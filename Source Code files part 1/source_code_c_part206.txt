	   on Vulcan adapter; when the complete ID sequence has been
;		   written, the ID sequence State Machine (IDS) enters the
;		   ID_CMD state.  This routine is called when IDS is in
;		   ID_WAIT state.
;
;   On Entry:
;		   dx = the ID port desired (1x0h)
;
;   On Exit:
;		   dx = preserved
;		   ax, cx are not preserved
;-----------------------------------------------------------------------------

Write_ID_Sequence  proc      near

		mov    al, 0
		out    dx, al			 ; to setup new ID port
		out    dx, al
		mov    cx, 0ffh			 ; 255-byte sequence
		mov    al, 0ffh			 ; initial value of sequence

wr_id_loop:
                out    dx, al
                shl    al, 1
                jnc    wr_id
                xor    al, 0cfh
wr_id:
	       loop   wr_id_loop
	
	       ret

Write_ID_Sequence  endp

;--------------------------------------------------------------------
;
;   Contention_Test: This routine, first, writes an "EEPROM Read Command" to
;		     ID port (dx), the write operation actually causes the
;		     content of the specified EEPROM data to be read into
;		     EEPROM data register.  Then it reads ID port 16 times
;		     and saves the results in ax.  During each read, the
;		     hardware drives bit 15 of EEPROM data register out onto
;		     bit 0 of the host data bus, reads this bit 0 back from
;		     host bus and if it does not match what is driven, then
;		     the IDS has a contention failure and returns to ID_WAIT
;		     state.  If the adapter does not experience contention
;		     failure, it will join the other contention tests when
;		     this routine is called again.
;
;		     Eventually, only one adapter is left in the ID_CMD state,
;		     so it can be activated.
;
;   On Entry:
;	      al = word of EEPROM data on which test will contend
;	      dx = ID port (to which ID sequence was written)
;	      cli
;
;   On Exit:
;	      ax = EEPROM data read back by hardware through contention test.
;	      dx = preserved
;	      bx = trashed
;	      cli
;
;--------------------------------------------------------------------

Contention_Test    proc      near

;;                assume ds:CGroup, es:CGroup
         
                add    al, READ_EEPROM			 ; select EEPROM data to
                out    dx, al				 ;  contend on

         	cli
         	; seems to solve some problem when Init is ran a few times
         	mov	cx, 3000h		; 5 ms
         	call	WaitTime
         	sti
         
                mov    cx, 16				 ; read 16 times
                xor    bx, bx				 ; reset the result

contention_read:
                shl    bx, 1
                in     al, dx				 ; reading ID port causes
         						 ;  contention test
         
                and    ax, 1				 ; each time, we read bit 0
                add    bx, ax
         
                loop   contention_read

                mov    ax, bx
                ret
         
Contention_Test    endp

;--------------------------------------------------------------------
; WaitTime - CX has 2*1.1932 the number of microseconds to wait.
;	If CX is small, add 1 to compensate for asynchronous nature
;	of clock.  For example, for 10us, call with CX = 25
;
;  On entry,
;	ints off (especially if CX is small, and accuracy needed)
;  On exit,
;	CX modified
;
; 911223 0.0 GK
;--------------------------------------------------------------------

WaitTime	proc	near

         	push	ax
         	push	bx
         	call	ReadTimer0		; get Timer0 value in AX
         	mov	bx, ax			; save in BX

ReadTimer0Loop:
         	call	ReadTimer0
         	push	bx
         	sub	bx, ax
         	cmp	bx, cx
         	pop	bx
         	jc	ReadTimer0Loop
         
         	pop	bx
		pop	ax
		ret

WaitTime	endp


ReadTimer0	proc	near

         	mov	al, 6
         	out	43h, al 		; port 43h, 8253 wrt timr mode 3
         	call	RT0
         
RT0:
         	jmp	short $+2
         	jmp	short $+2
         	jmp	short $+2
         	in	al, 40h 		; port 40h, 8253 timer 0 clock
		xchg	ah, al
		ret

ReadTimer0	endp

;------ GetBusType ----------------------------------------------------------;
;									     ;
;	Identify the type of system we are executing on.		     ;
;									     ;
;	Entry:								     ;
;	cli								     ;
;									     ;
;	Exit:								     ;
;	cli								     ;
;	AL = ISA, EISA or MCA (also saved in BusType)			     ;
;									     ;
;	Destroys AH, BX, CX, DX, SI, DI.  All other registers are     ;
;	preserved.							     ;
;									     ;
;----------------------------------------------------------------------------;

		public	GetBusType
GetBusType	proc	near

		push	es

; point ES at Real Mode F000:0000

		mov	ax, 0F000h
		mov	es, ax

; to determine if this is an EISA system or not we look for the string "EISA"
; in the ROM at F000:FFD9 thru FFDC.

		mov	di, 0FFD9h
		cmp	word ptr es:[di][0], 4945h	; "EI"?
		jne	gst_not_eisa
		cmp	word ptr es:[di][2], 4153h	; "SA"?
		jne	gst_not_eisa

		mov	al, BUS_EISA
		jmp	short gst_ret

; for the moment, if its not an EISA system, then its an ISA system

		public	gst_not_eisa
gst_not_eisa:

       	mov	ah, 0C0h
       	int	15h			; see if running on uC machine
         
       	; with Compaq DeskPro 486/33, the AL is wiped out if carry is cleared
       	mov	al, BUS_ISA
       	jc	NotMCA
         
       	test	byte ptr es:[bx+5], 00000010b ; check if micro-channel bit set
		stc
		jz	NotMCA			; not micro-channel machine

IsMChannel:
		mov	al, BUS_MCA		; BUS_MCA is defined by GY

NotMCA:

; save the bus type in AL in BusType

		public	gst_ret
gst_ret:
; temptemp		mov	BusType, al

; return with the system type in AL

		pop	es
		ret
GetBusType	endp

;------ CheckEISASlot -------------------------------------------------------;
;									     ;
;	This routine checks the EISA slot number specified for a Vulcan      ;
;	adapter and returns a yes/no indication.			     ;
;									     ;
;	Entry:								     ;
;	CL	= EISA slot number to check (0-15)			     ;
;									     ;
;	Exit:								     ;
;	carry	= set if Vulcan adapter found in that slot		     ;
;		= clear if not						     ;
;									     ;
;----------------------------------------------------------------------------;
		public	CheckEISASlot
CheckEISASlot	proc	near
		pusha

; under EISA all boards must respond at port xC80 and xC82 (where x is the
; slot number) with the manufacturer code and product id.  Compute xC80
; from the slot number in CL

		xor	dx, dx		    ; 0000
		mov	dh, cl		    ; 0x00
		shl	dx, 4		    ; x000
		add	dx, 0C80h	    ; xc80

; check for 3Com's manufacturer code

		in	ax, dx
		cmp	ax, EISA_MANUFACTURER_ID ; correct manufacturer?
		jne	ces_ret

; check for Vulcan's product id

		add	dx, PORT_ProductID - PORT_Manufacturer
		in	ax, dx
		and	ax, PRODUCT_ID_MASK	; mask off revision level
		cmp	ax, ISA_PRODUCT_ID	; correct product id?
		jne	ces_ret

ces_ret:
		popa
		ret
CheckEISASlot	endp



;----------------------------------------------------------------------
; Find529	Go to POS and find 3C529
;
; Assume	we are on MCA machine
;
; Exit		zf	set	3C529 found and adapter enabled
;			clear	3C529 not found or adapter not enabled
;		BX
;----------------------------------------------------------------------
Find529		proc	near

		; it's a 3C529 !!
		; search slot for Vulcan adapter
		mov	bl, 08			; start with slot 0
		cli				; ints off

AccessPOSLoop:
		mov	dx, 0096h
		mov	al, bl
		out	dx, al
		jmp	$+2
		mov	dx, 101h
		in	al, dx			; read MSB ID
		jmp	$+2
		xchg	al, ah
		dec	dx			; read LSB ID
		in	al, dx
		jmp	$+2
		cmp	ax, 0627Ch		; 3C529 ? 10 Base-2
		jz	Found529
       	
		cmp	ax, 0627Dh		; 3C529 ? 10 Base-T
		jz	Found529
       	
		cmp	ax, 062F7h		; 3C529 ? TP only
		jz	Found529
       	
		cmp	ax, 062F6h		; What is THIS ??????
		jz	Found529
       	
		cmp	ax, 061D8h		; Adapter in test mode. In test mode
		jz	Found529	      ; PROM should be disabled anyways.
       	
		inc	bl
		cmp	bl, 10h
		jb	AccessPOSLoop		 ; try next slot
		
		jmp	short Find529Bad
       	
Found529:
		; make sure adapter is enabled
		mov	dx, 102h		; POS[2]
		in	al, dx
		jmp	$+2
		test	al, 1			; is CDEN cleared ? (Card enabled )
		jnz	CardEnable
       	
Find529Bad:	sti
		or	bx, bx			; clear ZF. BX cannot be zero
		ret
       	
CardEnable:	sti
		xor	ax, ax			; set ZF
		ret
Find529		endp



Delay500ns	proc	 near

		push	ax
		push	bx
		push	dx
		mov	ax, DelayOneUsec.loword
		mov	dx, DelayOneUsec.hiword
		shr	ax, 1			; divide 1 Usec in half
		shr	dx, 1
		jnc	F2
		or	ax, 8000h		; move low order bit of dx into ax
F2:
		sub	ax, 1
		sbb	dx, 0
		mov	bx, ax
		or	bx, dx
		jnz	F2
		pop	dx
		pop	bx
		pop	ax
		ret

Delay500ns	endp




include		bw5x9.inc



_TEXT	ends




_DATA	segment	para public

; Data variables

NADDescription	label byte	     

LanOption   db  'LAN option: AMD PCnet - PCI II/PCnet - FAST Ethernet Adapter', CR, LF, 0

EthOption		db	' '
;EthOption		db	' Ethernet '
;EthProtString		db	'802.3 v'               ; Print correct protocol
VersionString		db	'v2.0 (971202)',0  ; Print correct version


;----------------- Device Driver Data Definitions --------------------
MaxPhysicalPacketSize  dw   1024		 ; max data request will handle

ErrConfSpace	db	09h,011h,' '
NothingString	db	0


NoNetMsg	db	'Ethernet card improperly installed or not connected.',0
TxMsg		db	'Transmit error', 0

		   ALIGN       4

NormalRxEarly	   dw	     ?		; set RxEarly cmd + threshold
CurTxStart	   dw	     CMD_SETTXSTART+TXSTART_DISABLED


; error messages - note BootWare prefaces them with a CR,LF
StrPrompt	db	01h,02h,'Initializing EtherLink III Adapter',0
StrEndless	db	'Reboot system for changes to take effect',0
StrWarnLevel	db	'Newer UNDI version is available for this adapter.',0
StrFailLevel	db	'New EtherLink III found. Need new UNDI version.',0
Str8022U	db	06h,08h,'BootWare/3C5X9 supports NetWare, RPL & TCP/IP boot protocols:',0
		db	09h,0ah,'To configure & save protocol/frame type, type <ENTER>',0
		db	0bh,0bh,'Default boot protocol is NetWare Ethernet_802.2',0
		db	03h,0fh,'This message will appear until boot protocol information is saved.',0
		db	0ffh
StrNull 	db	0


ISRErrFlag	db	FALSE		; flag indicating if error condition is
TxRetryCnt	dw	1		; Number of times to retry transmit
StoreDS     dw  0

padbytes    db  0

flag        dw  0

ModeBits	dw	0	; Contains System & Adapter Setting

Delayoneusec	dd	0




_DATA	ends


_BSS	segment

		db	'5N'
		
StartTick	dw	0		; save area for tick value
MaxTicks	dw	0		; save area for max ticks
CurTicks	dw	0		; save area for current ticks
DestID		db	6 dup (?)	; save area for destination node ID

RxPend		db	0		; b7 set if pending for Rx packet
					;  XXXXX NO XXX  else has rx status (0, 1)
TxEDPtr 	dd	?		; save area for transmit ED
RxEDPtr 	dd	?		; save area for receive ED
StatusMsgFlag	dw	0		; pointer to msg to be printed in DLCStatus

BWTFileName		db	65 dup(0)
IntVectorAddress	dw	     ?

OrgIntVector_OFF    dw  0
OrgIntVector_SEG    dw  0

;;OldInterrupt		dd	     0
IRQBit			db	     ?
AConfig_Old		dw	0	; old ACR before calling
					; ELNK3Conf
MemBase 		dw	0	; for TCP/IP Generic
OldEESoftConfigInfo	dw	0	; store old EESoftConfigInfo (Before
					; ELNK3CONF)
OldBWTLANOS		db	0	; store old BWTLANOS (before ELNK3CONF)

AConfig_Value		dw	?	; value of address config reg
RConfig_Value		dw	?	; value of resource config reg
EESoftConfigInfo	dw	?	; EEPROM word 0d
CWord			dw	?	; EEPROM word 0e
EECapabilities		dw	0	; EEPROM word 010h


;----------------------------------------------------------------------------
; variables to be initialized during init time
;----------------------------------------------------------------------------

		   ALIGN     4
		   even
eoi_value	   dw	?			 ; ah = master, al = slave
int_mask_port	   dw	?
HwFilter	   dw	?

IntMaskOnBit	   db	?
MsgCoord		dw	0

; DON'T SEPARATE THE FOLLOWING VARIABLES (FROM PortCmdStatus to PortRxFree)
; port variables for window 1
public		PortCmdStatus
		   even
PortCmdStatus	   dw	?			 ; offset 0e
PortTxFree	   dw	?			 ; offset 0c
PortTxStatus	   dw	?			 ; offset 0b
PortTimer	   dw	?			 ; offset 0a
PortRxStatus	   dw	?			 ; offset 08
PortRxFIFO	   dw	?			 ; offset 00
PortTxFIFO	   dw	?			 ; offset 00

; port variables for window 3

PortRxFree	   dw	?			 ; offset 0a

; port variables for window 4

PortFIFODiag       dw        ?                   ; offset 04

CliBufferSize		equ	128
		   ALIGN     4
CliBuffer	   db	     CliBufferSize dup (?) ; ** not needed, may be removed
						; along with other code in init
						; that computes copycli

NIDGroupAddr	db	6 dup(0)	; GroupAddr



_BSS	ends


	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c5x9\pci.inc ===
VENDOR_ID	equ 1022h	     ;4 ; Vendor Identification

DEVICE_ID	equ 2000h 	     ;6 ; Device Identification (AT2450)

DEVICE_ID1   equ     0AE34h     ; 32


;PCI BIOS call constants definition
;----------------------------------
PCI_BIOS_INT             equ     1Ah
PCI_FUNCTION_ID          equ    0B1h
PCI_BIOS_PRESENT         equ     01h
FIND_PCI_DEVICE          equ     02h
FIND_PCI_CLASS_CODE      equ     03h
GENERATE_SPECIAL_CYCLE   equ     06h
READ_CONFIG_BYTE         equ     08h
READ_CONFIG_WORD         equ     09h
READ_CONFIG_DWORD        equ     0Ah
WRITE_CONFIG_BYTE        equ     0Bh
WRITE_CONFIG_WORD        equ     0Ch
WRITE_CONFIG_DWORD       equ     0Dh

;PCI BIOS returned values constants definition
;---------------------------------------------
PCI_SUCCESSFUL           equ     00h
PCI_FUNC_NOT_SUPPORTED   equ     81h
PCI_BAD_VENDOR_ID        equ     83h
PCI_DEVICE_NOT_FOUND     equ     86h
PCI_BAD_REGISTER_NUMBER  equ     87h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c5x9\bw5x9.inc ===
; Routines in BW5X9.INC
;  : shared by 3C5X9, 3C59X-PCI and 3C59X-EISA
;
; Modules included:
;  - NADTransmitPacket
;  - DoRxDiscard
;  - SoftRxReset
;  - NADPoll
;  - NADDisengage
;  - Interrupt Service Routines
;  - TxReset
;  - RxReset
;  - RxDiscard
;
; 960618 GY    - Add support for Broadcast
; 960401 GY - Replace some MACROS with code
;        - standardize port access
;******************************************************************************



;------------------------------------------------------------------------------
; StartTime - save maxtick count, get current tick value
;	Timeout is ticks, each tick is 55 ms.
;	Note: this routine can only be called once the PC timer
;	and its interrupt are setup (INT19 and beyond are OK)
;
; On entry,
;	AX = max ticks to wait
;	ints enabled
;
; On exit,
;	all preserved
;
; 881030 1.0 GK
;------------------------------------------------------------------------------

StartTime	proc	near

		push	ax
		push	cx
		push	dx
        push    di  
        push    es

		mov	DGroup:MaxTicks, ax
;;		mov	ah, 0
;;db  0f1h
;;		int	1Ah				; get current tick value
        mov     ax, 40h
        mov     es, ax
        mov     di, 6Ch
        mov     dx, es:[di]
        mov     cx, es:[di+2]
		mov	DGroup:StartTick, dx		; save it

        pop es
        pop di
		pop	dx
		pop	cx
		pop	ax
		ret

StartTime	endp

;------------------------------------------------------------------------------
; CheckTime - gets current tick value, compares with maxticks
;	Timeout is ticks, each tick is 55 ms.
;	Note: this routine can only be called once the PC timer
;	and its interrupt are setup (INT19 and beyond are OK)
;
; On entry,
;	maxticks set by StartTime
;	ints enabled
;
; On exit,
;	CY set if timeout
;	all registers preserved
;
; 881030 1.0 GK
;------------------------------------------------------------------------------

CheckTime	proc	near

		push	ax
		push	cx
		push	dx
        push    di  
        push    es

;;		mov	ah, 0
;;		int	1Ah			; get current tick

        mov     ax, 40h
        mov     es, ax
        mov     di, 6Ch
        mov     dx, es:[di]
        mov     cx, es:[di+2]

		sub	dx, DGroup:StartTick
		cmp	dx, DGroup:MaxTicks
		cmc

        pop es
        pop di
		pop	dx
		pop	cx
		pop	ax

		ret				; return with CY set if timeout

CheckTime	endp



;----------------------------------------------------------------------
;  Routine Name:  NADTransmitPacket Routine
;
;  Description: The NADTransmitPacket Routine accepts all directed
;     send requests from the RIPL ROM NID code.  This
;     routine determines the validity of the request and
;     works with the adapter to carry it out.
;
;  Input:   ES:SI - pointer to ED
;     DS - Data Segment of RPL Module
;     ints disabled (spec says enabled)
;
;  Output:  ED Completion Code field updated
;     DS preserved
;     ints enabled (doesn't matter)
;
;  Calls:   TransmitPacket
;----------------------------------------------------------------------
public   NADTransmitPacket ; for DEBUGGING
NADTransmitPacket  PROC near

	push	ds			; save caller ds


;	mov	word ptr TxEDPtr, si	; save ED pointer
;	mov	word ptr TxEDPtr+2, es

;	assume   ds:CGroup

	cld				; Clear direction

	; calc number of bytes needed to pad to dword size
	mov	cx, es:[si].ED_Length	; get total packet length
	mov	bx, cx
	neg	cl
	and	cl, 3
	mov	DGroup:PadBytes, cl

	cli				; ints off

;;int 03

	mov	dx, DGroup:PortCmdStatus
	mov	ax, 801h
	out	dx, ax

	mov	dx, DGroup:PortTxFree
	in	ax, dx
	cmp	ax, bx
	jae	ww

    mov es:[si].ED_ErrCode, TRANSMIT_ERROR
    jmp NetSendRet
; write preamble & MAC header to Tx FIFO

ww:
	mov	dx, DGroup:PortCmdStatus
	mov	ax, 804h
	out	dx, ax
	mov	dx, DGroup:IOBASE	
	add	dx, 6
	in	ax, dx
	test	ax, 300h
	jz	ww1

;;int 03

ww1:
	sub	dx, 2
	in	ax, dx
	test	ax, 400h
	jz	ww2

ww2:

	mov	dx, DGroup:PortCmdStatus
	mov	ax, 801h
	out	dx, ax

	mov	dx, DGroup:PortTxFIFO

	mov	ax, es:[si].ED_Length	; get total packet length
	inc	ax

	and	al, 0feh		; len field in preamble evenized
	or	ah, high TXP_INTONSUCCESS ; generate TxStatus on all completions

	; write preamble
	out	dx, ax			; preamble
	xor	ax, ax
	out	dx, ax			; unused word

;	assume   ds:CGroup

	push	si			; save ED offset

;	lds	bx, cs:TxEDPtr
	mov	cx, es:[si].ED_FragCount; get fragment count
	lea	bx, [si].ED_FragOff	; point to first fragment descriptor

    push    ds

Tx_Frag_Loop:
	push	cx			; save fragment count
;	push	ds			; save fragment descriptor list segment
	mov	cx, es:[bx].FragLen	; length of this fragment

; !!!!!!!!!! Dmitry !!!!!!!!!!!!!
	lds	si, es:[bx].DPointer	; location of this fragment
	rep	outsb			; output bytes to adapter

Tx_Frag_End:
;	pop	ds			; restore frag descriptor list segment
	pop	cx			; restore fragment count
	add	bx, size Frag		; next descriptor
	loop	Tx_Frag_Loop		; loop through all fragments



Start_Tx:
	pop	ds			; restore ds
;	assume ds:CGroup


	mov	cl, DGroup:PadBytes
	rep	outsb			; pad packet to dword

	pop	si			; restore ED offset

	mov	DGroup:RxPend, TRUE		; indicate ready for a receive

	; wait for completion, and check for errors
	sti				; ints on again
	mov	ax, 5 ; 20 ; 5
	call	StartTime
;;	mov	ah, 0			; get current system tick count
;;	int	1Ah			; timer services
;;	mov	DGroup:StartTick, dx		; save timer value

WaitForEndTx:
;;;	mov   dx, DGroup:PortTxSTatus
;;;	in al, dx
;;;	in al, dx	
;;;	test  al, TXS_COMPLETE  ; done yet?
       cmp DGroup:flag, 1
       je    TxFinish  
;;;	jnz   TxFinish       ; jump if Tx complete

	call	CheckTime
	jnc	    WaitForEndTx	; check status again if not timeout
;;	mov   ah, 0       ; get current system tick count
;;	int   1Ah         ; timer services
;;	sub   dx, DGroup:StartTick     ; subtract start time
;;	cmp   dx, 5       ; 5 ticks time-out
;;	jb   WaitForEndTx      ; loop until time-out

BadConnection:
        mov   DGroup:flag, 0  
;;int 03
	mov   dx, DGroup:PortTxSTatus
	in al, dx
	mov   DGroup:RxPend, 0      ; clear Rx flag
	mov   dx, DGroup:PortCmdStatus
	call  TxReset     ; make sure FIFO is flushed

		; enable the transmitter
	mov     ah, CMDH_TXENABLE
	out     dx, ax

	mov   bx, offset DGroup:NoNetMsg

;		mov   cs:[StatusMsgFlag],bx   ; only for RPL

;	les   si, TxEDPtr

;    db 0F1h
	; set ErrStruct to print msg
;;	mov   es:[si].ED_ErrMsg, bx   ; should be ES:

	; Set return code to transmit error
	mov   es:[si].ED_ErrCode, TRANSMIT_ERROR

    stc
	jmp   short NetSendRet

; copy done, return

TxFinish:
	mov	dx, DGroup:PortCmdStatus
	mov	ax, 801h
	out	dx, ax
	mov   dx, DGroup:PortTxSTatus
	in al, dx
    mov   DGroup:flag, 0  
;;	out   dx, al         ; pop Tx status
	test  al, TXS_ERRTYPE   ; any error bits set?
	jnz   NetSendError

;	les   si, TxEDPtr

	; Set return code to successful
	mov   es:[si].ED_ErrCode, SUCCESSFUL
    clc

NetSendRet:
	pop	ds			; restore callers ds
	ret

NetSendError:
;		mov   cs:[StatusMsgFlag], offset CGroup:TxMsg ; only for RPL

;    db 0F1h
	push  ax
;	les   si, TxEDPtr

	; set ErrStruct to print msg
	mov   es:[si].ED_ErrMsg, offset DGroup:TxMsg

	; Set return code to transmit error
	mov   es:[si].ED_ErrCode, TRANSMIT_ERROR
	pop   ax

	mov   DGroup:RxPend, 0      ; clear Rx flag
	test  al, TXS_UNDERRUN or TXS_JABBERERROR
	jz NotTxUnderOrJabber

;;int 03
	call  TxReset     ; reset transmitter
	; enable the transmitter
	mov     ah, CMDH_TXENABLE
	out     dx, ax

    stc
	jmp   short NetSendRet

NotTxUnderOrJabber:
	; enable the transmitter
	mov     ah, CMDH_TXENABLE
	out     dx, ax

    stc
	jmp   short NetSendRet

NADTransmitPacket  ENDP



;------------------------------------------------------------------------------
; packet completed, but RxStatus.Err indicates the packet experienced an error
; during receiving.


ip_bad:
;        db 0F1h
		mov   dx, DGroup:PortCmdStatus
		call  RxDiscard      ; preserve all regs, except ah
		jmp    int_next      ; go directly to int_next without
          					 ; updating errcounts (BootWare doesnt
		    				 ;   keep count)

;------------------------------------------------------------------------------
; various errors: No ECB, pkt too small, pkt too big, pkt with bad size

ip_bad_llc:
not_eii_pkt:
ip_discard_pkt:
;    db 0F1h
;;int 03
	mov   dx, DGroup:PortCmdStatus
	call  RxDiscard 
	jmp   int_next    ; dx = port CmdStatus


;--------------------------------------------------------------------
;
;  Rx Complete interrupt.  PIO only.
;
;--------------------------------------------------------------------
; entry:
;   interrupt is disabled at adapter level. (through SetIntMask cmd).
;   EOIs have been issued to PICs.
;   we've not done sti
;
;   dx = port CmdStatus
;   ds = cs (CGroup)
;   cli
;   cld
;
;--------------------------------------------------------------------


			 public isr_RxPIO

isr_RxPIO:


    	mov	    dx, DGroup:PortCmdStatus
    	mov	    ax, 801h
    	out	    dx, ax

		mov     dx, DGroup:PortRxStatus

		in      ax, dx         ; ax = RxStatus
		test    ah, RXSH_ERROR    ; error reported?
		jnz     ip_bad


	; get Packet Length from RxStatus register (win 1,port8)
	mov	dx, PortRxStatus
	in	ax, dx			; ax = RxStatus
	and	ax, 07ffh		; keep only last 11 bits

   	call	GetED
	jz	ip_discard_pkt		; we didn't get an ED

	mov	bx, si			; move ED offset to bx

	mov	es:[si].ED_Length, ax	; save length in ED

	mov	cx, es:[si].ED_FragCount; get number of fragments

	lea	bx, [si].ED_FragOff	; point to 1st descriptor

	mov	dx, ax			; move packet size to dx

DRxNxtF:
	push	cx
	push	es
	mov	cx, es:[bx].Dlen	; get fragment length
;;	les	di, es:[bx].Dpointer	; get fragment pointer
	mov	ax, ds
	mov	es, ax
	mov	di, word ptr es:[bx].Dpointer	; get fragment pointer

ChkMovSize:
	cmp	dx, cx
	ja	MoveFrag		; more data after this frag

	mov	cx, dx			; no more data after this frag

MoveFrag:
	sub	dx, cx			; subtract size of this frag
	jcxz	DrxDoNxt 		; zero count -- skip data read

	push	dx
	mov	dx, PortRxFIFO
	rep	insb
	pop	dx

DrxDoNxt:
	pop   es
	pop   cx
	add   bx, 6    ; point to next fragment desc
	loop  DRxNxtF  ; do next frag, if any

; -- DX has # of bytes that couldn't fit in receive descriptors

NoRxFrag:

    	mov	es:[si].ED_ErrCode, 0	; Set good completion


;;IFDEF	UNDI
		lea	bx, es:[si].ED_FragOff	; point to 1st descriptor
		mov	ax, ds
		mov	es, ax
		mov	di, word ptr es:[bx].Dpointer	; get fragment pointer

		cmp	byte ptr es:[di], 01h
		jnz	NoMCastCheck		; not a MC address
;;db  0f1h
		mov	si, offset DGroup:MultiCast_Addresses
		mov	cx, (Eth_MCastBuf ptr [si]).MCastAddrCount
		jcxz	NoMCastCheck		; no MC address

		lea	si, (Eth_MCastBuf ptr [si]).MCastAddr
CheckMC:
		push	cx
		mov	cx, 6		;length of address in byte
    	repz	cmpsb
		jcxz	MCastFound	;this is our MC address

		add	si, 6
		pop	cx
		loop	CheckMC
;
; not our MC address, kill the recently saved ED
;
		mov	si, DGroup:[EDListCurrent]	; get current ED
		mov	word ptr [si].ED_Length, 0	;kill the data
		mov	DGroup:[EDListHead], si	; move the head backward
		jmp	DiscardRxData

MCastFound:
		pop	cx
NOMCastCheck:


;;	call	[AIPostEDJmp]		; post the received packet

; we've copied all packet data out of RxFIFO, now discard postamble and any
; pad bytes inserted by hardware.

DiscardRxData:
	mov   dx, DGroup:PortCmdStatus
	call  RxDiscard         ; discard padding & postamble

; copy is done, now tell foreground that a packet is available

	jmp    int_next


;--------------------------------------------------------------------
;
; TxReset - reset the transmitter
;
; entry:
;   dx = cmd/status port
;
; destroys:
;   ax
;
;--------------------------------------------------------------------
TxReset     proc  near
  
;int 03

    	mov   ax, CMD_TXRESET + TXRXRESET_ALLBUTBM
		out   dx, ax

?txrloop:   in      ax, dx
		test  ah, STH_BUSY
		jnz   ?txrloop                    ;; loop while busy

			ret
TxReset     endp

;--------------------------------------------------------------------
;
; RxReset - reset the receiver
;
; entry:
;   dx = cmd/status port
;
; destroys:
;   ax
;
;--------------------------------------------------------------------
RxReset     proc  near
		mov   ax, CMD_RXRESET
		out     dx, ax

?rxrloop:   in      ax, dx
		test    ah, STH_BUSY
		jnz     ?rxrloop                    ;; loop while busy
		ret
RxReset     endp

;--------------------------------------------------------------------
;
; RxDiscard - discard top packet in RxFIFO
;
; entry:
;   ds = DGROUP
;   dx = cmd/status port
;   cli
;
; exit:
;   cli
;
; destroys:
;   ax
;
;--------------------------------------------------------------------
RxDiscard   proc  near

		mov   ax, CMD_RXDISCARD
		out     dx, ax
?rxdloop:   in ax, dx
		test  ah, STH_BUSY
		jnz   ?rxdloop                    ;; loop while busy

		ret
RxDiscard   endp


;------ DoRxDiscard -------------------------------------------------
;
;  This routine performs an RxDiscard, including the workarounds
;  required by the Rev 1 versions of the ASIC.  It has been made a
;  procedure because the workarounds were getting too ungainly.
;
;  Entry:
;  DS = DGROUP
;  DX = port CmdStatus
;  cli
;
;  Exit:
;  cli
;  Destroys AX.  All other registers preserved.
;--------------------------------------------------------------------

		public   DoRxDiscard

DoRxDiscard proc  near

	mov   dx, DGroup:PortCmdStatus

; issue the RxDiscard and wait for it to complete

	mov   ah, CMDH_RXDISCARD
	out   dx, ax         ; discard the packet

discard_busy:
	in    ax, dx
	test  ah, STH_BUSY
	jnz   discard_busy       ; loop while busy

; check RxStatus.  if complete, everything is fine--just return.

	mov   dx, DGroup:PortRxStatus
	in ax, dx

	mov   dx, DGroup:PortCmdStatus

	ret

DoRxDiscard endp

;------ SoftRxReset -------------------------------------------------
;
;  This routine does an RxReset to clear out the RxFIFO and its
;  associated logic.  After the RxReset, it reenables and restores
;  the current RxFilter and RxEarly thresholds.
;
;  Entry:
;  DS = DGROUP
;  DX = port CmdStatus
;  cli
;
;  Exit:
;  cli
;  Destroys AX.  All other registers preserved.
;
;--------------------------------------------------------------------

		 public SoftRxReset
SoftRxReset   proc   near

	call  RxReset

	mov   dx, DGroup:PortCmdStatus
	mov   ax, DGroup:HWFilter      ; has CMD_SETFILTER in it
;db  0f1h
	out   dx, ax

		; enable the receiver
		mov     ah, CMDH_RXENABLE
		out     dx, ax


	mov   ax, DGroup:NormalRxEarly ; has CMD_SETRXEARLY in it
	out   dx, ax

	ret
SoftRxReset endp



;----------------------------------------------------------------------
;  Routine Name:  NADDisengage Routine

;  Description: The NADDisengage routine is used by the RIPL ROM NID
;     portion of the RIPL ROM to signal the Network Driver
;     to release its IRQ, DMA, and memory resources.
;
;  Input:   DS - Data Segment of RPL Module
;     ints enabled
;
;  Output:  DS preserved
;     ints enabled
;     ax = offset to error string or 0 if successful
;
;  Calls:   none
;
; July 10,91   implement NIDDisengage version 0.8
;----------------------------------------------------------------------
NADDisengage   PROC  FAR
	push  ds
	push  es

	cli



		; 3Com 5X9 NDIS driver place ISR at IRQ 2 rather than IRQ 9 ( compatibility
		; with IBM 3270 program ). Thus, this routine needs to restore the old
		; BIOS IRQ9 handler to invoke IRQ2. Also, this routine should NOT
		; mask IRQ9.

		mov    dx, DGroup:Int_mask_port
		in     al, dx
	
		or     al, DGroup:IRQBit
		jmp    $+2

		out    dx, al

		; restore handler
		call  DriverUnhook

		; unmask IRQ 9 again so that interrupt will pass to IRQ2 ISR
		cmp   DGroup:IRQNumber, 9
		jnz   DisengageExit

		mov   dx, 0a1h
		in al, dx
		and   al, 0fdh
		out   dx, al

DisengageExit:
		pop   es
		pop   ds

		sti
		xor   ax, ax

;;        int 03

        clc
		retf        ; Return to caller

NADDisengage   endp


;------------------------------------------------------------------
;
; DriverISR:  Interrupt Service Routine for Vulcan
;
;------------------------------------------------------------------

;;		 public DriverISR
		 public isr_1st_pass
		 public int_next
		 public isr_return
		 public isr_again
		 public isr_enable

		 ALIGN  4
		 db     'ISR'

BootISR     proc   far
;;db  0f1h
		 pusha
		 push   ds
		 push   es


	cld
	mov   dx, DGroup:PortCmdStatus


; make sure the adapter is in window 1, which is where it should always
; be post-init with interrupt enabled

; mask off all interrupts at adapter level. and release the system interrupt


		 mov    ax, CMD_SETINTMASK + MASK_ALL
		 out    dx, ax           ; disable all interrupts

		; acknowledge interrupt
		mov    ax, CMD_ACKNOWLEDGE + INT_LATCH
		out    dx, ax

		mov    ax, DGroup:eoi_value          ; ah = EOI for master PIC
						 ; if int < 8, eoi_value = 6040h
						 ;   else eoi_value = 6220h

		 cmp    al, 40h             ; Int level < 8 ? (i.e. NOP)
		 jz   EOIMaster         ; No, need EOI to Slave PIC

		 out    SlaveEOIPort, al          ; al = EOI for slave PIC

	jmp   $+2
	jmp   $+2
	jmp   $+2
	jmp   $+2
	jmp   $+2
	jmp   $+2


EOIMaster:
		 mov    al, ah           ; send EOI to Master 8259 PIC
		 out    MasterEOIPort, al

;----------------------------------------------------------------------------
; read the reason for the interrupt and dispatch control to the appropriate
; routine through jump table.  When that reason has been handled the routine
; will jump  to int_next.  if there is no reason for the interrupt
; we will simply end up at isr_return. the following types of interrupt
; are handled:
;
;      a. Adapter Failure
;      b. Rx Complete
;      c. Interrupt Request (not supported, ack and return)

		 public isr_1st_pass

isr_1st_pass:
	mov   dx, DGroup:PortCmdStatus

		 in     ax, dx           ; 05-21-92
		 jmp    IntDispatch

; there is another interrupt reason.  since we might be close to our disable
; time limit, enable before we handle it.

isr_again:           ; AL has CmdStatus contents
;int 03
		 sti
		 nop
		 cli
		 jmp    IntDispatch

; once the code entered through IntDispatch has completed its task, it jumps
; to this label. check for any remaining reasons.

		 public int_next

int_next:

	mov   dx, DGroup:PortCmdStatus

		 in     ax, dx       ; read status reg see if any
		 test   al, al       ; more interrupts to be
		 jnz    isr_again       ; serviced?

;-----------------------------------------------------------------------------
; nothing left showing in status.


isr_return:

;----------------------------------------------------------------------------
; reenable interrupts from the adapter.
;
; note: if indications are disabled, they are masked off through the
; ReadZeroMask so reenabling interrupts will have no effect on those bits.

isr_enable:
;;db  0f1h
		cli

		mov   dx, DGroup:PortCmdStatus
		mov   ax, CMD_SETINTMASK + BOOTWARE_INTS
		out   dx, ax

;950214       port   cs:CmdStatus          ; 03-24-92
		pop   es
		pop   ds
		popa

		iret

BootISR   endp

; 3Com's driver used a 128-word jmp table - faster, but too much room for us...

IntDispatch:            ; prioritized dispatch (err, Rx, Tx)
	test  al, INT_ADAPTERFAIL
	jz IntNotFail

;    db 0F1h
	jmp   isr_AdapterFailure

IntNotFail:
	test  al, INT_RXCOMPLETE
	jz IntNotRxComplete

;;db  0f1h
	jmp   isr_RxPIO

IntNotRxComplete:
;int 03
;    db 0F1h
	test  al, INT_TXCOMPLETE   ; shouldn't happen, only if cable
					; not connected
	jz IntNotTxComplete

	mov	dx, DGroup:PortCmdStatus
	mov	ax, 801h
	out	dx, ax

;;int 03
	mov   dx, DGroup:PortTxStatus
    in    al, dx
    cmp   al, 0C0h
    jne    xx
    mov DGroup:flag, 1
xx:
	out   dx, al         ; pop tx status to turn the bit off
	mov   dx, DGroup:PortCmdStatus
	mov    ax, CMD_ACKNOWLEDGE + 4
	out	dx,	ax
	jmp   int_next

IntNotTxComplete:
;;int 03
	test  al, INT_REQUESTED
	jnz   isr_return

isr_IntRequest:
		; acknowledge interrupt
		mov    ax, CMD_ACKNOWLEDGE + INT_REQUESTED
		out     dx, ax

		jmp   isr_return     ; Solve mysterious problem with V2

;--------------------------------------------------------------------
;
;  Adapter Failure interrupt.
;
;--------------------------------------------------------------------
; entry:
;   interrupt is disabled at adapter level. (through SetIntMask cmd).
;   EOIs have been issued to PICs.
;   we've not done sti
;
;   dx = port CmdStatus
;   ds = cs (CGroup)
;   cli
;   cld
;
; description:
;
;   Three possible reasons that force adapter to generate Adapter
;   Failure Interrupt are:
;
;        1. Rx DMA Trouble (DMA is enabled on a non-dword boundary)
;        2. Rx Underrun
;        3. Tx Overrun
;
;   Diagnostics Register offset 4, window 4 contains information of
;   what causes this interrupt.  Since this interrupt will hardly
;   be generated if software and hardware work properly, we should
;   not see it happen.
;
;   For the moment the only conditins we attempt any workaround for is
;   RxUnderrun and TxOverrun.  For RxUnderrun, we simply reset the
;   receiver by calling SoftRxReset.  For TxOverrun, we simply reset
;   the transmitter and start things going again.
;
;   Other than that, we do not attempt any workarounds to get the board
;   up and running again.  We simply die a graceful death in as little
;   code space as possible.
;
;--------------------------------------------------------------------

		 public isr_AdapterFailure

isr_AdapterFailure:

;;int 03

		SelectWindow WNO_DIAGNOSTICS        ; switch to window 4

		mov   dx, DGroup:PortFIFODiag
		in     ax, dx

		mov   dx, PortCmdStatus

		test   ax, FIFOD_RXUNDERRUN
		jz     chk_tx_overrun

; RxUnderrun.  ASIC (rev 1) adapter failure int. due to a false RxUnderrun.
; we just call SoftRxReset to reset the receiver and return to int_next as
; a software workaround to a hardware problem.

		 public AdapterFailure_Rxunderrun

AdapterFailure_Rxunderrun:
		SelectWindow WNO_OPERATING

		mov   dx, DGroup:PortCmdStatus
		call   SoftRxReset
		jmp    int_next

chk_tx_overrun:
		test   ax, FIFOD_TXOVERRUN
		jz     ia_shutdown

; TxOverrun.  Probably a software error, but since its probably on the back end
; of the TxFIFO and the error shuts down the transmitter, we won't have sent
; any bad packets yet (with rev 1 silicon).  Reset the transmitter and start
; things up again.

		public AdapterFailure_TxOverrun

AdapterFailure_TxOverrun:
		call  TxReset

		mov    ax, DGroup:CurTxStart
		out    dx, ax

		; enable the transmitter
		mov     ah, CMDH_TXENABLE
		out     dx, ax


		SelectWindow WNO_OPERATING

; shut off the transmitter and receiver
		public ia_shutdown

ia_shutdown:
		mov   dx, DGroup:PortCmdStatus
		SelectWindow WNO_OPERATING

		; Tx Disable
		mov     ah, CMDH_TXDISABLE
		out     dx, ax

				; Disable the receiver
		mov     ah, CMDH_RXDISABLE
		out     dx, ax

; disable additional interrupts from the adapter

		mov    ax, CMD_SETRZMASK + MASK_ALL
		out    dx, ax
		jmp    int_next
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c5x9\sstrucs.inc ===
;
; Modifications:   $Header:   J:/archives/preboot/lsa2/inc/SSTRUCS.INV   1.4   19 Sep 1997 21:39:20   MJOHNSOX  $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;

;
;   Description      :    NDIS structures and bit definitions for fields
;                         within those structures, name of driver, etc.
;                         THIS FILE HAS BEEN MODIFIED FROM NDIS NDK VERSION.
;

;
; File: sStrucs.inc    - Support Structures include NDIS specific.
;
;

;-----------------------------------------------------------------------------
;
;    The following equates are the primary configuration for the driver.
;
; * maximum number of multicast addresses.
;
NUM_MCADDRS        Equ       8
;
; * Maximum number of data blocks supported in a descriptor.
;
MAX_DATABLK        Equ    8
;

;-----------------------------------------------------------------------------
;
;    The following equates and structures should only be changed when
;    upgrading to a newer NDIS specification.
;

; * define the length of names and addresses in the Common Characteristics
; * and Specific Characteristics table.
;
NAME_LEN    Equ    16
ADDR_LEN    Equ    16
ADDR_SIZE   Equ    6

;
MIN_LOOKAHEAD_DEFAULT        Equ       MIN_PACKET+4
MAX_LOOKAHEAD                Equ       256

DELAY_COPY					 Equ	   -1
SUCCESS                      Equ       0000H
WAIT_FOR_RELEASE             Equ       0001H
REQUEST_QUEUED               Equ       0002H
FRAME_NOT_RECOGNIZED         Equ       0003H
FRAME_REJECTED               Equ       0004H
FORWARD_FRAME                Equ       0005H
OUT_OF_RESOURCE              Equ       0006H
INVALID_PARAMETER            Equ       0007H
INVALID_FUNCTION             Equ       0008H
NOT_SUPPORTED                Equ       0009H
HARDWARE_ERROR               Equ       000AH
TRANSMIT_ERROR               Equ       000BH
NO_SUCH_DESTINATION          Equ       000CH
ALREADY_STARTED              Equ       0020H
INCOMPLETE_BINDING           Equ       0021H
DRIVER_NOT_INITIALIZED       Equ       0022H
HARDWARE_NOT_FOUND           Equ       0023H
HARDWARE_FAILURE             Equ       0024H
CONFIGURATION_FAILURE        Equ       0025H
INTERRUPT_CONFLICT           Equ       0026H
INCOMPATIBLE_MAC             Equ       0027H
INITIALIZATION_FAILED        Equ       0028H
GENERAL_FAILURE              Equ       00FFH

; 
; * Packet filter bit definitions.
; 
FLTR_DIRECTED                Equ       01H
FLTR_MLTCST                  Equ       01H
FLTR_BRDCST                  Equ       02H
FLTR_PRMSCS                  Equ       04H
FLTR_SRC_RTG                 Equ       08H

; 
; * MAC status bits in the MAC Specific Characteristics table.
; * Bits 0-2 are coded to reflect the hardware status.
; 
HW_MISSING                   Equ       0000H
HW_BUD_ERR                   Equ       0001H
HW_CFG_ERR                   Equ       0002H
HW_FAULT                     Equ       0003H
HW_SOFT_ERR                  Equ       0004H
HW_OK                        Equ       0007H
MS_HW_MASK                   Equ       HW_OK

MS_BOUND                     Equ       0008H
MS_OPEN                      Equ       0010H
MS_DIAGS_ON                  Equ       0020H

;
;    Definintions for the MAC Service Supported Flags.
;    Bits 0-15.
;
BroadcastSupport             Equ       TRUE
MulticastSupport             Equ       TRUE
FunctionalGroupSupport       Equ       FALSE
PromiscuousSupport           Equ       TRUE
SetStationAddrSupport        Equ       TRUE
StatusAlwaysCurrent          Equ       FALSE
DiagnosticsSupport           Equ       FALSE
LoopBackSupport              Equ       FALSE
ReceiveChainPrimary          Equ       FALSE
IBMSourceRouting             Equ       FALSE
ResetMACSupport              Equ       TRUE
OpenAdapterSupport           Equ       TRUE
InterruptRequestSupp         Equ       TRUE
SourceRoutingBridge          Equ       FALSE
GDTAddressesSupported        Equ       TRUE
MultipleXferDatas            Equ       TRUE      ; Also set MaxXferDatas
RcvLkFrameSizeZero           Equ       FALSE

;
; * Definintions for the MAC Service Supported Flags.
; * Bits 0-14.
;
ServiceFlags    =  00000000H
ServiceFlags    =  ServiceFlags Or BroadcastSupport
ServiceFlags    =  ServiceFlags Or (MulticastSupport Shl 1)
ServiceFlags    =  ServiceFlags Or (FunctionalGroupSupport Shl 2)
ServiceFlags    =  ServiceFlags Or (PromiscuousSupport Shl 3)
ServiceFlags    =  ServiceFlags Or (SetStationAddrSupport Shl 4)
ServiceFlags    =  ServiceFlags Or (StatusAlwaysCurrent Shl 5)
ServiceFlags    =  ServiceFlags Or (DiagnosticsSupport Shl 6)
ServiceFlags    =  ServiceFlags Or (LoopBackSupport Shl 7)
ServiceFlags    =  ServiceFlags Or (ReceiveChainPrimary Shl 8)
ServiceFlags    =  ServiceFlags Or (IBMSourceRouting Shl 9)
ServiceFlags    =  ServiceFlags Or (ResetMACSupport Shl 10)
ServiceFlags    =  ServiceFlags Or (OpenAdapterSupport Shl 11)
ServiceFlags    =  ServiceFlags Or (InterruptRequestSupp Shl 12)
ServiceFlags    =  ServiceFlags Or (SourceRoutingBridge Shl 13)
ServiceFlags    =  ServiceFlags Or (GDTAddressesSupported Shl 14)
ServiceFlags    =  ServiceFlags Or (MultipleXferDatas Shl 15)
ServiceFlags    =  ServiceFlags Or (RcvLkFrameSizeZero Shl 16)

MAC_Type    Equ    <'DIX+802.3'>       ; Specific Characteristic Type.
;
; Protocol Manager opcodes used by the generic model
;
GetPMInfo                    Equ       1
RegisterModule               Equ       2
BindAndStart                 Equ       3
GetPMLinkage                 Equ       4

Ifdef AVL
;-----------------------------------------------------------------------------
; 
; * multicast address structure is ADDR_LEN bytes long
; 
MCastAddr   Struc
mAddr       DB     ADDR_LEN dup(0)
MCastAddr   Ends

; 
; * the multicast address buffer manages NUM_MCADDRS multicast address
; * structures.
; 
MCastBuf    Struc
McbMax      DW     ?    ;  max # of multicast addresses
McbCnt      DW     ?    ;  curr# "        "

McbAddrs    DB     size MCastAddr*NUM_MCADDRS dup(0)
MCastBuf    Ends
Endif	;; AVL 

;-----------------------------------------------------------------------------
;
;    Structures defined by the NDIS specification and used by the generic
;    model.
;
;-----------------------------------------------------------------------------
; * immediate data buffer length cannot exceed 64 bytes.
; 
MAX_IMMED_LEN      Equ       64
; 
; * Maximum number of data blocks supported in a Tx descriptor.
; 
MAX_TX_DATABLK     Equ       MAX_DATABLK
; 
; * Max number of TransferData blocks
; 
MAX_TD_DATABLK     Equ       MAX_DATABLK
; 
; * MAx number of ReceiveChain data blocks
; 
MAX_RX_DATABLK     Equ       MAX_DATABLK

; 
; * Data structures for TransmitChain (Tx), TransferData (TD), and
; * ReceiveChain (Rx).
; 
TxDataBlock Struc
TxPtrType   DB     ?        ; 0 => Phys pointer, 1 => GDT pointer
TxRsvdByte  DB     ?        ; Reservered, must be zero.
TxDataLen   DW     ?        ; Data block length in bytes.
TxDataPtr   DD     ?        ; Far pointer to data block.
TxDataBlock Ends

; 
; * TransmitChain descriptor structure definition
; 
TxBufDesc   Struc
TxImmedLen  DW     ?        ; Byte count of immediate data, max=64
TxImmedPtr  DD     ?        ; Virtual address of Immediate data
TxDataCount DW     ?        ; Number of Data Blocks (max = 8)
TxDataBlk   DB     size TxDataBlock * MAX_TX_DATABLK dup(0)
TxBufDesc   Ends

TxBufDescrSize    Equ    Size TxImmedLen + Size TxImmedPtr + Size TxDataCount

; 
; * TransferData data block description
; 
TDDataBlock Struc
TDPtrType   DB     ?        ; 0 => Phys pointer, 1 => GDT pointer
TDRsvdByte  DB     ?        ; Reservered, must be zero.
TDDataLen   DW     ?        ; Data block length in bytes.
TDDataPtr   DD     ?        ; Far pointer to data block.
TDDataBlock Ends

; 
; * TransferData descriptor structure
; 
TDBufDesc   Struc
TDDataCount DW    ?        ; No of Data Blocks (max 8 for V1.01).
TDDataBlk   DB    size TDDataBlock*MAX_TD_DATABLK dup(0)
TDBufDesc   Ends

; 
; * ReceiveChain data block structure definition
; 
RxDataBlock Struc
RxDataLen   DW    ?        ; Length of the Data Block
RxDataPtr   DD    ?        ; Far Pointer to Data Block
RxDataBlock Ends

; 
; * ReceiveChain descriptor structure definition
; 
RxBufDesc   Struc
RxDataCount DW    ?        ; No of Data Blocks. (max 8 for V1.01).

RxDataBlk   DB    size RxDataBlock*MAX_RX_DATABLK dup(0)
RxBufDesc   Ends


;-----------------------------------------------------------------------------
; 
;    Structures used in Protocol.Ini parsing.
;
;  
; * Data structures for the "Module Configuration" structure parsed from
; * the PROTOCOL.INI file. see NDIS spec for details.
; 
Param       Struc
ParamType   DW    ?    ; 0 => 31 bit signed integer, 1 => string
ParamLen    DW    ?    ; String length (including null) or 4.
ParmStart   DB    ?    ; Start of actual parameter.
Param       Ends

KeywordEntry       Struc
NextKeywordEntry   DD        ?                   ;  Forward pointer
PrevKeywordEntry   DD        ?                   ;  Back Pointer
KeyWord            DB        NAME_LEN Dup(?)     ;  Keyword on left side of "="
NumParams          DW        ?                   ;  Number of parameters on r. side of "="
Params             DB        Size Param dup(?)   ;  Actual size depends on NumParams
KeywordEntry       Ends


ModCfg      Struc
NextModCfg  DD     ?                   ;  Module config images are in a
PrevModCfg  DD     ?                   ;  double-linked list.
ModName     DB     NAME_LEN Dup(?)     ;  Bracketed Module Name.
KE          DB     Size KeywordEntry Dup(?) ;  Head of Keyword list
ModCfg      Ends

ProIni      Struc
MC          DB     Size ModCfg*1 dup(?)  ; Head of Module config list.
ProIni      Ends

PI_Record   Struc
Srchkeyword        DB        '                ' ; keyword.
SrchParmType       DW        ?         ; 0 - numeric, 1 - string. see below.
ParamField         DD        ?         ; If numeric, will contain value, 
                                       ; If string, will contain the pointer to string.
RequiredField      DB        ?         ; Set to 1 if parameter is required.
SetFCN             DW        ?         ; Offset to Parser function.
PI_Record   Ends


;
; Processor Type Equates.
;
EIGHT_BIT          equ       0001H
SIXTEEN_BIT        equ       0002H
PROC_TYPE_MASK     equ       0030H

PROC_8086          equ       0000H OR EIGHT_BIT
PROC_80286         equ       0010H OR SIXTEEN_BIT
PROC_80386         equ       0020H
PROC_80486         equ       0040H


; EOF - $Workfile:   sstrucs.inc  $
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c5x9\portable.inc ===
;
; Modifications:   $Header:   J:/archives/preboot/lsa2/inc/portable.INV   1.2   19 Sep 1997 21:39:10   MJOHNSOX  $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;

;
;   Description: MACROS which drive the way portable code is built
;

IFDEF              PORTABLE_INC
ELSE
PORTABLE_INC       equ    1

;--------------------------------------------------------------------------
; This file requires the inclusion of "equates.inc" before it is included.
;--------------------------------------------------------------------------
; This file must follow the definition (via inclusion or in-line) of one of
; the following configuration assemble-time switches.  The following IFNDEF
; statements take care of two situations:
;   1) the user of this file only needs to define the model it using as TRUE,
;      all other models will not be defined and will therefore be set FALSE,
;      which means all references to the model will use IF (not IFDEF or IFE).
;   2) a user who does not define any model will find that nothing is defined,
;      since all of the IFNDEF's will assemble.  A model must be selected.
;--------------------------------------------------------------------------

IFDEF DOSNDIS
ELSE
DOSNDIS              equ         FALSE
ENDIF

IFDEF OS2NDIS
ELSE
OS2NDIS              equ         FALSE
ENDIF

IFDEF NWSERVER
ELSE
NWSERVER             equ         FALSE
ENDIF

IFDEF DOSODI
ELSE
DOSODI               equ         FALSE
ENDIF

IFDEF OS2ODI
ELSE
OS2ODI               equ         FALSE
ENDIF

;--------------------------------------------------------------------------
; @CPUSH
;
; Description : Each driver inserts code that pushes the registers that must 
;               not be changed by a function called from C.
;
; Entry       : none
;
; Exit        : none
;
;--------------------------------------------------------------------------
@CPUSH macro  name
IF DOSODI
 IFDEF XMIT_NO_COPY_DMA
    push    ebp            
    push    ebx
    push    esi
    push    edi
 ELSE
    push    bp
    push    bx
    push    di
    push    si
 ENDIF
ENDIF
IF OS2ODI
    push    ebp            
    push    ebx
    push    edi
    push    esi
ENDIF
IF DOSNDIS
    push    bp
    push    bx
    push    di
    push    si
ENDIF
IF OS2NDIS
    push    ebp
    push    ebx
    push    edi
    push    esi
ENDIF
IF NWSERVER
    CPush
ENDIF
    ENDM

;--------------------------------------------------------------------------
; @CPOP
;
; Description : Each driver inserts code that pops the registers that must 
;               not be changed by a function called from C.  
;
; Entry       : none
;
; Exit        : none
;
;--------------------------------------------------------------------------
@CPOP macro  name
IF DOSODI
 IFDEF XMIT_NO_COPY_DMA
    pop     edi            
    pop     esi
    pop     ebx
    pop     ebp
 ELSE
    pop     si
    pop     di
    pop     bx
    pop     bp
 ENDIF
ENDIF
IF OS2ODI
    pop     esi
    pop     edi            
    pop     ebx
    pop     ebp
ENDIF
IF DOSNDIS
    pop     si
    pop     di
    pop     bx
    pop     bp
ENDIF
IF OS2NDIS
    pop     esi
    pop     edi            
    pop     ebx
    pop     ebp
ENDIF
IF NWSERVER
    CPop
ENDIF
    ENDM

;--------------------------------------------------------------------------
; @PUSH_MUSTSAVE
;
; Description : Each driver inserts code that pushes the registers that must 
;               NEVER be changed by a function, others may be saved at times.
;               PUSH_MUSTSAVE contents must correlate to POP_MUSTSAVE.
;               PUSH_MUSTSAVE can't be written to allow POP_SAVE to save flags.
;
; Entry       : none
;
; Exit        : none
;
;--------------------------------------------------------------------------
@PUSH_MUSTSAVE macro  name
IF DOSODI
    push    bx
ENDIF
IF OS2ODI
    push    ebx
ENDIF
IF DOSNDIS
ENDIF
IF OS2NDIS
ENDIF
IF NWSERVER
    push    ebp
    push    ebx
ENDIF
    ENDM

;--------------------------------------------------------------------------
; @POP_MUSTSAVE
;
; Description : Each driver inserts code that pops the registers that must 
;               NEVER be changed by a function, others may be saved at times.
;               POP_MUSTSAVE contents must correlate to PUSH_MUSTSAVE.
;               POP_MUSTSAVE cannot save contents of Flags Register.
;
; Entry       : none
;
; Exit        : none
;
;--------------------------------------------------------------------------
@POP_MUSTSAVE macro  name
IF DOSODI
    pop     bx
ENDIF
IF OS2ODI
    pop     ebx
ENDIF
IF DOSNDIS
ENDIF
IF OS2NDIS
ENDIF
IF NWSERVER
    pop     ebx
    pop     ebp
ENDIF
    ENDM

;--------------------------------------------------------------------------
; @PROC_BEGIN
;
; Description : Each driver inserts code that defines a procedure header.
;
; Entry       : The "name" is required as it precedes the "proc" directive,
;               the "distance" is optional, and will default to the size 
;               as specified by SEGMENT directives if it is not provided.
;
; Exit        : none
;
;--------------------------------------------------------------------------
@PROC_BEGIN macro  name, distance
IF DOSODI
            align 4
    public  name
name        proc   distance
ENDIF
IF OS2ODI
            align 4
    public  name
name        proc   distance
ENDIF
IF DOSNDIS
;            align 16
    public  name
name        proc   distance
ENDIF
IF OS2NDIS
            align 16
    public  name
name        proc   distance
ENDIF
IF NWSERVER
            align 16
    public  name
name        proc   distance
ENDIF
            ENDM

;--------------------------------------------------------------------------
; @PROC_END
;
; Description : Each driver inserts code that concludes a procedure, WITHOUT
;               the Return statement (avoids forcing jump-to-end to return).
;
; Entry       : none
;
; Exit        : none
;
;--------------------------------------------------------------------------
@PROC_END   macro  name
IF DOSODI
name        endp
ENDIF
IF OS2ODI
name        endp
ENDIF
IF DOSNDIS
name        endp
ENDIF
IF OS2NDIS
name        endp
ENDIF
IF NWSERVER
name        endp
ENDIF
            ENDM


;--------------------------------------------------------------------------
; BREG
;
; Description : Each driver defines an equate which will be used by portable
;               code when referring to variables in the data segment.
;               The value of the EQU must evaluate to a valid value when
;               used, the EQU is always used within [] brackets.
;
; Entry       : none
;
; Exit        : none
;
;--------------------------------------------------------------------------
IF DOSODI
BREG    equ    0
ENDIF

IF OS2ODI
BREG    equ    bx
ENDIF

IF DOSNDIS
BREG    equ    0
ENDIF

IF OS2NDIS
BREG    equ    0
ENDIF

IF NWSERVER
BREG    equ    ebp
ENDIF

;--------------------------------------------------------------------------
; Macro for virtual to physical address conversion, only necessary for users 
; of LINEAR mode as opposed to SEGMENTED mode.  If using LINEAR mode, base
; register is 0, all virtual addresses must be converted to true physical 
;   (therefore this mode requires that the macro convert "source").
;
; If using SEGMENTED mode AND not running under a memory maanager, then DS
; is the true paragraph number to be assigned to the CURU base register, and
; any offset with the data segment is valid value to give CU/RU as an address 
;   (therefore this mode requires that the macro leave "source" as-is).
;
; If using SEGMENTED mode AND loaded under a memory manager, the DS value is
; not necessarily the TRUE paragraph number, but OFFSETs will be correct.
; At initialization time DS must converted if needed under memory manager. 
; In this situation, whether DS is same as TRUE paragraph or not, BUILD_PHYSICAL
; will leave "source" alone since is offsets are correct within TRUE paragraph.
;
; NOTE that can't use SEGMENTED mode and point to memory outside base Segment,
; because the SCB MACROs and structures always force the high-16 bits to zero.
;--------------------------------------------------------------------------
;- Build A Physical Address From A Logical Address
@BUILD_PHYS_OFFSET  MACRO    Source
    ENDM

;- Build A Physical Address From A Logical Address
@BUILD_PHYS_ADDRESS MACRO    Source
IF NWSERVER
    xchg    eax, Source
    call    MSMGetPhysical
    xchg    Source, eax
ENDIF
IF OS2ODI
    ;- call    DevHlp:VirtToPhys          ; NOTE macro can be used ANYTIME!
    mov     esi, Source
    call    ConvertToPhysicalAddress
    mov     Source, eax
ENDIF
IF (DOSNDIS OR OS2NDIS)
    mov     ax, ds
    mov     es, ax
    mov     esi, Source
    call    ConvertToPhysicalAddress
    mov     Source, eax
ENDIF
    ENDM


;--------------------------------------------------------------------------
; Macro to Output a string under Various and Random Netware Requirements.
;--------------------------------------------------------------------------
@PrintWarning  macro Msg
IF NWSERVER
    push    esi
    mov     esi, OFFSET Msg
    call    MSMPrintStringWarning
    pop     esi
ENDIF

IF (OS2ODI OR DOSODI)
    push    dx
IF  OS2ODI
    mov     dx, Msg
ENDIF    
IF  DOSODI
    mov     dx, OFFSET CGROUP:Msg
ENDIF    
    push    ax
    push    bx
    call    MSMPrintStringZero 
    pop     bx
    pop     ax
    pop     dx
ENDIF
    ENDM

;--------------------------------------------------------------------------
; Macro Used by routines which load a pointer to a string in AX to indicate
; that the routine encountered an error (therefore NDIS must return non-zero).
;--------------------------------------------------------------------------
@LOAD_MSGPTR macro msg
IF NWSERVER
    lea     eax, msg 
ENDIF
IF DOSODI
    lea     ax, msg 
ENDIF
IF OS2ODI
    mov     eax, msg 
ENDIF
IF (OS2NDIS OR DOSNDIS)
    xor     eax, eax
    dec     eax
ENDIF
    ENDM

;--------------------------------------------------------------------------
; Generic Register names used in portable code:
;
; Assumption here is that the NWSERVER code is using Flat 32-bit model, all
; pointers must be 32-bit pointers (relative to DS, whatever that is).  All
; other drivers using this code are assumed to be 16-bit Segment Model code.
;--------------------------------------------------------------------------

IF NWSERVER

RDI equ     edi
RSI equ     esi
RDX equ     edx
RCX equ     ecx
RBX equ     ebx
RAX equ     eax
RBP equ     ebp

ELSE

RDI equ     di
RSI equ     si
RDX equ     dx
RCX equ     cx
RBX equ     bx
RAX equ     ax
RBP equ     bp

ENDIF

ENDIF


; EOF - $Workfile:   portable.inc  $
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c5x9\pxe_stru.inc ===
;
NUM_MCADDRS    	Equ	8		; max number of multicast addresses.
MAX_DATABLK    	Equ	8		; max number of data blocks supported 
					;	in a descriptor.
MAX_IMMED_LEN	Equ	64		; max immediate data buffer length
MAX_TX_DATABLK	Equ	MAX_DATABLK	; max number of data blocks supported 
					;	in a Tx descriptor.
MAX_TD_DATABLK	Equ	MAX_DATABLK	; max number of TransferData blocks
		
APIMaxFunc	EQU	0011h

ADDR_LEN	EQU	16
ETH_ADDR_LEN	EQU	6
MAXNUM_MCADDR	EQU	8

;
; protocol values in transmit buffer
;
P_UNKNOWN	EQU	0		;; no media header
P_IP	 	EQU	1		;; IP type
P_ARP		EQU	2		;; ARP type
P_RARP		EQU	3		;; RARP type

TYPE_IP	 	EQU	0800h		;; IP type
TYPE_ARP	EQU	0806h		;; ARP type
TYPE_RARP	EQU	8035h		;; RARP type
;
; xmitflag values in transmit buffer
;
PKT_DESTADDR	EQU 0	;; destination address given 
PKT_BROADCAST	EQU 1h	;; use broadcast address 
PKT_MULTICAST	EQU 2h	;; multicast addr given

;; Hardware type values
ETHER_TYPE 		EQU 1
EXP_ETHER_TYPE	EQU 2
IEEE_TYPE  	EQU 6
ARCNET_TYPE   	EQU 7


Eth_MCastBuf	Struc
MCastAddrCount	DW	?
MCastAddr	DB MAXNUM_MCADDR * ETH_ADDR_LEN dup (0)
Eth_MCastBuf	Ends

MC_MCastBuf		Struc
MC_MCastAddrCount	DW	?
MC_MCastAddr  		DB MAXNUM_MCADDR * ADDR_LEN dup (0)
MC_MCastBuf		Ends

NIC_StartUp	Struc
S_Status	DW	?
S_BusType	DB	?
S_AddrType	DB	?
S_DataSeg	DW	?
S_DataSegAddr	DD	?
S_DataSegSize	DW	?
S_CodeSegSize	DW	?
S_BusDevFunc	DW	?	;; PCI Dev_ID
S_PCI_ds_off	dw	?	;; Far pointer to PCI data structure
S_PCI_ds_seg	dw	?
S_PnP_csn	dw	?	; Card select number.-1 for non-PnP BBS device
S_PnP_eh_off	dw	?	; Far pointer to PnP expansion header
S_PnP_eh_seg	dw	?
NIC_StartUp	Ends

NIC_CleanUp	Struc
CL_Status	DW	?
NIC_CleanUp	Ends

NIC_Initialize	Struc
I_Status	DW	?
I_Prot_ini	DD	?
I_RcvInt	DD	?
I_GenInt	DD	?
NIC_Initialize  Ends

NIC_Reset	Struc
R_Status	DW	?
R_MCBuf		MC_MCastBuf <>
NIC_Reset	Ends

NIC_ShutDown	Struc
SD_Status	DW	?
NIC_ShutDown	Ends

NIC_Open	Struc
O_Status	DW	?
O_OpenFlg	DW	?
O_PktFilter	DW	?
O_MCBuf		MC_MCastBuf <>
NIC_Open	Ends

NIC_Close	Struc
C_Status	DW	?
NIC_Close	Ends

X_DataBlock	Struc
X_TxPtrType	DB	?	; 0 => Phys pointer, 1 => GDT pointer
X_TxRsvdByte	DB	?	; Reservered, must be zero.
X_TxDataLen	DW	?	; Data block length in bytes.
X_TxDataPtr	DD	?	; Far pointer to data block.
X_DataBlock Ends

NIC_TBD		Struc
X_Length	DW	?
X_BufOff	DW	?
X_BufSeg	DW	?
X_DataBlkCount	DW	?		; will always be zero for base code
X_DataBlk	DB	MAX_DATABLK * SIZE X_DataBlock dup (0)	
NIC_TBD		Ends

NIC_Transmit		Struc
T_Status		DW	?
T_Protocol		DB	?
T_XmitFlag		DB	?
T_DestAddrOffset 	DW	?	; 16-bit segment & offset of the
T_DestAddrSegment 	DW	?	; destination media address 
T_TBDOffset		DW	?	; 16-bit segment & offset 
T_TBDSegment		DW	?	; transmit buffer descriptor 
T_Reserved		DD	2 dup(0)	; for future use	
NIC_Transmit Ends

NIC_SetMCastAddr	Struc
SM_Status		DW	?
SM_MCBuf		MC_MCastBuf <>
NIC_SetMCastAddr	Ends

NIC_SetStationAddr	Struc
SS_Status		DW	?
SS_StationAddr		DB	ADDR_LEN dup (0)
NIC_SetStationAddr	Ends

NIC_SetPacketFilter	Struc
SP_Status		DW	?
;;SP_NewFilter		DW  ?
SP_NewFilter		DB  ?
;;SP_MCBuf		MC_MCastBuf <>
NIC_SetPacketFilter	Ends

NIC_GetInfo	Struc
GI_Status		DW	?
GI_BaseIo		DW	?
GI_IntNumber		DW	?
GI_MTU			DW	?
GI_HwType		DW	?
GI_HwAddrLen		DW	?
GI_CurrentNodeAddress	DB ADDR_LEN dup (0)
GI_PermNodeAddress	DB ADDR_LEN dup (0)
GI_ROMAddress		DW 	?
GI_RxBufCt		DW	?
GI_TxBufCt		DW	?
NIC_GetInfo	Ends

NIC_GetNICType_pci 	Struc
Status 		DW	?	; OUT: See PXENV_STATUS_xxx constants */ 
NicType 	DB	?	;  /* OUT: 2=PCI, 3=PnP */
Vendor_ID	DW	?	; /* OUT:  */
Dev_ID		DW	?	;  /* OUT:  */
Base_Class	DB	?	; /* OUT: */
Sub_Class	DB	?	;  /* OUT: */
Prog_Intf	DB	?	;  /* OUT: program interface */ 
Rev		DB	?	;  /* OUT: Revision number */ 
BusDevFunc	DW	?	; /* OUT: Bus, Device & Function numbers */
NIC_GetNICType_pci 	Ends

NIC_GetNICType_pnp 	Struc
Status 		DW	?	; OUT: See PXENV_STATUS_xxx constants */ 
NicType 	DB	?	;  /* OUT: 2=PCI, 3=PnP */
EISA_Dev_ID	DD	?	; /* Out:  */
Base_Class	DB	?	; /* OUT: */
Sub_Class	DB	?	;  /* OUT: */
Prog_Intf	DB	?	;  /* OUT: program interface */
CardSelNum	DW	?	; /* OUT: Card Selector Number */
Res		DB	0	;
NIC_GetNICType_pnp 	Ends

NIC_GetStatistics	Struc
GS_Status		DW	?
GS_XmtGoodFrames	dd    ?
GS_RcvGoodFrames	dd    ?
GS_RcvCRCErrors		dd    ?
GS_RcvResourceErrors	dd    ?
NIC_GetStatistics	Ends

NIC_ClearStatistics	Struc
CS_Status		DW	?
NIC_ClearStatistics	Ends

NIC_InitDiags	Struc
ID_Status	DW	?
NIC_InitDiags   Ends

NIC_ForceInterrupt	Struc
FI_Status		DW	?
NIC_ForceInterrupt	Ends

NIC_GetMCastAddr	Struc
GM_Status		DW	?
GM_InetAddr		DD	?
GM_HwAddr		DB	ADDR_LEN dup (0)
NIC_GetMCastAddr	Ends

;NIC_API_Entry	Struc
;Signature 	DB	'PXENV+'	;; not null terminated
;Version		DW	0100h		;; 1.0
;StrucLength	DB	0		;; length of this structure
;CheckSum	DB	0		;; fill in later
;rm_entry_off	DW	0		;; real mode driver entry offset
;rm_entry_seg	DW	0		;; real mode driver entry segment
;pm_entry_off	DW	0		;; protected mode driver entry offset
;pm_entry_seg	DW	0		;; protected mode driver entry segment
;NIC_API_Entry	Ends

s_PXENV_ENTRY	Struc
signature	db	6 dup(?)	; 'PXENV+'
ver             dw      ?               ; MSB=major, LSB=minor
bytes		db	?		; sizeof s_pxenv_entry
checksum	db	?		; 8-bit checksum of structure,
					; including this byte shoube be zero.
rm_entry_off	dw	?		; 16-bit real-mode segment & offset.
rm_entry_seg	dw	?
pm_entry_off	dw	?		; 16-bit protected mode 32-bit physical
pm_entry_base	dd	?		; address and 16-bit offset.
stack_sel	dw	?		; PROM stack segment.  Will be set
stack_size	dw	?		; to 0 when removed from memory.
base_cs_sel	dw	?		; Base code segment.  Will be set
base_cs_size	dw	?		; to 0 when removed from memory.
base_ds_sel	dw	?		; Base data segment.  Will be set
base_ds_size	dw	?		; to 0 when removed from memory.
mlid_ds_sel	dw	?		; MLID data segment.
mlid_ds_size	dw	?
mlid_cs_sel	dw	?		; MLID code segment.
mlid_cs_size	dw	?
s_PXENV_ENTRY	Ends

;; Ethernet II protocol header
EtherHeader	Struc
E_DestAddr	DB 6 dup (0)	;; destination ethernet addr
E_SrcAddr	DB 6 dup (0)	;; destination ethernet addr
E_Type		DW  ?	;; protocol type
EtherHeader	Ends

ETHER_HEADER_LEN	Equ	SIZE EtherHeader

; 
; * Data structures for TransmitChain (Tx), TransferData (TD)
; 
TxDataBlock	Struc
TxPtrType	DB	?	; 0 => Phys pointer, 1 => GDT pointer
TxRsvdByte	DB	?	; Reservered, must be zero.
TxDataLen	DW	?	; Data block length in bytes.
TxDataPtr	DD	?	; Far pointer to data block.
TxDataBlock	Ends

; 
; * TransmitChain descriptor structure definition
; 
TxBufDesc	Struc
TxImmedLen	DW	?	; Byte count of immediate data, max=64
TxImmedPtr	DD	?	; Virtual address of Immediate data
TxDataCount	DW	?	; Number of Data Blocks (max = 8)
TxDataBlk	DB	size TxDataBlock * MAX_TX_DATABLK dup(0)
TxBufDesc	Ends

TxBufDescrSize	Equ	Size TxImmedLen + Size TxImmedPtr + Size TxDataCount

; 
; * TransferData data block description
; 
TDDataBlock	Struc
TDPtrType	DB	?	; 0 => Phys pointer, 1 => GDT pointer
TDRsvdByte	DB	?	; Reservered, must be zero.
TDDataLen	DW	?	; Data block length in bytes.
TDDataPtr	DD	?	; Far pointer to data block.
TDDataBlock	Ends

; 
; * TransferData descriptor structure
; 
TDBufDesc	Struc
TDDataCount	DW	?	; No of Data Blocks (max 8 for V1.01).
TDDataBlk	DB	size TDDataBlock*MAX_TD_DATABLK dup(0)
TDBufDesc	Ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c5x9\undi_equ.inc ===
;
;--- Miscellaneous Equates
;
CR		equ	0Dh           ;- Carriage Return
LF		equ	0Ah           ;- Line Feed
FALSE		equ	0
TRUE		equ	1
;
;--- Ethernet Frame Sizes
;
ETHERNET_ADDRESS_LENGTH		equ	6
ETHERNET_HEADER_SIZE		equ	14
MINIMUM_ETHERNET_PACKET_SIZE	equ	60
;MAXIMUM_ETHERNET_PACKET_SIZE	equ	1514
MAXIMUM_ETHERNET_PACKET_SIZE	equ	1500 ;; just data, not media header

MAX_PACKET         Equ       1514      ; Maximum allowable packet size.
MIN_PACKET         Equ       60        ; Minimum allowable packet size.
; 
;--- Packet filter bit definitions
; 
FLTR_DIRECTED                Equ       01H
FLTR_MLTCST                  Equ       01H
FLTR_BRDCST                  Equ       02H
FLTR_PRMSCS                  Equ       04H
FLTR_SRC_RTG                 Equ       08H
;
;--- Processor Type Equates
;
EIGHT_BIT          equ       0001H
SIXTEEN_BIT        equ       0002H
PROC_TYPE_MASK     equ       0030H

PROC_8086          equ       0000H OR EIGHT_BIT
PROC_80286         equ       0010H OR SIXTEEN_BIT
PROC_80386         equ       0020H
PROC_80486         equ       0040H
;
;--- Result codes returned in AX by a PXE API service.
;
PXENV_EXIT_SUCCESS		equ	0
PXENV_EXIT_FAILURE		equ	1
PXENV_EXIT_CHAIN		equ	0FFFFh	; used internally
;
;--- Status codes returned in the status word of PXE API parameter structures.
;
PXENV_STATUS_SUCCESS		equ	0
PXENV_STATUS_FAILURE		equ	1	;general failure
PXENV_STATUS_BAD_FUNC		equ	2	;invalid function number
PXENV_STATUS_UNSUPPORTED	equ	3	;not yet supported
PXENV_STATUS_1A_HOOKED		equ	4	;Int 1AH cannot be unhooked

; Driver errors (60 to 0x6F)
; These errors are for UNDI compatible NIC drivers.
PXENV_STATUS_UNDI_MEDIATEST_FAILED 		equ	61h
PXENV_STATUS_UNDI_CANNOT_INIT_NIC_FOR_MCAST	equ	62h
;
;
EISA_ADAPTER             equ    1
PCI_ADAPTER              equ    2
PnP_ADAPTER              equ    3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c5x9\spdosegs.inc ===
;
; Modifications:   $Header:   J:/archives/preboot/lsa2/inc/SPDOSEGS.INV   1.5   19 Sep 1997 21:39:18   MJOHNSOX  $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;

;
;   Description: segment declaration and ordering for NDIS driver
;


;-----------------------------------------------------------------------
;
; Functional Description
;
;   This file defines the segments used by a MAC driver and the order
;   in which they are loaded. The groups DGROUP (for data) and CGROUP
;   (for code) are also defined, as are macros to open and close
;   segments (which also set up the default segment assumptions).
;
;-----------------------------------------------------------------------

;=======================================================================
;** Segment Definitions - order counts!
;
; DOS Order:
;      CGROUP, DGROUP
;         DevHeaderSeg
;         _TEXT
;         _DATA 
;         CONST
;         _BSS
;   ; Code and data will be cut off here.	;; AVL - not any more
;         ICODE
;         IDATA
;
; AVL - NEW Order:
;   CGROUP
;         DevHeaderSeg
;         _TEXT
;		  ICODE		;; DOS driver specific init routines, not needed for ROM
;	 DGROUP
;         _DATA 
;         CONST
;         _BSS
;         IDATA		;; just to mark the upper boundary.
;
;========================================================================


;==========================================================================
; DOS segment definitions and ordering.
;==========================================================================
Ifdef DRV
DevHeaderSeg   segment para public USE16 'CODE'
DevHeaderSeg   ends
Endif	;; DRV
;--------------------------------------------------------------------------
; Resident Code segment - code that is used after init time
; (unfortunately, this includes code to bind another driver, and
; initializations that take place at bind time) should be placed in this
; segment.
;--------------------------------------------------------------------------
_TEXT       segment para public USE16 'CODE'
_TEXT       ends

Ifdef DRV
ICODE       segment para public USE16 'INIT'
ICODE       ends
Endif	;; DRV
;--------------------------------------------------------------------------
; Resident Data segment - things put here will remain in memory after
; init time. At the present time, this is in low memory, so data that is
; not used after init time should NOT be put in this segment.
;--------------------------------------------------------------------------
_DATA       segment para public USE16 'DATA'
_DATA       ends

Ifdef DRV
_BSS       segment para public USE16 'DATA'
_BSS       ends
IDATA       segment para public USE16 'DATA'
IDATA       ends
Else
_BSS       segment para public USE16 'BSS'
_BSS       ends
Endif	;; DRV
;--------------------------------------------------------------------------
; Make sure the segment order defined in this file is respected.
;--------------------------------------------------------------------------
.SEQ               


;--------------------------------------------------------------------------
; DOS Group is all one 64K segment, CS=SS=DS, use equate for DGROUP.
;--------------------------------------------------------------------------

;DGROUP      equ     CGROUP
;CGROUP      group   DevHeaderSeg, _TEXT, _DATA, CONST, _BSS, ICODE, IDATA

Ifdef DRV
CGROUP      group   DevHeaderSeg, _TEXT, ICODE
DGROUP      group   _DATA, _BSS, IDATA
ELSE
CGROUP      group   _TEXT
DGROUP      group   _DATA, _BSS
Endif	;; DRV
;--------------------------------------------------------------------------
; Group is 64K data, 64K code, CS!=SS=DS, actual group for Code.
;--------------------------------------------------------------------------

;--------------------------------------------------------------------------
; Assume statement here takes care of for any source, same for OS2 and DOS.
;--------------------------------------------------------------------------
    Assume   CS:CGROUP, DS:DGROUP, ES:NOTHING, SS:NOTHING


; EOF - $Workfile:   spdosegs.inc  $
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c90x\bwstruct.inc ===
;====================================================================
; BWSTRUCT.INC
;
; Include for for BootWare, defines common structures.
;
; 970116 PC - first version
;====================================================================

;--------------------------------------------------------------------
; Common equates
;---------------------------------------------------------------------
FEATURE_LOCAL	equ	1
FEATURE_VIRUS	equ	2
FEATURE_MENU	equ	4
FEATURE_KEYWAIT	equ	8
FEATURE_FLOPPY	equ	64
FEATURE_HDRIVE	equ	128

;--------------------------------------------------------------------
; Event Descriptor (ED) Structure
;---------------------------------------------------------------------
IFDEF _IDEAL_
Struc	ED
	Ptr		dw	?	; pointer to next ED
	Unused		dw	?	; spare word
	DestAddr	dw	?, ?, ?	; destination Address
	ErrCode		dw	?	; error code
	ErrMsg		dw	?	; pointer to error msg
	Length		dw	?	; total packet length
	FragCount	dw	?	; number of fragments
	FragOff		dw	?	; 1st fragment offset
	FragSeg		dw	?	; 1st fragment segment
	FragLen 	dw	?	; length of fragment
ends
ELSE
ED_Struct      STRUC
	ED_Ptr		dw	?	; pointer to next ED
	ED_Unused	dw	?	; spare word
	ED_DestAddr	dw	?, ?, ?	; destination address
	ED_ErrCode	dw	?       ; error code
	ED_ErrMsg	dw	?       ; Pointer to error msg
	ED_Length	dw	?	; total packet length
	ED_FragCount	dw	?	; Number of descriptors/fragments
	ED_FragOff	dw	?	; Descriptor Pointer
	ED_FragSeg	dw	?	; Descriptor Pointer
	ED_FragLen 	dw	?	; Length of packet descriptor
ED_Struct      ENDS
ENDIF

;--------------------------------------------------------------------
; Descricptor Structure
;---------------------------------------------------------------------
IFDEF _IDEAL_
Struc Frag
	Off		dw	?	; offset of fragment
	Seg		dw	?	; segment of fragment
	Len		dw	?	; length of fragment
ends
ELSE
Frag Struc
	FragOff		dw	?	; offset of fragment
	FragSeg		dw	?	; segment of fragment
	FragLen		dw	?	; length of fragment
Frag ends
Descript_Struct STRUC
	DPointer	dd	?	; Descriptor Pointer
	DLen		dw	?	; Length of packet descriptor
Descript_Struct ends
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c5x9\vulcan.inc ===
;------ VULCAN.INC ----------------------------------------------------------;
;									     ;
;	This file contains Vulcan-specific equates, structures and	     ;
;	macros.  It must be assembled with MASM 5.1 or later.		     ;
;									     ;
;----------------------------------------------------------------------------;
;----------------------------------------------------------------------------;
;									     ;
;	This source file is the property of 3Com Corporation and may not be  ;
;	copied or distributed in any isomorphic form without an appropriate  ;
;	prior licensing arrangement with 3Com Corporation.		     ;
;									     ;
;	Copyright (c) 1988 3Com Corporation				     ;
;									     ;
;	3Com Corporation						     ;
;	5400 Bayfront Plaza, P.O. Box 58145				     ;
;	Santa Clara, CA 95052-8145 USA					     ;
;	(408) 764-6016							     ;
;									     ;
;----------------------------------------------------------------------------;

;
; the compatibility level of this driver
;
CLEVEL		    equ 0

;------ Equates -------------------------------------------------------------;
;
; Command code masks
;
CMD_CMDMASK	    equ 0F800h			; command bits
CMD_ARGMASK	    equ 007FFh			; argument bits
;
; Command codes, word form
;
CMD_GLOBALRESET     equ 00000b shl 11		; global reset
CMD_SELECTWINDOW    equ 00001B shl 11		; select register window
CMD_STARTINTXCVR    equ 00010b shl 11		; start internal transciver
CMD_RXDISABLE	    equ 00011b shl 11		; rx disable
CMD_RXENABLE	    equ 00100b shl 11		; rx enable
CMD_RXRESET	    equ 00101b shl 11		; rx reset
CMD_RXDISCARD	    equ 01000b shl 11		; rx discard top packet
CMD_TXENABLE	    equ 01001b shl 11		; tx enable
CMD_TXDISABLE	    equ 01010b shl 11		; tx disable
CMD_TXRESET	    equ 01011b shl 11		; tx reset
CMD_REQUESTINT	    equ 01100b shl 11		; request interrupt
CMD_ACKNOWLEDGE     equ 01101b shl 11		; acknowledge interrupt
CMD_SETINTMASK	    equ 01110b shl 11		; set interrupt mask
CMD_SETRZMASK	    equ 01111b shl 11		; set read zero mask
CMD_SETRXFILTER     equ 10000b shl 11		; set rx filter
CMD_SETRXEARLY	    equ 10001b shl 11		; set rx early threshold
CMD_SETTXAVAILABLE  equ 10010b shl 11		; set tx available threshold
CMD_SETTXSTART	    equ 10011b shl 11		; set tx start threshold
CMD_STATSENABLE     equ 10101b shl 11		; statistics enable
CMD_STATSDISABLE    equ 10110b shl 11		; statistics disable
CMD_STOPINTXCVR     equ 10111b shl 11		; start internal transciver
;
; Command codes, hibyte form (commands without operands only)
;
CMDH_STARTINTXCVR   equ CMD_STARTINTXCVR shr 8
CMDH_RXDISABLE	    equ CMD_RXDISABLE shr 8
CMDH_RXENABLE	    equ CMD_RXENABLE shr 8
CMDH_RXDISCARD	    equ CMD_RXDISCARD shr 8
CMDH_TXENABLE	    equ CMD_TXENABLE shr 8
CMDH_TXDISABLE	    equ CMD_TXDISABLE shr 8
CMDH_REQUESTINT     equ CMD_REQUESTINT shr 8
CMDH_STATSENABLE    equ CMD_STATSENABLE shr 8
CMDH_STATSDISABLE   equ CMD_STATSDISABLE shr 8
CMDH_STOPINTXCVR    equ CMD_STOPINTXCVR shr 8
;
; Status register bits (INT for interrupt sources, ST for the rest)
;
INT_LATCH	    equ 00001h			; interrupt latch
INT_ADAPTERFAIL     equ 00002h			; adapter failure
INT_TXCOMPLETE	    equ 00004h			; tx complete
INT_TXAVAILABLE     equ 00008h			; tx available
INT_RXCOMPLETE	    equ 00010h			; rx complete
INT_RXEARLY	    equ 00020h			; rx early
INT_REQUESTED	    equ 00040h			; interrupt requested
INT_UPDATESTATS     equ 00080h			; update statistics
ST_FAILED	    equ 00800h			; command failed
ST_BUSY 	    equ 01000h			; command busy
ST_WINDOW	    equ 0E000h			; window bits (13-15)

STH_FAILED	    equ ST_FAILED shr 8
STH_BUSY	    equ ST_BUSY shr 8
STH_WINDOW	    equ ST_WINDOW shr 8

ifdef REV0
INT_OFFTXCOMPLETE   equ ((NOT (INT_TXCOMPLETE or INT_ADAPTERFAIL or INT_UPDATESTATS)) and (0FFh))
ifdef NDIS
INT_ONTXCOMPLETE    equ (INT_TXCOMPLETE or INT_UPDATESTATS)
else
INT_ONTXCOMPLETE    equ ((NOT INT_ADAPTERFAIL) and (0FFh))
endif

else
INT_OFFTXCOMPLETE   equ ((NOT (INT_TXCOMPLETE)) and (0FFh))
ifdef NDIS
INT_ONTXCOMPLETE    equ INT_TXCOMPLETE
else
;940107INT_ONTXCOMPLETE    equ MASK_NONE
endif
endif
;
; RxStatus register bits, both forms
;
RXS_INCOMPLETE	    equ 8000h			; not completely received
RXS_ERROR	    equ 4000h			; error in packet
RXS_LENGTH	    equ 07FFh			; bytes in RxFIFO
RXS_ERRTYPE	    equ 3800h			; Rx error type, bit 13-11
ifdef REV0
RXS_OVERRUN	    equ 0000h			; overrun error
RXS_DRIBBLE	    equ 0800h			; dribble bit
RXS_CRC 	    equ 1000h			; CRC error
RXS_RUNT	    equ 1800h			; runt packet error
RXS_OVERSIZE	    equ 2000h			; oversize packet error
RXS_FRAMING	    equ 2800h			; framing error
else
RXS_OVERRUN	    equ 0000h			; overrun error
RXS_OVERSIZE	    equ 0800h			; oversize packet error
RXS_DRIBBLE	    equ 1000h			; dribble bit (not an error)
RXS_RUNT	    equ 1800h			; runt packet error
RXS_CRC 	    equ 2800h			; CRC error
RXS_FRAMING	    equ 2000h			; framing error
endif

RXSH_INCOMPLETE     equ RXS_INCOMPLETE shr 8
RXSH_ERROR	    equ RXS_ERROR shr 8
RXSH_ERRTYPE	    equ RXS_ERRTYPE shr 8
RXSH_OVERRUN	    equ RXS_OVERRUN shr 8
RXSH_DRIBBLE	    equ RXS_DRIBBLE shr 8
RXSH_CRC	    equ RXS_CRC shr 8
RXSH_RUNT	    equ RXS_RUNT shr 8
RXSH_OVERSIZE	    equ RXS_OVERSIZE shr 8
RXSH_FRAMING	    equ RXS_FRAMING shr 8
;
; TxStatus register bits
;
TXS_COMPLETE	    equ 80h			; tx completed
TXS_INTREQUESTED    equ 40h			; interrupt on successfull tx
TXS_ERRTYPE	    equ 38h			; error bits
TXS_JABBERERROR     equ 20h			; jabber error
TXS_UNDERRUN	    equ 10h			; tx underrun error
TXS_MAXCOLLISIONS   equ 08h			; max collisions error
TXS_STATUSOVERFLOW  equ 04h			; TX status stack is full
;
; Window Numbers
;
WNO_SETUP	    equ 0			; setup/configuration
WNO_OPERATING	    equ 1			; operating set
WNO_STATIONADDRESS  equ 2			; station address setup/read
WNO_FIFO	    equ 3			; FIFO management
WNO_DIAGNOSTICS     equ 4			; diagnostics
WNO_READABLE	    equ 5			; registers set by commands
WNO_STATISTICS	    equ 6			; statistics
;
; Port offsets, Window 1
;
PORT_CmdStatus	    equ 0Eh			; command/status
PORT_TxFree	    equ 0Ch			; free transmit bytes
PORT_TxStatus	    equ 0Bh			; transmit status (byte)
PORT_Timer	    equ 0Ah			; latency timer (byte)
PORT_RxStatus	    equ 08h			; receive status
PORT_RxFIFO	    equ 00h			; RxFIFO read
PORT_TxFIFO	    equ 00h			; TxFIFO write
;
; Port offsets, Window 0
;
PORT_EEData	    equ 0Ch			; EEProm data register
PORT_EECmd	    equ 0Ah			; EEProm command register
PORT_CfgResource    equ 08h			; resource configuration
PORT_CfgAddress     equ 06h			; address configuration
PORT_CfgControl     equ 04h			; configuration control
PORT_ProductID	    equ 02h			; product id (EISA)
PORT_Manufacturer   equ 00h			; Manufacturer code (EISA)
;
; Port offsets, Window 2
;
PORT_SA0_1	    equ 00h			; station address bytes 0,1
PORT_SA2_3	    equ 02h			; station address bytes 2,3
PORT_SA4_5	    equ 04h			; station address bytes 4,5
;
; Port offsets, Window 3
;
PORT_ALT_TxFree     equ 0Ch			; free transmit bytes (dup)
PORT_RxFree	    equ 0Ah			; free receive bytes
PORT_RomControl     equ 04h			; 940425 RomControl Register

;
; Port offsets, Window 4
;
PORT_MediaStatus    equ 0Ah			; media type/status
PORT_SlingshotStatus equ 08h			; Slingshot status
PORT_NetDiagnostic  equ 06h			; net diagnostic
PORT_FIFODiagnostic equ 04h			; FIFO diagnostic
PORT_HostDiagnostic equ 02h			; host diagnostic
PORT_TxDiagnostic   equ 00h			; tx diagnostic
;
; Port offsets, Window 5
;
PORT_RZMask	    equ 0Ch			; read zero mask
PORT_IntMask	    equ 0Ah			; interrupt mask
PORT_RxFilter	    equ 08h			; receive filter
PORT_RxEarly	    equ 06h			; rx early threshold
PORT_TxAvailable    equ 02h			; tx available threshold
PORT_TxStart	    equ 00h			; tx start threshold
;
; Port offsets, Window 6
;
PORT_TXBYTES	    equ 0Ch			; tx bytes ok
PORT_RXBYTES	    equ 0Ah			; rx bytes ok
PORT_TXDEFER	    equ 08h			; tx frames deferred (byte)
PORT_RXFRAMES	    equ 07h			; rx frames ok (byte)
PORT_TXFRAMES	    equ 06h			; tx frames ok (byte)
PORT_RXDISCARDED    equ 05h			; rx frames discarded (byte)
PORT_TXLATE	    equ 04h			; tx frames late coll. (byte)
PORT_TXSINGLE	    equ 03h			; tx frames one coll. (byte)
PORT_TXMULTIPLE     equ 02h			; tx frames mult. coll. (byte)
PORT_TXNOCD	    equ 01h			; tx frames no CDheartbt (byte)
PORT_TXCARRIERLOST  equ 00h			; tx frames carrier lost (byte)
;
; Various command arguments
;
INT_ALLDISABLED 	equ 00000000000b	    ; all interrupts disabled
ifdef REV0
INT_ALLENABLED		equ 00011111100b	    ; all but AdapterFailure
else
INT_ALLENABLED		equ 00011111110b	    ; all interrupts enabled
endif

MASK_ALL		equ INT_ALLDISABLED
MASK_NONE		equ INT_ALLENABLED

FILTER_INDIVIDUAL	equ 0001b		    ; individual address
FILTER_MULTICAST	equ 0010b		    ; multicast/group addresses
FILTER_BROADCAST	equ 0100b		    ; broadcast address
FILTER_PROMISCUOUS	equ 1000b		    ; promiscuous mode

RXEARLY_DISABLED	equ 2032		    ; RxEarly to disable

TXAVAIL_DISABLED	equ 2040		    ; TxAvailable to disable
TXAVAIL_MIN		equ 4

TXSTART_DISABLED	equ 2040		    ; TxStart to disable
TXSTART_MIN		equ 0
MAX_TXSTART		equ TXSTART_DISABLED

MAX_RXLENGTH		equ 1792		    ; maximum rxlength

TXRXRESET_ALLBUTBM      equ 0100b               ; DUMMY DUMMY This value is copied
						; from 59xp even though it doesn't
						; exist on isa board

;
; Transmit Preamble
;
PREAMBLESIZE		equ 4			    ; transmit preamble size
TXP_INTONSUCCESS	equ 8000h		    ; interrupt on successful tx
;
; Bits in various diagnostics registers
;
MEDIA_TP		equ 8000h		    ; TP transciever
MEDIA_BNC		equ 4000h		    ; Thinnet transciever
MEDIA_INTENDEC		equ 2000h		    ; internal encoder/decoder
MEDIA_SQE		equ 1000h		    ; SQE present
MEDIA_LBEAT		equ 0800h		    ; link beat ok (TP)
MEDIA_POLARITY		equ 0400h		    ; polarity (TP)
MEDIA_JABBER		equ 0200h		    ; jabber (TP)
MEDIA_UNSQUELCH 	equ 0100h		    ; unsquelch (TP)
MEDIA_LBEATENABLE	equ 0080h		    ; link beat enable (TP)
MEDIA_JABBERENABLE	equ 0040h		    ; jabber enable (TP)
MEDIA_CRS		equ 0020h		    ; carrier sense
MEDIA_COLLISION 	equ 0010h		    ; collision
MEDIA_SQEENABLE 	equ 0008h		    ; enable SQE statistics

NETD_EXTLOOPBACK	equ 8000h		    ; TP external loopback
NETD_ENDECLOOPBACK	equ 4000h		    ; ENDEC loopback
NETD_CORELOOPBACK	equ 2000h		    ; ethernet core loopback
NETD_FIFOLOOPBACK	equ 1000h		    ; FIFO loopback
NETD_TXENABLED		equ 0800h		    ; tx enabled
NETD_RXENABLED		equ 0400h		    ; rx enabled
NETD_TXTRANSMITTING	equ 0200h		    ; tx transmitting
NETD_TXRESETREQD	equ 0100h		    ; tx reset required

FIFOD_RXRECEIVING	equ 8000h		    ; rx receiveing
FIFOD_RXUNDERRUN	equ 2000h		    ; rx underrun
FIFOD_RXSTATUSOVER	equ 1000h		    ; rx status overrun
FIFOD_RXOVERRUN 	equ 0800h		    ; rx overrun
FIFOD_TXOVERRUN 	equ 0400h		    ; tx overrun
FIFOD_BISTRESULTS	equ 00FFh		    ; BIST results (mask)

SLING_TXUNDERRUN	equ 2000h		    ; Slingshot TxUnderrun bit
;
; board identification codes, byte swapped in Rev 0
;
ifdef REV0
EISA_MANUFACTURER_ID	equ 0506Dh		    ; EISA manufacturer code
ISA_PRODUCT_ID		equ 05090h		    ; Product ID for ISA board
PRODUCT_ID_MASK 	equ 0FFF0h		    ; Mask off revision nibble
else
EISA_MANUFACTURER_ID	equ 06D50h		    ; EISA manufacturer code
ISA_PRODUCT_ID		equ 09050h		    ; Product ID for ISA board
PRODUCT_ID_MASK 	equ 0F0FFh		    ; Mask off revision nibble
endif
;
; EEProm access
;
EE_BUSY 		    equ 8000h			; EEProm busy bit in EECmd
EE_TCOM_NODE_ADDR_WORD0     equ 00h
EE_TCOM_NODE_ADDR_WORD1     equ 01h
EE_TCOM_NODE_ADDR_WORD2     equ 02h
EE_VULCAN_PROD_ID	    equ 03h
EE_MANUFACTURING_DATA	    equ 04h
EE_SERIAL_NUMBER_WORD0	    equ 05h
EE_SERIAL_NUMBER_WORD1	    equ 06h
EE_MANUFACTURER_CODE	    equ 07h
EE_ADDR_CONFIGURATION	    equ 08h
EE_RESOURCE_CONFIGURATION   equ 09h
EE_OEM_NODE_ADDR_WORD0	    equ 0Ah
EE_OEM_NODE_ADDR_WORD1	    equ 0Bh
EE_OEM_NODE_ADDR_WORD2	    equ 0Ch
EE_SOFTWARE_CONFIG_INFO     equ 0Dh
EE_CWORD		    equ 0Eh
EE_CHECKSUM		    equ 0Fh
EE_CAPABILITIES		    equ	010h
;
; contention logic
;
ID_PORT 		equ 110h
READ_EEPROM		equ 080h
SET_TAG_REGISTER	equ 0D0h
TEST_TAG_REGISTER	equ 0D8h
ACTIVATE_AND_SET_IO	equ 0E0h
ACTIVATE_VULCAN 	equ 0FFh
;
; Resource Configuration Register bits
;
RCONFIG_IRQ		equ 0F000h
;
; Address Configuration Register bits
;
ACONFIG_XCVR		equ 0C000h
ACONFIG_IOBASE		equ 0001Fh
ACONFIG_ROM		equ 03f00h
ACONFIG_ROMSIZE 	equ 03000h
ACONFIG_ROMBASE 	equ 0f00h
;

IOBASE_EISA		equ 0001Fh

TP_XCVR 		equ 00000h
BNC_XCVR		equ 0C000h
AUI_XCVR		equ 04000h

MIN_IO_BASE_ADDR	equ 200h
MAX_IO_BASE_ADDR	equ 3F0h
REGISTER_SET_SIZE	equ 10h
;
; Software Configuration Register bits
;
SW_OPTIMIZE		equ 0030h
SW_MAXCLI		equ 3F00h		; Maximum Modem Speed
SW_LINKBEAT		equ 4000h
SW_BPROT		equ 00007h
SW_CONFIG		equ 00008h		; NOT assigned yet 0=enable, 1=disable
SW_DEFAULT		equ 040h		; 0 = network, 1 = disable
SW_RS			equ 080h		; 1 = enable, 0=disable
SW_BOOTWARE		equ SW_BPROT OR SW_CONFIG OR SW_DEFAULT OR SW_RS	 ; all the bits assigned to BootWare



;
; Possibilities for SW_OPTIMIZE
;
OPTIMIZE_DOS_CLIENT	equ 0010h
OPTIMIZE_WINDOWS_CLIENT equ 0020h
OPTIMIZE_SERVER 	equ 0030h
;
; Configuration Control Register bits
;
ENABLE_ADAPTER		equ 01h
;
; Possibilities for SW_MAXCLI ( Max Modem Speed )
; GY 931007
MODEM_NONE		equ	03F00h
MODEM_1200		equ	03300h
MODEM_2400		equ	02700h
MODEM_9600		equ	01300h
MODEM_19200		equ	0900h
MODEM_38400		equ	0400h
;
; Possible values for SW_BPROT
;
BOOTPROT_UNINIT 	equ 0	; means "virgin" board. Default to 802.2
BOOTPROT_NW_8022	equ 1
BOOTPROT_NW_EII 	equ 2
BOOTPROT_NW_8023	equ 3
BOOTPROT_RPL		equ 4
BOOTPROT_TCPIP		equ 5		; for BW5X9 overlay
BOOTPROT_BOOTP		equ 5
BOOTPROT_DHCP		equ 6

;
; Bus Types
;
BUS_ISA 		equ	1		; ISA card in  ISA mode on ISA	machine
BUS_EISA		equ	2		; EISA card
BUS_MCA 		equ	3		; MCA  card
BUS_EISA_ISAMODE	equ	4		; ISA card in  ISA mode on EISA machine
BUS_EISA_EISAMODE	equ	5		; ISA card in EISA mode on EISA machine
BUS_EISA_ISA2EISA	equ	6		; ISA card on EISA bus switch from ISA->EISA
BUS_EISA_EISA2ISA	equ	7		; ISA card on EISA bus switch from EISA->ISA
BUS_PCI			equ	8		; PCI card

; Current Fail and Warning Level
LEVEL_FAIL		equ	0		; current Fail Level
LEVEL_WARNING		equ	0		; current Warning Level

; RomControl register bits (select 16K ROM Page) Windows 3/Port 5
RomPage0		equ	0
RomPage1		equ	100h
RomPage2		equ	200h
RomPage3		equ	300h
RomPageMask		equ	0fcffh

; 940923 ModeBits, contains system & adapter setting
ModeV2		equ	1
ModeNonISA	equ	4
ModeMCA		equ	8
ModeEISA	equ	10h
ModePCI		equ	20h
ModePnP		equ	40h
ModeAtmel	equ	80h

; 940923 Capabilities Word (EEPROM Offset 010h)
CAPA_PNP		equ	1
CAPA_FULLDUPLEX		equ	2
CAPA_BIGPACKET		equ	4
CAPA_SLAVEDMA		equ	8

;------ Structures ----------------------------------------------------------;
;
; TxStart structure
;
TxStartStruc	struc
txs_thresh	dw	?		; TxStart threshold (+CMD_SETTXSTART)
txs_min 	dw	?		; minimum threshold
txs_uTxOK	dw	?		; TxOK low word at last underrun
txs_uN		dw	?		; number of entries in uSum
txs_uSum	dw	?		; sum of uN x packets between underruns
TxStartStruc	ends

SIZE_TxStart	equ	SIZE TxStartStruc

;
; SelectWindow - select register window specified (must be a constant)
;
; entry:
;   dx = cmd/status port
;
; destroys:
;   ax
;
SelectWindow macro  wno
		mov	ax, CMD_SELECTWINDOW + wno 
		out     dx, ax
endm

;------ GENERAL.INC ---------------------------------------------------------;
;                                                                            ;
;       General purpose equates, structures and macros.                      ;
;                                                                            ;
;----------------------------------------------------------------------------;

FALSE           equ     0
;;TRUE            equ     0ffh
;
; I/O ports for the PICs
;
MASTER_MASK_PORT equ    021h
SLAVE_MASK_PORT equ     0A1h
;
; DOUBLEWORD - Thirty-two bit double word layout for sixteen bit word access
;
doubleword      struc
loword          dw      0               ; low order word
hiword          dw      0               ; high order word
doubleword      ends

;
; FARPOINTER - Thirty-two bit 286-style far pointer layout for segment and
;              offset access
;
farpointer      struc
off             dw      0               ; offset
segm            dw      0               ; segment or selector
farpointer      ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c90x\59x90x.asm ===
title	BootWare Boot PROM (C) Lanworks Technologies Inc.
	subttl	3C59X-90X 
	page	80,132
;===============================================================================
;  59X90X.ASM - produces 3Com 3C59X/3C90X EtherLink PCI version of BootWare
;
;    (C) Lanworks Technologies Inc. 1992 - 1996 All rights reserved.
;
;       No /d   Assemble for 3C59X only
;	/dBW90X	Assemble for 3C90X only
;	/dUNDI	Assemble for NetPC UNDI
;	
;  Revision History - version numbers refer to 59XP.ASM changes only
;
;   970509       RL - Add new functions for NetPC UNDI
;   970303 3.00  RL - Adapted to new AI interface
;   970207 2.10  RL - Modified to adapt the new NID/NAD API changes
;   961029 2.00  RL - Add /dBW90x switch and split the ROM into two separated ones
;   960905 1.81  RL - Fix a bug on BWTable checksum, 2 pages of ROM RD/WR
;   960730 1.80  RL - Add the support for 3c595-T4 & 3c90x
;   960618 1.63  GY - NADChgReceiveMask redo to support broadcast & disable
;   960517 1.62  GY - Autoscan code from ROMTOP is moved here.
;   960328 1.5X  GY - Take out EISA related code (eg EISAV3Conf)
;		    - Use \rom\genr\rpl\src\bwapi.asm
;		    - standardize port access
;		    - eliminate ethernet.inc, netware.inc, general.inc
;		    - clean up macros in vulcan.inc and general.inc
;		    - merge general.inc into vulcan.inc
;		    - clean up BW5X9.INC
;   960129 1.51  GY - use \ROM\GENR\AUTOSCAN\AUTOSCAN and new GENRs
;   950605 1.41  GY - With EISA, need to copy 2nd 16K BootROM into RAM
;   950318 1.00  GY - In NADTransmitPacket, error message pointer is incorrect
;*  950316 1.00  GY - Initial Release
;*==============================================================================
CR		equ	0Dh
LF		equ	0Ah

ASReverseAttr	equ	070h		; Attribute for reverse video
ASNormalAttr	equ	07h		; attribute for normal video

MasterEOIPort 	equ	20h
SlaveEOIPort 	equ	0a0h

FALSE           equ     0
TRUE            equ     0ffh

;
; the number of times through a timed loop to stay off the bus while polling
; for bus master completion to avoid slowing the bus master transfers down
;
Delay3us	equ	8
Delay3ms	equ	01c20h
Delay25ms	equ	0ea60h

InitSTACKPTR	equ	07f00h		; stack pointer for AutoScan Code

T4_PHY_ADDR     equ     01h
NWAY_PHY_ADDR   equ     18h

;BOOTWARE_INTS equ      INT_LATCH + INT_ADAPTERFAIL + INT_RXCOMPLETE + INT_REQUESTED

;-------------------------------------
; Include all general companion files
;-------------------------------------

	.xlist
IFDEF	UNDI
	include	spdosegs.inc
	include	pxe_stru.inc
ELSE
	include \rom\sdk\include\drvseg.inc
	include \rom\genr\include\cui.ext
ENDIF
	include bwnad.inc
	include	vulcan.inc
	.list


IFNDEF	UNDI
public	RunROMTOP
public	InternalConfig
public	WaitEEBusy

;public	HookConfig
				; for CUI...
public	HookEditInput
public	HookHyphen
public	HookEditSpec
public	HookChkChar
public	HookChkInput
public	ErrConfSpace
public	MemBase
public	StoHex			; for 5X9CONF
public	ChkForCfg
public	ChkKey

public	NormalRxEarly
public	CurTxStart

public	eoi_value
public	int_mask_port

public	NADPCIConfig
public	LANOption
public	setchksum
ENDIF

public	IRQLevel
public	HWFilter
public	RxReset
public	TxReset
public	Int_Vector_Loc
public	OrgINTVector_Off
public	OrgINTVector_Seg

;-----------------------------------
; External Data/Variable References
;-----------------------------------

IFDEF	UNDI
	extrn	UNDI_DriverISR:near
ENDIF

	extrn	PCIBusDevFunc:word
	extrn	IOBase:word			; ROMTOP.ASM

IFNDEF	UNDI
	extrn	Start:near

	extrn	PrintErrMsg:near		; 5X9CONF.ASM
	extrn	ErrIRQ7:byte			; 5X9CONF.ASM
	extrn	NormalAttr:byte			; CUI.ASM
	extrn	ReverseAttr:byte		; CUI.ASM

	extrn	elnk3conf:near			; 5X9CONF.ASM
	extrn	Elnk3ConfSparse:byte		; 5X9CONF.ASM
	extrn	ROMCodeStart:word		; ROMTOP.ASM
	extrn	PrintAt:near
	extrn	NADIntFD:near
ENDIF

IFDEF	DEBUG
	extrn	StringAH:byte
	extrn	StringAL:byte
	extrn	StringPCI:byte
ENDIF

IFNDEF	UNDI
; the following structure is template for received lookahead data, it contains
; MAC header and the 1st 18 bytes of IPX Header.

LookAheadBuf_stru  struc
	;
DestAddr      db   6 dup (?)	       ; this part is
SrcAddr       db   6 dup (?)	       ;  MAC header of
LenType       dw   ?		       ;   received packet
;
IpxChkSum     dw   ?		       ; this portion
IpxPktLen     dw   ?		       ;  is the first
IpxTransContr db   ?		       ;   18 bytes
IpxPktType    db   ?		       ;    of IPX
IpxDestNet    db   4 dup (?)	       ;      header of
IpxDestNode   db   6 dup (?)	       ;	received
IpxDestSocket dw   ?		       ;	  packet.
;
LookAheadBuf_stru  ends

LxBufSize     equ  size LookAheadBuf_stru

LookAhead8022	struc
;
DestAddr8022	  db   6 dup (?)	   ; this part is
SrcAddr8022	  db   6 dup (?)	   ;  MAC header of
LenType8022	  dw   ?		   ;   received packet

; 802.2 LLC
DSAP	      db   0
SSAP	      db   0
Control       db   0
;
LookAhead8022	ends
ENDIF

MACHDRSIZE   		equ 	14
ETHADDRSIZE   		equ	6      		; address size

	.386

IFDEF	UNDI
_TEXT		Segment para public
	assume	cs:CGroup, ds:DGroup
ELSE
START_NAD
ENDIF

IFDEF	BW90X
LanOption	db	'3Com 3C90X EtherLink PCI v3.00 (970303)',0
ELSE		
LanOption	db	'3Com 3C59X EtherLink PCI v3.00 (970303)',0
ENDIF

NoNetMsg	db	'Ethernet card improperly installed or not connected.',CR,LF,0
TxMsg		db	'Transmit error                                      ',0

IFNDEF	UNDI
	include \rom\sdk\include\bwnadapi.asm

;----------------- Device Driver Data Definitions --------------------
ErrConfSpace	db	09h,011h,' '
NothingString	db	0

StrEndless	db	013h,0ah,'Reboot system for changes to take effect',0

CfgStr 		db	'Configuring Ethernet Adapter, press Ctrl-Alt-B to modify configuration', 0

;-----------------------------------------------------------------------------
;      V A R I A B L E S
;-----------------------------------------------------------------------------

		   ALIGN     4

LookAheadBufferPtr label     dword
		   dw	     offset LookAheadBuffer
		   dw	     ?

; error messages - note BootWare prefaces them with a CR,LF

IFDEF	BW90X
StrPrompt	db	'Initializing 3C90X EtherLink PCI Adapter',0
ELSE
StrPrompt	db	'Initializing 3C59X EtherLink PCI Adapter',0
ENDIF
BlankStr	db	'                                        ',0

IFDEF	BW90X
Str8022U	db	06h,08h,'BootWare 3C90X supports NetWare, RPL & TCP/IP boot protocols:',0
ELSE
Str8022U	db	06h,08h,'BootWare 3C59X supports NetWare, RPL & TCP/IP boot protocols:',0
ENDIF
		db	09h,0ah,'To configure & save protocol/frame type, type <ENTER>',0
		db	0bh,0bh,'Default boot protocol is NetWare Ethernet_802.2',0
		db	03h,0fh,'This message will appear until boot protocol information is saved.',0
		db	0ffh
StrNull 	db	0


MsgROM64K	db	'Only ROMSize of 64K is supported',0

ErrPressF1		db	'. Press <F1> to continue',0

StrWarnLevel	db	010h,0ah,'Newer BootWare version is available for this adapter.',0
StrFailLevel	db	0bh,0ah,'New EtherLink found. Need new BootWare version.',0

; Msg put here so it won't be on every page
IFDEF	BW90X
MsgUpdateErr	db	06h,0ah,'Unable to update BootWare 3C90X. Configuration changes are not saved.',0
ELSE
MsgUpdateErr	db	06h,0ah,'Unable to update BootWare 3C59X. Configuration changes are not saved.',0
ENDIF

MsgVerifyBad	db	012h,0ah,'BootWare Update verification failed.',0
MsgUpdateOk	db	018h,0ah,'Update Successful ('
MsgUpdateCnt	db	'00)',0
ENDIF

IFDEF	BW90X
MsgVulcanNotFound	db	'Could not find 3C90X', 0
ELSE
MsgVulcanNotFound	db	'Could not find 3C59X', 0
ENDIF

IFDEF	UNDI
NADGetBootInfo	proc	near
NADInitialize	proc	near
NADConfig	proc	near
NADStart	proc	near
		ret
NADStart	endp
NADConfig	endp
NADInitialize	endp
NADGetBootInfo	endp

ELSE
;--------------------------------------------------------------------
; NADGetBootInfo
;
; This function is called at the start of INT19 read the current
; configuration from the ROM.  The configuration is returned in ax.
;
; Values:
;	  1  local boot is default
;	  2  ROMShield enabled
;	  4  config menu enabled
;	 64  floppy drive disabled
;	128  hard drive disabled
;
; Parameters:
;	DS = RAM segment
;
; Returns:
;	ax - boot info
;--------------------------------------------------------------------

		xor	ax, ax
		test	BWTFeature, 1
		jz	no_local
		or	ax,1
no_local:
		test	BWTFeature, 2
		jz	no_rs  
		or	ax,2
no_rs:
		test	BWTFeature, 4
		jnz	no_menu
		or	ax,4
no_menu:
		test	BWTLanOS, 1
		jz	floppy
		or	ax,64
floppy:
		test	BWTLanOS, 2
		jz	hard
		or	ax,128
hard:
		ret

NADGetBootInfo	endp


;--------------------------------------------------------------------
; NADInitialize
;
; Initializes the network adapter and connects the adapter to the
; physical media.
;
; Parameters:
;	AX = PCIBusDevFunc #
;	DX = screen location to dislay initializing string
;	DS = RAM segment
;	ES = ROM Base
;
; Returns:
;	AX = 0 if no error else pointer to fatal error
;--------------------------------------------------------------------
NADInitialize	proc	near

		push	ds
		push	es

		mov	DGroup:PCIBusDevFunc, ax
		mov	ax,es
		mov	ROMBase, ax

		push	cs
		pop	ds
		mov	bx, offset CGroup:StrPrompt
		call	PrintAt

		push	cs
		pop	es

		; Update some init variables (BusType, IOBase, IRQ ...)
		mov	BusType, BUS_PCI

		call	Init_Vulcan		; init vulcan hardware and
						;  variables
		cld
		mov	cx, 6
		mov	di, offset NetAddress
		mov	si, offset BoardID
		rep	movsb

		call	Init_Vulcan2

		mov	LookAheadBufferPtr.segm, cs

		call	HookIntVector

		mov	dx, PortCmdStatus
		SelectWindow WNO_OPERATING		 ; switch to window 1

		xor	ax,ax
NADInitExit:
		pop	es
		pop	ds
		ret

NADInitialize	endp


IFNDEF	UNDI
;--------------------------------------------------------------------
; NADConfig
;
; Displays an optional configuration screen for the user to change
; ROM settings.
;
; Parameters:
;	dx = screen location for initialize string
;	ds = RAM segment
;
; Returns:
;	ax - pointer to configuration message
;--------------------------------------------------------------------
NADConfig	proc	near

		push	ds

		push	cs
		pop	ds
		mov	bx, offset CGroup:BlankStr
		call	PrintAt

		mov	ax, IOBase
		mov	NIC_IO, ax		; copy I/O base to NAD table

		mov	al, IRQLevel
		mov	NIC_IRQ, al		; copy IRQ to NAD table

;		cld
;		mov	cx, 6
;		mov	di, offset CGroup:NetAddress
;		mov	si, offset CGroup:BoardID
;		rep	movsb

;		call   ClearScreen
		xor	ax,ax

		pop	ds
		ret

NADConfig	endp


;--------------------------------------------------------------------
; NADStart
;
; Determine the protocol the ROM is configured, then jump to it.
;
; Parameters:
;	none
;--------------------------------------------------------------------
NADStart	proc near

		call	BuildNADAPI

		mov	al, BWTLANOS
		and	al, BWTLANMASK
		cmp	al, BWTLANRPL
		jnz	NotRPL
		jmp	CGroup:RPLStart

NotRPL:
	 	cmp	al, BWTLANIP
		jnz	NotIP
		jmp	CGroup:IPStart
NotIP:
		jmp	CGroup:NetWareStart

NADStart	endp


;--------------------------------------------------------------------
; NADPCIConfig
;
; Displays configuration screen for the user to change ROM settings.
;
; Parameters:
;	ds = RAM segment
;--------------------------------------------------------------------
NADPCIConfig	proc	near

		push	ds

		mov	al, NormalAttr
		mov	ah, ReverseAttr
		mov	CUIAttr, ax
		mov	NormalAttr, ASNormalAttr
		mov	ReverseAttr, ASReverseAttr

		call	ASConfig		; autoscan config
		mov	NormalAttr, ASNormalAttr
		mov	ReverseAttr, ASReverseAttr
		jnc	ConfigNoUpdate

	; Problem with Phoenix BIOS where SS is required to be
	; the same as CS
	; Assume that NOTHING is on the STACK!!!
;		cli
;		mov	ax, cs
;		mov	ss, ax
;		sti

		call	UpdatePCI_PEROM

	; Problem updating ROM. Just dump error message and let
	; them proceed
		xor	al, al		; Get user to press <ENTER> for acknowledge
		call	PrintErrMsg
		call	ClearScreen
ConfigNoUpdate:
		pop	ds
		ret

NADPCIConfig	endp


;--------------------------------------------------------------------
RomTopExitJmp:
		jmp	RomTopExit	;already init. Never run in RAM.

RunROMTOP:
		pusha
		push	ds
		push	es

		push	cs
		push	cs
		pop	ds
		pop	es

		cld

IFDEF		TSR
		mov	ax, 040h
ENDIF
IFDEF		DEBUG
		int	3
ENDIF
		push	ax


IFDEF		DEBUG
		mov	di, offset CGroup:StringAL
 		call	StoHex

	 	xchg	al, ah
	 	mov	di, offset CGroup:StringAH
	 	call	StoHex

	 	mov	ax, cs
	 	mov	di, offset CGroup:StringCS
	 	call	ROMStoHex

		mov	bx, offset CGroup:StringPCI
		call	PrintMessage

		mov	bx, offset CGroup:ErrPressF1
		call	PrintMessage

ChkF1F2Lp:
		sti			; enable interrupt

		mov	ah, 0		; Read char. Char is removed from buffer
		int	016h		; Keyboard interrupt

		cmp	ah, 3Bh ; <F1> pressed?
		jz	TempCont

		cmp	ah, 3Ch ; <f2> pressed?
		jnz	ChkF1F2Lp

		pop	ax

ASExitEarly:
		pop	es
		pop	ds
		popa
		retf
TempCont:

ENDIF		; DEBUG

		call	GetBusType
		cmp	al, BUS_PCI
		jz	ASPCI

		cmp	al, BUS_EISA_PCI
		jz	ASPCI

		; Bus could be EISA or PCI_EISA
		mov	bx, offset CGroup:MsgVulcanNotFound
		pop	ax
		jmp	AutoScanErr

ASPCI:
IFNDEF		TSR

		pop	ax
		mov	PCIBusDevFunc, ax
		pop	ax
		push	ax			;ROMBase
		mov	ROMBase, ax

		; to save space, OldStackPtr is not used. Replaced by Old MsgIOConflict
		; use our own stack
		mov	word ptr [OldStackPtr], sp
		mov	word ptr [OldStackPtr+2], ss

		call	FindStack
		cli
		mov	ss, ax
		mov	sp, InitSTACKPTR
		sti

ENDIF		; TSR
		push	cs
		pop	ds

		mov	BusType, BUS_PCI
		call	Init_Vulcan		; init vulcan hardware and
						;  variables
		cmp	ax, 0
		jz	Init_VulcanOk


		; Print Message. Can't use the one in CUI because it's not on
		; every page.
		mov	bx, offset CGroup:MsgVulcanNotFound

AutoScanErr:	call	PrintMessage
		mov	bx, offset CGroup:ErrPressF1
		call	PrintMessage

ChkF1Lp:
		sti			; enable interrupt

		mov	ah, 0		; Read char. Char is removed from buffer
		int	016h		; Keyboard interrupt

		cmp	ax, 3B00h	; <F1> pressed?
		jnz	ChkF1Lp

		; restore stack
		mov	ss, word ptr [OldStackPtr+2]
		mov	sp, word ptr [OldStackPtr]

		pop	es
		pop	ds
		popa
		retf

Init_VulcanOk:
		; Make sure ROMSize is set to 64K. Otherwise, print error
		; msg, wait and continue
		mov	bx, offset CGroup:MsgROM64K
		mov	ax, InternalConfig.loword
		and	ax, 0c0h		; consider only bit 6,7
		cmp	ax, 0c0h
		jnz	AutoScanErr

		; Setup PrintAttribute so that color will only be used
		; in Config Facility
;		mov	al, NormalAttr
;		mov	ah, ReverseAttr
;		mov	CUIAttr, ax
;		mov	NormalAttr, ASNormalAttr
;		mov	ReverseAttr, ASReverseAttr

;		call	ASConfig		; autoscan config
;		mov	NormalAttr, ASNormalAttr
;		mov	ReverseAttr, ASReverseAttr
;		jnc	AutoScanNoUpdate

		; Problem with Phoenix BIOS where SS is required to be
		; the same as CS
		; Assume that NOTHING is on the STACK!!!
;		cli
;		mov	ax, cs
;		mov	ss, ax
;		sti

;		call	UpdatePCI_PEROM

		; Problem updating ROM. Just dump error message and let
		; them proceed
;		xor	al, al		; Get user to press <ENTER> for acknowledge
;		call	PrintErrMsg
;		call	ClearScreen

AutoScanNoUpdate:

		push	cs
		pop	ds

IFNDEF		TSR
		; restore stack
		mov	ss, word ptr [OldStackPtr+2]
		mov	sp, word ptr [OldStackPtr]
ENDIF

RomTopExit:
 		pop	es
		pop	ds
		popa

		jmp	Start


;-----------------------------------------------------------------------------
; AutoConfig	Called by Autoscan routine
;
;		Exit:	ax = offset of checksum byte (whole ROM)
;-----------------------------------------------------------------------------
;AutoConfig	proc	near
;		ret
;AutoConfig	endp


;-----------------------------------------------------------------------------
; SetChkSum	Calculate checksum of a specified block of data and
;		write checksum to specified location
;
;		Entry:	ds:si = point to block of data to checksum
;			di = offset in block of data to write checksum
;			cx = length of data to checksum
;		Exit:	checksum ok block of data
;-----------------------------------------------------------------------------
SetChkSum	proc	near
		xor	ax, ax

SetChkSumLoop:
		lodsb
		add	ah, al
		loop	SetChkSumLoop

		neg	ah
		mov	ds:[di], ah		; write checksum

		ret
SetChkSum	endp
ENDIF

;------ GetBusType ----------------------------------------------------------;
;									     ;
;	Identify the type of system we are executing on.		     ;
;									     ;
;	Entry:								     ;
;	cli								     ;
;									     ;
;	Exit:								     ;
;	cli								     ;
;	AL = EISA or PCI or EISA_PCI (also saved in BusType)			     ;
;									     ;
;	Destroys AH, BX, CX, DX, SI, DI.  All other registers are     ;
;	preserved.							     ;
;									     ;
;----------------------------------------------------------------------------;
		public	GetBusType
GetBusType	proc	near

		push	es
; point ES at Real Mode F000:0000
		mov	ax, 0F000h
		mov	es, ax

; to determine if this is an EISA system or not we look for the string "EISA"
; in the ROM at F000:FFD9 thru FFDC.

		mov	ax, 0			; clear BusFlag
		mov	di, 0FFD9h
		cmp	word ptr es:[di][0], 4945h	; "EI"?
		jne	gst_not_eisa
		cmp	word ptr es:[di][2], 4153h	; "SA"?
		jne	gst_not_eisa

		mov	al, BUS_EISA

; for the moment, if its not an EISA system, see if it's PCI

gst_not_eisa:
		push	ax

		; Is machine PCI?
		mov	ax, PCI_FUNCTION_ID shl 8 + PCI_BIOS_PRESENT
		int	1ah
		jc	GetBusRet

		or	ah, ah
		jne	GetBusRet

		cmp	dx, 4350h		; EDX = "PCI "
		jne	GetBusRet

		pop	ax
		add	al, BUS_PCI
		push	ax

GetBusRet:
		pop	ax
		pop	es
		ret
GetBusType	endp
ENDIF

IFDEF	UNDI
	include	nad90x.asm
ENDIF

public		WaitTime
;--------------------------------------------------------------------
; WaitTime - CX has 2*1.1932 the number of microseconds to wait.
;	If CX is small, add 1 to compensate for asynchronous nature
;	of clock.  For example, for 10us, call with CX = 25
;
;  On entry,
;	ints off (especially if CX is small, and accuracy needed)
;  On exit,
;
; 911223 0.0 GK
;--------------------------------------------------------------------
WaitTime	proc	near

		push	ax
		push	bx
		push	cx

		call	ReadTimer0		; get Timer0 value in AX
		mov	bx, ax			; save in BX

ReadTimer0Loop:
		call	ReadTimer0
		push	bx
		sub	bx, ax
		cmp	bx, cx
		pop	bx
		jc	ReadTimer0Loop

		pop	cx
		pop	bx
		pop	ax
		ret

WaitTime	endp


ReadTimer0	proc	near

		mov	al, 6
		out	43h, al 		; port 43h, 8253 wrt timr mode 3
		call	RT0

RT0:
		jmp	short $+2
		jmp	short $+2
		jmp	short $+2
		in	al, 40h 		; port 40h, 8253 timer 0 clock
		xchg	ah, al

		jmp	short $+2
		jmp	short $+2
		jmp	short $+2

		ret

ReadTimer0	endp


;------ ReadEEProm ----------------------------------------------------------;
;									     ;
;	This routine reads a word from the EEProm.  It can only be used      ;
;	once the board has been brought up at a particular IOBase.	     ;
;									     ;
;	Entry:								     ;
;	AL	= EEProm word to read					     ;
;	Window	= 0							     ;
;	DX 	= IOBase
;	cli								     ;
;									     ;
;	Exit:								     ;
;	AX	= that EEProm word					     ;
;	cli								     ;
;									     ;
;	Destroys BX, CX, DX, SI, DI and ES.  All other registers are	     ;
;	preserved.							     ;
;									     ;
;----------------------------------------------------------------------------;
	  	public  ReadEEProm
ReadEEProm	proc    near
		push	dx

; issue an EEProm read command

;		mov    dx, IOBase
;		add    dx, PORT_EECmd_PCI
		add    al, READ_EEPROM
		out    dx, al

; spin until the EEProm busy bit goes off

		call   WaitEEBusy

; fetch the data from the EEProm data register

;960401		add    dx, PORT_EEData - PORT_EECmd
		mov	dx, PortEEData
		in     ax, dx

		pop	dx
		ret
ReadEEProm    endp


;-----------------------------------------------------------------------------
; WaitEEBusy	Poll until the EEPROM_BUSY bit in EECommand Register is cleared
;
; Input:	dx = IOBase+ PORT_EECmd
;		ax = 0 no problem, ax != 0 problem
;-----------------------------------------------------------------------------
WaitEEBusy	proc	near
		push	cx

		mov	cx, 0
WaitEELoop:
		in	ax, dx
		test	ax, EE_BUSY
		jz	WaitEEBusyExit
		loop	WaitEELoop
WaitEEBusyExit: 
		and	ax, EE_BUSY		; only consider bit 15 for Errcode
		pop	cx
		ret
WaitEEBusy	endp


		public	MediaEnable		 ; 10/20/94, cj
MediaEnable	label	word
		dw	MEDIA_JABBERENABLE + MEDIA_LBEATENABLE
		dw	MEDIA_SQEENABLE
		dw	0			; not used
		dw	0
		dw	MEDIA_LBEATENABLE
		dw	MEDIA_LBEATENABLE
		dw	0


;-----------------------------------------------------------------------------
; FindV3PCI
;
; Return	dx = 0		not found
;		     IOBase	found
;		al = IRQLevel
;-----------------------------------------------------------------------------
FindV3PCI	proc	near

		call	PCISearch
		jc	no_pci

IFDEF BW90X
; Check whether bus mastering has been forced off.  If so, set MasterOK to NO
		
	       mov     ah, 0B1h		; PCI BIOS Function
	       mov     al, 009h		; PCI Read Config Word
	       mov     bx, PCIBusDevFunc
	       mov     di, PCIC_COMMAND	; read PCICommand
	       int     1Ah
       
	       test    cx, PCIC_BMENABLE       ; bus mastering enabled?
	       jnz     bm_set
       
	       or      cx, PCIC_BMENABLE       ; force it on
	       mov     ah, 0B1h		; PCI BIOS Function
	       mov     al, 00Ch		; PCI Write Config Word
	       mov     bx, PCIBusDevFunc
	       mov     di, PCIC_COMMAND	; write it back to PCICommand
	       int     1Ah
bm_set:
ENDIF

; PCI device has been found, read IO address from config space

		mov	bx, PCIBusDevFunc
		mov	ax, PCI_FUNCTION_ID shl 8 + READ_CONFIG_WORD
		mov	di, CFGREG_IOBASE
		int	1ah
		jc	no_pci

		and	cx, 0ffe0h			 ; drop last 5 bits
		mov	dx, cx

		mov    ax, PCI_FUNCTION_ID shl 8 + READ_CONFIG_BYTE
		mov    bx, PCIBusDevFunc
		mov    di, CFGREG_INTLINE
		int    1ah
		mov    al, cl

		ret

no_pci: 	xor	dx, dx
		ret
FindV3PCI	endp


;------ PCISearch -----------------------------------------------------------;
;									     ;
;	Attempt to find a match against a PCI adapter.	The caller can	     ;
;	specify the exact busno/slot to check or leave either unspecified    ;
;	in which case a search will be performed among the allowed	     ;
;	busno/slot combinations for a match.				     ;
;									     ;
;	Entry:								     ;
;	cli								     ;
;	Slot  = slot number to search, -1 if not specified		     ;
;	BusNo = bus number to search, -1 if not specified		     ;
;									     ;
;	Exit:								     ;
;	cli								     ;
;	carry = set if no match 					     ;
;	      = clear if a match					     ;
;	BusNo = set for the matching adapter if carry clear		     ;
;	Slot  = set for the matching adapter if carry clear		     ;
;	PCIBusDevFunc = set for the matching adapter if carry clear	     ;
;									     ;
;	All registers are preserved.					     ;
;									     ;
;----------------------------------------------------------------------------;

		public	PCISearch
PCISearch	proc	near

		pusha

;
; Read the PciCommand register to see if the adapter has been activated.  if
; not, pretend we didn't find it
;
		mov	ah, 0B1h		; PCI BIOS Function
		mov	al, 009h		; PCI Read Config Word
		mov	bx, PCIBusDevFunc
		mov	di, PCIC_COMMAND
		int	1Ah
		jc	pcis_no

		test	ah, ah
		jnz	pcis_no


		test	cx, PCIC_IOENABLE	; I/O access enabled?
		jz	pcis_no

		clc
;
; exit with carry flag as set
;
		public	pcis_exit
pcis_exit:
		popa
		ret

;
; no PCI support or adapter not found or failure after found
;
		public	pcis_no
pcis_no:
		stc
		jmp	pcis_exit
PCISearch	endp


;*****************************************************************************
;
;   Init_Vulcan: This routine initializes hardware of Fast EtherLink and
;		 variables required by this driver. The following are
;		 performed in this routine:
;
;		   1. activate adapter
;		   2. determine resource config and enable resources
;		   3. initialze and determine driver variables, tables
;		   4. enable vulcan hardware (txmitter, receiver, xcvr, etc.)
;
;   On Entry:
;
;      ds = es = CGroup
;      sti
;      cld
;
;   On Exit:
;
;      sti
;      ax     = 0, init successful
;	      = offset of an error message indicating type of error
;
;*****************************************************************************

nohardware:	sti
		mov	ax, offset CGroup:MsgVulcanNotFound
		ret

Init_Vulcan	proc	  near

		call	FindV3PCI
		cmp	dx, 0
		jz	nohardware

		mov	DGroup:IOBase, dx
		mov	IRQLevel, al
;;;970808 RL
		call	CalibrateDelay

		mov	cx, 1			; 1us
		call	ComputeDelay
		mov	Delayoneusec.loword, ax
		mov	Delayoneusec.hiword, dx
;;;
;
; initialize IO Port Variables
;
		mov	ax, IOBase
		mov	cx, NumOfPorts
		mov	di, offset DGroup:PortCmdStatus
InitPorts:
		add	[di], ax
		add	di, 2
		loop	InitPorts

		mov	dx, PortCmdStatus
		mov	ax, CMD_SELECTWINDOW+WNO_SETUP	   ;   unload/reload &
		out	dx, ax				   ;	boot PROMs

;		mov	ax, cs
		mov	ax, ds
		mov	es, ax
		mov	di, offset DGroup:BoardID

		mov	dx, PortEECmd
		mov	al, EE_OEM_NODE_ADDR_WORD0
		call	ReadEEProm		  ; read word 0 of node addr
		xchg	ah, al
		stosw

		mov	al, EE_OEM_NODE_ADDR_WORD1
		call	ReadEEProm		  ; read word 1 of node addr
		xchg	ah, al
		stosw

		mov	al, EE_OEM_NODE_ADDR_WORD2
		call	ReadEEProm		  ; read word 2 of node addr
		xchg	ah, al
		stosw
;
; check to make sure the board is visible (ie. no conflict with IOBase).  since
; the PCI adapter doesn't have the EISA manufacturer ID in Window 0 anymore, we
; now use the Window 5 to check this
;
		mov	dx, PortCmdStatus
		SelectWindow WNO_READABLE

		mov	ax, CMD_SETTXSTART + 0
		out	dx, ax

		mov	dx, PortTxStart
		in	ax, dx
		test	ax, ax
		jnz	bind_ioconflict

		mov	dx, PortCmdStatus
		mov	ax, CMD_SETTXSTART + (TXSTART_DISABLED / 4)
		out	dx, ax

		mov	dx, PortTxStart
		in	ax, dx
		cmp	ax, TXSTART_DISABLED
		je	InitTxDisable

bind_ioconflict:
		jmp	nohardware

InitTxDisable:

;-------------------------------------------------------------------------------
;
; read a few things off the board
;
; note: because of the delays required for the EEProm accesses, we're going to
;	have interrupts disabled for a rather long time (hundreds of usec), but
;	since this is only init time, and our only other choice would be to
;	do this resident, we're going to do it anyway.
;

		mov	dx, PortCmdStatus
		SelectWindow WNO_FIFO

		mov	dx, PortResetOptions
		in	ax, dx
		mov	ResetOptions, ax

		mov	dx, PortInternalCfgH
		in	ax, dx
		mov	InternalConfig.hiword, ax

		mov	dx, PortInternalCfgL
		in	ax, dx
		mov	InternalConfig.loword, ax

		mov	dx, PortCmdStatus
		SelectWindow WNO_SETUP

		mov	al, EE_SOFTWARE_CONFIG_INFO
		mov	dx, PortEECmd
		call	ReadEEProm		  ; read software info
		mov	EESoftConfigInfo, ax

		mov	al, EE_SOFTWARE_CONFIG_INFO2
		call	ReadEEProm		  ; read software info 2
		mov	EESoftConfigInfo2, ax

		mov	al, EE_CAPABILITY_WORD
		call	ReadEEProm
		mov	EECapabilities, ax

		mov	al, EE_INT_CONFIG_0
		call	ReadEEProm
		mov	EEIntConfig0,ax

		mov	al, EE_INT_CONFIG_1
		call	ReadEEProm
		mov	EEIntConfig1,ax

		mov	al, EE_CWORD
		call	ReadEEProm		  ; read Compatibility word
		mov	CWord, ax

		mov	al, EE_MII_SELECT
		call	ReadEEProm
		and	ax, EE_MII_SELECT_MASK
		mov	EEMiiPhySelect,ax

; initialize IRQ on 8259 and remap vector to our interrupt service routine

		mov	al, IRQLevel
		call	SetInterruptVector

		mov    ax, 0

init_vulcan_rtn:
		sti
		ret

Init_Vulcan	endp


IFNDEF	UNDI
;--------------------------------------------------------------------------;
; ASConfig	autoscan Configuration Utility for 5X9. Will call Elnk3Conf
;
; Exit		cf	= clear No Change
;			= set	Changes are made
;
;--------------------------------------------------------------------------;
ASConfig	proc	near

  		; Check Fail/Warning Level to see if PROM should
		; dump any messages
		mov	dx, PortEECmd
		mov	al, EE_CWORD
		call	ReadEEPROM

		cmp	ah, LEVEL_FAIL		; is fail level ok?
		jbe	ChkWarnLevel

		call	ClearScreen
		mov	bx, offset CGroup:StrFailLevel
		xor	al, al
		call	PrintErrMsg
		call	ClearScreen

NoConfigJmp:	clc
		jmp	NoConfig

ChkWarnLevel:
		cmp	al, LEVEL_WARNING	; is warning level ok?
		jbe	ChkLevelDone

		call	ClearScreen
		mov	dx, word ptr CGroup:[StrWarnLevel]
		mov	ah, NormalAttr
		mov	bx, offset CGroup:StrWarnLevel+2
		call	PrintMsgLoc

		mov	si, 3			; 3 seconds
		call	ChkKey
		call	ClearScreen

ChkLevelDone:	; 940107 is CFG disabled by BW5X9.EXE ?
		mov	ax, BWTFeature
		test	ax, BWTFEA_CONF
		jnz	NoConfigJmp

; 930916 all 5X9Conf code will be here {
		call   ClearScreen
		call   ChkForCfg
		jnz    NoConfigJmp

		; setup ScreenAttributes
		mov	ax, CUIAttr
		mov	NormalAttr, al
		mov	ReverseAttr, ah

		mov	bx, InternalConfig.hiword
		mov	dx, EESoftConfigInfo

		mov	si, offset BoardID
		mov	di, IOBase
		mov	al, BusType

		call	ELNK3CONF
		jnc	NoConfig

		mov	EESoftConfigInfo, dx

		stc
NoConfig:
		pushf
		call   ClearScreen
		popf
		ret

ASConfig	endp


;--------------------------------------------------------------------------;
; UpdatePCI_PEROM	Update the BootWare Table of the PEROM for PCI V3
;
; Exit		bx  = 0, no problem
;		   != 0, pointer to error Message
;--------------------------------------------------------------------------;
UpdatePCI_PEROM proc	near

		mov	bx, 8
		call	FixRAMWidth

		; find a clean/free extend memory region
		call	FindExtendMemory
		cmp	UseExtendMem, 0
		jnz	ExtendMemFound

UpdateErr:
		mov	bx, offset CGroup:MsgUpdateErr
		jmp	UpdatePEROMExit

ExtendMemFound:
		; Use Word rather than DWord when READing/WRITing to config
		; space so that I can use Periscope to look at it
		; Fetch current Expansion +ROMBase Address so that we can
		; restore it later
		mov	bx, PCIBusDevFunc
		mov	di, PCIC_BIOSROMCONTROL + 2
		mov	ax, PCI_FUNCTION_ID shl 8 + READ_CONFIG_WORD
		int	01ah
		mov	OldPCIROMAddr+2, cx

		; assume bx preserved
		mov	di, PCIC_BIOSROMCONTROL
		mov	ax, PCI_FUNCTION_ID shl 8 + READ_CONFIG_WORD
		int	01ah
		mov	OldPCIROMAddr, cx

		; map BootROM at UseExtendMem.
		mov	cx, UseExtendMem
		mov	bx, PCIBusDevFunc
		mov	di, PCIC_BIOSROMCONTROL + 2
		mov	ax, PCI_FUNCTION_ID shl 8 + WRITE_CONFIG_WORD
		int	01ah

		; assume bx preserved
		mov	cx, 01			; enable ROM
		mov	di, PCIC_BIOSROMCONTROL
		mov	ax, PCI_FUNCTION_ID shl 8 + WRITE_CONFIG_WORD
		int	01ah

		; Update Physical BootROM with the appropriate information
		; Steps:
		; 1. Copy the first 256 bytes from BootROM to Elnk3ConfSparse
		; 2. Verify 1st 2 bytes are 55 AA
		; 3. Update appropriate data
		; 4. Copy data from AutoScanBuffer to BootROM
		; 5. Verify results and retry is necessary

		; First, Copy 256 bytes from BootROM to Elnk3ConfSparse
		; On entry	BX:DI is destination address
		;		DX:SI is source address
		;		CX    is byte count.

		mov	UpdateRetry, 3

UpdateMemRetry:
		cmp	UseExtendMem, 0ah
		jnz	CopyFromExtend

		; Segment A000 Update {
		push	ds
		mov	cx, 40h
		xor	esi, esi
;960529		mov	si, AtmelOffset
		mov	si, ROMCODESTART
		xor	edi, edi
		mov	di, AutoScanBuffer
		mov	ax, 0a000h
		mov	ds, ax
;		rep	movsd
CopyA000Lp1:
		lodsd
		jmp	$+2
		jmp	$+2
		jmp	$+2
		stosd
		loop	CopyA000Lp1
		pop	ds
		jmp	short UpdateChk55AA
		; Segment A000 Update }

CopyFromExtend:
		mov	cx, 010h
		mov	ax, cs
		mul	cx
		mov	bx, dx
		mov	di, ax
		add	di, AutoScanBuffer
		adc	bx, 0

		mov	dx, UseExtendMem
;960529		mov	si, AtmelOffset
		mov	si, ROMCODESTART
		mov	cx, 100h
		call	CopyMemory

UpdateChk55AA:
		; Should at least make sure that AutoScanBuffer
		; contains the 55 AA signature
		mov	bx, offset CGroup:MsgUpdateErr
		mov	di, AutoScanBuffer
		cmp	word ptr [di], 0aa55h
		jnz	UpdateMemRemap

		; Update BWTLANOS, BWTFeature, BWTEthStd
;960529		mov	di, AutoScanBuffer

		mov	al, BWTLANOS
		mov	byte ptr [di+offset BWTLANOS], al

		mov	ax, BWTFeature
		mov	word ptr [di+offset BWTFeature], ax

;970219		mov	ax, BWTEthStd
;		mov	word ptr [di+offset BWTEthStd], ax

;		mov	al, BWTAddrRes
;		mov	byte ptr [di+offset BWTAddrRes], al


		; Calculate checksum of BootROM Table
		xor	cx, cx
		mov	cl, byte ptr cs:[8]
		dec	cl
		mov	si, AutoScanBuffer
		add	si, 8
		add	di, offset BWTChkSum		; di still points to AutoScanBuffer
		call	SetChkSum


		cmp	UseExtendMem, 0ah
		jnz	CopyToExtend

		; Segment A000 Update {
		push	es
		mov	ax, 0a000h
		mov	es, ax
		mov	cx, 20h
		xor	esi, esi
		xor	edi, edi
;960529		mov	di, AtmelOffset
		mov	di, ROMCODESTART
		mov	si, AutoScanBuffer
;		rep	movsd
CopyA000Lp2:
		lodsd
		jmp	$+2
		jmp	$+2
		jmp	$+2
		stosd
		loop	CopyA000Lp2

		mov	cx, Delay25ms
		call	WaitTime

		mov	cx, 20h
CopyA000Lp3:
		lodsd
		jmp	$+2
		jmp	$+2
		jmp	$+2
		stosd
		loop	CopyA000Lp3

		pop	es
		jmp	short UpdateVerify
		; Segment A000 Update }

CopyToExtend:
		; Extend Memory Update {
		; Copy First 256 bytes to Physical BootROM
		mov	cx, 010h
		mov	ax, cs
		mul	cx
		mov	si, ax
		add	si, AutoScanBuffer
		adc	dx, 0

		mov	bx, UseExtendMem
;960529		mov	di, AtmelOffset
		mov	di, ROMCODESTART
		mov	cx, 80h
		call	CopyMemory

		mov	cx, Delay25ms
		call	WaitTime

		mov	cx, 80h
		call	CopyMemory
		; Extend Memory Update }

UpdateVerify:
		mov	cx, Delay25ms
		call	WaitTime

		cmp	UseExtendMem, 0ah
		jnz	CopyToVerify

		; Segment A000 Update {
		jmp	$+2
		jmp	$+2
		jmp	$+2

		push	ds
		mov	cx, 40h
		xor	esi, esi
;960529		mov	si, AtmelOffset
		mov	si, ROMCODESTART
		xor	edi, edi
		mov	di, AutoScanBuffer
		add	di, 100h
		mov	ax, 0a000h
		mov	ds, ax

CopyA000Lp4:
		lodsd
		jmp	$+2
		jmp	$+2
		jmp	$+2
		stosd
		loop	CopyA000Lp4

		pop	ds
		jmp	short UpdateCompare
		; Segment A000 Update }

CopyToVerify:
		; Verify PEROM content
		; es:di points to AutoScanBuffer
		; ds:si points to AutoScanBuffer+100h
		mov	cx, 010h
		mov	ax, cs
		mul	cx
		mov	bx, dx
		mov	di, ax
		add	di, AutoScanBuffer
		adc	bx, 0
		add	di, 100h
		adc	bx, 0

		mov	dx, UseExtendMem
;960529		mov	si, AtmelOffset
		mov	si, ROMCODESTART
		mov	cx, 100h
		call	CopyMemory

UpdateCompare:
		mov	bx, offset CGroup:MsgUpdateOk

		mov	di, AutoScanBuffer
		mov	si, di
		add	si, 100h
		mov	cx, 100h
		repz	cmpsb
		jz	UpdateMemRemap

		mov	bx, offset CGroup:MsgVerifyBad
		dec	UpdateRetry
		jz	UpdateMemRemap

		jmp	UpdateMemRetry

UpdateMemRemap:
		push	bx
		; Restore Expansion ROM Base Adress Register
		mov	bx, PCIBusDevFunc
		mov	cx, OldPCIROMAddr	; Disable ROM first
		mov	di, PCIC_BIOSROMCONTROL
		mov	ax, PCI_FUNCTION_ID shl 8 + WRITE_CONFIG_WORD
		int	01ah

		; assume bx preserved
		mov	cx, OldPCIROMAddr + 2
		mov	di, PCIC_BIOSROMCONTROL + 2
		mov	ax, PCI_FUNCTION_ID shl 8 + WRITE_CONFIG_WORD
		int	01ah

		mov	bx, 0fff7h
		call	FixRAMWidth
		pop	bx

UpdatePEROMExit:
		ret
UpdatePCI_PEROM endp

; Extended memory global descriptor structure:

DESCRIPTOR	STRUC
Dummy		DW	0, 0, 0, 0
GDT_LOC 	DW	0, 0, 0, 0
SourceLimit	DW	0
SourceLoWord	DW	0
SourceHiByte	DB	0
SourceRights	DB	0
SourceInternal	db	0
SourceHiByteHi	db	0
TargetLimit	DW	0
TargetLoWord	DW	0
TargetHiByte	DB	0
TargetRights	DB	0
TargetInternal	db	0
TargetHiByteHi	db	0
Bios		DW	0, 0, 0, 0
Temp		DW	0, 0, 0, 0
DESCRIPTOR	ENDS

GDT		Descriptor <>

;--------------------------------------------------------------------
; FixRAMWidth()
;
;	- When we detect that InternalConfig.ramWidth is byte-wide,
;	  we need to fix an ASIC problem where we cannot
;	  write to the Atmel PEROM. All the odd location bytes are
;	  overwritten with zero
;	- toggle 3C590.InternalConfig.ramWidth between Byte-wide and
;	  Word-wide. Because InternalConfig.ramWidth toggles, we
;	  can't use ramWidth to determine if adapter need Fix
;
; Input 	bx = 8		to change ramWidth to WordWide
;		   = 0fff7h	to change ramWidth to ByteWide
;--------------------------------------------------------------------
FixRAMWidth	proc	near

		; is adapter 3C590, 3C592 or 3C597?
		cmp	BusType, BUS_EISA
		jz	FixRAMWidthNow

		; Goto ConfigSpace DeviceID (offset2) to distinguish
		; between 3C590 and 3C595. CANNOT use PCIStructure
		; in ROM because Award uses BootWare/3C595
		; rather than BootWare/3C590 for the 3C590 adapter.
		push	bx
		mov	bx, PCIBusDevFunc
		mov	di, PCIC_DEVICEID
		mov	ax, PCI_FUNCTION_ID shl 8 + READ_CONFIG_WORD
		int	01ah
		pop	bx
		cmp	cx, PCI_DeviceID
		jnz	FixRAMWidthExit

FixRAMWidthNow:
		; Does version of ASIC contain bug?????????
		mov    dx, PortCmdStatus
		SelectWindow WNO_FIFO
;960401		port	InternalCfgL, CmdStatus
		mov	dx, PortInternalCfgL
		in	ax, dx

		test	bx, 8
		jnz	FixRAMWidthWord

		and	ax, bx
		jmp	short SetRAMWidth

FixRAMWidthWord:
		or	ax, bx

SetRAMWidth:
		out	dx, ax

		mov	dx, PortCmdStatus
		SelectWindow WNO_SETUP

FixRAMWidthExit:
		ret
FixRAMWidth	endp

;--------------------------------------------------------------------
; CopyMemory	Copy block of memory to/from extended memory
;
; On entry	BX:DI is destination address
;		DX:SI is source address
;		CX    is byte count.
;
;	Addresses is 32bit address
;	Assume CS=ES=DS
;--------------------------------------------------------------------
CopyMemory proc near

  	push	di
	push	cx
	mov	di, offset GDT
	mov	cx, (size DESCRIPTOR)/2
	xor	ax, ax
	rep	stosw
	pop	cx
	pop	di

	mov	ax, bx
	mov	bx, OffSet GDT	; address of GDT (es:si)
	mov	[bx].SourceLimit, cx	; set copy size
	mov	[bx].TargetLimit, cx	; set copy size
	mov	[bx].SourceRights, 93h	; set copy rights
	mov	[bx].TargetRights, 93h	; set rights

	mov	[bx].SourceLoWord, si	; set source address lo word
	mov	[bx].SourceHiByte, dl	; set source address LowByte of HighWord
	mov	[bx].SourceHiByteHi, dh ; set source address HighByte of HighWord

	mov	[bx].TargetLoWord, di	; set dest address low word
	mov	[bx].TargetHiByte, al	; set dest address lowbyte of High Word
	mov	[bx].TargetHiByteHi, ah ; set dest address highbyte of high word

	shr	cx, 1			; now cx is word count

	mov	si, bx			; es:si = GDT
	mov	ah, 87h
	int	15h			; move data to/from extended memory

	ret

CopyMemory EndP

;--------------------------------------------------------------------
; FindExtendMemory	- From Top of extended memory, find a region
;			  of extended memory we can use and return the
;			  Most Significant Word of the 32 bit address
;			- verify that the region we choose is unoccupied
;			  by examing the first 128 bytes of the 64K region
;			  and make sure the values are the same
;			- if region is occupied, goto next 64K region
;			  until we reach f000 0000
;
; Return:	ax =  Most Sign. Word of the 32Bit address that ROM code
;			can be copied to
;		   = error
;
;--------------------------------------------------------------------
FindExtendMemory	proc	near

		; Setup AutoScanBuffer
		; ** Elnk3ConfSparse is memory that we will throw away
		;    after AutoScan. Use it as a temporary buffer **
		; 950306 There are 1B0h bytes in Elnk3ConfSparse I can use
		mov	di, offset Elnk3ConfSparse
		inc	di
		and	di, 0fffeh		; make sure Buffer is Word Align
		mov	AutoScanBuffer, di


		; Before using Extended memory, check if A000:0 region is
		; available. Since A000:0 is below 1M, no need to use
		; CopyMemory to verify result
		push	ds
		mov	ax, 0a000h
		mov 	ds, ax
		xor	si, si
		mov	cx, 0ffffh

		lodsb
		mov	ah, al

FindA000Loop:
		lodsb
		cmp	ah, al
		jnz	FindA000

		loop	FindA000Loop

FindA000:	pop	ds

		cmp	cx, 0
		jnz	FindExtendMem

		mov	ax, 0ah
		mov	UseExtendMem, ax
		ret

FindExtendMem:
		mov	ah, 088h
		int	15h

		push	cx
		mov	cx, 040h
		div	cl		; divide by 40 to get starting 32bit
					; address
		xor	ah, ah		; ignore remainder
		add	ax, 020h	; add 1M for conventional RAM &
					; choose 1M above top of ExtendRAM
		mov	UseExtendMem, ax

		; Copy 128 bytes to AutoScanBuffer
		mov	cx, 010h
		mov	ax, cs
		mul	cx
		mov	bx, dx
		mov	di, ax
		add	di, AutoScanBuffer
		adc	bx, 0

		push	bx
		push	di

ExtendMemNextLp:
		pop	di
		pop	bx

		push	bx
		push	di

		mov	dx, UseExtendMem
		xor	si, si
		mov	cx, 080h
		call	CopyMemory

		; Make sure values in the AutoScanBuffer are identical
		;
		mov	cx, 07fh
		mov	si, AutoScanBuffer

		lodsb
		mov	ah, al

ExtendMemChkLoop:
		lodsb
		cmp	ah, al
		jnz	ExtendMemNext		; exit with zf cleared

		loop	ExtendMemChkLoop

FindExtendMemExit:
		mov	ax, UseExtendMem

		pop	di
		pop	bx

		pop	cx
		ret

ExtendMemNExt:
		inc	UseExtendMem		; goto next 64K region
		cmp	UseExtendMem, 0f000h
		jb	ExtendMemNextLp

		mov	UseExtendMem, 0
		jmp	short FindExtendMemExit

FindExtendMemory	endp

;--------------------------------------------------------------------
; FindStack	- From Top of conventional memory, find 1K of RAM
;		  we can use and return the Segment Value
;		- verify that the region we choose is unoccupied by
;		  examing the 1K region (make sure the values are identical)
;		- if region is occupied, goto next 1K region below
;		  until we reach 1000:0
;
; Entry
; Return:	ax = Segment Value of Stack
;
;--------------------------------------------------------------------
FindStack	proc	near
		push	ds
		push	bx
		push	cx
		int	12h
		sub	ax, 020h		; subtract 32K
		mov	cl, 6
		shl	ax, cl			; convert to segment form
		mov	ds, ax			; ES = Stack base

FindStackAgain:
		mov	cx, 07fh		; test 256 bytes
		mov	si, InitStackPtr
		lodsw
		mov	bx, ax

FindStackLoop:
		lodsw
		cmp	bx, ax
		jnz	FindStackNext

		loop	FindStackLoop

		; Carry would be cleared

		; ES is the stack segment!!
		mov	ax, ds
FindStackExit:
		pop	cx
		pop	bx
		pop	ds
		ret

FindStackNext:	mov	ax, ds
		sub	ax, 0800h
		mov	ds, ax

		cmp	ax, 01000h
		jae	FindStackAgain

		; No way. Can't find 1K free anywhere.
		; Just use ROMBase
		mov	ax, cs		; cs = ROMBase
		jmp	short FindStackExit

FindStack	endp
ENDIF


IFDEF	BW90X
;	include		\rom\3com\90x.p\src\new\bw90xp.inc
	include		bw90xp.inc
ELSE
	include		\rom\3com\59x.p\src\new\bw59xp.inc
ENDIF

include		bw5x9.inc

comment %
;---------------------------------------------------------------------------
; HookConfig - called by NWNID's GET_MEM_BASE. Find the RomBase, IOBase
;	       IRQ and DMA to use.
;	     - Build API Jump Table
;	     - Run ELNK3Conf is selected
;	     - setup BWTLANOS and BWTEthStd, ConfigString
;
;	Input:	ds = ROMBase
;	Output: ds = ROMBase
;
; Currently, NetWareStart, RPLStart & TCPStart do not take care
; of Error Condition
;---------------------------------------------------------------------------
HookConfig	proc	near
	
		push	ds
		push	es

		mov	bx, ds
		mov	cs:ROMBase, bx

		push	cs
		pop	ds

		push	cs
		pop	es

		; Update some init variables (BusType, IOBase, IRQ ...)
		mov	BusType, BUS_PCI

		mov	PCIBusDevFunc, ax

		call	ClearScreen
		call	Init_Vulcan		; init vulcan hardware and
						;  variables

IFDEF	DEBUG
		mov	bx, offset NodeID
		call	PrintMessage
ENDIF

     		call	BuildNADAPI

		cld

		push	cs
		pop	ds

		push	cs
		pop	es

		mov	cx, 6
		mov	di, offset NetAddress
		mov	si, offset BoardID
		rep	movsb

		call	Init_Vulcan2

		mov	LookAheadBufferPtr.segm, cs

		call	HookIntVector

		mov	dx, PortCmdStatus
		SelectWindow WNO_OPERATING		 ; switch to window 1

		; if Boot Protocol is changed, change BWTEthStd or
		; BWTLANOS
		mov	al, BWTLANOS
		and	al, BWTLANMASK

		cmp	al, BWTLANRPL
		jnz	NotRPL

		; RPL is actually 802.2 but BWTEthStd has to contain
		; BWTETH8023
		mov	byte ptr [EthProtString+4], '2'

		mov 	ax, offset CGroup:RPLStart
		jmp	ax

NotRPL: 	cmp	al, BWTLANIP
		jnz	NotIP

		; TCPIP !!
		mov	cx, ETHIISTRINGLEN
		mov	di, offset CGroup:EthProtString
		mov	si, offset CGroup:EthIIString
		rep	movsb

		mov 	ax, offset CGroup:TCPStart
		jmp	ax

NotIP:
;970219		mov	ax, BWTEthStd
;		cmp	ax, BWTETHEII
		mov	ax, BWTLANOS
		cmp	ax, 12h
		jb	NotNW_EII

		; NW_EthII !!
		mov	cx, ETHIISTRINGLEN
		mov	di, offset CGroup:EthProtString
		mov	si, offset CGroup:EthIIString
		rep	movsb

		jmp	short BWTBProt

NotNW_EII:	; if PROM is uninit, also assume PROM is 802.2
		cmp	ax, BWTETH8022
		jnz	BWTBProt

NW_8022:
		; NW_802.2 !!
		mov	byte ptr [EthProtString+4], '2'
BWTBProt:
		xor	ax, ax		; should not display error condition
					; NADInitialize will print err msg
					; for us.

		; change Protocol Change code if stack is modified
		pop	es
		pop	ds

		mov 	ax, offset CGroup:NetWareStart
		jmp	ax

HookConfig	endp

%

IFNDEF	UNDI
; ************************************************************************
; HOOKS for CUI.ASM
HookChkChar	proc	near
HookEditInput	proc	near
HookChkInput	proc	near
HookHyphen	proc	near
HookEditSpec	proc	near
		stc
		ret
HookEditSpec	endp
HookHyphen	endp
HookChkInput	endp
HookEditInput	endp
HookChkChar	endp

;----------------------------------------------------------------------
; StoHex - stuff binary AL as 2 hex digits at ES:DI
;
; On entry,
;	AL = binary digit to print as hex
;	ES:DI ptr to string buffer, CLD flag set
; On exit,
;	AX modified, ES:DI ptr to next location in buffer
;
; 920728 1.0 GK adapted from PutHex
;----------------------------------------------------------------------

StoHex	proc	near

	push	ax			; save for lower nibble
	shr	al,1
	shr	al,1
	shr	al,1
	shr	al,1
	call	h_digit
	pop	ax			; now do lower nibble

h_digit:
	and	al,00001111b
	add	al,90h
	daa
	adc	al,40h
	daa
	stosb				; stuff hex digit in buffer
	ret

StoHex	endp

;----------------------------------------------------------------------
; StoDec - stuff AX as CL decimal digits at ES:DI
;
; On entry,
;	AX = number to print as decimal
;	ES:DI ptr to leftmost position of field
;	CL has width of field, will zero-fill
; On exit,
;	AX, CX, DX modified, ES:DI ptr to beyond rightmost position
;
; 920728 1.0 GK adapted from PutHex
;----------------------------------------------------------------------

StoDec		proc	near

		push	ax		; save value
		mov	al, '0'
		mov	ch, 0
		rep	stosb		; fill with zeroes

		mov	cl, 0Ah 	; divide by 10
		pop	ax		; restore value
		push	di		; save ending DI value

StoDecNext:
		xor	dx, dx
		div	cx		; ax, dx rem=dx:ax/reg
		add	dl, 30h 	; '0'
		dec	di
		mov	es:[di], dl
		or	ax, ax
		jnz	StoDecNext

		pop	di		; return with DI pointing after field
		ret

StoDec		endp
ENDIF

;--------------------------------------------------------------------
;
;   SetInterruptVector: this routine determine the mask value for the selected
;			IRQ level and EOI values for both master and slave
;			8259s, remaps IRQ vector to our ISR and save current
;			IRQ vector in case DriverUnhook needs it.  We do not
;			mask on the selected IRQ in this routine, instead, it
;			will be turned on and off as init goes on.
;
;   On Entry:
;	      al = IRQ level
;	      sti
;   On Exit:
;	      sti
;
; 920717 0.0 GK modified, rewrote DOS get/setint calls
;--------------------------------------------------------------------

HookIntVector	proc	near
		push	es

; convert IRQ to interrupt vector number

		mov    al, IRQLevel		    ; al = IRQ level
		mov    ah, 8			    ; IRQ 0-7 => int vector # 08h-0fh
		cmp    al, 8
		jb     int_8tof
	
		mov    ah, (70h-8)		    ; IRQ 8-15 => int vector # 70h-77h
int_8tof:
		add    al, ah			    ; al = int vector number
		cli

; save old interrupt vector

		xor	bx, bx
		mov	es, bx			; ES = 0
		cbw
		mov	bx, ax
		shl	bx, 1
		shl	bx, 1
		les	bx, es:[bx]
		mov	OrgINTVector_Off, bx
		mov	OrgINTVector_Seg, es

; remap int vector to our DriverISR
IFDEF	UNDI
		mov    dx, offset CGroup:UNDI_DriverISR   ; ds:dx = ptr to DriverISR
ELSE
		mov    dx, offset CGroup:DriverISR   ; ds:dx = ptr to DriverISR
ENDIF
		xor	di, di
		mov	es, di			; ES = 0
		cbw
		mov	di, ax
		shl	di, 1
		shl	di, 1

		mov	cs:Int_Vector_Loc, di
	
		mov	ax, dx
		stosw
		mov	ax, cs		;971030
		stosw

		; PCInit (GENR.ASM) will mask out IRQ9. Need to
		; unmask again
		mov	al, IRQLevel		    ; al = IRQ level
		cmp	al, 7
		jbe	HookInt9

		in	al, 0A1h		; get slave PIC mask
		jmp	$+2
		and	al, 0fdh		; unmask int 9
		out	0A1h, al

HookInt9:
		; unmask Interrupt now
		mov    dx, int_mask_port
		in     al, dx

		and    al, IntMaskOnBit
		jmp    $+2

		out    dx, al

		cmp    dx, MASTER_MASK_PORT		  ; are we using IRQ from slave?
		je     HookIntVectorExit		 ; no

		in     al, MASTER_MASK_PORT		  ; yes, turn on cascaded input
		and    al, not 04			  ;  on master 8259
		out    21h, al

HookIntVectorExit:
		pop	es
		sti
		ret

HookIntVector	endp


;-----------------------------------------------------------------------------
;   Driver Unhook
;
;   assumes:
;	     DS is setup
;	     Interrupts are DISABLED
;
;   returns:
;	     interrupt disabled
;	     no registers need to be preserved.
;-----------------------------------------------------------------------------

DriverUnhook  proc near

	       xor    ax, ax
	       mov    es, ax
	       mov    di,word ptr cs:Int_Vector_Loc

	       mov    ax, OrgINTVector_Off
	       or     ax, OrgINTVector_Seg
	       jz     unhook_rtn		;nothing to unhook
	       mov    ax, OrgINTVector_Off
	       mov    es:[di].off, ax
	       mov    ax, OrgINTVector_Seg
	       mov    es:[di].segm, ax

unhook_rtn:
	       ret

DriverUnhook  endp

IFNDEF	UNDI
;----------------------------------------------------------------------------;
;      E I S A	  S U P P O R T    R O U T I N E S
;----------------------------------------------------------------------------;
;------ WriteEEProm ---------------------------------------------------------;
;									     ;
;	This routine writes  a word to the EEProm.  It can only be used      ;
;	once the board has been brought up at a particular IOBase.	     ;
;									     ;
;	Entry:								     ;
;	BL	= EEProm word to write					     ;
;	CX	- Value to write
;	Window	= 0							     ;
;	RealIOBase  = valid						     ;
;	cli								     ;
;									     ;
;	Exit:								     ;
;	cli								     ;
;									     ;
;	Destroys BX, CX, DX, SI, DI and ES.  All other registers are	     ;
;	preserved.							     ;
;									     ;
;----------------------------------------------------------------------------;
public		WriteEEProm
WriteEEProm	proc	near
	push	bx
	push	cx
	push	dx

	; To write a word to EEPROM, sequence of events are
	;	1. Issue Erase/Write Enable Cmd ( Port IOBase+A, Value 30h )
	;	2. Issue Erase Cmd ( Port IOBase+A, Value C0h or Address )
	;	3. Issue Erase/Write Enable Cmd again ( Port IOBase+A, Value 30h )
	;	4. Load data into EEPROM Data Reg ( Port IOBase+C, Value Data )
	;	5. Issue Write Cmd ( Port IOBase+A, Value 40 or Address )
	;
	; Always check if EEPROM Busy bit is cleared
;960401	mov	dx, IOBase
;960401	add	dx, PORT_EECmd
	mov	dx, PortEECmd
	call	WaitEEBusy

	mov	ax, 030h
	out	dx, ax				; issue Erase/Write Enable Cmd

	call	WaitEEBusy

	xor	ax, ax
	mov	al, bl
	add	al, 0c0h
	out	dx, ax				; issue Erase EEPROM Cmd

	call	WaitEEBusy

	mov	ax, 030h
	out	dx, ax				; issue Erase/Write Enable Cmd

	call	WaitEEBusy

	mov	ax, cx
;960401	add	dx, ( PORT_EEData - PORT_EECmd )
	mov	dx, PortEEData
	out	dx, ax				; load data

;960401	add	dx, ( PORT_EECmd - PORT_EEData )
	mov	dx, PortEECmd
	xor	ax, ax
	mov	al, bl
	add	al, 040h
	out	dx, ax

	call	WaitEEBusy

	pop	dx
	pop	cx
	pop	bx
	ret
WriteEEProm    endp


;----------------------------------------------------------------------------;
; NADChgReceiveMask - Called by NAD to change the receive mask of adapter.
;		       Change RxFilter to accept Multicast packets
;
; Input:	    bl	  command
;			  b0: set   = enable
;			      clear = disable
;			  b1: change broadcast mask
;			  b2: change multicast mask
;			  b3: change promiscuous mask (not supported yet)
;
;		    es:di pointer to multicast address (FOUND.Dest_Addr)
;
; no reg. changed
;----------------------------------------------------------------------------;
NADChangeReceiveMask	proc	far

		push	si
		push	dx
		push	ax

		mov	dx, PortCmdStatus

	; For the 3Com Chipset, enabling group address reception implies
	; broadcast reception. 
		test	bl, 2			; want to change Broadcast?
		jnz	NADChgBroad

		test	bl, 4			; want to change Multicast?
		jz	NADChgMaskEnd

NADChgMulti:
		test	bl, 1
		jz	NADChgMultiOff

NADChgMultiOn:
		mov	si, offset NIDGroupAddr
		mov	ax, es:[di]
		mov	ds:[si], ax

		add	si, 2
		add	di, 2
		mov	ax, es:[di]
		mov	ds:[si], ax

		add	si, 2
		add	di, 2
		mov	ax, es:[di]
		mov	ds:[si], ax

		mov	ax, HWFilter
		or	ax, FILTER_MULTICAST
		out	dx, ax
		jmp	short NADChgMaskEnd

NADChgMultiOff:
		mov	ax, HWFilter
		and	ax, NOT FILTER_MULTICAST
		out	dx, ax
		jmp	short NADChgMaskEnd

NADChgBroad:
		test	bl, 1
		jz	NADChgBroadOff

NADChgBroadOn:
		mov	ax, HWFilter
		or	ax, FILTER_BROADCAST
		out	dx, ax
		jmp	short NADChgMaskEnd

NADChgBroadOff:
		mov	ax, HWFilter
		and	ax, NOT FILTER_BROADCAST
		out	dx, ax

NADChgMaskEnd:
		mov	HWFilter, ax

		pop	ax
		pop	dx
		pop	si
		retf

NADChangeReceiveMask	endp


;--------------------------------------------------------------------
; ChkForCfg - prompt for config, wait up to 3s for Ctrl-Alt-B or Ctrl-Alt-Z
;
; On exit,
;	ZF set if user selected config option
;
; 911230 0.0 GK
;--------------------------------------------------------------------
ChkForCfg	proc	near
		push	es

		mov	ax, 0040h
		mov	es, ax			; ES = BIOS segment. For ChkKey

;		mov	al, BWTLANOS
;		and	al, BWTLANMASK
;		cmp	al, BWTLANTRI
;		jnz	NotFirst

		; dump "BootWare/3C5x9 supports NetWare..." string & wait for
		; user input
;		mov	ah, NormalAttr
;		mov	si, offset CGroup:Str8022U
;		call	PrintTemplate

;		mov	si, 8			; 8 seconds
;		call	ChkKey

		; check ah to see if <ENTER> is pressed
;		cmp	ah, 01ch	; ZF
;		jmp	short ChkForCfgExit

NotFirst:
		; dump "Press <CTRL><ALT><B>..." string & wait for user input
;		mov	bx, offset CGroup:StrPrompt
;		mov	dx, word ptr [bx]
;		mov	ah, NormalAttr
;		add	bx, 2
;		call	PrintMsgLoc
		mov	dx, 0
		mov	bx, offset cGroup:CfgStr
		call	PrintAt

		mov	si, 3			; 3 seconds
		call	ChkKey

ChkForCfgExit:
		pop	es
		ret			; ret ZF = 1 if config selected

ChkForCfg	endp

;--------------------------------------------------------------------
; ChkKey - prompt for config, wait up to 3s for Ctrl-Alt-B or Ctrl-Alt-Z
;
; On exit,
;	si  = # of seconds
;	ZF set if user selected config option
;
;	For 802.2U, ax = -1 if timeout
;		    ah = keyboard input (scan code)
;
; 911230 0.0 GK
;--------------------------------------------------------------------

ChkKey		proc	near

ChkKeyLoop1:
		mov	ax, 18		; 18 ticks = 1 second

		mov	cs:MaxTicks, ax
		mov	ah, 0
		int	1Ah			; get current tick value
		mov	cs:StartTick, dx	; save it


ChkKeyLoop:
	mov	ah, 1
	int	016h		; Keyboard interrupt - check keyboard status

	jz	ChkKeyTime	; No char available; Check time

; character available. check if char is Ctrl-Alt-B
; checking kybd status will not remove char from buffer

	mov	ah, 0		; Read char. Char is removed from buffer
	int	016h		; Keyboard interrupt

	cmp	ah, 030h	; "B"
	jz	ChkCtrlAlt	; are Ctrl & Alt keys pressed?

	cmp	ah, 02ch	; "Z"
	jnz	ChkKeyEnd

ChkCtrlAlt:
	mov	al, es:[17h]	; keyboard status flag 1
	and	al, 00001100b	; keep Ctrl and Alt bits
	cmp	al, 00001100b	; were they set?
;	 jz	 ChkKeyEnd	 ; yes, exit with ZF set
	jmp	short ChkKeyEnd ; exit with ZF

ChkKeyTime:
	mov	ah, 0
	int	1Ah			; get current tick
	sub	dx, cs:StartTick
	mov	cs:Curticks, dx
	cmp	dx, cs:MaxTicks
	cmc


	jnc	ChkKeyLoop	; Is 1 second yet ????

	mov	al, '.'
	call	PutChr
	dec	si
	jnz	ChkKeyLoop1

	mov	al, -1
	or	al, al		; ret ZF = 0, timeout

ChkKeyEnd:
		ret
ChkKey		endp


;--------------------------------------------------------------------
; Print
;
; Prints string given by DS:BX at current location.
;
; Parameters:
;	ds:bx - pointer to null terminated string
;
; Returns:
;	nothing
;--------------------------------------------------------------------
public	Print
Print	proc	near

	push	ax			; save ax
	push	si			; save si

	mov	si, bx			; put string address into si

printLoop:
	lodsb				; get a character
	or	al, al			; check for end of line NULL
	je	printDone		; got end of line
	mov	ah, 0Eh
	int	010h			; write TTY
	jmp	short printLoop 	; next char

printDone:
	pop	si			; restore si
	pop	ax			; restore ax
	ret

Print	endp
ENDIF


Int_Vector_Loc		dw	?


IFDEF	UNDI
_TEXT		ends

_DATA		segment	para public
ENDIF
OrgINTVector_Off	dw	0	;save area for original INT vector
OrgINTVector_Seg	dw	0

	even
;------------------------------------------------------------------------------
;	Adapter configuration set by DriverInit during initialization
;------------------------------------------------------------------------------
EEIntConfig0	dw	?		;value of internal config reg
EEIntConfig1	dw	?		;value of internal config reg
EEMiiPhySelect	dw	-1

		even
;
; the various TxStart thresholds, set at INIT time.  must be contiguous and
; MasterTxStart must follow PioTxStart.
;
		even
		public	PioTxStart
PioTxStart	label	word
		rept 4
		TxStartStruc <?, 4, 0, 0, 0, 0>
		endm

		public	AfterTxStart
AfterTxStart	label	word			; marks the end of them

TxFreeMax	dw	?

IntMaskOnBit	db	?
IRQLevel	db	?

		   even

public		BoardID
BoardID 	db	6 dup (0)
LineSpeed	dw	10		;10/100 Mb determined at init

		even

ResetOptions		dw	?
InternalConfig		dd	?

	public	xcvr
xcvr		dw	?		; 10/20/94, cj

OldStackPtr	dw	0		; save Stack Pointer
		dw	0

		   even

PortCmdStatus		dw	0eh	; Win 0	; Command/Status Register

PortBadSsdCount    	label	word	; Win 4
PortTxFree		label	word	; Win 1 
PortEEData  		dw	0Ch	; Win 0 ; EEProm data register

PortMediaStatus		label	word	; Win 4 ; Media type/status
PortRxFree		label 	word	; Win 3	; Rx Free
PortTimer		label	word	; Win 1 ; 
PortEECmd      		dw	0Ah	; Win 0 ; EEProm command register

PortResetOptions  	label 	word	; Win 3 ; ResetOptions
PortPhyMgmt		label	word	; Win 4 ; MII Management 
PortRxStatus		label	word	; Win 1
PortCfgResource 	dw	08h	; Win 0 ; resource configuration

PortNetDiag		label	word 	; Win 4 ; net diagnostic
PortMacControl		label	word	; Win 3 ; MacControl
PortCfgAddress  	dw	06h	; Win 0 ; address configuration

PortFIFODiag		label	word	; Win 4 ; FIFO Diagnostic
PortCfgControl  	dw	04h	; Win 0 ; configuration control

PortInternalCfgH   	label 	word    ; Win 3 ; InternalConfig High
PortProductID   	dw	02h	; Win 0 ; product id (EISA)

PortTxStart		label	word	; Win 5 ; tx start threshold
PortInternalCfgL   	label 	word	; Win 3 ; InternalConfig Low
PortSA0_1  		label	word	; win 2 ; station address bytes 0,1
PortRxFIFO	   	label 	word	; Win 1 ; offset 00
PortTxFIFO	   	label 	word	; Win 1 ; offset 00
PortManufacturer	dw	00h	; Win 0; Manufacturer code (EISA)

; port variables for window 1
PortTxStatus		dw	0bh	; offset 0b

NumOfPorts	equ	( $ - PortCmdStatus )/ 2 

; PCI and Extended Memory Stuff
UseExtendMem	dw	0

OldPCIROMAddr	dw	0
		dw	0

AutoScanBuffer	dw	0

CUIAttr 	dw	0		; Store Screen Attribute for CUI
UpdateRetry	db	3		; times to retry before giving up

 		   ALIGN       4

NormalRxEarly	   dw	     ?		; set RxEarly cmd + threshold

CurTxStart	   dw	     CMD_SETTXSTART+TXSTART_DISABLED

PadBytes	   db	     ?

EESoftConfigInfo	dw	?	; EEPROM word 0d
EESoftConfigInfo2	dw	?
CWord			dw	?	; EEPROM word 0e
EECapabilities		dw	0	; EEPROM word 010h
BusType 		db	?	;

		ALIGN	4
eoi_value	dw	?		; ah = master, al = slave
int_mask_port	dw	?

		ALIGN	4
HwFilter	dw	?
IRQBit			db	?

StartTick	dw	0		; save area for tick value
RxPend		db	0		; b7 set if pending for Rx packet
					;  XXXXX NO XXX  else has rx status (0, 1)
IFNDEF	UNDI
MaxTicks	dw	0		; save area for max ticks
CurTicks	dw	0		; save area for current ticks

TxRetries	db	0		; transmission retry count
DestID		db	6 dup (?)	; save area for destination node ID

StatusMsgFlag	dw	0		; pointer to msg to be printed in DLCStatus

MemBase 		dw	0	; for TCP/IP Generic
					; also used to store OldBWTFeature

		ALIGN	4		; always dword-aligned
LookAheadBuffer    db	     LxBufSize+3 dup (?)   ; receive lookahead buffer

		ALIGN   4
TxEDPtr 	dd	?		; save area for transmit ED
RxEDPtr 	dd	?		; save area for receive ED

		ALIGN     4
public		CliBuffer
CliBufferSize	equ	128
CliBuffer	db	CliBufferSize dup (?)	; ** not needed, may be removed
						; along with other code in init
						; that computes copycli

		even
NIDGroupAddr	db	6 dup(0)	; GroupAddr
;ErrStruct	ErrorStruct < 0, 0, 0 >

;public		APITbl
;APITbl		dw	'WB'            ; start of BootWare API table
;		dw	30 dup (0)	; allocate 60 bytes ?
ENDIF

flag		dw	0

MiiPhyUsed	dw	0
MIIPhyOui	dw	-1
MIIPhyModel	dw	-1
MiiRegValue	dw	-1

MIIPhyAddr	db	0
phyANLPAR	dw	0
phyANAR 	dw	0

LinkDetected	db	0
forcemode	db	0
broadcom	db	0

Calibration	dd	0
Delayoneusec	dd	0

IFDEF	UNDI
_DATA		ends
_BSS	segment
		db	1024 dup(0)

_BSS	ends

ELSE
END_NAD
ENDIF

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c90x\pxe_stru.inc ===
;
NUM_MCADDRS    	Equ	8		; max number of multicast addresses.
MAX_DATABLK    	Equ	8		; max number of data blocks supported 
					;	in a descriptor.
MAX_IMMED_LEN	Equ	64		; max immediate data buffer length
MAX_TX_DATABLK	Equ	MAX_DATABLK	; max number of data blocks supported 
					;	in a Tx descriptor.
MAX_TD_DATABLK	Equ	MAX_DATABLK	; max number of TransferData blocks
		
APIMaxFunc	EQU	0011h

ADDR_LEN	EQU	16
ETH_ADDR_LEN	EQU	6
MAXNUM_MCADDR	EQU	8

;
; protocol values in transmit buffer
;
P_UNKNOWN	EQU	0		;; no media header
P_IP	 	EQU	1		;; IP type
P_ARP		EQU	2		;; ARP type
P_RARP		EQU	3		;; RARP type

TYPE_IP	 	EQU	0800h		;; IP type
TYPE_ARP	EQU	0806h		;; ARP type
TYPE_RARP	EQU	8035h		;; RARP type
;
; xmitflag values in transmit buffer
;
PKT_DESTADDR	EQU 0	;; destination address given 
PKT_BROADCAST	EQU 1h	;; use broadcast address 
PKT_MULTICAST	EQU 2h	;; multicast addr given

;; Hardware type values
ETHER_TYPE 		EQU 1
EXP_ETHER_TYPE	EQU 2
IEEE_TYPE  	EQU 6
ARCNET_TYPE   	EQU 7


Eth_MCastBuf	Struc
MCastAddrCount	DW	?
MCastAddr	DB MAXNUM_MCADDR * ETH_ADDR_LEN dup (0)
Eth_MCastBuf	Ends

MC_MCastBuf		Struc
MC_MCastAddrCount	DW	?
MC_MCastAddr  		DB MAXNUM_MCADDR * ADDR_LEN dup (0)
MC_MCastBuf		Ends

NIC_StartUp	Struc
S_Status	DW	?
S_BusType	DB	?
S_AddrType	DB	?
S_DataSeg	DW	?
S_DataSegAddr	DD	?
S_DataSegSize	DW	?
S_CodeSegSize	DW	?
S_BusDevFunc	DW	?	;; PCI Dev_ID
S_PCI_ds_off	dw	?	;; Far pointer to PCI data structure
S_PCI_ds_seg	dw	?
S_PnP_csn	dw	?	; Card select number.-1 for non-PnP BBS device
S_PnP_eh_off	dw	?	; Far pointer to PnP expansion header
S_PnP_eh_seg	dw	?
NIC_StartUp	Ends

NIC_CleanUp	Struc
CL_Status	DW	?
NIC_CleanUp	Ends

NIC_Initialize	Struc
I_Status	DW	?
I_Prot_ini	DD	?
I_RcvInt	DD	?
I_GenInt	DD	?
NIC_Initialize  Ends

NIC_Reset	Struc
R_Status	DW	?
R_MCBuf		MC_MCastBuf <>
NIC_Reset	Ends

NIC_ShutDown	Struc
SD_Status	DW	?
NIC_ShutDown	Ends

NIC_Open	Struc
O_Status	DW	?
O_OpenFlg	DW	?
O_PktFilter	DW	?
O_MCBuf		MC_MCastBuf <>
NIC_Open	Ends

NIC_Close	Struc
C_Status	DW	?
NIC_Close	Ends

X_DataBlock	Struc
X_TxPtrType	DB	?	; 0 => Phys pointer, 1 => GDT pointer
X_TxRsvdByte	DB	?	; Reservered, must be zero.
X_TxDataLen	DW	?	; Data block length in bytes.
X_TxDataPtr	DD	?	; Far pointer to data block.
X_DataBlock Ends

NIC_TBD		Struc
X_Length	DW	?
X_BufOff	DW	?
X_BufSeg	DW	?
X_DataBlkCount	DW	?		; will always be zero for base code
X_DataBlk	DB	MAX_DATABLK * SIZE X_DataBlock dup (0)	
NIC_TBD		Ends

NIC_Transmit		Struc
T_Status		DW	?
T_Protocol		DB	?
T_XmitFlag		DB	?
T_DestAddrOffset 	DW	?	; 16-bit segment & offset of the
T_DestAddrSegment 	DW	?	; destination media address 
T_TBDOffset		DW	?	; 16-bit segment & offset 
T_TBDSegment		DW	?	; transmit buffer descriptor 
T_Reserved		DD	2 dup(0)	; for future use	
NIC_Transmit Ends

NIC_SetMCastAddr	Struc
SM_Status		DW	?
SM_MCBuf		MC_MCastBuf <>
NIC_SetMCastAddr	Ends

NIC_SetStationAddr	Struc
SS_Status		DW	?
SS_StationAddr		DB	ADDR_LEN dup (0)
NIC_SetStationAddr	Ends

NIC_SetPacketFilter	Struc
SP_Status		DW	?
;;SP_NewFilter		DW  ?
SP_NewFilter		DB  ?
;;SP_MCBuf		MC_MCastBuf <>
NIC_SetPacketFilter	Ends

NIC_GetInfo	Struc
GI_Status		DW	?
GI_BaseIo		DW	?
GI_IntNumber		DW	?
GI_MTU			DW	?
GI_HwType		DW	?
GI_HwAddrLen		DW	?
GI_CurrentNodeAddress	DB ADDR_LEN dup (0)
GI_PermNodeAddress	DB ADDR_LEN dup (0)
GI_ROMAddress		DW 	?
GI_RxBufCt		DW	?
GI_TxBufCt		DW	?
NIC_GetInfo	Ends

NIC_GetNICType_pci 	Struc
Status 		DW	?	; OUT: See PXENV_STATUS_xxx constants */ 
NicType 	DB	?	;  /* OUT: 2=PCI, 3=PnP */
Vendor_ID	DW	?	; /* OUT:  */
Dev_ID		DW	?	;  /* OUT:  */
Base_Class	DB	?	; /* OUT: */
Sub_Class	DB	?	;  /* OUT: */
Prog_Intf	DB	?	;  /* OUT: program interface */ 
Rev		DB	?	;  /* OUT: Revision number */ 
BusDevFunc	DW	?	; /* OUT: Bus, Device & Function numbers */
NIC_GetNICType_pci 	Ends

NIC_GetNICType_pnp 	Struc
Status 		DW	?	; OUT: See PXENV_STATUS_xxx constants */ 
NicType 	DB	?	;  /* OUT: 2=PCI, 3=PnP */
EISA_Dev_ID	DD	?	; /* Out:  */
Base_Class	DB	?	; /* OUT: */
Sub_Class	DB	?	;  /* OUT: */
Prog_Intf	DB	?	;  /* OUT: program interface */
CardSelNum	DW	?	; /* OUT: Card Selector Number */
Res		DB	0	;
NIC_GetNICType_pnp 	Ends

NIC_GetStatistics	Struc
GS_Status		DW	?
GS_XmtGoodFrames	dd    ?
GS_RcvGoodFrames	dd    ?
GS_RcvCRCErrors		dd    ?
GS_RcvResourceErrors	dd    ?
NIC_GetStatistics	Ends

NIC_ClearStatistics	Struc
CS_Status		DW	?
NIC_ClearStatistics	Ends

NIC_InitDiags	Struc
ID_Status	DW	?
NIC_InitDiags   Ends

NIC_ForceInterrupt	Struc
FI_Status		DW	?
NIC_ForceInterrupt	Ends

NIC_GetMCastAddr	Struc
GM_Status		DW	?
GM_InetAddr		DD	?
GM_HwAddr		DB	ADDR_LEN dup (0)
NIC_GetMCastAddr	Ends

;NIC_API_Entry	Struc
;Signature 	DB	'PXENV+'	;; not null terminated
;Version		DW	0100h		;; 1.0
;StrucLength	DB	0		;; length of this structure
;CheckSum	DB	0		;; fill in later
;rm_entry_off	DW	0		;; real mode driver entry offset
;rm_entry_seg	DW	0		;; real mode driver entry segment
;pm_entry_off	DW	0		;; protected mode driver entry offset
;pm_entry_seg	DW	0		;; protected mode driver entry segment
;NIC_API_Entry	Ends

s_PXENV_ENTRY	Struc
signature	db	6 dup(?)	; 'PXENV+'
ver             dw      ?               ; MSB=major, LSB=minor
bytes		db	?		; sizeof s_pxenv_entry
checksum	db	?		; 8-bit checksum of structure,
					; including this byte shoube be zero.
rm_entry_off	dw	?		; 16-bit real-mode segment & offset.
rm_entry_seg	dw	?
pm_entry_off	dw	?		; 16-bit protected mode 32-bit physical
pm_entry_base	dd	?		; address and 16-bit offset.
stack_sel	dw	?		; PROM stack segment.  Will be set
stack_size	dw	?		; to 0 when removed from memory.
base_cs_sel	dw	?		; Base code segment.  Will be set
base_cs_size	dw	?		; to 0 when removed from memory.
base_ds_sel	dw	?		; Base data segment.  Will be set
base_ds_size	dw	?		; to 0 when removed from memory.
mlid_ds_sel	dw	?		; MLID data segment.
mlid_ds_size	dw	?
mlid_cs_sel	dw	?		; MLID code segment.
mlid_cs_size	dw	?
s_PXENV_ENTRY	Ends

;; Ethernet II protocol header
EtherHeader	Struc
E_DestAddr	DB 6 dup (0)	;; destination ethernet addr
E_SrcAddr	DB 6 dup (0)	;; destination ethernet addr
E_Type		DW  ?	;; protocol type
EtherHeader	Ends

ETHER_HEADER_LEN	Equ	SIZE EtherHeader

; 
; * Data structures for TransmitChain (Tx), TransferData (TD)
; 
TxDataBlock	Struc
TxPtrType	DB	?	; 0 => Phys pointer, 1 => GDT pointer
TxRsvdByte	DB	?	; Reservered, must be zero.
TxDataLen	DW	?	; Data block length in bytes.
TxDataPtr	DD	?	; Far pointer to data block.
TxDataBlock	Ends

; 
; * TransmitChain descriptor structure definition
; 
TxBufDesc	Struc
TxImmedLen	DW	?	; Byte count of immediate data, max=64
TxImmedPtr	DD	?	; Virtual address of Immediate data
TxDataCount	DW	?	; Number of Data Blocks (max = 8)
TxDataBlk	DB	size TxDataBlock * MAX_TX_DATABLK dup(0)
TxBufDesc	Ends

TxBufDescrSize	Equ	Size TxImmedLen + Size TxImmedPtr + Size TxDataCount

; 
; * TransferData data block description
; 
TDDataBlock	Struc
TDPtrType	DB	?	; 0 => Phys pointer, 1 => GDT pointer
TDRsvdByte	DB	?	; Reservered, must be zero.
TDDataLen	DW	?	; Data block length in bytes.
TDDataPtr	DD	?	; Far pointer to data block.
TDDataBlock	Ends

; 
; * TransferData descriptor structure
; 
TDBufDesc	Struc
TDDataCount	DW	?	; No of Data Blocks (max 8 for V1.01).
TDDataBlk	DB	size TDDataBlock*MAX_TD_DATABLK dup(0)
TDBufDesc	Ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c90x\bwnad.inc ===
;====================================================================
; BWNAD.INC
;
; Include for for BootWare NAD modules.
;
; 970116 PC - first version
;====================================================================

;--------------------------------------------------------------------
; Include the common structures.
;--------------------------------------------------------------------

IFDEF _IDEAL_
	include "bwstruct.inc"
ELSE
	include bwstruct.inc

ENDIF

;--------------------------------------------------------------------
; NAD publics
;--------------------------------------------------------------------
public	NADGetBootInfo
public	NADInitialize
public	NADConfig
public	NADStart
public	LanOption

IFDEF _IDEAL_
	include "bwequ.inc"
ELSE
	include bwequ.inc

ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c90x\bw5x9.inc ===
;******************************************************************************
; Routines in BW5X9.INC
;  : shared by 3C5X9, 3C59X-PCI and 3C59X-EISA
;
; Modules included:
;  - NADTransmitPacket
;  - DoRxDiscard
;  - SoftRxReset
;  - NADPoll
;  - NADDisengage
;  - Interrupt Service Routines
;  - TxReset
;  - RxReset
;  - RxDiscard
;
; 960618 GY    - Add support for Broadcast
; 960401 GY - Replace some MACROS with code
;        - standardize port access
;******************************************************************************


IFDEF	UNDI
extrn	GETED:near
extrn	MultiCast_Addresses:word
extrn	EDListHead:word
extrn	EDListCurrent:word
extrn	ApiEntry:word
ENDIF


;NADReset proc far
;	ret
;NADReset endp

NADRelocate proc far
	ret
NADRelocate endp

;----------------------------------------------------------------------
;  Routine Name:  NADTransmitPacket Routine
;
;  Description: The NADTransmitPacket Routine accepts all directed
;     send requests from the RIPL ROM NID code.  This
;     routine determines the validity of the request and
;     works with the adapter to carry it out.
;
;  Input:   ES:SI - pointer to ED
;     DS - Data Segment of RPL Module
;     ints disabled (spec says enabled)
;
;  Output:  ED Completion Code field updated
;     DS preserved
;     ints enabled (doesn't matter)
;
;  Calls:   TransmitPacket
;----------------------------------------------------------------------
public   NADTransmitPacket ; for DEBUGGING
NADTransmitPacket  PROC near		;FAR

	push	ds			; save caller ds

;	push	cs
;	pop	ds			; set ds = cs
	mov 	ax, cs:ApiEntry.mlid_ds_sel
	mov	ds, ax

;	mov	word ptr TxEDPtr, si	; save ED pointer
;	mov	word ptr TxEDPtr+2, es

	cld				; Clear direction

	; calc number of bytes needed to pad to dword size
	mov	cx, es:[si].ED_Length	; get total packet length
	mov	bx, cx
	neg	cl
	and	cl, 3
	mov	PadBytes, cl

	cli				; ints off

	mov	dx, PortTxFree
	in	ax, dx
	cmp	ax, bx
	jae	ww

;;;970613
	mov	es:[si].ED_ErrCode, TRANSMIT_ERROR
	jmp	NetSendRet
   		
; write preamble & MAC header to Tx FIFO

ww:
	mov	dx, PortCmdStatus
	mov	ax, 804h
	out	dx, ax
	mov	dx, IOBASE	
	add	dx, 6
	in	ax, dx
	test	ax, 300h
	jz	ww1

ww1:
	sub	dx, 2
	in	ax, dx
	test	ax, 400h
	jz	ww2

ww2:
	mov	dx, PortCmdStatus
	mov	ax, 801h
	out	dx, ax

	mov	dx, PortTxFIFO

	mov	ax, es:[si].ED_Length	; get total packet length
;RL 970626
;	inc	ax
;	and	al, 0feh		; len field in preamble evenized

	or	ah, high TXP_INTONSUCCESS ; generate TxStatus on all completions

	; write preamble
	out	dx, ax			; preamble
	xor	ax, ax
	out	dx, ax			; unused word

	push	si			; save ED offset

;	lds	bx, cs:TxEDPtr
	mov	cx, es:[si].ED_FragCount; get fragment count
	lea	bx, [si].ED_FragOff	; point to first fragment descriptor

Tx_Frag_Loop:
	push	cx			; save fragment count
;	push	ds			; save fragment descriptor list segment
	mov	cx, es:[bx].FragLen	; length of this fragment
	lds	si, es:[bx].DPointer	; location of this fragment
	rep	outsb			; output bytes to adapter

Tx_Frag_End:
;	pop	ds			; restore frag descriptor list segment
	pop	cx			; restore fragment count
	add	bx, size Frag		; next descriptor
	loop	Tx_Frag_Loop		; loop through all fragments

Start_Tx:
;	push	cs
;	pop	ds			; restore cs = ds
	mov 	ax, cs:ApiEntry.mlid_ds_sel
	mov	ds, ax

	mov	cl, PadBytes
	rep	outsb			; pad packet to dword

	pop	si			; restore ED offset

	mov	RxPend, TRUE		; indicate ready for a receive

	; wait for completion, and check for errors
	sti				; ints on again
;	mov	ah, 0			; get current system tick count
;	int	1Ah			; timer services
;	mov	StartTick, dx		; save timer value
		mov	cx, 10000

WaitForEndTx:
		push	cx

	mov	dx, PortTxSTatus
	in	al, dx
	in	al, dx	
	test	al, TXS_COMPLETE  ; done yet?
;!        cmp cGroup:flag, 1
;!        je    TxFinish  
	jnz	TxFinish       ; jump if Tx complete

;	mov	ah, 0		; get current system tick count
;	int	1Ah		; timer services
;	sub	dx, StartTick   ; subtract start time
;	cmp	dx, 5		; 5 ticks time-out
;	jb	WaitForEndTx    ; loop until time-out

		mov	cx, 20
		call	Delay500ns
		pop	cx
		loop	WaitforEndTx

BadConnection:
;!        mov   cGroup:flag, 0  
	mov	RxPend, 0      ; clear Rx flag
	mov	dx, PortCmdStatus
	call	TxReset     ; make sure FIFO is flushed

		; enable the transmitter
	mov     ah, CMDH_TXENABLE
	out     dx, ax

	mov	bx, offset CGroup:NoNetMsg
;	mov	cs:[StatusMsgFlag],bx   ; only for RPL

;	les   si, TxEDPtr

	; set ErrStruct to print msg
	mov	es:[si].ED_ErrMsg, bx   ; should be ES:

	; Set return code to transmit error
	mov	es:[si].ED_ErrCode, TRANSMIT_ERROR

	jmp	short NetSendRet

; copy done, return

TxFinish:
		pop	cx		;971031

;!        mov   cGroup:flag, 0  
	out	dx, al			; pop Tx status
	test	al, TXS_ERRTYPE		; any error bits set?
	jnz	NetSendError

;	les   si, TxEDPtr

	; Set return code to successful
	mov   es:[si].ED_ErrCode, SUCCESSFUL

NetSendRet:
	pop	ds			; restore callers ds
	ret

NetSendError:
;		mov   cs:[StatusMsgFlag], offset CGroup:TxMsg ; only for RPL

	push	ax
;	les	si, TxEDPtr

	; set ErrStruct to print msg
	mov	es:[si].ED_ErrMsg, offset CGroup:TxMsg

	; Set return code to transmit error
	mov	es:[si].ED_ErrCode, TRANSMIT_ERROR
	pop	ax

	mov	RxPend, 0      ; clear Rx flag
	test	al, TXS_UNDERRUN or TXS_JABBERERROR
	jz	NotTxUnderOrJabber

	call	TxReset     ; reset transmitter

	; enable the transmitter
	mov	ah, CMDH_TXENABLE
	out	dx, ax

	jmp	short NetSendRet

NotTxUnderOrJabber:
	; enable the transmitter
	mov     ah, CMDH_TXENABLE
	out     dx, ax

	jmp	short NetSendRet

NADTransmitPacket  ENDP

;------------------------------------------------------------------------------
; packet completed, but RxStatus.Err indicates the packet experienced an error
; during receiving.

ip_bad:
		mov	dx, PortCmdStatus
		call	RxDiscard	; preserve all regs, except ah
		jmp	int_next	; go directly to int_next without
					; updating errcounts (BootWare doesnt
					;   keep count)

;------------------------------------------------------------------------------
; various errors: No ECB, pkt too small, pkt too big, pkt with bad size

ip_bad_llc:
not_eii_pkt:
ip_discard_pkt:

		mov   dx, PortCmdStatus
		call  RxDiscard 
		jmp   int_next    ; dx = port CmdStatus

;--------------------------------------------------------------------
;
;  Rx Complete interrupt.  PIO only.
;
;--------------------------------------------------------------------
; entry:
;   interrupt is disabled at adapter level. (through SetIntMask cmd).
;   EOIs have been issued to PICs.
;   we've not done sti
;
;   dx = port CmdStatus
;   cli
;   cld
;
;--------------------------------------------------------------------

	public isr_RxPIO

isr_RxPIO:
		mov	dx, PortRxStatus
		in	ax, dx			; ax = RxStatus
		test	ah, RXSH_ERROR		; error reported?
		jnz	ip_bad

; get Packet Length from RxStatus register (win 1,port8)
		mov	dx, PortRxStatus
		in	ax, dx			; ax = RxStatus
		and	ax, 07ffh		; keep only last 11 bits

IFDEF UNDI
		call	GetED
ELSE
		call	[AIGetEDJmp]		; get an ED (ES:SI)
ENDIF
		jz	ip_discard_pkt		; we didn't get an ED

		mov	bx, si			; move ED offset to bx
		mov	es:[si].ED_Length, ax	; save length in ED
		mov	cx, es:[si].ED_FragCount; get number of fragments
		lea	bx, [si].ED_FragOff	; point to 1st descriptor

		mov	dx, ax			; move packet size to dx
DRxNxtF:
		push	cx
		push	es
		mov	cx, es:[bx].Dlen	; get fragment length
;		les	di, es:[bx].Dpointer	; get fragment pointer
		mov	ax, ds
		mov	es, ax
		mov	di, word ptr es:[bx].Dpointer	; get fragment pointer
ChkMovSize:
		cmp	dx, cx
		ja	MoveFrag		; more data after this frag

		mov	cx, dx			; no more data after this frag
MoveFrag:
		sub	dx, cx			; subtract size of this frag
		jcxz	DrxDoNxt 		; zero count -- skip data read

		push	dx
		mov	dx, PortRxFIFO
	rep	insb
		pop	dx
DrxDoNxt:
		pop	es
		pop	cx
		add	bx, 6    ; point to next fragment desc
		loop	DRxNxtF  ; do next frag, if any

; -- DX has # of bytes that couldn't fit in receive descriptors

NoRxFrag:
;		push	cs
;		pop	ds			; restore DS = CS

		mov	es:[si].ED_ErrCode, 0	; Set good completion

IFDEF	UNDI
		lea	bx, [si].ED_FragOff	; point to 1st descriptor
;		les	di, es:[bx].Dpointer	; get fragment pointer
		mov	ax, ds
		mov	es, ax
		mov	di, word ptr es:[bx].Dpointer	; get fragment pointer

		cmp	byte ptr es:[di], 01h
		jnz	NoMCastCheck		; not a MC address
		mov	si, offset DGroup:MultiCast_Addresses
		mov	cx, (Eth_MCastBuf ptr [si]).MCastAddrCount
		jcxz	NoMCastCheck		; no MC address

		lea	si, (Eth_MCastBuf ptr [si]).MCastAddr
CheckMC:
		push	cx
		mov	cx, 6		;length of address in byte
	repz	cmpsb
		jcxz	MCastFound	;this is our MC address

		add	si, 6
		pop	cx
		loop	CheckMC
;
; not our MC address, kill the recently saved ED
;
		mov	si, DGroup:[EDListCurrent]	; get current ED
		mov	word ptr [si].ED_Length, 0	;kill the data
		mov	DGroup:[EDListHead], si	; move the head backward
		jmp	DiscardRxData

MCastFound:
		pop	cx
NOMCastCheck:
ELSE
		call	[AIPostEDJmp]		; post the received packet
ENDIF

; we've copied all packet data out of RxFIFO, now discard postamble and any
; pad bytes inserted by hardware.

DiscardRxData:
;		mov   ax, cs
;		mov   ds, ax

		mov	dx, PortCmdStatus
		call	RxDiscard         ; discard padding & postamble

; copy is done, now tell foreground that a packet is available

		jmp    int_next

;--------------------------------------------------------------------
;
; TxReset - reset the transmitter
;
; entry:
;   dx = cmd/status port
;
; destroys:
;   ax
;
;--------------------------------------------------------------------
TxReset     proc  near
IFDEF	BW90X
		mov   ax, CMD_TXRESET
ELSE
		mov   ax, CMD_TXRESET + TXRXRESET_ALLBUTBM
ENDIF
		out   dx, ax

?txrloop:   in      ax, dx
		test  ah, STH_BUSY
		jnz   ?txrloop                    ;; loop while busy

			ret
TxReset     endp

;--------------------------------------------------------------------
;
; RxReset - reset the receiver
;
; entry:
;   dx = cmd/status port
;
; destroys:
;   ax
;
;--------------------------------------------------------------------
RxReset     proc  near
		mov   ax, CMD_RXRESET
		out     dx, ax

?rxrloop:   in      ax, dx
		test    ah, STH_BUSY
		jnz     ?rxrloop                    ;; loop while busy
		ret
RxReset     endp

;--------------------------------------------------------------------
;
; RxDiscard - discard top packet in RxFIFO
;
; entry:
;   ds = DGROUP
;   dx = cmd/status port
;   cli
;
; exit:
;   cli
;
; destroys:
;   ax
;
;--------------------------------------------------------------------
RxDiscard   proc  near

		mov	ax, CMD_RXDISCARD
		out	dx, ax
?rxdloop:
		in	ax, dx
		test	ah, STH_BUSY
		jnz	?rxdloop                    ;; loop while busy
		ret

RxDiscard   endp


;------ DoRxDiscard -------------------------------------------------
;
;  This routine performs an RxDiscard, including the workarounds
;  required by the Rev 1 versions of the ASIC.  It has been made a
;  procedure because the workarounds were getting too ungainly.
;
;  Entry:
;  DS = DGROUP
;  DX = port CmdStatus
;  cli
;
;  Exit:
;  cli
;  Destroys AX.  All other registers preserved.
;--------------------------------------------------------------------

		public   DoRxDiscard
DoRxDiscard proc  near

		mov   dx, PortCmdStatus

; issue the RxDiscard and wait for it to complete

	mov   ah, CMDH_RXDISCARD
	out   dx, ax         ; discard the packet

discard_busy:
	in    ax, dx
	test  ah, STH_BUSY
	jnz   discard_busy       ; loop while busy

; check RxStatus.  if complete, everything is fine--just return.

	mov   dx, PortRxStatus
	in ax, dx

	mov   dx, PortCmdStatus

	ret

DoRxDiscard endp

;------ SoftRxReset -------------------------------------------------
;
;  This routine does an RxReset to clear out the RxFIFO and its
;  associated logic.  After the RxReset, it reenables and restores
;  the current RxFilter and RxEarly thresholds.
;
;  Entry:
;  DS = DGROUP
;  DX = port CmdStatus
;  cli
;
;  Exit:
;  cli
;  Destroys AX.  All other registers preserved.
;
;--------------------------------------------------------------------

		 public SoftRxReset
SoftRxReset   proc   near

	call  RxReset

	mov   dx, PortCmdStatus
	mov   ax, HWFilter      ; has CMD_SETFILTER in it
	out   dx, ax

		; enable the receiver
		mov     ah, CMDH_RXENABLE
		out     dx, ax


	mov   ax, NormalRxEarly ; has CMD_SETRXEARLY in it
	out   dx, ax

	ret
SoftRxReset endp


IFNDEF	UNDI
;----------------------------------------------------------------------
;  Routine Name:  NADPoll Routine
;
;  Description: The NADPoll routine is used by the RIPL ROM NID
;     portion of the RIPL ROM to poll the driver portion so
;     that the driver portion can do timeout work.
;
;  Input:   DS - Data Segment of RPL Module
;     ints enabled
;
;  Output:  DS preserved
;     ints enabled
;
;  Calls:   none
;----------------------------------------------------------------------
NADPoll  proc  far
	retf				; nothing to do...
NADPoll  endp

;----------------------------------------------------------------------
;  Routine Name:  NADDisengage Routine

;  Description: The NADDisengage routine is used by the RIPL ROM NID
;     portion of the RIPL ROM to signal the Network Driver
;     to release its IRQ, DMA, and memory resources.
;
;  Input:   DS - Data Segment of RPL Module
;     ints enabled
;
;  Output:  DS preserved
;     ints enabled
;     ax = offset to error string or 0 if successful
;
;  Calls:   none
;
; July 10,91   implement NIDDisengage version 0.8
;----------------------------------------------------------------------
NADDisengage   PROC  FAR
	push  ds
	push  es

	cli

	; is it RPL ?
	test  cs:BWTLANOS, BWTLANRPL
	jz DisengageRPL

	; change IntFD to point to NADIntFD in ROMTOP.ASM. Depending on
	; the ROMSize, RPLBOOT.SYS might call the IntFD that is not
	; even mapped on the system and hang the machine
	xor   ax, ax
	mov   es, ax
	mov   di, 0FDh*4
	mov   ax, offset CGroup:NADIntFD
	stosw
	mov   ax, cs:ROMBase    ; 940118
	stosw

	; make sure that it works on every page. Int13 should point to NADIntFD
	; also.
	mov   di, 013h*4
	mov   ax, offset CGroup:NADIntFD
	stosw
	mov   ax, cs:ROMBase
	stosw

	push  cs
	pop   es

DisengageRPL:

		; 3Com 5X9 NDIS driver place ISR at IRQ 2 rather than IRQ 9 ( compatability
		; with IBM 3270 program ). Thus, this routine needs to restore the old
		; BIOS IRQ9 handler to invoke IRQ2. Also, this routine should NOT
		; mask IRQ9.

		mov    dx, Int_mask_port
		in     al, dx
	
		or     al, cs:IRQBit
		jmp    $+2

		out    dx, al

		; restore handler
		call  DriverUnhook

		; unmask IRQ 9 again so that interrupt will pass to IRQ2 ISR
		cmp   cs:IRQLevel, 9
		jnz   DisengageExit

		mov   dx, 0a1h
		in al, dx
		and   al, 0fdh
		out   dx, al

DisengageExit:
		pop   es
		pop   ds

		sti
		xor   ax, ax
		retf        ; Return to caller

NADDisengage   endp
ENDIF


;------------------------------------------------------------------
;
; DriverISR:  Interrupt Service Routine for Vulcan
;
;------------------------------------------------------------------

		 public DriverISR
		 public isr_1st_pass
		 public int_next
		 public isr_return
		 public isr_again
		 public isr_enable

		 ALIGN  4
		 db     'ISR'

DriverISR     proc   near

		pusha
		push   ds
		push   es
;		mov    ax, cs
		mov 	ax, cs:ApiEntry.mlid_ds_sel
		mov	ds, ax

		cld
		mov	dx, PortCmdStatus

; make sure the adapter is in window 1, which is where it should always
; be post-init with interrupt enabled

; mask off all interrupts at adapter level. and release the system interrupt

		mov    ax, CMD_SETINTMASK + MASK_ALL
		out    dx, ax           ; disable all interrupts

		; acknowledge interrupt
		mov    ax, CMD_ACKNOWLEDGE + INT_LATCH
		out     dx, ax

		mov	ax, eoi_value          ; ah = EOI for master PIC
						 ; if int < 8, eoi_value = 6040h
						 ;   else eoi_value = 6220h

		cmp	al, 40h             ; Int level < 8 ? (i.e. NOP)
		jz	EOIMaster         ; No, need EOI to Slave PIC

		out	SlaveEOIPort, al          ; al = EOI for slave PIC

		jmp	$+2
		jmp	$+2
		jmp	$+2
		jmp	$+2
		jmp	$+2
		jmp	   $+2

EOIMaster:
		 mov    al, ah           ; send EOI to Master 8259 PIC
		 out    MasterEOIPort, al

;----------------------------------------------------------------------------
; read the reason for the interrupt and dispatch control to the appropriate
; routine through jump table.  When that reason has been handled the routine
; will jump  to int_next.  if there is no reason for the interrupt
; we will simply end up at isr_return. the following types of interrupt
; are handled:
;
;      a. Adapter Failure
;      b. Rx Complete
;      c. Interrupt Request (not supported, ack and return)

		 public isr_1st_pass

isr_1st_pass:
		mov	dx, PortCmdStatus
		in	ax, dx           ; 05-21-92
		jmp	IntDispatch

; there is another interrupt reason.  since we might be close to our disable
; time limit, enable before we handle it.

isr_again:           ; AL has CmdStatus contents

		sti
		nop
		cli

		jmp    IntDispatch

; once the code entered through IntDispatch has completed its task, it jumps
; to this label. check for any remaining reasons.

		public int_next
int_next:
;		mov	ax, cs
;		mov	ds, ax
		mov	dx, PortCmdStatus

		in	ax, dx       ; read status reg see if any
		test	al, al       ; more interrupts to be
		jnz	isr_again       ; serviced?

;-----------------------------------------------------------------------------
; nothing left showing in status.


isr_return:

;----------------------------------------------------------------------------
; reenable interrupts from the adapter.
;
; note: if indications are disabled, they are masked off through the
; ReadZeroMask so reenabling interrupts will have no effect on those bits.

isr_enable:
		cli

		mov   dx, PortCmdStatus
		mov   ax, CMD_SETINTMASK + BOOTWARE_INTS
		out   dx, ax

;950214       port   cs:CmdStatus          ; 03-24-92
		pop   es
		pop   ds
		popa
		iret


DriverISR   endp

; 3Com's driver used a 128-word jmp table - faster, but too much room for us...

IntDispatch:            ; prioritized dispatch (err, Rx, Tx)
		test	al, INT_ADAPTERFAIL
		jz	IntNotFail
		jmp	isr_AdapterFailure

IntNotFail:
		test	al, INT_RXCOMPLETE
		jz	IntNotRxComplete
		jmp	isr_RxPIO

IntNotRxComplete:
		test	al, INT_TXCOMPLETE   ; shouldn't happen, only if cable
					; not connected
		jz	IntNotTxComplete

		mov	dx, PortTxStatus
		in	al, dx
		cmp	al, 0C0h
		jne	xx
		mov	flag, 1
xx:
		out	dx, al         ; pop tx status to turn the bit off
		mov	dx, PortCmdStatus
		mov	ax, CMD_ACKNOWLEDGE + 4
		out	dx, ax
		jmp	int_next

IntNotTxComplete:
		test	al, INT_REQUESTED
		jz	isr_return

isr_IntRequest:
		; acknowledge interrupt
		mov	ax, CMD_ACKNOWLEDGE + INT_REQUESTED
		out     dx, ax

		jmp   isr_return     ; Solve mysterious problem with V2

;--------------------------------------------------------------------
;
;  Adapter Failure interrupt.
;
;--------------------------------------------------------------------
; entry:
;   interrupt is disabled at adapter level. (through SetIntMask cmd).
;   EOIs have been issued to PICs.
;   we've not done sti
;
;   dx = port CmdStatus
;   cli
;   cld
;
; description:
;
;   Three possible reasons that force adapter to generate Adapter
;   Failure Interrupt are:
;
;        1. Rx DMA Trouble (DMA is enabled on a non-dword boundary)
;        2. Rx Underrun
;        3. Tx Overrun
;
;   Diagnostics Register offset 4, window 4 contains information of
;   what causes this interrupt.  Since this interrupt will hardly
;   be generated if software and hardware work properly, we should
;   not see it happen.
;
;   For the moment the only conditins we attempt any workaround for is
;   RxUnderrun and TxOverrun.  For RxUnderrun, we simply reset the
;   receiver by calling SoftRxReset.  For TxOverrun, we simply reset
;   the transmitter and start things going again.
;
;   Other than that, we do not attempt any workarounds to get the board
;   up and running again.  We simply die a graceful death in as little
;   code space as possible.
;
;--------------------------------------------------------------------

		 public isr_AdapterFailure

isr_AdapterFailure:
		mov	dx, PortCmdStatus
		SelectWindow WNO_DIAGNOSTICS        ; switch to window 4

		mov	dx, PortFIFODiag
		in	ax, dx

		mov	dx, PortCmdStatus
		test	ax, FIFOD_RXUNDERRUN
		jz	chk_tx_overrun

; RxUnderrun.  ASIC (rev 1) adapter failure int. due to a false RxUnderrun.
; we just call SoftRxReset to reset the receiver and return to int_next as
; a software workaround to a hardware problem.

		 public AdapterFailure_Rxunderrun

AdapterFailure_Rxunderrun:
		SelectWindow WNO_OPERATING

		mov   dx, PortCmdStatus
		call   SoftRxReset

		jmp    int_next

chk_tx_overrun:
		test   ax, FIFOD_TXOVERRUN
		jz     ia_shutdown

; TxOverrun.  Probably a software error, but since its probably on the back end
; of the TxFIFO and the error shuts down the transmitter, we won't have sent
; any bad packets yet (with rev 1 silicon).  Reset the transmitter and start
; things up again.

		public AdapterFailure_TxOverrun

AdapterFailure_TxOverrun:
		call  TxReset

		mov    ax, CurTxStart
		out    dx, ax

		; enable the transmitter
		mov     ah, CMDH_TXENABLE
		out     dx, ax


;		SelectWindow WNO_OPERATING

; shut off the transmitter and receiver
		public ia_shutdown

ia_shutdown:
IFNDEF	UNDI
		SelectWindow WNO_OPERATING

		; Tx Disable
		mov     ah, CMDH_TXDISABLE
		out     dx, ax

				; Disable the receiver
		mov     ah, CMDH_RXDISABLE
		out     dx, ax

; disable additional interrupts from the adapter

		mov    ax, CMD_SETRZMASK + MASK_ALL
		out    dx, ax
ENDIF
		jmp    int_next
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c90x\bwequ.inc ===
;--------------------------------------------------------------------
; BootWare Table variables
;--------------------------------------------------------------------
;extrn	BWTLANOS:byte			; ROMTOP.ASM
;extrn	BWType:byte			; ROMTOP.ASM
;extrn	BWTCpyRAM:word			; ROMTOP.ASM
;extrn	BWTFeature:word 		; ROMTOP.ASM
;extrn	BWTEthStd:word			; ROMTOP.ASM
;extrn	BWTAddrRes:byte 		; ROMTOP.ASM  ; GK 970126
;extrn	BWTChkSum:byte			; ROMTOP.ASM

;extrn	RomBase:word			; autoscan.asm

;extrn	PrintAt:near			; common.asm
;extrn	ChangeTitleAttrib:near

;--------------------------------------------------------------------
; Protocol starting functions
;--------------------------------------------------------------------
;extrn	NetWareStart:near
;extrn	RPLStart:near
;extrn	IPStart:near

;--------------------------------------------------------------------
; EQUATES
;--------------------------------------------------------------------

; NAD Return Codes
SUCCESSFUL		EQU	0000h
REQUEST_QUEUED		EQU	0002h
OUT_OF_RESOURCE 	EQU	0006h
INVALID_PARAMETER	EQU	0007h
INVALID_FUNCTION	EQU	0008h
NOT_SUPPORTED		EQU	0009h
HARDWARE_ERROR		EQU	000ah
TRANSMIT_ERROR		EQU	000bh
NO_SUCH_DESTINATION	EQU	000ch
HARDWARE_NOT_FOUND	EQU	0023h
HARDWARE_FAILURE	EQU	0024h
CONFIGURATION_FAILURE	EQU	0025h
INTERRUPT_CONFLICT	EQU	0026h
INITIALIZATION_FAILED	EQU	0028h
RECEIVE_TIMEOUT 	EQU	0080h		; Rx2 in NetWare
GENERAL_FAILURE 	EQU	00ffh

; definition for BWTEthStd
BWTETH8023	equ	0
BWTETH8022	equ	1
BWTETHSOFT	equ	2
BWTETHEII	equ	1500		; if BWTEthStd >1500, then E_II
BWTETH8137	equ	08137h
;BWTETH800	equ	0800h		; used for tcp/ip bootp
;BWTETH806	equ	0806h		; used for tcp/ip bootp/arp

; definition for BWTLANOS
BWTLANNW	equ	010h
BWTLANRPL	equ	020h
BWTLANIP	equ	040h
BWTLANMASK	equ	0F0h
BWTLANTRI	equ	070h
BWTLANLOCAL	equ	3h		; Bit 0,1

; definition for BWTFEATURE
BWTFEA_DEFAULT	equ	1
BWTFEA_RS	equ	2
BWTFEA_CONF	equ	4

MasterEOIPort	equ	20h
SlaveEOIPort	equ	0a0h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c90x\nad90x.asm ===
page	,132
;************************************************************************
;* NAD90X.ASM
;*	- Contains modules supporting the NetPC UNDI API for 3c90x
;*
;* Modules included :-
;*	NADInit
;*	NADReset
;*	NADShutDown
;*	NADOpen
;*	NADClose
;*	NADSetFilter
;*	NADGetStatistics
;*	NADRequestINT
;*	NADMCastChange
;*	DriverISR_Proc
;*
;************************************************************************

.xlist


public	NADInit
public	NADReset
public	NADShutDown
public	NADOpen
public	NADClose
public	NADSetFilter
public	NADGetStatistics
public	NADRequestINT
public	NADMCastChange
public	DriverISR_Proc

public  NADSetMACAddress       ; * NEW
public  NADInitiateDiags       ; * NEW

extrn	IRQNumber:byte
extrn	Net_Address:byte
extrn	Node_Address:byte
extrn	MultiCast_Addresses:word

.list
	.386
;================
NADSetMACAddress	proc	near		; NEW

		push	di
		mov	di, offset DGroup:Node_Address
		mov	eax, dword ptr [si]
		mov	dword ptr ds:[di], eax
		mov	ax, word ptr [si+4]
		mov	word ptr ds:[di+4], ax
		xor	ax, ax
		pop	di
		ret

NADSetMACAddress	endp

;
;================
NADInitiateDiags	proc	near		; New

		stc
		ret

NADInitiateDiags	endp


;=========================================================================
; NADInit
;=========
;	- Initializes the adapter but does not enable the Tx and Rx units
;	- Hook receiving ISR
;
; Parameters:
;
; Return:	If CF = 0 then success,
;		else failure with  AX = 1 -> hardware failure
;			           AX = 2 -> media failure
;
; Remark:	Don't hook INT if this function fails
;=========================================================================
NADInit 	proc	near

;		push	ds
		push	es

;		mov	ax, cs
		mov	ax, ds
		mov	es, ax

		call	Init_Vulcan		;init vulcan hardware and
						;  variables, IOBase, IRQLevel
		or	ax, ax
		jnz	NADInitErr

		mov	al, IRQLevel
		mov	DGroup:IRQNumber, al

		cld
;		mov	cx, 6
;		mov	di, offset DGroup:NodeAddress
;		mov	si, offset DGroup:BoardID
;	rep	movsb

		mov	cx, 6
		mov	di, offset DGroup:Net_Address
		mov	si, offset DGroup:BoardID
	rep	movsb

		call	Init_Vulcan2

		cmp	LinkDetected, 0
		jz	no_media

		mov	dx, PortCmdStatus
		mov	ax, CMD_STATSENABLE
		out	dx, ax			;enable statistics counters

		call	HookIntVector

		mov	dx, PortCmdStatus
		SelectWindow WNO_OPERATING		 ; switch to window 1

		clc
		jmp	NADInitx

no_media:
		mov	ax, 2
		jmp	initerr
NADInitErr:
		mov	ax, 1
initerr:
		stc
NADInitx:
		pop	es
;		pop	ds
		ret

NADInit 	endp


;=========================================================================
; NADReset
;==========
;	- Reset and Reinitialize the adapter
;	- Enables the Tx and Rx units
;
; Parameters:
;
; Return:	carry set if failure
;=========================================================================
NADReset	proc	near

		call	Init_Vulcan2

		mov	dx, PortCmdStatus
		mov	ax, CMD_STATSENABLE
		out	dx, ax			;enable statistics counters

		clc
		ret

NADReset	endp


;=========================================================================
; NADShutDown
;=============
;	- reset the adapter and enables
;	- unhook our ISR
;
; Parameters:
;
; Return:	carry set if failure
;=========================================================================
NADShutDown	proc	near

		mov	dx, PortCmdStatus
		xor	ax,ax			   ; global reset
		out	dx,ax
GResetWait:
		in      ax, dx
		test    ah, STH_BUSY
		jnz	GResetWait		   ; loop while busy
;;;
		call	DriverUnhook

		mov	ax, IOBase
		mov	cx, NumOfPorts
		mov	di, offset DGroup:PortCmdStatus
KillPorts:
		sub	ds:[di], ax
		add	di, 2
		loop	KillPorts

		clc
		ret

NADShutDown	endp


;=========================================================================
; NADOpen
;=========
;	- Enables the Tx and Rx units
;
; Parameters:
;
; Return:	carry set if failure
;=========================================================================
NADOpen 	proc	near

		mov	dx, PortCmdStatus
		call	TxReset
		
		mov	ax, CMD_TXENABLE
		out	dx, ax			;enable Tx

		mov	ax, CMD_RXENABLE
		out	dx, ax			;enable Rx

		clc
		ret

NADOpen 	endp


;=========================================================================
; NADClose
;==========
;	- Disables the Tx and Rx units
;
; Parameters:
;
; Return:	carry set if failure
;=========================================================================
NADClose	proc	near

		mov	dx, PortCmdStatus
		mov	ah, CMDH_TXDISABLE
		out	dx, ax			;disable Tx
		mov	ah, CMDH_RXDISABLE
		out	dx, ax			;disable Rx

		clc
		ret

NADClose	endp


;=========================================================================
; DriverISR_Proc
;================
;	- ISR procedure to be called by UNDI_DriverISR
;
; Parameters:	DS = DataSeg
;
; Return:	CF = a if not our int
;=========================================================================
DriverISR_Proc	proc	near

		mov	dx, PortCmdStatus
		SelectWindow WNO_OPERATING
;
; check whether our board caused the interrupt
;
		in	ax, dx			; AL=Interrupt Reasons
		test	al, INT_LATCH
		jnz	isr_ours
not_ours:
		stc
		ret

isr_ours:
		pushf
		push	cs
		call	DriverISR	;a near call with IRET
		clc
		ret

DriverISR_Proc	endp


;=========================================================================
; NADSetFilter
;==============
;	- Change the rx unit's filter to a new one
;	- Handle the promiscuous/broadcast/multicast mode for the
;		rx unit accordingly if necessary
;
; Parameters:	AX = filter value, 1 = directed/multicast
;				   2 = broadcast
;				   4 = promiscuous
; Return:	carry set if failure
;=========================================================================
NADSetFilter	proc	near

		push	ax
		mov	dx, PortCmdStatus
		mov	ah, CMDH_RXDISABLE	;disable Rx
		out	dx, ax
		pop	ax

		shl	al, 1
		test	al, 00000010b
		jz	go_set_filter
		or	al, 00000001b	;set bit 0 if bit 1 is set
go_set_filter:
		mov	ah, CMD_SETRXFILTER/256
		mov	HWFilter, ax
		out	dx, ax
;
; if the filter setting was non-zero, enable the receiver.  otherwise, disable
; the receiver.
;
		test	al, al			; zero filter?
		jz	SetFilterEnd
;
; handle multicast addresses here if necessary
;
		mov	ah, CMDH_RXENABLE	;enable Rx
		out	dx, ax			;set Rx unit
SetFilterEnd:
		clc
		ret

NADSetFilter	endp


;=========================================================================
; NADGetStatistics
;==================
;	- Read the adapter's statistics
;
; Parameters:	ds:si points to variables holding the result
;			TxGoodFrames	dd	0	;1
;			RxGoodFrames	dd	0	;2
;			RxCRCErrors	dd	0	;3
;			RxDiscarded	dd	0	;3
;		ax = 0 means get the result
;		   = 1 means clear the statistics
;
; Return:	Carry clear if data obtained successfully
;=========================================================================
NADGetStatistics	proc	 near

		push	dx
		push	ax

		mov	dx, PortCmdStatus
		SelectWindow WNO_STATISTICS

		pop	ax
		or	ax, ax
		jz	get_data
		
		xor	ax, ax
		add	dx, 6			;PORT_TXFRAMES
		out	dx, al

		mov	dx, PortCmdStatus
		add	dx, 7			;PORT_RXFRAMES
		out	dx, al

		mov	dx, PortCmdStatus
		add	dx, 5			;PORT_RXDISCARDED
		out	dx, al
		
		jmp	short GetStatRet

get_data:
		xor	eax, eax
		add	dx, 6			;PORT_TXFRAMES
		in	al, dx
		mov	dword ptr [si], eax
		add	si, 4

		mov	dx, PortCmdStatus
		add	dx, 7			;PORT_RXFRAMES
		in	al, dx
		mov	dword ptr [si], eax
		add	si, 4

		mov	dword ptr [si], 0
		add	si, 4

		mov	dx, PortCmdStatus
		add	dx, 5			;PORT_RXDISCARDED
		in	al, dx
		mov	dword ptr [si], eax

GetStatRet:
		mov	dx, PortCmdStatus
		SelectWindow WNO_OPERATING
		pop	dx

		clc
		ret

NADGetStatistics	endp


;=========================================================================
; NADRequestINT
;================
;	- Generate an interrupt to the host
;
; Parameters:
;
; Return:
;=========================================================================
NADRequestINT	proc	near

		mov	dx, PortCmdStatus
		mov	ax, CMD_REQUESTINT
		out	dx, ax
		ret

NADRequestINT	endp


;==========================================================================
; NADMCastChange
;================
;	- Modify the multicast buffer to receive the multicast addresses
;	  listed in the multicast table.
;         Each entry in the multicast table is as follows:
;                 Bytes 0-5 = Multicast Address
;         All addresses are contiguous entries
;
; Parameters:	CX =  Number of multicast entries.
;               ES:SI -> Multicast Table.
;
; Return:	All registers may be destroyed.
;==========================================================================
NADMCastChange	proc	near

		push	ds

;		mov	dx, PortCmdStatus
;		mov	ax, CMD_RXDISABLE
;		out	dx, ax			;disable Rx

		push	ds
		push	es
		pop	ds		;ds:si -> mc table
		pop	es		;es = ds

		cmp	cx, MAXNUM_MCADDR
		jbe	MCsave
		mov	cx, MAXNUM_MCADDR
MCsave:
		lea	di, DGroup:MultiCast_Addresses
		mov	(Eth_MCastBuf ptr es:[di]).MCastAddrCount, cx
		jcxz	MC_SaveDone
;
; copy addresses from ds:si to es:di
;
		lea	di, (Eth_MCastBuf ptr es:[di]).MCastAddr
MC_SaveLoop:
		mov	eax, dword ptr [si]
		mov	dword ptr es:[di], eax
		mov	ax, word ptr [si+4]
		mov	word ptr es:[di+4], ax

		add	si, ADDR_LEN		; each unit is 16 bytes long
		add	di, ETH_ADDR_LEN
		loop	MC_SaveLoop
MC_SaveDone:
		pop	ds

;		mov	dx, PortCmdStatus
;		mov	ax, CMD_RXENABLE
;		out	dx, ax			;enable Rx

		lea	si, DGroup:MultiCast_Addresses
		mov	cx, (Eth_MCastBuf ptr [si]).MCastAddrCount
		lea	si, (Eth_MCastBuf ptr [si]).MCastAddr

		clc
		ret

NADMCastChange	endp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c90x\pci.inc ===
;************************************************
;*	PCI Config Space Header Register	*
;************************************************
PCI_VENDOR_ID_REG	EQU	0
PCI_DEVICE_ID_REG	EQU	2
PCI_COMMAND_REG		EQU	4
PCI_STATUS_REG		EQU	6
PCI_REV_ID_REG		EQU	8
PCI_CLASS_CODE_REG	EQU	9
PCI_HEADER_TYPE_REG	EQU	0EH
PCI_BASE_ADDR_REG	EQU	10H
PCI_ROM_BASE_ADDR	equ	30H

;*************************************
;*	PCI BIOS Function ID's	     *
;*************************************
PCI_FUNCTION_ID         EQU     0B1H
PCI_GET_BIOS	        EQU     01H
PCI_FIND_DEVICE     	EQU     02H
PCI_FIND_CLASS_CODE	EQU	03H
PCI_READ_CONFIG_BYTE	EQU	08H
PCI_READ_CONFIG_WORD	EQU	09H
PCI_READ_CONFIG_DWORD   EQU     0AH
PCI_WRITE_CONFIG_WORD	EQU	0CH
PCI_WRITE_CONFIG_DWORD	EQU	0DH
PCI_GET_INT_ROUTING	EQU     0EH
PCI_DEVICE_NOT_FOUND    EQU     86H
PCI_SUCCESSFUL          EQU     00H

;**********************************
;*	PCI Class Code Data	  *
;**********************************
NETWORK_ETHERNET	EQU	020000H
NETWORK_TOKEN_RING	EQU	020100H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c90x\spdosegs.inc ===
; Modifications:   $Header: /Client Boot/NICS/3Com/3C90x/UNDI/SPDOSEGS.INC 1     17/07/98 5:08p Dmitry Klimenko $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;
;   Description: segment declaration and ordering for NDIS driver
;-----------------------------------------------------------------------
; Functional Description
;
;   This file defines the segments used by a MAC driver and the order
;   in which they are loaded. The groups DGROUP (for data) and CGROUP
;   (for code) are also defined, as are macros to open and close
;   segments (which also set up the default segment assumptions).
;-----------------------------------------------------------------------
; DOS segment definitions and ordering.
;==========================================================================
Ifdef DRV
DevHeaderSeg   segment para public USE16 'CODE'
DevHeaderSeg   ends
Endif	
;--------------------------------------------------------------------------
; Resident Code segment - code that is used after init time
; (unfortunately, this includes code to bind another driver, and
; initializations that take place at bind time) should be placed in this
; segment.
;--------------------------------------------------------------------------
_TEXT       segment para public USE16 'CODE'
_TEXT       ends

Ifdef DRV
ICODE       segment para public USE16 'INIT'
ICODE       ends
ENDIF	
;--------------------------------------------------------------------------
; Resident Data segment - things put here will remain in memory after
; init time. At the present time, this is in low memory, so data that is
; not used after init time should NOT be put in this segment.
;--------------------------------------------------------------------------
_DATA       segment para public USE16 'DATA'
_DATA       ends

Ifdef DRV
_BSS       segment para public USE16 'DATA'
_BSS       ends
IDATA       segment para public USE16 'DATA'
IDATA       ends
Else
_BSS       segment para public USE16 'BSS'
_BSS       ends
ENDIF
;--------------------------------------------------------------------------
; Make sure the segment order defined in this file is respected.
;--------------------------------------------------------------------------
.SEQ               
;--------------------------------------------------------------------------
; DOS Group is all one 64K segment, CS=SS=DS, use equate for DGROUP.
;--------------------------------------------------------------------------
Ifdef DRV
    CGROUP      group   DevHeaderSeg, _TEXT, ICODE
    DGROUP      group   _DATA, _BSS, IDATA
ELSE
    CGROUP      group   _TEXT
    DGROUP      group   _DATA, _BSS
ENDIF	
;--------------------------------------------------------------------------
; Group is 64K data, 64K code, CS!=SS=DS, actual group for Code.
;--------------------------------------------------------------------------
; Assume statement here takes care of for any source, same for OS2 and DOS.
;--------------------------------------------------------------------------
    Assume   CS:CGROUP, DS:DGROUP, ES:NOTHING, SS:NOTHING

START_CODE	macro
_TEXT		segment Public 'Code'
		assume ds:DGroup,cs:cGroup,es:nothing,ss:nothing
		endm

END_CODE	macro
_TEXT		ends
		endm

START_DATA	macro
_Data		segment Public 'Data'
		assume ds:DGroup,cs:CGroup,es:nothing,ss:nothing
		endm

END_DATA	macro
_Data		ends
		endm

; 2 macros by John to let you easily insert data fragments into code
;
; This macro assumes that Code is open, closes it, and opens data.
OPEN_DATA       macro
    END_CODE
    START_DATA
                endm

; This macro closes the open data and re-opens the Code segment.
CLOSE_DATA      macro
    END_DATA
    START_CODE
                endm


; EOF - $Workfile: SPDOSEGS.INC $
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c90x\pcinic.inc ===
;
; Modifications:   $Header: /Client Boot/NICS/Generic/UNDI_NAD/PCINIC.INC 1     16/07/98 5:33p Dmitry Klimenko $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;

;
;   Description: PCI Configuration Space Definitions
;

IFDEF            PCI_INC
ELSE
PCI_INC          equ    1
include pci.inc

;--------------------------------------------------------------------------
; Configuration Space Header
;--------------------------------------------------------------------------
PCI_CONFIG_STRUC       struc
    PciVendorId        dw    ?                ;- PCI Vendor ID
    PciDeviceId        dw    ?                ;- PCI Device ID
    PciCommand         dw    ?
    PciStatus          dw    ?
    PciRevisionId      db    ?
    PciClassCode       db    3  dup (?)
    PciCacheLineSize   db    ?
    PciLatencyTimer    db    ?
    PciHeaderType      db    ?
    PciBIST            db    ?
    PciBaseReg0        dd    ?
    PciBaseReg1        dd    ?
    PciBaseReg2        dd    ?
    PciBaseReg3        dd    ?
    PciBaseReg4        dd    ?
    PciBaseReg5        dd    ?
    PciReserved0       dd    0
    PciReserved1       dd    0
    PciExpROMAddress   dd    ?
    PciReserved2       dd    0
    PciReserved3       dd    0
    PciInterruptLine   db    ?
    PciInterruptPin    db    ?
    PciMinGnt          db    ?
    PciMaxLat          db    ?
PCI_CONFIG_STRUC       ends

;--------------------------------------------------------------------------
; Config Space Register Offsets
; Refer To The PCI Specification For Detailed Explanations
;--------------------------------------------------------------------------
VENDOR_ID_REGISTER       equ     00h          ;- PCI Vendor ID Register
DEVICE_ID_REGISTER       equ     02h          ;- PCI Device ID Register
COMMAND_REGISTER         equ     04h          ;- PCI Command Register
STATUS_REGISTER          equ     06h          ;- PCI Status Register
REV_ID_REGISTER          equ     08h          ;- PCI Revision ID Register
CLASS_CODE_REGISTER      equ     09h          ;- PCI Class Code Register
CACHE_LINE_REGISTER      equ     0Ch          ;- PCI Cache Line Register
LATENCY_TIMER            equ     0Dh          ;- PCI Latency Timer Register
HEADER_TYPE              equ     0Eh          ;- PCI Header Type Register
BIST_REGISTER            equ     0Fh          ;- PCI Built-In SelfTest Register
BAR_0_REGISTER           equ     10h          ;- PCI Base Address Register 0
BAR_1_REGISTER           equ     14h          ;- PCI Base Address Register 1
BAR_2_REGISTER           equ     18h          ;- PCI Base Address Register 2
BAR_3_REGISTER           equ     1Ch          ;- PCI Base Address Register 3
BAR_4_REGISTER           equ     20h          ;- PCI Base Address Register 4
BAR_5_REGISTER           equ     24h          ;- PCI Base Address Register 5
SUB_VENDOR_ID_REGISTER           equ     2Ch          ;- PCI Base Address Register 5
SUB_DEVICE_ID_REGISTER           equ     2Eh          ;- PCI Base Address Register 5
EXPANSION_ROM            equ     30h          ;- PCI Expansion ROM Base Register
INTERRUPT_LINE           equ     3Ch          ;- PCI Interrupt Line Register
INTERRUPT_PIN            equ     3Dh          ;- PCI Interrupt Pin Register
MIN_GNT_REGISTER         equ     3Eh          ;- PCI Min-Gnt Register
MAX_LAT_REGISTER         equ     3Fh          ;- PCI Max_Lat Register

;--------------------------------------------------------------------------
; Configuration space DWORD register offsets
;--------------------------------------------------------------------------
CONFIG_SPACE_REG0        equ     0
CONFIG_SPACE_REG1        equ     1
CONFIG_SPACE_REG2        equ     2
CONFIG_SPACE_REG3        equ     3
CONFIG_SPACE_REG4        equ     4
CONFIG_SPACE_REG5        equ     5
CONFIG_SPACE_REG6        equ     6
CONFIG_SPACE_REG7        equ     7
CONFIG_SPACE_REG8        equ     8
CONFIG_SPACE_REG9        equ     9
CONFIG_SPACE_REGA        equ     0Ah
CONFIG_SPACE_REGB        equ     0Bh
CONFIG_SPACE_REGC        equ     0Ch
CONFIG_SPACE_REGD        equ     0Dh
CONFIG_SPACE_REGE        equ     0Eh
CONFIG_SPACE_REGF        equ     0Fh

;--------------------------------------------------------------------------
; Byte/Word Offsets In A Config DWORD
; These offsets can be used to move a Byte or Word into the lower half of
; a register.
;--------------------------------------------------------------------------
CONFIG_BYTE_0            equ     0
CONFIG_BYTE_1            equ     8
CONFIG_BYTE_2            equ     16
CONFIG_BYTE_8            equ     24
CONFIG_WORD_0            equ     0
CONFIG_WORD_1            equ     16

;--------------------------------------------------------------------------
; Configuration Mechanism Registers
;--------------------------------------------------------------------------
CF1_CONFIG_ADDR_REGISTER   equ   0CF8h        ;- Config Space Address Register
CF1_CONFIG_DATA_REGISTER   equ   0CFCh        ;- Config Space Data Register
CF2_SPACE_ENABLE_REGISTER  equ   0CF8h        ;- CSE Register
CF2_FORWARD_REGISTER       equ   0CFAh        ;- Forward Register
CF2_BASE_ADDRESS           equ   0C000h       ;- Configuration #2 Base

;--------------------------------------------------------------------------
; PCI Class Code Definitions
; Configuration Space Header
;--------------------------------------------------------------------------
PCI_BASE_CLASS           equ     02h          ;- Base Class - Network Controller
PCI_SUB_CLASS            equ     00h          ;- Sub Class - Ethernet Controller
PCI_PROG_INTERFACE       equ     00h          ;- Prog I/F - Ethernet COntroller

;--------------------------------------------------------------------------
; PCI Command Register Bit Definitions
; Configuration Space Header
;--------------------------------------------------------------------------
CMD_IO_SPACE             equ     BIT_0
CMD_MEMORY_SPACE         equ     BIT_1
CMD_BUS_MASTER           equ     BIT_2
CMD_SPECIAL_CYCLES       equ     BIT_3
CMD_MEM_WRT_INVALIDATE   equ     BIT_4
CMD_VGA_PALLETTE_SNOOP   equ     BIT_5
CMD_PARITY_RESPONSE      equ     BIT_6
CMD_WAIT_CYCLE_CONTROL   equ     BIT_7
CMD_SERR_ENABLE          equ     BIT_8
CMD_BACK_TO_BACK         equ     BIT_9

;--------------------------------------------------------------------------
; PCI Status Register Bit Definitions
; Configuration Space Header
;--------------------------------------------------------------------------
STAT_BACK_TO_BACK        equ     BIT_7
STAT_DATA_PARITY         equ     BIT_8
STAT_DEVSEL_TIMING       equ     BIT_9 OR BIT_10
STAT_SIGNAL_TARGET_ABORT equ     BIT_11
STAT_RCV_TARGET_ABORT    equ     BIT_12
STAT_RCV_MASTER_ABORT    equ     BIT_13
STAT_SIGNAL_MASTER_ABORT equ     BIT_14
STAT_DETECT_PARITY_ERROR equ     BIT_15

;--------------------------------------------------------------------------
; PCI Base Address Register For Memory (BARM) Bit Definitions
; Configuration Space Header
;--------------------------------------------------------------------------
BARM_LOCATE_BELOW_1_MEG  equ     BIT_1
BARM_LOCATE_IN_64_SPACE  equ     BIT_2
BARM_PREFETCHABLE        equ     BIT_3

;--------------------------------------------------------------------------
; PCI Base Address Register For I/O (BARIO) Bit Definitions
; Configuration Space Header
;--------------------------------------------------------------------------
BARIO_SPACE_INDICATOR    equ     BIT_0

;--------------------------------------------------------------------------
; PCI BIOS Definitions
; Refer To The PCI BIOS Specification
;--------------------------------------------------------------------------
;- Function Code List

;IFE  NWSERVER
;;- Server can use the defines in ODI.INC
;PCI_FUNCTION_ID          equ     0B1h         ;- AH Register
;PCI_BIOS_PRESENT         equ     01h          ;- AL Register
;FIND_PCI_DEVICE          equ     02h          ;- AL Register
;FIND_PCI_CLASS_CODE      equ     03h          ;- AL Register
;GENERATE_SPECIAL_CYCLE   equ     06h          ;- AL Register
;READ_CONFIG_BYTE         equ     08h          ;- AL Register
;READ_CONFIG_WORD         equ     09h          ;- AL Register
;READ_CONFIG_DWORD        equ     0Ah          ;- AL Register
;WRITE_CONFIG_BYTE        equ     0Bh          ;- AL Register
;WRITE_CONFIG_WORD        equ     0Ch          ;- AL Register
;WRITE_CONFIG_DWORD       equ     0Dh          ;- AL Register
;ENDIF

; Function Return Code List
SUCCESSFUL               equ     00h
FUNC_NOT_SUPPORTED       equ     81h
BAD_VENDOR_ID            equ     83h
DEVICE_NOT_FOUND         equ     86h
BAD_REGISTER_NUMBER      equ     87h

;- PCI BIOS Calls
PCI_BIOS_INTERRUPT       equ     01Ah         ;- PCI BIOS Int 1Ah Function Call
PCI_PRESENT_CODE         equ     20494350h    ;- Hex Equivalent Of 'PCI '
                                              ;- ASCII Codes for ' ICP'
PCI_PRESENT_CODE_WORD    equ     4350h        ;- Hex Equivalent Of 'CP'
PCI_SERVICE_IDENTIFIER   equ     49435024h    ;- ASCII Codes for 'ICP$'

;- PCI Device and Vendor IDs
;; JL - Removed nic specifics!
;;SPEEDO_DEVICE_ID         equ     1227h
;;SPLASH1_DEVICE_ID        equ     1226h
;;D100_DEVICE_ID           equ     1229h
;;D100_VENDOR_ID           equ     8086h

;- Maximum bus slots supported under Configuration mechanisms 1 and 2
CONFIG1_MAX_PCI_SLOTS    equ     32
CONFIG2_MAX_PCI_SLOTS    equ     16

;- Maximum buses supported
MAX_PCI_BUSES            equ     255

ENDIF


; EOF - $Workfile: PCINIC.INC $
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c90x\undi_equ.inc ===
;
;--- Miscellaneous Equates
;
NULL            equ     0
CR		equ	0Dh           ;- Carriage Return
LF		equ	0Ah           ;- Line Feed
FALSE		equ	0
TRUE		equ	1
;
;--- Ethernet Frame Sizes
;
ETHERNET_ADDRESS_LENGTH		equ	6
ETHERNET_HEADER_SIZE		equ	14
MINIMUM_ETHERNET_PACKET_SIZE	equ	60
;MAXIMUM_ETHERNET_PACKET_SIZE	equ	1514
MAXIMUM_ETHERNET_PACKET_SIZE	equ	1500 ;; just data, not media header

MAX_PACKET         Equ       1514      ; Maximum allowable packet size.
MIN_PACKET         Equ       60        ; Minimum allowable packet size.
; 
;--- Packet filter bit definitions
; 
FLTR_DIRECTED                Equ       01H
FLTR_MLTCST                  Equ       01H
FLTR_BRDCST                  Equ       02H
FLTR_PRMSCS                  Equ       04H
FLTR_SRC_RTG                 Equ       08H
;
;--- Processor Type Equates
;
EIGHT_BIT          equ       0001H
SIXTEEN_BIT        equ       0002H
PROC_TYPE_MASK     equ       0030H

PROC_8086          equ       0000H OR EIGHT_BIT
PROC_80286         equ       0010H OR SIXTEEN_BIT
PROC_80386         equ       0020H
PROC_80486         equ       0040H
;
;--- Result codes returned in AX by a PXE API service.
;
PXENV_EXIT_SUCCESS		equ	0
PXENV_EXIT_FAILURE		equ	1
PXENV_EXIT_CHAIN		equ	0FFFFh	; used internally
;
;--- Status codes returned in the status word of PXE API parameter structures.
;
PXENV_STATUS_SUCCESS		equ	0
PXENV_STATUS_FAILURE		equ	1	;general failure
PXENV_STATUS_BAD_FUNC		equ	2	;invalid function number
PXENV_STATUS_UNSUPPORTED	equ	3	;not yet supported
PXENV_STATUS_1A_HOOKED		equ	4	;Int 1AH cannot be unhooked

; Driver errors (60 to 0x6F)
; These errors are for UNDI compatible NIC drivers.
PXENV_STATUS_UNDI_MEDIATEST_FAILED 		equ	61h
PXENV_STATUS_UNDI_CANNOT_INIT_NIC_FOR_MCAST	equ	62h
;
;
EISA_ADAPTER             equ    1
PCI_ADAPTER              equ    2
PnP_ADAPTER              equ    3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c90xb\bwequ.inc ===
;--------------------------------------------------------------------
; BootWare Table variables
;--------------------------------------------------------------------
;extrn	BWTLANOS:byte			; ROMTOP.ASM
;extrn	BWType:byte			; ROMTOP.ASM
;extrn	BWTCpyRAM:word			; ROMTOP.ASM
;extrn	BWTFeature:word 		; ROMTOP.ASM
;extrn	BWTEthStd:word			; ROMTOP.ASM
;extrn	BWTAddrRes:byte 		; ROMTOP.ASM  ; GK 970126
;extrn	BWTChkSum:byte			; ROMTOP.ASM

;extrn	RomBase:word			; autoscan.asm

;extrn	PrintAt:near			; common.asm
;extrn	ChangeTitleAttrib:near

;--------------------------------------------------------------------
; Protocol starting functions
;--------------------------------------------------------------------
;extrn	NetWareStart:near
;extrn	RPLStart:near
;extrn	IPStart:near

;--------------------------------------------------------------------
; EQUATES
;--------------------------------------------------------------------

; NAD Return Codes
SUCCESSFUL		EQU	0000h
REQUEST_QUEUED		EQU	0002h
OUT_OF_RESOURCE 	EQU	0006h
INVALID_PARAMETER	EQU	0007h
INVALID_FUNCTION	EQU	0008h
NOT_SUPPORTED		EQU	0009h
HARDWARE_ERROR		EQU	000ah
TRANSMIT_ERROR		EQU	000bh
NO_SUCH_DESTINATION	EQU	000ch
HARDWARE_NOT_FOUND	EQU	0023h
HARDWARE_FAILURE	EQU	0024h
CONFIGURATION_FAILURE	EQU	0025h
INTERRUPT_CONFLICT	EQU	0026h
INITIALIZATION_FAILED	EQU	0028h
RECEIVE_TIMEOUT 	EQU	0080h		; Rx2 in NetWare
GENERAL_FAILURE 	EQU	00ffh

; definition for BWTEthStd
BWTETH8023	equ	0
BWTETH8022	equ	1
BWTETHSOFT	equ	2
BWTETHEII	equ	1500		; if BWTEthStd >1500, then E_II
BWTETH8137	equ	08137h
;BWTETH800	equ	0800h		; used for tcp/ip bootp
;BWTETH806	equ	0806h		; used for tcp/ip bootp/arp

; definition for BWTLANOS
BWTLANNW	equ	010h
BWTLANRPL	equ	020h
BWTLANIP	equ	040h
BWTLANMASK	equ	0F0h
BWTLANTRI	equ	070h
BWTLANLOCAL	equ	3h		; Bit 0,1

; definition for BWTFEATURE
BWTFEA_DEFAULT	equ	1
BWTFEA_RS	equ	2
BWTFEA_CONF	equ	4

MasterEOIPort	equ	20h
SlaveEOIPort	equ	0a0h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c90xb\bwnad.inc ===
;====================================================================
; BWNAD.INC
;
; Include for for BootWare NAD modules.
;
; 970116 PC - first version
;====================================================================

;--------------------------------------------------------------------
; Include the common structures.
;--------------------------------------------------------------------

IFDEF _IDEAL_
	include "bwstruct.inc"
ELSE
	include bwstruct.inc

ENDIF

;--------------------------------------------------------------------
; NAD publics
;--------------------------------------------------------------------
public	NADGetBootInfo
public	NADInitialize
public	NADConfig
public	NADStart
public	LanOption

IFDEF _IDEAL_
	include "bwequ.inc"
ELSE
	include bwequ.inc

ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c90xb\bwstruct.inc ===
;====================================================================
; BWSTRUCT.INC
;
; Include for for BootWare, defines common structures.
;
; 970116 PC - first version
;====================================================================

;--------------------------------------------------------------------
; Common equates
;---------------------------------------------------------------------
FEATURE_LOCAL	equ	1
FEATURE_VIRUS	equ	2
FEATURE_MENU	equ	4
FEATURE_KEYWAIT	equ	8
FEATURE_FLOPPY	equ	64
FEATURE_HDRIVE	equ	128

;--------------------------------------------------------------------
; Event Descriptor (ED) Structure
;---------------------------------------------------------------------
IFDEF _IDEAL_
Struc	ED
	Ptr		dw	?	; pointer to next ED
	Unused		dw	?	; spare word
	DestAddr	dw	?, ?, ?	; destination Address
	ErrCode		dw	?	; error code
	ErrMsg		dw	?	; pointer to error msg
	Length		dw	?	; total packet length
	FragCount	dw	?	; number of fragments
	FragOff		dw	?	; 1st fragment offset
	FragSeg		dw	?	; 1st fragment segment
	FragLen 	dw	?	; length of fragment
ends
ELSE
ED_Struct      STRUC
	ED_Ptr		dw	?	; pointer to next ED
	ED_Unused	dw	?	; spare word
	ED_DestAddr	dw	?, ?, ?	; destination address
	ED_ErrCode	dw	?       ; error code
	ED_ErrMsg	dw	?       ; Pointer to error msg
	ED_Length	dw	?	; total packet length
	ED_FragCount	dw	?	; Number of descriptors/fragments
	ED_FragOff	dw	?	; Descriptor Pointer
	ED_FragSeg	dw	?	; Descriptor Pointer
	ED_FragLen 	dw	?	; Length of packet descriptor
ED_Struct      ENDS
ENDIF

;--------------------------------------------------------------------
; Descricptor Structure
;---------------------------------------------------------------------
IFDEF _IDEAL_
Struc Frag
	Off		dw	?	; offset of fragment
	Seg		dw	?	; segment of fragment
	Len		dw	?	; length of fragment
ends
ELSE
Frag Struc
	FragOff		dw	?	; offset of fragment
	FragSeg		dw	?	; segment of fragment
	FragLen		dw	?	; length of fragment
Frag ends
Descript_Struct STRUC
	DPointer	dd	?	; Descriptor Pointer
	DLen		dw	?	; Length of packet descriptor
Descript_Struct ends
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c90xb\90xb.asm ===
subttl	3C90XB
	page	80,132

;===============================================================================
;  90XB.ASM - produces 3Com 3C90XB EtherLink PCI version of BootWare
;
;    (C) Lanworks Technologies Inc. 1992 - 1996 All rights reserved.
;
;  Revision History - version numbers refer to 90XB.ASM changes only
;
;  971210 1.00  RL - Initial Release
;*==============================================================================
CR		equ	0Dh
LF		equ	0Ah

ASReverseAttr	equ	070h		; Attribute for reverse video
ASNormalAttr	equ	07h		; attribute for normal video

MasterEOIPort 	equ	20h
SlaveEOIPort 	equ	0a0h

FALSE           equ     0
TRUE            equ     0ffh

;
; the number of times through a timed loop to stay off the bus while polling
; for bus master completion to avoid slowing the bus master transfers down
;
Delay3us	equ	8
Delay3ms	equ	01c20h
Delay25ms	equ	0ea60h

InitSTACKPTR	equ	07f00h		; stack pointer for AutoScan Code

T4_PHY_ADDR     equ     01h
NWAY_PHY_ADDR   equ     18h

;BOOTWARE_INTS equ      INT_LATCH + INT_ADAPTERFAIL + INT_RXCOMPLETE + INT_REQUESTED
BOOTWARE_INTS	equ	INT_LATCH+INT_ADAPTERFAIL+INT_UPCOMPLETE

;-------------------------------------
; Include all general companion files
;-------------------------------------

	.xlist
IFDEF	UNDI
	include	spdosegs.inc
	include	pxe_stru.inc
ELSE
	include \rom\sdk\include\drvseg.inc
	include \rom\genr\include\cui.ext
ENDIF
	include bwnad.inc
	include	boom.inc
	.list


IFNDEF	UNDI
public	RunROMTOP
public	InternalConfig
public	WaitEEBusy

;public	HookConfig
				; for CUI...
public	HookEditInput
public	HookHyphen
public	HookEditSpec
public	HookChkChar
public	HookChkInput
public	ErrConfSpace
public	MemBase
public	StoHex			; for 5X9CONF
public	ChkForCfg
public	ChkKey

public	NormalRxEarly
public	CurTxStart

public	eoi_value
public	int_mask_port

public	NADPCIConfig
public	LANOption
public	setchksum
ENDIF

public	IRQLevel
public	HWFilter
public	RxReset
public	TxReset
public	Int_Vector_Loc
public	OrgINTVector_Off
public	OrgINTVector_Seg

;-----------------------------------
; External Data/Variable References
;-----------------------------------

IFDEF	UNDI
	extrn	UNDI_DriverISR
ENDIF

	extrn	PCIBusDevFunc:word
	extrn	IOBase:word			; ROMTOP.ASM

IFNDEF	UNDI
	extrn	Start:near

	extrn	PrintErrMsg:near		; 5X9CONF.ASM
	extrn	ErrIRQ7:byte			; 5X9CONF.ASM
	extrn	NormalAttr:byte			; CUI.ASM
	extrn	ReverseAttr:byte		; CUI.ASM

	extrn	elnk3conf:near			; 5X9CONF.ASM
	extrn	Elnk3ConfSparse:byte		; 5X9CONF.ASM
	extrn	ROMCodeStart:word		; ROMTOP.ASM
	extrn	PrintAt:near
	extrn	NADIntFD:near
ENDIF

IFDEF	DEBUG
	extrn	StringAH:byte
	extrn	StringAL:byte
	extrn	StringPCI:byte
ENDIF

IFNDEF	UNDI
; the following structure is template for received lookahead data, it contains
; MAC header and the 1st 18 bytes of IPX Header.

LookAheadBuf_stru  struc
	;
DestAddr      db   6 dup (?)	       ; this part is
SrcAddr       db   6 dup (?)	       ;  MAC header of
LenType       dw   ?		       ;   received packet
;
IpxChkSum     dw   ?		       ; this portion
IpxPktLen     dw   ?		       ;  is the first
IpxTransContr db   ?		       ;   18 bytes
IpxPktType    db   ?		       ;    of IPX
IpxDestNet    db   4 dup (?)	       ;      header of
IpxDestNode   db   6 dup (?)	       ;	received
IpxDestSocket dw   ?		       ;	  packet.
;
LookAheadBuf_stru  ends

LxBufSize     equ  size LookAheadBuf_stru

LookAhead8022	struc
;
DestAddr8022	  db   6 dup (?)	   ; this part is
SrcAddr8022	  db   6 dup (?)	   ;  MAC header of
LenType8022	  dw   ?		   ;   received packet

; 802.2 LLC
DSAP	      db   0
SSAP	      db   0
Control       db   0
;
LookAhead8022	ends
ENDIF

MACHDRSIZE   		equ 	14
ETHADDRSIZE   		equ	6      		; address size

	.386

IFDEF	UNDI
_TEXT		Segment para public
	assume	cs:CGroup, ds:DGroup
ELSE
START_NAD
ENDIF

LanOption	db	'3Com 3C905B-TX EtherLink PCI v3.00 (971210)',0

NoNetMsg	db	'Ethernet card improperly installed or not connected.',CR,LF,0
TxMsg		db	'Transmit error                                      ',0

IFNDEF	UNDI
	include \rom\sdk\include\bwnadapi.asm

;----------------- Device Driver Data Definitions --------------------
ErrConfSpace	db	09h,011h,' '
NothingString	db	0

StrEndless	db	013h,0ah,'Reboot system for changes to take effect',0

CfgStr 		db	'Configuring Ethernet Adapter, press Ctrl-Alt-B to modify configuration', 0

;-----------------------------------------------------------------------------
;      V A R I A B L E S
;-----------------------------------------------------------------------------

		   ALIGN     4

LookAheadBufferPtr label     dword
		   dw	     offset LookAheadBuffer
		   dw	     ?

; error messages - note BootWare prefaces them with a CR,LF

StrPrompt	db	'Initializing 3C90X EtherLink PCI Adapter',0
BlankStr	db	'                                        ',0

Str8022U	db	06h,08h,'BootWare 3C90X supports NetWare, RPL & TCP/IP boot protocols:',0
		db	09h,0ah,'To configure & save protocol/frame type, type <ENTER>',0
		db	0bh,0bh,'Default boot protocol is NetWare Ethernet_802.2',0
		db	03h,0fh,'This message will appear until boot protocol information is saved.',0
		db	0ffh
StrNull 	db	0


MsgROM64K	db	'Only ROMSize of 64K is supported',0

ErrPressF1		db	'. Press <F1> to continue',0

StrWarnLevel	db	010h,0ah,'Newer BootWare version is available for this adapter.',0
StrFailLevel	db	0bh,0ah,'New EtherLink found. Need new BootWare version.',0

; Msg put here so it won't be on every page
MsgUpdateErr	db	06h,0ah,'Unable to update BootWare 3C90X. Configuration changes are not saved.',0

MsgVerifyBad	db	012h,0ah,'BootWare Update verification failed.',0
MsgUpdateOk	db	018h,0ah,'Update Successful ('
MsgUpdateCnt	db	'00)',0
ENDIF

MsgVulcanNotFound	db	'Could not find 3C90X', 0


IFNDEF	UNDI
;--------------------------------------------------------------------
RomTopExitJmp:
		jmp	RomTopExit	;already init. Never run in RAM.

RunROMTOP:
		pusha
		push	ds
		push	es

		push	cs
		push	cs
		pop	ds
		pop	es

		cld

IFDEF		TSR
		mov	ax, 040h
ENDIF
IFDEF		DEBUG
		int	3
ENDIF
		push	ax


IFDEF		DEBUG
		mov	di, offset CGroup:StringAL
 		call	StoHex

	 	xchg	al, ah
	 	mov	di, offset CGroup:StringAH
	 	call	StoHex

	 	mov	ax, cs
	 	mov	di, offset CGroup:StringCS
	 	call	ROMStoHex

		mov	bx, offset CGroup:StringPCI
		call	PrintMessage

		mov	bx, offset CGroup:ErrPressF1
		call	PrintMessage

ChkF1F2Lp:
		sti			; enable interrupt

		mov	ah, 0		; Read char. Char is removed from buffer
		int	016h		; Keyboard interrupt

		cmp	ah, 3Bh ; <F1> pressed?
		jz	TempCont

		cmp	ah, 3Ch ; <f2> pressed?
		jnz	ChkF1F2Lp

		pop	ax

ASExitEarly:
		pop	es
		pop	ds
		popa
		retf
TempCont:

ENDIF		; DEBUG

		call	GetBusType
		cmp	al, BUS_PCI
		jz	ASPCI

		cmp	al, BUS_EISA_PCI
		jz	ASPCI

		; Bus could be EISA or PCI_EISA
		mov	bx, offset CGroup:MsgVulcanNotFound
		pop	ax
		jmp	AutoScanErr

ASPCI:
IFNDEF		TSR

		pop	ax
		mov	PCIBusDevFunc, ax
		pop	ax
		push	ax			;ROMBase
		mov	ROMBase, ax

		; to save space, OldStackPtr is not used. Replaced by Old MsgIOConflict
		; use our own stack
		mov	word ptr [OldStackPtr], sp
		mov	word ptr [OldStackPtr+2], ss

		call	FindStack
		cli
		mov	ss, ax
		mov	sp, InitSTACKPTR
		sti

ENDIF		; TSR
		push	cs
		pop	ds

		mov	BusType, BUS_PCI
		call	Init_Adapter		; init vulcan hardware and
						;  variables
		cmp	ax, 0
		jz	Init_AdapterOk

		; Print Message. Can't use the one in CUI because it's not on
		; every page.
		mov	bx, offset CGroup:MsgVulcanNotFound

AutoScanErr:	call	PrintMessage
		mov	bx, offset CGroup:ErrPressF1
		call	PrintMessage

ChkF1Lp:
		sti			; enable interrupt

		mov	ah, 0		; Read char. Char is removed from buffer
		int	016h		; Keyboard interrupt

		cmp	ax, 3B00h	; <F1> pressed?
		jnz	ChkF1Lp

		; restore stack
		mov	ss, word ptr [OldStackPtr+2]
		mov	sp, word ptr [OldStackPtr]

		pop	es
		pop	ds
		popa
		retf

Init_AdapterOk:
		; Make sure ROMSize is set to 64K. Otherwise, print error
		; msg, wait and continue
		mov	bx, offset CGroup:MsgROM64K
		mov	ax, InternalConfig.loword
		and	ax, 0c0h		; consider only bit 6,7
		cmp	ax, 0c0h
		jnz	AutoScanErr

		; Setup PrintAttribute so that color will only be used
		; in Config Facility
;		mov	al, NormalAttr
;		mov	ah, ReverseAttr
;		mov	CUIAttr, ax
;		mov	NormalAttr, ASNormalAttr
;		mov	ReverseAttr, ASReverseAttr

;		call	ASConfig		; autoscan config
;		mov	NormalAttr, ASNormalAttr
;		mov	ReverseAttr, ASReverseAttr
;		jnc	AutoScanNoUpdate

		; Problem with Phoenix BIOS where SS is required to be
		; the same as CS
		; Assume that NOTHING is on the STACK!!!
;		cli
;		mov	ax, cs
;		mov	ss, ax
;		sti

;		call	UpdatePCI_PEROM

		; Problem updating ROM. Just dump error message and let
		; them proceed
;		xor	al, al		; Get user to press <ENTER> for acknowledge
;		call	PrintErrMsg
;		call	ClearScreen

AutoScanNoUpdate:

		push	cs
		pop	ds

IFNDEF		TSR
		; restore stack
		mov	ss, word ptr [OldStackPtr+2]
		mov	sp, word ptr [OldStackPtr]
ENDIF

RomTopExit:
 		pop	es
		pop	ds
		popa

		jmp	Start


;-----------------------------------------------------------------------------
; AutoConfig	Called by Autoscan routine
;
;		Exit:	ax = offset of checksum byte (whole ROM)
;-----------------------------------------------------------------------------
;AutoConfig	proc	near
;		ret
;AutoConfig	endp


;-----------------------------------------------------------------------------
; SetChkSum	Calculate checksum of a specified block of data and
;		write checksum to specified location
;
;		Entry:	ds:si = point to block of data to checksum
;			di = offset in block of data to write checksum
;			cx = length of data to checksum
;		Exit:	checksum ok block of data
;-----------------------------------------------------------------------------
SetChkSum	proc	near
		xor	ax, ax

SetChkSumLoop:
		lodsb
		add	ah, al
		loop	SetChkSumLoop

		neg	ah
		mov	ds:[di], ah		; write checksum

		ret
SetChkSum	endp


;------ GetBusType ----------------------------------------------------------;
;									     ;
;	Identify the type of system we are executing on.		     ;
;									     ;
;	Entry:								     ;
;	cli								     ;
;									     ;
;	Exit:								     ;
;	cli								     ;
;	AL = EISA or PCI or EISA_PCI (also saved in BusType)			     ;
;									     ;
;	Destroys AH, BX, CX, DX, SI, DI.  All other registers are     ;
;	preserved.							     ;
;									     ;
;----------------------------------------------------------------------------;
		public	GetBusType
GetBusType	proc	near

		push	es
; point ES at Real Mode F000:0000
		mov	ax, 0F000h
		mov	es, ax

; to determine if this is an EISA system or not we look for the string "EISA"
; in the ROM at F000:FFD9 thru FFDC.

		mov	ax, 0			; clear BusFlag
		mov	di, 0FFD9h
		cmp	word ptr es:[di][0], 4945h	; "EI"?
		jne	gst_not_eisa
		cmp	word ptr es:[di][2], 4153h	; "SA"?
		jne	gst_not_eisa

		mov	al, BUS_EISA

; for the moment, if its not an EISA system, see if it's PCI

gst_not_eisa:
		push	ax

		; Is machine PCI?
		mov	ax, PCI_FUNCTION_ID shl 8 + PCI_BIOS_PRESENT
		int	1ah
		jc	GetBusRet

		or	ah, ah
		jne	GetBusRet

		cmp	dx, 4350h		; EDX = "PCI "
		jne	GetBusRet

		pop	ax
		add	al, BUS_PCI
		push	ax

GetBusRet:
		pop	ax
		pop	es
		ret
GetBusType	endp
ENDIF

IFDEF	UNDI
	include	nad90x.asm
ENDIF

public		WaitTime
;--------------------------------------------------------------------
; WaitTime - CX has 2*1.1932 the number of microseconds to wait.
;	If CX is small, add 1 to compensate for asynchronous nature
;	of clock.  For example, for 10us, call with CX = 25
;
;  On entry,
;	ints off (especially if CX is small, and accuracy needed)
;  On exit,
;
; 911223 0.0 GK
;--------------------------------------------------------------------
WaitTime	proc	near

		push	ax
		push	bx
		push	cx

		call	ReadTimer0		; get Timer0 value in AX
		mov	bx, ax			; save in BX

ReadTimer0Loop:
		call	ReadTimer0
		push	bx
		sub	bx, ax
		cmp	bx, cx
		pop	bx
		jc	ReadTimer0Loop

		pop	cx
		pop	bx
		pop	ax
		ret

WaitTime	endp


ReadTimer0	proc	near

		mov	al, 6
		out	43h, al 		; port 43h, 8253 wrt timr mode 3
		call	RT0

RT0:
		jmp	short $+2
		jmp	short $+2
		jmp	short $+2
		in	al, 40h 		; port 40h, 8253 timer 0 clock
		xchg	ah, al

		jmp	short $+2
		jmp	short $+2
		jmp	short $+2

		ret

ReadTimer0	endp


;------ ReadEEProm ----------------------------------------------------------;
;									     ;
;	This routine reads a word from the EEProm.  It can only be used      ;
;	once the board has been brought up at a particular IOBase.	     ;
;									     ;
;	Entry:								     ;
;	AL	= EEProm word to read					     ;
;	Window	= 0							     ;
;	DX 	= IOBase
;	cli								     ;
;									     ;
;	Exit:								     ;
;	AX	= that EEProm word					     ;
;	cli								     ;
;									     ;
;	Destroys BX, CX, DX, SI, DI and ES.  All other registers are	     ;
;	preserved.							     ;
;									     ;
;----------------------------------------------------------------------------;
	  	public  ReadEEProm
ReadEEProm	proc    near
		push	dx

; issue an EEProm read command
		add    al, READ_EEPROM
		out    dx, al

; spin until the EEProm busy bit goes off

		call   WaitEEBusy

; fetch the data from the EEProm data register

;960401		add    dx, PORT_EEData - PORT_EECmd
		mov	dx, PortEEData
		in     ax, dx

		pop	dx
		ret

ReadEEProm    endp


;-----------------------------------------------------------------------------
; WaitEEBusy	Poll until the EEPROM_BUSY bit in EECommand Register is cleared
;
; Input:	dx = IOBase+ PORT_EECmd
;		ax = 0 no problem, ax != 0 problem
;-----------------------------------------------------------------------------
WaitEEBusy	proc	near
		push	cx

		mov	cx, 0
WaitEELoop:
		in	ax, dx
		test	ax, EE_BUSY
		jz	WaitEEBusyExit
		loop	WaitEELoop
WaitEEBusyExit: 
		and	ax, EE_BUSY		; only consider bit 15 for Errcode
		pop	cx
		ret
WaitEEBusy	endp


;
; bits to enable in MediaStatus based on XCVR type
;
		public	MediaEnable
MediaEnable	label	word
;;		ASSERT	<XCVR_10TP EQ 0>
		dw	MEDIA_JABBERENABLE + MEDIA_LBEATENABLE
;;;		ASSERT	<XCVR_10AUI EQ 1>
		dw	MEDIA_SQEENABLE
		dw	0			; not used
;;;		ASSERT	<XCVR_10BNC EQ 3>
		dw	0
;;;		ASSERT	<XCVR_100TX EQ 4>
		dw	MEDIA_LBEATENABLE
;;;		ASSERT	<XCVR_100FX EQ 5>
		dw	MEDIA_LBEATENABLE
;;;		ASSERT	<XCVR_MII EQ 6>
		dw	0
		dw	0
		dw	MEDIA_LBEATENABLE

;-----------------------------------------------------------------------------
; FindV3PCI
;
; Return	dx = 0		not found
;		     IOBase	found
;		al = IRQLevel
;-----------------------------------------------------------------------------
FindV3PCI	proc	near

		call	PCISearch
		jc	no_pci

; Check whether bus mastering has been forced off.  If so, set MasterOK to NO
		
	       mov     ah, 0B1h		; PCI BIOS Function
	       mov     al, 009h		; PCI Read Config Word
	       mov     bx, PCIBusDevFunc
	       mov     di, PCIC_COMMAND	; read PCICommand
	       int     1Ah
       
	       test    cx, PCIC_BMENABLE       ; bus mastering enabled?
	       jnz     bm_set
       
	       or      cx, PCIC_BMENABLE       ; force it on
	       mov     ah, 0B1h		; PCI BIOS Function
	       mov     al, 00Ch		; PCI Write Config Word
	       mov     bx, PCIBusDevFunc
	       mov     di, PCIC_COMMAND	; write it back to PCICommand
	       int     1Ah
bm_set:

; PCI device has been found, read IO address from config space

		mov	bx, PCIBusDevFunc
		mov	ax, PCI_FUNCTION_ID shl 8 + READ_CONFIG_WORD
		mov	di, CFGREG_IOBASE
		int	1ah
		jc	no_pci

		and	cx, 0ffe0h			 ; drop last 5 bits
		mov	dx, cx

		mov    ax, PCI_FUNCTION_ID shl 8 + READ_CONFIG_BYTE
		mov    bx, PCIBusDevFunc
		mov    di, CFGREG_INTLINE
		int    1ah
		mov    al, cl

		ret

no_pci: 	xor	dx, dx
		ret
FindV3PCI	endp


;------ PCISearch -----------------------------------------------------------;
;									     ;
;	Attempt to find a match against a PCI adapter.	The caller can	     ;
;	specify the exact busno/slot to check or leave either unspecified    ;
;	in which case a search will be performed among the allowed	     ;
;	busno/slot combinations for a match.				     ;
;									     ;
;	Entry:								     ;
;	cli								     ;
;	Slot  = slot number to search, -1 if not specified		     ;
;	BusNo = bus number to search, -1 if not specified		     ;
;									     ;
;	Exit:								     ;
;	cli								     ;
;	carry = set if no match 					     ;
;	      = clear if a match					     ;
;	BusNo = set for the matching adapter if carry clear		     ;
;	Slot  = set for the matching adapter if carry clear		     ;
;	PCIBusDevFunc = set for the matching adapter if carry clear	     ;
;									     ;
;	All registers are preserved.					     ;
;									     ;
;----------------------------------------------------------------------------;

		public	PCISearch
PCISearch	proc	near

		pusha

;
; Read the PciCommand register to see if the adapter has been activated.  if
; not, pretend we didn't find it
;
		mov	ah, 0B1h		; PCI BIOS Function
		mov	al, 009h		; PCI Read Config Word
		mov	bx, PCIBusDevFunc
		mov	di, PCIC_COMMAND
		int	1Ah
		jc	pcis_no

		test	ah, ah
		jnz	pcis_no


		test	cx, PCIC_IOENABLE	; I/O access enabled?
		jz	pcis_no

		clc
;
; exit with carry flag as set
;
pcis_exit:
		popa
		ret

;
; no PCI support or adapter not found or failure after found
;
		public	pcis_no
pcis_no:
		stc
		jmp	pcis_exit
PCISearch	endp


;*****************************************************************************
;
;   Init_Adapter: This routine initializes hardware of Fast EtherLink and
;		 variables required by this driver. The following are
;		 performed in this routine:
;
;		   1. activate adapter
;		   2. determine resource config and enable resources
;		   3. initialze and determine driver variables, tables
;		   4. enable vulcan hardware (txmitter, receiver, xcvr, etc.)
;
;   On Entry:
;
;      ds = es = CGroup
;      sti
;      cld
;
;   On Exit:
;
;      sti
;      ax     = 0, init successful
;	      = offset of an error message indicating type of error
;
;*****************************************************************************

nohardware:	sti
		mov	ax, offset CGroup:MsgVulcanNotFound
		ret

Init_Adapter	proc	  near

		call	FindV3PCI
		cmp	dx, 0
		jz	nohardware

		mov	DGroup:IOBase, dx
		mov	IRQLevel, al

		call	CalibrateDelay

		mov	cx, 1			; 1us
		call	ComputeDelay
		mov	Delayoneusec.loword, ax
		mov	Delayoneusec.hiword, dx


		mov	cx,0C350h
		call	ComputeDelay
		mov	DelaySomething.loword, ax
		mov	DelaySomething.hiword, dx

;;;
;
; initialize IO Port Variables
;
		mov	ax, IOBase
		mov	cx, NumOfPorts
		mov	di, offset DGroup:PortCmdStatus
InitPorts:
		add	[di], ax
		add	di, 2
		loop	InitPorts

		mov	dx, PortCmdStatus
		mov	ax, CMD_SELECTWINDOW+WNO_SETUP	   ;   unload/reload &
		out	dx, ax				   ;	boot PROMs

;PM		mov	ax, cs
		mov	ax, ds
		mov	es, ax
		mov	di, offset DGroup:BoardID

		mov	dx, PortEECmd
		mov	al, EE_OEM_NODE_ADDR_WORD0
		call	ReadEEProm		  ; read word 0 of node addr
		xchg	ah, al
		stosw

		mov	al, EE_OEM_NODE_ADDR_WORD1
		call	ReadEEProm		  ; read word 1 of node addr
		xchg	ah, al
		stosw

		mov	al, EE_OEM_NODE_ADDR_WORD2
		call	ReadEEProm		  ; read word 2 of node addr
		xchg	ah, al
		stosw
;
; check to make sure the board is visible (ie. no conflict with IOBase).  since
; the PCI adapter doesn't have the EISA manufacturer ID in Window 0 anymore, we
; now use the Window 5 to check this
;
		mov	dx, PortCmdStatus
		SelectWindow WNO_READABLE

		mov	ax, CMD_SETTXSTART + 0
		out	dx, ax

		mov	dx, PortTxStart
		in	ax, dx
		test	ax, ax
		jnz	bind_ioconflict

		mov	dx, PortCmdStatus
		mov	ax, CMD_SETTXSTART + (TXSTART_DISABLED / 4)
		out	dx, ax

		mov	dx, PortTxStart
		in	ax, dx
		cmp	ax, TXSTART_DISABLED
		je	InitTxDisable

bind_ioconflict:
		jmp	nohardware

InitTxDisable:
; init DPD
		mov	dword ptr DPD.DPD_DnNextPtr, 0	;use single DPD
		mov	ax, ds
		mov	bx, offset DGroup:TxBuf
		mov	dx, ax
		shr	dx, 12
		shl	ax, 4
		add	ax, bx
		adc	dx, 0
		mov	si, offset DPD
		mov	word ptr [si].DPD_Frag.Frag_physaddr, ax
		mov	word ptr [si].DPD_Frag.Frag_physaddr+2, dx
		mov	word ptr [si].DPD_Frag.Frag_len, MAX_RXBYTES
		mov	word ptr [si].DPD_Frag.Frag_len+2, 8000h   ;last frag.

		mov	ax, ds
		mov	bx, offset DPD
		mov	dx, ax
		shr	dx, 12
		shl	ax, 4
		add	ax, bx
		adc	dx, 0
		mov	word ptr DPD_physaddr, ax
		mov	word ptr DPD_physaddr+2, dx
; init UPD
		mov	dword ptr UPD.UPD_UpNextPtr, 0	;use single UPD
		mov	ax, ds
		mov	bx, offset DGroup:RxBuf
		mov	dx, ax
		shr	dx, 12
		shl	ax, 4
		add	ax, bx
		adc	dx, 0	 
		mov	si, offset UPD
		mov	word ptr [si].UPD_Frag.Frag_physaddr, ax
		mov	word ptr [si].UPD_Frag.Frag_physaddr+2, dx
		mov	word ptr [si].UPD_Frag.Frag_len, MAX_RXBYTES
		mov	word ptr [si].UPD_Frag.Frag_len+2, 8000h   ;last frag.

		mov	ax, ds
		mov	bx, offset UPD
		mov	dx, ax
		shr	dx, 12
		shl	ax, 4
		add	ax, bx
		adc	dx, 0
		mov	word ptr UPD_physaddr, ax
		mov	word ptr UPD_physaddr+2, dx
   
;-------------------------------------------------------------------------------
; read a few things off the board
;
; note: because of the delays required for the EEProm accesses, we're going to
;	have interrupts disabled for a rather long time (hundreds of usec), but
;	since this is only init time, and our only other choice would be to
;	do this resident, we're going to do it anyway.
;
		mov	dx, PortCmdStatus
		SelectWindow WNO_FIFO

;		mov	dx, PortMediaOptions
;		in	ax, dx
;		mov	MediaOptions, ax

		mov	dx, PortInternalCfgH
		in	ax, dx
		mov	InternalConfig.hiword, ax

		mov	dx, PortInternalCfgL
		in	ax, dx
		mov	InternalConfig.loword, ax

		mov	dx, PortCmdStatus
		SelectWindow WNO_SETUP

		mov	al, EE_SOFTWARE_INFO
		mov	dx, PortEECmd
		call	ReadEEProm		  ; read software info
		mov	EESoftConfigInfo, ax

		mov	al, EE_SOFTWARE_INFO_2
		call	ReadEEProm		  ; read software info 2
		mov	EESoftConfigInfo2, ax

		mov	al, EE_CAPABILITY_WORD
		call	ReadEEProm
		mov	EECapabilities, ax

		mov	al, EE_INTERNAL_CFG_WORD0
		call	ReadEEProm
		mov	EEIntConfig0,ax

		mov	al, EE_INTERNAL_CFG_WORD1
		call	ReadEEProm
		mov	EEIntConfig1,ax

		mov	al, EE_CWORD
		call	ReadEEProm		  ; read Compatibility word
		mov	CWord, ax

		mov	al, EE_MII_SELECT
		call	ReadEEProm
		and	ax, EE_MII_SELECT_MASK
		mov	MiiSelect,ax
;; 980519
		mov	al, EE_MEDIAOPTIONS
		call	ReadEEProm
		mov	MediaOptions, ax
;;;;

; initialize IRQ on 8259 and remap vector to our interrupt service routine

		mov	al, IRQLevel
		call	SetInterruptVector

		mov    ax, 0

Init_Adapter_rtn:
		sti
		ret

Init_Adapter	endp


IFNDEF	UNDI
;--------------------------------------------------------------------------;
; ASConfig	autoscan Configuration Utility for 5X9. Will call Elnk3Conf
;
; Exit		cf	= clear No Change
;			= set	Changes are made
;
;--------------------------------------------------------------------------;
ASConfig	proc	near

  		; Check Fail/Warning Level to see if PROM should
		; dump any messages
		mov	dx, PortEECmd
		mov	al, EE_CWORD
		call	ReadEEPROM

		cmp	ah, LEVEL_FAIL		; is fail level ok?
		jbe	ChkWarnLevel

		call	ClearScreen
		mov	bx, offset CGroup:StrFailLevel
		xor	al, al
		call	PrintErrMsg
		call	ClearScreen

NoConfigJmp:	clc
		jmp	NoConfig

ChkWarnLevel:
		cmp	al, LEVEL_WARNING	; is warning level ok?
		jbe	ChkLevelDone

		call	ClearScreen
		mov	dx, word ptr CGroup:[StrWarnLevel]
		mov	ah, NormalAttr
		mov	bx, offset CGroup:StrWarnLevel+2
		call	PrintMsgLoc

		mov	si, 3			; 3 seconds
		call	ChkKey
		call	ClearScreen

ChkLevelDone:	; 940107 is CFG disabled by BW5X9.EXE ?
		mov	ax, BWTFeature
		test	ax, BWTFEA_CONF
		jnz	NoConfigJmp

; 930916 all 5X9Conf code will be here {
		call   ClearScreen
		call   ChkForCfg
		jnz    NoConfigJmp

		; setup ScreenAttributes
		mov	ax, CUIAttr
		mov	NormalAttr, al
		mov	ReverseAttr, ah

		mov	bx, InternalConfig.hiword
		mov	dx, EESoftConfigInfo

		mov	si, offset BoardID
		mov	di, IOBase
		mov	al, BusType

		call	ELNK3CONF
		jnc	NoConfig

		mov	EESoftConfigInfo, dx

		stc
NoConfig:
		pushf
		call   ClearScreen
		popf
		ret

ASConfig	endp


;--------------------------------------------------------------------------;
; UpdatePCI_PEROM	Update the BootWare Table of the PEROM for PCI V3
;
; Exit		bx  = 0, no problem
;		   != 0, pointer to error Message
;--------------------------------------------------------------------------;
UpdatePCI_PEROM proc	near

		mov	bx, 8
		call	FixRAMWidth

		; find a clean/free extend memory region
		call	FindExtendMemory
		cmp	UseExtendMem, 0
		jnz	ExtendMemFound

UpdateErr:
		mov	bx, offset CGroup:MsgUpdateErr
		jmp	UpdatePEROMExit

ExtendMemFound:
		; Use Word rather than DWord when READing/WRITing to config
		; space so that I can use Periscope to look at it
		; Fetch current Expansion +ROMBase Address so that we can
		; restore it later
		mov	bx, PCIBusDevFunc
		mov	di, PCIC_BIOSROMCONTROL + 2
		mov	ax, PCI_FUNCTION_ID shl 8 + READ_CONFIG_WORD
		int	01ah
		mov	OldPCIROMAddr+2, cx

		; assume bx preserved
		mov	di, PCIC_BIOSROMCONTROL
		mov	ax, PCI_FUNCTION_ID shl 8 + READ_CONFIG_WORD
		int	01ah
		mov	OldPCIROMAddr, cx

		; map BootROM at UseExtendMem.
		mov	cx, UseExtendMem
		mov	bx, PCIBusDevFunc
		mov	di, PCIC_BIOSROMCONTROL + 2
		mov	ax, PCI_FUNCTION_ID shl 8 + WRITE_CONFIG_WORD
		int	01ah

		; assume bx preserved
		mov	cx, 01			; enable ROM
		mov	di, PCIC_BIOSROMCONTROL
		mov	ax, PCI_FUNCTION_ID shl 8 + WRITE_CONFIG_WORD
		int	01ah

		; Update Physical BootROM with the appropriate information
		; Steps:
		; 1. Copy the first 256 bytes from BootROM to Elnk3ConfSparse
		; 2. Verify 1st 2 bytes are 55 AA
		; 3. Update appropriate data
		; 4. Copy data from AutoScanBuffer to BootROM
		; 5. Verify results and retry is necessary

		; First, Copy 256 bytes from BootROM to Elnk3ConfSparse
		; On entry	BX:DI is destination address
		;		DX:SI is source address
		;		CX    is byte count.

		mov	UpdateRetry, 3

UpdateMemRetry:
		cmp	UseExtendMem, 0ah
		jnz	CopyFromExtend

		; Segment A000 Update {
		push	ds
		mov	cx, 40h
		xor	esi, esi
;960529		mov	si, AtmelOffset
		mov	si, ROMCODESTART
		xor	edi, edi
		mov	di, AutoScanBuffer
		mov	ax, 0a000h
		mov	ds, ax
;		rep	movsd
CopyA000Lp1:
		lodsd
		jmp	$+2
		jmp	$+2
		jmp	$+2
		stosd
		loop	CopyA000Lp1
		pop	ds
		jmp	short UpdateChk55AA
		; Segment A000 Update }

CopyFromExtend:
		mov	cx, 010h
		mov	ax, cs
		mul	cx
		mov	bx, dx
		mov	di, ax
		add	di, AutoScanBuffer
		adc	bx, 0

		mov	dx, UseExtendMem
;960529		mov	si, AtmelOffset
		mov	si, ROMCODESTART
		mov	cx, 100h
		call	CopyMemory

UpdateChk55AA:
		; Should at least make sure that AutoScanBuffer
		; contains the 55 AA signature
		mov	bx, offset CGroup:MsgUpdateErr
		mov	di, AutoScanBuffer
		cmp	word ptr [di], 0aa55h
		jnz	UpdateMemRemap

		; Update BWTLANOS, BWTFeature, BWTEthStd
;960529		mov	di, AutoScanBuffer

		mov	al, BWTLANOS
		mov	byte ptr [di+offset BWTLANOS], al

		mov	ax, BWTFeature
		mov	word ptr [di+offset BWTFeature], ax

;970219		mov	ax, BWTEthStd
;		mov	word ptr [di+offset BWTEthStd], ax

;		mov	al, BWTAddrRes
;		mov	byte ptr [di+offset BWTAddrRes], al


		; Calculate checksum of BootROM Table
		xor	cx, cx
		mov	cl, byte ptr cs:[8]
		dec	cl
		mov	si, AutoScanBuffer
		add	si, 8
		add	di, offset BWTChkSum		; di still points to AutoScanBuffer
		call	SetChkSum


		cmp	UseExtendMem, 0ah
		jnz	CopyToExtend

		; Segment A000 Update {
		push	es
		mov	ax, 0a000h
		mov	es, ax
		mov	cx, 20h
		xor	esi, esi
		xor	edi, edi
;960529		mov	di, AtmelOffset
		mov	di, ROMCODESTART
		mov	si, AutoScanBuffer
;		rep	movsd
CopyA000Lp2:
		lodsd
		jmp	$+2
		jmp	$+2
		jmp	$+2
		stosd
		loop	CopyA000Lp2

		mov	cx, Delay25ms
		call	WaitTime

		mov	cx, 20h
CopyA000Lp3:
		lodsd
		jmp	$+2
		jmp	$+2
		jmp	$+2
		stosd
		loop	CopyA000Lp3

		pop	es
		jmp	short UpdateVerify
		; Segment A000 Update }

CopyToExtend:
		; Extend Memory Update {
		; Copy First 256 bytes to Physical BootROM
		mov	cx, 010h
		mov	ax, cs
		mul	cx
		mov	si, ax
		add	si, AutoScanBuffer
		adc	dx, 0

		mov	bx, UseExtendMem
;960529		mov	di, AtmelOffset
		mov	di, ROMCODESTART
		mov	cx, 80h
		call	CopyMemory

		mov	cx, Delay25ms
		call	WaitTime

		mov	cx, 80h
		call	CopyMemory
		; Extend Memory Update }

UpdateVerify:
		mov	cx, Delay25ms
		call	WaitTime

		cmp	UseExtendMem, 0ah
		jnz	CopyToVerify

		; Segment A000 Update {
		jmp	$+2
		jmp	$+2
		jmp	$+2

		push	ds
		mov	cx, 40h
		xor	esi, esi
;960529		mov	si, AtmelOffset
		mov	si, ROMCODESTART
		xor	edi, edi
		mov	di, AutoScanBuffer
		add	di, 100h
		mov	ax, 0a000h
		mov	ds, ax

CopyA000Lp4:
		lodsd
		jmp	$+2
		jmp	$+2
		jmp	$+2
		stosd
		loop	CopyA000Lp4

		pop	ds
		jmp	short UpdateCompare
		; Segment A000 Update }

CopyToVerify:
		; Verify PEROM content
		; es:di points to AutoScanBuffer
		; ds:si points to AutoScanBuffer+100h
		mov	cx, 010h
		mov	ax, cs
		mul	cx
		mov	bx, dx
		mov	di, ax
		add	di, AutoScanBuffer
		adc	bx, 0
		add	di, 100h
		adc	bx, 0

		mov	dx, UseExtendMem
;960529		mov	si, AtmelOffset
		mov	si, ROMCODESTART
		mov	cx, 100h
		call	CopyMemory

UpdateCompare:
		mov	bx, offset CGroup:MsgUpdateOk

		mov	di, AutoScanBuffer
		mov	si, di
		add	si, 100h
		mov	cx, 100h
		repz	cmpsb
		jz	UpdateMemRemap

		mov	bx, offset CGroup:MsgVerifyBad
		dec	UpdateRetry
		jz	UpdateMemRemap

		jmp	UpdateMemRetry

UpdateMemRemap:
		push	bx
		; Restore Expansion ROM Base Adress Register
		mov	bx, PCIBusDevFunc
		mov	cx, OldPCIROMAddr	; Disable ROM first
		mov	di, PCIC_BIOSROMCONTROL
		mov	ax, PCI_FUNCTION_ID shl 8 + WRITE_CONFIG_WORD
		int	01ah

		; assume bx preserved
		mov	cx, OldPCIROMAddr + 2
		mov	di, PCIC_BIOSROMCONTROL + 2
		mov	ax, PCI_FUNCTION_ID shl 8 + WRITE_CONFIG_WORD
		int	01ah

		mov	bx, 0fff7h
		call	FixRAMWidth
		pop	bx

UpdatePEROMExit:
		ret
UpdatePCI_PEROM endp

; Extended memory global descriptor structure:

DESCRIPTOR	STRUC
Dummy		DW	0, 0, 0, 0
GDT_LOC 	DW	0, 0, 0, 0
SourceLimit	DW	0
SourceLoWord	DW	0
SourceHiByte	DB	0
SourceRights	DB	0
SourceInternal	db	0
SourceHiByteHi	db	0
TargetLimit	DW	0
TargetLoWord	DW	0
TargetHiByte	DB	0
TargetRights	DB	0
TargetInternal	db	0
TargetHiByteHi	db	0
Bios		DW	0, 0, 0, 0
Temp		DW	0, 0, 0, 0
DESCRIPTOR	ENDS

GDT		Descriptor <>

;--------------------------------------------------------------------
; FixRAMWidth()
;
;	- When we detect that InternalConfig.ramWidth is byte-wide,
;	  we need to fix an ASIC problem where we cannot
;	  write to the Atmel PEROM. All the odd location bytes are
;	  overwritten with zero
;	- toggle 3C590.InternalConfig.ramWidth between Byte-wide and
;	  Word-wide. Because InternalConfig.ramWidth toggles, we
;	  can't use ramWidth to determine if adapter need Fix
;
; Input 	bx = 8		to change ramWidth to WordWide
;		   = 0fff7h	to change ramWidth to ByteWide
;--------------------------------------------------------------------
FixRAMWidth	proc	near

		; is adapter 3C590, 3C592 or 3C597?
		cmp	BusType, BUS_EISA
		jz	FixRAMWidthNow

		; Goto ConfigSpace DeviceID (offset2) to distinguish
		; between 3C590 and 3C595. CANNOT use PCIStructure
		; in ROM because Award uses BootWare/3C595
		; rather than BootWare/3C590 for the 3C590 adapter.
		push	bx
		mov	bx, PCIBusDevFunc
		mov	di, PCIC_DEVICEID
		mov	ax, PCI_FUNCTION_ID shl 8 + READ_CONFIG_WORD
		int	01ah
		pop	bx
		cmp	cx, PCI_DeviceID
		jnz	FixRAMWidthExit

FixRAMWidthNow:
		; Does version of ASIC contain bug?????????
		mov    dx, PortCmdStatus
		SelectWindow WNO_FIFO
;960401		port	InternalCfgL, CmdStatus
		mov	dx, PortInternalCfgL
		in	ax, dx

		test	bx, 8
		jnz	FixRAMWidthWord

		and	ax, bx
		jmp	short SetRAMWidth

FixRAMWidthWord:
		or	ax, bx

SetRAMWidth:
		out	dx, ax

		mov	dx, PortCmdStatus
		SelectWindow WNO_SETUP

FixRAMWidthExit:
		ret
FixRAMWidth	endp

;--------------------------------------------------------------------
; CopyMemory	Copy block of memory to/from extended memory
;
; On entry	BX:DI is destination address
;		DX:SI is source address
;		CX    is byte count.
;
;	Addresses is 32bit address
;	Assume CS=ES=DS
;--------------------------------------------------------------------
CopyMemory proc near

  	push	di
	push	cx
	mov	di, offset GDT
	mov	cx, (size DESCRIPTOR)/2
	xor	ax, ax
	rep	stosw
	pop	cx
	pop	di

	mov	ax, bx
	mov	bx, OffSet GDT	; address of GDT (es:si)
	mov	[bx].SourceLimit, cx	; set copy size
	mov	[bx].TargetLimit, cx	; set copy size
	mov	[bx].SourceRights, 93h	; set copy rights
	mov	[bx].TargetRights, 93h	; set rights

	mov	[bx].SourceLoWord, si	; set source address lo word
	mov	[bx].SourceHiByte, dl	; set source address LowByte of HighWord
	mov	[bx].SourceHiByteHi, dh ; set source address HighByte of HighWord

	mov	[bx].TargetLoWord, di	; set dest address low word
	mov	[bx].TargetHiByte, al	; set dest address lowbyte of High Word
	mov	[bx].TargetHiByteHi, ah ; set dest address highbyte of high word

	shr	cx, 1			; now cx is word count

	mov	si, bx			; es:si = GDT
	mov	ah, 87h
	int	15h			; move data to/from extended memory

	ret

CopyMemory EndP

;--------------------------------------------------------------------
; FindExtendMemory	- From Top of extended memory, find a region
;			  of extended memory we can use and return the
;			  Most Significant Word of the 32 bit address
;			- verify that the region we choose is unoccupied
;			  by examing the first 128 bytes of the 64K region
;			  and make sure the values are the same
;			- if region is occupied, goto next 64K region
;			  until we reach f000 0000
;
; Return:	ax =  Most Sign. Word of the 32Bit address that ROM code
;			can be copied to
;		   = error
;
;--------------------------------------------------------------------
FindExtendMemory	proc	near

		; Setup AutoScanBuffer
		; ** Elnk3ConfSparse is memory that we will throw away
		;    after AutoScan. Use it as a temporary buffer **
		; 950306 There are 1B0h bytes in Elnk3ConfSparse I can use
		mov	di, offset Elnk3ConfSparse
		inc	di
		and	di, 0fffeh		; make sure Buffer is Word Align
		mov	AutoScanBuffer, di


		; Before using Extended memory, check if A000:0 region is
		; available. Since A000:0 is below 1M, no need to use
		; CopyMemory to verify result
		push	ds
		mov	ax, 0a000h
		mov 	ds, ax
		xor	si, si
		mov	cx, 0ffffh

		lodsb
		mov	ah, al

FindA000Loop:
		lodsb
		cmp	ah, al
		jnz	FindA000

		loop	FindA000Loop

FindA000:	pop	ds

		cmp	cx, 0
		jnz	FindExtendMem

		mov	ax, 0ah
		mov	UseExtendMem, ax
		ret

FindExtendMem:
		mov	ah, 088h
		int	15h

		push	cx
		mov	cx, 040h
		div	cl		; divide by 40 to get starting 32bit
					; address
		xor	ah, ah		; ignore remainder
		add	ax, 020h	; add 1M for conventional RAM &
					; choose 1M above top of ExtendRAM
		mov	UseExtendMem, ax

		; Copy 128 bytes to AutoScanBuffer
		mov	cx, 010h
		mov	ax, cs
		mul	cx
		mov	bx, dx
		mov	di, ax
		add	di, AutoScanBuffer
		adc	bx, 0

		push	bx
		push	di

ExtendMemNextLp:
		pop	di
		pop	bx

		push	bx
		push	di

		mov	dx, UseExtendMem
		xor	si, si
		mov	cx, 080h
		call	CopyMemory

		; Make sure values in the AutoScanBuffer are identical
		;
		mov	cx, 07fh
		mov	si, AutoScanBuffer

		lodsb
		mov	ah, al

ExtendMemChkLoop:
		lodsb
		cmp	ah, al
		jnz	ExtendMemNext		; exit with zf cleared

		loop	ExtendMemChkLoop

FindExtendMemExit:
		mov	ax, UseExtendMem

		pop	di
		pop	bx

		pop	cx
		ret

ExtendMemNExt:
		inc	UseExtendMem		; goto next 64K region
		cmp	UseExtendMem, 0f000h
		jb	ExtendMemNextLp

		mov	UseExtendMem, 0
		jmp	short FindExtendMemExit

FindExtendMemory	endp

;--------------------------------------------------------------------
; FindStack	- From Top of conventional memory, find 1K of RAM
;		  we can use and return the Segment Value
;		- verify that the region we choose is unoccupied by
;		  examing the 1K region (make sure the values are identical)
;		- if region is occupied, goto next 1K region below
;		  until we reach 1000:0
;
; Entry
; Return:	ax = Segment Value of Stack
;
;--------------------------------------------------------------------
FindStack	proc	near
		push	ds
		push	bx
		push	cx
		int	12h
		sub	ax, 020h		; subtract 32K
		mov	cl, 6
		shl	ax, cl			; convert to segment form
		mov	ds, ax			; ES = Stack base

FindStackAgain:
		mov	cx, 07fh		; test 256 bytes
		mov	si, InitStackPtr
		lodsw
		mov	bx, ax

FindStackLoop:
		lodsw
		cmp	bx, ax
		jnz	FindStackNext

		loop	FindStackLoop

		; Carry would be cleared

		; ES is the stack segment!!
		mov	ax, ds
FindStackExit:
		pop	cx
		pop	bx
		pop	ds
		ret

FindStackNext:	mov	ax, ds
		sub	ax, 0800h
		mov	ds, ax

		cmp	ax, 01000h
		jae	FindStackAgain

		; No way. Can't find 1K free anywhere.
		; Just use ROMBase
		mov	ax, cs		; cs = ROMBase
		jmp	short FindStackExit

FindStack	endp
ENDIF

	include		nad90xb.inc
	include		bw90xb.inc


IFNDEF	UNDI
; ************************************************************************
; HOOKS for CUI.ASM
HookChkChar	proc	near
HookEditInput	proc	near
HookChkInput	proc	near
HookHyphen	proc	near
HookEditSpec	proc	near
		stc
		ret
HookEditSpec	endp
HookHyphen	endp
HookChkInput	endp
HookEditInput	endp
HookChkChar	endp

;----------------------------------------------------------------------
; StoHex - stuff binary AL as 2 hex digits at ES:DI
;
; On entry,
;	AL = binary digit to print as hex
;	ES:DI ptr to string buffer, CLD flag set
; On exit,
;	AX modified, ES:DI ptr to next location in buffer
;
; 920728 1.0 GK adapted from PutHex
;----------------------------------------------------------------------

StoHex	proc	near

	push	ax			; save for lower nibble
	shr	al,1
	shr	al,1
	shr	al,1
	shr	al,1
	call	h_digit
	pop	ax			; now do lower nibble

h_digit:
	and	al,00001111b
	add	al,90h
	daa
	adc	al,40h
	daa
	stosb				; stuff hex digit in buffer
	ret

StoHex	endp

;----------------------------------------------------------------------
; StoDec - stuff AX as CL decimal digits at ES:DI
;
; On entry,
;	AX = number to print as decimal
;	ES:DI ptr to leftmost position of field
;	CL has width of field, will zero-fill
; On exit,
;	AX, CX, DX modified, ES:DI ptr to beyond rightmost position
;
; 920728 1.0 GK adapted from PutHex
;----------------------------------------------------------------------

StoDec		proc	near

		push	ax		; save value
		mov	al, '0'
		mov	ch, 0
		rep	stosb		; fill with zeroes

		mov	cl, 0Ah 	; divide by 10
		pop	ax		; restore value
		push	di		; save ending DI value

StoDecNext:
		xor	dx, dx
		div	cx		; ax, dx rem=dx:ax/reg
		add	dl, 30h 	; '0'
		dec	di
		mov	es:[di], dl
		or	ax, ax
		jnz	StoDecNext

		pop	di		; return with DI pointing after field
		ret

StoDec		endp
ENDIF

;--------------------------------------------------------------------
;
;   SetInterruptVector: this routine determine the mask value for the selected
;			IRQ level and EOI values for both master and slave
;			8259s, remaps IRQ vector to our ISR and save current
;			IRQ vector in case DriverUnhook needs it.  We do not
;			mask on the selected IRQ in this routine, instead, it
;			will be turned on and off as init goes on.
;
;   On Entry:
;	      al = IRQ level
;	      sti
;   On Exit:
;	      sti
;
; 920717 0.0 GK modified, rewrote DOS get/setint calls
;--------------------------------------------------------------------

HookIntVector	proc	near
		push	es

; convert IRQ to interrupt vector number

		mov    al, IRQLevel		    ; al = IRQ level
		mov    ah, 8			    ; IRQ 0-7 => int vector # 08h-0fh
		cmp    al, 8
		jb     int_8tof
	
		mov    ah, (70h-8)		    ; IRQ 8-15 => int vector # 70h-77h
int_8tof:
		add    al, ah			    ; al = int vector number
		cli

; save old interrupt vector

		xor	bx, bx
		mov	es, bx			; ES = 0
		cbw
		mov	bx, ax
		shl	bx, 1
		shl	bx, 1
		les	bx, es:[bx]
		mov	OrgINTVector_Off, bx
		mov	OrgINTVector_Seg, es

; remap int vector to our DriverISR
IFDEF	UNDI
		mov    dx, offset CGroup:UNDI_DriverISR   ; ds:dx = ptr to DriverISR
ELSE
		mov    dx, offset CGroup:DriverISR   ; ds:dx = ptr to DriverISR
ENDIF
		xor	di, di
		mov	es, di			; ES = 0
		cbw
		mov	di, ax
		shl	di, 1
		shl	di, 1

		mov	cs:Int_Vector_Loc, di
	
		mov	ax, dx
		stosw
		mov	ax, cs		;971030
		stosw

; PCInit (GENR.ASM) will mask out IRQ9. Need to unmask again
		mov	al, IRQLevel		    ; al = IRQ level
		cmp	al, 7
		jbe	HookInt9

		in	al, 0A1h		; get slave PIC mask
		jmp	$+2
		and	al, 0fdh		; unmask int 9
		out	0A1h, al

HookInt9:
		; unmask Interrupt now
		mov    dx, int_mask_port
		in     al, dx

		and    al, IntMaskOnBit
		jmp    $+2

		out    dx, al

		cmp    dx, MASTER_MASK_PORT		  ; are we using IRQ from slave?
		je     HookIntVectorExit		 ; no

		in     al, MASTER_MASK_PORT		  ; yes, turn on cascaded input
		and    al, not 04			  ;  on master 8259
		out    21h, al

HookIntVectorExit:
		pop	es
		sti
		ret

HookIntVector	endp


;-----------------------------------------------------------------------------
;   Driver Unhook
;
;   assumes:
;	     DS is setup
;	     Interrupts are DISABLED
;
;   returns:
;	     interrupt disabled
;	     no registers need to be preserved.
;-----------------------------------------------------------------------------
DriverUnhook  proc near

		xor	ax, ax
		mov	es, ax
		mov	di,word ptr cs:Int_Vector_Loc

		mov	ax, OrgINTVector_Off
		or	ax, OrgINTVector_Seg
		jz	unhook_rtn			;nothing to unhook
		mov	ax, OrgINTVector_Off
		mov	es:[di].off, ax
		mov	ax, OrgINTVector_Seg
		mov	es:[di].segm, ax
unhook_rtn:
		ret

DriverUnhook  endp

IFNDEF	UNDI
;----------------------------------------------------------------------------;
;      E I S A	  S U P P O R T    R O U T I N E S
;----------------------------------------------------------------------------;
;------ WriteEEProm ---------------------------------------------------------;
;									     ;
;	This routine writes  a word to the EEProm.  It can only be used      ;
;	once the board has been brought up at a particular IOBase.	     ;
;									     ;
;	Entry:								     ;
;	BL	= EEProm word to write					     ;
;	CX	- Value to write
;	Window	= 0							     ;
;	RealIOBase  = valid						     ;
;	cli								     ;
;									     ;
;	Exit:								     ;
;	cli								     ;
;									     ;
;	Destroys BX, CX, DX, SI, DI and ES.  All other registers are	     ;
;	preserved.							     ;
;									     ;
;----------------------------------------------------------------------------;
public		WriteEEProm
WriteEEProm	proc	near
	push	bx
	push	cx
	push	dx

	; To write a word to EEPROM, sequence of events are
	;	1. Issue Erase/Write Enable Cmd ( Port IOBase+A, Value 30h )
	;	2. Issue Erase Cmd ( Port IOBase+A, Value C0h or Address )
	;	3. Issue Erase/Write Enable Cmd again ( Port IOBase+A, Value 30h )
	;	4. Load data into EEPROM Data Reg ( Port IOBase+C, Value Data )
	;	5. Issue Write Cmd ( Port IOBase+A, Value 40 or Address )
	;
	; Always check if EEPROM Busy bit is cleared
;960401	mov	dx, IOBase
;960401	add	dx, PORT_EECmd
	mov	dx, PortEECmd
	call	WaitEEBusy

	mov	ax, 030h
	out	dx, ax				; issue Erase/Write Enable Cmd

	call	WaitEEBusy

	xor	ax, ax
	mov	al, bl
	add	al, 0c0h
	out	dx, ax				; issue Erase EEPROM Cmd

	call	WaitEEBusy

	mov	ax, 030h
	out	dx, ax				; issue Erase/Write Enable Cmd

	call	WaitEEBusy

	mov	ax, cx
;960401	add	dx, ( PORT_EEData - PORT_EECmd )
	mov	dx, PortEEData
	out	dx, ax				; load data

;960401	add	dx, ( PORT_EECmd - PORT_EEData )
	mov	dx, PortEECmd
	xor	ax, ax
	mov	al, bl
	add	al, 040h
	out	dx, ax

	call	WaitEEBusy

	pop	dx
	pop	cx
	pop	bx
	ret
WriteEEProm    endp


;----------------------------------------------------------------------------;
; NADChgReceiveMask - Called by NAD to change the receive mask of adapter.
;		       Change RxFilter to accept Multicast packets
;
; Input:	    bl	  command
;			  b0: set   = enable
;			      clear = disable
;			  b1: change broadcast mask
;			  b2: change multicast mask
;			  b3: change promiscuous mask (not supported yet)
;
;		    es:di pointer to multicast address (FOUND.Dest_Addr)
;
; no reg. changed
;----------------------------------------------------------------------------;
NADChangeReceiveMask	proc	far

		push	si
		push	dx
		push	ax

		mov	dx, PortCmdStatus

	; For the 3Com Chipset, enabling group address reception implies
	; broadcast reception. 
		test	bl, 2			; want to change Broadcast?
		jnz	NADChgBroad

		test	bl, 4			; want to change Multicast?
		jz	NADChgMaskEnd

NADChgMulti:
		test	bl, 1
		jz	NADChgMultiOff

NADChgMultiOn:
		mov	si, offset NIDGroupAddr
		mov	ax, es:[di]
		mov	ds:[si], ax

		add	si, 2
		add	di, 2
		mov	ax, es:[di]
		mov	ds:[si], ax

		add	si, 2
		add	di, 2
		mov	ax, es:[di]
		mov	ds:[si], ax

		mov	ax, HWFilter
		or	ax, FILTER_MULTICAST
		out	dx, ax
		jmp	short NADChgMaskEnd

NADChgMultiOff:
		mov	ax, HWFilter
		and	ax, NOT FILTER_MULTICAST
		out	dx, ax
		jmp	short NADChgMaskEnd

NADChgBroad:
		test	bl, 1
		jz	NADChgBroadOff

NADChgBroadOn:
		mov	ax, HWFilter
		or	ax, FILTER_BROADCAST
		out	dx, ax
		jmp	short NADChgMaskEnd

NADChgBroadOff:
		mov	ax, HWFilter
		and	ax, NOT FILTER_BROADCAST
		out	dx, ax

NADChgMaskEnd:
		mov	HWFilter, ax

		pop	ax
		pop	dx
		pop	si
		retf

NADChangeReceiveMask	endp


;--------------------------------------------------------------------
; ChkForCfg - prompt for config, wait up to 3s for Ctrl-Alt-B or Ctrl-Alt-Z
;
; On exit,
;	ZF set if user selected config option
;
; 911230 0.0 GK
;--------------------------------------------------------------------
ChkForCfg	proc	near
		push	es

		mov	ax, 0040h
		mov	es, ax			; ES = BIOS segment. For ChkKey

;		mov	al, BWTLANOS
;		and	al, BWTLANMASK
;		cmp	al, BWTLANTRI
;		jnz	NotFirst

		; dump "BootWare/3C5x9 supports NetWare..." string & wait for
		; user input
;		mov	ah, NormalAttr
;		mov	si, offset CGroup:Str8022U
;		call	PrintTemplate

;		mov	si, 8			; 8 seconds
;		call	ChkKey

		; check ah to see if <ENTER> is pressed
;		cmp	ah, 01ch	; ZF
;		jmp	short ChkForCfgExit

NotFirst:
		; dump "Press <CTRL><ALT><B>..." string & wait for user input
;		mov	bx, offset CGroup:StrPrompt
;		mov	dx, word ptr [bx]
;		mov	ah, NormalAttr
;		add	bx, 2
;		call	PrintMsgLoc
		mov	dx, 0
		mov	bx, offset cGroup:CfgStr
		call	PrintAt

		mov	si, 3			; 3 seconds
		call	ChkKey

ChkForCfgExit:
		pop	es
		ret			; ret ZF = 1 if config selected

ChkForCfg	endp

;--------------------------------------------------------------------
; ChkKey - prompt for config, wait up to 3s for Ctrl-Alt-B or Ctrl-Alt-Z
;
; On exit,
;	si  = # of seconds
;	ZF set if user selected config option
;
;	For 802.2U, ax = -1 if timeout
;		    ah = keyboard input (scan code)
;
; 911230 0.0 GK
;--------------------------------------------------------------------

ChkKey		proc	near

ChkKeyLoop1:
		mov	ax, 18		; 18 ticks = 1 second

		mov	cs:MaxTicks, ax
		mov	ah, 0
		int	1Ah			; get current tick value
		mov	cs:StartTick, dx	; save it


ChkKeyLoop:
	mov	ah, 1
	int	016h		; Keyboard interrupt - check keyboard status

	jz	ChkKeyTime	; No char available; Check time

; character available. check if char is Ctrl-Alt-B
; checking kybd status will not remove char from buffer

	mov	ah, 0		; Read char. Char is removed from buffer
	int	016h		; Keyboard interrupt

	cmp	ah, 030h	; "B"
	jz	ChkCtrlAlt	; are Ctrl & Alt keys pressed?

	cmp	ah, 02ch	; "Z"
	jnz	ChkKeyEnd

ChkCtrlAlt:
	mov	al, es:[17h]	; keyboard status flag 1
	and	al, 00001100b	; keep Ctrl and Alt bits
	cmp	al, 00001100b	; were they set?
;	 jz	 ChkKeyEnd	 ; yes, exit with ZF set
	jmp	short ChkKeyEnd ; exit with ZF

ChkKeyTime:
	mov	ah, 0
	int	1Ah			; get current tick
	sub	dx, cs:StartTick
	mov	cs:Curticks, dx
	cmp	dx, cs:MaxTicks
	cmc


	jnc	ChkKeyLoop	; Is 1 second yet ????

	mov	al, '.'
	call	PutChr
	dec	si
	jnz	ChkKeyLoop1

	mov	al, -1
	or	al, al		; ret ZF = 0, timeout

ChkKeyEnd:
		ret
ChkKey		endp

ENDIF

;--------------------------------------------------------------------
; Print
;
; Prints string given by DS:BX at current location.
;
; Parameters:
;	ds:bx - pointer to null terminated string
;
; Returns:
;	nothing
;--------------------------------------------------------------------
Print	proc	near

	push	ax			; save ax
	push	si			; save si

	mov	si, bx			; put string address into si

printLoop:
	lodsb				; get a character
	or	al, al			; check for end of line NULL
	je	printDone		; got end of line
	mov	ah, 0Eh
	int	010h			; write TTY
	jmp	short printLoop 	; next char

printDone:
	pop	si			; restore si
	pop	ax			; restore ax
	ret

Print	endp


Int_Vector_Loc		dw	?

IFDEF	UNDI
_TEXT		ends

_DATA		segment	para public
ENDIF
OrgINTVector_Off	dw	0	;save area for original INT vector
OrgINTVector_Seg	dw	0

	even
;------------------------------------------------------------------------------
;	Adapter configuration set by DriverInit during initialization
;------------------------------------------------------------------------------
EEIntConfig0	dw	?		;value of internal config reg
EEIntConfig1	dw	?		;value of internal config reg
EEMiiPhySelect	dw	-1

		even
;
; the various TxStart thresholds, set at INIT time.  must be contiguous and
; MasterTxStart must follow PioTxStart.
;
		even
		public	PioTxStart
PioTxStart	label	word
		rept 4
		TxStartStruc <?, 4, 0, 0, 0, 0>
		endm

		public	AfterTxStart
AfterTxStart	label	word			; marks the end of them

TxFreeMax	dw	?

IntMaskOnBit	db	?
IRQLevel	db	?

		   even

public		BoardID
BoardID 	db	6 dup (0)
LineSpeed	dw	10		;10/100 Mb determined at init

		even

MediaOptions	dw	?
InternalConfig	dd	?

	public	xcvr
xcvr		dw	?		; 10/20/94, cj

OldStackPtr	dw	0		; save Stack Pointer
		dw	0

		   even
PortCmdStatus		dw	0eh	; Win 0	; Command/Status Register

PortBadSsdCount    	label	word	; Win 4
PortTxFree		label	word	; Win 3 
PortEEData  		dw	0Ch	; Win 0 ; EEProm data register

PortMediaStatus		label	word	; Win 4 ; Media type/status
PortRxFree		label 	word	; Win 3	; Rx Free
;PortTimer		label	word	; Win 1 ; 
PortEECmd      		dw	0Ah	; Win 0 ; EEProm command register

PortMediaOptions  	label 	word	; Win 3 ; MediaOptions
PortPhyMgmt		label	word	; Win 4 ; MII Management 
;PortRxStatus		label	word	; Win 1
PortCfgResource 	dw	08h	; Win 0 ; resource configuration

PortNetDiag		label	word 	; Win 4 ; net diagnostic
PortMacControl		label	word	; Win 3 ; MacControl
PortCfgAddress  	dw	06h	; Win 0 ; address configuration

PortFIFODiag		label	word	; Win 4 ; FIFO Diagnostic
PortCfgControl  	dw	04h	; Win 0 ; configuration control

PortInternalCfgH   	label 	word    ; Win 3 ; InternalConfig High
PortProductID   	dw	02h	; Win 0 ; product id (EISA)

PortTxStart		label	word	; Win 5 ; tx start threshold
PortInternalCfgL   	label 	word	; Win 3 ; InternalConfig Low
PortSA0_1  		label	word	; win 2 ; station address bytes 0,1
;PortRxFIFO	   	label 	word	; Win 1 ; offset 00
;PortTxFIFO	   	label 	word	; Win 1 ; offset 00
PortManufacturer	dw	00h	; Win 0; Manufacturer code (EISA)

PortTxStatus		dw	1bh
;
PortPktStatus		dw	20h	; scatter/gather state bits
PortDnListPtr		dw	24h	; phys addr of current DPD
PortUpPktStatus		dw	30h	; upload packet status
PortUpListPtr		dw	38h	; phys addr of current UPD
; cyclone specific
PortDmaCtrl		dw	20h	; formerly Pktstatus
PortDnReq		dw	2Ch
PortDnPoll		dw	2Dh
PortUpReq		dw	3Ch
PortUpPoll		dw	3Dh

NumOfPorts	equ	( $ - PortCmdStatus )/ 2 

; PCI and Extended Memory Stuff
UseExtendMem	dw	0

OldPCIROMAddr	dw	0
		dw	0

AutoScanBuffer	dw	0

CUIAttr 	dw	0		; Store Screen Attribute for CUI
UpdateRetry	db	3		; times to retry before giving up

 		   ALIGN       4

NormalRxEarly	   dw	     ?		; set RxEarly cmd + threshold

CurTxStart	   dw	     CMD_SETTXSTART+TXSTART_DISABLED

PadBytes	   db	     ?

EESoftConfigInfo	dw	?	; EEPROM word 0d
EESoftConfigInfo2	dw	?
CWord			dw	?	; EEPROM word 0e
EECapabilities		dw	0	; EEPROM word 010h
BusType 		db	?	;

		ALIGN	4
eoi_value	dw	?		; ah = master, al = slave
int_mask_port	dw	?

		ALIGN	4
HwFilter	dw	?
IRQBit			db	?

StartTick	dw	0		; save area for tick value
RxPend		db	0		; b7 set if pending for Rx packet
					;  XXXXX NO XXX  else has rx status (0, 1)
IFNDEF	UNDI
MaxTicks	dw	0		; save area for max ticks
CurTicks	dw	0		; save area for current ticks

TxRetries	db	0		; transmission retry count
DestID		db	6 dup (?)	; save area for destination node ID

StatusMsgFlag	dw	0		; pointer to msg to be printed in DLCStatus

MemBase 		dw	0	; for TCP/IP Generic
					; also used to store OldBWTFeature

		ALIGN	4		; always dword-aligned
LookAheadBuffer    db	     LxBufSize+3 dup (?)   ; receive lookahead buffer

		ALIGN   4
TxEDPtr 	dd	?		; save area for transmit ED
RxEDPtr 	dd	?		; save area for receive ED

		ALIGN     4
public		CliBuffer
CliBufferSize	equ	128
CliBuffer	db	CliBufferSize dup (?)	; ** not needed, may be removed
						; along with other code in init
						; that computes copycli

		even
NIDGroupAddr	db	6 dup(0)	; GroupAddr
;ErrStruct	ErrorStruct < 0, 0, 0 >

;public		APITbl
;APITbl		dw	'WB'            ; start of BootWare API table
;		dw	30 dup (0)	; allocate 60 bytes ?
ENDIF

flag		dw	0

MiiSelect	dw	-1
MiiPhyUsed	dw	0
MiiPhyOui	dw	-1
MiiPhyModel	dw	-1
;MiiRegValue	dw	-1
MiiPhyAddr	db	0

phyANLPAR	dw	0
phyANAR 	dw	0

LinkDetected	db	0
forcemode	db	0
broadcom	db	0

Calibration	dd	0
Delayoneusec	dd	0
DelaySomething	dd	0

tempLoc     dw  0

;******************************************************************************
	align	8
DPD		DPDStruc <>
DPD_physaddr	dd	?

	align	8
UPD		UPDStruc <>
UPD_physaddr	dd	?



IFDEF	UNDI
_DATA		ends

_BSS	segment
 	even
	public	TxBuf
	public	RxBuf
TxBuf		db	MAX_RXBYTES dup(?)
RxBuf		db	MAX_RXBYTES dup(?)

_BSS	ends

ELSE
END_NAD
ENDIF

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c90x\vulcan.inc ===
;------ VULCAN.INC ----------------------------------------------------------;
;                                                                            ;
;       This file contains Vulcan-specific equates, structures and           ;
;       macros.  It must be assembled with MASM 5.1 or later.                ;
;                                                                            ;
;----------------------------------------------------------------------------;
;----------------------------------------------------------------------------;
;                                                                            ;
;       This source file is the property of 3Com Corporation and may not be  ;
;       copied or distributed in any isomorphic form without an appropriate  ;
;       prior licensing arrangement with 3Com Corporation.                   ;
;                                                                            ;
;       Copyright (c) 1993 3Com Corporation                                  ;
;                                                                            ;
;       3Com Corporation                                                     ;
;       5400 Bayfront Plaza, P.O. Box 58145                                  ;
;       Santa Clara, CA 95052-8145 USA                                       ;
;       (408) 764-6016                                                       ;
;                                                                            ;
;----------------------------------------------------------------------------;
;
;      10/06/94    delete MEDIA_SQE, add MEDIA_TXINPROG, add PORT_RxError
;                  redefine RxStatus/RxError register bits
;      10/18/94    delete BUS_MCA, add BUS_UNKNOWN, BUS_PCI
;      10/19/94    define new port offsets for window 3 and window 7
;      10/19/94    add adapter codes
;      10/20/94    add new equs: MEDIA_CRCSTRIPDISABLE, MEDIA_DATARATE100,
;                  MEDIA_XCVRBITS
;      11/27/94    Did some clean-up of the V3 bus master additions
;----------------------------------------------------------------------------;

BOOTWARE_INTS equ      INT_LATCH + INT_ADAPTERFAIL + INT_RXCOMPLETE + INT_REQUESTED
;
;  sizes for array of danger regions used in hardware workaround for V3
;  at 10 Mbit
;
RAID_N                  equ     256             ; entries in RaidArray table
RAID_MASK               equ     ((RAID_N * 4) - 1)
RX_FIFO_GOOD            equ     020H            ; Bit 5 of 2nd SW config word
EISA_RXPACE_FIX		equ	040H		; Bit 6 of 2nd SW config word
;
; Default TxStart Thresholds
;
DEFAULT_TXSTART         equ     16
DEFAULT_AVATXSTART      equ     256

;
; Multicast Table Entry Structure
;
MCTableEntry    struc

MCTableAddress  db      6 dup (?)
MCTableInUse    db      ?
		db      ?
MCTableEntry    ends

;
; the compatibility level of this driver
;
CLEVEL              equ 1

;------ Equates -------------------------------------------------------------;


;
; Command code masks
;
CMD_CMDMASK         equ 0F800h                  ; command bits
CMD_ARGMASK         equ 007FFh                  ; argument bits
;
; Command codes, word form
;
CMD_GLOBALRESET     equ 00000b shl 11           ; global reset
CMD_SELECTWINDOW    equ 00001B shl 11           ; select register window
CMD_STARTINTXCVR    equ 00010b shl 11           ; start internal transciver
CMD_RXDISABLE       equ 00011b shl 11           ; rx disable
CMD_RXENABLE        equ 00100b shl 11           ; rx enable
CMD_RXRESET         equ 00101b shl 11           ; rx reset
CMD_TXDONE          equ 00111b shl 11           ; tx done
CMD_RXDISCARD       equ 01000b shl 11           ; rx discard top packet
CMD_TXENABLE        equ 01001b shl 11           ; tx enable
CMD_TXDISABLE       equ 01010b shl 11           ; tx disable
CMD_TXRESET         equ 01011b shl 11           ; tx reset
CMD_REQUESTINT      equ 01100b shl 11           ; request interrupt
CMD_ACKNOWLEDGE     equ 01101b shl 11           ; acknowledge interrupt
CMD_SETINTMASK      equ 01110b shl 11           ; set interrupt mask
CMD_SETRZMASK       equ 01111b shl 11           ; set read zero mask
CMD_SETRXFILTER     equ 10000b shl 11           ; set rx filter
CMD_SETRXEARLY      equ 10001b shl 11           ; set rx early threshold
CMD_SETTXAVAILABLE  equ 10010b shl 11           ; set tx available threshold
CMD_SETTXSTART      equ 10011b shl 11           ; set tx start threshold
CMD_STARTDMA        equ 10100b shl 11           ; start dma upload/download
CMD_STATSENABLE     equ 10101b shl 11           ; statistics enable
CMD_STATSDISABLE    equ 10110b shl 11           ; statistics disable
CMD_STOPINTXCVR     equ 10111b shl 11           ; start internal transciver
CMD_SETTXRECLAIM    equ 11000b shl 11           ; set tx reclaim threshold
;
; Command codes, hibyte form (commands without operands only)
;
CMDH_STARTINTXCVR   equ CMD_STARTINTXCVR shr 8
CMDH_RXDISABLE      equ CMD_RXDISABLE shr 8
CMDH_RXENABLE       equ CMD_RXENABLE shr 8
CMDH_RXDISCARD      equ CMD_RXDISCARD shr 8
CMDH_TXENABLE       equ CMD_TXENABLE shr 8
CMDH_TXDISABLE      equ CMD_TXDISABLE shr 8
CMDH_REQUESTINT     equ CMD_REQUESTINT shr 8
CMDH_STATSENABLE    equ CMD_STATSENABLE shr 8
CMDH_STATSDISABLE   equ CMD_STATSDISABLE shr 8
CMDH_STOPINTXCVR    equ CMD_STOPINTXCVR shr 8
CMDH_ACKNOWLEDGE    equ CMD_ACKNOWLEDGE shr 8

CMD_DMARESET            equ     00BFh                                   ;global reset with only dma set
;
; Status register bits (INT for interrupt sources, ST for the rest)
;
INT_LATCH           equ 00001h                  ; interrupt latch
INT_ADAPTERFAIL     equ 00002h                  ; adapter failure
INT_TXCOMPLETE      equ 00004h                  ; tx complete
INT_TXAVAILABLE     equ 00008h                  ; tx available
INT_RXCOMPLETE      equ 00010h                  ; rx complete
INT_RXEARLY         equ 00020h                  ; rx early
INT_REQUESTED       equ 00040h                  ; interrupt requested
INT_UPDATESTATS     equ 00080h                  ; update statistics

ST_FAILED           equ 00800h                  ; command failed
ST_BUSY             equ 01000h                  ; command busy
ST_WINDOW           equ 0E000h                  ; window bits (13-15)
ST_DMABUSY          equ 00800h                  ; dma in progress

STH_FAILED          equ ST_FAILED shr 8
STH_BUSY            equ ST_BUSY shr 8
STH_WINDOW          equ ST_WINDOW shr 8
STH_DMABUSY         equ ST_DMABUSY shr 8

INT_OFFTXCOMPLETE   equ ((NOT (INT_TXCOMPLETE)) and (0FFh))
ifdef NDIS
INT_ONTXCOMPLETE    equ INT_TXCOMPLETE
else
INT_ONTXCOMPLETE    equ MASK_NONE
endif



;
; RxStatus/RxError register bits, both forms
;
RXS_INCOMPLETE      equ 8000h                   ; not completely received
RXS_ERROR           equ 4000h                   ; error in packet
RXS_LENGTH          equ 1FFFh                   ; bytes in RxFIFO
;RXS_ERRTYPE         equ 3800h                   ; Rx error type, bit 13-11
;RXS_OVERRUN         equ 0000h                   ; overrun error
;RXS_OVERSIZE        equ 0800h                   ; oversize packet error
;RXS_DRIBBLE         equ 1000h                   ; dribble bit (not an error)
;RXS_RUNT            equ 1800h                   ; runt packet error
;RXS_CRC             equ 2800h                   ; CRC error
;RXS_FRAMING         equ 2000h                   ; framing error

RXSH_INCOMPLETE     equ RXS_INCOMPLETE shr 8
RXSH_ERROR          equ RXS_ERROR shr 8
;RXSH_ERRTYPE        equ RXS_ERRTYPE shr 8
RXSH_OVERRUN        equ 01h
RXSH_DRIBBLE        equ 80h
RXSH_CRC            equ 08h
RXSH_RUNT           equ 02h
RXSH_OVERSIZE       equ 10h
RXSH_FRAMING        equ 04h
;
; TxStatus register bits
;
TXS_COMPLETE        equ 80h                     ; tx completed
TXS_INTREQUESTED    equ 40h                     ; interrupt on successfull tx
TXS_ERRTYPE         equ 38h                     ; error bits
TXS_JABBERERROR     equ 20h                     ; jabber error
TXS_UNDERRUN        equ 10h                     ; tx underrun error
TXS_MAXCOLLISIONS   equ 08h                     ; max collisions error
TXS_STATUSOVERFLOW  equ 04h                     ; TX status stack is full
TXS_RECLAIMERROR    equ 02h                     ; collision after reclaim threshold
;
; InternalConfig register bits
;
ICL_RAMSIZE_MASK    equ 0007h
RAM_8K              equ 000b
RAM_32K             equ 010b
RAM_64K             equ 011b
RAM_128K            equ 100b

ICL_RAM16BIT        equ 0008h                   ; set if word wide ram

ICH_RAMPART_MASK    equ 0003h
PART_5TO3           equ 00b
PART_3TO1           equ 01b
PART_1TO1           equ 10b

ICH_XCVR_MASK       equ 0070h                   ; transceiver select
ICH_XCVR_SHIFT      equ 4
;
; transceiver types
;
XCVR_10TP           equ 000b                    ; 10BaseT/TP
XCVR_10AUI          equ 001b                    ; 10Mbps AUI
XCVR_10BNC          equ 011b                    ; 10Base2/Coax/BNC
XCVR_100TX          equ 100b                    ; 100BaseTX (scrambled)
XCVR_100FX          equ 101b                    ; 100BaseFX (unscrambled)
XCVR_MII            equ 110b                    ; MII
;
; Window Numbers
;
WNO_SETUP           equ 0                       ; setup/configuration
WNO_OPERATING       equ 1                       ; operating set
WNO_STATIONADDRESS  equ 2                       ; station address setup/read
WNO_FIFO            equ 3                       ; FIFO management
WNO_DIAGNOSTICS     equ 4                       ; diagnostics
WNO_READABLE        equ 5                       ; registers set by commands
WNO_STATISTICS      equ 6                       ; statistics
WNO_BUSMASTER       equ 7                       ; bus master control
;
; Port offsets, Window 1
;
PORT_CmdStatus      equ 0Eh                     ; command/status
PORT_TxFree         equ 1Ch                     ; free transmit bytes
PORT_TxStatus       equ 1Bh                     ; transmit status (byte)
PORT_Timer          equ 1Ah                     ; latency timer (byte)
PORT_RxStatus       equ 18h                     ; receive status
PORT_RxError        equ 14h                     ; rx error code register
PORT_RxFIFO         equ 10h                     ; RxFIFO read
PORT_TxFIFO         equ 10h                     ; TxFIFO write
;
; Port offsets, Window 0
;
PORT_EEData         equ 0Ch                     ; EEProm data register
PORT_EECmd          equ 0Ah                     ; EEProm command register
PORT_CfgResource    equ 08h                     ; resource configuration
PORT_CfgAddress     equ 06h                     ; address configuration
PORT_CfgControl     equ 04h                     ; configuration control
PORT_ProductID      equ 02h                     ; product id (EISA)
PORT_Manufacturer   equ 00h                     ; Manufacturer code (EISA)
;
; Port offsets, Window 2
;
PORT_SA0_1          equ 00h                     ; station address bytes 0,1
PORT_SA2_3          equ 02h                     ; station address bytes 2,3
PORT_SA4_5          equ 04h                     ; station address bytes 4,5
PORT_SM0_1          equ 06h                     ; station address bytes 0,1
PORT_SM2_3          equ 08h                     ; station address bytes 2,3
PORT_SM4_5          equ 0Ah                     ; station address bytes 4,5
;
; Port offsets, Window 3                        ; 10/19/94, cj
;
PORT_ALT_TxFree     equ 0Ch                     ; free transmit bytes (dup)
PORT_RxFree         equ 0Ah                     ; free receive bytes
PORT_ResetOptions   equ 08h                     ; ResetOptions
PORT_MacControl     equ 06h                     ; MacControl
PORT_InternalCfgH   equ 02h                     ; InternalConfig High
PORT_InternalCfgL   equ 00h                     ; InternalConfig Low
;
; Port offsets, Window 4
;
PORT_BadSsdCount    equ 0Ch
PORT_MediaStatus    equ 0Ah                     ; media type/status
PORT_SlingshotStatus equ 08h                    ; Slingshot status
PORT_NetDiagnostic  equ 06h                     ; net diagnostic
PORT_FIFODiagnostic equ 04h                     ; FIFO diagnostic
PORT_HostDiagnostic equ 02h                     ; host diagnostic
PORT_TxDiagnostic   equ 00h                     ; tx diagnostic
;
; Port offsets, Window 5
;
PORT_RZMask         equ 0Ch                     ; read zero mask
PORT_IntMask        equ 0Ah                     ; interrupt mask
PORT_RxFilter       equ 08h                     ; receive filter
PORT_RxEarly        equ 06h                     ; rx early threshold
PORT_TxAvailable    equ 02h                     ; tx available threshold
PORT_TxStart        equ 00h                     ; tx start threshold
;
; Port offsets, Window 6
;
PORT_TXBYTES        equ 0Ch                     ; tx bytes ok
PORT_RXBYTES        equ 0Ah                     ; rx bytes ok
PORT_UPPERFRAMES    equ 09h                     ; upper bits of tx/rx frames ok
PORT_TXDEFER        equ 08h                     ; tx frames deferred (byte)
PORT_RXFRAMES       equ 07h                     ; rx frames ok (byte)
PORT_TXFRAMES       equ 06h                     ; tx frames ok (byte)
PORT_RXDISCARDED    equ 05h                     ; rx frames discarded (byte)
PORT_TXLATE         equ 04h                     ; tx frames late coll. (byte)
PORT_TXSINGLE       equ 03h                     ; tx frames one coll. (byte)
PORT_TXMULTIPLE     equ 02h                     ; tx frames mult. coll. (byte)
PORT_TXNOCD         equ 01h                     ; tx frames no CDheartbt (byte)
PORT_TXCARRIERLOST  equ 00h                     ; tx frames carrier lost (byte)
;
; Port offsets, Window 7
;
PORT_MasterStatus   equ 0Ch
PORT_MasterLen      equ 06h
PORT_MasterAddressH equ 02h
PORT_MasterAddress  equ 00h
;
; masks for UpperFramesOk
;
UPPER_RXFRAMES_MASK equ 00Fh
UPPER_TXFRAMES_MASK equ 0F0h
UPPER_TXFRAMES_SHIFT equ 4
;
; bits in ResetOptions
;
RO_AVAILBITS        equ 00FFh

RO_BASET4           equ 0001h
RO_BASETX           equ 0002h
RO_BASEFX           equ 0004h
RO_TP               equ 0008h
RO_COAX             equ 0010h
RO_AUI              equ 0020h
RO_MII              equ 0040h
RO_T4               equ 0080h
;
; Various command arguments
;
INT_ALLDISABLED         equ 00000000000b            ; all interrupts disabled
INT_ALLENABLED          equ 00011111110b            ; all interrupts enabled
ACK_ALL                 equ 00111111111b            ; ack everything

MASK_ALL                equ INT_ALLDISABLED
MASK_NONE               equ INT_ALLENABLED

FILTER_INDIVIDUAL       equ 0001b                   ; individual address
FILTER_MULTICAST        equ 0010b                   ; multicast/group addresses
FILTER_BROADCAST        equ 0100b                   ; broadcast address
FILTER_PROMISCUOUS      equ 1000b                   ; promiscuous mode

RXEARLY_DISABLED        equ 2032                    ; RxEarly to disable

TXAVAIL_DISABLED        equ 2040                    ; TxAvailable to disable
TXAVAIL_MIN             equ 4

TXSTART_DISABLED        equ 2040                    ; TxStart to disable
TXSTART_MIN             equ 0
MAX_TXSTART             equ TXSTART_DISABLED

TXRECLAIM_DISABLED      equ 1792                    ; TxReclaim to disable
TXRECLAIM_MIN           equ 256
TXRECLAIM_MAX           equ 1792
TXRECLAIM_INC           equ 256

MASK_AISM_RESET         equ 00010000b               ; mask off auto-init
						    ; reload from EEPROM on
						    ; reset
MASK_HOST_RESET                 equ     00100000b
;
; start dma command bits
;
DMA_UPLOAD              equ 00h
DMA_DOWNLOAD            equ 01h

MAX_RXLENGTH            equ 1792                    ; maximum rxlength

TXRXRESET_ALLBUTBM      equ 01000000b               ; Tx/Rx reset all but bus master ;

; Transmit Preamble
;
PREAMBLESIZE            equ 4                       ; transmit preamble size
TXP_INTONSUCCESS        equ 8000h                   ; interrupt on successful tx

;
; bits in MasterStatus
;
MS_INPROGRESS       equ 8000h                   ; bus master operation in progress
MS_UPLOAD           equ 4000h                   ; upload complete/ack
MS_DOWNLOAD         equ 1000h                   ; download complete/ack
MS_MASTERABORT      equ 0001h                   ; no response from slave
MS_TARGETABORT      equ 0002h                   ; aborted by slave


;
; Bits in various diagnostics registers
;
MEDIA_TP                equ 8000h                   ; TP transciever
MEDIA_BNC               equ 4000h                   ; Thinnet transciever
MEDIA_INTENDEC          equ 2000h                   ; internal encoder/decoder
;MEDIA_SQE               equ 1000h                   ; SQE present
MEDIA_TXINPROG          equ 1000h                   ;
MEDIA_LBEAT             equ 0800h                   ; link beat ok (TP)
MEDIA_POLARITY          equ 0400h                   ; polarity (TP)
MEDIA_JABBER            equ 0200h                   ; jabber (TP)
MEDIA_UNSQUELCH         equ 0100h                   ; unsquelch (TP)
MEDIA_LBEATENABLE       equ 0080h                   ; link beat enable (TP)
MEDIA_JABBERENABLE      equ 0040h                   ; jabber enable (TP)
MEDIA_CRS               equ 0020h                   ; carrier sense
MEDIA_COLLISION         equ 0010h                   ; collision
MEDIA_SQEENABLE         equ 0008h                   ; enable SQE statistics
MEDIA_CRCSTRIPDISABLE   equ 0004h                   ; disable Rx CRC stripping
MEDIA_DATARATE100       equ 0002h                   ; operating at 100Mbps

MEDIA_XCVRBITS          equ MEDIA_LBEATENABLE+MEDIA_JABBERENABLE+MEDIA_SQEENABLE


NETD_NOLOOPBACK_MASK    equ 0FFFh                   ; no loopbacks
NETD_EXTLOOPBACK        equ 8000h                   ; TP external loopback
NETD_ENDECLOOPBACK      equ 4000h                   ; ENDEC loopback
NETD_MACLOOPBACK        equ 2000h                   ; ethernet core loopback
NETD_FIFOLOOPBACK       equ 1000h                   ; FIFO loopback
NETD_TXENABLED          equ 0800h                   ; tx enabled
NETD_RXENABLED          equ 0400h                   ; rx enabled
NETD_TXTRANSMITTING     equ 0200h                   ; tx transmitting
NETD_TXRESETREQD        equ 0100h                   ; tx reset required
NETD_ASICREV            equ 003Eh                   ; ASIC revision

NETD_ASICREV_SHIFT      equ 1                       ; shr 1 to get revision

FIFOD_RXRECEIVING       equ 8000h                   ; rx receiveing
FIFOD_RXUNDERRUN        equ 2000h                   ; rx underrun
FIFOD_RXSTATUSOVER      equ 1000h                   ; rx status overrun
FIFOD_RXOVERRUN         equ 0800h                   ; rx overrun
FIFOD_TXOVERRUN         equ 0400h                   ; tx overrun
FIFOD_BISTRESULTS       equ 00FFh                   ; BIST results (mask)

SLING_TXUNDERRUN        equ 2000h                   ; Slingshot TxUnderrun bit
;
; bits in MacControl
;
MACC_DEFEREXTEND    equ 0010h
MACC_FULLDUPLEX     equ 0020h
MACC_ALLOWLARGE     equ 0040h
;
; Capabilities bits
;
SUPPORTS_FULLDUPLEX     equ 0002h
SUPPORTS_LARGEPACKETS   equ 0004h
SUPPORTS_FRAGBUSMASTER  equ 0040h
SUPPORTS_100MBPS        equ 1000h


;
; board identification codes
;
EISA_MANUFACTURER_ID    equ 06D50h                  ; EISA manufacturer code

EISA_10_100_ID          equ 07059h                  ; Product ID for EISA board
EISA_10_ONLY_ID         equ 02059h                  ; Product ID for EISA board
PRODUCT_ID_MASK         equ 0F0FFh                  ; Mask off revision nibble

ISAID_TP                equ 5090h                   ; ISA Product ID: TP/AUI
ISAID_BNC               equ 5091h                   ; ISA Product ID: BNC/AUI
ISAID_COMBO             equ 5094h                   ; ISA Product ID: Combo
ISAID_TPONLY            equ 5095h                   ; ISA Product ID: TP only

EISAID_TP               equ 5092h                   ; EISA Product ID: TP/AUI
EISAID_BNC              equ 5093h                   ; EISA Product ID: BNC/AUI
EISAID_COMBO            equ 5096h                   ; EISA Product ID: Combo (future)
EISAID_TPONLY           equ 5097h                   ; EISA Product ID: TP only (future)

MCAID_BNC               equ 627Ch                   ; MCA Adapter ID: BNC/AUI
MCAID_TP                equ 627Dh                   ; MCA Adapter ID: TP/AUI
MCAID_COMBO             equ 61DBh                   ; MCA Adapter ID: Combo (future)
MCAID_TPCOAX            equ 62F6h                   ; MCA Adapter ID: TP/COAX (future)
MCAID_TPONLY            equ 62F7h                   ; MCA Adapter ID: TP only (future)
;
; EEProm access
;
EE_BUSY                     equ 8000h                   ; EEProm busy bit in EECmd
EE_TCOM_NODE_ADDR_WORD0     equ 00h
EE_TCOM_NODE_ADDR_WORD1     equ 01h
EE_TCOM_NODE_ADDR_WORD2     equ 02h
EE_VULCAN_PROD_ID           equ 03h
EE_MANUFACTURING_DATA       equ 04h
EE_SERIAL_NUMBER_WORD0      equ 05h
EE_SERIAL_NUMBER_WORD1      equ 06h
EE_MANUFACTURER_CODE        equ 07h
EE_ADDR_CONFIGURATION       equ 08h
EE_RESOURCE_CONFIGURATION   equ 09h
EE_OEM_NODE_ADDR_WORD0      equ 0Ah
EE_OEM_NODE_ADDR_WORD1      equ 0Bh
EE_OEM_NODE_ADDR_WORD2      equ 0Ch
EE_SOFTWARE_CONFIG_INFO     equ 0Dh
EE_CWORD                    equ 0Eh
EE_SOFTWARE_CONFIG_INFO2    equ 0Fh
EE_CAPABILITY_WORD          equ 10h

EE_INT_CONFIG_0             equ 12h
EE_INT_CONFIG_1             equ 13h

EE_MII_SELECT		    equ 15h
EE_MII_SELECT_MASK	    equ 000Fh
;
; contention logic
;
ID_PORT                 equ 110h
READ_EEPROM             equ 080h
SET_TAG_REGISTER        equ 0D0h
TEST_TAG_REGISTER       equ 0D8h
ACTIVATE_AND_SET_IO     equ 0E0h
ACTIVATE_VULCAN         equ 0FFh
;
; Resource Configuration Register bits
;
RCONFIG_IRQ             equ 0F000h
RCONFIG_SYNCH           equ 00040h
;
; Address Configuration Register bits
;
ACONFIG_XCVR            equ 0C000h
ACONFIG_IOBASE          equ 0001Fh

IOBASE_EISA             equ 0001Fh

TP_XCVR                 equ 00000h
BNC_XCVR                equ 0C000h
AUI_XCVR                equ 04000h

ICH_AUTOSELECT          equ 100h              ; Internal Config word 1 autosel

MIN_IO_BASE_ADDR        equ 200h
MAX_IO_BASE_ADDR        equ 3F0h
REGISTER_SET_SIZE       equ 10h
;
; Software Configuration Register bits
;
SW_OPTIMIZE             equ 0030h
SW_MAXCLI               equ 3F00h
SW_LINKBEAT             equ 4000h
SW_FULLDUPLEX           equ 8000h

SW_BPROT		equ 00007h
SW_CONFIG		equ 00008h		; NOT assigned yet 0=enable, 1=disable
SW_DEFAULT		equ 040h		; 0 = network, 1 = disable
SW_RS			equ 080h		; 1 = enable, 0=disable
SW_LOCALBOOT		equ 0100h		; 1 = Enable, 0 = Disable
SW_BOOTWARE		equ SW_BPROT OR SW_CONFIG OR SW_DEFAULT OR SW_RS OR SW_LOCALBOOT	 ; all the bits assigned to BootWare

;
; Possibilities for SW_OPTIMIZE
;
OPTIMIZE_DOS_CLIENT     equ 0010h
OPTIMIZE_WINDOWS_CLIENT equ 0020h
OPTIMIZE_SERVER         equ 0030h
;
; Configuration Control Register bits
;
ENABLE_ADAPTER          equ 01h
					     ; CCR High-Byte Masks

AUI_AVAIL               equ 20h              ; CCR Bit 13: AUI Available
BNC_AVAIL               equ 10h              ; CCR Bit 12: BNC Available
TP_AVAIL                equ 02h              ; CCR Bit  9: TP  Available

;
;       Capabilities Word Mask Definitions
;
PNP_SUPPORT_MASK        equ     0001h
;
; V2 Internal Configuration Register bits
;
PNP_ENABLE_MASK         equ 0008h
ID_ENABLE_MASK          equ 0004h
PNP_AND_ID_MASK         equ 000Ch

PNP_ENABLE              equ 0008h
ID_ENABLE               equ 0004h

TXCOMPLETE_INT          equ 8000h            ; Interrupt on Tx Complete
TEST_PKT_LEN            equ 14               ; Loop Back Test Packet Length
MAX_RETRY_AUTOSEL       equ 3                ; Auto-Selection Test Max Retry

;
; Bus Types
;
BUS_UNKNOWN             equ     0
BUS_ISA                 equ     1
BUS_EISA                equ     2
BUS_PCI                 equ     3
BUS_EISA_PCI		equ	5

;
; adapter codes                                  ; 10/19/94
;
ACODE_PCI_10_TPO        equ     42
ACODE_PCI_10_COMBO      equ     43
ACODE_EISA_10_TPO       equ     44
ACODE_EISA_10_COMBO     equ     45
ACODE_PCI_100_TX        equ     46
ACODE_EISA_100_TX       equ     47
ACODE_PCI_T4		equ	63

;
; offsets in PCI configuration space
;
PCIC_INTERRUPTLINE      equ     003Ch
PCIC_BIOSROMCONTROL     equ     0030h
PCIC_IOBASE             equ     0010h
PCIC_LATENCYTIMER       equ     000Dh
PCIC_STATUS             equ     0006h
PCIC_COMMAND            equ     0004h
PCIC_DEVICEID           equ     0002h
PCIC_VENDORID           equ     0000h
;
; bits in PciCommand
;
PCIC_IOENABLE           equ     00001h
PCIC_BMENABLE           equ     00004h
;
; bits in LatencyTimer
;
LATE_MAX                equ     255
LATE_MASK               equ     (NOT 7)

BIND_BYTES              equ     1500
MAX_RXBYTES             equ     1792
;
; Possible values for Bus Master Lock
;
BMLOCK_UNLOCKED   equ   0
BMLOCK_RX         equ   1
BMLOCK_TX         equ   2
BMLOCK_DISABLE    equ   3

; 940923 ModeBits, contains system & adapter setting
ModeV2		equ	1
ModeNonISA	equ	4
ModeMCA		equ	8
ModeEISA	equ	10h
ModePCI		equ	20h
ModePnP		equ	40h
ModeAtmel	equ	80h

; RomControl register bits (select 16K ROM Page) Windows 3/Port 5
RomPage0		equ	0
RomPage1		equ	100h
RomPage2		equ	200h
RomPage3		equ	300h
RomPageMask		equ	0fcffh


;
; Possible values for SW_BPROT
;
BOOTPROT_UNINIT 	equ 0	; means "virgin" board. Default to 802.2
BOOTPROT_NW_8022	equ 1
BOOTPROT_NW_EII 	equ 2
BOOTPROT_NW_8023	equ 3
BOOTPROT_RPL		equ 4
BOOTPROT_TCPIP		equ 5
BOOTPROT_BOOTP_ARP	equ 6	; for V1 only. Can use Atmel for V2


; Current Fail and Warning Level
LEVEL_FAIL		equ	0		; current Fail Level
LEVEL_WARNING		equ	0		; current Warning Level

;IF CABLE_DISCONNECT
CABLE_TP          equ   0
CABLE_COAX        equ   1
;ENDIF

; constants for 3COM PCI device ID and vendor ID

PCI_V3_DEVICE_ID        equ     5950h
PCI_3COM_ID             equ     10b7h
PCI_DEVICEID_MASK       equ 0FF00h                  ; mask off last digit/rev
PCI_DEVICEID            equ 05900h                  ; PCI Device ID (masked)

; PCI BIOS function code

PCI_FUNCTION_ID         equ     0b1h
PCI_BIOS_PRESENT        equ     001h
FIND_PCI_DEVICE         equ     002h
READ_CONFIG_BYTE        equ     008h
READ_CONFIG_WORD        equ     009h
READ_CONFIG_DWORD       equ     00ah
WRITE_CONFIG_BYTE	equ	0bh
WRITE_CONFIG_WORD	equ	0Ch
WRITE_CONFIG_DWORD	equ	0Dh

; PCI BIOS function return code

PCI_CALL_SUCCESSFUL     equ     00h
PCI_DEVICE_NOT_FOUND    equ     86h
PCI_BAD_VENDOR_ID       equ     83h

; 3Com PCI configuration space

PCIC_STATUS             equ     0006h
PCIC_COMMAND            equ     0004h
PCIC_DEVICEID           equ     0002h
PCIC_VENDORID           equ     0000h
CFGREG_PCIC_COMMAND     equ     0004h
CFGREG_IOBASE           equ     010h
CFGREG_INTLINE          equ     03ch
CFGREG_INTERNALCFG      equ     040h
CFGREG_BIOSROMCONTROL   equ     030h

;
; bits in PciCommand
;
PCIC_IOENABLE           equ     00001h
PCIC_BMENABLE           equ     00004h
;
; adapter codes
;
ACODE_PCI_10_TPO        equ     42
ACODE_PCI_10_COMBO      equ     43
ACODE_EISA_10_TPO       equ     44
ACODE_EISA_10_COMBO     equ     45
ACODE_PCI_100_TX        equ     46
ACODE_EISA_100_TX       equ     47

;IF CABLE_DISCONNECT
CABLE_TP          equ   0
CABLE_COAX        equ   1
;ENDIF

;------ Structures ----------------------------------------------------------;
;
; TxStart structure.  Padded to 16 bytes for easy indexing.
;
TxStartStruc    struc
txs_thresh      dw      ?               ; TxStart threshold (+CMD_SETTXSTART)
txs_value       dw      ?               ; value, no cmd, unscaled
txs_min         dw      ?               ; minimum threshold, this bin
txs_count       dw      ?               ; packets since last underrun
txs_uN          dw      ?               ; number of entries in uSum
txs_uSum        dw      ?               ; sum of uN x packets between underruns
txs_pad         dw      ?               ; pad to 16 bytes
txs_marker      dw      ?               ; pad to 16 bytes, marker for debug
TxStartStruc    ends

SIZE_TxStart    equ     SIZE TxStartStruc
;
; constants used by the TxStart algorithm
;
; these are currently set up for 4 bins.  none of these variables can be
; changed independently!
;
; we assign packets to bins based on packet size.  here we set up 4 bins 512
; bytes in size.  these bins cover packets of size:
;
;           Bin     Size Range          Mid-Point
;           0       0-255 bytes         128
;           1       256-767 bytes       512
;           2       768-1279 bytes      1024
;           3       1280-1768 bytes     1536
;
; Bin 0 should collect all of the small packets, most likely a lot
; of 60-100 byte packets.  Bin 1 will likely be mostly empty unless
; some protocol is using 512 byte packets.  Bin 2 should contain all
; of the 1024-1100 byte packets (IPX for example).  And Bin 3 should
; contain the full-size packets, mostly high 1400's to 1514.
;
TXBIN_COUNT             equ     4               ; four bins
TXBIN_WIDTH             equ     512             ; 512 bytes wide
TXBIN_OFFSET            equ     256             ; first bin starts at -OFFSET
;
; these are used to convert a packet size to an index into a TxStart array
; where each TxStart entry in the array is 16 bytes in size.
;
TXBIN_ADD               equ     (TXBIN_WIDTH/2) ; size+ADD
TXBIN_SHIFT             equ     5               ; (size+ADD) >> SHIFT
TXBIN_MASK              equ     0110000b        ; ((size+ADD) >> SHIFT) AND MASK
;
; this value is used to adjust an index from PioTxStart into MasterTxStart
; which is assumed to follow it immediately.
;
TXBIN_MASTER_OFFSET     equ     (TXBIN_COUNT * SIZE_TxStart)


;------ VDS Stuff -----------------------------------------------------------;
;
; a flag to test in the BIOS data segment.  if set, must use VDS.  if not,
; you can compute physical addresses by (segment << 4) + offset.
;
VDS_FLAG_SEG        equ     0040h
VDS_FLAG_OFF        equ     007Bh
VDS_FLAG_TEST       equ     20h                 ; if set, use VDS
;
; the VDS interrupt
;
VDS_INT             equ     04Bh
;
; VDS functions (into AX)
;
VDS_SCATTER_LOCK    equ     8105h               ; scatter/gather lock region
VDS_SCATTER_UNLOCK  equ     8106h               ; scatter/gather unlock region

;
; MII register definitions.   The following are definitions of the standard
; MII registers, common to all implementations of the MII interface.
;
MII_PHY_CONTROL     equ    0       ; control reg address
MII_PHY_STATUS      equ    1       ; status reg address
MII_PHY_OUI         equ    2       ; most of the OUI bits
MII_PHY_MODEL       equ    3       ; model/rev bits, and rest of OUI
MII_PHY_ANAR        equ    4       ; AutoNegotiation Adverisement Register
MII_PHY_ANLPAR      equ    5       ; AutoNegotiation Link Partner Ability Reg.
MII_PHY_ANER        equ    6       ; AutoNegotiation Expantion Reg.
MII_PHY_PAR         equ    19h     ; PHY Address Register
MII_EXT_REG0	    equ    10h     ; Broadcom chip extended register 0
MII_BCM_EXTREG0     equ    10h     ; Broadcom chip extended register 0
MII_EXT_REG1        equ    14h     ; Broadcom chip extended register 1
MII_BCM_EXTREG1     equ    14h     ; Broadcom chip extended register 1
MII_PHY_PCR	    equ    17h	   ; PCS Configuration Reg.
;
; bit fields in the standard MII control register
;
MII_CTL_RESET       equ    8000h   ; reset bit in control reg
MII_CTL_100MB       equ    2000h   ; 100Mbit or 10 Mbit flag
MII_CTL_ENABLE_AUTO equ    1000h   ; autonegotiate enable
MII_CTL_ISOLATE     equ    0400h   ; islolate bit
MII_CTL_START_AUTO  equ    0200h   ; restart autonegotiate
MII_CTL_FULL_DUPLEX equ    0100h   ; enable full duplex
;
; bit fields in the standard MII status register
;
MII_STS_100MB_MASK  equ    0E000h  ; any of these indicate 100 Mbit
MII_STS_10MB_MASK   equ    1800h   ; either of these indicate 10 Mbit
MII_STS_100BASET4   equ    08000h  ; 100BaseT4
MII_STS_100BASEX_FD equ    04000h  ; 100BaseX Full Duplex
MII_STS_100BASEX_HD equ    02000h  ; 100BaseX Half Duplex
MII_STS_10BASET_FD  equ    01000h  ; 10BaseT Full Duplex
MII_STS_10BASET_HD  equ    0800h   ; 10BaseT Half Duplex
MII_STS_AUTO_DONE   equ    0020h   ; auto negotiation complete
MII_STS_AUTO        equ    0008h   ; auto negotiation is available
MII_STS_LINK_UP     equ    0004h   ; link status bit
MII_STS_EXTENDED    equ    0001h   ; extended regs exist
;
; bit fields in the extended MII auto-negotiation link partner ability reg.
; bit 5-12 are technology ability bits in MII spec.
; national n-way uses bit 5-9 only.
;
MII_ANLPAR_100BASET4   equ    0200h  ; 100BaseT4
MII_ANLPAR_100BASEX_FD equ    0100h  ; 100BaseX Full Duplex
MII_ANLPAR_100BASEX_HD equ    0080h  ; 100BaseX Half Duplex
MII_ANLPAR_10BASET_FD  equ    0040h  ; 10BaseT Full Duplex
MII_ANLPAR_10BASET_HD  equ    0020h  ; 10BaseT Half Duplex
;
; Physical Management bits
;
MGMT_PHY_CLOCK      equ    0001h
MGMT_PHY_DATA1      equ    0002h
MGMT_PHY_WRITE      equ    0004h
;
; MiiPhyUsed
;
MII_100BASET4       equ    1       ; 100BaseT4
MII_100BASEX_FD     equ    2       ; 100BaseX Full Duplex
MII_100BASEX_HD     equ    3       ; 100BaseX Half Duplex
MII_10BASET_FD      equ    4       ; 10BaseT Full Duplex
MII_10BASET_HD      equ    5       ; 10BaseT Half Duplex
;
; bit field in the extended register 0 for broadcom
MII_EXT_SPEED	       equ    0002h  ; Speed Indication (1=100, 0=10)
;
; Phy addr
;
NWAY		    equ    18h
T4		    equ    01h

;
; The structure filled in by INT 4B
;
PhysicalMapStruc   struc

VirtualSizeLo      dw        0
VirtualSizeHi      dw        0
LinearOffsetLo     dw        0
LinearOffsetHi     dw        0
LinearSegment      dw        0
		   dw        0
SegsProvided       dw        3
SegsNeeded         dw        0

PhysAddLo          dw        0
PhysAddHi          dw        0
PhysLenLo          dw        0
PhysLenHi          dw        0

Phys1AdrLo         dw        0
Phys1AdrHi         dw        0
Phys1LenLo         dw        0
Phys1LenHi         dw        0

Phys2AdrLo         dw        0
Phys2AdrHi         dw        0
Phys2LenLo         dw        0
Phys2LenHi         dw        0

PhysicalMapStruc   ends

PhysicalArrayStruc struc
PhysAAdrLo         dw        0
PhysAAdrHi         dw        0
PhysALenLo         dw        0
PhysALenHi         dw        0
PhysicalArrayStruc ends

;
; SelectWindow - select register window specified (must be a constant)
;
; entry:
;   dx = cmd/status port
;
; destroys:
;   ax
;
SelectWindow macro  wno
		mov	ax, CMD_SELECTWINDOW + wno 
		out     dx, ax
endm


;------ GENERAL.INC ---------------------------------------------------------;
;                                                                            ;
;       General purpose equates, structures and macros.                      ;
;                                                                            ;
;----------------------------------------------------------------------------;

;
; I/O ports for the PICs
;
MASTER_MASK_PORT equ    021h
SLAVE_MASK_PORT equ     0A1h
;
; DOUBLEWORD - Thirty-two bit double word layout for sixteen bit word access
;
doubleword      struc
loword          dw      0               ; low order word
hiword          dw      0               ; high order word
doubleword      ends

;
; FARPOINTER - Thirty-two bit 286-style far pointer layout for segment and
;              offset access
;
farpointer      struc
off             dw      0               ; offset
segm            dw      0               ; segment or selector
farpointer      ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c90x\version.inc ===
;
; Modifications:   $Header:   H:/Archives/Client/Include/version.inv   1.22.1.1   31 Jan 1998 23:08:08   MJOHNSOX  $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;

ifndef _VERSION_INC
_VERSION_INC=1


; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
; Equates
;

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Version number of current LSA build.
;
LSA_MAJOR	equ	0
LSA_MINOR	equ	99
LSA_EDIT	equ	'd'

LSA_EISA_ID	equ   ((('L'-'@') shl 26)+(('S'-'@') shl 21)+(('A'-'@') shl 16))

LSA_PMM_HANDLE	equ	((LSA_EISA_ID)+2000h+((LSA_MAJOR) shl 8)+(LSA_MINOR))


; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Product & manufacturer ID strings.
;
MFG_STR		textequ	<'Intel'>
PROD_STR	textequ	<'LANDesk (R) Service Agent II'>
COPYRIGHT_STR	textequ	<'Copyright (C) 1997  Intel Corporation.  All rights reserved.'>


endif ;_VERSION_INC

; EOF - $Workfile:   version.inc  $
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c90x\bw90xp.inc ===
; Routines in BW90XP.INC
;
; Modules included:
;	- Init_Vulcan2
; 	- SetInterruptVector
;	- init_vulcan_hw
;	- AutoSelect
;	- TryLinkBeat 
;	- TryLoopback
;	- SetupConnector 
;


;******************************************************************************
; Init_Vulcan2
;******************************************************************************
public	Init_Vulcan2
Init_Vulcan2	proc	near

;
; set up initial TxStart thresholds.
;
		mov	si, offset DGroup:PioTxStart

		public	init_txs_loop
init_txs_loop:
		mov	[si].txs_min, 0 	; Disable MinTxStart
;960408		max	ax, 16, dx

;960408 {
		; Replace "max	ax, 16, dx"
		cmp	ax, 16
		ja	init_txs_max

		mov	ax, 16
init_txs_max:	
;960408 }
		mov	[si].txs_value, ax
		add	ax, 2			; round
		shr	ax, 2			; then scale
		add	ax, CMD_SETTXSTART	; add command
		mov	[si].txs_thresh, ax	; for direct use
		mov	[si].txs_marker, 0D1CEh ; debug flag
		add	si, SIZE_TxStart	; next TxStart threshold
		cmp	si, offset DGroup:AfterTxStart
		jb	init_txs_loop		; around again
;
;------------------------------------------------------------------------------
; initialize Vulcan hardware, driver variables & tables
;

		call   init_vulcan_hw		; initialize Vulcan hardware
;960119       call   init_vt			; init variables and tables

;------------------------------------------------------------------------------
; enable int at 8259, turn on Ethernet Core Transciever and Receiver
;

mask_on_IRQ:

; setup initial TxStart & RxEarly Thresholds
; disable Tx and Rx Early Thresholds

;960403       port    CmdStatus
		mov	dx, PortCmdStatus

      ;mov    ax, CMD_SETRXEARLY+((1514+3) shr 2); early threshold = 0
		mov	ax, CMD_SETRXEARLY+RXEARLY_DISABLED
		mov	NormalRxEarly, ax	; will be adjusted later
		out	dx, ax

		mov	ax, CurTxStart
		out	dx, ax

; set rx filter
		mov	ax, CMD_SETRXFILTER+FILTER_INDIVIDUAL
		mov	HWFilter, ax		; save for SoftRxReset
		out	dx, ax

		mov	ax, CMD_SETINTMASK + BOOTWARE_INTS
		out	dx, ax

IFNDEF	UNDI
		; enable the transmitter
		mov     ah, CMDH_TXENABLE
		out     dx, ax

		; enable the receiver
		mov     ah, CMDH_RXENABLE
		out     dx, ax
ENDIF
		mov	ax, 0
		ret

Init_Vulcan2	endp



;******************************************************************************
;
;   SetInterruptVector: this routine determine the mask value for the selected
;			IRQ level and EOI values for both master and slave
;			8259s. We do not mask on the selected IRQ in this
;			routine, instead, it will be turned on and off as
;			initialization goes on.
;
;   On Entry:
;	      al = IRQ level
;	      cli
;
;   On Exit:
;
;******************************************************************************


SetInterruptVector proc near

;
;------------------------------------------------------------------------------
; determine the mask value for the selected IRQ level
;

       mov    cl, al				 ; al = IRQ level
       and    cl, 0f7h				 ; strip out IRQ on slave
       mov    ch, 1
       shl    ch, cl
       mov    IRQBit, ch			 ; IRQ bit postion (1), maskoff)
       not    ch				 ; all bits 1 except channel
       mov    IntMaskOnBit, ch			 ; Mask on bit position (0)

       mov    word ptr int_mask_port, MASTER_MASK_PORT
       cmp    al, 7
       jbe    SetIRQMaster
       mov    word ptr int_mask_port, SLAVE_MASK_PORT

SetIRQMaster:

;------------------------------------------------------------------------------
; determine EOI values for both master and slave 8259
;

       mov    al, IRQLevel
       cmp    al, 8				 ; IRQ on slave?
       jae    SetEOI				 ; yes

       mov    ah, al				 ;
       or     ah, 60h				 ; specific EOI to master 8259
       mov    al, 40h				 ; nop to slave to 8259
       jmp    short save_eoi

SetEOI:
       mov    ax, 6220h 			 ; non-specific EOI to slave
						 ; specific EOI to master 8259
save_eoi:
       mov    eoi_value, ax			 ; ah = EOI for master
						 ; al = EOI for slave
       ret

SetInterruptVector endp

;******************************************************************************
;   init_vulcan_hw:  this routine initializes most of vulcan hardware required
;		     to operate the adapter.  TxEnable and RxEnable will not
;		     be done in this routine
;
;   On Entry:
;	      adapter has been activated and window 0 is active.
;	      the following variables are valid and available:
;
;			1. IOBase
;			2. IRQLevel
;			5. NetAddress - ethernet addr of the adapter
;
;   On Exit:
;	      window 1 is active
;	      dx = port CmdStatus
;
;*****************************************************************************

init_vulcan_hw	   proc      near

	; for EISA board, cannot reset board.
		cmp	BusType, BUS_EISA
		jz	Init_SkipReset

;960403       port   CmdStatus
		mov	dx, PortCmdStatus
		xor	ax,ax			   ; global reset
		out	dx,ax

GlobalResetWait:
		in      ax, dx
		test    ah, STH_BUSY
		jnz	GlobalResetWait		   ; loop while busy

Init_SkipReset:
;
;------------------------------------------------------------------------------
; Setup Station Address.  the adapter's Ethernet Address has been read out of
; EEPROM, we need to program it into window 2, so Ethernet Core Receiver can
; receive packets properly.  the active window is 0, switch to window 2 first.
;

;960403       port   CmdStatus
		mov	dx, PortCmdStatus
		SelectWindow	WNO_STATIONADDRESS

IFDEF	UNDI
		lea	si, DGroup:BoardID	;971030
ELSE
		lea	si, NetAddress
ENDIF
;960403       sub    dx, PORT_CmdStatus-PORT_SA0_1	 ; dx = port addr 5, 4
		mov	dx, PortSA0_1
		lodsw
		out	dx, ax

		add	dx, 2			; dx = port addr 3, 2
		lodsw
		out	dx, ax

		add	dx, 2			; dx = port addr 1, 0 = IO base
		lodsw
		out	dx, ax
;
; Initialize the mask registers to 0's, so we get only messages meant for us
;
		xor    ax,ax
		add    dx,2			; dx = station mask lo
		out    dx,ax
		add    dx,2			; dx = station mask mid
		out    dx,ax
		add    dx,2			; dx = station mask hi
		out    dx,ax
;
;----------------------------------------------------------------------------
; determine the connector to use.
;
; we set the default to EEProm InternalConfiguration.  Then we check
;	for auto-selection
;

;  Autoselect and ComputeSpeeds expect CLI.  force it.

		cli

		mov	ax, EEIntConfig1
		and	ax, ICH_XCVR_MASK
		shr	ax, ICH_XCVR_SHIFT
		mov	Xcvr, ax
;960403		port	CmdStatus
		mov	dx, PortCmdStatus
		SelectWindow WNO_FIFO

;960403		port	InternalCfgH, CmdStatus
		mov	dx, PortInternalCfgH
		in	ax, dx
		test	ax, ICH_AUTOSELECT
		jz	not_auto_select
		mov	EEMiiPhySelect, -1
		call	AutoSelect		;if autoselect failed, Xcvr is
						;back to default
		cmp     Xcvr, XCVR_MII
		je      check_mii_speed

not_mii_connector:
;
;;980429, check link for single connector's adapter
;
		mov	LinkDetected, 0
		cmp     Xcvr, XCVR_100TX
		jz	test_100link
		cmp     Xcvr, XCVR_100FX
		jnz	not_100FX
test_100link:
		call	TryLinkbeat
		jc      fast_connector
		mov	LinkDetected, 1
		jmp     fast_connector

not_100FX:
		cmp	Xcvr, XCVR_10TP
		jnz	not_10TP
		call	TryLinkbeat
		jmp	short connector10

not_10TP:					;not 10TP, then 
		call	TryLoopback		;  either 10AUI or 10BNC
connector10:
		jc	slow_connector
		mov	LinkDetected, 1
		jmp	short slow_connector
;;
not_auto_select:
		cmp     Xcvr, XCVR_MII
		jne     not_mii_connector

                mov     forcemode, 100          ; force it to 100 Mb
                mov     ax, EEMiiPhySelect
                and     ax, 000fh               ; mask off all bits except 0 - 3
                cmp     ax, 1			;BASE100_T4; check EEPROM value
                je      forcing

                mov     forcemode, 10           ; force it to 10 Mb
                cmp     ax, 2			;BASE10_T; check EEPROM value
                je      forcing

                mov     forcemode, 100          ; since it doesn't match, force it
forcing:
		mov	dx, PortResetOptions
		in	ax, dx
		mov	bx, ax			; BX=ResetOptions

		mov     MIIPhyAddr, NWAY_PHY_ADDR
		test    bx, RO_MII
		jnz	forceMII
		test    bx, RO_BASET4
		jz      check_mii_speed
		mov     MIIPhyAddr, T4_Phy_ADDR
forceMII:
		call    TryMII
		jc      chk_mii_speed
		mov	LinkDetected, 0
	      	jmp	check_mii_speed

chk_mii_speed:
		mov	LinkDetected, 1
check_mii_speed:
		cmp     LineSpeed, 100
		je      fast_connector
		jmp     slow_connector

;
; determine link speed from connector.	also set BytesPerTick to 4 for 10Mbps
; operation (3.2us ticks=4 x 800ns) and 40 for 100Mbps operation (40 x 80ns).
;
fast_connector:
		mov	LineSpeed, 100		; Mbps
;960119		mov	BytesPerTick, 40
		jmp	short InitMediaAuto

;		cmp	Xcvr, XCVR_100TX
;		je	InitMediaAuto

;		cmp	Xcvr, XCVR_100FX
;		je	InitMediaAuto

;		cmp	Xcvr, XCVR_MII
;		je	InitMediaAuto

slow_connector:
		mov	LineSpeed, 10		; Mbps
;960119		mov	BytesPerTick, 4

InitMediaAuto:
;
; determine some tuning parameters
;
;  first make sure the internal DC DC converter is disabled
;

;960403       port    CmdStatus
		mov	dx, PortCmdStatus
		mov     ah, CMDH_STOPINTXCVR
		out     dx, ax		       ; issue command
;
; now give the transceiver 3ms to stabilize before we enable transmit or
; receive traffic thru it.
;
		mov	cx, Delay3ms
		call	WaitTime

; set up the connector (possibly for the second time)

		call    SetupConnector

;960403       port    CmdStatus
		mov	dx, PortCmdStatus
		SelectWindow WNO_FIFO
;960403       port    RxFree, CmdStatus
		mov	dx, PortRxFree
		in      ax, dx
;960403       port    CmdStatus, RxFree
		mov	dx, PortCmdStatus

		SelectWindow	WNO_OPERATING		 ;

		mov    ax, CMD_SETRZMASK+MASK_NONE	 ; enable all interrupts for Rev. 1
		out    dx, ax

		ret

init_vulcan_hw	endp


;------ AutoSelect ----------------------------------------------------------;
;									     ;
;	This routine attempts to auto-select the connector.  It should be    ;
;	called only if the autoselect bit is set.  If it fails, it will      ;
;	leave the current connector in InternalConfig set.		     ;
;									     ;
;	Entry:								     ;
;	cli								     ;
;	Station Address has been set up on adapter.			     ;
;	Xcvr set to the connector to use if AutoSelect fails (this should    ;
;	    be read from the EEProm, NOT from InternalConfig)		     ;
;	SWConfig has the software configuration word from the EEProm.	     ;
;	Delay3ms set for 3ms delay.					    ;
;	Delay25ms set up for a 50ms delay.				     ;
;	MediaEnable table defined.					     ;
;	Specific.mc_caddr set up with the station address.		     ;
;									     ;
;	Exit:								     ;
;	cli								     ;
;	MediaStatus, MacControl, InternalConfig set up for connector chosen. ;
;	DC-DC converter stopped/started as required.			     ;
;	TxFIFO/RxFIFO reset and disabled.				     ;
;	RZMask/IntMask disabled (0).					     ;
;	NetDiag modified for no loopback.				     ;
;	No interrupts pending.						     ;
;									     ;
;	All registers preserved.					     ;
;									     ;
;----------------------------------------------------------------------------;

AutoSelect	proc	near
		pusha
;
; set the IntMask and RZMask not to allow any interrupts through
;
;960403		port	CmdStatus
		mov	dx, PortCmdStatus
		mov	ax, CMD_SETINTMASK + 0
		out	dx, ax
		mov	ax, CMD_SETRZMASK + 0
		out	dx, ax
;
; save the default connector
;
		mov	bp, Xcvr		; save original Xcvr value
;
; determine what connectors are available
;
;960403		port	CmdStatus
		mov	dx, PortCmdStatus
		SelectWindow WNO_FIFO

;960403		port	ResetOptions, CmdStatus
		mov	dx, PortResetOptions
		in	ax, dx
		mov	bx, ax			; BX=ResetOptions
;
; if 100TX connector is available, try that.  we do 100Mbps first to avoid
; generating any 10Mbps traffic on a hub that might be autosensing and might
; switch to 10Mbps to match us.
;
; note: sending 100Mbps stuff on a 10TP connection will generally partition
;	us.  we'll need to clear this up before we're done.
;
		public	auto_try_100tx
auto_try_100TX:
		test	bx, RO_BASETX
		jz	auto_try_MII

		mov	Xcvr, XCVR_100TX
		call	TryLinkbeat
		jnc	auto_exit
		mov	LinkDetected, 0
;
; if MII is available, try that
;
		public	auto_try_MII
auto_try_MII:
		mov     MIIPhyAddr, NWAY_PHY_ADDR
		test    bx, RO_MII
		jnz	try_MII
		test    bx, RO_BASET4
		jz      auto_try_10TP
		mov     MIIPhyAddr, T4_Phy_ADDR
try_MII:
		mov	Xcvr, XCVR_MII
		mov	forcemode,0
		call	TryMII
		jc	auto_exit
		mov	LinkDetected, 0
;
; if 10TP connector is available, try that
;
		public	auto_try_10TP
auto_try_10TP:
		test	bx, RO_TP
		jz	auto_try_aui

		mov	Xcvr, XCVR_10TP
		call	TryLinkbeat
		jnc	auto_exit
		mov	LinkDetected, 0
;
; if 10AUI connector is available, try that
;
		public	auto_try_aui
auto_try_aui:
		test	bx, RO_AUI
		jz	auto_try_bnc

		mov	Xcvr, XCVR_10AUI
		call	TryLoopback
		jnc	auto_exit
		mov	LinkDetected, 0
;
; if 10BNC connector is available, try that
;
		public	auto_try_bnc
auto_try_bnc:
		test	bx, RO_COAX
		jz	auto_fail

		mov	Xcvr, XCVR_10BNC
		call	TryLoopback
		jnc	auto_exit
		mov	LinkDetected, 0
;
; nothing worked.  just switch back to the default connector
;
		public	auto_fail
auto_fail:
		mov	Xcvr, bp
		call	SetupConnector
		jmp	autox
;
; done.  leave.
;
		public	auto_exit
auto_exit:
		mov	LinkDetected, 1
autox:
		popa
		ret
AutoSelect	endp


;------ TryLinkBeat ---------------------------------------------------------;
;									     ;
;	This routine sets up the adapter to use one of the linkbeat-capable  ;
;	connectors: 10TP or 100TX.  Since the port might be partitioned by   ;
;	the hub (a previous attempt at an incorrect speed might cause this   ;
;	for example), we send a packet first to clear this up.	Then we      ;
;	look for linkbeat.						     ;
;									     ;
;	This routine is part of the auto-select logic and is called by	     ;
;	AutoSelect to do its work.					     ;
;									     ;
;	Entry:								     ;
;	cli								     ;
;	Xcvr set to the connector to set up.				     ;
;	SWConfig has the software configuration word from the EEProm.	     ;
;	Delay3ms set for 3ms delay.					    ;
;	Delay25ms set up for a 50ms delay.				     ;
;	MediaEnable table defined.					     ;
;	Specific.mc_caddr set up with the station address.		     ;
;	no interrupts pending.						     ;
;									     ;
;	Exit:								     ;
;	cli								     ;
;	clc if we get linkbeat, the connector seems fine.  stc if not.	     ;
;	DC-DC converted started/stopped.				     ;
;	MediaStatus set up.						     ;
;	MacControl set up.						     ;
;	InternalConfig set up.						     ;
;	Rx/TxFIFO's reset and disabled.                                      ;
;	NetDiag modified for no loopback.				     ;
;									     ;
;	All registers preserved.					     ;
;									     ;
;----------------------------------------------------------------------------;

		public	TryLinkbeat
TryLinkbeat	proc	near
		pusha
;
; go quiet for 1.5 seconds to get any N-Way hub into a receptive state to
; sense the new speed.  we go quiet by switching to the 10BaseT connector
; with no linkbeat
;
		call    QuietConnector

		mov     cx, 30		  ; 30 x 1/20th = 1.5 sec
tlb_qloop:
		push	cx
		mov	cx, Delay25ms
		call	WaitTime
		call	WaitTime		; assume cx preserved
		pop	cx
		loop    tlb_qloop

;
; set up the connector
;
		call	SetupConnector
;
; enable statistics
;
;960403		port	CmdStatus
		mov	dx, PortCmdStatus
;960403		StatsEnable
;
; give settling time. Run WaitTime twice to get enough delay
;
		mov	cx, Delay25ms
		call	WaitTime
		call	WaitTime		; assume cx preserved

;
; zero the Bad SSD Count stat
;
;960403		port	CmdStatus
		mov	dx, PortCmdStatus
		SelectWindow WNO_DIAGNOSTICS
;960403		port	BadSsdCount, CmdStatus
		mov	dx, PortBadSsdCount
		in	al,dx
;
; we might be partitioned.  some hubs won't clear the partition until we
; send a packet.  so send one.	the good news is that if we are partitioned
; then there is no receive traffic incoming so we don't have to wait that
; long for backoffs or retries.
;
; set up a 14-byte packet to send.  ourselves as the destination.
;
;960403		port	TxFIFO
		mov	dx, PortTxFIFO

		mov	ax, 14			; preamble
		out	dx, ax
		xor	ax, ax
		out	dx, ax

IFDEF	UNDI
		lea	si, DGroup:BoardID	;971030
ELSE
		lea	si, NetAddress
ENDIF
		mov	cx, 6
		rep outsb			    ; destination address
		mov	cx, 6
		sub	si, 6
		rep outsb			    ; source address

		xor	ax, ax			; IEEE length=0
		out	dx, ax
		out	dx, ax			; pad to 16 bytes
;
; enable transmission.
;
;960403		port	CmdStatus
		mov	dx, PortCmdStatus

		; enable the Tx
		mov     ah, CMDH_TXENABLE
		out     dx, ax

;
; wait 1/4 second for the linkbeat detect logic at 10Mbps, and 1.25sec (!)
; for the linkbeat detect logic at 100Mbps (MII spec).
;
		mov	cx, 5			; 5 x 1/20th = 1/4 sec
		cmp	Xcvr, XCVR_100TX
		jne	Delay100TX
		mov	cx, 25			; 25 x 1/20th = 1.25 sec
Delay100TX:

tlb_loop:
		push	cx
		mov	cx, Delay25ms
		call	WaitTime
		call	WaitTime
		pop	cx

		loop	tlb_loop
;
; check for linkbeat
;
;960403		port	CmdStatus
		mov	dx, PortCmdStatus
		SelectWindow WNO_DIAGNOSTICS

;960403		port	MediaStatus, CmdStatus
		mov	dx, PortMediaStatus
		in	ax, dx			; AX=MediaStatus
		test	ax, MEDIA_LBEAT 	; got linkbeat?
		jnz     tlb_gotlink
;
; no linkbeat.	connector probably not connected to a network.
;
		public	tlb_bad
tlb_bad:
		stc
		jmp	short tlb_exit
;
; got linkbeat.  if we're testing 10BaseT, that's good enough.
;
		public  tlb_gotlink
tlb_gotlink:
		cmp     Xcvr, XCVR_10TP
		je      tlb_good_10
;
; with 100BaseTX the problem is that 10Mbps traffic makes the 100Mbps link beat
; indication go on.  so we need to do some sanity checking of the result.  we
; want to loop around for a while looking for linkbeat to go off (there was
; a long enough gap in the 10Mbps traffic) or a packet to be received (if good,
; then its a real 100Mbps network).  we also sample carrier during this loop.
; if we see carrier enough of the time during the loop, then we should have
; received a packet.  if not, its just 10Mbps traffic giving us a false linkbeat.
; this is acceptable only because this loop runs for a very long time relative
; to the wire.  on current PCI systems with a single I/O taking around 600ns,
; this loop run run around 1/16th of a second.  this is long enough for 150
; max size 4500 byte packets plus 333 additional slot times for backoff.  this
; seems a reasonable period to require a packet to show up if we have carrier.
; the only exposure here is if some future system has massively faster single
; I/O cycles, which doesn't seem too worrisome.
;
;		port    CmdStatus
		mov	dx, PortCmdStatus
		mov     ax, CMD_SETRXFILTER + FILTER_PROMISCUOUS
		out     dx, ax
;		RxEnable
		; enable the receiver
		mov     ah, CMDH_RXENABLE
		out     dx, ax

		xor     bx, bx		  ; BX=# CRS's seen=0
		mov     cx, 0FFFFh	      ; CX=# loops to do
tlb_outer:
;		port    RxStatus
		mov	dx, PortRxStatus
		in      ax, dx
		test    ax, RXS_INCOMPLETE      ; got a packet?
		jnz	nopkg			; ...nope
		test    ax, RXS_ERROR		; any errors?
		jz      tlb_good		; ...no errors, must be 100Mbps

;		port    RxStatus, CmdStatus
		mov	dx, PortRxStatus
nopkg:
;		port    MediaStatus, RxStatus
		mov	dx, PortMediaStatus
		in      ax, dx

		test    ax, MEDIA_LBEAT		; still got linkbeat?
		jz      tlb_bad			; nope--bad link

		test    ax, MEDIA_CRS		; count CRS's seen
		jz      crss
		inc     bx			; ++BX = # of CRS's seen
crss:
		loop    tlb_outer
;
; fell out of loop.  linkbeat the whole time.  no good packets received.  if
; carrier sense was on a lot of the time, then we should have got a packet.
; if not, its a false reading.
;
		cmp     bx, 4000h		; CRS on 1/4 of the time?
		jae     tlb_bad			; if so, false reading
;
; connector good.  return carry clear.
;
tlb_good:
tlb_good_10:
		clc
;
; return current carry flag setting after disabling.
;
		public	tlb_exit
tlb_exit:
		pushf

;960403		port	CmdStatus
		mov	dx, PortCmdStatus
		call	TxReset
		call	RxReset

		popf
		popa
		ret
TryLinkbeat	endp


;------ QuietConnector ------------------------------------------------------;
;
;       This routine shuts down all output from the adapter.  It does this
;       by selecting the 10BaseT connector and disabling linkbeat.
;
;       Entry:
;       cli
;       DelayXcvr set for 3ms delay.
;
;       Exit:
;       cli
;       DC-DC stopped.
;       InternalConfig set to use 10BaseT.
;       MediaStatus set to linkbeat disabled.
;       Rx/TxFIFO's reset and disabled.
;
;       All registers preserved.
;
;----------------------------------------------------------------------------;

		public  QuietConnector
QuietConnector  proc    near
		pusha
;
; set up the InternalConfig for 10BaseT
;
;		port    CmdStatus
		mov	dx, PortCmdStatus
		SelectWindow WNO_FIFO
;		port    InternalCfgH, CmdStatus
		mov	dx, PortInternalCfgH
		in      ax, dx
		and     ax, NOT ICH_XCVR_MASK
		or      ax, XCVR_10TP SHL ICH_XCVR_SHIFT
		out     dx, ax
;
; in MediaStatus, disable linkbeat generation
;
;		port    CmdStatus
		mov	dx, PortCmdStatus
		SelectWindow WNO_DIAGNOSTICS

;		port    MediaStatus, CmdStatus
		mov	dx, PortMediaStatus
		in      ax, dx		  ; AX=media status
		and     ax, NOT (MEDIA_LBEATENABLE)
		out     dx, ax		  ; write it back
;
; reset the Tx/RxFIFO's
;
;		port    CmdStatus
		mov	dx, PortCmdStatus
		call	TxReset
		call	RxReset

		popa
		ret

QuietConnector  endp


;------ TryLoopback ---------------------------------------------------------;
;									     ;
;	This routine sets up the adapter to use one of the		     ;
;	non-linkbeat-capable connectors: 10BNC or 10AUI.  For these	     ;
;	connectors we enable external loopback and transmit a packet to      ;
;	ourselves.  If we receive it (or any other packet without errors)    ;
;	the connector works.						     ;
;									     ;
;	This routine is part of the auto-select logic and is called by	     ;
;	AutoSelect to do its work.					     ;
;									     ;
;	Entry:								     ;
;	cli								     ;
;	Xcvr set to the connector to set up.				     ;
;	SWConfig has the software configuration word from the EEProm.	     ;
;	Delay3ms set for 3ms delay.					    ;
;	Delay25ms set up for a 50ms delay.				     ;
;	MediaEnable table defined.					     ;
;	Specific.mc_caddr set up with the station address.		     ;
;	no interrupts pending.						     ;
;									     ;
;	Exit:								     ;
;	cli								     ;
;	clc if we get linkbeat, the connector seems fine.  stc if not.	     ;
;	DC-DC converted started/stopped.				     ;
;	MediaStatus set up.						     ;
;	MacControl set up.						     ;
;	InternalConfig set up.						     ;
;	Rx/TxFIFO's reset and disabled.                                      ;
;	NetDiag modified for no loopback.				     ;
;									     ;
;	All registers preserved.					     ;
;									     ;
;----------------------------------------------------------------------------;

		public	TryLoopback
TryLoopback	proc	near
		pusha
;
; set up the connector
;
		call	SetupConnector
;
; enable external loopback so that we can see our own packets
;
;960403		port	CmdStatus
		mov	dx, PortCmdStatus
		SelectWindow WNO_DIAGNOSTICS
;960403		port	NetDiagnostic, CmdStatus
		mov	dx, PortNetDiag
		in	ax, dx
		and	ax, NETD_NOLOOPBACK_MASK
		or	ax, NETD_EXTLOOPBACK
		out	dx, ax
;
; up to three times (we might get collisions) try to loop a packet thru
;
		mov	bp, 3			; outer loop count

		public	tlp_loop
tlp_loop:
;
; reset both transmitter and receiver, enable both and set up our packet
; filter to receive anything
;
;960403		port	CmdStatus
		mov	dx, PortCmdStatus
		call	TxReset
;960403		TxEnable
		; enable the transmitter
		mov     ah, CMDH_TXENABLE
		out     dx, ax

		call	RxReset

		; enable the receiver
		mov     ah, CMDH_RXENABLE
		out     dx, ax

		mov	ax, CMD_SETRXFILTER + FILTER_PROMISCUOUS
		out	dx, ax
;
; send a 14-byte packet to ourselves.
;
		mov	dx, PortCmdStatus
		SelectWindow WNO_OPERATING
;960403		port	TxFIFO
		mov	dx, PortTxFIFO

		mov	ax, 14			; preamble
		out	dx, ax
		xor	ax, ax
		out	dx, ax

IFDEF	UNDI
		lea	si, DGroup:BoardID	;971030
ELSE
		lea	si, NetAddress
ENDIF
		mov	cx, 6
	    rep outsb				; destination address
		mov	cx, 6
		sub	si, 6
	    rep outsb				; source address

		xor	ax, ax			; IEEE length=0
		out	dx, ax
		out	dx, ax			; pad to 16 bytes
;
; wait for the packet to show up in RxStatus.  give it up to 1/4 second.
;
		mov	cx, 5			; 5 x 1/20th = 1/4 second
tlp_rxloop:
;960403		port	RxStatus
		mov	dx, PortRxStatus
		in	ax, dx
		test	ax, RXS_INCOMPLETE
		jz	tlp_rxcomplete

		push	cx			; 950511
		mov	cx, Delay25ms
		call	WaitTime
		call	WaitTime
		pop	cx			; 950511

		loop	tlp_rxloop
;
; no complete packets received.  try again.
;
		public	tlp_rxfail
tlp_rxfail:
		dec	bp
;960402		djnz	tlp_loop
		jnz	tlp_loop
		jmp	tlp_bad
;
; a complete RxStatus.	check for any errors.
;
		public	tlp_rxcomplete
tlp_rxcomplete:
		test	ax, RXS_ERROR
		jnz	tlp_rxfail
;
; got a good receive packet.  connector seems good.
;
		public	tlp_good
tlp_good:
		clc
		jmp	short tlp_exit
;
; no packets received.	connector probably not connected to a network.
;
		public	tlp_bad
tlp_bad:
		stc
;
; return current carry flag setting after disabling/resetting.
;
		public	tlp_exit
tlp_exit:
		pushf

;960403		port	CmdStatus
		mov	dx, PortCmdStatus
		SelectWindow WNO_DIAGNOSTICS
;960403		port	NetDiagnostic, CmdStatus
		mov	dx, PortNetDiag
		in	ax, dx
		and	ax, NETD_NOLOOPBACK_MASK
		out	dx, ax			; disable any loopback modes
;960403		port	CmdStatus
		mov	dx, PortCmdStatus

		call	TxReset
		call	RxReset

		popf
		popa
		ret
TryLoopback	endp


;------ SetupConnector ------------------------------------------------------;
;									     ;
;	This routine sets up the adapter to use the specified connector.     ;
;	It sets up the connector in InternalConfig, sets bits in MacControl  ;
;	and MediaStatus as appropriate, and starts/stops the DC-DC converter ;
;	as required.							     ;
;									     ;
;	Entry:								     ;
;	cli								     ;
;	Xcvr set to the connector to set up.				     ;
;	SWConfig has the software configuration word from the EEProm.	     ;
;	Delay3ms set for 3ms delay.					    ;
;	MediaEnable table defined.					     ;
;									     ;
;	Exit:								     ;
;	cli								     ;
;	DC-DC converted started/stopped.				     ;
;	MediaStatus set up.						     ;
;	MacControl set up.						     ;
;	InternalConfig set up.						     ;
;	Rx/TxFIFO's reset and disabled.                                      ;
;	NetDiag modified for no loopback.				     ;
;									     ;
;	All registers preserved.					     ;
;									     ;
;----------------------------------------------------------------------------;

		public	SetupConnector
SetupConnector	proc	near
		pusha
;
; disable any loopback modes in effect
;
;960403		port	CmdStatus
		mov	dx, PortCmdStatus
		SelectWindow WNO_DIAGNOSTICS
;960403		port	NetDiagnostic, CmdStatus
		mov	dx, PortNetDiag
		in	ax, dx
		and	ax, NETD_NOLOOPBACK_MASK
		out	dx, ax
;
; set up the connector in InternalConfig
;
;960403		port	CmdStatus
		mov	dx, PortCmdStatus
		SelectWindow WNO_FIFO
;960403		port	InternalCfgH, CmdStatus
		mov	dx, PortInternalCfgH
		in	ax, dx
		and	ax, NOT ICH_XCVR_MASK
		mov	cx, Xcvr
		shl	cx, ICH_XCVR_SHIFT
		or	ax, cx
		out	dx, ax
;
; if full-duplex operation is specified, go enable it.	disable all the weird
; stuff for now.
;
;960403		port	CmdStatus
		mov	dx, PortCmdStatus
		SelectWindow WNO_FIFO

;960403		port	MacControl, CmdStatus
		mov	dx, PortMacControl
		in	ax, dx
		and	ax, NOT MACC_FULLDUPLEX ; not full duplex
		and	ax, NOT MACC_ALLOWLARGE ; no large packets
		and	ax, NOT MACC_DEFEREXTEND ; normal 802.3 deferrence
;;;;;;
		cmp     Xcvr, XCVR_MII
		jne     check_duplex   ; if it not an MII connector, check the software info
			      ; to decide to enable full-duplex or not

; if we are using MII connector, then check are we in autoselect mode. If we are
; useing autoselect, then do not use the the SW_FULLDUPLEX bit to set duplex mode,
; read the auto-negoation result to set the duplex mode.

		cmp    EEMiiPhySelect, -1
		jne     check_duplex

		test    MiiPhyUsed, MII_100BASEX_FD + MII_10BASET_FD
		jnz     set_full_duplex
		jmp     nset_full_duplex

; Cehck the SW_FULLDUPLEX bit, when we are using the Force mode with MII connector
; and when the non-MII connector being used.

check_duplex:
		test	EESoftConfigInfo, SW_FULLDUPLEX
		jz	ConnectDuplex

set_full_duplex:
		or	ax, MACC_FULLDUPLEX

nset_full_duplex:
ConnectDuplex:
		out	dx, ax
;
; setup various bits in MediaStatus (jabber, linkbeat, sqe) as appropriate
; for the connector.  the user can force linkbeat off if desired at 10Mbps.
;
;960403		port	CmdStatus
		mov	dx, PortCmdStatus
		SelectWindow WNO_DIAGNOSTICS

;960403		port	MediaStatus, CmdStatus
		mov	dx, PortMediaStatus
		in	ax, dx			; AX=media status
		and	ax, NOT MEDIA_XCVRBITS	; mask bits off first
		mov	bx, Xcvr		; transceiver type
		shl	bx, 1			; use as index into table
		or	ax, MediaEnable[bx]	; on bits appropriate to xcvr

		test	EESoftConfigInfo, SW_LINKBEAT	; if set, don't enable linkbeat
		jz	ConnectLinkBeat
		cmp	Xcvr, XCVR_10TP 	; but only for 10TP
		jne	ConnectLinkBeat
		and	ax, NOT (MEDIA_LBEATENABLE)
ConnectLinkBeat:
		out	dx, ax			; write it back
;
; if configured for 10Base2 we must start the internal transceiver.  if not
; we stop it (just in case the configuration has changed and we haven't cold
; booted).
;
;960403		port	CmdStatus
		mov	dx, PortCmdStatus
		mov	ah, CMDH_STARTINTXCVR	; if BNC, start
		cmp	Xcvr, XCVR_10BNC
		je	ConnectXcvr
		mov	ah, CMDH_STOPINTXCVR	; else, stop
ConnectXcvr:	out	dx, ax			; issue command
;
; now give the transceiver 3ms to stabilize before we enable transmit or
; receive traffic thru it.
;
		mov	cx, Delay3ms
		call	WaitTime

;
; reset the Tx/RxFIFO's
;
;960403		port	CmdStatus
		mov	dx, PortCmdStatus
		call	TxReset
		call	RxReset

		popa
		ret
SetupConnector	endp


;------ TryMII --------------------------------------------------------------;
;
;	Auto negotiates the speed and duplex with link partner.
;
;	Entry:
;	none
;
;	Exit:
;	Carry bit set: found MII
;	Carry bit clear: MII test failed
;	zf = 0	hardware failure
;	zf = 1	recoverable failure
;----------------------------------------------------------------------------;

		public	TryMII
TryMII		proc	near
		pusha
;
; First, to detect if there is anything connected to the MII
;
;		mov	auto_negotiated, 0	    ; clear auto negotiated flag
		call	FindMIIPhy
		jnz	tm01
		jmp	tm_fail_hw

tm01:
;
; The MII Phy exists. Reset it.
; DX has the offset of control reg. AX return the value of control reg.
;
		mov	dx, MII_PHY_CONTROL
		call	ReadMIIPhy
		jc	tm02
		jmp	tm_fail_hw

tm02:
		or	ax, MII_CTL_RESET
		call	WriteMIIPhy

		mov	cx, 10
tm_loop1:
		push	cx
		mov	dx, MII_PHY_CONTROL
		call	ReadMIIPhy
		pop	cx
		jc	tm03
		jmp	tm_fail_hw

tm03:
		test	ax, MII_CTL_RESET
		jz	mii_reset_done

		call	Delay200ms			 ; delay 200 ms
		loop	tm_loop1
		jmp	tm_fail_hw

mii_reset_done:
; Force mode is used when autoselect is not enabled and we have to read the
; EEPROM.
		cmp	forcemode, 0
		je	not_force_mode
		jmp	force_the_speed

not_force_mode:
		mov	dx, MII_PHY_CONTROL
		call	ReadMIIPhy
		jc	tm04
		jmp	tm_fail_hw

tm04:
		mov	cx, ax			; cx <= control reg.
;
; now we can read the status and try to figure out what's out there.
;
		push	cx
		mov	dx, MII_PHY_STATUS
		call	ReadMIIPhy
		pop	cx
		jc	tm05
		jmp	tm_fail_hw

tm05:
;
; bit 15 = 100BaseT4,
; bit 14 = 100BaseTX (full duplex),
; bit 13 = 100BaseTX (half duplex),
; bit 12 = 10BaseT (full duplex),
; bit 11 = 10BaseT (half duplex)
;
		test	ax, MII_STS_100MB_MASK+MII_STS_10MB_MASK
		jnz	handle_both
		jmp	tm_fail_hw		; sanity check

handle_both:
;
; if MII does not have extended registers, we have no way to tell
; what the link speed is after the completion of auto negotiation.
; (no ANLPAR register, no PAR regiater)
;
		test	ax, MII_STS_EXTENDED
		jnz	tm06
		jmp	no_auto_nego

tm06:
;
; see if it is capable of auto negotiation
;
		test	ax, MII_STS_AUTO
		jnz	tm07
		jmp	no_auto_nego

tm07:
;
; it is capable of auto negotiation, see if it has been done already.
; if not, re-initialize autoselect. otherwise, accept the results.
;
; special hack for National part.  We know we are NWAY capable
; and we are not the Broadcom T4 part which is not NWAY capable
		push	cx
		push	ax
		mov	dx, MII_PHY_PCR
		call	ReadMIIPhy
		jc	force_link_disc
		jmp	tm_fail_hw

force_link_disc:
		or	ax, 0020h			; set bit 5 = 1, force
							; disconnect to bypass
		mov	dx, MII_PHY_PCR
		call	WriteMIIPhy
		pop	ax
		pop	cx

		test	cx, MII_CTL_ENABLE_AUTO
		jz	auto_not_enabled

		test	ax, MII_STS_AUTO_DONE
		jz	auto_not_enabled
		jmp	auto_nego_done

auto_not_enabled:
		mov	ax, cx			; AX <= control reg.
		or	ax, MII_CTL_START_AUTO
		or	ax, MII_CTL_ENABLE_AUTO
		mov	dx, MII_PHY_CONTROL
		call	WriteMIIPhy

		mov	cx, 10
tm_loop2:
		push	cx
		mov	dx, MII_PHY_STATUS
		call	ReadMIIPhy
		pop	cx
		jc	tm08
		jmp	tm_fail_hw

tm08:
		test	ax, MII_STS_AUTO_DONE
		jnz	auto_nego_done

		call	Delay200ms			 ; delay 200 ms
		loop	tm_loop2
;
; pending: if MII_STS_AUTO_DONE never set in status reg. so just get out
;
		jmp	tm_fail

auto_nego_done:

; check link status.  Since it is a latch function, read status register again.
;		mov	mii_mode, 0
;		mov	auto_negotiated, 1
		mov	dx, MII_PHY_STATUS
		call	ReadMIIPhy
		jc	tm09
		jmp	tm_fail_hw

tm09:
		test	ax, MII_STS_LINK_UP
		jnz	tm10
		jmp	tm_fail

tm10:
		mov	dx, MII_PHY_ANLPAR
		call	ReadMIIPhy
		jnc	tm_fail_hw

		mov	phyANLPAR, ax

		mov	dx, MII_PHY_ANAR
		call	ReadMIIPhy
		jnc	tm_fail_hw

		mov	phyANAR, ax

		mov	bx, phyANLPAR		; link partner's abilities
		test	bx, 03e0h		; bits 9 - 5 set?
		jz	nway_patch		; nope, go to NWAY patch for National part

		mov	ax, phyANAR		; my abilities
		test	bx, MII_ANLPAR_100BASET4 + MII_ANLPAR_100BASEX_FD + MII_ANLPAR_100BASEX_HD
		jz	tm11

		test	ax, MII_ANLPAR_100BASET4 + MII_ANLPAR_100BASEX_FD + MII_ANLPAR_100BASEX_HD
		jnz	auto_nego_must_be_100

tm11:
		and	ax, MII_ANLPAR_10BASET_FD + MII_ANLPAR_10BASET_HD
		and	bx, MII_ANLPAR_10BASET_FD + MII_ANLPAR_10BASET_HD
		test	ax, bx
		jnz	auto_nego_must_be_10
		jmp	tm_fail 		; just get out

auto_nego_must_be_100:
;		mov	full_duplex, 1		; it is full duplex
		test	ax, MII_ANLPAR_100BASEX_FD
		jz	tm12

		test	bx, MII_ANLPAR_100BASEX_FD
		jnz	must_be_100mb

tm12:
;		mov	full_duplex, 0		; half duplex
		jmp	must_be_100mb

auto_nego_must_be_10:
;		mov	full_duplex, 1
		test	ax, MII_ANLPAR_10BASET_FD
		jz	tm13

		test	bx, MII_ANLPAR_10BASET_FD
		jnz	must_be_10mb

tm13:
;		mov	full_duplex, 0
		jmp	must_be_10mb

;
; PATCH for National n-way chip problem.
; Should read the ANLPAR reg. and ANAR reg. to determine the link used.
; See P010.C, a workaround solution is to read PAR reg. instead.
;
nway_patch:
;		mov	full_duplex, 0		; since link partner not NWAY default to half duplex
		mov	dx, MII_PHY_PAR
		call	ReadMIIPhy
		jc	tm14
		jmp	tm_fail

tm14:
		test	ax, 0040h		; SPEED_10 = bit 6
		jnz	must_be_10mb
;
; *** end of PATCH
;
must_be_100mb:
		mov	LineSpeed, 100
		stc				; return success
		jmp	tm_exit

must_be_10mb:
		mov	LineSpeed, 10
		stc				; return success
		jmp	tm_exit

;
; auto negotiation didn't work.
;
no_auto_nego:
;		mov	auto_negotiated, 0	; didn't auto negotiate
;
; need to read the MIIPhyOui and MIIPhyModel reg. to check if a Broadcom part
; AX = status reg. CX = control reg.
;
		push	ax
		push	cx
		mov	dx, MII_PHY_OUI
		call	ReadMIIPhy
		mov	MIIPhyOui, ax
		jc	tm15
		pop	cx
		pop	ax
		jmp	tm_fail_hw

tm15:
		mov	dx, MII_PHY_MODEL
		call	ReadMIIPhy
		mov	MIIPhyModel, ax
		pop	cx
		pop	ax
		jc	tm16
		jmp	tm_fail_hw		; just get out

; It might be a Broadcom part that only supports T4
tm16:
		cmp	MIIPhyOui, 03e0h
		je	tm17
		jmp	tm_fail_hw		; just get out

tm17:
		cmp	MIIPhyModel, 0
		je	tm18
		jmp	tm_fail_hw

tm18:
; need to set some flags for bug fixes for Broadcom T4 part.
		mov	broadcom, 1			; do broadcom fix
		push	ax
		push	cx
		test	cx, MII_CTL_ENABLE_AUTO ; here it is auto-selection
						; not auto-negotiation
		jz	bcm_auto_not_enabled

		test	ax, MII_STS_AUTO_DONE
		jz	bcm_auto_not_enabled
		jmp	bcm_auto_done

bcm_auto_not_enabled:
		mov	ax, cx
		or	ax, MII_CTL_ENABLE_AUTO ; enable auto selection
		and	ax, NOT MII_CTL_FULL_DUPLEX
;		test	SWConfig, SW_FULLDUPLEX
;		jz	@F
;
;		or	ax, MII_CTL_FULL_DUPLEX
;@@:
		mov	dx, MII_PHY_CONTROL
		call	WriteMIIPhy

bcm_auto_done:
		pop	cx
		pop	ax

; check link status.  Since it is a latch function, read status register again.
		mov	cx, 10

link_status_loop:
		push	cx
		mov	dx, MII_PHY_STATUS
		call	ReadMIIPhy
		pop	cx
		jc	tm19
		jmp	tm_fail_hw

tm19:
		test	ax, MII_STS_LINK_UP
		jnz	read_ext_reg

		call	Delay200ms

		loop	link_status_loop
		jmp	tm_fail

;
; read address reg. 10h
;
read_ext_reg:
		mov	dx, MII_EXT_REG0
		call	ReadMIIPhy		; read extended reg. 0 to get speed
		jc	tm20
		jmp	tm_fail_hw

tm20:
		test	ax, MII_EXT_SPEED	; speed is (1=100, 0=10)
		jnz	tm21
		jmp	must_be_10mb

tm21:
		jmp	must_be_100mb

;
; Force the speed to whatever was set in the EEPROM
;
force_the_speed:
		mov	broadcom, 0
		mov	dx, MII_PHY_OUI
		call	ReadMIIPhy
		mov	MIIPhyOui, ax
		jc	tm22
		jmp	tm_fail_hw

tm22:
		 mov	 dx, MII_PHY_MODEL
		 call	 ReadMIIPhy
		 mov	MIIPhyModel, ax
		 jc	 tm23
		 jmp	 tm_fail_hw		 ; just get out

; It might be a Broadcom part that only supports T4
tm23:
		mov	broadcom, 1		; this is a broadcom part
		cmp	MIIPhyOui, 03e0h
		je	tm24

tm24:
		cmp	MIIPhyModel, 0
		je	tm25

		mov	broadcom, 0		; not a broadcom
; special hack for National part.
		mov	dx, MII_PHY_PCR 	; yes, do National fix
		call	ReadMIIPhy
		jc	forcemode_link_disc
		jmp	tm_fail_hw

forcemode_link_disc:
		or	ax, 0020h			; set bit 5 = 1, force
							; disconnect to bypass
		mov	dx, MII_PHY_PCR
		call	WriteMIIPhy

tm25:
		mov	dx, MII_PHY_CONTROL
		call	ReadMIIPhy
		jnc	tm_fail_hw

		mov	cx, ax
; determine duplex
;
set_duplex:
		and	ax, NOT MII_CTL_FULL_DUPLEX	; half duplex
;		test	SWConfig, SW_FULLDUPLEX
;		jz	@F
;
;		or	ax, MII_CTL_FULL_DUPLEX 	; full duplex
;@@:
		and	ax, not MII_CTL_ENABLE_AUTO	; disable auto negotiation
		or	ax, MII_CTL_100MB		; select 100Mb
		mov	LineSpeed, 100
		cmp	forcemode, 100			; am I forcing to 100?
		je	tm26				; yes

		and	ax, not MII_CTL_100MB		; select 10 MB
		mov	LineSpeed, 10
tm26:
		mov	dx, MII_PHY_CONTROL
		call	WriteMIIPhy

		push	cx

; check link status.  Since it is a latch function, read status register again.
		mov	cx, 10
link_stat_loop:
		push	cx
		mov	dx, MII_PHY_STATUS
		call	ReadMIIPhy
		pop	cx
		jc	tm27
		pop	cx
		jmp	tm_fail_hw

tm27:
		test	ax, MII_STS_LINK_UP
		jnz	linkup

		call	Delay200ms
		loop	link_stat_loop
		pop	cx
		jmp	tm_fail

linkup:
		pop	cx
; workaround for T4 bug
		cmp	broadcom, 1
		je	tm28

;nway_bug_fix:
		test	cx, 2000h			; if previous speed=100
		jnz	tm28				; don't reset

		cmp	LineSpeed, 100			; prev. speed = 10, check current speed
		jne	tm28

		mov	dx, MII_CTL_RESET		; current speed = 100,
		call	WriteMiiPhy			; need to reset
tm28:
;		mov	mii_mode, 03h			; forced by user
		stc
		jmp	short tm_exit

tm_fail_hw:
;		mov	mii_mode, 0ffh
		or	ax, 1				; zf = 0
		clc					; cf = 0
		jmp	short tm_exit

tm_fail:
;		mov	mii_mode, 0ffh
		xor	ax, ax				; zf = 1
		clc					; cf = 0
tm_exit:
		popa
		ret

TryMII		endp

			
;------ FindMIIPhy ----------------------------------------------------------;
;        
;       Exit:
;       ZF set: not found
;       ZF clear: found
;----------------------------------------------------------------------------;

                public  FindMIIPhy
FindMIIPhy      proc    near
                pusha
;                port    CmdStatus
		mov	dx, PortCmdStatus
                SelectWindow    WNO_DIAGNOSTICS
;                port    SlingshotStatus, CmdStatus      ; dx: mii port
		mov	dx, PortPhyMgmt
;
; drop everything, so we are not driving the data, and run the clock
; through 32 cycles in case the PHY is trying to tell us something. Then
; read the data line, since the PHY's pull-up will read as a 1 if it's
; present.
;
                xor     ax, ax
                out     dx, ax

                mov     cx, 32
fmp_loop:
                call	Delay500ns
                mov     ax, MGMT_PHY_CLOCK
                out     dx, ax
                call	Delay500ns
                xor     ax, ax
                out     dx, ax
                loop    fmp_loop

                in      ax, dx
                test    ax, MGMT_PHY_DATA1

                popa
                ret
FindMIIPhy      endp


;------ SendOneBitToMII --------------------------------------------------------;
;
; send one bit out on MDIO.
;
; On Entry:
;     bit 0 in AX - the bit to be sent.
;
; On Exit:
;     none
;----------------------------------------------------------------------------;

                public  SendOneBitToMII
SendOneBitToMII proc    near

                or      ax, MGMT_PHY_WRITE
                out     dx, ax
                call	Delay500ns

                or      ax, MGMT_PHY_CLOCK
                out     dx, ax
                call	Delay500ns

                and     ax, NOT MGMT_PHY_CLOCK
                out     dx, ax
                call	Delay500ns

                ret
SendOneBitToMII endp


;------ WriteMIIPhy ---------------------------------------------------------;
;
;	Entry:
;	DX = the register offset
;	AX = the data to be written to the register of xcvr
;
;	Exit:
;	All registers are preserved.
;
;----------------------------------------------------------------------------;

		public	WriteMIIPhy
WriteMIIPhy	proc	near
		pusha

		push	ax
		push	dx
;		port	CmdStatus
		mov	dx, PortCmdStatus
		SelectWindow	WNO_DIAGNOSTICS
;		port	PhysicalMgmt, CmdStatus      ; dx: mii port
		mov	dx, PortPhyMgmt

		mov	cx, 32
wmp_preamblebits:
		mov	ax, MGMT_PHY_DATA1
		call	SendOneBitToMII
		loop	wmp_preamblebits
; start of frame = 01
		xor	ax, ax
		call	SendOneBitToMII
		mov	ax, MGMT_PHY_DATA1
		call	SendOneBitToMII
; op code = 01h
		xor	ax, ax
		call	SendOneBitToMII
		mov	ax, MGMT_PHY_DATA1
		call	SendOneBitToMII
; PHY address = 18h (nway), 01h (T4)
		  mov	  bl, miiphyaddr
		  shl	  bl, 3 			; phy addr is 5 bits
		  mov	  cx, 5

send_phy_addr:
		  xor	  ax, ax
		  sal	  bl, 1
		  jnc	  wMii1

		  mov	  ax, MGMT_PHY_DATA1
wMii1:
		  call	  SendOneBitToMII
		  loop	  send_phy_addr
; Reg. address
		pop	bx
		mov	cx, 5
wmp_outregaddr:
		xor	ax, ax
		test	bx, 0010h
		jz	wMii2
		mov	ax, MGMT_PHY_DATA1
wMii2:
		call	SendOneBitToMII
		shl	bx, 1
		loop	wmp_outregaddr
; turnaround
		mov	ax, MGMT_PHY_DATA1
		call	SendOneBitToMII
		xor	ax, ax
		call	SendOneBitToMII

		pop	bx
		mov	cx, 16
write16bits:
		xor	ax, ax
		test	bx, 8000h
		jz	wMii3

		mov	ax, MGMT_PHY_DATA1
wMii3:
		call	SendOneBitToMII
		shl	bx, 1
		loop	write16bits
;
; OK now give it a clock with nobody driving.
;
		mov	ax, MGMT_PHY_CLOCK
		out	dx, ax
		call	Delay500ns
		xor	ax, ax
		out	dx, ax
		call	Delay500ns

		popa
		ret
WriteMIIPhy	endp


;------ ReadMIIPhy ----------------------------------------------------------;
;
;	Entry:
;	DX = the register offset
;
;	Exit:
;	Carry bit set: success
;	Carry bit clear: failed
;	AX = the value of the register in xcvr
;
;----------------------------------------------------------------------------;

		public	ReadMIIPhy
ReadMIIPhy	proc	near

		push	bx
		push	cx
		push	dx
;		port	CmdStatus
		mov	dx, PortCmdStatus
		SelectWindow	WNO_DIAGNOSTICS
;		port	PhysicalMgmt, CmdStatus      ; dx: mii port
		mov	dx, PortPhyMgmt

		mov	cx, 32
rmp_preamblebits:
		mov	ax, MGMT_PHY_DATA1
		call	SendOneBitToMII
		loop	rmp_preamblebits
; start of frame
		xor	ax, ax
		call	SendOneBitToMII
		mov	ax, MGMT_PHY_DATA1
		call	SendOneBitToMII
; op code
		mov	ax, MGMT_PHY_DATA1
		call	SendOneBitToMII
		xor	ax, ax
		call	SendOneBitToMII
; PHY address = 18H
		  mov	  bl, miiphyaddr
		  shl	  bl, 3 			; phy addr is 5 bits
		  mov	  cx, 5

read_send_phy_addr:
		  xor	  ax, ax
		  sal	  bl, 1
		  jnc	  rMii1

		  mov	  ax, MGMT_PHY_DATA1
rMii1:
		  call	  SendOneBitToMII
		  loop	  read_send_phy_addr
; Reg. address
		pop	bx
		mov	cx, 5
rmp_outregaddr:
		xor	ax, ax
		test	bx, 0010h
		jz	rMii2
		mov	ax, MGMT_PHY_DATA1
rMii2:
		call	SendOneBitToMII
		shl	bx, 1
		loop	rmp_outregaddr
; turnaround
		xor	ax, ax
		out	dx, ax
		call	Delay500ns
		mov	ax, MGMT_PHY_CLOCK
		out	dx, ax
		call	Delay500ns
		xor	ax, ax
		out	dx, ax
		call	Delay500ns

		in	ax, dx
		test	ax, MGMT_PHY_DATA1
		jz	rMii3
		;SelectWindow WNO_OPERATING
		clc
		jmp	rmp_exit
rMii3:
		mov	ax, MGMT_PHY_CLOCK
		out	dx, ax
		call	Delay500ns
		xor	ax, ax
		out	dx, ax
		call	Delay500ns

		xor	bx, bx
		mov	cx, 16
read16bits:
		shl	bx, 1
		in	ax, dx

		test	ax, MGMT_PHY_DATA1
		jz	rMii4

		or	bx, 0001h
rMii4:
		mov	ax, MGMT_PHY_CLOCK
		out	dx, ax
		call	Delay500ns
		xor	ax, ax
		out	dx, ax
		call	Delay500ns
		loop	read16bits
;
; OK now give it a couple of clocks with nobody driving.
;
		mov	ax, MGMT_PHY_CLOCK
		out	dx, ax
		call	Delay500ns
		xor	ax, ax
		out	dx, ax
		call	Delay500ns

		mov	ax, bx
		stc		; should take out this
rmp_exit:
		pop	cx
		pop	bx
		ret
ReadMIIPhy	endp


;------ TestMIILink ---------------------------------------------------------;
;        
; Read the "link is up" bit, (this will reset it in case it was latched
; low due to a failure) and then read it again to see if the link is up.
;
;       Exit:
;       Carry set: success
;       Carry clear: failed
;----------------------------------------------------------------------------;

                public  TestMIILink
TestMIILink     proc    near
                pusha

                mov     dx, MII_PHY_STATUS
                call    ReadMIIPhy
                jnc     tml_exit
                
                mov     dx, MII_PHY_STATUS
                call    ReadMIIPhy
                mov     ax, MiiRegValue
                jnc     tml_exit
                test    ax, MII_STS_LINK_UP
                jz      tml_exit
                stc
tml_exit:
                popa
                ret
TestMIILink     endp


;------ CalibrateDelay ------------------------------------------------------;
;									     ;
;	This routine computes the number of loop iterations for 5 timer      ;
;	ticks.	From this ComputeDelay can then compute the number of loop   ;
;	iterations to delay a specified number of microseconds.  Note that   ;
;	the delay loop and the compute loop must use the same instructions.  ;
;									     ;
;	Note: since interrupts must be enabled during this operation in      ;
;	order to accumulate timer ticks, we minimize the possible overhead   ;
;	by masking off all other interrupts through the PIC temporarily.     ;
;									     ;
;	Entry:								     ;
;	DS	= DGROUP						     ;
;	cli								     ;
;									     ;
;	Exit:								     ;
;	cli (enables during processing) 				     ;
;									     ;
;	All registers preserved.					     ;
;									     ;
;----------------------------------------------------------------------------;

		public	CalibrateDelay
CalibrateDelay	proc	near

		pusha
		push	es
;
; mask off all but the timer interrupt through the PIC
;
		in	al, MASTER_MASK_PORT
		push	ax			; save original mask on stack
		jmp	$+2
		mov	al, NOT 1		; mask off all but timer
		out	MASTER_MASK_PORT, al
;
; enable interrupts... we need to take timer ticks in here
;
		sti
;
; set DI to the current count
;
; to limit our error watch the timer tick and wait until we see it change.
;
; under DOS we use the tick count in the BIOS data area.  under OS/2 we have
; access to a msec counter in the GlobalInfoSeg.
;
		mov	ax, 0
		mov	es, ax

		mov	di, es:[46ch]		;bios_ticks.loword
B1:		cmp	di, es:[46ch]		;bios_ticks.loword
		je	B1
		mov	di, es:[46ch]		;bios_ticks.loword
;
; set CX to zero.  this will be our outer loop count, the number of times we
; have run thru the calibration loop.
;
		xor	cx, cx
;
; now do 10000 iterations of our calibration loop.  we want a large enough count
; that the overhead of fetching the system time cause a significant error in
; our calculations.  on a 486DX2/66 this loop takes about 1ms so its unlikely
; to take too long on even the slowest computer we run on.
;
		public	cal_loop
cal_loop:
		inc	cx			; increment our outer loop count

		mov	ax, 10000		; DX:AX is our loop count
		xor	dx, dx

		align	16
B2:		sub	ax, 1
		sbb	dx, 0
		mov	bx, ax
		or	bx, dx
		jnz	B2
;
; if we wait for at least 5 ticks to go by our measurement error will be below
; 20% which is probably good enough
;
; check the system time to see if at least 5 ticks or 1/4 second have gone by.
; if not, run through the calibration loop again.
;
		mov	ax, es:[46ch]		;bios_ticks.loword
		sub	ax, di
		cmp	ax, 5
		jb	cal_loop
;
; compute iterations per 50ms.
;
; under DOS, 5 ticks at 18.20651 MHz = approx 275,000us. or 275ms.  so ticks
; per 50ms is:
;
;   cx * 10,000     cx * 10,000     cx * 20,000
;   -----------  =  -----------  =  -----------
;     275/50		5.5		11
;
; the result will likely exceed a single word in size, so we do long division.
; say the numerator is H:L, both letters being digits base 64k
;
;	Dh :  Dl
;    ------------
; 11 )	H  :  L
;	Rh :  L
;
		mov	ax, 20000
		mul	cx			; DX:AX = H:L

		mov	cx, 11

		mov	bx, ax			; save L

		mov	ax, dx
		xor	dx, dx			; 0:H

		div	cx			; 0:H / 11
		mov	Calibration.hiword, ax

		mov	ax, bx			; Rh:L

		div	cx			; Rh:L / 11
		mov	Calibration.loword, ax
;
; disable interrupts again
;
		cli
;
; enable interrupts through the PIC again
;
		pop	ax			; original PIC mask
		out	MASTER_MASK_PORT, al	; restore it

		pop	es
		popa
		ret

CalibrateDelay	endp


;------ ComputeDelay --------------------------------------------------------;
;									     ;
;	This routine computes a value to delay a specified number of	     ;
;	microseconds on this machine.  This count can then be passed to      ;
;	the DelayN routine to delay for that amount of time.		     ;
;									     ;
;	CalibateDelay has already been used to compute the number of	     ;
;	iterations of our delay loop in 50ms, so the calculations here are   ;
;	straight-forward.  See CalibrateDelay for details.		     ;
;									     ;
;	Entry:								     ;
;	CX	= number of microseconds to compute for 		     ;
;									     ;
;	Exit:								     ;
;	DX:AX	= loop count						     ;
;									     ;
;	Destroys BX, CX, SI, DI.  All other registers are preserved.	     ;
;									     ;
;----------------------------------------------------------------------------;

		public	ComputeDelay
ComputeDelay	proc	near
;
; Calibration contains the number of loop iterations for 50ms.	So the number
; of iterations for cx usec is:
;
;   Calibration * cx
;   ----------------
;	 50,000
;
; again the result may be three words in size after the multiply, so we do
; the multiplication and division long form as above.
;
		mov	ax, Calibration.loword
		mul	cx
		mov	si, ax			; SI=L
		mov	di, dx			; DI=M

		mov	ax, Calibration.hiword
		mul	cx
		add	ax, di			; AX=M
		adc	dx, 0			; DX=H, finished multiply

		mov	di, ax			; DI=M

		mov	ax, dx
		xor	dx, dx			; 0:H

		mov	bx, 50000		; 50ms=50000us
		div	bx			; assume Dh=0, ignore it

		mov	ax, di			; Rh:M

		div	bx			; Rh:M / usec
		mov	di, ax			; DI=Dm

		mov	ax, si			; Rm:L

		div	bx			; Rm:L / usec
		mov	dx, di			; DX:AX = Dm:Dl
;
; make sure its at least one
;
		mov	bx, ax
		or	bx, dx
		jnz	F1
		inc	ax
F1:
		ret
ComputeDelay	endp

public	Delay500ns
Delay500ns	proc	 near

		push	ax
		push	bx
		push	dx
		mov	ax, DelayOneUsec.loword
		mov	dx, DelayOneUsec.hiword
		shr	ax, 1			; divide 1 Usec in half
		shr	dx, 1
		jnc	F2
		or	ax, 8000h		; move low order bit of dx into ax
F2:
		or	ax, dx			;980429
		jnz	F3			;safety check in case of 0
		mov	ax, 1
F3:
		sub	ax, 1
		sbb	dx, 0
		mov	bx, ax
		or	bx, dx
		jnz	F3
		pop	dx
		pop	bx
		pop	ax
		ret

Delay500ns	endp


Delay200ms	proc	near

		push	cx
		mov	cx, Delay25ms
		call	WaitTime
		call	WaitTime
		call	WaitTime
		call	WaitTime
		call	WaitTime
		call	WaitTime
		call	WaitTime
		call	WaitTime
		pop	cx
		ret

Delay200ms	endp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c90xb\nad90x.asm ===
page	,132
;************************************************************************
;* NAD90X.ASM
;*	- Contains modules supporting the NetPC UNDI API for 3c90x
;*
;* Modules included :-
;*	NADInit
;*	NADReset
;*	NADShutDown
;*	NADOpen
;*	NADClose
;*	NADSetFilter
;*	NADGetStatistics
;*	NADRequestINT
;*	NADMCastChange
;*	DriverISR_Proc
;*
;* Latest Update: May 15, 1997
;************************************************************************

.xlist


public	NADInit
public	NADReset
public	NADShutDown
public	NADOpen
public	NADClose
public	NADSetFilter
public	NADGetStatistics
public	NADRequestINT
public	NADMCastChange
public	DriverISR_Proc

public  NADSetMACAddress       ; * NEW
public  NADInitiateDiags       ; * NEW

extrn	IRQNumber:byte
extrn	Net_Address:byte
extrn	Node_Address:byte
extrn	MultiCast_Addresses:word

.list
	.386
;================
NADSetMACAddress	proc	near		; NEW

		push	di
		mov	di, offset DGroup:Node_Address
		mov	eax, dword ptr [si]
		mov	dword ptr ds:[di], eax
		mov	ax, word ptr [si+4]
		mov	word ptr ds:[di+4], ax
		xor	ax, ax
		pop	di
		ret

NADSetMACAddress	endp

;
;================
NADInitiateDiags	proc	near		; New

		stc
		ret

NADInitiateDiags	endp


;=========================================================================
; NADInit
;=========
;	- Initializes the adapter but does not enable the Tx and Rx units
;	- Init variables such as IOBase, ROMBase, IRQNumber, Net_Address
;		NodeAddress for UNDI_NAD
;	- Hook receiving ISR
;
; Parameters:
;
; Return:	If CF = 0 then success,
;		else failure with  AX = 1 -> hardware failure
;			           AX = 2 -> media failure
;
; Remark:	Don't hook INT if this function fails
;=========================================================================
NADInit 	proc	near

;		push	ds
		push	es

;		mov	ax, cs
		mov	ax, ds
		mov	es, ax

		call	Init_Adapter		;init vulcan hardware and
						;  variables, IOBase, IRQLevel
		or	ax, ax
		jnz	NADInitErr

		mov	al, IRQLevel
		mov	DGroup:IRQNumber, al

		cld
;		mov	cx, 6
;		mov	di, offset DGroup:NodeAddress
;		mov	si, offset DGroup:BoardID
;	rep	movsb

		mov	cx, 6
		mov	di, offset DGroup:Net_Address
		mov	si, offset DGroup:BoardID
	rep	movsb

		call	Init_Adapter2

		cmp	LinkDetected, 0
		jz	no_media

		mov	dx, PortCmdStatus
		mov	ax, CMD_STATSENABLE
		out	dx, ax			;enable statistics counters

		call	HookIntVector

		mov	dx, PortCmdStatus
		SelectWindow WNO_OPERATING		 ; switch to window 1

		clc
		jmp	NADInitx

no_media:
		mov	ax, 2
		jmp	initerr
NADInitErr:
		mov	ax, 1
initerr:
		stc
NADInitx:
		pop	es
;		pop	ds
		ret

NADInit 	endp


;=========================================================================
; NADReset
;==========
;	- Reset and Reinitialize the adapter
;	- Enables the Tx and Rx units
;
; Parameters:
;
; Return:	carry set if failure
;=========================================================================
NADReset	proc	near

		call	Init_Adapter2

		mov	dx, PortCmdStatus
		mov	ax, CMD_STATSENABLE
		out	dx, ax			;enable statistics counters
		clc
		ret

NADReset	endp


;=========================================================================
; NADShutDown
;=============
;	- reset the adapter
;	- unhook our ISR
;
; Parameters:
;
; Return:	carry set if failure
;=========================================================================
NADShutDown	proc	near

		mov	dx, PortCmdStatus
		xor	ax,ax			   ; global reset
		out	dx,ax
GResetWait:
		in      ax, dx
		test    ah, STH_BUSY
		jnz	GResetWait		   ; loop while busy
;;;
		call	DriverUnhook

		mov	ax, IOBase
		mov	cx, NumOfPorts
		mov	di, offset DGroup:PortCmdStatus
KillPorts:
		sub	ds:[di], ax
		add	di, 2
		loop	KillPorts

		clc
		ret

NADShutDown	endp


;=========================================================================
; NADOpen
;=========
;	- Enables the Tx and Rx units
;
; Parameters:
;
; Return:	carry set if failure
;=========================================================================
NADOpen 	proc	near

		mov	dx, PortCmdStatus
		call	TxReset
		
		mov	ax, CMD_TXENABLE
		out	dx, ax			;enable Tx

		mov	ax, CMD_RXENABLE
		out	dx, ax			;enable Rx

		clc
		ret

NADOpen 	endp


;=========================================================================
; NADClose
;==========
;	- Disables the Tx and Rx units
;
; Parameters:
;
; Return:	carry set if failure
;=========================================================================
NADClose	proc	near

		mov	dx, PortCmdStatus
		mov	ah, CMDH_TXDISABLE
		out	dx, ax			;disable Tx
		mov	ah, CMDH_RXDISABLE
		out	dx, ax			;disable Rx

		clc
		ret

NADClose	endp


;=========================================================================
; DriverISR_Proc
;================
;	- ISR procedure to be called by UNDI_DriverISR
;
; Parameters:	DS = DataSeg
;
; Return:	CF = a if not our int
;=========================================================================
DriverISR_Proc	proc	near

		mov	dx, PortCmdStatus
		SelectWindow WNO_OPERATING
;
; check whether our board caused the interrupt
;
		in	ax, dx			; AL=Interrupt Reasons
		test	al, INT_LATCH
		jnz	isr_ours
not_ours:
;;db 0f1h    
		stc
		ret

isr_ours:
		pushf
		push	cs
		call	DriverISR	;a near call with IRET
		clc
		ret

DriverISR_Proc	endp


;=========================================================================
; NADSetFilter
;==============
;	- Change the rx unit's filter to a new one
;	- Handle the promiscuous/broadcast/multicast mode for the
;		rx unit accordingly if necessary
;
; Parameters:	AX = filter value, 1 = directed/multicast
;				   2 = broadcast
;				   4 = promiscuous
; Return:	carry set if failure
;=========================================================================
NADSetFilter	proc	near

		push	ax
		mov	dx, PortCmdStatus
		mov	ah, CMDH_RXDISABLE	;disable Rx
		out	dx, ax
		pop	ax

		shl	al, 1
		test	al, 00000010b
		jz	go_set_filter
		or	al, 00000001b	;set bit 0 if bit 1 is set
go_set_filter:
		mov	ah, CMD_SETRXFILTER/256
		mov	HWFilter, ax
		out	dx, ax
;
; if the filter setting was non-zero, enable the receiver.  otherwise, disable
; the receiver.
;
		test	al, al			; zero filter?
		jz	SetFilterEnd
;
; handle multicast addresses here if necessary
;
		mov	ah, CMDH_RXENABLE	;enable Rx
		out	dx, ax			;set Rx unit
SetFilterEnd:
		clc
		ret

NADSetFilter	endp


;=========================================================================
; NADGetStatistics
;==================
;	- Read the adapter's statistics
;
; Parameters:	ds:si points to variables holding the result
;			TxGoodFrames	dd	0	;1
;			RxGoodFrames	dd	0	;2
;			RxCRCErrors	dd	0	;3
;			RxDiscarded	dd	0	;3
;		ax = 0 means get the result
;		   = 1 means clear the statistics
;
; Return:	Carry clear if data obtained successfully
;=========================================================================
NADGetStatistics	proc	 near

		push	dx
		push	ax

		mov	dx, PortCmdStatus
		SelectWindow WNO_STATISTICS

		pop	ax
		or	ax, ax
		jz	get_data
		
		xor	ax, ax
		add	dx, 6			;PORT_TXFRAMES
		out	dx, al

		mov	dx, PortCmdStatus
		add	dx, 7			;PORT_RXFRAMES
		out	dx, al

		mov	dx, PortCmdStatus
		add	dx, 5			;PORT_RXDISCARDED
		out	dx, al
		
		jmp	short GetStatRet

get_data:
		xor	eax, eax
		add	dx, 6			;PORT_TXFRAMES
		in	al, dx
		mov	dword ptr [si], eax
		add	si, 4

		mov	dx, PortCmdStatus
		add	dx, 7			;PORT_RXFRAMES
		in	al, dx
		mov	dword ptr [si], eax
		add	si, 4

		mov	dword ptr [si], 0
		add	si, 4

		mov	dx, PortCmdStatus
		add	dx, 5			;PORT_RXDISCARDED
		in	al, dx
		mov	dword ptr [si], eax

GetStatRet:
		mov	dx, PortCmdStatus
		SelectWindow WNO_OPERATING
		pop	dx

		clc
		ret

NADGetStatistics	endp


;=========================================================================
; NADRequestINT
;================
;	- Generate an interrupt to the host
;
; Parameters:
;
; Return:
;=========================================================================
NADRequestINT	proc	near

		mov	dx, PortCmdStatus
		mov	ax, CMD_REQUESTINT
		out	dx, ax
		ret

NADRequestINT	endp


;==========================================================================
; NADMCastChange
;================
;	- Modify the multicast buffer to receive the multicast addresses
;	  listed in the multicast table.
;         Each entry in the multicast table is as follows:
;                 Bytes 0-5 = Multicast Address
;         All addresses are contiguous entries
;
; Parameters:	CX =  Number of multicast entries.
;               ES:SI -> Multicast Table.
;
; Return:	All registers may be destroyed.
;==========================================================================
NADMCastChange	proc	near

		push	ds

;		mov	dx, PortCmdStatus
;		mov	ax, CMD_RXDISABLE
;		out	dx, ax			;disable Rx

		push	ds
		push	es
		pop	ds		;ds:si -> mc table
		pop	es		;es = ds

		cmp	cx, MAXNUM_MCADDR
		jbe	MCsave
		mov	cx, MAXNUM_MCADDR
MCsave:
		lea	di, DGroup:MultiCast_Addresses
		mov	(Eth_MCastBuf ptr es:[di]).MCastAddrCount, cx
		jcxz	MC_SaveDone
;
; copy addresses from ds:si to es:di
;
		lea	di, (Eth_MCastBuf ptr es:[di]).MCastAddr
MC_SaveLoop:
		mov	eax, dword ptr [si]
		mov	dword ptr es:[di], eax
		mov	ax, word ptr [si+4]
		mov	word ptr es:[di+4], ax

		add	si, ADDR_LEN		; each unit is 16 bytes long
		add	di, ETH_ADDR_LEN
		loop	MC_SaveLoop
MC_SaveDone:
		pop	ds

;		mov	dx, PortCmdStatus
;		mov	ax, CMD_RXENABLE
;		out	dx, ax			;enable Rx

		lea	si, DGroup:MultiCast_Addresses
		mov	cx, (Eth_MCastBuf ptr [si]).MCastAddrCount
		lea	si, (Eth_MCastBuf ptr [si]).MCastAddr

		clc
		ret

NADMCastChange	endp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c90xb\nad90xb.inc ===
;	NAD modules for 3C90XB PCI
;
; Modules included:
;  - NADChangeReceiveMask
;  - NADConfig
;  - NADDisengage
;  - NADGetBootInfo
;  - NADInitialize
;  - NADPCIConfig
;  - NADPoll
;  - NADRelocate
;  - NADReset
;  - NADStart
;  - NADTransmitPacket
;
;  - Interrupt Service Routines
;  - SoftRxReset
;  - TxReset
;  - RxReset
;  - RxDiscard
;
; 960618 GY    - Add support for Broadcast
; 960401 GY - Replace some MACROS with code
;        - standardize port access
;******************************************************************************

IFDEF	UNDI
extrn	GETED:near
extrn	MultiCast_Addresses:word
extrn	EDListHead:word
extrn	EDListCurrent:word
extrn	ApiEntry:word
ENDIF

NADRelocate proc far
	ret
NADRelocate endp

IFDEF	UNDI
NADGetBootInfo	proc	near
NADInitialize	proc	near
NADConfig	proc	near
NADStart	proc	near
		ret
NADStart	endp
NADConfig	endp
NADInitialize	endp
NADGetBootInfo	endp

ELSE
;--------------------------------------------------------------------
; NADGetBootInfo
;
; This function is called at the start of INT19 read the current
; configuration from the ROM.  The configuration is returned in ax.
;
; Values:
;	  1  local boot is default
;	  2  ROMShield enabled
;	  4  config menu enabled
;	 64  floppy drive disabled
;	128  hard drive disabled
;
; Parameters:
;	DS = RAM segment
;
; Returns:
;	ax - boot info
;--------------------------------------------------------------------

		xor	ax, ax
		test	BWTFeature, 1
		jz	no_local
		or	ax,1
no_local:
		test	BWTFeature, 2
		jz	no_rs  
		or	ax,2
no_rs:
		test	BWTFeature, 4
		jnz	no_menu
		or	ax,4
no_menu:
		test	BWTLanOS, 1
		jz	floppy
		or	ax,64
floppy:
		test	BWTLanOS, 2
		jz	hard
		or	ax,128
hard:
		ret

NADGetBootInfo	endp


;--------------------------------------------------------------------
; NADInitialize
;
; Initializes the network adapter and connects the adapter to the
; physical media.
;
; Parameters:
;	AX = PCIBusDevFunc #
;	DX = screen location to dislay initializing string
;	DS = RAM segment
;	ES = ROM Base
;
; Returns:
;	AX = 0 if no error else pointer to fatal error
;--------------------------------------------------------------------
NADInitialize	proc	near

		push	ds
		push	es

		mov	DGroup:PCIBusDevFunc, ax
		mov	ax,es
		mov	ROMBase, ax

		push	cs
		pop	ds
		mov	bx, offset CGroup:StrPrompt
		call	PrintAt

		push	cs
		pop	es

		; Update some init variables (BusType, IOBase, IRQ ...)
		mov	BusType, BUS_PCI

		call	Init_Vulcan		; init vulcan hardware and
						;  variables
		cld
		mov	cx, 6
		mov	di, offset NetAddress
		mov	si, offset BoardID
		rep	movsb

		call	Init_Vulcan2

		mov	LookAheadBufferPtr.segm, cs

		call	HookIntVector

		mov	dx, PortCmdStatus
		SelectWindow WNO_OPERATING		 ; switch to window 1

		xor	ax,ax
NADInitExit:
		pop	es
		pop	ds
		ret

NADInitialize	endp


;--------------------------------------------------------------------
; NADConfig
;
; Displays an optional configuration screen for the user to change
; ROM settings.
;
; Parameters:
;	dx = screen location for initialize string
;	ds = RAM segment
;
; Returns:
;	ax - pointer to configuration message
;--------------------------------------------------------------------
NADConfig	proc	near

		push	ds

		push	cs
		pop	ds
		mov	bx, offset CGroup:BlankStr
		call	PrintAt

		mov	ax, IOBase
		mov	NIC_IO, ax		; copy I/O base to NAD table

		mov	al, IRQLevel
		mov	NIC_IRQ, al		; copy IRQ to NAD table

;		cld
;		mov	cx, 6
;		mov	di, offset CGroup:NetAddress
;		mov	si, offset CGroup:BoardID
;		rep	movsb

;		call   ClearScreen
		xor	ax,ax

		pop	ds
		ret

NADConfig	endp


;--------------------------------------------------------------------
; NADStart
;
; Determine the protocol the ROM is configured, then jump to it.
;
; Parameters:
;	none
;--------------------------------------------------------------------
NADStart	proc near

		call	BuildNADAPI

		mov	al, BWTLANOS
		and	al, BWTLANMASK
		cmp	al, BWTLANRPL
		jnz	NotRPL
		jmp	CGroup:RPLStart

NotRPL:
	 	cmp	al, BWTLANIP
		jnz	NotIP
		jmp	CGroup:IPStart
NotIP:
		jmp	CGroup:NetWareStart

NADStart	endp


;--------------------------------------------------------------------
; NADPCIConfig
;
; Displays configuration screen for the user to change ROM settings.
;
; Parameters:
;	ds = RAM segment
;--------------------------------------------------------------------
NADPCIConfig	proc	near

		push	ds

		mov	al, NormalAttr
		mov	ah, ReverseAttr
		mov	CUIAttr, ax
		mov	NormalAttr, ASNormalAttr
		mov	ReverseAttr, ASReverseAttr

		call	ASConfig		; autoscan config
		mov	NormalAttr, ASNormalAttr
		mov	ReverseAttr, ASReverseAttr
		jnc	ConfigNoUpdate

	; Problem with Phoenix BIOS where SS is required to be
	; the same as CS
	; Assume that NOTHING is on the STACK!!!
;		cli
;		mov	ax, cs
;		mov	ss, ax
;		sti

		call	UpdatePCI_PEROM

	; Problem updating ROM. Just dump error message and let
	; them proceed
		xor	al, al		; Get user to press <ENTER> for acknowledge
		call	PrintErrMsg
		call	ClearScreen
ConfigNoUpdate:
		pop	ds
		ret

NADPCIConfig	endp
ENDIF

;----------------------------------------------------------------------
;  Routine Name:  NADTransmitPacket Routine
;
;  Description: The NADTransmitPacket Routine accepts all directed
;     send requests from the RIPL ROM NID code.  This
;     routine determines the validity of the request and
;     works with the adapter to carry it out.
;
;  Input:   ES:SI - pointer to ED
;     DS - Data Segment of RPL Module
;     ints disabled (spec says enabled)
;
;  Output:  ED Completion Code field updated
;     DS preserved
;     ints enabled (doesn't matter)
;
;  Calls:   TransmitPacket
;----------------------------------------------------------------------
public   NADTransmitPacket ; for DEBUGGING
NADTransmitPacket  PROC near		;FAR

		push	ds			; save caller ds

;PM		push	cs
;		pop	ds			; set ds = cs

		cld				; Clear direction
		cli				; ints off

 		push	si			; save ED offset
	 	mov	di, offset DGroup:TxBuf
		mov	cx, [es:si].ED_FragCount; get fragment count
		lea	bx, [si].ED_FragOff	; point to first fragment descriptor
Tx_Frag_Loop:
		push	cx			; save fragment count
		mov	cx, [es:bx].FragLen	; length of this fragment
		lds	si, [es:bx].DPointer	; location of this fragment
		push	es
		mov	ax, cs:ApiEntry.mlid_ds_sel
		mov	es, ax
	rep	movsb
		pop	es
Tx_Frag_End:
		pop	cx		; restore fragment count
		add	bx, size Frag	; next descriptor
		loop	Tx_Frag_Loop	; loop through all fragments

Start_Tx:
;PM		push	cs
;		pop	ds		; restore cs = ds
		mov	ax, cs:ApiEntry.mlid_ds_sel
		mov	ds, ax

		pop	si		; restore ED offset

		xor	eax, eax
		mov	ax, es:[si].ED_Length		; get total packet length
		mov	bx, offset DPD
		mov	[bx].DPD_FSHindicate, 0000h	; turn off dnIndicate
		mov	[bx].DPD_FrameStart, 8000h 	; txIndicate, dword roundup
		mov	[bx].DPD_Frag.Frag_len, eax	 ; # of bytes of data
		or	[bx].DPD_Frag.Frag_len, FRAGLAST ; set fraglast bit

		mov	dx, PortDnListPtr
		mov	eax, DPD_physaddr
		out	dx, eax 		; enable download
;
; wait for completion, and check for errors
;
		sti			; ints on again
;		mov	ah, 0		; get current system tick count
;		int	1Ah		; timer services
;		mov	StartTick, dx	; save timer value

		mov	cx, 250
WaitFornTx:
		push	cx
		mov	cx, 1000	; delay
WaitForEndTx:
		mov	dx, PortTxStatus
;		in	al, dx
		in	al, dx	
		test	al, TXS_COMPLETE  ; done yet?
		jnz	TxFinish	  ; jump if Tx complete

;		mov	ah, 0		; get current system tick count
;		int	1Ah		; timer services
;		sub	dx, StartTick	; subtract start time
;		cmp	dx, 5		; 5 ticks time-out
;		jb	WaitForEndTx	; loop until time-out

		call	Delay500ns
		call	Delay500ns
		loop	WaitforEndTx
		pop	cx
		loop	WaitfornTx

BadConnection:
		mov	dx, PortCmdStatus
		call	TxReset		; make sure FIFO is flushed

		mov	ah, CMDH_TXENABLE
		out     dx, ax		; enable the transmitter

		mov	es:[si].ED_ErrMsg, offset CGroup:NoNetMsg
		mov	es:[si].ED_ErrCode, TRANSMIT_ERROR

		jmp	short NetSendRet

; copy done, return

TxFinish:
		pop	cx
		out	dx, al		; pop Tx status
		test	al, TXS_ERRTYPE	; any error bits set?
		jnz	NetSendError

		mov	es:[si].ED_ErrCode, SUCCESSFUL
NetSendRet:
		pop	ds		; restore callers ds
		ret

NetSendError:
;		push	ax
		mov	es:[si].ED_ErrMsg, offset CGroup:TxMsg
		mov	es:[si].ED_ErrCode, TRANSMIT_ERROR
;		pop	ax

		test	al, TXS_UNDERRUN or TXS_JABBERERROR
		jz	NotTxUnderOrJabber

		mov	dx, PortCmdStatus
		call	TxReset			; reset transmitter

		mov     ah, CMDH_TXENABLE
		out     dx, ax			; enable the transmitter

		jmp	short NetSendRet

NotTxUnderOrJabber:
		mov	dx, PortCmdStatus
		mov     ah, CMDH_TXENABLE
		out     dx, ax			; enable the transmitter
		jmp	short NetSendRet

NADTransmitPacket	ENDP


;--------------------------------------------------------------------
; TxReset - reset the transmitter
;
; entry:
;   dx = cmd/status port
;
; destroys:
;   ax
;--------------------------------------------------------------------
TxReset		proc	near

		mov	ax, CMD_TXRESET		;+ TXRXRESET_ALLBUTBM
		out	dx, ax
?txrloop:
		in	ax, dx
		test	ah, STH_BUSY
		jnz	?txrloop                ;; loop while busy
		ret

TxReset		endp


;--------------------------------------------------------------------
; RxReset - reset the receiver
;
; entry:
;   dx = cmd/status port
;
; destroys:
;   ax
;--------------------------------------------------------------------
RxReset		proc	near

		mov	ax, CMD_RXRESET
		out	dx, ax
?rxrloop:
		in	ax, dx
		test	ah, STH_BUSY
		jnz	?rxrloop                    ;; loop while busy
		ret

RxReset		endp


;--------------------------------------------------------------------
; RxDiscard - discard top packet in RxFIFO
;
; entry:
;   ds = DGROUP
;   dx = cmd/status port
;   cli
;
; exit:
;   cli
;
; destroys:
;   ax
;--------------------------------------------------------------------
;RxDiscard	proc  near

;		mov	dx, PortUpListPtr
;		mov	eax, UPD_physaddr
;		out	dx, eax 			; write UpListPtr
;		ret

;RxDiscard	endp


;------ SoftRxReset -------------------------------------------------
;
;  This routine does an RxReset to clear out the RxFIFO and its
;  associated logic.  After the RxReset, it reenables and restores
;  the current RxFilter and RxEarly thresholds.
;
;  Entry:
;  DS = DGROUP
;  DX = port CmdStatus
;  cli
;
;  Exit:
;  cli
;  Destroys AX.  All other registers preserved.
;
;--------------------------------------------------------------------
		 public SoftRxReset
SoftRxReset   proc   near

		call	RxReset

		mov	dx, PortCmdStatus
		mov	ax, HWFilter      ; has CMD_SETFILTER in it
		out	dx, ax

		; enable the receiver
		mov     ah, CMDH_RXENABLE
		out     dx, ax

		mov   ax, NormalRxEarly ; has CMD_SETRXEARLY in it
		out   dx, ax

		ret
SoftRxReset endp


IFNDEF	UNDI
;----------------------------------------------------------------------
;  Routine Name:  NADPoll Routine
;
;  Description: The NADPoll routine is used by the RIPL ROM NID
;     portion of the RIPL ROM to poll the driver portion so
;     that the driver portion can do timeout work.
;
;  Input:   DS - Data Segment of RPL Module
;     ints enabled
;
;  Output:  DS preserved
;     ints enabled
;
;  Calls:   none
;----------------------------------------------------------------------
NADPoll  proc  far
	retf				; nothing to do...
NADPoll  endp

;----------------------------------------------------------------------
;  Routine Name:  NADDisengage Routine

;  Description: The NADDisengage routine is used by the RIPL ROM NID
;     portion of the RIPL ROM to signal the Network Driver
;     to release its IRQ, DMA, and memory resources.
;
;  Input:   DS - Data Segment of RPL Module
;     ints enabled
;
;  Output:  DS preserved
;     ints enabled
;     ax = offset to error string or 0 if successful
;
;  Calls:   none
;
; July 10,91   implement NIDDisengage version 0.8
;----------------------------------------------------------------------
NADDisengage   PROC  FAR
	push  ds
	push  es

	cli

	; is it RPL ?
	test  cs:BWTLANOS, BWTLANRPL
	jz DisengageRPL

	; change IntFD to point to NADIntFD in ROMTOP.ASM. Depending on
	; the ROMSize, RPLBOOT.SYS might call the IntFD that is not
	; even mapped on the system and hang the machine
	xor   ax, ax
	mov   es, ax
	mov   di, 0FDh*4
	mov   ax, offset CGroup:NADIntFD
	stosw
	mov   ax, cs:ROMBase    ; 940118
	stosw

	; make sure that it works on every page. Int13 should point to NADIntFD
	; also.
	mov   di, 013h*4
	mov   ax, offset CGroup:NADIntFD
	stosw
	mov   ax, cs:ROMBase
	stosw

	push  cs
	pop   es

DisengageRPL:

		; 3Com 5X9 NDIS driver place ISR at IRQ 2 rather than IRQ 9 ( compatability
		; with IBM 3270 program ). Thus, this routine needs to restore the old
		; BIOS IRQ9 handler to invoke IRQ2. Also, this routine should NOT
		; mask IRQ9.

		mov    dx, Int_mask_port
		in     al, dx
	
		or     al, cs:IRQBit
		jmp    $+2

		out    dx, al

		; restore handler
		call  DriverUnhook

		; unmask IRQ 9 again so that interrupt will pass to IRQ2 ISR
		cmp   cs:IRQLevel, 9
		jnz   DisengageExit

		mov   dx, 0a1h
		in al, dx
		and   al, 0fdh
		out   dx, al

DisengageExit:
		pop   es
		pop   ds

		sti
		xor   ax, ax
		retf        ; Return to caller

NADDisengage   endp
ENDIF


;------------------------------------------------------------------------------
; packet completed, but RxStatus.Err indicates the packet experienced an error
; during receiving.

ip_bad:
;		call	RxDiscard
; A packet may be marked as a runt but it may be a good packet
; This happens after a real bonafide runt.   The packet after it
; could also be marked as a runt but is really a good packet.

		mov	al, UPD.UPD_UpPktError
		cmp	al, RXE_RUNT		; the only error is a runt
		jnz	ipbad
		cmp	cx, 60			; yes, check the length to verify it is ok
		jl	ipbad
		jmp	isr_accept
ipbad:
		jmp	int_next

;------------------------------------------------------------------------------
; various errors: No ECB, pkt too small, pkt too big, pkt with bad size
ip_discard_pkt:
;		call	RxDiscard 
		jmp	int_next    ; dx = port CmdStatus

;--------------------------------------------------------------------
;
;  Upload Complete interrupt.
;
;--------------------------------------------------------------------
; entry:
;   interrupt is disabled at adapter level. (through SetIntMask cmd).
;   EOIs have been issued to PICs.
;   we've not done sti
;
;   dx = port CmdStatus
;   cli
;   cld
;
;--------------------------------------------------------------------
isr_UpPkt:
; acknowledge upComplete int
;		mov	dx, PortCmdStatus
		mov	ax, CMD_ACKNOWLEDGE + INT_UPCOMPLETE	
		out     dx, ax

		mov	ax, UPD.UPD_UpPktStatus
		mov	cx, ax
		and	cx, RXS_LENGTH		;packet length

		test	ah, RXSH_ERROR		; error reported?
		jnz	ip_bad
isr_accept:
;
; get Packet Length from UpPktStatus register
;
		mov	ax, cx
IFDEF UNDI
		call	GetED
ELSE
		call	[AIGetEDJmp]		; get an ED (ES:SI)
ENDIF
		jz	ip_discard_pkt		; we didn't get an ED

		mov	bx, si			; move ED offset to bx
		mov	es:[si].ED_Length, ax	; save length in ED
		mov	cx, es:[si].ED_FragCount; get number of fragments
		lea	bx, [si].ED_FragOff	; point to 1st descriptor

		mov	dx, ax			; move packet size to dx
DRxNxtF:
		push	cx
		push	es
		mov	cx, es:[bx].Dlen	; get fragment length
;PM		les	di, es:[bx].Dpointer	; get fragment pointer
		mov	ax, ds
		mov	es, ax
		mov	di, word ptr es:[bx].Dpointer	; get fragment pointer
ChkMovSize:
		cmp	dx, cx
		ja	MoveFrag		; more data after this frag

		mov	cx, dx			; no more data after this frag
MoveFrag:
		sub	dx, cx			; subtract size of this frag
		jcxz	DrxDoNxt 		; zero count -- skip data read

		push	si
		mov	si, offset DGroup:RxBuf
	rep	movsb
		pop	si

DrxDoNxt:
		pop	es
		pop	cx
		add	bx, 6			; point to next fragment desc
		loop	DRxNxtF			; do next frag, if any

; -- DX has # of bytes that couldn't fit in receive descriptors

NoRxFrag:
;PM		push	cs
;		pop	ds			; restore DS = CS
;		mov	ax, cs:ApiEntry.mlid_ds_sel
;		mov	ds, ax

		mov	es:[si].ED_ErrCode, 0	; Set good completion

IFDEF	UNDI
		lea	bx, [si].ED_FragOff	; point to 1st descriptor
;		les	di, es:[bx].Dpointer	; get fragment pointer
		mov	ax, ds
		mov	es, ax
		mov	di, word ptr es:[bx].Dpointer	; get fragment pointer

		cmp	byte ptr es:[di], 01h
		jnz	NoMCastCheck		; not a MC address
		mov	si, offset DGroup:MultiCast_Addresses
		mov	cx, (Eth_MCastBuf ptr [si]).MCastAddrCount
		jcxz	NoMCastCheck		; no MC address

		lea	si, (Eth_MCastBuf ptr [si]).MCastAddr
CheckMC:
		push	cx
		mov	cx, 6		;length of address in byte
	repz	cmpsb
		jcxz	MCastFound	;this is our MC address

		add	si, 6
		pop	cx
		loop	CheckMC
;
; not our MC address, kill the recently saved ED
;
		mov	si, DGroup:[EDListCurrent]	; get current ED
		mov	word ptr [si].ED_Length, 0	;kill the data
		mov	DGroup:[EDListHead], si	; move the head backward
		jmp	DiscardRxData

MCastFound:
		pop	cx
NOMCastCheck:
ELSE
		call	[AIPostEDJmp]		; post the received packet
ENDIF

; we've copied all packet data out of RxFIFO, now discard postamble and any
; pad bytes inserted by hardware.

DiscardRxData:
;		call  RxDiscard         ; discard padding & postamble

; copy is done, now tell foreground that a packet is available

		jmp   int_next

;------------------------------------------------------------------
;
; DriverISR:  Interrupt Service Routine for Vulcan
;
;------------------------------------------------------------------

	 public DriverISR

		 ALIGN  4
		 db     'ISR'

DriverISR	proc   near

		pusha
		push	ds
		push	es
;PM		mov	ax, cs
		mov	ax, cs:ApiEntry.mlid_ds_sel
		mov	ds, ax

		cld

; mask off all interrupts at adapter level. and release the system interrupt
		mov	dx, PortCmdStatus
		mov	ax, CMD_SETINTMASK + MASK_ALL
		out	dx, ax			; disable all interrupts

; acknowledge interrupt
		mov	ax, CMD_ACKNOWLEDGE + INT_LATCH
		out     dx, ax

		mov	ax, eoi_value		; ah = EOI for master PIC
						; if int < 8, eoi_value = 6040h
						;   else eoi_value = 6220h
		cmp	al, 40h			; Int level < 8 ? (i.e. NOP)
		jz	EOIMaster		; No, need EOI to Slave PIC

		out	SlaveEOIPort, al	; al = EOI for slave PIC

		jmp	$+2
		jmp	$+2
		jmp	$+2
		jmp	$+2
		jmp	$+2
		jmp	$+2
EOIMaster:
		mov	al, ah			; send EOI to Master 8259 PIC
		out	MasterEOIPort, al

;----------------------------------------------------------------------------
; read the reason for the interrupt and dispatch control to the appropriate
; routine through jump table.  When that reason has been handled the routine
; will jump  to int_next.  if there is no reason for the interrupt
; we will simply end up at isr_return. the following types of interrupt
; are handled:
;
;      a. Adapter Failure
;      b. Upload Complete
;      c. Interrupt Request (not supported, ack and return)

isr_1st_pass:
;		mov	dx, PortCmdStatus
		in	ax, dx
		jmp	IntDispatch

; there is another interrupt reason.  since we might be close to our disable
; time limit, enable before we handle it.

isr_again:				; AL has CmdStatus contents
		 sti
		 nop
		 cli
		 jmp    IntDispatch

; once the code entered through IntDispatch has completed its task, it jumps
; to this label. check for any remaining reasons.

int_next:
		mov	dx, PortUpListPtr
		mov	eax, UPD_physaddr
		out	dx, eax 		;re-enable upload engine

		xor	ax, ax
		mov	UPD.UPD_UpPktStatus, ax

		mov	dx, PortCmdStatus
		mov	ax, CMD_STALLCTL OR UP_UNSTALL
		out	dx, ax
xrloop:
		in	ax, dx
		test	ah, STH_BUSY
		jnz	xrloop                ;; loop while busy

;PM		mov	ax, cs
;		mov	ds, ax			; DS = CS
;		mov	dx, PortCmdStatus
;		in	ax, dx			; read status reg see if any
;		and	ax, 0412h
;		test	ax, ax			; more interrupts to be
;		jnz	isr_again		; serviced?

;-----------------------------------------------------------------------------
; nothing left showing in status.
isr_return:

;----------------------------------------------------------------------------
; reenable interrupts from the adapter.
;
; note: if indications are disabled, they are masked off through the
; ReadZeroMask so reenabling interrupts will have no effect on those bits.

isr_enable:
		cli

		mov	dx, PortCmdStatus
		mov	ax, CMD_SETINTMASK + BOOTWARE_INTS
		out	dx, ax			;re-enable INT

		pop	es
		pop	ds
		popa

		iret

DriverISR	endp


IntDispatch:
		test	ax, INT_ADAPTERFAIL
		jz	IntNotFail
		jmp	isr_AdapterFailure

IntNotFail:
		test	ax, INT_RXCOMPLETE
		jz	IntNotRxComplete
		mov	cx, 10
wait_upcomplete:
		mov	ax, UPD.UPD_UpPktStatus
		test	ax, UPPKTCOMPLETE
		jnz	isr_UpPkt
		call	Delay500ns
		loop	wait_upcomplete
		jmp	int_next

IntNotRxComplete:
		test	ax, INT_UPCOMPLETE
		jz	IntNotUpComplete
		jmp	isr_UpPkt

IntNotUpComplete:
;		test	ax, INT_TXCOMPLETE   ; shouldn't happen, only if cable not connected
;		jz	IntNotTxComplete

;		mov	dx, PortTxStatus
;		in	al, dx
;		cmp	al, 0C0h
;		jne	xx
;		mov	cGroup:flag, 1
;xx:
;		out	dx, al         ; pop tx status to turn the bit off
;		mov	dx, PortCmdStatus
;		mov	ax, CMD_ACKNOWLEDGE + 4
;		out	dx, ax
;		jmp	int_next

IntNotTxComplete:
		test	al, INT_REQUESTED
		jz	isr_return

;	mov	al, 85h
;	call	puthex

isr_IntRequest:
; acknowledge interrupt
		mov	ax, CMD_ACKNOWLEDGE + INT_REQUESTED
		out     dx, ax
		jmp	isr_return     ; Solve mysterious problem with V2

isr_AdapterFailure:
		mov	dx, PortCmdStatus
		SelectWindow WNO_DIAGNOSTICS        ; switch to window 4

		mov	dx, PortFIFODiag
		in	ax, dx

		mov	dx, PortCmdStatus
		test	ax, FIFOD_RXUNDERRUN
		jz	chk_tx_overrun

; RxUnderrun.  ASIC (rev 1) adapter failure int. due to a false RxUnderrun.
; we just call SoftRxReset to reset the receiver and return to int_next as
; a software workaround to a hardware problem.

		 public AdapterFailure_Rxunderrun

AdapterFailure_Rxunderrun:
		SelectWindow WNO_OPERATING

		mov   dx, PortCmdStatus
		call   SoftRxReset

		jmp    int_next

chk_tx_overrun:
		test   ax, FIFOD_TXOVERRUN
		jz     ia_shutdown

; TxOverrun.  Probably a software error, but since its probably on the back end
; of the TxFIFO and the error shuts down the transmitter, we won't have sent
; any bad packets yet (with rev 1 silicon).  Reset the transmitter and start
; things up again.

		public AdapterFailure_TxOverrun

AdapterFailure_TxOverrun:
		call  TxReset

		mov    ax, CurTxStart
		out    dx, ax

		; enable the transmitter
		mov     ah, CMDH_TXENABLE
		out     dx, ax


;		SelectWindow WNO_OPERATING

; shut off the transmitter and receiver
		public ia_shutdown

ia_shutdown:
IFNDEF	UNDI
		SelectWindow WNO_OPERATING

		; Tx Disable
		mov     ah, CMDH_TXDISABLE
		out     dx, ax

				; Disable the receiver
		mov     ah, CMDH_RXDISABLE
		out     dx, ax

; disable additional interrupts from the adapter

		mov    ax, CMD_SETRZMASK + MASK_ALL
		out    dx, ax
ENDIF
		jmp    int_next


IFDEF	DEBUG
Puthex	proc	near

		push	es
		push	ax		; save for lower nibble
		shr	al, 1
		shr	al, 1
		shr	al, 1
		shr	al, 1
		add	al, 90h
		daa
		adc	al, 40h
		daa
;		call	h_digit
		push	ax
		mov	ax, 0b800h
		mov	es, ax
		xor	di, di
		pop	ax
		stosb
		pop	ax		; now do lower nibble

h_digit:
		push	ax
		and	al, 00001111b
		add	al, 90h
		daa
		adc	al, 40h
		daa
;		call	putchr
		mov	di, 2
		stosb
		pop	ax
		pop	es
		ret
		
Puthex		endp

Putchr		proc	near

		push	bx
		mov	ah,0eh
		mov	bx, 0007h		; page 0, normal
		int	10h
		pop	bx
		ret

Putchr		endp
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c90xb\boom.inc ===
;------ BOOM.INC ------------------------------------------------------------;
;									     ;
;	This file contains Boomerang specific equates, structures and	     ;
;	macros. It must be assembled with MASM 5.1 or later.		     ;
;									     ;
;									     ;
;----------------------------------------------------------------------------;
;----------------------------------------------------------------------------;
;									     ;
;	This source file is the property of 3Com Corporation and may not be  ;
;	copied or distributed in any isomorphic form without an appropriate  ;
;	prior licensing arrangement with 3Com Corporation.		     ;
;									     ;
;	Copyright (c) 1994 3Com Corporation				     ;
;									     ;
;	3Com Corporation						     ;
;	5400 Bayfront Plaza, P.O. Box 58145				     ;
;	Santa Clara, CA 95052-8145 USA					     ;
;	(408) 764-6016							     ;
;									     ;
;----------------------------------------------------------------------------;
;----------------------------------------------------------------------------;
;									     ;
;	Revision History:						     ;
;									     ;
;	11-95 Sidenblad 						     ;
;	Original version adapted from V3.INC				     ;
;									     ;
;	6-96 Elaine Mar 						     ;
;	Clean up done							     ;
;									     ;
;----------------------------------------------------------------------------;

;
; the compatibility level of this driver
;
CLEVEL		    equ 0
;
; number of I/O ports used
;
REGISTER_SET_SIZE   equ 64

;------ Equates -------------------------------------------------------------;
;
; Command code masks
;
CMD_CMDMASK	    equ 0F800h			; command bits
CMD_ARGMASK	    equ 007FFh			; argument bits
;
; Command codes, word form
;
CMD_GLOBALRESET     equ 00000b shl 11		; global reset
CMD_SELECTWINDOW    equ 00001B shl 11		; select register window
CMD_STARTINTXCVR    equ 00010b shl 11		; start internal transciver
CMD_RXDISABLE	    equ 00011b shl 11		; rx disable
CMD_RXENABLE	    equ 00100b shl 11		; rx enable
CMD_STALLCTL	    equ 00110b shl 11		; scatter/gather stall control
CMD_RXRESET	    equ 00101b shl 11		; rx reset
CMD_TXDONE	    equ 00111b shl 11		; tx done
CMD_RXDISCARD	    equ 01000b shl 11		; rx discard top packet
CMD_TXENABLE	    equ 01001b shl 11		; tx enable
CMD_TXDISABLE	    equ 01010b shl 11		; tx disable
CMD_TXRESET	    equ 01011b shl 11		; tx reset
CMD_REQUESTINT	    equ 01100b shl 11		; request interrupt
CMD_ACKNOWLEDGE     equ 01101b shl 11		; acknowledge interrupt
CMD_SETINTMASK	    equ 01110b shl 11		; set interrupt mask
CMD_SETRZMASK	    equ 01111b shl 11		; set read zero mask
CMD_SETRXFILTER     equ 10000b shl 11		; set rx filter
CMD_SETRXEARLY	    equ 10001b shl 11		; set rx early threshold
CMD_SETTXAVAILABLE  equ 10010b shl 11		; set tx available threshold
CMD_SETTXSTART	    equ 10011b shl 11		; set tx start threshold
CMD_STARTDMA	    equ 10100b shl 11		; start dma upload/download
CMD_STATSENABLE     equ 10101b shl 11		; statistics enable
CMD_STATSDISABLE    equ 10110b shl 11		; statistics disable
CMD_STOPINTXCVR     equ 10111b shl 11		; start internal transciver
CMD_SETHASHFILTER   equ 11001b shl 11		; set hash filter bit
;
; Command codes, hibyte form (commands without operands only)
;
CMDH_STARTINTXCVR   equ CMD_STARTINTXCVR shr 8
CMDH_RXDISABLE	    equ CMD_RXDISABLE shr 8
CMDH_RXENABLE	    equ CMD_RXENABLE shr 8
CMDH_STALLCTL	    equ CMD_STALLCTL shr 8
CMDH_TXDONE	    equ CMD_TXDONE shr 8
CMDH_RXDISCARD	    equ CMD_RXDISCARD shr 8
CMDH_TXENABLE	    equ CMD_TXENABLE shr 8
CMDH_TXDISABLE	    equ CMD_TXDISABLE shr 8
CMDH_REQUESTINT     equ CMD_REQUESTINT shr 8
CMDH_STATSENABLE    equ CMD_STATSENABLE shr 8
CMDH_STATSDISABLE   equ CMD_STATSDISABLE shr 8
CMDH_STOPINTXCVR    equ CMD_STOPINTXCVR shr 8
;
; Status register bits (INT for interrupt sources, ST for the rest)
;
INT_LATCH	    equ 00001h			; interrupt latch
INT_ADAPTERFAIL     equ 00002h			; adapter failure
INT_TXCOMPLETE	    equ 00004h			; tx complete
;INT_TXAVAILABLE     equ 00008h			; tx available
INT_RXCOMPLETE	    equ 00010h			; rx complete
INT_RXEARLY	    equ 00020h			; rx early
INT_REQUESTED	    equ 00040h			; interrupt requested
INT_UPDATESTATS     equ 00080h			; update statistics
INT_DMADONE	    equ 00100h			; V3 bus master complete
INT_DNCOMPLETE	    equ 00200h			; Download bus master complete
INT_UPCOMPLETE	    equ 00400h			; Upload bus master complete

ST_DMABUSY	    equ 00800h			; dma in progress
ST_BUSY 	    equ 01000h			; command busy
ST_WINDOW	    equ 0E000h			; window bits (13-15)

INTH_DMADONE	    equ INT_DMADONE shr 8
STH_DMABUSY	    equ ST_DMABUSY shr 8
STH_BUSY	    equ ST_BUSY shr 8
STH_WINDOW	    equ ST_WINDOW shr 8

MASK_ALL	    equ 000000000000b
MASK_NONE	    equ 011011111110b		; actually, V3 bus master
						; masked
MASK_MASTER	    equ 000011111110b		; all bus master masked

ACK_ALL 	    equ 011111111111b		; ack everything

TXRXRESET_ALLBUTDN  equ 0000000101000000b	; Tx/Rx reset all but bus master
						; and download logic
TXRXRESET_ALLBUTBM  equ 0000000001000000b	; Tx/Rx reset all but bus master
;
; PktStatus register bits
;
PS_DNINPROGRESS     equ 0080h			; dnInProgress
;
; RxStatus register bits, both forms
;
RXS_INCOMPLETE	    equ 8000h			; not completely received
RXS_ERROR	    equ 4000h			; error in packet
RXS_LENGTH	    equ 1FFFh			; bytes in RxFIFO

RXSH_INCOMPLETE     equ RXS_INCOMPLETE shr 8
RXSH_ERROR	    equ RXS_ERROR shr 8
;
; RxError register bits
;
RXE_OVERRUN	    equ 0001h
RXE_RUNT	    equ 0002h
RXE_FRAMING	    equ 0004h
RXE_CRC 	    equ 0008h
RXE_OVERSIZE	    equ 0010h
RXE_DRIBBLE	    equ 0080h
RXE_OVERFLOW	    equ 0100h
;
; TxStatus register bits
;
TXS_COMPLETE	    equ 80h			; tx completed
TXS_INTREQUESTED    equ 40h			; interrupt on successfull tx
TXS_ERRTYPE	    equ 3Ch			; error bits
TXS_JABBERERROR     equ 20h			; jabber error
TXS_UNDERRUN	    equ 10h			; tx underrun error
TXS_MAXCOLLISIONS   equ 08h			; max collisions error
TXS_STATUSOVERFLOW  equ 04h			; TX status stack is full
;
; start dma command bits
;
DMA_UPLOAD	    equ 00h
DMA_DOWNLOAD	    equ 01h
;
; Stall/unstall scatter/gather command bits
;
UP_STALL	    equ 000b
UP_UNSTALL	    equ 001b
DN_STALL	    equ 010b
DN_UNSTALL	    equ 011b
FRAGLAST	    equ 80000000h		; last frag. indicator in dnFraglen
FSH_DNCOMPLETE	    equ 0001h			; dnComplete in FSH
;
; PktStatus/DMACtrl register bits
UPPKTCOMPLETE	    equ 8000h
COUNTERSPEED_10     equ 0100h			; bit 8 = 1  10 MB
COUNTERSPEED_100    equ 0000h			; bit 8 = 0  100 Mb
UPRXEARLYENABLE     equ 0020h
DNCOMPLETE	    equ 0010h			;
UPCOMPLETE	    equ 0008h
;
; InternalConfig register bits
;
ICL_RAMSIZE_MASK    equ 0007h
RAM_8K		    equ 000b
RAM_32K 	    equ 010b
RAM_64K 	    equ 011b
RAM_128K	    equ 100b

ICL_RAM16BIT	    equ 0008h			; set if word wide ram

ICH_RAMPART_MASK    equ 0003h
PART_5TO3	    equ 00b
PART_3TO1	    equ 01b
PART_1TO1	    equ 10b

;ICH_XCVR_MASK	     equ 0070h			 ; transceiver select
ICH_XCVR_MASK	    equ 00F0h			; transceiver select
ICH_XCVR_SHIFT	    equ 4

ICH_AUTOSELECT	    equ 0100h			; auto-select bit
;
; transceiver types
;
XCVR_10TP	    equ 000b			; 10BaseT/TP
XCVR_10AUI	    equ 001b			; 10Mbps AUI
XCVR_10BNC	    equ 011b			; 10Base2/Coax/BNC
XCVR_100TX	    equ 100b			; 100BaseTX (scrambled)
XCVR_100FX	    equ 101b			; 100BaseFX (unscrambled)
XCVR_MII	    equ 110b			; MII
XCVR_AUTO	    equ 1000b			; Cyclone autonegotiation
;
; bits in ResetOptions
;
RO_AVAILBITS	    equ 00FFh

RO_BASET4	    equ 0001h
RO_BASETX	    equ 0002h
RO_BASEFX	    equ 0004h
RO_TP		    equ 0008h
RO_COAX 	    equ 0010h
RO_AUI		    equ 0020h
RO_MII		    equ 0040h
RO_BASEFL	    equ 0100h		;980514
;
; Window Numbers
;
WNO_SETUP	    equ 0			; setup/configuration
WNO_OPERATING	    equ 1			; operating set
WNO_STATIONADDRESS  equ 2			; station address setup/read
WNO_FIFO	    equ 3			; FIFO management
WNO_DIAGNOSTICS     equ 4			; diagnostics
WNO_READABLE	    equ 5			; registers set by commands
WNO_STATISTICS	    equ 6			; statistics
WNO_BUSMASTER	    equ 7			; bus master stuff
comment %
;
; Port offsets, Window 1.  Set up for the alternate decode.
;
PORT_CmdStatus	    equ 0Eh			; command/status
PORT_TxFree	    equ 1Ch			; free transmit bytes
PORT_TxStatus	    equ 1Bh			; transmit status (byte)
;PORT_TxStatus	     equ 0Bh			 ; transmit status (byte)
PORT_Timer	    equ 1Ah			; latency timer (byte)
PORT_RxStatus	    equ 18h			; receive status
PORT_RxError	    equ 14h			; receive error bits
PORT_RxFIFO	    equ 10h			; RxFIFO read
PORT_TxFIFO	    equ 10h			; TxFIFO write
; cyclone changes
PORT_TxPktID	    equ 18h			; Tx Packed ID
PORT_IntStatusAuto  equ 1Eh
;
; Port offsets, Window 0
;
PORT_EEData	    equ 0Ch
PORT_EECmd	    equ 0Ah			; EEProm command register
PORT_CfgResource    equ 08h			; resource configuration (EISA)
PORT_CfgAddress     equ 06h			; address configuration (EISA)
PORT_CfgControl     equ 04h			; configuration control (EISA)
PORT_ProductID	    equ 02h			; product id (EISA)
PORT_Manufacturer   equ 00h			; manufacturer code (EISA)
; Cyclone specific
PORT_BiosRomData    equ 08h			; data port for direct I/O to BIOS
PORT_BiosRomAddr    equ 04h			; addr. port for I/O to BIOS
;
; Port offsets, Window 2
;
PORT_SA0_1	    equ 00h			; station address bytes 0,1
PORT_SA2_3	    equ 02h			; station address bytes 2,3
PORT_SA4_5	    equ 04h			; station address bytes 4,5
PORT_SM0_1	    equ 06h			; station mask bytes 0,1
PORT_SM2_3	    equ 08h			; station mask bytes 0,1
PORT_SM4_5	    equ 0Ah			; station mask bytes 0,1
; cyclone specific
PORT_cycloneresetoptions equ 0ch		; resetOptions
;
; Port offsets, Window 3
;
PORT_ALT_TxFree     equ 0Ch			; free transmit bytes (dup)
PORT_RxFree	    equ 0Ah			; free receive bytes
PORT_ResetOptions   equ 08h			; ResetOptions
PORT_MacControl     equ 06h			; MacControl
PORT_InternalCfgH   equ 02h			; InternalConfig High
PORT_InternalCfgL   equ 00h			; InternalConfig Low
; cyclone specific
PORT_MediaOptions   equ 08h			; Media Options
PORT_MaxPktSize     equ 04h			; Max pkt for Oversized pkt
;
; Port offsets, Window 4
;
PORT_UpperBytesOk   equ 0Dh			; upper 4 bits of tx bytes ok and rx bytes ok
PORT_BadSsdCount    equ 0Ch			; rx bad frame start stat
PORT_MediaStatus    equ 0Ah			; media type/status
PORT_PhysicalMgmt   equ 08h			; physical management
PORT_NetDiagnostic  equ 06h			; net diagnostic
PORT_FIFODiagnostic equ 04h			; FIFO diagnostic
PORT_VCODiagnostic  equ 02h			; VCO diagnostic
; cyclone specific
PORT_AnalogDiagnostic equ 00h
;
; Port offsets, Window 5
;
PORT_RZMask	    equ 0Ch			; read zero mask
PORT_IntMask	    equ 0Ah			; interrupt mask
PORT_RxFilter	    equ 08h			; receive filter
PORT_RxEarly	    equ 06h			; rx early threshold
PORT_TxAvailable    equ 02h			; tx available threshold
PORT_TxStart	    equ 00h			; tx start threshold
; cyclone specific
PORT_TxReClaim	    equ 09h
;
; Port offsets, Window 6
;
PORT_TXBYTES	    equ 0Ch			; tx bytes ok
PORT_RXBYTES	    equ 0Ah			; rx bytes ok
PORT_UPPERFRAMES    equ 09h			; upper bits of tx/rx frames ok
PORT_TXDEFER	    equ 08h			; tx frames deferred (byte)
PORT_RXFRAMES	    equ 07h			; rx frames ok (byte)
PORT_TXFRAMES	    equ 06h			; tx frames ok (byte)
PORT_RXDISCARDED    equ 05h			; rx frames discarded (byte)
PORT_TXLATE	    equ 04h			; tx frames late coll. (byte)
PORT_TXSINGLE	    equ 03h			; tx frames one coll. (byte)
PORT_TXMULTIPLE     equ 02h			; tx frames mult. coll. (byte)
PORT_TXNOCD	    equ 01h			; tx frames no CDheartbt (byte)
PORT_TXCARRIERLOST  equ 00h			; tx frames carrier lost (byte)
;
; Port offsets, Window 7
;
PORT_MasterStatus   equ 0Ch
PORT_MasterLen	    equ 06h
PORT_MasterAddressH equ 02h
PORT_MasterAddress  equ 00h
; cyclone specific
PORT_VlanMask	    equ 00h
PORT_PowerMgmt	    equ 0ch
;
; Port offsets, Boomerang Extensions
;
PORT_PKTSTATUS	    equ 020h			; scatter/gather state bits
PORT_DNLISTPTR	    equ 024h			; phys addr of current DPD
PORT_FRAGADDR	    equ 028h			; phys addr of current fragment
PORT_FRAGLEN	    equ 02Ch			; current fragment length
PORT_LISTOFF	    equ 02Eh			; current DPD or UPD index
PORT_TXFREETHRESH   equ 02Fh			; minimum TX free
PORT_UPPKTSTATUS    equ 030h			; upload packet status
PORT_COUNTDOWN	    equ 036h			; countdown timer
PORT_UPLISTPTR	    equ 038h			; phys addr of current UPD
; cyclone specific
PORT_DmaCtrl	    equ 20h			; formerly Pktstatus
PORT_DnTgtBurst     equ 2Ah
PORT_DnReq	    equ 2Ch
PORT_DnPoll	    equ 2Dh
PORT_FreeTimer	    equ 34h
PORT_UpReq	    equ 3Ch
PORT_UpPoll	    equ 3Dh
PORT_UpTgtBurst     equ 3Eh
PORT_RealTimeCnt    equ 40h
%
;
; masks for UpperFramesOk
;
UPPER_RXFRAMES_MASK equ 00Fh
UPPER_TXFRAMES_MASK equ 0F0h
UPPER_TXFRAMES_SHIFT equ 4
;
; bits in MasterStatus
;
MS_INPROGRESS	    equ 8000h			; bus master operation in progress
MS_UPLOAD	    equ 4000h			; upload complete/ack
MS_DOWNLOAD	    equ 1000h			; download complete/ack
MS_MASTERABORT	    equ 0001h			; no response from slave
MS_TARGETABORT	    equ 0002h			; aborted by slave
;
; bits in RCR (EISA)
;
RCR_IRQ_MASK	    equ 0F000h
RCR_IRQ_SHIFT	    equ 12
;
; bits in CCR (EISA)
;
CCR_ENABLE	    equ 00001h
;
; bits in MacControl
;
MACC_DEFEREXTEND    equ 0010h
MACC_FULLDUPLEX     equ 0020h
MACC_ALLOWLARGE     equ 0040h
MACC_FLOWCTRL_EN    equ 0100h			; new for cyclone
;
; Various command arguments
;
FILTER_INDIVIDUAL	equ 0001b		    ; individual address
FILTER_MULTICAST	equ 0010b		    ; multicast/group addresses
FILTER_BROADCAST	equ 0100b		    ; broadcast address
FILTER_PROMISCUOUS	equ 1000b		    ; promiscuous mode
FILTER_HASHMULTICAST	equ 10000b		    ; multicast hast

RXEARLY_DISABLED	equ 8188		    ; RxEarly to disable

TXAVAIL_DISABLED	equ 8188		    ; TxAvailable to disable

TXSTART_DISABLED	equ 8188		    ; TxStart to disable
MAX_TXSTART		equ TXSTART_DISABLED
MAXTXSTARTVALUE 	equ 1FFCh
;
; Transmit Preamble
;
PREAMBLESIZE		equ 4			    ; transmit preamble size

PRE_INTONSUCCESS	equ 8000h		    ; interrupt on success
PRE_CRCAPPENDDISABLE	equ 2000h		    ; CRC included
;
; maximum packet that can be received normally
;
MAX_RXBYTES		equ 1792
;
; the size of a receive buffer should be the nearest higher multiple of 64,
; to preserve 64 byte alignment on receive buffers...
;
RX_BUFSIZE		equ (MAX_RXBYTES + 63) AND (NOT 63)
;
; Bits in various diagnostics registers
;
; MediaStatus
;
MEDIA_AUIDISABLE	equ 8000h		    ; on board transceiver selected
MEDIA_DCCONVERTERENABLED equ 4000h		    ; EnableDcConverter done
MEDIA_TXINPROG		equ 1000h		    ; transmit in progress
MEDIA_LBEAT		equ 0800h		    ; link beat ok (TP)
MEDIA_POLARITY		equ 0400h		    ; polarity (TP)
MEDIA_JABBER		equ 0200h		    ; jabber (TP)
MEDIA_LBEATENABLE	equ 0080h		    ; link beat enable (TP)
MEDIA_JABBERENABLE	equ 0040h		    ; jabber enable (TP)
MEDIA_CRS		equ 0020h		    ; carrier sense
MEDIA_COLLISION 	equ 0010h		    ; collision
MEDIA_SQEENABLE 	equ 0008h		    ; enable SQE statistics
MEDIA_CRCSTRIPDISABLE	equ 0004h		    ; disable Rx CRC stripping
MEDIA_DATARATE100	equ 0002h		    ; operating at 100Mbps

MEDIA_XCVRBITS		equ MEDIA_LBEATENABLE+MEDIA_JABBERENABLE+MEDIA_SQEENABLE
;
; NetDiagnostics
;
NETD_NOLOOPBACK_MASK	equ 0FFFh		    ; no loopbacks
NETD_EXTLOOPBACK	equ 8000h		    ; TP external loopback
NETD_ENDECLOOPBACK	equ 4000h		    ; ENDEC loopback
NETD_MACLOOPBACK	equ 2000h		    ; ethernet core loopback
NETD_FIFOLOOPBACK	equ 1000h		    ; FIFO loopback
NETD_TXENABLED		equ 0800h		    ; tx enabled
NETD_RXENABLED		equ 0400h		    ; rx enabled
NETD_TXTRANSMITTING	equ 0200h		    ; tx transmitting (maybe)
NETD_TXRESETREQD	equ 0100h		    ; tx reset required
NETD_STATSENABLED	equ 0080h		    ; statistics enabled
NETD_ASICREV		equ 003Eh		    ; ASIC revision
NETD_ASICREV_SHIFT	equ 1			    ; shr 1 to get revision
NETD_LOWVOLTAGE 	equ 0001h		    ; low voltage detect

FIFOD_RXRECEIVING	equ 8000h		    ; rx receiveing
FIFOD_RXUNDERRUN	equ 2000h		    ; rx underrun
FIFOD_RXOVERRUN 	equ 0800h		    ; rx overrun
FIFOD_TXOVERRUN 	equ 0400h		    ; tx overrun
;
; bits in Cyclone Reset Options
;
STANDARD_ADAPTER	equ 02h 		    ; all adv. features enabled
MOTHERBOARD		equ 00h 		    ; all enable except pkt scheduling
LOW_COST		equ 01h 		    ; adv. features disabled
SERVER_ADAPTER		equ 04h 		    ; same as standard.
;
; board identification codes
;
PCI_VENDORID		equ 010B7h		    ; PCI Vendor ID (3Com)
PCI_DEVICEID_MASK	equ 0FF00h		    ; mask off last digit/rev
PCI_DEVICEID		equ 09000h		    ; PCI Device ID (masked)
PCI_DEVICEID_CYC_TX	equ 09055h		    ; Cyclone TX
PCI_DEVICEID_CYC_T4	equ 09056h		    ; Cyclone T4
PCI_DEVICEID_KRA_TPO	equ 09004h		    ; Krakatau TPO
PCI_DEVICEID_KRA_COMBO	equ 09005h		    ; Krakatau Combo
PCI_DEVICEID_KRA_TPC	equ 09006h		    ; Krakatau TPC
PCI_DEVICEID_BOOM_T4	equ 09051h		    ; Boomerang T4
PCI_DEVICEID_BOOM_TX	equ 09050h		    ; Boomerang TX
PCI_DEVICEID_BOOM_TPO	equ 09000h		    ; Boomerang TPO
PCI_DEVICEID_BOOM_COMBO equ 09001h		    ; Boomerang Combo

;
; EEProm access
;
EE_BUSY 		equ 8000h		    ; EEProm busy bit in EECmd
READ_EEPROM		equ 080h

EE_TCOM_NODE_ADDR_WORD0     equ 00h
EE_TCOM_NODE_ADDR_WORD1     equ 01h
EE_TCOM_NODE_ADDR_WORD2     equ 02h
EE_DEVICE_ID		    equ 03h
EE_MANUFACTURING_DATE	    equ 04h
EE_MANUFACTURING_DIVISION   equ 05h
EE_MANUFACTURING_PRODCODE   equ 06h
EE_PCI_PARMS		    equ 08h
EE_ROM_INFO		    equ 09h
EE_OEM_NODE_ADDR_WORD0	    equ 0Ah
EE_OEM_NODE_ADDR_WORD1	    equ 0Bh
EE_OEM_NODE_ADDR_WORD2	    equ 0Ch
EE_SOFTWARE_INFO	    equ 0Dh
EE_CWORD		    equ 0Eh
EE_SOFTWARE_INFO_2	    equ 0Fh
EE_CAPABILITY_WORD	    equ 10h
EE_INTERNAL_CFG_WORD0	    equ 12h
EE_INTERNAL_CFG_WORD1	    equ 13h
EE_MII_SELECT		    equ 15h
EE_MEDIAOPTIONS		    equ	19h
EE_MII_SELECT_MASK	    equ 000Fh
;
; Software Configuration bits
;
SW_OPTIMIZE		equ 0030h
SW_MAXCLI		equ 3F00h
SW_LINKBEAT		equ 4000h
SW_FULLDUPLEX		equ 8000h
;
; Software Info 2 bits
;
DRIBBLE_10_FIX		equ 0001h
;
; Possibilities for SW_OPTIMIZE
;
OPTIMIZE_NORMAL 	equ 0010h
OPTIMIZE_NETWORK	equ 0020h
OPTIMIZE_CPU		equ 0030h
;
; Capabilities bits
;
SUPPORTS_FULLDUPLEX	equ 0002h
SUPPORTS_LARGEPACKETS	equ 0004h
SUPPORTS_FULLBUSMASTER	equ 0020h
SUPPORTS_FRAGBUSMASTER	equ 0040h
SUPPORTS_100MBPS	equ 1000h
;
; Bus Types
;
BUS_UNKNOWN		equ	0
BUS_ISA 		equ	1
BUS_EISA		equ	2
BUS_PCI 		equ	3
;
; PCI BIOS function code
;
PCI_FUNCTION_ID         equ     0b1h
PCI_BIOS_PRESENT        equ     001h
FIND_PCI_DEVICE         equ     002h
READ_CONFIG_BYTE        equ     008h
READ_CONFIG_WORD        equ     009h
READ_CONFIG_DWORD       equ     00ah
WRITE_CONFIG_BYTE	equ	0bh
WRITE_CONFIG_WORD	equ	0Ch
WRITE_CONFIG_DWORD	equ	0Dh
;
; PCI BIOS function return code
;
PCI_CALL_SUCCESSFUL     equ     00h
PCI_DEVICE_NOT_FOUND    equ     86h
PCI_BAD_VENDOR_ID       equ     83h
;
; offsets in PCI configuration space
;
PCIC_INTERRUPTLINE	equ	003Ch
PCIC_BIOSROMCONTROL	equ	0030h
PCIC_IOBASE		equ	0010h
PCIC_LATENCYTIMER	equ	000Dh
PCIC_STATUS		equ	0006h
PCIC_COMMAND		equ	0004h
PCIC_DEVICEID		equ	0002h
PCIC_VENDORID		equ	0000h
PCIC_MEDTESTMODEHI	equ	0054h

CFGREG_PCIC_COMMAND     equ     0004h
CFGREG_IOBASE           equ     010h
CFGREG_INTLINE          equ     03ch
CFGREG_INTERNALCFG      equ     040h
CFGREG_BIOSROMCONTROL   equ     030h
;
; bits in PciCommand
;
PCIC_IOENABLE		equ	00001h
PCIC_BMENABLE		equ	00004h
PCIC_PARITYENABLE	equ	00040h
;
; bits in LatencyTimer
;
LATE_MAX		equ	255
LATE_MASK		equ	(NOT 7)
;
; adapter codes
;
ACODE_PCI_10_TPO	equ	42
ACODE_PCI_10_COMBO	equ	43
ACODE_EISA_10_TPO	equ	44
ACODE_EISA_10_COMBO	equ	45
ACODE_PCI_100_TX	equ	46
ACODE_EISA_100_TX	equ	47
ACODE_BOOM_TPO		equ	60
ACODE_BOOM_COMBO	equ	61
ACODE_BOOM_TX		equ	62
ACODE_BOOM_T4		equ	63
;
; MII Transceiver type
;
GENERIC_MII		equ	0h
BASE100_T4		equ	1h
BASE10_T		equ	2h
BASE100_TX		equ	3h
AUTO_10BASET		equ	4h
AUTO_100BASETX		equ	5h

;
; special values used for RetryBits variable.  see DATA.ASM for details.
;
RETRY_YES		equ	CMD_ARGMASK
RETRY_NO		equ	0


;------ Structures ----------------------------------------------------------;
;
; Download and Upload Fragment descriptors:
;
MemFragment	struc
Frag_physaddr	dd	?		; 32 bit physical address
Frag_len	dd	?		; fragment length
MemFragment	ends

MemFragmentvirt struc
Frag_virtaddr_seg dw	?		; segment
Frag_virtaddr_off dw	?		; offset
Frag_numbytes	  dw	?		; number of bytes of data
MemFragmentvirt ends
;
;
; Download and Upload Packet Descriptors:
;
; The nextptr must be aligned on an 8 byte boundary.  Since we allocate
; space for several DPDs contiguously, the size must be held to a multiple
; of 8 bytes, so we make sure the software prefix bytes add up to a multiple
; of 8.
;
; Download Packet Descriptor
;
NUM_DPDS	  	equ	6
MAX_DOWNFRAGMENTS	equ	1	;16; gives us a 64 byte DPD
SMALL_PKT_BUFF_SIZE	equ	134

DPDStruc	struc
;DPD_header	db	 4 dup (?)	; queue header (next and prev)
;DPD_physaddr	dd	?		; physical address of this DPD
;DPD_pktaddr	dd	?		; physical address of small pkt buffer
;qtx_handle	dw	?		; save protocol handle
;qtx_protID	dw	?		; save protID
;DPD_VDS_used	db	0		; VDS used flag
;DPD_VDS_count	db	0		; count of fragments that were VDSed
;DPD_immed_bytes db	SMALL_PKT_BUFF_SIZE dup (0)	; space for small packet buffer
;DPD_virt_fragment db	(8*(size MemFragmentvirt)) dup (0) ; fragment virtual
DPD_DnNextPtr	dd	?		; physical address of next DPD
DPD_FrameStart	dw	?		; frame start header for packet
DPD_FSHindicate	dw	?		; high order bit requests an interrupt
DPD_Frag	db	(MAX_DOWNFRAGMENTS*(size MemFragment)) dup (?)
					; fragment descriptors
DPDStruc	ends

;
; Upload Packet Descriptor
;
NUM_RXBUFFERS	equ	6		; also the number of UPDs needed
MAX_UPFRAGMENTS equ	1	;3	; gives us a 40 byte UPD

UPDStruc	struc
;UPD_nextvirtoff dw	?		; virtual address offset to next UPD
;UPD_pktoff	dw	?		; offset of receive packet buffer
;UPD_pktseg	dw	?		; segment of receive packet buffer
;UPD_physaddr	dd	?		; physical address of this UPD's
;UPD_pad_bytes	db	6 dup (0)	; pad to 8-byte boundary
					; upnextptr (hardware structure start)
UPD_UpNextPtr	dd	?		; physical address of next UPD's
					; upnextptr (hardware structure start)
UPD_UpPktStatus	dw	?		; packet status
UPD_UpPktError	db	?		; error indications
UPD_UpStatspare	db	?		; unused
UPD_Frag	db	(MAX_UPFRAGMENTS*(size MemFragment)) dup (?)
					; fragment descriptors
UPDStruc	ends

;
; TxStart structure.  Padded to 16 bytes for easy indexing.
;
TxStartStruc	struc
txs_thresh	dw	?		; TxStart threshold (+CMD_SETTXSTART)
txs_value	dw	?		; value, no cmd, unscaled
txs_min 	dw	?		; minimum threshold, this bin
txs_count	dw	?		; packets since last underrun
txs_uN		dw	?		; number of entries in uSum
txs_uSum	dw	?		; sum of uN x packets between underruns
txs_pad 	dw	?		; pad to 16 bytes
txs_marker	dw	?		; pad to 16 bytes, marker for debug
TxStartStruc	ends

SIZE_TxStart	equ	SIZE TxStartStruc
TXBIN_COUNT	equ	1		; 1 bin

;
; MII register definitions.   The following are definitions of the standard
; MII registers, common to all implementations of the MII interface.
;
MII_PHY_CONTROL     equ    0	   ; control reg address
MII_PHY_STATUS	    equ    1	   ; status reg address
MII_PHY_OUI	    equ    2	   ; most of the OUI bits
MII_PHY_MODEL	    equ    3	   ; model/rev bits, and rest of OUI
MII_PHY_ANAR	    equ    4	   ; AutoNegotiation Adverisement Register
MII_PHY_ANLPAR	    equ    5	   ; AutoNegotiation Link Partner Ability Reg.
MII_PHY_ANER	    equ    6	   ; AutoNegotiation Expansion Reg.
MII_PHY_PAR	    equ    19h	   ; PHY Address Register
MII_EXT_REG0	    equ    10h	   ; Extended Reg. 0 (Broadcom)
MII_PHY_PCR	    equ    17h	   ; PCS Configuration Reg. (National)
;
; bit fields in the standard MII control register
;
MII_CTL_RESET	    equ    8000h   ; reset bit in control reg
MII_CTL_100MB	    equ    2000h   ; 100Mbit or 10 Mbit flag
MII_CTL_ENABLE_AUTO equ    1000h   ; autonegotiate enable
MII_CTL_ISOLATE     equ    0400h   ; islolate bit
MII_CTL_START_AUTO  equ    0200h   ; restart autonegotiate
MII_CTL_FULL_DUPLEX equ    0100h   ; full duplex
;
; bit fields in the standard MII status register
;
MII_STS_100MB_MASK  equ    0E000h  ; any of these indicate 100 Mbit
MII_STS_10MB_MASK   equ    1800h   ; either of these indicate 10 Mbit
MII_STS_100BASET4   equ    08000h  ; 100BaseT4
MII_STS_100BASEX_FD equ    04000h  ; 100BaseX Full Duplex
MII_STS_100BASEX_HD equ    02000h  ; 100BaseX Half Duplex
MII_STS_10BASET_FD  equ    01000h  ; 10BaseT Full Duplex
MII_STS_10BASET_HD  equ    0800h   ; 10BaseT Half Duplex
MII_STS_AUTO_DONE   equ    0020h   ; auto negotiation complete
MII_STS_AUTO	    equ    0008h   ; auto negotiation is available
MII_STS_LINK_UP     equ    0004h   ; link status bit
MII_STS_EXTENDED    equ    0001h   ; extended regs exist
;
; bit fields in the extended MII auto-negotiation link partner ability reg.
; bit 5-12 are technology ability bits in MII spec.
; national n-way uses bit 5-9 only.
;
MII_ANLPAR_100BASET4   equ    0200h  ; 100BaseT4
MII_ANLPAR_100BASEX_FD equ    0100h  ; 100BaseX Full Duplex
MII_ANLPAR_100BASEX_HD equ    0080h  ; 100BaseX Half Duplex
MII_ANLPAR_10BASET_FD  equ    0040h  ; 10BaseT Full Duplex
MII_ANLPAR_10BASET_HD  equ    0020h  ; 10BaseT Half Duplex
;
; bit fields in the ANER register
;
LP_AN_ABLE	     equ      0001h  ; Link Partner Auto-Negotiation able
MII_ANER_MLF	     equ      0010h  ; Multiple Link Fault
; bit field in the PAR reg.
;
SPEED_10	     equ      0040h  ; 1 = 10Mb, 0 = 100Mb
;
; Physical Management bits
;
MGMT_PHY_CLOCK	    equ    0001h
MGMT_PHY_DATA1	    equ    0002h
MGMT_PHY_WRITE	    equ    0004h
;
; bit field in the extended register 0 for broadcom
MII_EXT_SPEED	       equ    0002h  ; Speed Indication (1=100, 0=10)
;
; Phy addr
;
NWAY		    equ    18h
T4		    equ    01h
;
; Phy OUI
;
BROADCOM_OUI	    equ    3E0h 	; T4
NATIONAL_OUI	    equ    2000h	; 840A
;
; Phy Model
;
NATIONAL_MODEL	    equ    5C00h	; 840A
BROADCOM_MODEL	    equ    0000h	; T4

;
; for intercepting keyboard
;
BIOS_SEG		equ	40h
KEY_FLAG_OFF		equ	17h
KEY_WARMBOOT_BIT	equ	00001100b
KEY_ALT_BIT		equ	00001000b
KEY_CTRL_BIT		equ	00000100b

;------ Macros --------------------------------------------------------------;
;
; SelectWindow - select register window specified (must be a constant)
;
; entry:
;   dx = cmd/status port
;
; destroys:
;   ax
;
SelectWindow macro  wno
	    mov     ax, CMD_SELECTWINDOW + wno
	    out     dx, ax
endm

;
; General purpose equates, structures and macros.
;
FALSE           equ     0
TRUE            equ     0ffh
;
; I/O ports for the PICs
;
MASTER_MASK_PORT equ    021h
SLAVE_MASK_PORT	 equ    0A1h
;
; DOUBLEWORD - Thirty-two bit double word layout for sixteen bit word access
;
doubleword      struc
loword          dw      0               ; low order word
hiword          dw      0               ; high order word
doubleword      ends

;
; FARPOINTER - Thirty-two bit 286-style far pointer layout for segment and
;              offset access
;
farpointer      struc
off             dw      0               ; offset
segm            dw      0               ; segment or selector
farpointer      ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c90xb\undi_equ.inc ===
;
;--- Miscellaneous Equates
;
NULL            equ     0
CR		equ	0Dh           ;- Carriage Return
LF		equ	0Ah           ;- Line Feed
FALSE		equ	0
TRUE		equ	1
;
;--- Ethernet Frame Sizes
;
ETHERNET_ADDRESS_LENGTH		equ	6
ETHERNET_HEADER_SIZE		equ	14
MINIMUM_ETHERNET_PACKET_SIZE	equ	60
;MAXIMUM_ETHERNET_PACKET_SIZE	equ	1514
MAXIMUM_ETHERNET_PACKET_SIZE	equ	1500 ;; just data, not media header

MAX_PACKET         Equ       1514      ; Maximum allowable packet size.
MIN_PACKET         Equ       60        ; Minimum allowable packet size.
; 
;--- Packet filter bit definitions
; 
FLTR_DIRECTED                Equ       01H
FLTR_MLTCST                  Equ       01H
FLTR_BRDCST                  Equ       02H
FLTR_PRMSCS                  Equ       04H
FLTR_SRC_RTG                 Equ       08H
;
;--- Processor Type Equates
;
EIGHT_BIT          equ       0001H
SIXTEEN_BIT        equ       0002H
PROC_TYPE_MASK     equ       0030H

PROC_8086          equ       0000H OR EIGHT_BIT
PROC_80286         equ       0010H OR SIXTEEN_BIT
PROC_80386         equ       0020H
PROC_80486         equ       0040H
;
;--- Result codes returned in AX by a PXE API service.
;
PXENV_EXIT_SUCCESS		equ	0
PXENV_EXIT_FAILURE		equ	1
PXENV_EXIT_CHAIN		equ	0FFFFh	; used internally
;
;--- Status codes returned in the status word of PXE API parameter structures.
;
PXENV_STATUS_SUCCESS		equ	0
PXENV_STATUS_FAILURE		equ	1	;general failure
PXENV_STATUS_BAD_FUNC		equ	2	;invalid function number
PXENV_STATUS_UNSUPPORTED	equ	3	;not yet supported
PXENV_STATUS_1A_HOOKED		equ	4	;Int 1AH cannot be unhooked

; Driver errors (60 to 0x6F)
; These errors are for UNDI compatible NIC drivers.
PXENV_STATUS_UNDI_MEDIATEST_FAILED 		equ	61h
PXENV_STATUS_UNDI_CANNOT_INIT_NIC_FOR_MCAST	equ	62h
;
;
EISA_ADAPTER             equ    1
PCI_ADAPTER              equ    2
PnP_ADAPTER              equ    3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c90xb\version.inc ===
;
; Modifications:   $Header:   H:/Archives/Client/Include/version.inv   1.22.1.1   31 Jan 1998 23:08:08   MJOHNSOX  $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;

ifndef _VERSION_INC
_VERSION_INC=1


; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
; Equates
;

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Version number of current LSA build.
;
LSA_MAJOR	equ	0
LSA_MINOR	equ	99
LSA_EDIT	equ	'd'

LSA_EISA_ID	equ   ((('L'-'@') shl 26)+(('S'-'@') shl 21)+(('A'-'@') shl 16))

LSA_PMM_HANDLE	equ	((LSA_EISA_ID)+2000h+((LSA_MAJOR) shl 8)+(LSA_MINOR))


; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Product & manufacturer ID strings.
;
MFG_STR		textequ	<'Intel'>
PROD_STR	textequ	<'LANDesk (R) Service Agent II'>
COPYRIGHT_STR	textequ	<'Copyright (C) 1997  Intel Corporation.  All rights reserved.'>


endif ;_VERSION_INC

; EOF - $Workfile:   version.inc  $
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\amd\buildcfg.inc ===
;
; Modifications:   $Header:   J:/archives/preboot/lsa2/inc/BUILDCFG.INV   1.2   19 Sep 1997 21:39:16   MJOHNSOX  $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;

;
;   Description: Compilation Switches used to build NDIS DOS, OS/2 driver
;

;
;   Description      :    Compilation Switches used to build the NDIS DOS
;                         and OS2 drivers.   Controls version numbers,
;                         default values for parameters, debug inclusion.
;
;                         This file will be included in all of the NDIS
;                         driver source files. Any changes to this file must
;                         (through makefile) force a complete remake of the
;                         entire driver.

.386

TRUE        Equ  1
FALSE       Equ  0


Ifndef DOS
DOSNDIS         Equ     FALSE
OS2NDIS         Equ     TRUE
Else
DOSNDIS         Equ     TRUE
OS2NDIS         Equ     FALSE
Endif

OS2             Equ     OS2NDIS
DOS             Equ     DOSNDIS

;- Switch to enable debug breakpoints (int 3)
DEBUG_BP             equ         FALSE

;- Switch to enable Early Receive Code
EARLY_RCV            equ         FALSE

;- Switch to enable Code Profiling
CODE_PROFILE         equ         FALSE

StratStack           equ         TRUE

;- when transmitter hangs, when should we reset?
TRANSMIT_TIMEOUT Equ     2

;- Interval (in seconds) between successive reads of SCB statistics
UPDATE_STATS_INTERVAL    equ     4

MAX_PACKET         Equ       1514      ; Maximum allowable packet size.
MIN_PACKET         Equ       60        ; Minimum allowable packet size.

;- Number Of Multicast Addresses Supported By This Driver
MAX_MULTICAST_ADDRESSES  equ     20

;- Optional data area in TCB for Flexible mode
TXCB_BUFFER_SIZE         equ     60

;- Transmit buffer size is max Eth Size (not incl. CRC) plus slop to 1536
TCB_SLOP                 equ     22
TCB_BUFFER_SIZE          equ     MAX_PACKET+TCB_SLOP

;- Receive buffer size is max Eth size plus CRC plus slop to 1536
RCB_SLOP                 equ     22
RCB_BUFFER_SIZE          equ     MAX_PACKET+RCB_SLOP

;- minimum number of Tx buffers and/or Rx buffers allowed to run driver.
MIN_TXRX_BUF_CTS         equ     2

;- Interframe Spacing 96 Tx Clocks
IFS_SPACING              equ     60h

;- Slot Time 512 Tx Clocks
SLOT_TIME                equ     200h

;- Default CUSTOM parameter values
DEFAULT_TXFIFO           equ     8
DEFAULT_RXFIFO           equ     8
DEFAULT_LINE_SPEED       equ     100
DEFAULT_ADAPTIVE_IFS     equ     0
DEFAULT_TXTHRESHOLD      equ     32
DEFAULT_FORCEFDX         equ     0
DEFAULT_IOMAPMODE        equ     0
DEFAULT_TXDMACOUNT       equ     0
DEFAULT_RXDMACOUNT       equ     0
DEFAULT_PHYADDRESS       equ     0FFh
DEFAULT_FRAME_GAP equ 6
FRAME_GAP_MIN equ  6
FRAME_GAP_MAX equ  15

IF DOS
DEFAULT_TXBUF_COUNT      equ     4
DEFAULT_RXBUF_COUNT      equ     8               ; v40
ENDIF

DEFAULT_CONGENB          equ     0               ; v0.49

USE_DEFAULT_VALUE        equ     (-1)

DEFAULT_MCWA_EventCount  equ     6               ; v44

;- used by timer tick interrupt routine to count out one second
TICKS_PER_SECOND         equ     18



;- this indicates the offset to add to get to the '$' in the driver name
;  '0123456789'
;  'E100B$'
DOLLAR_OFFSET            equ     5               ; v0.38

; TRANSMIT_CHECK equ 1


; EOF - $Workfile:   buildcfg.inc  $
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c90xb\pcinic.inc ===
;
; Modifications:   $Header: /Client Boot/NICS/3Com/3C90xB/UNDI/PCINIC.INC 2     22/07/98 8:30p John Lobraico $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;

;
;   Description: PCI Configuration Space Definitions
;

IFDEF            PCI_INC
ELSE
PCI_INC          equ    1
include pci.inc

;--------------------------------------------------------------------------
; Configuration Space Header
;--------------------------------------------------------------------------
PCI_CONFIG_STRUC       struc
    PciVendorId        dw    ?                ;- PCI Vendor ID
    PciDeviceId        dw    ?                ;- PCI Device ID
    PciCommand         dw    ?
    PciStatus          dw    ?
    PciRevisionId      db    ?
    PciClassCode       db    3  dup (?)
    PciCacheLineSize   db    ?
    PciLatencyTimer    db    ?
    PciHeaderType      db    ?
    PciBIST            db    ?
    PciBaseReg0        dd    ?
    PciBaseReg1        dd    ?
    PciBaseReg2        dd    ?
    PciBaseReg3        dd    ?
    PciBaseReg4        dd    ?
    PciBaseReg5        dd    ?
    PciReserved0       dd    0
    PciReserved1       dd    0
    PciExpROMAddress   dd    ?
    PciReserved2       dd    0
    PciReserved3       dd    0
    PciInterruptLine   db    ?
    PciInterruptPin    db    ?
    PciMinGnt          db    ?
    PciMaxLat          db    ?
PCI_CONFIG_STRUC       ends

;--------------------------------------------------------------------------
; Config Space Register Offsets
; Refer To The PCI Specification For Detailed Explanations
;--------------------------------------------------------------------------
VENDOR_ID_REGISTER       equ     00h          ;- PCI Vendor ID Register
DEVICE_ID_REGISTER       equ     02h          ;- PCI Device ID Register
COMMAND_REGISTER         equ     04h          ;- PCI Command Register
STATUS_REGISTER          equ     06h          ;- PCI Status Register
REV_ID_REGISTER          equ     08h          ;- PCI Revision ID Register
CLASS_CODE_REGISTER      equ     09h          ;- PCI Class Code Register
CACHE_LINE_REGISTER      equ     0Ch          ;- PCI Cache Line Register
LATENCY_TIMER            equ     0Dh          ;- PCI Latency Timer Register
HEADER_TYPE              equ     0Eh          ;- PCI Header Type Register
BIST_REGISTER            equ     0Fh          ;- PCI Built-In SelfTest Register
BAR_0_REGISTER           equ     10h          ;- PCI Base Address Register 0
BAR_1_REGISTER           equ     14h          ;- PCI Base Address Register 1
BAR_2_REGISTER           equ     18h          ;- PCI Base Address Register 2
BAR_3_REGISTER           equ     1Ch          ;- PCI Base Address Register 3
BAR_4_REGISTER           equ     20h          ;- PCI Base Address Register 4
BAR_5_REGISTER           equ     24h          ;- PCI Base Address Register 5
SUB_VENDOR_ID_REGISTER           equ     2Ch          ;- PCI Base Address Register 5
SUB_DEVICE_ID_REGISTER           equ     2Eh          ;- PCI Base Address Register 5
EXPANSION_ROM            equ     30h          ;- PCI Expansion ROM Base Register
INTERRUPT_LINE           equ     3Ch          ;- PCI Interrupt Line Register
INTERRUPT_PIN            equ     3Dh          ;- PCI Interrupt Pin Register
MIN_GNT_REGISTER         equ     3Eh          ;- PCI Min-Gnt Register
MAX_LAT_REGISTER         equ     3Fh          ;- PCI Max_Lat Register

;--------------------------------------------------------------------------
; Configuration space DWORD register offsets
;--------------------------------------------------------------------------
CONFIG_SPACE_REG0        equ     0
CONFIG_SPACE_REG1        equ     1
CONFIG_SPACE_REG2        equ     2
CONFIG_SPACE_REG3        equ     3
CONFIG_SPACE_REG4        equ     4
CONFIG_SPACE_REG5        equ     5
CONFIG_SPACE_REG6        equ     6
CONFIG_SPACE_REG7        equ     7
CONFIG_SPACE_REG8        equ     8
CONFIG_SPACE_REG9        equ     9
CONFIG_SPACE_REGA        equ     0Ah
CONFIG_SPACE_REGB        equ     0Bh
CONFIG_SPACE_REGC        equ     0Ch
CONFIG_SPACE_REGD        equ     0Dh
CONFIG_SPACE_REGE        equ     0Eh
CONFIG_SPACE_REGF        equ     0Fh

;--------------------------------------------------------------------------
; Byte/Word Offsets In A Config DWORD
; These offsets can be used to move a Byte or Word into the lower half of
; a register.
;--------------------------------------------------------------------------
CONFIG_BYTE_0            equ     0
CONFIG_BYTE_1            equ     8
CONFIG_BYTE_2            equ     16
CONFIG_BYTE_8            equ     24
CONFIG_WORD_0            equ     0
CONFIG_WORD_1            equ     16

;--------------------------------------------------------------------------
; Configuration Mechanism Registers
;--------------------------------------------------------------------------
CF1_CONFIG_ADDR_REGISTER   equ   0CF8h        ;- Config Space Address Register
CF1_CONFIG_DATA_REGISTER   equ   0CFCh        ;- Config Space Data Register
CF2_SPACE_ENABLE_REGISTER  equ   0CF8h        ;- CSE Register
CF2_FORWARD_REGISTER       equ   0CFAh        ;- Forward Register
CF2_BASE_ADDRESS           equ   0C000h       ;- Configuration #2 Base

;--------------------------------------------------------------------------
; PCI Class Code Definitions
; Configuration Space Header
;--------------------------------------------------------------------------
PCI_BASE_CLASS           equ     02h          ;- Base Class - Network Controller
PCI_SUB_CLASS            equ     00h          ;- Sub Class - Ethernet Controller
PCI_PROG_INTERFACE       equ     00h          ;- Prog I/F - Ethernet COntroller

;--------------------------------------------------------------------------
; PCI Command Register Bit Definitions
; Configuration Space Header
;--------------------------------------------------------------------------
CMD_IO_SPACE             equ     BIT_0
CMD_MEMORY_SPACE         equ     BIT_1
CMD_BUS_MASTER           equ     BIT_2
CMD_SPECIAL_CYCLES       equ     BIT_3
CMD_MEM_WRT_INVALIDATE   equ     BIT_4
CMD_VGA_PALLETTE_SNOOP   equ     BIT_5
CMD_PARITY_RESPONSE      equ     BIT_6
CMD_WAIT_CYCLE_CONTROL   equ     BIT_7
CMD_SERR_ENABLE          equ     BIT_8
CMD_BACK_TO_BACK         equ     BIT_9

;--------------------------------------------------------------------------
; PCI Status Register Bit Definitions
; Configuration Space Header
;--------------------------------------------------------------------------
STAT_BACK_TO_BACK        equ     BIT_7
STAT_DATA_PARITY         equ     BIT_8
STAT_DEVSEL_TIMING       equ     BIT_9 OR BIT_10
STAT_SIGNAL_TARGET_ABORT equ     BIT_11
STAT_RCV_TARGET_ABORT    equ     BIT_12
STAT_RCV_MASTER_ABORT    equ     BIT_13
STAT_SIGNAL_MASTER_ABORT equ     BIT_14
STAT_DETECT_PARITY_ERROR equ     BIT_15

;--------------------------------------------------------------------------
; PCI Base Address Register For Memory (BARM) Bit Definitions
; Configuration Space Header
;--------------------------------------------------------------------------
BARM_LOCATE_BELOW_1_MEG  equ     BIT_1
BARM_LOCATE_IN_64_SPACE  equ     BIT_2
BARM_PREFETCHABLE        equ     BIT_3

;--------------------------------------------------------------------------
; PCI Base Address Register For I/O (BARIO) Bit Definitions
; Configuration Space Header
;--------------------------------------------------------------------------
BARIO_SPACE_INDICATOR    equ     BIT_0

;--------------------------------------------------------------------------
; PCI BIOS Definitions
; Refer To The PCI BIOS Specification
;--------------------------------------------------------------------------
;- Function Code List

;IFE  NWSERVER
;;- Server can use the defines in ODI.INC
;PCI_FUNCTION_ID          equ     0B1h         ;- AH Register
;PCI_BIOS_PRESENT         equ     01h          ;- AL Register
;FIND_PCI_DEVICE          equ     02h          ;- AL Register
;FIND_PCI_CLASS_CODE      equ     03h          ;- AL Register
;GENERATE_SPECIAL_CYCLE   equ     06h          ;- AL Register
;READ_CONFIG_BYTE         equ     08h          ;- AL Register
;READ_CONFIG_WORD         equ     09h          ;- AL Register
;READ_CONFIG_DWORD        equ     0Ah          ;- AL Register
;WRITE_CONFIG_BYTE        equ     0Bh          ;- AL Register
;WRITE_CONFIG_WORD        equ     0Ch          ;- AL Register
;WRITE_CONFIG_DWORD       equ     0Dh          ;- AL Register
;ENDIF

; Function Return Code List
SUCCESSFUL               equ     00h
FUNC_NOT_SUPPORTED       equ     81h
BAD_VENDOR_ID            equ     83h
DEVICE_NOT_FOUND         equ     86h
BAD_REGISTER_NUMBER      equ     87h

;- PCI BIOS Calls
PCI_BIOS_INTERRUPT       equ     01Ah         ;- PCI BIOS Int 1Ah Function Call
PCI_PRESENT_CODE         equ     20494350h    ;- Hex Equivalent Of 'PCI '
                                              ;- ASCII Codes for ' ICP'
PCI_PRESENT_CODE_WORD    equ     4350h        ;- Hex Equivalent Of 'CP'
PCI_SERVICE_IDENTIFIER   equ     49435024h    ;- ASCII Codes for 'ICP$'

;- PCI Device and Vendor IDs
;; JL - Removed nic specifics!
;;SPEEDO_DEVICE_ID         equ     1227h
;;SPLASH1_DEVICE_ID        equ     1226h
;;D100_DEVICE_ID           equ     1229h
;;D100_VENDOR_ID           equ     8086h

;- Maximum bus slots supported under Configuration mechanisms 1 and 2
CONFIG1_MAX_PCI_SLOTS    equ     32
CONFIG2_MAX_PCI_SLOTS    equ     16

;- Maximum buses supported
MAX_PCI_BUSES            equ     255

ENDIF


; EOF - $Workfile: PCINIC.INC $
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\amd\bwstruct.inc ===
;====================================================================
; BWSTRUCT.INC
;
; Include for for BootWare, defines common structures.
;
; 970116 PC - first version
;====================================================================

;--------------------------------------------------------------------
; Common equates
;---------------------------------------------------------------------
FEATURE_LOCAL	equ	1
FEATURE_VIRUS	equ	2
FEATURE_MENU	equ	4
FEATURE_KEYWAIT	equ	8
FEATURE_FLOPPY	equ	64
FEATURE_HDRIVE	equ	128

;--------------------------------------------------------------------
; Event Descriptor (ED) Structure
;---------------------------------------------------------------------
IFDEF _IDEAL_
Struc	ED
	Ptr		dw	?	; pointer to next ED
	Unused		dw	?	; spare word
	DestAddr	dw	?, ?, ?	; destination Address
	ErrCode		dw	?	; error code
	ErrMsg		dw	?	; pointer to error msg
	Length		dw	?	; total packet length
	FragCount	dw	?	; number of fragments
	FragOff		dw	?	; 1st fragment offset
	FragSeg		dw	?	; 1st fragment segment
	FragLen 	dw	?	; length of fragment
ends
ELSE
ED_Struct      STRUC
	ED_Ptr		dw	?	; pointer to next ED
	ED_Unused	dw	?	; spare word
	ED_DestAddr	dw	?, ?, ?	; destination address
	ED_ErrCode	dw	?       ; error code
	ED_ErrMsg	dw	?       ; Pointer to error msg
	ED_Length	dw	?	; total packet length
	ED_FragCount	dw	?	; Number of descriptors/fragments
	ED_FragOff	dw	?	; Descriptor Pointer
	ED_FragSeg	dw	?	; Descriptor Pointer
	ED_FragLen 	dw	?	; Length of packet descriptor
ED_Struct      ENDS
ENDIF

;--------------------------------------------------------------------
; Descricptor Structure
;---------------------------------------------------------------------
IFDEF _IDEAL_
Struc Frag
	Off		dw	?	; offset of fragment
	Seg		dw	?	; segment of fragment
	Len		dw	?	; length of fragment
ends
ELSE
Frag Struc
	FragOff		dw	?	; offset of fragment
	FragSeg		dw	?	; segment of fragment
	FragLen		dw	?	; length of fragment
Frag ends
Descript_Struct STRUC
	DPointer	dd	?	; Descriptor Pointer
	DLen		dw	?	; Length of packet descriptor
Descript_Struct ends
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c90xb\pci.inc ===
;
; Modifications:   $Header: /Client Boot/NICS/3Com/3C90xB/UNDI/PCI.INC 2     22/07/98 8:30p John Lobraico $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;

ifndef _PCI_INC
_PCI_INC = 1

; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
; Structures and records
;


; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
; Equates
;

PCI_IRQ_LINE	equ	3Ch


; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
; Macros
;

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; PCI_READ_BYTE
;	Read one byte from PCI configuration space.
;
; passed:
;	BH := PCI bus number
;	BL := PCI device (bits 7-3) & function (bits 2-0) numbers
;	DI := Offset into PCI configuration space (00h to FFh)
;
; returns:
;	SUCCESS
;		CY := 0
;		AH := 0
;		CL := Byte read from PCI configuration space
;
;	FAILURE
;		CY := 1
;		AH := 81h (Unsupported function)
;		AH := 87h (Bad PCI register number)
;
PCI_READ_BYTE macro
	mov	ax, 0B108h
	int	1Ah
	endm

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; PCI_READ_WORD
;	Read one word from PCI configuration space.
;
; passed:
;	BH := PCI bus number
;	BL := PCI device (bits 7-3) & function (bits 2-0) numbers
;	DI := Offset into PCI configuration space (00h to FEh)
;
; returns:
;	SUCCESS
;		CY := 0
;		AH := 0
;		CX := Word read from PCI configuration space
;
;	FAILURE
;		CY := 1
;		AH := 81h (Unsupported function)
;		AH := 87h (Bad PCI register number)
;
PCI_READ_WORD macro
	mov	ax, 0B109h
	int	1Ah
	endm

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; PCI_READ_DWORD
;	Read one dword from PCI configuration space.
;
; passed:
;	BH := PCI bus number
;	BL := PCI device (bits 7-3) & function (bits 2-0) numbers
;	DI := Offset into PCI configuration space (00h to FCh)
;
; returns:
;	SUCCESS
;		CY := 0
;		AH := 0
;		ECX := Dword read from PCI configuration space
;
;	FAILURE
;		CY := 1
;		AH := 81h (Unsupported function)
;		AH := 87h (Bad PCI register number)
;
PCI_READ_DWORD macro
	mov	ax, 0B10Ah
	int	1Ah
	endm


endif ;_PCI_INC

; EOF - $Workfile: PCI.INC $
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c90xb\spdosegs.inc ===
; Modifications:   $Header: /Client Boot/NICS/3Com/3C90xB/UNDI/SPDOSEGS.INC 2     22/07/98 8:30p John Lobraico $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;
;   Description: segment declaration and ordering for NDIS driver
;-----------------------------------------------------------------------
; Functional Description
;
;   This file defines the segments used by a MAC driver and the order
;   in which they are loaded. The groups DGROUP (for data) and CGROUP
;   (for code) are also defined, as are macros to open and close
;   segments (which also set up the default segment assumptions).
;-----------------------------------------------------------------------
; DOS segment definitions and ordering.
;==========================================================================
Ifdef DRV
DevHeaderSeg   segment para public USE16 'CODE'
DevHeaderSeg   ends
Endif	
;--------------------------------------------------------------------------
; Resident Code segment - code that is used after init time
; (unfortunately, this includes code to bind another driver, and
; initializations that take place at bind time) should be placed in this
; segment.
;--------------------------------------------------------------------------
_TEXT       segment para public USE16 'CODE'
_TEXT       ends

Ifdef DRV
ICODE       segment para public USE16 'INIT'
ICODE       ends
ENDIF	
;--------------------------------------------------------------------------
; Resident Data segment - things put here will remain in memory after
; init time. At the present time, this is in low memory, so data that is
; not used after init time should NOT be put in this segment.
;--------------------------------------------------------------------------
_DATA       segment para public USE16 'DATA'
_DATA       ends

Ifdef DRV
_BSS       segment para public USE16 'DATA'
_BSS       ends
IDATA       segment para public USE16 'DATA'
IDATA       ends
Else
_BSS       segment para public USE16 'BSS'
_BSS       ends
ENDIF
;--------------------------------------------------------------------------
; Make sure the segment order defined in this file is respected.
;--------------------------------------------------------------------------
.SEQ               
;--------------------------------------------------------------------------
; DOS Group is all one 64K segment, CS=SS=DS, use equate for DGROUP.
;--------------------------------------------------------------------------
Ifdef DRV
    CGROUP      group   DevHeaderSeg, _TEXT, ICODE
    DGROUP      group   _DATA, _BSS, IDATA
ELSE
    CGROUP      group   _TEXT
    DGROUP      group   _DATA, _BSS
ENDIF	
;--------------------------------------------------------------------------
; Group is 64K data, 64K code, CS!=SS=DS, actual group for Code.
;--------------------------------------------------------------------------
; Assume statement here takes care of for any source, same for OS2 and DOS.
;--------------------------------------------------------------------------
    Assume   CS:CGROUP, DS:DGROUP, ES:NOTHING, SS:NOTHING

START_CODE	macro
_TEXT		segment Public 'Code'
		assume ds:DGroup,cs:cGroup,es:nothing,ss:nothing
		endm

END_CODE	macro
_TEXT		ends
		endm

START_DATA	macro
_Data		segment Public 'Data'
		assume ds:DGroup,cs:CGroup,es:nothing,ss:nothing
		endm

END_DATA	macro
_Data		ends
		endm

; 2 macros by John to let you easily insert data fragments into code
;
; This macro assumes that Code is open, closes it, and opens data.
OPEN_DATA       macro
    END_CODE
    START_DATA
                endm

; This macro closes the open data and re-opens the Code segment.
CLOSE_DATA      macro
    END_DATA
    START_CODE
                endm


; EOF - $Workfile: SPDOSEGS.INC $
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c90xb\pxe_stru.inc ===
;
NUM_MCADDRS    	Equ	8		; max number of multicast addresses.
MAX_DATABLK    	Equ	8		; max number of data blocks supported 
					;	in a descriptor.
MAX_IMMED_LEN	Equ	64		; max immediate data buffer length
MAX_TX_DATABLK	Equ	MAX_DATABLK	; max number of data blocks supported 
					;	in a Tx descriptor.
MAX_TD_DATABLK	Equ	MAX_DATABLK	; max number of TransferData blocks
		
APIMaxFunc	EQU	0011h

ADDR_LEN	EQU	16
ETH_ADDR_LEN	EQU	6
MAXNUM_MCADDR	EQU	8

;
; protocol values in transmit buffer
;
P_UNKNOWN	EQU	0		;; no media header
P_IP	 	EQU	1		;; IP type
P_ARP		EQU	2		;; ARP type
P_RARP		EQU	3		;; RARP type

TYPE_IP	 	EQU	0800h		;; IP type
TYPE_ARP	EQU	0806h		;; ARP type
TYPE_RARP	EQU	8035h		;; RARP type
;
; xmitflag values in transmit buffer
;
PKT_DESTADDR	EQU 0	;; destination address given 
PKT_BROADCAST	EQU 1h	;; use broadcast address 
PKT_MULTICAST	EQU 2h	;; multicast addr given

;; Hardware type values
ETHER_TYPE 		EQU 1
EXP_ETHER_TYPE	EQU 2
IEEE_TYPE  	EQU 6
ARCNET_TYPE   	EQU 7


Eth_MCastBuf	Struc
MCastAddrCount	DW	?
MCastAddr	DB MAXNUM_MCADDR * ETH_ADDR_LEN dup (0)
Eth_MCastBuf	Ends

MC_MCastBuf		Struc
MC_MCastAddrCount	DW	?
MC_MCastAddr  		DB MAXNUM_MCADDR * ADDR_LEN dup (0)
MC_MCastBuf		Ends

NIC_StartUp	Struc
S_Status	DW	?
S_BusType	DB	?
S_AddrType	DB	?
S_DataSeg	DW	?
S_DataSegAddr	DD	?
S_DataSegSize	DW	?
S_CodeSegSize	DW	?
S_BusDevFunc	DW	?	;; PCI Dev_ID
S_PCI_ds_off	dw	?	;; Far pointer to PCI data structure
S_PCI_ds_seg	dw	?
S_PnP_csn	dw	?	; Card select number.-1 for non-PnP BBS device
S_PnP_eh_off	dw	?	; Far pointer to PnP expansion header
S_PnP_eh_seg	dw	?
NIC_StartUp	Ends

NIC_CleanUp	Struc
CL_Status	DW	?
NIC_CleanUp	Ends

NIC_Initialize	Struc
I_Status	DW	?
I_Prot_ini	DD	?
I_RcvInt	DD	?
I_GenInt	DD	?
NIC_Initialize  Ends

NIC_Reset	Struc
R_Status	DW	?
R_MCBuf		MC_MCastBuf <>
NIC_Reset	Ends

NIC_ShutDown	Struc
SD_Status	DW	?
NIC_ShutDown	Ends

NIC_Open	Struc
O_Status	DW	?
O_OpenFlg	DW	?
O_PktFilter	DW	?
O_MCBuf		MC_MCastBuf <>
NIC_Open	Ends

NIC_Close	Struc
C_Status	DW	?
NIC_Close	Ends

X_DataBlock	Struc
X_TxPtrType	DB	?	; 0 => Phys pointer, 1 => GDT pointer
X_TxRsvdByte	DB	?	; Reservered, must be zero.
X_TxDataLen	DW	?	; Data block length in bytes.
X_TxDataPtr	DD	?	; Far pointer to data block.
X_DataBlock Ends

NIC_TBD		Struc
X_Length	DW	?
X_BufOff	DW	?
X_BufSeg	DW	?
X_DataBlkCount	DW	?		; will always be zero for base code
X_DataBlk	DB	MAX_DATABLK * SIZE X_DataBlock dup (0)	
NIC_TBD		Ends

NIC_Transmit		Struc
T_Status		DW	?
T_Protocol		DB	?
T_XmitFlag		DB	?
T_DestAddrOffset 	DW	?	; 16-bit segment & offset of the
T_DestAddrSegment 	DW	?	; destination media address 
T_TBDOffset		DW	?	; 16-bit segment & offset 
T_TBDSegment		DW	?	; transmit buffer descriptor 
T_Reserved		DD	2 dup(0)	; for future use	
NIC_Transmit Ends

NIC_SetMCastAddr	Struc
SM_Status		DW	?
SM_MCBuf		MC_MCastBuf <>
NIC_SetMCastAddr	Ends

NIC_SetStationAddr	Struc
SS_Status		DW	?
SS_StationAddr		DB	ADDR_LEN dup (0)
NIC_SetStationAddr	Ends

NIC_SetPacketFilter	Struc
SP_Status		DW	?
;;SP_NewFilter		DW  ?
SP_NewFilter		DB  ?
;;SP_MCBuf		MC_MCastBuf <>
NIC_SetPacketFilter	Ends

NIC_GetInfo	Struc
GI_Status		DW	?
GI_BaseIo		DW	?
GI_IntNumber		DW	?
GI_MTU			DW	?
GI_HwType		DW	?
GI_HwAddrLen		DW	?
GI_CurrentNodeAddress	DB ADDR_LEN dup (0)
GI_PermNodeAddress	DB ADDR_LEN dup (0)
GI_ROMAddress		DW 	?
GI_RxBufCt		DW	?
GI_TxBufCt		DW	?
NIC_GetInfo	Ends

NIC_GetNICType_pci 	Struc
Status 		DW	?	; OUT: See PXENV_STATUS_xxx constants */ 
NicType 	DB	?	;  /* OUT: 2=PCI, 3=PnP */
Vendor_ID	DW	?	; /* OUT:  */
Dev_ID		DW	?	;  /* OUT:  */
Base_Class	DB	?	; /* OUT: */
Sub_Class	DB	?	;  /* OUT: */
Prog_Intf	DB	?	;  /* OUT: program interface */ 
Rev		DB	?	;  /* OUT: Revision number */ 
BusDevFunc	DW	?	; /* OUT: Bus, Device & Function numbers */
SubSystemId     dd      ?       ; /*OUT: SubsytemId & SubsystemVendorId
NIC_GetNICType_pci 	Ends

NIC_GetNICType_pnp 	Struc
Status 		DW	?	; OUT: See PXENV_STATUS_xxx constants */ 
NicType 	DB	?	;  /* OUT: 2=PCI, 3=PnP */
EISA_Dev_ID	DD	?	; /* Out:  */
Base_Class	DB	?	; /* OUT: */
Sub_Class	DB	?	;  /* OUT: */
Prog_Intf	DB	?	;  /* OUT: program interface */
CardSelNum	DW	?	; /* OUT: Card Selector Number */
Res		DB	0	;
NIC_GetNICType_pnp 	Ends

NIC_GetStatistics	Struc
GS_Status		DW	?
GS_XmtGoodFrames	dd    ?
GS_RcvGoodFrames	dd    ?
GS_RcvCRCErrors		dd    ?
GS_RcvResourceErrors	dd    ?
NIC_GetStatistics	Ends

NIC_ClearStatistics	Struc
CS_Status		DW	?
NIC_ClearStatistics	Ends

NIC_InitDiags	Struc
ID_Status	DW	?
NIC_InitDiags   Ends

NIC_ForceInterrupt	Struc
FI_Status		DW	?
NIC_ForceInterrupt	Ends

NIC_GetMCastAddr	Struc
GM_Status		DW	?
GM_InetAddr		DD	?
GM_HwAddr		DB	ADDR_LEN dup (0)
NIC_GetMCastAddr	Ends

;NIC_API_Entry	Struc
;Signature 	DB	'PXENV+'	;; not null terminated
;Version		DW	0100h		;; 1.0
;StrucLength	DB	0		;; length of this structure
;CheckSum	DB	0		;; fill in later
;rm_entry_off	DW	0		;; real mode driver entry offset
;rm_entry_seg	DW	0		;; real mode driver entry segment
;pm_entry_off	DW	0		;; protected mode driver entry offset
;pm_entry_seg	DW	0		;; protected mode driver entry segment
;NIC_API_Entry	Ends

s_PXENV_ENTRY	Struc
signature	db	6 dup(?)	; 'PXENV+'
ver             dw      ?               ; MSB=major, LSB=minor
bytes		db	?		; sizeof s_pxenv_entry
checksum	db	?		; 8-bit checksum of structure,
					; including this byte shoube be zero.
rm_entry_off	dw	?		; 16-bit real-mode segment & offset.
rm_entry_seg	dw	?
pm_entry_off	dw	?		; 16-bit protected mode 32-bit physical
pm_entry_base	dd	?		; address and 16-bit offset.
stack_sel	dw	?		; PROM stack segment.  Will be set
stack_size	dw	?		; to 0 when removed from memory.
base_cs_sel	dw	?		; Base code segment.  Will be set
base_cs_size	dw	?		; to 0 when removed from memory.
base_ds_sel	dw	?		; Base data segment.  Will be set
base_ds_size	dw	?		; to 0 when removed from memory.
mlid_ds_sel	dw	?		; MLID data segment.
mlid_ds_size	dw	?
mlid_cs_sel	dw	?		; MLID code segment.
mlid_cs_size	dw	?
s_PXENV_ENTRY	Ends

;; Ethernet II protocol header
EtherHeader	Struc
E_DestAddr	DB 6 dup (0)	;; destination ethernet addr
E_SrcAddr	DB 6 dup (0)	;; destination ethernet addr
E_Type		DW  ?	;; protocol type
EtherHeader	Ends

ETHER_HEADER_LEN	Equ	SIZE EtherHeader

; 
; * Data structures for TransmitChain (Tx), TransferData (TD)
; 
TxDataBlock	Struc
TxPtrType	DB	?	; 0 => Phys pointer, 1 => GDT pointer
TxRsvdByte	DB	?	; Reservered, must be zero.
TxDataLen	DW	?	; Data block length in bytes.
TxDataPtr	DD	?	; Far pointer to data block.
TxDataBlock	Ends

; 
; * TransmitChain descriptor structure definition
; 
TxBufDesc	Struc
TxImmedLen	DW	?	; Byte count of immediate data, max=64
TxImmedPtr	DD	?	; Virtual address of Immediate data
TxDataCount	DW	?	; Number of Data Blocks (max = 8)
TxDataBlk	DB	size TxDataBlock * MAX_TX_DATABLK dup(0)
TxBufDesc	Ends

TxBufDescrSize	Equ	Size TxImmedLen + Size TxImmedPtr + Size TxDataCount

; 
; * TransferData data block description
; 
TDDataBlock	Struc
TDPtrType	DB	?	; 0 => Phys pointer, 1 => GDT pointer
TDRsvdByte	DB	?	; Reservered, must be zero.
TDDataLen	DW	?	; Data block length in bytes.
TDDataPtr	DD	?	; Far pointer to data block.
TDDataBlock	Ends

; 
; * TransferData descriptor structure
; 
TDBufDesc	Struc
TDDataCount	DW	?	; No of Data Blocks (max 8 for V1.01).
TDDataBlk	DB	size TDDataBlock*MAX_TD_DATABLK dup(0)
TDBufDesc	Ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\amd\genmacro.inc ===
;
; Modifications:   $Header:   J:/archives/preboot/lsa2/inc/GENMACRO.INV   1.2   19 Sep 1997 21:39:10   MJOHNSOX  $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;

;
;   Description: Generic macros used by all Speedo3 ASM driver
;

IFDEF            GENMACRO_INC
ELSE
GENMACRO_INC     equ       1

;--------------------------------------------------------------------------
; Small/quick way to set a register to NULL, all F's (avoid 32-bit constants).
;--------------------------------------------------------------------------
@NULLPTR macro reg
    xor     reg, reg
    dec     reg
    ENDM

;--------------------------------------------------------------------------
; Port I/O macros
;--------------------------------------------------------------------------
;- 32-bit Output
@OUTPD     MACRO    portid, low, high
.XALL
IFNB       <portid>
    mov    dx, portid
ENDIF
    push   high
    push   low
    pop    eax
    out    dx, eax
.SALL
    ENDM

;- 16-bit Output
@OUTPW     MACRO    portid, value
.XALL
IFNB       <portid>
    mov    dx, portid
ENDIF
IFNB       <value>
    mov    ax, value
ENDIF
    out    dx, ax
.SALL
    ENDM

;- 8-bit Output
@OUTPB     MACRO    portid, value
.XALL
IFNB       <portid>
    mov    dx, portid
ENDIF
IFNB       <value>
    mov    al, value
ENDIF
    out    dx, al
.SALL
    ENDM

;- 32-bit Input
@INPD      MACRO    portid
.XALL
IFNB       <portid>
    mov    dx, portid
ENDIF
    in     eax, dx
.SALL
    ENDM

;- 16-bit Input
@INPW      MACRO    portid
.XALL
IFNB       <portid>
    mov    dx, portid
ENDIF
    in     ax, dx
.SALL
    ENDM

;- 8-bit Input
@INPB      MACRO    portid
.XALL
IFNB       <portid>
    mov    dx, portid
ENDIF
    in     al, dx
.SALL
    ENDM

;--------------------------------------------------------------------------
; Macro @POPF (DESTROYS AX!!!)                   v1.6
;--------------------------------------------------------------------------
@POPF MACRO                                      
    pop     ax      
    test    ax, 200H
    jz      @F      
    sti                
@@:
    ENDM

;--------------------------------------------------------------------------
; FASTCOPY
; Macro to perform fast DWORD memory copy
; Handles data transfers that are not multiples of 4
;--------------------------------------------------------------------------
@FASTCOPY  MACRO
.XALL
    push   cx
    shr    cx, 2
    rep    movsd
    pop    cx
    and    cx, 3
    rep    movsb
.SALL
    ENDM

;--------------------------------------------------------------------------
; REALLY_FASTCOPY
; Macro to perform fast DWORD memory copy, optimized by processor type.
; Handles data transfers that are not multiples of 4, or not dword-aligned.
;
; Each time REALLY_FASTCOPY is invoked, make sure that:
;  - pass macro value returned by "GetCpuType" (=PENTIUM_CPU does special move)
;  - CX has length
;  - ES:EDI points to destination (must clear upper 16 bits under DOS, OS/2)
;  - DS:ESI points to source      (must clear upper 16 bits under DOS, OS/2)
;--------------------------------------------------------------------------
@REALLY_FASTCOPY  MACRO CpuTypeValue
    local   CopyDword, RepCopy, CopyRemainder, CopyByte, Exit
    push    ax                                             ; v1.04
    push    dx                                             ; v1.04

    mov     dx, cx
    cmp     dx, 4
    jb      CopyRemainder

;--------------------------------------------------
;  Align destination to dword boundary
;--------------------------------------------------
    movsd
    sub     dx, 4

    mov     ax, di
    and     ax, 00003h
    sub     di, ax
    sub     si, ax
    add     dx, ax

    cmp     CpuTypeValue, PENTIUM_CPU                      ; v1.04
    jb      RepCopy

;-------------------------------------------------
; Do Pentium Optimized Block Copy
;-------------------------------------------------
    mov     ax, dx
    shr     ax, 2
    jz      CopyRemainder

CopyDword:
    movsd
    dec     ax
    jnz     CopyDword
    jmp     CopyRemainder

;-------------------------------------------------
; Do i386 and i486 Optimized Block Copy
;-------------------------------------------------
RepCopy:
    mov     cx, dx
    shr     cx, 2
    rep     movsd

;------------------------------------------------
; Copy any remaining bytes
;------------------------------------------------
CopyRemainder:
    mov     ax, dx
    and     ax, 00003h
    jz      Exit

CopyByte:
    movsb
    dec     ax
    jnz     CopyByte

Exit:
    pop     dx                                             ; v1.04
    pop     ax                                             ; v1.04
    ENDM

;--------------------------------------------------------------------------
; SLOW
; Macro to delay execution
; Processor speed independent. Executes an I/O to the keyboard port.  We
; use port 61h and not port 60h, because polling 60h can cause the
; "crazy mouse" problem under windows.
;--------------------------------------------------------------------------
@SLOW      MACRO
.XALL
    push   ax
    in     al,61h
    pop    ax
.SALL
    ENDM

;--------------------------------------------------------------------------
; READ_TICK_COUNTER
; This macro reads the 16-bit Timer Tick Count register 
; (8254 System Board Timer 0).
; The count register decrements by 2 (even numbers) every 838ns.
;
; Entry:    Interrupts disabled
;
; Exit:     AX with the current count
;           Interrupts disabled
;--------------------------------------------------------------------------
@READ_TICK_COUNTER     MACRO
;- Setup 8254 To Latch T0's Current Count
    xor     al, al
    out     43h, al
;- Read The Latched Counter Value, LSB First and MSB Next
    in      al, 40h
    mov     ah, al
    in      al, 40h
;- Swap The Counter Bytes To Correct Format
    xchg    al, ah
    ENDM


;--------------------------------------------------------------------------
; DELAY 
; This macro inserts a delay of specified milliseconds. 
;
; Entry:    Interrupts disabled
;
; Exit:     AX , CX destroyed
;           Interrupts disabled
;--------------------------------------------------------------------------
@DELAY MACRO MSEC
    local   Delay_Loop

    @READ_TICK_COUNTER
    mov     cx, ax
Delay_Loop:
    @READ_TICK_COUNTER
    neg     ax
    add     ax, cx
    cmp     ax, MSEC
    jb      Delay_Loop
    ENDM

;--------------------------------------------------------------------------
; INC32  
; This macro increments a 32 bit counter. 
;
; Entry:    Interrupts disabled
;
; Exit:     AX , CX destroyed
;           Interrupts disabled
;--------------------------------------------------------------------------
@INC32      MACRO     num32
    add     word ptr num32[0], 1
    adc     word ptr num32[2], 0
    ENDM

;--------------------------------------------------------------------------
; @FATAL
;
; Description : Macro to Halt execution (TRAP) in case of Fatal error
;
; Entry       : none
;
; Exit        : none
;--------------------------------------------------------------------------
@FATAL     MACRO 
    int 3
    ENDM

;--------------------------------------------------------------------------
; @INT3BP
;
; Description : inserts an INT 3 in way that is easy to find with an editor.
;
; Entry       : none
;
; Exit        : none
;
;--------------------------------------------------------------------------
@INT3BP macro
    Int    3
endm


;--------------------------------------------------------------------------
; @BP_IFDEBUG
; Description : inserts an INT 3 instruction if debug switch has been set.
;
; Entry       : none
;
; Exit        : none
;
;--------------------------------------------------------------------------
@BP_IFDEBUG macro
IF  DEBUG_BP
    @INT3BP
ENDIF    
endm

ENDIF


; EOF - $Workfile:   genmacro.inc  $
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\amd\eep15.inc ===
;************************************************************************;
;*									*;
;*			EEP15.INC					*;
;*									*;
;*  EEPROM configuration routines for the ATI AT-1500 Adapters.		*;
;*									*;
;*  Copyright (c) 1992, 1993, Allied Telesis, Inc.  All Rights Reserved.*;
;*									*;
;************************************************************************;

; Bit definitions for the PCNetISA "Vendor Specific Word", which on the
; AT-1500 controls the on-board serial EEPROM (National Semiconductor NMC95C12).
DATA_IN		equ	001h	; EEPROM serial data in (DI) - write/only
CLOCK		equ	002h	; EEPROM serial clock (SK) - write/only
DATA_OUT	equ	004h	; EEPROM serial data out - read/only
CHIP_SEL	equ	008h	; EEPROM Chip Select - write/only
JUMPER_STATE	equ	008h	; Alternate Address Jumper state - read/only

; EEPROM command codes.
READ		equ	80h	; Read EEPROM memory at specified address
WEN		equ	30h	; Write Enable
WRITE		equ	40h	; Write EEPROM memory at specified address
WRALL		equ	10h	; Write to all EEPROM locations
WDS		equ	00h	; Write Disable

SB		equ	01h	; "Start Bit" (command follows)
ADDR_MASK	equ	3Fh	; EEPROM memory address mask

; EEPROM locations used for AT-1500 configuration data (all are word addresses):
BOARD_TYPE_LOC		equ	0	; ASCII product name:  12 bytes
BOARD_REV_LOC		equ	6	; board rev. level:  low-order byte
BOARD_SUBTYPE_LOC	equ	6	; board subtype code:  high-order byte
FLAG_WORD_LOC		equ	32	; Flag bits - see below
Off_33_1500		equ	33	; Bit 13,14,15 reserved for Lanworks
SCR_SAVE_ADDR		equ	61	; SCR (below) power-up value save loc.
SCR_ADDR		equ	62	; "Switch Configuration Register"
SRR_ADDR		equ	63	; "Switch Readback Register"

; Configuration values for the SCR and the SCR_SAVE (word locations 61 & 62):
IRQ_MASK	equ	0003h		; bits  0-3  (switch 1): IRQ: see below
DMA_MASK	equ	0030h		; bits  4-7  (switch 2): DMA: see below
IO_BASE_MASK	equ	0300h		; bits  8-11 (switch 3): IO: see below
BOOT_EN_MASK	equ	1000h		; bits 12-15 (switch 4): BOOT: see below
MAU_SEL_MASK	equ	2000h		; bits 12-15 (switch 4): PORT: see below

; SCR Bits 0-3:  IRQ configuration:
IRQ_CHOICE_A	equ	0000h
IRQ_CHOICE_B	equ	0001h
IRQ_CHOICE_C	equ	0002h
IRQ_CHOICE_D	equ	0003h
IRQ_3		equ	IRQ_CHOICE_A
IRQ_4		equ	IRQ_CHOICE_B
IRQ_5		equ	IRQ_CHOICE_C
IRQ_9		equ	IRQ_CHOICE_D
IRQ_10		equ	IRQ_CHOICE_A		; AT-1500xx-20 only
IRQ_11		equ	IRQ_CHOICE_B		; AT-1500xx-00/01/20 only
IRQ_12		equ	IRQ_CHOICE_C		; AT-1500xx-30 only
IRQ_14		equ	IRQ_CHOICE_C		; AT-1500xx-20 only
IRQ_15		equ	IRQ_CHOICE_D		; AT-1500xx-00/01/20 only

; SCR Bits 4-7:  DMA configuration:
DMA_3		equ	0000h
DMA_5		equ	0010h
DMA_6		equ	0020h
DMA_7		equ	0030h

; SCR Bits 8-11:  IO BASE configuration:
BASE_IO_300	equ	0000h
BASE_IO_320	equ	0100h
BASE_IO_340	equ	0200h
BASE_IO_360	equ	0300h

; SCR Bits 12-15:  BOOT PROM and PORT SELECTION configuration:
BOOT_ENA	equ	1000h		; bit 12 = 1:  Enable boot PROM
BOOT_DIS	equ	0000h		; bit 12 = 0:  Disable boot PROM
UTP_PORT	equ	2000h		; bit 13 = 1:  Select UTP Port
OTHER_PORT	equ	0000h		; bit 13 = 0:  Select "Other" Port

; Flag Word (location 32):
AUTO_SENSE_BIT	equ	0001h
BOOT_PROTOCOL	equ	0006h		; type of boot prom protocol:
;951030	BOOT_NCP	equ	0002h	; use Novell Netware NCP (IPX)
;951030	BOOT_RPL	equ	0004h	; use IBM/Microsoft Remote Program Load
;951030	BOOT_BOOTP	equ	0006h	; use TCP/IP BOOTP and TFTP
;951030	BOOT_OTHER	equ	0000h	; use some other protocol
;951124	BOOT_NW_8023	equ	0000h	; use NetWare with IEEE 802.3
;951124	BOOT_NW_8022	equ	0002h	; use NetWare with IEEE 802.2
;951124	BOOT_NW_8137	equ	0004h	; use NetWare with Ethernet II
;951124	BOOT_RPL	equ	0006h	; use IBM/Microsoft Remote Program Load


; Off_33_1500 (location 33 Bit 13,14,15)
BOOT1500_PROT	equ	0e000h		; type of BootProtocol (bit 11,12,13)
        BOOT1500_NW_8023        equ     0000h   ; use NetWare with IEEE 802.3
        BOOT1500_NW_8022        equ     02000h  ; use NetWare with IEEE 802.2
        BOOT1500_NW_8137        equ     04000h  ; use NetWare with Ethernet II
        BOOT1500_RPL            equ     06000h  ; use RPL
        BOOT1500_BOOTP          equ     08000h  ; BOOTP
        BOOT1500_BOOTP_ARP      equ     0a000h  ; BOOTP/ARP


; Board "Subtypes" (location 6):
SUBTYPE_00	equ	1
SUBTYPE_10	equ	2
SUBTYPE_20	equ	3
SUBTYPE_01	equ	4
SUBTYPE_30	equ	5

; PCNetISA I/O Ports:
ADDR_PROM_OFFSET	equ	0	; MAC (datalink) Address PROM
RDP_OFFSET		equ	16	; Register Data Port
RAP_OFFSET		equ	18	; Register Address Port
ISACR_OFFSET		equ	22	; ISA-Bus Control Register
VSW_OFFSET		equ	24	; Vendor Specific Word

ISACR2		equ	2		; ISACR2 (out RAP register == ISACR2)
MC_UTP_OTHER	equ	001h		; value to select UTP or "Other" port
MC_AUTO_SEL	equ	002h		; value to select "Auto Select" function

; Possible AT-1500 IRQ choices (varies depending on board "subtype"):
IRQ_RANGE	MACRO	range_name, irq_a, irq_b, irq_c, irq_d
range_name	equ	(irq_a SHL 12) + (irq_b SHL 8) + (irq_c SHL 4) + irq_d
		ENDM
	IRQ_RANGE  LOW_IRQ_RANGE,     3,  4,  5,  9	; all except Subtype 30
	IRQ_RANGE  HIGH_IRQ_RANGE,   10, 11, 14, 15	; all except Subtype 30
	IRQ_RANGE  MIXED_IRQ_RANGE,   3, 11,  5, 15	; all except Subtype 30
	IRQ_RANGE  LOWER_IRQ_RANGE,   3,  4,  5,  9	; Subtype 30, BOOT_ENA=0
	IRQ_RANGE  UPPER_IRQ_RANGE,  10, 11, 12, 15	; Subtype 30, BOOT_ENA=1


Delay_750	proc	near
	push	cx
	mov	cx, 8

DELAY_750_Lp:
	loop	DELAY_750_Lp

	pop	cx
	ret
Delay_750	endp

DELAY_250 MACRO
	; times 2 = at least 400ns on a 40Mhz 386
	; times 4 = at least 400ns on an 80Mhz 386 (!!)
	jmp short $+2
	jmp short $+2
	jmp short $+2
	jmp short $+2
	ENDM


DEBUG_DISPLAY MACRO	display_char
	push	AX
	push	DX
	mov	AH, 02h
	mov	DL, '<'
	int	21h
	mov	DL, display_char
	int	21h
	mov	DL, '>'
	int	21h
	pop	DX
	pop	AX
	ENDM

;************************************************************************;
;*									*;
;*  VerifyBoard 							*;
;*	Function: Read the configuration of the AT-1500 board.		*;
;*	Input:	DI = base I/O address of the AT-1500 board.		*;
;*	Output: stc (carry set) if not an AT-1500 or config error;	*;
;*		clc (carry clear) if successful, and:			*;
;*			BH = configured DMA channel.			*;
;*			BL = configured IRQ.				*;
;*			CX = value to be output to the ISACR2 register. *;
;*		Other registers used are preserved.			*;
;*									*;
;************************************************************************;

VerifyBoard proc	near

	push	AX			; save caller's registers
	push	DX

	; Verify that this really is an AT-1500 board.
	mov	DX, DI			; DX = address prom I/O address
	in	AX, DX			; read the first 2 bytes of MAC address
	cmp	AX, 0			; it better be 0000
	je	VB_go_on
	 jmp	scr_error
VB_go_on:
	add	DX, 2
	in	AX, DX			; read the next 2 bytes of MAC address
	cmp	AL, 0F4h		; the third byte better be F4
	je	VB_its_ours
	 jmp	scr_error
VB_its_ours:
	;  Read the SCR to get the state of the configuration "switches".
	mov	BX, SCR_ADDR
	call	rd_oper 		; read the Switch Configuration Register
	mov	DX, AX			; save SCR value for later
	mov	CX, AX			; save SCR value for later

	;  Read this board's rev level and "subtype" codes.
	mov	BX, BOARD_REV_LOC	; read "board rev code" at EEPROM loc 6
	call	rd_oper 		; AL=rev level code, AH=Subtype code

	;  Determine the configured IRQ and return this value in BL.
	cmp	AH, SUBTYPE_30		; is this a Subtype 30 (8 IRQ) board ?
	 jne	VB_not_st30		;   no

	cmp	AL, 00h 		; is this an early-rev board ?
	 je	VB_jumper_normal	;    yes - ignore jumper
	cmp	AL, 0FFh		; is this an early-rev board ?
	 je	VB_jumper_normal	;    yes - ignore jumper
	mov	DX, DI
	add	DX, VSW_OFFSET
	in	AL, DX			; read the VSW to get the jumper state

    mov DX, CX		    ; Restore register value
	test	AL, JUMPER_STATE	; are both jumpers J1/J2 "in" (NORMAL) ?
	 jnz	VB_jumper_normal	;   yes
	; Alternate Address Mode is jumpered - adjust things.
	mov	BL, 9			; yes, assume 320/9
	cmp	DI, 320h
	 je	got_irq
	mov	BL, 5			; ... or 340/5
	cmp	DI, 340h
	 je	got_irq
	mov	BL, 10			; ... or 360/10
	jmp	got_irq
  VB_jumper_normal:
	mov	BX, UPPER_IRQ_RANGE	; jumper normal:  assume upper IRQs

	test	DX, BOOT_ENA		; is it using the upper range of IRQs?
	 jnz	got_irq_range		;   yes
	mov	BX, LOWER_IRQ_RANGE	; no, uses lower range of IRQs
	jmp	got_irq_range

  VB_not_st30:
	mov	BX, HIGH_IRQ_RANGE	; (assume this is a Subtype 20 board)
	cmp	AH, SUBTYPE_20		; is this a Subtype 20 board ?
	 je	got_irq_range		;   yes, uses High range of IRQ choices
	mov	BX, MIXED_IRQ_RANGE
	cmp	AH, SUBTYPE_00		; is this a Subtype 00 board ?
	 je	got_irq_range		;   yes, uses Mixed range of IRQ choices
	cmp	AH, SUBTYPE_01		; is this a Subtype 01 board ?
	 je	got_irq_range		;   yes, uses Mixed range of IRQ choices
	mov	BX, LOW_IRQ_RANGE	; must be Subtype 10: uses Low IRQ range
  got_irq_range:
	mov	AX, DX			; get the SCR value again
	and	AX, IRQ_MASK		; isolate IRQ configuration bits
	mov	CL, 12
	cmp	AX, IRQ_CHOICE_A	; switch based upon on of 4 IRQ choices
	 je	got_irq_choice
	mov	CL, 8
	cmp	AX, IRQ_CHOICE_B
	 je	got_irq_choice
	mov	CL, 4
	cmp	AX, IRQ_CHOICE_C
	 je	got_irq_choice
	xor	CL, CL
	cmp	AX, IRQ_CHOICE_D
	 je	got_irq_choice
	jmp	scr_error
  got_irq_choice:
	shr	BX, CL			; compute actual IRQ value
	and	BL, 0Fh 		;   and return in register BL
got_irq:

	;  Determine the configured DMA channel and return this value in BH.
	mov	AX, DX			; get the SCR value again
	and	AX, DMA_MASK		; isolate DMA channel configuration bits
	mov	BH, 3
	cmp	AX, DMA_3		; is it DMA channel 3 ?
	 je	got_dma 		;    yes
	mov	BH, 5
	cmp	AX, DMA_5		; is it DMA channel 5 ?
	 je	got_dma 		;    yes
	mov	BH, 6
	cmp	AX, DMA_6		; is it DMA channel 6 ?
	 je	got_dma 		;    yes
	mov	BH, 7
	cmp	AX, DMA_7		; is it DMA channel 7 ?
	 je	got_dma 		;    yes
	jmp	scr_error
got_dma:

	;  Determine the proper value to be used for ISACR2 and return it in CX.
	mov	CX, 0001h		; assume ISACR2 = XMAUSEL (ext. hdw)
	test	DX, UTP_PORT		; check SCR value: is "UTP" selected ?
	 jz	got_mau 		;   no, "Other" port (BNC/FOIRL/AUI)
	push	bx
	mov	BX, Off_33_1500	; not the "other" port, but ...
	call	rd_oper 		; read the flag word from the EEPROM
	pop	bx
	test	AX, AUTO_SENSE_BIT	; is "Auto Select" configured ?
	 jz	got_mau 		;   no, must be the UTP port
	mov	CX, 0002h		; yes, ISACR2 = ASEL (Auto Select)
got_mau:

	clc				; set CF=0 == "success"
	pop	dx			; restore caller's registers
	pop	ax
	ret				; return to caller

scr_error:
	stc				; set CF=1 == "error"
	pop	dx			; restore caller's registers
	pop	ax
	ret				; return to caller

VerifyBoard endp


;************************************************************************;
;*									*;
;*  rd_oper								*;
;*	Function: do a complete word READ operation.			*;
;*	Input:	BX = EEPROM address to be read.				*;
;*		DI = base I/O address of the AT-1500 board		*;
;*	Output: AX = data read from EEPROM.				*;
;*		registers used are preserved				*;
;*									*;
;************************************************************************;
public	rd_oper
rd_oper proc	near

	push	bx		; save caller's registers
	push	cx
	push	dx
	mov	cx, bx

	call	pulse_cs	; pulse CS to terminate any previous command
	call	prep_load	; prepare the EEPROM for a new command
	mov	dx, SB
	call	wr_bit		; write a Start Bit
	mov	dl, READ
	and	cl, ADDR_MASK
	or	dl, cl
	call	wr_byte		; write a READ command code with the address

	xor	bx, bx		; bx = data read
	mov	cx, 16		; reading 16 bits
rd_next_bit1:
	shl	bx, 1
	call	rd_bit		; read a bit
	or	bx, ax		; merge it with accumulated bits so far
	loop	rd_next_bit1

	call	pulse_cs	; pulse CHIP SELECT to terminate the command
	mov	ax, bx		; return EEPROM value in AX
	pop	dx		; restore caller's registers
	pop	cx
	pop	bx
	ret			; return to caller

rd_oper endp

;************************************************************************;
;*									*;
;*  rd_bit								*;
;*	Function: Read 1 bit from the eeprom DO pin.			*;
;*	Input:	AX = the least significant bit (bit 0) is the data bit	*;
;*			read.						*;
;*		DI = base I/O address of the AT-1500 board		*;
;*	Output: nothing							*;
;*		registers used are preserved				*;
;*									*;
;************************************************************************;
public	rd_bit
rd_bit	proc	near

	push	dx
	xor	ax, ax
	mov	al, CHIP_SEL
	or	al, CLOCK
	mov	dx, DI
	add	dx, VSW_OFFSET
	out	dx, al		; make CLOCK go high

	in	al, dx		; read D0
	and	al, DATA_OUT
	call 	DELAY_750	; chip requires about 750ns hold time here

	push	ax
	mov	al, CHIP_SEL
	out	dx, al		; make CLOCK go low again
	pop	ax

	shr	ax, 1
	shr	ax, 1		; return DO in LSB (bit 0) of AX
	pop	dx
	ret

rd_bit	endp


;************************************************************************;
;*									*;
;*  wr_byte								*;
;*	Function: Write a byte to the eeprom.				*;
;*	Input:	DL = data byte to be written.				*;
;*		DI = base I/O address of the AT-1500 board.		*;
;*	Output:	nothing							*;
;*		registers used are preserved				*;
;*									*;
;************************************************************************;
public	wr_byte
wr_byte proc	near

	push	ax			; save caller's registers
	push	cx

	mov	al, dl
	mov	cx, 8
next_bit:
	rol	al, 1
	mov	dl, al
	and	dl, 01h			; DL bit 0 = bit to write
	call	wr_bit			; write one bit of the byte
	loop	next_bit		; loop to write all bits

	pop	cx			; restore caller's registers
	pop	ax
	ret				; return to caller

wr_byte endp

;************************************************************************;
;*									*;
;*  wr_bit								*;
;*	Function: Write a bit to the EEPROM Data In pin.		*;
;*	Input:	DL = the least significant bit (bit 0) is the data bit	*;
;*			to be written.					*;
;*		DI = base I/O address of the AT-1500 board.		*;
;*	Output: nothing							*;
;*		registers used are preserved				*;
;*									*;
;************************************************************************;
public	wr_bit
wr_bit	proc	near

	push	ax		; save caller's registers
	push	bx
	push	dx
	mov	bl, dl
	mov	al, CHIP_SEL
	and	bl, 01h
	or	al, bl
	mov	dx, DI
	add	dx, VSW_OFFSET
	out	dx, al		; write CS and DI out
	or	al, CLOCK
	out	dx, al		; present data bit with CLOCK high
	call	DELAY_750		; chip requires about 750ns hold time here
	mov	al, CHIP_SEL
	out	dx, al		; make the CLOCK go low again

	pop	dx		; restore registers
	pop	bx
	pop	ax
	ret			; return to caller

wr_bit	endp

;************************************************************************;
;*									*;
;*  cs_low								*;
;*	Function: to make the Chip Select pin in the EEPROM go low.	*;
;*	Input:	DI = base I/O address of the AT-1500 board		*;
;*	Output: nothing							*;
;*		registers used are preserved				*;
;*									*;
;************************************************************************;
public	cs_low
cs_low	proc	near

	push	ax		; save caller's registers
	push	dx
	mov	dx, DI
	add	dx, VSW_OFFSET
	xor	ax, ax
	out	dx, al		; turn off CHIP SELECT
	DELAY_250		; chip requires about 250ns between instructions
	pop	dx		; restore caller's registers
	pop	ax
	ret			; return to caller

cs_low	endp

;************************************************************************;
;*									*;
;*  cs_high								*;
;*	Function: to make the Chip Select pin in the EEPROM go high.	*;
;*	Input:	DI = base I/O address of the AT-1500 board		*;
;*	Output: nothing							*;
;*		registers used are preserved				*;
;*									*;
;************************************************************************;
public	cs_high
cs_high	proc	near

	push	ax		; save caller's registers
	push	dx
	mov	dx, DI
	add	dx, VSW_OFFSET
	mov	al, CHIP_SEL
	out	dx, al		; turn on CHIP SELECT
	pop	dx		; restore caller's registers
	pop	ax
	ret			; return to caller

cs_high	endp

; Code is moved from  AT1500.ASM. EEPROM code specific to AT-1500

;************************************************************************;
;*									*;
;*  prep_load								*;
;*	Function: Generate one clock cycle as required before sending	*;
;*			a new command code to the EEPROM.		*;
;*	Input:	DI = base I/O address of the AT-1500 board		*;
;*	Output: nothing 						*;
;*		registers used are preserved				*;
;*									*;
;************************************************************************;
public	prep_load
prep_load	proc	near

		mov	al, CHIP_SEL + CLOCK
		call	OutVSW
		and	al, NOT CLOCK
		call	OutVSW

		ret				; return to caller

prep_load	endp

;************************************************************************;
;*									*;
;*  pulse_cs								*;
;*	function: to make CS pin in the eeprom go low for a short time, *;
;*		  then go high again (required between commands).	*;
;*	input:	DI = base I/O address of the AT-1500 board		*;
;*	output: nothing 						*;
;*		registers used are preserved				*;
;*									*;
;************************************************************************;
public	pulse_cs
pulse_cs	proc	near

	pushf			; save interrupt state
	cli			; disable interrupts
	xor	ax, ax
	call	OutVSW
	mov	al, CHIP_SEL
	call	OutVSW
	popf			; re-enable interrupts (if they were enabled)
	ret			; return to caller

pulse_cs	endp


;************************************************************************;
; OutVSW	output a byte to VSW. Save space.
; Input:	DI = base I/O address of the AT-1500
;		AL = byte to output
;************************************************************************;
public	OutVSW
OutVSW	proc	near

	push	dx
	mov	dx, DI
	add	dx, VSW_OFFSET
	out	dx, al		; turn on CHIP SELECT
	call	Delay_750
	pop	dx		; restore caller's registers
	ret			; return to caller

	ret
OutVSW	endp

; Copied from Config15.ASM from Allied Telesis DDK
;************************************************************************;
;*									*;
;*  wr_oper								*;
;*	Function: do a complete word WRITE operation.			*;
;*	Input:	DX = data word to be written.				*;
;*		BX = address of the word to be written. 		*;
;*		DI = base I/O address of the AT-1500 board.		*;
;*	Output: nothing 						*;
;*		registers used are preserved				*;
;*									*;
;************************************************************************;
public	wr_oper
wr_oper proc	near

	push	bx		; save caller's registers
	push	dx

	call	pulse_cs	; 930928 pulse CS to terminate any previous command
	call	prep_load	; prepare the EEPROM for a new command
	mov	dx, SB
	call	wr_bit		; write a Start Bit
	mov	dl, WRITE
	and	bl, ADDR_MASK
	or	dl, bl
	call	wr_byte 	; write a WRITE command code with the address
	pop	dx		; pop caller's data word to be written
	push	dx		; (save it again)
	call	wr_word 	; write the caller's data word

	pop	dx		; restore caller's registers
	pop	bx
	cmp	bx, SCR_ADDR	; did we just write to the SCR ?
	 je	wo1		;   yes, not a real EEPROM location - don't wait
	call	wait_for_write	; no, wait for EEPROM write cycle to complete
	call	pulse_cs	; pulse CHIP SELECT to terminate the command
wo1:
	ret			; return to caller

wr_oper endp

;************************************************************************;
;*									*;
;*  wr_word								*;
;*	Function: Write a word to the eeprom.				*;
;*	Input:	DX = data word to be written.				*;
;*		DI = base I/O address of the AT-1500 board		*;
;*	Output: nothing 						*;
;*		registers used are preserved.				*;
;*									*;
;************************************************************************;
public		wr_word
wr_word proc	near

	xchg	dl, dh
	call	wr_byte 		; write the high-order byte first
	xchg	dl, dh
	call	wr_byte 		; write the low-order byte next
	ret				; return to caller

wr_word endp

;************************************************************************;
;*									*;
;*  wait_for_write							*;
;*	Function: to wait and check for write operation to complete.	*;
;*	Input:	DI = base I/O address of the AT-1500 board		*;
;*	Output: nothing 						*;
;*		registers used are preserved				*;
;*									*;
;************************************************************************;
public	wait_for_write
wait_for_write	proc	near

	push	ax
	push	dx
	mov	dx, DI
	add	dx, VSW_OFFSET
	pushf			; save interrupt state
	cli			; disable interrupts - timing below important
	xor	ax, ax
	out	dx, al		; drop CHIP SELECT
	jmp	$+2
	jmp	$+2		; dally a bit
	jmp	$+2
	mov	al, CHIP_SEL
	out	dx, al		; turn on CHIP SELECT again
	popf			; re-enable interrupts (if they were enabled)
	call	DELAY_750	; chip requires min. 500ns before status valid
wait_til_write_completes:
	in	al, dx
	test	ax, DATA_OUT	; is the write complete yet ?
	 jz	wait_til_write_completes  ; no - wait
    write_has_completed:

	pop	dx
	pop	ax
	ret

wait_for_write	endp

;************************************************************************;
;*									*;
;*  wr_enable								*;
;*	function: to do WREN operation (Write Enable).			*;
;*	input:	DI = base I/O address of the AT-1500 board		*;
;*	output: nothing 						*;
;*		registers used are preserved				*;
;*									*;
;************************************************************************;
public		wr_enable
wr_enable	proc	near

	push	dx
	call	prep_load	;wait for 1 clock cycle
	mov	dx, SB		;write Start Bit
	call	wr_bit
	mov	dx, WEN
	call	wr_byte
	call	pulse_cs
	pop	dx
	ret

wr_enable	endp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\amd\drvseg.inc ===
;----------------------------------------------------------------------
; DRVSEG.INC
;
; Segment definitions for all BootWare ROMs.
;
; 961226 PC - added Code_NID and Code_NAD, changed alignments to para
;	    - added IDEAL mode support
; 960105 PC - added INIT segment
; 951030 PC
;----------------------------------------------------------------------
IFDEF _IDEAL_
Group	cGroup _Text
DGROUP equ <Cgroup>
	assume	cs:cGroup, ds:cGroup, es:nothing,ss:nothing

; Define segment macros for ideal mode

Macro	START_INIT
Segment	Code Public "Code"
	assume ds:cGroup,cs:cGroup,es:nothing,ss:nothing
endm

Macro	END_INIT
ends
endm

Macro	START_NAD
Segment	Code Public "Code"
	assume ds:cGroup,cs:cGroup,es:nothing,ss:nothing
endm

Macro	END_NAD
ends
endm

Macro	START_CODE
;Segment	Code Public "Code"
Segment _TEXT  para public "CODE"
	assume ds:dGroup,cs:cGroup,es:nothing,ss:nothing
endm

Macro	END_CODE
ends
endm

Macro	START_NID
;Segment	Code Public "Code"
Segment _TEXT  para public "CODE"
	assume ds:cGroup,cs:cGroup,es:nothing,ss:nothing
endm

Macro	END_NID
ends
endm

Macro	START_SPARSE
Segment _TEXT  para public "CODE"
;Segment	Sparse Public "Code"
endm

Macro	END_SPARSE
ends
endm

Macro   START_TEXT

Segment _TEXT  para public "CODE"
endm

Macro	END_TEXT
ends
endm





ELSE
; Define segment macros for MASM mode
;====================================================================
cGroup		group	_TEXT
		assume	cs:cGroup, ds:cGroup, es:nothing,ss:nothing

START_INIT	macro
Code		segment Public 'Code'
		assume ds:cGroup,cs:cGroup,es:nothing,ss:nothing
		endm

END_INIT	macro
Code		ends
		endm

START_NAD	macro
Code		segment Public 'Code'
		assume ds:cGroup,cs:cGroup,es:nothing,ss:nothing
		endm

END_NAD		macro
Code		ends
		endm

START_CODE	macro
;Code		segment Public 'Code'
_TEXT       segment para public 'CODE'
		assume ds:cGroup,cs:cGroup,es:nothing,ss:nothing
		endm

END_CODE	macro
;Code		ends
_TEXT       ends
		endm

START_NID	macro
;Code		segment Public 'Code'
_TEXT       segment para public 'CODE'
		assume ds:cGroup,cs:cGroup,es:nothing,ss:nothing
		endm

END_NID		macro
_TEXT       ends
;Code		ends
		endm

START_SPARSE	macro
;Sparse		segment Public 'Code'
_TEXT       segment para public 'CODE'
		assume ds:cGroup,cs:cGroup,es:nothing,ss:nothing
		endm

END_SPARSE	macro
;Sparse		ends
_TEXT       ends
		endm
ENDIF

;====================================================================
; Use all the marcos to set the order of the segments.
;====================================================================

;START_INIT
;END_INIT

;START_NAD
;END_NAD

START_CODE
END_CODE

;START_NID
;END_NID

START_SPARSE
END_SPARSE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\amd\pci.inc ===
VENDOR_ID	equ 1022h	     ;4 ; Vendor Identification

DEVICE_ID	equ 2000h 	     ;6 ; Device Identification (AT2450)

DEVICE_ID1   equ     0AE34h     ; 32


;PCI BIOS call constants definition
;----------------------------------
PCI_BIOS_INT             equ     1Ah
PCI_FUNCTION_ID          equ    0B1h
PCI_BIOS_PRESENT         equ     01h
FIND_PCI_DEVICE          equ     02h
FIND_PCI_CLASS_CODE      equ     03h
GENERATE_SPECIAL_CYCLE   equ     06h
READ_CONFIG_BYTE         equ     08h
READ_CONFIG_WORD         equ     09h
READ_CONFIG_DWORD        equ     0Ah
WRITE_CONFIG_BYTE        equ     0Bh
WRITE_CONFIG_WORD        equ     0Ch
WRITE_CONFIG_DWORD       equ     0Dh

;PCI BIOS returned values constants definition
;---------------------------------------------
PCI_SUCCESSFUL           equ     00h
PCI_FUNC_NOT_SUPPORTED   equ     81h
PCI_BAD_VENDOR_ID        equ     83h
PCI_DEVICE_NOT_FOUND     equ     86h
PCI_BAD_REGISTER_NUMBER  equ     87h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\amd\eep24.inc ===
;************************************************************************
;*
;*			    EEP24.INC
;*
;*  EEPROM configuration routines for the ATI AT-2450 Adapters.
;*
;*  Copyright (c) 1994-5 Allied Telesyn Int.  All Rights Reserved.
;*
;
;    Rev 1.0   14 Nov 1994 11:30:24   SSCHELL
;************************************************************************

; EEPROM Opcode
READ_OP 	equ	2	; Read from EEPROM
EWEN_OP 	equ	0	; Erase Write Enable	0b00
EWEN_ADR	equ	030h	;			0b110000
ERASE_OP	equ	3	; Erase 		0b11
ERAL_OP 	equ	0	; Erase all		0b00
WRITE_OP	equ	1	; Write to EEPROM	0b01
WRAL_OP 	equ	0	; Write all reg 	0b00
EWDS_OP 	equ	0	; Erase Write Enable	0b00
EWDS_ADR	equ	0	;			0b000000

; EEPROM Map word offset
PROM_PADR1	equ	0
PROM_PADR2	equ	1
PROM_PADR3	equ	2
PROM_HWID	equ	4
PROM_USER1	equ	5
PROM_CHKSUM1	equ	6
PROM_ASCIIW	equ	7
PROM_IOLOW	equ	8
PROM_IOUP	equ	9
PROM_BCR18	equ	0ah
PROM_BCR2	equ	0bh
PROM_BCR21	equ	0ch
PROM_BCR9	equ	0eh
PROM_CHKSUM2	equ	0fh
PROM_USER2	equ	011h

; User1 Word (location 5):
BOOT2450_PROT	equ	03800h		; type of BootProtocol (bit 11,12,13)
	BOOT2450_NW_8023	equ	0000h	; use NetWare with IEEE 802.3
	BOOT2450_NW_8022	equ	0800h	; use NetWare with IEEE 802.2
	BOOT2450_NW_8137	equ	01000h	; use NetWare with Ethernet II
	BOOT2450_RPL		equ	01800h	; use RPL
	BOOT2450_BOOTP		equ	02000h	; BOOTP
	BOOT2450_BOOTP_ARP	equ	02800h	; BOOTP/ARP


; uwire control bit definitions
BCR19_UWIRE_ON	equ	10h	; sets EEN
BCR19_START	equ	15h	; "Start Bit" (command follows)
BCR19_STOP	equ	0	; Stop bit
BCR19		equ	19	; EEPROM control and status register
BCR19_ESK_HIGH	equ	2	; EEPROM serial clock
BCR19_ECS	equ	0014H	; EEPROM chip select

; PCNetPCI I/O Ports:
RAP_OFFSET	equ	12h	; Register Address Port
BDP_OFFSET	equ	16h	; Bus Data Port

; Configuration values for BCR2
MAU_SEL_MASK_2450	equ	0003h	; Bits 0-1 (BCR2): media selection

Delay_2450	proc	near
	push	cx
	mov	cx, 50

DELAY_2450_Lp:
	loop	DELAY_2450_Lp

	pop	cx
	ret
Delay_2450	endp


;************************************************************************;
;*									*;
;*  VerifyPCIBoard							*;
;*   Function: Read the configuration of the AT-2450 board.		*;
;*	       All we need is the media selection from the EEPROM.	*;
;*   Input:  DI = base I/O address of the AT-2450 board.		*;
;*   Output: stc (carry set) if not an AT-2450 or config error; 	*;
;*	clc (carry clear) if successful, and:				*;
;*	   CH = autoselect flag from BCR2 register			*;
;*	   CL = twisted pair flag from BCR2 register			*;
;*	Other registers used are preserved.				*;
;*									*;
;************************************************************************;
public	VerifyPCIBoard
VerifyPCIBoard proc   near

	push	ax			; Save caller's registers
	push	bx
	push	dx

	; Verify that this really is an AT-2450 board.
	mov	dx, di			; DX = address prom I/O address
	in	ax, dx			; Read the first 2 bytes of MAC address
	cmp	ax, 0			; It better be 0000
	je	VB_go_on_2450
	jmp	not_our_card

VB_go_on_2450:
	add	dx, 2
	in	ax, DX			; Read the next 2 bytes of MAC address
	cmp	al, 0F4h		; The third byte better be F4
	je	VB_its_ours_2450
	jmp	not_our_card

VB_its_ours_2450:
	mov	bx, PROM_BCR2		; Read BCR2 in the EEPROM
	call	EE_Read 		; to get the media selection

	and	bx, MAU_SEL_MASK_2450	; Look at only the 2 media sel bits
	mov	cx, bx			; We'll return it in cx
	and	cx, 01			; cl is the twisted pair flag
	shr	bx, 1			; Now look at autoselect
	mov	ch, bl			; Autoselect flag in ch

	clc				; Set CF=0 == "success"
	pop	dx			; Restore caller's registers
	pop	bx
	pop	ax
	ret				; Return to caller

not_our_card:
	stc				; Set CF=1 == "error"
	pop	dx			; Restore caller's registers
	pop	bx
	pop	ax
	ret				; Return to caller

VerifyPCIBoard endp


;****************************************************************************
;   This function reads a 16-bit word from the serial eeprom and returns the
;   result as an unsigned short integer in BX.	The eeprom location to be read
;   is passed to this function as the register BX. Note: It is assumed that
;   the EEPROM is configured for word (16 bit) mode.
;
;	Input:
;		bx = EEPROM location to read
;		di = IOBase
;
;	Output:
;		bx = value read
;****************************************************************************
public	EE_Read
EE_Read PROC NEAR

	push	si			; Save registers used
	push	cx
	push	dx
	push	ax

	mov	si, BCR19_START
	call	uwire_out		; Give START condition to EEPROM.

	mov	al, READ_OP
	call	ee_opcode		; Write the read opcode to EEPROM.

	call	ee_address		; Write desired address (BX) to EEPROM.

	xor	si, si			; Clear registers
	xor	bx, bx

	; Read 16 bits from EEPROM.
serial_in:
	call	eedo_in 		; Read a bit - returned in ax
	mov	cl, 000fH		; 15 bits
	mov	dx, si
	sub	cl, dl			; CL = 15 - loop counter
	shl	ax, cl			; Position the bit to add to the word
	or	bx, ax			; Add in the bit we just read
	inc	si
	cmp	si, 000fH		; Do we have a word yet?
	jle	serial_in		; No - read another bit

	; The word is read
	mov	si, BCR19_STOP		; BCR19_STOP = 0
	call	uwire_out		; Clear EEN and ECS.
					; bx = the EEPROM word just read

	pop	ax			; Restore saved registers
	pop	dx
	pop	cx
	pop	si

	ret

EE_Read ENDP

;****************************************************************************
;   EE_EWEN	Enable EEPROM  erase/write
;
;   Input:	bx = EEPROM location to write to
;		ax = value to write to EEPROM
;****************************************************************************
public		EE_Ewen
EE_Ewen 	proc	near
		push	dx
		push	ax

		mov	di, IOBase
		mov	si, BCR19_START
		call	uwire_out	; Give START condition to EEPROM.

		mov	al, EWEN_OP
		call	ee_opcode	; Write the write opcode to EEPROM.

		mov	bx, EWEN_ADR
		call	ee_address	; Write desired address (BX) to EEPROM.

		mov	si, BCR19_STOP		; BCR19_STOP = 0
		call	uwire_out		; Clear EEN and ECS.

	pop	ax
		pop	dx
		ret
EE_Ewen 	endp

;****************************************************************************
;   EE_EWDS	Disable EEPROM	erase/write
;
;   Input:	bx = EEPROM location to write to
;		ax = value to write to EEPROM
;****************************************************************************
public		EE_Ewds
EE_Ewds 	proc	near
		push	dx
		push	ax

		mov	di, IOBase
		mov	si, BCR19_START
		call	uwire_out	; Give START condition to EEPROM.

		mov	al, EWDS_OP
		call	ee_opcode	; Write the write opcode to EEPROM.

		mov	bx, EWDS_ADR
		call	ee_address	; Write desired address (BX) to EEPROM.

		mov	si, BCR19_STOP		; BCR19_STOP = 0
		call	uwire_out		; Clear EEN and ECS.

		pop	ax
		pop	dx
		ret
EE_Ewds 	endp



;****************************************************************************
;   EE_Write	This function writes a 16-bit word to the serial eeprom.
;
;   Input:	bx = EEPROM location to write to
;		ax = value to write to EEPROM
;		di = IOBase
;****************************************************************************
public		EE_Write
EE_Write	PROC NEAR

	push	si			; Save registers used
	push	cx
	push	dx
	push	ax

	push	ax
	mov	si, BCR19_START
	call	uwire_out		; Give START condition to EEPROM.

	mov	al, WRITE_OP
	call	ee_opcode		; Write the write opcode to EEPROM.

	call	ee_address		; Write desired address (BX) to EEPROM.

	xor	si, si			; Clear registers
	xor	bx, bx

	pop	ax			; Value to write to EEPROM

	; Write 16 bits to EEPROM.
	mov	cx, 16
serial_out:
	rol	ax, 1
	mov	si, ax
	and	si, 1
	or	si, BCR19_ECS
	call	uwire_out		; Write a bit

	loop	serial_out		; No - read another bit

	mov	ax, 19
	mov	bx, BCR19_UWIRE_ON
	call	reg_write		; clears ESC to start programming

	call	Delay_2450

	mov	ax, 19
	mov	bx, BCR19_ECS
	call	reg_write		; EEPROM DO now the busy indicator

	; Wait for program cycle to complete
EE_Write_chk:
	mov	ax, 19
	call	reg_read
	test	ax, 1
	jz	EE_Write_chk


	mov	si, BCR19_STOP		; BCR19_STOP = 0
	call	uwire_out		; Clear EEN and ECS.
					; bx = the EEPROM word just read

	pop	ax			; Restore saved registers
	pop	dx
	pop	cx
	pop	si

	ret

EE_Write	ENDP

;****************************************************************************
;   SetChkSum1	This function update Checksum 1 of EEPROM if necessary
;
;   Input:	di = IOBase
;****************************************************************************
public		SetChkSum1
SetChkSum1	proc	near

		xor	ax, ax
		mov	di, IOBase
		mov	bx, PROM_PADR1

SetChkSumB:	push	bx
		call	EE_Read
		add	al, bl
		adc	ah, 0
		add	al, bh
		adc	ah, 0
		pop	bx

		inc	bx
		cmp	bx, 6
		jnz	SetChkSumB

		mov	bx, PROM_ASCIIW
		call	EE_Read
		add	al, bl
		adc	ah, 0
		add	al, bh
		adc	ah, 0

		mov	bx,  PROM_CHKSUM1
		call	EE_Read
		cmp	ax, bx
		jz	SetChkSum1Exit

		call	Delay_2450

		; Need to update PROM_CHKSUM1
		mov	bx,  PROM_CHKSUM1
		call	EE_Write

		call	Delay_2450

SetChkSum1Exit:
		ret
SetChkSum1	endp

;****************************************************************************
;   SetChkSum2	This function update Checksum 2 of EEPROM if necessary
;
;   Input:	di = IOBase
;****************************************************************************
public		SetChkSum2
SetChkSum2	proc	near

		xor	ax, ax
		mov	di, IOBase
		mov	bx, PROM_PADR1

ReadChkSum2:	push	bx
		call	EE_Read
		add	ah, bl
		add	ah, bh
		pop	bx

		inc	bx
		cmp	bx, 012h
		jnz	ReadChkSum2

		; is checksum okay?
		sub	ah, 0ffh
		jz	SetChkSum2Exit

		; Need to readjust checksum
		neg	ah

		mov	bx,  PROM_CHKSUM2
		call	EE_Read
		add	ah, bh

		call	Delay_2450

		mov	bx,  PROM_CHKSUM2
		call	EE_Write

		call	Delay_2450


SetChkSum2Exit:
		ret
SetChkSum2	endp


;****************************************************************************
;   This function writes bit 1, followed by bit 0 of the argument 'opcode'
;   in AL onto the uwire interface.  The opcode of a desired eeprom operation
;   should be placed in the least significant two bits of the argument
;   'opcode', to write an opcode to the eeprom.
;
;	ax = OpCode
;****************************************************************************
public		ee_opcode
ee_opcode	PROC NEAR

	push	si			; Save used registers

	; Write out MSB of opcode
	push	ax			; Save for future use
	and	al, 2			; Look at bit 1 only
	shr	al, 1			; Put it in bit 0
	or	al, BCR19_ECS		; EEPROM chip select
	sub	ah, ah			; Clear high byte
	mov	si, ax			; SI is argument to uwire_out
	call	uwire_out		; Write the bit to the EEPROM

	; Write out LSB of opcode
	pop	ax			; Retrieve passed-in argument
	and	al, 1			; Look at bit 0 only
	or	al, BCR19_ECS		; EEPROM chip select
	sub	ah, ah			; Clear high byte
	mov	si, ax			; SI is argument to uwire_out
	call	uwire_out		; Write the bit to the EEPROM

	pop	si			; Restore used registers
	ret

ee_opcode	ENDP

;****************************************************************************
;   This function writes the 6 least significant bits of the argument
;   'address' onto the uwire interface (order:bit 5 to bit 0).  The desired
;   eeprom address should be placed in the 6 least significant bits of the
;   argument 'address' to write an address to the eeprom.
;
;   BX = address to write
;****************************************************************************
public		ee_address
ee_address	PROC NEAR

	push	si			; Save used registers
	push	dx
	push	ax
	push	cx

	xor	dx, dx			; Initialize bit counter

	; Write out MSB to LSB of address
write_address_bit:
	mov	cl, 5			; 5 bits
	mov	ax, dx
	sub	cl, al			; CL = 5 - loop counter
	mov	al, bl			; Passed in address is in BX
	shr	al, cl			; Position the bit to add to the word
	and	al, 1			; Look at just a single bit
	or	al, BCR19_ECS		; EEPROM chip select
	sub	ah, ah			; Clear high bit
	mov	si, ax			; SI is argument to uwire_out
	call	uwire_out		; Write the address bit to the EEPROM

	inc	dx			; Next bit
	cmp	dx, 5			; Did we do 5 bits yet?
	jbe	write_address_bit	; No - read another bit

	pop	cx			; Restore used registers
	pop	ax
	pop	dx
	pop	si
	ret

ee_address	ENDP

;****************************************************************************
;   This function takes a 16-bit unsigned integer argument, in SI, and
;   writes the lower 5 bits to BCR19, affecting the uwire interface.  A
;   clock edge on the EESK output is generated to clock the uwire interface,
;   causing a single bit write to the EEPROM.
;   SI = value to write
;****************************************************************************
public		uwire_out
uwire_out	PROC NEAR

	push	ax			; Save used registers
	push	bx
	mov	ax, si			; AX = value to write

	; Isolate uwire signals and clear the ESK bit to allow clocking.
	and	ax, 001dH

	; Writes data to uwire interface (ESK low).
	mov	bx, ax			; Data to be written
	mov	ax, BCR19		; Write to EEPROM control register
	call	reg_write

	call	Delay_2450		; Guarantees fSK, tSKL, and tDIS EE

	or	bx, BCR19_ESK_HIGH	; Make EEPROM serial clock high
	mov	ax, BCR19		; Write to EEPROM control register
	call	reg_write

	call	Delay_2450		; Guarantees fSK, tSKL, and tDIS EE

	pop	bx			; Restore used registers
	pop	ax

	ret

uwire_out	ENDP

;****************************************************************************
;   eedo_in - Perform single bit read from EEPROM using uwire interface.
;
;   The bit is returned in AX.
;****************************************************************************
public		eedo_in
eedo_in PROC NEAR

	push	bx			; Save used registers

	; Bring EESK (clock pin) low.
	mov	bx, BCR19_ECS		; EEPROM serial clock
	mov	ax, BCR19		; Write to EEPROM control register
	call	reg_write

	call	Delay_2450		; Guarantees fSK and tSKL eeprom

	; Clock out EEPROM bit to EEDO pin.
	mov	bx, BCR19_ECS		; EEPROM serial clock
	or	bx, BCR19_ESK_HIGH	; Make EEPROM serial clock high
	mov	ax, BCR19		; Write to EEPROM control register
	call	reg_write

	call	Delay_2450		; Guarantees fSK and tSKL eeprom
	call	Delay_2450

	mov	ax, BCR19		; Read from EEPROM control register
	call	reg_read		; Read the bit
	and	ax, 1			; Look at just a single bit

	pop	bx			; Restore used registers

	ret

eedo_in ENDP

;****************************************************************************
;   reg_write - Write a 16-bit value to the specified CSR or BCR register.
;
;   Use a 16-bit I/O instruction.  A BCR write is performed.
;
;
;	DI = IOBase
;	AX = number of the specific register to access
;	BX = data
;****************************************************************************
public		reg_write
reg_write	PROC NEAR

	push	dx			; Save used registers
	push	ax

	mov	dx, di			; Base IO address
	add	dx, RAP_OFFSET		; Write to Register Address Port
	out	dx, ax			; Write register to be accessed

	mov	ax, bx			; Data to be written

	mov	dx, di			; Base IO address
	add	dx, BDP_OFFSET		; Write to Bus Data Port
	out	dx, ax			; Write data to register

	pop	ax			; Restore used registers
	pop	dx

	ret

reg_write	ENDP

;****************************************************************************
;   reg_read - Read a 16-bit value from the specified CSR or BCR register.
;
;   Use a 16-bit I/O instruction.  A BCR read is performed.
;
;   IOAddress1 is expected to contain the correct I/O address.
;   AX contains the register to read on entry.	On exit, AX contains
;   the value just read.
;
;	DI = IOBase
;	AX = number of the specific register to access
;
;****************************************************************************
public		reg_read
reg_read	PROC NEAR

	push	dx			; Save used registers

	mov	dx, di			; Base IO address
	add	dx, RAP_OFFSET		; Write to Register Address Port
	out	dx, ax			; Write register to be accessed

	mov	dx, di			; Base IO address
	add	dx, BDP_OFFSET		; Write to Bus Data Port
	in	ax, dx			; Read data from register

	pop	dx			; Restore used registers

	ret

reg_read	ENDP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\amd\eeprom.asm ===
;-----------------------------------------------------------------------------
; EEPROM Interface Equates

;EE_SK           equ     00000001B       ;EEPROM shift clock (1 = high, 0 = low)
;EE_CS           equ     00000010B       ;EEPROM chip select (1 = high, 0 = low)
EE_CS           equ     00000001B       ;EEPROM chip select (1 = high, 0 = low)
EE_SK           equ     00000010B       ;EEPROM shift clock (1 = high, 0 = low)
EE_DI           equ     00000100B       ;EEPROM data in
					; (set to 1 for writing data to EEPROM)
EE_DO           equ     00001000B       ;EEPROM data out
EE_tick         equ     64

EEPROM_read_opcode      equ     110B
EEPROM_write_opcode     equ     101B
EEPROM_erase_opcode     equ     111B
EEPROM_EWEN_opcode      equ     10011B          ;Erase/write enable
EEPROM_EWDS_opcode      equ     10000B          ;Erase/write disable

i8254Cmd                Equ     43h
i8254Ch0                Equ     40h

public read_eeprom
public write_eeprom

Code		segment para public USE16 'CODE'
;-----------------------------------------------------------------------------
;
;  Reads the contents of the specified EEPROM register from the specified
;  base I/O address.
;
;  Entry   - AX  EEPROM location
;	     DX  eeprom control reg in PLX chip
;
;  Returns - AX  EEPROM location contents
;
;  NOTE: Must preserve DI!
;-----------------------------------------------------------------------------
read_eeprom	proc	near

	push	di
	push	bx
	push	cx

	mov	bx, ax

	;---------------------------------------------------------------------
	; Select the EEPROM.  Mask off the ASIC and 586 reset bits and set
	; the ee_cs bit in the EEPROM control register.
	;---------------------------------------------------------------------
	in	al, dx
	and	al, 11110010b
	or	al, EE_CS
	out	dx, al

	;---------------------------------------------------------------------
	; Write out read opcode and EEPROM location.
	;---------------------------------------------------------------------
	mov	ax, EEPROM_read_opcode		;Set AX to READ opcode and
	mov	cx, 3				;Send it to the EEPROM circuit
	call	shift_bits_out

	mov	ax, bx				;Tell EEPROM which register is
	mov	cx, 6				; to be read.  6 bit address.
	call	shift_bits_out

	call	shift_bits_in			;AX gets EEPROM register
						;contents

	call	eeprom_clean_up			;Leave EEPROM in known state.

	pop	cx
	pop	bx
	pop	di
	ret

read_eeprom	endp

;-----------------------------------------------------------------------------
;  Writes the specified value to the specified EEPROM register at the
;  specified base I/O address.
;
;  Entry  - AX  EEPROM location to write.
;           BX  Value to write
;	    DX  eeprom control reg in PLX chip
;
;  Return - AX = 0 if no error
;           AX = Pointer to Error message
;
;-----------------------------------------------------------------------------
write_eeprom    proc	near

        push    bx
        mov     bx, ax

        in      al, dx                          ;Select EEPROM
        and     al, 11110010b
        or      al, EE_CS
        out     dx, al

        ;---------------------------------------------------------------------
        ; Send Erase/write enable opcode to the EEPROM.
        ;---------------------------------------------------------------------
        mov     ax, EEPROM_EWEN_opcode          ;Send erase/write enable
        mov     cx, 5                           ; command to the EEPROM.
        call    shift_bits_out

        mov     cx, 4                           ;Send 4 don't cares as
        call    shift_bits_out                  ; required by the eeprom

        call    stand_by

        ;---------------------------------------------------------------------
        ; Send the erase opcode to the EEPROM and wait for the command to
        ; complete.
        ;---------------------------------------------------------------------
        mov     ax, EEPROM_erase_opcode         ;Send Erase command to the
        mov     cx, 3                           ; EEPROM.
        call    shift_bits_out

        mov     ax, bx                          ;Send EEPROM location the the
        mov     cx, 6                           ; EEPROM.  6 bit address.
        call    shift_bits_out

        call    wait_eeprom_cmd_done            ;wait for end-of-operation
        or      ah, ah                          ; Error?
        jnz     write_Fault_pop                 ; Yes

        call    stand_by

        ;---------------------------------------------------------------------
        ; send the write opcode, location to write, and data to write to the
        ; eeprom.  wait for the write to complete.
        ;---------------------------------------------------------------------
        mov     ax, EEPROM_write_opcode         ;Send write command to the
        mov     cx, 3                           ; EEPROM.
        call    shift_bits_out

        mov     ax, bx                          ;Send the EEPROM location to
        mov     cx, 6                           ; the EEPROM.  5 bit address.
        call    shift_bits_out

        pop     ax                              ;Send data to write to the
        mov     cx, 16                          ; EEPROM.  16 bits.
        call    shift_bits_out

        call    wait_eeprom_cmd_done            ;Await end-of-command
        or      ah,ah                           ;Error?
        jnz     write_Fault                     ;Yes

        call    stand_by

        ;---------------------------------------------------------------------
        ; Send the erase write disable command to the EEPROM.
        ;---------------------------------------------------------------------
        mov     ax, EEPROM_EWDS_opcode          ;Disable the Erase/write
        mov     cx, 5                           ; command previously sent to
        call    shift_bits_out                  ; EEPROM.

        mov     cx, 4                           ;Send 4 don't cares as
        call    shift_bits_out                  ; required by the eeprom

        call    eeprom_clean_up

        mov     ax, 1

write_eeprom_exit:

        ret

write_Fault_pop:

        add     sp, 2                           ;Get rid of data on stack

write_Fault:

        mov     ax, 0
        jmp     write_eeprom_exit

write_eeprom    endp


;-----------------------------------------------------------------------------
;  wait_eeprom_cmd_done
;
;       Wait for ee_do to go high, indicating end-of-write or end-of-erase
;       operation.
;
;       Input:
;               none
;
;       Output:
;               AX  = 0 : No Error
;               AX != 0 : Time out error
;
; The EEPROM spec calls for a 10 millisecond max time for DO to go high
; indicating an end of operation.  This loop uses a 54.7 millisecond timeout.
;-----------------------------------------------------------------------------
wait_eeprom_cmd_done    proc    near

        push    bx
        push    cx

        call    stand_by

        call    ReadTickCounter
        mov     di, ax

ee_do_wait_loop:
        call    ReadTickCounter
        neg     ax
        add     ax, di

        cmp     ax, 7000h                       ; wait 10ms before we even
        jb      ee_do_wait_loop                 ;  start testing

        push    ax                              ; save counter difference
        in      al, dx                          ;Get EEPROM control register
        test    al, EE_DO                       ;ee_do high?
        pop     ax                              ; restore counter difference.

        jnz     ee_do_found                     ; If EE_DO high, we're done here!

        cmp     ax, 0ff00h                      ; 54.7 Millisecond time out

        jb      ee_do_wait_loop                 ; if B then no timeout yet.

        mov     ah, -1                          ; indicate timout.
        jmp     short wait_eeprom_cmd_done_exit

ee_do_found:

        xor     ah, ah                          ;"clean" status (no timeout)

wait_eeprom_cmd_done_exit:

        pop     cx
        pop     bx
        ret

wait_eeprom_cmd_done    endp


;-----------------------------------------------------------------------------
;  shift_bits_out
;
;	This subroutine shift_bits bits out to the Hyundai EEPROM.
;
;	Input:
;		AX = data to be shifted
;		CX = # of bits to be shifted
;
;	Output:
;		none
;
;-----------------------------------------------------------------------------
shift_bits_out	proc	near

	push	bx

	;---------------------------------------------------------------------
	; Data bits are right justified in the AX register.  Move the data
	; into BX and left justify it.  This will cause addresses to to
	; be sent to the EEPROM high order bit first.
	;---------------------------------------------------------------------
	mov	bx, ax
	mov	ch, 16
	sub	ch, cl
	xchg	cl, ch
	shl	bx, cl
	xchg	cl, ch
	xor	ch, ch

	;---------------------------------------------------------------------
	; Get the EEPROM control register into AL.  Mask of the ASIC asn 586
	; reset bits.
	;---------------------------------------------------------------------
	in	al, dx
	AND	AL, 11110011B

	;---------------------------------------------------------------------
	; Set or clear DI bit in EEPROM control register based on value of
	; data in BX.
	;---------------------------------------------------------------------
out_shift_loop:

	and	al, not EE_DI			;Assume data bit will be zero

	rcl	bx, 1				;Is the data bit a one?
	jnc	out_with_it			;No

	or	al, EE_DI      			;Yes

out_with_it:

	out	dx, al				;Output a 0 or 1 on data pin

	;---------------------------------------------------------------------
	; Set up time for data is .4 Microseconds.  So to be safe (incase of
	; this software is run on a cray), call delay.
	;---------------------------------------------------------------------
	mov	di, 1
	call	eeprom_delay

	;---------------------------------------------------------------------
	; clock the data into the EEPROM.
	;---------------------------------------------------------------------
	call	raise_eeprom_clock
	call	lower_eeprom_clock
	loop	out_shift_loop			;Send next bit

	AND	AL, NOT EE_DI			;Force DI = 0
	OUT	DX, AL				;Output DI

	pop	bx

	ret

shift_bits_out	endp

;-----------------------------------------------------------------------------
;
;  shift_bits_in
;
;	This subroutine shift_bits bits in from the Hyundai EEPROM.
;
;	Input:
;		none
;
;	Output:
;		AX = register contents
;
;-----------------------------------------------------------------------------
shift_bits_in	proc	near

	push	bx
	push	cx

	;---------------------------------------------------------------------
	; BX will receive the 16 bits read from the EEPROM.  Data is valid in
	; data out bit (DO) when clock is high.  There for, this procedure
	; raises clock and waits a minimum amount of time.  DO is read, and
	; clock is lowered.
	;---------------------------------------------------------------------
	in	al, dx				;Init AL to eeprom control
	AND	AL, 11110011B			; register.

	xor	bx, bx				;Init holding register
	mov	cx, 16				;We'll shift in 16 bits

in_shift_loop:

	shl	bx, 1				;Adjust holding register for
						; next bit

	call	raise_eeprom_clock

	in	al, dx
	AND	AL, 11111011B

	test	al, EE_DO			;Was the data bit a one?
	jz	in_eeprom_delay			;No

	or	bx, 1				;Yes, reflect data bit state
						; in holding register.

in_eeprom_delay:

	call	lower_eeprom_clock
	loop	in_shift_loop			;CONTINUE

	mov	ax, bx				;AX = data

	pop	cx
	pop	bx
	ret

shift_bits_in	endp

;-----------------------------------------------------------------------------
raise_eeprom_clock	proc	near

	or	al, EE_SK    			;clock the bit out by raising
	jmp	short eeprom_clock_common

raise_eeprom_clock	endp

;-----------------------------------------------------------------------------
lower_eeprom_clock	proc	near

	and	al, not EE_SK			;lower ee_sk

eeprom_clock_common:

	out	dx, al
	mov	di, EE_tick
	call	eeprom_delay			;waste time

	ret

lower_eeprom_clock	endp

;-----------------------------------------------------------------------------
;
; lower EEPROM chip select and di.
; clock EEPROM twice and leave clock low.
;
eeprom_clean_up	proc	near

	push	ax

	in	al, dx
	AND	AL, 11111111B
	and	al, not (EE_CS or EE_DI)
	out	dx, al

	call	raise_eeprom_clock
	call	lower_eeprom_clock

	pop	ax
	ret

eeprom_clean_up	endp

;-----------------------------------------------------------------------------
;
; DI has number of 838 Nanoseconds clock counts
;
;-----------------------------------------------------------------------------
eeprom_delay	proc	near

	push	ax
	push	bx
	push	dx

	call	ReadTickCounter
	mov	bx, ax

eeprom_delay_loop:

	call	ReadTickCounter
	neg	ax
	add	ax, bx
	cmp	ax, di
	jb	eeprom_delay_loop

	pop	dx
	pop	bx
	pop	ax
	ret

eeprom_delay	endp


;-----------------------------------------------------------------------------
; Stand-by is lowering chip select for 1 microsecond.
;-----------------------------------------------------------------------------
stand_by        proc    near

        in      al, dx                          ;de-select eeprom
        and     al, (11111110b) and (not EE_CS)
        out     dx, al

        mov     di, 2
        call    eeprom_delay

        or      al, EE_CS
        out     dx, al
        ret

stand_by        endp

;-----------------------------------------------------------------------------
;
;       ReadTickCounter
;
;       Read the 16 bit timer tick count register (system board timer 0).
;       The count register decrements by 2 (even numbers) every 838ns.
;
;       Assumes:        Interrupts disabled
;
;       Returns:        ax with the current count
;                       dx destroyed
;                       Interrupts disabled
;
ReadTickCounter proc    near
	push    dx
	mov     dx, i8254Cmd                    ; Command 8254 timer to latch
	xor     al, al                          ; T0's current count
	out     dx, al

	mov     dx, i8254Ch0                    ; read the latched count
	in      al, dx                          ; LSB first
	mov     ah, al
	in      al, dx                          ; MSB next
	xchg    al, ah                          ; put count in proper order
	pop     dx
	ret
ReadTickCounter endp

Code	ends
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\amd\pxe_stru.inc ===
;
NUM_MCADDRS    	Equ	8		; max number of multicast addresses.
MAX_DATABLK    	Equ	8		; max number of data blocks supported 
					;	in a descriptor.
MAX_IMMED_LEN	Equ	64		; max immediate data buffer length
MAX_TX_DATABLK	Equ	MAX_DATABLK	; max number of data blocks supported 
					;	in a Tx descriptor.
MAX_TD_DATABLK	Equ	MAX_DATABLK	; max number of TransferData blocks
		
APIMaxFunc	EQU	0011h

ADDR_LEN	EQU	16
ETH_ADDR_LEN	EQU	6
MAXNUM_MCADDR	EQU	8

;
; protocol values in transmit buffer
;
P_UNKNOWN	EQU	0		;; no media header
P_IP	 	EQU	1		;; IP type
P_ARP		EQU	2		;; ARP type
P_RARP		EQU	3		;; RARP type

TYPE_IP	 	EQU	0800h		;; IP type
TYPE_ARP	EQU	0806h		;; ARP type
TYPE_RARP	EQU	8035h		;; RARP type
;
; xmitflag values in transmit buffer
;
PKT_DESTADDR	EQU 0	;; destination address given 
PKT_BROADCAST	EQU 1h	;; use broadcast address 
PKT_MULTICAST	EQU 2h	;; multicast addr given

;; Hardware type values
ETHER_TYPE 		EQU 1
EXP_ETHER_TYPE	EQU 2
IEEE_TYPE  	EQU 6
ARCNET_TYPE   	EQU 7


Eth_MCastBuf	Struc
MCastAddrCount	DW	?
MCastAddr	DB MAXNUM_MCADDR * ETH_ADDR_LEN dup (0)
Eth_MCastBuf	Ends

MC_MCastBuf		Struc
MC_MCastAddrCount	DW	?
MC_MCastAddr  		DB MAXNUM_MCADDR * ADDR_LEN dup (0)
MC_MCastBuf		Ends

NIC_StartUp	Struc
S_Status	DW	?
S_BusType	DB	?
S_AddrType	DB	?
S_DataSeg	DW	?
S_DataSegAddr	DD	?
S_DataSegSize	DW	?
S_CodeSegSize	DW	?
S_BusDevFunc	DW	?	;; PCI Dev_ID
S_PCI_ds_off	dw	?	;; Far pointer to PCI data structure
S_PCI_ds_seg	dw	?
S_PnP_csn	dw	?	; Card select number.-1 for non-PnP BBS device
S_PnP_eh_off	dw	?	; Far pointer to PnP expansion header
S_PnP_eh_seg	dw	?
NIC_StartUp	Ends

NIC_CleanUp	Struc
CL_Status	DW	?
NIC_CleanUp	Ends

NIC_Initialize	Struc
I_Status	DW	?
I_Prot_ini	DD	?
I_RcvInt	DD	?
I_GenInt	DD	?
NIC_Initialize  Ends

NIC_Reset	Struc
R_Status	DW	?
R_MCBuf		MC_MCastBuf <>
NIC_Reset	Ends

NIC_ShutDown	Struc
SD_Status	DW	?
NIC_ShutDown	Ends

NIC_Open	Struc
O_Status	DW	?
O_OpenFlg	DW	?
O_PktFilter	DW	?
O_MCBuf		MC_MCastBuf <>
NIC_Open	Ends

NIC_Close	Struc
C_Status	DW	?
NIC_Close	Ends

X_DataBlock	Struc
X_TxPtrType	DB	?	; 0 => Phys pointer, 1 => GDT pointer
X_TxRsvdByte	DB	?	; Reservered, must be zero.
X_TxDataLen	DW	?	; Data block length in bytes.
X_TxDataPtr	DD	?	; Far pointer to data block.
X_DataBlock Ends

NIC_TBD		Struc
X_Length	DW	?
X_BufOff	DW	?
X_BufSeg	DW	?
X_DataBlkCount	DW	?		; will always be zero for base code
X_DataBlk	DB	MAX_DATABLK * SIZE X_DataBlock dup (0)	
NIC_TBD		Ends

NIC_Transmit		Struc
T_Status		DW	?
T_Protocol		DB	?
T_XmitFlag		DB	?
T_DestAddrOffset 	DW	?	; 16-bit segment & offset of the
T_DestAddrSegment 	DW	?	; destination media address 
T_TBDOffset		DW	?	; 16-bit segment & offset 
T_TBDSegment		DW	?	; transmit buffer descriptor 
T_Reserved		DD	2 dup(0)	; for future use	
NIC_Transmit Ends

NIC_SetMCastAddr	Struc
SM_Status		DW	?
SM_MCBuf		MC_MCastBuf <>
NIC_SetMCastAddr	Ends

NIC_SetStationAddr	Struc
SS_Status		DW	?
SS_StationAddr		DB	ADDR_LEN dup (0)
NIC_SetStationAddr	Ends

NIC_SetPacketFilter	Struc
SP_Status		DW	?
;;SP_NewFilter		DW  ?
SP_NewFilter		DB  ?
;;SP_MCBuf		MC_MCastBuf <>
NIC_SetPacketFilter	Ends

NIC_GetInfo	Struc
GI_Status		DW	?
GI_BaseIo		DW	?
GI_IntNumber		DW	?
GI_MTU			DW	?
GI_HwType		DW	?
GI_HwAddrLen		DW	?
GI_CurrentNodeAddress	DB ADDR_LEN dup (0)
GI_PermNodeAddress	DB ADDR_LEN dup (0)
GI_ROMAddress		DW 	?
GI_RxBufCt		DW	?
GI_TxBufCt		DW	?
NIC_GetInfo	Ends

NIC_GetNICType_pci 	Struc
Status 		DW	?	; OUT: See PXENV_STATUS_xxx constants */ 
NicType 	DB	?	;  /* OUT: 2=PCI, 3=PnP */
Vendor_ID	DW	?	; /* OUT:  */
Dev_ID		DW	?	;  /* OUT:  */
Base_Class	DB	?	; /* OUT: */
Sub_Class	DB	?	;  /* OUT: */
Prog_Intf	DB	?	;  /* OUT: program interface */ 
Rev		DB	?	;  /* OUT: Revision number */ 
BusDevFunc	DW	?	; /* OUT: Bus, Device & Function numbers */
NIC_GetNICType_pci 	Ends

NIC_GetNICType_pnp 	Struc
Status 		DW	?	; OUT: See PXENV_STATUS_xxx constants */ 
NicType 	DB	?	;  /* OUT: 2=PCI, 3=PnP */
EISA_Dev_ID	DD	?	; /* Out:  */
Base_Class	DB	?	; /* OUT: */
Sub_Class	DB	?	;  /* OUT: */
Prog_Intf	DB	?	;  /* OUT: program interface */
CardSelNum	DW	?	; /* OUT: Card Selector Number */
Res		DB	0	;
NIC_GetNICType_pnp 	Ends

NIC_GetStatistics	Struc
GS_Status		DW	?
GS_XmtGoodFrames	dd    ?
GS_RcvGoodFrames	dd    ?
GS_RcvCRCErrors		dd    ?
GS_RcvResourceErrors	dd    ?
NIC_GetStatistics	Ends

NIC_ClearStatistics	Struc
CS_Status		DW	?
NIC_ClearStatistics	Ends

NIC_InitDiags	Struc
ID_Status	DW	?
NIC_InitDiags   Ends

NIC_ForceInterrupt	Struc
FI_Status		DW	?
NIC_ForceInterrupt	Ends

NIC_GetMCastAddr	Struc
GM_Status		DW	?
GM_InetAddr		DD	?
GM_HwAddr		DB	ADDR_LEN dup (0)
NIC_GetMCastAddr	Ends

;NIC_API_Entry	Struc
;Signature 	DB	'PXENV+'	;; not null terminated
;Version		DW	0100h		;; 1.0
;StrucLength	DB	0		;; length of this structure
;CheckSum	DB	0		;; fill in later
;rm_entry_off	DW	0		;; real mode driver entry offset
;rm_entry_seg	DW	0		;; real mode driver entry segment
;pm_entry_off	DW	0		;; protected mode driver entry offset
;pm_entry_seg	DW	0		;; protected mode driver entry segment
;NIC_API_Entry	Ends

s_PXENV_ENTRY	Struc
signature	db	6 dup(?)	; 'PXENV+'
ver             dw      ?               ; MSB=major, LSB=minor
bytes		db	?		; sizeof s_pxenv_entry
checksum	db	?		; 8-bit checksum of structure,
					; including this byte shoube be zero.
rm_entry_off	dw	?		; 16-bit real-mode segment & offset.
rm_entry_seg	dw	?
pm_entry_off	dw	?		; 16-bit protected mode 32-bit physical
pm_entry_base	dd	?		; address and 16-bit offset.
stack_sel	dw	?		; PROM stack segment.  Will be set
stack_size	dw	?		; to 0 when removed from memory.
base_cs_sel	dw	?		; Base code segment.  Will be set
base_cs_size	dw	?		; to 0 when removed from memory.
base_ds_sel	dw	?		; Base data segment.  Will be set
base_ds_size	dw	?		; to 0 when removed from memory.
mlid_ds_sel	dw	?		; MLID data segment.
mlid_ds_size	dw	?
mlid_cs_sel	dw	?		; MLID code segment.
mlid_cs_size	dw	?
s_PXENV_ENTRY	Ends

;; Ethernet II protocol header
EtherHeader	Struc
E_DestAddr	DB 6 dup (0)	;; destination ethernet addr
E_SrcAddr	DB 6 dup (0)	;; destination ethernet addr
E_Type		DW  ?	;; protocol type
EtherHeader	Ends

ETHER_HEADER_LEN	Equ	SIZE EtherHeader

; 
; * Data structures for TransmitChain (Tx), TransferData (TD)
; 
TxDataBlock	Struc
TxPtrType	DB	?	; 0 => Phys pointer, 1 => GDT pointer
TxRsvdByte	DB	?	; Reservered, must be zero.
TxDataLen	DW	?	; Data block length in bytes.
TxDataPtr	DD	?	; Far pointer to data block.
TxDataBlock	Ends

; 
; * TransmitChain descriptor structure definition
; 
TxBufDesc	Struc
TxImmedLen	DW	?	; Byte count of immediate data, max=64
TxImmedPtr	DD	?	; Virtual address of Immediate data
TxDataCount	DW	?	; Number of Data Blocks (max = 8)
TxDataBlk	DB	size TxDataBlock * MAX_TX_DATABLK dup(0)
TxBufDesc	Ends

TxBufDescrSize	Equ	Size TxImmedLen + Size TxImmedPtr + Size TxDataCount

; 
; * TransferData data block description
; 
TDDataBlock	Struc
TDPtrType	DB	?	; 0 => Phys pointer, 1 => GDT pointer
TDRsvdByte	DB	?	; Reservered, must be zero.
TDDataLen	DW	?	; Data block length in bytes.
TDDataPtr	DD	?	; Far pointer to data block.
TDDataBlock	Ends

; 
; * TransferData descriptor structure
; 
TDBufDesc	Struc
TDDataCount	DW	?	; No of Data Blocks (max 8 for V1.01).
TDDataBlk	DB	size TDDataBlock*MAX_TD_DATABLK dup(0)
TDBufDesc	Ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\amd\eep24x.inc ===
;************************************************************************
;*
;*                          EEP24.INC
;*
;*  EEPROM configuration routines for the ATI AT-2450 Adapters.
;*
;*  Copyright (c) 1994-5 Allied Telesyn Int.  All Rights Reserved.
;*
; 
;    Rev 1.0   14 Nov 1994 11:30:24   SSCHELL
;************************************************************************

; EEPROM Opcode
READ_OP		equ	2	; Read from EEPROM
EWEN_OP		equ	0	; Erase Write Enable	0b00
EWEN_ADR	equ	030h	; 			0b110000
ERASE_OP	equ	3	; Erase			0b11
ERAL_OP		equ	0	; Erase all		0b00
WRITE_OP	equ	1	; Write to EEPROM	0b01
WRAL_OP		equ	0	; Write all reg		0b00
EWDS_OP		equ	0	; Erase Write Enable	0b00
EWDS_ADR	equ	0	; 			0b000000

; EEPROM Map word offset
PROM_PADR1	equ	0
PROM_PADR2	equ	1
PROM_PADR3	equ	2
PROM_HWID	equ	4
PROM_USER1	equ	5
PROM_CHKSUM1	equ	6
PROM_ASCIIW	equ	7
PROM_IOLOW	equ	8
PROM_IOUP	equ	9
PROM_BCR18	equ	0ah
PROM_BCR2	equ	0bh
PROM_BCR21	equ	0ch
PROM_BCR9	equ	0eh
PROM_CHKSUM2	equ	1fh
PROM_USER2	equ	011h

; User1 Word (location 5):
BOOT2450_PROT	equ	03800h		; type of BootProtocol (bit 11,12,13)
	BOOT2450_NW_8023	equ	0000h	; use NetWare with IEEE 802.3
	BOOT2450_NW_8022	equ	0800h	; use NetWare with IEEE 802.2
	BOOT2450_NW_8137	equ	01000h	; use NetWare with Ethernet II
	BOOT2450_RPL		equ	01800h	; use RPL
	BOOT2450_BOOTP		equ	02000h	; BOOTP
	BOOT2450_BOOTP_ARP	equ	02800h	; BOOTP/ARP


; uwire control bit definitions
BCR19_UWIRE_ON	equ	10h	; sets EEN
BCR19_START	equ	15h	; "Start Bit" (command follows)
BCR19_STOP	equ	0	; Stop bit
BCR19		equ	19	; EEPROM control and status register
BCR19_ESK_HIGH	equ	2	; EEPROM serial clock
BCR19_ECS	equ	0014H	; EEPROM chip select

; PCNetPCI I/O Ports:
RAP_OFFSET	equ	12h	; Register Address Port
BDP_OFFSET	equ	16h	; Bus Data Port

; Configuration values for BCR2
MAU_SEL_MASK_2450	equ	0003h	; Bits 0-1 (BCR2): media selection

public  Delay_2450

Delay_2450	proc	near
	push	cx
	mov	cx, 50

DELAY_2450_Lp:
	loop	DELAY_2450_Lp

	pop	cx
	ret
Delay_2450	endp


;************************************************************************;
;*                                                                      *;
;*  VerifyPCIBoard                                                      *;
;*   Function: Read the configuration of the AT-2450 board.             *;
;*             All we need is the media selection from the EEPROM.      *;
;*   Input:  DI = base I/O address of the AT-2450 board.                *;
;*   Output: stc (carry set) if not an AT-2450 or config error;         *;
;*      clc (carry clear) if successful, and:                           *;
;*         CH = autoselect flag from BCR2 register                      *;
;*         CL = twisted pair flag from BCR2 register                    *;
;*      Other registers used are preserved.                             *;
;*                                                                      *;
;************************************************************************;
public	VerifyPCIBoard
VerifyPCIBoard proc   near

	push	ax			; Save caller's registers
	push	bx
	push	dx

	; Verify that this really is an AT-2450 board.
	mov	dx, di			; DX = address prom I/O address
	in	ax, dx			; Read the first 2 bytes of MAC address
	cmp	ax, 0			; It better be 0000
	je	VB_go_on_2450
	jmp	not_our_card

VB_go_on_2450:
	add	dx, 2
	in	ax, DX			; Read the next 2 bytes of MAC address
	cmp	al, 0F4h		; The third byte better be F4
	je	VB_its_ours_2450
	jmp	not_our_card

VB_its_ours_2450:
	mov	bx, PROM_BCR2		; Read BCR2 in the EEPROM
	call	ee_read			; to get the media selection

	and	bx, MAU_SEL_MASK_2450	; Look at only the 2 media sel bits
	mov	cx, bx			; We'll return it in cx
	and	cx, 01			; cl is the twisted pair flag
	shr	bx, 1			; Now look at autoselect
	mov	ch, bl			; Autoselect flag in ch

	clc				; Set CF=0 == "success"
	pop	dx			; Restore caller's registers
	pop	bx
	pop	ax
	ret				; Return to caller
   
not_our_card:
	stc				; Set CF=1 == "error"
	pop	dx			; Restore caller's registers
	pop	bx
	pop	ax
	ret				; Return to caller
      
VerifyPCIBoard endp


;****************************************************************************
;   This function reads a 16-bit word from the serial eeprom and returns the
;   result as an unsigned short integer in BX.  The eeprom location to be read
;   is passed to this function as the register BX. Note: It is assumed that
;   the EEPROM is configured for word (16 bit) mode.
;
;	Input:
;		bx = EEPROM location to read
;		di = IOBase
;
;	Output:
;		bx = value read
;****************************************************************************
public	ee_read
ee_read	PROC NEAR

	push	si			; Save registers used
	push	cx
	push	dx
	push	ax

	mov	si, BCR19_START
	call	uwire_out		; Give START condition to EEPROM.

	mov	al, READ_OP
	call	ee_opcode		; Write the read opcode to EEPROM.

	call	ee_address		; Write desired address (BX) to EEPROM.

	xor	si, si			; Clear registers
	xor	bx, bx
	
	; Read 16 bits from EEPROM.
serial_in:
	call	eedo_in			; Read a bit - returned in ax
	mov	cl, 000fH		; 15 bits
	mov	dx, si
	sub	cl, dl			; CL = 15 - loop counter
	shl	ax, cl			; Position the bit to add to the word
	or	bx, ax			; Add in the bit we just read
	inc	si
	cmp	si, 000fH		; Do we have a word yet?
	jle	serial_in		; No - read another bit

	; The word is read
	mov	si, BCR19_STOP		; BCR19_STOP = 0
	call	uwire_out		; Clear EEN and ECS.
					; bx = the EEPROM word just read

	pop	ax			; Restore saved registers
	pop	dx
	pop	cx
	pop	si

	ret	

ee_read	ENDP

;****************************************************************************
;   EE_EWEN	Enable EEPROM  erase/write
;
;   Input:	bx = EEPROM location to write to
;		ax = value to write to EEPROM
;****************************************************************************
public		EE_EWEN
ee_ewen		proc	near
		push	dx
		push	ax

		mov	di, NIC_IO
		mov	si, BCR19_START
		call	uwire_out	; Give START condition to EEPROM.
	
		mov	al, EWEN_OP
		call	ee_opcode	; Write the write opcode to EEPROM.

		mov	bx, EWEN_ADR
		call	ee_address	; Write desired address (BX) to EEPROM.

		mov	si, BCR19_STOP		; BCR19_STOP = 0
		call	uwire_out		; Clear EEN and ECS.

		pop	ax
		pop	dx
		ret
ee_ewen		endp

;****************************************************************************
;   EE_EWDS	Disable EEPROM  erase/write
;
;   Input:	bx = EEPROM location to write to
;		ax = value to write to EEPROM
;****************************************************************************
public		EE_EWDS
ee_ewds		proc	near
		push	dx
		push	ax

		mov	di, NIC_IO
		mov	si, BCR19_START
		call	uwire_out	; Give START condition to EEPROM.
	
		mov	al, EWDS_OP
		call	ee_opcode	; Write the write opcode to EEPROM.

		mov	bx, EWDS_ADR
		call	ee_address	; Write desired address (BX) to EEPROM.

		mov	si, BCR19_STOP		; BCR19_STOP = 0
		call	uwire_out		; Clear EEN and ECS.

		pop	ax
		pop	dx
		ret
ee_ewds		endp



;****************************************************************************
;   EE_WRITE	This function writes a 16-bit word to the serial eeprom.
;
;   Input:	bx = EEPROM location to write to
;		ax = value to write to EEPROM
;		di = IOBase
;****************************************************************************
public		ee_write
ee_write	PROC NEAR

	push	si			; Save registers used
	push	cx
	push	dx
	push	ax

	push	ax
	mov	si, BCR19_START
	call	uwire_out		; Give START condition to EEPROM.

	mov	al, WRITE_OP
	call	ee_opcode		; Write the write opcode to EEPROM.

	call	ee_address		; Write desired address (BX) to EEPROM.

	xor	si, si			; Clear registers
	xor	bx, bx

	pop	ax			; Value to write to EEPROM
	
	; Write 16 bits to EEPROM.
	mov	cx, 16
serial_out:
	rol	ax, 1
	mov	si, ax
	and	si, 1
	or	si, BCR19_ECS
	call	uwire_out		; Write a bit

	loop	serial_out		; No - read another bit

	mov	ax, 19
	mov	bx, BCR19_UWIRE_ON
	call	reg_write		; clears ESC to start programming

	call	Delay_2450

	mov	ax, 19
	mov	bx, BCR19_ECS
	call	reg_write		; EEPROM DO now the busy indicator

	; Wait for program cycle to complete
ee_write_chk:
	mov	ax, 19
	call	reg_read
	test	ax, 1
	jz	ee_write_chk


	mov	si, BCR19_STOP		; BCR19_STOP = 0
	call	uwire_out		; Clear EEN and ECS.
					; bx = the EEPROM word just read

	pop	ax			; Restore saved registers
	pop	dx
	pop	cx
	pop	si

	ret	

ee_write	ENDP

;****************************************************************************
;   SetChkSum1	This function update Checksum 1 of EEPROM if necessary
;
;   Input:	di = IOBase
;****************************************************************************
public		SetChkSum1
SetChkSum1	proc	near
		
		xor	ax, ax
		mov	di, NIC_IO
		mov	bx, PROM_PADR1

SetChkSumB:	push	bx
		call	ee_read
		add	al, bl
		adc	ah, 0
		add	al, bh
		adc	ah, 0
		pop	bx

		inc	bx
		cmp	bx, 6
		jnz	SetChkSumB
	   
		mov	bx, PROM_ASCIIW
		call	ee_read				
		add	al, bl
		adc	ah, 0
		add	al, bh
		adc	ah, 0

		mov	bx,  PROM_CHKSUM1
		call	ee_read
		cmp	ax, bx
		jz	SetChkSum1Exit

		call	Delay_2450

		; Need to update PROM_CHKSUM1
		mov	bx,  PROM_CHKSUM1
		call	ee_write

		call	Delay_2450

SetChkSum1Exit:
		ret
SetChkSum1	endp

;****************************************************************************
;   SetChkSum2	This function update Checksum 2 of EEPROM if necessary
;
;   Input:	di = IOBase
;****************************************************************************
public		SetChkSum2
SetChkSum2	proc	near
		
		xor	ax, ax
		mov	di, NIC_IO
		mov	bx, PROM_PADR1

ReadChkSum2:	push	bx
		call	ee_read
		add	ah, bl
		add	ah, bh
		pop	bx

		inc	bx
		cmp	bx, 01Fh
		jnz	ReadChkSum2

		call	ee_read
		add	ah, bh

		; is checksum okay?
		sub	ah, 0ffh
		jz	SetChkSum2Exit

		; Need to readjust checksum
		neg	ah

		mov	bx,  PROM_CHKSUM2
		call	ee_read	
		add	ah, bh

		call	Delay_2450

		mov	bx,  PROM_CHKSUM2
		call	ee_write

		call	Delay_2450


SetChkSum2Exit:
		ret
SetChkSum2	endp


;****************************************************************************
;   This function writes bit 1, followed by bit 0 of the argument 'opcode'
;   in AL onto the uwire interface.  The opcode of a desired eeprom operation
;   should be placed in the least significant two bits of the argument
;   'opcode', to write an opcode to the eeprom.
;
;	ax = OpCode
;****************************************************************************
public		ee_opcode
ee_opcode	PROC NEAR

	push	si			; Save used registers

	; Write out MSB of opcode
	push	ax			; Save for future use
	and	al, 2			; Look at bit 1 only
	shr	al, 1			; Put it in bit 0
	or	al, BCR19_ECS		; EEPROM chip select
	sub	ah, ah			; Clear high byte
	mov	si, ax			; SI is argument to uwire_out
	call	uwire_out		; Write the bit to the EEPROM

	; Write out LSB of opcode
	pop	ax			; Retrieve passed-in argument
	and	al, 1			; Look at bit 0 only
	or	al, BCR19_ECS		; EEPROM chip select
	sub	ah, ah			; Clear high byte
	mov	si, ax			; SI is argument to uwire_out
	call	uwire_out		; Write the bit to the EEPROM

	pop	si			; Restore used registers
	ret	

ee_opcode	ENDP

;****************************************************************************
;   This function writes the 6 least significant bits of the argument
;   'address' onto the uwire interface (order:bit 5 to bit 0).  The desired
;   eeprom address should be placed in the 6 least significant bits of the
;   argument 'address' to write an address to the eeprom.
;
;   BX = address to write
;****************************************************************************
public		ee_address
ee_address	PROC NEAR

	push	si			; Save used registers
	push	dx
	push	ax
	push	cx

	xor	dx, dx			; Initialize bit counter

	; Write out MSB to LSB of address
write_address_bit:
	mov	cl, 5			; 5 bits
	mov	ax, dx
	sub	cl, al			; CL = 5 - loop counter
	mov	al, bl			; Passed in address is in BX
	shr	al, cl			; Position the bit to add to the word
	and	al, 1			; Look at just a single bit
	or	al, BCR19_ECS		; EEPROM chip select
	sub	ah, ah			; Clear high bit
	mov	si, ax			; SI is argument to uwire_out
	call	uwire_out		; Write the address bit to the EEPROM

	inc	dx			; Next bit
	cmp	dx, 5			; Did we do 5 bits yet?
	jbe	write_address_bit	; No - read another bit

	pop	cx			; Restore used registers
	pop	ax
	pop	dx
	pop	si
	ret	

ee_address	ENDP

;****************************************************************************
;   This function takes a 16-bit unsigned integer argument, in SI, and
;   writes the lower 5 bits to BCR19, affecting the uwire interface.  A
;   clock edge on the EESK output is generated to clock the uwire interface,
;   causing a single bit write to the EEPROM.
;   SI = value to write
;****************************************************************************
public		uwire_out
uwire_out	PROC NEAR

	push	ax			; Save used registers
	push	bx
	mov	ax, si			; AX = value to write

	; Isolate uwire signals and clear the ESK bit to allow clocking.
	and	ax, 001dH

	; Writes data to uwire interface (ESK low).
	mov	bx, ax			; Data to be written
	mov	ax, BCR19		; Write to EEPROM control register
	call	reg_write

	call	DELAY_2450		; Guarantees fSK, tSKL, and tDIS EE

	or	bx, BCR19_ESK_HIGH	; Make EEPROM serial clock high
	mov	ax, BCR19		; Write to EEPROM control register
	call	reg_write

	call	DELAY_2450		; Guarantees fSK, tSKL, and tDIS EE

	pop	bx			; Restore used registers
	pop	ax

	ret	

uwire_out	ENDP

;****************************************************************************
;   eedo_in - Perform single bit read from EEPROM using uwire interface.
;
;   The bit is returned in AX.
;****************************************************************************
public		eedo_in
eedo_in	PROC NEAR

	push	bx			; Save used registers
	
	; Bring EESK (clock pin) low.
	mov	bx, BCR19_ECS		; EEPROM serial clock
	mov	ax, BCR19		; Write to EEPROM control register
	call	reg_write

	call	DELAY_2450		; Guarantees fSK and tSKL eeprom

	; Clock out EEPROM bit to EEDO pin.
	mov	bx, BCR19_ECS		; EEPROM serial clock
	or	bx, BCR19_ESK_HIGH	; Make EEPROM serial clock high
	mov	ax, BCR19		; Write to EEPROM control register
	call	reg_write

	call	DELAY_2450		; Guarantees fSK and tSKL eeprom
	call	DELAY_2450

	mov	ax, BCR19		; Read from EEPROM control register
	call	reg_read		; Read the bit
	and	ax, 1			; Look at just a single bit

	pop	bx			; Restore used registers

	ret	

eedo_in	ENDP

;****************************************************************************
;   reg_write - Write a 16-bit value to the specified CSR or BCR register.
;
;   Use a 16-bit I/O instruction.  A BCR write is performed.
;   
;
;	DI = IOBase
;	AX = number of the specific register to access
;	BX = data
;****************************************************************************
public		reg_write
reg_write	PROC NEAR

	push	dx			; Save used registers
	push	ax
	
	mov	dx, di			; Base IO address
	add	dx, RAP_OFFSET		; Write to Register Address Port
	out	dx, ax			; Write register to be accessed

	mov	ax, bx			; Data to be written

	mov	dx, di			; Base IO address
	add	dx, BDP_OFFSET		; Write to Bus Data Port
	out	dx, ax			; Write data to register

	pop	ax			; Restore used registers
	pop	dx

	ret	

reg_write	ENDP

;****************************************************************************
;   reg_read - Read a 16-bit value from the specified CSR or BCR register.
;
;   Use a 16-bit I/O instruction.  A BCR read is performed.
;   
;   IOAddress1 is expected to contain the correct I/O address.
;   AX contains the register to read on entry.  On exit, AX contains
;   the value just read.
;
;	DI = IOBase
;	AX = number of the specific register to access
;
;****************************************************************************
public		reg_read
reg_read	PROC NEAR

	push	dx			; Save used registers

	mov	dx, di			; Base IO address
	add	dx, RAP_OFFSET		; Write to Register Address Port
	out	dx, ax			; Write register to be accessed

	mov	dx, di			; Base IO address
	add	dx, BDP_OFFSET		; Write to Bus Data Port
	in	ax, dx			; Read data from register

	pop	dx			; Restore used registers

	ret	

reg_read	ENDP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\amd\spdosegs.inc ===
;
; Modifications:   $Header:   J:/archives/preboot/lsa2/inc/SPDOSEGS.INV   1.5   19 Sep 1997 21:39:18   MJOHNSOX  $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;

;
;   Description: segment declaration and ordering for NDIS driver
;


;-----------------------------------------------------------------------
;
; Functional Description
;
;   This file defines the segments used by a MAC driver and the order
;   in which they are loaded. The groups DGROUP (for data) and CGROUP
;   (for code) are also defined, as are macros to open and close
;   segments (which also set up the default segment assumptions).
;
;-----------------------------------------------------------------------

;=======================================================================
;** Segment Definitions - order counts!
;
; DOS Order:
;      CGROUP, DGROUP
;         DevHeaderSeg
;         _TEXT
;         _DATA 
;         CONST
;         _BSS
;   ; Code and data will be cut off here.	;; AVL - not any more
;         ICODE
;         IDATA
;
; AVL - NEW Order:
;   CGROUP
;         DevHeaderSeg
;         _TEXT
;		  ICODE		;; DOS driver specific init routines, not needed for ROM
;	 DGROUP
;         _DATA 
;         CONST
;         _BSS
;         IDATA		;; just to mark the upper boundary.
;
;========================================================================


;==========================================================================
; DOS segment definitions and ordering.
;==========================================================================
Ifdef DRV
DevHeaderSeg   segment para public USE16 'CODE'
DevHeaderSeg   ends
Endif	;; DRV
;--------------------------------------------------------------------------
; Resident Code segment - code that is used after init time
; (unfortunately, this includes code to bind another driver, and
; initializations that take place at bind time) should be placed in this
; segment.
;--------------------------------------------------------------------------
_TEXT       segment para public USE16 'CODE'
_TEXT       ends

Ifdef DRV
ICODE       segment para public USE16 'INIT'
ICODE       ends
Endif	;; DRV
;--------------------------------------------------------------------------
; Resident Data segment - things put here will remain in memory after
; init time. At the present time, this is in low memory, so data that is
; not used after init time should NOT be put in this segment.
;--------------------------------------------------------------------------
_DATA       segment para public USE16 'DATA'
_DATA       ends

Ifdef DRV
_BSS       segment para public USE16 'DATA'
_BSS       ends
IDATA       segment para public USE16 'DATA'
IDATA       ends
Else
_BSS       segment para public USE16 'BSS'
_BSS       ends
Endif	;; DRV
;--------------------------------------------------------------------------
; Make sure the segment order defined in this file is respected.
;--------------------------------------------------------------------------
.SEQ               


;--------------------------------------------------------------------------
; DOS Group is all one 64K segment, CS=SS=DS, use equate for DGROUP.
;--------------------------------------------------------------------------

;DGROUP      equ     CGROUP
;CGROUP      group   DevHeaderSeg, _TEXT, _DATA, CONST, _BSS, ICODE, IDATA

Ifdef DRV
CGROUP      group   DevHeaderSeg, _TEXT, ICODE
DGROUP      group   _DATA, _BSS, IDATA
ELSE
CGROUP      group   _TEXT
DGROUP      group   _DATA, _BSS
Endif	;; DRV
;--------------------------------------------------------------------------
; Group is 64K data, 64K code, CS!=SS=DS, actual group for Code.
;--------------------------------------------------------------------------

;--------------------------------------------------------------------------
; Assume statement here takes care of for any source, same for OS2 and DOS.
;--------------------------------------------------------------------------
    Assume   CS:CGROUP, DS:DGROUP, ES:NOTHING, SS:NOTHING


; EOF - $Workfile:   spdosegs.inc  $
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\amd\undi_equ.inc ===
;
;--- Miscellaneous Equates
;
CR		equ	0Dh           ;- Carriage Return
LF		equ	0Ah           ;- Line Feed
FALSE		equ	0
TRUE		equ	1
;
;--- Ethernet Frame Sizes
;
ETHERNET_ADDRESS_LENGTH		equ	6
ETHERNET_HEADER_SIZE		equ	14
MINIMUM_ETHERNET_PACKET_SIZE	equ	60
;MAXIMUM_ETHERNET_PACKET_SIZE	equ	1514
MAXIMUM_ETHERNET_PACKET_SIZE	equ	1500 ;; just data, not media header

MAX_PACKET         Equ       1514      ; Maximum allowable packet size.
MIN_PACKET         Equ       60        ; Minimum allowable packet size.
; 
;--- Packet filter bit definitions
; 
FLTR_DIRECTED                Equ       01H
FLTR_MLTCST                  Equ       01H
FLTR_BRDCST                  Equ       02H
FLTR_PRMSCS                  Equ       04H
FLTR_SRC_RTG                 Equ       08H
;
;--- Processor Type Equates
;
EIGHT_BIT          equ       0001H
SIXTEEN_BIT        equ       0002H
PROC_TYPE_MASK     equ       0030H

PROC_8086          equ       0000H OR EIGHT_BIT
PROC_80286         equ       0010H OR SIXTEEN_BIT
PROC_80386         equ       0020H
PROC_80486         equ       0040H
;
;--- Result codes returned in AX by a PXE API service.
;
PXENV_EXIT_SUCCESS		equ	0
PXENV_EXIT_FAILURE		equ	1
PXENV_EXIT_CHAIN		equ	0FFFFh	; used internally
;
;--- Status codes returned in the status word of PXE API parameter structures.
;
PXENV_STATUS_SUCCESS		equ	0
PXENV_STATUS_FAILURE		equ	1	;general failure
PXENV_STATUS_BAD_FUNC		equ	2	;invalid function number
PXENV_STATUS_UNSUPPORTED	equ	3	;not yet supported
PXENV_STATUS_1A_HOOKED		equ	4	;Int 1AH cannot be unhooked

; Driver errors (60 to 0x6F)
; These errors are for UNDI compatible NIC drivers.
PXENV_STATUS_UNDI_MEDIATEST_FAILED 		equ	61h
PXENV_STATUS_UNDI_CANNOT_INIT_NIC_FOR_MCAST	equ	62h
;
;
EISA_ADAPTER             equ    1
PCI_ADAPTER              equ    2
PnP_ADAPTER              equ    3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\amd\bwamd.inc ===
;====================================================================
; BWAMD.INC - Generic Transmit, receive code for NE2100 and AT1500.
;		Based on AMD Ethernet Chipset
;
;;	 CONDITIONALS
;;	 /dGILBUG to generate debug version which prints all error cond
;;	 /dTSR	  for TSR version
;;
;;   (C) Lanworks Technologies Inc. 1992-1995 All rights reserved.
;;
;---------------------------------------------------------------------
; BWAMD.INC
;
; Date	 Ver	Dev	Comments
;
; 9701XX 1.XX GY    - fix problem when more than 800h packets are received
; 961022 1.XX GY    - support for Multicast/Broadcast reception in
;		      NADChgReceiveMask. Newer controller allows disable
;		      broadcast reception in CSR15
; 960206 1.60 GY    - packet size between 60 and 64 bytes are not transmitted
;			properly
; 950928 1.40 GY    - Split up AT1500 and NE2100. Both will share BWAMD.INC
;		      as the include file. Take out all Non AT1500 code
;
;---------------------------------------------------------------------

; used to Acknowledge the Interrupt from the controller,
; but disable further controller Interrupts until we service
; the current interrupt.
; writing a "1" to RINT, TINT and IDON should clear up the interrupt
ACKNOWLEDGEINT	equ (CSR0_INEA or CSR0_TDMD or CSR0_STOP or CSR0_STRT or CSR0_INIT)

; Stored in InterruptFlag to indicate type of interrupt serviced
INTRXANY	equ	0ffh		; Any receive interrupt
INTINIT 	equ	0100h		; Initialization done interrupt
INTTX		equ	0200h		; Transmit interrupt
INTINITERR	equ	0400h		; Initialization error
INTTXERR	equ	0800h		; Transmit Error
INTRXERR	equ	02000h		; Receive error
INTNO		equ	04000h		; No interrupt source
INTRXOVF	equ	08000h		; Rx buffers all used up
INTERR		equ	0fc00h		; any error



;include	 \rom\genr\include\nadcode.inc
;------------------------------------------------------------------------------
; StartTime - save maxtick count, get current tick value
;	Timeout is ticks, each tick is 55 ms.
;	Note: this routine can only be called once the PC timer
;	and its interrupt are setup (INT19 and beyond are OK)
;
; On entry,
;	AX = max ticks to wait
;	ints enabled
;
; On exit,
;	all preserved
;
; 881030 1.0 GK
;------------------------------------------------------------------------------

StartTime	proc	near

		push	ax
		push	cx
		push	dx
        push    di  
        push    es

		mov	DGroup:MaxTicks, ax
;;		mov	ah, 0
;;db  0f1h
;;		int	1Ah				; get current tick value
        mov     ax, 40h
        mov     es, ax
        mov     di, 6Ch
        mov     dx, es:[di]
        mov     cx, es:[di+2]
		mov	DGroup:StartTick, dx		; save it

        pop es
        pop di
		pop	dx
		pop	cx
		pop	ax
		ret

StartTime	endp

;------------------------------------------------------------------------------
; CheckTime - gets current tick value, compares with maxticks
;	Timeout is ticks, each tick is 55 ms.
;	Note: this routine can only be called once the PC timer
;	and its interrupt are setup (INT19 and beyond are OK)
;
; On entry,
;	maxticks set by StartTime
;	ints enabled
;
; On exit,
;	CY set if timeout
;	all registers preserved
;
; 881030 1.0 GK
;------------------------------------------------------------------------------

CheckTime	proc	near

		push	ax
		push	cx
		push	dx
        push    di  
        push    es

;;		mov	ah, 0
;;		int	1Ah			; get current tick

        mov     ax, 40h
        mov     es, ax
        mov     di, 6Ch
        mov     dx, es:[di]
        mov     cx, es:[di+2]

		sub	dx, DGroup:StartTick
		cmp	dx, DGroup:MaxTicks
		cmc

        pop es
        pop di
		pop	dx
		pop	cx
		pop	ax

		ret				; return with CY set if timeout

CheckTime	endp



;------------------------------------------------------------------------------
;	SetCardAddr
;	Function: Fetch the station address stored in the adapter's PROM. Called
;		  during initialization
;	Modify: NIDNetAddress - the station address is stored in the last
;				   six bytes of this variale
;	Remarks: There is no need to set the card address. The card will
;		automatically use the PROM's Ethernet address to
;		configure the board
;
;------------------------------------------------------------------------------

		assume	cs:CGROUP, ds:DGROUP

SetCardAddr	proc	near
		push	ax
		push	cx
		push	dx
		push	di

		mov	cx,6		; A total of 6 bytes are transferred
		mov	dx, DGroup:IOBase
		add	dx, REGADDR1
		push	ds
		pop	es
		mov	di, offset DGroup:Net_Address
SetCardLoop:	
        in	al,dx		; Fetch address from I/O port
		stosb			; Store address bytes
		inc	dx		; Next I/O port
		loop	SetCardLoop

		pop	di
		pop	dx
		pop	cx
		pop	ax
		ret
SetCardAddr	endp




;----------------------------------------------------------------------
;  Routine Name:  NADPoll Routine
;
;  Description: The NADPoll routine is used by the RIPL ROM NID
;		portion of the RIPL ROM to poll the driver portion so
;		that the driver portion can do timeout work.
;
;  Input:	DS - Data Segment of RPL Module
;		ints enabled
;
;  Output:	DS preserved
;		ints enabled
;
;  Calls:	none
;----------------------------------------------------------------------
NADPoll 	proc	far

		retf

NADPoll 	endp

;----------------------------------------------------------------------
;  Routine Name:  NADDisengage Routine
;
;  Description: The NADDisengage routine is used by the RIPL ROM NID
;		portion of the RIPL ROM to signal the Network Driver
;		to release its IRQ, DMA, and memory resources.
;
;  Input:	DS - Data Segment of RPL Module
;		ints enabled
;
;  Output:	DS preserved
;		ints enabled
;		ax = offset to error string or 0 if successful
;
;  Calls:	none
;
; July 10,91	implement NIDDisengage version 0.8
;----------------------------------------------------------------------

NADDisengage	PROC	FAR
		push	ds

		; reset card first
		mov	ax, CSR0_STOP
		mov	bl, CSR0
		call	CSROut

		cmp	ax,CSR0_STOP	; All the bits in CSR0 are cleared
					; except the stop bit
		jnz	NADDisErr	; Error if STOP bit not set

        cli
		; Mask interrupt level
		mov	dx, DGroup:MaskReg
;;		in	al, dx
        mov al, byte ptr DGroup:OldMaskReg
;;		or	al, DGroup:IRQLine
		out	dx, al

		; Problem with AT1500.DOS ver 1.32 when IRQ2 is used.
		; v1.32 driver install Interrupt Handler @ int ah rather
		; than int 71. Deinstall Handler and restore old vector will
		; solve the problem
		push	es
;;		mov	bx, DGroup:OldIntVector[2]	 ; segment
;;		mov	dx, DGroup:OldIntVector[0]   ; offset

		mov	    bx, DGroup:OrgIntVector_SEG	 ; segment
		mov	    dx, DGroup:OrgIntVector_OFF   ; offset

		xor	ax,ax
		mov	es,ax		; segment for vector address is 0
		mov	ax, DGroup:IntVect

;db  0f1h
		mov	di, ax
		mov	es:[di], dx
		add	di,2
		mov	es:[di], bx
		pop	es

        sti

;;        mov bx, 5
;;        call    csrIn
;;        mov     bx, ax
;;    	mov	dx, [IOBase]
;;    	add	dx, REGRESET
;;    	in	ax, dx		; start an S_RESET (takes 1us).

;;        test    bx, 2
;;        jz      @F
;;        call    AMD_enable_magic_packet

@@:
		xor	ax,ax		; indicate no error
		pop	ds
		retf			; Return to caller

NADDisErr:
		mov	ax, -1
		pop	ds

		retf

NADDisengage	ENDP


;------------------------------------------------------------------------------
;	SetupRing
;
;	Purpose : 1. Convert # of buffers to power of twos
;		  2. Convert dx from segment:offset to a 24 bit address
;	In :	ax = # of buffers
;		dx = pointer to buffer
;	Out:	ax = first byte of transmit descriptor ring pointer
;			Bit 15:13 Transmit ring length
;			Bit 7:0   high order byte of pointer to buffer
;		dx = second byte of transmit descriptor ring pointer
;			Bit 15:0  Lower word pointer to buffer
;	Remarks: follow sample in Diag_Sub.c (form_phy_address)
;		 follow sample in Diag_Sub.c (cal_num_rings)
;		 Used for setting up 1. CSR1 and CSR2
;				     2. Receive Descriptor ring pointer
;				     3. Transmit descriptor ring pointer
;	Assume : ax = 1,2,4,8,16,32,64 or 128 ( power of 2)
;
;------------------------------------------------------------------------------
SetupRing	proc	near
		push	bx
		push	cx
        push    di
;        push    ds

        
        mov ebx,    CR0
        test    bx, 1
        je      real_mode

; We are in protected mode:

;db  0f1h
        
;        xor     ebx,    ebx
;        mov     bx, ds
;        test    bx, 4h
;        je      gtxx
;        sldt    DGroup:LDT1
;        jmp short    @F
;gtxx:    
;        sgdt    DGroup:GDT
;@@:     
        mov     di, DGroup:StoreDS
        jmp short   @F
        
real_mode:

        mov     di, ds            
@@:
		cmp	ax,0
		jz	SetupRingZero	; No need to check if # of buffers = 0

		mov	bx,1
		mov	cx,7

SetupRingLoop:	test	bx,ax
		jnz	SetupRingMatch	; jump if match is found

		shl	bx,1		; move the bit left
		loop	SetupRingLoop

SetupRingMatch: not	cx

		sub	cx,not (7h)	; means 8 - cx
					; not(7h) = 2's complement of 8

		shl	cx, 13

; Detect what mode we are now :

;db  0f1h

;db  0f1h
		mov	ax, cx
;        mov bx, ds
;        push    ds
;        pop     cx
;        mov di, ds    
@@:
;		mov	ax, cx

SetupRingZero:	
        
        mov	bx, di		; move segment
		shr	bx, 12

		or	ax,bx


		mov	bx, di

		shl	bx, 4

		add	dx,bx		; add the offset and segment/16
		jnc	SetupRingEnd

		inc	ax		; overflow means increment segment

SetupRingEnd:	

;        pop ds
        pop di
        pop	cx
		pop	bx
		ret
SetupRing	endp

; --------------------------- ISR Routines  -------------------------------

;------------------------------------------------------------------------------
;	bootISR
;	Function : This ISR will service all interrupt. It services the host
;		   interrupt (EOI). It determines the type of interrupt and
;		   jump to the appropriate ISR. All errors in CSR0 will be
;		   stored in variable ISRErr
;
 ;	 Remarks :  Follow sample in INT_HAND.ASM (AT1500_isr)
;------------------------------------------------------------------------------
BootISR 	proc	far

;IFDEF	 DEBUG
;	push	ax
;	mov	al, '.'
;	call	PutChr
;	pop	ax
;
;ENDIF

;;db	 0F1h

		pusha
		pushf
		push	es
		push	ds

;		push	cs
;		pop	ds

		push	ds
		pop	es		; es=ds

		mov	bl, CSR0
		call	CSRIn


		; if nothing is set, don't do anything
;931019;ignore CSR0_CERR for AUI port		     test    ax, ( CSR0_INTR or CSR0_CERR )
		test	ax,  CSR0_INTR
		jz	BootISREnd

		; Acknowledge interrupt from controller
		; Clear INEA to disable interrupt until current interrupt is
		; serviced
		; Flags cleared include receive interrupt, transmitter interrupt
		; initialization done, babble flag, collision error, miss packet
		; memory error

		mov	bx,ax		; have 2 copies of CSR0
		and	ax,not ACKNOWLEDGEINT
		mov	dx, DGroup:IOBase
		add	dx, REGRDP
		out	dx,ax		; still CSR0
		in	ax,dx		; follow all write with read

		mov	ax,bx		; restore CSR0 to ax


		test	bx,CSR0_MERR
		jz	BootChkTx	; Jump if no error

		mov	ax,DGroup:InterruptFlag
		or	ax, INTERR	 ; all error bits are set
		mov	DGroup:InterruptFlag,ax

		mov	DGroup:ISRErr,bx
		mov	DGroup:ISRErrFlag,TRUE
		jmp	BootEnableInt

BootChkTx:	; determine what type of interrupt it is and call appropriate
		; ISR
;931019;ignore CSR0_CERR for AUI port		     test    bx,(CSR0_TINT or CSR0_BABL or CSR0_CERR )
		test	bx,(CSR0_TINT or CSR0_BABL )

		jz	BootChkRecv	; Is it a transmit interrupt

		call	TxISR

BootChkRecv:	test	bx,(CSR0_RINT or CSR0_MISS) ; Is it a receive interrupt
		jz	BootChkInit

		call	RecvISR
        jnc     @F
        mov     DGroup:ReceiveError, 1
;	 int 03
@@:
BootChkInit:	test	bx,CSR0_IDON
;970527 	jz	BootEnableInt
		jz	BootChkUInt

		mov	ax,bx		; ax now has CSR0
		test	ax,CSR0_ERR
		jz	BootInitOK

		mov	ax, DGroup:InterruptFlag
		or	ax, INTINITERR
		mov	DGroup:InterruptFlag,ax
		jmp	BootEnableInt

;970527
BootChkUInt:				; see if it's a user-interrupt
		mov	bl, CSR4
		call	CSRIn		; b6, UINT will be set if so
		test	ax, 0040h
		jz	BootEnableInt	; not a user interrupt

; clear the user interrupt by writing a 1 back to b6 of CSR4

;    	db  0F1h
		call	CSROut
;		jmp	short BootEnableInt
;		jmp	short ReallyOk
;970527

BootInitOK:
;		mov	    bl, CSR4
;		call	CSRIn
;	test	ax, CSR4_UINT
;	jz	ReallyOk
;	jz	BootEnableInt
;	int	03

;ReallyOk:
		mov	ax,DGroup:InterruptFlag
		or	ax, INTINIT
		mov	DGroup:InterruptFlag,ax
					; There is no need to do any processing
					; for initialization done interrupt


BootEnableInt:
		mov	al,EOI
		out	20h,al		; Master Controller
		mov	dx,DGroup:MaskReg	; Get (0cw0) mask register address
		cmp	dx,021h
		jz	MasterCnt
					; al still contains EOI
		out	0a0h,al 	; Slave controller

MasterCnt:
; For some reason, interrupt is masked 961216 {
		mov	ah,DGroup:IRQLine
		not	ah

		mov	dx,DGroup:MaskReg	; Address of mask register
		in	al,dx		; Get old mask byte
		and	al,ah		; unmask the correct bits
		out	dx,al		; Enable the interrupt
; For some reason, interrupt is masked 961216 }


		; Need to enable interrupt again
		mov	bl, CSR0
		mov	ax, CSR0_INEA
		call	CSROut

BootISREnd:
		pop	ds
		pop	es
		popf
		popa
		iret
BootISR 	endp

;------------------------------------------------------------------------------
;	TxISR
;	Purpose : Interrupt service routine for transmit
;	On entry,	bx = CSR0 status
;------------------------------------------------------------------------------
TxISR		proc	near

;;db	 0F1h

;	 int	 03
		push	bx
;931019;ignore CSR0_CERR for AUI port		     mov     ax,bx
;931019;ignore CSR0_CERR for AUI port		     test    ax,CSR0_ERR
;931019;ignore CSR0_CERR for AUI port		     jnz     TxISRErr	     ; CSR0 indicates error

		mov	ax,DGroup:TxMsgBlock[0].TxTmd1
		test	ax,Tmd1Own
		jnz	TxISRErr	; Did card give up ownership

		test	ax,Tmd1Err	; check for error
		jnz	TxISRErr	 ; Error indicated in Tmd1??

		; Pass all the error testing
		mov	ax,DGroup:InterruptFlag
		or	ax, INTTX
		mov	DGroup:InterruptFlag,ax; Check for other interrupts rather
					; than jumping to exit routine
IFDEF		GILBUG
		push	ax
		mov	ax,0e20h	; print " "
		int	010h
		mov	ax,0e54h	; print "T"
		int	010h
		mov	ax,0e54h	; print "T"
		int	010h
		mov	ax,0e20h	; print " "
		int	010h
		pop	ax

ENDIF
		jmp	TxISREnd

TxISRErr:	mov	ax,DGroup:InterruptFlag; set transmit error flag
		or	ax, INTTXERR
		mov	DGroup:InterruptFlag,ax

TxISREnd:	pop	bx
		ret
TxISR		endp

;------------------------------------------------------------------------------
;	RecvISR
;	Purpose : Interrupt service routine for receive
;		  check if packet received is a broadcast. If so, reject packet
;	On entry,	bx = CSR0 status
;	Exit	       ; z flag set	 means broadcast or error
;		       ; z flag cleared  means not broadcast
;------------------------------------------------------------------------------
RecvISR 	proc	near


;	 int	 03
		push	bx
		push	ax
		push	cx
		push	dx


;IFDEF	 DEBUG
;	push	ax
;	mov	al, '~'
;	call	PutChr
;	pop	ax
;
;ENDIF

		; if AM7990 MISS a packet, just quit without getting and
		; returning an ED
		test	bx, CSR0_MISS
        jz  @F
;;;db  0f1h
		jmp short	RxISRErrJmp
;;		jnz	RxISRErrJmp

@@:
NextBuffer:
		; the offset for Rmd1 is determined by the InterruptFlag not
		; RecvRingOffset
		push	di
		push	cx
		xor	cx,cx
		push	bx

		mov	bx, NumRxBuf	; used to check if RecvIntCount is
					; multiple of 8
		xor	dx, dx
		mov	ax, DGroup:RecvIntCount

		div	bx
		mov	ax, dx		; move reminder to AL
		or	ax, ax		; is RecvIntCount multiple of NumRxBuf?
		pop	bx
		jz	RecvISRFoundOff

RecvISRSub:	add	cx, RINGSIZE
		dec	al
		jz	RecvISRFoundOff

		jmp	RecvISRSub

RxISRErrJmp:	jmp	RxISRErr	; Jump


RecvISRFoundOff:
		mov	di, offset DGROUP:RxMsgBlock[0].RxRmd1

		add	di,cx
		pop	cx
		mov	ax,ds:[di]
		pop	di

		test	ax, Rmd1Own
        jz  @F
        
;;;db  0f1h
		jmp short	RxISRErrJmp
;;		jnz	RxISRErrJmp	; Did card give up ownership

@@:
		test	ax,  Rmd1Fram or Rmd1Crc or Rmd1BufErr
;		mov	ax,1		; indicate not a broadcast
        jz  @F

;;db  0f1h
;;		jmp short	RxISRErrJmp
;;		jnz	RxISRErrJmp
        mov     DGroup:ReceiveError, 1

@@:
		; 970225 NCR sees problem where RMD1.ENP is not set
		; even though all my buffers are MTU and error bits
		; should be set
ChkEndofPacket:
		test	ax, Rmd1End
		jnz	Rmd1EndOk

		inc	DGroup:RecvIntCount
		jmp	NextBuffer

Rmd1EndOk:
		; Check if this is the first packet received
		mov	ax, DGroup:RecvIntCount
		or	ax, ax
		jnz	RecvNotFirst

		mov	ax, DGroup:InterruptFlag
		or	dx, INTRXANY
		mov	DGroup:InterruptFlag, ax
		jmp	ProcessRecv


RecvNotFirst:	; confusing part. The buffer offset RecvBufOffset,
		; RecvRingOffset, UpdateBufOff and UpdateRingOff are manipulated
		; so that the PROM will have access to a "continuous" supply
		; of receive buffers.
		; See notes on January 6,92
		; Packet #0-5	increment RecvBufOffset, RecvRingOffset
		; Packet #6,7,9 increment RecvBufOffset, RecvRingOffset
		;		increment UpdateBufOffset, UpdateRingOffset
		; Packet #8	set to 0  RecvBufOffset, RecvRingOffset
		;		increment UpdateBufOffset, UpdateRingOffset
		; Packet #14	increment RecvBufOffset, RecvRingOffset
		;		set to 0  UpdateBufOffset, UpdateRingOffset
		;
		mov	cx, NumRxBuf	; should be 8
		xor	dx, dx
		mov	ax, DGroup:RecvIntCount
		cmp	ax, 6
		jb	RecvPktB6	; jump if less than 6 packets received

		div	cx
		or	dx, dx		; is remainder 0 ?
		jz	RecvPkt8	; need to reset receive buffer pointers

		xor	dx, dx
		mov	ax, DGroup:RecvIntCount
		sub	ax, 6
		div	cx
		or	dx, dx		; is remainder 0 ?
		jz	RecvPkt14	; need to reset update buffer pointers

		; For any other packets, we update buffers for both RecvBuf
		; & UpdateBufOff
		add	DGroup:RecvBufOffset, PACKETSIZE
		add	DGroup:RecvRingOffset, RINGSIZE
		add	DGroup:UpdateBufOff, PACKETSIZE
		add	DGroup:UpdateRingOff, RINGSIZE
		call	ReleaseBuffer
		jmp	short ProcessRecv

RecvPkt14:	; packet # - 6 is a multiple of 8
		add	DGroup:RecvBufOffset, PACKETSIZE
		add	DGroup:RecvRingOffset, RINGSIZE
		mov	DGroup:UpdateBufOff, 0
		mov	DGroup:UpdateRingOff, 0
		call	ReleaseBuffer
		jmp	short ProcessRecv

RecvPkt8:	; Packet # is a multiple of 8
		mov	DGroup:RecvBufOffset, 0
		mov	DGroup:RecvRingOffset, 0
		add	DGroup:UpdateBufOff, PACKETSIZE
		add	DGroup:UpdateRingOff, RINGSIZE
		call	ReleaseBuffer
		jmp	short ProcessRecv

RecvPktB6:	; below packet # 6
		add	DGroup:RecvBufOffset, PACKETSIZE
		add	DGroup:RecvRingOffset, RINGSIZE

ProcessRecv:	; fetch an ED for the received packet


        cmp DGroup:ReceiveError, 1
        jne @F 

		pushf
		inc	DGroup:RecvIntCount
		popf
        jmp short RxISRErr
        
@@:

		push	bx
		xor	ax, ax
    	call	GetED

		pop	bx
		mov	word ptr DGroup:RxEDPtr, si
		mov	word ptr DGroup:RxEDPtr+2, es
;        clc
;;        jnz   @F
;;db  0f1h
		jz    RxISRErr
;@@:
;	 int	 03

		call	PacketReceived
		pushf
		inc	DGroup:RecvIntCount
		popf
		jnc	RecvISREnd

;;ReturnED:

;;db  0f1h    

;;		les	si, ds:RxEDPtr
;;		push	bx
;;    	call	ReturnED
;;		pop	bx
;;        jz	RxISRErr
RxISRErr:

;;db  0f1h    

        stc

IFDEF		GILBUG

		mov	ax,InterruptFlag; set receive error flag
		or	ax,IntRxErr
		mov	InterruptFlag,ax
		jmp	RecvISREnd
ENDIF

RecvISREnd:  ;;;	 or	 ax,ax		 ; set zero flag
		pop	dx
		pop	cx
		pop	ax
		pop	bx
		ret
RecvISR 	endp

;------------------------------------------------------------------------
;
; SYNOPSIS:	call PacketReceived
;
; ON ENTRY:	bx - address of RBD containing packet
;		es = CGROUP
;
; DESCRIPTION:	This routine is called by the interrupt handler to
;		hand the packet off to the next higher level.
;
;
; REGISTERS:	bx, ds saved; others destroyed
;
; RETURNS:	carry set = error , return ED unchanged
;		carry clear = no error
;
; CALLED BY:	ProcessFRInt
;
; 881101 1.0 George Kostiuk
;------------------------------------------------------------------------
public		PacketReceived
PacketReceived	proc	near

;int 03

		; set up segment registers so that
		; es = segment of ED
		; ds = segment where ROM Code is
		; cs = segment where ROM Code is
;		push	cs
;		pop	ds
		assume	ds:DGROUP

		; Make sure packet is not a broadcast (check dest address)
		; temporarily set ES=CS
        cld
ChkAddress:
		push	ds      ;  !!!!!!!!!!!!!!! cs
		pop	es
		mov	si, offset DGroup:RxPacket[0].DestAddr[0]

		add	si, DGroup:RecvBufOffset
		mov	bx, si			; save pointer to packet in bx also
		jmp	short OkAddress

ReturnRxEDJmp:
		jmp	ReturnRxED


OkAddress:

; Cannot use MAC header length for Eth II PROMs ( bootP & NW_EthII )
; Use the Rmd3	 instead
		mov	si, offset DGroup:RxMsgBlock.RxRmd3
		add	si, DGroup:RecvRingOffset
		lodsw
		and	ax, 0fffh

		mov	dx,ax			; MAC Length

		mov	DGroup:PacketLen, ax

		les	bp, DGroup:RxEDPtr		; ES:BX point to ED


		mov	es:[bp].ED_Length, dx	 ; Set good completion
		mov	cx, es:[bp].ED_FragCount
		jcxz	NoRxFrag		; there are no fragments

; setup source ptr (points to data in packet past the header)
		lea	si, [bx]
		lea	bp, [bp].ED_FragOff	; point to 1st descriptor
		push	bx

DRxNxtF:
    	push	cx
		push	es
		mov	cx, es:[bp].DLen	; CX has frag len

        
        mov di, WORD PTR es:[bp].DPointer
;		les	di, es:[bp].DPointer	; ES:DI ptr to frag



ChkMovSize:	
        cmp	dx, cx
		ja	MoveFrag	; more data after this frag

		mov	cx, dx		; no more data after this frag

MoveFrag:	sub	dx, cx		; subtract size of this frag
		jcxz	DrxDoNxt	; zero count -- skip data read

		rep	movsb		; move data from card to ED

DrxDoNxt:	pop	es
		pop	cx
		add	bp, 6		; point to next fragment desc
		loop	DRxNxtF 	; do next frag, if any

		pop	bx

; -- DX has # of bytes that couldn't fit in receive descriptors

NoRxFrag:	
;        push	cs
;		pop	ds			; DS = CS
		assume	ds:DGROUP
IFDEF		DEBUG
		int	3
ENDIF

		push	ds
		les	si, DGroup:RxEDPtr
		mov	es:[si].ED_ErrCode, 0	; Set good completion
		; Generic routines need ds=code segment
;		push	cs
;		pop	ds
		push	bx


;	 int	 03
;	call	PostED

		pop	bx
		pop	ds

		clc			; indicate no problem

IFDEF		GILBUG
		push	ax
		mov	ax,0e20h	; print " "
		int	010h
		mov	ax,0e52h	; print "R"
		int	010h
		mov	ax,0e52h	; print "R"
		int	010h
		mov	ax,0e20h	; print " "
		int	010h
		pop	ax
ENDIF

		ret

ReturnRxED:	stc			; indicate error
		ret

PacketReceived	endp

;----------------------------------------------------------------------
; Routine Name: ReleaseBuffer
;
; Description: Release the buffer pointed by UpdateBufOff and UpdateRingOff
;	       by setting the Ownership bit in RMD1. This allows the
;	       AMD access to a continuous streams of buffers for packets
;----------------------------------------------------------------------
ReleaseBuffer	proc	near
		push	ax
		push	di
		mov	di, offset DGroup:RxMsgBlock[0].RxRmd1
		add	di, DGroup:UpdateRingOff
		mov	ax, ds:[di]
		or	ax, DGroup:RxMsgMode	; set ownership bit
		mov	ds:[di], ax
		pop	di
		pop	ax
		ret
ReleaseBuffer	endp

; --- Transmit Routines -----------------------------------

;----------------------------------------------------------------------
;  Routine Name:  NADTransmitPacket Routine
;
;  Description: The NADTransmitPacket Routine accepts all directed
;		send requests from the RIPL ROM NID code.  This
;		routine determines the validity of the request and
;		works with the adapter to carry it out.
;
;  Input:	ES:SI - pointer to ED
;		DS - Data Segment of RPL Module
;		ints disabled (spec says enabled)
;
;  Output:	ED Completion Code field updated
;		DS preserved
;		ints enabled (doesn't matter)
;
;  Calls:	TransmitPacket
;----------------------------------------------------------------------

		PUBLIC	NADTransmitPacket
NADTransmitPacket	 PROC	near

;int 03        

;931021SkipDefer:
;db  0f1h
		push	ds
		pushf
		sti			; interrupt should be enabled

;	 int  03

		mov	word ptr DGroup:TxEDPtr, si	; save Tx ED ptr
		mov	word ptr DGroup:TxEDPtr+2, es

		mov	ax, TIME100MS
		call	StartTime

		; Reset card before doing anything
		mov	ax, CSR0_STOP
		mov	bl, CSR0
		call	CSROut

		mov	dx, DGroup:IOBase
		add	dx, REGRDP

		mov	ax, TIME100MS
		call	StartTime

NetSendReset:	;mov	 dx,IORDP	 ; read register back
		in	ax,dx
		cmp	ax,(CSR0_STOP)
		jz	TxResetOK	; Jump if reset is Okay

		call	CheckTime
		jnc	NetSendReset	; check status again if not timeout

TxResetOK:
		; clear StatusMsgFlag
		mov	DGroup:[StatusMsgFlag],0
		mov	DGroup:InterruptFlag,0
		mov	DGroup:RecvBufOffset,0
		mov	DGroup:RecvRingOffset,0
		mov	DGroup:ISRErrFlag,FALSE; Clear flag
		mov	DGroup:RecvIntCount,0	; indicate which RxPacket buffer is used

		; set up segment registers so that
		; ds = segment of ED
		; es = segment where ROM Code is
		; cs = segment where ROM Code is
;		push	es
;		pop	ds
		push	ds  ; !!!!!!!!!!!!!! es !!!!!!!!!!!!!!!
		pop	es
		assume	es:DGROUP

;  Now, get the ED pointer to the transmit data buffer descriptor and
;  verify the fields contained in it.

		mov	ax, INVALID_PARAMETER	; Set error code
		mov	cx, ds:[si].ED_FragCount   ; Get data count
		jcxz	SetEDCCodeJmp		; err if total # of ptrs = 0

		jmp	short GetDataLen ; temp

SetEDCCodeJmp:	; when there is an error, post ED now with return code
		; set appropriately
		lds	si, DGroup:TxEDPtr
		mov	ds:[si].ED_ErrCode, ax	; Set return code
		push	ds			; es = ED segment
		pop	es
;		push	cs			; Set DS = CS
;		pop	ds			;
		jmp	TransmitEnd

GetDataLen:	;  Get total data size in AX by adding up frame descriptors
		xor	ax, ax
		lea	bx, [si].ED_FragOff	; point to first framedesc

SumDataLen:
		add	ax, ds:[bx].DLen
		add	bx, size Descript_Struct ; next descriptor
		loop	SumDataLen

		mov	DGroup:PacketLen,ax
		push	ax			; save packet size for later use
		cld					; Clear direction
		mov	di, offset DGroup:TxPacket


; Ethernet packets must contain at least 46 bytes of data or they will
; be rejected as runt packets.	If the packet to be transmitted is less
; than 46 bytes, it will be padded to 46, but the length field will
; still indicate the number of valid bytes.


		pop	ax			; get packet size back

		lds	bx, DGroup:TxEDPtr
		mov	cx, ds:[bx].ED_FragCount   ; Get fragment count
		lea	bx, [bx].ED_FragOff	; point to first framedesc

Tx_Frag_Loop:
		push	cx			; save fragment count
		push	ds			; save fragment descriptor list segment
		mov	cx, ds:[bx].DLen	; length of this fragment

;        mov si, WORD PTR ds:[bx].DPointer

		lds	si, ds:[bx].DPointer	; location of this fragment
		rep	movsb

Tx_Frag_End:	pop	ds			; restore frag descriptor list segment
		pop	cx			; restore fragment count
		add	bx, size Descript_Struct ; next descriptor
		loop	Tx_Frag_Loop		; loop through all fragments

		call	RealTransmit

TransmitEnd:
		popf
		pop	ds
        clc
        or  ax, ax
        jz  @F
        stc
@@:
		sti			; enable interrupt before exit
;;db	 0F1h
		ret			; Return to caller

NADTransmitPacket	 ENDP

;------------------------------------------------------------------------------
;	RealTransmit
;	Purpose : Set ownership of Tx buffers and force transmission to happen
;
;	Exit	zf set = error recorded in CSR0
;		zf cleared = no error recorded by CSR0
;------------------------------------------------------------------------------
RealTransmit	proc	near

IFDEF		GILBUG
	mov	al, '~'
	push	bx
	mov	ah, 0Eh
	mov	bx, 0007h		; page 0, normal
	int	10h			; Write TTY

	mov	al, '~'
	mov	bx, 0007h		; page 0, normal
	int	10h			; Write TTY
	pop	bx
ENDIF

;db  0F1h
;int 03

;db  0f1h


		mov	DGroup:TxRetryCnt, 1


Do_Tx:		; DS doesn't have to point to ED anymore
;		push	cs
;		pop	ds

		; One buffer is enough for transmit (always)
		mov	DGroup:TxMsgMode,(Tmd1Start or Tmd1End)
		mov	ax,0
		mov	dx, offset DGroup:TxPacket
;int 03
		call	SetupRing
		mov	DGroup:TxMsgBlock[0].TxTmd0,dx
		or	ax,DGroup:TxMsgMode
		mov	DGroup:TxMsgBlock[0].TxTmd1,ax
		mov	ax, DGroup:PacketLen	 ; Get data count

		cmp	ax, 60
		jae	NetSendLenOK

		; documentation is wrong (minimum size should be 60 )
		; 64 bytes include checksum also
		mov	ax, 60

NetSendLenOK:	neg	ax		; put 2's comp. of size in Tmd2
		or	ax,0f000h	; make sure first nibble is all ones
		mov	DGroup:TxMsgBlock[0].TxTmd2,ax
		; clear bits in Tmd3
		xor	ax,ax
		mov	DGroup:TxMsgBlock[0].TxTmd3,ax


		; setup receive buffer before initializing card
		; need to initialize 8 buffers
		mov	cx, NumRxBuf
		mov	DGroup:RecvBufOffset,0 ; Clear flags
		mov	DGroup:RecvRingOffset,0;

;db	 0F1h

NetSendRBuf:	push	cx
		mov	DGroup:RxMsgMode,Rmd1Own ; setup mode register
		mov	ax,0
		mov	dx, offset DGROUP:RxPacket[0]
		add	dx,DGroup:RecvBufOffset ; for multiple buffer
		call	SetupRing

		push	di
		mov	di, offset DGROUP:RxMsgBlock[0].RxRmd0
		add	di,DGroup:RecvRingOffset
		mov	ds:[di],dx
		pop	di

		push	di
		lea	di,DGroup:RxMsgBlock[0].RxRmd1
		add	di,DGroup:RecvRingOffset
		mov	ds:[di],ax
		pop	di
		mov	ax,PACKETSIZE	; adequate for any packet
		neg	ax			; put 2's comp. of size in Tmd2
		or	ax,0f000h	; make sure first nibble is all ones

		push	di
		lea	di,DGroup:RxMsgBlock[0].RxRmd2
		add	di,DGroup:RecvRingOffset
		mov	ds:[di],ax
		pop	di

		push	ax
		push	di
		xor	ax,ax
		lea	di,DGroup:RxMsgBlock[0].RxRmd3
		add	di,DGroup:RecvRingOffset
		mov	ds:[di],ax
		pop	di
		pop	ax
		add	DGroup:RecvBufOffset,PACKETSIZE
		add	DGroup:RecvRingOffset,RINGSIZE
		pop	cx
		loop	NetSendRBuf

;db	 0F1h

		mov	DGroup:RecvBufOffset,0 ; initialize offset back to zero
		mov	DGroup:RecvRingOffset,0; initialize offset back to zero

		; Send initialization block
;961028 	mov	InitialBlock.InitMode,0 ; Enable receive & transmit
		mov	ax, CSR15Broad
		mov	DGroup:InitialBlock.InitMode, ax ; Enable receive & transmit
		mov	DGroup:BusInterface,0
		mov	DGroup:CSR0Cmd,(CSR0_INEA or CSR0_INIT)
		mov	di, offset DGROUP:RxMsgBlock[0]
		mov	si, offset DGROUP:TxMsgBlock[0]
;int 03
;;db	 0F1h
		call	SendInitBlock
;;db	 0F1h
		jz	NetSendTxmit	;transmit packet if initialize successful

		dec	DGroup:TxRetryCnt
		jz	TxmitBadCodeJmp

		jmp	Do_Tx		; ReTry if initialization fails

TxmitBadCodeJmp: jmp	 TxmitBadCode

NetSendTxmit:
		mov	ax,DGroup:TxMsgBlock[0].TxTmd1 ; give ownership of buffer to
		or	ax,Tmd1Own		; adapter
		mov	DGroup:TxMsgBlock[0].TxTmd1,ax

		; in multiple buffer mode, need to give control of all buffers
		; to card

		mov	DGroup:RecvRingOffset,0	; make sure offset is zero
		mov	cx, NumRxBuf
TxmitRxBuf:	push	di
		lea	di,DGroup:RxMsgBlock[0].RxRmd1
		add	di,DGroup:RecvRingOffset
		mov	ax,ds:[di]
		or	ax,DGroup:RxMsgMode
		mov	ds:[di],ax
		pop	di

		add	DGroup:RecvRingOffset,RINGSIZE
		loop	TxmitRxBuf

		mov	DGroup:RecvRingOffset,0

;;db  0f1h

		mov	ax,(CSR0_INEA or CSR0_STRT )
		mov	bl, CSR0
		call	CSROut

		sti			; enable interrupt

		mov	ax, TIME100MS
		call	StartTime

TxmitPacLoop:	mov	ax,InterruptFlag

;db  0f1h

		test	ax, INTTXERR
		jnz	TxmitPacErr

		test	ax, INTTX
		jnz	TxmitPacOK

		cmp	DGroup:ISRErrFlag, TRUE
		jz	TxmitMERR

		call	CheckTime
		jnc	TxmitPacLoop

		jmp	short TxmitPacErr

TxmitPacOK:
		les	si, DGroup:TxEDPtr
;		push	cs
;		pop	ds
		; Set return code to successful
		mov	es:[si].ED_ErrCode, SUCCESSFUL
		xor	ax,ax		; indicate no error

TxmitPacEnd:	or	ax,ax
		ret

TxmitPacErr:	; ask user to check cable connection

;;db  0f1h
		les	si, DGroup:TxEDPtr
;		mov	di, offset CGROUP:ErrTx
;		mov	DGroup:StatusMsgFlag, di		; used for RPL
		mov	es:[si].ED_ErrCode, TRANSMIT_ERROR
;		mov	es:[si].ED_ErrMsg, offset CGROUP:ErrTx

		les	si, TxEDPtr
;		push	cs			; Set DS = CS = ES
;		pop	ds			;
		; Set return code to indicate error
		mov	es:[si].ED_ErrCode, TRANSMIT_ERROR

		mov	ax,1		; indicate error
		jmp	TxmitPacEnd

TxmitBadCode:	

;;;db  0f1h

        les	si, TxEDPtr
;		push	cs			; Set DS = CS = ES
;		pop	ds			;
		; Set return code to indicate error
		mov	es:[si].ED_ErrCode, TRANSMIT_ERROR
;		mov	es:[si].ED_ErrMsg, offset DGROUP:ErrTx1

		mov	ax,1		; indicate error
		jmp	TxmitPacEnd

TxmitMERR:	les	si, DGroup:TxEDPtr
;		push	cs			; Set DS = CS = ES
;		pop	ds			;
		; Set return code to indicate error
		mov	es:[si].ED_ErrCode, GENERAL_FAILURE
;		mov	es:[si].ED_ErrMsg, offset DGROUP:ErrTx2

		mov	ax,1		; indicate error
		jmp	TxmitPacEnd

RealTransmit	endp

FlushRxBuffer	proc	near
ClearRecvBit	proc	near
		ret
ClearRecvBit	endp
FlushRxBuffer	endp


; ----------------- Initialize routines -------------------------------

;------------------------------------------------------------------------------
;	SetupInt
;
;	Purpose : Setup variables related to interrupt lines and mask registers
;		  The old interrupt vector is saved and the interrupt level is
;		  in IntNum. A new interrupt vector is given to the system.
;		  The interrupt is also enabled (unmasked )
;	Remarks : follow sample in DIAG_SUB.C (SetupIntVar)
;		  follow sample in INT_Hand.asm (save_int_vec)
;		  follow sample in INT_HAND.ASM (enable_int_vec)
;
;------------------------------------------------------------------------------
public		SetupInt
SetupInt	proc	near
		pusha
		xor	cx, cx
		mov	DGroup:MaskReg, 021h	; assume Master PIC first
		mov	DGroup:IntVect, 020h	; base vector address for Master PIC
		mov	al,DGroup:IntNum
		mov	cl,DGroup:IntNum

		cmp	al, 8
		jb	MaskRegOk

		sub	cl, 8
		mov	DGroup:MaskReg, 0a1h

;;		in	al, 0A1h		; get slave PIC mask
;;		jmp	$+2
;;		and	al, 0fdh		; unmask int 9
;;		out	0A1h, al

		mov	DGroup:IntVect, 01C0h	; base vector address for slave PIC

MaskRegOk:	; Setup  IRQLine
		mov	bl, 1
		shl	bl, cl
		mov	DGroup:IRQLine, bl
		shl	cl, 1
		shl	cl, 1		; multiply bl by 4
		add	DGroup:IntVect, cx	; get correct vector address

SetupIntSave:
	       ; Store old pointer and place new pointer in int. vector
		cli			; disable interrupt

		push	es
		push	si
		xor	ax,ax
		mov	es,ax		; segment for vector address is 0
		mov	ax,DGroup:IntVect

		mov	si,ax
		mov	bx,es:[si]
		add	si,2
		mov	ax,es:[si]
		mov	es,ax

		mov	DGroup:OrgIntVector_OFF,bx ; old interrupt pointer is stored in
		mov	DGroup:OrgIntVector_SEG,es ; this variable

;;		mov	DGroup:OldIntVector,bx ; old interrupt pointer is stored in
;;		mov	DGroup:OldIntVector[2],es ; this variable

		xor	ax,ax
		mov	es,ax

		sub	si,2

;;db  0f1h

IFDEF	UNDI
		mov	dx, offset CGroup:UNDI_DriverISR
ELSE
		mov	dx, offset CGROUP:BootISR
ENDIF
		mov	es:[si],dx
		add	si,2
		mov	es:[si],cs

		pop	si
		pop	es

		mov	ah, DGroup:IRQLine
		not	ah

;;		in	al, 0A1h		; get slave PIC mask
;;		jmp	$+2
;;		and	al, 0fdh		; unmask int 9
;;		out	0A1h, al


		mov	dx, DGroup:MaskReg   ; Address of mask register
		in	al, dx		; Get old mask byte
        mov byte ptr DGroup:OldMaskReg, al
		and	al, ah		; unmask the correct bits
        cmp dx, 0A1h
        jne @F
        and al, 0FDh
@@:
		out	dx,al		; Enable the interrupt

		cmp    dx, 21h		  ; are we using IRQ from slave?
		je     HookIntVectorExit		 ; no

		in     al, 21h		  ; yes, turn on cascaded input
		and    al, not 04			  ;  on master 8259
		out    21h, al

HookIntVectorExit:

		sti			; enable interrupt
		xor	al,al		; set zero flag to indicate no error

SetupIntEnd:
		popa
		ret
SetupInt	endp

IFNDEF	UNDI
;------------------------------------------------------------------------------
;	EnableDmaCascade
;	Purpose : Puts the DMA controller into cascade mode (16 bit)
;
;	Remarks : follow sample in DMA_Util.c
;------------------------------------------------------------------------------

EnableDmaCascade       proc    near

		cmp	DGroup:DmaNum, 4
		jae	Set16BitDma

		mov	bx, 0Ah 	; 8-bit mask reg
		mov	cx, 0Bh 	; 8-bit mode reg
		jmp	short DoDmaInit

Set16BitDma:
		mov	bx, 0D4h	; 16-bit mask reg
		mov	cx, 0D6h	; 16-bit mode reg

DoDmaInit:
		mov	ah, DGroup:DmaNum
		and	ah, 00000011b	; keep only b1 b0
		mov	al, ah
		or	al, 00000100b	; set the mask bit
		mov	dx, bx
		out	dx, al
		mov	al, ah		;  DmaNum AND 03
		or	al, 11010000b	; set cascade mode
		mov	dx, cx
		out	dx, al
		mov	al, ah		; DmaNum AND 03
		mov	dx, bx
		out	dx, al		; clear the mask bit
		ret
EnableDmaCascade	endp
ENDIF	; IFNDEF UNDI

;----------------------------------------------------------------------------;
; NADChangeReceiveMask - Called by NAD to change the receive mask of adapter.
;
; Input:	bl	  command
;		b0: set   = enable
;		    clear = disable
;		b1: enable/disable broadcast reception on the NIC based on b0
;		b2: enable/disable multicast reception on the NIC based on b0
;		    ES:DI is ignored.
;		b3: Change Multicast Address Table
;			if b0 is set, ES:DI will point to the multicast address to add
;			if b0 is cleared, ES:DI will point to multicast address to delete.
;			if b0 is cleared and ES:DI = 0:0, clear whole Multicast Table
;		b4: enable/disable promiscuous reception on the NIC based on b0
;
;		es:di pointer to multicast address
;
; no reg. changed
;----------------------------------------------------------------------------;
NADChangeReceiveMask	proc	far

;    int 03

	; ** This routine DOESN'T support Deleting a particular  **
	; ** Multicast Address **

	test	bl, 2			; want to change Broadcast?
	jnz	NADChgBroad

	test	bl, 4			; want to change Multicast?
	jnz	NADChgMulti

	test	bl, 8			; want to change Multicast Table?
	jz	NADChgMaskEnd

NADMTable:
	test	bl, 1
	jnz	NADMTableAdd

NADMTableClear:
	; Only support clearing whole table
	mov	ax, es
	cmp	ax, 0
	jnz	NADChgMaskEnd

	cmp	di, 0
	jnz	NADChgMaskEnd

	push	ds
	pop	es

	; clear both MCastTable and LADRF
	mov	di, offset DGroup:MCastTable
	xor	ax, ax
	stosw
	stosw
	stosw

	mov	di, offset DGroup:LADRF
	stosw
	stosw
	stosw
	stosw
	jmp	short NADChgMaskEnd

NADMTableAdd:

	call	Set_Multicast_List
	add	bx, offset DGroup:LADRF
	or	byte ptr [bx], al
	jmp	short NADChgMaskEnd

NADChgMulti:
	mov	LADRFPtr, offset DGroup:LADRF

	test	bl, 1
	jnz	NADChgMaskEnd

NADChgMultiOff:
	mov	LADRFPtr, offset DGroup:LADRFDisable
	jmp	short NADChgMaskEnd

NADChgBroad:
	mov	ax, DGroup:CSR15Broad
	test	bl, 1
	jz	NADChgBroadOff

NADChgBroadOn:

	and	ax, 0bfffh		; clear bit 14
;	or	ax, 04000h		; set bit 14
	mov	DGroup:CSR15Broad, ax
	jmp	short NADChgMaskEnd

NADChgBroadOff:
	or	ax, 04000h		; set bit 14
;	and	ax, 0bfffh		; clear bit 14
	mov	DGroup:CSR15Broad, ax

NADChgMaskEnd:
    clc
	retf

NADChangeReceiveMask	   endp


;----------------------------------------
; Set_Multicast_List
;
; enter with ES:DI ->multicast address
; returns:	bx	offset from LADRF (# of bytes)
;		ah	bit in LADRF to set/clear
;----------------------------------------
;
POLYL	equ	1DB6h			; CRC polynomial coefficients
POLYH	equ	04C1h			;

Set_Multicast_List	proc	near

	mov	ax, 0FFFFh		; AX, DX = CRC accumulator
	mov	dx, ax			;
	mov	ch, 3			; CH = word counter

CRCwordloop:
	mov	bp, es:[di]			; get a word of address
	add	di, 2			; point to next address
	mov	cl, 16			; CL = bit counter

CRCbitloop:
	mov	bx,dx			; get high word of CRC
	rol	bx,1			; put CRC bit 31 to LSB
	xor	bx,bp			; combine CRC31 with word
	sal	ax,1			; left shift CRC accumulator
	rcl	dx,1			;
	and	bx,0001h		; BX = control bit
	jz	short DontXORwithPOLY	;

	xor	ax,POLYL		; XOR if control bit = 1
	xor	dx,POLYH		;

DontXORwithPOLY:
	or	ax,bx			; put control bit in CRC0
	ror	bp,1			; rotate address word
	dec	cl			;
	jnz	short CRCbitloop	;

	dec	ch			; decrement word counter
	jnz	short CRCwordloop	;

	; formation of CRC complete, AL contains the reversed Hash code
	mov	cx,10			;
Reversehashbits:
	sal	al,1			; reverse the order of AL bits
	rcr	ah,1			;
	loop	Reversehashbits 	;

	; AL contains the 6 - bit Hash code
	mov	bl,ah			; BL = Hash code, BH = 0
	mov	cl,3			;
	shr	bl,cl			; divide Hash code by 8
	mov	al,1			; preset filetr bit
	and	ah,0111B		; extract bit count
	mov	cl,ah			;
	shl	al,cl			; shift bit to correct positions
	clc				; return clear carry flag
	ret

Set_Multicast_List	endp

; Routine used to build string
;----------------------------------------------------------------------
; StoHex - stuff binary AL as 2 hex digits at ES:DI
;
; On entry,
;	AL = binary digit to print as hex
;	ES:DI ptr to string buffer, CLD flag set
; On exit,
;	AX modified, ES:DI ptr to next location in buffer
;
; 920728 1.0 GK adapted from PutHex
;----------------------------------------------------------------------

StoHex	proc	near

	push	ax			; save for lower nibble
	shr	al, 4
	call	h_digit
	pop	ax			; now do lower nibble

h_digit:
	and	al,00001111b
	add	al,90h
	daa
	adc	al,40h
	daa
	stosb				; stuff hex digit in buffer
	ret

StoHex	endp

;----------------------------------------------------------------------
; StoDec - stuff AX as CL decimal digits at ES:DI
;
; On entry,
;	AX = number to print as decimal
;	ES:DI ptr to leftmost position of field
;	CL has width of field, will zero-fill
; On exit,
;	AX, CX, DX modified, ES:DI ptr to beyond rightmost position
;
; 920728 1.0 GK adapted from PutHex
;----------------------------------------------------------------------

StoDec		proc	near

		push	ax		; save value
		mov	al, '0'
		mov	ch, 0
		rep	stosb		; fill with zeroes

		mov	cl, 0Ah 	; divide by 10
		pop	ax		; restore value
		push	di		; save ending DI value

StoDecNext:
		xor	dx, dx
		div	cx		; ax, dx rem=dx:ax/reg
		add	dl, 30h 	; '0'
		dec	di
		mov	es:[di], dl
		or	ax, ax
		jnz	StoDecNext

		pop	di		; return with DI pointing after field
		ret

StoDec		endp



public		WaitTime
;--------------------------------------------------------------------
; WaitTime - CX has 2*1.1932 the number of microseconds to wait.
;	If CX is small, add 1 to compensate for asynchronous nature
;	of clock.  For example, for 10us, call with CX = 25
;
;  On entry,
;	ints off (especially if CX is small, and accuracy needed)
;  On exit,
;	CX modified
;
; 911223 0.0 GK
;--------------------------------------------------------------------
WaitTime	proc	near

		push	ax
		push	bx
		call	ReadTimer0		; get Timer0 value in AX
		mov	bx, ax			; save in BX

ReadTimer0Loop:
		call	ReadTimer0
		push	bx
		sub	bx, ax
		cmp	bx, cx
		pop	bx
		jc	ReadTimer0Loop

		pop	bx
		pop	ax
		ret

WaitTime	endp


ReadTimer0	proc	near

		mov	al, 6
		out	43h, al 		; port 43h, 8253 wrt timr mode 3
		call	RT0

RT0:
		jmp	short $+2
		jmp	short $+2
		jmp	short $+2
		in	al, 40h 		; port 40h, 8253 timer 0 clock
		xchg	ah, al

		jmp	short $+2
		jmp	short $+2
		jmp	short $+2

		ret

ReadTimer0	endp



IFNDEF	UNDI
END_CODE
START_BUFFER
ENDIF	; IFNDEF UNDI


_TEXT	ends


_DATA	segment	para public

        align 2


;;LDT1    dw  3 dup(0)
;;GDT     db  6 dup(0)

ReceiveError    dw  0


CSR15Broad	dw	  04000h	     ; CSR15 value. * Only change Bit14 *
							; Other bits must be zero !!
MCastTable	db	6 dup (0)	; Multicast table
			db	6 dup (0)

public		LADRFPtr
LADRFPtr	dw	offset LADRFDisable
;LADRFPtr	dw	offset LADRF
LADRF		db	8 dup (0)	; Value to put in Logical Address Filter
LADRFDisable	db	8 dup (0)	; Disable Logical Address Filter

public CardType

		db	"Start"
CardType	db	0		; indicate what card it is : AT1500
					; NE2100/1500 or ANSEL NS2100/NH2100
					; or HP
MemBase 	db	0		; for BPPatch (TCP/IP)
IRQLine 	db	0		; interrupt request line
StartTick	dw	0		; save area for tick value
MaxTicks	dw	0		; save area for max ticks
CurTicks	dw	0

MaskReg 	dw	0		; mask register
IntVect 	dw	0		; interrupt vector
OldMaskReg 	dw	0		; mask register

OrgIntVector_OFF    dw  0
OrgIntVector_SEG    dw  0

;OldIntVector	dw	2 dup (0)	; Store the old pointer to interrupt
					; vector

;IRQLine	 db	 0		 ; interrupt request line
;ISRErrFlag	 db	 FALSE		 ; flag indicating if error condition is
;					 ; encountered during int acknowledgement
ISRErr		dw	0		; contains CSR0 if ISRErrFlag is TRUE
InterruptFlag	dw	0		; indicate what type of interrupt is
					; serviced

TxMsgMode	dw	0		; Tmd1 in the descriptor ring
RxMsgMode	dw	0		; Rmd1 in the descriptor ring
BusInterface	dw	0		; CSR3 value (allow redefinition of bus
					; interface)
CSR0Cmd 	dw	0		; Command to be sent to CSR0

RecvBufOffset	dw	0		; Indicate offset to rx buffer used
RecvRingOffset	dw	0		; Indicate offset to Rx Ring desc used
UpdateBufOff	dw	0		; Indicate offset to Rx update buffer
UpdateRingOff	dw	0		; indicate offset to Rx update ring desc.

RecvIntCount	dw	0		; Buffer # being tested
TxEDPtr 	dd	?		; save area for transmit ED
RxEDPtr 	dd	?		; save area for receive ED
StatusMsgFlag	dw	0		; pointer to msg to be printed in NIDStatus
PacketLen	dw	0		; length of packet data

ValISACR2	dw	02		 ; value to be output to ISACR2 Register

_DATA	ends


;ErrStruct	 ErrorStruct < 0, 0, 0 >

;db 0, 0, 0

_BSS	segment

        align 8

db  'BWSPARSE'

        align 2



		align 8
InitialBlock	InitBlock <,,,,>	; Structure for initialization block




    	align 8
TxPacket	Packet NumTxBuf dup(<,,,,>)	 ; Store transmit ethernet packet

;db 0, 0

	ALIGN 8
RxPacket	Packet	NumRxBuf dup(<,,,,>)	 ; Store receive ethernet packet
	ALIGN 8
TxMsgBlock	TxMsgDesc NumTxBuf dup(<,,,>)	; Transmit message descriptor entry
		ALIGN 8
RxMsgBlock	RecvMsgDesc NumRxBuf+8 dup(<,,,>) ; Receiver message descriptor entry

;_DATA	ends

_BSS	ends

_TEXT	Segment para public


IFNDEF	UNDI
END_BUFFER
ENDIF		; note in UNDI case, this file is included within _TEXT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c90xb\bw90xb.inc ===
; Routines in BW90XB.INC
;
; Modules included:
;	- Init_Vulcan2
; 	- SetInterruptVector
;	- init_vulcan_hw
;	- AutoSelect
;	- TryLinkBeat 
;	- TryLoopback
;	- SetupConnector 
;


;******************************************************************************
; Init_Adapter2
;******************************************************************************
Init_Adapter2	proc	near
;
; set up initial TxStart thresholds.
;
;		mov	si, offset DGroup:PioTxStart
init_txs_loop:
;		mov	[si].txs_min, 0 	; Disable MinTxStart
;;960408		max	ax, 16, dx

;960408 {
;		; Replace "max	ax, 16, dx"
;		cmp	ax, 16
;		ja	init_txs_max
;
;		mov	ax, 16
;init_txs_max:	
;		mov	[si].txs_value, ax
;		add	ax, 2			; round
;		shr	ax, 2			; then scale
;		add	ax, CMD_SETTXSTART	; add command
;		mov	[si].txs_thresh, ax	; for direct use
;		mov	[si].txs_marker, 0D1CEh ; debug flag
;		add	si, SIZE_TxStart	; next TxStart threshold
;		cmp	si, offset DGroup:AfterTxStart
;		jb	init_txs_loop		; around again
;
; initialize Vulcan hardware, driver variables & tables
;
		call   init_adapter_hw		; initialize Vulcan hardware

;------------------------------------------------------------------------------
; enable int at 8259, turn on Ethernet Core Transciever and Receiver
;
mask_on_IRQ:

; setup initial TxStart & RxEarly Thresholds
; disable Tx and Rx Early Thresholds

		mov	dx, PortCmdStatus
		mov	ax, CMD_SETRXEARLY+RXEARLY_DISABLED
		mov	NormalRxEarly, ax	; will be adjusted later
		out	dx, ax

		mov	ax, CurTxStart
		out	dx, ax

; set rx filter
		mov	ax, CMD_SETRXFILTER+FILTER_INDIVIDUAL
		mov	HWFilter, ax		; save for SoftRxReset
		out	dx, ax

		mov	ax, CMD_SETINTMASK + BOOTWARE_INTS
		out	dx, ax

IFNDEF	UNDI
		; enable the transmitter
		mov     ah, CMDH_TXENABLE
		out     dx, ax

		; enable the receiver
		mov     ah, CMDH_RXENABLE
		out     dx, ax
ENDIF
; enable upload engine
		mov	eax, UPD_physaddr
		mov	dx, PortUpListPtr
		out	dx, eax

		mov	dx, PortCmdStatus
		mov	ax, CMD_STALLCTL + UP_UNSTALL
		out	dx, ax

		mov	ax, 0
		ret

Init_Adapter2	endp

;******************************************************************************
;
;   SetInterruptVector: this routine determine the mask value for the selected
;			IRQ level and EOI values for both master and slave
;			8259s. We do not mask on the selected IRQ in this
;			routine, instead, it will be turned on and off as
;			initialization goes on.
;
;   On Entry:
;	      al = IRQ level
;	      cli
;
;   On Exit:
;
;******************************************************************************
SetInterruptVector proc near

;
;------------------------------------------------------------------------------
; determine the mask value for the selected IRQ level
;

       mov    cl, al				 ; al = IRQ level
       and    cl, 0f7h				 ; strip out IRQ on slave
       mov    ch, 1
       shl    ch, cl
       mov    IRQBit, ch			 ; IRQ bit postion (1), maskoff)
       not    ch				 ; all bits 1 except channel
       mov    IntMaskOnBit, ch			 ; Mask on bit position (0)

       mov    word ptr int_mask_port, MASTER_MASK_PORT
       cmp    al, 7
       jbe    SetIRQMaster
       mov    word ptr int_mask_port, SLAVE_MASK_PORT

SetIRQMaster:
;------------------------------------------------------------------------------
; determine EOI values for both master and slave 8259
;
       mov    al, IRQLevel
       cmp    al, 8				 ; IRQ on slave?
       jae    SetEOI				 ; yes

       mov    ah, al				 ;
       or     ah, 60h				 ; specific EOI to master 8259
       mov    al, 40h				 ; nop to slave to 8259
       jmp    short save_eoi

SetEOI:
       mov    ax, 6220h 			 ; non-specific EOI to slave
						 ; specific EOI to master 8259
save_eoi:
       mov    eoi_value, ax			 ; ah = EOI for master
						 ; al = EOI for slave
       ret

SetInterruptVector endp


;******************************************************************************
;   init_adapter_hw:  this routine initializes most of vulcan hardware required
;		     to operate the adapter.  TxEnable and RxEnable will not
;		     be done in this routine
;
;   On Entry:
;	      adapter has been activated and window 0 is active.
;	      the following variables are valid and available:
;
;			1. IOBase
;			2. IRQLevel
;			5. NetAddress - ethernet addr of the adapter
;
;   On Exit:
;	      window 1 is active
;	      dx = port CmdStatus
;
;*****************************************************************************
init_adapter_hw	   proc      near

; for EISA board, cannot reset board.
		cmp	BusType, BUS_EISA
		jz	Init_SkipReset

		mov	dx, PortCmdStatus
		xor	ax,ax			   ; global reset
		out	dx,ax

GlobalResetWait:
		in      ax, dx
		test    ah, STH_BUSY
		jnz	GlobalResetWait		   ; loop while busy

Init_SkipReset:
;
;------------------------------------------------------------------------------
; Setup Station Address.  the adapter's Ethernet Address has been read out of
; EEPROM, we need to program it into window 2, so Ethernet Core Receiver can
; receive packets properly.  the active window is 0, switch to window 2 first.
;

		mov	dx, PortCmdStatus
		SelectWindow	WNO_STATIONADDRESS

IFDEF	UNDI
		lea	si, DGroup:BoardID	;971030
ELSE
		lea	si, NetAddress
ENDIF
		mov	dx, PortSA0_1
		lodsw
		out	dx, ax

		add	dx, 2			; dx = port addr 3, 2
		lodsw
		out	dx, ax

		add	dx, 2			; dx = port addr 1, 0 = IO base
		lodsw
		out	dx, ax
;
; Initialize the mask registers to 0's, so we get only messages meant for us
;
		xor    ax,ax
		add    dx,2			; dx = station mask lo
		out    dx,ax
		add    dx,2			; dx = station mask mid
		out    dx,ax
		add    dx,2			; dx = station mask hi
		out    dx,ax
;
;----------------------------------------------------------------------------
; determine the connector to use.
;
; we set the default to EEProm InternalConfiguration.  Then we check
;	for auto-selection
;

;;int 03    

;  Autoselect and ComputeSpeeds expect CLI.  force it.

		cli

		mov	ax, EEIntConfig1
		and	ax, ICH_XCVR_MASK
		shr	ax, ICH_XCVR_SHIFT
		mov	Xcvr, ax

		mov	dx, PortCmdStatus
		SelectWindow WNO_FIFO

		mov	dx, PortInternalCfgH
		in	ax, dx
		test	ax, ICH_AUTOSELECT
		jz	not_auto_select

		mov	MiiSelect, -1
		call	AutoSelect		;if autoselect failed, Xcvr is
						;back to default
		jnc	autoselected

		mov	ax, HARDWARE_FAILURE	; don't do anything more
		ret

autoselected:
		cmp	Xcvr, XCVR_AUTO
		je	check_mii_speed

		cmp     Xcvr, XCVR_MII
		je      check_mii_speed

not_mii_connector:
;
;;980429, check link for single connector's adapter
;
		mov	LinkDetected, 0
		cmp     Xcvr, XCVR_100TX
		jz	test_100link
		cmp     Xcvr, XCVR_100FX
		jnz	not_100FX
test_100link:
		call	TryLinkbeat
		jc      fast_connector
		mov	LinkDetected, 1
		jmp     fast_connector

not_100FX:
		cmp	Xcvr, XCVR_10TP
		jnz	not_10TP
		call	TryLinkbeat
		jmp	short connector10

not_10TP:
;;; 980519
		cmp	Xcvr, XCVR_10AUI
		jnz	not_10AUI

		test	MediaOptions, RO_BASEFL		;10BaseFL ?
		jz	x10AUI
;
; since 10FL's link can't be detected, so always set it to true
;
		mov	LinkDetected, 1
		jmp	short slow_connector

not_10AUI:
x10AUI:
;;;
		call	TryLoopback		;  either 10AUI or 10BNC
connector10:
		jc	slow_connector
		mov	LinkDetected, 1
		jmp	short slow_connector
;;
not_auto_select:
		cmp	Xcvr, XCVR_AUTO 	; Cyclone AutoNegotiation
		jne	not_cyc_auto

		call	ForceMII
		jc      chk_mii_speed
		mov	LinkDetected, 0
		jz	check_mii_speed 	; not ok, but recoverable

		mov	ax, HARDWARE_FAILURE	; can't do anything more
		ret

not_cyc_auto:
		cmp     Xcvr, XCVR_MII
		jne     not_mii_connector

		call    ForceMII
		jc      chk_mii_speed
		mov	LinkDetected, 0
		jz	check_mii_speed 	; not ok, but recoverable

		mov	ax, HARDWARE_FAILURE	; can't do anything more
		ret

chk_mii_speed:
		mov	LinkDetected, 1
check_mii_speed:
		cmp     LineSpeed, 100
		je      fast_connector
		jmp     slow_connector

;
; determine link speed from connector.	also set BytesPerTick to 4 for 10Mbps
; operation (3.2us ticks=4 x 800ns) and 40 for 100Mbps operation (40 x 80ns).
;
fast_connector:
		mov	LineSpeed, 100		; Mbps
		jmp	xcvr_done

slow_connector:
		mov	LineSpeed, 10		; Mbps
xcvr_done:
;
;  first make sure the internal DC DC converter is disabled
;
		mov	dx, PortCmdStatus
		mov     ah, CMDH_STOPINTXCVR
		out     dx, ax		       ; issue command
;
; now give the transceiver 3ms to stabilize before we enable transmit or
; receive traffic thru it.
;
		mov	cx, Delay3ms
		call	WaitTime
;
; workaround for a hardware bug fix in Cyclone regarding PCI command MWI
;
		mov	ax, EESoftConfigInfo2
		test	ax, 0020h		;test bit 5
		jnz	bugfixed

		mov	dx, PortDMACtrl
		in	eax, dx
		or	eax, 100000h		;set defeatMWI to 1
		out	dx, eax
bugfixed:
;
; set up the connector (possibly for the second time)
;
		call    SetupConnector

		mov	dx, PortCmdStatus
		SelectWindow	WNO_OPERATING		 ;

		mov	ax, CMD_SETRZMASK+MASK_NONE	 ; enable all interrupts for Rev. 1
		out	dx, ax

		ret

init_adapter_hw	endp


;------ AutoSelect ----------------------------------------------------------;
;									     ;
;	This routine attempts to auto-select the connector.  It should be    ;
;	called only if the autoselect bit is set.  If it fails, it will      ;
;	leave the current connector in InternalConfig set.		     ;
;									     ;
;	Entry:								     ;
;	cli								     ;
;	Station Address has been set up on adapter.			     ;
;	Xcvr set to the connector to use if AutoSelect fails (this should    ;
;	    be read from the EEProm, NOT from InternalConfig)		     ;
;	SWConfig has the software configuration word from the EEProm.	     ;
;	Delay3ms set for 3ms delay.					    ;
;	Delay25ms set up for a 50ms delay.				     ;
;	MediaEnable table defined.					     ;
;	Specific.mc_caddr set up with the station address.		     ;
;									     ;
;	Exit:								     ;
;	cli								     ;
;	MediaStatus, MacControl, InternalConfig set up for connector chosen. ;
;	DC-DC converter stopped/started as required.			     ;
;	TxFIFO/RxFIFO reset and disabled.				     ;
;	RZMask/IntMask disabled (0).					     ;
;	NetDiag modified for no loopback.				     ;
;	No interrupts pending.						     ;
;									     ;
;	All registers preserved.					     ;
;									     ;
;----------------------------------------------------------------------------;
AutoSelect	proc	near

		pusha
;
; set the IntMask and RZMask not to allow any interrupts through
;
		mov	dx, PortCmdStatus
		mov	ax, CMD_SETINTMASK + 0
		out	dx, ax
		mov	ax, CMD_SETRZMASK + 0
		out	dx, ax
;
; save the default connector
;
		mov	bp, Xcvr		; save original Xcvr value
;
; determine what connectors are available
;
;980519		mov	dx, PortCmdStatus
;		SelectWindow WNO_FIFO

;		mov	dx, PortMediaOptions	;PortResetOptions
;		in	ax, dx
;		mov	bx, ax			; BX=ResetOptions

		mov	bx, MediaOptions
;
; if 100TX connector is available, try that.  we do 100Mbps first to avoid
; generating any 10Mbps traffic on a hub that might be autosensing and might
; switch to 10Mbps to match us.  For Cyclone, 100TX is used to indicate on
; board auto-negotiation.
;
; note: sending 100Mbps stuff on a 10TP connection will generally partition
;	us.  we'll need to clear this up before we're done.
;
		public	auto_try_100tx
auto_try_100TX:
		test	bx, RO_BASETX
		jz	auto_try_MII

		mov	Xcvr, XCVR_AUTO

;;int    03h

		call	TryMII
		jc	auto_exit
		jz	auto_try_mii
		mov	LinkDetected, 0
		jmp	auto_exit_hw_fail
;
; if MII is available, try that
;
		public	auto_try_MII
auto_try_MII:
		test    bx, RO_MII
		jnz	try_MII

;
; if 100BASE-T4 PHY is available through MII
;
		test    bx, RO_BASET4
		jz      auto_try_10TP

try_MII:
		mov	Xcvr, XCVR_MII

;;int    03h

		call	TryMII
		jc	auto_exit
		jz	auto_try_10TP
		mov	LinkDetected, 0
		jmp	auto_exit_hw_fail
;
; if 10TP connector is available, try that.  This is for the Boomerang case.
; For Cyclone, it could be a 10Mbps only card that uses the auto negotiation.
;
		public	auto_try_10TP
auto_try_10TP:
		test	bx, RO_TP
		jz	auto_try_aui

		mov	Xcvr, XCVR_AUTO

;;int    03h

		call	TryMII
		jc	auto_exit
		jz	boom_10tp		; could be TPO
		mov	LinkDetected, 0
		jmp	auto_exit_hw_fail

boom_10tp:
		mov	Xcvr, XCVR_10TP
		call	TryLinkbeat
		jnc	auto_exit
;
; if 10AUI connector is available, try that
;
		public	auto_try_aui
auto_try_aui:
		test	bx, RO_AUI
		jz	auto_try_bnc

		mov	Xcvr, XCVR_10AUI
		call	TryLoopback
		jnc	auto_exit
		mov	LinkDetected, 0
;
; if 10BNC connector is available, try that
;
		public	auto_try_bnc
auto_try_bnc:
		test	bx, RO_COAX
		jz	auto_try_100FX
;		jz	auto_fail

		mov	Xcvr, XCVR_10BNC
		call	TryLoopback
		jnc	auto_exit
		mov	LinkDetected, 0
;;; 980519
; if 100FX connector is available, try that
;
auto_try_100FX:
		test	bx, RO_BASEFX
		jz	auto_try_10FL

		mov	Xcvr, XCVR_100FX
		call	TryLinkbeat
		jnc	auto_exit
		mov	LinkDetected, 0
;
; if 10FL connector is available, always assume the link is available since it
;	can't be detected
;
auto_try_10FL:
		test	bx, RO_BASEFL
		jz	auto_fail
		mov	Xcvr, XCVR_10AUI
		jmp	short auto_exit
;;;
;
; nothing worked.  just switch back to the default connector
;
		public	auto_fail
auto_fail:
		mov	Xcvr, bp
		call	SetupConnector
		jmp	autox
;
; done.  leave.
;
		public	auto_exit
auto_exit:
		mov	LinkDetected, 1
autox:
		clc
		popa
		ret

auto_exit_hw_fail:
		stc					; hardware failure
		popa
		ret

AutoSelect	endp


;------ TryLinkBeat ---------------------------------------------------------;
;									     ;
;	This routine sets up the adapter to use one of the linkbeat-capable  ;
;	connectors: 10TP or 100TX.  Since the port might be partitioned by   ;
;	the hub (a previous attempt at an incorrect speed might cause this   ;
;	for example), we send a packet first to clear this up.	Then we      ;
;	look for linkbeat.						     ;
;									     ;
;	This routine is part of the auto-select logic and is called by	     ;
;	AutoSelect to do its work.					     ;
;									     ;
;	Entry:								     ;
;	cli								     ;
;	Xcvr set to the connector to set up.				     ;
;	SWConfig has the software configuration word from the EEProm.	     ;
;	Delay3ms set for 3ms delay.					    ;
;	Delay25ms set up for a 50ms delay.				     ;
;	MediaEnable table defined.					     ;
;	Specific.mc_caddr set up with the station address.		     ;
;	no interrupts pending.						     ;
;									     ;
;	Exit:								     ;
;	cli								     ;
;	clc if we get linkbeat, the connector seems fine.  stc if not.	     ;
;	DC-DC converted started/stopped.				     ;
;	MediaStatus set up.						     ;
;	MacControl set up.						     ;
;	InternalConfig set up.						     ;
;	Rx/TxFIFO's reset and disabled.                                      ;
;	NetDiag modified for no loopback.				     ;
;									     ;
;	All registers preserved.					     ;
;									     ;
;----------------------------------------------------------------------------;
		public	TryLinkbeat
TryLinkbeat	proc	near

		pusha
		push	es
;
; go quiet for 1.5 seconds to get any N-Way hub into a receptive state to
; sense the new speed.  we go quiet by switching to the 10BaseT connector
; with no linkbeat
;
		call    QuietConnector

		mov     cx, 30		  ; 30 x 1/20th = 1.5 sec
tlb_qloop:
		push	cx
		mov	cx, Delay25ms
		call	WaitTime
		call	WaitTime		; assume cx preserved
		pop	cx
		loop    tlb_qloop

;
; set up the connector
;
		call	SetupConnector
;
; give settling time. Run WaitTime twice to get enough delay
;
		mov	cx, Delay25ms
		call	WaitTime
		call	WaitTime		; assume cx preserved
;
; we might be partitioned.  some hubs won't clear the partition until we
; send a packet.  so send one.	the good news is that if we are partitioned
; then there is no receive traffic incoming so we don't have to wait that
; long for backoffs or retries.
;
; load the UplistPtr
;
		mov	dx, PortUpListPtr
		mov	eax, UPD_physaddr
		out	dx, eax

		mov	dx, PortCmdStatus
		mov	ax, CMD_STALLCTL + UP_UNSTALL
		out	dx, ax
;
; set up a 14-byte packet to send.  ourselves as the destination.
;
		push	ds
		pop	es
		mov	di, offset DGroup:TxBuf
		mov	dword ptr [di], 16
		add	di, 4			; adjust ptr 4 bytes
IFDEF	UNDI
		lea	si, DGroup:BoardID
ELSE
		lea	si, NetAddress
ENDIF
		mov	cx, 6
	rep	movsb			;rep outsb	; destination address
		mov	cx, 6
		sub	si, 6
	rep	movsb			;rep outsb	; source address

		mov	word ptr es:[di], 0h		; pad to 16 bytes

		mov	si, offset DPD
		mov	[si].DPD_FSHindicate, 0000h	;turn off dnIndicate
		mov	[si].DPD_FrameStart, 8000h 	;turn on txIndicate 
		mov	[si].DPD_Frag.Frag_len, 20	 ; # of bytes of data
		or	[si].DPD_Frag.Frag_len, FRAGLAST ; set fraglast bit

		mov	dx, PortDnListPtr
		mov	eax, DPD_physaddr
		out	dx, eax 			; write DnListPtr
;
; enable transmission.
;
		mov	dx, PortCmdStatus
		mov     ah, CMDH_TXENABLE
		out     dx, ax			; enable the Tx
;
; wait 1.25 seconds (>1 sec required by N-Way) for the linkbeat detect
; logic/N-Way auto-select to settle.
;
		mov	cx, 25			; 25 x 1/20th = 1.25 sec
tlb_loop:
		push	cx
		mov	cx, Delay25ms
		call	WaitTime
		call	WaitTime
		pop	cx
		loop	tlb_loop
;
; check for linkbeat
;
		mov	dx, PortCmdStatus
		SelectWindow WNO_DIAGNOSTICS

		mov	dx, PortMediaStatus
		in	ax, dx			; AX=MediaStatus
		test	ax, MEDIA_LBEAT 	; got linkbeat?
		jnz     tlb_gotlink
;
; no linkbeat.	connector probably not connected to a network.
;
		public	tlb_bad
tlb_bad:
		stc
		jmp	short tlb_exit
;
; got linkbeat.  if we're testing 10BaseT, that's good enough.
;
		public  tlb_gotlink
tlb_gotlink:
		cmp     Xcvr, XCVR_10TP
		je      tlb_good_10
;
; with 100BaseTX the problem is that 10Mbps traffic makes the 100Mbps link beat
; indication go on.  so we need to do some sanity checking of the result.  we
; want to loop around for a while looking for linkbeat to go off (there was
; a long enough gap in the 10Mbps traffic) or a packet to be received (if good,
; then its a real 100Mbps network).  we also sample carrier during this loop.
; if we see carrier enough of the time during the loop, then we should have
; received a packet.  if not, its just 10Mbps traffic giving us a false linkbeat.
; this is acceptable only because this loop runs for a very long time relative
; to the wire.  on current PCI systems with a single I/O taking around 600ns,
; this loop run run around 1/16th of a second.  this is long enough for 150
; max size 4500 byte packets plus 333 additional slot times for backoff.  this
; seems a reasonable period to require a packet to show up if we have carrier.
; the only exposure here is if some future system has massively faster single
; I/O cycles, which doesn't seem too worrisome.
;
		mov	dx, PortCmdStatus
		mov     ax, CMD_SETRXFILTER + FILTER_PROMISCUOUS
		out     dx, ax
		mov     ah, CMDH_RXENABLE
		out     dx, ax			; enable the receiver

		xor     bx, bx			; BX=# CRS's seen=0
		mov	cx, 0FFFFh		; CX=# loops to do
tlb_outer:
		test	UPD.UPD_UpPktStatus, UPPKTCOMPLETE
		jz	nopkg			; ...nope

;		AcknowledgeInt INT_UPCOMPLETE
		mov	eax, dword ptr UPD.UPD_UpPktStatus
		test	ah, RXSH_ERROR		; any errors?
		jz	tlb_good		; ...no errors, must be 100Mbps

		mov	dword ptr UPD.UPD_UpPktStatus, 0 ; clear the uppktstatus
nopkg:
		mov	dx, PortMediaStatus
		in      ax, dx

		test    ax, MEDIA_LBEAT		; still got linkbeat?
		jz      tlb_bad			; nope--bad link

		test    ax, MEDIA_CRS		; count CRS's seen
		jz      crss
		inc     bx			; ++BX = # of CRS's seen
crss:
		loop    tlb_outer
;
; fell out of loop.  linkbeat the whole time.  no good packets received.  if
; carrier sense was on a lot of the time, then we should have got a packet.
; if not, its a false reading.
;
		cmp     bx, 4000h		; CRS on 1/4 of the time?
		jae     tlb_bad			; if so, false reading
;
; connector good.  return carry clear.
;
tlb_good:
tlb_good_10:
		clc
;
; return current carry flag setting after disabling.
;
		public	tlb_exit
tlb_exit:
		mov	ax, 0			; used mov's to preserve CF
		mov	UPD.UPD_UpPktStatus, ax	; clear UPD status
		pushf

		mov	dx, PortCmdStatus
		call	TxReset
		call	RxReset

		popf
		pop	es
		popa
		ret

TryLinkbeat	endp



;------ QuietConnector ------------------------------------------------------;
;
;       This routine shuts down all output from the adapter.  It does this
;       by selecting the 10BaseT connector and disabling linkbeat.
;
;       Entry:
;       cli
;       DelayXcvr set for 3ms delay.
;
;       Exit:
;       cli
;       DC-DC stopped.
;       InternalConfig set to use 10BaseT.
;       MediaStatus set to linkbeat disabled.
;       Rx/TxFIFO's reset and disabled.
;
;       All registers preserved.
;
;----------------------------------------------------------------------------;
QuietConnector  proc    near

		pusha
;
; set up the InternalConfig for 10BaseT
;
		mov	dx, PortCmdStatus
		SelectWindow WNO_FIFO

		mov	dx, PortInternalCfgH
		in      ax, dx
		and     ax, NOT ICH_XCVR_MASK
		or      ax, XCVR_10TP SHL ICH_XCVR_SHIFT
		out     dx, ax
;
; in MediaStatus, disable linkbeat generation
;
		mov	dx, PortCmdStatus
		SelectWindow WNO_DIAGNOSTICS

		mov	dx, PortMediaStatus
		in      ax, dx		  ; AX=media status
		and     ax, NOT (MEDIA_LBEATENABLE)
		out     dx, ax		  ; write it back
;
; reset the Tx/RxFIFO's
;
		mov	dx, PortCmdStatus
		call	TxReset
		call	RxReset

		popa
		ret

QuietConnector  endp


;------ TryLoopback ---------------------------------------------------------;
;									     ;
;	This routine sets up the adapter to use one of the		     ;
;	non-linkbeat-capable connectors: 10BNC or 10AUI.  For these	     ;
;	connectors we enable external loopback and transmit a packet to      ;
;	ourselves.  If we receive it (or any other packet without errors)    ;
;	the connector works.						     ;
;									     ;
;	This routine is part of the auto-select logic and is called by	     ;
;	AutoSelect to do its work.					     ;
;									     ;
;	Entry:								     ;
;	cli								     ;
;	Xcvr set to the connector to set up.				     ;
;	SWConfig has the software configuration word from the EEProm.	     ;
;	Delay3ms set for 3ms delay.					    ;
;	Delay25ms set up for a 50ms delay.				     ;
;	MediaEnable table defined.					     ;
;	Specific.mc_caddr set up with the station address.		     ;
;	no interrupts pending.						     ;
;									     ;
;	Exit:								     ;
;	cli								     ;
;	clc if we get linkbeat, the connector seems fine.  stc if not.	     ;
;	DC-DC converted started/stopped.				     ;
;	MediaStatus set up.						     ;
;	MacControl set up.						     ;
;	InternalConfig set up.						     ;
;	Rx/TxFIFO's reset and disabled.                                      ;
;	NetDiag modified for no loopback.				     ;
;									     ;
;	All registers preserved.					     ;
;									     ;
;----------------------------------------------------------------------------;

		public	TryLoopback
TryLoopback	proc	near
		pusha
;
; set up the connector
;
		call	SetupConnector
;
; enable external loopback so that we can see our own packets
;
		mov	dx, PortCmdStatus
		SelectWindow WNO_DIAGNOSTICS
		mov	dx, PortNetDiag
		in	ax, dx
		and	ax, NETD_NOLOOPBACK_MASK
		or	ax, NETD_EXTLOOPBACK
		out	dx, ax
;
; up to three times (we might get collisions) try to loop a packet thru
;
		mov	bp, 3			; outer loop count

		public	tlp_loop
tlp_loop:
;
; reset both transmitter and receiver, enable both and set up our packet
; filter to receive anything
;
		mov	dx, PortCmdStatus
		call	TxReset
		mov     ah, CMDH_TXENABLE
		out     dx, ax

		call	RxReset
		mov     ah, CMDH_RXENABLE
		out     dx, ax

		mov	ax, CMD_SETRXFILTER + FILTER_PROMISCUOUS
		out	dx, ax
;
; load the UplistPtr
;
		mov	dx, PortUpListPtr
		mov	eax, UPD_physaddr
		out	dx, eax

		mov	dx, PortCmdStatus
		mov	ax, CMD_STALLCTL + UP_UNSTALL
		out	dx, ax
;
; send a 14-byte packet to ourselves.
;
		push	ds
		pop	es
		mov	di, offset DGroup:TxBuf
		mov	dword ptr [di], 16
		add	di, 4			; adjust ptr 4 bytes
IFDEF	UNDI
		lea	si, DGroup:BoardID
ELSE
		lea	si, NetAddress
ENDIF
		mov	cx, 6
	rep	movsb			;rep outsb	; destination address
		mov	cx, 6
		sub	si, 6
	rep	movsb			;rep outsb	; source address

		mov	word ptr es:[di], 0h		; pad to 16 bytes

		mov	si, offset DPD
		mov	[si].DPD_FSHindicate, 0000h	; turn off dnIndicate
		mov	[si].DPD_FrameStart, 8000h 	;turn on txIndicate 
		mov	[si].DPD_Frag.Frag_len, 20	 ; # of bytes of data
		or	[si].DPD_Frag.Frag_len, FRAGLAST ; set fraglast bit

		mov	dx, PortDnListPtr
		mov	eax, DPD_physaddr
		out	dx, eax 			; write DnListPtr

		mov	dx, PortDMACtrl
;
; wait for the packet to show up in RxStatus.  give it up to 1/4 second.
;
		mov	cx, 5			; 5 x 1/20th = 1/4 second
tlp_rxloop:
		in	eax, dx 		; read pktstatus
		test	ax, UPCOMPLETE
		jnz	tlp_rxcomplete

		push	cx			; 950511
		mov	cx, Delay25ms
		call	WaitTime
		call	WaitTime
		pop	cx			; 950511
		loop	tlp_rxloop

		xor	ax, ax
		mov	UPD.UPD_UpPktStatus, ax	; clear it anyway
;
; no complete packets received.  try again.
;
		public	tlp_rxfail
tlp_rxfail:
		dec	bp
		jnz	tlp_loop
		jmp	tlp_bad
;
; a complete RxStatus.	check for any errors.
;
		public	tlp_rxcomplete
tlp_rxcomplete:
		mov	dx, PortCmdStatus
		mov	ax, CMD_ACKNOWLEDGE + INT_UPCOMPLETE	
		out     dx, ax

		mov	eax, DWORD PTR UPD.UPD_UpPktStatus
		test	ah, RXSH_ERROR
		jnz	tlp_rxfail
;
; got a good receive packet.  connector seems good.
;
		public	tlp_good
tlp_good:
		xor	ax, ax
		mov	UPD.UPD_UpPktStatus, ax ; clear it
		clc
		jmp	short tlp_exit
;
; no packets received.	connector probably not connected to a network.
;
		public	tlp_bad
tlp_bad:
		stc
;
; return current carry flag setting after disabling/resetting.
;
		public	tlp_exit
tlp_exit:
		pushf

		mov	dx, PortCmdStatus
		SelectWindow WNO_DIAGNOSTICS
		mov	dx, PortNetDiag
		in	ax, dx
		and	ax, NETD_NOLOOPBACK_MASK
		out	dx, ax			; disable any loopback modes

		mov	dx, PortCmdStatus
		call	TxReset
		call	RxReset

		popf
		popa
		ret

TryLoopback	endp


;------ SetupConnector ------------------------------------------------------;
;									     ;
;	This routine sets up the adapter to use the specified connector.     ;
;	It sets up the connector in InternalConfig, sets bits in MacControl  ;
;	and MediaStatus as appropriate, and starts/stops the DC-DC converter ;
;	as required.							     ;
;									     ;
;	Entry:								     ;
;	cli								     ;
;	Xcvr set to the connector to set up.				     ;
;	SWConfig has the software configuration word from the EEProm.	     ;
;	Delay3ms set for 3ms delay.					    ;
;	MediaEnable table defined.					     ;
;									     ;
;	Exit:								     ;
;	cli								     ;
;	DC-DC converted started/stopped.				     ;
;	MediaStatus set up.						     ;
;	MacControl set up.						     ;
;	InternalConfig set up.						     ;
;	Rx/TxFIFO's reset and disabled.                                      ;
;	NetDiag modified for no loopback.				     ;
;									     ;
;	All registers preserved.					     ;
;									     ;
;----------------------------------------------------------------------------;

		public	SetupConnector
SetupConnector	proc	near
		pusha
;
; disable any loopback modes in effect
;
		mov	dx, PortCmdStatus
		SelectWindow WNO_DIAGNOSTICS

		mov	dx, PortNetDiag
		in	ax, dx
		and	ax, NETD_NOLOOPBACK_MASK
		out	dx, ax
;
; set up the connector in InternalConfig
;
		mov	dx, PortCmdStatus
		SelectWindow WNO_FIFO

		mov	dx, PortInternalCfgH
		in	ax, dx
		and	ax, NOT ICH_XCVR_MASK
		mov	cx, Xcvr
		shl	cx, ICH_XCVR_SHIFT
		or	ax, cx
		out	dx, ax
;
; if full-duplex operation is specified, go enable it.	disable all the weird
; stuff for now.
;
		mov	dx, PortCmdStatus
		SelectWindow WNO_FIFO

		mov	dx, PortMacControl
		in	ax, dx
		and	ax, NOT MACC_FULLDUPLEX ; not full duplex
		and	ax, NOT MACC_ALLOWLARGE ; no large packets
		and	ax, NOT MACC_DEFEREXTEND ; normal 802.3 deferrence

; check to see if we auto negotiated.  If we did, then program full duplex
; based on what was negotiated.

;		mov	full_on, 0		; init a full duplex flag
;		test	Xcvr, XCVR_MII + XCVR_AUTO
;		jz	check_EEPROM

;		test	auto_negotiated, 1
;		jz	check_EEPROM

;		test	full_duplex, 1		; full duplex was set
;		jz	@F

;		or	ax, MACC_FULLDUPLEX
;		mov	full_on, 1
;		jmp	@F

;check_EEPROM:
;		test	SWConfig, SW_FULLDUPLEX
;		jz	@F

;		or	ax, MACC_FULLDUPLEX
;		mov	full_on, 1		; full duplex was set
;@@:
		out	dx, ax
;
; setup various bits in MediaStatus (jabber, linkbeat, sqe) as appropriate
; for the connector.  the user can force linkbeat off if desired at 10Mbps.
;
		mov	dx, PortCmdStatus
		SelectWindow WNO_DIAGNOSTICS

		mov	dx, PortMediaStatus
		in	ax, dx			; AX=media status
		and	ax, NOT MEDIA_XCVRBITS	; mask bits off first
		mov	bx, Xcvr		; transceiver type
		shl	bx, 1			; use as index into table
		or	ax, MediaEnable[bx]	; on bits appropriate to xcvr

		test	EESoftConfigInfo, SW_LINKBEAT	; if set, don't enable linkbeat
		jz	ConnectLinkBeat
		cmp	Xcvr, XCVR_10TP 	; but only for 10TP
		jne	ConnectLinkBeat
		and	ax, NOT (MEDIA_LBEATENABLE)
ConnectLinkBeat:
		out	dx, ax			; write it back
;
; if configured for 10Base2 we must start the internal transceiver.  if not
; we stop it (just in case the configuration has changed and we haven't cold
; booted).
;
		mov	dx, PortCmdStatus
		mov	ah, CMDH_STARTINTXCVR	; if BNC, start
		cmp	Xcvr, XCVR_10BNC
		je	ConnectXcvr
		mov	ah, CMDH_STOPINTXCVR	; else, stop
ConnectXcvr:
		out	dx, ax			; issue command
;
; now give the transceiver 3ms to stabilize before we enable transmit or
; receive traffic thru it.
;
		mov	cx, Delay3ms
		call	WaitTime
;
; reset the Tx/RxFIFO's
;
		mov	dx, PortCmdStatus
		call	TxReset
		call	RxReset

		mov	cx, 40*3
waitrdy:
		push	cx
		mov	cx, Delay25ms
		call	WaitTime
		pop	cx
		loop	waitrdy

		popa
		ret

SetupConnector	endp


;------ ForceMII --------------------------------------------------------------;
;	
;       Exit:
;       Carry bit set: found MII
;       Carry bit clear: MII test failed
;----------------------------------------------------------------------------;
		public  ForceMII
ForceMII	proc    near

		pusha

		cmp	Xcvr, XCVR_MII
		je	fmii_external_port
;
; Since it is not an external MII, it must be the Cyclone on-board in which
; case we know the PHY addr is 18h and we can go ahead and read the OUI.
;
		mov	MIIPhyAddr, NWAY
		mov	dx, MII_PHY_OUI
		call	ReadMIIPhy
		mov	miiphyoui, ax		; save OUI
		jc	freset_phy
		jmp	fm_fail_hw

fmii_external_port:
;
; Check to see if the MII is there.  No use going any further if it doesn't
; exist.  We only do this for the external MII.
;
		call	FindMIIPhy
		jnz	FoundMii
		jmp	fm_fail_hw

FoundMii:
		mov	cx, 31			; 31 possible combinations
floop_for_phy:
		mov	MIIPhyAddr, cl
		mov	dx, MII_PHY_OUI
		call	ReadMIIPhy
		jc	ffind_mii_phy
		loop	floop_for_phy
		jmp	fm_fail_hw

ffind_mii_phy:
		mov	miiphyoui, ax		; save the OUI
		mov	dx, MII_PHY_MODEL
		call	ReadMIIPhy
		jc	freset_phy
		jmp	fm_fail_hw

freset_phy:
		mov	miiphymodel, ax 	; save the model
		mov	dx, MII_PHY_CONTROL
		call	ReadMIIPhy
		jc	ff1
		jmp	fm_fail_hw
ff1:
		or	ax, MII_CTL_RESET	; reset the MII
		call	WriteMiiPhy
;
; Wait up to 2 seconds for reset to finish.
;
		mov	ecx, 10
fm_loop1:
		mov	dx, MII_PHY_CONTROL
		call	ReadMIIPhy
		jc	ff2
		jmp	fm_fail_hw

ff2:
		test	ax, MII_CTL_RESET	; reset done?
		jz	mii_freset_done

		call	Delay200ms

		loop	fm_loop1
		jmp	fm_fail_hw

mii_freset_done:
		cmp	miiphyoui, NATIONAL_OUI ; National's OUI
		jne	force_nway

		cmp	miiphymodel, NATIONAL_MODEL ;
		jne	force_nway

; do the National 840A fix for the switch
		mov	dx, MII_PHY_PCR
		call	ReadMIIPhy
		jc	ff3
		jmp	fm_fail_hw

ff3:
		or	ax, 0020h		; set bit 5 = 1, force
						; disconnect to bypass
		call	WriteMIIPhy
force_nway:
		mov	dx, MII_PHY_CONTROL
		call	ReadMIIPhy
		jc	ff4
		jmp	fm_fail_hw

ff4:
		mov	cx, ax			; save Control reg. value
		mov	LineSpeed, 10
		and	ax, NOT MII_CTL_100MB	; 10 Mbps
		cmp	miiselect, BASE10_T
		je	force_speed_done

		cmp	miiselect, AUTO_10BASET ; 10 Mbps - Auto_nego
		je	force_speed_done

		mov	LineSpeed, 100
		or	ax, MII_CTL_100MB	; 100 Mbps
		cmp	miiselect, BASE100_TX
		je	force_speed_done

		cmp	miiselect, AUTO_100BASETX   ; 100 Mbps - Auto nego
		je	force_speed_done

		and	ax, not MII_CTL_ENABLE_AUTO ; disable auto negotiation
		and	ax, not MII_CTL_FULL_DUPLEX ; half duplex
		cmp	miiselect, BASE100_T4	; 100 Mbps - T4
		je	fmii_2
		jmp	fm_fail_hw

force_speed_done:
		and	ax, not MII_CTL_ENABLE_AUTO ; disable auto negotiation
		and	ax, not MII_CTL_FULL_DUPLEX ; half duplex
;		test	SWConfig, SW_FULLDUPLEX     ; check SoftwareInfo for
;		jz	fmii_2			    ; duplex info
;
;		or	ax, MII_CTL_FULL_DUPLEX ; full duplex
fmii_2:
		mov	dx, MII_PHY_CONTROL
		call	WriteMiiPhy
;
; workaround for Broadcom T4 bug - need to reset if going from 10 to 100 Mbps
;
		cmp	miiphyoui, BROADCOM_OUI ; check for Broadcom
		jne	ff5

		cmp	miiphymodel, BROADCOM_MODEL ; model = 0
		jne	ff5

		test	cx, 2000h		; if previous speed=100
		jnz	ff5			; don't reset

		cmp	LineSpeed, 100		; prev. speed = 10, check current speed
		jne	ff5

		mov	dx, MII_CTL_RESET	; current speed = 100,
		call	WriteMiiPhy		; need to reset
ff5:
;;; 980209
; check link status

		mov	cx, 25
chk_link_status:
		push	cx
		mov	dx, MII_PHY_STATUS
		call	ReadMIIPhy
		pop	cx
		jc	chk_lnk2
		jmp	fm_fail_hw

chk_lnk2:
		test	ax, MII_STS_LINK_UP
		jnz	ff6

		call	Delay200ms

		loop	chk_link_status
		jmp	fm_fail_hw
ff6:
;;;
		stc
		jmp	short fm_exit

fm_fail_hw:
		or	ax, 1			; zf = 0
		clc				; cf = 0
		jmp	short fm_exit

fm_fail:
		xor	ax, ax			; zf = 1
		clc				; cf = 0
fm_exit:
		popa
		ret

ForceMII	endp


;------ TryMII --------------------------------------------------------------;
;	
;       Exit:
;       Carry bit set: found MII
;       Carry bit clear: MII test failed
;----------------------------------------------------------------------------;
		public  TryMII
TryMII		proc	near

;;int 03h

		pusha
;		mov	auto_negotiated, 0	    ; clear auto negotiated flag
;		mov	forcemode, 0
		cmp	Xcvr, XCVR_MII
		je	mii_external_port

cyc_auto_con:
		mov	miiphyaddr, NWAY
		mov	dx, MII_PHY_OUI
		call	ReadMIIPhy
		mov	miiphyoui, ax
		jc	reset_phy
		jmp	tm_fail_hw

mii_external_port:
		call	FindMIIPhy
		jnz	tm01
		jmp	tm_fail_hw
;
; Search for the PHY address
;
tm01:
		mov	cx, 31
loop_for_phy:
		mov	miiphyaddr, cl
		mov	dx, MII_PHY_OUI
		call	ReadMIIPhy
		jc	find_mii_phy
		loop	loop_for_phy
		jmp	tm_fail_hw

find_mii_phy:
		mov	miiphyoui, ax
		mov	dx, MII_PHY_MODEL
		call	ReadMIIPhy
		mov	miiphymodel, ax 	; save the model
		jc	reset_phy
		jmp	tm_fail_hw
;
; The MII Phy exists. Reset it.
; DX has the offset of control reg. AX return the value of control reg.
;
reset_phy:
		mov	dx, MII_PHY_CONTROL
		call	ReadMIIPhy
		jc	tm02
		jmp	tm_fail_hw

tm02:
		or	ax, MII_CTL_RESET
		call	WriteMIIPhy

		mov	cx, 10			; total timeout about 2 sec.
tm_loop1:
		push	cx
		mov	dx, MII_PHY_CONTROL
		call	ReadMIIPhy
		pop	cx
		jc	tm03
		jmp	tm_fail_hw

tm03:
		test	ax, MII_CTL_RESET	; reset done?
		jz	mii_reset_done		; yes

		call	Delay200ms		; no, delay 200 ms
		loop	tm_loop1
		jmp	tm_fail_hw

mii_reset_done:


			mov	cx,0Fh
  			push	ax
  			push	bx
  			push	cx
  			push	dx
			mov	cx,4

locloop_1167:							;  xref 8A38:F210
				mov	ax,DGroup:DelaySomething.loword				; (8A38:2892=0)
           		mov	dx,DGroup:DelaySomething.hiword				; (8A38:2894=0)
loc_1168:							;  xref 8A38:F20E
				sub	ax,1
				sbb	dx,0

      			mov	bx,ax
      			or	bx,dx
      			jnz	loc_1168				; Jump if not zero
      			loop	locloop_1167				; Loop if cx > 0

      			pop	dx
      			pop	cx
      			pop	bx
      			pop	ax

;;		mov	dx, MII_PHY_CONTROL
;;		call	ReadMIIPhy
;;		jc	tm04
;;		jmp	tm_fail_hw

;;tm04:
;;		mov	cx, ax			; cx <= control reg.


locloop_1169:							;  xref 8A38:F249
    		mov	dx, MII_PHY_STATUS
    		call	ReadMIIPhy					; (659E)
    		jc	short loc_1170				; Jump if carry Set
    		jmp	tm_fail_hw				; (F38B)
loc_1170:							;  xref 8A38:F21C
    		test	ax,20h
    		jnz	short loc_1173				; Jump if not zero
    		push	ax
    		push	bx
    		push	cx
    		push	dx
    		mov	cx,4

locloop_1171:							;  xref 8A38:F243

			mov	ax,DGroup:DelaySomething.loword				; (8A38:2892=0)
       		mov	dx,DGroup:DelaySomething.hiword				; (8A38:2894=0)

loc_1172:							;  xref 8A38:F241

    		sub	ax,1
    		sbb	dx,0
    		mov	bx,ax
    		or	bx,dx
    		jnz	loc_1172				; Jump if not zero
    		loop	locloop_1171				; Loop if cx > 0

    		pop	dx
    		pop	cx
    		pop	bx
    		pop	ax
    		loop	locloop_1169				; Loop if cx > 0

loc_1173:							;  xref 8A38:F227


		mov	dx, MII_PHY_CONTROL
		call	ReadMIIPhy
		jc	tm04
		jmp	tm_fail_hw

tm04:
		mov	cx, ax			; cx <= control reg.


;
; now we can read the status and try to figure out what's out there.
;
		push	cx
		mov	dx, MII_PHY_STATUS
		call	ReadMIIPhy
		pop	cx
		jc	tm05
		jmp	tm_fail_hw

tm05:
;
; bit 15 = 100BaseT4,
; bit 14 = 100BaseTX (full duplex),
; bit 13 = 100BaseTX (half duplex),
; bit 12 = 10BaseT (full duplex),
; bit 11 = 10BaseT (half duplex)
;
		test	ax, MII_STS_100MB_MASK+MII_STS_10MB_MASK
		jnz	handle_both
		jmp	tm_fail_hw		; sanity check

handle_both:
;
; if MII does not have extended registers, we have no way to tell
; what the link speed is after the completion of auto negotiation.
; (no ANLPAR register, no PAR regiater)
;
		test	ax, MII_STS_EXTENDED
		jnz	tm06
		jmp	no_auto_nego

tm06:
;
; see if it is capable of auto negotiation
;
		test	ax, MII_STS_AUTO	; auto negotiation capable
		jnz	tm07			; yes
		jmp	no_auto_nego

tm07:
;
; it is capable of auto negotiation, see if it has been done already.
; if not, re-initialize autoselect/autonego. otherwise, accept the results.
;
; special hack for National part.  We know we are NWAY capable
; and we are not the Broadcom T4 part which is not NWAY capable
;
		cmp	miiphyoui, NATIONAL_OUI
		jne	enable_auto

		cmp	miiphymodel, NATIONAL_MODEL
		jne	enable_auto

		push	cx
		push	ax
		mov	dx, MII_PHY_PCR
		call	ReadMIIPhy
		jc	force_link_disc
		pop	cx
		pop	ax
		jmp	tm_fail_hw

force_link_disc:
		or	ax, 0020h		; set bit 5 = 1, force
						; disconnect to bypass
		mov	dx, MII_PHY_PCR
		call	WriteMIIPhy
		pop	ax
		pop	cx

enable_auto:
		mov	si, 3			; retry count for 840A fix
		test	cx, MII_CTL_ENABLE_AUTO ; auto nego enabled?
		jz	auto_not_enabled

		test	ax, MII_STS_AUTO_DONE	; auto nego done?
		jz	auto_not_enabled
		jmp	auto_nego_done

auto_not_enabled:
		mov	ax, cx			; AX <= control reg.
		or	ax, MII_CTL_START_AUTO	; restart auto nego
		or	ax, MII_CTL_ENABLE_AUTO ; enable it
		mov	dx, MII_PHY_CONTROL
		call	WriteMIIPhy

		mov	cx, 10			; 2 sec. timeout
tm_loop2:
		push	cx
		mov	dx, MII_PHY_STATUS
		call	ReadMIIPhy
		pop	cx
		jc	tm08
		jmp	tm_fail_hw

tm08:
		test	ax, MII_STS_AUTO_DONE	; done?
		jnz	auto_nego_done		; yes

		call	Delay200ms		; no, delay 200 ms
		loop	tm_loop2
;
; pending: if MII_STS_AUTO_DONE never set in status reg. Check to see if it is
; a National 840A in which case do 840A fix else fail out as a recoverable.
;
		cmp	miiphyoui, NATIONAL_OUI
		jne	tm_fail

		cmp	miiphymodel, NATIONAL_MODEL
		jne	tm_fail
;
; 840A workaround
;
		mov	dx, MII_PHY_ANER
		call	ReadMIIPhy
		jc	tm09
		jmp	tm_fail_hw

tm09:
		mov	dx, MII_PHY_ANER
		call	ReadMIIPhy
		jc	tm10
		jmp	tm_fail_hw

tm10:
		test	ax, MII_ANER_MLF
		jz	auto_nego_retry

		mov	dx, MII_PHY_CONTROL
		call	ReadMIIPhy
		jc	tm11
		jmp	tm_fail_hw

;
; force to 100Mbps half duplex
;
tm11:
		and	ax, NOT MII_CTL_FULL_DUPLEX
		and	ax, NOT MII_CTL_ENABLE_AUTO
		or	ax, MII_CTL_100MB
		mov	dx, MII_PHY_CONTROL
		call	WriteMIIPhy

		mov	dx, MII_PHY_STATUS
		call	ReadMIIPhy
		jc	tm12
		jmp	tm_fail_hw
tm12:
		mov	cx, 20			; wait up to 4 sec.
tm_mlp:
		push	cx
		mov	dx, MII_PHY_STATUS
		call	ReadMIIPhy
		pop	cx
		jc	tm13
		jmp	tm_fail_hw

tm13:
		test	ax, MII_STS_LINK_UP
		jnz	mlp_link_up

		call	Delay200ms
		loop	tm_mlp
		jmp	tm_fail_hw

mlp_link_up:
;		mov	full_duplex, 0		; forced to half duplex
		mov	LineSpeed, 100		; forced to 100 Mbps
;		mov	auto_negotiated, 1	; fake the auto negotiation
		stc
		jmp	tm_exit

;
; retry the auto negotiation here for a certain number of times
;
auto_nego_retry:
		dec	si
		jz	tm_fail

		mov	ax, MII_CTL_RESET
		mov	dx, MII_PHY_CONTROL
		call	WriteMIIPhy

		mov	cx, 10			; wait up to 2 sec for reset
reset_wait:
		push	cx
		mov	dx, MII_PHY_CONTROL
		call	ReadMIIPhy
		pop	cx
		jc	tm14
		jmp	tm_fail_hw

tm14:
		test	ax, MII_CTL_RESET
		jz	mlp_reset_done

		call	Delay200ms		; delay 200 ms
		loop	reset_wait
		jmp	tm_fail_hw		; can't reset, something wrong

mlp_reset_done:
		mov	cx, ax
		jmp	auto_not_enabled
; end 840A workaround
;
; check link status.  Since it is a latch function, read status register again.
;
auto_nego_done:
;		mov	auto_negotiated, 1
		mov	dx, MII_PHY_STATUS
		call	ReadMIIPhy
		jc	tm15
		jmp	tm_fail_hw

tm15:
		test	ax, MII_STS_LINK_UP	; do I have link?
		jnz	tm16			; yes
		jmp	tm_fail 		; no, just get out (maybe not plugged in)
;
; read the advertised abilities of link partner as received during auto
; negotiation.
;
tm16:
		mov	dx, MII_PHY_ANLPAR
		call	ReadMIIPhy
		jnc	tm_fail_hw

		mov	phyANLPAR, ax
;
; read the advertised abilities of myself as transmitted to link partner
; during auto negotiation.
;
		mov	dx, MII_PHY_ANAR
		call	ReadMIIPhy
		jnc	tm_fail_hw

		mov	phyANAR, ax
		mov	bx, phyANLPAR		; link partner's abilities
		mov	ax, phyANAR		; my abilities
		test	ax, MII_ANLPAR_100BASET4 ; Can I do 100 T4?
		jz	nws_1			; no

		test	bx, MII_ANLPAR_100BASET4 ; yes, now can my partner?
		jz	nws_1			; no

;		mov	full_duplex, 0		; yes, set to half duplex
		jmp	must_be_100mb

nws_1:
		test	ax, MII_ANLPAR_100BASEX_FD ; Can I do 100 Full duplex?
		jz	nws_2			; no

		test	bx, MII_ANLPAR_100BASEX_FD ; yes, now can my partner?
		jz	nws_2			; no

;		mov	full_duplex, 1		; yes, set to full duplex
		jmp	must_be_100mb

nws_2:
		test	ax, MII_ANLPAR_100BASEX_HD ; Can I do 100 Half duplex?
		jz	nws_3			; no

		test	bx, MII_ANLPAR_100BASEX_HD ; yes, now can my partner?
		jz	nws_3			; no

;		mov	full_duplex, 0		; yes, set to half duplex
		jmp	must_be_100mb

nws_3:
		test	ax, MII_ANLPAR_10BASET_FD ; Can I do 10 Full duplex?
		jz	nws_4			; no

		test	bx, MII_ANLPAR_10BASET_FD ; yes, now can my partner
		jz	nws_4			; no

;		mov	full_duplex, 1		; yes, set to full duplex
		jmp	must_be_10mb

nws_4:
		test	ax, MII_ANLPAR_10BASET_HD ; Can I do 10 Half duplex?
		jz	tm_fail_hw		; no, fail out

		test	bx, MII_ANLPAR_10BASET_HD ; yes, now can my partner?
		jz	nws_5			; no

;		mov	full_duplex, 0		; yes, set to half duplex
		jmp	must_be_10mb
;
; We came here because the link partner didn't advertise anything.  Maybe
; it is a bug.	Check if it is a National 840A.  If it is, then do the fix
; else fail out.
;
nws_5:
		cmp	miiphyoui, NATIONAL_OUI
		jne	tm_fail_hw		; since not National part, fail

		cmp	miiphymodel, NATIONAL_MODEL
		je	nway_patch		; go to NWAY patch for National part
		jmp	tm_fail_hw		; fail, not the correct model
;
; PATCH for National 840A nway chip problem.
; Should read the ANLPAR reg. and ANAR reg. to determine the link used.
; See P010.C, a workaround solution is to read PAR reg. instead.
;
nway_patch:
;		mov	full_duplex, 0		; since link partner not NWAY default to half duplex
		mov	dx, MII_PHY_PAR 	; special National register
		call	ReadMIIPhy
		jc	tm17
		jmp	tm_fail

tm17:
		test	ax, 0040h		; SPEED_10 = bit 6
		jnz	must_be_10mb
;
; *** end of PATCH
;
must_be_100mb:
		mov	LineSpeed, 100
		stc				; return success
		jmp	tm_exit

must_be_10mb:
		mov	LineSpeed, 10
		stc				; return success
		jmp	tm_exit

;
; auto negotiation didn't work.  It might be able to auto-select
;
no_auto_nego:
;		mov	auto_negotiated, 0	; didn't auto negotiate
;
; It might be a Broadcom part that only supports T4
;
		cmp	MIIPhyOui, 03e0h
		je	tm18
		jmp	tm_fail_hw		; just get out

tm18:
		cmp	MIIPhyModel, 0
		je	tm19
		jmp	tm_fail_hw		; just get out and fail h/w

tm19:
;
; we now know we are Broadcom T4, so initialize some variables for the the
; T4 fix here.	It is a good a place as any.
;
		push	ax
		push	cx
		test	cx, MII_CTL_ENABLE_AUTO ; here it is auto-selection
						; not auto-negotiation
		jz	bcm_auto_not_enabled

		test	ax, MII_STS_AUTO_DONE
		jz	bcm_auto_not_enabled
		jmp	bcm_auto_done

bcm_auto_not_enabled:
		mov	ax, cx
		or	ax, MII_CTL_ENABLE_AUTO ; enable auto selection
		and	ax, NOT MII_CTL_FULL_DUPLEX
;		test	SWConfig, SW_FULLDUPLEX
;		jz	tm20

;		or	ax, MII_CTL_FULL_DUPLEX
tm20:
		mov	dx, MII_PHY_CONTROL
		call	WriteMIIPhy

bcm_auto_done:
		pop	cx
		pop	ax

; check link status.  Since it is a latch function, read status register again.

		mov	cx, 25
link_status_loop:
		push	cx
		mov	dx, MII_PHY_STATUS
		call	ReadMIIPhy
		pop	cx
		jc	tm21
		jmp	tm_fail_hw

tm21:
		test	ax, MII_STS_LINK_UP
		jnz	read_ext_reg

		call	Delay200ms

		loop	link_status_loop
		jmp	tm_fail
;
; read address reg. 10h
;
read_ext_reg:
		mov	dx, MII_EXT_REG0
		call	ReadMIIPhy		; read extended reg. 0 to get speed
		jc	tm22
		jmp	tm_fail_hw

tm22:
		test	ax, MII_EXT_SPEED	; speed is (1=100, 0=10)
		jnz	tm23
		jmp	must_be_10mb
tm23:
		jmp	must_be_100mb

tm_fail_hw:
		or	ax, 1				; zf = 0
		clc					; cf = 0
		jmp	short tm_exit

tm_fail:
		xor	ax, ax				; zf = 1
		clc					; cf = 0
tm_exit:
		popa
		ret

TryMII		endp


;------ FindMIIPhy ----------------------------------------------------------;
;        
;       Exit:
;       ZF set: not found
;       ZF clear: found
;----------------------------------------------------------------------------;

                public  FindMIIPhy
FindMIIPhy      proc    near

                pusha
		mov	dx, PortCmdStatus
                SelectWindow    WNO_DIAGNOSTICS
		mov	dx, PortPhyMgmt
;
; drop everything, so we are not driving the data, and run the clock
; through 32 cycles in case the PHY is trying to tell us something. Then
; read the data line, since the PHY's pull-up will read as a 1 if it's
; present.
;
                xor     ax, ax
                out     dx, ax

                mov     cx, 32
fmp_loop:
                call	Delay500ns
                mov     ax, MGMT_PHY_CLOCK
                out     dx, ax
                call	Delay500ns
                xor     ax, ax
                out     dx, ax
                loop    fmp_loop

                in      ax, dx
                test    ax, MGMT_PHY_DATA1

                ;SelectWindow   WNO_OPERATING
                popa
                ret
FindMIIPhy      endp


;------ SendOneBitToMII --------------------------------------------------------;
;        
; send one bit out on MDIO.
;
; On Entry: bit 0 in AX - the bit to be sent.
;----------------------------------------------------------------------------;
                public  SendOneBitToMII
SendOneBitToMII proc    near

;;Sub_59 proc    near


		or	ax,4
		out	dx,ax					; port 0FFFAh ??I/O Non-standard

        call	Delay500ns

;;		pusha						; Save all regs
;;		mov	ax,data_577				; (8A38:2896=0)
;;		mov	dx,data_578				; (8A38:2898=0)
;;loc_415:							;  xref 8A38:690D
;;		sub	ax,1
;;		sbb	dx,0
;		mov	bx,ax
;;		or	bx,dx
;;		jnz	loc_415					; Jump if not zero
;;		popa						; Restore all regs

		or	ax,1
		out	dx,ax					; port 0FFFAh ??I/O Non-standard

        call	Delay500ns

;;		pusha						; Save all regs
;;		mov	ax,data_577				; (8A38:2896=0)
;;				mov	dx,data_578				; (8A38:2898=0)
;;loc_416:							;  xref 8A38:6926
;;		sub	ax,1
;;		sbb	dx,0
;;		mov	bx,ax
;;		or	bx,dx
;;		jnz	loc_416					; Jump if not zero
;;		popa						; Restore all regs

		and	ax,0FFFEh
		out	dx,ax					; port 0FFFAh ??I/O Non-standard

        call	Delay500ns

;;		pusha						; Save all regs
;;		mov	ax,data_577				; (8A38:2896=0)
;;				mov	dx,data_578				; (8A38:2898=0)
;;loc_417:							;  xref 8A38:693F
;;		sub	ax,1
;;		sbb	dx,0
;;		mov	bx,ax
;;		or	bx,dx
;;		jnz	loc_417					; Jump if not zero
;;		popa						; Restore all regs


                ret

;;Sub_59 endp

SendOneBitToMII endp


;------ WriteMIIPhy ---------------------------------------------------------;
;
;       Entry:
;       DX = the register offset
;       AX = the data to be written to the register of xcvr
;
;       Exit:
;       All registers are preserved.
;        
;----------------------------------------------------------------------------;
                public  WriteMIIPhy
WriteMIIPhy     proc    near

		pusha						; Save all regs
		push	ax
		push	dx

		mov	dx, PortCmdStatus
        SelectWindow    WNO_DIAGNOSTICS
		mov	dx, PortPhyMgmt

		mov	cx,20h

locloop_353:							;  xref 8A38:6503
		mov	ax,2
		call	SendOneBitToMII					; (68F7)
		loop	locloop_353				; Loop if cx > 0

		xor	ax,ax					; Zero register

		call	SendOneBitToMII					; (68F7)
		mov	ax,2
		call	SendOneBitToMII					; (68F7)
		xor	ax,ax					; Zero register
		call	SendOneBitToMII					; (68F7)
		mov	ax,2
		call	SendOneBitToMII					; (68F7)

        xor bh, bh
    	mov	bl, miiphyaddr				; (8A38:64E0=0)
		mov	cx,5

locloop_354:							;  xref 8A38:6532
		xor	ax,ax					; Zero register
		test	bx,10h
		jz	short loc_355				; Jump if zero
		mov	ax,2

loc_355:							;  xref 8A38:6528
		call	SendOneBitToMII					; (68F7)
		shl	bx,1					; Shift w/zeros fill
		loop	locloop_354				; Loop if cx > 0

		pop	bx
		mov	cx,5

locloop_356:							;  xref 8A38:6548
		xor	ax,ax					; Zero register
		test	bx,10h
		jz	short loc_357				; Jump if zero
		mov	ax,2
loc_357:							;  xref 8A38:653E
		call	SendOneBitToMII					; (68F7)
		shl	bx,1					; Shift w/zeros fill
		loop	locloop_356				; Loop if cx > 0

		mov	ax,2
		call	SendOneBitToMII					; (68F7)
		xor	ax,ax					; Zero register
		call	SendOneBitToMII					; (68F7)
		pop	bx
		mov	cx,10h

locloop_358:							;  xref 8A38:6569
		xor	ax,ax					; Zero register
		test	bx,8000h
		jz	short loc_359				; Jump if zero
		mov	ax,2
loc_359:							;  xref 8A38:655F
		call	SendOneBitToMII					; (68F7)
		shl	bx,1					; Shift w/zeros fill
		loop	locloop_358				; Loop if cx > 0

		mov	ax,1
		out	dx,ax					; port 0FFFAh ??I/O Non-standard

        call	Delay500ns

;;		pusha						; Save all regs
;;		mov	ax,data_577				; (8A38:2896=0)
;;				mov	dx,data_578				; (8A38:2898=0)
;;loc_360:							;  xref 8A38:6581
;;		sub	ax,1
;;		sbb	dx,0
;;		mov	bx,ax
;;		or	bx,dx
;;		jnz	loc_360					; Jump if not zero
;;		popa						; Restore all regs

		xor	ax,ax					; Zero register
		out	dx,ax					; port 0FFFAh ??I/O Non-standard

        call	Delay500ns

;;		pusha						; Save all regs
;;		mov	ax,data_577				; (8A38:2896=0)
;;				mov	dx,data_578				; (8A38:2898=0)
;;loc_361:							;  xref 8A38:6599
;;		sub	ax,1
;;		sbb	dx,0
;;		mov	bx,ax
;;		or	bx,dx
;;		jnz	loc_361					; Jump if not zero
;;		popa						; Restore all regs

		popa						; Restore all regs
		retn



WriteMIIPhy	endp


; *******************************************************************
; *******************************************************************


;------ ReadMIIPhy ----------------------------------------------------------;
;        
;       Entry:
;       DX = the register offset
;
;       Exit:
;       Carry bit set: success
;       Carry bit clear: failed
;	AX = the value of the register in xcvr
;
;----------------------------------------------------------------------------;
                public  ReadMIIPhy
ReadMIIPhy      proc    near

		pusha						; Save all regs
		push	dx

		mov	dx, PortCmdStatus
        SelectWindow    WNO_DIAGNOSTICS
		mov	dx, PortPhyMgmt

		mov	cx,20h

locloop_362:							;  xref 8A38:65B4
		mov	ax,2
		call	sendonebittomii					; (68F7)
		loop	locloop_362				; Loop if cx > 0

		xor	ax,ax					; Zero register
		call	sendonebittomii					; (68F7)
		mov	ax,2
		call	sendonebittomii					; (68F7)
		mov	ax,2
		call	sendonebittomii					; (68F7)
		xor	ax,ax					; Zero register
		call	sendonebittomii					; (68F7)
        xor bh, bh
    	mov	bl, miiphyaddr				; (8A38:64E0=0)
		mov	cx,5

locloop_363:							;  xref 8A38:65E3
		xor	ax,ax					; Zero register
		test	bx,10h
		jz	short loc_364				; Jump if zero
		mov	ax,2
loc_364:							;  xref 8A38:65D9
		call	sendonebittomii					; (68F7)
		shl	bx,1					; Shift w/zeros fill
		loop	locloop_363				; Loop if cx > 0

		pop	bx
		mov	cx,5

locloop_365:							;  xref 8A38:65F9
		xor	ax,ax					; Zero register
		test	bx,10h
		jz	short loc_366				; Jump if zero
		mov	ax,2
loc_366:							;  xref 8A38:65EF
		call	sendonebittomii					; (68F7)
		shl	bx,1					; Shift w/zeros fill
		loop	locloop_365				; Loop if cx > 0

		xor	ax,ax					; Zero register
		out	dx,ax					; port 0FFFAh ??I/O Non-standard

		call	Delay500ns

;;		pusha						; Save all regs
;;		mov	ax,data_577				; (8A38:2896=0)
;;		mov	dx,data_578				; (8A38:2898=0)
;;loc_367:							;  xref 8A38:6610
;;		sub	ax,1
;;		sbb	dx,0
;;		mov	bx,ax
;;		or	bx,dx
;;		jnz	loc_367					; Jump if not zero
;;		popa						; Restore all regs
        
		mov	ax,1
		out	dx,ax					; port 0FFFAh ??I/O Non-standard
    
		call	Delay500ns

;;		pusha						; Save all regs
;;		mov	ax,data_577				; (8A38:2896=0)
;;				mov	dx,data_578				; (8A38:2898=0)
;;loc_368:							;  xref 8A38:6629
;;		sub	ax,1
;;		sbb	dx,0
;;		mov	bx,ax
;;		or	bx,dx
;;		jnz	loc_368					; Jump if not zero
;;		popa						; Restore all regs

		xor	ax,ax					; Zero register
		out	dx,ax					; port 0FFFAh ??I/O Non-standard

		call	Delay500ns

;;		pusha						; Save all regs
;;		mov	ax,data_577				; (8A38:2896=0)
;;		mov	dx,data_578				; (8A38:2898=0)
;;loc_369:							;  xref 8A38:6641

;;		sub	ax,1
;;		sbb	dx,0
;;		mov	bx,ax
;;		or	bx,dx
;;		jnz	loc_369					; Jump if not zero
;;		popa						; Restore all regs

		in	ax,dx					; port 0FFFAh ??I/O Non-standard
		test	ax,2
		jz	short loc_370				; Jump if zero
		clc						; Clear carry flag
		jmp	loc_379					; (66F8)
loc_370:							;  xref 8A38:6648
		mov	ax,1
		out	dx,ax					; port 0FFFAh ??I/O Non-standard

		call	Delay500ns

;;		pusha						; Save all regs
;;		mov	ax,data_577				; (8A38:2896=0)
;;				mov	dx,data_578				; (8A38:2898=0)
;;loc_371:							;  xref 8A38:6664
;;		sub	ax,1
;;		sbb	dx,0
;;		mov	bx,ax
;;		or	bx,dx
;;		jnz	loc_371					; Jump if not zero
;;		popa						; Restore all regs

		xor	ax,ax					; Zero register
		out	dx,ax					; port 0FFFAh ??I/O Non-standard

		call	Delay500ns

;;		pusha						; Save all regs
;;		mov	ax,data_577				; (8A38:2896=0)
;;				mov	dx,data_578				; (8A38:2898=0)
;;loc_372:							;  xref 8A38:667C
;;		sub	ax,1
;;		sbb	dx,0
;;		mov	bx,ax
;;		or	bx,dx
;;		jnz	loc_372					; Jump if not zero
;;		popa						; Restore all regs
  
    	xor	bx,bx					; Zero register
		mov	cx,10h

locloop_373:							;  xref 8A38:66C0
		shl	bx,1					; Shift w/zeros fill
		in	ax,dx					; port 0FFFAh ??I/O Non-standard
		test	ax,2
		jz	short loc_374				; Jump if zero
		or	bx,1
loc_374:							;  xref 8A38:668A
		mov	ax,1
		out	dx,ax					; port 0FFFAh ??I/O Non-standard

		call	Delay500ns

;;		pusha						; Save all regs
;;		mov	ax,data_577				; (8A38:2896=0)
;;				mov	dx,data_578				; (8A38:2898=0)
;;loc_375:							;  xref 8A38:66A5
;;		sub	ax,1
;;		sbb	dx,0
;;		mov	bx,ax
;;		or	bx,dx
;;		jnz	loc_375					; Jump if not zero
;;		popa						; Restore all regs

		xor	ax,ax					; Zero register
		out	dx,ax					; port 0FFFAh ??I/O Non-standard

		call	Delay500ns

;;		pusha						; Save all regs
;;		mov	ax,data_577				; (8A38:2896=0)
;;				mov	dx,data_578				; (8A38:2898=0)
;;loc_376:							;  xref 8A38:66BD
;;		sub	ax,1
;;		sbb	dx,0
;;		mov	bx,ax
;;		or	bx,dx
;;		jnz	loc_376					; Jump if not zero
;;		popa						; Restore all regs

		loop	locloop_373				; Loop if cx > 0

		mov	ax,1
		out	dx,ax					; port 0FFFAh ??I/O Non-standard

		call	Delay500ns

;;		pusha						; Save all regs
;;		mov	ax,data_577				; (8A38:2896=0)
;;				mov	dx,data_578				; (8A38:2898=0)
;;loc_377:							;  xref 8A38:66D8
;;		sub	ax,1
;;		sbb	dx,0
;;		mov	bx,ax
;;		or	bx,dx
;;		jnz	loc_377					; Jump if not zero
;;		popa						; Restore all regs

		xor	ax,ax					; Zero register

		out	dx,ax					; port 0FFFAh ??I/O Non-standard

		call	Delay500ns

;;		pusha						; Save all regs
;;		mov	ax,data_577				; (8A38:2896=0)
;;				mov	dx,data_578				; (8A38:2898=0)
;;loc_378:							;  xref 8A38:66F0
;;		sub	ax,1
;;		sbb	dx,0
;;		mov	bx,ax
;;		or	bx,dx
;;		jnz	loc_378					; Jump if not zero
;;		popa						; Restore all regs

		mov	DGroup:tempLoc,bx				; (8A38:64E8=0FFFFh)
		stc						; Set carry flag
loc_379:							;  xref 8A38:664B
		popa						; Restore all regs
        mov ax, DGroup:tempLoc
		retn

ReadMIIPhy	endp


;------ TestMIILink ---------------------------------------------------------;
;        
; Read the "link is up" bit, (this will reset it in case it was latched
; low due to a failure) and then read it again to see if the link is up.
;
;       Exit:
;       Carry set: success
;       Carry clear: failed
;----------------------------------------------------------------------------;

                public  TestMIILink
TestMIILink     proc    near

                pusha

                mov     dx, MII_PHY_STATUS
                call    ReadMIIPhy
                jnc     tml_exit
                
                call    ReadMIIPhy
                jnc     tml_exit
                test    ax, MII_STS_LINK_UP
                jz      tml_exit
                stc
tml_exit:
                popa
                ret

TestMIILink     endp


;------ CalibrateDelay ------------------------------------------------------;
;									     ;
;	This routine computes the number of loop iterations for 5 timer      ;
;	ticks.	From this ComputeDelay can then compute the number of loop   ;
;	iterations to delay a specified number of microseconds.  Note that   ;
;	the delay loop and the compute loop must use the same instructions.  ;
;									     ;
;	Note: since interrupts must be enabled during this operation in      ;
;	order to accumulate timer ticks, we minimize the possible overhead   ;
;	by masking off all other interrupts through the PIC temporarily.     ;
;									     ;
;	Entry:								     ;
;	DS	= DGROUP						     ;
;	cli								     ;
;									     ;
;	Exit:								     ;
;	cli (enables during processing) 				     ;
;									     ;
;	All registers preserved.					     ;
;									     ;
;----------------------------------------------------------------------------;

		public	CalibrateDelay
CalibrateDelay	proc	near

		pusha
		push	es
;
; mask off all but the timer interrupt through the PIC
;
		in	al, MASTER_MASK_PORT
		push	ax			; save original mask on stack
		jmp	$+2
		mov	al, NOT 1		; mask off all but timer
		out	MASTER_MASK_PORT, al
;
; enable interrupts... we need to take timer ticks in here
;
		sti
;
; set DI to the current count
;
; to limit our error watch the timer tick and wait until we see it change.
;
; under DOS we use the tick count in the BIOS data area.  under OS/2 we have
; access to a msec counter in the GlobalInfoSeg.
;
		mov	ax, 0
		mov	es, ax

		mov	di, es:[46ch]		;bios_ticks.loword
B1:		cmp	di, es:[46ch]		;bios_ticks.loword
		je	B1
		mov	di, es:[46ch]		;bios_ticks.loword
;
; set CX to zero.  this will be our outer loop count, the number of times we
; have run thru the calibration loop.
;
		xor	cx, cx
;
; now do 10000 iterations of our calibration loop.  we want a large enough count
; that the overhead of fetching the system time cause a significant error in
; our calculations.  on a 486DX2/66 this loop takes about 1ms so its unlikely
; to take too long on even the slowest computer we run on.
;
		public	cal_loop
cal_loop:
		inc	cx			; increment our outer loop count

		mov	ax, 10000		; DX:AX is our loop count
		xor	dx, dx

		align	16
B2:		sub	ax, 1
		sbb	dx, 0
		mov	bx, ax
		or	bx, dx
		jnz	B2
;
; if we wait for at least 5 ticks to go by our measurement error will be below
; 20% which is probably good enough
;
; check the system time to see if at least 5 ticks or 1/4 second have gone by.
; if not, run through the calibration loop again.
;
		mov	ax, es:[46ch]		;bios_ticks.loword
		sub	ax, di
		cmp	ax, 5
		jb	cal_loop
;
; compute iterations per 50ms.
;
; under DOS, 5 ticks at 18.20651 MHz = approx 275,000us. or 275ms.  so ticks
; per 50ms is:
;
;   cx * 10,000     cx * 10,000     cx * 20,000
;   -----------  =  -----------  =  -----------
;     275/50		5.5		11
;
; the result will likely exceed a single word in size, so we do long division.
; say the numerator is H:L, both letters being digits base 64k
;
;	Dh :  Dl
;    ------------
; 11 )	H  :  L
;	Rh :  L
;
		mov	ax, 20000
		mul	cx			; DX:AX = H:L

		mov	cx, 11

		mov	bx, ax			; save L

		mov	ax, dx
		xor	dx, dx			; 0:H

		div	cx			; 0:H / 11
		mov	Calibration.hiword, ax

		mov	ax, bx			; Rh:L

		div	cx			; Rh:L / 11
		mov	Calibration.loword, ax
;
; disable interrupts again
;
		cli
;
; enable interrupts through the PIC again
;
		pop	ax			; original PIC mask
		out	MASTER_MASK_PORT, al	; restore it

		pop	es
		popa
		ret

CalibrateDelay	endp


;------ ComputeDelay --------------------------------------------------------;
;									     ;
;	This routine computes a value to delay a specified number of	     ;
;	microseconds on this machine.  This count can then be passed to      ;
;	the DelayN routine to delay for that amount of time.		     ;
;									     ;
;	CalibateDelay has already been used to compute the number of	     ;
;	iterations of our delay loop in 50ms, so the calculations here are   ;
;	straight-forward.  See CalibrateDelay for details.		     ;
;									     ;
;	Entry:								     ;
;	CX	= number of microseconds to compute for 		     ;
;									     ;
;	Exit:								     ;
;	DX:AX	= loop count						     ;
;									     ;
;	Destroys BX, CX, SI, DI.  All other registers are preserved.	     ;
;									     ;
;----------------------------------------------------------------------------;

		public	ComputeDelay
ComputeDelay	proc	near
;
; Calibration contains the number of loop iterations for 50ms.	So the number
; of iterations for cx usec is:
;
;   Calibration * cx
;   ----------------
;	 50,000
;
; again the result may be three words in size after the multiply, so we do
; the multiplication and division long form as above.
;
		mov	ax, Calibration.loword
		mul	cx
		mov	si, ax			; SI=L
		mov	di, dx			; DI=M

		mov	ax, Calibration.hiword
		mul	cx
		add	ax, di			; AX=M
		adc	dx, 0			; DX=H, finished multiply

		mov	di, ax			; DI=M

		mov	ax, dx
		xor	dx, dx			; 0:H

		mov	bx, 50000		; 50ms=50000us
		div	bx			; assume Dh=0, ignore it

		mov	ax, di			; Rh:M

		div	bx			; Rh:M / usec
		mov	di, ax			; DI=Dm

		mov	ax, si			; Rm:L

		div	bx			; Rm:L / usec
		mov	dx, di			; DX:AX = Dm:Dl
;
; make sure its at least one
;
		mov	bx, ax
		or	bx, dx
		jnz	F1
		inc	ax
F1:
		ret
ComputeDelay	endp

public	Delay500ns
Delay500ns	proc	 near

		push	ax
		push	bx
		push	dx
		mov	ax, DelayOneUsec.loword
		mov	dx, DelayOneUsec.hiword
		shr	ax, 1			; divide 1 Usec in half
		shr	dx, 1
		jnc	F2
		or	ax, 8000h		; move low order bit of dx into ax
F2:
		or	ax, dx			;980429
		jnz	F3			;safety check in case of 0
		mov	ax, 1
F3:
		sub	ax, 1
		sbb	dx, 0
		mov	bx, ax
		or	bx, dx
		jnz	F3
		pop	dx
		pop	bx
		pop	ax
		ret

Delay500ns	endp


Delay200ms	proc	near

		push	cx
		mov	cx, Delay25ms
		call	WaitTime
		call	WaitTime
		call	WaitTime
		call	WaitTime
		call	WaitTime
		call	WaitTime
		call	WaitTime
		call	WaitTime
		pop	cx
		ret

Delay200ms	endp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\amd\nadamd.asm ===
page	,132
;************************************************************************
;* NADAMD.ASM
;*	- Contains modules supporting the NetPC UNDI API for Am79C970A
;*							PCnet-PCI II
;*
;* Modules included:-
;*	NADInit
;*	NADReset
;*	NADShutDown
;*	NADOpen
;*	NADClose
;*	NADSetFilter
;*	NADGetStatistics
;*	NADRequestINT
;*	NADMCastChange
;*	DriverISR_Proc
;*
;* Latest Update: 970514
;************************************************************************
.386


include 	undi_equ.inc
include 	pxe_stru.inc
include 	bwstruct.inc
include 	spdosegs.inc


_TEXT	Segment para public

	assume	cs:CGroup, ds:DGroup


public	NADInit
public	NADReset
public	NADShutDown
public	NADOpen
public	NADClose
public	NADSetFilter
public	NADGetStatistics
public  NADInitiateDiags
public  NADSetMACAddress

ifdef HARD_INT
    public	NADRequestINT
endif

public	NADMCastChange
public	DriverISR_Proc

public   OrgIntVector_OFF
public   OrgIntVector_SEG


extrn	GetED:near
extrn	PostED:near
extrn	Net_Address:byte
extrn	Node_Address:byte
extrn	UNDI_DriverISR:far
extrn	IOBase:word
extrn	IRQNumber:byte
;extern GenIntCallBack:dword
;extern RxCallback:dword
extrn EDListHead:word
extrn EDListTail:word




;extern IntReqPending:byte

;;extrn Puts:near


;public  RxEDs

;NAD return codes from BWEQU.INC

SUCCESSFUL		EQU	0000h
REQUEST_QUEUED		EQU	0002h
OUT_OF_RESOURCE 	EQU	0006h
INVALID_PARAMETER	EQU	0007h
INVALID_FUNCTION	EQU	0008h
NOT_SUPPORTED		EQU	0009h
HARDWARE_ERROR		EQU	000ah
TRANSMIT_ERROR		EQU	000bh
NO_SUCH_DESTINATION	EQU	000ch
HARDWARE_NOT_FOUND	EQU	0023h
HARDWARE_FAILURE	EQU	0024h
CONFIGURATION_FAILURE	EQU	0025h
INTERRUPT_CONFLICT	EQU	0026h
INITIALIZATION_FAILED	EQU	0028h
RECEIVE_TIMEOUT 	EQU	0080h		; Rx2 in NetWare
GENERAL_FAILURE 	EQU	00ffh


;
; offsets in PCI configuration space
;
PCIC_INTERRUPTLINE	equ	003Ch
PCIC_BIOSROMCONTROL	equ	0030h
PCIC_IOBASE		    equ	0010h
PCIC_LATENCYTIMER	equ	000Dh
PCIC_STATUS		    equ	0006h
PCIC_COMMAND		equ	0004h
PCIC_DEVICEID		equ	0002h
PCIC_VENDORID		equ	0000h
;
; bits in PciCommand
;
PCIC_IOENABLE		equ	00001h
PCIC_BMENABLE		equ	00004h

; PCI BIOS function code

PCI_FUNCTION_ID 	equ	0b1h
PCI_BIOS_PRESENT	equ	001h
FIND_PCI_DEVICE 	equ	002h
READ_CONFIG_BYTE	equ	008h
READ_CONFIG_WORD	equ	009h
READ_CONFIG_DWORD	equ	00ah
WRITE_CONFIG_BYTE	equ	0bh
WRITE_CONFIG_WORD	equ	0Ch
WRITE_CONFIG_DWORD	equ	0Dh

; PCI BIOS function return code

PCI_CALL_SUCCESSFUL	    equ	00h
PCI_DEVICE_NOT_FOUND	equ	86h
PCI_BAD_VENDOR_ID	    equ	83h

VENDOR_IDx	equ 1022h	     ;4 ; Vendor ID for AMD
DEVICE_ID	equ 2000h	     ;6 ; Device ID for PCnet-PCI II

include AT1500.EQU			; AMD-specific equates

; Time constants used in delays and timeouts
TIME50MS	equ	1		; 1 clock tick is 50ms
TIME100MS	equ	2		; 2 clock tick is 100ms
TIME900MS	equ	50		; 2 clock tick is 100ms

EOI		equ	20h

LF	equ	0Ah
CR	equ	0Dh


MTU	    	equ	1514	;max size for a completed Ethernet packet
NUM_ED		equ	5	;number of EDs





;=========================================================================
; NADInit
;=========
;	- Initializes the adapter but does not enable the Tx and Rx units
;	- Hook receiving ISR
;
; Parameters:	DS = CGroup
;
; Returns:	If CF = 0 then success, else fail
;=========================================================================

NADInit 	proc	near

;;db  0f1h        

		cld
		push	ds
		push	es

        mov     ax, ds
        mov     es, ax
;        push    ds
;        pop     es


;int 03        

		call	FindAT2450	; returns DX = IOBase, AL = irq
		or	    dx, dx
		jz	    NADInitErr	; adapter not found

		mov	    DGroup:[IOBase], dx	; UNDI_NAD variable
		mov	    DGroup:[IntNum], al
		mov	    DGroup:[IRQNumber], al ; UNDI_NAD variable

		call	InitHardware



;;   	mov	ax, DGroup:CSR15Broad

;;	    and	ax, 0bfffh		; clear bit 14
;;  	mov	DGroup:CSR15Broad, ax



;**** Dmitry ***

        mov     bl, 58      ; set software style - 16 bit
        mov     ax, 0
        call    csrOut

;*****

		mov	    si, offset DGroup:Net_Address
		mov	    di, offset DGroup:Node_Address
		movsw
		movsw
		movsw

;;    	lea	bp, DGroup:LanOption
;;    	call	puts

        mov     ax, ds
        mov     DGroup:StoreDS, ax

        call    NADCheckCable

        jnc     NADInitExit
        call    NADDisengage
        mov     ax, 2

;		clc
;		jmp	short NADInitExit

NADInitErr:
		stc
NADInitExit:

;db  0f1h
		pop	es
		pop	ds
		ret

NADInit 	endp

;-----------------------------------------------------------------------------
; FindAT2450
;
; Return	dx = 0		not found
;		     IOBase	found
;		al = IRQLevel
;-----------------------------------------------------------------------------

FindAT2450	proc	near

	call	PCISearch
	jc	no_pci

;   Set Bus Master Enable ( some BIOSes disable that ):

	mov	bx, DGroup:[PCIBusDevFunc]
	mov	ah, PCI_FUNCTION_ID	; 0B1h
	mov	al, READ_CONFIG_WORD	; read word from config space (04h)
	mov	di, 04h 		; offset in config space for COMMAND
	INT	1AH
	jc	no_pci			; Brif PCI error.

; *** Dmitry ***

	mov	bx, DGroup:[PCIBusDevFunc]
	or	cx, 04h 		; set Bus Master Enable
	mov	ah, PCI_FUNCTION_ID	; 0B1h
	mov	al, WRITE_CONFIG_WORD	; write word back to config space (04h)
	mov	di, 04h 		; offset in config space for COMMAND
	INT	1AH
	jc	no_pci	      ; Brif PCI error.

; ***

; PCI device has been found, read IO address from config space

	mov	bx, DGroup:[PCIBusDevFunc]
	mov	ax, PCI_FUNCTION_ID shl 8 + READ_CONFIG_WORD
	mov	di, PCIC_IOBASE
	int	1ah
	jc	no_pci

	and	cx, 0FFE0h			 ; drop last 5 bits
	mov	dx, cx

	mov    ax, PCI_FUNCTION_ID shl 8 + READ_CONFIG_BYTE
	mov    bx, DGroup:[PCIBusDevFunc]
	mov    di, PCIC_INTERRUPTLINE
	int    1ah
	mov    al, cl
	ret

no_pci:
	xor	dx, dx
	ret

FindAT2450	endp

;------ PCISearch -----------------------------------------------------------;
;									     ;
;	Attempt to find a match against a PCI adapter.	The caller can	     ;
;	specify the exact busno/slot to check or leave either unspecified    ;
;	in which case a search will be performed among the allowed	     ;
;	busno/slot combinations for a match.				     ;
;									     ;
;	Entry:								     ;
;	cli								     ;
;	Slot  = slot number to search, -1 if not specified		     ;
;	BusNo = bus number to search, -1 if not specified		     ;
;									     ;
;	Exit:								     ;
;	cli								     ;
;	carry = set if no match 					     ;
;	      = clear if a match					     ;
;	BusNo = set for the matching adapter if carry clear		     ;
;	Slot  = set for the matching adapter if carry clear		     ;
;	PCIBusDevFunc = set for the matching adapter if carry clear	     ;
;									     ;
;	All registers are preserved.					     ;
;									     ;
;----------------------------------------------------------------------------;

	public	PCISearch

PCISearch	proc	near

	push	ax
	push	bx
	push	cx
	push	di

	mov	cx, DEVICE_ID
	mov	dx, VENDOR_IDx
	mov	si, 0			; PCI device number (0 for first)
	mov	ah, PCI_FUNCTION_ID	; 0B1h
	mov	al, FIND_PCI_DEVICE	; 02h
	INT	1AH
	jc	PCIS_No        ; Brif PCI error.

	;Device was found - Return Handler in BX.
	;---------------------------------
	mov	word ptr DGroup:[PCIBusDevFunc], bx

;
; Read the PciCommand register to see if the adapter has been activated.  if
; not, pretend we didn't find it
;
	mov	ah, 0B1h		; PCI BIOS Function
	mov	al, 009h		; PCI Read Config Word
	mov	bx, DGroup:[PCIBusDevFunc]
	mov	di, PCIC_COMMAND
	int	1Ah
	jc	PCIS_No

	test	ah, ah
	jnz	PCIS_No


	test	cx, PCIC_IOENABLE	; I/O access enabled?
	jz	PCIS_No

	clc
;
; exit with carry flag as set
;
	public	pcis_exit
pcis_exit:
;	popa

	pop	di
	pop	cx
	pop	bx
	pop	ax

	ret

;
; no PCI support or adapter not found or failure after found
;
	public	PCIS_No
PCIS_No:
	stc
	jmp	pcis_exit

PCISearch	endp

public StopAdapter

StopAdapter    proc    near

	mov	dx, DGroup:[IOBase]
	add	dx, REGRAP
	mov	ax, CSR0
	cli				; 970515 - to ensure no interrupts
	out	dx, ax			; Specify CSR0
	jmp	$+2
	in	ax, dx

	sub	dx, 2			; -2 to get RegRDP

	; 940315 Before issuing CSR0_STOP, issue CSR0_STRT to
	; get adapter out of STOP mode ( happens sometimes ).

; ** Dmitry **

;;	mov	ax, CSR0_STRT
;;	out	dx, ax

;;	jmp	$+2
;;	jmp	$+2

; **
	; 940315 }

	mov	ax, CSR0_STOP		; Reset card
	out	dx,ax
	jmp	$+2
	in	ax,dx
	sti				; 970515 - allow interrupts again

	mov	ax, TIME100MS
	call	StartTime

GetMemReset:
	in	ax,dx
	cmp	ax, CSR0_STOP
	jz	GetMemResetOK	; Jump if reset is Okay (CY clear)

	call	CheckTime
	jnc	GetMemReset	; check status again if not timeout

GetMemErr:
	stc			; CY set to indicate reset timeout

GetMemResetOK:
	ret

StopAdapter	endp



InitHardware	proc	near

; Stop card before doing anything

;    int 03
    push    ds
	call	StopAdapter

; Enable  receiver:

    mov     bl, 15
    call    CSRIn
    and     ax, not 1h
    mov     bl, 15
    call    CSROut

; Enable transmit poll:

    mov     bl, CSR4
    call    CSRIn
    and     ax, not 1000h
    mov     bl, CSR4
    call    CSROut



	cld			; clear direction flag
	mov	    DGroup:[InterruptFlag],0 ; initialize variable

	; Save the original PIC interrupt vector
	call	SetupInt	; Setup interrupt variables

;db  0f1h
    in  ax, 60h         ;

;*** do we need this????
;	; Set the DMA interrupt controller into cascade mode
;	call	EnableDMACascade

	; Fetch the network address
	call	SetCardAddr
	xor ax, ax

	pop	ds
	ret				; return to caller

InitHardware	endp

;=========================================================================
; NADReset
;==========
;	- Reset and Reinitialize the adapter
;	- Enables the Tx and Rx units
;
; Parameters:	DS = DataSeg
;
; Returns:
;=========================================================================
NADReset	proc	near

;int 03        
;db  0f1h

	push	es
	push	di		; save ES:DI since UNDI_NAD doesn't!!!
	call	StopAdapter
    clc
	pop	di
	pop	es
	ret

NADReset	endp

;=========================================================================
; NADShutDown
;=============
;	- reset the adapter and enables
;	- unhook our ISR
;
; Parameters:
;
; Returns:
;=========================================================================

NADShutDown	proc	near

;;db  0f1h
;int 03
;	push	cs		; NADDisengage does a retf

	call	NADDisengage	; stop adapter, unhook ISR

IFDEF Gateway

; Disable receiver:

;db  0f1h

    mov     bl, 15
    call    CSRIn
    or      ax, 1h
    mov     bl, 15
    call    CSROut

; Disable transmit poll:

    mov     bl, CSR4
    call    CSRIn
    or      ax, 1000h
    mov     bl, CSR4
    call    CSROut

	mov	    ax,( CSR0_STRT )
	mov	    bl, CSR0
	call	CSROut

ENDIF

;;	mov	dx, [IOBase]
;;	add	dx, REGRESET
;;	in	ax, dx		; start an S_RESET (takes 1us).

;db  0f1h
    clc

	ret

NADShutDown	endp


;=========================================================================
; NADOpen
;=========
;	- Enables the Tx and Rx units
;
; Parameters:	DS = CGroup
;
; Returns:
;=========================================================================
NADOpen 	proc	near

;db  0f1h

;int 03        

; not sure whether we have to do anything here, since NADTransmit does a
; reset of the adapter and re-inits everytime.

        clc
    	ret

NADOpen 	endp


;=========================================================================
; NADClose
;==========
;	- Disables the Tx and Rx units
;
; Parameters:	DS = CGroup
;
; Returns:
;=========================================================================
NADClose	proc	near

;int 03        

	push	es
	push	di		; save ES:DI since UNDI_NAD doesn't!!!
	call	StopAdapter
    clc
	pop	di
	pop	es
	ret

NADClose	endp



NADInitiateDiags    proc    near
    stc
    ret
NADInitiateDiags    endp



NADSetMACAddress    proc    near
;;    stc
    clc
    ret
NADSetMACAddress    endp




;=========================================================================
; DriverISR_Proc
;================
;	- ISR procedure to be called by UNDI_DriverISR
;
; Parameters:	DS = CGroup
;
; Returns:	CF = a if not our int
;=========================================================================
DriverISR_Proc	proc	near

;
; check whether our board caused the interrupt
;
;int 03        


		mov	bl, CSR0
		call	CSRIn		; AX.b7 = INTR, int flag
		test	al, CSR0_INTR	; Interrupt Flag set?
		jnz	isr_ours

		stc
		ret

isr_ours:
		pushf
		call	BootISR 	; (BWAMD.INC)

; ********************************
        cli
        sub     DGroup:ReceiveError, 1  ; detect CY flag
        cmc                             ; toggle it
        mov     DGroup:ReceiveError, 0
        sti
; ********************************
;;;;            clc

;;;        jnc     @F
;;;db  0f1h
;;		clc
;;;@@:
		ret

DriverISR_Proc	endp

;=========================================================================
; NADSetFilter
;==============
;	- Change the rx unit's filter to a new one
;
; Parameters:	AX = filter value, 1 = directed/multicast
;				   2 = broadcast
;				   4 = promiscuous
;		DS = CGroup
;
; Returns:
;=========================================================================
NADSetFilter	proc	near

; use NADChangeReceiveMask to do all of the dirty work -- 1 bit at a time,
; since NADChangeReceiveMask does not accept OR'd mask settings

;int 03
	push	ax			; save for later
	mov	bl, 00000100b		; multicast setting - assume off
	test	al, 1			; directed/multicast?
	jz	SetFilterMulticast

	or	bl, 1			; multicast on

SetFilterMulticast:
	call	NADChangeReceiveMask

	pop	ax
	push	ax
	mov	bl, 00000010b		; broadcast setting - assume off
	test	al, 2			; broadcast?
	jz	SetFilterBroadcast

	or	bl, 1			; broadcast on

SetFilterBroadcast:
	call	NADChangeReceiveMask

	pop	ax
	mov	bl, 00010000b		; promiscuous setting - assume off
	test	al, 4			; promiscuous?
	jz	SetFilterPromiscuous

	or	bl, 1			; promiscuous on

SetFilterPromiscuous:
	call	NADChangeReceiveMask
    clc
	ret

NADSetFilter	endp


;=========================================================================
; NADGetStatistics
;==================
;	- Read the adapter's statistics
;
; Parameters:	ds:si points to variables to hold the result
;			TxGoodFrames	dd	0	;1
;			RxGoodFrames	dd	0	;2
;			RxCRCErrors	dd	0	;3
;			RxDiscarded	dd	0	;3
;
; Returns:
;=========================================================================
NADGetStatistics	proc	 near

;int 03        

		push	dx
; more code here

		pop	dx
;;        stc
        clc
		ret

NADGetStatistics	endp


ifdef HARD_INT


;=========================================================================
; NADRequestINT
;================
;	- Generate an interrupt to the host
;
; Parameters:
;
; Returns:
;=========================================================================
NADRequestINT	proc	near


;	 int 03

;;		mov	bl, CSR3
;;	xor ax,ax
;;		call	CSROut
;;	sti
;;		ret

;	 sti
;	 int 03


;;	db  0F1h


        mov bl, CSR0
        call    CSRIn
        or  ax, 40h
;        mov ax, 44h
        call    CSROUT
		mov	    bl, CSR4
		call	CSRIn		; read CSR4
		and	    ax, 4D15h   ; set b7, UINTCMD to generate user int
		or      ax, 4080h
		sti
		call	CSROut
;		sti
		ret



NADRequestINT	endp


endif


;==========================================================================
; NADMCastChange
;================
;	- Modify the multicast buffer to receive the multicast addresses
;	  listed in the multicast table.
;	  Each entry in the multicast table is as follows:
;		  Bytes 0-5 = Multicast Address
;	  All addresses are contiguous entries
;
; Parameters:	CX =  Number of multicast entries.
;		ES:SI -> Multicast Table.
;		AX = 1 means save the list
;		AX = 0 means use the saved list
;
; Return:	All registers may be destroyed.
;==========================================================================

NADMcastChange	proc	near

;;	call	StopReceiveUnit
	push	es			; save ES

;; add code here to deal with AX=0 case (used saved list)

;- clear the existing multicast table (and LADRF??)

	push	ds
	pop	es			; ES = DS
	mov	di, offset DGroup:MCastTable
	xor	ax, ax
	stosw
	stosw
	stosw

	mov	di, offset DGroup:LADRF
	stosw
	stosw
	stosw
	stosw

	pop	es			; restore ES
	mov	di, si			; ES:DI now points to mcast addrlist
	cmp	cx, MAXNUM_MCADDR
	jbe	MCsave

	mov	cx, MAXNUM_MCADDR

MCsave:
	jcxz	Set_MCastDone		; could be zero -- just exit

Set_McastTable_Loop:
	push	cx			; save mcastaddr count
	call	Set_Multicast_List	; return ES:DI ptr to next address
	pop	cx
	add	bx, offset DGroup:LADRF
	or	byte ptr [bx], al
	loop	Set_MCastTable_Loop




; Fill the LADRF AMD registers (CSR8-CSR11 ):

;int	03
;    push    cx

;    mov cx, 4
;    mov bl, 8
;    mov si, offset LADRF
;setLADRF:
;    lodsw
;    call CSROUT
;    inc  bl
;    loop setLADRF

;    pop cx

Set_MCastDone:
;;  call    StartReceiveUnit
	ret

NADMcastChange	endp

; ***** routines pasted directly from AT1500.ASM
;
;
;	void CSROut(reg, val) - put value to CSR register.
;
; Input 	bl	CSR reg number ( CSR0, CSR1 ... )
;		ax	Value to write to
;
; Output	ax	Value read from port after data is written
;
; Outputs value val to lance CSR reg (0-3 for AM7790, 0-127 for AM79c960)
; given by reg.
;
CSROut	proc	near
	push	dx

	push	ax
	mov	dx, DGroup:[IOBase]
	add	dx, REGRAP	;offset to RAP register
	mov	al, bl		;load CSR number (ie CSR0, CSR1...)
	xor	ah, ah		;clear upper byte of word to put
	out	dx, ax		;selec CSR reg

	add	dx, -2		;point to RDP
	pop	ax		;get value to stuff
	out	dx, ax		;send to selected CSR reg.

	call	Delay_750

	in	ax, dx
	pop	dx
	ret
CSROut	endp

;
;
;	CSRIn(reg) - read value from CSR register
;
; Input 	bl	CSR reg number
;
; Output	AX	value of CSR register
;
; Outputs value val to lance CSR reg (0-3 for AM7790, 0-127 for AM79c960)
; given by reg.
;
;
CSRIn	 proc	 near
	push	dx

	mov	dx, DGroup:[IOBase]
	add	dx, REGRAP	;point to RAP register
	mov	al, bl		;get isacr reg to address
	xor	ah, ah		;clear high byte
	out	dx, ax		;select CSR reg

	add	dx, -2		;point to RDP
	in	ax, dx		;read value to return

	pop	dx
	ret
CSRIn	 endp



BCROut	proc	near
	push	dx

	push	ax
	mov	dx, DGroup:IOBase
	add	dx, RegRAP	;offset to RAP register
	mov	al, bl		;load BCR number (ie BCR0, BCR1...)
	xor	ah, ah		;clear upper byte of word to put
	out	dx, ax		;select BCR reg

	add	dx, 4		;point to BDP
	pop	ax		    ;get value to stuff
	out	dx, ax		;send to selected BCR reg.

	call	Delay_750

	in	ax, dx
	pop	dx
	ret
BCROut	endp

;
;
;	BCRIn(reg) - read value from BCR register
;
; Input 	bl	BCR reg number
;
; Output	AX	value of BCR register
;
; Outputs value val to lance BCR reg (0-3 for AM7790, 0-127 for AM79c960)
; given by reg.
;
;

BCRIn	 proc	 near
	push	dx

	mov	dx, DGroup:IOBase
	add	dx, RegRAP	;point to RAP register
	mov	al, bl		;get isacr reg to address
	xor	ah, ah		;clear high byte
	out	dx, ax		;select BCR reg

	add	dx, 4		;point to BDP
	in	ax, dx		;read value to return

	pop	dx
	ret
BCRIn	 endp



;public  NADCheckCable 


NADCheckCable   proc    near

; first check Internal PHY :
        mov     bl, 4
        call    BCRIn
        and     ax, 7fffh
        push    ax
        mov     ax, 40h
        call    BCROut
        call    BCRIn
        mov     cx, ax
        pop     ax
        call    BCROut
        test    cx, 8000h
        jnz     Media_ok

; then externalPhy:

        mov     bl, 32
        call    BCRIn
        test    ax, 4000h
        jnz     extPhy
        inc     bl
        mov     ax, 2h
        call    BCROut
        inc     bl
        call    BCRIn
        or      ax, ax
        jz      media_fail
        cmp     ax, 0ffffh
        je      media_fail
extPhy:
        inc     bl
        mov     ax, 21h
        call    BCROut
        inc     bl
        call    BCRIn
        test    ax, 4
        jnz     Media_ok

media_fail:
		stc
		ret

Media_ok:
		clc
		ret

NADCheckCable   endp


;------------------------------------------------------------------------------
;	SendInitBlock
;	Function : Assemble and send the initialization block to the adapter
;		   The initialization block contains operating parameters
;		   necessary for operations
;		   It will also wait for the adapter to acknowledge the
;		   initialization and check for errors
;	in	:  di pointer to receive ring pointer
;		   si pointer to transmit ring pointer
;		   BusInterface contains value to be stored in CSR3
;		   CSR0Cmd contains command to be sent to CSR0
;		   InitBlock.Mode is set to reflect desired operating parameters
;	 Out	:  zf=1 no error	zf=0 error
;
;	Assumption :	The mode register is set already
;------------------------------------------------------------------------------
public		SendInitBlock
SendInitBlock	proc	near
		pusha

		push	si
		push	di
		; Place the node address into PADR ( physical address )
;;        push    ds
;;        pop     es
        mov     ax, ds
        mov     es, ax
		mov	di, offset DGroup:InitialBlock.InitNodeAdd
		mov	si, offset DGroup:Net_Address
		mov	cx,6
		rep	movsb

		; The logical address filter will just be zeros
		; Try to use filter to filter out broadcast

    	mov si, offset DGroup:LADRF
;	    mov si, LADRFPtr
;	    mov al, 0ffh
		mov	di, offset DGroup:InitialBlock.InitAddrFilter
		mov	cx,8
;		rep stosb
		rep	movsb

		; Setup the receive descriptor ring pointer
		mov	ax,NumRxBuf
		pop	di
		mov	dx,di
		call	SetupRing
		mov	di, offset DGroup:InitialBlock.InitRdrp

		mov	ds:[di],dx
		add	di,2
		mov	ds:[di],ax

		; Setup the transmit descriptor ring pointer
		mov	ax, NumTxBuf
		pop	si
		mov	dx,si
		call	SetupRing
		mov	di, offset DGroup:InitialBlock.InitTdrp

		mov	ds:[di],dx
		add	di,2
		mov	ds:[di],ax

		; Finish setting up the initialization block
		; Start setting up the CSR blocks
		mov	ax, DGroup:[BusInterface]
		mov	bl, CSR3
		call	CSROut



IFDEF		GILBUG
		; Check if the STOP bit is set (it will disable all activities)
		; Print Tx3 if bit is set
		; Only in GILBUG mode (the bit is checked again later )
		push	ax
		push	dx

		mov	ax, CSR0
		mov	dx, DGroup:[IOBase]
		add	dx, REGRAP
		out	dx,ax		; Specify CSR0

		mov	dx, DGroup:[IOBase]
		add	dx, REGRDP
		in	ax, dx
		cmp	ax, CSR0_STOP
		pop	dx
		pop	ax
		jz	NetSendTest1

		mov	ax, 0e0dh	 ;
		int	010h
		mov	ax, 0e0ah
		int	010h		; skip one line
		mov	ax,0e4ch	; print "L"
		int	010h

		mov	al,3		; Print Tx3 to indicate mysterious reset
		add	al,'0'

NetSendTest1:

ENDIF
		; Place address of initialization block in CSR1 and CSR2
		mov	dx, offset DGroup:InitialBlock

		xor	ax,ax		;
		call	SetupRing

		mov	bl, CSR2
		call	CSROut

		mov	ax, dx
		and	ax, 0FFFEh		; bit 0 has to be zero
		mov	bl, CSR1
		call	CSROut

		; Check if the STOP bit is set (it will disable all activities)
		; Print Tx3 if bit is set
		mov	bl, CSR0
		call	CSRIn

		cmp	ax,CSR0_STOP
		jz	SendInitStop

;		mov	di, offset CGroup:ErrReset
;		mov	cs:StatusMsgFlag, di

		mov	ax,1
		or	ax,ax		; clear zf to indicate error
		jmp	SentInitEnd

SendInitStop:
		mov	ax, DGroup:[CSR0Cmd]
		mov	bl, CSR0
		call	CSROut

		mov	ax, 18	; 1 second
		call	StartTime

SendInitPoll:	mov	ax, DGroup:[InterruptFlag]
		test	ax, INTINITERR
		jnz	SendInitErr

		test	ax, INTINIT
		jnz	SendInitOK

		call	CheckTime	; timeout is 100ms
		jnc	SendInitPoll

		jmp	SendInitErr

SendInitOK:

IFDEF		DEBUG
		int	3
ENDIF


SendInit2450:
		mov	bx, DGroup:[ValISACR2]

		mov	di, DGroup:[IOBase]
		mov	ax, 2
		call	reg_read

		; if bit 1 (ASEL) is already set, just exit
		test	ax, 2
		jnz	SentInitISACR

		and	ax, 0FFFEh		; always clear XMAUSEL

		or	ax, 2			; set ASEL for AutoSelect

;951109 Just force the board to use AutoSelect. Ignore setting (951109)

;951109 	cmp	bh, 0			; Test for autoselect
;951109 	jne	SendInitWrite
;951109
;951109 	and	ax, 0fffdh
;951109SendInitWrite:

		mov	bx, ax
		mov	ax, 2
		call	reg_write

		; Delay for AutoSelect to stablize???
		mov	ax, 5
		call	StartTime

SentInitDelay:
		call	CheckTime
		jnc	SentInitDelay


SentInitISACR:
		xor	ax,ax		; set zero flag to indicate no error

SentInitEnd:	popa
		ret

SendInitErr:
;		mov	di, offset CGroup:ErrInit
;		mov	cs:StatusMsgFlag, di

		mov	ax,1
		or	ax,ax		; clear zf to indicate error
		jmp	SentInitEnd

SendInitBlock	endp

; ***** routines pasted directly from EEP15.INC

Delay_750	proc	near
	push	cx
	mov	cx, 8

DELAY_750_Lp:
	loop	DELAY_750_Lp

	pop	cx
	ret
Delay_750	endp

include EEP24.INC

UNDI	equ	1			; needed to conditionalize BWAMD.INC


include BWAMD.INC


_TEXT	ends




_DATA	segment	para public

; Data variables

LanOption   db  'LAN option: AMD PCnet - PCI II/PCnet - FAST Ethernet Adapter', CR, LF, 0

PCIBusDevFunc	dw	?
IntNum		db	?
ISRErrFlag	db	FALSE		; flag indicating if error condition is
TxRetryCnt	dw	1		; Number of times to retry transmit
StoreDS     dw  0

_DATA	ends





	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\smc9432\bwstruct.inc ===
;====================================================================
; BWSTRUCT.INC
;
; Include for for BootWare, defines common structures.
;
; 970116 PC - first version
;====================================================================

;--------------------------------------------------------------------
; Common equates
;---------------------------------------------------------------------
FEATURE_LOCAL	equ	1
FEATURE_VIRUS	equ	2
FEATURE_MENU	equ	4
FEATURE_KEYWAIT	equ	8
FEATURE_FLOPPY	equ	64
FEATURE_HDRIVE	equ	128

;--------------------------------------------------------------------
; Event Descriptor (ED) Structure
;---------------------------------------------------------------------
IFDEF _IDEAL_
Struc	ED
	Ptr		dw	?	; pointer to next ED
	Unused		dw	?	; spare word
	DestAddr	dw	?, ?, ?	; destination Address
	ErrCode		dw	?	; error code
	ErrMsg		dw	?	; pointer to error msg
	Length		dw	?	; total packet length
	FragCount	dw	?	; number of fragments
	FragOff		dw	?	; 1st fragment offset
	FragSeg		dw	?	; 1st fragment segment
	FragLen 	dw	?	; length of fragment
ends
ELSE
ED_Struct      STRUC
	ED_Ptr		dw	?	; pointer to next ED
	ED_Unused	dw	?	; spare word
	ED_DestAddr	dw	?, ?, ?	; destination address
	ED_ErrCode	dw	?       ; error code
	ED_ErrMsg	dw	?       ; Pointer to error msg
	ED_Length	dw	?	; total packet length
	ED_FragCount	dw	?	; Number of descriptors/fragments
	ED_FragOff	dw	?	; Descriptor Pointer
	ED_FragSeg	dw	?	; Descriptor Pointer
	ED_FragLen 	dw	?	; Length of packet descriptor
ED_Struct      ENDS
ENDIF

;--------------------------------------------------------------------
; Descricptor Structure
;---------------------------------------------------------------------
IFDEF _IDEAL_
Struc Frag
	Off		dw	?	; offset of fragment
	Seg		dw	?	; segment of fragment
	Len		dw	?	; length of fragment
ends
ELSE
Frag Struc
	FragOff		dw	?	; offset of fragment
	FragSeg		dw	?	; segment of fragment
	FragLen		dw	?	; length of fragment
Frag ends
Descript_Struct STRUC
	DPointer	dd	?	; Descriptor Pointer
	DLen		dw	?	; Length of packet descriptor
Descript_Struct ends
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\amd\moreseg.inc ===
;----------------------------------------------------------------------
;
; File Name:	   DRVSEG.INC
;
; Function:	   This module contains all the segment definitions
;		   to be used throughout the source code.
;
; History:
;
; 910201 0.0 GK	adapted from MSRPL Kit
;----------------------------------------------------------------------
include		drvseg.inc

CGroup		group	_TEXT, PacketBufferSeg
DGroup		equ	<CGroup>

		assume	cs:CGroup,ds:DGroup,es:DGroup,SS:DGroup


;----------------------------------------------------------------------
;			 segment ORDER DECLARATIONS
;
; Description: This section declares all the segments in their proper
;	       order.  After these declarations, all code and data
;	       segments may use the generic segment macros defined in
;	       the next section to delimit themselves.
;
;	       The segment order will be different based on whether
;	       this is a DOS driver or not.  If it is, then the dis-
;	       cardable segments go last.  If it isn't, then we will
;	       split up the code and data parts.
;
;	       The segments that are defined for this driver are:
;	     - DATA:	 contains all the permanent data.
;	     - CODE:	 contains all the permanent code.
;----------------------------------------------------------------------

;Code		segment word public 'CODE'
;Code		ends

PacketBufferSeg    segment para public 'BUF'
PacketBufferSeg    ends

;start_code	macro
;Code		segment
;		assume cs:CGroup,DS:DGroup,es:DGroup,ss:DGroup
;		endm
;
;end_code	macro
;Code		ends
;		endm

start_buffer	macro
PacketBufferSeg segment align
		endm

end_buffer	macro
PacketBufferSeg ends
		endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\amd\portable.inc ===
;
; Modifications:   $Header:   J:/archives/preboot/lsa2/inc/portable.INV   1.2   19 Sep 1997 21:39:10   MJOHNSOX  $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;

;
;   Description: MACROS which drive the way portable code is built
;

IFDEF              PORTABLE_INC
ELSE
PORTABLE_INC       equ    1

;--------------------------------------------------------------------------
; This file requires the inclusion of "equates.inc" before it is included.
;--------------------------------------------------------------------------
; This file must follow the definition (via inclusion or in-line) of one of
; the following configuration assemble-time switches.  The following IFNDEF
; statements take care of two situations:
;   1) the user of this file only needs to define the model it using as TRUE,
;      all other models will not be defined and will therefore be set FALSE,
;      which means all references to the model will use IF (not IFDEF or IFE).
;   2) a user who does not define any model will find that nothing is defined,
;      since all of the IFNDEF's will assemble.  A model must be selected.
;--------------------------------------------------------------------------

IFDEF DOSNDIS
ELSE
DOSNDIS              equ         FALSE
ENDIF

IFDEF OS2NDIS
ELSE
OS2NDIS              equ         FALSE
ENDIF

IFDEF NWSERVER
ELSE
NWSERVER             equ         FALSE
ENDIF

IFDEF DOSODI
ELSE
DOSODI               equ         FALSE
ENDIF

IFDEF OS2ODI
ELSE
OS2ODI               equ         FALSE
ENDIF

;--------------------------------------------------------------------------
; @CPUSH
;
; Description : Each driver inserts code that pushes the registers that must 
;               not be changed by a function called from C.
;
; Entry       : none
;
; Exit        : none
;
;--------------------------------------------------------------------------
@CPUSH macro  name
IF DOSODI
 IFDEF XMIT_NO_COPY_DMA
    push    ebp            
    push    ebx
    push    esi
    push    edi
 ELSE
    push    bp
    push    bx
    push    di
    push    si
 ENDIF
ENDIF
IF OS2ODI
    push    ebp            
    push    ebx
    push    edi
    push    esi
ENDIF
IF DOSNDIS
    push    bp
    push    bx
    push    di
    push    si
ENDIF
IF OS2NDIS
    push    ebp
    push    ebx
    push    edi
    push    esi
ENDIF
IF NWSERVER
    CPush
ENDIF
    ENDM

;--------------------------------------------------------------------------
; @CPOP
;
; Description : Each driver inserts code that pops the registers that must 
;               not be changed by a function called from C.  
;
; Entry       : none
;
; Exit        : none
;
;--------------------------------------------------------------------------
@CPOP macro  name
IF DOSODI
 IFDEF XMIT_NO_COPY_DMA
    pop     edi            
    pop     esi
    pop     ebx
    pop     ebp
 ELSE
    pop     si
    pop     di
    pop     bx
    pop     bp
 ENDIF
ENDIF
IF OS2ODI
    pop     esi
    pop     edi            
    pop     ebx
    pop     ebp
ENDIF
IF DOSNDIS
    pop     si
    pop     di
    pop     bx
    pop     bp
ENDIF
IF OS2NDIS
    pop     esi
    pop     edi            
    pop     ebx
    pop     ebp
ENDIF
IF NWSERVER
    CPop
ENDIF
    ENDM

;--------------------------------------------------------------------------
; @PUSH_MUSTSAVE
;
; Description : Each driver inserts code that pushes the registers that must 
;               NEVER be changed by a function, others may be saved at times.
;               PUSH_MUSTSAVE contents must correlate to POP_MUSTSAVE.
;               PUSH_MUSTSAVE can't be written to allow POP_SAVE to save flags.
;
; Entry       : none
;
; Exit        : none
;
;--------------------------------------------------------------------------
@PUSH_MUSTSAVE macro  name
IF DOSODI
    push    bx
ENDIF
IF OS2ODI
    push    ebx
ENDIF
IF DOSNDIS
ENDIF
IF OS2NDIS
ENDIF
IF NWSERVER
    push    ebp
    push    ebx
ENDIF
    ENDM

;--------------------------------------------------------------------------
; @POP_MUSTSAVE
;
; Description : Each driver inserts code that pops the registers that must 
;               NEVER be changed by a function, others may be saved at times.
;               POP_MUSTSAVE contents must correlate to PUSH_MUSTSAVE.
;               POP_MUSTSAVE cannot save contents of Flags Register.
;
; Entry       : none
;
; Exit        : none
;
;--------------------------------------------------------------------------
@POP_MUSTSAVE macro  name
IF DOSODI
    pop     bx
ENDIF
IF OS2ODI
    pop     ebx
ENDIF
IF DOSNDIS
ENDIF
IF OS2NDIS
ENDIF
IF NWSERVER
    pop     ebx
    pop     ebp
ENDIF
    ENDM

;--------------------------------------------------------------------------
; @PROC_BEGIN
;
; Description : Each driver inserts code that defines a procedure header.
;
; Entry       : The "name" is required as it precedes the "proc" directive,
;               the "distance" is optional, and will default to the size 
;               as specified by SEGMENT directives if it is not provided.
;
; Exit        : none
;
;--------------------------------------------------------------------------
@PROC_BEGIN macro  name, distance
IF DOSODI
            align 4
    public  name
name        proc   distance
ENDIF
IF OS2ODI
            align 4
    public  name
name        proc   distance
ENDIF
IF DOSNDIS
;            align 16
    public  name
name        proc   distance
ENDIF
IF OS2NDIS
            align 16
    public  name
name        proc   distance
ENDIF
IF NWSERVER
            align 16
    public  name
name        proc   distance
ENDIF
            ENDM

;--------------------------------------------------------------------------
; @PROC_END
;
; Description : Each driver inserts code that concludes a procedure, WITHOUT
;               the Return statement (avoids forcing jump-to-end to return).
;
; Entry       : none
;
; Exit        : none
;
;--------------------------------------------------------------------------
@PROC_END   macro  name
IF DOSODI
name        endp
ENDIF
IF OS2ODI
name        endp
ENDIF
IF DOSNDIS
name        endp
ENDIF
IF OS2NDIS
name        endp
ENDIF
IF NWSERVER
name        endp
ENDIF
            ENDM


;--------------------------------------------------------------------------
; BREG
;
; Description : Each driver defines an equate which will be used by portable
;               code when referring to variables in the data segment.
;               The value of the EQU must evaluate to a valid value when
;               used, the EQU is always used within [] brackets.
;
; Entry       : none
;
; Exit        : none
;
;--------------------------------------------------------------------------
IF DOSODI
BREG    equ    0
ENDIF

IF OS2ODI
BREG    equ    bx
ENDIF

IF DOSNDIS
BREG    equ    0
ENDIF

IF OS2NDIS
BREG    equ    0
ENDIF

IF NWSERVER
BREG    equ    ebp
ENDIF

;--------------------------------------------------------------------------
; Macro for virtual to physical address conversion, only necessary for users 
; of LINEAR mode as opposed to SEGMENTED mode.  If using LINEAR mode, base
; register is 0, all virtual addresses must be converted to true physical 
;   (therefore this mode requires that the macro convert "source").
;
; If using SEGMENTED mode AND not running under a memory maanager, then DS
; is the true paragraph number to be assigned to the CURU base register, and
; any offset with the data segment is valid value to give CU/RU as an address 
;   (therefore this mode requires that the macro leave "source" as-is).
;
; If using SEGMENTED mode AND loaded under a memory manager, the DS value is
; not necessarily the TRUE paragraph number, but OFFSETs will be correct.
; At initialization time DS must converted if needed under memory manager. 
; In this situation, whether DS is same as TRUE paragraph or not, BUILD_PHYSICAL
; will leave "source" alone since is offsets are correct within TRUE paragraph.
;
; NOTE that can't use SEGMENTED mode and point to memory outside base Segment,
; because the SCB MACROs and structures always force the high-16 bits to zero.
;--------------------------------------------------------------------------
;- Build A Physical Address From A Logical Address
@BUILD_PHYS_OFFSET  MACRO    Source
    ENDM

;- Build A Physical Address From A Logical Address
@BUILD_PHYS_ADDRESS MACRO    Source
IF NWSERVER
    xchg    eax, Source
    call    MSMGetPhysical
    xchg    Source, eax
ENDIF
IF OS2ODI
    ;- call    DevHlp:VirtToPhys          ; NOTE macro can be used ANYTIME!
    mov     esi, Source
    call    ConvertToPhysicalAddress
    mov     Source, eax
ENDIF
IF (DOSNDIS OR OS2NDIS)
    mov     ax, ds
    mov     es, ax
    mov     esi, Source
    call    ConvertToPhysicalAddress
    mov     Source, eax
ENDIF
    ENDM


;--------------------------------------------------------------------------
; Macro to Output a string under Various and Random Netware Requirements.
;--------------------------------------------------------------------------
@PrintWarning  macro Msg
IF NWSERVER
    push    esi
    mov     esi, OFFSET Msg
    call    MSMPrintStringWarning
    pop     esi
ENDIF

IF (OS2ODI OR DOSODI)
    push    dx
IF  OS2ODI
    mov     dx, Msg
ENDIF    
IF  DOSODI
    mov     dx, OFFSET CGROUP:Msg
ENDIF    
    push    ax
    push    bx
    call    MSMPrintStringZero 
    pop     bx
    pop     ax
    pop     dx
ENDIF
    ENDM

;--------------------------------------------------------------------------
; Macro Used by routines which load a pointer to a string in AX to indicate
; that the routine encountered an error (therefore NDIS must return non-zero).
;--------------------------------------------------------------------------
@LOAD_MSGPTR macro msg
IF NWSERVER
    lea     eax, msg 
ENDIF
IF DOSODI
    lea     ax, msg 
ENDIF
IF OS2ODI
    mov     eax, msg 
ENDIF
IF (OS2NDIS OR DOSNDIS)
    xor     eax, eax
    dec     eax
ENDIF
    ENDM

;--------------------------------------------------------------------------
; Generic Register names used in portable code:
;
; Assumption here is that the NWSERVER code is using Flat 32-bit model, all
; pointers must be 32-bit pointers (relative to DS, whatever that is).  All
; other drivers using this code are assumed to be 16-bit Segment Model code.
;--------------------------------------------------------------------------

IF NWSERVER

RDI equ     edi
RSI equ     esi
RDX equ     edx
RCX equ     ecx
RBX equ     ebx
RAX equ     eax
RBP equ     ebp

ELSE

RDI equ     di
RSI equ     si
RDX equ     dx
RCX equ     cx
RBX equ     bx
RAX equ     ax
RBP equ     bp

ENDIF

ENDIF


; EOF - $Workfile:   portable.inc  $
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\amd\sstrucs.inc ===
;
; Modifications:   $Header:   J:/archives/preboot/lsa2/inc/SSTRUCS.INV   1.4   19 Sep 1997 21:39:20   MJOHNSOX  $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;

;
;   Description      :    NDIS structures and bit definitions for fields
;                         within those structures, name of driver, etc.
;                         THIS FILE HAS BEEN MODIFIED FROM NDIS NDK VERSION.
;

;
; File: sStrucs.inc    - Support Structures include NDIS specific.
;
;

;-----------------------------------------------------------------------------
;
;    The following equates are the primary configuration for the driver.
;
; * maximum number of multicast addresses.
;
NUM_MCADDRS        Equ       8
;
; * Maximum number of data blocks supported in a descriptor.
;
MAX_DATABLK        Equ    8
;

;-----------------------------------------------------------------------------
;
;    The following equates and structures should only be changed when
;    upgrading to a newer NDIS specification.
;

; * define the length of names and addresses in the Common Characteristics
; * and Specific Characteristics table.
;
NAME_LEN    Equ    16
ADDR_LEN    Equ    16
ADDR_SIZE   Equ    6

;
MIN_LOOKAHEAD_DEFAULT        Equ       MIN_PACKET+4
MAX_LOOKAHEAD                Equ       256

DELAY_COPY					 Equ	   -1
SUCCESS                      Equ       0000H
WAIT_FOR_RELEASE             Equ       0001H
REQUEST_QUEUED               Equ       0002H
FRAME_NOT_RECOGNIZED         Equ       0003H
FRAME_REJECTED               Equ       0004H
FORWARD_FRAME                Equ       0005H
OUT_OF_RESOURCE              Equ       0006H
INVALID_PARAMETER            Equ       0007H
INVALID_FUNCTION             Equ       0008H
NOT_SUPPORTED                Equ       0009H
HARDWARE_ERROR               Equ       000AH
TRANSMIT_ERROR               Equ       000BH
NO_SUCH_DESTINATION          Equ       000CH
ALREADY_STARTED              Equ       0020H
INCOMPLETE_BINDING           Equ       0021H
DRIVER_NOT_INITIALIZED       Equ       0022H
HARDWARE_NOT_FOUND           Equ       0023H
HARDWARE_FAILURE             Equ       0024H
CONFIGURATION_FAILURE        Equ       0025H
INTERRUPT_CONFLICT           Equ       0026H
INCOMPATIBLE_MAC             Equ       0027H
INITIALIZATION_FAILED        Equ       0028H
GENERAL_FAILURE              Equ       00FFH

; 
; * Packet filter bit definitions.
; 
FLTR_DIRECTED                Equ       01H
FLTR_MLTCST                  Equ       01H
FLTR_BRDCST                  Equ       02H
FLTR_PRMSCS                  Equ       04H
FLTR_SRC_RTG                 Equ       08H

; 
; * MAC status bits in the MAC Specific Characteristics table.
; * Bits 0-2 are coded to reflect the hardware status.
; 
HW_MISSING                   Equ       0000H
HW_BUD_ERR                   Equ       0001H
HW_CFG_ERR                   Equ       0002H
HW_FAULT                     Equ       0003H
HW_SOFT_ERR                  Equ       0004H
HW_OK                        Equ       0007H
MS_HW_MASK                   Equ       HW_OK

MS_BOUND                     Equ       0008H
MS_OPEN                      Equ       0010H
MS_DIAGS_ON                  Equ       0020H

;
;    Definintions for the MAC Service Supported Flags.
;    Bits 0-15.
;
BroadcastSupport             Equ       TRUE
MulticastSupport             Equ       TRUE
FunctionalGroupSupport       Equ       FALSE
PromiscuousSupport           Equ       TRUE
SetStationAddrSupport        Equ       TRUE
StatusAlwaysCurrent          Equ       FALSE
DiagnosticsSupport           Equ       FALSE
LoopBackSupport              Equ       FALSE
ReceiveChainPrimary          Equ       FALSE
IBMSourceRouting             Equ       FALSE
ResetMACSupport              Equ       TRUE
OpenAdapterSupport           Equ       TRUE
InterruptRequestSupp         Equ       TRUE
SourceRoutingBridge          Equ       FALSE
GDTAddressesSupported        Equ       TRUE
MultipleXferDatas            Equ       TRUE      ; Also set MaxXferDatas
RcvLkFrameSizeZero           Equ       FALSE

;
; * Definintions for the MAC Service Supported Flags.
; * Bits 0-14.
;
ServiceFlags    =  00000000H
ServiceFlags    =  ServiceFlags Or BroadcastSupport
ServiceFlags    =  ServiceFlags Or (MulticastSupport Shl 1)
ServiceFlags    =  ServiceFlags Or (FunctionalGroupSupport Shl 2)
ServiceFlags    =  ServiceFlags Or (PromiscuousSupport Shl 3)
ServiceFlags    =  ServiceFlags Or (SetStationAddrSupport Shl 4)
ServiceFlags    =  ServiceFlags Or (StatusAlwaysCurrent Shl 5)
ServiceFlags    =  ServiceFlags Or (DiagnosticsSupport Shl 6)
ServiceFlags    =  ServiceFlags Or (LoopBackSupport Shl 7)
ServiceFlags    =  ServiceFlags Or (ReceiveChainPrimary Shl 8)
ServiceFlags    =  ServiceFlags Or (IBMSourceRouting Shl 9)
ServiceFlags    =  ServiceFlags Or (ResetMACSupport Shl 10)
ServiceFlags    =  ServiceFlags Or (OpenAdapterSupport Shl 11)
ServiceFlags    =  ServiceFlags Or (InterruptRequestSupp Shl 12)
ServiceFlags    =  ServiceFlags Or (SourceRoutingBridge Shl 13)
ServiceFlags    =  ServiceFlags Or (GDTAddressesSupported Shl 14)
ServiceFlags    =  ServiceFlags Or (MultipleXferDatas Shl 15)
ServiceFlags    =  ServiceFlags Or (RcvLkFrameSizeZero Shl 16)

MAC_Type    Equ    <'DIX+802.3'>       ; Specific Characteristic Type.
;
; Protocol Manager opcodes used by the generic model
;
GetPMInfo                    Equ       1
RegisterModule               Equ       2
BindAndStart                 Equ       3
GetPMLinkage                 Equ       4

Ifdef AVL
;-----------------------------------------------------------------------------
; 
; * multicast address structure is ADDR_LEN bytes long
; 
MCastAddr   Struc
mAddr       DB     ADDR_LEN dup(0)
MCastAddr   Ends

; 
; * the multicast address buffer manages NUM_MCADDRS multicast address
; * structures.
; 
MCastBuf    Struc
McbMax      DW     ?    ;  max # of multicast addresses
McbCnt      DW     ?    ;  curr# "        "

McbAddrs    DB     size MCastAddr*NUM_MCADDRS dup(0)
MCastBuf    Ends
Endif	;; AVL 

;-----------------------------------------------------------------------------
;
;    Structures defined by the NDIS specification and used by the generic
;    model.
;
;-----------------------------------------------------------------------------
; * immediate data buffer length cannot exceed 64 bytes.
; 
MAX_IMMED_LEN      Equ       64
; 
; * Maximum number of data blocks supported in a Tx descriptor.
; 
MAX_TX_DATABLK     Equ       MAX_DATABLK
; 
; * Max number of TransferData blocks
; 
MAX_TD_DATABLK     Equ       MAX_DATABLK
; 
; * MAx number of ReceiveChain data blocks
; 
MAX_RX_DATABLK     Equ       MAX_DATABLK

; 
; * Data structures for TransmitChain (Tx), TransferData (TD), and
; * ReceiveChain (Rx).
; 
TxDataBlock Struc
TxPtrType   DB     ?        ; 0 => Phys pointer, 1 => GDT pointer
TxRsvdByte  DB     ?        ; Reservered, must be zero.
TxDataLen   DW     ?        ; Data block length in bytes.
TxDataPtr   DD     ?        ; Far pointer to data block.
TxDataBlock Ends

; 
; * TransmitChain descriptor structure definition
; 
TxBufDesc   Struc
TxImmedLen  DW     ?        ; Byte count of immediate data, max=64
TxImmedPtr  DD     ?        ; Virtual address of Immediate data
TxDataCount DW     ?        ; Number of Data Blocks (max = 8)
TxDataBlk   DB     size TxDataBlock * MAX_TX_DATABLK dup(0)
TxBufDesc   Ends

TxBufDescrSize    Equ    Size TxImmedLen + Size TxImmedPtr + Size TxDataCount

; 
; * TransferData data block description
; 
TDDataBlock Struc
TDPtrType   DB     ?        ; 0 => Phys pointer, 1 => GDT pointer
TDRsvdByte  DB     ?        ; Reservered, must be zero.
TDDataLen   DW     ?        ; Data block length in bytes.
TDDataPtr   DD     ?        ; Far pointer to data block.
TDDataBlock Ends

; 
; * TransferData descriptor structure
; 
TDBufDesc   Struc
TDDataCount DW    ?        ; No of Data Blocks (max 8 for V1.01).
TDDataBlk   DB    size TDDataBlock*MAX_TD_DATABLK dup(0)
TDBufDesc   Ends

; 
; * ReceiveChain data block structure definition
; 
RxDataBlock Struc
RxDataLen   DW    ?        ; Length of the Data Block
RxDataPtr   DD    ?        ; Far Pointer to Data Block
RxDataBlock Ends

; 
; * ReceiveChain descriptor structure definition
; 
RxBufDesc   Struc
RxDataCount DW    ?        ; No of Data Blocks. (max 8 for V1.01).

RxDataBlk   DB    size RxDataBlock*MAX_RX_DATABLK dup(0)
RxBufDesc   Ends


;-----------------------------------------------------------------------------
; 
;    Structures used in Protocol.Ini parsing.
;
;  
; * Data structures for the "Module Configuration" structure parsed from
; * the PROTOCOL.INI file. see NDIS spec for details.
; 
Param       Struc
ParamType   DW    ?    ; 0 => 31 bit signed integer, 1 => string
ParamLen    DW    ?    ; String length (including null) or 4.
ParmStart   DB    ?    ; Start of actual parameter.
Param       Ends

KeywordEntry       Struc
NextKeywordEntry   DD        ?                   ;  Forward pointer
PrevKeywordEntry   DD        ?                   ;  Back Pointer
KeyWord            DB        NAME_LEN Dup(?)     ;  Keyword on left side of "="
NumParams          DW        ?                   ;  Number of parameters on r. side of "="
Params             DB        Size Param dup(?)   ;  Actual size depends on NumParams
KeywordEntry       Ends


ModCfg      Struc
NextModCfg  DD     ?                   ;  Module config images are in a
PrevModCfg  DD     ?                   ;  double-linked list.
ModName     DB     NAME_LEN Dup(?)     ;  Bracketed Module Name.
KE          DB     Size KeywordEntry Dup(?) ;  Head of Keyword list
ModCfg      Ends

ProIni      Struc
MC          DB     Size ModCfg*1 dup(?)  ; Head of Module config list.
ProIni      Ends

PI_Record   Struc
Srchkeyword        DB        '                ' ; keyword.
SrchParmType       DW        ?         ; 0 - numeric, 1 - string. see below.
ParamField         DD        ?         ; If numeric, will contain value, 
                                       ; If string, will contain the pointer to string.
RequiredField      DB        ?         ; Set to 1 if parameter is required.
SetFCN             DW        ?         ; Offset to Parser function.
PI_Record   Ends


;
; Processor Type Equates.
;
EIGHT_BIT          equ       0001H
SIXTEEN_BIT        equ       0002H
PROC_TYPE_MASK     equ       0030H

PROC_8086          equ       0000H OR EIGHT_BIT
PROC_80286         equ       0010H OR SIXTEEN_BIT
PROC_80386         equ       0020H
PROC_80486         equ       0040H


; EOF - $Workfile:   sstrucs.inc  $
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\smc9432\9432umac.asm ===
;----------------------------------------------------------------------------
; 9432UMAC.ASM
;
;   (C) Lanworks Technologies Inc. 1995. All rights reserved.
;
;$History: 9432UMAC.ASM $
; 
; *****************  Version 1  *****************
; User: Paul Cowan   Date: 26/08/98   Time: 9:40a
; Created in $/Client Boot/NICS/SMC/9432/UNDI
;
; 10-Sep-97 1.10 PC - uses new TCP/IP NID and AI
; 29-Apr-97 1.00 PC - first release
;----------------------------------------------------------------------------
UMAC_MAIN	equ	1

ETHERNET	equ	9432
EPIC		equ	1
EPIC100		equ	1
PCI		equ	1

PCI_VENDOR_ID	equ	000010b8h
PCI_DEVICE_ID	equ	5

MAXPACKETDATASIZE  =	1514		; max packet data size
STATUS_PENDING	= 1

;;locals
	.xlist
;;	include \rom\sdk\include\drvseg.inc
;;	include \rom\sdk\include\bwnad.inc
;;	include \rom\sdk\include\bwequ.inc
    include 	undi_equ.inc
    include 	pxe_stru.inc
    include 	bwstruct.inc
    include 	spdosegs.inc
	include epic100.inc
	include lmstruct.inc
	.list

;;.386

INT_CTRL1	EQU	020h		; 8259A Int Controller #1
INT_CTRL1_MR	EQU	021h		; 8259A Int Controller #1
INT_CTRL1_ELR	EQU	4d0h		; 8259A Int Controller #1
INT_CTRL2	EQU	0a0h		; 8259A Int Controller #2
INT_CTRL2_MR	EQU	0a1h		; 8259A Int Controller #2
INT_CTRL2_ELR	EQU	4d1h		; 8259A Int Controller #2

EOI_SPECIFIC	EQU	060h		; Specific interrupt EOI


TRANSMIT_ERROR  EQU 0bh

;;extrn	PrintAt:near
;;extrn 	Print:near
;;extrn	PrintChar:near

;;extrn	ReadConfig:near
;;extrn	DoConfig:near


extrn	GetED:near
extrn	PostED:near
extrn	UNDI_DriverISR:far

extrn	Net_Address:byte
extrn	Node_Address:byte


extrn	LM_GetCnfg:near
extrn	LM_Send:near
extrn	LM_Initialize_Adapter:near
extrn	LM_Enable_Adapter:near
extrn	LM_Disable_Adapter:near
extrn	LM_Open_Adapter:near
extrn	LM_Service_Events:near
extrn	LM_Change_Receive_Mask:near
extrn	LM_Add_Multi_Address:near
extrn	LM_Delete_Multi_Address:near
extrn	LM_Receive_Copy:near
extrn	LM_Close_Adapter:near

;;extrn   Puts:near


extrn	IOBase:word
extrn	IRQNumber:byte


.386P

public	AS

public	UM_Send_Complete
public	UM_Receive_Copy_Complete
public	UM_Status_Change
public	UM_Interrupt
public	UM_Card_Services
public	UM_Receive_Packet


public	NADInit
public	NADReset
public	NADShutDown
public	NADOpen
public	NADClose
public	NADSetFilter
public	NADGetStatistics
public  NADMCastChange
public  NADTransmitPacket
public  DriverISR_Proc
public  NADInitiateDiags
public  NADSetMACAddress


public   OrgIntVector_OFF
public   OrgIntVector_SEG


Assume  CS:CGroup, DS:DGroup

;--------------------------------------------------------------------
;;START_CODE
_TEXT	Segment para public



;;	include \rom\sdk\include\bwnadapi.asm


;--------------------------------------------------------------------
; NADInitialize
;
;--------------------------------------------------------------------
NADInit proc near

;;	mov	bx, offset DGroup:StrPrompt
;;	call	PrintAt			; print initializing message

;;db  0f1h


;;;   	lea	bp, DGroup:LanOption
;;;   	call	puts


	call	FindAdapter		; find and reset LAN adapter
	or	dx, dx			; did we find the adapter?
	jne	xx_found
;	mov	ax, offset DGroup:NicNotFound	; return error message
	stc
	ret

xx_found:
;;	call	ReadConfig		; read configuration from adapter

	call	InitializeAdapter
	or	ax, ax			; was there an error?
	je	initOK2			; no error
    stc
	ret				; return (with error message in ax)

initOK2:
    mov ax, ds
    mov DGroup:StoreDS, ax
    clc
	xor	ax, ax			; return no error
	ret

NADInit endp



;------------------------------------------------------------------------------
; StartTime - save maxtick count, get current tick value
;	Timeout is ticks, each tick is 55 ms.
;	Note: this routine can only be called once the PC timer
;	and its interrupt are setup (INT19 and beyond are OK)
;
; On entry,
;	AX = max ticks to wait
;	ints enabled
;
; On exit,
;	all preserved
;
; 881030 1.0 GK
;------------------------------------------------------------------------------

StartTime	proc	near

		push	ax
		push	cx
		push	dx
        push    di  
        push    es

		mov	DGroup:MaxTicks, ax
;;		mov	ah, 0
;;db  0f1h
;;		int	1Ah				; get current tick value
        mov     ax, 40h
        mov     es, ax
        mov     di, 6Ch
        mov     dx, es:[di]
        mov     cx, es:[di+2]
		mov	DGroup:StartTick, dx		; save it

        pop es
        pop di
		pop	dx
		pop	cx
		pop	ax
		ret

StartTime	endp


;------------------------------------------------------------------------------
; CheckTime - gets current tick value, compares with maxticks
;	Timeout is ticks, each tick is 55 ms.
;	Note: this routine can only be called once the PC timer
;	and its interrupt are setup (INT19 and beyond are OK)
;
; On entry,
;	maxticks set by StartTime
;	ints enabled
;
; On exit,
;	CY set if timeout
;	all registers preserved
;
; 881030 1.0 GK
;------------------------------------------------------------------------------

CheckTime	proc	near

		push	ax
		push	cx
		push	dx
        push    di  
        push    es

;;		mov	ah, 0
;;		int	1Ah			; get current tick

        mov     ax, 40h
        mov     es, ax
        mov     di, 6Ch
        mov     dx, es:[di]
        mov     cx, es:[di+2]

		sub	dx, DGroup:StartTick
		cmp	dx, DGroup:MaxTicks
		cmc

        pop es
        pop di
		pop	dx
		pop	cx
		pop	ax

		ret				; return with CY set if timeout

CheckTime	endp




;--------------------------------------------------------------------
; FindAdapter
;
; Parameters:
;	none
;
; Returns:
;	dx = I/O address
;--------------------------------------------------------------------
FindAdapter proc near

	mov	ax, 0b101h
	int	1ah			; check for PCI BIOS
	jc	notFound		; device not found

	cmp	edx, ' ICP'		; check for PCI signature
	jne	notFound		; return "not found" error

	mov	dx, PCI_VENDOR_ID	; PCI vendor ID
	mov	cx, PCI_DEVICE_ID	; PCI device ID
	mov	si, 0			; index
	mov	ax, 0b102h
	int	1ah			; find PCI device
	jc	notFound		; device not found

	mov	di, 10h			; register number (I/O address)
	mov	ax, 0b109h
	int	1ah			; read PCI config word
	jc	notFound		; device not found

	and	cl, 80h
	push	cx			; save address on stack

	mov	dx, cx
	add	dx, EPC_GEN_CONTROL
	mov	ax, GC_SOFT_RESET
	out	dx, ax			; reset the NIC

; delay for > 1 us (15 pci clocks)
	mov	cx, 100h
reset_delay:
	mov	al, DGroup:StatusFlag
	loop	reset_delay

	pop	dx			; return address in dx
	ret

notFound:
	xor	dx, dx			; return 0 - adapter not found
	ret

FindAdapter endp

;---------------------------------------------------------------------
;  Routine Name:  NetInitialize Routine
;
;  Description: The NetInitialize routine is responsible for initial-
;		izing the adapter.  This routine is called from the
;		NETINT code when it is ready to use the adapter to
;		send the first request out to the network.
;  On entry,
;		DS = DGroup
;		ints enabled
;
;  On exit,
;		AX - return code (0 = good completion)
;
;  Calls:
;
;---------------------------------------------------------------------
InitializeAdapter proc near

;	push	cs
;	pop	ds			; ds = cs

	mov	DGroup:[AS.pc_bus], PCI_BUS
	mov	DGroup:[AS.slot_num], 16

	mov	bp, offset DGroup:AS

    push    es
    push    ds
    pop     es

;db  0f1h
	call	LM_GetCnfg		; try and find the SMC adapter

    pop     es

	cmp	ax, ADAPTER_AND_CONFIG
	je	getCnfgOK

	mov	ax, offset DGroup:InitError
	ret				; return error code

getCnfgOK:
	mov	ax, offset DGroup:HostRAM
	mov	dx, ds
	mov	word ptr DGroup:[AS.host_ram_virt_addr], ax
	mov	word ptr DGroup:[AS.host_ram_virt_addr+2], dx
	mov	word ptr DGroup:AS.setup_ptr.virtual_addr, ax
	mov	word ptr DGroup:AS.setup_ptr.virtual_addr+2, dx

	and     edx, 0ffffh
	shl     edx, 4
	and     eax, 0ffffh
	add     edx, eax
	mov     DGroup:AS.host_ram_phy_addr, edx
	mov	    DGroup:AS.setup_ptr.phy_addr, edx

foundAdapter:

;	First, the maximum packet size and number of transmit buffers,
;	the memory address used by the host (seg:off in this code),
;	and the pointers to error counters are set before calling
;	LM_Initialize_Adapter.	Since Token Ring and Ethernet use
;	different errors, an IFDEF is used to initialize the correct
;	pointers.  Interrupts are disabled before installing new
;	interrupt vector, and are not enabled until after
;	LM_Initialize_Adapter is called in order to prevent the
;	mishandling of spurious interrupts.  STATUS_PENDING is used to
;	determine when the call is completed.  Since UM_Status_Change
;	may be called inside of LM_Initialize_Adapter, STATUS_PENDING
;	is set before the call.  If the adapter initialize
;	successfully, we set the multicast addresses (different for
;	Token ring and Ethernet) and open the adapter.	We return after
;	opening the adapter.

;  set up the values needed by LM_Initialize_Adapter
;  (num_of_tx_bufs defaults to 1)

	mov	DGroup:[AS.rx_lookahead_size], 4
	mov	DGroup:[AS.max_packet_size], MAXPACKETDATASIZE
;	mov	[AS.media_type], MEDIA_UNKNOWN
	or	DGroup:[AS.adapter_flags], ENABLE_TX_PENDING

	push	ds
	pop	es			; ES = DS
	lea	di, DGroup:AS.ptr_rx_CRC_errors
	mov	si, offset DGroup:eth_rx_CRC_errors
	mov	cx, 15			; 15 error counters are defined

defineEthErrPtrs:
	mov	ax, si
	stosw
	add	si, 4			; next dword error variable
	mov	ax, ds
	stosw
	loop	defineEthErrPtrs

	cli				; ints off

	mov	ax, offset CGroup:UNDI_DriverISR



	mov	bl, byte ptr DGroup:AS.irq_value
	xor	bh, bh
	call	HookIntVector
	or	DGroup:statusFlag, STATUS_PENDING

	mov	DGroup:AS.receive_mask,  0 ; ACCEPT_PHYSICAL

	push	ds
	pop	es			; es = ds

;db  0f1h
	call	LM_Initialize_Adapter
	sti				; enable ints again

;db  0f1h
	or	ax, ax			; was there an error?
	jz	AdapterInitOk		; no error

	push	ax			; save retcode
	call	UnhookIntVector 	; restore int vector and mask PIC
	pop	ax

	mov	ax, offset DGroup:msg_initerror

;GetLMErrStr:
;	test	word ptr [bx], -1	; reached end of errcode table?
;	jz	FoundLMErrStr		; yes, return default message

;	cmp	ax, [bx]
;	jz	FoundLMErrStr		; [bx+2] has err msg offset

;	add	bx, 4
;	jmp	short GetLMErrStr

;FoundLMErrStr:
;	mov	ax, [bx+2]		; AX has errmsg offset
	jmp	init_exit		; return with error msg

AdapterInitOk:
; -- wait up to 10s for adapter to initialize. The call to UM_Status_Change
;    from the LMAC will cause the STATUS_PENDING bit to be reset.

;db  0f1h
	mov	ax, 0182		; wait up to 10s
	call	StartTime

InitPendLoop:
	test	DGroup:statusFlag, STATUS_PENDING
	jz	InitCompleted

	call	CheckTime
	jnc	InitPendLoop

	call	UnhookIntVector 	; clean up interrupt stuff
	mov	ax, offset DGroup:msg_initerror ; "Error initializing adapter"
	jmp	short init_exit		; return AX errmsg offset

InitCompleted:
; Now open the adapter onto the network.

	or	DGroup:statusFlag, STATUS_PENDING
;;	call	LM_Open_Adapter
    jmp     OpenCompleted1    

OpenCompleted1:

	mov	si, offset DGroup:AS.Xnode_address
	mov	di, offset DGroup:Node_Address
	mov	cx, 6
	rep	movsb			; copy node address

	mov	si, offset DGroup:AS.Xnode_address
	mov	di, offset DGroup:Net_Address
	mov	cx, 6
	rep	movsb			; copy node address

    mov	    ax, DGroup:AS.io_base
	mov	    DGroup:[IOBase], ax	; UNDI_NAD variable
	mov	    al, byte ptr DGroup:AS.irq_value
	mov	    DGroup:[IRQNumber], al ; UNDI_NAD variable


    in  ax, 60h         ;

	xor	ax, ax			; no errors

init_exit:
	ret				; Return to caller

InitializeAdapter endp

;--------------------------------------------------------------------
;--------------------------------------------------------------------
NADReset proc near

;db  0f1h
    call    NADClose
	ret

NADReset endp

;--------------------------------------------------------------------
; NADDisengage
;
;--------------------------------------------------------------------
NADDisengage proc far

	push	ds			; save callers' DS
	mov	bp, offset DGroup:AS

   	or	DGroup:statusFlag, STATUS_PENDING
;db  0f1h
	call	LM_Close_Adapter
   	or	ax, ax
   	jnz	NADCloseFailed

   	mov	ax, 637 		; wait up to 35s for open
   	call	StartTime

NADClosePendLoop:
   	test	DGroup:statusFlag, STATUS_PENDING
   	jz	NADCloseCompleted

   	call	CheckTime
   	jnc	NADClosePendLoop


NADCloseFailed:
	pop	ds			; restore callers' DS
    stc
    ret

;  Status changed -- see if adapter is open; if so, set good retcode

NADCloseCompleted:
    cmp	DGroup:AS.adapter_status, CLOSED
    jnz	NADCloseFailed

	call	LM_Disable_Adapter
	call	UnhookIntVector 	; restore int vector and mask PIC

	pop	ds			; restore callers' DS
    clc
	ret				; Return to caller

NADDisengage endp

;---------------------------------------------------------------------
;  Routine Name:  Adapter Interrupt Handler Routine
;
;  Description: The Adapter Interrupt Handler Routine is what is called
;		when an interrupt is asserted from the adapter.
;		This routine first calls LM_Disable_Adapter, then
;		LM_Service_Events. LM_Service_Events will then make
;		calls back to us  to complete interrupt processing.
;		After returning to us, we must issue an LM_Enable_Adapter
;		to enable further adapter interrupts.
;
; 920902 - 0.0 GK
;---------------------------------------------------------------------
OurInterruptHandler proc far


	cld
	cli

	pusha				; save all registers
	push	ds			; save ds
	push	es			; save es



	mov	bp, offset DGroup:AS	; get pointer to adapter structure

	;  call LM_Disable_Adapter to prevent further interrupts from adapter
	call	LM_Disable_Adapter
	call	IssueEOI		; EOI the int controller
	sti				; allow other interrupts to occur

;db  0f1h
	call	LM_Service_Events
	cli
	; reenable the adapter
	call	LM_Enable_Adapter

	pop	es			; restore es
	pop	ds			; restore ds
	popa				; restore all registers

	iret				; Return from interrupt

OurInterruptHandler endp

;--------------------------------------------------------------------
;  IssueEOI
;
;  Description: The IssueEOI routine issues a EOI to the interrupt
;		controller.  This is done differently (maybe) depend-
;		on whether we're under DOS or OS/2.
;
;  Input:	DS:BX - adapter ACB
;
;  Output:	none
;
;  Calls:	none
;---------------------------------------------------------------------
IssueEOI proc near

	mov	al, byte ptr DGroup:AS.irq_value
					; Get the int level
	cmp	al, 7			; Is it on secondary ctrlr ?
	jbe	int_prim		;   No, its on controller #1

	sub	al, 8			; Adjust int level
	or	al, EOI_SPECIFIC	; Make it specific EOI
	out	INT_CTRL2, al		; EOI controller #1
	mov	al, 2			; Set int level 2

int_prim:
	or	al, EOI_SPECIFIC	; Make it specific EOI
	out	INT_CTRL1, al		; EOI controller #1

	ret				; Return to caller

IssueEOI endp

;--------------------------------------------------------------------
; HookIntVector  - hook int vector given by adapterStruc.irq_value
;
; On entry,
;	ax - handler function offset
;	bx - interrupt number
;	ints disabled
;
; On exit,
;	???
;
; 931223 2.7 GK doesn't convert INT9 back to INT2 when installing vector
; 920910 0.0 GK
;--------------------------------------------------------------------

HookIntVector proc near

	pusha				; save all registers
	mov	si, ax			; save function offset in si
	cli				; disable interrupts

;	test	byte ptr cs:ATFlag, -1
;	jz	int_adj_skip		; not running on AT, keep at int 2

	cmp	bl, 2			; Is interrupt level = 2 ?
	jne	int_adj_skip		;   No, skip this

	mov	bl, 9			; Set interrupt level 9

int_adj_skip:
	mov	dx, INT_CTRL1_MR	; Set int controller #1
	mov	cx, bx			; Save int level in cx
	cmp	cl, 7			; We on right controller ?
	jbe	ctrler_ok		;   Yep, continue

	mov	dx, INT_CTRL2_MR	; Set int controller #2
	sub	cl, 8			; Adjust int level offset

ctrler_ok:
	mov	ah, 11111110b		; Make IRQ mask
	rol	ah, cl			; Put enable bit in right

	mov	dGroup:irq_mask, ah	; Save interrupt enable mask

	push	ax			; Save enable mask
	push	dx			; Save int controller port

	mov	al, bl			; Get IRQ number
	cmp	al, 9			; Is it level 9 ?
	jne	int_lvl_ok		;   No, skip this

;931223 mov	al, 2			; Make it level 2

int_lvl_ok:
	add	al, 08h 		; Point to correct INT
	cmp	al, 10h 		; Is it below INT 10h ?
	jb	int_set 		;   Yes, go set it up

	add	al, 60h 		; Point to correct INT

int_set:
	push	ax			; Save INT number

	xor	bx, bx			; Clear target register
	mov	es, bx			; es = 0
	mov	bl, al			; Copy INT vector
	shl	bx, 1			; Point to vector in memory
	shl	bx, 1			; Point to vector in memory
	mov	dGroup:IvtOffset, bx	; save IVT offset

;;	mov	ax, es:[bx]		; get old vector
;;	mov	word ptr dGroup:OldIntVector, ax
;;	mov	ax, es:[bx+2]
;;	mov	word ptr dGroup:OldIntVector+2, ax


	mov	ax, es:[bx]		; get old vector
	mov	word ptr dGroup:OrgIntVector_OFF, ax
	mov	ax, es:[bx+2]
	mov	word ptr dGroup:OrgIntVector_SEG, ax


	pop	ax			; Restore INT number

; * Dmitry *
;;;;;db  0f1h

	mov	es:[bx], si		; set new interrupt vector offset
	mov	es:[bx+2], cs		; set new interrupt vector segment

	pop	dx			; Restore int controller
	pop	ax			; Restore int enable mask
	in	al, dx			; Get current IRQs
	jmp	$+2			; slow
	and	al, ah			; Add in our's
	out	dx, al			; Put it back into 8259

	popa				; restore registers
	sti				; enable interrupts
	ret

HookIntVector endp

;--------------------------------------------------------------------
; UnhookIntVector - remove our int handler from the IVT chain
;
; On entry,
;	HookIntVector has been called
;	DS = CS
;
; On exit,
;	AX, BX, DX, ES modified
;
; 931223 2.7 - GK leaves INT9 interrupt enabled
; 920910 0.0 - George Kostiuk
;--------------------------------------------------------------------
UnhookIntVector proc near

; --- first disable adapter-specific int

	mov	bx, dGroup:IvtOffset	; get IVT offset
	cmp	bx, 0
	je	unhookExit

	xor	ax, ax			; Point to int vector memory
	mov	es, ax
;931223 for POST
	cmp	bx, 1C4h		; slave INT 9??
	jz	UnhookIVT		; yes, keep the int enabled
;931223 for POST

	mov	dx, INT_CTRL1_MR	; assume master PIC
	or	bh, bh			; slave PIC?
	jz	MaskIntOff

	mov	dx, INT_CTRL2_MR	; slave PIC

maskIntOff:
	mov	ah, DGroup:irq_mask		; AH has enable mask
	not	ah			; invert it to get disable mask
	in	al, dx
	jmp	$+2
	or	al, ah			; mask the interrupt
	out	dx, al

unhookIVT:
	cli

;;	mov	ax, word ptr DGroup:OldIntVector
;;	mov	es:[bx], ax		; restore old vector
;;	mov	ax, word ptr DGroup:OldIntVector+2
;;	mov	es:[bx+2], ax

	mov	ax, word ptr DGroup:OrgIntVector_OFF
	mov	es:[bx], ax		; restore old vector
	mov	ax, word ptr DGroup:OrgIntVector_SEG
	mov	es:[bx+2], ax

	sti

unhookExit:
	ret

UnhookIntVector endp

;----------------------------------------------------------------------
;  Routine Name:  NADTransmitPacket Routine
;
;  Description:
;	Called to send a frame out onto the network.
;
; The ED is set up with the frame data descriptors pointing to
; the packet data to be transmitted.  The packet is to be
; transmitted in RAW mode where the entire packet, including
; the MAC header is included in the fragment buffers.
;
;  Input:	ES:SI - pointer to ED (ES != DS)
;		DS = RAM Base
;
;  Output:	ED.retcode field updated
;
;----------------------------------------------------------------------
;TxEDPtr dd 0
NADTransmitPacket proc near

;db  0f1h

	push	ds			; Save data segment


	pushf				; Save flags

;;cli

; ********* DMitry *************

;db  0f1h
        push    si
        push    es
        push    ds

        push    ds
        push    es
        pop     ds
        pop     es

		cld					; Clear direction
		mov	di, offset DGroup:TxPacket

        mov bx, si

		mov	cx, ds:[bx].ED_FragCount   ; Get fragment count
		lea	bx, [bx].ED_FragOff	; point to first framedesc
        xor dx, dx

Tx_Frag_Loop:
		push	cx			; save fragment count
		push	ds			; save fragment descriptor list segment
		mov	cx, ds:[bx].DLen	; length of this fragment
        add dx, cx

		lds	si, ds:[bx].DPointer	; location of this fragment
		rep	movsb

Tx_Frag_End:	
        
        pop	ds			; restore frag descriptor list segment
		pop	cx			; restore fragment count
		add	bx, size Descript_Struct ; next descriptor
		loop	Tx_Frag_Loop		; loop through all fragments

        pop ds
        pop es
        pop si

	cli				; Disable interrupts

	; We must convert the fragment list to physical addresses.
	mov	cx, 1 ; get fragment count
	mov	DGroup:FragCount, cx
    mov cx, dx

	mov	di, offset DGroup:Frag1

;copyTxFrags:


    mov ebx,    CR0
    test    bx, 1
    je      real_mode
    mov ax, Dgroup:StoreDS
    jmp short   p_mode

real_mode:
	mov	ax, ds

p_mode:
    and eax, 0ffffh
	shl	eax, 4
	mov	dx, offset DGroup:TxPacket
    and edx, 0ffffh 
	add	eax, edx
	mov	[di], eax
    mov	ax, cx
	or	ax, PHYSICAL_ADDR
	mov	[di+4], ax


	mov	cx, es:[si].ED_Length	; CX has packet_size

	cmp	cx, 60
	jae	EthTxSizeOk

	mov	cx, 60

EthTxSizeOk:
	mov	byte ptr DGroup:TxDoneFlag, 0	; clear Tx Done

	push	si			; save ED pointer
	push	es			; save es

	push	ds
	pop	es			; set es = ds

	mov	si, offset DGroup:FragCount
	mov	bp, offset DGroup:AS
	sti				; Enable interrupts

;db  0f1h
	call	LM_Send
;	sti				; Enable interrupts

	pop	es			; restore es

	mov	ax, 5			; wait up to 5 ticks for Tx complete
	call	StartTime
	xor	ax, ax			; prepare errCode = 0

	pop	si			; restore ED pointer

TxPendLoop:
	cmp	byte ptr DGroup:TxDoneFlag, al
	jnz	SetEDCCode

	call	CheckTime
	jnc	TxPendLoop

	mov	ax, -1	                    ; fatal
	mov	bx, offset DGroup:NoNetMsg	; not installed or not connected

;  post the ED completion code and return

SetEDCCode:

;	les	si, TxEDPtr
	mov	es:[si].ED_ErrCode, ax	; Set return code
	or	ax, ax
	jz	noTxError

	mov	es:[si].ED_ErrMsg, bx	; BX has errmsg offset
    popf
    stc
    pop ds
    ret

noTxError:
	popf				; Restore interrupts
    clc
	pop	ds			; Restore data segment
	ret				; Return to caller

NADTransmitPacket endp

;======================= RECEIVE SECTION =============================

;--------------------------------------------------------------------
; NADChangeReceiveMask
;
;	Change the receive mask of the controller. Can force the adapter
;	to enable/disable broadcast, multicast or promiscuous receptions
;
;	Parameters:
;		BL - new receive bit mask:
;			bit 0:	set   = enable
;				clear = disable
;			bit 1:	change broadcast mask based on bit 0 flag
;			bit 2:	change multicast mask based on bit 0 flag
;			bit 3:	change Multicast Address Table:
;				if bit 0 is set, ES:DI will point to the
;					multicast address to add
;				if bit 0 is cleared, ES:DI will point to
;					multicast address to delete.
;				if bit 0 is cleared and DI = 0,
;					clear whole Multicast Table
;
;		ES:DI pointer to multicast address
;
;	Returns:
;		BX - TRUE/FALSE status if change was made
;		DS - preserved
;
; 970303 1.80/320 - GK
;--------------------------------------------------------------------
NADChangeReceiveMask proc far

	push	ds			; save callers' DS
  
    mov	bp, offset DGroup:AS

	mov	ax, ACCEPT_BROADCAST
	test	bx, 10b			; change broadcast mask?
	jnz	changeMaskTest

	mov	ax, ACCEPT_MULTICAST
	test	bx, 100b		; change multicast mask?
	jnz	changeMaskTest

	test	bx, 1000b		; change multicast table?
	jz	changeMaskExit

;    set AS.receive_mask to ACCEPT_MULTICAST and call LM_Change_Receive_Mask

; -- copy ES:DI to AS.multi_address and call LM_Add_Multi_Address or
;    LM_Delete_Multi_Address

	or	di, di			; clear whole table?
	jz	ChangeMaskErr		; not supported!

	mov	ax, es:[di]
	mov	word ptr DGroup:AS.multi_address, ax
	mov	ax, es:[di+2]
	mov	word ptr DGroup:AS.multi_address+2, ax
	mov	ax, es:[di+4]
	mov	word ptr DGroup:AS.multi_address+4, ax

				; ds:bp ptr to AS with multi_address field set

	test	bx, 1			; set or clear?
	jnz	AddMulti

cli
	call	LM_Delete_Multi_Address
sti
	jmp	changeMaskExit

addMulti:
cli
	call	LM_Add_Multi_Address
sti
	jmp	changeMaskExit

changeMaskTest:
	test	bx, 1			; set if enable, clear if disable
	jnz	setMask

	not	ax
	and	DGroup:AS.receive_mask, ax
	jmp	changeMask

setMask:
	or	DGroup:AS.receive_mask, ax

changeMask:
cli
	call	LM_Change_Receive_Mask
sti

changeMaskExit:
	mov	bx, 1			; return TRUE
	pop	ds			; restore callers' DS
	ret

changeMaskErr:
	xor	bx, bx			; return FALSE
	pop	ds
	ret

NADChangeReceiveMask    endp



;=========================================================================
; NADSetFilter
;==============
;	- Change the rx unit's filter to a new one
;
; Parameters:	AX = filter value, 1 = directed/multicast
;				   2 = broadcast
;				   4 = promiscuous
;		DS = DGroup
;
; Returns:
;=========================================================================
NADSetFilter	proc	near

; use NADChangeReceiveMask to do all of the dirty work -- 1 bit at a time,
; since NADChangeReceiveMask does not accept OR'd mask settings

;int 03

;;db  0f1h

	push	ax			; save for later
	mov	bl, 00000100b		; multicast setting - assume off
	test	al, 1			; directed/multicast?
	jz	SetFilterMulticast

	or	bl, 1			; multicast on

SetFilterMulticast:
	call	NADChangeReceiveMask

	pop	ax
	push	ax
	mov	bl, 00000010b		; broadcast setting - assume off
	test	al, 2			; broadcast?
	jz	SetFilterBroadcast

	or	bl, 1			; broadcast on

SetFilterBroadcast:
	call	NADChangeReceiveMask

	pop	ax
	mov	bl, 00010000b		; promiscuous setting - assume off
	test	al, 4			; promiscuous?
	jz	SetFilterPromiscuous

	or	bl, 1			; promiscuous on

SetFilterPromiscuous:
	call	NADChangeReceiveMask
    clc
	ret

NADSetFilter	endp



;==========================================================================
; NADMCastChange
;================
;	- Modify the multicast buffer to receive the multicast addresses
;	  listed in the multicast table.
;	  Each entry in the multicast table is as follows:
;		  Bytes 0-5 = Multicast Address
;	  All addresses are contiguous entries
;
; Parameters:	CX =  Number of multicast entries.
;		ES:SI -> Multicast Table.
;		AX = 1 means save the list
;		AX = 0 means use the saved list
;
; Return:	All registers may be destroyed.
;==========================================================================

NADMcastChange	proc	near

;;db  0f1h

	mov	di, si			; ES:DI now points to mcast addrlist
	cmp	cx, MAXNUM_MCADDR
	jbe	MCsave

	mov	cx, MAXNUM_MCADDR

MCsave:
	jcxz	Set_MCastDone		; could be zero -- just exit

Set_McastTable_Loop:


	push	cx			; save mcastaddr count
;		BL - new receive bit mask:
;			bit 0:	set   = enable
;				clear = disable
;			bit 1:	change broadcast mask based on bit 0 flag
;			bit 2:	change multicast mask based on bit 0 flag
;			bit 3:	change Multicast Address Table:
;				if bit 0 is set, ES:DI will point to the
;					multicast address to add
    mov     bx, 9
    call    NadChangeReceiveMask
    add     di, 6
	pop	cx
	loop	Set_MCastTable_Loop

Set_MCastDone:
	ret

NADMcastChange	endp




;--------------------------------------------------------------------
; UM_Receive_Packet
;
; On entry,
;	CX = size of received data
;	DS:BP ptr to AS
;	ES:SI ptr to lookahead data (if AS.adapter_flags has
;	      RX_VALID_LOOKAHEAD set)
;
; On exit,
;	AX = SUCCESS or EVENTS_DISABLED
;	all other regs preserved *******IMPORTANT****!!!!
;
;--------------------------------------------------------------------
UM_Receive_Packet proc near

;db  0f1h

    or  cx, cx
    jz  just_ret1

    or  bl, bl
    jnz  just_ret1


;    cli
    

;    test    bl, 6
;    jz  shhh


;shhh:

	pusha				; save registers
	push	es
	cld

	mov	DGroup:RxSize, cx		; save total rx packet size

	mov	ax, DGroup:RxSize
	cmp	ax, MAXPACKETDATASIZE	; check what max size is
	ja	rcv_no_filter


	mov	cx, 1; get fragment count
	mov	DGroup:RxFragCount, cx
;	lea	bx, es:[si].ED_FragOff

	mov	di, offset DGroup:RxFrag1

;copyRxFrags:

    mov ebx,    CR0
    test    bx, 1
    je      real_mode2
    mov ax, Dgroup:StoreDS
    jmp short   p_mode1
real_mode2:
    mov	ax, ds
p_mode1:

;    mov     ax, ds
    and     eax, 0ffffh
;	movzx	eax, ds
	shl	eax, 4
	mov 	dx, offset Dgroup:RxPacket
    and     edx, 0ffffh
	add	eax, edx
	mov	[di], eax
	mov	ax, 1800
	or	ax, PHYSICAL_ADDR
	mov	[di+4], ax

	mov	si, offset DGroup:RxFragCount
	mov	bp, offset DGroup:AS
	mov	cx, DGroup:RxSize

	xor	ax, ax			; offset = 0
	push	cx			; save receive count

	push	es			; save es
	push	ds
	pop	es			; es = ds

	mov	bx, 1			; set to indicate final copy, poll status
	call	LM_Receive_Copy

;    sti

	pop	es			; restore es
	pop	cx
	or	ax, ax
	jnz	RxWasTooBig

;	mov	BytesReceived, cx	; set received byte count


	call	GetED
	mov	word ptr DGroup:RxEDPtr, si	; save ED pointer
	mov	word ptr DGroup:RxEDPtr+2, es
	jz	rcv_no_filter


    mov     si, offset DGroup:RxPacket

    mov     cx,    DGroup:RxSize

	les	bx, DGroup:RxEDPtr		; ES:BX point to ED

	lea	di, es:[bx].ED_FragOff	; ES:SI ptr to fragment descriptor list

    mov di, WORD PTR es:[di].FragOff
;;	les	di, dword ptr es:[di].FragOff

    rep movsb    

OkPac:

	les	si, DGroup:RxEDPtr

    mov     cx,    DGroup:RxSize
	mov	es:[si].ED_Length, cx	; save length in ED

	mov	es:[si].ED_ErrCode, 0	; Set good completion


rcv_no_filter:				; this packet can be thrown away now
	pop	es			; restore registers
	popa

Just_ret:
	xor	ax, ax			; indicate SUCCESS
	ret

Just_ret1:
;db  0f1h
	xor	ax, ax			; indicate SUCCESS
	ret



RxWasTooBig:
;	mov	BytesReceived, 0	; indicate no bytes received

;;db  0f1h

	jmp	rcv_no_filter

UM_Receive_Packet   endp

;--------------------------------------------------------------------
;--------------------------------------------------------------------
UM_Receive_Copy_Complete proc near
	xor	ax, ax			; indicate SUCCESS
	ret
UM_Receive_Copy_Complete endp

UM_SEND_COMPLETE proc
;db  0f1h
	mov	DGroup:TxDoneFlag, -1	; for now, should check AX =send_status
	xor	ax, ax			; return SUCCESS
	ret
UM_SEND_COMPLETE    endp

UM_STATUS_CHANGE proc
;db  0f1h
	mov	DGroup:StatusFlag, 0		; clear status pending
	xor	ax, ax			; return success
	ret
UM_STATUS_CHANGE    endp

UM_Interrupt proc near
	xor	ax, ax			; indicate SUCCESS
	ret
UM_Interrupt endp

UM_Card_Services proc
	int	1ah
	ret

UM_Card_Services    endp


;=========================================================================
; DriverISR_Proc
;================
;	- ISR procedure to be called by UNDI_DriverISR
;
; Parameters:	DS = CGroup
;
; Returns:	CF = a if not our int
;=========================================================================
DriverISR_Proc	proc	near

;db  0f1h
		pushf
        call    OurInterruptHandler
		clc
		ret

DriverISR_Proc	endp


;=========================================================================
; NADGetStatistics
;==================
;	- Read the adapter's statistics
;
; Parameters:	ds:si points to variables to hold the result
;			TxGoodFrames	dd	0	;1
;			RxGoodFrames	dd	0	;2
;			RxCRCErrors	dd	0	;3
;			RxDiscarded	dd	0	;3
;
; Returns:
;=========================================================================
NADGetStatistics	proc	 near

		push	dx
; more code here

;;        stc
        clc
		pop	dx
		ret

NADGetStatistics	endp

;=========================================================================
; NADOpen
;=========
;	- Enables the Tx and Rx units
;
; Parameters:	DS = CGroup
;
; Returns:
;=========================================================================
NADOpen 	proc	near

;db  0f1h

; not sure whether we have to do anything here, since NADTransmit does a
; reset of the adapter and re-inits everytime.
    
    	mov	bp, offset DGroup:AS

        mov ebx,    CR0
        test    bx, 1
        je      real_mode1     ; je

; reinitialize this if we are in protected mode :

    	mov	ax, offset DGroup:HostRAM
    	mov	dx, ds
    	mov	word ptr DGroup:[AS.host_ram_virt_addr], ax
    	mov	word ptr DGroup:[AS.host_ram_virt_addr+2], dx
    	mov	word ptr DGroup:AS.setup_ptr.virtual_addr, ax
    	mov	word ptr DGroup:AS.setup_ptr.virtual_addr+2, dx

    	mov	dx, DGroup:StoreDS
    	and     edx, 0ffffh
    	shl     edx, 4
    	and     eax, 0ffffh
    	add     edx, eax
    	mov     DGroup:AS.host_ram_phy_addr, edx
    	mov	    DGroup:AS.setup_ptr.phy_addr, edx


    	mov	DGroup:[AS.rx_lookahead_size], 4
    	mov	DGroup:[AS.max_packet_size], MAXPACKETDATASIZE
    	or	DGroup:[AS.adapter_flags], ENABLE_TX_PENDING ; 0

        push    di
        push    es

    	push	ds
    	pop	es			; ES = DS

    	mov	dx, ds  

    	lea	di, DGroup:AS.ptr_rx_CRC_errors
    	mov	si, offset DGroup:eth_rx_CRC_errors
    	mov	cx, 15			; 15 error counters are defined

defineEthErrPtrs1:
    	mov	ax, si
    	stosw
    	add	si, 4			; next dword error variable
    	mov	ax, dx
    	stosw
    	loop	defineEthErrPtrs1

    	or	DGroup:statusFlag, STATUS_PENDING

    	sti				; enable ints again
    	call	LM_Initialize_Adapter

        pop     es
        pop     di

    	or	ax, ax			    ; was there an error?
    	jnz	NADOpenFailed		; error

;db  0f1h        

AdapterInitOk1:
; -- wait up to 10s for adapter to initialize. The call to UM_Status_Change
;    from the LMAC will cause the STATUS_PENDING bit to be reset.

;db  0f1h
    	mov	ax, 0182		; wait up to 10s

    	call	StartTime

InitPendLoop1:
    	test	DGroup:statusFlag, STATUS_PENDING
    	jz	    InitCompleted1


    	call	CheckTime
    	jnc	InitPendLoop1

        jmp short NADOpenFailed
;db  0f1h    


;;		call	init_tx_queues
;;		call	init_rx_queues

InitCompleted1:

real_mode1:

    	or	DGroup:statusFlag, STATUS_PENDING
;db  0f1h
    	call	LM_Open_Adapter
    	or	ax, ax
    	jnz	NADOpenFailed

    	mov	ax, 637 		; wait up to 35s for open
    	call	StartTime

NADOpenPendLoop:
    	test	DGroup:statusFlag, STATUS_PENDING
    	jz	NADOpenCompleted

    	call	CheckTime
    	jnc	NADOpenPendLoop

;  The open adapter request failed:  UnhookIntVector, set errmsg and return.

NADOpenFailed:
    stc
    ret

;  Status changed -- see if adapter is open; if so, set good retcode

NADOpenCompleted:
     cmp	DGroup:AS.adapter_status, OPEN
     jnz	NADOpenFailed

     clc
  	 ret

NADOpen 	endp



;=========================================================================
; NADShutDown
;=============
;	- reset the adapter and enables
;	- unhook our ISR
;
; Parameters:
;
; Returns:
;=========================================================================

NADShutDown	proc	near

;int 03
;	push	cs		; NADDisengage does a retf
;db  0f1h
	call	NADDisengage	; stop adapter, unhook ISR

	ret

NADShutDown	endp


;=========================================================================
; NADClose
;==========
;	- Disables the Tx and Rx units
;
; Parameters:	DS = CGroup
;
; Returns:
;=========================================================================
NADClose	proc	near

;db  0f1h
    push    ax
	push	ds			; save callers' DS
	mov	bp, offset DGroup:AS

   	or	DGroup:statusFlag, STATUS_PENDING
;db  0f1h
	call	LM_Close_Adapter
   	or	ax, ax
   	jnz	NADCloseFailed1

   	mov	ax, 637 		; wait up to 35s for open
   	call	StartTime

NADClosePendLoop1:
   	test	DGroup:statusFlag, STATUS_PENDING
   	jz	NADCloseCompleted1

   	call	CheckTime
   	jnc	NADClosePendLoop1


NADCloseFailed1:

	pop	ds			; restore callers' DS
    pop ax
    stc
    ret

;  Status changed -- see if adapter is open; if so, set good retcode

NADCloseCompleted1:
    cmp	DGroup:AS.adapter_status, CLOSED
    jnz	NADCloseFailed1




;;	call	LM_Disable_Adapter
;;	call	UnhookIntVector 	; restore int vector and mask PIC

	pop	ds			; restore callers' DS
    pop ax
    clc
	ret				; Return to caller

NADClose	endp


NADInitiateDiags    proc    near
    stc
    ret
NADInitiateDiags    endp



NADSetMACAddress    proc    near
;;    stc
    clc
    ret
NADSetMACAddress    endp



_TEXT	ends
;END_CODE

;====================================================================
; SPARSE data
;====================================================================
;START_SPARSE


_DATA	segment	para public

; Data variables


StoreDS dw  0

;;public  LanOption

;;LanOption   db  'LAN option: SMC EPIC adapter', CR, LF, 0

;;StrPrompt	db	'Initializing SMC EtherPower II Adapter', 0

;;Speed10		db "Media: 10Base-T", 0
;;Speed100	db "Media: 100Base-T", 0

even

AS		AdapterStructure <?>

StatusFlag	db	0

InitError	db	"Error: Unable to read configuration from adapter.", 0
msg_initerror	db	"Error initializing adapter", 0
NoNetMsg	db	'Adapter is improperly installed or not connected to the network.', 13, 10, 0

even

IFDEF	ETHERNET
eth_rx_CRC_errors	dd	0
eth_rx_too_big		dd	0
eth_rx_lost_pkts	dd	0
eth_rx_align_errors	dd	0
eth_rx_overruns 	dd	0
eth_tx_deferred 	dd	0
eth_tx_total_collisions dd	0
eth_tx_max_collisions	dd	0
eth_tx_one_collision	dd	0
eth_tx_mult_collisions	dd	0
eth_tx_ow_collision	dd	0
eth_tx_CD_heartbeat	dd	0
eth_tx_carrier_lost	dd	0
eth_tx_underruns	dd	0
eth_ring_OVW		dd	0
ENDIF

ErrorPtr	dw	0
;NicNotFound  	db	"Could not find SMC EtherPower II adapter.", 0


MaxTicks	dw	0
CurTicks	dw	0
StartTick	dw	0		; used by StartTime and CheckTime


IvtOffset	dw	0
;;OldIntVector	dd	0		; Old interrupt vector
OrgIntVector_OFF    dw  0
OrgIntVector_SEG    dw  0
irq_mask	db	0		; int enable mask

TxDoneFlag db 0


RxEDPtr dd	0
RxSize	dw	0

even

;public FragCount
FragCount	dw	?
Frag1		FragmentStructure <?>
;Frag2		FragmentStructure <?>
;Frag3		FragmentStructure <?>
;Frag4		FragmentStructure <?>
;Frag5		FragmentStructure <?>


RxFragCount	dw	?
RxFrag1		FragmentStructure <?>
RxFrag2		FragmentStructure <?>
RxFrag3		FragmentStructure <?>
RxFrag4		FragmentStructure <?>
RxFrag5		FragmentStructure <?>


public HostRAM


public MemEnd
MemEnd		db	?
;END_SPARSE
_DATA	ends

_BSS	segment

align   16
HostRAM 	db	HOST_RAM_SIZE+100 dup (?)

even

TxPacket    db  1800 dup (0)    
RxPacket    db  1800 dup (0)    

_BSS ends

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\smc9432\eeprom2.inc ===
;****************************************************************************
;
;       The information contained in this file is confidential and 
;       proprietary to Standard Microsystems Corporation.  No part
;       of this file may be reproduced or distributed, in any form
;       or by any means for any purpose, without the express written
;       permission of Standard Microsystems Corporation.
;
;	(c) COPYRIGHT 1995 Standard Microsystems Corporation,
;	ALL RIGHTS RESERVED.
;
; File:         EEPROM2.INC
;
; Description:  Defines the data format for the EEPROM of EPIC and
;               later adapters.
;
;
;*******************
; Revision History *
;*******************
;
; $Log: /Client Boot/NICS/SMC/9432/UNDI/EEPROM2.INC $
;
;   Rev 1.1   07 Jan 1997 18:19:46   cosand
;Added a value definition for the QSI 6612 PHY.
;
;   Rev 1.0   03 Oct 1995 11:25:50   ANDERSON
;Initial revision.
;
; Change: removed "bank" references from comments.
;
; Change: Added Configured Media Type and Configured Line Speed fields.
;
; Change: Replaced Interface Chip byte with an eight byte Chip Type array.
;         Added four physical layer chips.
;
; Change: Removed Integrated BIC/NIC flag.
;
; Change: Added 1.5 MBps (T1) ATM line speed, but not 100 MBps (TAXI)
;	  or 45 MBps (DS3).
;
; Initial Version taken from Mike Steiger's NEW BOARD ID FORMAT proposal.
;
;
; +!/? ***********************************************************************
;
;
; NEW BOARD ID FORMAT
;
; Starting with the EPIC-based adapters, SWENG is adopting a new board ID
; standard. The current board ID standard is outdated and does not adequately
; describe new technologies and options.
;
; ADAPTER ID STRING
;
; The adapter ID string that is displayed when the driver loads will be stored
; directly in EEPROM. This will require 12 bytes of EEPROM to be allocated.
; Storing the string on the adapter alleviates the requirement of the software
; to correlate adapter options with adapter names. With the string stored in
; EEPROM, the driver will always report the correct adapter name.
;
; OPTION DEFINITIONS
;
; The proposed EEPROM data format is described below:
;
;****************************************************************************
; EEPROM format version.
;
;        7       6       5       4       3       2       1       0
;      MAJ3    MAJ2    MAJ1    MAJ0    MIN3    MIN2    MIN1    MIN0
;
;        Data structure revision. Indicates the format of the data in the
;        structure.
;        MAJ3-0          Major version. Indicates a change in the data format.
;        MIN3-0          Minor version. Indicates that the structure has been
;                        appended.
;

; Offset
EPM_FMT		equ	000h

; Current EEPROM Format version
EPM_FMT_VER	equ	000h	; Version 0.0

; Bit definition
EPM_FMT_MAJ3	equ	080h
EPM_FMT_MAJ2	equ	040h
EPM_FMT_MAJ1	equ	020h
EPM_FMT_MAJ0	equ	010h
EPM_FMT_MIN3	equ	008h
EPM_FMT_MIN2	equ	004h
EPM_FMT_MIN1	equ	002h
EPM_FMT_MIN0	equ	001h

;****************************************************************************
; Adapter RAM size.
;
;        7       6       5       4       3       2       1       0
;       RS7     RS6     RS5     RS4     RS3     RS2     RS1     RS0
;
;        RS7-0   Size of adapter RAM in 8KB (2000h) units.
;
;

; Offset
EPM_RAM_SIZE	equ	001h

; Some common values
EPM_RAM_SIZE_128KB	equ	010h
EPM_RAM_SIZE_64KB	equ	008h
EPM_RAM_SIZE_32KB	equ	004h
EPM_RAM_SIZE_16KB	equ	002h
EPM_RAM_SIZE_8KB	equ	001h

;****************************************************************************
; Adapter RAM Window Minimum Size
;
;        7       6       5       4       3       2       1       0
;       WS7     WS6     WS5     WS4     WS3     WS2     WS1     WS0
;
;        WS7-0   Minimum size of adapter RAM window in KB.
;        
;
;
; Offset
EPM_RAM_WIN_SIZE	equ	002h

; Some common values
EPM_RAM_WIN_SIZE_16KB	equ	010h
EPM_RAM_WIN_SIZE_8KB	equ	008h

;****************************************************************************
; Adapter Bus Type
;

; Offset
EPM_BUS	equ	003h

; Value definitions
EPM_BUS_PCI_32b_33M	equ	000h	; PCI 32 bit 33 MHz
EPM_BUS_PCI_32b_66M	equ	001h	; PCI 32 bit 66 MHz
EPM_BUS_PCI_64b_66M	equ	002h	; PCI 64 bit 66 MHz
EPM_BUS_CARDBUS		equ	003h	; CardBus
EPM_BUS_PCCARD		equ	004h	; PC Card 16 Bit
;   		                5-255      available

;****************************************************************************
; Card Type
;
;        7       6       5       4       3       2       1       0
;       ETH     TKR     ATM     MOD     WIR    ISDN     ---     ---
;
;        ETH     Ethernet
;        TKR     Token Ring
;        ATM     ATM
;        MOD     Modem
;        WIR     Wireless
;        ISDN    ISDN Interface
;
; Note: bit mask.  Multiple bits may be defined; e.g. Modem and ISDN.

; Offset
EPM_TYPE	equ	004h

; Bit definition
EPM_TYPE_ETH	equ	080h		; Ethernet
EPM_TYPE_TKN	equ	040h		; Token Ring
EPM_TYPE_ATM	equ	020h		; ATM
EPM_TYPE_MOD	equ	010h		; Modem
EPM_TYPE_WIR	equ	008h		; Wireless
EPM_TYPE_ISDN	equ	004h		; ISDN Interface
EPM_TYPE_RV1	equ	002h		; available
EPM_TYPE_RV0	equ	001h		; available

;****************************************************************************
; 100 Mbps Ethernet Supported Media I
;
;        7       6       5       4       3       2       1       0
;       FXHD    FXFD     T4     TXHD    TXFD    MII     STP     UTP
;
;        FXHD    Fiber Half-Duplex
;        FXFD    Fiber Full-Duplex ?
;        T4      T4
;        TXHD    TX Half-Duplex
;        TXFD    TX Full-Duplex
;        MII     Media-Independent Interface
;        STP     Shielded Twisted Pair
;        UTP     Unshielded Twisted Pair
;

; Offset
EPM_E100MED1	equ	005h

; Bit definition
EPM_E100MED1_FXHD	equ	080h		; 100Base-Fx Half Duplex
EPM_E100MED1_FXFD	equ	040h		; 100Base-Fx Full Duplex
EPM_E100MED1_T4 	equ	020h		; 100Base-T4
EPM_E100MED1_TXHD	equ	010h		; 100Base-Tx Half Duplex
EPM_E100MED1_TXFD	equ	008h		; 100Base-Tx Full Duplex
EPM_E100MED1_MII	equ	004h		; Media-Independent Interface
EPM_E100MED1_STP	equ	002h		; Shielded Twisted Pair
EPM_E100MED1_UTP	equ	001h		; Unshielded Twisted Pair

;****************************************************************************
; 100 Mbps Ethernet Supported Media II
;
;        7       6       5       4       3       2       1       0
;       ---     ---     ---     ---     ---     ---     ---     ---       
;
; All bits available for future expansion.

; Offset
EPM_E100MED2	equ	006h

; Bit definition
EPM_E100MED2_RV7	equ	080h
EPM_E100MED2_RV6	equ	040h
EPM_E100MED2_RV5	equ	020h
EPM_E100MED2_RV4	equ	010h
EPM_E100MED2_RV3	equ	008h
EPM_E100MED2_RV2	equ	004h
EPM_E100MED2_RV1	equ	002h
EPM_E100MED2_RV0	equ	001h

;****************************************************************************
; 10 Mbps Ethernet Supported Media
;
;        7       6       5       4       3       2       1       0
;       ---     ---     FD      S10     BNC     AUI     STP     UTP
;
;        FD      Full Duplex
;        S10     Starlan-10
;        BNC     Thinnet Coax
;        AUI     Attachment Unit Interface
;        STP     Shielded Twisted Pair
;        UTP     Unshielded Twisted Pair
;

; Offset
EPM_E10MED	equ	007h

; Bit definition
EPM_E10MED_RV7	equ	080h		; available
EPM_E10MED_RV6	equ	040h		; available
EPM_E10MED_FD	equ	020h		; Full Duplex
EPM_E10MED_S10	equ	010h		; Starlan-10
EPM_E10MED_BNC	equ	008h		; Thinnet Coax
EPM_E10MED_AUI	equ	004h		; Attachment Unit Interface
EPM_E10MED_STP	equ	002h		; Shielded Twisted Pair
EPM_E10MED_UTP	equ	001h		; Unshielded Twisted Pair

;****************************************************************************
; Token Ring Supported Media
;
;        7       6       5       4       3       2       1       0
;       ---     ---     ---     ---     ---     STP     UTP     DTR
;
;        STP     Shielded Twisted Pair
;        UTP     Unshielded Twisted Pair
;        DTR     Dedicated Token Ring
;

; Offset
EPM_TKNMED	equ	008h

; Bit definition
EPM_TKNMED_RV7	equ	080h		; available
EPM_TKNMED_RV6	equ	040h		; available
EPM_TKNMED_RV5	equ	020h		; available
EPM_TKNMED_RV4	equ	010h		; available
EPM_TKNMED_RV3	equ	008h		; available
EPM_TKNMED_STP	equ	004h		; Shielded Twisted Pair
EPM_TKNMED_UTP	equ	002h		; Unshielded Twisted Pair
EPM_TKNMED_DTR	equ	001h		; Dedicated Token Ring

;****************************************************************************
; ATM Supported Media
;
;        7       6       5       4       3       2       1       0
;       ---     ---     ---     ---     ---     ---     UTP     FIB
;
;        UTP     Unshielded Twisted Pair
;        FIB     Fiber
;
;

; Offset
EPM_ATMMED	equ	009h

; Bit definition
EPM_ATMMED_RV7	equ	080h		; available
EPM_ATMMED_RV6	equ	040h		; available
EPM_ATMMED_RV5	equ	020h		; available
EPM_ATMMED_RV4	equ	010h		; available
EPM_ATMMED_RV3	equ	008h		; available
EPM_ATMMED_RV2	equ	004h		; available
EPM_ATMMED_UTP	equ	002h		; Unshielded Twisted Pair
EPM_ATMMED_FIB	equ	001h		; Fiber

;****************************************************************************
; Modem Supported Rates I
;
;        7       6       5       4       3       2       1       0
;       ---     ---     ---     ---     V42     V34     V32     FAX
;
;        V42     V.42BIS
;        V34     V.34 (28.8K)
;        V32     V.32 (14.4K)
;        FAX     Fax Support
;

; Offset
EPM_MODSPD1	equ	00Ah

; Bit definition
EPM_MODSPD1_RV7	equ	080h		; available
EPM_MODSPD1_RV6	equ	040h		; available
EPM_MODSPD1_RV5	equ	020h		; available
EPM_MODSPD1_RV4	equ	010h		; available
EPM_MODSPD1_RV3	equ	008h		; available
EPM_MODSPD1_RV2	equ	004h		; available
EPM_MODSPD1_RV1	equ	002h		; available
EPM_MODSPD1_RV0	equ	001h		; available

;****************************************************************************
; Modem Supported Rates II
;
;        7       6       5       4       3       2       1       0
;       ---     ---     ---     ---     ---     ---     ---     ---    
;
;

; Offset
EPM_MODSPD2	equ	00Bh

; Bit definition
EPM_MODSPD2_RV7	equ	080h		; available
EPM_MODSPD2_RV6	equ	040h		; available
EPM_MODSPD2_RV5	equ	020h		; available
EPM_MODSPD2_RV4	equ	010h		; available
EPM_MODSPD2_RV3	equ	008h		; available
EPM_MODSPD2_RV2	equ	004h		; available
EPM_MODSPD2_RV1	equ	002h		; available
EPM_MODSPD2_RV0	equ	001h		; available

;****************************************************************************
; Ethernet Supported Rates
;
;        7       6       5       4       3       2       1       0
;       ---     ---     ---     ---     ---     ---    BPS100   BPS10
;
;        BPS100  100 Mbps
;        BPS10   10 Mbps
;

; Offset
EPM_ETHSPD	equ	00Ch

; Bit definition
EPM_ETHSPD_RV7	equ	080h		; available
EPM_ETHSPD_RV6	equ	040h		; available
EPM_ETHSPD_RV5	equ	020h		; available
EPM_ETHSPD_RV4	equ	010h		; available
EPM_ETHSPD_RV3	equ	008h		; available
EPM_ETHSPD_RV2	equ	004h		; available
EPM_ETHSPD_100	equ	002h		; 100 MBps
EPM_ETHSPD_10	equ	001h		; 10 MBps

;****************************************************************************
; Token Ring Supported Rates
;
;        7       6       5       4       3       2       1       0
;       ---     ---     ---     ---     ---     ---    BPS16    BPS4
;
;        BPS16   16 Mbps
;        BPS4     4 Mbps
;

; Offset
EPM_TKNSPD	equ	00Dh

; Bit definition
EPM_TKNSPD_RV7	equ	080h		; available
EPM_TKNSPD_RV6	equ	040h		; available
EPM_TKNSPD_RV5	equ	020h		; available
EPM_TKNSPD_RV4	equ	010h		; available
EPM_TKNSPD_RV3	equ	008h		; available
EPM_TKNSPD_RV2	equ	004h		; available
EPM_TKNSPD_16	equ	002h		; 16 MBps
EPM_TKNSPD_4	equ	001h		; 4 MBps

;****************************************************************************
; ATM Supported Rates
;
;        7       6       5       4       3       2       1       0
;       ---     ---     ---    BPS622  BPS155  BPS51   BPS25   BPS2
;

; Offset
EPM_ATMSPD	equ	00Eh

; Bit definition
EPM_ATMSPD_RV7	equ	080h		; available
EPM_ATMSPD_RV6	equ	040h		; available
EPM_ATMSPD_RV5	equ	020h		; available
EPM_ATMSPD_622	equ	010h		; 622 MBps
EPM_ATMSPD_155	equ	008h		; 155 MBps (STS-3c)
EPM_ATMSPD_51	equ	004h		; 51.84 MBps
EPM_ATMSPD_25	equ	002h		; 25.6 MBps
EPM_ATMSPD_2	equ	001h		; 1.5/2 MBps (T-1/E-1)

;****************************************************************************
; Adapter Architecture
;
;        7       6       5       4       3       2       1       0
;       ---     ---     ---     ---     ---     INT     MCH     MPT 
;
;        INT     Intelligent Card
;        MCH     Multi-Channel Card
;        MPT     Multi-Port Card
;

; Offset
EPM_ARCH	equ	00Fh

; Bit definition
EPM_ARCH_RV7	equ	080h
EPM_ARCH_RV6	equ	040h
EPM_ARCH_RV5	equ	020h
EPM_ARCH_RV4	equ	010h
EPM_ARCH_RV3	equ	008h
EPM_ARCH_INT	equ	004h		; Intelligent Card
EPM_ARCH_MCH	equ	002h		; Multi-Channel Card
EPM_ARCH_MPT	equ	001h		; Multi-Port Card

;****************************************************************************
; Chip Type Array
;
; each byte defines one chip installed on the adapter.
; eight chips may be defined for each adapter.
;

; Offset
EPM_CHIP7	equ	017h
EPM_CHIP6	equ	016h
EPM_CHIP5	equ	015h
EPM_CHIP4	equ	014h
EPM_CHIP3	equ	013h
EPM_CHIP2	equ	012h
EPM_CHIP1	equ	011h
EPM_CHIP0	equ	010h

; Value definition
EPM_CHIP_NONE	equ	000h	; empty array entry
EPM_CHIP_EPIC	equ	001h	; SMC 100Base-TX NIC & integrated PCI BIC
EPM_CHIP_EPIC_C	equ	002h	; SMC 100Base-T4 NIC & integrated PCI BIC
EPM_CHIP_N83840	equ	003h	; National 100Base-TX Physical Layer
EPM_CHIP_CY971	equ	004h	; Cypress 100Base-T4 Physical Layer
EPM_CHIP_SMC111	equ	005h	; SMC 100Base-TX Physical Layer
EPM_CHIP_SMC140	equ	006h	; SMC 100Base-T4 Physical Layer
EPM_CHIP_QS6612 equ     007h    ; QSI 100Base-TX Physical Layer
EPM_CHIP_RSV	equ	0FFh	; reserved for future expansion

;****************************************************************************
; Adapter name string.
;
;        12 byte adapter name string.
;        pad with spaces.
;        no NULL termination.
;
;        for example:
;        	EPM_NAME[0] = 'S'
;        	EPM_NAME[1] = 'M'
;        	EPM_NAME[2] = 'C'
;        	EPM_NAME[3] = '9
;        	EPM_NAME[4] = '4'
;        	EPM_NAME[5] = '3'
;        	EPM_NAME[6] = '2'
;        	EPM_NAME[7] = 'D'
;        	EPM_NAME[8] = 'M'
;        	EPM_NAME[9] = 'T'
;        	EPM_NAME[A] = ' '
;        	EPM_NAME[B] = ' '
;

; Offset
EPM_NAME	equ	018h	; adapter name offset 18 - 23

;****************************************************************************
; Reserved for Lanworks I.
;

; Offset
EPM_LANWORKS1	equ	024h

;****************************************************************************
; Reserved for Lanworks II.
;

; Offset
EPM_LANWORKS2	equ	025h

;****************************************************************************
; Wireless Info.
;

; Offset
EPM_WIR		equ	026h

;****************************************************************************
; ISDN Info.
;

; Offset
EPM_ISDN	equ	027h

;****************************************************************************
; Media Type2 -- configured default media word 
;

; Offset
EPM_MEDIA_TYPE2	equ	028h	; offsets 28 - 29

;****************************************************************************
; Line Speed -- configured default line speed word 
;

; Offset
EPM_LINE_SPEED	equ	02Ah	; offsets 2A - 2B
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\smc9432\pci.inc ===
;
; Modifications:   $Header: /Client Boot/NICS/3Com/3C90xB/UNDI/PCI.INC 2     22/07/98 8:30p John Lobraico $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;

ifndef _PCI_INC
_PCI_INC = 1

; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
; Structures and records
;


; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
; Equates
;

PCI_IRQ_LINE	equ	3Ch


; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
; Macros
;

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; PCI_READ_BYTE
;	Read one byte from PCI configuration space.
;
; passed:
;	BH := PCI bus number
;	BL := PCI device (bits 7-3) & function (bits 2-0) numbers
;	DI := Offset into PCI configuration space (00h to FFh)
;
; returns:
;	SUCCESS
;		CY := 0
;		AH := 0
;		CL := Byte read from PCI configuration space
;
;	FAILURE
;		CY := 1
;		AH := 81h (Unsupported function)
;		AH := 87h (Bad PCI register number)
;
PCI_READ_BYTE macro
	mov	ax, 0B108h
	int	1Ah
	endm

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; PCI_READ_WORD
;	Read one word from PCI configuration space.
;
; passed:
;	BH := PCI bus number
;	BL := PCI device (bits 7-3) & function (bits 2-0) numbers
;	DI := Offset into PCI configuration space (00h to FEh)
;
; returns:
;	SUCCESS
;		CY := 0
;		AH := 0
;		CX := Word read from PCI configuration space
;
;	FAILURE
;		CY := 1
;		AH := 81h (Unsupported function)
;		AH := 87h (Bad PCI register number)
;
PCI_READ_WORD macro
	mov	ax, 0B109h
	int	1Ah
	endm

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; PCI_READ_DWORD
;	Read one dword from PCI configuration space.
;
; passed:
;	BH := PCI bus number
;	BL := PCI device (bits 7-3) & function (bits 2-0) numbers
;	DI := Offset into PCI configuration space (00h to FCh)
;
; returns:
;	SUCCESS
;		CY := 0
;		AH := 0
;		ECX := Dword read from PCI configuration space
;
;	FAILURE
;		CY := 1
;		AH := 81h (Unsupported function)
;		AH := 87h (Bad PCI register number)
;
PCI_READ_DWORD macro
	mov	ax, 0B10Ah
	int	1Ah
	endm


endif ;_PCI_INC

; EOF - $Workfile: PCI.INC $
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\smc9432\lm9432.inc ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       ETH_PCI.INC    (C) Copyright 1995 Standard Microsystems Corp.
;                       All rights reserved.
;
;       LMI lower routine include file for 
;       Ethernet 9432 PCI adapter.
;
;       Author: najay
;
; Revision Log:
; $Log: /Client Boot/NICS/SMC/9432/UNDI/LM9432.INC $
;  
;     Rev 1.3   21 Feb 1996 12:05:08   RHODES
;  Added NDIS3X def to support ML assembly for use with C UMAC
;  
;     Rev 1.2   25 Sep 1995 16:34:32   NAJARIAN
;  fixed pass dependent defines for tasm builds
;  
;     Rev 1.1   17 May 1995 15:20:20   NAJARIAN
;  added 386 support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;
; PCI Defines (pulled from PCI bios spec v2.1 (26Aug94)
;

; function list

PCI_FUNCTION_ID         equ     0b1h
PCI_BIOS_PRESENT        equ     01h
FIND_PCI_DEVICE         equ     02h
FIND_PCI_CLASS_CODE     equ     03h
GENERATE_SPECIAL_CYCLE  equ     06h
PCI_READ_CONFIG_BYTE    equ     08h
PCI_READ_CONFIG_WORD    equ     09h
PCI_READ_CONFIG_DWORD   equ     0ah
PCI_WRITE_CONFIG_BYTE   equ     0bh
PCI_WRITE_CONFIG_WORD   equ     0ch
PCI_WRITE_CONFIG_DWORD  equ     0dh
GET_IRQ_ROUTING_OPTIONS equ     0eh
SET_PCI_IRQ             equ     0fh


PCI_SUCCESSFUL          equ     00h
PCI_FUNC_NOT_SUPPORTED  equ     81h
PCI_BAD_VENDOR_ID       equ     83h
PCI_DEVICE_NOT_FOUND    equ     86h
PCI_BAD_REGISTER_NUMBER equ     87h
PCI_SET_FAILED          equ     88h
PCI_BUFFER_TOO_SMALL    equ     89h

; lm9432 macros

ifdef	CODE_386
ifndef NDIS3X
; ifndef	pAS
  pAS	equ    <[ebp]>		; Pointer to adapter structure
  epAS	equ    <[ebp]>
; endif

 pASi	equ    <[ebp+esi]>	; Pointer to adapter structure + index

; ifndef	pDS
  pDS	equ    <[esi]>		; Pointer to data buffer structure
; endif

 pDST	equ    <[edi]>
 pSRC	equ    <[esi]>

 RWORD	equ	dword

 rax	equ    <EAX>
 rbx	equ    <EBX>
 rcx	equ    <ECX>
 rdx	equ    <EDX>
 rdi	equ    <EDI>
 rsi	equ    <ESI>
 rbp	equ    <EBP>
 rsp	equ    <ESP>

else

; ifndef	pAS
  pAS	equ    [ebp]		; Pointer to adapter structure
  epAS	equ    [ebp]
; endif

 pASi	equ    [ebp+esi]	; Pointer to adapter structure + index

; ifndef	pDS
  pDS	equ    [esi]		; Pointer to data buffer structure
; endif

 pDST	equ    [edi]
 pSRC	equ    [esi]

 RWORD	equ	dword

 rax	equ    EAX
 rbx	equ    EBX
 rcx	equ    ECX
 rdx	equ    EDX
 rdi	equ    EDI
 rsi	equ    ESI
 rbp	equ    EBP
 rsp	equ    ESP
endif

else

; ifndef	pAS
  pAS	equ	ds:[bp]		; Pointer to adapter structure
  epAS	equ	es:[bp]
; endif

 pASi	equ	ds:[bp+si]	; Pointer to adapter structure + index

; ifndef	pDS
  pDS	equ	es:[si]		; Pointer to data buffer structure
; endif

 pDST	equ	es:[di]
 pSRC	equ	ds:[si]

 RWORD	equ	word
 
 rax	equ	AX
 rbx	equ	BX
 rcx	equ	CX
 rdx	equ	DX
 rdi	equ	DI
 rsi	equ	SI
 rbp	equ	BP
 rsp	equ	SP

endif



ifdef   COUNTER16
errptr  equ     <word ptr>
errAX   equ     <ax>
else
errptr  equ     <dword ptr>
errAX   equ     <eax>
endif

; PUSH_ES, POP_ES,
; PUSH_DS POP_DS
; PUSH_CS
; do nothing for CODE_386, pushes/pops es & ds otherwise.

PUSH_ES	MACRO
 ifndef	CODE_386
	push	es
 endif
ENDM

PUSH_DS	MACRO
 ifndef	CODE_386
	push	ds
 endif
ENDM

PUSH_CS	MACRO
 ifndef	CODE_386
	push	cs
 endif
ENDM

POP_DS	MACRO
 ifndef	CODE_386
	pop	ds
 endif
ENDM

POP_ES	MACRO
 ifndef	CODE_386
	pop	es
 endif
ENDM

;-----------------
; MACRO - PUSHALL
;-----------------

PUSHALL	MACRO

        push ds
        push es
        push si
        push di
        push dx
        push cx
        push bx
        ENDM

;----------------
; MACRO - POPALL
;----------------

POPALL 	MACRO

        pop bx
        pop cx
        pop dx
        pop di
        pop si
        pop es
        pop ds
        ENDM

;--------------------------------
; ASM Procedure Start Definition
;--------------------------------
		
ASM_PCI_PROC	MACRO	X

IFDEF  EZSTART

	IFDEF	CODE_386
		EVEN
		PUBLIC	PCI_&X
	PROC	NEAR
	ELSE
	IFDEF	LARGE
		EVEN
		PUBLIC	PCI_&X
PCI_&X	PROC	FAR
	ELSE
		EVEN
		PUBLIC	PCI_&X
PCI_&X	PROC	NEAR
	
	ENDIF
	ENDIF
ELSE
	IFDEF   CODE_386
		EVEN
		PUBLIC  X
X		PROC    NEAR
	ELSE
	IFDEF   LARGE
		EVEN
		PUBLIC  X
X               PROC    FAR
	ELSE
		EVEN
		PUBLIC  X
X               PROC    NEAR
	
	ENDIF
	ENDIF
ENDIF
		ENDM


;--------------------------------
; ASM Procedure Start Definition
;--------------------------------
		
ASM_PROC	MACRO	ProcNameStub

	IFDEF	CODE_386
		EVEN
		PUBLIC	ProcNameStub
ProcNameStub	PROC	NEAR
	ELSE
	IFDEF	LARGE
		EVEN
		PUBLIC	ProcNameStub
ProcNameStub	PROC	FAR
	ELSE
		EVEN
		PUBLIC	ProcNameStub
ProcNameStub	PROC	NEAR
	
	ENDIF
	ENDIF
		ENDM

;------------------------------
; ASM Procedure End Definition
;------------------------------

ASM_PCI_PROC_END	MACRO	X


IFDEF  EZSTART
PCI_&X          ENDP
ELSE
X               ENDP
ENDIF

		ENDM

;------------------------------
; ASM Procedure End Definition
;------------------------------

ASM_PROC_END	MACRO	ProcNameStub

ProcNameStub		ENDP

		ENDM

;------------------------------
; ASM Procedure call Definition
;------------------------------
ASM_PCI_CALL	MACRO	X

IFDEF   EZSTART
	IFDEF	CODE_386
	call	PCI_&X
	ELSE
	IFDEF	LARGE
	call	far ptr	PCI_&X
	ELSE
		EVEN
	call	near ptr PCI_&X
	ENDIF
	ENDIF
ELSE
	IFDEF	CODE_386
	call	X
	ELSE
	IFDEF	LARGE
	call	far ptr	X
	ELSE
		EVEN
	call	near ptr X
	ENDIF
	ENDIF
ENDIF
		ENDM

;------------------------------
; ASM Procedure call Definition
;------------------------------
ASM_CALL	MACRO	ProcCallStub

	IFDEF	CODE_386
	call	ProcCallStub
	ELSE
	IFDEF	LARGE
	call	far ptr	ProcCallStub
	ELSE
		EVEN
	call	near ptr ProcCallStub
	ENDIF
	ENDIF
		ENDM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\smc9432\epic100.inc ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       EPIC100.INC    (C) Copyright 1995 Standard Microsystems Corp.
;                       All rights reserved.
;
;       Definitions for the EPIC/100 chip
;
;       Author: najay
;
; Revision Log:
; $Log: /Client Boot/NICS/SMC/9432/UNDI/EPIC100.INC $
;  
;     Rev 1.16   24 Nov 1997 16:50:18   cosand
;  Moved the definition for the PCI Subsystem ID for 9432BTX to lmstruct.inc.
;  
;     Rev 1.15   04 Nov 1997 16:39:44   cosand
;  Defined EPC_SSID_9432BTX, the PCI Subsystem ID for 9432BTX.
;  Defined the bit PHY_LINK_DOWN_INT for the register PHY_INT_SOURCE_REG.
;  
;     Rev 1.14   11 Sep 1997 13:36:06   cosand
;  Defined EPC_ID_EPIC_C for the EPC_DEVICE_ID register.
;  Defined the organizationally unique identifiers (OUI)
;  for National, TDK, and QSI.
;  
;     Rev 1.13   05 Aug 1997 12:20:10   cosand
;  Changed the length of the bit definitions for the Non-Volatile Control
;  register to 32 bits.
;  
;     Rev 1.12   26 Mar 1997 15:04:34   ANDERS
;  For the EPC_GEN_CONTROL register defined GC_RD_MULT = 00000400h &
;  GC_RD_LINE = 00000800h.
;  
;     Rev 1.11   26 Feb 1997 17:27:40   cosand
;  Added a definition for the PBLCNT register.
;  
;     Rev 1.10   07 Jan 1997 17:36:52   cosand
;  Added the compact definition GP2 for INT_PHY_EVENT.
;  Added Mercury PHY register and bit definitions.
;  
;     Rev 1.9   18 Dec 1996 08:50:34   ANDERS
;  redefined I/O port BCh to EPC_PREEMP_RX_INT
;  
;     Rev 1.8.1.0   16 Oct 1996 09:50:54   ANDERS
;  DEBUG release: add definitions for Preemptive Int & Interpacket Gap
;  processing
;  
;     Rev 1.8   21 Aug 1996 13:50:42   STEIGER
;  Eliminated the "XE" definition requirement. This release and all
;  future releases will support Epic XE & later only.
;  
;     Rev 1.7   21 Aug 1996 11:10:18   STEIGER
;  Added changes for EPIC XE. "XE" must be defined to enable XE register
;  and bit definitions.
;  
;     Rev 1.6   03 Oct 1995 16:22:40   ANDERSON
;  
;     Rev 1.5   03 Oct 1995 16:13:32   ANDERSON
; Change: added EPC_EEPROM_SW_OFFSET.
;  
;     Rev 1.4   13 Sep 1995 14:52:46   ANDERSON
;
; Change: add bit definitions for TRANSMIT_CONTROL mode bits:
;       TC_NORMAL_MODE         half duplex operation, no loopback
;       TC_INTERNAL_LOOPBACK   do not send data to PHY chips
;       TC_EXTERNAL_LOOPBACK   must put PHY chip in loopback mode
;       TC_FULL_DUPLEX         full duplex operation, no loopback
; 
;     Rev 1.3   29 Aug 1995 17:51:24   CHAN_M
;  Added additional PHY layer register & bit definitions.
;  
;     Rev 1.2   17 Jul 1995 20:20:14   CHAN_M
;  Added some physical layer register & bit definitions.
;  
;     Rev 1.1   19 Jun 1995 17:43:20   CHAN_M
;  added more compact bit definitions for the interrupt status bits.
;  
;     Rev 1.0   11 May 1995 14:20:32   NAJARIAN
;  Initial revision.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Mapping for EPIC/100 configuration registers

EPC_VENDOR_ID           equ     0h
EPC_ID_SMC              equ     000010b8h

EPC_DEVICE_ID           equ     2h
EPC_ID_EPIC_100         equ     0005h
EPC_ID_EPIC_C           equ     0006h

EPC_PCI_COMMAND         equ     4h
PCIC_FAST_BTOB_ENABLE   equ     0200h
PCIC_SERR_ENABLE        equ     0100h
PCIC_WAIT_CYCLE         equ     0080h
PCIC_PARITY_ENABLE      equ     0040h
PCIC_VGA_SNOOP          equ     0020h
PCIC_MEM_WRITE_INV      equ     0010h
PCIC_SPECIAL_CYCLES     equ     0008h
PCIC_BUSMASTER_ENABLE   equ     0004h
PCIC_MEM_SPACE_ENABLE   equ     0002h
PCIC_IO_SPACE_ENABLE    equ     0001h

EPC_PCI_STATUS          equ     6h
PCIS_PARITY_ERR         equ     8000h
PCIS_SYSTEM_ERR         equ     4000h
PCIS_MASTER_ABORT       equ     2000h
PCIS_TARGET_ABORT       equ     1000h 
PCIS_SIG_TARGET_ABORT   equ     0800h
PCIS_DEVSEL_TIMING      equ     0600h 
PCIS_DATA_PARITY        equ     0100h
PCIS_FAST_BTOB          equ     0080h
PCIS_UDF_SUPPORT        equ     0040h
PCIS_66MHZ_SUPPORT      equ     0020h


EPC_REV_ID              equ     8h
EPC_CLASS_CODE          equ     08h
CC_BASE_CLASS           equ     0ff000000h
CC_SUB_CLASS            equ     00ff0000h
CC_PROG_INTERFACE       equ     0000ff00h
CC_REV_ID               equ     000000ffh

EPC_LAT_TIMER           equ     0dh

EPC_HDR_TYPE            equ     0eh
HT_MULTI_FUNC           equ     80h
HT_TYPE                 equ     7fh

EPC_IO_ADDR             equ     10h
IO_BASE_ADDR            equ     0fffffff0h
IO_SPACE_IND            equ     00000001h

EPC_MEM_ADDR            equ     14h
MEM_BASE_ADDR           equ     0fffff000h
MEM_PREFETCHABLE        equ     000000008h
MEM_TYPE                equ     000000006h
MEM_SPACE_IND           equ     000000001h

EPC_CIS_PTR             equ     28h
CIS_ADDR_SPACE          equ     70000000h
CIS_ROM_IMAGE           equ     0f000000h
CIS_OFFSET              equ     00ffffffh

EPC_SUBSYSTEM_VENDOR    equ     2ch

EPC_SYSTEM_ID           equ     2eh

EPC_ROM_ADDR            equ     30h
ROM_BASE_ADDR           equ     0ffff0000h
ROM_ADDR_DECODE_ENABLE  equ     000000001h

EPC_INT_LINE            equ     3ch
EPC_INT_PIN             equ     3dh
EPC_MIN_GNT             equ     3eh
EPC_MAX_LAT             equ     3fh

EPC_EEPROM_SW_OFFSET    equ     40h   ; start of software-defined eeprom data

;
; EPIC/100 Register descriptions
;

EPC_COMMAND             equ     00h
CMD_RXQUEUED_ALT        equ     0800h
CMD_TXQUEUED_ALT        equ     0400h
CMD_TXUGO               equ     0080h
CMD_STOP_RDMA           equ     0040h
CMD_STOP_TDMA           equ     0020h
CMD_NEXTFRAME           equ     0010h
CMD_RXQUEUED            equ     0008h
CMD_TXQUEUED            equ     0004h
CMD_START_RX            equ     0002h
CMD_STOP_RX             equ     0001h        

EPC_INT_STATUS          equ     04h
EPC_INT_MASK            equ     08h

; the following interrupts are status only

INT_RCV_COPY_THRESH_STATUS equ  00400000h
INT_RCV_BUFF_EMPTY      equ     00200000h
INT_XMIT_COPY_ACTIVE    equ     00100000h
INT_RCV_COPY_ACTIVE     equ     00080000h
INT_XMIT_IDLE           equ     00040000h
INT_RCV_IDLE            equ     00020000h
INT_ACTIVE              equ     00010000h

;ifdef   XE      ; EPIC Rev XE changes

 INT_RCV_STATUS_VALID    equ     00800000h

 ; The following 4 statii are OR'd together and generate an
 ; interrupt on INT_FATAL below...

 INT_PCI_TARGET_ABORT    equ     08000000h
 INT_PCI_MASTER_ABORT    equ     04000000h
 INT_PCI_ADDR_PARITY_ERR equ     02000000h
 INT_PCI_DATA_PARITY_ERR equ     01000000h

; the following interrupts will generate an interrupt
; (and are valid as interrupt masks)

 INT_PHY_EVENT           equ     00008000h
 INT_FATAL               equ     00001000h
 INT_RCV_COPY_THRESH     equ     00000800h
 INT_RCV_PREEMPT         equ     00000400h

;else
;
; INT_RCV_STATUS_VALID    equ     00008000h
; INT_PCI_TARGET_ABORT    equ     00004000h
; INT_PCI_MASTER_ABORT    equ     00002000h
; INT_PCI_ADDR_PARITY_ERR equ     00001000h
; INT_PCI_DATA_PARITY_ERR equ     00000800h
; INT_RCV_COPY_THRESH     equ     00000400h
;
;endif

INT_CNTR_OVERFLOW       equ     00000200h
INT_XMIT_UNDERRUN       equ     00000100h
INT_XMIT_QUEUE_EMPTY    equ     00000080h
INT_XMIT_CHAIN_DONE     equ     00000040h
INT_XMIT_DONE           equ     00000020h
INT_RCV_ERR             equ     00000010h
INT_RCV_BUFF_OVERFLOW   equ     00000008h
INT_RCV_QUEUE_EMPTY     equ     00000004h
INT_HEADER_COPY_DONE    equ     00000002h
INT_RCV_COPY_DONE       equ     00000001h

; more compact definitions

PTA     equ     INT_PCI_MASTER_ABORT
PMA     equ     INT_PCI_MASTER_ABORT
APE     equ     INT_PCI_ADDR_PARITY_ERR     
DPE     equ     INT_PCI_DATA_PARITY_ERR
GP2     equ     INT_PHY_EVENT
RCT     equ     INT_RCV_COPY_THRESH
RXP     equ     INT_RCV_PREEMPT
CNT     equ     INT_CNTR_OVERFLOW
TXU     equ     INT_XMIT_UNDERRUN
TQE     equ     INT_XMIT_QUEUE_EMPTY
TCC     equ     INT_XMIT_CHAIN_DONE
TXC     equ     INT_XMIT_DONE
RXE     equ     INT_RCV_ERR
OVR     equ     INT_RCV_BUFF_OVERFLOW
RQE     equ     INT_RCV_QUEUE_EMPTY
HCC     equ     INT_HEADER_COPY_DONE
RCC     equ     INT_RCV_COPY_DONE

EPC_GEN_CONTROL         equ     0ch
GC_HARD_RESET           equ     00004000h
GC_SOFT_BITS            equ     00003000h
GC_RD_MULT              equ     00000400h
GC_RD_LINE              equ     00000800h
GC_RCV_FIFO_THRESH      equ     00000300h
GC_RCV_FIFO_LOW         equ     00000000h
GC_RCV_FIFO_MID         equ     00000100h
GC_RCV_FIFO_HIGH        equ     00000200h
GC_XMIT_DMA_PRIORITY    equ     00000080h
GC_RECV_DMA_PRIORITY    equ     00000040h
GC_BIG_ENDIAN           equ     00000020h
GC_ONECOPY              equ     00000010h
GC_POWERDOWN            equ     00000008h
GC_SW_INT               equ     00000004h
GC_INT_ENABLE           equ     00000002h
GC_SOFT_RESET           equ     00000001h

EPC_NV_CONTROL          equ     10h

NVC_IPG_DELAY_SHCNT     equ     7        ; Bit position of LSB, use to shift value
					 ; into position. (XE ONLY)
NVC_IPG_DELAY_MASK      equ     00000780h
NVC_CB_MODE             equ     00000040h ; When set, Epic is in a Cardbus slot. (XE ONLY)
NVC_GPIO2               equ     00000020h
NVC_GPIO1               equ     00000010h
NVC_GPOE2               equ     00000008h
NVC_GPOE1               equ     00000004h
NVC_CLOCK_RUN           equ     00000002h
NVC_MAP_CONTROL         equ     00000001h

EPC_EEPROM_CONTROL      equ     14h
EEC_SIZE                equ     00000040h
EEC_READY               equ     00000020h
EEC_DATAOUT             equ     00000010h
EEC_DATAIN              equ     00000008h
EEC_CLOCK               equ     00000004h
EEC_CHIP_SELECT         equ     00000002h
EEC_ENABLE              equ     00000001h

EPC_PBLCNT              equ     18h

EPC_TEST                equ     1ch
TEST_BYPASS_ADDR        equ     00000080h
TEST_FORCE_DATALEN      equ     00000040h
TEST_COUNTERS           equ     00000020h
TEST_FIFO_LEVELS        equ     00000010h
TEST_CLOCK              equ     00000008h
TEST_PARITY_IN          equ     00000004h
TEST_PARITY_OUT         equ     00000002h
TEST_REGISTER           equ     00000001h

EPC_CRC_ERR_CNT         equ     20h

EPC_FA_ERR_CNT          equ     24h

EPC_MISSED_PKT_CNT      equ     28h

EPC_RECEIVE_FIFO        equ     2ch

EPC_MII_CONTROL         equ     30h
MII_PHYS_ADDR           equ     0003e00h
MII_REG_ADDR            equ     00001f0h
MII_RESPONDER           equ     0000008h
MII_WRITE               equ     0000002h
MII_READ                equ     0000001h

EPC_MII_DATA            equ     34h
PHY_BMC_REG             equ     0       ;Basic Mode Control Register

PHY_AN_ENABLE           equ     1000h
PHY_RESTART_AN          equ     200h
PHY_SPEED_SELECT_100    equ     2000h
PHY_FULL_DUPLEX         equ     100h
PHY_ISOLATE             equ     400h
PHY_LOOPBACK            equ     4000h

PHY_BMS_REG             equ     1       ;Basic Mode Status Register

PHY_AN_COMPLETE         equ     20h
PHY_LINK_STATUS         equ     4

PHY_ID_REG1             equ     2       ;Identifier register 1

PHY_ID_REG2             equ     3       ;Identifier register 2

PHY_NATIONAL_OUI        equ     080017h     ;Organizationally unique identifier
PHY_TDK_OUI             equ     00c039h     ;Organizationally unique identifier
PHY_QSI_OUI             equ     006051h     ;Organizationally unique identifier

PHY_ANLPA_REG           equ     5       ;Auto-Negotiation Link Partner Ability Reg.

PHY_100_BASE_T4         equ     200h
PHY_100_BASE_TX_FD      equ     100h
PHY_100_BASE_TX_HD      equ     80h
PHY_10_BASE_T_FD        equ     40h
PHY_10_BASE_T_HD        equ     20h

PHY_ANE_REG             equ     6       ;Auto-Negotiation Expansion Reg.

PHY_LP_AN_ABLE          equ     1

PHY_INT_SOURCE_REG      equ     29      ;Interrupt Source Register

PHY_LINK_DOWN_INT       equ     10h
PHY_AN_COMPLETE_INT     equ     40h

PHY_INT_MASK_REG        equ     30      ;Interrupt Mask Register

PHY_INT_MODE            equ     8000h

EPC_MII_CONFIG          equ     38h
MII_ALT_DIR             equ     0000080h
MII_ALT_DATA            equ     0000040h
MII_ALT_CLOCK           equ     0000020h
MII_ENABLE_SMI          equ     0000010h
MII_PHY_PRESENT         equ     0000008h
MII_694_LINK_STATUS     equ     0000004h
MII_ENABLE_694          equ     0000002h
MII_SERIAL_MODE_ENABLE  equ     0000001h

EPC_INTERPACKET_GAP     equ     3ch
IPG_INTERFRAME_SPACING  equ     0007f00h
IPG_GAP_TIME            equ     00000ffh        

EPC_LANADDR1            equ     40h
EPC_LANADDR2            equ     44h
EPC_LANADDR3            equ     48h

EPC_BOARD_ID            equ     4ch

EPC_MC_HASH_TABLE1      equ     50h
EPC_MC_HASH_TABLE2      equ     54h
EPC_MC_HASH_TABLE3      equ     58h
EPC_MC_HASH_TABLE4      equ     5ch

EPC_RECEIVE_CONTROL     equ     60h
RC_BUFFER_SIZE          equ     0000300h
RC_EARLY_RECEIVE_ENABLE equ     0000080h
RC_MONITOR_MODE         equ     0000040h
RC_PROMISCUOUS_MODE     equ     0000020h
RC_RCV_INVERSE          equ     0000010h
RC_RCV_MULTICAST        equ     0000008h
RC_RCV_BROADCAST        equ     0000004h
RC_RCV_RUNT             equ     0000002h
RC_RCV_ERRORED          equ     0000001h

EPC_RECEIVE_STATUS      equ     64h
RS_RECEIVER_DISABLED    equ     0000040h
RS_BROADCAST_ADDR       equ     0000020h
RS_MULTICAST_ADDR       equ     0000010h
RS_MISSED_PKT           equ     0000008h
RS_CRC_ERR              equ     0000004h
RS_FA_ERR               equ     0000002h
RS_RCV_OK               equ     0000001h

EPC_RECEIVE_BYTE_CNT    equ     68h

EPC_RECEIVE_TEST        equ     6ch
RT_RECEIVE_FIFO_LEVEL   equ     0007c00h
RT_RUNT_STATUS          equ     0000080h
RT_TEST_RDMA2           equ     0000040h
RT_TEST_RDMA1           equ     0000020h
RT_INT_BUFF_DISABLE     equ     0000010h
RT_TEST_COUNTERS        equ     0000008h
RT_SPLIT_COUNTERS       equ     0000004h
RT_TEST_RECEIVE_FIFOS   equ     0000003h

EPC_TRANSMIT_CONTROL    equ     70h
TC_SLOT_TIME            equ     00000f8h
TC_LOOPBACK_MODE        equ     0000006h        ; mode mask
TC_NORMAL_MODE          equ     0000000h        ; half duplex operation, no loopback
TC_INTERNAL_LOOPBACK    equ     0000002h        ; do not send data to PHY chips
TC_EXTERNAL_LOOPBACK    equ     0000004h        ; must put PHY chip in loopback mode
TC_FULL_DUPLEX          equ     0000006h        ; full duplex operation, no loopback
TC_EARLY_XMIT_ENABLE    equ     0000001h

EPC_TRANSMIT_STATUS     equ     74h
TS_COLLISION_CNT        equ     0001f00h
TS_DEFERRING            equ     0000080h
TS_OUT_OF_WINDOW_COLL   equ     0000040h
TS_COLLISION_DETECT_HB  equ     0000020h
TS_UNDERRUN             equ     0000010h
TS_CARRIER_SENSE_LOST   equ     0000008h
TS_XMIT_WITH_COLL       equ     0000004h
TS_NON_DEFERRED_XMIT    equ     0000002h
TS_XMIT_OK              equ     0000001h

EPC_TRANSMIT_PKT_ADDR   equ     78h

EPC_TRANSMIT_TEST       equ     7ch
TT_MUXED_INT_MODES      equ     0000f00h
TT_FORCE_COLLISION      equ     0000080h
TT_MUX_BACKTIMER        equ     0000040h
TT_RANDOMIZE_BACKOFF    equ     0000020h
TT_SET_BACKTIME         equ     0000010h
TT_SLOT_TIMER_TEST      equ     0000008h
TT_DELAY_TIMER_TEST     equ     0000004h
TT_BACKOFF_TIMER_TEST   equ     0000002h
TT_XMIT_SCAN_ENABLE     equ     0000001h

EPC_RCV_FIRST_DESC_ADDR equ     80h

EPC_RCV_CURR_DESC_ADDR  equ     84h

EPC_RCV_HOST_DATA_ADDR  equ     88h

EPC_RCV_FRAGLIST_ADDR   equ     8ch

EPC_RCV_DMA_DATALEN     equ     90h
RDMA_OWNER              equ     0080000h
RDMA_HEADER             equ     0040000h
RDMA_LFFORM             equ     0020000h
RDMA_FRAGLIST           equ     0010000h

EPC_RCV_FRAG_CNT        equ     94h

EPC_RCV_RAM_CURR_ADDR   equ     98h

EPC_RCV_RAM_PKT_ADDR    equ     9ch

EPC_RCV_EOF_ADDR        equ     0a0h

EPC_RCV_DMA_STATUS      equ     0a4h
RDMA_FRAME_LEN          equ     0ffff0000h
RDMA_OWNER_STATUS       equ     0008000h
RDMA_HEADER_COPIED      equ     0004000h
RDMA_FRAG_LIST_ERR      equ     0002000h
RDMA_NW_STATUS_VALID    equ     0001000h
RDMA_RECEIVER_DISABLED  equ     0000040h
RDMA_BROADCAST_ADDR     equ     0000020h
RDMA_MULTICAST_ADDR     equ     0000010h
RDMA_MISSED_PKT         equ     0000008h
RDMA_CRC_ERR            equ     0000004h
RDMA_FA_ERR             equ     0000002h
RDMA_RCV_OK             equ     0000001h

EPC_RCV_RAM_BUFFER      equ     0a8h

EPC_RCV_MTU_CURR_ADDR   equ     0ach

EPC_RCV_COPY_THRESH     equ     0b0h

;EPC_RCV_DMA_TEST        equ     0bch
EPC_PREEMP_RX_INT       equ     0bch

EPC_XMIT_FIRST_DESC_ADDR equ    0c0h

EPC_XMIT_CURR_DESC_ADDR equ     0c4h

EPC_XMIT_HOST_DATA_ADDR equ     0c8h

EPC_XMIT_FRAGLIST_ADDR  equ     0cch

EPC_XMIT_DMA_DATALEN    equ     0d0h
XDMA_OWNER              equ     0200000h
XDMA_LASTDESC           equ     0100000h
XDMA_NOCRC              equ     0080000h
XDMA_IAF                equ     0040000h
XDMA_LFFORM             equ     0020000h
XDMA_FRAGLIST           equ     0010000h

EPC_XMIT_FRAG_CNT       equ     0d4h

EPC_XMIT_RAM_CURR_ADDR  equ     0d8h

EPC_XMIT_COPY_THRESH    equ     0dch

EPC_XMIT_EARLY_CNT      equ     0e0h

EPC_XMIT_DMA_STATUS     equ     0e4h
XDMA_XMIT_LEN           equ     0ffff0000h
XDMA_OWNER_STATUS       equ     0008000h
XDMA_EXCESSIVE_COLL     equ     0001000h
XDMA_COLLISION_CNT      equ     0001f00h
XDMA_DEFERRING          equ     0000080h
XDMA_OUT_OF_WINDOW_COLL equ     0000040h
XDMA_COLLISION_DETECT_HB equ    0000020h
XDMA_UNDERRUN           equ     0000010h
XDMA_CARRIER_SENSE_LOST equ     0000008h
XDMA_XMIT_WITH_COLL     equ     0000004h
XDMA_NON_DEFERRED_XMIT  equ     0000002h
XDMA_XMIT_OK            equ     0000001h

EPC_XMIT_RAM_BUFFER     equ     0e8h

EPC_XMIT_FIRST_DESC_ADDR2 equ    0ech

;ifdef   XE
 ;; Epic XE rev Cardbus register defs...
 EPC_FEVTR               equ     0F0h
 EPC_FETVR_MASK          equ     0F4h
 EPC_FPRSTR              equ     0F8h
 EPC_FFRCEVTR            equ     0FCh
;else
;EPC_XMIT_DMA_TEST       equ     0fch
;endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\smc9432\pcinic.inc ===
;
; Modifications:   $Header: /Client Boot/NICS/3Com/3C90xB/UNDI/PCINIC.INC 2     22/07/98 8:30p John Lobraico $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;

;
;   Description: PCI Configuration Space Definitions
;

IFDEF            PCI_INC
ELSE
PCI_INC          equ    1
include pci.inc

;--------------------------------------------------------------------------
; Configuration Space Header
;--------------------------------------------------------------------------
PCI_CONFIG_STRUC       struc
    PciVendorId        dw    ?                ;- PCI Vendor ID
    PciDeviceId        dw    ?                ;- PCI Device ID
    PciCommand         dw    ?
    PciStatus          dw    ?
    PciRevisionId      db    ?
    PciClassCode       db    3  dup (?)
    PciCacheLineSize   db    ?
    PciLatencyTimer    db    ?
    PciHeaderType      db    ?
    PciBIST            db    ?
    PciBaseReg0        dd    ?
    PciBaseReg1        dd    ?
    PciBaseReg2        dd    ?
    PciBaseReg3        dd    ?
    PciBaseReg4        dd    ?
    PciBaseReg5        dd    ?
    PciReserved0       dd    0
    PciReserved1       dd    0
    PciExpROMAddress   dd    ?
    PciReserved2       dd    0
    PciReserved3       dd    0
    PciInterruptLine   db    ?
    PciInterruptPin    db    ?
    PciMinGnt          db    ?
    PciMaxLat          db    ?
PCI_CONFIG_STRUC       ends

;--------------------------------------------------------------------------
; Config Space Register Offsets
; Refer To The PCI Specification For Detailed Explanations
;--------------------------------------------------------------------------
VENDOR_ID_REGISTER       equ     00h          ;- PCI Vendor ID Register
DEVICE_ID_REGISTER       equ     02h          ;- PCI Device ID Register
COMMAND_REGISTER         equ     04h          ;- PCI Command Register
STATUS_REGISTER          equ     06h          ;- PCI Status Register
REV_ID_REGISTER          equ     08h          ;- PCI Revision ID Register
CLASS_CODE_REGISTER      equ     09h          ;- PCI Class Code Register
CACHE_LINE_REGISTER      equ     0Ch          ;- PCI Cache Line Register
LATENCY_TIMER            equ     0Dh          ;- PCI Latency Timer Register
HEADER_TYPE              equ     0Eh          ;- PCI Header Type Register
BIST_REGISTER            equ     0Fh          ;- PCI Built-In SelfTest Register
BAR_0_REGISTER           equ     10h          ;- PCI Base Address Register 0
BAR_1_REGISTER           equ     14h          ;- PCI Base Address Register 1
BAR_2_REGISTER           equ     18h          ;- PCI Base Address Register 2
BAR_3_REGISTER           equ     1Ch          ;- PCI Base Address Register 3
BAR_4_REGISTER           equ     20h          ;- PCI Base Address Register 4
BAR_5_REGISTER           equ     24h          ;- PCI Base Address Register 5
SUB_VENDOR_ID_REGISTER           equ     2Ch          ;- PCI Base Address Register 5
SUB_DEVICE_ID_REGISTER           equ     2Eh          ;- PCI Base Address Register 5
EXPANSION_ROM            equ     30h          ;- PCI Expansion ROM Base Register
INTERRUPT_LINE           equ     3Ch          ;- PCI Interrupt Line Register
INTERRUPT_PIN            equ     3Dh          ;- PCI Interrupt Pin Register
MIN_GNT_REGISTER         equ     3Eh          ;- PCI Min-Gnt Register
MAX_LAT_REGISTER         equ     3Fh          ;- PCI Max_Lat Register

;--------------------------------------------------------------------------
; Configuration space DWORD register offsets
;--------------------------------------------------------------------------
CONFIG_SPACE_REG0        equ     0
CONFIG_SPACE_REG1        equ     1
CONFIG_SPACE_REG2        equ     2
CONFIG_SPACE_REG3        equ     3
CONFIG_SPACE_REG4        equ     4
CONFIG_SPACE_REG5        equ     5
CONFIG_SPACE_REG6        equ     6
CONFIG_SPACE_REG7        equ     7
CONFIG_SPACE_REG8        equ     8
CONFIG_SPACE_REG9        equ     9
CONFIG_SPACE_REGA        equ     0Ah
CONFIG_SPACE_REGB        equ     0Bh
CONFIG_SPACE_REGC        equ     0Ch
CONFIG_SPACE_REGD        equ     0Dh
CONFIG_SPACE_REGE        equ     0Eh
CONFIG_SPACE_REGF        equ     0Fh

;--------------------------------------------------------------------------
; Byte/Word Offsets In A Config DWORD
; These offsets can be used to move a Byte or Word into the lower half of
; a register.
;--------------------------------------------------------------------------
CONFIG_BYTE_0            equ     0
CONFIG_BYTE_1            equ     8
CONFIG_BYTE_2            equ     16
CONFIG_BYTE_8            equ     24
CONFIG_WORD_0            equ     0
CONFIG_WORD_1            equ     16

;--------------------------------------------------------------------------
; Configuration Mechanism Registers
;--------------------------------------------------------------------------
CF1_CONFIG_ADDR_REGISTER   equ   0CF8h        ;- Config Space Address Register
CF1_CONFIG_DATA_REGISTER   equ   0CFCh        ;- Config Space Data Register
CF2_SPACE_ENABLE_REGISTER  equ   0CF8h        ;- CSE Register
CF2_FORWARD_REGISTER       equ   0CFAh        ;- Forward Register
CF2_BASE_ADDRESS           equ   0C000h       ;- Configuration #2 Base

;--------------------------------------------------------------------------
; PCI Class Code Definitions
; Configuration Space Header
;--------------------------------------------------------------------------
PCI_BASE_CLASS           equ     02h          ;- Base Class - Network Controller
PCI_SUB_CLASS            equ     00h          ;- Sub Class - Ethernet Controller
PCI_PROG_INTERFACE       equ     00h          ;- Prog I/F - Ethernet COntroller

;--------------------------------------------------------------------------
; PCI Command Register Bit Definitions
; Configuration Space Header
;--------------------------------------------------------------------------
CMD_IO_SPACE             equ     BIT_0
CMD_MEMORY_SPACE         equ     BIT_1
CMD_BUS_MASTER           equ     BIT_2
CMD_SPECIAL_CYCLES       equ     BIT_3
CMD_MEM_WRT_INVALIDATE   equ     BIT_4
CMD_VGA_PALLETTE_SNOOP   equ     BIT_5
CMD_PARITY_RESPONSE      equ     BIT_6
CMD_WAIT_CYCLE_CONTROL   equ     BIT_7
CMD_SERR_ENABLE          equ     BIT_8
CMD_BACK_TO_BACK         equ     BIT_9

;--------------------------------------------------------------------------
; PCI Status Register Bit Definitions
; Configuration Space Header
;--------------------------------------------------------------------------
STAT_BACK_TO_BACK        equ     BIT_7
STAT_DATA_PARITY         equ     BIT_8
STAT_DEVSEL_TIMING       equ     BIT_9 OR BIT_10
STAT_SIGNAL_TARGET_ABORT equ     BIT_11
STAT_RCV_TARGET_ABORT    equ     BIT_12
STAT_RCV_MASTER_ABORT    equ     BIT_13
STAT_SIGNAL_MASTER_ABORT equ     BIT_14
STAT_DETECT_PARITY_ERROR equ     BIT_15

;--------------------------------------------------------------------------
; PCI Base Address Register For Memory (BARM) Bit Definitions
; Configuration Space Header
;--------------------------------------------------------------------------
BARM_LOCATE_BELOW_1_MEG  equ     BIT_1
BARM_LOCATE_IN_64_SPACE  equ     BIT_2
BARM_PREFETCHABLE        equ     BIT_3

;--------------------------------------------------------------------------
; PCI Base Address Register For I/O (BARIO) Bit Definitions
; Configuration Space Header
;--------------------------------------------------------------------------
BARIO_SPACE_INDICATOR    equ     BIT_0

;--------------------------------------------------------------------------
; PCI BIOS Definitions
; Refer To The PCI BIOS Specification
;--------------------------------------------------------------------------
;- Function Code List

;IFE  NWSERVER
;;- Server can use the defines in ODI.INC
;PCI_FUNCTION_ID          equ     0B1h         ;- AH Register
;PCI_BIOS_PRESENT         equ     01h          ;- AL Register
;FIND_PCI_DEVICE          equ     02h          ;- AL Register
;FIND_PCI_CLASS_CODE      equ     03h          ;- AL Register
;GENERATE_SPECIAL_CYCLE   equ     06h          ;- AL Register
;READ_CONFIG_BYTE         equ     08h          ;- AL Register
;READ_CONFIG_WORD         equ     09h          ;- AL Register
;READ_CONFIG_DWORD        equ     0Ah          ;- AL Register
;WRITE_CONFIG_BYTE        equ     0Bh          ;- AL Register
;WRITE_CONFIG_WORD        equ     0Ch          ;- AL Register
;WRITE_CONFIG_DWORD       equ     0Dh          ;- AL Register
;ENDIF

; Function Return Code List
SUCCESSFUL               equ     00h
FUNC_NOT_SUPPORTED       equ     81h
BAD_VENDOR_ID            equ     83h
DEVICE_NOT_FOUND         equ     86h
BAD_REGISTER_NUMBER      equ     87h

;- PCI BIOS Calls
PCI_BIOS_INTERRUPT       equ     01Ah         ;- PCI BIOS Int 1Ah Function Call
PCI_PRESENT_CODE         equ     20494350h    ;- Hex Equivalent Of 'PCI '
                                              ;- ASCII Codes for ' ICP'
PCI_PRESENT_CODE_WORD    equ     4350h        ;- Hex Equivalent Of 'CP'
PCI_SERVICE_IDENTIFIER   equ     49435024h    ;- ASCII Codes for 'ICP$'

;- PCI Device and Vendor IDs
;; JL - Removed nic specifics!
;;SPEEDO_DEVICE_ID         equ     1227h
;;SPLASH1_DEVICE_ID        equ     1226h
;;D100_DEVICE_ID           equ     1229h
;;D100_VENDOR_ID           equ     8086h

;- Maximum bus slots supported under Configuration mechanisms 1 and 2
CONFIG1_MAX_PCI_SLOTS    equ     32
CONFIG2_MAX_PCI_SLOTS    equ     16

;- Maximum buses supported
MAX_PCI_BUSES            equ     255

ENDIF


; EOF - $Workfile: PCINIC.INC $
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\smc9432\lmstruct.inc ===
;****************************************************************************
;
;       The information contained in this file is confidential and 
;       proprietary to Standard Microsystems Corporation.  No part
;       of this file may be reproduced or distributed, in any form
;       or by any means for any purpose, without the express written
;       permission of Standard Microsystems Corporation.
;
; File:         lmstruct.inc
;
; Description:  Definitions for the various data structures and the
;               equates supporting these structures.
;
;
;********************
;* Revision History *
;********************
;
; $Log: /Client Boot/NICS/SMC/9432/UNDI/LMSTRUCT.INC $
; 
;    Rev 1.191   24 Nov 1997 17:22:54   cosand
; Added definitions for the AdapterStructure variable card_SSID (PCI
; Subsystem ID), added the variable power_mode inside IFDEF EPIC.
; Added the variables TxUnderrunCnt, NoETX, PciMRead, BurstLen, and
; ScrambleOn to AdapterStructure inside IFDEF EZSTART in order to make
; the assembly AdapterStructure match the C AdapterStructure for EZSTART.
; 
;    Rev 1.190   04 Nov 1997 16:05:22   cosand
; Added the variable card_SSID to AdapterStructure.  It is used to store
; the PCI Subsystem ID.
; 
;    Rev 1.189   11 Sep 1997 13:29:12   cosand
; Added the variable phy_id to AdapterStructure.  It is
; used by the Epic lmac to store the Phy's organizationally
; unique identifier.
; 
;    Rev 1.188   05 Aug 1997 12:26:34   cosand
; Changed the size of gen_cntl from a word to a dword, since the General
; Control register in Epic XF uses more than 16 bits.
; 
;    Rev 1.187   27 Mar 1997 07:42:18   ANDERS
; Added 2 new bit definitions to AdapterStructure variable "adapter_flags1".
; "SCRAMBLE equ 0001h" & "READ_MULT equ 8000h".
; In AdapterStructure struc definition used IFDEF EPIC to define 3 new
; variables - "burstlen db 0", "ipg_delay db 0" & "preemp_count dw 0".
;
;   Rev 1.0   26 Mar 1997 15:01:14   ANDERS
;Initial revision.
; 
;    Rev 1.186   20 Feb 1997 10:36:36   ANDERS
; changed gen_cntl variable in Adapter Structure to 0010 (FREEBUFF defined)
; or 0110 (FREEBUFF not defined).  This turns off PCI "read multiple" for 9432.
; 
;    Rev 1.185   20 Feb 1997 10:29:20   DONOHOE
; Added Enabler support
; 
;    Rev 1.184   14 Feb 1997 18:44:06   cosand
; Changed the default value of gen_cntl outside the FREEBUFF conditional
; to 0500h (was 0100h) to set the PCI transmit DMA "memory read multiple"
; command bit in the Epic General Control Register.
; 
;    Rev 1.183   07 Feb 1997 17:38:58   DONOHOE
; Change for 8020TM with 2.1 tuples
; 
;    Rev 1.182   05 Feb 1997 12:06:32   ANDERS
; changed default value of "gen_cntl" under FREEBUFF conditional to
; 0410h (was 0010h) to set transmit DMA PCI "read memory multiple"
; command
; 
;    Rev 1.181   04 Oct 1996 14:23:46   cosand
; Added NEEDS_SERVICE to adapter_flags1 to indicate that BroadcomBugFix needs
; to be called for the 9332BVT.
; 
;    Rev 1.180   06 Sep 1996 10:53:18   COSAND_J
; Added a MEDIA_TYPE_AUTO_SENSE bit to media_type2 to specify auto
; speed detection for the 9332bvt.
; 
;    Rev 1.179   23 Aug 1996 09:42:58   ANDERS
; under conditional assembly "IFDEF EPIC" change definition of "int_mask"
; from dw to dd for XE chip reg defintions
; 
;    Rev 1.178   16 Jul 1996 13:30:30   STEIGER
; Removed C-language comment delimiter around "LINE_SPEED_T4" and replaced it
; with an assembly language comment delimiter (semicolon). After all, it is
; an INC file!
; 
;    Rev 1.177   16 Jul 1996 11:19:14   STEIGER
; Changed "IFDEF SPIKE" to "IFDEF TURBO".
; 
;    Rev 1.176   14 May 1996 13:42:36   COOKE_J
; Added defines for 100BaseT4 LINE_SPEED_T4 as LINE_SPEED_100
; 
;    Rev 1.175   11 Mar 1996 08:50:00   TRAN_D
; Defined callback_handler_addr in AdapterStructure for 8016 (PCMCIA).
; 
;    Rev 1.174   29 Feb 1996 14:51:32   COOKE_J
; Added support for 9332BDT
; 
;    Rev 1.173   13 Feb 1996 09:51:44   DONOHOE
; Added lm_gc_corruption_check and ADAPTER_FOUND_LAN_CORRUPT return to
; LM_GetCnfg so it can still try to find the card if some of the LAN
; regs were corrupted.
; 
;    Rev 1.172   12 Jan 1996 11:13:36   CHAN_M
; Changed EPIC's rx fifo threshold to 1/4 full for Free Buffer Pool mode.
; 
;    Rev 1.171   08 Jan 1996 15:14:44   WATANABE
; 1.  Update LMAC to conform to spec v3.01.
;         - eliminate media_used.
; 
; 2.  Add dual function support - PC Card 5.0 spec compliant. 
; 
; 
;    Rev 1.170   22 Dec 1995 14:19:50   NAJARIAN
; changes rx_lastfrag from dd to dw when not in CODE_386
; 
; 
;    Rev 1.169   19 Dec 1995 19:09:34   WATANABE
; 1.  Add defines for multi-function PC Card per v5.0 standard.
; 2.  Add 91C94 and 8020 Xilinx part support.
; 
;    Rev 1.168   19 Dec 1995 11:05:06   NAJARIAN
; added defines for lm9432
; 
;    Rev 1.167   26 Sep 1995 15:56:48   MALIK_D
; Cooke_J changed ifdef lm9432 to EPIC.
; 
;    Rev 1.166   07 Sep 1995 13:46:54   NAJARIAN
; uncommented out the commented out ERX_DISABLED, since the ethernet lower
; uses the cable to track the state of the early receive hardware on the 790.
; 
;    Rev 1.165   29 Aug 1995 18:04:20   CHAN_M
; Added fields media_type2 and line_speed in adapter structure for EPIC100.
; 
;    Rev 1.164   19 Jul 1995 11:32:38   ANDERSON
;
; Change: commented out ERX_DISABLED.  This bit was redundant.
;         Instead, use EARLY_RX_ENABLE in receive_mask.
; 
;    Rev 1.163   18 Jul 1995 14:50:28   CHAN_M
; EPIC100 changes to support Free Buffer Pool receive mechanism.
; 
;    Rev 1.162   12 Jul 1995 11:10:50   NAJARIAN
; removed references to needs_physical_addr and uses_physical_addr.
; Added TX_PHY, RX_PHY, TX_VIRT, and RX_VIRT.
; removed reference to TX_PHY_RX_VIRT (redundant)
; added ADAPTER_REMOVABLE to facilitate code to support hot swappable
; adapters.
; 
;    Rev 1.161   11 Jul 1995 15:03:08   COOKE_J
; Added flags and definitions for SATURN chipset in PCI machines.
; 
;    Rev 1.160   19 Jun 1995 18:15:16   CHAN_M
; minor modifications for EPIC100
; 
;    Rev 1.159   06 Jun 1995 16:21:32   CHAN_M
; EPIC100 changes
; 
;    Rev 1.159   06 Jun 1995 15:39:04   CHAN_M
; changes for EPIC100
; 
;    Rev 1.158   30 May 1995 17:10:36   WATANABE
; 1.  Reverse order for Rev and Early Rcv registers in 91Cxx chip.
; 
;    Rev 1.157   30 May 1995 11:35:24   ANDERSON
;
; Change: added PNP_ENABLE and PNP_BOOT_BIT to adapter_flags1
; 
;    Rev 1.156   23 May 1995 11:13:22   STEIGER
; Removed _DWORD definition -- MASM didn't like it. Changed
; Ethernet error counter variable widths explicitly. This may
; cause some assembly warnings.
; 
;    Rev 1.155   23 May 1995 10:45:26   STEIGER
; Changed Ethernet error counter pointers from "dd 0" to
; "_DWORD"
; Added definition of _DWORD. If CODE_386 is defined, _DWORD is equivalent
; to "dd 0", else it is equivalent to "dw 2 dup (0)"
; 
;    Rev 1.154   25 Apr 1995 10:54:36   WATANABE
; Added MEDIA_UTP100 for media_type.
; Added MEDIA_INVALID for error codes under CONFIG_ERROR.
; 
;    Rev 1.154   24 Apr 1995 19:02:36   WATANABE
; Added MEDIA_UTP100 for media_type.
; 
;    Rev 1.153   14 Apr 1995 09:41:52   HUI_S
; Change: move mc_count into ifdef ETHERNET (Token ring has its own)
; 
;    Rev 1.152   20 Mar 1995 11:45:26   HUI_S
; move mc_count field from DEC_PCI definition to public 
;    in Adapter Structure
; 
;    Rev 1.151   16 Mar 1995 17:27:26   MARCUS_C
; WORD aligned Token Ring Adapter Structure variables following monitor_state.
; 
;    Rev 1.150   08 Mar 1995 16:00:50   WATANABE
; 1.  Added eerom_rev, pci_bus_number and pci_vslot_num for EZStart.
; 
;    Rev 1.149   13 Feb 1995 15:03:30   ANDERSON
;
; Change: Add EARLY_RX_DONE flag to adapter_flags1.
; 
;    Rev 1.148   08 Feb 1995 18:24:38   CHAN_M
; Changed early rx & tx values for high performance 8416 driver
; 
;    Rev 1.147   02 Feb 1995 15:12:22   WATANABE
; 1.  Added NOT_INIT_BY_BRIDGE return code.  LM_GetCnfg will return this
;     code when a PCI-PCI_bridge is present but BIOS does not initialize
;     the NIC properly.
; 
; 
; 
;    Rev 1.146   11 Jan 1995 14:47:52   WATANABE
; 1.  Added test_flag(BYTE) to adapter structure for EZStart 
;     interrupt test.
; 
; 
; 
; 
;    Rev 1.145   02 Dec 1994 19:30:56   WATANABE
; 1. Added members to adapter structure for LM9232 support with conditional compile 
;    switch "LM9232".
; 2. Added new equates :
;         EISA_SLAVE_DMA_CUTOFF - DMA threshold
;         BIC_574_CHIP - EFI bic
;         NIC_C100_CHIP - FEAST 
;         
; 
;    Rev 1.143   09 Nov 1994 11:12:38   CHAN_M
; Changed the following bus_type definitions to conform to Novell's spec.
;     PCI_BUS  equ  3
;     PCMCIA_BUS equ 4
; 
;    Rev 1.142   10 Oct 1994 18:59:04   WATANABE
; For supporting 8432BTA, 8432BA, & 8432TA boards
; 
; 1.  Changed define labels for media_type :
;         MEDIA_UTP_FULL_DUPLEX    to   MEDIA_UTPFD
;         MEDIA_UTP_NO_LINK_TEST   to   MEDIA_UTPNL
; 
; 2.  Added new define lables for media_type :
; 
;         MEDIA_AUI_BNC
;         MEDIA_AUI_BNC_UTP
; 
;    Rev 1.141   15 Sep 1994 11:46:20   MARCUS_C
; Added ptr_bcn_type and ptr_local_ring_num variables to adapter structure.
; These variables are mandatory for the Novell 386 file server driver.
; 
;    Rev 1.140   26 Aug 1994 11:03:10   MARCUS_C
; 1. Evenize adapter_structure.
; 
;    Rev 1.139   26 Aug 1994 10:46:32   MARCUS_C
; 1. Made changes to support LM_8115_s2.2_v2.00a.
; 
;    Rev 1.138   16 Aug 1994 13:31:02   PAUL_A
; Add support for 8316 Token Ring AT Bus Master adapter and 587 i-face chip.
; 
; Change:       add extra dma area for queueing sends.
; Change:       add bus_master_control to set dma priority.
; Change:       add  ETX_DISABLE to adapter_flags to disable early transmit.
; Change:       Add virt_erx_buffer and ptr_erx_fraglist to support
;               Early Receive for 8316.
; Change:       Add dma_channel.
; Change:       Add num_tx_fcbs_queued for 8316 for pending support.
; Change:       Add BIC_587_CHIP.
;
;    Rev 1.137   12 Aug 1994 11:07:28   teresa
; Added board_id2, extra_info2, and media_menu to adapter_structure
;    for EZSTART interface with future products.
; Added media_used to DEC_PCI specific section in adapter structure.
; 
; 
;    Rev 1.136   02 Aug 1994 17:29:36   teresa
; 1.  Add tx_buff_tbl and tx_buff_idx to adapter structure to support
;     double copy in tx routine.
; 2.  Move rev_number field to the end to align each field on word boundary.
; 3.  Change defines for host RAM size to include TX buffer.
; 
; 
;    Rev 1.131   18 May 1994 16:16:04   WOOD_R
; Fixed banner, finally
;  
;     Rev 1.130   03 May 1994 16:05:20   STEIGER
;  More banner problems.
;  
;     Rev 1.129   03 May 1994 16:01:00   STEIGER
;  Added structure members media_opts and media_set. Used by LM_GetCnfg
;  to indicate available and configured media on Ethernet and Token Ring
;  adapters.
;  
;     Rev 1.128   21 Apr 1994 16:02:40   wood_r
;  Banner problems
;  
;     Rev 1.127   21 Apr 1994 15:13:34   wood_r
;  LM_8416_s2.1_v2.00a
;
; Changes:      This revision of the file will be the start of the next
;               generation of the Ethernet LMACs.  The version level will
;               be bumped from 1.xxx to 2.xxx.
;
;               The Ring Empty feature on the 795 was added to the code
;               base.  To implement the feature, a flag bit is used in the
;               adapter structure variable "lmac_flags".  The equate
;               USE_RE_BIT was defined to support the feature.
;
;               The Ehternet LMAC driver now supports "Dual Mode" operation.
;               This is implemented by using a flag bit, "IO_MAPPED", in the
;               adapter structure variable "adapter_flags".
;
;+!?/ ***********************************************************************

MC_TABLE_ENTRIES        equ     16

;IFNDEF MAXFRAGMENTS
MAXFRAGMENTS            equ     32
;ENDIF

MAX_TX_QS               equ     8
NUM_TX_QS_USED          equ     3

MAX_RX_QS               equ     2
NUM_RX_QS_USED          equ     2

LAPAD                   equ     20
IFDEF   LAF                     ; Look Ahead Full
LOOK_AHEAD_BUFFER_LEN   equ     512
;LOOK_AHEAD_BUFFER_LEN  equ     1518
ELSE
LOOK_AHEAD_BUFFER_LEN   equ     64
ENDIF

ifdef CODE_386
PHYSICAL_ADDR           equ     80000000h
else
PHYSICAL_ADDR           equ     8000h
endif

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;       Structure Template to simplify handling of far pointers . . .

FarPointer      struc

	ofst            dw      ?
	sgmt            dw      ?

FarPointer      ends

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;       Structure Template for received Ethernet packets (690)

EthernetPacket  struc

	EthRStat                db      ?
	EthNxtPkt               db      ?
	EthPhysSize             dw      ?
	EthDestAdd              db      6 dup (?)
	EthSrcAdd               db      6 dup (?)
	Eth8023Size             dw      ?

EthernetPacket  ends

;***************************
; Multicast Table Structure
;***************************

McTable                 struc

	address                 db      6 dup (?)
	instance_count          db      0

McTable                 ends

SIZE_OF_MC_TABLE        equ     MC_TABLE_ENTRIES * (size McTable)

;*******************************
; Fragment Descriptor Structure
;*******************************

FragmentStructure       struc
	fragment_ptr            dd      0
ifdef   CODE_386
	fragment_length         dd      0
else
	fragment_length         dw      0
endif
FragmentStructure       ends

;**********************************
; Data Buffer Structure Definition
;**********************************

DataBuffStructure       struc

ifdef   CODE_386
	fragment_count          dd      0
else
	fragment_count          dw      0
endif
	fragment_list           db      (MAXFRAGMENTS * (size FragmentStructure)) dup (0)

DataBuffStructure       ends
ifdef   PCMCIA
;**********************************
; PCMCIA Data Structure defs
;**********************************

InfoStruct      struc

	InfoInfoLen             dw      0
	InfoSignature           dw      0
	InfoCount               dw      0
	InfoRevision            dw      0
	InfoCSLevel             dw      0
	InfoVStrOff             dw      0
	InfoVStrLen             dw      0
	InfoVendorString        db      128 dup (0)

InfoStruct      ends
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

RegisterClientStruct    struc

	RegCliAttributes        dw      0
	RegCliEventMask         dw      0
	RegCliClientData        db      8       dup (0)
	RegCliCSVersion         dw      0

RegisterClientStruct    ends

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; The following struct is a template to go along with TupleData struct.
; 
TupleStruct     struc

	TpStSocket              dw      ?
	TpStAttributes          dw      ?
	TpStDesiredTuple        db      ?
	TpStTupleOffset         db      ?
	TpStFlags               dw      ?
	TpStLinkOffset          dd      ?
	TpStCISOffset           dd      ?
	TpStTupleCode           db      ?
	TpStTupleLink           db      ?

TupleStruct     ends
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TupleData       struc

	TpDtSocket              dw      0
	TpDtAttributes          dw      0
	TpDtDesiredTuple        db      0
	TpDtTupleOffset         db      0
	TpDtFlags               dw      0
	TpDtLinkOffset          dd      0
	TpDtCISOffset           dd      0
	TpDtTupleDataMax        dw      0       
	TpDtTupleDataLen        dw      0       
	TpDtTupleData           db      128     dup (0)

TupleData       ends
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ReqIOStruct     struc

	ReqIOSocket             dw      0
	ReqIOBasePort1          dw      0
	ReqIONumPorts1          db      0
	ReqIOAttributes1        db      0
	ReqIOBasePort2          dw      0
	ReqIONumPorts2          db      0
	ReqIOAttributes2        db      0
	ReqIOIOAddrLines        db      0

ReqIOStruct     ends

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ReqIrqStruct    struc

	ReqIrqSocket            dw      0
	ReqIrqAttributes        dw      0
	ReqIrqAssignedIrq       db      0
	ReqIrqIRQInfo1          db      0
	ReqIrqIRQInfo2          dw      0

ReqIrqStruct    ends

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ReqMemStruct    struc

	ReqMemSocket            dw      0
	ReqMemAttributes        dw      0
	ReqMemBase              dd      0
	ReqMemSize              dd      0
	ReqMemAccessSpeed       db      0

ReqMemStruct    ends

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
MapMemPageStruct        struc

	MapMemCardOffset        dd      0
	MapMemPageNum           db      0

MapMemPageStruct        ends
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ReqCfgStruct    struc

	ReqCfgSocket            dw      0
	ReqCfgAttributes        dw      0
	ReqCfgVcc               db      0
	ReqCfgVpp1              db      0
	ReqCfgVpp2              db      0
	ReqCfgIntType           db      0
	ReqCfgConfigBase        dd      0
	ReqCfgStatus            db      0
	ReqCfgPin               db      0
	ReqCfgCopy              db      0
	ReqCfgConfigIndex       db      0
	ReqCfgPresent           db      0

ReqCfgStruct    ends
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

GetCfgInfoStruct        struc

	GCISocket               dw      0
	GCIAttribute            dw      0
	GCIVcc                  db      0
	GCIVpp1                 db      0
	GCIVpp2                 db      0
	GCIIntType              db      0
       GCIConfigBase            dd      0
	GCIStatus               db      0
	GCIPin                  db      0
	GCICopy                 db      0
	GCIConfigIndex          db      0
	GCIPresent              db      0
	GCIFirstDevType         db      0
	GCIFuncCode             db      0
	GCISysInitMask          db      0
	GCIManufCode            dw      0
	GCIManufInfo            dw      0
	GCICardValues           db      0
	GCIAssignedIRQ          db      0
	GCIIRQAttributes        dw      0
	GCIBasePort1            dw      0
	GCINumPorts1            db      0
	GCIAttributes1          db      0
	GCIBasePort2            dw      0
	GCINumPorts2            db      0
	GCIAttributes2          db      0
	GCIIOAddrLines          db      0

GetCfgInfoStruct        ends


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;; The following are structure templates for Tuple Data . . .

MfgIDTuple      struc

;       MfgTplCode              db      ?
;       MfgTplLink              db      ?
	MfgTplId                dw      ?
	MfgTplInfo              dw      ?

MfgIDTuple      ends
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FuncIdTuple        struc

	FuncIdTplCode           db      ?
	FuncIdTplSysinit        db      ?

FuncIdTuple        ends


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

LanTuple        struc

	LTpType                 db      ?
	LTpLanTech              db      ?

LanTuple        ends

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

LanNid          struc

	LanNidType              db      ?
	LTpLanIdSz              db      ?
	LTpLanId                db      6 dup (?)

LanNid          ends

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ConfigTuple    struc
       
       CTpSize                 db      ?
       CTpLast                 db      ?
       CTpRADR                 dw      ?
       CTpRMSK                 db      ?
       CTpRSVD                 db      ?

ConfigTuple    ends


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

AdjResInfoStructMem     struc

	ARIActionM              db      ?
	ARIResourceM            db      ?
	ARIAttributesM          dw      ?
	ARIBase                 dd      ?
	ARISize                 dd      ?

AdjResInfoStructMem     ends

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

AdjResInfoStructIO1     struc

	ARIActionIO1            db      ?
	ARIResourceIO1          db      ?
       ARIBasePortIO1          dw      ?
       ARINumPortIO1           db      ?
	ARIAttributesIO1        db      ?
       ARIAdrLineIO1           db      ?

AdjResInfoStructIO1     ends

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

AdjResInfoStructIO2     struc

	ARIActionIO2            db      ?
	ARIResourceIO2          db      ?
       ARIBasePortIO2          dd      ?
       ARINumPortIO2           dd      ?
	ARIAttributesIO2        db      ?
       ARIAdrLineIO2           db      ?

AdjResInfoStructIO2     ends

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

AdjResInfoStructIrq     struc

	ARIActionI              db      ?
	ARIResourceI            db      ?
	ARIAttributesI          db      ?
	ARIIrq                  db      ?

AdjResInfoStructIrq     ends

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

endif ; (PCMCIA)



;**********************************
; DEC PCI Data Structures & defs
;**********************************

ifdef  DEC_PCI

       MAX_TX_FRAMES_8432      equ     3
       MAX_TX_DESC_8432        equ     ((MAX_TX_FRAMES_8432 * MAXFRAGMENTS) + 1)
       MAX_RX_DESC_8432        equ     4
       MAX_BUFFER_SIZE         equ     1520
       SETUP_BUFFER_SIZE       equ     192
       HOST_RAM_ALIGNMENT      equ     32    

       HOST_RAM_SIZE           equ   ( (32 * MAX_TX_DESC_8432) \
				     + (32 * MAX_RX_DESC_8432 )   \
				     + SETUP_BUFFER_SIZE          \
				     + (MAX_RX_DESC_8432 * MAX_BUFFER_SIZE) \
				    + (MAX_TX_FRAMES_8432 * MAX_BUFFER_SIZE) \
				     + HOST_RAM_ALIGNMENT )

ADDR_TBL       struc
       virtual_addr    dd      0
       phy_addr        dd      0
ADDR_TBL       ends


TxDescriptorStructure  struc 

       tx_status       dd      0
       tx_control      dd      0
       tbuffer_1       dd      0
       tbuffer_2       dd      0
       tdesc_pad       dd      4 dup (0)

TxDescriptorStructure  ends


RxDescriptorStructure  struc

       rx_status       dd      0
       rx_control      dd      0
       rbuffer_1       dd      0
       rbuffer_2       dd      0
       vbuffer_1       dd      0
       rdesc_pad       dd      3 dup (0)

RxDescriptorStructure  ends


endif ; (DEC_PCI)

ifdef EPIC

DMA_FRAG        struc
dma_status      dw      0
dma_len         dw      0
dma_buf_addr    dd      0
dma_buf_len     dw      0
dma_control     dw      0
dma_next_phys   dd      0
dma_handle      dd      0
IFDEF CODE_386
dma_next_off    dd      0
dma_buff_off    dd      0
ELSE
dma_next_off    dw      0
dma_buff_off    dw      0
ENDIF
DMA_FRAG        ends

DMA_FRAG_SIZE   equ     4 + (8 * MAXFRAGMENTS)

DEFAULT_TX_DESC_9432        equ     3
DEFAULT_RX_DESC_9432        equ     3

; Default host ram size for UMACs that don't call LM_Get_Host_Ram_Size

HOST_RAM_TX_SIZE        equ     (size DMA_FRAG + DMA_FRAG_SIZE) * DEFAULT_TX_DESC_9432
HOST_RAM_RX_SIZE        equ     (size DMA_FRAG + DMA_FRAG_SIZE) * DEFAULT_RX_DESC_9432
HOST_RAM_SIZE   equ     HOST_RAM_TX_SIZE + HOST_RAM_RX_SIZE + 256

ADDR_TBL       struc
       virtual_addr    dd      0
       phy_addr        dd      0
ADDR_TBL       ends

endif

;******************************
; Adapter Structure Definition
;******************************

AdapterStructure        struc

	adapter_num             db      0       ;logical adapter no.  
	pc_bus                  db      0       ;Bus type
	io_base                 dw      0       ;I/O base address
	adapter_name            db      12 dup (0)
	irq_value               dw      0       ;IRQ line used by hardware
	rom_size                dw      0       ;num of 1024 byte blocks
	rom_base                dd      0       ;physical address of ROM
	rom_access              dd      0       ;seg:off value to access ROM
	ram_size                dw      0       ;num of 1024 byte blocks
	ram_base                dd      0       ;physical address of RAM
	ram_access              dd      0       ;seg:off value to access RAM
	ram_usable              dw      0       ;num of 1024 byte blocks (window size)
	io_base_new             dw      0       ;new base I/O Addr (for PutCnfg)
	xnode_address           db      6 dup (0)       ;network address 
	max_packet_size         dw      0       ;max pkt size hardware supports
IFDEF EPIC
	num_of_tx_buffs         dw      DEFAULT_TX_DESC_9432
ELSE
	num_of_tx_buffs         dw      1       ;TX buffs available in hardware
ENDIF
	receive_mask            dw      0
	adapter_status          dw      0
	media_type              dw      0       ;BNC, AUI, UTP_4, etc.
	media_type2             dw      0       ;added to support EPIC100
	line_speed              dw      0       ;added to support EPIC100
	adapter_bus             dw      0
	pos_id                  dw      0       ;Adapter POS ID (MCA only)
	adapter_flags           dw      0       ;
	adapter_flags1          dw      0       ;
	slot_num                db      0       ;Micro Channel slot number
	rx_lookahead_size       db      0       ; Size of UMAC's max lookahead in 16 byte chunks.
	media_opts              dw      0       ; Media options supported by the adapter ...
	media_set               dw      0       ; Media type(s) being used by the adapter ...
ifdef   LM8316
	dma_channel             dw      0       ; Direct Memory Access channel
else
ifdef  LM9232
       dma_channel             dw      0
endif
endif
IFDEF EPIC
IFDEF FREEBUFF
	num_of_rx_buffs         dw      10      ; num. of rx fragment lists
						; to preallocate
ELSE
	num_of_rx_buffs         dw      DEFAULT_RX_DESC_9432
ENDIF
IFDEF EZSTART
; These 5 variables were added to make lmstruct.inc match lmstruct.h for EZSTART.
; None of these variables are being used by the assembly lmac 11/24/97.
    TxUnderrunCnt           dw      0
    NoETX                   dw      0
    PciMRead                dw      0
    BurstLen                dw      0
    ScrambleOn              dw      0
ENDIF ;EZSTART
IFDEF FREEBUFF
	num_rx_free_buffs       dw      0       ; num. of rx fragment lists
						; owned by the LMAC
ENDIF
ENDIF ;EPIC

	;-----------------------...Local vars for each adapter...----------------------

	bic_type                dw      0
	nic_type                dw      0
	phy_id                  dd      0       ;Phy organizationally unique identifer
	board_id                dw      0       ;WDM defined Board ID
	board_id2               dw      0
	extra_info              dw      0       ;WDM defined Extra Board Info
	extra_info2             dw      0
	mode_bits               dw      0       ;mode bits for adapter
	status_bits             dw      0       ;
	xmit_buf_size           dw      600h    ;
	xmit_flag_offset        dw      0
	config_mode             dw      0       ; 1=store config in EEROM
	page_offset_mask        dw      0
	media_menu              dw      0
	easp                    dd      0
    card_SSID               dw      0       ;PCI Subsystem ID

ifdef TOKEN_RING
	ptr_rx_fcb_overruns     dd      0
	ptr_rx_bdb_overruns     dd      0
	ptr_rx_fifo_overruns    dd      0
	ptr_tx_fifo_underruns   dd      0
	ptr_internal_errors     dd      0
	ptr_line_errors         dd      0
	ptr_ac_errors           dd      0
	ptr_burst_errors        dd      0
	ptr_ad_trans_errors     dd      0
	ptr_rcv_congest_errors  dd      0
	ptr_lost_frame_errors   dd      0
	ptr_freq_errors         dd      0
	ptr_fr_copied_errors    dd      0
	ptr_token_errors        dd      0
	ptr_una                 dd      0
	ptr_bcn_type            dd      0
	ptr_local_ring_num      dd      0

	ring_status_flags       db      0
	join_state              db      0
	monitor_state           db      0
	filler                  db      0       ; evenize structure

	ring_status             dw      0
	authorized_function_clases      dw      0
	authorized_access_priority      dw      0
	microcode_version       dw      0
	group_address_0         dw      0
	group_address           dw      2 dup (0)
	functional_address_0    dw      0
	functional_address      dw      2 dup (0)
	bitwise_group_address   dw      2 dup (0)
	source_ring_number      dw      0
	target_ring_number      dw      0
	ptr_ucode               dd      0

;/*
;   The following values are for lower mac use only!
;   They are not used by the upper mac
;*/

ifdef   LM8316
	tx_dma_area_ptr         dd      0       ;ptr to tx fraglist space
	rx_dma_area_ptr         dd      0       ;ptr to rx fraglist space
	extra_dma_area_ptr      dd      0       ;ptr to extra fraglist space
	tx_dma_fcb              dd      0       ;transmit fcb being transferred
	virt_erx_buffer         dd      0       ;virt ptr to UMAC erx buffer
	ptr_erx_fraglist        dd      0       ;virt ptr to phys fraglist
	bus_master_control      dw      0       ;set dma request priority
endif
	sh_mem_used             dd      0

	config_word0            dw      0       
	config_word1            dw      0       

	iscpb_ptr               dd      0       ;ptr to init sys cfg ptr block
	scgb_ptr                dd      0       ;ptr to sys config block
	sclb_ptr                dd      0       ;ptr to sys control block
	isb_ptr                 dd      0       ;ptr to interrupt status block
	current_isb_index       dw      0       ;interrupt status block index
	misc_command_data       dd      0

	acb_head                dd      0       ;ptr to action command block
	acb_curr                dd      0
	acb_next                dd      0

	num_acbs                dw      0
	num_acbs_used           dw      0
	acb_pending             dw      0

	tx_fcb_head             dd      NUM_TX_QS_USED dup (0)
	tx_fcb_curr             dd      NUM_TX_QS_USED dup (0)
	tx_fcb_tail             dd      NUM_TX_QS_USED dup (0)  ; points to the most recent transmitted frame

	tx_bdb_head             dd      NUM_TX_QS_USED dup (0)

	tx_buff_head            dd      NUM_TX_QS_USED dup (0)
	tx_buff_end             dd      NUM_TX_QS_USED dup (0)
	tx_buff_curr            dd      NUM_TX_QS_USED dup (0)
	tx_buff_size            dw      NUM_TX_QS_USED dup (0)

	num_tx_fcbs             dw      NUM_TX_QS_USED dup (0)
	num_tx_bdbs             dw      NUM_TX_QS_USED dup (0)
	num_tx_fcbs_used        dw      NUM_TX_QS_USED dup (0)

ifdef   LM8316
	num_tx_fcbs_queued      dw      NUM_TX_QS_USED dup (0)
endif
	tx_buff_used            dw      NUM_TX_QS_USED dup (0)
	tx_queue_status         dw      NUM_TX_QS_USED dup (0)

	rx_fcb_head             dd      NUM_RX_QS_USED dup (0)
	rx_fcb_curr             dd      NUM_RX_QS_USED dup (0)

	rx_bdb_head             dd      NUM_RX_QS_USED dup (0)
	rx_bdb_end              dd      NUM_RX_QS_USED dup (0)
	rx_bdb_curr             dd      NUM_RX_QS_USED dup (0)

	rx_buff_head            dd      NUM_RX_QS_USED dup (0)
	rx_buff_end             dd      NUM_RX_QS_USED dup (0)

	num_rx_fcbs             dw      NUM_RX_QS_USED dup (0)
	num_rx_bdbs             dw      NUM_RX_QS_USED dup (0)
	receive_queue_number    dw      0

	rx_buff_blk_size        dw      NUM_RX_QS_USED dup (0)
	rx_shift_factor         db      NUM_RX_QS_USED dup (0)  ; mul. factor to get # of BDBs from frame length        

	trc_mask                db      0
	rx_fifo_overrun_count   db      0

	lobe_media_test_flag    db      0
	DMA_test_state          db      0
						  
;/* end of lower mac specific variables */

endif

ifdef   ETHERNET
;-------------------------...Error Counter Pointers...-------------------------

ifdef   CODE_386
	ptr_rx_CRC_errors       dd      0
	ptr_rx_too_big          dd      0
	ptr_rx_lost_pkts        dd      0
	ptr_rx_align_errors     dd      0
	ptr_rx_overruns         dd      0
	ptr_tx_deferred         dd      0
	ptr_tx_total_collisions dd      0
	ptr_tx_max_collisions   dd      0
	ptr_tx_one_collision    dd      0
	ptr_tx_mult_collisions  dd      0
	ptr_tx_ow_collision     dd      0
	ptr_tx_CD_heartbeat     dd      0
	ptr_tx_carrier_lost     dd      0
	ptr_tx_underruns        dd      0
	ptr_ring_OVW            dd      0
else
	ptr_rx_CRC_errors       dw      2 dup (0)
	ptr_rx_too_big          dw      2 dup (0)
	ptr_rx_lost_pkts        dw      2 dup (0)
	ptr_rx_align_errors     dw      2 dup (0)
	ptr_rx_overruns         dw      2 dup (0)
	ptr_tx_deferred         dw      2 dup (0)
	ptr_tx_total_collisions dw      2 dup (0)
	ptr_tx_max_collisions   dw      2 dup (0)
	ptr_tx_one_collision    dw      2 dup (0)
	ptr_tx_mult_collisions  dw      2 dup (0)
	ptr_tx_ow_collision     dw      2 dup (0)
	ptr_tx_CD_heartbeat     dw      2 dup (0)
	ptr_tx_carrier_lost     dw      2 dup (0)
	ptr_tx_underruns        dw      2 dup (0)
	ptr_ring_OVW            dw      2 dup (0)
endif
	multi_address           db      6 dup (0)       ;network group address

;/*
;   The following values are for lower mac use only!
;   They are not used by the upper mac
;  
;*/
ifdef   CODE_386
	early_xmit_flags        dw      0
	split_word              dw      0
	leftover_count          dd      0
endif

IFDEF EPIC
	burstlen                db      0
	ipg_delay               db      0
	preemp_count            dw      0
ELSE
; for 8232
	max_page_num            db      0
	curr_page_num           db      0
	early_tx_pend           db      0
	rx_pend                 db      0
ENDIF
	early_tx_threshold      dw      0

	rx_frag                 dd      0
	erx_offset              dw      0
	erx_size                dw      0
	dummy_vector            dd      0

ifdef   CODE_386
	xmit_threshold          dd      0
else
	xmit_threshold          dw      0
endif
	tx_pend                 dw      0
;;;     early_tx_slope          db      0
	tx_retry                db      0
	early_rx_slope          dw      0
endif

ifdef   ETHERNET
	imr_hold                db      0
	rcr_hold                db      0
	pstart_hold             db      0
	pstop_hold              db      0
	local_nxtpkt_ptr        db      0
	int_bit                 db      0
	hdw_int                 db      0
	ovw_tx_pending          db      0
ifdef   CODE_386
	pstop_32                dd      0
	wr_frag_cnt             dd      0
	byte_cnt                dd      0
	packet_offset           dd      0
else    
	wr_frag_cnt             dw      0
	byte_cnt                dw      0
	packet_offset           dw      0
endif
endif

ifdef   ETHERNET
	packet_ptr              dw      0
	int_port                dw      0
	pkt_len                 dw      0
	ring_ovw                db      0
	laar_enter              db      0
	data_buff_seg           dw      0
	leftover_data           dw      0
	tx_buffer               dd      3 dup (0)
ifdef   LNKLST
	tx_head                 dw      0
	tx_tail                 dw      0
else
	tx_head                 db      0
	tx_tail                 db      0
endif
	tx_count                db      0
	tx_pstop                db      0
	servicing_ints          dw      0

;;      lpbk_frag_count         dw      0
;;      lpbk_frag_struct        db      size FragmentStructure dup (0)

ifdef   LNKLST
	rec_buf_size            dw      0
	tstart                  dw      0
	tstop                   dw      0
	rstart                  dw      0
	rstop                   dw      0
	tbegin                  db      0
	tend                    db      0
	rbegin                  db      0
	rend                    db      0
	num_rdt_entries         dw      0
	next_rdt_entry          dw      0
	rdt_size                db      0
	xmt_size                db      0
	rec_size                db      0
endif
	laar_exit               db      0
	erx_frame_size          dw      0
	lmac_flags              dw      0
	erx_addr_type           db      0
;if ETHERNET EQ 3000
ifdef E3000
	tx_mask                 db      0
	rx_mask                 db      0
	rx_status               db      0

	pkt_byte_offset         dw      0
	total_bytes_to_move     dw      0
	xmit_pkt_size           dw      0
	driver_state            dw      0
	pkt_bytes_looked        dw      0
	etherstar_byte_count    dw      0
	bytes_from_LA           dw      0

	ptr_shrtpkt_errors      dd      0
	ptr_busread_errors      dd      0
	ptr_buswrite_errors     dd      0

ifdef LA_BUFF
	look_ahead_buf          db      LA_BUFF dup (0)
else
	look_ahead_buf          db      256 dup (0)
endif
endif

;------------------------...Multicast Address Table...-------------------------
	bc_add                  db      6 dup   (0ffh)  ; Broadcast address.
				db      1               ; Instance count for
							; broadcast address.
	mc_table                db      SIZE_OF_MC_TABLE dup (0)
	temp_addr               db      6 dup   (0)

ifdef   PCMCIA
	callback_handler_addr   dd      0
	callback_handler_status dw      0
	pcm_socket              dw      0
	pcm_card_flags          dw      0
	pcm_client_handle       dw      0
	pcm_ram_win_handle      dw      0
	pcm_reg_win_handle      dw      0
       pcm_isr_handler         dd      0
       pcm_cs_ver              dw      0
       pcm_max_num_skt         dw      0
       pcm_cfg_reg_addr        dw      0 
       req_irq_struct           db      size ReqIrqStruct               dup (0)
	req_mem_struct          db      size ReqMemStruct               dup (0)
	req_io_struct           db      size ReqIOStruct                dup (0)
	tuple_data              db      size TupleData                  dup (0)
	register_client_struct  db      size RegisterClientStruct       dup (0)
	info_struct             db      size InfoStruct                 dup (0)
	req_cfg_struct          db      size ReqCfgStruct               dup (0)
	get_cfg_info_struct     db      size GetCfgInfoStruct           dup (0)
	map_mem_page_struct     db      size MapMemPageStruct           dup (0)
	adj_res_info_struct     db      size AdjResInfoStructMem        dup (0)
ifndef PCCARD5
	pcm_modem_irq           dw      0
	pcm_modem_iobase        dw      0
	pcm_modem_isr           dd      0
	pcm_modem_handle        dw      0  ;swap generic enabler handle and ours
endif
       
endif ; (PCMCIA)

;/* end of lower mac specific variables */
endif ; (Ethernet)

; 
; PCI configuration
;
ifdef  DEC_PCI

; host ram physical and virtual address
       host_ram_phy_addr       dd      0
       host_ram_virt_addr      dd      0

	device_id               dw      0
	cbio                    dd      0

; Registers

	op_mode                 dd      0
	int_mask                dd      0
	sia_mode0               dd      0
	sia_mode1               dd      0
	sia_mode2               dd      0
       def_bus_mode            dd      0

; TX descriptor ring  - 16 bytes/descriptor - quadword aligned 

	tx_ring                 db      (size ADDR_TBL) dup (0)
       tx_buff_tbl             db      (MAX_TX_FRAMES_8432 * (size ADDR_TBL)) dup (0)
       tx_buff_idx             dw      0
	tx_enqueue              dd      0
	tx_dequeue              dd      0
	free_tx_desc            dd      0

;
; Rx descriptor ring - 16 bytes/descriptor - quadword aligned
; Rx buffer - 1.6k/buffer - longword aligned
;

	rx_ring                 db      (size ADDR_TBL) dup (0)
	rx_dequeue              dd      0
	current_rx_buffer       dd      0
       media_used              dw      0

;
; CAM setup buffer -192 bytes - longword aligned
;

	setup_ptr               db      (size ADDR_TBL) dup (0)

       multicast_check         db      0

	rev_number              db      0
       test_flag               db      0

;
; for EZSTART 
;
       eerom_rev               db      0
       pci_bus_num             db      0
       pci_vslot_num           db      0

endif         ; DEC_PCI

IFDEF EPIC
; host ram physical and virtual address
host_ram_phy_addr       dd      0
host_ram_phy_base       dd      0
host_ram_virt_addr      dd      0


IFDEF CODE_386
rx_curr_lookahead       dd      0
rx_curr_fraglist        dd      0
IFDEF FREEBUFF
rx_last_fraglist        dd      0
ENDIF
tx_first_off            dd      0
tx_curr_off             dd      0
ELSE
rx_curr_lookahead       dw      0
rx_curr_fraglist        dw      0
IFDEF FREEBUFF
rx_last_fraglist        dw      0
ENDIF
tx_first_off            dw      0
tx_curr_off             dw      0
ENDIF
tx_free_desc_count      dw      0
tx_scratch              dd      0

early_tx_thresh         dw      64
ipg_timer               dw      03c60h

vslotnumber             db      0
busnumber               db      0


int_mask                dd      0
slot_timer              dw      0fh
IFDEF FREEBUFF 
gen_cntl                dd      00000010h       ; ONECOPY, "memory read", 32 byte rx thresh
ELSE
gen_cntl                dd      00000100h       ; 64 byte rx thresh, "memory read"
ENDIF
test_reg                dd      0h

;
; CAM setup buffer -192 bytes - longword aligned
;

	setup_ptr               db      (size ADDR_TBL) dup (0)

       multicast_check         db      0

endif

IFDEF LM9232
       look_ahead_buf          db      256 dup (0)

MCAddress               db      6 dup (0)       ;Used for multicast
MCWorkArea              db      8 dup (0)
SCECTxQueueSize         db       3              ;default max tx free count
TxPacketsInsideSCEC     db      0               ; 1 -> 2048 bytes for 91C90
CurrentTxPcktSize       db      0               ; but 256 bytes for 91C92
SCECShrForPageSize      db      ?
MIRShlTo256ByteUnits    db      0               ;0 for 91C90/92, 1 for FEAST

InDriverInitFlag        db      0
OddAddressFlag          db      0
AllocationRequestedFlag db      0

Is386                   db      0               ;Default to 286

;RxErrorBits             dw      ?
SCECPageSize            dw      ?
SCECMaxMemForTx         db      ?               ;In percentage
SCECMaxPagesForTx       dw      ?
SCEC1518InSCECPages     dw      ?
SCECNumberOfPages       dw      ?

HardwareFrameLength     dw      ?               ;Used to set SCEC's Control 
						; byte.

;/**************************************************************************\
;*                                                                          *
;*      I/O Port Variables                                                  *
;*                                                                          *
;\**************************************************************************/

;storage for IO address locations
;Bank 1

TCR                     dw      0     
StatusRegister          dw      0             
RCRRegister             dw      0     
Counter                 dw      0             
MIR                     dw      0     
MCR                     dw      0     
NotUsed1                dw      0
BankSelect              dw      0
     
;Bank 2
Configuration           dw      0             
BaseAddress             dw      0     
IA0_1                   dw      0             
IA2_3                   dw      0             
IA4_5                   dw      0             
General                 dw      0             
Control                 dw      0     
NotUsed2                dw      0

;Bank 3
MMUCommand              dw      0     
PNR_ARR                 dw      0             
FifoPorts               dw      0     
Pointer                 dw      0             
Data0_1                 dw      0             
Data2_3                 dw      0             
Interrupt               dw      0     
NotUsed3                dw      0

;Bank 4
MT0_1                   dw      0             
MT2_3                   dw      0             
MT4_5                   dw      0             
MT6_7                   dw      0             
NotUsed4                dw      0
Revision                dw      0
ERCV                    dw      0

SCECRAMSize             dw      ?               ;In 256 byte units

; ----- debug counters -----
IFDEF  DEBUG
SQETCount               dw      2 dup (0)
ExcessiveDeferralCount  dw      2 dup (0)
TXDeferredCount         dw      2 dup (0)
TXMulticastCount        dw      2 dup (0)
TXBroadcastCount        dw      2 dup (0)
RxBroadcastCount        dw      2 dup (0)
RxMulticastCount        dw      2 dup (0)
SCECRxTooShortCount     dw      2 dup (0)
MMUTimeoutCount         dw      2 dup (0)
SpuriousEntryToISR      dw      2 dup (0)
ENDIF

MaxPercentageOnTx       dw      2 dup (0)

FoundSCECMaxMemForTx    db      0

InScecDriverInitFlag    db      0
;IntLine1                db      2              ;Override test pattern


;DMA look up tables for IO base registers

base_addr_dat           db      8 dup (0)
base_addr_dat_L         db      8 dup (0)
byte_count_dat          db      8 dup (0)

DMA_base_addr_dat       db      0
DMA_base_addr_dat_L     db      0
DMA_byte_count_dat      db      0


; Temporary FIX for FEAST Rev. B lockup problem with multiple stations
;
KickStartFlag          db      0

endif ; end FEAST

ifdef ETHERNET
       mc_count                dd      0
endif

IFDEF EPIC
       power_mode       dw      0            
ENDIF

AdapterStructure        ends

;************************************
; SNMP-ON-BOARD Agent Link Structure
;************************************

AgentLink       struc
  LnkSigStr     db 12 dup(0)    ;signature string containing "SmcLinkTable"
  LnkDrvTyp     db 0    ;1=Redbox ODI, 2=ODI DOS, 3=ODI OS/2, 4=NDIS DOS,
  LnkFlg        db 0    ;0 if no agent linked in, 1 if agent linked in
  LnkNfo        dd 0    ;pointer to routine which returns pointer to NIC info
  LnkAgtRcv     dd 0    ;pointer to agent receive trap entry
  LnkAgtXmt     dd 0    ;pointer to agent transmit trap entry
  LnkGet        dd 0    ;pointer to NIC receive data copy routine
  LnkSnd        dd 0    ;pointer to NIC send routine
  LnkRst        dd 0    ;pointer to NIC driver reset routine
  LnkMib        dd 0    ;pointer to MIB data base
  LnkMibAct     dd 0    ;pointer to MIB action routine list
  LnkCntOffset  dw 0    ;offset to error counters
  LnkCntNum     dw 0    ;number of error counters
  LnkCntSize    dw 0    ;size of error counters i.e. 32 = 32 bits
  LnkISR        dd 0    ;pointer to interrupt vector
  LnkFrmTyp     db 0    ; 1=Ethernet, 2=Token Ring
  LnkDrvVer1    db 0    ; driver major version
  LnkDrvVer2    db 0    ; driver minor version
AgentLink       ends

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Defs for pcm_card_flags(bit-mapped)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
REG_COMPLETE    equ     00001h
INSERTED        equ     00002h
PCC_INSERTED  equ    00004h          ; 1=currently inserted, 0=currently removed
ENABLER       equ    00008h

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Ram Test Patterns
;
RAM_PATTERN_1   equ     055AAh
RAM_PATTERN_2   equ     09249h
RAM_PATTERN_3   equ     0DB6Dh

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Equates for RAM test
;
ROM_SIGNATURE   equ     0AA55h
MIN_ROM_SIZE    equ     02000h
;
;
;**************
; Return Codes
;**************

SUCCESS                 equ     0000h   ; this code is defined by NDIS spec
ADAPTER_AND_CONFIG      equ     0001h
ADAPTER_NO_CONFIG       equ     0002h
NOT_MY_INTERRUPT        equ     0003h
FRAME_REJECTED          equ     0004h   ; this code is defined by NDIS spec
EVENTS_DISABLED         equ     0005h
OUT_OF_RESOURCES        equ     0006h   ; this code is defined by NDIS spec
INVALID_PARAMETER       equ     0007h   ; this code is defined by NDIS spec
INVALID_FUNCTION        equ     0008h   ; this code is defined by NDIS spec
INITIALIZE_FAILED       equ     0009h
CLOSE_FAILED            equ     000Ah
MAX_COLLISIONS          equ     000Bh
NO_SUCH_DESTINATION     equ     000Ch
BUFFER_TOO_SMALL_ERROR  equ     000Dh
ADAPTER_CLOSED          equ     000Eh
UCODE_NOT_PRESENT       equ     000Fh
FIFO_UNDERRUN           equ     0010h
DEST_OUT_OF_RESOURCES   equ     0011h
ADAPTER_NOT_INITIALIZED equ     0012h
PENDING                 equ     0013h
UCODE_PRESENT           equ     0014h
NOT_INIT_BY_BRIDGE     equ     0015h

OPEN_FAILED             equ     0080h
HARDWARE_FAILED         equ     0081h
SELF_TEST_FAILED        equ     0082h
RAM_TEST_FAILED         equ     0083h
RAM_CONFLICT            equ     0084h
ROM_CONFLICT            equ     0085h
UNKNOWN_ADAPTER         equ     0086h
CONFIG_ERROR            equ     0087h
CONFIG_WARNING          equ     0088h
NO_FIXED_CNFG           equ     0089h
EEROM_CKSUM_ERROR       equ     008Ah
ROM_SIGNATURE_ERROR     equ     008Bh
ROM_CHECKSUM_ERROR      equ     008Ch
ROM_SIZE_ERROR          equ     008Dh
UNSUPPORTED_NIC_CHIP    equ     008Eh
NIC_REG_ERROR           equ     008Fh
BIC_REG_ERROR           equ     0090h
MICROCODE_TEST_ERROR    equ     0091h
LOBE_MEDIA_TEST_FAILED  equ     0092h
CS_UNSUPPORTED_REV      equ     0093h
CS_NOT_PRESENT          equ     0094h
TUPLE_ERROR             equ     0095h
REG_CLIENT_ERR          equ     0096h
NOT_OUR_CARD            equ     0097h
UNSUPPORTED_CARD        equ     0098h
PCM_CONFIG_ERR          equ     0099h
CARD_CONFIGURED         equ     009Ah

ADAPTER_FOUND_LAN_CORRUPT       equ     009Bh
MODEM_NOT_CONFIGURED        equ    009Ch
UNSUPPORTED_PCMCIA          equ    009Dh
ENABLER_NO_CONFIG           equ    009Eh

ADAPTER_NOT_FOUND       equ     0ffffh
ILLEGAL_FUNCTION        equ     INVALID_FUNCTION

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Bit-Mapped codes returned in DX if return code from LM_GET_CONFIG is
; CONFIG_ERROR or CONFIG_WARNING:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;; Errors:
IO_BASE_INVALID         equ     0001h
IO_BASE_RANGE           equ     0002h
IRQ_INVALID             equ     0004h
IRQ_RANGE               equ     0008h
RAM_BASE_INVALID        equ     0010h
RAM_BASE_RANGE          equ     0020h
RAM_SIZE_RANGE          equ     0040h
MEDIA_INVALID          equ     0800h

;;;; Warnings:
IRQ_MISMATCH            equ     0080h
RAM_BASE_MISMATCH       equ     0100h
RAM_SIZE_MISMATCH       equ     0200h
BUS_MODE_MISMATCH       equ     0400h

;************************************************************
;* Definitions for status bits when calling UM_Receive_Packet
;************************************************************

RX_CRC_ERROR            equ     01h
RX_ALIGNMENT_ERROR      equ     02h
RX_HW_FAILED            equ     80h

;**********************************************
;* Definitions for the field RING_STATUS_FLAGS
;**********************************************

RING_STATUS_CHANGED                     equ     01h
MONITOR_STATE_CHANGED                   equ     02h
JOIN_STATE_CHANGED                      equ     04h

;***************************************
;* Definitions for the field JOIN_STATE
;***************************************

JS_BYPASS_STATE                         equ     00h
JS_LOBE_TEST_STATE                      equ     01h
JS_DETECT_MONITOR_PRESENT_STATE         equ     02h
JS_AWAIT_NEW_MONITOR_STATE              equ     03h
JS_DUPLICATE_ADDRESS_TEST_STATE         equ     04h
JS_NEIGHBOR_NOTIFICATION_STATE          equ     05h
JS_REQUEST_INITIALIZATION_STATE         equ     06h
JS_JOIN_COMPLETE_STATE                  equ     07h
JS_BYPASS_WAIT_STATE                    equ     08h

;******************************************
;* Definitions for the field MONITOR_STATE
;******************************************

MS_MONITOR_FSM_INACTIVE                 equ     00h
MS_REPEAT_BEACON_STATE                  equ     01h
MS_REPEAT_CLAIM_TOKEN_STATE             equ     02h
MS_TRANSMIT_CLAIM_TOKEN_STATE           equ     03h
MS_STANDBY_MONITOR_STATE                equ     04h
MS_TRANSMIT_BEACON_STATE                equ     05h
MS_ACTIVE_MONITOR_STATE                 equ     06h
MS_TRANSMIT_RING_PURGE_STATE            equ     07h
MS_BEACON_TEST_STATE                    equ     09h

;********************************************
;* Definitions for the bit-field RING_STATUS
;********************************************

SIGNAL_LOSS                             equ     08000h
HARD_ERROR                              equ     04000h
SOFT_ERROR                              equ     02000h
TRANSMIT_BEACON                         equ     01000h
LOBE_WIRE_FAULT                         equ     00800h
AUTO_REMOVAL_ERROR                      equ     00400h
REMOVE_RECEIVED                         equ     00100h
COUNTER_OVERFLOW                        equ     00080h
SINGLE_STATION                          equ     00040h
RING_RECOVERY                           equ     00020h

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Definitions for the field BUS_TYPE

AT_BUS                  equ     00h
MCA_BUS         equ     01h
EISA_BUS                equ     02h
PCI_BUS                 equ     03h
PCMCIA_BUS              equ     04h


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;**********************
; Defs for adapter_flags
;**********************

RX_VALID_LOOKAHEAD      equ     0001h
FORCED_16BIT_MODE       equ     0002h
ADAPTER_DISABLED        equ     0004h
TRANSMIT_CHAIN_INT      equ     0008h
EARLY_RX_FRAME          equ     0010h
EARLY_TX                equ     0020h
EARLY_RX_COPY           equ     0040h
;;;USES_PHYSICAL_ADDR   equ     0080h   ;;;#### Reserved - Do not uncomment
;;;NEEDS_PHYSICAL_ADDR  equ     0100h   ;;;#### Reserved - Do not uncomment
RX_STATUS_PENDING       equ     0200h
ERX_DISABLED            equ     0400h   ;;; Used by Ethernet 790 ERX logic
ENABLE_TX_PENDING       equ     0800h
ENABLE_RX_PENDING       equ     1000h
PERM_CLOSE              equ     2000h   ; For PCMCIA LM_Close_Adapter
IO_MAPPED               equ     4000h   ; IO mapped bus interface (795)
ETX_DISABLED            equ     8000h


;************************
; Defs for adapter_flags1
;************************
;;;TX_PHY_RX_VIRT       equ     0001h   ;;;#### No Longer used - Reserved
					; See TX_PHY... below
SCRAMBLE                equ     0001h   ;set scramble in EPIC Phy for Baystack problem
NEEDS_HOST_RAM         equ     0002h
NEEDS_MEDIA_TYPE       equ     0004h
EARLY_RX_DONE          equ     0008h
PNP_BOOT_BIT           equ     0010h    ; activates PnP & config on power-up
					; clear => regular PnP operation
PNP_ENABLE             equ     0020h    ; regular PnP operation
					; clear=>no PnP, overrides PNP_BOOT_BIT
SATURN_ENABLE          equ     0040h

ADAPTER_REMOVABLE      equ     0080h    ; adapter is hot swappable

TX_PHY                 equ     0100h    ; Uses physical address for tx bufs
RX_PHY                 equ     0200h    ; Uses physical address for rx bufs
TX_VIRT                equ     0400h    ; Uses virtual address for tx bufs
RX_VIRT                equ     0800h    ; Uses virtual address for rx bufs
NEEDS_SERVICE          equ     1000h    ; Request that LM_Service_Events call
					; BroadcomBugFix for the 9332BVT.
PCMCIA_LAN_IRQ         equ     2000h    ; BTM, set if LAN func generated INT
PCMCIA_MODEM_IRQ       equ     4000h    ; BTM, set if Modem func generated INT */
READ_MULT               equ     8000h   ; set to tell LMAC to enable Mem Read Multiple

;**********************
; ADAPTER STATUS CODES
;**********************

OPEN                    equ     0001h
INITIALIZED             equ     0002h
CLOSED                  equ     0003h
FAILED                  equ     0005h
NOT_INITIALIZED         equ     0006h
IO_CONFLICT             equ     0007h
CARD_REMOVED            equ     0008h
CARD_INSERTED           equ     0009h

;**********************
; MODE BIT DEFINITIONS
;**********************

INTERRUPT_STATUS_BIT    equ     8000h   ; PC Interrupt Line: 0 = Not Enabled
BOOT_STATUS_MASK        equ     6000h   ; Mask to isolate BOOT_STATUS
BOOT_INHIBIT            equ     0000h   ; BOOT_STATUS is 'inhibited'
BOOT_TYPE_1             equ     2000h   ; Unused BOOT_STATUS value
BOOT_TYPE_2             equ     4000h   ; Unused BOOT_STATUS value
BOOT_TYPE_3             equ     6000h   ; Unused BOOT_STATUS value
ZERO_WAIT_STATE_MASK    equ     1800h   ; Mask to isolate Wait State flags
ZERO_WAIT_STATE_8_BIT   equ     1000h   ; 0 = Disabled (Inserts Wait States)
ZERO_WAIT_STATE_16_BIT  equ     0800h   ; 0 = Disabled (Inserts Wait States)
LOOPING_MODE_MASK       equ     0007h
LOOPBACK_MODE_0         equ     0000h
LOOPBACK_MODE_1         equ     0001h
LOOPBACK_MODE_2         equ     0002h
LOOPBACK_MODE_3         equ     0003h
LOOPBACK_MODE_4         equ     0004h
LOOPBACK_MODE_5         equ     0005h
LOOPBACK_MODE_6         equ     0006h
LOOPBACK_MODE_7         equ     0007h
AUTO_MEDIA_DETECT       equ     0008h   ; Auto detect the media connection
MANUAL_CRC              equ     0010h
EARLY_TOKEN_REL         equ     0020h   ; Early Token Release for Token Ring
NDIS_UMAC               equ     0040h   ; Indicates to LMAC that UMAC is NDIS.
UTP2_PORT               equ     0080h   ; For 8216T2, 0=port A, 1=Port B.
BNC_10BT_INTERFACE      equ     0600h   ; BNC and UTP current media set
UTP_INTERFACE           equ     0500h   ; Ethernet UTP Only.
BNC_INTERFACE           equ     0400h   ; net defs for adv. feature adapters
AUI_INTERFACE           equ     0300h   
AUI_10BT_INTERFACE      equ     0200h   
STARLAN_10_INTERFACE    equ     0100h   
INTERFACE_TYPE_MASK     equ     0700h   ; Mask value for interface type

;****************************************************************************
; Definitions for the field:
; media_type
; TP = Twisted Pair
; STP = Shielded twisted pair
; UTP = Unshielded twisted pair

CNFG_MEDIA_TYPE_MASK    equ     03h     ; bits 0-1

MEDIA_S10               equ     00000h  ; Ethernet adapter, TP.
MEDIA_AUI_UTP           equ     00001h  ; Ethernet adapter, AUI/UTP media.
MEDIA_BNC               equ     00002h  ; Ethernet adapter, BNC media.
MEDIA_AUI               equ     00003h  ; Ethernet adapter, AUI media.
MEDIA_STP_16            equ     00004h  ; TokenRing adap, 16Mbit STP.
MEDIA_STP_4             equ     00005h  ; TokenRing adap, 4Mbit STP.
MEDIA_UTP_16            equ     00006h  ; TokenRing adap, 16Mbit UTP.
MEDIA_UTP_4             equ     00007h  ; TokenRing adap, 4Mbit UTP.
MEDIA_UTP               equ     00008h  ; Ethernet adapter, UTP media (no AUI).
MEDIA_BNC_UTP          equ     00010h  ; Ethernet adapter, BNC/UTP media 
MEDIA_UTPFD            equ     00011h  ; Ethernet adapter, TP and full duplex.
MEDIA_UTPNL            equ     00012h  ; Ethernet adapter, TP w/o link integrity test.
MEDIA_AUI_BNC          equ     00013h  ; Ethernet adapter, AUI/BNC .
MEDIA_AUI_BNC_UTP      equ     00014h  ; Ethernet adapter, AUI/BNC/UTP.
MEDIA_UTPA             equ     00015h  ; Ethernet UTP-10Mbps Ports A
MEDIA_UTPB             equ     00016h  ; Ethernet UTP-10Mbps Ports B
MEDIA_STP_16_UTP_16    equ     00017h  ; Token Ring STP-16Mbps/UTP-16Mbps
MEDIA_STP_4_UTP_4      equ     00018h  ; Token Ring STP-4Mbps/UTP-4Mbps                

MEDIA_STP100_UTP100    equ     00020h  ; Ethernet STP-100Mbps/UTP-100Mbps
MEDIA_UTP100FD         equ     00021h  ; Ethernet UTP-100Mbps, full duplex */
MEDIA_UTP100           equ     00022h  ; Ethernet UTP-100Mbps */
	
MEDIA_UNKNOWN           equ     0FFFFh  ; Unknown adapter/media type

;****************************************************************************
; Definitions for the field:
; media_type2
MEDIA_TYPE_MII                  equ     1
MEDIA_TYPE_UTP                  equ     2
MEDIA_TYPE_BNC                  equ    0004h
MEDIA_TYPE_AUI                  equ    0008h
MEDIA_TYPE_S10                  equ    0010h
MEDIA_TYPE_AUTO_SENSE           equ     1000h
MEDIA_TYPE_AUTO_NEGOTIATE       equ     8000h
MEDIA_TYPE_AUTO_DETECT          equ     4000h

;****************************************************************************
; Definitions for the field:
; line_speed
LINE_SPEED_UNKNOWN              equ     0
LINE_SPEED_4                    equ     1
LINE_SPEED_10                   equ     2
LINE_SPEED_16                   equ     4
LINE_SPEED_100                  equ     8
LINE_SPEED_T4                   equ     8  ; 100BaseT4 aliased for 9332BVT
LINE_SPEED_FULL_DUPLEX          equ     8000h

;****************************************************************************
; Definitions for the field:
; bic_type (Bus interface chip type)
;
BIC_NO_CHIP             equ     00000h  ; Bus interface chip not implemented
BIC_583_CHIP            equ     00001h  ; 83C583 bus interface chip
BIC_584_CHIP            equ     00002h  ; 83C584 bus interface chip
BIC_585_CHIP            equ     00003h  ; 83C585 bus interface chip
BIC_593_CHIP            equ     00004h  ; 83C593 bus interface chip
BIC_594_CHIP            equ     00005h  ; 83C594 bus interface chip
BIC_564_CHIP            equ     00006h  ; PCMCIA bus interface chip
BIC_790_CHIP            equ     00007h  ; 83C790 bus i-face/Ethernet NIC chip
BIC_571_CHIP            equ     00008h  ; 83C571 EISA bus master i-face
BIC_587_CHIP            equ     00009h  ; Token Ring AT Bus Master i-face chip
BIC_574_CHIP           equ     00010h  ; FEAST bus interface chip
BIC_8432_CHIP          equ     00011h  ; 8432 bus i-face/Ethernet NIC chip(DEC PCI)
BIC_9332_CHIP          equ     00012h  ; 9332 bus i-face/100 Mbps Ethernet NIC chip(DEC PCI)
BIC_8432E_CHIP         equ     00013h  ; 8432 Enhanced bus iface/Ethernet NIC(DEC)
BIC_EPIC100_CHIP        equ     00014h  ; EPIC/100 10/100 Mbps Ethernet BIC/NIC
BIC_C94_CHIP           equ     00015h  ; 91C94 bus i-face in PCMCIA mode
BIC_X8020_CHIP         equ     00016h  ; Xilinx PCMCIA multi-func i-face


;****************************************************************************
; Definitions for the field:
; nic_type (Bus interface chip type)
;
NIC_UNK_CHIP            equ     00000h  ; Unknown NIC chip
NIC_8390_CHIP           equ     00001h  ; DP8390 Ethernet NIC
NIC_690_CHIP            equ     00002h  ; 83C690 Ethernet NIC
NIC_825_CHIP            equ     00003h  ; 83C825 Token Ring NIC
;NIC_???_CHIP           equ     00004h  ; Not used
;NIC_???_CHIP           equ     00005h  ; Not used
;NIC_???_CHIP           equ     00006h  ; Not used
NIC_790_CHIP            equ     00007h  ; 83C790 bus i-face/Ethernet NIC chip
NIC_C100_CHIP          equ     00010h  ; FEAST 100Mbps Ethernet NIC
NIC_8432_CHIP          equ     00011h  ; 8432 bus i-face/Ethernet NIC(DEC PCI)
NIC_9332_CHIP          equ     00012h  ; 9332 bus i-face/100 Mbps Ethernet NIC(DEC PCI)
NIC_8432E_CHIP         equ     00013h  ; 8432 enhanced bus iface/Ethernet NIC(DEC) 
NIC_EPIC100_CHIP        equ     00014h  ; EPIC/100 10/100 Mbps Ethernet BIC/NIC
NIC_C94_CHIP           equ     00015h  ; 91C94 PC Card with multi func

;****************************************************************************
; Definitions for the field:
; adapter_type  The adapter_type field describes the adapter/bus
;               configuration.
;
BUS_UNK_TYPE            equ     00000h  ; 
BUS_ISA16_TYPE          equ     00001h  ; 16 bit adap in 16 bit (E)ISA slot
BUS_ISA8_TYPE           equ     00002h  ; 8/16b adap in 8 bit XT/(E)ISA slot
BUS_MCA_TYPE            equ     00003h  ; Micro Channel adapter
BUS_EISA32M_TYPE        equ     00004h  ; EISA 32 bit bus master adapter
BUS_EISA32S_TYPE        equ     00005h  ; EISA 32 bit bus slave adapter
BUS_PCMCIA_TYPE         equ     00006h  ; PCMCIA Bus
BUS_PCI_TYPE           equ     00007h  ; PCI bus

;***************************
; Receive Mask Definitions
;***************************

ACCEPT_MULTICAST                equ     0001h
ACCEPT_BROADCAST                equ     0002h
PROMISCUOUS_MODE                equ     0004h
ACCEPT_SOURCE_ROUTING           equ     0008h
ACCEPT_ERR_PACKETS              equ     0010h
ACCEPT_ATT_MAC_FRAMES           equ     0020h
ACCEPT_MULTI_PROM               equ     0040h   
TRANSMIT_ONLY                   equ     0080h
ACCEPT_EXT_MAC_FRAMES           equ     0100h
EARLY_RX_ENABLE                 equ     0200h
PKT_SIZE_NOT_NEEDED             equ     0400h
ACCEPT_SOURCE_ROUTING_SPANNING  equ     0808h
ACCEPT_ALL_MAC_FRAMES           equ     0120h
				   
;*******************************************
; config_mode defs
;*******************************************

STORE_EEROM             equ     00001h          ; Store config in EEROM.
STORE_REGS              equ     00002h          ; Store config in register set.

;****************************************************************************
; Definitions for the field:
; card_SSID (PCI Subsystem ID)
;****************************************************************************

SSID9332BDT     equ     02001h                  ; National PHY
SSID9332BVT     equ     02002h
SSID9334BDT     equ     02003h
;;SSID9332BDT     equ     02004h                ; Microlinear PHY
SSID8032DT      equ     02005h
SSSID8432BT     equ     02007h
SSID8432BTA     equ     02008h
SSID8432T       equ     02009h
SID1208T        equ     02011h                  ; Accton 10 Mbps
;;SSID9332BDT     equ     02401h                ; QSI 6611 PHY
SSID9432DMT     equ     0A010h
SSID9432TX      equ     0A011h
SSID9032TXM     equ     0A012h                  ; Eval Mercury Cardbus + Modem
SSID9032TX      equ     0A013h                  ; TDK PHY
SSID9432TXPWR   equ     0A014h                  ; 9432TX with power management
SSID9432BTX     equ     0A015h

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; equates for lmac_flags in adapter structure (Ethernet)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

MEM_DISABLE     equ     0001h
RX_STATUS_POLL  equ     0002h
USE_RE_BIT      equ     0004h
;RESERVED       equ     0008h
;RESERVED       equ     0010h   
;RESERVED       equ     0020h
;RESERVED       equ     0040h
;RESERVED       equ     0080h
;RESERVED       equ     0100h
;RESERVED       equ     0200h
;RESERVED       equ     0400h
;RESERVED       equ     0800h
;RESERVED       equ     1000h
;RESERVED       equ     2000h
;RESERVED       equ     4000h
;RESERVED       equ     8000h


; media_opts & media_set Fields bit defs for Ethernet ...
MED_OPT_BNC     equ     01h
MED_OPT_UTP     equ     02h
MED_OPT_AUI     equ     04h
MED_OPT_10MB    equ     08h
MED_OPT_100MB   equ     10h
MED_OPT_S10     equ     20h

; unique media_opts & media_set Fields bit defs for Token Ring ...
MED_OPT_4MB     equ     08h
MED_OPT_16MB    equ     10h
MED_OPT_STP     equ     40h

;*******************************************
; PCMCIA definitions
;*******************************************

CS_SIG                          equ     05343h  ; ASCII 'CS' 
SMC_PCMCIA_ID                   equ     0108h   ; SMC ID Byte value.
IO_PORT_RANGE                   equ     0020h   ; Number of IO Ports.   
ENABLE_IRQ_STEER                equ     0002h   ; For ReqCfgStruct.ReqCfgAttributes
FIVE_VOLTS                      equ     50      ; For ReqCfgStruct.ReqCfgVcc, .Vpp1, .Vpp2
TWELVE_VOLTS                    equ     120     ; For ReqCfgStruct.ReqCfgVcc, .Vpp1, .Vpp2
MEM_AND_IO                      equ     0002h   ; For ReqCfgStruct.ReqCfgIntType
ATTRIBUTE_REG_OFFSET            equ     0001h   ; Hi word of offset of attribute registers
REG_COR_VALUE                   equ     0041h   ; Value for Config Option Register
REGS_PRESENT_VALUE              equ     000Fh   ; Value for ReqCfgStruct.ReqCfgPresent
LEVEL_IRQ                       equ     0020h   ; For ReqIrqStruct.IRQInfo1
IRQ_INFO2_VALID                 equ     0010h   ; For ReqIrqStruct.IRQInfo1
VALID_IRQS                      equ     8EBCh   ; For ReqIrqStruct.IRQInfo2
OFFSET_SHMEM_HI                 equ     0002h   ; Hi word of shared ram offset
OFFSET_SHMEM_LO                 equ     00000h  ; Lo word of shared ram offset
OFFSET_REGISTER_MEM             equ     0003h   ; Hi word of register memory offset (not used)
AMD_ID                          equ     0A701h  ; Mfg/Product ID for AMD flash ROM
ATMEL_ID                        equ     0D51Fh  ; Mfg/Product ID for ATMEL flash ROM
SHMEM_SIZE                      equ     4000h   ; Size of shared memory device.
SHMEM_NIC_OFFSET                equ     0100h   ; Offset of start of shared memory space for NIC.
REG_OFFSET                      equ     0000h   ; Offset of PCM card's mem-mapped register set.

MAX_8023_SIZE                   equ     1500    ; Max 802.3 size of frame.
IFDEF TURBO
DEFAULT_ERX_VALUE               equ     01h     ; Number of 16-byte blocks for 790B early Rx.
DEFAULT_ETX_VALUE               equ     4       ; Number of bytes for 790B early Tx.
ELSE
DEFAULT_ERX_VALUE               equ     04h     ; Number of 16-byte blocks for 790B early Rx.
DEFAULT_ETX_VALUE               equ     32      ; Number of bytes for 790B early Tx.
ENDIF
DEFAULT_TX_RETRIES              equ     3       ; Number of transmit retries
LPBK_FRAME_SIZE                 equ     1024    ; Default loopback frame for Rx calibration test.
MAX_LOOKAHEAD_SIZE              equ     252     ; Max lookahead size for ethernet.

;*******************************************
; FEAST EISA 
;*******************************************
EISA_SLAVE_DMA_CUTOFF          equ     128    ; DMA threshold


IFDEF DEC_PCI
SATURN_BIT_MASK                 equ     00FDh
SATURN_CDC_CFID_VAL             equ     0483h
SATURN_PCMC_CFID_VAL            equ     04A3h
INTEL_VAL                       equ     8086h
SATURN_CPU_PCI_ENTRY            equ     0053h
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\smc9432\lmac.asm ===
;----------------------------------------------------------------------------
; LMAC.ASM
;
; Main file for SMC 9432 LMAC.
;
;$History: LMAC.ASM $
; 
; *****************  Version 1  *****************
; User: Paul Cowan   Date: 26/08/98   Time: 9:40a
; Created in $/Client Boot/NICS/SMC/9432/UNDI
;
;----------------------------------------------------------------------------

include 	spdosegs.inc

_TEXT	Segment para public

.386

EPIC		equ 1
ETHERNET	equ	1

assume ds:DGroup,cs:cGroup,es:nothing,ss:nothing

include epic100.inc
include lmstruct.inc
include eeprom2.inc
include lm9432.inc
include lm9432cf.asm
include lm9432.asm

extrn	UM_SEND_COMPLETE:near
extrn	UM_Receive_Copy_Complete:near
extrn	UM_STATUS_CHANGE:near
extrn	UM_Interrupt:near
extrn	UM_Card_Services:near
extrn	UM_RECEIVE_PACKET:near

_TEXT	ends

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\smc9432\pxe_stru.inc ===
;
NUM_MCADDRS    	Equ	8		; max number of multicast addresses.
MAX_DATABLK    	Equ	8		; max number of data blocks supported 
					;	in a descriptor.
MAX_IMMED_LEN	Equ	64		; max immediate data buffer length
MAX_TX_DATABLK	Equ	MAX_DATABLK	; max number of data blocks supported 
					;	in a Tx descriptor.
MAX_TD_DATABLK	Equ	MAX_DATABLK	; max number of TransferData blocks
		
APIMaxFunc	EQU	0011h

ADDR_LEN	EQU	16
ETH_ADDR_LEN	EQU	6
MAXNUM_MCADDR	EQU	8

;
; protocol values in transmit buffer
;
P_UNKNOWN	EQU	0		;; no media header
P_IP	 	EQU	1		;; IP type
P_ARP		EQU	2		;; ARP type
P_RARP		EQU	3		;; RARP type

TYPE_IP	 	EQU	0800h		;; IP type
TYPE_ARP	EQU	0806h		;; ARP type
TYPE_RARP	EQU	8035h		;; RARP type
;
; xmitflag values in transmit buffer
;
PKT_DESTADDR	EQU 0	;; destination address given 
PKT_BROADCAST	EQU 1h	;; use broadcast address 
PKT_MULTICAST	EQU 2h	;; multicast addr given

;; Hardware type values
ETHER_TYPE 		EQU 1
EXP_ETHER_TYPE	EQU 2
IEEE_TYPE  	EQU 6
ARCNET_TYPE   	EQU 7


Eth_MCastBuf    Struc
MCastAddrCount	DW	?
MCastAddr	DB MAXNUM_MCADDR * ETH_ADDR_LEN dup (0)
Eth_MCastBuf	Ends

MC_MCastBuf    Struc
MC_MCastAddrCount	DW	?
MC_MCastAddr  		DB MAXNUM_MCADDR * ADDR_LEN dup (0)

MC_MCastBuf Ends

NIC_StartUp    Struc
S_Status	DW	?
S_BusType	DB	?
S_AddrType	DB	?
S_DataSeg	DW	?
S_DataSegAddr	DD	?
S_DataSegSize	DW	?
S_CodeSegSize	DW	?
S_BusDevFunc	DW	?	;; PCI Dev_ID
S_PCI_ds_off	dw	?	;; Far pointer to PCI data structure
S_PCI_ds_seg	dw	?
S_PnP_csn	dw	?	; Card select number.-1 for non-PnP BBS device
S_PnP_eh_off	dw	?	; Far pointer to PnP expansion header
S_PnP_eh_seg	dw	?
NIC_StartUp Ends

NIC_CleanUp    Struc
CL_Status	DW	?
NIC_CleanUp Ends

NIC_Initialize    Struc
I_Status	DW	?
I_Prot_ini	DD	?
I_RcvInt	DD	?
I_GenInt	DD	?
NIC_Initialize  Ends

NIC_Reset    Struc
R_Status	DW	?
R_MCBuf		MC_MCastBuf <>
NIC_Reset   Ends

NIC_ShutDown    Struc
SD_Status	DW	?
NIC_ShutDown    Ends

NIC_Open    Struc
O_Status	DW	?
O_OpenFlg	DW	?
O_PktFilter	DW	?
O_MCBuf		MC_MCastBuf <>
NIC_Open    Ends

NIC_Close    Struc
C_Status	DW	?
NIC_Close   Ends

X_DataBlock    Struc
X_TxPtrType	DB	?	; 0 => Phys pointer, 1 => GDT pointer
X_TxRsvdByte	DB	?	; Reservered, must be zero.
X_TxDataLen	DW	?	; Data block length in bytes.
X_TxDataPtr	DD	?	; Far pointer to data block.
X_DataBlock Ends

NIC_TBD    Struc
X_Length	DW	?
X_BufOff	DW	?
X_BufSeg	DW	?
X_DataBlkCount	DW	?		; will always be zero for base code
X_DataBlk	DB	MAX_DATABLK * SIZE X_DataBlock dup (0)	
NIC_TBD Ends

NIC_Transmit    Struc
T_Status		DW	?
T_Protocol		DB	?
T_XmitFlag		DB	?
T_DestAddrOffset 	DW	?	; 16-bit segment & offset of the
T_DestAddrSegment 	DW	?	; destination media address 
T_TBDOffset		DW	?	; 16-bit segment & offset 
T_TBDSegment		DW	?	; transmit buffer descriptor 
T_Reserved		DD	2 dup(0)	; for future use	
NIC_Transmit    Ends

NIC_SetMCastAddr    Struc
SM_Status		DW	?
SM_MCBuf		MC_MCastBuf <>
NIC_SetMCastAddr    Ends

NIC_SetStationAddr    Struc
SS_Status		DW	?
SS_StationAddr		DB	ADDR_LEN dup (0)
NIC_SetStationAddr  Ends

NIC_SetPacketFilter    Struc
SP_Status		DW	?
;;SP_NewFilter		DW  ?
SP_NewFilter		DB  ?
;;SP_MCBuf		MC_MCastBuf <>
NIC_SetPacketFilter Ends

NIC_GetInfo    Struc
GI_Status		DW	?
GI_BaseIo		DW	?
GI_IntNumber		DW	?
GI_MTU			DW	?
GI_HwType		DW	?
GI_HwAddrLen		DW	?
GI_CurrentNodeAddress	DB ADDR_LEN dup (0)
GI_PermNodeAddress	DB ADDR_LEN dup (0)
GI_ROMAddress		DW 	?
GI_RxBufCt		DW	?
GI_TxBufCt		DW	?
NIC_GetInfo Ends

NIC_GetNICType_pci    Struc
Status 		DW	?	; OUT: See PXENV_STATUS_xxx constants */ 
NicType 	DB	?	;  /* OUT: 2=PCI, 3=PnP */
Vendor_ID	DW	?	; /* OUT:  */
Dev_ID		DW	?	;  /* OUT:  */
Base_Class	DB	?	; /* OUT: */
Sub_Class	DB	?	;  /* OUT: */
Prog_Intf	DB	?	;  /* OUT: program interface */ 
Rev		DB	?	;  /* OUT: Revision number */ 
BusDevFunc	DW	?	; /* OUT: Bus, Device & Function numbers */
SubSystemId     dd      ?       ; /*OUT: SubsytemId & SubsystemVendorId
NIC_GetNICType_pci  Ends

NIC_GetNICType_pnp    Struc
Status 		DW	?	; OUT: See PXENV_STATUS_xxx constants */ 
NicType 	DB	?	;  /* OUT: 2=PCI, 3=PnP */
EISA_Dev_ID	DD	?	; /* Out:  */
Base_Class	DB	?	; /* OUT: */
Sub_Class	DB	?	;  /* OUT: */
Prog_Intf	DB	?	;  /* OUT: program interface */
CardSelNum	DW	?	; /* OUT: Card Selector Number */
Res		DB	0	;
NIC_GetNICType_pnp  Ends

NIC_GetStatistics    Struc
GS_Status		DW	?
GS_XmtGoodFrames	dd    ?
GS_RcvGoodFrames	dd    ?
GS_RcvCRCErrors		dd    ?
GS_RcvResourceErrors	dd    ?
NIC_GetStatistics   Ends

NIC_ClearStatistics    Struc
CS_Status		DW	?
NIC_ClearStatistics Ends

NIC_InitDiags    Struc
ID_Status	DW	?
NIC_InitDiags   Ends

NIC_ForceInterrupt    Struc
FI_Status		DW	?
NIC_ForceInterrupt  Ends

NIC_GetMCastAddr    Struc
GM_Status		DW	?
GM_InetAddr		DD	?
GM_HwAddr		DB	ADDR_LEN dup (0)
NIC_GetMCastAddr    Ends

;NIC_API_Entry	Struc
;Signature 	DB	'PXENV+'	;; not null terminated
;Version		DW	0100h		;; 1.0
;StrucLength	DB	0		;; length of this structure
;CheckSum	DB	0		;; fill in later
;rm_entry_off	DW	0		;; real mode driver entry offset
;rm_entry_seg	DW	0		;; real mode driver entry segment
;pm_entry_off	DW	0		;; protected mode driver entry offset
;pm_entry_seg	DW	0		;; protected mode driver entry segment
;_EndStruct     NIC_API_Entry

s_PXENV_ENTRY    Struc
signature	db	6 dup(?)	; 'PXENV+'
ver             dw      ?               ; MSB=major, LSB=minor
bytes		db	?		; sizeof s_pxenv_entry
checksum	db	?		; 8-bit checksum of structure,
					; including this byte shoube be zero.
rm_entry_off	dw	?		; 16-bit real-mode segment & offset.
rm_entry_seg	dw	?
pm_entry_off	dw	?		; 16-bit protected mode 32-bit physical
pm_entry_base	dd	?		; address and 16-bit offset.
stack_sel	dw	?		; PROM stack segment.  Will be set
stack_size	dw	?		; to 0 when removed from memory.
base_cs_sel	dw	?		; Base code segment.  Will be set
base_cs_size	dw	?		; to 0 when removed from memory.
base_ds_sel	dw	?		; Base data segment.  Will be set
base_ds_size	dw	?		; to 0 when removed from memory.
mlid_ds_sel	dw	?		; MLID data segment.
mlid_ds_size	dw	?
mlid_cs_sel	dw	?		; MLID code segment.
mlid_cs_size	dw	?
s_PXENV_ENTRY   Ends

;; Ethernet II protocol header
EtherHeader    Struc
E_DestAddr	DB 6 dup (0)	;; destination ethernet addr
E_SrcAddr	DB 6 dup (0)	;; destination ethernet addr
E_Type		DW  ?	;; protocol type
EtherHeader Ends

ETHER_HEADER_LEN	Equ	SIZE EtherHeader

; 
; * Data structures for TransmitChain (Tx), TransferData (TD)
; 
TxDataBlock    Struc
TxPtrType	DB	?	; 0 => Phys pointer, 1 => GDT pointer
TxRsvdByte	DB	?	; Reservered, must be zero.
TxDataLen	DW	?	; Data block length in bytes.
TxDataPtr	DD	?	; Far pointer to data block.
TxDataBlock Ends

; 
; * TransmitChain descriptor structure definition
; 
TxBufDesc    Struc
TxImmedLen	DW	?	; Byte count of immediate data, max=64
TxImmedPtr	DD	?	; Virtual address of Immediate data
TxDataCount	DW	?	; Number of Data Blocks (max = 8)
TxDataBlk	DB	size TxDataBlock * MAX_TX_DATABLK dup(0)
TxBufDesc   Ends

TxBufDescrSize	Equ	Size TxImmedLen + Size TxImmedPtr + Size TxDataCount

; 
; * TransferData data block description
; 
TDDataBlock    Struc
TDPtrType	DB	?	; 0 => Phys pointer, 1 => GDT pointer
TDRsvdByte	DB	?	; Reservered, must be zero.
TDDataLen	DW	?	; Data block length in bytes.
TDDataPtr	DD	?	; Far pointer to data block.
TDDataBlock Ends

; 
; * TransferData descriptor structure
; 
TDBufDesc    Struc
TDDataCount	DW	?	; No of Data Blocks (max 8 for V1.01).
TDDataBlk	DB	size TDDataBlock*MAX_TD_DATABLK dup(0)
TDBufDesc   Ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\smc9432\stdio.asm ===
;--------------------------------------------------------------------
DisplayByte Proc near
; AL has byte to output to tty
;           
                    push    ax
                    mov     ah,0eh  ; write tty
                    int     10h     ; video - write tty            
                    pop     ax
DisplayByteExit:    ret
DisplayByte endp
;--------------------------------------------------------------------
Print   Proc near
;
; Prints a null terminated string to the console
;
; PARMAMETERS: ds:si - pointer to string
;     RETURNS: nothing
;    DESTROYS: nothing
;     ASSUMES: nothing
;
                push	ax
                push    si
printLoop:      mov     al,[si]
                inc     si
                and     al,al                   ; check for zero
        	je	printEnd
                call    DisplayByte
        	jmp	printLoop
printEnd:       pop     si
                pop	ax
	        ret
Print   endp
;--------------------------------------------------------------------
PrintDecimal Proc   near
;
; Prints a number to the console in decimal
;
; PARMAMETERS: AX - has the number (in binary) to print
;     RETURNS: nothing
;    DESTROYS: nothing
;     ASSUMES: nothing
;
	        pusha
        	xor	cx, cx          ; cx = 0
        	mov	dx, cx          ; dx = 0
        	mov	bx, 10          ; bx = 10
__loop1:        div	bx              ; ax/10
        	push	dx      	; save digit on stack
        	inc	cx		; inc digit counter
        	xor	dx, dx		; clear remainder
        	or	ax, ax		; check for more digits
        	jne	__loop1
__loop2:        pop	ax              ; get 1st item off stack
        	add	al, '0'         ; make ASCII
                call    DisplayByte
        	loop	__loop2         ; do for each digit on stack
        	popa
	        ret
PrintDecimal    endp
;--------------------------------------------------------------------
PrintHexDword   Proc    near
                push    eax
                shr     eax,16      ; print high word 1st
                call    PrintHexWord
                pop     eax
                call    PrintHexWord
                ret
PrintHexDword   endp
;--------------------------------------------------------------------
PrintHexWord    Proc near
;
; Prints a number to the console in hex
;
; PARMAMETERS: AX - has the number (in binary) to print
;     RETURNS: nothing
;    DESTROYS: nothing
;     ASSUMES: nothing
;
                push    ax
                push    bx
        	mov	bx, ax
        	mov	al, bh
        	call	PrintHexByte
	        mov	al, bl
        	call	PrintHexByte
                pop     bx
                pop     ax
	        ret
PrintHexWord    endp
;--------------------------------------------------------------------
PrintHexByte   Proc    near
;	AL - number to print
; PARMAMETERS: AL has the number (in binary) to print
;     RETURNS: nothing
;    DESTROYS: nothing
;     ASSUMES: nothing
;
        	push	ax			; save word
        	rol	al, 4
	        call	HexDigit
        	pop	ax
hexDigit:      	push	ax
        	and	al, 00001111b
	        add	al, 90h
        	daa
        	adc	al, 40h
        	daa
                call    DisplayByte
        	pop	ax
        	ret
PrintHexByte    endp
;--------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\smc9432\spdosegs.inc ===
; Modifications:   $Header: /Client Boot/NICS/Generic/UNDI_NAD/SPDOSEGS.INC 1     16/07/98 5:33p Dmitry Klimenko $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;
;   Description: segment declaration and ordering for NDIS driver
;-----------------------------------------------------------------------
; Functional Description
;
;   This file defines the segments used by a MAC driver and the order
;   in which they are loaded. The groups DGROUP (for data) and CGROUP
;   (for code) are also defined, as are macros to open and close
;   segments (which also set up the default segment assumptions).
;-----------------------------------------------------------------------
; DOS segment definitions and ordering.
;==========================================================================
Ifdef DRV
DevHeaderSeg   segment para public USE16 'CODE'
DevHeaderSeg   ends
Endif	
;--------------------------------------------------------------------------
; Resident Code segment - code that is used after init time
; (unfortunately, this includes code to bind another driver, and
; initializations that take place at bind time) should be placed in this
; segment.
;--------------------------------------------------------------------------
_TEXT       segment para public USE16 'CODE'
_TEXT       ends

Ifdef DRV
ICODE       segment para public USE16 'INIT'
ICODE       ends
ENDIF	
;--------------------------------------------------------------------------
; Resident Data segment - things put here will remain in memory after
; init time. At the present time, this is in low memory, so data that is
; not used after init time should NOT be put in this segment.
;--------------------------------------------------------------------------
_DATA       segment para public USE16 'DATA'
_DATA       ends

Ifdef DRV
_BSS       segment para public USE16 'DATA'
_BSS       ends
IDATA       segment para public USE16 'DATA'
IDATA       ends
Else
_BSS       segment para public USE16 'BSS'
_BSS       ends
ENDIF
;--------------------------------------------------------------------------
; Make sure the segment order defined in this file is respected.
;--------------------------------------------------------------------------
.SEQ               
;--------------------------------------------------------------------------
; DOS Group is all one 64K segment, CS=SS=DS, use equate for DGROUP.
;--------------------------------------------------------------------------
Ifdef DRV
    CGROUP      group   DevHeaderSeg, _TEXT, ICODE
    DGROUP      group   _DATA, _BSS, IDATA
ELSE
    CGROUP      group   _TEXT
    DGROUP      group   _DATA, _BSS
ENDIF	
;--------------------------------------------------------------------------
; Group is 64K data, 64K code, CS!=SS=DS, actual group for Code.
;--------------------------------------------------------------------------
; Assume statement here takes care of for any source, same for OS2 and DOS.
;--------------------------------------------------------------------------
    Assume   CS:CGROUP, DS:DGROUP, ES:NOTHING, SS:NOTHING

START_CODE	macro
_TEXT		segment Public 'Code'
		assume ds:DGroup,cs:cGroup,es:nothing,ss:nothing
		endm

END_CODE	macro
_TEXT		ends
		endm

START_DATA	macro
_Data		segment Public 'Data'
		assume ds:DGroup,cs:CGroup,es:nothing,ss:nothing
		endm

END_DATA	macro
_Data		ends
		endm

; 2 macros by John to let you easily insert data fragments into code
;
; This macro assumes that Code is open, closes it, and opens data.
OPEN_DATA       macro
    END_CODE
    START_DATA
                endm

; This macro closes the open data and re-opens the Code segment.
CLOSE_DATA      macro
    END_DATA
    START_CODE
                endm


; EOF - $Workfile: SPDOSEGS.INC $
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\smc9432\lm9432cf.asm ===
;----------------------------------------------------------------------------
;
;$History: LM9432CF.ASM $
; 
; *****************  Version 1  *****************
; User: Paul Cowan   Date: 26/08/98   Time: 9:31a
; Created in $/Client Boot/NICS/SMC/9432/UNDI
;
;
;$NoKeywords: $
;
;----------------------------------------------------------------------------

;****************************************************************************
;****************************************************************************
;*                                                                          *
;*          LM9432CF.ASM -  Get Config for LM 9432 driver  *
;*                                                                          *
;*          Copyright (C) 1995 Standard MicroSystems Corporation            *
;*                        All Rights Reserved.                              *
;*                                                                          *
;*                Contains confidential information and                     *
;*                     trade secrets proprietary to:                        *
;*                                                                          *
;*                  Standard MicroSystems Corporation                       *
;*                            6 Hughes	  
;*                           Irvine, CA                                     *
;*                                                                          *
;*                                                                          *
;****************************************************************************
;*                                                                          
;* History Log:                                                             
;*
;* Standard Microsystem LMAC Get Config module.
;*
;* Written by:     najay
;* Date:           2/14/95
;*
;* By         Date     Ver.   Modification Description
;* ------------------- -----  --------------------------------------
;*                                       
;****************************************************************************

;****************************************************************************
;
; Function:     LM_GetCnfg
;
; Synopis:      Find an adapter 
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************


ASM_PCI_PROC    LM_GetCnfg
	push	edx
	push	ecx
	push	ebx
	push	di
	push	si

; make sure the upper thinks we are pci
	cmp	pAS.pc_bus, PCI_BUS
	jne	pci_cnfg_fail

; check for a pci bios 
	mov	ah, PCI_FUNCTION_ID
	mov	al, PCI_BIOS_PRESENT

	call	UM_Card_Services
	jc	pci_cnfg_fail

IFDEF CODE_386
	cmp	dx, 'CP'
ELSE
	cmp	edx, ' ICP'		; 'PCI ' backwards
ENDIF
	jne	pci_cnfg_fail

; find the adapter 
	mov	ah, PCI_FUNCTION_ID
	mov	al, FIND_PCI_DEVICE
	mov	cx, EPC_ID_EPIC_100
	mov	dx, EPC_ID_SMC
	movzx	si, pAS.slot_num
	sub	si, 16			; follow dec's convention for
	call	UM_Card_Services	; PCI slot numbering
        jnc     pci_adapter_found

; check for 9032
	mov	ah, PCI_FUNCTION_ID
	mov	al, FIND_PCI_DEVICE
        mov     cx, EPC_ID_EPIC_C
	call	UM_Card_Services	
	jc	pci_cnfg_fail
pci_adapter_found:
	
; save card specific info 
	mov	pAS.busnumber, bh
	mov	pAS.vslotnumber, bl
	
; get irq value 
	mov	ah, PCI_FUNCTION_ID
	mov	al, PCI_READ_CONFIG_BYTE
	mov	di, EPC_INT_LINE 
	call	UM_Card_Services
	jc	pci_cnfg_fail

	mov 	byte ptr  pAS.irq_value, cl	

; enable memory mapped config registers 
	mov	ah, PCI_FUNCTION_ID
	mov	al, PCI_WRITE_CONFIG_WORD
	mov	di, EPC_PCI_COMMAND
	mov	cx, PCIC_MEM_SPACE_ENABLE + PCIC_BUSMASTER_ENABLE + PCIC_IO_SPACE_ENABLE
	call	UM_Card_Services
	jc	pci_cnfg_fail

; get address of pci registers
	mov	ah, PCI_FUNCTION_ID
	mov	al, PCI_READ_CONFIG_DWORD
	mov	di, EPC_MEM_ADDR
	call	UM_Card_Services
	jc	pci_cnfg_fail

	mov	pAS.ram_base, ecx

; get iobase of pci registers
	mov	ah, PCI_FUNCTION_ID
	mov	al, PCI_READ_CONFIG_DWORD
	mov	di, EPC_IO_ADDR
	call	UM_Card_Services
	jc	pci_cnfg_fail

	and	ecx, IO_BASE_ADDR
	mov	pAS.io_base, cx

; get subsystem ID
	mov	ah, PCI_FUNCTION_ID
	mov	al, PCI_READ_CONFIG_WORD
	mov	di, EPC_SYSTEM_ID
	call	UM_Card_Services
	jc	pci_cnfg_fail

	mov	pAS.card_SSID, cx

; copy name into adapter area
	lea	rdi, pAS.adapter_name
	mov	dx, (EPC_EEPROM_SW_OFFSET + EPM_NAME) SHR 1 ; address of adapter name
	mov	cx, 6				; number of words in name

pci_cnfg_an_loop:
	call	eeprom_read
	xchg	al, ah
	mov	pDST, ax
	add	rdi, 2
	inc	dx
	loop	pci_cnfg_an_loop	
	dec	rdi
	mov	byte ptr pDST, 0

; set adapter_flags
	or	pAS.adapter_flags, RX_VALID_LOOKAHEAD
	or	pAS.adapter_flags1, NEEDS_MEDIA_TYPE + TX_PHY +	RX_PHY + NEEDS_HOST_RAM

; set media type
	mov	dx, (EPC_EEPROM_SW_OFFSET + EPM_MEDIA_TYPE2) SHR 1 ; address of media_type2
        call    eeprom_read
        mov     pAS.media_type2, ax
        inc     dx
        call    eeprom_read
        mov     pAS.line_speed, ax

; autodetect stuff moved to LM_Initialize_Adapter in init_mii_registers
; autodetect stuff would go here
;	mov	pAS.media_type, MEDIA_STP100_UTP100

pci_media_type_set:

; set adapter bus
	mov	pAS.bic_type, BIC_EPIC100_CHIP
	mov	pAS.nic_type, NIC_EPIC100_CHIP
	mov	pAS.adapter_bus, BUS_PCI_TYPE
	mov     rax, ADAPTER_AND_CONFIG

pci_cnfg_done:
	pop	si
	pop	di
	pop	ebx
	pop	ecx
	pop	edx
	ret

pci_cnfg_fail:
	mov	rax, ADAPTER_NOT_FOUND	
	jmp	short pci_cnfg_done

ASM_PCI_PROC_END LM_GetCnfg

;****************************************************************************
;
; Function:     eeprom_read
;
; Synopis:      fetches a word from the eeprom
;
; Input:        ds:bp (ebp)	AdapterStructure
; 		dx		address
;
; Output:       ax 		word fetched
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    eeprom_read

; set chip select
	mov	al, EEC_ENABLE or EEC_CHIP_SELECT
	call	eeprom_register_write

; send read command and address
	call	eeprom_register_read
	test	al, EEC_SIZE
	mov	ax, dx
	jz	eepr_128k
	and	ax, 03fh
	or	ax, 180h
	jmp	eepr_write

eepr_128k:
	and	ax, 0ffh
	or	ax, 600h

eepr_write:
	call	eeprom_output_word

; read data
	call	eeprom_input_word
	xchg	al, ah

; clear chip select
	push	ax
	mov	al, EEC_ENABLE
	call	eeprom_register_write
	pop	ax

	ret

ASM_PCI_PROC_END eeprom_read


;****************************************************************************
;
; Function:     eeprom_input_word
;
; Synopis:      fetches a word from the eeprom
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax 		word fetched
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    eeprom_input_word
	push	cx
	push	bx

	mov	cx, 16
	mov	bx, 0

eep_iw_loop:
	mov	al, EEC_ENABLE or EEC_CHIP_SELECT
	call	eeprom_clock

	shl	bx, 1
	test	al, EEC_DATAOUT
	jz	eep_iw_data0
	inc	bx

eep_iw_data0:
	loop	eep_iw_loop

	mov	ax, bx
	pop	bx
	pop	cx
	ret

ASM_PCI_PROC_END eeprom_input_word

;****************************************************************************
;
; Function:     eeprom_output_word
;
; Synopis:      fetches a word from the eeprom
;
; Input:        ds:bp (ebp)	AdapterStructure
; 		ax		address
;
; Output:       ax 		word fetched
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    eeprom_output_word
	push	cx
	push	bx

	mov	cx, 16
	mov	bx, ax

eep_ow_loop:
	rol	bx, 1
	mov	al, EEC_ENABLE or EEC_CHIP_SELECT
	jnc	eep_ow_data0
	or	al, EEC_DATAIN

eep_ow_data0:
	call	eeprom_clock
	loop	eep_ow_loop

	mov	ax, bx
	pop	bx
	pop	cx
	ret

ASM_PCI_PROC_END eeprom_output_word

;****************************************************************************
;
; Function:     eeprom_clock
;
; Synopis:      fetches a word from the eeprom
;
; Input:        ds:bp (ebp)	AdapterStructure
; 		ax		address
;
; Output:       ax 		word fetched
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    eeprom_clock

; write register with clock low
	call	eeprom_register_write

; write register with clock high
	push	ax
	or	al, EEC_CLOCK
	call	eeprom_register_write
	pop	ax

; write register with clock low
	call	eeprom_register_write

	call	eeprom_register_read
	ret

ASM_PCI_PROC_END eeprom_clock

;****************************************************************************
;
; Function:     eeprom_register_write
;
; Synopis:      outputs a bte to EEPROM and waits for data valid
;
; Input:        ds:bp (ebp)	AdapterStructure
; 		al		byte to write
;
; Output:       None
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    eeprom_register_write
	push	dx
	push	cx
	push	ax

	mov	dx, pAS.io_base
	add	dx, EPC_EEPROM_CONTROL
	out	dx, al

; wait for eeprom ready
	mov	cx, 0fffh

eep_rw_loop:
	in	al, dx
	and	al, EEC_READY
	loopz	eep_rw_loop

	pop	ax
	pop	cx
	pop	dx
	ret

ASM_PCI_PROC_END eeprom_register_write

;****************************************************************************
;
; Function:     eeprom_register_read
;
; Synopis:      inputs a byte from the eeprom
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       al 		byte fetched
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    eeprom_register_read
	push	dx

	mov	dx, pAS.io_base
	add	dx, EPC_EEPROM_CONTROL
	in	al, dx

	pop	dx
	ret

ASM_PCI_PROC_END eeprom_register_read
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\smc9432\undi_equ.inc ===
;
;--- Miscellaneous Equates
;
NULL            equ     0
CR		equ	0Dh           ;- Carriage Return
LF		equ	0Ah           ;- Line Feed
FALSE		equ	0
TRUE		equ	1
;
;--- Ethernet Frame Sizes
;
ETHERNET_ADDRESS_LENGTH		equ	6
ETHERNET_HEADER_SIZE		equ	14
MINIMUM_ETHERNET_PACKET_SIZE	equ	60
;MAXIMUM_ETHERNET_PACKET_SIZE	equ	1514
MAXIMUM_ETHERNET_PACKET_SIZE	equ	1500 ;; just data, not media header

MAX_PACKET         Equ       1514      ; Maximum allowable packet size.
MIN_PACKET         Equ       60        ; Minimum allowable packet size.
; 
;--- Packet filter bit definitions
; 
FLTR_DIRECTED                Equ       01H
FLTR_MLTCST                  Equ       01H
FLTR_BRDCST                  Equ       02H
FLTR_PRMSCS                  Equ       04H
FLTR_SRC_RTG                 Equ       08H
;
;--- Processor Type Equates
;
EIGHT_BIT          equ       0001H
SIXTEEN_BIT        equ       0002H
PROC_TYPE_MASK     equ       0030H

PROC_8086          equ       0000H OR EIGHT_BIT
PROC_80286         equ       0010H OR SIXTEEN_BIT
PROC_80386         equ       0020H
PROC_80486         equ       0040H
;
;--- Result codes returned in AX by a PXE API service.
;
PXENV_EXIT_SUCCESS		equ	0
PXENV_EXIT_FAILURE		equ	1
PXENV_EXIT_CHAIN		equ	0FFFFh	; used internally
;
;--- Status codes returned in the status word of PXE API parameter structures.
;
PXENV_STATUS_SUCCESS		equ	0
PXENV_STATUS_FAILURE		equ	1	;general failure
PXENV_STATUS_BAD_FUNC		equ	2	;invalid function number
PXENV_STATUS_UNSUPPORTED	equ	3	;not yet supported
PXENV_STATUS_1A_HOOKED		equ	4	;Int 1AH cannot be unhooked

; Driver errors (60 to 0x6F)
; These errors are for UNDI compatible NIC drivers.
PXENV_STATUS_UNDI_MEDIATEST_FAILED 		equ	61h
PXENV_STATUS_UNDI_CANNOT_INIT_NIC_FOR_MCAST	equ	62h
;
;
EISA_ADAPTER             equ    1
PCI_ADAPTER              equ    2
PnP_ADAPTER              equ    3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\smc9432\undi_nad.asm ===
page	,132
;************************************************************************
;*  UNDI_NAD.ASM :-							*
;*  Universal NIC Driver Interface (UNDI) for Bootware's NAD            *
;*									*
;*  (C) Lanworks Technologies Inc. 1997.  All rights reserved.		*
;*									*
;*  Revision history:-							*
;*  970624  0.10  RL	- Init version for NetPC Spec v1.0b		*
;*  970508  0.00  RL	- Init version for NetPC Spec v0.9		*
;*  980504        JL    - Revised for making our UNDI's for Goliath     *
;************************************************************************
;------------------------------------------------------------------------------
;                       DEBUG       CONSTANTS
;------------------------------------------------------------------------------
_NOP        EQU     090h        ; define a NOP to put in BREAK definition
DEBUG_BREAK EQU     0CCh        ; int 3 for TurboDebug and Debug
ARIUM_BREAK EQU     0F1h        ; 0F1h for Arium breakpoint
;
;BREAK EQU   db ARIUM_BREAK     ; change this for your breakpoint opcodes
;BREAK EQU DB DEBUG_BREAK
BREAK EQU DB _NOP

;_DEBUG      equ 1       ; makes linked in code start at 1000H
;_VERBOSE    equ 1       ; makes progress messages show up
;------------------------------------------------------------------------------

LSA_MAJOR	equ	0           ; Version #'s
LSA_MINOR	equ	99

.xlist

MTU		equ	1514	;max size for a completed Ethernet packet
NUM_ED		equ	5	;number of EDs

TYPE_UCAST	equ	0
TYPE_BCAST	equ	1
TYPE_MCAST	equ	2

include 	undi_equ.inc
include 	pxe_stru.inc
include 	bwstruct.inc
include 	pci.inc
include 	pcinic.inc
include 	spdosegs.inc

extern	NADInit:near
extern	NADReset:near
extern	NADShutDown:near
extern	NADOpen:near
extern	NADClose:near
extern	NADTransmitPacket:near
extern	NADSetFilter:near
extern	NADGetStatistics:near
extern	NADMCastChange:near
extern	DriverISR_Proc:near
extern  NADSetMACAddress:near       ; * NEW
extern  NADInitiateDiags:near       ; * NEW

extern  OrgIntVector_Off:WORD
extern  OrgIntVector_Seg:WORD

public	IOBase              ; NIC's I/O base address (WORD)
public	ROMBase
public	PCIBusDevFunc
public  VendorId            ; filled in at runtime by this code
public  DeviceId            ; filled in at runtime by this code
public  SimulateInterrupts  ; lower level code will set this if hardware
                            ; ints are NOT used
public  NicIntsEnabled      ; lower level code should set & clr this to reflect
                            ; when hardware ints on the nic are enabled
public  Print               ; prints string pointed to by DS:SI
public  DisplayByte         ; prints byte in AL
public  PrintDecimal        ; prints value in AX as decimal
public  PrintHexWord        ; prints value in AX as hexadecimal
public  PrintHexByte        ; prints value in AL as hexadecimal

public	GetED
public	PostED
public	Net_Address         ; the changeable NIC address for this card
public	Node_Address        ; the permanent NIC address for this card
public	BusType
public	IRQNumber
public	RecFilter
public	UNDI_DriverISR
public	MultiCast_Addresses
public	EDListHead
public	EDListTail
public	EDListCurrent

.list
;******************************************************************************
_TEXT		Segment para public
	assume	cs:CGroup, ds:DGroup
;==========================================================================
; PXENV_UNDI_API:
;=================
;
; Entry:	BX contains function number
;		ES:DI contains parameter block
;
; Exit: 	AX contains success/failure code,
;		CF cleared on success, set on error,
;		all other registers are preserved.
;==========================================================================
	public	PXENV_UNDI_API			; must always be at offset 0
.386
PXENV_UNDI_API	proc	far
                nop
                BREAK           ; defined at top of file
		push	ebp
		push	ebx
		push	ecx
		push	edx
		push	edi
		push	esi
		push	ds
		push	es
		push	fs
;
		cmp	bx, 1
		jb	API_Bad
		je	call_function

		cmp	bx, UNDI_APIMaxFunc
		ja	API_Bad

;  assumed startup is over and dataseg is valid
        	mov 	ax, cs:ApiEntry.mlid_ds_sel
	        mov 	ds, ax
call_function:
;
; TIP - code to print function # that is being called in UNDI
;       Put this code (and the code right after the call) back in if you
;       want to see when the UNDI code is entered and exited while you're
;       in the debugging stages.
;
;;  push    si
;;  push    ax
;;  mov     ax,bx
;;  call    PrintHexWord            ; print UNDI function # called
;;  pop     ax
;;  mov     si,offset msg_Entry     ; print "Entering UNDI"
;;  call    Print
;;  mov     si,offset msg_CRLF
;;  call    Print
;;  pop     si

		DEC	BX
	JZ	SKIPAHEAD	; skip if force interrupt
		NOP             ; Dimitry -> set BP here for other functions

SkipAhead:	shl	bx, 1                       ; * 2 for word table
		call	cs:NIC_Export_Table[bx]     ; near call
;
;              pushf                               ; save error status
;              push    si
 ;             mov     si,offset msg_Exit
;              call    Print                       ; print "Exiting UNDI"
;;              pop     si
;;              popf                                ; restore error status
;
		jc	API_err_ret
		xor	ax, ax
		jmp	API_Done
;
API_err_ret:	mov	ax, -1
		jmp	API_Err
API_Bad:	mov	ax, PXENV_STATUS_BAD_FUNC
API_Err:	stc
API_Done:	pop	fs
		pop	es
		pop	ds
		pop	esi
		pop	edi
		pop	edx
		pop	ecx
		pop	ebx
		pop	ebp
		ret
;
PXENV_UNDI_API	Endp
;------------------------------------------------------------------------------
Old_1A		dd	0	;address of previous int 1A ISR

	align	4
	public	NIC_Export_Table

NIC_Export_Table	label	word
		dw	OFFSET CGROUP:UNDI_StartUp
		dw	OFFSET CGROUP:UNDI_CleanUp
		dw	OFFSET CGROUP:UNDI_Initialize
		dw	OFFSET CGROUP:UNDI_ResetAdapter
		dw	OFFSET CGROUP:UNDI_ShutDown
		dw	OFFSET CGROUP:UNDI_OpenAdapter
		dw	OFFSET CGROUP:UNDI_CloseAdapter
		dw	OFFSET CGROUP:UNDI_Transmit
		dw	OFFSET CGROUP:UNDI_SetMCastAddr
		dw	OFFSET CGROUP:UNDI_SetStationAddress
		dw	OFFSET CGROUP:UNDI_SetPacketFilter
		dw	OFFSET CGROUP:UNDI_GetNICInfo
		dw	OFFSET CGROUP:UNDI_GetStatistics
		dw	OFFSET CGROUP:UNDI_ClearStatistics
		dw	OFFSET CGROUP:UNDI_InitDiags
		dw	OFFSET CGROUP:UNDI_ForceInterrupt
		dw	OFFSET CGROUP:UNDI_GetMCastAddr
		dw	OFFSET CGROUP:UNDI_GetNICType

UNDI_APIMaxFunc equ	($ - NIC_Export_Table)/2

;==========================================================================
; UNDI_StartUp
;==============
; Description:	Hooks INT 1AH and saves DataSeg, Dev_ID values
;
; Entry:	called from PXENV_UNDI_API for boot-rom.
;		ES:DI contains NIC_StartUp Pointer
;
; Exit: 	AX contains success/failure code,
;		CF cleared on success, set on error, and
;		the status field in parameter structure is set.
;==========================================================================
UNDI_StartUp	proc	 near
;
; set the physical address of the API entry structure
		xor	eax, eax
		mov	ax, cs
		shl	eax, 4
		add	eax, offset CGroup:ApiEntry
		mov	cs:ApiEntryPhyAddr, eax

	;; set local ds from es:di...
		mov	ds, (NIC_StartUp ptr es:[di]).S_DataSeg

; save the data segment selector and size in API Entry structure
		lea	bx, CGroup:ApiEntry

		mov	ax, (NIC_StartUp ptr es:[di]).S_DataSegSize
		mov 	(s_PXENV_ENTRY ptr cs:[bx]).mlid_ds_size, ax
		mov 	(s_PXENV_ENTRY ptr cs:[bx]).mlid_ds_sel, ds

		mov	ax, (NIC_StartUp ptr es:[di]).S_CodeSegSize
		mov 	(s_PXENV_ENTRY ptr cs:[bx]).mlid_cs_size, ax
		mov 	(s_PXENV_ENTRY ptr cs:[bx]).mlid_cs_sel, cs

		mov 	(s_PXENV_ENTRY ptr cs:[bx]).rm_entry_seg, cs
		mov 	(s_PXENV_ENTRY ptr cs:[bx]).rm_entry_off, offset cs:PXENV_UNDI_API

		mov 	(s_PXENV_ENTRY ptr cs:[bx]).pm_entry_off, 0
		mov 	(s_PXENV_ENTRY ptr cs:[bx]).pm_entry_base, 0

		mov 	(s_PXENV_ENTRY ptr cs:[bx]).stack_sel, 0
		mov 	(s_PXENV_ENTRY ptr cs:[bx]).stack_size, 0

		mov 	(s_PXENV_ENTRY ptr cs:[bx]).base_cs_sel, 0
		mov 	(s_PXENV_ENTRY ptr cs:[bx]).base_cs_size, 0

		mov 	(s_PXENV_ENTRY ptr cs:[bx]).base_ds_sel, 0
		mov 	(s_PXENV_ENTRY ptr cs:[bx]).base_ds_size, 0

		mov	dword ptr (s_PXENV_ENTRY ptr cs:[bx]).signature, 4e455850h ; PXENV+
		mov	word ptr (s_PXENV_ENTRY ptr cs:[bx]).signature+4, 2b56h	   ; PXENV+

		mov 	(s_PXENV_ENTRY ptr cs:[bx]).ver, (LSA_MAJOR shl 8) or LSA_MINOR
		mov 	(s_PXENV_ENTRY ptr cs:[bx]).bytes, SIZE s_PXENV_ENTRY

		xor	al, al
		mov	(s_PXENV_ENTRY ptr cs:[bx]).checksum, al

		push	bx
		mov	cx, sizeof s_PXENV_ENTRY
@@:		add	al, cs:[bx]
		inc	bx
		loop	@B
		pop	bx

		sub	(s_PXENV_ENTRY ptr cs:[bx]).checksum, al

		mov	ax, word ptr (NIC_StartUp ptr es:[di]).S_BusDevFunc
		mov	DGroup:PCIBusDevFunc, ax

		mov	al, byte ptr (NIC_StartUp ptr es:[di]).S_BusType
		mov	BusType, al

; chain int 1Ah
		push	es
		push	bx

		xor	ax, ax
		mov	es, ax
		mov	bx, 1Ah * 4		; 1Ah * 4
		mov	eax, es:[bx]		; old ISR
		mov	dword ptr cs:Old_1A, eax
		mov	ax, cs
		shl	eax, 16
		lea	ax, cs:Int1A_ISR
		pushf
			cli
			mov	dword ptr es:[bx], eax
		popf
		POP	bx 	; JL patch
		pop	es
;
; take PCIBusDevFunc # and get DeviceID and VendorID values
;
; code to find out the DeviceId & VendorID from the BusDevFunc value
;
		push	di	; JRL
                mov     ax,0B101h   ; test PCI BIOS present
                int     1Ah
                jc      StartUpError    ; error for carry
                and     ah,ah
                jnz     StartUpError    ; error for AH != 0
                cmp     edx,020494350h  ;
                jne     StartUpError    ; error for bad PCI signature
;
                mov     ax,0B109h   ; read config word
                mov     bx,PCIBusDevFunc
                sub     di,di       ; read config reg 0000 - VendorID
                int     1Ah         ; do it
                jc      StartUpError ; error out
                and     ah,ah
                jnz     StartUpError    ; error for AH != 0

                mov     VendorID,cx ; put it in
;
                mov     ax,0B109h   ; read config word
                mov     bx,PCIBusDevFunc
                mov     di,2        ; read config reg 0002 - DeviceID
                int     1Ah         ; do it
                jc      StartUpError ; error out
                and     ah,ah
                jnz     StartUpError    ; error for AH != 0

                mov     DeviceID,cx ; put it in
;
                mov     ax,0B10Ah        ; read config dword
                mov     bx,PCIBusDevFunc
                mov     di,02Ch         ; Subsystem Id & Subsystem VendorId
                int     1Ah             ; do it
                jc      StartUpError
                and     ah,ah
                jnz     StartUpError    ; error for AH != 0
                mov     SubSystem_Id,ecx
;
		pop	di	; JL
		mov	ax, PXENV_EXIT_SUCCESS
		mov	word ptr es:[di], PXENV_STATUS_SUCCESS
		clc
		ret
STARTUPERROR:   pop	di
		MOV	WORD PTR ES:[DI], PXENV_STATUS_FAILURE
          	mov	ax, PXENV_EXIT_FAILURE
		stc
		ret
UNDI_StartUp	endp
;------------------------------------------------------------------------------
Int1A_ISR	proc	far
;
		cmp	ax, 5650h		; VP, signature check
		jne	old_isr1A
		lea	bx, cs:ApiEntry
		push	cs
		pop	es                      ; ES = CS

; es:bx has s_PXENV_ENTRY structure

		mov	ax, 564eh	        ;; VN
		mov	edx, cs:ApiEntryPhyAddr	;; physical address of the entry structure
		push	bp
		mov	bp, sp
		and	word ptr [bp+6], not 1      ; clr carry on stack
		pop	bp
		iret
;
old_isr1A:	push	word ptr cs:Old_1A+2
		push	word ptr cs:Old_1A
		retf			; far jump to the previous ISR
;
Int1A_ISR	endp
;==========================================================================
; UNDI_CleanUp
;==============
; Entry:	called from PXENV_UNDI_API for boot-rom.
;		ES:DI contains ParamBlock Pointer
;
; Exit: 	AX contains success/failure code,
;		CF cleared on success, set on error, and
;		the status field in parameter structure is set.
;==========================================================================
UNDI_CleanUp	proc	near
;
; unhook the int1A
;
		cli
		push	es

		xor	ax, ax
		mov	es, ax                  ; ES = 0000 (I.V.T)
		mov	bx, 1Ah * 4             ; int 1A offset
		mov	eax, es:[bx]		; current ISR
		cmp	ax, cs:Int1A_ISR	; is this ours?
		jne	Cant_unhook
		shr	eax, 16
		mov	cx, cs
		cmp	ax, cx
		jne	Cant_unhook
		mov	eax, dword ptr cs:Old_1A
		mov	dword ptr es:[bx], eax
Cant_unhook:    pop     es
		mov	ax, PXENV_EXIT_SUCCESS
		mov	word ptr es:[di], PXENV_STATUS_SUCCESS
		clc
		jmp short CleanUp_Exit
;
;Cant_unhook:    pop     es
;                mov     ax, PXENV_EXIT_FAILURE
;                mov     word ptr es:[di], PXENV_STATUS_1A_HOOKED
;                stc
CleanUp_Exit:	sti                             ; re-allow interrupts
                ret
;
UNDI_CleanUp	endp
;==========================================================================
; UNDI_Initialize
;=================
; Description:	Resets the adapter with default parameters but does not
;		enable the Tx and Rx units.
;
; Entry:	ES:DI contains NIC_Initialize pointer
;
; Exit: 	AX contains success/failure code,
;		CF cleared on success, set on error, and
;		the status field in parameter structure is set.
;==========================================================================
UNDI_Initialize proc	near
BREAK
	push	es
		push	di

		mov	eax, (NIC_Initialize ptr es:[di]).I_RcvInt
		mov	RxCallback, eax         ; save ptr to Applications callback routine
		mov	eax, (NIC_Initialize ptr es:[di]).I_GenInt
		mov	GenIntCallback, eax     ; callback for ints other than receive

; We don't care to save prot_INI pointer as we don't use it.
;
                mov     bx,PCIBusDevFunc       ; by JON
		cmp	IsInitialized,0			; is it already init'ed?
                jne     PPI_Err2                                ; yes, skip
IFDEF _VERBOSE
                push    si
                mov     si,offset msg_callNADInit
                call    Print
                pop     si
ENDIF
		call	NADInit			;Don't hook INT in NADInit
        					; if it fails
IFDEF _VERBOSE  ; print success or fail msg for NADInit
                pushf                           ; save for carry test later
                push    si
                mov     si,offset msg_NADInitOK ; set ok msg
                jnc     NADInitRetOK            ; branch if really ok
                mov     si,offset msg_NADInitErr ; set error msg
NADInitRetOK:   call    Print
                pop     si
                popf
ENDIF
		jc	PPI_Err
PPI_Err2:       mov             IsInitialized,1                 ; set state variable
; JL - copy 6 byte address from Net_Address to Node_Address so driver code
;      doesn't have to worry about it

                mov     ax,ds
                mov     es,ax           ; let ES = DS
                cld
                mov     si,offset DGroup:Net_Address
                mov     di,offset DGroup:Node_Address
                mov     cx,3            ; 6 bytes = 3 words
           rep  movsw
; end JL code
		call	InitEDMemory

		mov	ForcedINT, FALSE        ; set default value
		mov	NeedIndComplete, FALSE

		pop	di
		pop	es
		mov	ax, PXENV_EXIT_SUCCESS
		mov	word ptr es:[di], PXENV_STATUS_SUCCESS
		clc
		ret

PPI_Err: 	pop	di
	 	pop	es
	 	cmp	ax, 2
	 	jz	MediaFail
	 	mov	word ptr es:[di], PXENV_STATUS_FAILURE
	 	jmp	init_err
MediaFail:      mov	word ptr es:[di], PXENV_STATUS_UNDI_MEDIATEST_FAILED
init_err: 	mov	ax, PXENV_EXIT_FAILURE
	  	stc
	  	ret
;
UNDI_Initialize endp
;==========================================================================
; UNDI_ResetAdapter
;===================
; Description:	Resets and reinitializes the adapter with the same set
;		of parameters supplied to Initialize routine, and
;		opens the adapter, i.e. connects logically to network.
;
; Entry:	ES:DI contains NIC_Reset pointer
;
; Exit: 	AX contains success/failure code,
;		CF cleared on success, set on error, and
;		the status field in parameter structure is set.
;==========================================================================
UNDI_ResetAdapter	proc	near

		cmp	IsInitialized,0		; if not init'd error out of here
		jne	Ok2Reset
		jmp	short ResetOkExit
;;		mov	ax, PXENV_EXIT_FAILURE
;;		mov	word ptr es:[di], PXENV_STATUS_FAILURE
;;		stc
;;		ret
Ok2Reset:	push	es
		push	di
      		call	UNDI_CloseAdapter
;
IFDEF   _VERBOSE
                push    si
                mov     si,offset msg_callNADReset
                call    Print
                pop     si
ENDIF
		call	NADReset
IFDEF _VERBOSE                      ; print success or fail msg for NADReset
                pushf                           ; save for carry test later
                push    si
                mov     si,offset msg_NADResetOK    ; set ok msg
                jnc     NADResetRetOK               ; branch if really ok
                mov     si,offset msg_NADResetErr   ; set error msg
NADResetRetOK:  call    Print
                pop     si
                popf
ENDIF
IFDEF   _VERBOSE
                push    si
                mov     si,offset msg_callNADOpen
                call    Print
                pop     si
ENDIF
		call	NADOpen

IFDEF _VERBOSE  ; print success or fail msg for NADOpen
                pushf                           ; save for carry test later
                push    si
                mov     si,offset msg_NADOpenOK ; set ok msg
                jnc     NADOpenRetOK            ; branch if really ok
                mov     si,offset msg_NADOpenErr ; set error msg
NADOpenRetOK:   call    Print
                pop     si
                popf
ENDIF
                jnc      @F
		pop	di
		pop	es
		mov	ax, PXENV_EXIT_FAILURE
		mov	word ptr es:[di], PXENV_STATUS_FAILURE
		stc
		ret
;
@@:		mov	DGroup:IsOpen,1
		mov	ax, RecFilter

IFDEF   _VERBOSE
                push    si
                mov     si,offset msg_callNADSetFilter
                call    Print
                pop     si
ENDIF
		call	NADSetFilter
IFDEF _VERBOSE  ; print success or fail msg for NADInit
                pushf                           ; save for carry test later
                push    si
                mov     si,offset msg_NADSetFilterOK ; set ok msg
                jnc     NADSetFilterOK            ; branch if really ok
                mov     si,offset msg_NADSetFilterErr ; set error msg
NADSetFilterOK: call    Print
                pop     si
                popf
ENDIF
;
;- Set ES:SI = Multicast list, Set CX to # of MC entries.
;
		mov	cx, (NIC_Reset ptr es:[di]).R_MCBuf.MC_MCastAddrCount
		lea	si, (NIC_Reset ptr es:[di]).R_MCBuf.MC_MCastAddr
		mov	ax, 1			; save mcast address list
IFDEF   _VERBOSE
                push    si
                mov     si,offset msg_callNADMCast
                call    Print
                pop     si
ENDIF
		call	NADMCastChange
IFDEF _VERBOSE  ; print success or fail msg for NADInit
                pushf                           ; save for carry test later
                push    si
                mov     si,offset msg_NADMCastChangeOK  ; set ok msg
                jnc     NADMCastRetOK2                  ; branch if really ok
                mov     si,offset msg_NADMCastChangeErr ; set error msg
NADMCastRetOK2:   call    Print
                pop     si
                popf
ENDIF
		pop	di
		pop	es
ResetOkExit:    mov	ax, PXENV_EXIT_SUCCESS
		mov	word ptr es:[di], PXENV_STATUS_SUCCESS
		clc
		ret
;
UNDI_ResetAdapter	endp
;==========================================================================
; UNDI_ShutDown
;===============
; Description:	Resets the adapter and leaves it in a safe state for
;		another driver to program it.
;
; Entry:	ES:DI contains NIC_ShutDown Pointer
;
; Exit: 	AX contains success/failure code,
;		CF cleared on success, set on error, and
;		the status field in parameter structure is set.
;==========================================================================
UNDI_ShutDown	proc	near

		push	es
		push	di
		cmp     IsOpen,0        ; if = 0 means closed
		je	ok2ShutDown
      		call	UNDI_CloseAdapter       ; close it for them
ok2ShutDown:	cmp	IsInitialized,0		; has UNDI_Initialize been called?
		je	ShutdownErr			; no, so skip this
IFDEF   _VERBOSE
                push    si
                mov     si,offset msg_callNADShutDown
                call    Print
                pop     si
ENDIF
				call	NADShutDown
				jc      ShutdownFailed
				mov		IsInitialized,0		; set to uninitialized state
ShutdownFailed:
IFDEF _VERBOSE  ; print success or fail msg for NADShutDown
                pushf                           ; save for carry test later
                push    si
                mov     si,offset msg_NADShutDownOK  ; set ok msg
                jnc     NADShutDownOK                ; branch if really ok
                mov     si,offset msg_NADShutDownErr ; set error msg
NADShutDownOK:  call    Print
                pop     si
                popf
ENDIF
                jnc      @F
ShutdownErr:
;;              pop             di
;;              pop             es
;;              stc
;;              mov         ax,PXENV_EXIT_FAILURE
;;              mov             word ptr es:[di],PXENV_STATUS_FAILURE
;;              jmp short ShutdownExit                  ; carry set to indicate error
;
@@:     		pop	di
				pop	es
				mov	ax, PXENV_EXIT_SUCCESS
				mov	word ptr es:[di], PXENV_STATUS_SUCCESS
				clc
ShutdownExit:	ret
;
UNDI_ShutDown	endp
;==========================================================================
; UNDI_OpenAdapter
;==================
; Description:	Activates the adapter's network connection and sets the
;		adapter ready to accept packets for transmit and receive.
;
; Entry:	ES:DI points to NIC_Open Structure
;
; Exit: 	AX contains success/failure code,
;		CF cleared on success, set on error, and
;		the status field in parameter structure is set.
;
; JL - We'll handle the "OPEN" state as a variable "IsOpen" which will be
;      set to non-zero when the adapter is "OPEN". If the higher level calls
;      us to do a Transmit we will check for IsOpen and fail the call if it
;      isn't.
;
;==========================================================================
UNDI_OpenAdapter proc	near

		push	es
		push	di
        	cmp     DGroup:IsOpen,0         ; 0 means NOT open
	        jne     skipNADOpen             ; skip if 'open'
       		cmp	DGroup:IsInitialized,0	; has UNDI_Initialize been called?
		je	skipNADOpen
;;      	je	OpenErr			; no, so skip this
IFDEF   _VERBOSE
                push    si
                mov     si,offset msg_callNADOpen
                call    Print
                pop     si
ENDIF
		call	NADOpen

IFDEF _VERBOSE  ; print success or fail msg for NADOpen
                pushf                           ; save for carry test later
                push    si
                mov     si,offset msg_NADOpenOK ; set ok msg
                jnc     NADOpenRetOK2           ; branch if really ok
                mov     si,offset msg_NADOpenErr ; set error msg
NADOpenRetOK2:  call    Print
                pop     si
                popf
ENDIF
                jnc      @F
		pop	di
		pop	es
		ret                     ; carry set to indicate error
;
@@:             mov     DGroup:IsOpen,1     ; JL - indicate Open state
		mov	ax, (NIC_Open ptr es:[di]).O_PktFilter
		mov	RecFilter, ax
IFDEF   _VERBOSE
                push    si
                mov     si,offset msg_callNADSetFilter
                call    Print
                pop     si
ENDIF
		call	NADSetFilter
IFDEF _VERBOSE  ; print success or fail msg for NADInit
                pushf                           ; save for carry test later
                push    si
                mov     si,offset msg_NADSetFilterOK ; set ok msg
                jnc     NADSetFilterOK2           ; branch if really ok
                mov     si,offset msg_NADSetFilterErr ; set error msg
NADSetFilterOK2: call    Print
                pop     si
                popf
ENDIF
;
;- Set ES:SI = Multicast list, Set CX to # of MC entries.
;
		pop	di
		pop	es
		push	es
		push	di

		mov	cx, (NIC_Open ptr es:[di]).O_MCBuf.MC_MCastAddrCount
		lea	si, (NIC_Open ptr es:[di]).O_MCBuf.MC_MCastAddr
		mov	ax, 1			; save mcast address list
IFDEF   _VERBOSE
                push    si
                mov     si,offset msg_callNADMCast
                call    Print
                pop     si
ENDIF
		call	NADMCastChange
IFDEF _VERBOSE  ; print success or fail msg for NADInit
                pushf                           ; save for carry test later
                push    si
                mov     si,offset msg_NADMCastChangeOK  ; set ok msg
                jnc     NADMCastRetOK3                  ; branch if really ok
                mov     si,offset msg_NADMCastChangeErr ; set error msg
NADMCastRetOK3:   call    Print
                pop     si
                popf
ENDIF
skipNADOpen:    pop     di
		pop	es
		mov	ax, PXENV_EXIT_SUCCESS
		mov	word ptr es:[di], PXENV_STATUS_SUCCESS
		clc
		ret
OpenErr:	pop	di
		pop	es
		stc
		mov	ax,PXENV_EXIT_FAILURE
		mov	word ptr es:[di],PXENV_STATUS_FAILURE
            	ret
;
UNDI_OpenAdapter endp
;==========================================================================
; UNDI_CloseAdapter
;===================
; Description:	Disconnects the adapter from network.
;		Packets cannot be Tx or Rx.
;
; Entry:	ES:DI points to NIC_Close Struc
;
; Exit: 	AX contains success/failure code,
;		CF cleared on success, set on error, and
;		the status field in parameter structure is set.
;==========================================================================
UNDI_CloseAdapter	proc	near

		push	es
		push	di
                cmp     DGroup:IsOpen,0
                je      skipNADClose		; DEADISSUE BUGBUG no POPs
IFDEF   _VERBOSE
                push    si
                mov     si,offset msg_callNADClose
                call    Print
                pop     si
ENDIF
		call	NADClose

IFDEF _VERBOSE  ; print success or fail msg for NADClose
                pushf                           ; save for carry test later
                push    si
                mov     si,offset msg_NADCloseOK ; set ok msg
                jnc     NADCloseRetOK            ; branch if really ok
                mov     si,offset msg_NADCloseErr ; set error msg
NADCloseRetOK:  call    Print
                pop     si
                popf
ENDIF
                pop	di
				pop	es
                jnc     @F
CloseFail:      mov     ax, PXENV_EXIT_FAILURE
				mov	word ptr es:[di],PXENV_STATUS_FAILURE
				ret                 ; carry set to indicate error
skipNADClose:	pop		di
				pop		es
;;jrl 980722    stc
;;JRL 980722    jmp short CloseFail
;
@@:	        	mov     DGroup:IsOpen,0     ; JL - indicate closed state
				mov	ax,PXENV_EXIT_SUCCESS
				mov	word ptr es:[di], PXENV_STATUS_SUCCESS
				clc
				ret
;
UNDI_CloseAdapter	endp
;==========================================================================
; UNDI_Transmit
;===============
; Description:	Transmit a frame onto the medium.
;
; Entry:	ES:DI = Pointer to NIC_Transmit
;		Board Interrupts COULD BE disabled.
;		System Interrupts are enabled.
;
; Exit: 	AX contains success/failure code,
;		CF cleared on success, set on error, and
;		the status field in parameter structure is set.
;		Board and System Interrupts are enabled
;
;==========================================================================
UNDI_Transmit	proc	near

                cmp     DGroup:IsOpen,0     ; is port really "Open"?
                je      DS_TransmitError    ; no, so abort
				cmp	(NIC_Transmit ptr es:[di]).T_Protocol, 3 ; largest supported #
				ja	DS_NotSupported

				mov	bx, di			; free DI, it is used for ED frags
                cli
				call	TransmitSetup
                sti
				jc	DS_TransmitError	; return error -- packet size exceeded

;*** perhaps increment statistic???  - jump to specific error label in future

				mov	cx, 10
TX_try_again:	push	cx
				push	di
				push	es		; save ptr to UNDI_TRANSMIT parm struc
				mov	ax, ds		; (can't assume NADTransmit will save ES:BX)
				mov	es, ax
				mov	si, offset DGroup:TxED 	; ES:SI ptr to transmit ED
IFDEF _VERBOSE
                push    si
                mov     si,offset msg_callNADTransmit
                call    Print
                pop     si
ENDIF
				call	NADTransmitPacket
IFDEF _VERBOSE  ; print success or fail msg for NADTransmitPacket
                pushf                           ; save for carry test later
                push    si
                mov     si,offset msg_NADTransmitOK ; set ok msg
                jnc     NADTransmitRetOK            ; branch if really ok
                mov     si,offset msg_NADTransmitErr ; set error msg
NADTransmitRetOK:   call    Print
                pop     si
                popf
ENDIF
				pop	es
				pop	di		; ES:DI ptr to UNDI_TRANSMIT parm struc
				pop	cx

				test	TxED.ED_ErrCode, -1	; did the transmit complete OK?
				jz	DS_TransmitSuccess

		  loop	TX_try_again
				jmp	DS_TransmitError	; no, return PXENV_STATUS_FAILURE

DS_TransmitSuccess:

;;        push    dx
;;        mov     edx,    CR0
;;        test    dx, 1
;;        je      real_mode4
;; BREAK
;;real_mode4:
;;       pop dx
				mov	cx, TxED.ED_Length      ; CX has length of packet transmitted
				mov	bx, TxType              ; BX has packet type
                                                ; BX=0 for directed packet
                                                ; BX=1 for broadcast packet
                                                ; BX=2 for multicast packet
				mov	ax, 1			; tx post processing callback
				call	DWORD PTR GenIntCallback    ; call SWI to tell it transmit complete

				mov	ax, PXENV_EXIT_SUCCESS
				mov	word ptr es:[di], PXENV_STATUS_SUCCESS
				clc
				ret

DS_NotSupported: mov	word ptr es:[di], PXENV_STATUS_UNSUPPORTED  ; status
		jmp	DS_ErrorExit

;*** this is a good place to differentiate between various Tx errors and set
; statistics if we see that it's needed

DS_TransmitError: mov	word ptr es:[di], PXENV_STATUS_FAILURE ; status
DS_ErrorExit:	mov	ax, PXENV_EXIT_FAILURE
		stc
		ret
;
UNDI_Transmit	endp
;==========================================================================
; TransmitSetup
;===============
; Description : This routine translates UNDI_TX parameters to the format
;		required by NADTransmit.
;
; Entry:	ES:BX -> NIC_Transmit param block structure
;			  NDIS transmit buffer descriptor
;		CLD is in effect
;		System Interrupts are enabled
;
; Exit: 	AX = 0, CY clear if translation went OK
;		AX = -1, CY set if MAX_PACKET length exceeded
;		BX,DI,BP,DS,ES preserved
;
; 970514 0.00 GK
;==========================================================================
TransmitSetup	proc	near

				push	bp
				push	es
				push	bx
				push	ds
				push	di

				mov	di, offset DGroup:TxED.ED_FragOff

; DS:DI ptr to TxED's 1st fragment descriptor
;--------------------------------------------------------------------------
; swap ES/DS so that DGROUP is pointed to by ES, BuffDesc by DS
;--------------------------------------------------------------------------
				push	ds
				push	es
				pop	ds			; DS:BX ptr to UNDI TxBuffDesc
				pop	es			; ES:DI ptr to TxED
				xor	bp, bp			; assume no media header
				mov	es:TxED.ED_FragCount, bp ; no fragments yet
;----------------------------------------------------------------------
;	Check if we need to add the media header
;--------------------------------------------------------------------
				cmp	(NIC_Transmit ptr ds:[bx]).T_Protocol, 0
				je	PFT_NoMediaHeader
; fill destination addr
				cmp	(NIC_Transmit ptr ds:[bx]).T_XmitFlag, 0
				je	PFT_DestAddrGiven	; take dest addr from T_DestAddrOffset
; fill broadcast addr
				xor	eax, eax
				dec	eax			; all F's
				mov	dword ptr es:MediaHeader, eax
				mov	word ptr es:MediaHeader+4, ax
				jmp	PFT_DestAddrFilled

PFT_DestAddrGiven:
				push	ds
				lds	si, dword ptr (NIC_Transmit ptr ds:[bx]).T_DestAddrOffset
				mov	eax, DWORD PTR [si]
				mov	dword ptr es:MediaHeader, eax
				mov	ax, WORD PTR [si+4]
				mov	word ptr es:MediaHeader+4, ax
				pop	ds

PFT_DestAddrFilled:				; fill source addr
				mov	eax, DWORD PTR es:Net_Address
				mov	dword ptr es:MediaHeader+6, eax
				mov	ax, WORD PTR es:Net_Address+4
				mov	word ptr es:MediaHeader+10, ax	; fill protocol type(This is Ethernet II)

				cmp	(NIC_Transmit ptr ds:[bx]).T_Protocol, P_IP
				jne	@F

				mov	ax,  TYPE_IP
				jmp	PFT_MediaHeaderDone
@@:             cmp	(NIC_Transmit ptr ds:[bx]).T_Protocol, P_ARP
				jne	@F

				mov	ax, TYPE_ARP
				jmp	PFT_MediaHeaderDone
@@:				mov	ax, TYPE_RARP				; must be RARP
PFT_MediaHeaderDone:
				xchg	al, ah
				mov	word ptr es:MediaHeader+12, ax
				mov	ax, offset DGroup:MediaHeader
				stosw				; frag1.offset = MediaHeader
				mov	ax, es
				stosw				; frag1.segment = ES (DGROUP)
				mov	ax, 14			; size of MediaHeader
				add	bp, ax			; BP = size of packet data so far
				stosw				; frag1.length = 14 (size of MediaHeader)
						; ES:DI now points to frag2
				inc	es:TxED.ED_FragCount	; bump fragment count by 1

				mov	eax, dword ptr es:MediaHeader
				and	ax, WORD PTR es:MediaHeader+4
				cmp	eax, -1
				jz	BCast

				mov	al, byte ptr es:MediaHeader
				cmp	al, 01h
				jz	MCast

				mov	ax, TYPE_UCAST
				jmp	set_xtype
MCast:			mov	ax, TYPE_MCAST
				jmp	set_xtype
BCast:			mov	ax, TYPE_BCAST
set_xtype:		mov	es:TxType, ax		;971030

PFT_NoMediaHeader:				; get the TBD into ds:si
				lds	si, dword ptr (NIC_Transmit ptr ds:[bx]).T_TBDOffset
;--------------------------------------------------------------------------
; Copy the Immediate Data if any
;--------------------------------------------------------------------------
				mov	cx, (TxBufDesc ptr ds:[si]).TxImmedLen
				or	cx, cx
				jz	PFT_NoImmediateData

				add	bp, cx
				cmp	bp, MAX_PACKET		; should not go beyond the buf size
				ja	len_error

				mov	ax, word ptr (TxBufDesc ptr ds:[si]).TxImmedPtr
				stosw				; frag1 (or frag2) = TxImmedptr
				mov	ax, word ptr (TxBufDesc ptr ds:[si]).TxImmedPtr+2
				stosw
				mov	ax, cx
				stosw				; this frag all defined, ES:DI ptr to
						;  next ED fragment
				inc	es:TxED.ED_FragCount	; bump fragment count by 1
;--------------------------------------------------------------------------
; Now copy TxDataBlock pointers/lengths to the ED fragments
;
; ES:DI points to next ED fragment descriptor
; DS:SI points to TransmitBufferDescriptor.
; BX will contain # of Fragment Descriptor Structures starting at TxDataBlk.
;--------------------------------------------------------------------------
PFT_NoImmediateData:
				mov	bx, (TxBufDesc ptr ds:[si]).TxDataCount
				or	bx, bx
				jz	PFT_NoDataBlocks

				lea	si, (TxBufDesc ptr ds:[si]).TxDataBlk
PFT_FragmentsLoop:
				mov	cx, (TxDataBlock ptr ds:[si]).TxDataLen
				or	cx, cx
				jz	PFT_NextFragment
;
;- remember to track total number of bytes in BP, no error checking though.
;
				add	bp, cx
				cmp	bp, MAX_PACKET	;; should not go beyond the buf size
				ja	len_error

				mov	ax, word ptr (TxDataBlock ptr ds:[si]).TxDataPtr
				stosw
				mov	ax, word ptr (TxDataBlock ptr ds:[si]).TxDataPtr+2
				stosw
				mov	ax, cx
				stosw
				inc	es:TxED.ED_FragCount	; bump fragment count by 1
PFT_NextFragment:
				add	si, TYPE TxDataBlock
				dec	bx
				jnz	PFT_FragmentsLoop
PFT_NoDataBlocks:
				pop	di	    ;; restore to the start
				pop	ds
				pop	bx
				pop	es

				mov	TxED.ED_Length, bp	; set total transmit length into TxED
;--------------------------------------------------------------------------
				push	es			; save ES

				mov	si, TxED.ED_FragOff ; DS:SI ptr to 1st fragment
				mov	ax, [si+6]
				or	ax, [si+8]
				or	ax, [si+10]
				jnz	PFT_NonZeroAddress

				mov	ax, WORD PTR Net_Address
				mov	[si+6], ax
				mov	ax, WORD PTR Net_Address+2
				mov	[si+8], ax
				mov	ax, WORD PTR Net_Address+4
				mov	[si+10], ax
PFT_NonZeroAddress:
				pop	es			; restore ES
				pop	bp
				xor	ax, ax
				clc
				ret
len_error:		pop	di			; restore to the start
				pop	ds
				pop	bx
				pop	es
				pop	bp
				mov	ax, -1
				stc
				ret
;
TransmitSetup	endp
;==========================================================================
; UNDI_DriverISR
;================
; Description:	Interrupt service routine for receiving packets
;
; Entry:	None
;
; Exit: 	None
;==========================================================================

UNDI_DriverISR	proc	far
;   			BREAK
				push	ds
				push	es
				push	eax
				push	ebx
				push	ecx
				push	edx
				push	esi
				push	edi
				push	ebp
;;   mov     edx,    CR0
;;   test    dx, 1
;;   je      real_mode3
real_mode3:     mov 	ax, cs:ApiEntry.mlid_ds_sel
				mov 	ds, ax
IFDEF _VERBOSE
                push    si
                mov     si,offset msg_callNADDriverISR
                call    Print
                pop     si
ENDIF
; *******  Dmitry *************
; when entering this ISR low-level service routine should be processed
; in any case, otherwise we risk to miss interrupt.
; That's why code below is commented and moved after call to the
; DriverISR_Proc
; ******************************
;;                inc     DGroup:InAdapterIsr            ; inc reentrant count
;;                cmp     DGroup:InAdapterIsr,1          ; just us here?
;;                jne     skip_Isr                ; no, don't reenter

                call    DriverISR_Proc          ; adapter specific Rx ISR
                jc      not_our_isr
                inc     DGroup:InAdapterIsr            ; inc reentrant count
                cmp     DGroup:InAdapterIsr,1          ; just us here?
                jne     skip_Isr                ; no, don't reenter
                dec     DGroup:InAdapterIsr            ; dec reentrant count
;

IFDEF _VERBOSE  ; print success or fail msg for NADInit
                pushf                           ; save for carry test later
                push    si
                mov     si,offset msg_NADIsrOK ; set ok msg
                jnc     NADIsrRetOK            ; branch if really ok
                mov     si,offset msg_NADIsrErr ; set error msg
NADIsrRetOK:    call    Print
                pop     si
                popf
ENDIF
;;		jc	not_our_isr

				sti
				call	ProcessRxInt
				jmp short DriverISR_ret
skip_Isr:       dec     InAdapterIsr            ; dec reentrant count
        		jmp short DriverISR_ret
;
not_our_isr:
; *******  Dmitry *************
; too dangerous for now to chain interrupt - in some cases
; CF is set in the end of low-level service routine to
; indicate interrupt failure and not "not our interrupt" case.
; In case of interrupt failed we shouldn't process Rx Buffer,
; but it would be illegal to call original vector.
; Needs further elaboration
; ******************************
;;        cmp	OrgINTVector_Seg, 0	; segment == 0?
;; 		jne     ChainTheInt
DriverISR_ret:	cli
		        pop	ebp
				pop	edi
				pop	esi
				pop	edx
				pop	ecx
				pop	ebx
				pop	eax
				pop	es
				pop	ds
				iret
;
ChainTheInt:    pop	ebp     ; safer to chain this way with a jump
				pop	edi     ; after clearing our saved stuff off the stack
				pop	esi
				pop	edx
				pop	ecx
				pop	ebx
				pop	eax
				pop	es
				pop	ds
                cli                             ; simulate interrupt
				jmp 	DWORD PTR OrgINTVector_Off ; and a JMP far
;
UNDI_DriverISR	endp
;==========================================================================
; UNDI_SetMCastAddr
;===================
; Description:	Change the list of multicast addresses and
;		resets the adapter to accept it.
;
; Entry:	ES:DI contains NIC_SetMCastAddr
;
; Exit: 	AX contains success/failure code,
;		CF cleared on success, set on error, and
;		the status field in parameter structure is set.
;==========================================================================
UNDI_SetMCastAddr	proc	near

		push	es
		push	di
;
;- Set ES:SI = Multicast list, Set CX to # of MC entries.
;
		mov	cx, (NIC_SetMCastAddr ptr es:[di]).SM_MCBuf.MC_MCastAddrCount
		lea	si, (NIC_SetMCastAddr ptr es:[di]).SM_MCBuf.MC_MCastAddr
;;JRL 980511		mov	ax, 1			; save mcast address list
IFDEF   _VERBOSE
                push    si
                mov     si,offset msg_callNADMCast
                call    Print
                pop     si
ENDIF
		call	NADMCastChange
IFDEF _VERBOSE  ; print success or fail msg for NADInit
                pushf                           ; save for carry test later
                push    si
                mov     si,offset msg_NADMCastChangeOK ; set ok msg
                jnc     NADMCastRetOK            ; branch if really ok
                mov     si,offset msg_NADMCastChangeErr ; set error msg
NADMCastRetOK:   call    Print
                pop     si
                popf
ENDIF
				pop	di
				pop	es
				mov	ax, PXENV_EXIT_SUCCESS
				mov	word ptr es:[di], PXENV_STATUS_SUCCESS
				clc
				ret
;
UNDI_SetMCastAddr	endp
;==========================================================================
; UNDI_SetStationAddress
;========================
; Description:	Sets MAC address to be the input value
;
; Entry:	ES:DI contains the param blk
;
; Exit: 	AX contains success/failure code,
;		CF cleared on success, set on error, and
;		the status field in parameter structure is set.
;==========================================================================
UNDI_SetStationAddress	proc	near

				mov	si, offset DGroup:Net_Address
				mov	eax, dword ptr (NIC_SetStationAddr ptr es:[di]).SS_StationAddr
				mov	dword ptr [si], eax         ; put 4 bytes of new MAC address in
				mov	ax, word ptr (NIC_SetStationAddr ptr es:[di]).SS_StationAddr+4
				mov	word ptr [si+4], ax         ; put 2 bytes of new mac address in
;; JL - PATCHED OUT 980715
;               cmp     IsOpen,0                        ; disallow if nic not 'open'
;               jne     setMacFailed
				call	NADSetMACAddress		; SI points to 6 byte MAC address
				jc setMacFailed
        		mov	ax, PXENV_EXIT_SUCCESS
		        mov	word ptr es:[di], PXENV_STATUS_SUCCESS
        		clc
SSA_Exit:		ret
setMacFailed:   mov	ax, PXENV_EXIT_FAILURE
				mov	word ptr es:[di], PXENV_STATUS_UNSUPPORTED
				stc
				jmp short SSA_Exit
;
UNDI_SetStationAddress	endp
;==========================================================================
; UNDI_SetPacketFilter
;======================
; Description:	Resets the adapter's Rx unit to accept a new filter.
;
; Entry:	ES:DI points to the filter parameter
;
; Exit: 	AX contains success/failure code,
;		CF cleared on success, set on error, and
;		the status field in parameter structure is set.
;==========================================================================
UNDI_SetPacketFilter	proc	near

				movzx	ax, (NIC_SetPacketFilter ptr es:[di]).SP_NewFilter
				test	ax, NOT (FLTR_DIRECTED OR FLTR_MLTCST OR FLTR_BRDCST OR FLTR_PRMSCS)
				jz	    FilterValueOK

				mov	ax, PXENV_EXIT_FAILURE
				mov	word ptr es:[di], PXENV_STATUS_FAILURE
				stc
				ret
FilterValueOK:	mov	RecFilter, ax
IFDEF   _VERBOSE
                push    si
                mov     si,offset msg_callNADSetFilter
                call    Print
                pop     si
ENDIF
				call	NADSetFilter
IFDEF _VERBOSE  ; print success or fail msg for NADInit
                pushf                                 ; save for carry test later
                push    si
                mov     si,offset msg_NADSetFilterOK  ; set ok msg
                jnc     NADSetFilterOK3               ; branch if really ok
                mov     si,offset msg_NADSetFilterErr ; set error msg
NADSetFilterOK3: call    Print
                pop     si
                popf
ENDIF
				mov	ax, PXENV_EXIT_SUCCESS
				mov	word ptr es:[di], PXENV_STATUS_SUCCESS
				clc
				ret
;
UNDI_SetPacketFilter	endp
;==========================================================================
; UNDI_GetNICInfo
;=================
; Description:	Copies adapter variables into the input buffer
;
; Entry:	ES:DI contains NIC_GetInfo Pointer
;
; Exit: 	AX contains success/failure code,
;		CF cleared on success, set on error, and
;		the status field in parameter structure is set.
;==========================================================================
UNDI_GetNICInfo proc	 near

				mov	ax, IOBase
				mov	(NIC_GetInfo ptr es:[di]).GI_BaseIo, ax
                sub     ax,ax                   ; clr AH
				mov	al, IRQNumber
				mov	(NIC_GetInfo ptr es:[di]).GI_IntNumber, ax
; MTU
				mov	(NIC_GetInfo ptr es:[di]).GI_MTU, MAXIMUM_ETHERNET_PACKET_SIZE
				mov	(NIC_GetInfo ptr es:[di]).GI_HwType, ETHER_TYPE
				mov	(NIC_GetInfo ptr es:[di]).GI_HwAddrLen, ETHERNET_ADDRESS_LENGTH
; Permanent address
				mov	eax, DWORD PTR Node_Address
				mov	dword ptr (NIC_GetInfo ptr es:[di]).GI_PermNodeAddress, eax
				mov	ax, WORD PTR Node_Address+4
				mov	word ptr (NIC_GetInfo ptr es:[di]).GI_PermNodeAddress+4, ax
; current address
				mov	eax, DWORD PTR Net_Address
				mov	dword ptr (NIC_GetInfo ptr es:[di]).GI_CurrentNodeAddress, eax
				mov	ax, WORD PTR Net_Address+4
				mov	word ptr (NIC_GetInfo ptr es:[di]).GI_CurrentNodeAddress+4, ax
; Get the on-board ROM address
				mov	ax, word ptr ROMBase
				mov	(NIC_GetInfo ptr es:[di]).GI_ROMAddress, ax
				mov	ax, 1
				mov	(NIC_GetInfo ptr es:[di]).GI_TxBufCt, ax
				mov	ax, NUM_ED
				mov	(NIC_GetInfo ptr es:[di]).GI_RxBufCt, ax
				mov	ax, PXENV_EXIT_SUCCESS
				mov	word ptr es:[di], PXENV_STATUS_SUCCESS
				clc
				ret
;
UNDI_GetNICInfo endp
;==========================================================================
; GetNICType:
;=============
; Entry       :	es:di contains NICType_pnp/pci Pointer
;
; Exit        :
;==========================================================================
UNDI_GetNICType	proc	near

				mov	(NIC_GetNICType_pci ptr es:[di]).NicType, PCI_ADAPTER
                mov     ax,VendorId
				mov	(NIC_GetNICType_pci ptr es:[di]).Vendor_ID, ax
                mov     ax,DeviceId
				mov	(NIC_GetNICType_pci ptr es:[di]).Dev_ID,ax
				mov	(NIC_GetNICType_pci ptr es:[di]).Base_Class, PCI_BASE_CLASS
				mov	(NIC_GetNICType_pci ptr es:[di]).Sub_Class,PCI_SUB_CLASS
				mov	(NIC_GetNICType_pci ptr es:[di]).Prog_Intf,PCI_PROG_INTERFACE
; JL code
                mov     ebx,SubSystem_Id
                mov     (NIC_GetNICType_pci ptr es:[di]).SubSystemId,ebx
; JL ends
				mov	bx, PCIBusDevFunc
				mov	(NIC_GetNICType_pci ptr es:[di]).BusDevFunc, bx
;
	;; don't read the configuration data whenever this is called
	;; should not read in protected mode!!

;		push	di
;		mov 	di, REV_ID_REGISTER
;		PCI_READ_BYTE		;; cx will have it
;		pop	di
				mov	(NIC_GetNICType_pci ptr es:[di]).Rev, cl
				mov	ax, PXENV_EXIT_SUCCESS
				mov	word ptr es:[di], PXENV_STATUS_SUCCESS
				clc
				ret
;
UNDI_GetNICType	endp
;==========================================================================
; UNDI_GetStatistics
;====================
; Description:	Reads statistical information from adapter.
;
; Entry:	ES:DI contains NIC_GetStatistics Pointer
;
; Exit: 	AX contains success/failure code,
;		CF cleared on success, set on error, and
;		the status field in parameter structure is set.
;==========================================================================
UNDI_GetStatistics	proc	near

				push	es
				push	di
				mov	si, offset DGroup:TxGoodFrames
                sub     ax,ax                   ; signal to get stats (not clear them)
IFDEF _VERBOSE
                push    si
                mov     si,offset msg_callNADGetStats
                call    Print
                pop     si
ENDIF
				call	NADGetStatistics    ; with AX=0 means get the stats

IFDEF _VERBOSE  ; print success or fail msg for NADGetStatistics
                pushf                           ; save for carry test later
                push    si
                mov     si,offset msg_NADGetStatOK ; set ok msg
                jnc     NADGetStatOK            ; branch if really ok
                mov     si,offset msg_NADGetStatErr ; set error msg
NADGetStatOK:   call    Print
                pop     si
                popf
ENDIF
				pop	di
				pop	es
                jc      cantGetStats
				mov	eax, TxGoodFrames
				mov	(NIC_GetStatistics ptr es:[di]).GS_XmtGoodFrames, eax
				mov	eax, RxGoodFrames
				mov	(NIC_GetStatistics ptr es:[di]).GS_RcvGoodFrames, eax
				mov	eax, RxCRCErrors
				mov	(NIC_GetStatistics ptr es:[di]).GS_RcvCRCErrors, eax
				mov	eax, RxDiscarded
				mov	(NIC_GetStatistics ptr es:[di]).GS_RcvResourceErrors, eax

				mov	ax, PXENV_EXIT_SUCCESS
				mov	word ptr es:[di], PXENV_STATUS_SUCCESS
				clc
getStatsExit:	ret
cantGetStats:   mov	ax, PXENV_EXIT_FAILURE
				mov	word ptr es:[di], PXENV_STATUS_UNSUPPORTED
				stc
                jmp short getStatsExit
;
UNDI_GetStatistics	endp
;==========================================================================
; UNDI_ClearStatistics
;======================
; Description:	Clears the statistical information from the adapter.
;
; Entry:	ES:DI points to para block
;
; Exit: 	AX contains success/failure code,
;		CF cleared on success, set on error, and
;		the status field in parameter structure is set.
;==========================================================================
UNDI_ClearStatistics	proc	near

				push	es
				push	di

				mov	si, offset DGroup:TxGoodFrames
                mov     ax,1                    ; signal to clear statistics
IFDEF _VERBOSE
                push    si
                mov     si,offset msg_callNADGetStats
                call    Print
                pop     si
ENDIF
				call	NADGetStatistics        ; with AX != 0 means clr the stats
IFDEF _VERBOSE  ; print success or fail msg for NADGetStatistics
                pushf                           ; save for carry test later
                push    si
                mov     si,offset msg_NADGetStatOK ; set ok msg
                jnc     NADGetStatOK2           ; branch if really ok
                mov     si,offset msg_NADGetStatErr ; set error msg
NADGetStatOK2:  call    Print
                pop     si
                popf
ENDIF
				pop	di
				pop	es
                jc      cantClrStats            ; branch on lower level error
				mov	ax, PXENV_EXIT_SUCCESS
				mov	word ptr es:[di], PXENV_STATUS_SUCCESS
				clc
clrStatsExit:	ret
cantClrStats:   mov	ax, PXENV_EXIT_FAILURE
		mov	word ptr es:[di], PXENV_STATUS_UNSUPPORTED
		stc
                jmp short clrStatsExit
;
UNDI_ClearStatistics	endp
;==========================================================================
; UNDI_InitDiags
;================
; Description:	Initialize the run-time diagnostics.
;
; Entry:	ES:DI points to parameter block
;
; Exit: 	returns NOT_SUPPORTED IF lower level doesn't support
;==========================================================================
; TODO: Find out when it's legal to make this call to us so we can refuse
;       the call when it's made at the wrong time
;
UNDI_InitDiags	proc	near

                push    es                      ; save structure pointers
                push    di
                call    NADInitiateDiags       ; NEW - return status word in AX
                pop     di                      ; restore stucture pointers
                pop     es
                jc      diagsFail               ; did lower level support call?
                mov     es:[di],ax              ; TODO: use structure here
		mov	ax, PXENV_EXIT_SUCCESS
		mov	word ptr es:[di], PXENV_STATUS_SUCCESS
		clc
                jmp short diagExit
diagsFail:	mov	ax, PXENV_EXIT_FAILURE
		mov	word ptr es:[di], PXENV_STATUS_UNSUPPORTED
		stc
diagExit:	ret
;
UNDI_InitDiags	endp
;==========================================================================
; UNDI_ForceInterrupt
;=====================
; Description:	Forces the adapter to generate an interrupt.
;
; Entry:	ES:DI points to parameter block
;
; Exit: 	AX contains success/failure code,
;		CF cleared on success, set on error, and
;		the status field in parameter structure is set.
;
; Note: 	A software handling for Rx is implemented here to
;		accommodate those adapters which may have problem on
;		generating interrupt by itself.
;==========================================================================
UNDI_ForceInterrupt	proc	near

		push	es
		push	di

		mov	ForcedInt, TRUE     ;

                cmp     SimulateInterrupts,0    ; if non-zero we need to fake ints
                je      dontFakeThem            ; else we don't need to
                pushf                           ; simulate int  JL
                call    UNDI_DriverISR          ; JL - call UNDI level ISR
                jmp short UF_Exit
;
dontFakeThem:	call	ProcessRxInt

UF_Exit:	pop	di
		pop	es
		mov	ax, PXENV_EXIT_SUCCESS
		mov	word ptr es:[di], PXENV_STATUS_SUCCESS

		clc
		ret
;
UNDI_ForceInterrupt	endp
;------------------------------------------------------------------------------
ProcessRxInt	proc	near
;
;  DESCRIPTION: Checks and sets a re-entrancy flag
;               Checks for data in ED's ring buffer
;   PARAMETERS:
;      RETURNS:
;    CALLED BY: UNDI_DriverISR, UNDI_ForceInterrupt
;
		push	es

		cmp	InProcessRxInt, TRUE    ; are we IN this routine already?
		jz	RxIntRet                ; yes, don't re-enter
		mov	InProcessRxInt, TRUE    ; no, mark as entered
check_more:	mov	si,[EDListTail]         ; get ptr to ring buffer tail
		cmp	[EDListHead], si        ; same as head?
		jnz	data_avail              ; no, must have data in it
		cmp	word ptr [si].ED_Length, 0	;does this ED have data?
		jnz	data_avail
		cmp	ForcedInt, FALSE        ; called by other than UNDI_ForceInterrupt?
;;    nop
;;    nop ;JRL Test to see if this is a problem
 		jz	NoMoreData              ; yes, skip
; Comes here when called by UNDI_ForceInterrupt
		mov	ForcedInt, FALSE        ; unsignal flag
		mov	ax, 3			; software INT callback
		call	DWORD PTR GenIntCallback ; call General Interrupt Handler
		jmp	NoMoreData
data_avail:	nop
		mov	cx, [si].ED_Length
		lea	bx, [si].ED_FragOff	; point to 1st descriptor
		mov	ax, ds
		mov	es, ax
		mov	di, word ptr [bx].DPointer	; get fragment pointer
;
; Find the packet type & convert it into 0,1,2,3 and put in BX
;
                sub     bx,bx               ; make sure BH clr cuz we return result in BX
		mov	ax, (EtherHeader ptr es:[di]).E_Type
		xchg	al, ah
		cmp	ax, TYPE_IP
		jne	@F
		mov	bl, P_IP            ; signal packet type IP
		jmp	GotType
@@:		cmp	ax, TYPE_ARP
		jne	@F
		mov	bl, P_ARP           ; signal packet type ARP
		jmp	GotType
@@:		cmp	ax, TYPE_RARP
		jne	@F
		mov	bl, P_RARP          ; signal packet type RARP
		jmp	GotType
@@:		sub	bl, bl              ; BL = 0 ; signal unknown type
GotType:	mov	ax, ETHER_HEADER_LEN
;-------------------------------------------------------------------
; call the receive callback function.
;	ES:DI must contain the buffer
;	CX must contain the length
;	AX must contain the length of media header which is 6+6+2
;	BX must contain the packet type: 0 - P_UNKNOWN, 1 - P_IP,
;-------------------------------------------------------------------
		Call	DWORD PTR RxCallback    ; call application level callback routine

		cmp	ax, -1			;DELAY_COPY
		jz	DelayCopy		;yes

		mov	NeedIndComplete, TRUE
		call	PostED

		cmp	ForcedInt, FALSE
		je	check_more

; if ForcedInt is TRUE we call the GeneralInterruptHandler as a SWI
		mov	ForcedInt, FALSE        ; un-signal flag
		mov	ax, 3			; software INT callback
		call	DWORD PTR GenIntCallback
		jmp	check_more
NoMoreData:	cmp	NeedIndComplete, FALSE
		jz	OutRxInt
		mov	NeedIndComplete, FALSE
		mov	ax, 2			; rx post processing callback
		call	DWORD PTR GenIntCallback
DelayCopy:
OutRxInt:	mov	InProcessRxInt, FALSE   ; set flag that we are no longer in this code
RxIntRet:	pop	es
		ret
;
ProcessRxInt	endp
;==========================================================================
; UNDI_GetMCastAddr
;===================
; Description:	Converts given IP address to hardware multicast address
;
; Entry:	ES:DI points to NIC_GetMCastAddr parameter
;
; Exit: 	AX contains success/failure code,
;		CF cleared on success, set on error, and
;		the status field in parameter structure is set.
;==========================================================================
; ether net MCAST	Equ	01005e00h	; Ethernet multicast header

UNDI_GetMCastAddr	proc	near

		push	ebx
		mov	ebx, (NIC_GetMCastAddr ptr es:[di]).GM_InetAddr
		and	ebx, 0fffff700h 	;; take the last 23 bits.
						;; it is in host order now
		mov	(NIC_GetMCastAddr ptr es:[di]).GM_HwAddr, 01h
		mov	(NIC_GetMCastAddr ptr es:[di]).GM_HwAddr+1, 00h
		mov	(NIC_GetMCastAddr ptr es:[di]).GM_HwAddr+2, 5eh
		mov	(NIC_GetMCastAddr ptr es:[di]).GM_HwAddr+3, 0h
		mov	(NIC_GetMCastAddr ptr es:[di]).GM_HwAddr+4, 00h
		mov	(NIC_GetMCastAddr ptr es:[di]).GM_HwAddr+5, 00h
		or	dword ptr (NIC_GetMCastAddr ptr es:[di]).GM_HwAddr+2, ebx
		pop	ebx

		mov	ax, PXENV_EXIT_SUCCESS
		mov	word ptr es:[di], PXENV_STATUS_SUCCESS
		clc
		ret
;
UNDI_GetMCastAddr	endp
;**************************************************************************
; Routines for EDs handling
;--------------------------------------------------------------------
; InitEDMemory
;--------------
; Create memory for EDs and data buffers.  The data buffers can
; contain a complete ethernet packet (1500 bytes).
;
; Parameters:	none
;
; Returns:	nothing
;--------------------------------------------------------------------
InitEDMemory	proc	near

		push	es

		mov	ax, ds
		mov	es, ax                  ; ES = DS

; The ED's are linked together, the first dword contains a
; pointer to the next ED.

		mov	si, offset DGroup:RxEDs	; get address of 1st ED
		mov	bl, NUM_ED-1		; use bl as ED counter
initLoop:	mov	di, si
		mov	cx, (size ED_Struct)/2
		xor	ax, ax
	rep	stosw				; clear the ED

		mov	word ptr [si].ED_FragCount, 1	; define one fragment

		mov	ax, si			; put address in ax
		add	ax, size ED_Struct	; calc location of buffer following ED
		mov	[si].ED_FragOff, ax	; set location of data packet
		mov	[si].ED_FragSeg, ds
		mov	[si].ED_FragLen, MTU	; buffer size

		or	bl, bl			; is this the last ED?
		je	initDone		; yes

		add	ax, MTU 		; add size of buffer
		mov	[si].ED_Ptr, ax 	; set link pointer to next ED
		mov	si, ax			; move next address into di
		dec	bl
		jmp	short initLoop

initDone:	mov	ax, offset DGroup:RxEDs
		mov	[si].ED_Ptr, ax 	; link last ED back to the start

		mov	[EDListHead], ax	; set linked list head to start ED
		mov	[EDListTail], ax	; set linked list tail to start ED
		pop	es
		ret
;
InitEDMemory	endp
;------------------------------------------------------------------------
; GetED
;-------
; Check the head ED to see if it is available, if it is it's returned
; to the NAD and the head is changed to the next ED.
;
; Parameters:	none
;
; Returns:	es:si - pointer to ED
;		(si = 0 if no ED available)
;------------------------------------------------------------------------
GetED		proc	near

		cli				; disable interrupts
		push	ax
		mov	ax, ds
		mov	es, ax                  ; ES = DS

		mov	si, DGroup:[EDListHead]	; get ED at head of list
		cmp	word ptr [si].ED_Length, 0	; does this ED have data?
		je	edAvailable		; no - it's available

		xor	si, si			; return no ED available
		jmp	short getEDexit

edAvailable:	mov	DGroup:[EDListCurrent], si
		mov	ax, [si].ED_Ptr 	; get pointer to next ED
		mov	DGroup:[EDListHead], ax	; set next ED as head

		or	si, si			; reset zero flag
getEDexit:	pop	ax
		sti				; enable interrupts
		ret				; return (es:si is pointer to ED)
;
GetED		endp
;--------------------------------------------------------------------
; PostED
;--------
; Routine is called after a packet is received and has been copied
; into a data buffer in upper layer.
;
; Parameters:	none
;
; Returns:	nothing
;--------------------------------------------------------------------
PostED		proc	near

		cli
		push	es
		mov	ax, ds
		mov	es, ax                  ; ES = DS

		mov	si, [EDListTail]		; get ED at tail of list
		cmp	word ptr [si].ED_Length, 0	; does this ED have data?
		jz	nopost
		mov	word ptr [si].ED_Length, 0	; kill the data

		cmp	si, [EDListHead]
		mov	si, [si].ED_Ptr 		; get pointer to next ED
		jnz	postit
		cmp	word ptr [si].ED_Length, 0	; does this ED have data?
		jz	nopost
postit:		mov	[EDListTail], si		; set next ED as tail
nopost:		pop	es
		sti
		ret
;
PostED		endp
;------------------------------------------------------------------------------
; code added by jon
include stdio.asm   ; DisplayChar,Print,PrintDecimal,PrintHexWord,PrintHexByte
; code added ends
;------------------------------------------------------------------------------
Delay25ms	equ	0ea60h

	align	16

public		ApiEntry
ApiEntry	s_PXENV_ENTRY<>
ApiEntryPhyAddr	dd	0

; This ORG was added by Jon to make linked in code assemble at 1000H so
; we could org it at 1000h to generate a listing file and then re ORG it
; at 0000 for the actual obj file. The linker will locate it at 1000h
; in the finished binary.
;

IFDEF _DEBUG

ORG 0FFFh
    nop

ENDIF

_TEXT		Ends
;******************************************************************************
_DATA	segment	para public
	align	4
;
; Protocol's callback
;
RxCallback	dd	0
GenIntCallback	dd	0
;
; Don't change the order of the following four statistic variables
;
TxGoodFrames	dd	0	;1
RxGoodFrames	dd	0	;2
RxCRCErrors	dd	0	;3
RxDiscarded	dd	0	;3
;
; Transmit data variables   MOVED TO _BSS SEG
;
;TxED		ED_Struct <?>		; provide 9 additional fragments
;TxFrags 	Frag	9 dup (<?>)	;  for a total of 10 ED fragments
;MediaHeader	db	14 dup (?)	; destination, source, typelength
;					;  we only build and include this
;					;  header if protocol !=0
;
; Receive data variables
;
EDListHead	dw	0		; head pointer of ED list
EDListTail	dw	0		; tail pointer of ED list
EDListCurrent	dw	0		; pointer to current ED
;
; Adapter's infomation
;
BusType 	db	0
even
VendorID        dw      0
DeviceID        dw      0
PCIBusDevFunc	dw	0		;PCI bus & device function #
IOBase		dw	0		;adapter's base IO
ROMBase 	dw	0		;ROM base address
IRQNumber	db	0		;IRQ number
Node_Address	db	6 dup(0)	;adapter's permanent MAC address
Net_Address	db	6 dup(0)        ;MAC address in use
;
MultiCast_Addresses	Eth_MCastBuf <>
;
ForcedInt	db	0
NeedIndComplete	db	0
InProcessRxInt	db	0       ; flag to prevent re-entering this subroutine
;
RecFilter	dw	0
TxType		dw	0
;
SubSystem_Id     dd      0       ; extra info MS wanted
;
; STATE MACHINE INFORMATION     by Jon
;
SimulateInterrupts  db  0   ; set by adapter code if it needs ints simulated
IsOpen              db  0   ; when non-zero means the adapter is "Open" to Tx or Rx
IsInitialized		db	0	; set on UNDI_Initialize, clr on UNDI_Shutdown
InAdapterIsr        db  0   ; flag to prevent reentering ISR
NicIntsEnabled      db  0   ; driver code should set & clr this to let us know
                            ; when hardware interrupts from the nic are enabled
                            ; so we can use that info when deciding to chain to
                            ; previous interrupt handlers

;;IFDEF   _VERBOSE

msg_Entry   db  " Entering UNDI ",0
msg_Exit    db  " Exiting UNDI ",0dh,0ah,0
msg_CRLF    db  0Dh,0Ah,0

IFDEF _VERBOSE

msg_callNADInit     db  "Calling NADInit...",NULL
msg_callNADOpen     db  "Calling NADOpen...",NULL
msg_callNADClose    db  "Calling NADClose...",NULL
msg_callNADReset    db  "Calling NADReset...",NULL
msg_callNADSetFilter db "Calling NADSetFilter...",NULL
msg_callNADShutDown db  "Calling NADShutDown...",NULL
msg_callNADMCast    db  "Calling NADMCastChange...",NULL
msg_callNADGetStats db  "Calling NADGetStatistics...",NULL
msg_callNADTransmit db  "Calling NADTransmitPacket...",NULL
msg_callNADDriverISR db " ISR++.",NULL

msg_NADInitOK   db  "NADInit returns Success!",CR,LF,NULL
msg_NADInitErr  db  "ERROR: NADInit returned failure!",CR,LF,NULL

msg_NADOpenOK   db  "NADOpen returns Success!",CR,LF,NULL
msg_NADOpenErr  db  "ERROR: NADOpen returned failure!",CR,LF,NULL

msg_NADCloseOK   db  "NADClose returns Success!",CR,LF,NULL
msg_NADCloseErr  db  "ERROR: NADClose returned failure!",CR,LF,NULL

msg_NADResetOK   db  "NADReset returns Success!",CR,LF,NULL
msg_NADResetErr  db  "ERROR: NADReset returned failure!",CR,LF,NULL

msg_NADShutDownOK   db  "NADShutDown returns Success!",CR,LF,NULL
msg_NADShutDownErr  db  "ERROR: NADShutDown returned failure!",CR,LF,NULL

msg_NADSetFilterOK  db  "NADSetFilter returns Success!",CR,LF,NULL
msg_NADSetFilterErr db  "ERROR: NADSetFilter returned failure!",CR,LF,NULL

msg_NADMCastChangeOK  db  "NADMCastChange returns Success!",CR,LF,NULL
msg_NADMCastChangeErr db  "ERROR: NADMCastChange returned failure!",CR,LF,NULL

msg_NADGetStatOK    db  "NADGetStatistics returns Success!",CR,LF,NULL
msg_NADGetStatErr   db  "ERROR: NADGetStatistics returned failure!",CR,LF,NULL

msg_NADTransmitOK    db  "NADTransmit returned success!",CR,LF,NULL
msg_NADTransmitErr   db  "NAD DriverISR_Proc returned failure!",CR,LF,NULL

msg_NADIsrOK        db  "--ISR(ok) ",NULL
msg_NADIsrErr       db  "--ISR(err)",NULL


ENDIF

IFDEF _DEBUG
            ORG 0FFFh
            db  0CCh
ENDIF

_DATA	ends
;******************************************************************************
_BSS	segment
;
; Receiving buffer for ED
;

dummy		dw	0	;don't delete this in order to let offset RxEDs
				;   non-zero
public	RxEDs
RxEDs		db	(size ED_Struct + MTU) * NUM_ED dup (?) ;ED list & data buffer

;
; Transmit data variables
;
public	TxED
TxED		ED_Struct <?>		; provide 9 additional fragments
TxFrags 	Frag	9 dup (<?>)	;  for a total of 10 ED fragments
MediaHeader	db	14 dup (?)	; destination, source, typelength
					;  we only build and include this
					;  header if protocol !=0

_BSS	ends

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\cleanri\cleanri.c ===
/*
   This is cleanri
 */
#include <windows.h>
#include <tchar.h>
#include <winldap.h>
#include <dsgetdc.h>
#define SECURITY_WIN32
#include <security.h>
#include "resource.h"


HINSTANCE g_hInstance = NULL;

#ifdef DBG
#define DebugOut OutputDebugString
#else
#define DebugOut 1 ? (void)0 : (void) 
#endif

#define ARRAYSIZE( array ) sizeof( array ) / sizeof(( array )[ 0 ] )

//
// Ldap_InitializeConnection( )
//
DWORD
Ldap_InitializeConnection(
    PLDAP  * LdapHandle )
{
    DWORD LdapError = LDAP_SUCCESS;

    if ( !( *LdapHandle ) ) {
        ULONG temp = DS_DIRECTORY_SERVICE_REQUIRED |
                     DS_IP_REQUIRED |
                     DS_GC_SERVER_REQUIRED;

        DebugOut( L"Initializing LDAP connection.\n" );

        *LdapHandle = ldap_init( NULL, LDAP_PORT);

        if ( !*LdapHandle ) 
        {
            DebugOut( L"ldap_init() failed.\n" );
            LdapError = LDAP_UNAVAILABLE;
            goto e0;
        }

        ldap_set_option( *LdapHandle, LDAP_OPT_GETDSNAME_FLAGS, &temp );

        temp = LDAP_VERSION3;
        ldap_set_option( *LdapHandle, LDAP_OPT_VERSION, &temp );

        LdapError = ldap_connect( *LdapHandle, 0 );
        if ( LdapError != LDAP_SUCCESS )
        {
            DebugOut( L"ldap_connect() failed.\n" );
            goto e1;
        }

        LdapError = ldap_bind_s( *LdapHandle, NULL, NULL, LDAP_AUTH_SSPI );
        if ( LdapError != LDAP_SUCCESS ) 
        {
            DebugOut( L"ldap_bind_s() failed.\n" );
            goto e1;
        }
    }

    DebugOut( L"LDAP initialization succeeded.\n" );

e0:
    return LdapError;

e1:
    ldap_unbind( *LdapHandle );
    *LdapHandle = NULL;
    goto e0;
}


void
ErrorMessage( 
    ULONG LdapError )
{
    TCHAR szTmp[ 512 ];
    TCHAR szText[ 512 ];
    TCHAR szTitle[ 64 ];

    szTitle[0] = TEXT('\0');
    LoadString( g_hInstance, IDS_UNABLE_TITLE, szTitle, ARRAYSIZE(szTitle) );
    szTmp[0] = TEXT('\0');
    LoadString( g_hInstance, IDS_UNABLE_TEXT, szTmp, ARRAYSIZE(szTmp) );

    wsprintf( szText, szTmp, LdapError );

    MessageBox( NULL, szText, szTitle, MB_OK );
}

VOID
Usage(
    VOID
    )
{
    TCHAR szText[ 512 ];
    TCHAR szTitle[ 100 ];

    LoadString( g_hInstance, IDS_USAGE_TITLE, szTitle, ARRAYSIZE(szTitle) );
    LoadString( g_hInstance, IDS_USAGE_TEXT, szText, ARRAYSIZE(szText) );
    
    MessageBox( NULL, szText, szTitle, MB_OK );
}

//WINAPI
//
// WinMain()
//
int APIENTRY
_tWinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPTSTR lpCmdLine,
    int nCmdShow)
{
    LPWSTR pszDN = NULL;
    LPWSTR *ppszDN = NULL;
    PLDAP  LdapHandle = NULL;
    PLDAPMessage LdapMessage = NULL;
    int iErr = -1;
    PTSTR CmdLine = lpCmdLine;
    PTSTR p,q;

    ULONG  nSize;
    ULONG  LdapError;
    LPWSTR pszAttributes[ 2 ];
    DWORD  dwCount;
    PLDAPMessage LdapCurrent;
    
    g_hInstance = hInstance;

    if (CmdLine) {
        p = CmdLine;

        while (*p) {
            if (*p == TEXT('/') || *p == TEXT('-')) {
                q = p+1;
                if (*q == TEXT('?')) {
                    Usage();
                    return ERROR_SUCCESS;
                }
            }

            p++;
        }
    }

    if ( !GetComputerObjectName( NameFullyQualifiedDN, NULL, &nSize ) )
    {
        DebugOut( L"GetComputerObjectName() failed.\n" );
        iErr = -2;
        goto Cleanup;
    }
    DebugOut( L"Got GetComputerObjectName() nSize.\n" );

    pszDN = (LPWSTR) LocalAlloc( LMEM_FIXED, nSize * sizeof(WCHAR) );
    if ( !pszDN )
    {
        DebugOut( L"Out of memory.\n" );
        iErr = -3;
        goto Cleanup;
    }
    DebugOut( L"Allocated memory.\n" );

    if ( !GetComputerObjectName( NameFullyQualifiedDN, pszDN, &nSize ) )
    {
        DebugOut( L"GetComputerObjectName() failed.\n" );
        iErr = -4;
        goto Cleanup;
    }
    DebugOut( L"Got GetComputerObjectName().\n" );
    DebugOut( L"Computer DN: " );
    DebugOut( pszDN );
    DebugOut( L"\n" );

    if ( Ldap_InitializeConnection( &LdapHandle ) )
    {
        DebugOut( L"Ldap failed to initialize.\n" );
        iErr = -5;
        goto Cleanup;
    }
    DebugOut( L"Ldap initialized.\n" );

    pszAttributes[0] = L"netbootSCPBL";
    pszAttributes[1] = NULL;

TrySearchAgain:
    LdapError = ldap_search_ext_s( LdapHandle,
                                   pszDN,
                                   LDAP_SCOPE_BASE,
                                   L"objectClass=Computer",
                                   pszAttributes,
                                   FALSE,
                                   NULL,
                                   NULL,
                                   NULL,
                                   0,
                                   &LdapMessage );
    switch( LdapError )
    {
    case LDAP_SUCCESS:
        break;

    case LDAP_BUSY:
    case LDAP_TIMEOUT:
        DebugOut( L"ldap_search_ext_s() failed. Trying again.\n" );
        goto TrySearchAgain;

    default:
        DebugOut( L"ldap_search_ext_s() failed. Displaying pop-up.\n" );
        ErrorMessage( LdapError );
        iErr = -6;
        goto Cleanup;
    }
    DebugOut( L"ldap_search_ext_s() succeeded.\n" );

    dwCount = ldap_count_entries( LdapHandle, LdapMessage );
    if ( dwCount == 0 )
    {
        DebugOut( L"ldap_search_ext_s() returned a count of zero. Nothing to do.\n" );
        iErr = -7;
        goto Cleanup; // NOP
    }
    DebugOut( L"ldap_search_ext_s() found an SCP.\n" );

    LdapCurrent = ldap_first_entry( LdapHandle, LdapMessage );
    if ( !LdapCurrent )
    {
        DebugOut( L"Couldn't retrieve the first entry. Aborting...\n" );
        iErr = -8;
        goto Cleanup;
    }

    ppszDN = ldap_get_values( LdapHandle, LdapCurrent, L"netbootSCPBL");
    if ( !ppszDN )
    {
        DebugOut( L"No DN to SCP. How did we did we get here then?\n" );
        iErr = -9;
        goto Cleanup;
    }
    DebugOut( L"SCP DN: " );
    DebugOut( *ppszDN );
    DebugOut( L"\n" );

TryDeleteAgain:
    LdapError = ldap_delete_s( LdapHandle, *ppszDN );
    switch ( LdapError )
    {
    case LDAP_SUCCESS:
        break;

    case LDAP_BUSY:
    case LDAP_TIMEOUT:
        DebugOut( L"ldap_delete_s() failed. Trying again.\n" );
        goto TryDeleteAgain;

    default:
        {
            LPWSTR pszExtendedError;
            DebugOut( L"ldap_delete_s() failed. Displaying pop-up.\n" );

            ldap_get_option(LdapHandle, LDAP_OPT_SERVER_ERROR, (void *) &pszExtendedError);
            DebugOut( L"Extended Error: " );
            DebugOut( pszExtendedError );
            DebugOut( L"\n" );

            ErrorMessage( LdapError );
            iErr = -9;
            goto Cleanup;
        }
    }

    DebugOut( L"SCP deletion succeeded.\n" );
    iErr = ERROR_SUCCESS;

Cleanup:
    DebugOut( L"Cleaning up...\n" );
    if ( ppszDN )
        ldap_value_free( ppszDN );

    if ( LdapMessage )
        ldap_msgfree( LdapMessage );

    if ( LdapHandle )
        ldap_unbind( LdapHandle );

    if ( pszDN )
        LocalFree( pszDN );

    return iErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\imirror\copy.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    copy.c

Abstract:

    This is for supporting copying files, creating new files, and copying the registries to
    the remote server.

Author:

    Sean Selitrennikoff - 4/5/98

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

WCHAR pConfigPath[MAX_PATH];
WCHAR pSystemPath[MAX_PATH];
WCHAR pCSDVersion[128];
WCHAR pProcessorArchitecture[64];
WCHAR pCurrentType[128];
WCHAR pHalName[128];

#if 0
IMIRROR_MODIFY_DS_INFO ModifyInfo;
#endif

NTSTATUS
AddCopyToDoItems(
    VOID
    )

/*++

Routine Description:

    This routine adds all the to do items necessary for copying files and registries to
    a server installation point, as well as creating new files necessary for remote boot.

Arguments:

    None

Return Value:

    STATUS_SUCCESS if it completes adding all the to do items properly.

--*/

{
    NTSTATUS Status;
    Status = AddToDoItem(CheckPartitions, NULL, 0);

    if (!NT_SUCCESS(Status)) {
        IMirrorHandleError(Status, IMirrorInitialize);
        return Status;
    }

    Status = AddToDoItem(CopyPartitions, NULL, 0);

    if (!NT_SUCCESS(Status)) {
        IMirrorHandleError(Status, IMirrorInitialize);
        return Status;
    }
#if 0
    Status = AddToDoItem(PatchDSEntries, &ModifyInfo, sizeof(ModifyInfo)); // NOTE: This MUST come before MungeRegistry

    if (!NT_SUCCESS(Status)) {
        IMirrorHandleError(Status, IMirrorInitialize);
        return Status;
    }
#endif
    return STATUS_SUCCESS;
}










//
// Functions for processing each TO DO item
//

NTSTATUS
CopyCopyPartitions(
    IN PVOID pBuffer,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine verifies that any partition on the same disk as in the parameter pBuffer, has
    enough free space to hold all the files in the partition that is also in pBuffer.

Arguments:

    pBuffer - Pointer to any arguments passed in the to do item.

    Length - Length, in bytes of the arguments.

Return Value:

    STATUS_SUCCESS if it completes adding all the to do items properly.

--*/

{
    NTSTATUS Status;
    PLIST_ENTRY listEntry;
    PMIRROR_VOLUME_INFO mirrorVolInfo;
    ULONG numberPartitions;
    BOOLEAN copyRegistry = FALSE;
    ULONG NameLength;
    ULONG baseLength = 0;
    BOOLEAN gotUncPath = FALSE;

    IMirrorNowDoing(CopyPartitions, NULL);

    if (GlobalMirrorCfgInfo == NULL) {

        Status = CheckForPartitions();

        if (!NT_SUCCESS(Status)) {
            IMirrorHandleError(Status, CopyPartitions);
            return Status;
        }
    }

    ASSERT(GlobalMirrorCfgInfo != NULL);

    if (GlobalMirrorCfgInfo == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        IMirrorHandleError(Status, CopyPartitions);
        return(Status);
    }
    
    listEntry = GlobalMirrorCfgInfo->MirrorVolumeList.Flink;

    numberPartitions = 0;
    Status = STATUS_SUCCESS;

    while (listEntry != &GlobalMirrorCfgInfo->MirrorVolumeList) {

        mirrorVolInfo = (PMIRROR_VOLUME_INFO) CONTAINING_RECORD(
                                                listEntry,
                                                MIRROR_VOLUME_INFO,
                                                ListEntry
                                                );
        listEntry = listEntry->Flink;

        if (mirrorVolInfo->MirrorUncPath == NULL) {

            if (! gotUncPath) {

                gotUncPath = TRUE;
                NameLength = WCHARSIZE(TmpBuffer);

                Status = IMirrorGetMirrorDir( (PWCHAR)TmpBuffer,
                                             &NameLength);

                if (!NT_SUCCESS(Status)) {

                    IMirrorHandleError(Status, CopyPartitions);
                    return Status;
                }

                baseLength = lstrlenW( (PWCHAR) TmpBuffer );
            }

            swprintf(   (PWCHAR)TmpBuffer2,
                        L"\\Mirror%d",
                        mirrorVolInfo->MirrorTableIndex );

            *((PWCHAR)(TmpBuffer)+baseLength) = L'\0';

            if (wcslen((PWCHAR)TmpBuffer) + wcslen((PWCHAR)TmpBuffer2) + 1 > WCHARSIZE(TmpBuffer)) {
                Status = STATUS_NO_MEMORY;
                IMirrorHandleError(Status, CopyPartitions);
                return Status;
            }
            lstrcatW( (PWCHAR)TmpBuffer, (PWCHAR)TmpBuffer2 );

            NameLength = (lstrlenW( (PWCHAR)TmpBuffer ) + 1) * sizeof(WCHAR);

            mirrorVolInfo->MirrorUncPath = IMirrorAllocMem(NameLength);

            if (mirrorVolInfo->MirrorUncPath == NULL) {

                Status = STATUS_NO_MEMORY;
                IMirrorHandleError(Status, CopyPartitions);
                return Status;
            }

            RtlMoveMemory( mirrorVolInfo->MirrorUncPath,
                           TmpBuffer,
                           NameLength );
        }

        IMirrorNowDoing(CopyPartitions, mirrorVolInfo->MirrorUncPath);

        if (mirrorVolInfo->IsBootDisk) {

            copyRegistry = TRUE;
        }

        Status = AddToDoItem(CopyFiles, &mirrorVolInfo->DriveLetter, sizeof(WCHAR));

        if (!NT_SUCCESS(Status)) {
            IMirrorHandleError(Status, CheckPartitions);
            return Status;
        }

        numberPartitions++;
    }

    if (copyRegistry) {

        Status = AddToDoItem(CopyRegistry, pBuffer, Length);

        if (!NT_SUCCESS(Status)) {
            IMirrorHandleError(Status, CopyPartitions);
            return Status;
        }
    }

    //
    //  write out the mirror config file locally so that if we restart, we
    //  can retrieve the same config again.
    //

    if (numberPartitions && ! GlobalMirrorCfgInfo->SysPrepImage) {

        //
        // Write it out to \\SystemRoot\System32\IMirror.dat
        //

        Status = GetBaseDeviceName(L"\\SystemRoot", (PWCHAR)TmpBuffer2, sizeof(TmpBuffer2));

        wcscat((PWCHAR)TmpBuffer2, L"\\System32\\");
        wcscat((PWCHAR)TmpBuffer2, IMIRROR_DAT_FILE_NAME );

        Status = NtPathToDosPath((PWCHAR)TmpBuffer2, (PWCHAR)TmpBuffer, WCHARSIZE(TmpBuffer), FALSE, FALSE);

        if (NT_SUCCESS(Status)) {

            Status = WriteMirrorConfigFile((PWCHAR) TmpBuffer);

            if (!NT_SUCCESS(Status)) {
                IMirrorHandleError(Status, CopyPartitions);
            }
        }
    }

    return Status;
}



NTSTATUS
CopyCopyFiles(
    IN PVOID pBuffer,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine copies all the files on the given drive to the remote server.

Arguments:

    pBuffer - Pointer to any arguments passed in the to do item.
              The argument must be the drive letter

    Length - Length, in bytes of the arguments.  Should be sizeof(WCHAR)

Return Value:

    STATUS_SUCCESS if it completes the to do item properly.

--*/

{
    PLIST_ENTRY listEntry;
    PMIRROR_VOLUME_INFO mirrorVolInfo = NULL;
    NTSTATUS Status;
    WCHAR LocalBuffer[TMP_BUFFER_SIZE];
    WCHAR SourcePath[8];
    PCOPY_TREE_CONTEXT copyContext = NULL;
    BOOLEAN BackupPriviledged = FALSE;

    Status = IMirrorNowDoing(CopyFiles, NULL);
    if ( Status != NO_ERROR ) {
        return Status;
    }

    if (GlobalMirrorCfgInfo == NULL) {

        Status = CheckForPartitions();

        if (!NT_SUCCESS(Status)) {
            IMirrorHandleError(Status, CopyPartitions);
            return Status;
        }
    }

    ASSERT(GlobalMirrorCfgInfo != NULL);

    if (GlobalMirrorCfgInfo == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        IMirrorHandleError(Status, CopyPartitions);
        return(Status);
    }

    if (Length != sizeof(WCHAR) || pBuffer == NULL) {

        IMirrorHandleError(ERROR_INVALID_DRIVE, CopyFiles);
        return ERROR_INVALID_DRIVE;
    }

    listEntry = GlobalMirrorCfgInfo->MirrorVolumeList.Flink;

    while (listEntry != &GlobalMirrorCfgInfo->MirrorVolumeList) {

        mirrorVolInfo = (PMIRROR_VOLUME_INFO) CONTAINING_RECORD(
                                                listEntry,
                                                MIRROR_VOLUME_INFO,
                                                ListEntry
                                                );
        listEntry = listEntry->Flink;

        if (mirrorVolInfo->DriveLetter == *(PWCHAR)pBuffer) {
            break;
        }

        mirrorVolInfo = NULL;
    }
    if (mirrorVolInfo == NULL) {

        IMirrorHandleError(ERROR_INVALID_DRIVE, CopyFiles);
        return ERROR_INVALID_DRIVE;
    }

    //
    // Create root directory, don't fail if it already exists
    //
    if (!CreateDirectory(mirrorVolInfo->MirrorUncPath, NULL)) {

        Status = GetLastError();

        if (Status != ERROR_ALREADY_EXISTS) {
            IMirrorHandleError(Status, CopyFiles);
            return Status;
        }
    }

    //
    //   create the config file in this mirror root
    //

    if (_snwprintf(LocalBuffer,
                   WCHARSIZE(LocalBuffer),
                   L"%s\\%s",
                   mirrorVolInfo->MirrorUncPath,
                   IMIRROR_DAT_FILE_NAME) < 0) {
        Status = STATUS_BUFFER_OVERFLOW;
        IMirrorHandleError(Status, CopyFiles);
        return Status;
    }
    LocalBuffer[WCHARSIZE(LocalBuffer)-1] = L'\0';

    Status = WriteMirrorConfigFile(LocalBuffer);

    if (!NT_SUCCESS(Status)) {
        IMirrorHandleError(Status, CopyFiles);
        return Status;
    }

    if (!GlobalMirrorCfgInfo->SysPrepImage) {

        //
        //  create staging directory if one is required
        //
        if (_snwprintf(LocalBuffer,
                   WCHARSIZE(LocalBuffer),
                   L"%s\\Staging",
                   mirrorVolInfo->MirrorUncPath) < 0) {
            Status = STATUS_BUFFER_OVERFLOW;
            IMirrorHandleError(Status, CopyFiles);
            return Status;
        }
        LocalBuffer[WCHARSIZE(LocalBuffer)-1] = L'\0';

        if (!CreateDirectory( LocalBuffer, NULL)) {
            Status = GetLastError();

            if (Status != ERROR_ALREADY_EXISTS) {
                IMirrorHandleError(Status, CopyFiles);
                return Status;
            }
        }
    }

    if (mirrorVolInfo->PartitionActive) {

        //
        //  copy the boot code to the server
        //

        if (_snwprintf(LocalBuffer,
                   WCHARSIZE(LocalBuffer),
                   L"%s\\BootCode.dat",
                   mirrorVolInfo->MirrorUncPath) < 0) {
            Status = STATUS_BUFFER_OVERFLOW;
            IMirrorHandleError(Status, CopyFiles);
            return Status;
        }
        LocalBuffer[WCHARSIZE(LocalBuffer)-1] = L'\0';
        
        Status = SaveBootSector(    mirrorVolInfo->DiskNumber,
                                    mirrorVolInfo->PartitionNumber,
                                    mirrorVolInfo->BlockSize,
                                    LocalBuffer );

        if (Status != STATUS_SUCCESS) {
            IMirrorHandleError(Status, CopyFiles);
            return Status;
        }
    }

    //
    // Create UserData directory, don't fail if it already exists
    //
    if (_snwprintf(LocalBuffer,
                   WCHARSIZE(LocalBuffer),
                   L"%s\\UserData",
                   mirrorVolInfo->MirrorUncPath) < 0) {
        Status = STATUS_BUFFER_OVERFLOW;
        IMirrorHandleError(Status, CopyFiles);
        return Status;
    }
    LocalBuffer[WCHARSIZE(LocalBuffer)-1] = L'\0';

    if (!CreateDirectory( LocalBuffer, NULL)) {
        Status = GetLastError();

        if (Status != ERROR_ALREADY_EXISTS) {
            IMirrorHandleError(Status, CopyFiles);
            return Status;
        }
    }

    //
    //  set up the dest path ready for really long file names.
    //

    if (*(mirrorVolInfo->MirrorUncPath) == L'\\' &&
        *(mirrorVolInfo->MirrorUncPath+1) == L'\\') {

        if (*(mirrorVolInfo->MirrorUncPath+2) == L'?') {

            // dest is \\?\..., it's of the correct format
            if (_snwprintf(LocalBuffer,
                   WCHARSIZE(LocalBuffer),
                   L"%s\\UserData",
                   mirrorVolInfo->MirrorUncPath) < 0) {
                Status = STATUS_BUFFER_OVERFLOW;
                IMirrorHandleError(Status, CopyFiles);
                return Status;
            }
            LocalBuffer[WCHARSIZE(LocalBuffer)-1] = L'\0';
        } else {

            // dest is \\billg1\imirror
            // format should be \\?\UNC\billg1\imirror
            if (_snwprintf(LocalBuffer,
                   WCHARSIZE(LocalBuffer),
                   L"\\\\?\\UNC%s\\UserData",
                   mirrorVolInfo->MirrorUncPath +1) < 0) {
                Status = STATUS_BUFFER_OVERFLOW;
                IMirrorHandleError(Status, CopyFiles);
                return Status;
            }
            LocalBuffer[WCHARSIZE(LocalBuffer)-1] = L'\0';
        }
    } else {

        // dest is something like X:
        // format should be \\?\X:

        if (_snwprintf(LocalBuffer,
               WCHARSIZE(LocalBuffer),
               L"\\\\?\\%s\\UserData",
               mirrorVolInfo->MirrorUncPath) < 0) {
            Status = STATUS_BUFFER_OVERFLOW;
            IMirrorHandleError(Status, CopyFiles);
            return Status;
        }
        LocalBuffer[WCHARSIZE(LocalBuffer)-1] = L'\0';
    }

    SourcePath[0] = L'\\';  // format is L"\\\\?\\E:"
    SourcePath[1] = L'\\';
    SourcePath[2] = L'?';
    SourcePath[3] = L'\\';
    SourcePath[4] = mirrorVolInfo->DriveLetter;
    SourcePath[5] = L':';
    SourcePath[6] = L'\\';
    SourcePath[7] = L'\0';

    //
    // Copy all the files
    //

    Status = AllocateCopyTreeContext( &copyContext, TRUE );

    if (Status != ERROR_SUCCESS) {

        IMirrorHandleError(Status, CopyFiles);
        return Status;
    }

    if (RTEnableBackupRestorePrivilege()) {
        BackupPriviledged = TRUE;
    }

    Status = CopyTree( copyContext,
                       (BOOLEAN) (mirrorVolInfo->PartitionType == PARTITION_IFS),
                       &SourcePath[0],
                       LocalBuffer );

    if (BackupPriviledged) {
        RTDisableBackupRestorePrivilege();
    }

    if (copyContext->Cancelled) {
        //
        //  since the copy was cancelled, let's bail on the rest of the processing.
        //

        ClearAllToDoItems(TRUE);
    }

    FreeCopyTreeContext( copyContext );

    if (!NT_SUCCESS(Status)) {
        IMirrorHandleError(Status, CopyFiles);
        return(Status);
    }
    return Status;
}

NTSTATUS
CopyCopyRegistry(
    IN PVOID pBuffer,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine copies the currently running registries to the server.

Arguments:

    pBuffer - Pointer to any arguments passed in the to do item.

    Length - Length, in bytes of the arguments.

Return Value:

    STATUS_SUCCESS if it completes the to do item properly.

--*/

{
    NTSTATUS Status;
    PLIST_ENTRY listEntry;
    ULONG Error;
    PMIRROR_VOLUME_INFO mirrorVolInfo = NULL;

    UNREFERENCED_PARAMETER(pBuffer);
    UNREFERENCED_PARAMETER(Length);

    IMirrorNowDoing(CopyRegistry, NULL);

    if (GlobalMirrorCfgInfo == NULL) {

        Status = CheckForPartitions();

        if (!NT_SUCCESS(Status)) {
            IMirrorHandleError(Status, CopyPartitions);
            return Status;
        }
    }

    ASSERT(GlobalMirrorCfgInfo != NULL);

    if (GlobalMirrorCfgInfo == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        IMirrorHandleError(Status, CopyPartitions);
        return(Status);
    }

    listEntry = GlobalMirrorCfgInfo->MirrorVolumeList.Flink;

    while (listEntry != &GlobalMirrorCfgInfo->MirrorVolumeList) {

        mirrorVolInfo = (PMIRROR_VOLUME_INFO) CONTAINING_RECORD(
                                                listEntry,
                                                MIRROR_VOLUME_INFO,
                                                ListEntry
                                                );
        listEntry = listEntry->Flink;

        if (mirrorVolInfo->IsBootDisk) {
            break;
        }

        mirrorVolInfo = NULL;
    }
    if (mirrorVolInfo == NULL) {

        IMirrorHandleError(ERROR_INVALID_DRIVE, CopyRegistry);
        return ERROR_INVALID_DRIVE;
    }

    //
    // Now do registry backup
    //

    Error = DoFullRegBackup( mirrorVolInfo->MirrorUncPath );
    if (Error != NO_ERROR) {
        IMirrorHandleError(Error, CopyRegistry);
        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
WriteMirrorConfigFile(
    PWCHAR DestFile
    )
{
    ULONG bufferSize;
    PLIST_ENTRY listEntry;
    PMIRROR_VOLUME_INFO mirrorVolInfo;
    PMIRROR_VOLUME_INFO_FILE mirrorVolInfoFile;
    PMIRROR_CFG_INFO_FILE mirrorInfoFile;
    ULONG pathLength;
    ULONG systemPathLength;
    ULONG csdVersionLength;
    ULONG processorArchitectureLength;
    ULONG currentTypeLength;
    ULONG halNameLength;
    PWCHAR nextString;
    NTSTATUS Status;
    HANDLE fileHandle;

retryWriteConfig:

    mirrorInfoFile = NULL;
    Status = STATUS_SUCCESS;
    fileHandle = INVALID_HANDLE_VALUE;

    ASSERT(GlobalMirrorCfgInfo != NULL);

    if (GlobalMirrorCfgInfo == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto exitWriteFile;
    }

    systemPathLength = (lstrlenW( GlobalMirrorCfgInfo->SystemPath ) + 1) * sizeof(WCHAR);
    csdVersionLength = (lstrlenW( GlobalMirrorCfgInfo->CSDVersion ) + 1) * sizeof(WCHAR);
    processorArchitectureLength = (lstrlenW( GlobalMirrorCfgInfo->ProcessorArchitecture ) + 1) * sizeof(WCHAR);
    currentTypeLength = (lstrlenW( GlobalMirrorCfgInfo->CurrentType ) + 1) * sizeof(WCHAR);
    halNameLength = (lstrlenW( GlobalMirrorCfgInfo->HalName ) + 1) * sizeof(WCHAR);

    bufferSize = sizeof( MIRROR_CFG_INFO_FILE ) +
                (sizeof( MIRROR_VOLUME_INFO_FILE ) *
                 (GlobalMirrorCfgInfo->NumberVolumes - 1)) +
                 systemPathLength +
                 csdVersionLength +
                 processorArchitectureLength +
                 currentTypeLength +
                 halNameLength;

    listEntry = GlobalMirrorCfgInfo->MirrorVolumeList.Flink;

    while (listEntry != &GlobalMirrorCfgInfo->MirrorVolumeList) {

        mirrorVolInfo = (PMIRROR_VOLUME_INFO) CONTAINING_RECORD(
                                                listEntry,
                                                MIRROR_VOLUME_INFO,
                                                ListEntry
                                                );
        listEntry = listEntry->Flink;
        bufferSize += ((lstrlenW( mirrorVolInfo->MirrorUncPath ) + 1) * sizeof(WCHAR)) +
                      ((lstrlenW( mirrorVolInfo->VolumeLabel ) + 1) * sizeof(WCHAR)) +
                      ((lstrlenW( mirrorVolInfo->NtName ) + 1) * sizeof(WCHAR)) +
                      ((lstrlenW( mirrorVolInfo->ArcName ) + 1) * sizeof(WCHAR));
    }

    mirrorInfoFile = (PMIRROR_CFG_INFO_FILE) IMirrorAllocMem( bufferSize );

    if (mirrorInfoFile == NULL) {

        Status = STATUS_NO_MEMORY;
        goto exitWriteFile;
    }

    mirrorInfoFile->MirrorVersion = IMIRROR_CURRENT_VERSION;
    mirrorInfoFile->FileLength = bufferSize;
    mirrorInfoFile->NumberVolumes = GlobalMirrorCfgInfo->NumberVolumes;
    mirrorInfoFile->SystemPathLength = systemPathLength;
    mirrorInfoFile->CSDVersionLength = csdVersionLength;
    mirrorInfoFile->ProcessorArchitectureLength = processorArchitectureLength;
    mirrorInfoFile->CurrentTypeLength = currentTypeLength;
    mirrorInfoFile->HalNameLength = halNameLength;
    mirrorInfoFile->SysPrepImage = GlobalMirrorCfgInfo->SysPrepImage;
    mirrorInfoFile->Debug = GlobalMirrorCfgInfo->Debug;
    mirrorInfoFile->MajorVersion = GlobalMirrorCfgInfo->MajorVersion;
    mirrorInfoFile->MinorVersion = GlobalMirrorCfgInfo->MinorVersion;
    mirrorInfoFile->BuildNumber = GlobalMirrorCfgInfo->BuildNumber;
    mirrorInfoFile->KernelFileVersionMS = GlobalMirrorCfgInfo->KernelFileVersionMS;
    mirrorInfoFile->KernelFileVersionLS = GlobalMirrorCfgInfo->KernelFileVersionLS;
    mirrorInfoFile->KernelFileFlags = GlobalMirrorCfgInfo->KernelFileFlags;

    mirrorVolInfoFile = &mirrorInfoFile->Volumes[mirrorInfoFile->NumberVolumes];
    nextString = (PWCHAR) mirrorVolInfoFile;

    mirrorInfoFile->SystemPathOffset = (ULONG)((PCHAR) nextString - (PCHAR) mirrorInfoFile);
    lstrcpyW( nextString, GlobalMirrorCfgInfo->SystemPath );
    nextString += systemPathLength / sizeof(WCHAR);

    mirrorInfoFile->CSDVersionOffset = (ULONG)((PCHAR) nextString - (PCHAR) mirrorInfoFile);
    lstrcpyW( nextString, GlobalMirrorCfgInfo->CSDVersion );
    nextString += csdVersionLength / sizeof(WCHAR);

    mirrorInfoFile->ProcessorArchitectureOffset = (ULONG)((PCHAR) nextString - (PCHAR) mirrorInfoFile);
    lstrcpyW( nextString, GlobalMirrorCfgInfo->ProcessorArchitecture );
    nextString += processorArchitectureLength / sizeof(WCHAR);

    mirrorInfoFile->CurrentTypeOffset = (ULONG)((PCHAR) nextString - (PCHAR) mirrorInfoFile);
    lstrcpyW( nextString, GlobalMirrorCfgInfo->CurrentType );
    nextString += currentTypeLength / sizeof(WCHAR);

    mirrorInfoFile->HalNameOffset = (ULONG)((PCHAR) nextString - (PCHAR) mirrorInfoFile);
    lstrcpyW( nextString, GlobalMirrorCfgInfo->HalName );
    nextString += halNameLength / sizeof(WCHAR);

    listEntry = GlobalMirrorCfgInfo->MirrorVolumeList.Flink;

    mirrorVolInfoFile = &mirrorInfoFile->Volumes[0];

    while (listEntry != &GlobalMirrorCfgInfo->MirrorVolumeList) {

        mirrorVolInfo = (PMIRROR_VOLUME_INFO) CONTAINING_RECORD(
                                                listEntry,
                                                MIRROR_VOLUME_INFO,
                                                ListEntry
                                                );
        listEntry = listEntry->Flink;

        mirrorVolInfoFile->MirrorTableIndex = mirrorVolInfo->MirrorTableIndex;
        mirrorVolInfoFile->DriveLetter = mirrorVolInfo->DriveLetter;
        mirrorVolInfoFile->PartitionType = mirrorVolInfo->PartitionType;
        mirrorVolInfoFile->PartitionActive = mirrorVolInfo->PartitionActive;
        mirrorVolInfoFile->IsBootDisk = mirrorVolInfo->IsBootDisk;
        mirrorVolInfoFile->CompressedVolume = mirrorVolInfo->CompressedVolume;
        mirrorVolInfoFile->DiskSignature = mirrorVolInfo->DiskSignature;
        mirrorVolInfoFile->BlockSize = mirrorVolInfo->BlockSize;
        mirrorVolInfoFile->LastUSNMirrored = mirrorVolInfo->LastUSNMirrored;
        mirrorVolInfoFile->FileSystemFlags = mirrorVolInfo->FileSystemFlags;
        wcscpy(mirrorVolInfoFile->FileSystemName, mirrorVolInfo->FileSystemName);
        mirrorVolInfoFile->DiskSpaceUsed = mirrorVolInfo->DiskSpaceUsed;
        mirrorVolInfoFile->StartingOffset = mirrorVolInfo->StartingOffset;
        mirrorVolInfoFile->PartitionSize = mirrorVolInfo->PartitionSize;
        mirrorVolInfoFile->DiskNumber = mirrorVolInfo->DiskNumber;
        mirrorVolInfoFile->PartitionNumber = mirrorVolInfo->PartitionNumber;

        // set the path in the config file relative to the root of this
        // image.  As example, set it to L"\Mirror1\UserData"
        swprintf(   (PWCHAR)TmpBuffer2,
                    L"\\Mirror%d\\UserData",
                    mirrorVolInfo->MirrorTableIndex );

        pathLength = (lstrlenW( (PWCHAR)TmpBuffer2 ) + 1) * sizeof(WCHAR);
        mirrorVolInfoFile->MirrorUncLength = pathLength;
        mirrorVolInfoFile->MirrorUncPathOffset = (ULONG)((PCHAR) nextString - (PCHAR) mirrorInfoFile);
        lstrcpyW( nextString, (PWCHAR)TmpBuffer2 );
        nextString += pathLength / sizeof(WCHAR);

        pathLength = (lstrlenW( mirrorVolInfo->VolumeLabel ) + 1) * sizeof(WCHAR);
        mirrorVolInfoFile->VolumeLabelLength = pathLength;
        mirrorVolInfoFile->VolumeLabelOffset = (ULONG)((PCHAR) nextString - (PCHAR) mirrorInfoFile);
        lstrcpyW( nextString, mirrorVolInfo->VolumeLabel );
        nextString += pathLength / sizeof(WCHAR);

        pathLength = (lstrlenW( mirrorVolInfo->NtName ) + 1) * sizeof(WCHAR);
        mirrorVolInfoFile->NtNameLength = pathLength;
        mirrorVolInfoFile->NtNameOffset = (ULONG)((PCHAR) nextString - (PCHAR) mirrorInfoFile);
        lstrcpyW( nextString, mirrorVolInfo->NtName );
        nextString += pathLength / sizeof(WCHAR);

        pathLength = (lstrlenW( mirrorVolInfo->ArcName ) + 1) * sizeof(WCHAR);
        mirrorVolInfoFile->ArcNameLength = pathLength;
        mirrorVolInfoFile->ArcNameOffset = (ULONG)((PCHAR) nextString - (PCHAR) mirrorInfoFile);
        lstrcpyW( nextString, mirrorVolInfo->ArcName );
        nextString += pathLength / sizeof(WCHAR);

        mirrorVolInfoFile++;

        //
        //  call off to the wizard to tell him what the system directory
        //  is if we have a valid one.
        //

        if (mirrorVolInfo->IsBootDisk && (systemPathLength > 3 * sizeof(WCHAR))) {

            //
            //  pass it in the form of "MirrorX\UserData\WinNT"
            //  so we have to skip the C: in the systempath
            //

            swprintf(   (PWCHAR)TmpBuffer2,
                        L"Mirror%d\\UserData",
                        mirrorVolInfo->MirrorTableIndex );

            lstrcatW( (PWCHAR)TmpBuffer2, GlobalMirrorCfgInfo->SystemPath + 2 );
            IMirrorSetSystemPath(   (PWCHAR) TmpBuffer2,
                                    (lstrlenW( (PWCHAR) TmpBuffer2)) );
        }
    }

    fileHandle = CreateFile(    DestFile,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_ARCHIVE,
                                NULL );

    if (fileHandle == INVALID_HANDLE_VALUE) {

        Status = GetLastError();
        goto exitWriteFile;
    }

    if (!WriteFile( fileHandle,
                    mirrorInfoFile,
                    bufferSize,
                    &bufferSize,
                    NULL)) {

        Status = GetLastError();
        goto exitWriteFile;
    }

exitWriteFile:

    if (fileHandle != INVALID_HANDLE_VALUE) {

        CloseHandle( fileHandle );
        fileHandle = INVALID_HANDLE_VALUE;
    }

    if (mirrorInfoFile) {
        IMirrorFreeMem( mirrorInfoFile );
        mirrorInfoFile = NULL;
    }

    if (Status != ERROR_SUCCESS) {

        DWORD errorCase;

        errorCase = ReportCopyError(   NULL,
                                       DestFile,
                                       COPY_ERROR_ACTION_CREATE_FILE,
                                       Status );
        if (errorCase == STATUS_RETRY) {
            goto retryWriteConfig;
        }
        if ( errorCase == ERROR_SUCCESS ) {
            Status = ERROR_SUCCESS;
        }
    }
    return Status;
}

#define MIN_BOOT_SECTOR_BLOCK_SIZE  512

NTSTATUS
SaveBootSector(
    DWORD DiskNumber,
    DWORD PartitionNumber,
    DWORD BlockSize,
    PWCHAR DestFile
    )
{
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    IO_STATUS_BLOCK IoStatusBlock;
    DWORD bufferSize;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE bootSectorHandle = INVALID_HANDLE_VALUE;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    PUCHAR AlignedBuffer;
    PUCHAR allocatedBuffer = NULL;

    swprintf((PWCHAR)TmpBuffer, L"\\Device\\Harddisk%d\\Partition%d", DiskNumber, PartitionNumber );

    RtlInitUnicodeString(&UnicodeString, (PWCHAR)TmpBuffer);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                              );

    Status = NtCreateFile(&bootSectorHandle,
                          (ACCESS_MASK)FILE_GENERIC_READ,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          FILE_OPEN,
                          FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0
                         );

    if (!NT_SUCCESS(Status)) {
        IMirrorHandleError(Status, CopyPartitions);
        goto exitSaveBootSector;
    }

    if (BlockSize < MIN_BOOT_SECTOR_BLOCK_SIZE) {

        BlockSize = MIN_BOOT_SECTOR_BLOCK_SIZE;
    }

    if (BlockSize + MIN_BOOT_SECTOR_BLOCK_SIZE > TMP_BUFFER_SIZE) {

        allocatedBuffer = IMirrorAllocMem( BlockSize + MIN_BOOT_SECTOR_BLOCK_SIZE );

        if (allocatedBuffer == NULL) {

            Status = STATUS_NO_MEMORY;
            goto exitSaveBootSector;
        }

        AlignedBuffer = ALIGN(allocatedBuffer, MIN_BOOT_SECTOR_BLOCK_SIZE);

    } else {

        AlignedBuffer = ALIGN(TmpBuffer, MIN_BOOT_SECTOR_BLOCK_SIZE);
    }

    Status = NtReadFile(bootSectorHandle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        AlignedBuffer,
                        BlockSize,
                        NULL,
                        NULL
                       );

    if (!NT_SUCCESS(Status)) {
        IMirrorHandleError(Status, CopyPartitions);
        goto exitSaveBootSector;
    }

    fileHandle = CreateFile(    DestFile,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_ARCHIVE,
                                NULL );

    if (fileHandle == INVALID_HANDLE_VALUE) {

        Status = GetLastError();
        goto exitSaveBootSector;
    }

    if (!WriteFile( fileHandle,
                    AlignedBuffer,
                    BlockSize,
                    &bufferSize,
                    NULL)) {

        Status = GetLastError();

    } else {

        Status = STATUS_SUCCESS;
    }

exitSaveBootSector:

    if (bootSectorHandle != INVALID_HANDLE_VALUE) {
        NtClose(bootSectorHandle);
    }

    if (fileHandle != INVALID_HANDLE_VALUE) {
        NtClose(fileHandle);
    }

    if (allocatedBuffer) {
        IMirrorFreeMem( allocatedBuffer );
    }

    if (!NT_SUCCESS(Status)) {
        IMirrorHandleError(Status, CopyPartitions);
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\imirror\copy.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    copy.h

Abstract:

    This the include file for supporting copying files, creating new files, and
    copying the registries to the remote server.

Author:

    Sean Selitrennikoff - 4/5/98

Revision History:

--*/


extern WCHAR pConfigPath[MAX_PATH];

//
// Define structure for an on-disk master boot record. (pulled from
// private\windows\setup\textmode\kernel\sppartit.h)
//
typedef struct _ON_DISK_PTE {
    UCHAR ActiveFlag;
    UCHAR StartHead;
    UCHAR StartSector;
    UCHAR StartCylinder;
    UCHAR SystemId;
    UCHAR EndHead;
    UCHAR EndSector;
    UCHAR EndCylinder;
    UCHAR RelativeSectors[4];
    UCHAR SectorCount[4];
} ON_DISK_PTE, *PON_DISK_PTE;
typedef struct _ON_DISK_MBR {
    UCHAR       BootCode[440];
    UCHAR       NTFTSignature[4];
    UCHAR       Filler[2];
    ON_DISK_PTE PartitionTable[4];
    UCHAR       AA55Signature[2];
} ON_DISK_MBR, *PON_DISK_MBR;

#define ALIGN(p,val) (PVOID)((((UINT_PTR)(p) + (val) - 1)) & (~((val) - 1)))
#define U_USHORT(p)    (*(USHORT UNALIGNED *)(p))
#define U_ULONG(p)     (*(ULONG  UNALIGNED *)(p))

typedef struct _MIRROR_VOLUME_INFO {
    LIST_ENTRY ListEntry;
    DWORD   MirrorTableIndex;
    WCHAR   DriveLetter;
    UCHAR   PartitionType;
    BOOLEAN PartitionActive;
    BOOLEAN IsBootDisk;
    BOOLEAN CompressedVolume;
    PWCHAR  MirrorUncPath;
    DWORD   DiskNumber;
    DWORD   PartitionNumber;
    DWORD   DiskSignature;
    DWORD   BlockSize;
    DWORD   LastUSNMirrored;
    ULONG   FileSystemFlags;
    WCHAR   FileSystemName[16];
    PWCHAR  VolumeLabel;
    PWCHAR  NtName;
    PWCHAR  ArcName;
    LARGE_INTEGER DiskSpaceUsed;
    LARGE_INTEGER StartingOffset;
    LARGE_INTEGER PartitionSize;
} MIRROR_VOLUME_INFO, *PMIRROR_VOLUME_INFO;


typedef struct _MIRROR_CFG_INFO {
    DWORD   MirrorVersion;
    DWORD   FileLength;
    DWORD   NumberVolumes;
    PWCHAR  SystemPath;
    BOOLEAN SysPrepImage;   // if FALSE, means it's a mirror
    BOOLEAN Debug;
    ULONG   NumberOfProcessors;
    ULONG   MajorVersion;
    ULONG   MinorVersion;
    ULONG   BuildNumber;
    ULONG   KernelFileVersionMS;
    ULONG   KernelFileVersionLS;
    ULONG   KernelFileFlags;
    PWCHAR  CSDVersion;
    PWCHAR  ProcessorArchitecture;
    PWCHAR  CurrentType;
    PWCHAR  HalName;
    LIST_ENTRY MirrorVolumeList;
} MIRROR_CFG_INFO, *PMIRROR_CFG_INFO;

extern PMIRROR_CFG_INFO GlobalMirrorCfgInfo;

typedef struct _IMIRROR_IGNORE_FILE_LIST {
    LIST_ENTRY ListEntry;
    USHORT FileNameLength;
    WCHAR FileName[1];
} IMIRROR_IGNORE_FILE_LIST, *PIMIRROR_IGNORE_FILE_LIST;

//
// Main processing functions
//
NTSTATUS
AddCopyToDoItems(
    VOID
    );


//
// Functions for processing each to do item
//
NTSTATUS
CopyCopyFiles(
    IN PVOID pBuffer,
    IN ULONG Length
    );

NTSTATUS
CopyCopyPartitions(
    IN PVOID pBuffer,
    IN ULONG Length
    );

NTSTATUS
CopyCopyRegistry(
    IN PVOID pBuffer,
    IN ULONG Length
    );

//
// Helper functions in filecopy.c
//
#if 0
NTSTATUS
DoFileCopy(
    IN PWSTR pMachineDir,
    IN PWSTR pSrc,
    IN BOOLEAN CheckConfig
    );

NTSTATUS
CopyNode(
    IN PWIN32_FIND_DATA pSrcFindData,
    IN BOOLEAN fFirstTime
    );
#endif

DWORD
CallBackFn(LPCWSTR             lpszName,
           DWORD               dwStatus,
           DWORD               dwHintFlags,
           DWORD               dwPinCount,
           WIN32_FIND_DATAW    *lpFind32,
           DWORD               dwReason,
           DWORD               dwParam1,
           DWORD               dwParam2,
           DWORD               dwContext
          );

#if 0
BOOLEAN
CopyPath(
    IN OUT PWCHAR *ppDest,
    IN OUT PULONG pLength,
    IN PWCHAR pSrc
    );

BOOLEAN
CatPath(
    IN OUT PWCHAR *ppDest,
    IN OUT PULONG pLength,
    IN PWCHAR pSrc
    );
#endif
//
// Helper functions in regcopy.c
//
DWORD
DoFullRegBackup(
    PWCHAR MirrorRoot
    );

DWORD
DoSpecificRegBackup(
    PWSTR HivePath,
    HKEY HiveRoot,
    PWSTR HiveName
    );

DWORD
GetRegistryFileList(
    PLIST_ENTRY ListHead
    );

//
// Global Defines
//
#define TMP_BUFFER_SIZE 1024
#define ARRAYSIZE( _x ) ( sizeof( _x ) / sizeof( _x[ 0 ] ) )
//
// use this macro to get the size of byte buffers below
//
#define WCHARSIZE( _x ) ( sizeof( _x ) / sizeof( WCHAR ) )
//
// Global variables
//
extern BYTE TmpBuffer[TMP_BUFFER_SIZE];
extern BYTE TmpBuffer2[TMP_BUFFER_SIZE];
extern BYTE TmpBuffer3[TMP_BUFFER_SIZE];

//
// Memory functions
//
#define IMirrorAllocMem(x) LocalAlloc( LPTR, x)
#define IMirrorFreeMem(x)  LocalFree(x)
#define IMirrorReallocMem(x, sz)  LocalReAlloc(x, sz, LMEM_MOVEABLE)


//
// Error handling
//
#define IMirrorHandleError(_s, _f) ((Callbacks.ErrorFn != NULL) ? \
                                      Callbacks.ErrorFn(Callbacks.Context, _s, _f) : 0)

#define IMirrorNowDoing(_f, _s) ((Callbacks.NowDoingFn != NULL) ? \
                                      Callbacks.NowDoingFn(Callbacks.Context, _f, _s) : 0)

#define IMirrorGetMirrorDir(_s, _l) ((Callbacks.GetMirrorDirFn != NULL) ? \
                                      Callbacks.GetMirrorDirFn(Callbacks.Context, _s, _l) : 0)

#define IMirrorGetSetupPath(_s, _p, _l) ((Callbacks.GetSetupFn != NULL) ? \
                                      Callbacks.GetSetupFn(Callbacks.Context, _s, _p, _l) : 0)

#define IMirrorSetSystemPath(_p, _l) ((Callbacks.SetSystemDirFn != NULL) ? \
                                      Callbacks.SetSystemDirFn(Callbacks.Context, _p, _l) : 0)

#define IMirrorFileCreate(_f, _a, _e) ((Callbacks.FileCreateFn != NULL) ? \
                                      Callbacks.FileCreateFn(Callbacks.Context, _f, _a, _e) : 0)

#define IMirrorRegSaveError(_p, _s) ((Callbacks.RegSaveErrorFn != NULL) ? \
                                      Callbacks.RegSaveErrorFn(Callbacks.Context, _p, _s) : 0)

#define IMirrorReinit() ((Callbacks.ReinitFn != NULL) ? \
                                      Callbacks.ReinitFn(Callbacks.Context) : 0)
//
// To Do item functions
//

NTSTATUS
GetNextToDoItem(
    OUT PIMIRROR_TODO Item,
    OUT PVOID *Buffer,
    OUT PULONG Length
    );

NTSTATUS
AddToDoItem(
    IN IMIRROR_TODO Item,
    IN PVOID Buffer,
    IN ULONG Length
    );

NTSTATUS
ModifyToDoItem(
    IN IMIRROR_TODO Item,
    IN PVOID Buffer,
    IN ULONG Length
    );

NTSTATUS
CopyToDoItemParameters(
    IN IMIRROR_TODO Item,
    OUT PVOID Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
WriteMirrorConfigFile(
    PWCHAR DestFile
    );

NTSTATUS
SaveBootSector(
    DWORD DiskNumber,
    DWORD PartitionNumber,
    DWORD BlockSize,
    PWCHAR DestFile
    );

extern WCHAR pConfigPath[MAX_PATH];
extern WCHAR pSystemPath[MAX_PATH];
extern WCHAR pCSDVersion[128];
extern WCHAR pProcessorArchitecture[64];
extern WCHAR pCurrentType[128];
extern WCHAR pHalName[128];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\imirror\ckmach.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ckmach.c

Abstract:

    This is for supporting checking a machine to see if it can be converted to IntelliMirror.

Author:

    Sean Selitrennikoff - 4/5/98

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop
#include <ntverp.h>

PMIRROR_CFG_INFO GlobalMirrorCfgInfo = NULL;


//
// Support functions to do individual tasks
//
NTSTATUS
AddCheckMachineToDoItems(
    VOID
    )

/*++

Routine Description:

    This routine adds all the to do items necessary for checking out the local machine for
    conversion.

Arguments:

    None

Return Value:

    STATUS_SUCCESS if it completes adding all the to do items properly.

--*/

{
    NTSTATUS Status;

    Status = AddToDoItem(VerifySystemIsNt5, NULL, 0);

    if (!NT_SUCCESS(Status)) {
        IMirrorHandleError(Status, IMirrorInitialize);
        return Status;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
CheckIfNt5(
    )

/*++

Routine Description:

    This routine verifies that the current system is NT5 workstation, x86

Arguments:

    None.
    
Return Value:

    STATUS_SUCCESS if it completes adding all the to do items properly.

--*/

{
    OSVERSIONINFO OsVersion;
    DWORD productVersion[] = { VER_PRODUCTVERSION };

    IMirrorNowDoing(VerifySystemIsNt5, NULL);

    RtlZeroMemory(&OsVersion, sizeof(OSVERSIONINFO));
    OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if (!GetVersionEx(&OsVersion)) {
        IMirrorHandleError(GetLastError(), VerifySystemIsNt5);
        return GetLastError();
    }

    if (OsVersion.dwPlatformId != VER_PLATFORM_WIN32_NT) {
        IMirrorHandleError(ERROR_OLD_WIN_VERSION, VerifySystemIsNt5);
        return ERROR_OLD_WIN_VERSION;
    }

    if (OsVersion.dwMajorVersion != productVersion[0]) {
        IMirrorHandleError(ERROR_OLD_WIN_VERSION, VerifySystemIsNt5);
        return ERROR_OLD_WIN_VERSION;
    }

    //
    //  We're changing the format of the alternate data stream.  As such,
    //  we're introducing an incompatiblility.  We'll pick this up here and
    //  return to riprep.exe the error.  Otherwise the user doesn't find out
    //  about it until text mode setup on restoring the image.
    //
    //  The NT build number that this is getting checked into is 2080.
    //

    if (OsVersion.dwBuildNumber < 2080) {

        DbgPrint("build number is %u\n", OsVersion.dwBuildNumber);
        IMirrorHandleError(ERROR_OLD_WIN_VERSION, VerifySystemIsNt5);
        return ERROR_OLD_WIN_VERSION;
    }
    return STATUS_SUCCESS;
}

BOOLEAN
ReadRegistryString(
    IN PWCHAR KeyName,
    IN PWCHAR ValueName,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine reads a string from the registry into Buffer.

Arguments:

    KeyName - The registry key.

    ValueName - The value under that key to read, or NULL if the name of
        the first key under that key is to be read.

    Buffer - The buffer to hold the result.

    BufferLength - The length of Buffer.

Return Value:

    TRUE if success, FALSE if any errors occur.

--*/

{
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PKEY_VALUE_PARTIAL_INFORMATION pValueInfo = NULL;
    PKEY_BASIC_INFORMATION pKeyInfo = NULL;
    HANDLE Handle = NULL;
    ULONG ByteCount;
    NTSTATUS Status;
    PVOID ResultData;
    ULONG ResultDataLength;
    BOOLEAN ReturnValue = FALSE;

    //
    //
    // Open the key.
    //
    //
    RtlInitUnicodeString(&UnicodeString, KeyName);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                              );

    Status = NtOpenKey(&Handle,
                       KEY_ALL_ACCESS,
                       &ObjectAttributes
                      );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }


    if (ValueName != NULL) {

        RtlInitUnicodeString(&UnicodeString, ValueName);

        //
        // Get the size of the buffer needed
        //
        ByteCount = 0;
        Status = NtQueryValueKey(Handle,
                                 &UnicodeString,
                                 KeyValuePartialInformation,
                                 NULL,
                                 0,
                                 &ByteCount
                                );

        if (Status != STATUS_BUFFER_TOO_SMALL) {
            goto Cleanup;
        }

        pValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)IMirrorAllocMem(ByteCount);

        if (pValueInfo == NULL) {
            goto Cleanup;
        }

        //
        // Get the buffer from the registry
        //
        Status = NtQueryValueKey(Handle,
                                 &UnicodeString,
                                 KeyValuePartialInformation,
                                 pValueInfo,
                                 ByteCount,
                                 &ByteCount
                                );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        if (pValueInfo->Type != REG_SZ) {
            goto Cleanup;
        }

        ResultData = pValueInfo->Data;
        ResultDataLength = pValueInfo->DataLength;

    } else {

        //
        // Get the size of the buffer needed
        //
        ByteCount = 0;
        Status = NtEnumerateKey(Handle,
                                0,
                                KeyBasicInformation,
                                NULL,
                                0,
                                &ByteCount
                               );

        if (Status != STATUS_BUFFER_TOO_SMALL) {
            goto Cleanup;
        }

        pKeyInfo = (PKEY_BASIC_INFORMATION)IMirrorAllocMem(ByteCount);

        if (pKeyInfo == NULL) {
            goto Cleanup;
        }

        //
        // Get the name from the registry
        //
        Status = NtEnumerateKey(Handle,
                                0,
                                KeyBasicInformation,
                                pKeyInfo,
                                ByteCount,
                                &ByteCount
                               );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        ResultData = pKeyInfo->Name;
        ResultDataLength = pKeyInfo->NameLength;

    }

    if (ResultDataLength > BufferLength) {
        goto Cleanup;
    }

    memcpy(Buffer, ResultData, ResultDataLength);

    //
    // NULL-terminate it just in case, if there is room.
    //

    if (ResultDataLength <= BufferLength - sizeof(WCHAR)) {
        ((PWCHAR)Buffer)[ResultDataLength / sizeof(WCHAR)] = L'\0';
    }


    ReturnValue = TRUE;

Cleanup:

    if (pValueInfo != NULL) {
        IMirrorFreeMem(pValueInfo);
    }

    if (pKeyInfo != NULL) {
        IMirrorFreeMem(pKeyInfo);
    }

    if (Handle != NULL) {
        NtClose(Handle);
    }

    return ReturnValue;
}

NTSTATUS
CheckForPartitions(
    VOID
    )

/*++

Routine Description:

    This routine enumerates all partitions and formats the GlobalMirrorCfgInfo
    global structure.

    It also fills in the pConfigPath.

Arguments:

    None.
    
Return Value:

    STATUS_SUCCESS if it completes adding all the to do items properly.

--*/

{
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatus;
    PARTITION_INFORMATION_EX PartitionInfoEx;
    PARTITION_INFORMATION PartitionInfo;
    HANDLE Handle;
    ULONG MirrorNumber;
    ULONG DiskNumber;
    ULONG PartitionNumber;
    NTSTATUS Status;
    BOOLEAN foundBoot = FALSE;
    BOOLEAN foundSystem = FALSE;
    FILE_FS_SIZE_INFORMATION SizeInfo;
    LARGE_INTEGER UsedSpace;
    LARGE_INTEGER FreeSpace;
    ON_DISK_MBR OnDiskMbr;
    PUCHAR AlignedBuffer;
    UINT previousMode;

    HANDLE DosDevicesDir;
    ULONG Context;
    WCHAR SystemDriveLetter;
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    ULONG dosLength;
    BOOLEAN RestartScan;
    PMIRROR_VOLUME_INFO mirrorVolInfo;
    ULONG diskSignature;
    DWORD fileSystemFlags;
    WCHAR fileSystemName[16];
    WCHAR volumeLabel[33];
    ULONG volumeLabelLength;
    WCHAR arcName[MAX_PATH];
    ULONG ntNameLength;
    ULONG arcNameLength;
    OSVERSIONINFO osVersionInfo;
    SYSTEM_INFO systemInfo;
    DWORD fileVersionInfoSize;
    DWORD versionHandle;
    PVOID versionInfo;
    VS_FIXEDFILEINFO * fixedFileInfo;
    UINT fixedFileInfoLength;
    WCHAR kernelPath[MAX_PATH];
    PWCHAR kernelPathPart;
    BOOL b;
#ifndef IMIRROR_NO_TESTING_LIMITATIONS
    ULONG numberOfDrives = 0;
#endif
    BOOLEAN isDynamic = FALSE;
    BOOLEAN UsePartitionInfoEx = TRUE;

    IMirrorNowDoing(CheckPartitions, NULL);

    if (GlobalMirrorCfgInfo) {

        return STATUS_SUCCESS;
    }

    //
    // alloc space for the data structure that tracks the partition
    // information.
    //
    GlobalMirrorCfgInfo = IMirrorAllocMem(sizeof(MIRROR_CFG_INFO));

    if (GlobalMirrorCfgInfo == NULL) {
        Status = STATUS_NO_MEMORY;
        IMirrorHandleError(Status, CheckPartitions);
        return Status;
    }

    //
    // Disable hard error popups for this thread.
    //

    previousMode = SetErrorMode( SEM_FAILCRITICALERRORS );

    //
    // save away system information in the data structure that tracks the 
    // partition  information.
    //
    GlobalMirrorCfgInfo->MirrorVersion = IMIRROR_CURRENT_VERSION;
    GlobalMirrorCfgInfo->FileLength = 0;
    GlobalMirrorCfgInfo->SystemPath = NULL;
    GlobalMirrorCfgInfo->SysPrepImage = TRUE;  
    GlobalMirrorCfgInfo->NumberVolumes = 0;

    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (GetVersionEx(&osVersionInfo)) {
        GlobalMirrorCfgInfo->MajorVersion = osVersionInfo.dwMajorVersion;
        GlobalMirrorCfgInfo->MinorVersion = osVersionInfo.dwMinorVersion;
        GlobalMirrorCfgInfo->BuildNumber = osVersionInfo.dwBuildNumber;
        lstrcpyW(pCSDVersion, osVersionInfo.szCSDVersion);
        GlobalMirrorCfgInfo->CSDVersion = pCSDVersion;
    }

    //
    // save kernel version information.
    //
    if (SearchPath(
            NULL,
            L"ntoskrnl.exe",
            NULL,
            MAX_PATH,
            kernelPath,
            &kernelPathPart)) {
        fileVersionInfoSize = GetFileVersionInfoSize(kernelPath, &versionHandle);
        if (fileVersionInfoSize != 0) {
            versionInfo = IMirrorAllocMem(fileVersionInfoSize);
            if (versionInfo != NULL) {
                if (GetFileVersionInfo(
                        kernelPath,
                        versionHandle,
                        fileVersionInfoSize,
                        versionInfo)) {
                    if (VerQueryValue(
                            versionInfo,
                            L"\\",
                            &fixedFileInfo,
                            &fixedFileInfoLength)) {
                        GlobalMirrorCfgInfo->KernelFileVersionMS = fixedFileInfo->dwFileVersionMS;
                        GlobalMirrorCfgInfo->KernelFileVersionLS = fixedFileInfo->dwFileVersionLS;
                        GlobalMirrorCfgInfo->KernelFileFlags = fixedFileInfo->dwFileFlags;
                        DbgPrint("MS %lx LS %lx flags %lx\n",
                            GlobalMirrorCfgInfo->KernelFileVersionMS,
                            GlobalMirrorCfgInfo->KernelFileVersionLS,
                            GlobalMirrorCfgInfo->KernelFileFlags);
                    }
                }
                IMirrorFreeMem(versionInfo);
            }
        }
    }

    //
    // is it a debug system?
    //
    if (GetSystemMetrics(SM_DEBUG)) {
        GlobalMirrorCfgInfo->Debug = TRUE;
    }

    //
    // save # of processors.
    //
    GetSystemInfo(&systemInfo);
    GlobalMirrorCfgInfo->NumberOfProcessors = systemInfo.dwNumberOfProcessors;

    //
    // save architecture
    //
    if (ReadRegistryString(
            L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Session Manager\\Environment",
            L"PROCESSOR_ARCHITECTURE",
            pProcessorArchitecture,
            sizeof(pProcessorArchitecture))) {
        DbgPrint("processor arch is %ws\n", pProcessorArchitecture);
        GlobalMirrorCfgInfo->ProcessorArchitecture = pProcessorArchitecture;
    }

    //
    // "current type" of system (server/workstation/etc.)
    //
    if (ReadRegistryString(
            L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion",
            L"CurrentType",
            pCurrentType,
            sizeof(pCurrentType))) {
        DbgPrint("current type is %ws\n", pCurrentType);
        GlobalMirrorCfgInfo->CurrentType = pCurrentType;
    }

    //
    // save the hal type
    //
    if (ReadRegistryString(
            L"\\Registry\\Machine\\Hardware\\RESOURCEMAP\\Hardware Abstraction Layer",
            NULL,
            pHalName,
            sizeof(pHalName))) {
        DbgPrint("HAL name is %ws\n", pHalName);
        GlobalMirrorCfgInfo->HalName = pHalName;
    }

    InitializeListHead( &GlobalMirrorCfgInfo->MirrorVolumeList );

    //
    // Get local system drive letter and \\Systemroot\System32\Config path
    //

    Status = GetBaseDeviceName(L"\\SystemRoot", (PWCHAR)TmpBuffer2, sizeof(TmpBuffer2));

    if (!NT_SUCCESS(Status)) {
        IMirrorHandleError(Status, CheckPartitions);
        goto ExitCheckPartitions;
    }

    Status = NtPathToDosPath(   (PWCHAR) TmpBuffer2,
                                pConfigPath,
                                ARRAYSIZE(pConfigPath),
                                FALSE,
                                FALSE);

    if (!NT_SUCCESS(Status)) {
        IMirrorHandleError(Status, CheckPartitions);
        goto ExitCheckPartitions;
    }

    ASSERT( pConfigPath[1] == L':' );
    SystemDriveLetter = (WCHAR) pConfigPath[0];

    //
    //  save off the system path so that we can write it out to
    //  the imirror.dat file
    //

    lstrcpynW( pSystemPath, pConfigPath, MAX_PATH );
    pSystemPath[MAX_PATH-1] = L'\0';

    GlobalMirrorCfgInfo->SystemPath = pSystemPath;

    wcscat( pConfigPath, L"\\System32\\Config");

    //
    // Open \DosDevices directory.
    //
    RtlInitUnicodeString(&UnicodeString,L"\\Device");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                              );

    Status = NtOpenDirectoryObject(&DosDevicesDir,
                                   DIRECTORY_QUERY,
                                   &ObjectAttributes
                                  );

    if (!NT_SUCCESS(Status)) {
        IMirrorHandleError(Status, CheckPartitions);
        goto ExitCheckPartitions;
    }

    //
    // Iterate each object in that directory that is a directory.
    //
    Context = 0;
    RestartScan = TRUE;

    Status = NtQueryDirectoryObject(DosDevicesDir,
                                    TmpBuffer,
                                    sizeof(TmpBuffer),
                                    TRUE,
                                    RestartScan,
                                    &Context,
                                    &dosLength
                                   );

    RestartScan = FALSE;
    DirInfo = (POBJECT_DIRECTORY_INFORMATION)TmpBuffer;
    MirrorNumber = 1;

    while (NT_SUCCESS(Status)) {

        DirInfo->Name.Buffer[DirInfo->Name.Length/sizeof(WCHAR)] = 0;
        DirInfo->TypeName.Buffer[DirInfo->TypeName.Length/sizeof(WCHAR)] = 0;

        //
        // Skip this entry if it's not a "HardDiskN"
        //

        if ((DirInfo->Name.Length > (sizeof(L"Harddisk")-sizeof(WCHAR))) &&
            (!wcsncmp(DirInfo->Name.Buffer,L"Harddisk",(sizeof(L"Harddisk")/sizeof(WCHAR))-1)) &&
            !_wcsicmp(DirInfo->TypeName.Buffer, L"Directory")) {

            PWCHAR diskNumberPtr;

            PartitionNumber = 0;
            DiskNumber = 0;

            diskNumberPtr = &DirInfo->Name.Buffer[(sizeof(L"Harddisk")/sizeof(WCHAR))-1];

            while (*diskNumberPtr >= L'0' && *diskNumberPtr <= L'9' ) {

                DiskNumber *= 10;
                DiskNumber += *(diskNumberPtr) - L'0';
                diskNumberPtr++;
            }

            if (*diskNumberPtr != L'\0') {

                //
                //  if the device name wasn't of form HardDiskN, skip this entry.
                //

                goto getNextDevice;
            }

            diskSignature = 0;

            //
            //  get the MBR disk signature, continue if it fails.
            //
            
            swprintf((PWCHAR)TmpBuffer2, L"\\Device\\Harddisk%d\\Partition0", DiskNumber);

            RtlInitUnicodeString(&UnicodeString, (PWCHAR)TmpBuffer2);

            InitializeObjectAttributes(&ObjectAttributes,
                                       &UnicodeString,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL
                                      );

            Status = NtCreateFile(&Handle,
                                  (ACCESS_MASK)FILE_GENERIC_READ,
                                  &ObjectAttributes,
                                  &IoStatus,
                                  NULL,
                                  FILE_ATTRIBUTE_NORMAL,
                                  FILE_SHARE_READ,
                                  FILE_OPEN,
                                  FILE_SYNCHRONOUS_IO_NONALERT,
                                  NULL,
                                  0
                                 );

            if (NT_SUCCESS(Status)) {

                ASSERT(sizeof(ON_DISK_MBR) == 512);
                AlignedBuffer = ALIGN(TmpBuffer, 512);

                Status = NtReadFile(Handle,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatus,
                                    AlignedBuffer,
                                    sizeof(ON_DISK_MBR),
                                    NULL,
                                    NULL
                                   );

                if (NT_SUCCESS(Status)) {

                    RtlMoveMemory(&OnDiskMbr, AlignedBuffer, sizeof(ON_DISK_MBR));

                    ASSERT(U_USHORT(OnDiskMbr.AA55Signature) == 0xAA55);

                    diskSignature = U_ULONG(OnDiskMbr.NTFTSignature);

                    //
                    //  check to see if this disk is dynamic
                    //

                    if (OnDiskMbr.PartitionTable[0].SystemId == PARTITION_LDM ||
                        OnDiskMbr.PartitionTable[1].SystemId == PARTITION_LDM ||
                        OnDiskMbr.PartitionTable[2].SystemId == PARTITION_LDM ||
                        OnDiskMbr.PartitionTable[3].SystemId == PARTITION_LDM) {

                        isDynamic = TRUE;
                        NtClose(Handle);
                        goto getNextDevice;
                    }
                }
                NtClose(Handle);
            }

            while (1) {

                PartitionNumber++;

                swprintf((PWCHAR)TmpBuffer2, L"\\Device\\Harddisk%d\\Partition%d", DiskNumber, PartitionNumber);

                RtlInitUnicodeString(&UnicodeString, (PWCHAR)TmpBuffer2);

                InitializeObjectAttributes(&ObjectAttributes,
                                           &UnicodeString,
                                           OBJ_CASE_INSENSITIVE,
                                           NULL,
                                           NULL
                                          );

                Status = NtCreateFile(&Handle,
                                      (ACCESS_MASK)FILE_GENERIC_READ,
                                      &ObjectAttributes,
                                      &IoStatus,
                                      NULL,
                                      FILE_ATTRIBUTE_NORMAL,
                                      FILE_SHARE_READ | FILE_SHARE_WRITE,
                                      FILE_OPEN,
                                      FILE_SYNCHRONOUS_IO_NONALERT,
                                      NULL,
                                      0
                                     );

                if (!NT_SUCCESS(Status)) {
                    break;      // on to next disk
                }

                ZeroMemory(&PartitionInfo,sizeof(PARTITION_INFORMATION));
                Status = NtDeviceIoControlFile(Handle,
                                               NULL,
                                               NULL,
                                               NULL,
                                               &IoStatus,
                                               IOCTL_DISK_GET_PARTITION_INFO_EX,
                                               NULL,
                                               0,
                                               &PartitionInfoEx,
                                               sizeof(PARTITION_INFORMATION_EX) );

                if( (Status == STATUS_NOT_IMPLEMENTED) || (Status == STATUS_INVALID_DEVICE_REQUEST) ) {

                    //
                    // We're on an old build that didn't have this IOCTL.
                    //
                    UsePartitionInfoEx = FALSE;

                    Status = NtDeviceIoControlFile(Handle,
                                                   NULL,
                                                   NULL,
                                                   NULL,
                                                   &IoStatus,
                                                   IOCTL_DISK_GET_PARTITION_INFO,
                                                   NULL,
                                                   0,
                                                   &PartitionInfo,
                                                   sizeof(PARTITION_INFORMATION) );
                }


                if (!NT_SUCCESS(Status)) {
                    NtClose(Handle);
                    continue;   // on to next partition
                }

                //
                // For Whistler, ignore GPT partitions.  if we want to pay
                // attention to GPT partitions, then we would have to start
                // paying attention to the GPT disk signature as well.
                //

                if( (UsePartitionInfoEx) && (PartitionInfoEx.PartitionStyle != PARTITION_STYLE_MBR) ) {
                    NtClose(Handle);
                    continue;
                }

                Status = NtQueryVolumeInformationFile(Handle,
                                                      &IoStatus,
                                                      &SizeInfo,
                                                      sizeof(SizeInfo),
                                                      FileFsSizeInformation );

                NtClose(Handle);

                if (!NT_SUCCESS(Status)) {
                    continue;   // on to next partition
                }

                Status = NtPathToDosPath(   (PWCHAR) TmpBuffer2,
                                            (PWCHAR) TmpBuffer,
                                            WCHARSIZE(TmpBuffer),
                                            TRUE,
                                            FALSE);

                if (!NT_SUCCESS(Status)) {
                    continue;   // on to next partition
                }

                if ((lstrlenW((PWCHAR) TmpBuffer) == 0) ||
                    *(((PWCHAR)TmpBuffer)+1) != L':') {

                    continue;   // on to next partition
                }

                //
                // Get the ARC name of the partition.
                //

                NtNameToArcName( (PWCHAR) TmpBuffer2,
                                 (PWCHAR) arcName,
                                 WCHARSIZE(arcName),
                                 FALSE);

                //
                // Get the file system type. We add a \ to the end
                // of TmpBuffer if there isn't one.
                //

                if (((PWCHAR)TmpBuffer)[lstrlenW((PWCHAR)TmpBuffer) - 1] != L'\\') {
                    wcscat((PWCHAR)TmpBuffer, L"\\");
                }

                b = GetVolumeInformationW(
                        (PWCHAR) TmpBuffer,
                        volumeLabel,
                        ARRAYSIZE(volumeLabel),
                        NULL,      // no volume serial number requested
                        NULL,      // no maximum name length requested
                        &fileSystemFlags,
                        fileSystemName,
                        ARRAYSIZE(fileSystemName));

                if (!b) {
                    continue;
                }

                //
                // Calculate the amount of free space on the drive.
                //
                FreeSpace = RtlExtendedIntegerMultiply(
                                SizeInfo.AvailableAllocationUnits,
                                SizeInfo.SectorsPerAllocationUnit * SizeInfo.BytesPerSector
                                );

                UsedSpace = RtlExtendedIntegerMultiply(
                                SizeInfo.TotalAllocationUnits,
                                SizeInfo.SectorsPerAllocationUnit * SizeInfo.BytesPerSector
                                );

                UsedSpace = RtlLargeIntegerSubtract(
                                UsedSpace,
                                FreeSpace
                                );

#ifndef IMIRROR_NO_TESTING_LIMITATIONS

                numberOfDrives++;

                //
                //  for NT 5.0, the test group doesn't want to test more than a single
                //  partition.  Now that the test team is dictating what the feature set
                //  is, we'll return an error if we have more than a single partition or
                //  disk.
                //

                if ( (UsePartitionInfoEx  && !PartitionInfoEx.Mbr.BootIndicator) ||
                     (!UsePartitionInfoEx && !PartitionInfo.BootIndicator)) {

                    if (*(PWCHAR)TmpBuffer == SystemDriveLetter) {

                        IMirrorHandleError(STATUS_MISSING_SYSTEMFILE, CheckPartitions);
                        NtClose(DosDevicesDir);
                        Status = STATUS_MISSING_SYSTEMFILE;
                        goto ExitCheckPartitions;
                    }
                    continue;
                }

                if (*(PWCHAR)TmpBuffer != SystemDriveLetter) {

                    // if another drive is marked bootable but it isn't the
                    // system drive, we'll ignore it.  We'll pick up the
                    // error down below if this is the only bootable drive.
#if 0
                    if ( (UsePartitionInfoEx  && PartitionInfoEx.Mbr.BootIndicator) ||
                         (!UsePartitionInfoEx && PartitionInfo.BootIndicator)) {

                        IMirrorHandleError(STATUS_MISSING_SYSTEMFILE, CheckPartitions);
                        NtClose(DosDevicesDir);
                        Status = STATUS_MISSING_SYSTEMFILE;
                        goto ExitCheckPartitions;
                    }
#endif
                    continue;
                }
#endif
                mirrorVolInfo = IMirrorAllocMem(sizeof(MIRROR_VOLUME_INFO));

                if (mirrorVolInfo == NULL) {
                    NtClose(DosDevicesDir);
                    Status = STATUS_NO_MEMORY;
                    IMirrorHandleError(Status, CheckPartitions);
                    goto ExitCheckPartitions;
                }

                //
                // Save the NT and ARC device names.
                //

                ntNameLength = (lstrlenW( (PWCHAR)TmpBuffer2 ) + 1) * sizeof(WCHAR);

                mirrorVolInfo->NtName = IMirrorAllocMem(ntNameLength);

                if (mirrorVolInfo->NtName == NULL) {

                    Status = STATUS_NO_MEMORY;
                    IMirrorHandleError(Status, CheckPartitions);
                    NtClose(DosDevicesDir);
                    goto ExitCheckPartitions;
                }

                arcNameLength = (lstrlenW( (PWCHAR)arcName ) + 1) * sizeof(WCHAR);

                mirrorVolInfo->ArcName = IMirrorAllocMem(arcNameLength);

                if (mirrorVolInfo->ArcName == NULL) {

                    Status = STATUS_NO_MEMORY;
                    IMirrorHandleError(Status, CheckPartitions);
                    NtClose(DosDevicesDir);
                    goto ExitCheckPartitions;
                }

                memcpy(mirrorVolInfo->NtName, TmpBuffer2, ntNameLength);
                memcpy(mirrorVolInfo->ArcName, arcName, arcNameLength);

                mirrorVolInfo->DriveLetter = *(PWCHAR)TmpBuffer;
                mirrorVolInfo->PartitionType = UsePartitionInfoEx ? PartitionInfoEx.Mbr.PartitionType : PartitionInfo.PartitionType;

                //
                // If this is a non-NTFS volume, check if it is configured
                // for compression
                //
                if ( ((UsePartitionInfoEx  && (PartitionInfoEx.Mbr.PartitionType != PARTITION_IFS)) ||
                      (!UsePartitionInfoEx && (PartitionInfo.PartitionType != PARTITION_IFS))) 
                     &&
                     (fileSystemFlags & FS_VOL_IS_COMPRESSED) ) {

                    mirrorVolInfo->CompressedVolume = TRUE;

                } else {

                    mirrorVolInfo->CompressedVolume = FALSE;
                    
                }

                if ( (UsePartitionInfoEx  && (PartitionInfoEx.Mbr.BootIndicator)) ||
                     (!UsePartitionInfoEx && (PartitionInfo.BootIndicator)) ) {

                    foundBoot = TRUE;
                    mirrorVolInfo->PartitionActive = TRUE;

                } else {

                    mirrorVolInfo->PartitionActive = FALSE;
                }

                if (*(PWCHAR)TmpBuffer == SystemDriveLetter) {

                    foundSystem = TRUE;
                    mirrorVolInfo->IsBootDisk = TRUE;

                } else {

                    mirrorVolInfo->IsBootDisk = FALSE;
                }

                mirrorVolInfo->DiskNumber = DiskNumber;
                mirrorVolInfo->PartitionNumber = PartitionNumber;
                mirrorVolInfo->MirrorTableIndex = MirrorNumber++;
                mirrorVolInfo->MirrorUncPath = NULL;
                mirrorVolInfo->LastUSNMirrored = 0;
                mirrorVolInfo->BlockSize = SizeInfo.BytesPerSector;
                mirrorVolInfo->DiskSignature = diskSignature;
                mirrorVolInfo->FileSystemFlags = fileSystemFlags;
                wcscpy(mirrorVolInfo->FileSystemName, fileSystemName);

                volumeLabelLength = (lstrlenW( (PWCHAR)volumeLabel ) + 1) * sizeof(WCHAR);
                mirrorVolInfo->VolumeLabel = IMirrorAllocMem(volumeLabelLength);
                if (mirrorVolInfo->VolumeLabel == NULL) {
                    Status = STATUS_NO_MEMORY;
                    IMirrorHandleError(Status, CheckPartitions);
                    NtClose(DosDevicesDir);
                    goto ExitCheckPartitions;
                }
                memcpy(mirrorVolInfo->VolumeLabel, volumeLabel, volumeLabelLength);

                mirrorVolInfo->StartingOffset = UsePartitionInfoEx ? PartitionInfoEx.StartingOffset : PartitionInfo.StartingOffset;
                mirrorVolInfo->PartitionSize  = UsePartitionInfoEx ? PartitionInfoEx.PartitionLength : PartitionInfo.PartitionLength;
                mirrorVolInfo->DiskSpaceUsed = UsedSpace;

                InsertTailList( &GlobalMirrorCfgInfo->MirrorVolumeList,
                                &mirrorVolInfo->ListEntry );

                GlobalMirrorCfgInfo->NumberVolumes = MirrorNumber - 1;
            }
        }
        //
        // Go on to next object.
        //
getNextDevice:
        Status = NtQueryDirectoryObject(
                    DosDevicesDir,
                    TmpBuffer,
                    sizeof(TmpBuffer),
                    TRUE,
                    RestartScan,
                    &Context,
                    &dosLength
                    );
    }

    NtClose(DosDevicesDir);

    if ((!foundBoot) || (!foundSystem) ) {

        Status = (isDynamic ? STATUS_OBJECT_TYPE_MISMATCH : STATUS_MISSING_SYSTEMFILE);
        IMirrorHandleError(Status, CheckPartitions);
        goto ExitCheckPartitions;
    }
#ifndef IMIRROR_NO_TESTING_LIMITATIONS
    if (numberOfDrives > 1) {
        IMirrorHandleError(ERROR_INVALID_DRIVE, CheckPartitions);
        Status = ERROR_INVALID_DRIVE;
    } else {
        Status = STATUS_SUCCESS;
    }
#else
    Status = STATUS_SUCCESS;
#endif

ExitCheckPartitions:

    SetErrorMode( previousMode );
    return Status;
}

NTSTATUS
NtPathToDosPath(
    IN PWSTR NtPath,
    OUT PWSTR DosPath,
    IN ULONG DosPathBufferSize,
    IN BOOLEAN GetDriveOnly,
    IN BOOLEAN NtPathIsBasic
    )

/*++

Routine Description:

    This routine calls off to convert a \Device\HarddiskX\PartitionY\<path> to Z:\<path>

Arguments:

    NtPath - Something like \Device\Harddisk0\Partition2\WINNT

    DosPath - Will be something like D: or D:\WINNT, depending on flag below.
              
    DosPathBufferSize - size in characters of DosPath buffer

    GetDriveOnly - TRUE if the caller only wants the DOS drive.

    NtPathIsBasic - TRUE if NtPath is not symbolic link.

Return Value:

    STATUS_SUCCESS if it completes filling in DosDrive, else an appropriate error code.

--*/

{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE DosDevicesDir;
    ULONG Context;
    ULONG Length;
    BOOLEAN RestartScan;
    WCHAR LinkTarget[2*MAX_PATH];
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    WCHAR LocalBuffer[MAX_PATH];
    WCHAR LocalBuffer2[MAX_PATH];
    PWCHAR pTmp;
    PWCHAR NameSpace[] = { L"\\??", L"\\GLOBAL??" };
    UINT i;
    
    if (NtPath == NULL) {
        return ERROR_PATH_NOT_FOUND;
    }

    if (!NtPathIsBasic) {

        //
        // Find the end of the \device\harddiskX\partitionY string
        //
        wcsncpy(LocalBuffer2, NtPath, MAX_PATH);
        LocalBuffer2[MAX_PATH-1] = L'\0';
        pTmp = LocalBuffer2;
        if (*pTmp != L'\\') {
            return ERROR_PATH_NOT_FOUND;
        }

        pTmp = wcsstr(pTmp + 1, L"\\");

        if (pTmp == NULL) {
            return ERROR_PATH_NOT_FOUND;
        }

        pTmp = wcsstr(pTmp + 1, L"\\");

        if (pTmp == NULL) {
            return ERROR_PATH_NOT_FOUND;
        }

        pTmp = wcsstr(pTmp + 1, L"\\");

        if (pTmp != NULL) {
            *pTmp = UNICODE_NULL;
            pTmp++;
        }

        //
        // Find the base NT device name
        //
        Status = GetBaseDeviceName(LocalBuffer2, LocalBuffer, sizeof(LocalBuffer));

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

    } else {

        wcsncpy(LocalBuffer, NtPath, MAX_PATH);
        LocalBuffer[MAX_PATH-1] = L'\0';
        pTmp = NULL;

    }

    //
    // Open \DosDevices directory.  First try the "normal" dosdevices path, 
    // then try the global dosdevices path.
    //
    for (i = 0; i < sizeof(NameSpace)/sizeof(PWCHAR *); i++) {
        
        RtlInitUnicodeString(&UnicodeString,NameSpace[i]);
    
        InitializeObjectAttributes(&ObjectAttributes,
                                   &UnicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL
                                  );
    
        Status = NtOpenDirectoryObject(&DosDevicesDir,
                                       DIRECTORY_QUERY,
                                       &ObjectAttributes
                                      );
    
        if (!NT_SUCCESS(Status)) {
            DosDevicesDir = NULL;   
        } else {
        
    
            //
            // Iterate each object in that directory.
            //
            Context = 0;
            RestartScan = TRUE;
        
            Status = NtQueryDirectoryObject(DosDevicesDir,
                                            TmpBuffer3,
                                            sizeof(TmpBuffer3),
                                            TRUE,
                                            RestartScan,
                                            &Context,
                                            &Length
                                           );
        
            RestartScan = FALSE;
            DirInfo = (POBJECT_DIRECTORY_INFORMATION)TmpBuffer3;
        
            while (NT_SUCCESS(Status)) {
        
                DirInfo->Name.Buffer[DirInfo->Name.Length/sizeof(WCHAR)] = 0;
                DirInfo->TypeName.Buffer[DirInfo->TypeName.Length/sizeof(WCHAR)] = 0;
        
                //
                // Skip this entry if it's not a symbolic link.
                //
                if ((DirInfo->Name.Length != 0) &&
                    (DirInfo->Name.Buffer[1] == L':') &&
                    !_wcsicmp(DirInfo->TypeName.Buffer, L"SymbolicLink")) {
        
                    //
                    // Get this \DosDevices object's link target.
                    //
                    if (_snwprintf(
                                LocalBuffer2,
                                WCHARSIZE(LocalBuffer2),
                                L"%ws\\%ws",
                                NameSpace[i], 
                                DirInfo->Name.Buffer) < 0) {
                        //
                        // not enough buffer space, go onto next link.
                        //
                        goto next;
                    }
                    LocalBuffer2[MAX_PATH-1] = L'\0';
                    
                    Status = GetBaseDeviceName(LocalBuffer2, LinkTarget, sizeof(LinkTarget));
        
                    if (NT_SUCCESS(Status)) {
        
                        //
                        // See if it's a prefix of the path we're converting,
                        //
                        if(!_wcsnicmp(LocalBuffer, LinkTarget, wcslen(LinkTarget))) {
        
                            //
                            // Got a match.
                            //
                            lstrcpynW(DosPath, DirInfo->Name.Buffer,DosPathBufferSize);
                            DosPath[DosPathBufferSize-1] = L'\0';
        
                            if (!GetDriveOnly) {
        
                                if (NtPathIsBasic) {
        
                                    if (wcslen(LocalBuffer + wcslen(LinkTarget)) + wcslen(DosPath) + 1 <= DosPathBufferSize) {
                                        lstrcat(DosPath, LocalBuffer + wcslen(LinkTarget));
                                    } else {
                                        goto next;
                                    }
        
                                } else if (pTmp != NULL) {
        
                                    if (wcslen(DosPath) + wcslen(pTmp) + sizeof(L"\\")/sizeof(WCHAR) <= DosPathBufferSize) {
                                        lstrcat(DosPath, L"\\");
                                        lstrcat(DosPath, pTmp);
                                    } else {
                                        goto next;
                                    }
                                }
        
                            }
        
                            NtClose(DosDevicesDir);
                            return(STATUS_SUCCESS);
                        }
                    }
                }

next:
                //
                // Go on to next object.
                //
                Status = NtQueryDirectoryObject(
                            DosDevicesDir,
                            TmpBuffer3,
                            sizeof(TmpBuffer3),
                            TRUE,
                            RestartScan,
                            &Context,
                            &Length
                            );
            
            }
    
            NtClose(DosDevicesDir);
    
        }

    }

    return(Status);

}

NTSTATUS
NtNameToArcName(
    IN PWSTR NtName,
    OUT PWSTR ArcName,
    IN ULONG  ArcNameBufferSize,
    IN BOOLEAN NtNameIsBasic
    )

/*++

Routine Description:

    This routine calls off to convert a \Device\HarddiskX\PartitionY to
    the ARC name.

Arguments:

    NtName - Something like \Device\Harddisk0\Partition2

    ArcName - Will be something like \Arcname\multi(0)disk(0)rdisk(0)partition(1).
    
    ArcNameBufferSize - size in characters of arcname buffer

    NtNameIsBasic - TRUE if NtName is not symbolic link.

Return Value:

    STATUS_SUCCESS if it completes filling in ArcName, else an appropriate error code.

--*/

{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    HANDLE DosDevicesDir;
    ULONG Context;
    ULONG Length;
    BOOLEAN RestartScan;
    WCHAR LinkTarget[2*MAX_PATH];
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    WCHAR LocalBuffer[MAX_PATH];
    WCHAR LocalBuffer2[MAX_PATH];
    
    if (!NtNameIsBasic) {

        //
        // Find the base NT device name
        //
        Status = GetBaseDeviceName(NtName, LocalBuffer, sizeof(LocalBuffer));

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

    } else {

        wcsncpy(LocalBuffer, NtName, MAX_PATH);
        LocalBuffer[MAX_PATH-1] = L'\0';

    }

    //
    // Open \ArcName directory.
    //
    RtlInitUnicodeString(&UnicodeString,L"\\ArcName");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                              );

    Status = NtOpenDirectoryObject(&DosDevicesDir,
                                   DIRECTORY_QUERY,
                                   &ObjectAttributes
                                  );

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Iterate each object in that directory.
    //
    Context = 0;
    RestartScan = TRUE;

    Status = NtQueryDirectoryObject(DosDevicesDir,
                                    TmpBuffer3,
                                    sizeof(TmpBuffer3),
                                    TRUE,
                                    RestartScan,
                                    &Context,
                                    &Length
                                   );

    RestartScan = FALSE;
    DirInfo = (POBJECT_DIRECTORY_INFORMATION)TmpBuffer3;

    while (NT_SUCCESS(Status)) {

        DirInfo->Name.Buffer[DirInfo->Name.Length/sizeof(WCHAR)] = 0;
        DirInfo->TypeName.Buffer[DirInfo->TypeName.Length/sizeof(WCHAR)] = 0;

        //
        // Skip this entry if it's not a symbolic link.
        //
        if ((DirInfo->Name.Length != 0) &&
            !_wcsicmp(DirInfo->TypeName.Buffer, L"SymbolicLink")) {

            //
            // Get this \DosDevices object's link target.
            //
            if (_snwprintf(
                        LocalBuffer2,
                        MAX_PATH,
                        L"\\ArcName\\%ws",
                        DirInfo->Name.Buffer) < 0) {
                goto next;
            }
            LocalBuffer2[MAX_PATH-1] = L'\0';

            Status = GetBaseDeviceName(LocalBuffer2, LinkTarget, sizeof(LinkTarget));

            if (NT_SUCCESS(Status)) {

                //
                // See if the base name of this link matches the base
                // name of what we are looking for.
                //

                if(!_wcsnicmp(LocalBuffer, LinkTarget, wcslen(LinkTarget))) {

                    if (wcslen(DirInfo->Name.Buffer) + 1 > ArcNameBufferSize) {
                        return ERROR_BUFFER_OVERFLOW;
                    }
                    //
                    // Got a match.
                    //
                    lstrcpyn(ArcName, DirInfo->Name.Buffer, ArcNameBufferSize);
                    ArcName[ArcNameBufferSize-1] = L'\0';

                    NtClose(DosDevicesDir);
                    return STATUS_SUCCESS;
                }
            }
        }

next:
        //
        // Go on to next object.
        //
        Status = NtQueryDirectoryObject(
                    DosDevicesDir,
                    TmpBuffer3,
                    sizeof(TmpBuffer3),
                    TRUE,
                    RestartScan,
                    &Context,
                    &Length
                    );
    }

    NtClose(DosDevicesDir);
    return Status;
}

NTSTATUS
GetBaseDeviceName(
    IN PWSTR SymbolicName,
    OUT PWSTR Buffer,
    IN ULONG Size
    )

/*++

Routine Description:

    This routine drills down thru symbolic links until it finds the base device name.

Arguments:

    SymbolicName - The name to start with.

    Buffer - The output buffer.

    Size - Length, in bytes of Buffer

Return Value:

    STATUS_SUCCESS if it completes adding all the to do items properly.

--*/

{
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Handle;
    NTSTATUS Status;

    //
    // Start at the first name
    //
    RtlInitUnicodeString(&UnicodeString, SymbolicName);

    InitializeObjectAttributes(
       &ObjectAttributes,
       &UnicodeString,
       OBJ_CASE_INSENSITIVE,
       NULL,
       NULL
       );

    Status = NtOpenSymbolicLinkObject(&Handle,
                                      (ACCESS_MASK)SYMBOLIC_LINK_QUERY,
                                      &ObjectAttributes
                                     );

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    while (TRUE) {

        //
        // Take this open and get the next name
        //
        UnicodeString.Length = 0;
        UnicodeString.MaximumLength = (USHORT)Size;
        UnicodeString.Buffer = (PWCHAR)Buffer;
        Status = NtQuerySymbolicLinkObject(Handle,
                                           &UnicodeString,
                                           NULL
                                          );

        NtClose(Handle);

        Buffer[(UnicodeString.Length / sizeof(WCHAR))] = UNICODE_NULL;

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        //
        // See if the next name is also a symbolic name
        //

        RtlInitUnicodeString(&UnicodeString, Buffer);

        InitializeObjectAttributes(
           &ObjectAttributes,
           &UnicodeString,
           OBJ_CASE_INSENSITIVE,
           NULL,
           NULL
           );

        Status = NtOpenSymbolicLinkObject(&Handle,
                                          (ACCESS_MASK)SYMBOLIC_LINK_QUERY,
                                          &ObjectAttributes
                                         );

        if (!NT_SUCCESS(Status)) {
            return STATUS_SUCCESS;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\cleanri\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cleanri.rc
//
#define IDS_UNABLE_TITLE                1
#define IDS_UNABLE_TEXT                 2
#define IDS_USAGE_TITLE                 3
#define IDS_USAGE_TEXT                  4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\imirror\ckmach.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ckmach.h

Abstract:

    This is the include file for supporting checking a machine to see if it can
    be converted to IntelliMirror.

Author:

    Sean Selitrennikoff - 4/5/98

Revision History:

--*/

//
// Main processing functions
//
NTSTATUS
AddCheckMachineToDoItems(
    VOID
    );

//
// Support functions to do individual tasks
//
NTSTATUS
CheckIfNt5(
    VOID
    );

NTSTATUS
CheckForPartitions(
    VOID
    );
//
// Utility functions
//
NTSTATUS
NtPathToDosPath(
    IN PWCHAR NtPath,
    OUT PWCHAR DosPath,
    IN ULONG DosPathBufferSize,
    IN BOOLEAN GetDriveOnly,
    IN BOOLEAN NtPathIsBasic
    );

NTSTATUS
NtNameToArcName(
    IN PWSTR NtName,
    OUT PWSTR ArcName,
    IN ULONG ArcNameBufferSize,
    IN BOOLEAN NtNameIsBasic
    );

NTSTATUS
GetBaseDeviceName(
    IN PWSTR SymbolicName,
    OUT PWSTR Buffer,
    IN ULONG Size
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\imirror\precomp.h ===
#define SECURITY_WIN32
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4127)   // conditional expression is constant
#pragma warning(disable:4706)   // assignment within conditional

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>

#include <winldap.h>
#include <dsgetdc.h>
#include <sspi.h>
#include <secext.h>

#include <ntdddisk.h>

#include <aclapi.h>
#include <remboot.h>

#include "imirror.h"
#include "ckmach.h"
#include "copy.h"
#include "mirror.h"
#include "regtool.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\imirror\mirror.h ===
/*
Module Name:

    mirror.h

Abstract:

    This module is the header file for the code that copies from one
    tree to another.

Author:

    Andy Herron May 27 1998

Revision History:

*/

//
//  This structure contains all the global data passed around for the
//  different instances of copying subtrees active.
//

typedef struct _COPY_TREE_CONTEXT {

    LIST_ENTRY PendingDirectoryList;

    LARGE_INTEGER BytesCopied;
    ULONG FilesCopied;
    ULONG AttributesModified;
    ULONG SourceFilesScanned;
    ULONG DestFilesScanned;
    ULONG DirectoriesCreated;
    ULONG ErrorsEncountered;
    ULONG FilesDeleted;
    ULONG DirectoriesDeleted;
    ULONG SecurityDescriptorsWritten;
    ULONG SourceSecurityDescriptorsRead;
    ULONG SFNWritten;
    BOOLEAN Cancelled;
    BOOLEAN DeleteOtherFiles;

    CRITICAL_SECTION Lock;

} COPY_TREE_CONTEXT, *PCOPY_TREE_CONTEXT;


//
//  this is the structure we use to track per thread instance data, per thread
//  buffers, etc.
//

#define IMIRROR_INITIAL_SD_LENGTH 2048
#define IMIRROR_INITIAL_SFN_LENGTH 32

typedef struct _IMIRROR_THREAD_CONTEXT {
    PCOPY_TREE_CONTEXT CopyContext;

    LPBYTE SDBuffer;
    DWORD  SDBufferLength;

    LPBYTE SFNBuffer;
    DWORD  SFNBufferLength;

    LPBYTE DirectoryBuffer;
    DWORD  DirectoryBufferLength;
    BOOLEAN IsNTFS;
    HANDLE SourceDirHandle;
    HANDLE DestDirHandle;

    PVOID FindBufferBase;
    PVOID FindBufferNext;
    ULONG FindBufferLength;

    LIST_ENTRY FilesToIgnore;

} IMIRROR_THREAD_CONTEXT, *PIMIRROR_THREAD_CONTEXT;

//
//  This structure is used to report back errors that occurred during copying.
//

typedef struct _COPY_ERROR {
    LIST_ENTRY ListEntry;
    DWORD Error;
    DWORD ActionCode;
    PWCHAR FileName;
    WCHAR  FileNameBuffer[1];
} COPY_ERROR, *PCOPY_ERROR;

#define IMIRROR_ATTRIBUTES_TO_REPLICATE ( FILE_ATTRIBUTE_HIDDEN    | \
                                          FILE_ATTRIBUTE_READONLY  | \
                                          FILE_ATTRIBUTE_SYSTEM    | \
                                          FILE_ATTRIBUTE_TEMPORARY | \
                                          FILE_ATTRIBUTE_NORMAL    | \
                                          FILE_ATTRIBUTE_DIRECTORY | \
                                          FILE_ATTRIBUTE_ARCHIVE )

#define IMIRROR_ATTRIBUTES_TO_STORE (~(IMIRROR_ATTRIBUTES_TO_REPLICATE))

#define IMIRROR_ATTRIBUTES_TO_IGNORE ( FILE_ATTRIBUTE_OFFLINE             | \
                                       FILE_ATTRIBUTE_SPARSE_FILE         | \
                                       FILE_ATTRIBUTE_NOT_CONTENT_INDEXED )

//
//  These are the functions in mirror.c
//

DWORD
AllocateCopyTreeContext (
    PCOPY_TREE_CONTEXT *CopyContext,
    BOOLEAN DeleteOtherFiles
    );

VOID
FreeCopyTreeContext (
    PCOPY_TREE_CONTEXT CopyContext
    );

DWORD
CopyTree (
    PCOPY_TREE_CONTEXT CopyContext,
    BOOLEAN IsNtfs,
    PWCHAR SourceRoot,
    PWCHAR DestRoot
    );

ULONG
ReportCopyError (
    PCOPY_TREE_CONTEXT CopyContext OPTIONAL,
    PWCHAR File,
    DWORD  ActionCode,
    DWORD err
    );

ULONG
IMConvertNT2Win32Error(
    IN NTSTATUS Status
    );

DWORD
IMFindNextFile(
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    HANDLE  DirHandle,
    PFILE_FULL_DIR_INFORMATION *lpFindFileData
    );

DWORD
IMFindFirstFile(
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    HANDLE  DirHandle,
    PFILE_FULL_DIR_INFORMATION *lpFindFileData
    );

NTSTATUS
GetTokenHandle(
    IN OUT PHANDLE TokenHandle
    );

NTSTATUS
SetPrivs(
    IN HANDLE TokenHandle,
    IN LPTSTR lpszPriv
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\imirror\imirror.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    imirror.h

Abstract:

    This is the include file for the IntelliMirror conversion DLL

Author:

    Sean Selitrennikoff - 4/5/98

Revision History:

--*/

//
//  These are the action codes for the file error report callback
//

#define COPY_ERROR_ACTION_CREATE_FILE   1
#define COPY_ERROR_ACTION_OPEN_DIR      2
#define COPY_ERROR_ACTION_CREATE_DIR    3
#define COPY_ERROR_ACTION_SETATTR       4
#define COPY_ERROR_ACTION_GETATTR       5
#define COPY_ERROR_ACTION_GETACL        6
#define COPY_ERROR_ACTION_SETACL        7
#define COPY_ERROR_ACTION_DELETE        8
#define COPY_ERROR_ACTION_ENUMERATE     9
#define COPY_ERROR_ACTION_MALLOC       10
#define COPY_ERROR_ACTION_SETTIME      11
#define COPY_ERROR_ACTION_GETSFN       12
#define COPY_ERROR_ACTION_SETSFN       13


//
// Basic To Do items
//
typedef enum _IMIRROR_TODO {
    IMirrorNone,
    IMirrorInitialize,
    VerifySystemIsNt5,
    CheckPartitions,
    CopyPartitions,
    CopyFiles,
    CopyRegistry,
    PatchDSEntries,
    RebootSystem
} IMIRROR_TODO, *PIMIRROR_TODO;

//
// Client call back function definitions
//
typedef
NTSTATUS
(*IMIRROR_ERROR_CALLBACK)(
    IN PVOID Context,
    IN NTSTATUS Status,
    IN IMIRROR_TODO IMirrorFunctionId
    );

typedef
NTSTATUS
(*IMIRROR_NOWDOING_CALLBACK)(
    IN PVOID Context,
    IN IMIRROR_TODO Function,
    IN PWSTR String
    );

typedef
NTSTATUS
(*IMIRROR_GETMIRRORDIR_CALLBACK)(
    IN PVOID Context,
    OUT PWSTR Server,
    IN OUT PULONG Length
    );

typedef
NTSTATUS
(*IMIRROR_GETSETUP_CALLBACK)(
    IN PVOID Context,
    IN PWSTR Server,
    OUT PWSTR SetupPath,
    IN OUT PULONG Length
    );

typedef
NTSTATUS
(*IMIRROR_SETSYSTEM_CALLBACK)(
    IN PVOID Context,
    IN PWSTR SystemPath,
    IN ULONG Length
    );

typedef
NTSTATUS
(*IMIRROR_FILECREATE_CALLBACK)(
    IN PVOID Context,
    IN PWSTR FileName,
    IN ULONG FileAction,
    IN ULONG Status
    );

typedef
NTSTATUS
(*IMIRROR_REGSAVE_CALLBACK)(
    IN PVOID Context,
    IN PWSTR Name,
    IN ULONG Status
    );

typedef
NTSTATUS
(*IMIRROR_REINIT_CALLBACK)(
    IN PVOID Context
    );

typedef
NTSTATUS
(*IMIRROR_ADDTODO_CALLBACK)(
    IN PVOID Context,
    IN IMIRROR_TODO Function,
    IN PWSTR String,
    IN ULONG Length
    );

typedef
NTSTATUS
(*IMIRROR_REBOOT_CALLBACK)(
    IN PVOID Context
    );

typedef
NTSTATUS
(*IMIRROR_REMOVETODO_CALLBACK)(
    IN PVOID Context,
    IN IMIRROR_TODO Function,
    IN PWSTR String,
    IN ULONG Length
    );

typedef struct _IMIRROR_CALLBACK {
    PVOID Context;
    IMIRROR_ERROR_CALLBACK ErrorFn;
    IMIRROR_NOWDOING_CALLBACK NowDoingFn;
    IMIRROR_GETSETUP_CALLBACK GetSetupFn;
    IMIRROR_FILECREATE_CALLBACK FileCreateFn;
    IMIRROR_REGSAVE_CALLBACK RegSaveErrorFn;
    IMIRROR_REINIT_CALLBACK ReinitFn;
    IMIRROR_GETMIRRORDIR_CALLBACK GetMirrorDirFn;
    IMIRROR_SETSYSTEM_CALLBACK SetSystemDirFn;
    IMIRROR_ADDTODO_CALLBACK AddToDoFn;
    IMIRROR_REMOVETODO_CALLBACK RemoveToDoFn;
    IMIRROR_REBOOT_CALLBACK RebootFn;
} IMIRROR_CALLBACK, *PIMIRROR_CALLBACK;

extern IMIRROR_CALLBACK Callbacks;

//
// Dll entry point
//
DWORD
IMirrorInitDll(
    IN HINSTANCE hInst,
    IN DWORD Reason,
    IN PVOID Context
    );

VOID
IMirrorInitCallback(
    IN PIMIRROR_CALLBACK Callbacks
    );

NTSTATUS
ProcessToDoItems(
    VOID
    );

NTSTATUS
InitToDo(
    VOID
    );

VOID
ClearAllToDoItems(
    IN BOOLEAN MemoryOnly
    );

NTSTATUS
SaveAllToDoItems(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\smc9432\lm9432.asm ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       LM9432.ASM    (C) Copyright 1995 Standard Microsystems Corp.
;                       All rights reserved.
;
;*                Contains confidential information and                     *
;*                     trade secrets proprietary to:                        *
;*                                                                          *
;*                  Standard MicroSystems Corporation                       *
;*                            6 Hughes	  
;*                           Irvine, CA                                     *
;
;       LMI lower routine assembly source file for 
;       Ethernet 9432 PCI adapter.
;
;$History: LM9432.ASM $
; 
; *****************  Version 1  *****************
; User: Paul Cowan   Date: 26/08/98   Time: 9:31a
; Created in $/Client Boot/NICS/SMC/9432/UNDI
;
;
;$NoKeywords: $
;
;       Author: najay
;	Date: 2/14/95
;
; By         Date     Ver.   Modification Description
; ------------------- -----  --------------------------------------
;
; Revision Log:
; $Log:   G:\sweng\src\lm9432\vcs\lm9432.avm  $
;  
;     Rev 1.79   24 Nov 1997 16:48:40   cosand
;  Changed init_etx_threshold to use the current tx descriptor rather than
;  making the first tx descriptor point to itself.  This fixes a problem with
;  LM_Send failing when check_bnc_port is called before init_etx_threshold
;  is called.
;  Changed epic_auto_detect to set line_speed to LINE_SPEED_10 when BNC is
;  being used.
;  Modified check_bnc_port to make it work when CODE_386 is defined.
;  
;     Rev 1.78   06 Nov 1997 13:49:54   cosand
;  Modified init_mii_registers, epic_auto_detect, and LM_Service_Events,
;  and added handle_phy_event and check_bnc_port to support the 9432BTX.
;  
;     Rev 1.77   11 Sep 1997 13:41:06   cosand
;  Added the routines init_tdk_phy and Ronnie Kunin's
;  read_phy_OUI, modified init_mii_registers and
;  handle_nway_complete to support the TDK 2120 PHY.
;  
;     Rev 1.76   05 Aug 1997 12:23:12   cosand
;  Changed all writes to the General Control and Non-Volatile Control
;  registers from 16 bits to 32 bits to avoid enabling unwanted features
;  in Epic XF.
;  
;     Rev 1.75   07 Jul 1997 18:54:08   cosand
;  In init_mii_registers added a delay which is executed when the SCRAMBLE
;  bit is set in adapter_flags1.  This delay allows the ScrambleOn keyword
;  to work reliably with the Synoptics Switch Model 28115 (Bay Networks Design).
;  
;     Rev 1.74   28 Mar 1997 13:47:24   ANDERS
;  In init_etx_idle backed out code that cleared transmit interrupt
;  status bits.  Since init_etx_idle is called by other parts of the 
;  LMAC besides init_etx_threshold, this change had caused the DOS ODI
;  driver to lose a transmit interrupt.
;  
;     Rev 1.73   27 Mar 1997 11:29:44   ANDERS
;  Test SCRAMBLE bit in AdapterStructure variable "adapter_flags1" &
;  if set execute scramble code.  Default is to NOT execute this code.
;  This applies to both the init_mii_registers & handle_nway_complete
;  routines.
;  The init_tx_queues routine will now check the EARLY_TX bit in the
;  "adapter_flags" variable of the AdapterStructure & only enable Early
;  Transmit if this bit is set.  This is for the EarlyTxOff keyword support.
;  In init_nic routine, output value from AdapterStructure variable "burstlen"
;  to EPC_PBLCNT (18h).  Default is 0, but may be changed by BurstLength
;  keyword.
;  In the same routine, test AdapterStructure variable "adapter_flags1" for
;  the READ_MULT bit being set & if set, set the GC_RD_MULT bit in the
;  "gen_cntl" variable of the AdapterStructure.  This later gets loaded to
;  the EPC_GEN_CONTROL register (0ch).
;  The init_etx_threshold routine has be restored to its original algorithem,
;  using 16 as the default threshold value.  In the init_etx_idle routine
;  clear transmit interrupt status bits before returning
;  
;     Rev 1.73   26 Mar 1997 15:06:16   ANDERS
;  Scramble code will not be executed unless SCRAMBLE bit in "adapter_flags"
;  is set.
;  Early transmit will not be enabled unless EARLY_TX in "adapter_flags" is set.
;  The register EPC_PBLCNT will loaded from the  "burstlen" adapterstructure
;  variable which is set by the UMAC.
;  
;     Rev 1.72   10 Mar 1997 11:29:10   cosand
;  Changed init_mii_registers and handle_nway_complete to toggle the
;  Scramble Disable bit in Mercury register 31.  This is a software
;  workaround for a bug in the Mercury PHY in which the 9432TX can't
;  receive data when it is connected to a Bay Networks Baystack 100.
;  
;     Rev 1.71   04 Mar 1997 15:55:00   ANDERS
;  If DEFed out call to LM_Enable_Adpater in LM_Initialize_Adpater routine if
;  CODE_386 is defined.  Instead return rax=SUCCESS to fix bug found in DOS
;  Client32 where interrupts were enabled before interrupt vector was set.
;  In init_etx_threshold routine load EPC_XMIT_COPY_THRESH register with a
;  default of 40 (was 16), the exit without doing Early Transmit adjustment
;  as this routine wasn't working (stop-gap fix to release 32 bit odi driver)
;  
;     Rev 1.70   26 Feb 1997 17:26:20   cosand
;  Changed init_mii_registers to make the PHY drop link before forcing
;  it to a particular speed.  If we are connected to an nway device,
;  this will cause it to renegotiate.  Changed init_nic to not enable
;  the GP2 interrupt when Auto-Negotiation is off.  
;  
;     Rev 1.69   20 Feb 1997 14:59:58   ANDERS
;  Changed all CX register references used in any type of "loop" or
;  "dec" counter to RCX macro that defines CX to be 16 bits or 32 bits
;  depending on if CODE_386 is defined for the conditional assembly
;  
;     Rev 1.68   14 Feb 1997 18:46:08   cosand
;  Changed init_mii_registers to write a zero (was 2000h) to the PHY Basic
;  Mode Control Register before enabling nway to prevent the Mercury PHY
;  from sending runt packets on a 10Mbps network during initialization.
;  
;     Rev 1.67   05 Feb 1997 11:57:12   ANDERS
;  In LMSTRUCT.inc set default value of 9432 General Control register
;  to 0410h (was 0010h) to enable transmit DMA PCI "memory read multiple"
;  command.
;  
;     Rev 1.66   24 Jan 1997 18:19:34   cosand
;  Changed init_tx_queues and init_tx_threshold to correctly restore the
;  loopback mode select bits of the transmit control register.  This fixes a
;  bug in which init_tx_threshold was always switching the Epic out of full
;  duplex mode.
;  Removed all references to mode_bits, it is not being used by any umacs.
;  
;     Rev 1.65   22 Jan 1997 11:44:34   cosand
;  Changed version string.
;  
;     Rev 1.64   20 Jan 1997 17:26:10   cosand
;  Changed init_mii_registers to turn off bit 1 in Mercury PHY register 27
;  to improve long cable length performance.  Changed the PHY reset delay
;  counters in init_mii_registers from 80 to 80h.
;  
;     Rev 1.63   08 Jan 1997 19:14:46   cosand
;  Changed init_nic to enable the GP2 interrupt.
;  Changed init_mii_registers to enable the autonegotiation complete
;  interrupt in the Mercury PHY when MEDIA_TYPE_AUTO_NEGOTIATE is set
;  in media_type2.
;  Added the function handle_nway_complete.
;  Changed LM_Service_Events to call handle_nway_complete when a GP2
;  interrupt occurs.
;  Added a delay to init_mii_registers between resetting the PHY and
;  the first write to a PHY register to fix a problem with the Mercury
;  PHY not initializing properly in a Pentium Pro 200.
;  
;     Rev 1.62   31 Oct 1996 15:58:08   cosand
;  Added a hardware reset delay for the QSI 6612 to init_mii_registers.
;  
;     Rev 1.61   23 Aug 1996 09:34:12   ANDERS
;  update vers string to 1.26
;  in "init_nic" & "lm_service_events" when referencing int_mask changed
;  reg ax to eax because int reg definitions for XE chip use bits 23-27
;  
;     Rev 1.61   21 Aug 1996 14:13:06   COOKE_J
;  Updated LMAC version string to 1.26
;  
;     Rev 1.60   24 Jul 1996 11:53:18   STEIGER
;  Updated LMAC version string to 1.25.
;  
;     Rev 1.59   28 Jun 1996 16:08:32   STEIGER
;  Changed several loop counts in cx to rcx to fix perceived lockup and
;  slow loading problems.
;  
;     Rev 1.58   12 Jun 1996 17:17:46   NAJARIAN
;  fixed fragment-list issues
;  
;     Rev 1.56   14 Feb 1996 15:07:30   NAJARIAN
;  fixed cardbus OLD_MII problem
;  
;     Rev 1.55   14 Feb 1996 13:35:36   NAJARIAN
;  fixed cardbus (OLD_MII) build
;  
;     Rev 1.54   13 Feb 1996 11:12:34   NAJARIAN
;  fixed early_rx bug which posted invalid packet lengths
;  
;     Rev 1.53   09 Feb 1996 11:17:58   NAJARIAN
;  fixed txugo code
;  
;     Rev 1.52   08 Feb 1996 17:19:36   NAJARIAN
;  added ENABLE_TX_PENDING no enabled fixes
;  
;     Rev 1.51   29 Jan 1996 15:00:20   NAJARIAN
;  added workaround for 'no erx on offset' hardware issue
;  
;     Rev 1.50   26 Jan 1996 09:50:14   NAJARIAN
;  reordered two lines in LM_Receive_Copy
;  
;     Rev 1.49   25 Jan 1996 16:29:18   NAJARIAN
;  fixed pending code in lm_receive_copy
;  
;     Rev 1.48   23 Jan 1996 16:03:58   NAJARIAN
;  removed extraneous tx_retry variable
;  
;     Rev 1.47   23 Jan 1996 15:46:00   NAJARIAN
;  fixed jump polarity problem in init_etx_threshold
;  
;     Rev 1.0   23 Jan 1996 15:44:46   NAJARIAN
;  Initial revision.
;  
;     Rev 1.46   23 Jan 1996 13:36:10   NAJARIAN
;  added early transmit preinitialization code
;  
;     Rev 1.45   19 Jan 1996 18:21:04   NAJARIAN
;  fixed receive routing algorithm
;  
;     Rev 1.44   18 Jan 1996 15:16:52   NAJARIAN
;  fixed push/pop sync problem in Open_Adapter with FREEBUF set
;  
;     Rev 1.43   18 Jan 1996 12:20:58   NAJARIAN
;  fixed packet size required code. The PACKET_SIZE_NOT_NEEDED declaration has 
;  removed from the LMAC. Not setting ENABLE_EARLY_RX will accomplish the same
;  functionality.
;  
;     Rev 1.42   17 Jan 1996 10:15:58   NAJARIAN
;  checked in the correct code this time.
;  
;     Rev 1.40   11 Jan 1996 11:01:50   NAJARIAN
;  fixed PKT_SIZE_NOT_NEEDED bug in LM_Service_Events. rbx was being
;  overwritten.
;  
;     Rev 1.39   05 Jan 1996 10:51:58   NAJARIAN
;  updated internal version number
;  
;     Rev 1.38   05 Jan 1996 10:44:22   NAJARIAN
;  added check on receive to route header copies and lm_receive_copy copies
;  
;     Rev 1.37   29 Dec 1995 13:54:52   ANDERSON
;  fixed lookahead version of lmse_receive_copy to correct packet status in bx.
;  
;     Rev 1.36   28 Dec 1995 11:49:22   NAJARIAN
;  fixed HARDWARE_FAILED return code in LM_Receive_Copy
;  
;     Rev 1.35   26 Dec 1995 10:58:10   CHAN_M
;  Added bounds to the wait for idle loops in LM_Close_Adapter.
;  
;     Rev 1.34   22 Dec 1995 21:56:28   CHAN_M
;  Added poll loops in LM_Close_Adapter to wait for EPIC to go idle. Without
;  these loops, resetting the epic after calling LM_Close_Adapter may lock up
;  the bus.
;  
;     Rev 1.33   21 Dec 1995 16:15:20   NAJARIAN
;  fixed lm_delete_group_address dup entry
;  
;     Rev 1.32   21 Dec 1995 16:14:00   NAJARIAN
;  fixed checkmultiadd endp typo
;  
;     Rev 1.31   21 Dec 1995 15:47:02   NAJARIAN
;  added HW_RX_FAILED return codes
;  
;     Rev 1.30   19 Dec 1995 10:56:08   NAJARIAN
;  added support for DOS ODI free buffer pool
;  added working tx underrun adjustment logic
;  added checks for rx lockup
;  added check for rxqueue not being set right (nextframe without rxqueue)
;  added several checks for bad status before calling the umac on receives
;  
;     Rev 1.29   09 Nov 1995 11:40:06   CHAN_M
;  Initialized pAS.num_rx_free_buffs to 0 in init_rx_queues.
;  
;     Rev 1.28   08 Nov 1995 16:16:00   NAJARIAN
;  added transmit retry logic
;  
;     Rev 1.27   07 Nov 1995 10:59:20   NAJARIAN
;  rearranged interrupt handling priority, fixed way TXUGO is handled
;  synchronized C and assembly code
;  
;     Rev 1.26   03 Nov 1995 15:24:24   NAJARIAN
;  fixed EVENTS_DISABLE bug in receive interrupt handler.
;  
;     Rev 1.25   19 Oct 1995 12:27:14   ANDERSON
;  fixed getver string to LM_9432_s2.2_v1.12.
; Change: fixed getver string to LM_9432_s2.2_v1.12.
;  
;     Rev 1.24   19 Oct 1995 11:21:12   NAJARIAN
;  fixed backoff timer initialization bug
;  
;     Rev 1.23   02 Oct 1995 19:24:42   NAJARIAN
;  fixed receive status posting stuff in lm_service_events
;  
;     Rev 1.22   02 Oct 1995 18:37:12   NAJARIAN
;  reordered code
;  
;     Rev 1.21   02 Oct 1995 18:17:26   NAJARIAN
;  fixed header copy problem
;  
;     Rev 1.20   02 Oct 1995 18:00:28   NAJARIAN
;  fixed ipxload lockup/data miscompare problem. Fixed Tx pending/Packetsize
;  0 problems.
;  
;     Rev 1.19   27 Sep 1995 10:01:34   NAJARIAN
;  fixed ENABLE_TX_PENDING and call_umac labels
;  
;     Rev 1.18   25 Sep 1995 14:46:56   NAJARIAN
;  fixed wait polarity on lm_send. Removed EZSTART stuff
;  
;     Rev 1.17   25 Sep 1995 14:33:20   NAJARIAN
;  added PKT_SIZE_NOT_NEEDED support. added ENABLE_TX_PENDING support. made
;  minor editing changes.
;  
;     Rev 1.16   19 Sep 1995 16:38:20   NAJARIAN
;  fixed version string
;  
;     Rev 1.15   18 Sep 1995 14:59:26   NAJARIAN
;  added sweng doc compliant function headers. Fixed bug in LM_Add_Multi_Addr
;  that would prevent multicast address from being added correctly.
;  
;     Rev 1.14   08 Sep 1995 15:34:32   CHAN_M
;  Fixed bug in initializing MII port
;  Fixed RX OVW processing
;  
;     Rev 1.13   29 Aug 1995 18:26:58   CHAN_M
;  Fixed bug in receiving multicast frames.
;  
;     Rev 1.12   29 Aug 1995 17:36:18   CHAN_M
;  Changed physical layer chip addr. to 3 for new boards.
;  Added support for MII port and auto detection between the 2 ports.
;  Added media_type2 and line_speed in lmstruct.inc
;  DMA complete is always checked once even if ENABLE_RX_PENDING is not on.
;  Made the IO loop for RX DMA complete less tight to allow DMA to proceed.
;  Added check for available TX descriptors before performing transmit.
;  Added optional code for transmit with double copy for performance evaluation.
;  
;     Rev 1.11   07 Aug 1995 16:52:50   NAJARIAN
;  added delay in init_nic
;  
;     Rev 1.10   28 Jul 1995 14:25:22   CHAN_M
;  Fixed bug in LM_Change_Receive_Mask reported by Fred K.
;  Reimplemented NWAY for the new boards.
;  
;     Rev 1.9   24 Jul 1995 13:38:58   CHAN_M
;  added error counters.
;  
;     Rev 1.8   20 Jul 1995 11:36:26   CHAN_M
;  1. Took out workaround code for xmit.
;  2. Stopped rx before changing receive control reg.
;  3. Fixed send complete logic to process all outstanding xmit frames during
;  xmit complete interrupt.
;  
;     Rev 1.7   17 Jul 1995 20:11:38   CHAN_M
;  1. Implemented Free Buffer Pool receive mechanism.
;  2. Implemented NWAY for National DP83840 PHY chip.
;  3. Implemented mechanism to set IAF when the transmit q is almost full.
;  
;     Rev 1.6   19 Jun 1995 17:34:48   CHAN_M
;  The tx_curr_off pointer (the last completed tx packet in the chain) is saved
;  before calling UM_Send_Complete.
;  Fixed the problem of q'ing the next receive descriptor twice when
;  ENABLE_RX_PENDING is not turned on.
;  
;     Rev 1.5   05 Jun 1995 16:17:06   CHAN_M
;  Unmasked Transmit Chain Complete in Interrupt Mask register.
;  Added check for NW_STATUS_VALID in Rx Status before checking CRC & FAE error
;  bits.
;  
;     Rev 1.4   05 Jun 1995 16:03:44   STEIGER
;  Set save errored packets bit in RX config register when early rx is enabled.
;  Added code to set appropriate status in AX on call to UM_Receive_Copy_Complete.
;  
;     Rev 1.3   05 Jun 1995 15:10:00   STEIGER
;  Fixed double instances of INT_RCV_ERR constant.
;  
;     Rev 1.2   17 May 1995 15:19:14   NAJARIAN
;  added 386 support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

IFDEF DEBUG
db              '@(#) LM_9432_s3.01_x1.44',0,'$'
ELSE
db              '@(#) LM_9432_s3.01_v1.44',0,'$'
ENDIF

DEBUG_ADDR      equ     0ec99h
;OLD_MII		equ	0
;DOUBLE_COPY_TX	equ	0

ETX_CUTOFF	equ	500
ETX_MAX_THRESH	equ	1518

;****************************************************************************
;
; Function:     Debug_Call
;
; Synopis:      Cause a software debugger to breakpoint
;
; Input:        None
;
; Output:       None
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

public Debug_call
Debug_call      proc    far
		push    dx
		push    ax
		mov     dx, DEBUG_ADDR
		in      al, dx
		pop     ax
		pop     dx
		int 3
		iret
Debug_call      endp

;****************************************************************************
;
; Function:     LM_Add_Multi_Address    
;
; Synopis:      Adds Multicast address in adapter structure to
;               Multicast address table.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    LM_Add_Multi_Address

		push    edi
		push    esi
		push    ecx
		push    ebx
		PUSH_ES
		cld

		mov     rax, SUCCESS             ; Preset return code

ifndef CODE_386
		push    ds
		pop     es                      ; ES = DS
endif
		lea     rdi, pAS.mc_table
		mov     rcx, MC_TABLE_ENTRIES    ; CL == max number of
						; entries in table

AroundTheWorld:
		lea     rsi, pAS.multi_address
		push    edi
		push    ecx
		mov     rcx, 3
		repz    cmpsw
		pop     ecx
		pop     edi
		jnz     DoYerNeighbor
		cmp     byte ptr [rdi+6], 0ffh  ; If instance count >= 0ffh,
						; entry is maxed out.
		je      McTableFull
		inc     byte ptr [rdi+6]        ; Increment instance_count
		jmp     AddMultiDone            ; All Done

DoYerNeighbor:  
		add     rdi, 7                  ; Point to next address
		loop    AroundTheWorld          ; Check all addresses.
						; No match found, find
						; first empty table entry
		mov     rcx, MC_TABLE_ENTRIES    ; and insert address there
		lea     rdi, pAS.mc_table

CheckForEmpty:
		mov     bl, [rdi+6]              ; Check instance count for
		cmp     bl, 0                   ; this address.
		je      add_address             ; If instance count == 0
						; copy address to this space.
		add     rdi, 7                   ; Point to next address
		loop    CheckForEmpty           ; Loop for all entries.
		jmp     McTableFull             ; If no empty entries, bail out

add_address:    lea     rsi, pAS.multi_address
		mov     rcx, 3
		rep     movsw
		inc     byte ptr [rdi]           ; Increment instance_count
		jmp     AddMultiDone

McTableFull:    mov     rax, OUT_OF_RESOURCES

AddMultiDone:
		POP_ES
		pop     ebx
		pop     ecx
		pop     esi
		pop     edi

		ret

ASM_PCI_PROC_END        LM_Add_Multi_Address


;****************************************************************************
;
; Function:     set_CAM_registers	
;
; Synopis:      set the receive control registers from
;				the receive mask values
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

set_CAM_registers proc near
		push	dx

		mov	dx, pAS.io_base
		add	dx, EPC_MC_HASH_TABLE1

; delete for initial testing
		test	pAS.receive_mask, ACCEPT_MULTI_PROM
;		jz	no_multiprom

; set all multi bits to one
		mov	ax, 0ffffh
		out	dx, ax
		add	dx, EPC_MC_HASH_TABLE2 - EPC_MC_HASH_TABLE1
		out	dx, ax
		add	dx, EPC_MC_HASH_TABLE3 - EPC_MC_HASH_TABLE2
		out	dx, ax
		add	dx, EPC_MC_HASH_TABLE4 - EPC_MC_HASH_TABLE3
		out	dx, ax
			
set_CAM_done:
		pop	dx
		ret

no_multiprom:
		jmp	set_CAM_done

set_CAM_registers endp

;****************************************************************************
;
; Function:     set_receive_mask	
;
; Synopis:      set the receive control registers from
;		the receive mask values
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

set_receive_mask proc	near
		push	dx

		mov	dx, pAS.io_base
		add	dx, EPC_RECEIVE_CONTROL
		
		mov	ax, 0
		test	pAS.receive_mask, ACCEPT_MULTICAST or ACCEPT_MULTI_PROM
		jz	itx_nomulticast
		or	ax, RC_RCV_MULTICAST

itx_nomulticast:
		test	pAS.receive_mask, ACCEPT_BROADCAST
		jz	itx_nobroadcast
		or	ax, RC_RCV_BROADCAST

itx_nobroadcast:
		test	pAS.receive_mask, PROMISCUOUS_MODE
		jz	itx_nopromiscuous
		or	ax, RC_PROMISCUOUS_MODE

itx_nopromiscuous:
		test	pAS.receive_mask, ACCEPT_ERR_PACKETS
		jz	itx_noerrors
		or	ax, RC_RCV_ERRORED or RC_RCV_RUNT

itx_noerrors:
		test	pAS.receive_mask, EARLY_RX_ENABLE
		jz	itx_noerx
		or	ax, RC_EARLY_RECEIVE_ENABLE or RC_RCV_ERRORED

itx_noerx:
		out	dx, ax

; set receive lookahead size
		add	dx, EPC_RCV_COPY_THRESH - EPC_RECEIVE_CONTROL
		movzx	ax, pAS.rx_lookahead_size
		shl	ax, 4				; 16 byte increment
		out	dx, ax

		call	set_CAM_registers

		pop	dx
		ret

set_receive_mask endp

;****************************************************************************
;
; Function:     LM_Change_Receive_Mask
;
; Synopis:      Change the EPIC/100 receive configuration
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    LM_Change_Receive_Mask

		mov	ax, pAS.adapter_status
		cmp     ax, NOT_INITIALIZED
		jne     LM_Ch_Stat_ok
		mov     rax, ADAPTER_NOT_INITIALIZED
		jmp     LM_Ch_Msk_Done

LM_Ch_Stat_ok:
		cmp	ax, OPEN
		jnz	LM_Ch_rx_disabled

		push	dx
		push	rcx
IFNDEF CODE_386
		push	eax
ENDIF

; wait for rx idle first
		mov	dx, pAS.io_base
		mov	ax, CMD_STOP_RDMA or CMD_STOP_RX
		out	dx, ax
		add	dx, EPC_INT_STATUS

		mov	rcx, 800h

LM_Ch_wait_for_idle:
		dec	rcx
		jz	LM_Ch_Msk_failed
		push	rcx
		mov	rcx, 80h
		loop	$
		pop	rcx
		in	eax, dx
		test	eax, INT_RCV_IDLE
		jz	LM_Ch_wait_for_idle

IFNDEF CODE_386
		pop	eax
ENDIF
		pop	rcx
		pop	dx

LM_Ch_rx_disabled:
		call	set_receive_mask

LM_Ch_Msk_Done:
		cmp	pAS.adapter_status, OPEN
		jnz	LM_Ch_Msk_ret

		push	dx
		mov	dx, pAS.io_base
		mov	ax, CMD_START_RX or CMD_RXQUEUED
		out	dx, ax
		pop	dx
LM_Ch_Msk_ret:
		mov     rax, SUCCESS
		ret

LM_Ch_Msk_failed:
IFNDEF CODE_386
		pop	eax
ENDIF
		pop	rcx
		pop	dx
		
		mov	rax, HARDWARE_FAILED
		ret

ASM_PCI_PROC_END        LM_Change_Receive_Mask


;****************************************************************************
;
; Function:     LM_Close_Adapter        
;
; Synopis:      Closes adapter whose adapter structure is
;               indicated by DS:BP.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    LM_Close_Adapter

		cmp     pAS.adapter_status, NOT_INITIALIZED
		jne     StatusOK
		mov     rax, ADAPTER_NOT_INITIALIZED
		jmp     NoStatusChange
					
StatusOK:
		call	LM_Disable_Adapter

		mov	dx, pAS.io_base
		add	dx, EPC_COMMAND
		mov	ax, CMD_STOP_RX or CMD_STOP_TDMA or CMD_STOP_RDMA
		out	dx, ax

		add	dx, EPC_INT_STATUS - EPC_COMMAND
IFNDEF CODE_386
		push	eax
ENDIF
		push	ecx
		mov	rcx, 1000h
lmc_wait_rx_idle:
		dec	rcx
		jz	lmc_start_wait_tx_idle
		in	ax, 61h
		in	ax, 61h
		in	eax, dx
		test	eax, INT_RCV_IDLE
		jz	lmc_wait_rx_idle

lmc_start_wait_tx_idle:
		mov	rcx, 1000h
lmc_wait_tx_idle:
		dec	rcx
		jz	lmc_tx_idle
		in	ax, 61h
		in	ax, 61h
		in	eax, dx
		test	eax, INT_XMIT_IDLE
		jz	lmc_wait_tx_idle

lmc_tx_idle:
		pop	ecx
IFNDEF CODE_386
		pop	eax
ENDIF

		mov	ax, 0ffffh
		out	dx, ax

		mov     pAS.adapter_status, CLOSED
		call    UM_Status_Change
		mov     rax, SUCCESS             ; Set return code
NoStatusChange:
		ret

ASM_PCI_PROC_END        LM_Close_Adapter

;****************************************************************************
;
; Function:     LM_Delete_Group_Address 
;
; Synopis:      returns INVALID_FUNCTION for Ethernet.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    LM_Delete_Group_Address

		mov     rax, INVALID_FUNCTION
		ret
ASM_PCI_PROC_END        LM_Delete_Group_Address


;****************************************************************************
;
; Function:     LM_Delete_Multi_Address 
;
; Synopis:      Removes Multicast address in adapter
;               structure from Multicast address table.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    LM_Delete_Multi_Address

		push    ecx
		push    edi
		push    esi
		PUSH_ES
		cld

		mov     rax, SUCCESS             ; Preset return code

ifndef CODE_386
		push    ds
		pop     es                      ; ES = DS
endif

		lea     rdi, pAS.mc_table
		mov     rcx, MC_TABLE_ENTRIES

FrootLoop:      lea     rsi, pAS.multi_address
		push    edi
		push    ecx
		mov     rcx, 3
		repz    cmpsw
		pop     ecx
		pop     edi
		jnz     TryNextDoor
		cmp     byte ptr [rdi+6], 0h    ; If instance count = 0h,
						; entry is alrady gone.
		je      McTableEmpty
		dec     byte ptr [rdi+6]        ; Decrement instance_count
		jmp     DeleteMultiDone         ; All Done

TryNextDoor:    add     rdi, 7                   ; Point to next address
		loop    FrootLoop               ; Check all addresses
						; If all entries checked and
						; no matches, bail out.

McTableEmpty:   mov     rax, OUT_OF_RESOURCES

DeleteMultiDone:
		POP_ES
		pop     esi
		pop     edi
		pop     ecx
		ret

ASM_PCI_PROC_END        LM_Delete_Multi_Address

;****************************************************************************
;
; Function:     LM_Disable_Adapter
;
; Synopis:      Disables adapter whose adapter structure is
;               indicated by DS:BP.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    LM_Disable_Adapter
                push    eax
		push	dx
		mov	dx, pAS.io_base
		add	dx, EPC_GEN_CONTROL
		mov	eax, pAS.gen_cntl
		and	eax, NOT GC_INT_ENABLE
		out	dx, eax
		pop	dx
                pop     eax

		mov     rax, SUCCESS
		or      pAS.adapter_flags, ADAPTER_DISABLED
		ret

ASM_PCI_PROC_END        LM_Disable_Adapter

;****************************************************************************
;
; Function:     LM_Enable_Adapter
;
; Synopis:      Enables adapter whose adapter structure is
;		                  indicated by DS:BP.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    LM_Enable_Adapter
                push    eax
		push	dx
		mov	dx, pAS.io_base
		add	dx, EPC_GEN_CONTROL
		mov	eax, pAS.gen_cntl
		or	eax, GC_INT_ENABLE
		out	dx, eax
		pop	dx
                pop     eax

		mov     rax, SUCCESS
		and     pAS.adapter_flags, not ADAPTER_DISABLED
		ret

ASM_PCI_PROC_END        LM_Enable_Adapter

;****************************************************************************
;
; Function:     LM_Get_Host_Ram_Size       
;
; Synopis:      Returns the size of Host Ram to allocate
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

IFDEF FREEBUFF
ASM_PCI_PROC		LM_Get_Host_Ram_Size
	push	cx
	push	dx
	mov	cx, pAS.num_of_tx_buffs
	add	cx, pAS.num_of_rx_buffs
	mov	ax, SIZE DMA_FRAG
	add	ax, DMA_FRAG_SIZE
	mul	cx

IFDEF DOUBLE_COPY_TX
	push	ax
	mov	ax, 1520
	sub	ax, DMA_FRAG_SIZE
	mov	cx, pAS.num_of_tx_buffs
	mul	cx
	mov	cx, ax
	pop	ax
	add	ax, cx
ENDIF
	pop	dx
	pop	cx
	ret
ASM_PCI_PROC_END	LM_Get_Host_Ram_Size
ENDIF


;****************************************************************************
;
; Function:     reset_nic       
;
; Synopis:      Resets the NIC on the adapter whose adapter structure
;                       is indicated by DS:BP.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

reset_nic       proc    near
		push	dx
		mov	dx, pAS.io_base
		add	dx, EPC_GEN_CONTROL
		mov	eax, GC_SOFT_RESET
		out	dx, eax

; delay for ~ 1 us
; EPIC needs at least 15 internal clocks after initialization before
; it can be accessed. This is intel specific - it needs to be modified for
; the target OS
		in	al, 061h
		in	al, 061h
		in	al, 061h
		in	al, 061h
		in	al, 061h

		add	dx, EPC_TEST - EPC_GEN_CONTROL
		mov	ax, TEST_CLOCK
		out	dx, ax
		pop	dx
		ret

reset_nic       endp

;****************************************************************************
;
; Function:     init_tx_queues
;
; Synopis:      Initialize the transmit queues on the NIC
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

init_tx_queues  proc    near
		PUSH_ES
		push	eax
		push	ebx
		push	ecx
		push	edx
		push	esi
		push	edi

; initialize tx host memory
		mov	rbx, RWORD ptr pAS.host_ram_virt_addr	
		mov	edx, pAS.host_ram_phy_addr
		mov	rsi, rbx
		mov	pAS.tx_first_off, rbx
		mov	pAS.tx_curr_off, rbx
		movzx	ecx, pAS.num_of_tx_buffs
		mov	pAS.tx_free_desc_count, cx

init_txdma:
		mov	dword ptr [rbx].dma_status, 0
		mov	dword ptr [rbx].dma_buf_len, 0
		add	edx, size DMA_FRAG
		add	rsi, size DMA_FRAG
		mov	[rbx].dma_next_phys, edx
		mov	[rbx].dma_next_off, rsi
		add	rbx, size DMA_FRAG
		loop	init_txdma

; fix up loop
		sub	rbx, size DMA_FRAG
		mov	eax, pAS.host_ram_phy_addr
		mov	[rbx].dma_next_phys, eax
		mov	rax, RWORD ptr pAS.host_ram_virt_addr
		mov	[rbx].dma_next_off, rax

; init frag lists
		mov	rbx, RWORD ptr pAS.host_ram_virt_addr	
		mov	rdi, rbx 			; get txdma offset
		mov	edx, pAS.host_ram_phy_addr
		mov	eax, size DMA_FRAG
		xor	ecx, ecx
		mov	cx, pAS.num_of_tx_buffs
		add	cx, pAS.num_of_rx_buffs
		push	edx
		mul	ecx
		pop	edx

		add	rbx, rax
		add	edx, eax
		movzx	ecx, pAS.num_of_tx_buffs

tx_fraglist_loop:
		mov	dword ptr [rbx].fragment_count, 0
		mov	[rdi].dma_buf_addr, edx
		mov	[rdi].dma_buff_off, rbx
IFDEF DOUBLE_COPY_TX
		add	rbx, 1520
		add	edx, 1520
ELSE
		add	rbx, DMA_FRAG_SIZE
		add	edx, DMA_FRAG_SIZE
ENDIF
		add	rdi, size DMA_FRAG
		loop	tx_fraglist_loop

; initialize tx epic regs 		
		mov	dx, pAS.io_base
		add	dx, EPC_TRANSMIT_CONTROL				
		mov	bx, pAS.slot_timer		; slot timer
		shl	bx, 3
		mov	ax, bx
                test    pAS.line_speed, LINE_SPEED_FULL_DUPLEX
                jz      init_tx_half_duplex
                or      ax, TC_FULL_DUPLEX
init_tx_half_duplex:
; flag in "adapter_flags" must be set by UMAC to enable "early transmit"
		test	pAS.adapter_flags, EARLY_TX
		jz	init_tx_no_e_tx
		or	ax, TC_EARLY_XMIT_ENABLE
init_tx_no_e_tx:
		out	dx, ax

; zero out retry count
		mov	pAS.tx_pend, 0

; set the start of tx desc area
		add	dx, EPC_XMIT_CURR_DESC_ADDR - EPC_TRANSMIT_CONTROL
		mov	eax, pAS.host_ram_phy_addr
		out	dx, eax

		pop	edi
		pop	esi
		pop	edx
		pop	ecx
		pop	ebx
		pop	eax
		POP_ES

		ret

init_tx_queues  endp

;****************************************************************************
;
; Function:     init_rx_queues   
;
; Synopis:      Initialize the receive queues on the NIC
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

init_rx_queues  proc    near
		PUSH_ES
		push	eax
		push	ebx
		push	ecx
		push	edx
		push	esi
		push	edi

; init recv host memory
		mov	rbx, RWORD ptr pAS.host_ram_virt_addr	
		mov	edx, pAS.host_ram_phy_addr
		mov	eax, SIZE DMA_FRAG
		movzx	ecx, pAS.num_of_tx_buffs
		push	edx
		mul	ecx
		pop	edx
		add	edx, eax
		add	rbx, rax
		push	edx		; save rx_dma phys addr
		push	rbx		; save rx_dma virtual addr
		mov	rsi, rbx
		mov	pAS.rx_curr_lookahead, rbx
		mov	pAS.rx_curr_fraglist, rbx
IFDEF	FREEBUFF
		mov	pAS.rx_last_fraglist, rbx
		mov	pAS.num_rx_free_buffs, 0
		mov	eax, XDMA_FRAGLIST
ELSE
		movzx	eax, pAS.rx_lookahead_size
		shl	eax, 4				; 16 byte increment
		or	eax, RDMA_HEADER
ENDIF
		movzx	ecx, pAS.num_of_rx_buffs

init_rxdma:
		mov	dword ptr [rbx].dma_status, 0
		mov	dword ptr [rbx].dma_buf_len, eax
		add	edx, size DMA_FRAG
		add	rsi, size DMA_FRAG
		mov	[rbx].dma_next_phys, edx
		mov	[rbx].dma_next_off, rsi
		add	rbx, size DMA_FRAG
		loop	init_rxdma

; fix up loop
		sub	rbx, size DMA_FRAG

		pop	rax			; pop rx_dma virtual addr
		mov	[rbx].dma_next_off, rax
		pop	eax			; pop rx_dma phys addr
		mov	[rbx].dma_next_phys, eax

; init frag lists
		push	eax				; save rx_dma phys addr
		mov	edx, eax			; rx_dma phys addr
		mov	rbx, pAS.rx_curr_fraglist	; rx_dma virtual addr
		mov	rdi, rbx

		mov	eax, size DMA_FRAG
		movzx	ecx, pAS.num_of_rx_buffs
		push	edx
		mul	ecx
		pop	edx
		add	edx, eax			; tx_frag phys addr
		add	rbx, rax			; tx_frag virt addr

IFDEF DOUBLE_COPY_TX
		mov	eax, 1520
ELSE
		mov	eax, DMA_FRAG_SIZE
ENDIF
		movzx	ecx, pAS.num_of_tx_buffs
		push	edx
		mul	ecx
		pop	edx
		add	edx, eax			; rx_frag phys addr
		add	rbx, rax			; rx_frag virt addr

		movzx	ecx, pAS.num_of_rx_buffs

fraglist_loop:
		mov	dword ptr [rbx].fragment_count, 0
		mov	[rdi].dma_buf_addr, edx
		mov	[rdi].dma_buff_off, rbx
		add	rbx, DMA_FRAG_SIZE
		add	edx, DMA_FRAG_SIZE
		add	rdi, size DMA_FRAG
		loop	fraglist_loop

		mov	pAS.tx_scratch, edx	
ifndef FREEBUFF
; init first frag area
		mov	rbx, pAS.rx_curr_lookahead
		mov	dword ptr [rbx].dma_status, RDMA_OWNER_STATUS
endif

; wait for rx idle first
		mov	dx, pAS.io_base
		mov	ax, CMD_STOP_RDMA or CMD_STOP_RX
		out	dx, ax
		add	dx, EPC_INT_STATUS

		mov	rcx, 1000h
init_rx_wait_for_idle:
		dec	rcx
		jz	init_rx_set_rx_mask
		in	eax, dx
		test	eax, INT_RCV_IDLE
		jz	init_rx_wait_for_idle

; initialize rx epic regs
init_rx_set_rx_mask:
		call	set_receive_mask

; set the start of rx desc area
		mov	dx, pAS.io_base
		add	dx, EPC_RCV_CURR_DESC_ADDR
		pop	eax				; rx_dma phys addr
		out	dx, eax

		pop	edi
		pop	esi
		pop	edx
		pop	ecx
		pop	ebx
		pop	eax
		POP_ES

		ret

init_rx_queues  endp

;****************************************************************************
;
; Function:     init_nic        
;
; Synopis:      Initializes NIC on adapter whose adapter
;                       structure is indicated by DS:BP.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************
	public	init_nic
init_nic        proc    near
		push	dx

; fix transmit backoff problem
		mov	dx, pAS.io_base
		add	dx, EPC_TRANSMIT_TEST
		mov	ax, 0
		out	dx, ax

		add	dx, EPC_INTERPACKET_GAP - EPC_TRANSMIT_TEST
		mov	ax, pAS.ipg_timer
		out	dx, ax

; Default value for EPC_PBLCNT reg is 0.  If keyword BurstLength detected
; by UMAC, the UMAC must load the BurstLength value to the AdapterStructure
; byte size variable "burstlen".
		add	dx, EPC_PBLCNT - EPC_INTERPACKET_GAP
		xor	ax, ax
		mov	al, pAS.burstlen
		out	dx, ax

		add	dx, EPC_INT_MASK - EPC_PBLCNT
IFDEF FREEBUFF
		mov	eax, PTA+PMA+APE+DPE+CNT+TXU+TXC+RXE+OVR+RCC+TCC
ELSE
	        mov	eax, PTA+PMA+APE+DPE+CNT+TXU+TXC+RXE+OVR+HCC+RCC+TCC
ENDIF
                test    pAS.media_type2, MEDIA_TYPE_AUTO_NEGOTIATE
                jz      skip_enable_GP2
                or      eax, GP2

skip_enable_GP2:
		mov	pAS.int_mask, eax	
		out	dx, eax

; Default to PCI "memory read" unless MemoryReadMultiple keyword has been
; detected.  If so, set PCI "memory read multiple" bit in gen_cntl variable
; that resides in adapter structure
		test	pAS.adapter_flags1, READ_MULT
		jz	rd_mult_not
		or	pAS.gen_cntl, GC_RD_MULT
rd_mult_not:

IFDEF OLD_MII
; set 10 or 100 mb outputs
		add	dx, EPC_NV_CONTROL - EPC_INT_MASK
		mov	ax, 0
		out	dx, ax				; disable everything

		mov	ax, NVC_GPOE2 or NVC_GPOE1	; set 100mb mode
		cmp	pAS.media_type, MEDIA_STP100_UTP100
		je	in_no10mb
		or	ax, NVC_GPIO1	; set 10mb mode

in_no10mb:
		out	dx, ax
ENDIF
		pop	dx
		ret

init_nic        endp

;****************************************************************************
;
; Function:     init_etx_idle
;
; Synopis:      poll for transmit to finish
;
; Input:        ds:bp (ebp)	AdapterStructure
;		dx		EPIC COMMAND reg
;
; Output:       eax		interrupt status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

init_etx_idle   proc    near
		push	rcx
		add	dx, EPC_INT_STATUS - EPC_COMMAND

; wait for transmitter to go idle

init_etx_wait:
		mov	rcx, 80h
		loop	$
		in	eax, dx
		test	eax, INT_XMIT_IDLE or INT_XMIT_QUEUE_EMPTY or INT_XMIT_UNDERRUN
		jz	init_etx_wait		

		add	dx, EPC_COMMAND - EPC_INT_STATUS
		pop	rcx
		ret

init_etx_idle	endp

;****************************************************************************
;
; Function:     init_etx_threshold
;
; Synopis:      sets an initial value for the early transmit
;		threshold.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

init_etx_threshold	proc	near
		push	dx
		push	rbx

; start with an early tx of 16
		mov	dx, pAS.io_base
		add	dx, EPC_XMIT_COPY_THRESH
		mov	ax, 16
		mov	pAS.early_tx_thresh, ax
		out	dx, ax

; if line speed is 10mb, no initial adjustment is needed
		cmp	pAS.line_speed, LINE_SPEED_10
		je	init_etx_end

; assume line speed is 100mb
; set the epic in loopback mode
		add	dx, EPC_TRANSMIT_CONTROL - EPC_XMIT_COPY_THRESH
		in	ax, dx
		and	ax, NOT TC_LOOPBACK_MODE
		or	ax, TC_INTERNAL_LOOPBACK
		out	dx, ax
					
; initialize one transmit buffer
;		mov	rbx, pAS.tx_first_off
;;;jcc
                mov     rbx, pAS.tx_curr_off
;;;jcc
;		push	[rbx].dma_next_phys	; save next pointer

;		mov	eax, pAS.host_ram_phy_addr
;		mov	[rbx].dma_next_phys, eax	; set one packet tx
		mov     ax, pAS.max_packet_size
                mov     [rbx].dma_buf_len, ax
                mov     [rbx].dma_len, ax
		add	dx, EPC_COMMAND - EPC_TRANSMIT_CONTROL

init_etx_loop:
                mov     [rbx].dma_status, XDMA_OWNER_STATUS
		mov	ax, CMD_TXQUEUED
		out	dx, ax

		call	init_etx_idle

; do early tx adjustment
		test	eax, INT_XMIT_UNDERRUN
		jz	init_etx_reset

; wait for txugo to clear (yech!)
init_etx_loop2:
		mov	ax, CMD_TXUGO
		out	dx, ax

; stop at end of current tx
		mov	ax, CMD_STOP_TDMA
		out	dx, ax

		call	init_etx_idle

		test	eax, INT_XMIT_UNDERRUN
		jnz	init_etx_loop2

		cmp	pAS.early_tx_thresh, ETX_MAX_THRESH
		ja	init_etx_reset

; update threshold
		add	dx, EPC_XMIT_COPY_THRESH - EPC_COMMAND
		add	pAS.early_tx_thresh, 4
		mov	ax, pAS.early_tx_thresh
		out	dx, ax
		add	dx, EPC_COMMAND - EPC_XMIT_COPY_THRESH
		jmp	init_etx_loop

; restore the transmit buffer
init_etx_reset:
; take epic out of loopback mode
		add	dx, EPC_TRANSMIT_CONTROL - EPC_COMMAND
		in	ax, dx
		and	ax, NOT TC_LOOPBACK_MODE
                test    pAS.line_speed, LINE_SPEED_FULL_DUPLEX
                jz      init_etx_half_duplex
                or      ax, TC_FULL_DUPLEX
init_etx_half_duplex:
		out	dx, ax

;		pop	[rbx].dma_next_phys
;;;jcc
; update the first and current transmit descriptor pointers
                mov     rbx, pAS.tx_curr_off
                mov     rbx, [rbx].dma_next_off
                mov     pAS.tx_first_off, rbx
                mov     pAS.tx_curr_off, rbx
;;;jcc

init_etx_end:
		pop	rbx
		pop	dx
		ret

init_etx_threshold	endp


;****************************************************************************
;
; Function:     init_mii_registers        
;
; Synopis:      Initializes PHY and related Epic registers.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

public init_mii_registers
init_mii_registers        proc    near

		push	eax
		push	dx
		push	bx
		push	ecx

IFDEF OLD_MII
		mov	dx, pAS.io_base
		add	dx, EPC_MII_CONFIG

		mov	eax, 0			; disable 10 and 100 mb
		out	dx, eax

; default to 100mb mode
		mov	eax, MII_SERIAL_MODE_ENABLE
		cmp	pAS.media_type, MEDIA_STP100_UTP100
		je	mii_100mb

; turn on 10 mb link light
		add	dx, EPC_MII_CONTROL - EPC_MII_CONFIG
		mov	eax, 0
		out	dx, eax
		add	dx, EPC_MII_CONFIG - EPC_MII_CONTROL

		mov	eax, MII_ENABLE_SMI or MII_SERIAL_MODE_ENABLE or MII_ENABLE_694
mii_100mb:
		out	dx, eax

init_mii_exit:
ELSE
; get mii phy organizationally unique identifier
                call    read_phy_OUI
                mov     pAS.phy_id, eax
                cmp     eax, 0000c039h
                jnz     init_mii_not_tdk_phy
                call    init_tdk_phy
                jmp     init_mii_exit

init_mii_not_tdk_phy:
                cmp     pAS.card_SSID, SSID9432BTX
                jnz     init_mii_check_nway
		test	pAS.media_type2, MEDIA_TYPE_AUTO_DETECT
                jnz     init_mii_auto_detect

init_mii_check_bnc:
		test	pAS.media_type2, MEDIA_TYPE_BNC
                jz      init_mii_check_nway
        	mov	dx, pAS.io_base
	        add	dx, EPC_MII_CONFIG              ; turn on BNC
                mov     ax, MII_ENABLE_SMI or MII_ENABLE_694 or MII_SERIAL_MODE_ENABLE
                out     dx, ax
		mov	bx, PHY_BMC_REG	                ; isolate mii and	
		mov	ax, PHY_ISOLATE                 ; turn off nway
		call	write_phy_register
                jmp     init_mii_fried

init_mii_auto_detect:
		call	epic_auto_detect
		test	pAS.media_type2, MEDIA_TYPE_BNC
                jnz     init_mii_enable_int
		test	pAS.media_type2, MEDIA_TYPE_UTP
                jz      init_mii_enable_int             ; jump if no media detected

init_mii_check_nway:
		test	pAS.media_type2, MEDIA_TYPE_AUTO_NEGOTIATE
		jz	init_mii_check_speed

		cmp	pAS.line_speed, LINE_SPEED_UNKNOWN
		jnz	init_mii_nway_complete

init_mii_reset_phy:
		mov	dx, pAS.io_base
		add	dx, EPC_NV_CONTROL
;		mov	eax, NVC_GPOE1 or NVC_GPIO1
		mov	eax, NVC_GPOE1                  ; drive gpio[1] low
		out	dx, eax                         ; required for 9432BTX

		add	dx, EPC_MII_CONFIG - EPC_NV_CONTROL
		mov	eax, MII_ENABLE_SMI
		out	dx, eax

		add	dx, EPC_GEN_CONTROL - EPC_MII_CONFIG
		mov	eax, pAS.gen_cntl
		or	eax, GC_HARD_RESET
		out	dx, eax

; the QSI 6612 requires a hardware reset to be at least 10 microseconds long
		mov	rcx, 80h
wait_for_reset:
                in      eax, dx
                loop    wait_for_reset
		and	eax, not GC_HARD_RESET
		out	dx, eax
; add delay after clearing GC_HARD_RESET as required by Mercury based
; adapters used on Pentium Pro 200 or similarly fast machines.
		mov	rcx, 80h
wait_for_reset_clear:
		jmp	$+2
		loop	wait_for_reset_clear

; The National PHY requires that something be written to the Basic Mode
; Control Register before enabling nway, or nway will not complete.
		mov	ax, 0
		mov	bx, PHY_BMC_REG
		call	write_phy_register

init_mii_start_nway:
		mov	ax, PHY_AN_ENABLE
		mov	bx, PHY_BMC_REG
		call	write_phy_register

		mov	ax, PHY_RESTART_AN or PHY_AN_ENABLE
		mov	bx, PHY_BMC_REG
		call	write_phy_register

		mov	ecx, 30000h
init_mii_nway_complete_loop:
		dec	ecx
		jz	init_mii_enable_int
		mov	bx, PHY_BMS_REG
		call	read_phy_register
		test	ax, PHY_AN_COMPLETE	;test for nway complete
		jz	init_mii_nway_complete_loop

init_mii_nway_complete:
		mov	bx, PHY_ANLPA_REG
		call	read_phy_register
		test	ax, PHY_100_BASE_TX_HD or PHY_10_BASE_T_HD
		jz	init_mii_workaround
		test	ax, PHY_100_BASE_TX_FD or PHY_100_BASE_TX_HD
		jnz	init_mii_report_100Mb

init_mii_report_10Mb:
		mov	pAS.line_speed, LINE_SPEED_10
		test	ax, PHY_10_BASE_T_FD
		jz	init_mii_enable_int

		jmp	short init_mii_set_epic_FD

init_mii_report_100Mb:
		mov	pAS.line_speed, LINE_SPEED_100
		test	ax, PHY_100_BASE_TX_FD
		jz	init_mii_enable_int

init_mii_set_epic_FD:
		mov	dx, pAS.io_base
		add	dx, EPC_TRANSMIT_CONTROL
		in	ax, dx
		or	ax, TC_FULL_DUPLEX
		out	dx, ax
		or	pAS.line_speed, LINE_SPEED_FULL_DUPLEX
		jmp	short init_mii_enable_int

; user selected (non-nway) speed

init_mii_check_speed:
		cmp	pAS.line_speed, LINE_SPEED_UNKNOWN
		jz	init_mii_qsi_workarounds        ; do nothing if line_speed
						        ; is not specified

; If we are connected to an nway device we want it to renegotiate, so
; we have to tell the phy to drop link.  So first put it in 10 Mbps
; half duplex mode, then put it in loopback mode, before setting it
; to the desired speed and duplex mode.
                mov     ax, 0                   ; 10 Mbps, half duplex
		mov	bx, PHY_BMC_REG
		call	write_phy_register

                mov     ax, 750
                call    epic_delay              ; 750 millisecond delay

                mov     ax, PHY_LOOPBACK
		call	write_phy_register

                mov     ax, 100
                call    epic_delay

		xor	ax, ax
		test	pAS.line_speed, LINE_SPEED_FULL_DUPLEX
		jz	init_mii_not_full_duplex

		mov	ax, PHY_FULL_DUPLEX

init_mii_not_full_duplex:
		test	pAS.line_speed, LINE_SPEED_100
		jz	init_mii_set_speed

		or	ax, PHY_SPEED_SELECT_100

init_mii_set_speed:
		mov	bx, PHY_BMC_REG
		call	write_phy_register

		test	pAS.line_speed, LINE_SPEED_FULL_DUPLEX
		jz	init_mii_qsi_workarounds

		mov	dx, pAS.io_base
		add	dx, EPC_TRANSMIT_CONTROL
		in	ax, dx
		or	ax, TC_FULL_DUPLEX
		out	dx, ax

; first clear, then enable the QSI 6612 autonegotiation complete interrupt
; and link down interrupt
init_mii_enable_int:
		test	pAS.media_type2, MEDIA_TYPE_AUTO_NEGOTIATE
                jz      init_mii_qsi_workarounds
                mov     bx, PHY_INT_SOURCE_REG
                call    read_phy_register
                mov     ax, PHY_INT_MODE or PHY_AN_COMPLETE_INT or PHY_LINK_DOWN_INT
                mov     bx, PHY_INT_MASK_REG
	        call	write_phy_register

init_mii_qsi_workarounds:
; turn off bit 1 in Mercury register 27 to improve long cable length performance
                mov     bx, 27
                call    read_phy_register
                and     ax, 0fffdh
	        call	write_phy_register

; To scramble or not to scramble, that is the question.
; Default is to NOT scramble (ie fried)
; Scramble only if keyword was detectd
		test	pAS.adapter_flags1, SCRAMBLE
		jz	init_mii_fried
; Toggle the scramble disable bit in Mercury register 31 to fix a Mercury
; bug in which the EPIC can't receive data when the PHY is connected to a
; Bay Networks BayStack 100.
                mov     ax, 750                 ; 750 ms delay required for
                call    epic_delay              ; Synoptics 28115 switch
                mov     bx, 31
                call    read_phy_register
                push    ax
                or      ax, 1
 	        call	write_phy_register
                pop     ax
	        call	write_phy_register

init_mii_fried:
		mov	dx, pAS.io_base
		add	dx, EPC_NV_CONTROL
		mov	eax, NVC_GPOE1
		out	dx, eax

ENDIF

init_mii_exit:
		pop	ecx
		pop	bx
		pop	dx
		pop	eax
		ret

IFNDEF OLD_MII
; National DP83840 workaround code
init_mii_workaround:
		mov	bx, 19h
		call	read_phy_register
		test	ax, 40h
		jz	init_mii_100Mb_half_duplex
		mov	pAS.line_speed, LINE_SPEED_10
		jmp	short init_mii_fried

init_mii_100Mb_half_duplex:
		mov	pAS.line_speed, LINE_SPEED_100
		jmp	short init_mii_fried
ENDIF
init_mii_registers        endp

;****************************************************************************
;
; Function:     read_phy_OUI        
;
; Synopis:      returns the OUI from the Phy (See Phy Identifier Registers)
;               on the Nic whose adapter structure is indicated by DS:BP.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       eax	return status (OUI)
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

public read_phy_OUI
read_phy_OUI            proc    near
	push	ebx
	push	ecx
	push	edx

	mov	bx, PHY_ID_REG1
	call	read_phy_register

	xor	ecx, ecx		;clear extended part
	mov	cx, ax
	shl	ecx, 6			;make space for 6 lsbs

	mov	bx, PHY_ID_REG2
	call	read_phy_register

	and	eax, 0fc00h		;filter bits we want
	shr	eax, 10			;position as 6 lsbs

	or	eax, ecx		

	pop	edx
	pop	ecx
	pop	ebx

	ret

read_phy_OUI            endp

;****************************************************************************
;
; Function:     init_tdk_phy
;
; Synopis:      Initializes TDK PHY registers and related Epic registers.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

public init_tdk_phy
init_tdk_phy            proc    near
                push    bx
                push    ecx
                push    dx

		mov	dx, pAS.io_base
		add	dx, EPC_NV_CONTROL
                in      ax, dx
                and     ax, 0fbbfh              ; turn off statusreg_en bit
                or      ax, 800h                ; turn on phypwrdwn_n bit
                out     dx, ax

                add     dx, EPC_GEN_CONTROL - EPC_NV_CONTROL
		mov	eax, pAS.gen_cntl
		or	eax, GC_HARD_RESET
		out	dx, eax

		mov	rcx, 80h
init_tdk_reset:
                in      eax, dx
                loop    init_tdk_reset
		and	eax, not GC_HARD_RESET
		out	dx, eax

; a bug in the TDK 2120 rev. 3 requires all writes to be performed twice
		mov	ax, PHY_RESTART_AN or PHY_AN_ENABLE
		mov	bx, PHY_BMC_REG
		call	write_phy_register

		mov	ax, PHY_RESTART_AN or PHY_AN_ENABLE
		mov	bx, PHY_BMC_REG
		call	write_phy_register

		mov	ecx, 30000h
init_tdk_nway_complete_loop:
		dec	ecx
		jz	init_tdk_exit
		mov	bx, PHY_BMS_REG
		call	read_phy_register
		test	ax, PHY_AN_COMPLETE	;test for nway complete
		jz	init_tdk_nway_complete_loop

                call    handle_nway_complete

		mov	bx, PHY_BMC_REG
                call    read_phy_register

		mov	bx, PHY_BMS_REG
                call    read_phy_register

		mov	bx, PHY_ANLPA_REG
		call	read_phy_register

init_tdk_exit:
                pop     dx
                pop     ecx
                pop     bx
                ret
init_tdk_phy            endp

;****************************************************************************
;
; Function:     handle_nway_complete        
;
; Synopis:      Read the results of an autonegotiation-complete event
;               from the PHY and switch the Epic to full or half duplex.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       None
;
; Modified:     AdapterStructure.line_speed
;
; Notes:	None
;
;****************************************************************************

public handle_nway_complete
handle_nway_complete        proc    near
		push	ax
		push	dx
		push	bx

; If the PHY is a National then exit, the National PHY sometimes causes
; a GP2 interrupt when there is a cable disconnect.
;
                cmp     pAS.phy_id, 00080017h
                jz      handle_nway_exit

; There is a bug in the Mercury PHY.  If the result of autonegotiation is full
; duplex and the cable is pulled and plugged into a half duplex link partner,
; the result of autonegotiation will be full duplex.  This can be avoided if
; the PHY status register is read after an autonegotiation complete interrupt
; occurs.
;
                mov     bx, PHY_BMS_REG
                call    read_phy_register

; Read the PHY status register a second time to make sure its content is valid.
                call    read_phy_register

                mov     dx, pAS.io_base
                add     dx, EPC_TRANSMIT_CONTROL

		mov	bx, PHY_ANLPA_REG
		call	read_phy_register
                test    ax, PHY_100_BASE_TX_FD or PHY_100_BASE_TX_HD
                jz      handle_nway_10Mb
                mov     pAS.line_speed, LINE_SPEED_100
                test    ax, PHY_100_BASE_TX_FD
                jz      handle_nway_reset_epic_FD

handle_nway_set_epic_FD:
                in      ax, dx
                or      ax, TC_FULL_DUPLEX
                out     dx, ax
                or      pAS.line_speed, LINE_SPEED_FULL_DUPLEX
                jmp     short handle_nway_qsi_workaround

handle_nway_10Mb:
; If no valid bit is set in the link partner ability register, then exit
; without doing anything.
;
                test    ax, PHY_10_BASE_T_FD or PHY_10_BASE_T_HD
                jz      handle_nway_exit
                mov     pAS.line_speed, LINE_SPEED_10
                test    ax, PHY_10_BASE_T_FD
                jnz     handle_nway_set_epic_FD

handle_nway_reset_epic_FD:
                in      ax, dx
                and     ax, NOT TC_FULL_DUPLEX
                out     dx, ax

handle_nway_qsi_workaround:
; Jump if this is a TDK phy.
                cmp     pAS.phy_id, 0000c039h
                jz      handle_nway_exit

; To scramble or not to scramble, that is the question.
; Default is to NOT scramble
; Scramble only if keyword was detectd
		test	pAS.adapter_flags1, SCRAMBLE
		jz	handle_nway_exit
; Toggle the scramble disable bit in Mercury register 31 to fix a Mercury
; bug in which the EPIC can't receive data when the PHY is connected to a
; Bay Networks BayStack 100.
                mov     bx, 31
                call    read_phy_register
                push    ax
                or      ax, 1
	        call	write_phy_register
                pop     ax
	        call	write_phy_register

handle_nway_exit:
                pop     bx
                pop     dx
                pop     ax
                ret
handle_nway_complete        endp

;****************************************************************************
;
; Function:     handle_phy_event
;
; Synopis:      Handle a link-down or autonegotiation-complete event. If
;               the board is a 9432BTX in AutoDetect mode, switch between
;               utp and bnc when the current media is down.  Indicate the
;               new media type in media_type2.  Indicate the new line speed
;               and duplex mode in line_speed.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       None
;
; Modified:     AdapterStructure.media_type2
;               AdapterStructure.line_speed
;
; Notes:	None
;
;****************************************************************************

public handle_phy_event
handle_phy_event        proc    near

                mov     bx, PHY_INT_SOURCE_REG
                call    read_phy_register

                test    ax, PHY_AN_COMPLETE_INT
                jnz     handle_phy_nway_complete

                test    ax, PHY_LINK_DOWN_INT
                jz      handle_phy_exit

; If this is a 9432BTX in AutoDetect mode and the utp link is down, then
; switch to bnc.
handle_phy_link_down:
                cmp     pAS.card_SSID, SSID9432BTX
                jnz     handle_phy_exit
                test    pAS.media_type2, MEDIA_TYPE_AUTO_DETECT
                jz      handle_phy_exit

                and     pAS.media_type2, NOT MEDIA_TYPE_UTP
                or      pAS.media_type2, MEDIA_TYPE_BNC         ; indicate bnc

                mov     ax, PHY_ISOLATE or PHY_AN_ENABLE        ; isolate mii
                mov     bx, PHY_BMC_REG
                call    write_phy_register

                call    read_phy_register

                mov     dx, pAS.io_base                         ; turn on bnc
                add     dx, EPC_MII_CONFIG
		mov	ax, MII_ENABLE_SMI or MII_SERIAL_MODE_ENABLE or MII_ENABLE_694
                out     dx, ax

                add     dx, EPC_TRANSMIT_CONTROL - EPC_MII_CONFIG
                in      ax, dx
                and     ax, NOT TC_FULL_DUPLEX
                out     dx, ax                                  ; turn off full duplex
                mov     pAS.line_speed, LINE_SPEED_10           ; indicate 10, half duplex
                jmp     short handle_phy_exit

; If this is a 9432BTX in AutoDetect mode, then switch to utp.
handle_phy_nway_complete:
                cmp     pAS.card_SSID, SSID9432BTX
                jnz     handle_phy_utp

                test    pAS.media_type2, MEDIA_TYPE_AUTO_DETECT
                jz      handle_phy_utp

                and     pAS.media_type2, NOT MEDIA_TYPE_BNC
                or      pAS.media_type2, MEDIA_TYPE_UTP         ; indicate utp

                mov     dx, pAS.io_base
                add     dx, EPC_MII_CONFIG
                mov     ax, MII_ENABLE_SMI
                out     dx, ax                                  ; turn off bnc

                mov     ax, PHY_AN_ENABLE                       ; clear mii isolate
                mov     bx, PHY_BMC_REG                         ; bit
                call    write_phy_register

handle_phy_utp:
                call    handle_nway_complete

handle_phy_exit:
                ret

handle_phy_event        endp

;****************************************************************************
;
; Function:     epic_delay
;
; Synopsis:     Wait for ax milliseconds.
;
; Input:        ds:bp (ebp)	AdapterStructure
;               ax 
;
; Output:       None
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

epic_delay      	proc	near
        push    ecx
        push    dx

        mov     dx, pAS.io_base
        add     dx, EPC_PBLCNT
        movzx   ecx, ax
        shl     ecx, 11
epic_delay_loop:
        in      ax, dx
        dec     ecx
        jnz     epic_delay_loop

        pop     dx
        pop     ecx
        ret
epic_delay              endp

;****************************************************************************
;
; Function:     epic_auto_detect        
;
; Synopis:      Auto detect between UTP and BNC port.
;               The detected media is set in media_type2.
;               If neither UTP or BNC is detected, those
;               bits are cleared in media_type2.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     media_type2, line_speed
;
; Notes:	None
;
;****************************************************************************

public epic_auto_detect
epic_auto_detect	proc	near
        push    eax
        push    ebx
        push    ecx
        push    es
        push    rdi

        and     pAS.media_type2, MEDIA_TYPE_AUTO_NEGOTIATE or MEDIA_TYPE_AUTO_DETECT
	or	pAS.media_type2, MEDIA_TYPE_UTP

	mov	bx, PHY_BMS_REG
	call	read_phy_register		; read multiple times for
	call	read_phy_register		; the current UTP link status
	call	read_phy_register
	call	read_phy_register
	test	ax, PHY_LINK_STATUS		; check UTP link status
	jnz	epic_ad_done			; jmp if we have link

	and	pAS.media_type2, NOT MEDIA_TYPE_UTP
        call    check_bnc_port
        jc      epic_ad_done                    ; jump if bnc is down
        or      pAS.media_type2, MEDIA_TYPE_BNC
;;;jcc
        mov     pAS.line_speed, LINE_SPEED_10
;;;jcc

epic_ad_done:
        pop     rdi
        pop     es
        pop     ecx
        pop     ebx
        pop     eax
	ret

epic_auto_detect	endp

;****************************************************************************
;
; Function:     check_bnc_port
;
; Synopis:      Send a runt packet with a bad crc through the bnc port to
;               check if it is active.  The Epic is left in bnc mode whether
;               or not bnc is up.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     
;
; Notes:	On return the carry flag is cleared if bnc is up, set if bnc
;               is down.  Called by epic_auto_detect.
;
;****************************************************************************

public check_bnc_port
check_bnc_port          proc	near

        mov     ax, PHY_ISOLATE                 ; isolate mii
	or	ax, PHY_AN_ENABLE
        mov     bx, PHY_BMC_REG
        call    write_phy_register
        call    read_phy_register

	mov	dx, pAS.io_base
	add	dx, EPC_MII_CONFIG              ; turn on BNC
        mov     ax, MII_ENABLE_694 or MII_SERIAL_MODE_ENABLE or MII_ENABLE_SMI
        out     dx, ax

; the current 9432btx requires that gpio[1] be driven low in order to use bnc
	add	dx, EPC_NV_CONTROL - EPC_MII_CONFIG
	mov	eax, NVC_GPOE1
	out	dx, eax

        mov     ax, 500
        call    epic_delay

; build and send a test packet to check for BNC connection
ifdef CODE_386
        mov     edi, pAS.setup_ptr.virtual_addr
else
        les     di, pAS.setup_ptr.virtual_addr
endif        

; copy the node address to the test packet's source and destination fields
	mov	dx, pAS.io_base   
        add     dx, EPC_LANADDR1               
        in      ax, dx

        mov     es:[rdi], ax
        mov     es:[rdi]+6, ax
        add     dx, EPC_LANADDR2 - EPC_LANADDR1
        in      ax, dx
        mov     es:[rdi]+2, ax
        mov     es:[rdi]+8, ax
        add     dx, EPC_LANADDR3 - EPC_LANADDR2
        in      ax, dx
        mov     es:[rdi]+4, ax
        mov     es:[rdi]+10, ax

; fill in the rest of the packet with ones
        add     rdi, 12
        mov     ax, 0ffffh
        mov     rcx, 19
        rep     stosw

        mov     rbx, pAS.tx_curr_off            ; ptr to current tx descriptor
        mov     dword ptr [rbx].dma_buf_len, XDMA_FRAGLIST or XDMA_NOCRC
        mov     [rbx].dma_len, 50               ; packet length
        mov     rdi, [rbx].dma_buff_off         ; ptr to fragment list

ifndef CODE_386
        mov     ax, ds
        mov     es, ax          
endif

        mov     eax, 1                          ; fragment count
        stosd
        mov     eax, pAS.setup_ptr.phy_addr
        stosd
        mov     eax, 50                         ; buffer length
        stosd

; set the descriptor ownership to the nic
        mov     [rbx].dma_status, XDMA_OWNER_STATUS

        mov     dx, pAS.io_base
        add     dx, EPC_COMMAND
        mov     ax, CMD_TXQUEUED
        out     dx, ax                          ; start tx

        mov     ecx, 0f000000h
check_bnc_loop:
        dec     ecx
        jz      check_bnc_down                  ; jump if hardware fails
        test    [rbx].dma_status, XDMA_OWNER_STATUS
        jnz     check_bnc_loop                  ; wait for tx to complete

        test    [rbx].dma_status, XDMA_CARRIER_SENSE_LOST
        clc                                     ; indicate bnc is up
        jz      check_bnc_done                  ; jump if bnc is up
check_bnc_down:
        stc                                     ; indicate bnc is down

check_bnc_done:
;; update first and current transmit pointers
        mov     rdi, pAS.tx_curr_off
	mov	rdi, [rdi].dma_next_off
	mov	pAS.tx_first_off, rdi
        mov     pAS.tx_curr_off, rdi

        ret
check_bnc_port          endp

;****************************************************************************
;
; Function:     write_phy_register      
;
; Synopis:      Write value in ax to physical layer register
;                       bx.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       None
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

write_phy_register	proc	near
        push    ax
	push	dx
	mov	dx, pAS.io_base
	add	dx, EPC_MII_DATA
	out	dx, ax
	add	dx, EPC_MII_CONTROL - EPC_MII_DATA
	mov	ax, bx
	shl	ax, 4
	or	ax, MII_WRITE
	test	pAS.media_type2, MEDIA_TYPE_MII
	jnz	write_phy_mii
	or	ax, 3h SHL 9
write_phy_mii:
	out	dx, ax
write_phy_reg_loop:
	in	ax, dx
	test	ax, MII_WRITE
	jnz	write_phy_reg_loop
	pop	dx
        pop     ax
	ret
write_phy_register	endp

;****************************************************************************
;
; Function:     read_phy_register       
;
; Synopis:      Read physical layer register bx and return
;                      value in ax
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

public read_phy_register
read_phy_register	proc	near
	push	dx
	mov	dx, pAS.io_base
	add	dx, EPC_MII_CONTROL
	mov	ax, bx
	shl	ax, 4
	or	ax, MII_READ
	test	pAS.media_type2, MEDIA_TYPE_MII
	jnz	read_phy_mii
	or	ax, 3h SHL 9
read_phy_mii:
	out	dx, ax
read_phy_reg_loop:
	in	ax, dx
	test	ax, MII_READ
	jnz	read_phy_reg_loop
	add	dx, EPC_MII_DATA - EPC_MII_CONTROL
	in	ax, dx
	pop	dx
	ret
read_phy_register	endp

;****************************************************************************
;
; Function:     InitErrorCounters       
;
; Synopis:      Initializes error counters to point to
;               ds:[bp].dummy_vector if they are not
;               initialized by UMAC.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

InitErrorCounters       proc    near
		push    ax
		push    ebx
		push    ecx
		push    esi

		mov     rcx, (ptr_ring_OVW - ptr_rx_CRC_errors) / 4 + 1
		lea     rsi, pAS.ptr_rx_CRC_errors      ; Get address of first counter
		lea     rbx, pAS.dummy_vector           ; BX = offset of dummy vector.
							; DS:SI = offset of first counter.
ifndef CODE_386
		ror     ebx, 16
		mov     bx, ds
		ror     ebx, 16
endif

CheckVectors:
		cmp     dword ptr [rsi], 0
		jnz     SkipThisVector                  ; If null, fill with dummy vector.
		mov     [rsi], rbx

SkipThisVector:
		add     rsi, 4
		loop    CheckVectors

		pop     esi
		pop     ecx
		pop     ebx
		pop     ax

		ret
InitErrorCounters       endp

;****************************************************************************
;
; Function:     put_node_address	
;
; Synopis:      if the node address is set, get it from
;		the pAS, otherwise copy
;		the adapter node address to pAS
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

put_node_address proc	near
		push	eax
		push	dx

		movzx	eax, word ptr pAS.xnode_address[0]
		or	eax, dword ptr pAS.xnode_address[2]
		je	no_node_address

		mov	dx, pAS.io_base
		add	dx, EPC_LANADDR1
		mov	ax, word ptr pAS.xnode_address[0]
		out	dx, ax
		add	dx, EPC_LANADDR2 - EPC_LANADDR1
		mov	ax, word ptr pAS.xnode_address[2]
		out	dx, ax
		add	dx, EPC_LANADDR3 - EPC_LANADDR2
		mov	ax, word ptr pAS.xnode_address[4]
		out	dx, ax
		jmp	gna_done

no_node_address:
		mov	dx, pAS.io_base
		add	dx, EPC_LANADDR1
		in	ax, dx
		mov	word ptr pAS.xnode_address[0], ax
		add	dx, EPC_LANADDR2 - EPC_LANADDR1
		in	ax, dx
		mov	word ptr pAS.xnode_address[2], ax
		add	dx, EPC_LANADDR3 - EPC_LANADDR2
		in	ax, dx
		mov	word ptr pAS.xnode_address[4], ax

gna_done:
		pop	dx
		pop	eax
		ret

put_node_address endp

;****************************************************************************
;
; Function:     LM_Initialize_Adapter
;
; Synopis:      Initializes the adapter whose structure is 
;               indicated by DS:BP
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    LM_Initialize_Adapter

		push    ebx
		push    ecx
		push    edx
		push    esi
		push    edi
		push	eax

; set up physical base address
	
		call	reset_nic
		call	init_tx_queues
		call	init_rx_queues
		call	init_nic
		call	init_mii_registers
		call	init_etx_threshold

		call	put_node_address

		call    InitErrorCounters
		mov     pAS.adapter_status, INITIALIZED

IFDEF EZSTART
		call    PCI_LM_Enable_Adapter
ELSE
 IFNDEF CODE_386
		call    LM_Enable_Adapter
 ELSE
		mov	rax, SUCCESS
 ENDIF
ENDIF

LM_Init_Return:
		push    rax
		call    UM_Status_Change
		pop     rbx

		pop	eax
		mov	rax, rbx		; restore return code
		pop     edi
		pop     esi
		pop     edx
		pop     ecx
		pop     ebx

		ret

ASM_PCI_PROC_END        LM_Initialize_Adapter

;****************************************************************************
;
; Function:     LM_Interrupt_Req        
;
; Synopis:      Generates a hardware interrupt from the
;               adapter indicated by DS:BP.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    LM_Interrupt_Req

		push    dx
                push    eax
		test    pAS.adapter_flags, ADAPTER_DISABLED
		mov     rax, OUT_OF_RESOURCES
		jnz     IntReqDone

		mov	dx, pAS.io_base
		add	dx, EPC_GEN_CONTROL
		in	eax, dx
                or      eax, GC_SW_INT
		out	dx, eax
		inc	pAS.int_bit
                pop     eax

		mov     rax, SUCCESS

IntReqDone:
		pop     dx
		ret

ASM_PCI_PROC_END        LM_Interrupt_Req

;****************************************************************************
;
; Function:     LM_Open_Adapter         
;
; Synopis:      Opens adapter whose adapter structure is
;               indicated by DS:BP.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    LM_Open_Adapter

			push    ecx
			push    edx
			cmp     pAS.adapter_status, NOT_INITIALIZED
			jne     CheckStat01
			mov     rax, ADAPTER_NOT_INITIALIZED
			jmp     LM_OADone
CheckStat01:            cmp     pAS.adapter_status, INITIALIZED
			je      OKToOpen
			cmp     pAS.adapter_status, OPEN
			je      AlreadyOpen
DoInit:
IFDEF EZSTART
			call    PCI_LM_Initialize_Adapter
ELSE
			call    LM_Initialize_Adapter
ENDIF
			cmp     rax, SUCCESS
			je      OKToOpen
			mov     rax, OPEN_FAILED
			mov     pAS.adapter_status, FAILED
			jmp     LM_OADone

OKToOpen:
IFDEF FREEBUFF
			mov	ax, pAS.num_rx_free_buffs
			cmp	ax, pAS.num_of_rx_buffs
			jz	RxBufferOK

			mov	rax, OPEN_FAILED
			jmp     LM_OADone

RxBufferOK:
ENDIF
; clear dma status bits (they power up on!)
			push	eax
			mov	dx, pAS.io_base
			add	dx, EPC_RCV_DMA_STATUS
			mov	eax, 0
			out	dx, eax
			pop	eax

; turn on the receiver and start receive dma's
			add	dx, EPC_COMMAND - EPC_RCV_DMA_STATUS
			mov	ax, CMD_START_RX or CMD_RXQUEUED
			out	dx, ax


AlreadyOpen:            
            mov     pAS.adapter_status, OPEN
			call    UM_Status_Change
            mov     rax, SUCCESS             ; Set return code
LM_OADone:  pop     edx
			pop     ecx
			ret

ASM_PCI_PROC_END        LM_Open_Adapter

;****************************************************************************
;
; Function:     LM_Put_Rx_Frag       
;
; Synopis:      Enqueues a Fragment list for receive
;
; Input:        ds:bp (ebp)	AdapterStructure
;               es:si (esi)     Fragment list pointer
;               dx:di (edi)     Handle
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

IFDEF FREEBUFF
ASM_PCI_PROC		LM_Put_Rx_Frag

	mov	ax, pAS.num_rx_free_buffs

	cmp	ax, pAS.num_of_rx_buffs
	jb	enqueue_it
	mov	rax, OUT_OF_RESOURCES
	ret
enqueue_it:
	push	ebx
	push	edi
	push	ecx

	mov	rbx, pAS.rx_last_fraglist
IFDEF CODE_386
	mov	[rbx].dma_handle, edi
ELSE
	mov	word ptr [rbx].dma_handle, di
	mov	word ptr [rbx].dma_handle+2, dx
ENDIF
	mov	rdi, [rbx].dma_buff_off
IFDEF CODE_386
	mov	ecx, [esi]
	movsd
	shl	ecx, 1
	rep	movsd
ELSE
	movzx	ecx, word ptr es:[si]
	push	ds
	push	es
	pop	ds
	pop	es
	mov	es:[di], ecx
	add	di, 4
	add	si, fragment_list
load_frag_loop:
	movsd
	lodsw
	and	ax, NOT PHYSICAL_ADDR
	stosw
	mov	word ptr es:[di], 0
	add	di, 2
	loop	load_frag_loop
	push	es
	push	ds
	pop	es
	pop	ds
ENDIF
	mov	dword ptr [rbx].dma_status, RDMA_OWNER_STATUS
	mov	rbx, [rbx].dma_next_off
	mov	pAS.rx_last_fraglist, rbx
	inc	pAS.num_rx_free_buffs

	cmp	pAS.adapter_status, OPEN
	jnz	LM_Put_Rx_Frag_Exit

	mov	ebx, edx			; save edx
	mov	dx, pAS.io_base
	mov	ax, CMD_RXQUEUED
	out	dx, ax
	mov	edx, ebx

LM_Put_Rx_Frag_Exit:
	pop	ecx
	pop	edi
	pop	ebx
	mov	eax, SUCCESS
	ret
	
ASM_PCI_PROC_END	LM_Put_Rx_Frag
ENDIF

;****************************************************************************
;
; Function:     LM_Receive_Copy 
;
; Synopis:      Copies data from the received packet to
;                  a Data buffer structure.
;
; Input:        ds:bp (ebp)	AdapterStructure
;       	cx    (ecx)	bytes to move
;               ax    (eax)	Offset in shared RAM
;               bx    (ebx)     Lookahead flag, 0 = Lookahead copy.
;               es:si (esi)     Pointer to data buffer structure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    LM_Receive_Copy
                push    edx
                push    ebx
                
; check for bad request
                cmp     pAS.adapter_status, OPEN
		jne     lrc_out_of_res

                movzx   edx, ax
                add     ax, cx                  
		cmp     ax, 600h      		; max possible ethernet size
		ja      lrc_out_of_res
                
; set up receive fragment
		mov	rbx, pAS.rx_curr_fraglist
		mov	rbx, [rbx].dma_next_off
		mov	pAS.rx_curr_fraglist, rbx
ifdef FREEBUF
		mov	[rbx].dma_buf_len, dx		; offset length
else
		mov	[rbx].dma_buf_len, 0		; offset length
endif
		
; initialize the fragment list
		push	rcx
                push    rsi
                push    rdi
		push	eax

                mov     rdi, [rbx].dma_buff_off
		mov	eax, 0

ifndef CODE_386
		push	es			; swap es and ds segments
		push	ds
		pop	es
		pop	ds
endif

ifndef CODE_386
                lodsw				; get fragment count
else
		lodsd
endif
		mov	rcx, rax
ifndef FREEBUF
		add	rax, 2
endif
		stosd

ifndef FREEBUF
; erx enable fix
; the epic will not do an early receive unless the packet
; starts at byte 0. Our fix is to prepend a scratch buffer to the
; beginning of the fragment list.
		mov	eax, es:[bp].tx_scratch
		stosd
		mov	eax, edx
		stosd
; end erx workaround
endif


rx_frag_loop:
; move a single fragment dw len, dd ptr to dd len, dd ptr
		movsd				; move pointer
ifndef CODE_386
                lodsw				; get fragment length
else
		lodsd
endif
                and     rax, NOT PHYSICAL_ADDR
                stosd
		loop	rx_frag_loop

ifndef FREEBUF
; fraglist error workaround
; the epic will post rx status at the completion of the fraglist dma.
; this is a problem when the dma fraglist is shorter that the received packet.
; In this case, NW_STATUS_VALID will be 0 and FRAGMENT_LIST_ERROR will be
; 1, causing the packet to be tossed. To fix this bug, we add an extra fragment 
; at the end of the fraglist to force the dma to wait for receive completion.
		mov	eax, es:[bp].tx_scratch
		stosd
		mov	eax, 256
		stosd
; end fraglist workaround
endif

ifndef CODE_386
		push	es			; swap es and ds segments
		push	ds
		pop	es
		pop	ds
endif

		pop	eax
                pop     rdi
                pop     rsi
                pop     rcx
                
; add rx fragment to nic chain (set status to nic)
		mov	[rbx].dma_control, RDMA_FRAGLIST SHR 16
                mov     dword ptr [rbx].dma_status, RDMA_OWNER_STATUS

; start rx (if not already going)
		mov	dx, pAS.io_base
		add	dx, EPC_COMMAND
		mov	ax, CMD_RXQUEUED
		out	dx, ax

		mov	rax, PENDING

lrc_return_wait:
		mov	rcx, 800h

lrc_wait_completion:
		test	dword ptr [rbx].dma_status, RDMA_OWNER_STATUS
		jz	lrc_dma_done
		test	pAS.adapter_flags, ENABLE_RX_PENDING
		jnz	lrc_exit
		push	rcx
		mov	rcx, 80h
		loop	$
		pop	rcx
		loop	lrc_wait_completion

lrc_dma_done:
		or	rcx, rcx
		jz	lrc_out_of_res

lrc_return:
		add	dx, EPC_INT_STATUS - EPC_COMMAND
                mov     ax, INT_RCV_COPY_DONE
		out	dx, ax			; clear receive copy int

		mov	rax, SUCCESS
		mov	dx, [rbx].dma_status
		and	dx, RDMA_CRC_ERR or RDMA_FA_ERR or RDMA_FRAG_LIST_ERR
		jz	lrc_no_errors
		mov	rax, HARDWARE_FAILED		

lrc_no_errors:
		test	dx, RDMA_FRAG_LIST_ERR
		jz	lrc_no_fle
		or	dx, RX_HW_FAILED

lrc_no_fle:
		mov	cx, [rbx].dma_len
		sub	cx, 4

lrc_exit:
                pop     ebx
		mov	bx, dx
                pop     edx
		ret

lrc_out_of_res:
		mov	rax, OUT_OF_RESOURCES
		jmp	lrc_exit

ASM_PCI_PROC_END        LM_Receive_Copy

;****************************************************************************
;
; Function:     LM_Send         
;
; Synopis:      send a packet
;
; Input:        ds:bp (ebp)  AdapterStructure
;		ES:SI (esi)  ptr to data buffer structure
;               CX    (ecx)  Transmit byte count
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    LM_Send

		push    ebx

                push    edx
                push    ecx
		push	eax

		mov     rax, OUT_OF_RESOURCES
                cmp     pAS.adapter_status, OPEN
		jne     LM_Send_done

		cmp     cx, pAS.max_packet_size
		ja      LM_Send_done

		cmp	pAS.tx_free_desc_count, 0
		jz	LM_Send_done
		
; increment retry counter
		inc	pAS.tx_pend
		jz	lms_notxugo
		mov	pAS.tx_pend, ETX_CUTOFF

lms_notxugo:
; if the nic owns this fragment, we are out of buffers
		mov	rbx, pAS.tx_curr_off
                test    [rbx].dma_status, XDMA_OWNER_STATUS
                jne     LM_Send_done

; fragment is ok to use. Initialize the controls
		dec	pAS.tx_free_desc_count
		cmp	pAS.tx_free_desc_count, 1
		jne	LM_Send_above_lo_water
IFDEF DOUBLE_COPY_TX
		and	ecx, 0ffffh
		or	ecx, XDMA_IAF or XDMA_LASTDESC
		mov	dword ptr [rbx].dma_buf_len, ecx
ELSE
		mov	dword ptr [rbx].dma_buf_len, XDMA_IAF or XDMA_FRAGLIST
ENDIF
		jmp	short LM_Send_setup_size
LM_Send_above_lo_water:
IFDEF DOUBLE_COPY_TX
		and	ecx, 0ffffh
		or	ecx, XDMA_LASTDESC
		mov	dword ptr [rbx].dma_buf_len, ecx
ELSE
                mov     dword ptr [rbx].dma_buf_len, XDMA_FRAGLIST
ENDIF
LM_Send_setup_size:

       mov     [rbx].dma_len, cx



IFNDEF DOUBLE_COPY_TX
; initialize the fragment list
                push    rdi
                push    rsi
                push    eax

		mov	eax, 0			; zero upper 16 bits
                mov     rdi, [rbx].dma_buff_off

ifndef CODE_386
		push	es			; swap es and ds segments
		push	ds
		pop	es
		pop	ds
endif

ifndef CODE_386


;;       mov     ecx,    CR0
;;       test    cx, 1
;;       jz      real_mode3

;;db  0F1h    

;;real_mode3:


                lodsw				; get fragment count
else
		lodsd
endif
		mov	rcx, rax
		stosd

tx_frag_loop:
; move a single fragment dw len, dd ptr to dd len, dd ptr
		movsd				; move pointer
ifndef CODE_386
                lodsw				; get fragment length
else
		lodsd
endif
                and     rax, NOT PHYSICAL_ADDR
                stosd
		loop	tx_frag_loop

ifndef CODE_386
		push	es			; swap es and ds segments
		push	ds
		pop	es
		pop	ds
endif

                pop     eax
                pop     rsi
                pop     rdi
ELSE
		push	eax
		push	esi
		push	edi

                mov     rdi, [rbx].dma_buff_off
		mov	ecx, [esi]
		add	esi, 4

tx_double_copy_loop:
		push	esi
		push	ecx

		mov	ecx, [esi+4]
		mov	esi, [esi]
		cmp	ecx, 3
		ja	tx_large
		rep	movsb
		jmp	tx_copy_done
tx_large:
		test	edi, 3
		jz	tx_dword

		mov	eax, edi
		and	eax, 3
		push	ecx
		mov	ecx, 4
		sub	ecx, eax
		mov	eax, ecx
		rep	movsb
		pop	ecx
		sub	ecx, eax
tx_dword:
		mov	eax, ecx
		shr	ecx, 2
		rep	movsd
		mov	ecx, eax
		and	ecx, 3
		jz	tx_copy_done
		rep	movsb
tx_copy_done:
		pop	ecx
		pop	esi
		add	esi, size FragmentStructure
		loop	tx_double_copy_loop

tx_update_curr_buff:
		pop	edi
		pop	esi
		pop	eax

ENDIF

; add tx fragment to nic chain (set status to nic)
                mov     [rbx].dma_status, XDMA_OWNER_STATUS

; start tx (if not already going)
		mov	dx, pAS.io_base

		add	dx, EPC_COMMAND
		mov	ax, CMD_TXQUEUED
		out	dx, ax

; bump tx pointer
		mov	rbx, [rbx].dma_next_off
		mov	pAS.tx_curr_off, rbx

IFDEF DOUBLE_COPY_TX
		mov	rax, SUCCESS
		jmp	LM_Send_done
ENDIF

; we ALWAYS return PENDING, and let UM_Send_Complete finish the transaction
                mov     rax, PENDING
		test	pAS.adapter_flags, ENABLE_TX_PENDING
		jnz	LM_Send_done

		call	init_etx_idle

; do early tx adjustment
		test	eax, INT_XMIT_UNDERRUN
		jz	LM_Send_no_txbump

; wait for txugo to clear (yech!)
lms_tx_wait:
		mov	ax, CMD_TXUGO
		out	dx, ax

IFDEF CODE_386
		push	ebx
		mov	ebx, pAS.ptr_tx_underruns
		add	errptr [ebx], 1
		pop	ebx
ELSE
		push	es
		push	bx
		les	bx, dword ptr pAS.ptr_tx_underruns
		add	errptr es:[bx], 1
		pop	bx
		pop	es
ENDIF

; stop at end of current tx
		mov	ax, CMD_STOP_TDMA
		out	dx, ax
		call	init_etx_idle

		test	eax, INT_XMIT_UNDERRUN
		jnz	lms_tx_wait

		cmp	pAS.early_tx_thresh, ETX_MAX_THRESH
		ja	LM_Send_no_txbump
		cmp	pAS.tx_pend, ETX_CUTOFF
		ja	LM_Send_no_txbump

; update threshold
		add	dx, EPC_XMIT_COPY_THRESH - EPC_COMMAND
		add	pAS.early_tx_thresh, 4
		mov	ax, pAS.early_tx_thresh
		out	dx, ax

		mov	pAS.tx_pend, 0

LM_Send_no_txbump:
		mov	rax, SUCCESS

LM_Send_done:
		mov	rcx, rax		; preserve error code
		pop	eax			; and upper 16 bits
		mov	rax, rcx
                pop     ecx
                pop     edx
		pop     ebx

		ret


ASM_PCI_PROC_END        LM_Send

;****************************************************************************
;
; Function:     CheckMultiAdd   
;
; Synopis:      Compares the address indicated by ES:SI to
;               all addresses in the adapter structure multicast
;               table, and the braodcast address located at BC_ADD
;               in the adapter structure.
;
; Input:        ds:bp (ebp)	AdapterStructure
;               es:si(esi)      data buffer
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

CheckMultiAdd   proc    near
			push    esi
			push    edi
			push    edx
			push    ecx
			push    ebx

			mov     rcx, MC_TABLE_ENTRIES+1  ; # of MC table entries
							; + broadcast address
							; entry.
			mov     rdi, rsi
			lea     rsi, pAS.bc_add         ; Start with b'cast
			test    pAS.receive_mask, ACCEPT_BROADCAST
			jnz     DontSkipBCAdd
			dec     rcx                      ; Decrement entry cnt
			lea     rsi, pAS.mc_table        ; Skip b'cast entry
DontSkipBCAdd:
			cld

GoopLoop:               push    esi
			push    edi
			push    ecx
			mov     rcx, 3
			repz    cmpsw
			pop     ecx
			pop     edi
			pop     esi
			jnz     TryNextAdd
			cmp     byte ptr [rsi+6], 0h     ; If inst. count = 0,
							; entry is invalid.
			je      AddHas0Cnt
			mov     rbx, SUCCESS
			jmp     CheckMADone     ; All Done

TryNextAdd:             add     rsi, 7          ; Point to next address
			loop    GoopLoop        ; Check all addresses
						; If all entries checked and
						; no matches, bail out.

AddHas0Cnt:             mov     rbx, OUT_OF_RESOURCES

CheckMADone:
			mov     rax, rbx          ; Get return code into AX

			pop     ebx
			pop     ecx
			pop     edx
			pop     edi
			pop     esi
			ret

CheckMultiAdd          endp

;****************************************************************************
;
; Function:     LM_Service_Events       
;
; Synopis:      Interrupt event handling routine.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    LM_Service_Events

		PUSH_ES
		push	ebx
                push    eax
		push	ecx
                push    edx
		push	edi

; test for software interrupt
		cmp	pAS.int_bit, 0
		jnz	lmse_handle_sw_int

; test for normal interrupt
		mov	dx, pAS.io_base
		add	dx, EPC_INT_STATUS
		in	eax, dx
		test	eax, INT_ACTIVE
                je      lmse_not_my_interrupt
		jmp	short lmse_initial_loop		
lmse_loop:
; main interrupt loop entry point
		in	eax, dx
		test	eax, INT_ACTIVE
                je      lmse_done_ok

lmse_initial_loop:
; scan the status for set interrupts
; test for receive complete
                test    eax, INT_RCV_COPY_DONE or INT_HEADER_COPY_DONE
                jne     lmse_receive_route

; handle transmit underrun
                test    eax, INT_XMIT_UNDERRUN
                jne     lmse_tx_error

; test for transmit complete
                test    eax, INT_XMIT_DONE or INT_XMIT_CHAIN_DONE
                jne     lmse_xmit_complete

; handle counter errors
                test    eax, INT_CNTR_OVERFLOW
                jne     lmse_counter_error

; handle soft errors
                test    eax, INT_RCV_ERR or INT_RCV_BUFF_OVERFLOW
                jne     lmse_soft_error

; handle end of queue situations
                test    eax, INT_RCV_QUEUE_EMPTY or INT_XMIT_QUEUE_EMPTY   
                jne     lmse_queue_error

; check for a pci bus error
; ( a pci error is considered fatal)
                test    eax, PTA or PMA or APE or DPE
                jne     lmse_hard_error

; check for a threshold interrupt
		test	eax, INT_RCV_COPY_THRESH
		jne	lmse_clear_thresh_copy

; check for a phy interrupt
                test    eax, INT_PHY_EVENT
                jnz     lmse_phy_int

lmse_done_ok:
                mov     rax, SUCCESS

lmse_done:
		pop	edi
                pop     edx
		pop	ecx
                mov     rbx, rax
                pop     eax
                mov     rax, rbx             ; restore return code
		pop	ebx
		POP_ES
        	ret

lmse_handle_sw_int:
		mov	dx, pAS.io_base
		add	dx, EPC_GEN_CONTROL
		in	eax, dx
                and     eax, NOT GC_SW_INT      ; clear sw int
		out	dx, eax
		dec	pAS.int_bit
		inc	pAS.hdw_int
		call	UM_Interrupt
		mov	dx, pAS.io_base
		add	dx, EPC_INT_STATUS
                jmp     lmse_loop

lmse_clear_thresh_copy:
		and	ax, INT_RCV_COPY_THRESH
		out	dx, ax
                jmp     lmse_loop


lmse_receive_route:
                and     ax, INT_HEADER_COPY_DONE or INT_RCV_COPY_DONE
		out	dx, ax

		mov	rdi, pAS.rx_curr_fraglist
		test	[rdi].dma_control, RDMA_HEADER SHR 16
		jz	lmse_receive_copy
		jmp	lmse_early_receive

lmse_tx_error:
		add	dx, EPC_COMMAND - EPC_INT_STATUS

lmse_tx_error1:
		mov	ax, CMD_TXUGO
		out	dx, ax

IFDEF CODE_386
		mov	ebx, pAS.ptr_tx_underruns
		add	errptr [ebx], 1
ELSE
		push	es
		les	bx, dword ptr pAS.ptr_tx_underruns
		add	errptr es:[bx], 1
		pop	es
ENDIF

; stop at end of current tx
		mov	ax, CMD_STOP_TDMA
		out	dx, ax

; wait for transmitter to go idle
		call	init_etx_idle

		test	eax, INT_XMIT_UNDERRUN
		jnz	lmse_tx_error1

; do early tx adjustment
		cmp	pAS.tx_pend, ETX_CUTOFF
		ja	lmse_etx_reset

		cmp	pAS.early_tx_thresh, ETX_MAX_THRESH
		ja	lmse_etx_reset

; update threshold
		add	dx, EPC_XMIT_COPY_THRESH - EPC_COMMAND
		add	pAS.early_tx_thresh, 4
		mov	ax, pAS.early_tx_thresh
		out	dx, ax
		add	dx, EPC_COMMAND - EPC_XMIT_COPY_THRESH
		mov	pAS.tx_pend, 0

lmse_etx_reset:
		add	dx, EPC_INT_STATUS - EPC_COMMAND
                jmp     lmse_loop

; handle counter errors
lmse_counter_error:
                and     ax, INT_CNTR_OVERFLOW
		out	dx, ax

		add	dx, EPC_CRC_ERR_CNT - EPC_INT_STATUS
		in	al, dx
		movzx	errAX, al

IFDEF CODE_386
		mov	ebx, pAS.ptr_rx_CRC_errors
		add	errptr [ebx], errAX
ELSE
		push	es
		les	bx, dword ptr pAS.ptr_rx_CRC_errors
		add	errptr es:[bx], errAX
		pop	es
ENDIF

		add	dx, EPC_FA_ERR_CNT - EPC_CRC_ERR_CNT
		in	al, dx
		movzx	errAX, al

IFDEF CODE_386
		mov	ebx, pAS.ptr_rx_align_errors
		add	errptr [ebx], errAX
ELSE
		push	es
		les	bx, dword ptr pAS.ptr_rx_align_errors
		add	errptr es:[bx], errAX
		pop	es
ENDIF

		add	dx, EPC_MISSED_PKT_CNT - EPC_FA_ERR_CNT
		in	al, dx
		movzx	errAX, al

IFDEF CODE_386
		mov	ebx, pAS.ptr_rx_lost_pkts
		add	errptr [ebx], errAX
ELSE
		push	es
		les	bx, dword ptr pAS.ptr_rx_lost_pkts
		add	errptr es:[bx], errAX
		pop	es
ENDIF

		add	dx, EPC_INT_STATUS - EPC_MISSED_PKT_CNT
		jmp	lmse_loop

; handle soft errors
lmse_soft_error:
		test	ax, INT_RCV_BUFF_OVERFLOW
		jz	lmse_no_ovw
IFDEF CODE_386
		mov	ebx, pAS.ptr_rx_overruns
		add	errptr [ebx], 1
ELSE
		push	es
		les	bx, dword ptr pAS.ptr_rx_overruns
		add	errptr es:[bx], 1
		pop	es
ENDIF

; see if receiver hung
		push	ax
		add	dx, EPC_COMMAND - EPC_INT_STATUS
		in	ax, dx
		test	ax, CMD_NEXTFRAME
		jz	lmse_no_nextframe_err

; requeue receive
		mov	ax, CMD_RXQUEUED
		out	dx, ax

lmse_no_nextframe_err:
		add	dx, EPC_INT_STATUS - EPC_COMMAND		
		pop	ax

lmse_no_ovw:
                and     ax, INT_RCV_ERR or INT_RCV_BUFF_OVERFLOW
		out	dx, ax
                jmp     lmse_loop

; handle end of queue situations
lmse_queue_error:
                and     ax, INT_RCV_QUEUE_EMPTY or INT_XMIT_QUEUE_EMPTY
		out	dx, ax
                jmp     lmse_loop

; check for a pci bus error
; (a pci error is considered fatal)
lmse_hard_error:
                and     eax, PTA or PMA or APE or DPE
		out	dx, eax

                mov     ax, HARDWARE_FAILED
                jmp     lmse_done

lmse_not_my_interrupt:
                mov     ax, NOT_MY_INTERRUPT
                jmp     lmse_done

check_multicast:
		call	CheckMultiAdd
		cmp	rax, SUCCESS
		jne	lse_bad_packet
		jmp	return_multicast

; test for early receive
lmse_early_receive:
		PUSH_ES
		push	esi
		push	ebx

		mov	rbx, pAS.rx_curr_lookahead
		mov	rsi, [rbx].dma_buff_off
ifndef CODE_386
		mov	es, word ptr pAS.host_ram_virt_addr+2
		test	byte ptr es:[si], 01h	; check for multicast packet
else
		test	byte ptr [esi], 01h
endif
		jz	return_multicast
		test	pAS.receive_mask, ACCEPT_MULTI_PROM
		jnz	return_multicast
		jmp	check_multicast

return_multicast:
; check NW_STATUS_VALID before checking CRC & FA error bits
		mov	ax, [rbx].dma_status
		test	ax, RDMA_NW_STATUS_VALID
		jnz	get_error_status

		xor	bx, bx
		mov	rcx, 0
		jmp	short call_umac

get_error_status:
IFDEF CODE_386
		xor	ecx, ecx
ENDIF
		mov	cx, [rbx].dma_len
		sub	cx, 4
		mov	bx, ax
		and	bx, RDMA_CRC_ERR or RDMA_FA_ERR
		jz	call_umac
IFDEF CODE_386
		mov	ebx, pAS.ptr_rx_CRC_errors
		add	errptr [ebx], 1
ELSE
		push	es
		les	bx, dword ptr pAS.ptr_rx_CRC_errors
		add	errptr es:[bx], 1
		pop	es
ENDIF
		mov	bx, ax
		and	bx, RDMA_CRC_ERR or RDMA_FA_ERR
call_umac:
		push	edx

		call	UM_Receive_Packet
	
		pop	edx

lse_bad_packet:
		pop	ebx
		pop	esi
		POP_ES

		cmp	rax, PENDING		; don't get next packet
		je	lmse_loop

; set up current rx descriptor as the header desc
lse_next_rxqueue:
		push	ebx
		push	eax

		mov	rbx, pAS.rx_curr_fraglist
		mov	rbx, [rbx].dma_next_off
		mov	pAS.rx_curr_lookahead, rbx
		mov	pAS.rx_curr_fraglist, rbx
		mov	dword ptr [rbx].dma_status, RDMA_OWNER_STATUS
		movzx	eax, pAS.rx_lookahead_size
		shl	eax, 4				; 16 byte increment
		or	eax, RDMA_HEADER
		mov	dword ptr [rbx].dma_buf_len, eax

		add	dx, EPC_COMMAND - EPC_INT_STATUS
		mov	ax, CMD_NEXTFRAME or CMD_RXQUEUED
		out	dx, ax
		add	dx, EPC_INT_STATUS - EPC_COMMAND

lse_rx_pend:
		pop	eax
		pop	ebx

		cmp	rax, EVENTS_DISABLED
		je	lmse_done		; stop processing ints
                jmp     lmse_loop

; test for receive complete
lmse_receive_copy:
IFDEF FREEBUFF
lmse_receive_copy_loop:
		cmp	pAS.num_rx_free_buffs, 0
		jz	lmse_loop
		mov	rdi, pAS.rx_curr_fraglist
		mov	bx, [rdi].dma_status
		test	bx, RDMA_OWNER_STATUS
		jnz	lmse_loop
		and	bx, NOT RX_HW_FAILED
		test	bx, RDMA_FRAG_LIST_ERR
		jz	lmse_no_fraglist_err
		add	dx, EPC_COMMAND - EPC_INT_STATUS
		mov	ax, CMD_NEXTFRAME
		out	dx, ax
		add	dx, EPC_INT_STATUS - EPC_COMMAND

lmse_hw_failed:
		or	bx, RX_HW_FAILED
		mov	rax, HARDWARE_FAILED
		jmp	short lmse_call_upper

lmse_no_fraglist_err:
		test	bx, RDMA_NW_STATUS_VALID
		jz	lmse_hw_failed

		mov	cx, [rdi].dma_len
		sub	cx, 4			; minus CRC

; XC bugfix (removed)
;		cmp	cx, 600h
;		jae	lmse_hw_failed

lmse_size_ok:
		and	bx, RDMA_CRC_ERR or RDMA_FA_ERR
		mov	rax, SUCCESS

lmse_call_upper:
IFNDEF CODE_386
		push	dx
		mov	dx, word ptr [di].dma_handle+2
		mov	di, word ptr [di].dma_handle
ELSE
		mov	edi, [edi].dma_handle
ENDIF
		call	UM_Receive_Packet
		dec	pAS.num_rx_free_buffs

IFDEF CODE_386
		or	esi, esi
ELSE
		mov	ax, es
		or	ax, si
ENDIF
		jz	no_new_frag
		call	LM_Put_Rx_Frag
no_new_frag:
IFNDEF CODE_386
		pop	dx
ENDIF
		mov	rdi, pAS.rx_curr_fraglist
		mov	rdi, [rdi].dma_next_off
		mov	pAS.rx_curr_fraglist, rdi
		jmp	lmse_receive_copy_loop

ELSE	; NOT FREEBUFF

		test	pAS.adapter_flags, ENABLE_RX_PENDING
		jz	lmse_loop	; next descriptor already q'd

		mov	rax, SUCCESS

; check packet status
		mov	rdi, pAS.rx_curr_fraglist
		mov	bx, [rdi].dma_status

		test	bx, RDMA_OWNER_STATUS
		jnz	lmse_bad_copy

		test	bx, RDMA_NW_STATUS_VALID
		jz	lmse_bad_copy

		and	bx, RDMA_CRC_ERR or RDMA_FA_ERR

; set packet length
		mov	cx, [rdi].dma_len
		sub	cx, 4			; remove CRC length

; XC bugfix (removed)
;		cmp	cx, 600h		; hw bug check
;		jae	lmse_bad_copy

lmse_good_copy:
		call	UM_Receive_Copy_Complete

		
; check for pending return
		cmp	rax, PENDING
		je	lmse_loop
		jmp	lse_next_rxqueue

lmse_bad_copy:
                mov     rax, HARDWARE_FAILED
		and	bx, RDMA_CRC_ERR or RDMA_FA_ERR
		or	bx, RX_HW_FAILED
		jmp	lmse_good_copy

ENDIF	; FREEBUFF

; test for transmit complete
lmse_xmit_complete:
                and     ax, INT_XMIT_CHAIN_DONE or INT_XMIT_DONE
		out	dx, ax

		mov	cx, pAS.num_of_tx_buffs
lmse_xmit_complete_loop:
		cmp	pAS.tx_free_desc_count, cx
		jz	lmse_loop		; no more outstanding xmits

		mov	rsi, pAS.tx_first_off
		mov	rax, SUCCESS
		mov	bx, [rsi].dma_status
		test	bx, XDMA_OWNER_STATUS
		jnz	lmse_loop

		test	bx, XDMA_XMIT_OK
		jnz	lmse_no_excess_coll
		test	bx, XDMA_EXCESSIVE_COLL
		jz	lmse_no_excess_coll
		mov	rax, MAX_COLLISIONS
IFDEF CODE_386
		mov     ebx, pAS.ptr_tx_max_collisions
		add     errptr [ebx], 1
ELSE
		push    es
		les     bx, dword ptr pAS.ptr_tx_max_collisions
		add     errptr es:[bx], 1
		pop     es
ENDIF
		jmp	short lmse_call_umsc

lmse_no_excess_coll:
		test	bx, XDMA_XMIT_WITH_COLL
		jz	lmse_no_coll
IFDEF CODE_386
		mov     ebx, pAS.ptr_tx_total_collisions
		add     errptr [ebx], 1			; add 1 for now
ELSE
		push    es
		les     bx, dword ptr pAS.ptr_tx_total_collisions
		add     errptr es:[bx], 1
		pop     es
ENDIF
		jmp	short lmse_call_umsc
lmse_no_coll:
		test	bx, XDMA_NON_DEFERRED_XMIT
		jnz	lmse_call_umsc
IFDEF CODE_386
		mov     ebx, pAS.ptr_tx_deferred
		add     errptr [ebx], 1
ELSE
		push    es
		les     bx, dword ptr pAS.ptr_tx_deferred
		add     errptr es:[bx], 1
		pop     es
ENDIF
lmse_call_umsc:
		inc	pAS.tx_free_desc_count
		push	ecx
		call	UM_Send_Complete
		pop	ecx
; update first transmit pointer
		mov	rsi, pAS.tx_first_off
		mov	rsi, [rsi].dma_next_off
		mov	pAS.tx_first_off, rsi

		cmp	rax, EVENTS_DISABLED
		je	lmse_done		; stop processing ints

		jmp	lmse_xmit_complete_loop

public lmse_phy_int
lmse_phy_int:
                call    handle_phy_event

        	mov	dx, pAS.io_base
	        add	dx, EPC_INT_STATUS
                in      ax, dx
                and     ax, INT_PHY_EVENT
	        out	dx, ax
                jmp     lmse_loop

ASM_PCI_PROC_END        LM_Service_Events

;****************************************************************************
;
; Function:     LM_Set_Funct_Address 
;
; Synopis:      returns INVALID_FUNCTION for Ethernet.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    LM_Set_Funct_Address

		mov     rax, INVALID_FUNCTION
		ret
ASM_PCI_PROC_END        LM_Set_Funct_Address

;****************************************************************************
;
; Function:     LM_Set_Group_Address 
;
; Synopis:      returns INVALID_FUNCTION for Ethernet.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    LM_Set_Group_Address

		mov     rax, INVALID_FUNCTION
		ret

ASM_PCI_PROC_END        LM_Set_Group_Address
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\imirror\mirror.c ===
/*
Module Name:

    mirror.c

Abstract:

    This module implements routines to copy up a tree to a destination.

Author:

    Andy Herron May 27 1998

Revision History:

*/

#include "precomp.h"
#pragma hdrstop

#define RNDM_CONSTANT   314159269    /* default scrambling constant */
#define RNDM_PRIME     1000000007    /* prime number for scrambling  */

//
// Compute a string hash value that is invariant to case
//
#define COMPUTE_STRING_HASH( _pus, _phash ) {                \
    PWCHAR _p = _pus;                                        \
    ULONG _chHolder =0;                                      \
                                                             \
    while( *_p != L'\0' ) {                                  \
        _chHolder = 37 * _chHolder + (unsigned int) *(_p++); \
    }                                                        \
                                                             \
    *(_phash) = abs(RNDM_CONSTANT * _chHolder) % RNDM_PRIME; \
}


BOOLEAN IMirrorUpdatedTokens = FALSE;

//
//  this is the structure we use to track what files already exist on the
//  destination
//

typedef struct _EXISTING_MIRROR_FILE {
    LIST_ENTRY ListEntry;
    DWORD  NameHashValue;
    DWORD  FileAttributes;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    ULONG  FileNameLength;
    ULONG  EaSize;
    WCHAR  FileName[1];
} EXISTING_MIRROR_FILE, *PEXISTING_MIRROR_FILE;

//
//  this is the structure we use to track the directories that we still need
//  to copy.
//

typedef struct _COPY_DIRECTORY {
    LIST_ENTRY ListEntry;
    PCOPY_TREE_CONTEXT CopyContext;

    BOOLEAN DirectoryRoot;      // is this the root of the volume?
    DWORD  SourceAttributes;
    PWCHAR Source;
    PWCHAR Dest;
    PWCHAR NtSourceName;
    PWCHAR NtDestName;
    WCHAR  SourceBuffer[1];
} COPY_DIRECTORY, *PCOPY_DIRECTORY;

DWORD
CreateMatchingDirectory (
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    PCOPY_DIRECTORY DirectoryInfo
    );

DWORD
MirrorFile(
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    PWCHAR SourceFileName,
    PFILE_FULL_DIR_INFORMATION SourceFindData,
    PWCHAR DestFileName,
    PEXISTING_MIRROR_FILE ExistingMirrorFile
    );

DWORD
UnconditionalDelete (
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    PWCHAR SourceFile,
    PWCHAR FileToDelete,
    DWORD  Attributes,
    PWCHAR NameBuffer
    );

DWORD
StoreOurSecurityStream (
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    PWCHAR Source,
    PWCHAR Dest,
    DWORD  AttributesToStore,
    LARGE_INTEGER ChangeTime
    );

DWORD
StoreOurSFNStream (
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    PWCHAR Source,
    PWCHAR Dest,
    PWCHAR ShortFileName
    );


DWORD
GetOurSecurityStream (
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    PWCHAR Dest,
    PMIRROR_ACL_STREAM MirrorAclStream
    );

DWORD
GetOurSFNStream (
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    PWCHAR Dest,
    PMIRROR_SFN_STREAM MirrorSFNStream,
    PWCHAR SFNBuffer,
    DWORD  SFNBufferSize
    );


DWORD
CopySubtree(
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    PCOPY_DIRECTORY DirectoryInfo
    );

BOOL
IMSetFileTime(
    HANDLE hFile,
    CONST FILETIME *lpCreationTime,
    CONST FILETIME *lpLastAccessTime,
    CONST FILETIME *lpLastWriteTime,
    CONST FILETIME *lpChangeTime
    );

DWORD
IMirrorOpenDirectory (
    HANDLE *Handle,
    PWCHAR NtDirName,
    DWORD Disposition,
    BOOLEAN IsSource,
    DWORD SourceAttributes,
    PFILE_BASIC_INFORMATION BasicDirInfo OPTIONAL
    );

NTSTATUS
CanHandleReparsePoint (
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    PWCHAR SourceFileName,
    DWORD FileAttributes
    );

DWORD
AllocateCopyTreeContext (
    PCOPY_TREE_CONTEXT *CopyContext,
    BOOLEAN DeleteOtherFiles
    )
/*++

Description:

    This routine allocates the necessary structure that we pass around
    that contains all of our "global" data during copying a large tree.

Parameters:

    CopyContext : Location to put allocated structure.

    DeleteOtherFiles : Do we remove files and dirs that aren't on the master?

Return Value:

    Win32 error code

++*/
{
    PCOPY_TREE_CONTEXT context;

    *CopyContext = IMirrorAllocMem(sizeof( COPY_TREE_CONTEXT ));

    context = *CopyContext;

    if (context == NULL) {

        return GetLastError();
    }

    InitializeListHead( &(context->PendingDirectoryList) );
    InitializeCriticalSection( &(context->Lock) );
    context->Cancelled = FALSE;
    context->DeleteOtherFiles = DeleteOtherFiles;

    return ERROR_SUCCESS;
}


VOID
FreeCopyTreeContext (
    PCOPY_TREE_CONTEXT CopyContext
    )
/*++

Description:

    This routine frees the necessary structures that we pass around
    that contains all of our "global" data during copying a large tree.

Parameters:

    CopyContext : Structure that is no longer needed.

Return Value:

    None

++*/
{
    while (IsListEmpty( &(CopyContext->PendingDirectoryList) ) == FALSE) {

        PCOPY_DIRECTORY copyDir;
        PLIST_ENTRY listEntry = RemoveHeadList( &(CopyContext->PendingDirectoryList) );

        copyDir = (PCOPY_DIRECTORY) CONTAINING_RECORD(  listEntry,
                                                        COPY_DIRECTORY,
                                                        ListEntry );

        IMirrorFreeMem( copyDir );
    }

    DeleteCriticalSection( &CopyContext->Lock );
    return;
}

DWORD
CopyTree (
    PCOPY_TREE_CONTEXT CopyContext,
    BOOLEAN IsNtfs,
    PWCHAR SourceRoot,
    PWCHAR DestRoot
    )
/*++

Description:

    This is the main routine that initiates the full subtree copy.

Parameters:

    CopyContext : Structure that is no longer needed.

    SourceRoot  : source tree to copy in NT format, not DOS format.

    DestRoot    : location to copy it to

Return Value:

    Win32 error code

++*/
{
    DWORD err;
    DWORD sourceAttributes;
    IMIRROR_THREAD_CONTEXT threadContext;
    COPY_DIRECTORY rootDir;
    //
    //  if we were to create multiple threads handling copying this subtree,
    //  this is where we'll setup the threads where each has their own
    //  thread context.
    //

    if (! IMirrorUpdatedTokens) {

        HANDLE hToken;

        // Enable the privileges necessary to copy security information.

        err = GetTokenHandle(&hToken);

        if (err == ERROR_SUCCESS) {

            SetPrivs(hToken, TEXT("SeSecurityPrivilege"));
            IMirrorUpdatedTokens = TRUE;
        }
    }

retryCopyTree:

    RtlZeroMemory( &threadContext, sizeof( threadContext ));
    threadContext.CopyContext = CopyContext;
    threadContext.IsNTFS = IsNtfs;
    threadContext.SourceDirHandle = INVALID_HANDLE_VALUE;
    threadContext.DestDirHandle = INVALID_HANDLE_VALUE;
    threadContext.SDBufferLength = IMIRROR_INITIAL_SD_LENGTH;
    threadContext.SFNBufferLength = IMIRROR_INITIAL_SFN_LENGTH;

    InitializeListHead( &threadContext.FilesToIgnore );

    sourceAttributes = GetFileAttributes( SourceRoot );

    if (sourceAttributes == (DWORD) -1) {

        ULONG action;

        err = GetLastError();
        action = ReportCopyError( CopyContext,
                                  SourceRoot,
                                  COPY_ERROR_ACTION_GETATTR,
                                  err );
        if (action == STATUS_RETRY) {

            goto retryCopyTree;

        } else if (action == STATUS_REQUEST_ABORTED) {

            goto exitCopyTree;
        }

        //
        //  the user told us to ignore the error.  we'll do our best.
        //
        sourceAttributes = FILE_ATTRIBUTE_DIRECTORY;
    }

    err = GetRegistryFileList( &threadContext.FilesToIgnore );
    if( err != NO_ERROR ) {
        goto exitCopyTree;
    }

    RtlZeroMemory( &rootDir, sizeof( COPY_DIRECTORY ));
    rootDir.CopyContext = CopyContext;
    rootDir.DirectoryRoot = TRUE;
    rootDir.SourceAttributes = sourceAttributes;
    rootDir.Source = SourceRoot;
    rootDir.Dest = DestRoot;

    err = CopySubtree( &threadContext,
                       &rootDir
                       );

    ASSERT( threadContext.SourceDirHandle == INVALID_HANDLE_VALUE );
    ASSERT( threadContext.DestDirHandle == INVALID_HANDLE_VALUE );

    EnterCriticalSection( &CopyContext->Lock );

    while ((CopyContext->Cancelled == FALSE) &&
           (IsListEmpty( &(CopyContext->PendingDirectoryList) ) == FALSE)) {

        PCOPY_DIRECTORY copyDir;
        PLIST_ENTRY listEntry = RemoveHeadList( &(CopyContext->PendingDirectoryList) );

        copyDir = (PCOPY_DIRECTORY) CONTAINING_RECORD(  listEntry,
                                                        COPY_DIRECTORY,
                                                        ListEntry );
        LeaveCriticalSection( &CopyContext->Lock );

        err = CopySubtree(  &threadContext,
                            copyDir
                            );

        ASSERT( threadContext.SourceDirHandle == INVALID_HANDLE_VALUE );
        ASSERT( threadContext.DestDirHandle == INVALID_HANDLE_VALUE );

        IMirrorFreeMem( copyDir );

        EnterCriticalSection( &CopyContext->Lock );
    }

exitCopyTree:

    if (threadContext.SDBuffer) {

        IMirrorFreeMem( threadContext.SDBuffer );
    }
    if (threadContext.SFNBuffer) {

        IMirrorFreeMem( threadContext.SFNBuffer );
    }
    if (threadContext.DirectoryBuffer) {

        IMirrorFreeMem( threadContext.DirectoryBuffer );
    }
    if ( threadContext.FindBufferBase ) {

        IMirrorFreeMem( threadContext.FindBufferBase );
    }

    while (IsListEmpty( &(threadContext.FilesToIgnore) ) == FALSE) {

        PIMIRROR_IGNORE_FILE_LIST ignoreListEntry;
        PLIST_ENTRY listEntry = RemoveHeadList( &(threadContext.FilesToIgnore) );

        ignoreListEntry = (PIMIRROR_IGNORE_FILE_LIST)
                            CONTAINING_RECORD(  listEntry,
                                                IMIRROR_IGNORE_FILE_LIST,
                                                ListEntry );
        IMirrorFreeMem( ignoreListEntry );
    }

    return err;
}


DWORD
CopySubtree(
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    PCOPY_DIRECTORY DirectoryInfo
    )
/*++

Description:

    This routine enumerates the directories on the client to continue
    traversing the tree.   It then enumerates the files on the slave
    ( to compare them against what is on the master ), it then ensures
    that all files on the master are up on the slave.  It then deletes all
    files on the slave that are not on the master.

Parameters:

    ThreadContext   : data for this instance of copying a tree

    DirectoryInfo   : information on the source and dest that we know of

Return Value:

    Win32 error code
++*/
{
    DWORD err;
    PWCHAR destFileName;
    PWCHAR sourceFileName;
    ULONG destFileNameSize;
    ULONG sourceFileNameSize;
    PWCHAR endOfSourcePath;
    PWCHAR endOfDestPath = NULL;
    LIST_ENTRY existingMirrorFilesList;
    PLIST_ENTRY listEntry;
    PEXISTING_MIRROR_FILE existingMirrorFile;
    BOOLEAN deleteExistingMirrorFilesNotInMaster;
    PCOPY_TREE_CONTEXT copyContext;
    UNICODE_STRING ntSourcePath;
    UNICODE_STRING ntDestPath;
    PFILE_FULL_DIR_INFORMATION findData;
    ULONG errorCase;
    
    
retryCopySubtree:

    errorCase = ERROR_SUCCESS;
    destFileName = NULL;
    sourceFileName = NULL;
    deleteExistingMirrorFilesNotInMaster = FALSE;
    copyContext = ThreadContext->CopyContext;

    InitializeListHead( &existingMirrorFilesList );
    RtlInitUnicodeString( &ntSourcePath, NULL );
    RtlInitUnicodeString( &ntDestPath, NULL );

    //
    //  since some of the NT specific calls use the NT format of the name,
    //  we grab that up front so as not to have to do it every time.
    //

    if (RtlDosPathNameToNtPathName_U(   DirectoryInfo->Source,
                                        &ntSourcePath,
                                        NULL,
                                        NULL ) == FALSE) {

        //err = STATUS_OBJECT_PATH_NOT_FOUND;
        err = ERROR_PATH_NOT_FOUND;

        errorCase = ReportCopyError(  copyContext,
                                      DirectoryInfo->Source,
                                      COPY_ERROR_ACTION_OPEN_DIR,
                                      err );
        goto exitCopySubtree;
    }

    if (RtlDosPathNameToNtPathName_U(   DirectoryInfo->Dest,
                                        &ntDestPath,
                                        NULL,
                                        NULL ) == FALSE) {

        //err = STATUS_OBJECT_PATH_NOT_FOUND;
        err = ERROR_PATH_NOT_FOUND;

        errorCase = ReportCopyError(  copyContext,
                                      DirectoryInfo->Dest,
                                      COPY_ERROR_ACTION_OPEN_DIR,
                                      err );
        goto exitCopySubtree;
    }

    DirectoryInfo->NtSourceName = ntSourcePath.Buffer;
    DirectoryInfo->NtDestName = ntDestPath.Buffer;

    //
    //  Create a directory on the slave that matches this one.  This will
    //  open handles to both the source and dest directories.  We cache the
    //  handle in case other operations need it.
    //

    err = CreateMatchingDirectory( ThreadContext, DirectoryInfo );
    if (err != ERROR_SUCCESS) {
        goto exitCopySubtree;
    }

    destFileNameSize = (lstrlenW( DirectoryInfo->Dest ) + 5 + MAX_PATH) * sizeof(WCHAR);
    destFileName = IMirrorAllocMem( destFileNameSize );

    if (destFileName == NULL) {

        err = GetLastError();

        errorCase = ReportCopyError(  copyContext,
                                      DirectoryInfo->Dest,
                                      COPY_ERROR_ACTION_MALLOC,
                                      err );
        goto exitCopySubtree;
    }

    lstrcpyW( destFileName, DirectoryInfo->Dest );
    lstrcatW( destFileName, L"\\" );

    
    // track the next character after the trailing backslash

    endOfDestPath = destFileName + lstrlenW( destFileName );

    sourceFileNameSize = (lstrlenW( DirectoryInfo->Source ) + 5 + MAX_PATH) * sizeof(WCHAR);
    sourceFileName = IMirrorAllocMem( sourceFileNameSize );

    if (sourceFileName == NULL) {

        err = GetLastError();

        errorCase = ReportCopyError(  copyContext,
                                      DirectoryInfo->Source,
                                      COPY_ERROR_ACTION_MALLOC,
                                      err );
        goto exitCopySubtree;
    }
    
    lstrcpyW( sourceFileName, DirectoryInfo->Source );
    if (!DirectoryInfo->DirectoryRoot) {
        lstrcatW( sourceFileName, L"\\" );
    }


    // track the next character after the trailing backslash

    endOfSourcePath = sourceFileName + lstrlenW( sourceFileName );

    //
    //  enumerate all files/directories on the target so that we have the
    //  details to grovel correctly.
    //

    err = IMFindFirstFile( ThreadContext,
                           ThreadContext->DestDirHandle,
                           &findData );

    while ( findData != NULL &&
            err == ERROR_SUCCESS &&
            copyContext->Cancelled == FALSE) {

        InterlockedIncrement( (PLONG) &copyContext->DestFilesScanned ); // this is really a ULONG

        if (((findData->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0) &&
             (findData->FileName[0] == L'.')) {

            if ((findData->FileNameLength == sizeof(WCHAR)) ||
                (findData->FileName[1] == L'.' &&
                 findData->FileNameLength == 2*sizeof(WCHAR))) {

                goto skipToNextDir1;
            }
        }

        if (DirectoryInfo->DirectoryRoot &&
            ((findData->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) &&
            ((!_wcsnicmp(&findData->FileName[0],
                         L"pagefile.sys",
                         findData->FileNameLength)) ||
             (!_wcsnicmp(&findData->FileName[0],
                         L"hiberfil.sys",
                         findData->FileNameLength)))) {

            goto skipToNextDir1;
        }

        
        existingMirrorFile = (PEXISTING_MIRROR_FILE) IMirrorAllocMem(
                        sizeof(EXISTING_MIRROR_FILE) +
                        findData->FileNameLength);

        if (existingMirrorFile == NULL) {

            err = GetLastError();

            errorCase = ReportCopyError(   copyContext,
                                           destFileName,
                                           COPY_ERROR_ACTION_MALLOC,
                                           err );
            goto exitCopySubtree;
        }

        existingMirrorFile->FileAttributes = findData->FileAttributes;
        existingMirrorFile->CreationTime = findData->CreationTime;
        existingMirrorFile->LastWriteTime = findData->LastWriteTime;
        existingMirrorFile->ChangeTime = findData->ChangeTime;
        existingMirrorFile->EndOfFile  = findData->EndOfFile;
        existingMirrorFile->EaSize     = findData->EaSize;
        existingMirrorFile->FileNameLength = findData->FileNameLength;
        
        RtlCopyMemory( &existingMirrorFile->FileName[0],
                       &findData->FileName[0],
                       findData->FileNameLength );
        existingMirrorFile->FileName[ findData->FileNameLength / sizeof(WCHAR) ] = UNICODE_NULL;

        COMPUTE_STRING_HASH( &existingMirrorFile->FileName[0],
                             &existingMirrorFile->NameHashValue );

        InsertTailList( &existingMirrorFilesList, &existingMirrorFile->ListEntry );

skipToNextDir1:

        err = IMFindNextFile( ThreadContext,
                              ThreadContext->DestDirHandle,
                              &findData );
    }

    //
    //  copy all files up from the source to the dest
    //

    err = IMFindFirstFile( ThreadContext,
                           ThreadContext->SourceDirHandle,
                           &findData );

    if (err != ERROR_SUCCESS) {

        if (err == STATUS_NO_MORE_FILES) {

            err = ERROR_SUCCESS;

        } else {
            errorCase = ReportCopyError(  copyContext,
                                          DirectoryInfo->Source,
                                          COPY_ERROR_ACTION_ENUMERATE,
                                          err );
            goto exitCopySubtree;
        }
    }

    while ( findData != NULL &&
            err == ERROR_SUCCESS &&
            copyContext->Cancelled == FALSE) {

        DWORD nameHashValue;

        if (((findData->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0) &&
             (findData->FileName[0] == L'.')) {

            if ((findData->FileNameLength == sizeof(WCHAR)) ||
                (findData->FileName[1] == L'.' &&
                 findData->FileNameLength == 2*sizeof(WCHAR))) {

                goto skipToNextDir;
            }
        }

        if (DirectoryInfo->DirectoryRoot &&
            ((findData->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) &&
            ((!_wcsnicmp(&findData->FileName[0],
                        L"pagefile.sys",
                        findData->FileNameLength)) ||
             (!_wcsnicmp(&findData->FileName[0],
                         L"hiberfil.sys",
                         findData->FileNameLength)))) {

            goto skipToNextDir;
        }

        InterlockedIncrement( (PLONG) &copyContext->SourceFilesScanned ); // this is really a ULONG

        RtlCopyMemory( endOfSourcePath,
                       findData->FileName,
                       findData->FileNameLength );
        *(endOfSourcePath+(findData->FileNameLength/sizeof(WCHAR))) = UNICODE_NULL;

        RtlCopyMemory( endOfDestPath,
                       findData->FileName,
                       findData->FileNameLength );
        *(endOfDestPath+(findData->FileNameLength/sizeof(WCHAR))) = UNICODE_NULL;

        //
        //  search the list of existing files on the target to see if
        //  it's already there.
        //

        COMPUTE_STRING_HASH( endOfDestPath, &nameHashValue );

        listEntry = existingMirrorFilesList.Flink;

        existingMirrorFile = NULL;

        while (listEntry != &existingMirrorFilesList) {

            existingMirrorFile = (PEXISTING_MIRROR_FILE) CONTAINING_RECORD(
                                                    listEntry,
                                                    EXISTING_MIRROR_FILE,
                                                    ListEntry );
            listEntry = listEntry->Flink;

            if ((existingMirrorFile->NameHashValue == nameHashValue) &&
                (existingMirrorFile->FileNameLength == findData->FileNameLength) &&
                (CompareStringW( LOCALE_SYSTEM_DEFAULT,
                                 NORM_IGNORECASE,
                                 endOfDestPath,
                                 findData->FileNameLength / sizeof(WCHAR),
                                 &existingMirrorFile->FileName[0],
                                 existingMirrorFile->FileNameLength / sizeof(WCHAR)) == 2)) {
                break;
            }

            existingMirrorFile = NULL;
        }

        if ((findData->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {

            //
            //  this is a file, let's mirror it up from the master.
            //

            (VOID)MirrorFile(   ThreadContext,
                                sourceFileName,
                                findData,
                                destFileName,
                                existingMirrorFile
                                );
        } else {

            //
            //  it's a directory, put it on the pending list.
            //
            PCOPY_DIRECTORY copyDir;
            ULONG sourceLength;

            sourceLength = lstrlenW( sourceFileName ) + 1;  // space for null
            copyDir = (PCOPY_DIRECTORY) IMirrorAllocMem(
                            sizeof( COPY_DIRECTORY ) +
                            (( sourceLength +
                               lstrlenW( destFileName ) + 1 )
                               * sizeof(WCHAR)));

            if (copyDir == NULL) {

                err = GetLastError();

                errorCase = ReportCopyError(  copyContext,
                                              sourceFileName,
                                              COPY_ERROR_ACTION_MALLOC,
                                              err );
                goto exitCopySubtree;
            }

            //
            //  we save off all info we know about both the source and the
            //  dest so that we don't have to go read it again.
            //

            copyDir->CopyContext = copyContext;
            copyDir->DirectoryRoot = FALSE;
            copyDir->SourceAttributes = findData->FileAttributes;
            copyDir->Source = &copyDir->SourceBuffer[0];
            lstrcpyW( copyDir->Source, sourceFileName );

            copyDir->Dest = &copyDir->SourceBuffer[sourceLength];
            lstrcpyW( copyDir->Dest, destFileName );

            EnterCriticalSection( &copyContext->Lock );

            InsertHeadList( &(copyContext->PendingDirectoryList), &copyDir->ListEntry );

            LeaveCriticalSection( &copyContext->Lock );
        }

        if (existingMirrorFile != NULL) {

            RemoveEntryList( &existingMirrorFile->ListEntry );
            IMirrorFreeMem( existingMirrorFile );
        }

skipToNextDir:
        err = IMFindNextFile( ThreadContext,
                              ThreadContext->SourceDirHandle,
                              &findData );

        if (err != ERROR_SUCCESS) {

            if (err == STATUS_NO_MORE_FILES) {

                err = ERROR_SUCCESS;

            } else {
                errorCase = ReportCopyError(  copyContext,
                                              DirectoryInfo->Source,
                                              COPY_ERROR_ACTION_ENUMERATE,
                                              err );
                goto exitCopySubtree;
            }
        }
    }

    if (err == ERROR_SUCCESS) {

        //
        //  now go through list of remaining files and directories that were on
        //  the destination but not on the source to delete them.  We only do
        //  that if we successfully made it through all existing master files.
        //

        if (copyContext->DeleteOtherFiles) {

            deleteExistingMirrorFilesNotInMaster = TRUE;
        }
    }

exitCopySubtree:

    while (IsListEmpty( &existingMirrorFilesList ) == FALSE) {

        listEntry = RemoveHeadList( &existingMirrorFilesList );

        existingMirrorFile = (PEXISTING_MIRROR_FILE) CONTAINING_RECORD( listEntry,
                                                                EXISTING_MIRROR_FILE,
                                                                ListEntry );
        if ((errorCase == STATUS_SUCCESS) &&
            deleteExistingMirrorFilesNotInMaster &&
            (copyContext->Cancelled == FALSE)) {

            lstrcpyW( endOfDestPath, &existingMirrorFile->FileName[0] );

            UnconditionalDelete(    ThreadContext,
                                    DirectoryInfo->Source,
                                    destFileName,
                                    existingMirrorFile->FileAttributes,
                                    NULL );
        }

        IMirrorFreeMem( existingMirrorFile );
    }

    if (destFileName != NULL) {
        IMirrorFreeMem( destFileName );
    }
    if (sourceFileName != NULL) {
        IMirrorFreeMem( sourceFileName );
    }
    if ( ThreadContext->SourceDirHandle != INVALID_HANDLE_VALUE ) {

        NtClose( ThreadContext->SourceDirHandle );
        ThreadContext->SourceDirHandle = INVALID_HANDLE_VALUE;
    }
    if ( ThreadContext->DestDirHandle != INVALID_HANDLE_VALUE ) {

        NtClose( ThreadContext->DestDirHandle );
        ThreadContext->DestDirHandle = INVALID_HANDLE_VALUE;
    }
    if (ntSourcePath.Buffer) {

        RtlFreeHeap( RtlProcessHeap(), 0, ntSourcePath.Buffer );
    }

    if (ntDestPath.Buffer) {

        RtlFreeHeap( RtlProcessHeap(), 0, ntDestPath.Buffer );
    }

    if (errorCase == STATUS_RETRY) {

        goto retryCopySubtree;
    }
    if ( errorCase == ERROR_SUCCESS ) {
        err = ERROR_SUCCESS;        // we ignore all errors if user told us to
    }
    return err;
}

DWORD
CreateMatchingDirectory (
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    PCOPY_DIRECTORY DirectoryInfo
    )
/*++

Description:

    This routine ensures that the destination directory on the mirror
    matches the source directory.  It doesn't handle the files
    or subdirectories, just the actual directory itself.

Parameters:

    ThreadContext   : instance data for this thread copying a tree

    DirectoryInfo   : structure containing all the info for the directory

Return Value:

    Win32 error code
++*/
{
    FILE_BASIC_INFORMATION sourceDirInfo;
    FILE_BASIC_INFORMATION destDirInfo;
    DWORD err;
    BOOLEAN updateBasic;
    BOOLEAN updateStoredSecurityAttributes;
    BOOLEAN createdDir;
    IO_STATUS_BLOCK IoStatusBlock;
    ULONG errorCase;

retryCreateDir:

    updateBasic = FALSE;
    updateStoredSecurityAttributes = FALSE;
    createdDir = FALSE;

    err = IMirrorOpenDirectory( &ThreadContext->SourceDirHandle,
                                DirectoryInfo->NtSourceName,
                                FILE_OPEN,
                                TRUE,
                                DirectoryInfo->SourceAttributes,
                                &sourceDirInfo
                                );

    if (err != ERROR_SUCCESS) {

        errorCase = ReportCopyError(    ThreadContext->CopyContext,
                                        DirectoryInfo->Source,
                                        COPY_ERROR_ACTION_OPEN_DIR,
                                        err );
        if (errorCase == STATUS_RETRY) {
            goto retryCreateDir;
        }
        if (errorCase == ERROR_SUCCESS) {
            err = ERROR_SUCCESS;
        }
        return err;
    }

    if (DirectoryInfo->SourceAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {

        errorCase = ReportCopyError(    ThreadContext->CopyContext,
                                        DirectoryInfo->Source,
                                        COPY_ERROR_ACTION_OPEN_DIR,
                                        ERROR_REPARSE_ATTRIBUTE_CONFLICT );

        err = ERROR_REPARSE_ATTRIBUTE_CONFLICT;

        if (errorCase == STATUS_RETRY) {
            goto retryCreateDir;
        }
        
        //
        // we can't ever succeed a create request, so don't allow the 
        // code to return ERROR_SUCCESS, instead always force an abort
        //
        if (errorCase == ERROR_SUCCESS) {
            //err = ERROR_SUCCESS;
            err = ERROR_REQUEST_ABORTED;
        }

        return err;
    }

    ASSERT( (DirectoryInfo->SourceAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0);

    err = IMirrorOpenDirectory( &ThreadContext->DestDirHandle,
                                DirectoryInfo->NtDestName,
                                FILE_OPEN,
                                FALSE,
                                FILE_ATTRIBUTE_DIRECTORY,
                                &destDirInfo
                                );

    if (err == STATUS_NOT_A_DIRECTORY) {

        DWORD DestAttributes = GetFileAttributes( DirectoryInfo->Dest );

        //
        //  this is not a directory on the dest, let's delete it.
        //

        DestAttributes &= ~FILE_ATTRIBUTE_DIRECTORY;    // be real sure of this

        err = UnconditionalDelete(  ThreadContext,
                                    DirectoryInfo->Source,
                                    DirectoryInfo->Dest,
                                    DestAttributes,
                                    NULL );
        if (err != ERROR_SUCCESS) {
            return err;
        }
    }

    if (ThreadContext->DestDirHandle == INVALID_HANDLE_VALUE) {

        //
        //  try to create the destination directory from the source
        //

        err = IMirrorOpenDirectory( &ThreadContext->DestDirHandle,
                                    DirectoryInfo->NtDestName,
                                    FILE_CREATE,
                                    FALSE,
                                    FILE_ATTRIBUTE_DIRECTORY,
                                    &destDirInfo
                                    );

        // report either success or failure up to the caller

        if (!NT_SUCCESS( err )) {

            errorCase = ReportCopyError(    ThreadContext->CopyContext,
                                            DirectoryInfo->Dest,
                                            COPY_ERROR_ACTION_CREATE_DIR,
                                            err );
            if (errorCase == STATUS_RETRY) {
                goto retryCreateDir;
            }
            if (errorCase == ERROR_SUCCESS) {
                err = ERROR_SUCCESS;
            }
            return err;
        }

        //
        //  this is for the success case so it won't fail.
        //

        ReportCopyError(   ThreadContext->CopyContext,
                           DirectoryInfo->Dest,
                           COPY_ERROR_ACTION_CREATE_DIR,
                           ERROR_SUCCESS );

        InterlockedIncrement( (PLONG)&ThreadContext->CopyContext->DirectoriesCreated ); // this is really a ULONG

        createdDir = TRUE;
        updateBasic = TRUE;
        updateStoredSecurityAttributes = TRUE;
        
    } else {

        MIRROR_ACL_STREAM aclStream;
        
        //
        //  let's get the security descriptor and extended attributes to
        //  see if we need to update our alternate data stream on the target.
        //

        err = GetOurSecurityStream( ThreadContext, DirectoryInfo->Dest, &aclStream );

        if (!NT_SUCCESS( err )) {

            updateStoredSecurityAttributes = TRUE;

        } else {

            destDirInfo.ChangeTime = aclStream.ChangeTime;

            if (( aclStream.ChangeTime.QuadPart != sourceDirInfo.ChangeTime.QuadPart ) ||
                ( aclStream.ExtendedAttributes != DirectoryInfo->SourceAttributes ) ) {

                updateStoredSecurityAttributes = TRUE;
            }
        }

        //
        //  if the creation time or lastwrite time is different, then we'll
        //  update them on the target to match the source.
        //

        if (( destDirInfo.CreationTime.QuadPart != sourceDirInfo.CreationTime.QuadPart ) ||
            ( destDirInfo.LastWriteTime.QuadPart != sourceDirInfo.LastWriteTime.QuadPart )) {

            updateBasic = TRUE;
        }
    }

    //
    //  Save the complete attribute values in the alternate data stream
    //     on the slave file.
    //

    if (updateStoredSecurityAttributes || DirectoryInfo->DirectoryRoot) {

        err = StoreOurSecurityStream(  ThreadContext,
                                       DirectoryInfo->Source,
                                       DirectoryInfo->Dest,
                                       DirectoryInfo->SourceAttributes,
                                       sourceDirInfo.ChangeTime
                                       );
        updateBasic = TRUE;
    }

    if ((err == ERROR_SUCCESS) &&
        updateBasic &&
        (DirectoryInfo->DirectoryRoot == FALSE)) {

        destDirInfo.CreationTime = sourceDirInfo.CreationTime;
        destDirInfo.LastWriteTime = sourceDirInfo.LastWriteTime;
        destDirInfo.ChangeTime = sourceDirInfo.ChangeTime;

        destDirInfo.FileAttributes = 0;     // leave dir attributes alone.

        err = NtSetInformationFile(    ThreadContext->DestDirHandle,
                                       &IoStatusBlock,
                                       &destDirInfo,
                                       sizeof( FILE_BASIC_INFORMATION ),
                                       FileBasicInformation
                                       );

        err = IMConvertNT2Win32Error( err );
        if ( err != ERROR_SUCCESS) {

            errorCase = ReportCopyError(    ThreadContext->CopyContext,
                                            DirectoryInfo->Dest,
                                            COPY_ERROR_ACTION_SETATTR,
                                            GetLastError() );
            if (errorCase == STATUS_RETRY) {
                goto retryCreateDir;
            }
            if (errorCase == ERROR_SUCCESS) {
                err = ERROR_SUCCESS;
            }
        } else if (! createdDir ) {

            InterlockedIncrement( (PLONG)&ThreadContext->CopyContext->AttributesModified ); // this is really a ULONG
        }
    }

    //
    // Save off our SFN information too.
    //
    if( (err == ERROR_SUCCESS) && (DirectoryInfo->DirectoryRoot == FALSE) ) {


        WCHAR ShortFileNameInStream[MAX_PATH*2];
        WCHAR *p = NULL;


        //
        // Get the short file name on the source directory.
        //
        ShortFileNameInStream[0] = L'\0';

        //
        // It's likely that our path looks like \??\C:\xxxxx,
        // which GetShortPathName will fail on.  We need to fix
        // up the path so it looks like a good ol' DOS path.
        //
        if( p = wcsrchr(DirectoryInfo->NtSourceName, L':') ) {
            p -= 1;
        } else {
            p = DirectoryInfo->NtSourceName;
        }
        err = GetShortPathName( p,
                                ShortFileNameInStream,
                                ARRAYSIZE(ShortFileNameInStream) );
        
        
        //
        // If we got a short file name, then go set that information in
        // the alternate stream in our destination file.
        //
        if( err == 0 ) {
            err = GetLastError();
        } else {
            if( wcscmp(ShortFileNameInStream, p) ) {
            
                //
                // The short file name is different from the name of
                // our source file, so better save it off.
                //
                if( p = wcsrchr(ShortFileNameInStream, L'\\') ) {
                    p += 1;
                } else {
                    p = ShortFileNameInStream;
                }
        
        
                if( *p != '\0' ) {

                    WCHAR SavedCharacter = L'\0';
                    PWSTR q = NULL;
                    //
                    // Incredibly nausiating hack where CreateFile explodes
                    // when we send him a "\??\UNC\...." path, which is exactly
                    // what we're probably going to send him when we call into
                    // StoreOurSFNStream().  We'll need to patch the NtDestName
                    // here, then restore it when we come back.
                    //
                    if( q = wcsstr(DirectoryInfo->NtDestName, L"\\??\\UNC\\") ) {
                        SavedCharacter = DirectoryInfo->NtDestName[6];
                        DirectoryInfo->NtDestName[6] = L'\\';
                        q = &DirectoryInfo->NtDestName[6];
                    } else {
                        q = DirectoryInfo->NtDestName;
                    }
                    err = StoreOurSFNStream( ThreadContext,
                                             DirectoryInfo->NtSourceName,
                                             q,
                                             p );
                    if( SavedCharacter != L'\0' ) {
                        // restore the destination path.
                        DirectoryInfo->NtDestName[6] = SavedCharacter;
                    }
        
                }
            }
        }

        //
        // Cover up any errors here because it's certainly not fatal.
        //
        err = ERROR_SUCCESS;
    }


    return err;
}


DWORD
IMirrorOpenDirectory (
    HANDLE *Handle,
    PWCHAR NtDirName,
    DWORD Disposition,
    BOOLEAN IsSource,
    DWORD SourceAttributes,
    PFILE_BASIC_INFORMATION BasicDirInfo OPTIONAL
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeInput;
    DWORD createOptions;
    DWORD desiredAccess;

    BOOLEAN StrippedTrailingSlash;

    ASSERT( Handle != NULL );
    ASSERT( *Handle == INVALID_HANDLE_VALUE );

    RtlInitUnicodeString(&UnicodeInput,NtDirName);

    if ((UnicodeInput.Length > 2 * sizeof(WCHAR)) &&
        (UnicodeInput.Buffer[(UnicodeInput.Length>>1)-1] == L'\\') &&
        (UnicodeInput.Buffer[(UnicodeInput.Length>>1)-2] != L':' )) {

        UnicodeInput.Length -= sizeof(UNICODE_NULL);
        StrippedTrailingSlash = TRUE;

    } else {

        StrippedTrailingSlash = FALSE;
    }

    createOptions = FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT;
    desiredAccess = FILE_LIST_DIRECTORY | SYNCHRONIZE | FILE_TRAVERSE | FILE_READ_ATTRIBUTES;

    if (IsSource) {

        createOptions |= FILE_OPEN_FOR_BACKUP_INTENT;

    } else {

        desiredAccess |= FILE_ADD_FILE |
                         FILE_ADD_SUBDIRECTORY |
                         FILE_WRITE_ATTRIBUTES |
                         FILE_DELETE_CHILD;
    }

retryCreate:

    InitializeObjectAttributes(
        &Obja,
        &UnicodeInput,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    //  Open the directory for the desired access.  This may create it.
    //

    Status = NtCreateFile(
                Handle,
                desiredAccess,
                &Obja,
                &IoStatusBlock,
                NULL,
                SourceAttributes,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                Disposition,
                createOptions,
                NULL,
                0 );

    if ( Status == STATUS_INVALID_PARAMETER && StrippedTrailingSlash ) {
        //
        // open of a pnp style path failed, so try putting back the trailing slash
        //
        UnicodeInput.Length += sizeof(UNICODE_NULL);
        StrippedTrailingSlash = FALSE;
        goto retryCreate;
    }

    if (*Handle == NULL) {

        *Handle = INVALID_HANDLE_VALUE;
    }

    if (NT_SUCCESS( Status ) && BasicDirInfo != NULL) {

        //
        //  read the attributes for the caller too
        //

        Status = NtQueryInformationFile(    *Handle,
                                            &IoStatusBlock,
                                            BasicDirInfo,
                                            sizeof( FILE_BASIC_INFORMATION ),
                                            FileBasicInformation
                                            );
    }

    return IMConvertNT2Win32Error( Status );
}


DWORD
MirrorFile(
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    PWCHAR SourceFileName,
    PFILE_FULL_DIR_INFORMATION SourceFindData,
    PWCHAR DestFileName,
    PEXISTING_MIRROR_FILE ExistingMirrorFile
    )
{
    DWORD err;
    BOOLEAN fileIsAlreadyThere;
    PCOPY_TREE_CONTEXT copyContext;
    BOOLEAN updateStoredSecurityAttributes;
    BOOLEAN updateStoredSFNAttributes;
    BOOLEAN updateBasic;
    BOOLEAN isEncrypted;
    FILE_BASIC_INFORMATION fileBasicInfo;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    MIRROR_ACL_STREAM aclStream;
    MIRROR_SFN_STREAM SFNStream;
    ULONG errorCase;
    static FARPROC pSetFileShortName = NULL;
    static BOOL AlreadyCheckedForExport = FALSE;
    WCHAR ShortFileNameInStream[32];
    WCHAR ShortFileName[MAX_PATH],*p;

retryMirrorFile:

    if ( fileHandle != INVALID_HANDLE_VALUE ) {
        CloseHandle( fileHandle );
        fileHandle = INVALID_HANDLE_VALUE;
    }

    errorCase = STATUS_SUCCESS;
    err = STATUS_SUCCESS;
    fileIsAlreadyThere = FALSE;
    copyContext = ThreadContext->CopyContext;
    updateStoredSecurityAttributes = TRUE;
    updateStoredSFNAttributes = TRUE;
    updateBasic = TRUE;
    isEncrypted = FALSE;


    ShortFileName[0] = L'\0';
    GetShortPathName( 
        SourceFileName, 
        ShortFileName, 
        ARRAYSIZE(ShortFileName));
    if (p = wcsrchr(ShortFileName, L'\\')) {
        p += 1;        
    } else {
        p = ShortFileName;
    }
            
    if (!AlreadyCheckedForExport) {
        HMODULE hKernel32 = GetModuleHandle(L"kernel32.dll");

        if (hKernel32) {
            pSetFileShortName = GetProcAddress(
                                    hKernel32, 
                                    "SetFileShortNameW");
        }

        AlreadyCheckedForExport = TRUE;
    }

    // don't copy file if callback says not to

    if ((err = IMirrorNowDoing(CopyFiles, SourceFileName)) != ERROR_SUCCESS) {

        if (err == STATUS_REQUEST_ABORTED) {

            copyContext->Cancelled = TRUE;
        }
        return STATUS_SUCCESS;
    }

    //
    //  sorry, for this release we currently don't support encrypted files.
    //

    if (SourceFindData->FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {

        errorCase = ReportCopyError(   copyContext,
                                       SourceFileName,
                                       COPY_ERROR_ACTION_CREATE_FILE,
                                       ERROR_FILE_ENCRYPTED );
        if (errorCase == STATUS_RETRY) {
            SourceFindData->FileAttributes = GetFileAttributes( SourceFileName );
            goto retryMirrorFile;
        }
        if (errorCase == ERROR_SUCCESS) {

            err = STATUS_SUCCESS;

        } else {

            err = ERROR_FILE_ENCRYPTED;
        }
        return err;
    }

    fileBasicInfo.FileAttributes = 0;       // by default, leave them alone

    if (SourceFindData->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {

        err = CanHandleReparsePoint( ThreadContext,
                                     SourceFileName,
                                     SourceFindData->FileAttributes
                                     );
        if (!NT_SUCCESS(err)) {

            errorCase = ReportCopyError(   copyContext,
                                           SourceFileName,
                                           COPY_ERROR_ACTION_CREATE_FILE,
                                           err );
            if (errorCase == STATUS_RETRY) {
                SourceFindData->FileAttributes = GetFileAttributes( SourceFileName );
                goto retryMirrorFile;
            }
            if (errorCase == ERROR_SUCCESS) {

                err = STATUS_SUCCESS;
            }
            return err;
        }

        SourceFindData->FileAttributes &= ~FILE_ATTRIBUTE_REPARSE_POINT;
    }

    if (ExistingMirrorFile) {

        if (ExistingMirrorFile->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

            //
            //  it exists as a directory.  Master is always right, let's
            //  delete the directory.
            //
            //  Also, if the master and slave differ in whether the file is
            //  encrypted or not, delete the slave.
            //

            err = UnconditionalDelete(  ThreadContext,
                                        SourceFileName,
                                        DestFileName,
                                        ExistingMirrorFile->FileAttributes,
                                        NULL );

            if (err != ERROR_SUCCESS) {
                return err;
            }

            ExistingMirrorFile = NULL;

        } else {

            //
            //  if the files are the same, leave it be.
            //

            if ((SourceFindData->CreationTime.QuadPart == ExistingMirrorFile->CreationTime.QuadPart ) &&
                (SourceFindData->LastWriteTime.QuadPart == ExistingMirrorFile->LastWriteTime.QuadPart) &&
                (SourceFindData->EaSize == ExistingMirrorFile->EaSize) &&
                (SourceFindData->EndOfFile.QuadPart == ExistingMirrorFile->EndOfFile.QuadPart)) {

                fileIsAlreadyThere = TRUE;
                updateBasic = FALSE;

                //
                //  let's get the security descriptor and extended attributes to
                //  see if we need to update our alternate data stream on the target.
                //

                err = GetOurSecurityStream( ThreadContext, DestFileName, &aclStream );

                if ((err == ERROR_SUCCESS) &&
                    (aclStream.ChangeTime.QuadPart == SourceFindData->ChangeTime.QuadPart) &&
                    (SourceFindData->FileAttributes == aclStream.ExtendedAttributes)) {

                    updateStoredSecurityAttributes = FALSE;

                } else {

                    err = ERROR_SUCCESS;
                }

                //
                // let's get the short file name to see if we need to update 
                // our alternate data stream on the target.
                //

                err = GetOurSFNStream( 
                            ThreadContext, 
                            DestFileName, 
                            &SFNStream, 
                            ShortFileNameInStream, 
                            sizeof(ShortFileNameInStream) );

                if ((err == ERROR_SUCCESS) &&
                    *p != L'\0' &&
                    (wcscmp(ShortFileNameInStream, p) == 0)) {

                    updateStoredSFNAttributes = FALSE;

                } else {

                    err = ERROR_SUCCESS;
                }



            }
        }
    }

    //
    //  if the file already exists but it's not current or our alternate
    //  stream needs updating, let's update the attributes such that we can
    //  modify the file.
    //

    fileBasicInfo.CreationTime.QuadPart = SourceFindData->CreationTime.QuadPart;
    fileBasicInfo.LastWriteTime.QuadPart = SourceFindData->LastWriteTime.QuadPart;
    fileBasicInfo.LastAccessTime.QuadPart = SourceFindData->LastAccessTime.QuadPart;
    fileBasicInfo.ChangeTime.QuadPart = SourceFindData->ChangeTime.QuadPart;

    err = ERROR_SUCCESS;

    if (! fileIsAlreadyThere) {

        if (CopyFile( SourceFileName, DestFileName, FALSE) == FALSE) {

            err = GetLastError();

        } else {

            err = ERROR_SUCCESS;
        }
        if (err == ERROR_SHARING_VIOLATION) {

            //
            //  we ignore sharing violations for the following files :
            //      system registry files
            //      tracking.log
            //      ntuser.dat & ntuser.dat.log
            //      usrclass.dat & usrclass.dat.log
            //

            PWCHAR fileName = SourceFileName;
            PIMIRROR_IGNORE_FILE_LIST ignoreListEntry;
            ULONG componentLength;
            PLIST_ENTRY listEntry;

            if (_wcsicmp(SourceFileName, L"\\\\?\\")) {

                PWCHAR firstSlash;

                fileName += 4;      // now fileName points to L"C:\WINNT..."

                firstSlash = fileName;
                while (*firstSlash != L'\\' && *firstSlash != L'\0') {
                    firstSlash++;
                }
                if (*firstSlash != L'\0') {
                    fileName = firstSlash+1;  // now fileName points to L"WINNT\..."
                }
            }

            componentLength = lstrlenW( fileName );

            listEntry = ThreadContext->FilesToIgnore.Flink;

            while (listEntry != &(ThreadContext->FilesToIgnore)) {

                ignoreListEntry = (PIMIRROR_IGNORE_FILE_LIST)
                                    CONTAINING_RECORD(  listEntry,
                                                        IMIRROR_IGNORE_FILE_LIST,
                                                        ListEntry );

                if (CompareStringW( LOCALE_SYSTEM_DEFAULT,
                                    NORM_IGNORECASE,
                                    fileName,
                                    min( componentLength, ignoreListEntry->FileNameLength),
                                    &ignoreListEntry->FileName[0],
                                    ignoreListEntry->FileNameLength) == 2) {

                    // it matched one of our special files.  we'll ignore the
                    // error but also not set the attributes on the image.

                    return err;
                }

                listEntry = listEntry->Flink;
            }
        }

        // report either success or failure up to the caller

        if (err == ERROR_SUCCESS) {

            ReportCopyError(   ThreadContext->CopyContext,
                               SourceFileName,
                               COPY_ERROR_ACTION_CREATE_FILE,
                               err );

            InterlockedIncrement( (PLONG)&copyContext->FilesCopied ); // this is really a ULONG
            copyContext->BytesCopied.QuadPart += SourceFindData->EndOfFile.QuadPart;

        } else {

            errorCase = ReportCopyError(   ThreadContext->CopyContext,
                                           SourceFileName,
                                           COPY_ERROR_ACTION_CREATE_FILE,
                                           err );
            if (errorCase == STATUS_RETRY) {
                goto retryMirrorFile;
            }
            if (errorCase == ERROR_SUCCESS) {

                err = STATUS_SUCCESS;
            }
            return err;
        }

        updateStoredSecurityAttributes = TRUE;
        updateStoredSFNAttributes = TRUE;
        updateBasic = TRUE;
        fileBasicInfo.FileAttributes = 0;   // don't set the attribute again.

        if (err == STATUS_SUCCESS) {

            //
            //  we just created the file so we'll just give it the archive
            //  bit as an attribute since we've saved off the rest in the
            //  stream.
            //

            if (! SetFileAttributes( DestFileName, FILE_ATTRIBUTE_ARCHIVE )) {

                err = GetLastError();

                errorCase = ReportCopyError(   copyContext,
                                               DestFileName,
                                               COPY_ERROR_ACTION_SETATTR,
                                               err );
                if (errorCase == STATUS_RETRY) {
                    goto retryMirrorFile;
                }
                if (errorCase == ERROR_SUCCESS) {

                    err = STATUS_SUCCESS;
                }
            }
        }
    }

    if ((err == ERROR_SUCCESS) && updateStoredSFNAttributes && (*p != L'\0')) {

        err = StoreOurSFNStream(  ThreadContext,
                                  SourceFileName,
                                  DestFileName,
                                  p
                                );
        updateBasic = TRUE;
    }

    if ((err == ERROR_SUCCESS) && updateStoredSecurityAttributes) {

        err = StoreOurSecurityStream(  ThreadContext,
                                       SourceFileName,
                                       DestFileName,
                                       SourceFindData->FileAttributes,
                                       SourceFindData->ChangeTime
                                       );
        updateBasic = TRUE;
    }

    if ((err == ERROR_SUCCESS) && updateBasic) {

        //
        //  set create date and lastUpdate date to correct values
        //

        fileHandle = CreateFile(    DestFileName,
                                    FILE_WRITE_ATTRIBUTES | DELETE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    0,
                                    NULL );

        if (fileHandle == INVALID_HANDLE_VALUE) {

            err = GetLastError();

        } else {
            
            //
            // first try to set the short name.  If this fails, we just ignore
            // the error.
            //
            
            
            if (pSetFileShortName) {
                pSetFileShortName( fileHandle, p );                
            }

            //
            //  if we're making a change to an existing file, update the ARCHIVE bit.
            //

            if (fileIsAlreadyThere &&
                0 == (fileBasicInfo.FileAttributes & FILE_ATTRIBUTE_ARCHIVE)) {

                fileBasicInfo.FileAttributes |= FILE_ATTRIBUTE_ARCHIVE;
            }

            //
            //  set create date and lastUpdate date to correct values
            //

            err = NtSetInformationFile(    fileHandle,
                                           &IoStatusBlock,
                                           &fileBasicInfo,
                                           sizeof( FILE_BASIC_INFORMATION ),
                                           FileBasicInformation
                                           );

            err = IMConvertNT2Win32Error( err );
        }
        if (err != STATUS_SUCCESS) {

            errorCase = ReportCopyError(   copyContext,
                                           DestFileName,
                                           COPY_ERROR_ACTION_SETTIME,
                                           err );
            if (errorCase == STATUS_RETRY) {
                goto retryMirrorFile;
            }
            if (errorCase == ERROR_SUCCESS) {

                err = STATUS_SUCCESS;
            }
        } else if (fileIsAlreadyThere) {

            InterlockedIncrement( (PLONG) &copyContext->AttributesModified ); // this is really a ULONG
        }
    }

    if (err == STATUS_SUCCESS) {

        //
        //  report that we succeeded in copying the file
        //

        (VOID)ReportCopyError(   copyContext,
                                 SourceFileName,
                                 COPY_ERROR_ACTION_CREATE_FILE,
                                 err );
    }

    if ( fileHandle != INVALID_HANDLE_VALUE ) {
        CloseHandle( fileHandle );
    }
    return err;
}

DWORD
UnconditionalDelete (
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    PWCHAR SourceFile,
    PWCHAR FileToDelete,
    DWORD  Attributes,
    PWCHAR NameBuffer
    )
{
    DWORD err;
    BOOLEAN allocatedBuffer;
    BOOLEAN reportError;
    PCOPY_TREE_CONTEXT copyContext;

retryDelete:

    err = ERROR_SUCCESS;
    allocatedBuffer = FALSE;
    reportError = TRUE;
    copyContext = ThreadContext->CopyContext;

    if (copyContext->DeleteOtherFiles == FALSE) {

        err = ERROR_WRITE_PROTECT;
        goto exitWithError;
    }

    if ((Attributes & (FILE_ATTRIBUTE_READONLY |
                       FILE_ATTRIBUTE_HIDDEN   |
                       FILE_ATTRIBUTE_SYSTEM)) != 0) {

        // set the attributes back to normal

        Attributes &= ~FILE_ATTRIBUTE_READONLY;
        Attributes &= ~FILE_ATTRIBUTE_HIDDEN;
        Attributes &= ~FILE_ATTRIBUTE_SYSTEM;

        SetFileAttributesW( FileToDelete, Attributes );
    }

    if ((Attributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {

        if (! DeleteFile( FileToDelete )) {

            err = GetLastError();

        } else {

            InterlockedIncrement( (PLONG)&copyContext->FilesDeleted ); // this is really a ULONG
        }
    } else {

        //
        //  remove all files and subdirectories recursively here...
        //

        HANDLE fileEnum = INVALID_HANDLE_VALUE;
        WIN32_FIND_DATA findData;
        PWCHAR startFileName;
        ULONG dirLength;

        if (NameBuffer == NULL) {

            NameBuffer = IMirrorAllocMem( TMP_BUFFER_SIZE );

            if (NameBuffer == NULL) {

                //err = STATUS_NO_MEMORY;
                err = ERROR_NOT_ENOUGH_MEMORY;
                goto exitWithError;
            }

            lstrcpyW( NameBuffer, FileToDelete );
            allocatedBuffer = TRUE;
        }

        dirLength = lstrlenW( NameBuffer );
        lstrcatW( NameBuffer, L"\\*" );

        // remember the start of the char after the backslash to slap in the name

        startFileName = NameBuffer + dirLength + 1;

        err = ERROR_SUCCESS;
        fileEnum = FindFirstFile( NameBuffer, &findData );

        if (fileEnum != INVALID_HANDLE_VALUE) {

            while (copyContext->Cancelled == FALSE) {

                if (((findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0) &&
                     (findData.cFileName[0] == L'.')) {

                    if ((findData.cFileName[1] == L'\0') ||
                        (findData.cFileName[1] == L'.' &&
                         findData.cFileName[2] == L'\0')) {

                        goto skipToNextDir;
                    }
                }

                lstrcpyW( startFileName, &findData.cFileName[0] );

                err = UnconditionalDelete(  ThreadContext,
                                            SourceFile,
                                            NameBuffer,
                                            findData.dwFileAttributes,
                                            NameBuffer );

                if (err != ERROR_SUCCESS) {

                    reportError = FALSE;
                    break;
                }
skipToNextDir:
                if (! FindNextFile( fileEnum, &findData)) {

                    err = GetLastError();
                    if (err == ERROR_NO_MORE_FILES) {
                        err = ERROR_SUCCESS;
                        break;
                    }
                }
            }
            FindClose( fileEnum );
            *(NameBuffer+dirLength) = L'\0';
        }

        if (err == ERROR_SUCCESS) {

            if (! RemoveDirectory( FileToDelete ) ) {

                err = GetLastError();

            } else {

                InterlockedIncrement( (PLONG)&copyContext->DirectoriesDeleted );// this is really a ULONG
            }
        }
    }

exitWithError:

    // we report the error for both success and failure

    if (allocatedBuffer && NameBuffer != NULL) {

        IMirrorFreeMem( NameBuffer );
    }

    if (reportError) {

        DWORD errorCase;

        errorCase = ReportCopyError(   copyContext,
                                       FileToDelete,
                                       COPY_ERROR_ACTION_DELETE,
                                       err );
        if (errorCase == STATUS_RETRY) {
            goto retryDelete;
        }
        if (errorCase == ERROR_SUCCESS) {
            err = ERROR_SUCCESS;
        }
    }
    return err;
}

DWORD
StoreOurSecurityStream (
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    PWCHAR Source,
    PWCHAR Dest,
    DWORD  AttributesToStore,
    LARGE_INTEGER ChangeTime
    )
//
//  This routine stores off the acl from the master into a named alternate
//  data stream on the destination.  It saves off both the ACL and a few
//  file attributes that couldn't be stored in the normal directory entry.
//
{
    PSECURITY_DESCRIPTOR SourceSD;
    PCOPY_TREE_CONTEXT copyContext;
    DWORD err;
    DWORD requiredLength;
    HANDLE hAclFile;
    PWCHAR aclFileName;
    ULONG action;
    MIRROR_ACL_STREAM mirrorAclStream;
    DWORD BytesWritten;
    DWORD deleteAclFile;
    DWORD errorCase;

retryWriteStream:

    errorCase = STATUS_SUCCESS;
    SourceSD = NULL;
    copyContext = ThreadContext->CopyContext;
    err = ERROR_SUCCESS;
    requiredLength = 0;
    hAclFile = INVALID_HANDLE_VALUE;
    action = COPY_ERROR_ACTION_GETACL;
    deleteAclFile = FALSE;

    //
    //  We use the SDBuffer on the thread context to store not only the
    //  security descriptor but also the file name of the alternate data stream.
    //

    requiredLength = (lstrlenW( Dest ) + lstrlenW( IMIRROR_ACL_STREAM_NAME ) + 1) * sizeof(WCHAR);

    if (ThreadContext->SDBuffer == NULL || requiredLength > ThreadContext->SDBufferLength) {

        if (ThreadContext->SDBuffer != NULL) {

            IMirrorFreeMem( ThreadContext->SDBuffer );
            ThreadContext->SDBuffer = NULL;
            ThreadContext->SDBufferLength = requiredLength;
        }

        if (requiredLength > ThreadContext->SDBufferLength) {
            ThreadContext->SDBufferLength = requiredLength;
        }

        ThreadContext->SDBuffer = IMirrorAllocMem( ThreadContext->SDBufferLength );

        if (ThreadContext->SDBuffer == NULL) {

            err = GetLastError();

            errorCase = ReportCopyError(  copyContext,
                                          Source,
                                          COPY_ERROR_ACTION_MALLOC,
                                          err );
            goto IMCEExit;
        }
    }

    aclFileName = (PWCHAR) ThreadContext->SDBuffer;
    lstrcpyW( aclFileName, Dest );
    lstrcatW( aclFileName, IMIRROR_ACL_STREAM_NAME );

    hAclFile  = CreateFile(     aclFileName,
                                GENERIC_WRITE,
                                0,              // Exclusive access.
                                NULL,           // Default security descriptor.
                                CREATE_ALWAYS,  // Overrides if file exists.
                                0,              // no special attributes
                                NULL
                                );

    if (hAclFile == INVALID_HANDLE_VALUE) {

        err = GetLastError();

        errorCase = ReportCopyError(  copyContext,
                                      Source,
                                      COPY_ERROR_ACTION_CREATE_FILE,
                                      err );
        goto IMCEExit;
    }

    //
    //  read the source security descriptor into the buffer allocated off the
    //  thread context.
    //

    if (ThreadContext->IsNTFS == FALSE) {

        requiredLength = 0;

    } else {

        err = ERROR_INSUFFICIENT_BUFFER;

        while (err == ERROR_INSUFFICIENT_BUFFER) {

            if (ThreadContext->SDBuffer == NULL) {

                ThreadContext->SDBuffer = IMirrorAllocMem( ThreadContext->SDBufferLength );

                if (ThreadContext->SDBuffer == NULL) {

                    err = GetLastError();
                    break;
                }
            }

            SourceSD = (PSECURITY_DESCRIPTOR) ThreadContext->SDBuffer;

            //
            // get SD of the SourceRoot file.  This comes back self relative.
            //
            if (GetFileSecurity( Source,
                                 (DACL_SECURITY_INFORMATION |
                                  GROUP_SECURITY_INFORMATION |
                                  SACL_SECURITY_INFORMATION |
                                  OWNER_SECURITY_INFORMATION),
                                SourceSD,
                                ThreadContext->SDBufferLength,
                                &requiredLength )) {

                err = ERROR_SUCCESS;

            } else {

                err = GetLastError();

                if ((err == ERROR_INSUFFICIENT_BUFFER) ||
                    (requiredLength > ThreadContext->SDBufferLength)) {

                    // let's try it again with a bigger buffer.

                    ThreadContext->SDBufferLength = requiredLength;
                    IMirrorFreeMem( ThreadContext->SDBuffer );
                    ThreadContext->SDBuffer = NULL;
                    err = ERROR_INSUFFICIENT_BUFFER;
                }
            }
        }

        if (err != ERROR_SUCCESS) {

            errorCase = ReportCopyError(  copyContext,
                                          Source,
                                          COPY_ERROR_ACTION_GETACL,
                                          err );
            goto IMCEExit;
        }

        InterlockedIncrement( (PLONG)&copyContext->SourceSecurityDescriptorsRead );// this is really a ULONG
        ASSERT( IsValidSecurityDescriptor(SourceSD) );
    }

    mirrorAclStream.StreamVersion = IMIRROR_ACL_STREAM_VERSION;
    mirrorAclStream.StreamLength = sizeof( MIRROR_ACL_STREAM ) +
                                   requiredLength;
    mirrorAclStream.ChangeTime.QuadPart = ChangeTime.QuadPart;
    mirrorAclStream.ExtendedAttributes = AttributesToStore;
    mirrorAclStream.SecurityDescriptorLength = requiredLength;

    if ((WriteFile( hAclFile,
                    &mirrorAclStream,
                    sizeof( MIRROR_ACL_STREAM ),
                    &BytesWritten,
                    NULL        // No overlap.
                    ) == FALSE) ||
         (BytesWritten < sizeof( MIRROR_ACL_STREAM ))) {

        deleteAclFile = TRUE;
        err = GetLastError();

        errorCase = ReportCopyError(  copyContext,
                                      Source,
                                      COPY_ERROR_ACTION_SETACL,
                                      err );
        goto IMCEExit;
    }

    if (ThreadContext->IsNTFS) {

        if ((WriteFile( hAclFile,
                        SourceSD,
                        requiredLength,
                        &BytesWritten,
                        NULL        // No overlap.
                        ) == FALSE) ||
             (BytesWritten < requiredLength )) {

            deleteAclFile = TRUE;
            err = GetLastError();

            errorCase = ReportCopyError(  copyContext,
                                          Source,
                                          COPY_ERROR_ACTION_SETACL,
                                          err );
            goto IMCEExit;
        }

        InterlockedIncrement( (PLONG)&copyContext->SecurityDescriptorsWritten ); // this is really a ULONG
    }

IMCEExit:

    if (hAclFile != INVALID_HANDLE_VALUE) {

        CloseHandle( hAclFile );

        if (deleteAclFile) {

            // the file didn't get written properly, let's delete

            aclFileName = (PWCHAR) ThreadContext->SDBuffer;
            lstrcpyW( aclFileName, Dest );
            lstrcatW( aclFileName, IMIRROR_ACL_STREAM_NAME );

            DeleteFile( aclFileName );
        }
    }
    if (errorCase == STATUS_RETRY) {
        goto retryWriteStream;
    }
    if (errorCase == ERROR_SUCCESS) {
        err = ERROR_SUCCESS;
    }
    return err;
}

DWORD
StoreOurSFNStream (
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    PWCHAR Source,
    PWCHAR Dest,
    PWCHAR ShortFileName
    )
//
//  This routine stores off the short file name from the master into a named
//  alternate data stream on the destination.  
//
{
    
    PCOPY_TREE_CONTEXT copyContext;
    DWORD err;
    DWORD requiredLength;
    DWORD ShortFileNameLength;
    HANDLE hSFNFile;
    PWCHAR SFNFileName;
    ULONG action;
    MIRROR_SFN_STREAM mirrorSFNStream;
    DWORD BytesWritten;
    BOOL deleteSFNFile;
    DWORD errorCase;


retryWriteStream:

    errorCase = STATUS_SUCCESS;
    
    copyContext = ThreadContext->CopyContext;
    err = ERROR_SUCCESS;
    requiredLength = 0;
    hSFNFile = INVALID_HANDLE_VALUE;
    action = COPY_ERROR_ACTION_GETSFN;
    deleteSFNFile = FALSE;

    ShortFileNameLength = ((DWORD)wcslen(ShortFileName)+1)*sizeof(WCHAR);

    //
    //  We use the SFNBuffer on the thread context to store the file name of the
    //  alternate data stream.
    //

    requiredLength = (lstrlenW( Dest ) + lstrlenW( IMIRROR_SFN_STREAM_NAME ) + 1) * sizeof(WCHAR);
    if (requiredLength < ShortFileNameLength) {
        requiredLength = ShortFileNameLength;
    }

    if (ThreadContext->SFNBuffer == NULL || (requiredLength > ThreadContext->SFNBufferLength)) {

        if (ThreadContext->SFNBuffer != NULL) {

            IMirrorFreeMem( ThreadContext->SFNBuffer );
            ThreadContext->SFNBuffer = NULL;            
        }

        if (requiredLength > ThreadContext->SFNBufferLength) {
            ThreadContext->SFNBufferLength = requiredLength;
        }
        
        ThreadContext->SFNBuffer = IMirrorAllocMem( ThreadContext->SFNBufferLength );
        

        if (ThreadContext->SFNBuffer == NULL) {

            err = GetLastError();

            errorCase = ReportCopyError(  copyContext,
                                          Source,
                                          COPY_ERROR_ACTION_MALLOC,
                                          err );
            goto IMCEExit;
        }
    }

    SFNFileName = (PWCHAR) ThreadContext->SFNBuffer;
    lstrcpyW( SFNFileName, Dest );
    lstrcatW( SFNFileName, IMIRROR_SFN_STREAM_NAME );

    hSFNFile  = CreateFile(     SFNFileName,
                                GENERIC_WRITE,
                                0,              // Exclusive access.
                                NULL,           // Default security descriptor.
                                CREATE_ALWAYS,  // Overrides if file exists.
                                FILE_FLAG_BACKUP_SEMANTICS,  // Open directories too.
                                NULL
                                );

    if (hSFNFile == INVALID_HANDLE_VALUE) {

        err = GetLastError();

        errorCase = ReportCopyError(  copyContext,
                                      Source,
                                      COPY_ERROR_ACTION_CREATE_FILE,
                                      err );
        goto IMCEExit;
    }


    mirrorSFNStream.StreamVersion = IMIRROR_SFN_STREAM_VERSION;
    mirrorSFNStream.StreamLength = sizeof( MIRROR_SFN_STREAM ) + ShortFileNameLength;
    
    if ((WriteFile( hSFNFile,
                    &mirrorSFNStream,
                    sizeof( MIRROR_SFN_STREAM ),
                    &BytesWritten,
                    NULL        // No overlap.
                    ) == FALSE) ||
         (BytesWritten < sizeof( MIRROR_SFN_STREAM ))) {

        deleteSFNFile = TRUE;
        err = GetLastError();

        errorCase = ReportCopyError(  copyContext,
                                      Source,
                                      COPY_ERROR_ACTION_SETSFN,
                                      err );
        goto IMCEExit;
    }

    if ((WriteFile( hSFNFile,
                    ShortFileName,
                    ShortFileNameLength,
                    &BytesWritten,
                    NULL        // No overlap.
                    ) == FALSE) ||
             (BytesWritten < ShortFileNameLength )) {

        deleteSFNFile = TRUE;
        err = GetLastError();

        errorCase = ReportCopyError(  copyContext,
                                      Source,
                                      COPY_ERROR_ACTION_SETSFN,
                                      err );
        goto IMCEExit;
    }

    InterlockedIncrement( (PLONG)&copyContext->SFNWritten );// this is really a ULONG
    

IMCEExit:

    if (hSFNFile != INVALID_HANDLE_VALUE) {

        CloseHandle( hSFNFile );

        if (deleteSFNFile) {

            // the file didn't get written properly, let's delete

            SFNFileName = (PWCHAR) ThreadContext->SFNBuffer;
            lstrcpyW( SFNFileName, Dest );
            lstrcatW( SFNFileName, IMIRROR_SFN_STREAM_NAME );

            DeleteFile( SFNFileName );
        }
    }
    if (errorCase == STATUS_RETRY) {
        goto retryWriteStream;
    }
    if (errorCase == ERROR_SUCCESS) {
        err = ERROR_SUCCESS;
    }
    return err;
}


DWORD
GetOurSFNStream (
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    PWCHAR Dest,
    PMIRROR_SFN_STREAM MirrorSFNStream,
    PWCHAR SFNBuffer,
    DWORD  SFNBufferSize
    )
//
//  This routine reads the short filename stream header from the destination.  We do this
//  to get the fields out of it so that we can determine if it needs updating.
//
{
    DWORD err = ERROR_SUCCESS;
    DWORD requiredLength = 0;
    HANDLE hSFNFile = INVALID_HANDLE_VALUE;
    PWCHAR SFNFileName;
    DWORD BytesRead;

    //
    //  We use the SFNBuffer on the thread context to store not only the
    //  security descriptor but also the file name of the alternate data stream.
    //
    if (!Dest || *Dest == L'\0') {
        err = ERROR_INVALID_PARAMETER;
        goto IMCEExit;
    }

    requiredLength = (lstrlenW( Dest ) + lstrlenW( IMIRROR_SFN_STREAM_NAME ) + 1) * sizeof(WCHAR);

    if (ThreadContext->SFNBuffer == NULL || requiredLength > ThreadContext->SFNBufferLength) {

        if (ThreadContext->SFNBuffer != NULL) {

            IMirrorFreeMem( ThreadContext->SFNBuffer );
            ThreadContext->SFNBuffer = NULL;
            ThreadContext->SFNBufferLength = requiredLength;
        }

        if (requiredLength > ThreadContext->SFNBufferLength) {
            ThreadContext->SFNBufferLength = requiredLength;
        }

        ThreadContext->SFNBuffer = IMirrorAllocMem( ThreadContext->SFNBufferLength );

        if (ThreadContext->SFNBuffer == NULL) {

            err = GetLastError();
            goto IMCEExit;
        }
    }

    SFNFileName = (PWCHAR) ThreadContext->SFNBuffer;
    lstrcpyW( SFNFileName, Dest );
    lstrcatW( SFNFileName, IMIRROR_SFN_STREAM_NAME );

    hSFNFile  = CreateFile(     SFNFileName,
                                GENERIC_READ,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,           // Default security descriptor.
                                OPEN_EXISTING,
                                0,              // no special attributes
                                NULL
                                );

    if (hSFNFile == INVALID_HANDLE_VALUE) {

        err = GetLastError();
        goto IMCEExit;
    }

    
    if ((ReadFile( hSFNFile,
                   MirrorSFNStream,
                   sizeof( MIRROR_SFN_STREAM ),
                   &BytesRead,
                   NULL        // No overlap.
                   ) == FALSE) ||
         (BytesRead < sizeof( MIRROR_SFN_STREAM )) ||
         (MirrorSFNStream->StreamVersion != IMIRROR_SFN_STREAM_VERSION) ||
         (MirrorSFNStream->StreamLength < sizeof( MIRROR_SFN_STREAM ))) {

        err = ERROR_INVALID_DATA;
    }

    if ((MirrorSFNStream->StreamLength - sizeof(MIRROR_SFN_STREAM)) > SFNBufferSize) {
        err = ERROR_INSUFFICIENT_BUFFER;
    } else {
        if ((ReadFile( hSFNFile,
                  SFNBuffer,
                  MirrorSFNStream->StreamLength - sizeof(MIRROR_SFN_STREAM),
                  &BytesRead,
                  NULL ) == FALSE) ||
            (BytesRead != (MirrorSFNStream->StreamLength - sizeof(MIRROR_SFN_STREAM)))) {
            err = ERROR_INVALID_DATA;
        }
    }

IMCEExit:

    if (hSFNFile != INVALID_HANDLE_VALUE) {

        CloseHandle( hSFNFile );
    }

    return err;
}

DWORD
GetOurSecurityStream (
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    PWCHAR Dest,
    PMIRROR_ACL_STREAM MirrorAclStream
    )
//
//  This routine reads the stream header from the destination.  We do this
//  to get the fields out of it so that we can determine if it needs updating.
//
{
    DWORD err = ERROR_SUCCESS;
    DWORD requiredLength = 0;
    HANDLE hAclFile = INVALID_HANDLE_VALUE;
    PWCHAR aclFileName;
    DWORD BytesRead;

    //
    //  We use the SDuffer on the thread context to store not only the
    //  security descriptor but also the file name of the alternate data stream.
    //

    if (!Dest || *Dest == L'\0') {
        err = ERROR_INVALID_PARAMETER;
        goto IMCEExit;
    }
    requiredLength = (lstrlenW( Dest ) + lstrlenW( IMIRROR_ACL_STREAM_NAME ) + 1) * sizeof(WCHAR);

    if (ThreadContext->SDBuffer == NULL || requiredLength > ThreadContext->SDBufferLength) {

        if (ThreadContext->SDBuffer != NULL) {

            IMirrorFreeMem( ThreadContext->SDBuffer );
            ThreadContext->SDBuffer = NULL;
            ThreadContext->SDBufferLength = requiredLength;
        }

        if (requiredLength > ThreadContext->SDBufferLength) {
            ThreadContext->SDBufferLength = requiredLength;
        }

        ThreadContext->SDBuffer = IMirrorAllocMem( ThreadContext->SDBufferLength );

        if (ThreadContext->SDBuffer == NULL) {

            err = GetLastError();
            goto IMCEExit;
        }
    }

    aclFileName = (PWCHAR) ThreadContext->SDBuffer;
    lstrcpyW( aclFileName, Dest );
    lstrcatW( aclFileName, IMIRROR_ACL_STREAM_NAME );

    hAclFile  = CreateFile(     aclFileName,
                                GENERIC_READ,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,           // Default security descriptor.
                                OPEN_EXISTING,
                                0,              // no special attributes
                                NULL
                                );

    if (hAclFile == INVALID_HANDLE_VALUE) {

        err = GetLastError();
        goto IMCEExit;
    }

    //
    //  read the header of the stream.  We don't bother reading the security
    //  descriptor because all we need is the ChangeTime (which changes with
    //  the security descriptor).
    //

    if ((ReadFile( hAclFile,
                   MirrorAclStream,
                   sizeof( MIRROR_ACL_STREAM ),
                   &BytesRead,
                   NULL        // No overlap.
                   ) == FALSE) ||
         (BytesRead < sizeof( MIRROR_ACL_STREAM )) ||
         (MirrorAclStream->StreamVersion != IMIRROR_ACL_STREAM_VERSION) ||
         (MirrorAclStream->StreamLength < sizeof( MIRROR_ACL_STREAM ))) {

        err = ERROR_INVALID_DATA;
    }

IMCEExit:

    if (hAclFile != INVALID_HANDLE_VALUE) {

        CloseHandle( hAclFile );
    }

    return err;
}

ULONG
ReportCopyError (
    PCOPY_TREE_CONTEXT CopyContext OPTIONAL,
    PWCHAR File,
    DWORD  ActionCode,
    DWORD  Err
    )
//
//  This returns either ERROR_SUCCESS, STATUS_RETRY, or STATUS_REQUEST_ABORTED
//
//  ERROR_SUCCESS means we just continue on and ignore the error.
//  STATUS_RETRY means we retry the operation
//  STATUS_REQUEST_ABORTED means we bail.
//
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ReturnCode = ERROR_SUCCESS;

    if (CopyContext != NULL) {

        if (Err != ERROR_SUCCESS) {

            InterlockedIncrement( (PLONG)&CopyContext->ErrorsEncountered );// this is really a ULONG
        }
    }

    if (Callbacks.FileCreateFn == NULL) {

        if (Err != ERROR_SUCCESS) {
            if (ActionCode == COPY_ERROR_ACTION_DELETE) {

                printf( "error %u while deleting %S\n", Err, File );

            } else {

                printf( "error %u while copying %S\n", Err, File );
            }
        } else {

            if (ActionCode == COPY_ERROR_ACTION_DELETE) {

                printf( "deleted %S\n", File );

            } else {

                printf( "copied %S\n", File );
            }
        }
    }

    if (Err != STATUS_SUCCESS) {

        Status = IMirrorFileCreate(File, ActionCode, Err);

        if (Status == STATUS_REQUEST_ABORTED) {
            CopyContext->Cancelled = TRUE;
        } else if ((Status != STATUS_RETRY) &&
                   (Status != STATUS_SUCCESS)) {
            Status = STATUS_SUCCESS;
        }

        ReturnCode = (ULONG) Status;

    } else {
        ReturnCode = ERROR_SUCCESS;
    }

    return(ReturnCode);
}

NTSTATUS
SetPrivs(
    IN HANDLE TokenHandle,
    IN LPTSTR lpszPriv
    )
/*++

Routine Description:

    This routine enables the given privilege in the given token.

Arguments:



Return Value:

    FALSE                       - Failure.
    TRUE                        - Success.

--*/
{
    LUID SetPrivilegeValue;
    TOKEN_PRIVILEGES TokenPrivileges;

    //
    // First, find out the value of the privilege
    //

    if (!LookupPrivilegeValue(NULL, lpszPriv, &SetPrivilegeValue)) {
        return GetLastError();
    }

    //
    // Set up the privilege set we will need
    //

    TokenPrivileges.PrivilegeCount = 1;
    TokenPrivileges.Privileges[0].Luid = SetPrivilegeValue;
    TokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    if (!AdjustTokenPrivileges( TokenHandle,
                                FALSE,
                                &TokenPrivileges,
                                sizeof(TOKEN_PRIVILEGES),
                                NULL,
                                NULL)) {

        return GetLastError();
    }

    return ERROR_SUCCESS;
}

NTSTATUS
GetTokenHandle(
    IN OUT PHANDLE TokenHandle
    )
/*++

Routine Description:

    This routine opens the current process object and returns a
    handle to its token.

Arguments:


Return Value:

    NTSTATUS

--*/
{
    HANDLE ProcessHandle;
    NTSTATUS Result;

    ProcessHandle = OpenProcess(PROCESS_QUERY_INFORMATION,
                                FALSE,
                                GetCurrentProcessId());

    if (ProcessHandle == NULL) {
        return GetLastError();
    }

    Result = OpenProcessToken(ProcessHandle,
                              TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                              TokenHandle);

    CloseHandle(ProcessHandle);

    if (Result) {
        Result = ERROR_SUCCESS;
    } else {
        Result = GetLastError();
    }
    return Result;
}

NTSTATUS
CanHandleReparsePoint (
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    PWCHAR SourceFileName,
    DWORD FileAttributes
    )
//
//  This routine checks the type of reparse point a file is.  If it is a
//  reparse point we can handle (e.g. a structured storage document) then
//  return success.  Otherwise we return the appropriate error.
//
{
    UNREFERENCED_PARAMETER(ThreadContext);
    UNREFERENCED_PARAMETER(SourceFileName);
    UNREFERENCED_PARAMETER(FileAttributes);
    return(ERROR_REPARSE_ATTRIBUTE_CONFLICT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\imirror\findfile.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    findfile.c

Abstract:

    This module implements IMFindFirst/IMFindNext

Author:


Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#define IMIRROR_DIR_ENUM_BUFFER_SIZE 4096

ULONG
IMConvertNT2Win32Error(
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This API sets the "last error value" and the "last error string"
    based on the value of Status. For status codes that don't have
    a corresponding error string, the string is set to null.

Arguments:

    Status - Supplies the status value to store as the last error value.

Return Value:

    The corresponding Win32 error code that was stored in the
    "last error value" thread variable.

--*/

{
    ULONG dwErrorCode;

    dwErrorCode = RtlNtStatusToDosError( Status );
    SetLastError( dwErrorCode );
    return( dwErrorCode );
}


DWORD
IMFindNextFile(
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    HANDLE  DirHandle,
    PFILE_FULL_DIR_INFORMATION *lpFindFileData
    )
/*++

    ThreadContext - instance data for this enumeration

    DirHandle - handle of directory to query.

    lpFindFileData - On a successful find, this parameter returns information
        about the located file.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    if (ThreadContext->FindBufferNext != NULL) {

        *lpFindFileData = (PFILE_FULL_DIR_INFORMATION) ThreadContext->FindBufferNext;

        if ((*lpFindFileData)->NextEntryOffset > 0) {

            ThreadContext->FindBufferNext =
                (PVOID)(((PCHAR)*lpFindFileData ) + (*lpFindFileData)->NextEntryOffset );
        } else {

            ThreadContext->FindBufferNext = NULL;
        }

        return ERROR_SUCCESS;
    }

    ThreadContext->FindBufferNext = NULL;

    Status = NtQueryDirectoryFile(
                DirHandle,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                ThreadContext->FindBufferBase,
                ThreadContext->FindBufferLength,
                FileFullDirectoryInformation,
                FALSE,                  // return multiple entries
                NULL,
                FALSE                   // not a rescan
                );

    if (NT_SUCCESS( Status )) {

        *lpFindFileData = (PFILE_FULL_DIR_INFORMATION) ThreadContext->FindBufferBase;

        if ((*lpFindFileData)->NextEntryOffset > 0) {

            ThreadContext->FindBufferNext =
                (PVOID)(((PCHAR) *lpFindFileData ) + (*lpFindFileData)->NextEntryOffset );
        }
        return STATUS_SUCCESS;

    }

    *lpFindFileData = NULL;

    if (Status == STATUS_NO_MORE_FILES ||
        Status == STATUS_NO_SUCH_FILE ||
        Status == STATUS_OBJECT_NAME_NOT_FOUND) {

        return STATUS_SUCCESS;
    }
    return IMConvertNT2Win32Error( Status );
}


DWORD
IMFindFirstFile(
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    HANDLE  DirHandle,
    PFILE_FULL_DIR_INFORMATION *lpFindFileData
    )
/*++

Routine Description:

    This returns all entries in a directory.  This allocates a buffer if
    needed and sets up the variables in the ThreadContext to track the
    enumeration.

Arguments:

    ThreadContext - instance data for this enumeration

    DirHandle - handle of directory to query.

    lpFindFileData - Supplies a pointer to a full dir info structure.
        This points into our buffer and should not be freed by the caller.

    No call is required to close this, but note that a thread context
    can only have a single enumeration going on at any time.

Return Value:

    Win32 error.  ERROR_SUCCESS is only successful case.

--*/

{
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    UNICODE_STRING allFiles;

    if (ThreadContext->FindBufferBase == NULL) {

        ThreadContext->FindBufferBase = IMirrorAllocMem( IMIRROR_DIR_ENUM_BUFFER_SIZE );

        if (ThreadContext->FindBufferBase == NULL) {

            return IMConvertNT2Win32Error(STATUS_NO_MEMORY);
        }

        ThreadContext->FindBufferLength = IMIRROR_DIR_ENUM_BUFFER_SIZE;
    }

    RtlInitUnicodeString( &allFiles, L"*" );

    ThreadContext->FindBufferNext = NULL;

    Status = NtQueryDirectoryFile(
                DirHandle,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                ThreadContext->FindBufferBase,
                ThreadContext->FindBufferLength,
                FileFullDirectoryInformation,
                FALSE,                  // return multiple entries
                &allFiles,
                TRUE
                );
    if (NT_SUCCESS( Status )) {

        *lpFindFileData = (PFILE_FULL_DIR_INFORMATION) ThreadContext->FindBufferBase;

        if ((*lpFindFileData)->NextEntryOffset > 0) {

            ThreadContext->FindBufferNext =
                (PVOID)(((PCHAR) *lpFindFileData ) + (*lpFindFileData)->NextEntryOffset );
        }
    } else {

        *lpFindFileData = NULL;
    }
    return IMConvertNT2Win32Error( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\imirror\regcopy.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    regcopy.c

Abstract:

    This is for supporting copying and munging the registry files.

Author:

    Sean Selitrennikoff - 4/5/98

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

typedef BOOL (*PFNGETPROFILESDIRECTORYW)(LPWSTR lpProfile, LPDWORD dwSize);

//PWSTR HivePath;
HKEY HiveRoot;
//PWSTR HiveName;
REG_CONTEXT RegistryContext;

PWSTR MachineName;
PWSTR HiveFileName;
PWSTR HiveRootName;



DWORD
DoFullRegBackup(
    PWCHAR MirrorRoot
    )

/*++

Routine Description:

    This routine copies all the registries to the given server path.

Arguments:

    None.

Return Value:

    NO_ERROR if everything was backed up properly, else the appropriate error code.

--*/

{
    PWSTR w;
    LONG Error;
    HKEY HiveListKey;
    PWSTR KeyName;
    PWSTR FileName;
    PWSTR Name;
    DWORD ValueIndex;
    DWORD ValueType;
    DWORD ValueNameLength;
    DWORD ValueDataLength;
    WCHAR ConfigPath[ MAX_PATH ];
    WCHAR HiveName[ MAX_PATH ];
    WCHAR HivePath[ MAX_PATH ];
    WCHAR FilePath[ MAX_PATH ];
    
    NTSTATUS Status;
    BOOLEAN savedBackup;

    //
    // First try and give ourselves enough priviledge
    //
    if (!RTEnableBackupRestorePrivilege()) {
        return(GetLastError());
    }

    //
    // Now attach to the registry
    //
    Error = RTConnectToRegistry(MachineName,
                                HiveFileName,
                                HiveRootName,
                                NULL,
                                &RegistryContext
                               );

    if (Error != NO_ERROR) {
        RTDisableBackupRestorePrivilege();
        return Error;
    }

    //
    // Get handle to hivelist key
    //
    KeyName = L"HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Hivelist";
    Error = RTOpenKey(&RegistryContext,
                      NULL,
                      KeyName,
                      MAXIMUM_ALLOWED,
                      0,
                      &HiveListKey
                     );

    if (Error != NO_ERROR) {
        RTDisconnectFromRegistry(&RegistryContext);
        return Error;
    }

    //
    // get path data for system hive, which will allow us to compute
    // path name to config dir in form that hivelist uses.
    // (an NT internal form of path)  this is NOT the way the path to
    // the config directory should generally be computed.
    //

    ValueDataLength = sizeof(ConfigPath);
    Error = RTQueryValueKey(&RegistryContext,
                            HiveListKey,
                            L"\\Registry\\Machine\\System",
                            &ValueType,
                            &ValueDataLength,
                            ConfigPath
                           );
    if (Error != NO_ERROR) {
        RTDisconnectFromRegistry(&RegistryContext);
        return Error;
    }
    w = wcsrchr(ConfigPath, L'\\');
    if( w ) {
        *w = UNICODE_NULL;
    }


    //
    // ennumerate entries in hivelist.  for each entry, find it's hive file
    // path then save it.
    //
    for (ValueIndex = 0; TRUE; ValueIndex++) {

        savedBackup = FALSE;
        ValueType = REG_NONE;
        ValueNameLength = ARRAYSIZE( HiveName );
        ValueDataLength = sizeof( HivePath );

        Error = RTEnumerateValueKey(&RegistryContext,
                                    HiveListKey,
                                    ValueIndex,
                                    &ValueType,
                                    &ValueNameLength,
                                    HiveName,
                                    &ValueDataLength,
                                    HivePath
                                   );
        if (Error == ERROR_NO_MORE_ITEMS) {
            break;
        } else if (Error != NO_ERROR) {
            RTDisconnectFromRegistry(&RegistryContext);
            return Error;
        }

        if ((ValueType == REG_SZ) && (ValueDataLength > sizeof(UNICODE_NULL))) {
            //
            // there's a file, compute it's path, hive branch, etc
            //

            if ((w = wcsrchr( HivePath, L'\\' ))) {
                *w++ = UNICODE_NULL;
            }
            FileName = w;

            if (w = wcsrchr( HiveName, L'\\' )) {
                *w++ = UNICODE_NULL;
            }
            Name = w;

            HiveRoot = NULL;
            if (w = wcsrchr( HiveName, L'\\' )) {
                w += 1;
                if (!_wcsicmp( w, L"MACHINE" )) {
                    HiveRoot = HKEY_LOCAL_MACHINE;
                } else if (!_wcsicmp( w, L"USER" )) {
                    HiveRoot = HKEY_USERS;
                } else {

                    Status = IMirrorRegSaveError(w, ERROR_PATH_NOT_FOUND);

                    if (Status == STATUS_RETRY) {
                        continue;
                    }

                    if (!NT_SUCCESS(Status)) {
                        return Error;
                    }

                }

            }

            if (FileName != NULL && Name != NULL && HiveRoot != NULL) {

                //
                // Extract the path name from HivePath
                //
                if (_wcsicmp(HivePath, L"\\Device")) {

                    w = HivePath + 1;
                    w = wcsstr(w, L"\\");
                    w++;
                    w = wcsstr(w, L"\\");
                    w++;

                } else if (*(HivePath + 1) == L':') {

                    w = HivePath + 2;

                } else {

                    Status = IMirrorRegSaveError(HivePath, ERROR_PATH_NOT_FOUND);

                    if (Status == STATUS_RETRY) {
                        continue;
                    }

                    if (!NT_SUCCESS(Status)) {
                        return Error;
                    }

                }

                //
                // Do the save
                //

                swprintf( FilePath, L"%ws\\UserData\\%ws\\%ws", MirrorRoot, w, FileName );

                IMirrorNowDoing(CopyRegistry, FileName);

                //
                //  if the file already exists, rename it to a backup name
                //  so that if it fails, we'll restore it.
                //

                lstrcpyW( (PWCHAR) TmpBuffer, FilePath );
                lstrcatW( (PWCHAR) TmpBuffer, L".old" );
                if (MoveFileEx( FilePath, (PWCHAR) TmpBuffer, MOVEFILE_REPLACE_EXISTING)) {

                    savedBackup = TRUE;
                }

RetrySave:
                Error = DoSpecificRegBackup(FilePath,
                                            HiveRoot,
                                            Name
                                           );

                if (Error != NO_ERROR) {

                    Status = IMirrorRegSaveError(Name, Error);

                    if (Status == STATUS_RETRY) {
                        goto RetrySave;
                    }

                    if (!NT_SUCCESS(Status)) {

                        if (savedBackup) {

                            if (MoveFileEx( (PWCHAR) TmpBuffer, FilePath, MOVEFILE_REPLACE_EXISTING)) {

                                savedBackup = FALSE;
                            }
                        }
                        return Error;
                    }
                }
            }
        }
    }

    RTDisconnectFromRegistry(&RegistryContext);
    return NO_ERROR;
}

DWORD
DoSpecificRegBackup(
    PWSTR HivePath,
    HKEY HiveRoot,
    PWSTR HiveName
    )


/*++

Routine Description:

    This routine copies all the registries to the given server path.

Arguments:

    HivePath - file name to pass directly to OS

    HiveRoot - HKEY_LOCAL_MACHINE or HKEY_USERS

    HiveName - 1st level subkey under machine or users

Return Value:

    NO_ERROR if everything was backed up properly, else the appropriate error code.

--*/

{
    HKEY HiveKey;
    ULONG Disposition;
    LONG Error;
    
    //
    // get a handle to the hive.  use special create call what will
    // use privileges
    //

    Error = RTCreateKey(&RegistryContext,
                        HiveRoot,
                        HiveName,
                        KEY_READ,
                        REG_OPTION_BACKUP_RESTORE,
                        NULL,
                        &HiveKey,
                        &Disposition
                       );
    if (Error == NO_ERROR) {
        Error = RegSaveKey(HiveKey, HivePath, NULL);
        RTCloseKey(&RegistryContext, HiveKey);
    }

    return Error;
}

DWORD
GetRegistryFileList(
    PLIST_ENTRY ListHead
    )

/*++

Routine Description:

    This routine stores all registry file names to a list.

Arguments:

    None.

Return Value:

    NO_ERROR if everything was backed up properly, else the appropriate error code.

--*/

{
    LONG Error;
    HKEY HiveListKey;
    PWSTR KeyName;
    PWSTR FileName;
    DWORD ValueIndex;
    DWORD ValueType;
    DWORD ValueNameLength;
    DWORD ValueDataLength;
    WCHAR HiveName[ MAX_PATH ];
    WCHAR HivePath[ MAX_PATH ];
    PIMIRROR_IGNORE_FILE_LIST entry;

    //
    // enter all hardcoded files that we don't want to mirror here...
    //

    FileName = L"System Volume Information\\tracking.log";

    entry = IMirrorAllocMem(sizeof(IMIRROR_IGNORE_FILE_LIST) +
                            ((lstrlenW(FileName) + 1) * sizeof(WCHAR)));

    if (entry != NULL) {

        lstrcpyW( &entry->FileName[0], FileName );
        entry->FileNameLength = (USHORT) lstrlenW( FileName );
        InsertHeadList( ListHead, &entry->ListEntry );
    } else {
        return(ERROR_OUTOFMEMORY);
    }

    //
    // Now attach to the registry
    //
    Error = RTConnectToRegistry(MachineName,
                                HiveFileName,
                                HiveRootName,
                                NULL,
                                &RegistryContext
                               );

    if (Error != NO_ERROR) {
        return Error;
    }

    //
    // Get handle to hivelist key
    //
    KeyName = L"HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Hivelist";
    Error = RTOpenKey(&RegistryContext,
                      NULL,
                      KeyName,
                      MAXIMUM_ALLOWED,
                      0,
                      &HiveListKey
                     );

    if (Error != NO_ERROR) {
        RTDisconnectFromRegistry(&RegistryContext);
        return Error;
    }

    //
    // ennumerate entries in hivelist.  for each entry, find it's hive file
    // path then save it.
    //
    for (ValueIndex = 0; TRUE; ValueIndex++) {

        ValueType = REG_NONE;
        ValueNameLength = ARRAYSIZE( HiveName );
        ValueDataLength = sizeof( HivePath );

        Error = RTEnumerateValueKey(&RegistryContext,
                                    HiveListKey,
                                    ValueIndex,
                                    &ValueType,
                                    &ValueNameLength,
                                    HiveName,
                                    &ValueDataLength,
                                    HivePath
                                   );
        if (Error != NO_ERROR) {
            if (Error == ERROR_NO_MORE_ITEMS) {
                Error = NO_ERROR;
            }
            break;
        }

        if ((ValueType == REG_SZ) && (ValueDataLength > sizeof(UNICODE_NULL))) {

            //
            // Extract the path name from HivePath
            //
            if (_wcsicmp(HivePath, L"\\Device")) {

                FileName = HivePath + 1;
                FileName = wcsstr(FileName, L"\\");
                FileName++;
                FileName = wcsstr(FileName, L"\\");
                FileName++;     // now points to L"\winnt\system32\config\sam"

            } else if (*(HivePath + 1) == L':') {

                FileName = HivePath + 2;

            } else {

                FileName = HivePath;
            }

            entry = IMirrorAllocMem(sizeof(IMIRROR_IGNORE_FILE_LIST) +
                                    ((lstrlenW(FileName) + 1) * sizeof(WCHAR)));

            if (entry != NULL) {

                lstrcpyW( &entry->FileName[0], FileName );
                entry->FileNameLength = (USHORT) lstrlenW( FileName );
                InsertHeadList( ListHead, &entry->ListEntry );
            }
        }
    }

    RTCloseKey(&RegistryContext, HiveListKey);
    RTDisconnectFromRegistry(&RegistryContext);
    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\imirror\imirror.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    imirror.c

Abstract:

    This is the file for the IntelliMirror conversion DLL basic To Do item processing.

Author:

    Sean Selitrennikoff - 4/5/98

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Global variables
//
LIST_ENTRY GlobalToDoList;
IMIRROR_CALLBACK Callbacks;
BYTE TmpBuffer[TMP_BUFFER_SIZE];
BYTE TmpBuffer2[TMP_BUFFER_SIZE];
BYTE TmpBuffer3[TMP_BUFFER_SIZE];

BOOL fCallbackPreviouslySet = FALSE;

//
// Definitions for this file
//
typedef struct _TODOITEM {
    IMIRROR_TODO Item;
    PVOID Buffer;
    ULONG Length;
} TODOITEM, *PTODOITEM;


typedef struct _TODOLIST {
    LIST_ENTRY ListEntry;
    ULONG ToDoNum;
    TODOITEM ToDoList[1];
} TODOLIST, *PTODOLIST;



VOID
IMirrorInitCallback(
    PIMIRROR_CALLBACK pCallbacks
    )

/*++

Routine Description:

    This routine initializes the call back structure with the one supplied by the client.

Arguments:

    pCallbacks - Client supplied information for making callbacks to the client.

Return Value:

    None.

--*/

{
    if (pCallbacks != NULL) {
        Callbacks = *pCallbacks;        
    }
}

//
//
//
// Main processing loop
//
//
//
NTSTATUS
ProcessToDoItems(
    VOID
    )

/*++

Routine Description:

    This routine is the main processing loop for To Do Items.

Arguments:

    None

Return Value:

    STATUS_SUCCESS if it completed all to do items properly.

--*/

{
    IMIRROR_TODO Item;
    PVOID pBuffer;
    ULONG Length;
    NTSTATUS Status;

    Status = InitToDo();
    if ( Status != STATUS_SUCCESS )
        return Status;

    while (1) {

        Status = GetNextToDoItem(&Item, &pBuffer, &Length);

        if (!NT_SUCCESS(Status)) {
            IMirrorHandleError(Status, IMirrorNone);
            return Status;
        }

        switch (Item) {

        case IMirrorNone:
            return STATUS_SUCCESS;

        case VerifySystemIsNt5:
            Status = CheckIfNt5();
            break;

        case CheckPartitions:
            Status = CheckForPartitions();
            break;

        case CopyPartitions:
            Status = CopyCopyPartitions(pBuffer, Length);
            break;

        case CopyFiles:
            Status = CopyCopyFiles(pBuffer, Length);
            break;

        case CopyRegistry:
            Status = CopyCopyRegistry(pBuffer, Length);
            break;
        
        case RebootSystem:
            Status = Callbacks.RebootFn(Callbacks.Context);
            break;
        }

        IMirrorFreeMem(pBuffer);

    }

}

//
//
//
// TO DO Item functions
//
//
//

NTSTATUS
InitToDo(
    VOID
    )

/*++

Routine Description:

    This routine reads from the registry all the current ToDo items and puts
    them in a single TODOLIST.

Arguments:

    None

Return Value:

    STATUS_SUCCESS if it was initialized properly, else the appropriate error code.

--*/

{
    NTSTATUS Status;

    //
    // Initialize global variables
    //
    InitializeListHead(&GlobalToDoList);

    //
    // If there is nothing in the registry, presume this is a fresh start.
    //

    Status = AddCheckMachineToDoItems();

    if (!NT_SUCCESS(Status)) {
        ClearAllToDoItems(TRUE);
        return Status;
    }

    Status = AddCopyToDoItems();

    if (!NT_SUCCESS(Status)) {
        ClearAllToDoItems(TRUE);
        return Status;
    }

    if ( Callbacks.RebootFn ) {
        AddToDoItem( RebootSystem, NULL, 0 );
    }

    return STATUS_SUCCESS;
}

NTSTATUS
GetNextToDoItem(
    OUT PIMIRROR_TODO Item,
    OUT PVOID *Buffer,
    OUT PULONG Length
    )
/*++

Routine Description:

    This routine gets the next thing TODO from the global list.

    NOTE: The client is responsible for freeing Buffer.

Arguments:

    Item - Place to store the next item to process.

    Buffer - Any context for the item.

    Length - Number of bytes in Buffer.

Return Value:

    STATUS_SUCCESS if it was able to get an item, else an appropriate error code.

--*/
{
    PTODOLIST pToDoList;
    PTODOLIST pNewToDoList;
    PLIST_ENTRY pListEntry = NULL;

    *Item = IMirrorNone;
    *Buffer = NULL;
    *Length = 0;

    pToDoList = NULL;

    while (!IsListEmpty(&GlobalToDoList)) {

        //
        // Get the first list
        //
        pListEntry = RemoveHeadList(&GlobalToDoList);

        pToDoList = CONTAINING_RECORD(pListEntry,
                                      TODOLIST,
                                      ListEntry
                                     );

        if (pToDoList->ToDoNum != 0) {
            break;
        }

        IMirrorFreeMem(pToDoList);
        pToDoList = NULL;

    }

    if (IsListEmpty(&GlobalToDoList) && (pToDoList == NULL)) {
        return STATUS_SUCCESS;
    }

    if (!pListEntry) {
        return ERROR_INVALID_DATA;
    }

    ASSERT(pToDoList->ToDoNum != 0);

    //
    // Found the first item.
    //

    *Item = pToDoList->ToDoList[0].Item;
    *Buffer = pToDoList->ToDoList[0].Buffer;
    *Length = pToDoList->ToDoList[0].Length;

    if (Callbacks.RemoveToDoFn != NULL) {

        Callbacks.RemoveToDoFn( Callbacks.Context, *Item, *Buffer, *Length );
    }

    pToDoList->ToDoNum--;

    //
    // Now create a new ToDo list for anything that may get added by the processing of this item.
    // This creates an effective 'stack' of to do items, so that things get processed in the
    // correct order.
    //

    pNewToDoList = IMirrorAllocMem(sizeof(TODOLIST));

    if (pNewToDoList == NULL) {
        return STATUS_NO_MEMORY;
    }

    //
    // Do an effective "pop" on the current list, by moving everything else up the list
    //
    if (pToDoList->ToDoNum == 0) {
        IMirrorFreeMem(pToDoList);
    } else {
        RtlMoveMemory(&(pToDoList->ToDoList[0]), &(pToDoList->ToDoList[1]), sizeof(TODOITEM) * pToDoList->ToDoNum);
        InsertHeadList(&GlobalToDoList, pListEntry);
    }

    //
    // Now push on the new space for new items.
    //
    pNewToDoList->ToDoNum = 0;
    InsertHeadList(&GlobalToDoList, &(pNewToDoList->ListEntry));

    return STATUS_SUCCESS;
}

NTSTATUS
AddToDoItem(
    IN IMIRROR_TODO Item,
    IN PVOID Buffer,
    IN ULONG Length
    )
/*++

Routine Description:

    This routine adds a TODO item to the end of the current list.  It allocates
    new memory and copies the buffer.

Arguments:

    Item - The item id.

    Buffer - Buffer for any arguments, context for the item.

    Length - Length of the buffer in bytes.

Return Value:

    STATUS_SUCCESS if it was able to add the item, else an appropriate error status.

--*/

{
    PTODOLIST pNewToDoList;
    PLIST_ENTRY pListEntry;
    PBYTE pBuf;
    PTODOLIST pToDoList;
    ULONG err;

    if (Callbacks.AddToDoFn != NULL) {

        err = Callbacks.AddToDoFn( Callbacks.Context, Item, Buffer, Length );

        if (err != STATUS_SUCCESS) {

            //
            //  if the UI bounces the request, we'll treat it as success.
            //

            return STATUS_SUCCESS;
        }
    }

    //
    // Allocate space for the buffer
    //
    if (Length != 0) {

        pBuf = IMirrorAllocMem(Length);

        if (pBuf == NULL) {
            return STATUS_NO_MEMORY;
        }

    } else {
        pBuf = NULL;
    }

    //
    // Get the current TODO List
    //
    if (IsListEmpty(&GlobalToDoList)) {

        pNewToDoList = IMirrorAllocMem(sizeof(TODOLIST));
        if (pNewToDoList == NULL) {
            IMirrorFreeMem(pBuf);
            return STATUS_NO_MEMORY;
        }

        pNewToDoList->ToDoNum = 1;

    } else {

        pListEntry = RemoveHeadList(&GlobalToDoList);

        pToDoList = CONTAINING_RECORD(pListEntry,
                                      TODOLIST,
                                      ListEntry
                                     );

        //
        // Allocate space for the new item
        //
        pNewToDoList = IMirrorReallocMem(pToDoList, sizeof(TODOLIST) + sizeof(TODOITEM) * pToDoList->ToDoNum);

        if (pNewToDoList == NULL) {
            InsertHeadList(&GlobalToDoList, pListEntry);
            IMirrorFreeMem(pBuf);
            return STATUS_NO_MEMORY;
        }

        pNewToDoList->ToDoNum++;

    }

    //
    // Insert the item at the end of the list
    //
    if (pBuf != NULL) {
        RtlMoveMemory(pBuf, Buffer, Length);
    }
    pNewToDoList->ToDoList[pNewToDoList->ToDoNum - 1].Item = Item;
    pNewToDoList->ToDoList[pNewToDoList->ToDoNum - 1].Buffer = pBuf;
    pNewToDoList->ToDoList[pNewToDoList->ToDoNum - 1].Length = Length;

    pListEntry = &(pNewToDoList->ListEntry);
    InsertHeadList(&GlobalToDoList, pListEntry);

    return STATUS_SUCCESS;
}

VOID
ClearAllToDoItems(
    IN BOOLEAN MemoryOnly
    )
/*++

Routine Description:

    This routine clears out all To Do items in memory and the registry

Arguments:

    MemoryOnly - TRUE if to only clear the stuff in memory.

Return Value:

    None.

--*/
{
    PTODOLIST pToDoList;
    PLIST_ENTRY pListEntry;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Handle;
    NTSTATUS Status;

    //
    // Clear out all the items in memory
    //
    while (!IsListEmpty(&GlobalToDoList)) {

        //
        // Get the first list
        //
        pListEntry = RemoveHeadList(&GlobalToDoList);

        pToDoList = CONTAINING_RECORD(pListEntry,
                                      TODOLIST,
                                      ListEntry
                                     );

        while (pToDoList->ToDoNum != 0) {
            pToDoList->ToDoNum--;

            if (Callbacks.RemoveToDoFn != NULL) {

                Callbacks.RemoveToDoFn( Callbacks.Context,
                                        pToDoList->ToDoList[pToDoList->ToDoNum].Item,
                                        pToDoList->ToDoList[pToDoList->ToDoNum].Buffer,
                                        pToDoList->ToDoList[pToDoList->ToDoNum].Length );
            }

            if (pToDoList->ToDoList[pToDoList->ToDoNum].Length != 0) {
                IMirrorFreeMem(pToDoList->ToDoList[pToDoList->ToDoNum].Buffer);
            }
        }

        IMirrorFreeMem(pToDoList);

    }

    if (MemoryOnly) {
        return;
    }

    //
    // Now clear out the ones in the registry
    //
    RtlInitUnicodeString(&UnicodeString, L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\RemoteBoot");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                              );

    Status = NtOpenKey(&Handle,
                       KEY_ALL_ACCESS,
                       &ObjectAttributes
                      );

    if (!NT_SUCCESS(Status)) {
        return;
    }

    RtlInitUnicodeString(&UnicodeString, L"ConversionState");

    Status = NtDeleteValueKey(Handle, &UnicodeString);

    NtClose(Handle);
}

NTSTATUS
SaveAllToDoItems(
    VOID
    )
/*++

Routine Description:

    This routine writes out all To Do items in the list to the registry so that conversion
    can be restarted later.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS if it was able to save, else an appropriate error status.

--*/
{
    return STATUS_SUCCESS;
}


NTSTATUS
ModifyToDoItem(
    IN IMIRROR_TODO Item,
    IN PVOID Buffer,
    IN ULONG Length
    )
/*++

Routine Description:

    This routine changes the parameters to the first TODO item that matches Item.

Arguments:

    Item - The item id.

    Buffer - Buffer for any arguments, context for the item.

    Length - Length of the buffer in bytes.

Return Value:

    STATUS_SUCCESS if it was able to change the item, else an appropriate error status.

--*/

{
    PLIST_ENTRY pListEntry;
    LIST_ENTRY TmpGlobalList;
    PTODOLIST pToDoList;
    ULONG i;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    InitializeListHead(&TmpGlobalList);
    while (!IsListEmpty(&GlobalToDoList)) {

        //
        // Get the first list
        //
        pListEntry = RemoveHeadList(&GlobalToDoList);

        pToDoList = CONTAINING_RECORD(pListEntry,
                                      TODOLIST,
                                      ListEntry
                                     );

        //
        // Save the entry away for later
        //
        InsertTailList(&TmpGlobalList, pListEntry);

        //
        // Walk the list until we find an item that matches.
        //
        i = 0;

        while (i < pToDoList->ToDoNum) {

            if (pToDoList->ToDoList[i].Item == Item) {

                if (pToDoList->ToDoList[i].Length == Length) {

                    RtlMoveMemory(pToDoList->ToDoList[i].Buffer, Buffer, Length);

                } else {

                    PVOID pTmp;

                    pTmp = IMirrorAllocMem(Length);

                    if (pTmp == NULL) {
                        return STATUS_NO_MEMORY;
                    }

                    if (pToDoList->ToDoList[i].Length != 0) {
                        IMirrorFreeMem(pToDoList->ToDoList[i].Buffer);
                    }

                    pToDoList->ToDoList[i].Buffer = pTmp;
                    pToDoList->ToDoList[i].Length = Length;

                    RtlMoveMemory(pTmp, Buffer, Length);

                }

                Status = STATUS_SUCCESS;
                goto Done;
            }

            i++;

        }

    }

Done:

    //
    // Restore global list
    //
    while (!IsListEmpty(&TmpGlobalList)) {
        pListEntry = RemoveTailList(&TmpGlobalList);
        InsertHeadList(&GlobalToDoList, pListEntry);
    }

    return Status;
}

NTSTATUS
CopyToDoItemParameters(
    IN IMIRROR_TODO Item,
    OUT PVOID Buffer,
    IN OUT PULONG Length
    )
/*++

Routine Description:

    This routine finds the first instance of Item, and copies its current parameters into Buffer.

Arguments:

    Item - The item id.

    Buffer - The arguments, context for the item.

    Length - Length of the buffer in bytes.

Return Value:

    STATUS_SUCCESS if it was able to change the item, else an appropriate error status.

--*/

{
    PLIST_ENTRY pListEntry;
    LIST_ENTRY TmpGlobalList;
    PTODOLIST pToDoList;
    ULONG i;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    InitializeListHead(&TmpGlobalList);
    while (!IsListEmpty(&GlobalToDoList)) {

        //
        // Get the first list
        //
        pListEntry = RemoveHeadList(&GlobalToDoList);

        pToDoList = CONTAINING_RECORD(pListEntry,
                                      TODOLIST,
                                      ListEntry
                                     );

        //
        // Save the entry away for later
        //
        InsertTailList(&TmpGlobalList, pListEntry);

        //
        // Walk the list until we find an item that matches.
        //
        i = 0;

        while (i < pToDoList->ToDoNum) {

            if (pToDoList->ToDoList[i].Item == Item) {

                if (pToDoList->ToDoList[i].Length <= *Length) {

                    if (pToDoList->ToDoList[i].Length != 0) {

                        RtlMoveMemory(Buffer,
                                      pToDoList->ToDoList[i].Buffer,
                                      pToDoList->ToDoList[i].Length
                                     );

                    }

                    Status = STATUS_SUCCESS;

                } else {

                    Status = STATUS_INSUFFICIENT_RESOURCES;

                }

                *Length = pToDoList->ToDoList[i].Length;
                goto Done;
            }

            i++;

        }

    }

Done:

    //
    // Restore global list
    //
    while (!IsListEmpty(&TmpGlobalList)) {
        pListEntry = RemoveTailList(&TmpGlobalList);
        InsertHeadList(&GlobalToDoList, pListEntry);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\imirror\regtool.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    regtool.h

Abstract:

    This is the include file for the REGTOOL.DLL registry helper.

Author:

    Steve Wood (stevewo) 16-Nov-1995

Revision History:

--*/

//
// Routines for accessing registry.  Allows code to access any of the following
// registry locations with the same code:
//
//      Windows NT registry on local machine
//      Windows NT registry on remote machine
//      Windows NT hive files
//

#define REG_TARGET_DISCONNECTED    0
#define REG_TARGET_LOCAL_REGISTRY  1
#define REG_TARGET_REMOTE_REGISTRY 2
#define REG_TARGET_HIVE_REGISTRY   4

typedef struct _REG_CONTEXT_OPEN_HIVE_KEY {
    struct _REG_CONTEXT_OPEN_HIVE_KEY *Next;
    HKEY KeyHandle;
    ULONG ReferenceCount;
} REG_CONTEXT_OPEN_HIVE_KEY, *PREG_CONTEXT_OPEN_HIVE_KEY;

typedef struct _REG_CONTEXT {
    struct _REG_CONTEXT *Next;
    ULONG Target;
    HKEY MachineRoot;
    HKEY UsersRoot;
    HKEY CurrentUserRoot;
    WCHAR MachinePath[ MAX_PATH ];
    WCHAR UsersPath[ MAX_PATH ];
    WCHAR CurrentUserPath[ MAX_PATH ];
    ULONG MachinePathLength;
    ULONG UsersPathLength;
    ULONG CurrentUserPathLength;
    HKEY HiveRootHandle;
    OBJECT_ATTRIBUTES HiveRootKey;
    PREG_CONTEXT_OPEN_HIVE_KEY OpenHiveKeys;
} REG_CONTEXT, *PREG_CONTEXT;


BOOLEAN
RTEnableBackupRestorePrivilege( void );

void
RTDisableBackupRestorePrivilege( void );

LONG
RTConnectToRegistry(
    IN PWSTR MachineName,
    IN PWSTR HiveFileName,
    IN PWSTR HiveRootName,
    OUT PWSTR *DefaultRootKeyName,
    OUT PREG_CONTEXT RegistryContext
    );

LONG
RTDisconnectFromRegistry(
    IN PREG_CONTEXT RegistryContext
    );

LONG
RTCreateKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY RootKeyHandle,
    IN PCWSTR SubKeyName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG CreateOptions,
    IN PVOID SecurityDescriptor,
    OUT PHKEY ReturnedKeyHandle,
    OUT PULONG Disposition
    );


LONG
RTOpenKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY RootKeyHandle,
    IN PCWSTR SubKeyName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG OpenOptions,
    OUT PHKEY ReturnedKeyHandle
    );

#define HKEY_REGISTRY_ROOT          (( HKEY ) (ULONG_PTR)((LONG)0x8000000A) )

LONG
RTCloseKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle
    );

LONG
RTEnumerateValueKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle,
    IN ULONG Index,
    OUT PULONG ValueType,
    IN OUT PULONG ValueNameLength,
    OUT PWSTR ValueName,
    IN OUT PULONG ValueDataLength,
    OUT PVOID ValueData
    );


LONG
RTQueryValueKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle,
    IN PWSTR ValueName,
    OUT PULONG ValueType,
    IN OUT PULONG ValueDataLength,
    OUT PVOID ValueData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rbsetup\server\check.cpp ===
/************************************************************************

   Copyright (c) Microsoft Corporation 1997-1998
   All rights reserved

 ***************************************************************************/

#include "pch.h"

#include "setup.h"
#include "check.h"

DEFINE_MODULE("Check");
#define SMALL_BUFFER_SIZE 256
#define FILTER_SIZE 128
#define BIG_BUFFER        4096

//
// Ldap_InitializeConnection( )
//
DWORD
Ldap_InitializeConnection(
    PLDAP  * LdapHandle )
{
    TraceFunc( "Ldap_InitializeConnection( ... )\n" );


    DWORD LdapError = LDAP_SUCCESS;

    if ( !( *LdapHandle ) ) {
        ULONG temp = DS_DIRECTORY_SERVICE_REQUIRED |
                     DS_IP_REQUIRED;

        *LdapHandle = ldap_init( NULL, LDAP_PORT);

        if ( !*LdapHandle )
        {
            LdapError = GetLastError( );
            goto e0;
        }

        ldap_set_option( *LdapHandle, LDAP_OPT_GETDSNAME_FLAGS, &temp );

        temp = LDAP_VERSION3;
        ldap_set_option( *LdapHandle, LDAP_OPT_VERSION, &temp );

        //
        //  our searches should be contained to a single naming context, though
        //  we should be able to go outside the root of the tree to find the
        //  naming context we're interested in.
        //

        temp = LDAP_CHASE_EXTERNAL_REFERRALS;
        ldap_set_option( *LdapHandle, LDAP_OPT_REFERRALS, &temp );

        LdapError = ldap_connect( *LdapHandle, 0 );

        if ( LdapError != LDAP_SUCCESS )
            goto e1;

        LdapError = ldap_bind_s( *LdapHandle, NULL, NULL, LDAP_AUTH_SSPI );

        if ( LdapError != LDAP_SUCCESS )
            goto e1;
    }

e0:
    if ( LdapError != LDAP_SUCCESS ) {
        DebugMsg( "!!Error initializing LDAP connection.\n" );
    }
    RETURN( LdapError );

e1:
    ldap_unbind( *LdapHandle );
    *LdapHandle = NULL;
    goto e0;
}


//
// CheckDSForSCP( )
//
HRESULT
CheckDSForSCP( )
{
    TraceFunc( "CheckDSForSCP( )\n" );

    HRESULT hr = S_FALSE;
    PLDAP LdapHandle = NULL;
    DWORD LdapError = LDAP_SUCCESS;
    DWORD count;

    LPWSTR * ppszPath;
    PLDAPMessage CurrentEntry;
    PLDAPMessage LdapMessage;

    ULONG  ulSize = 0;
    LPWSTR pMachineDN = NULL;

    //  Paramters we want from the Computer Object
    LPWSTR ComputerAttrs[2];
    ComputerAttrs[0] = TEXT("netbootSCPBL");
    ComputerAttrs[1] = NULL;

    //
    // We already detected it
    //
    if ( g_Options.fBINLSCPFound ) {
        Assert( LdapError == LDAP_SUCCESS );
        hr = S_OK;
        goto e0;
    }

    if ( !GetComputerObjectName( NameFullyQualifiedDN, NULL, &ulSize ) ) {
        DWORD Error = GetLastError( );

        DebugMsg( "0 GetComputerObjectName failed (%x)\n", Error);
        MessageBoxFromStrings( NULL, IDS_DOMAINMEMBERSHIP_TITLE, IDS_DOMAINMEMBERSHIP_TEXT, MB_OK );
        hr = THR(E_FAIL);
        goto e0;
    }

    pMachineDN = (LPWSTR) TraceAlloc( LPTR, ulSize * sizeof(WCHAR) );
    
    if ( !pMachineDN ) {
        hr = THR(E_OUTOFMEMORY);
        goto e0;
    }

    if ( !GetComputerObjectName( NameFullyQualifiedDN, pMachineDN, &ulSize ) ) {
        DWORD Error = GetLastError( );
        
        DebugMsg( "1 GetComputerObjectName failed (%x)\n", Error);
        MessageBoxFromStrings( NULL, IDS_DOMAINMEMBERSHIP_TITLE, IDS_DOMAINMEMBERSHIP_TEXT, MB_OK );
        hr = THR(E_FAIL);
        goto e0;
    }

    DebugMsg( "Our MAO's DN is %s.\n", pMachineDN );

    LdapError = Ldap_InitializeConnection( &LdapHandle );
    if ( LdapError != ERROR_SUCCESS ) {
        hr = THR( HRESULT_FROM_WIN32( LdapMapErrorToWin32( LdapError ) ) );
        MessageBoxFromError( NULL, NULL, LdapMapErrorToWin32(LdapError) );
        LdapError = LDAP_SUCCESS;
        goto e0;
    }

    LdapError = ldap_search_ext_s( LdapHandle,
                                    pMachineDN,
                                    LDAP_SCOPE_BASE,
                                    L"(objectClass=computer)",
                                    ComputerAttrs,
                                    FALSE,
                                    NULL,
                                    NULL,
                                    NULL,
                                    0,
                                    &LdapMessage);

    if (LdapError == LDAP_NO_SUCH_ATTRIBUTE ) {
        DebugMsg( "SCP not found.\n" );
        LdapError = ERROR_SUCCESS;
        hr = S_FALSE;
        goto e1;
    }

    count = ldap_count_entries( LdapHandle, LdapMessage );
    if (count!= 1) {
        //
        //  What should we do with two entries for the same server?
        //
        if ( count ) {
            Assert(FALSE);
        }
        DebugMsg( "SCP not found.\n" );
        goto e2;
    }

    CurrentEntry = ldap_first_entry( LdapHandle, LdapMessage );

    ppszPath = ldap_get_values( LdapHandle, CurrentEntry, TEXT("netbootSCPBL") );
    if ( !ppszPath ) {
        DebugMsg( "SCP not found.\n" );
        LdapError = LDAP_OTHER;
        goto e2;
    }

    DebugMsg( "SCP found.\n" );

    g_Options.fBINLSCPFound = TRUE;

    hr = S_OK;

    ldap_value_free(ppszPath);

e2:
    ldap_msgfree( LdapMessage );

e1:
    ldap_unbind( LdapHandle );

e0:
    if ( LdapError != LDAP_SUCCESS ) {
        hr = S_FALSE;
    }

    if ( pMachineDN ) {
        TraceFree( pMachineDN );
    }

    HRETURN(hr);
}

//
//  This will retrieve information about the remote install share path
//
HRESULT
GetRemoteInstallShareInfo()
{
    WCHAR remInstPath[MAX_PATH];
    LPSHARE_INFO_502 psi;
    HRESULT hr = S_OK;
    NET_API_STATUS netStat;

    //
    //  See if we found the share or have setup the directory yet
    //

    if ( !g_Options.fIMirrorShareFound ||
         !g_Options.fIMirrorDirectory) {

        //
        //  Load the share name
        //

        if (LoadString( g_hinstance, 
                        IDS_REMOTEBOOTSHARENAME, 
                        remInstPath, 
                        ARRAYSIZE(remInstPath )) == 0) {

            HRETURN(HRESULT_FROM_WIN32(GetLastError()));
        }

        //
        //  See if the share exists, get path name
        //

        netStat = NetShareGetInfo( NULL, remInstPath, 502, (LPBYTE *)&psi );
        if (netStat != NERR_Success) {

            if (netStat == ERROR_MORE_DATA) {

                NetApiBufferFree( psi );
            }

            HRETURN(HRESULT_FROM_WIN32(netStat));
        }

        //
        //  The share exists, flag it
        //

        g_Options.fIMirrorShareFound = TRUE;
        DebugMsg( "Found the IMIRROR share, using it for the IntelliMirror Directory: %s\n", psi->shi502_path );

        //
        //  Save the share path name
        //

        hr = StringCbCopy(g_Options.szIntelliMirrorPath,
                          sizeof(g_Options.szIntelliMirrorPath),
                          psi->shi502_path);

        if (SUCCEEDED(hr)) {

            //
            //  If it fit, flag we got it
            //

            g_Options.fIMirrorDirectory  = TRUE;
        }

        NetApiBufferFree( psi );
    }

    HRETURN(hr);
}



//
// CheckDirectoryTree( )
//
HRESULT
CheckDirectoryTree( )
{
    HRESULT hr = S_FALSE;
    PWSTR szRemInstPath = NULL;
    

    TraceFunc( "CheckDirectoryTree()\n" );

    Assert( g_Options.hinf != INVALID_HANDLE_VALUE );

    //
    // Try to find the IMIRROR share
    //

    (void)GetRemoteInstallShareInfo();

    //
    // Try to use the TFTPD's reg key to find the IntelliMirror tree.
    //
    if ( !g_Options.fIMirrorDirectory
      && !g_Options.fTFTPDDirectoryFound ) {
        //
        // Try finding TFTPD's regkey to find the IntelliMirror Directory
        //
        HKEY  hkey;
        PWSTR szTftpPath = (PWSTR)TraceAlloc( LPTR, MAX_PATH*sizeof(WCHAR));

        if (szTftpPath) {
            if (LoadString( 
                        g_hinstance, 
                        IDS_TFTPD_SERVICE_PARAMETERS, 
                        szTftpPath,
                        MAX_PATH) && 
                ( ERROR_SUCCESS == RegOpenKeyEx( 
                                            HKEY_LOCAL_MACHINE,
                                            szTftpPath,
                                            0, // options
                                            KEY_QUERY_VALUE,
                                            &hkey ))) {
                ULONG l;
                DWORD dwType;
                LONG lErr;
    
                l = sizeof(g_Options.szTFTPDDirectory);
                lErr = RegQueryValueEx( hkey,
                                        L"Directory",
                                        0, // reserved
                                        &dwType,
                                        (LPBYTE) g_Options.szTFTPDDirectory,
                                        &l );
                Assert( wcslen(g_Options.szTFTPDDirectory) < ARRAYSIZE(g_Options.szTFTPDDirectory) );
                if ( lErr == ERROR_SUCCESS ) {
                    DebugMsg( "Found TFTPD's Directory regkey: %s\n", g_Options.szTFTPDDirectory );
                    g_Options.fTFTPDDirectoryFound = TRUE;
                }
                RegCloseKey( hkey );
            }
            TraceFree(szTftpPath);
            szTftpPath = NULL;
        }
    }

    if ( !g_Options.fIMirrorDirectory
       && g_Options.fTFTPDDirectoryFound ) {
        lstrcpyn( g_Options.szIntelliMirrorPath, g_Options.szTFTPDDirectory, ARRAYSIZE(g_Options.szIntelliMirrorPath) );
        g_Options.fIMirrorDirectory = TRUE;
        DebugMsg( "Used the TFTPD RegKey to find the IntelliMirror Directory.\n" );
    }

    //
    // Did we find the IntelliMirror directory?
    //
    if ( !g_Options.fIMirrorDirectory ) {
        //
        // Nope... so figure out which drive we can put it on.
        // Find a non-system, fixed disk, drive to place the
        // IntelliMirror directory tree
        //
        WCHAR chSystemDriveLetter;
        WCHAR chLargestDriveLetter = 0;
        ULARGE_INTEGER uliBiggestFree = { 0 };
        WCHAR szRootDrive[ 4 ] = TEXT("C:\\");
        PWSTR DefaultPath;

        DebugMsg( "Could not find the IntelliMirror directory.\n" );

        DefaultPath = (PWSTR)TraceAlloc( LPTR, MAX_PATH*sizeof(WCHAR));
        if (DefaultPath) {
        
            if (LoadString( g_hinstance, IDS_DEFAULTPATH, DefaultPath, MAX_PATH ) &&
                ExpandEnvironmentStrings( DefaultPath, g_Options.szIntelliMirrorPath, ARRAYSIZE(g_Options.szIntelliMirrorPath))) {
                
                
        
                // The default string actually contains the system drive letter
                chSystemDriveLetter = g_Options.szIntelliMirrorPath[0];
                DebugMsg(  "Searching for suitable drive:" );
        
                for( ; szRootDrive[0] <= TEXT('Z'); szRootDrive[0]++ )
                {
                    ULARGE_INTEGER uliFree;
                    ULARGE_INTEGER uliTotal;
                    ULARGE_INTEGER uliBytesFree;
                    UINT uDriveType;
        
                    DebugMsg( "%s ", szRootDrive );
        
                    uDriveType = GetDriveType( szRootDrive );
        
                    if ( DRIVE_FIXED != uDriveType
                      || szRootDrive[0] == chSystemDriveLetter )
                        continue; // skip non-fixed and non-system drives
        
                    if ( !GetDiskFreeSpaceEx( szRootDrive, &uliFree, &uliTotal, &uliBytesFree ) )
                        continue; // error - skip it.
        
                    if ( uliBytesFree.QuadPart > uliBiggestFree.QuadPart )
                    {
                        chLargestDriveLetter = szRootDrive[0];
                        uliBiggestFree = uliBytesFree;
                    }
                }
                DebugMsg( "\n" );
        
                if ( !chLargestDriveLetter )
                {
                    g_Options.szIntelliMirrorPath[0] = chSystemDriveLetter;
                    DebugMsg( "BAD! Using system drive as default.\n" );
                }
                else
                {
                    g_Options.szIntelliMirrorPath[0] = chLargestDriveLetter;
                    DebugMsg( "Suggesting %s for the IntelliMirror Drive/Directory.\n", g_Options.szIntelliMirrorPath );
                }
            } else {
                TraceFree(DefaultPath);
                DefaultPath = NULL;
                goto e0; // skip the tree
            }
            
            TraceFree(DefaultPath);
            DefaultPath = NULL;
            goto e0; // skip the tree
        } else {
            goto e0; // skip the tree
        }
    }

    //
    // Check the directory tree.
    // If any of these fail, just recreate the whole tree.
    //
    DebugMsg( "Checking Directory Tree:\n" );
    //
    // Create
    // "D:\IntelliMirror"
    //
    DebugMsg( "%s\n", g_Options.szIntelliMirrorPath );
    if ( 0xFFFFffff == GetFileAttributes( g_Options.szIntelliMirrorPath ) )
        goto e0;

    //
    // Create
    // "D:\IntelliMirror\Setup"
    //
    szRemInstPath = (PWSTR)TraceAlloc( LPTR, MAX_PATH*sizeof(WCHAR));
    if (!szRemInstPath) {
        goto e0;
    }
    
    if (_snwprintf(
               szRemInstPath,
               MAX_PATH,
               L"%s\\Setup",
               g_Options.szIntelliMirrorPath) <0) {
        TraceFree(szRemInstPath);
        szRemInstPath = NULL;
        goto e0;
    }
    szRemInstPath[MAX_PATH-1] = L'\0';
    DebugMsg( "%s\n", szRemInstPath );
    if ( 0xFFFFffff == GetFileAttributes( szRemInstPath ) ) {
        TraceFree(szRemInstPath);
        szRemInstPath = NULL;
        goto e0;
    }

    //
    // Create the OS Chooser tree
    // "D:\IntelliMirror\OSChooser"
    //
    lstrcpyn( g_Options.szOSChooserPath, g_Options.szIntelliMirrorPath, ARRAYSIZE(g_Options.szOSChooserPath) );
    ConcatenatePaths( g_Options.szOSChooserPath, L"\\OSChooser", ARRAYSIZE(g_Options.szOSChooserPath) );
    DebugMsg( "%s\n", g_Options.szOSChooserPath );
    if ( 0xFFFFffff == GetFileAttributes( g_Options.szOSChooserPath ) ) {
        TraceFree(szRemInstPath);
        szRemInstPath = NULL;
        goto e0;
    }

    g_Options.fOSChooserDirectory = TRUE;

    if ( !g_Options.fOSChooserDirectoryTreeExists ) {
        WCHAR szFile[ MAX_PATH ];
        BOOL fFound;
        INFCONTEXT context;

        fFound = SetupFindFirstLine( g_Options.hinf, L"OSChooser", NULL, &context );
        AssertMsg( fFound, "Could not find 'OSChooser' section in REMINST.INF.\n" );

        while ( fFound
             && SetupGetStringField( &context, 1, szFile, ARRAYSIZE(szFile), NULL ) )
        {
            LPWSTR psz = StrChr( szFile, L'\\' );
            if ( psz ) {
                *psz = L'\0'; // terminate
                if (_snwprintf(szRemInstPath,
                               MAX_PATH,
                               L"%s\\%s",
                               g_Options.szOSChooserPath,
                               szFile ) <0) {
                    TraceFree(szRemInstPath);
                    szRemInstPath = NULL;
                    goto e0;
                }
                
                szRemInstPath[MAX_PATH-1] = L'\0';
                DebugMsg( "%s\n", szRemInstPath );

                if ( 0xFFFFffff == GetFileAttributes( szRemInstPath ) ) {
                    TraceFree(szRemInstPath);
                    szRemInstPath = NULL;
                    goto e0;
                }
            }

            fFound = SetupFindNextLine( &context, &context );
        }

        g_Options.fOSChooserDirectoryTreeExists = TRUE;
    }

    g_Options.fDirectoryTreeExists = TRUE;
    TraceFree(szRemInstPath);
    szRemInstPath = NULL;

e0:
    
    Assert( szRemInstPath == NULL );
    if (szRemInstPath) {
        TraceFree(szRemInstPath);
        szRemInstPath = NULL;
    }

    if ( g_Options.fIMirrorDirectory
        && g_Options.fIMirrorShareFound
        && g_Options.fDirectoryTreeExists
        && g_Options.fOSChooserDirectory
        && g_Options.fOSChooserDirectoryTreeExists ) {
        DebugMsg( "All directories found.\n" );
        hr = S_OK;
    } else {
        DebugMsg( "Directory tree check failed.\n" );
    }

    HRETURN(hr);
}

BOOL
CheckService(
    SC_HANDLE schSystem,
    LPWSTR ServiceName,
    LPBOOL Started
    )
{
    SC_HANDLE sch;
    SERVICE_STATUS status;
    BOOL b;

    sch = OpenService( schSystem,
                       ServiceName,
                       SERVICE_ALL_ACCESS );
    if ( sch == NULL ) {
        DebugMsg( "%ws is NOT installed.\n", ServiceName );
        return FALSE;
    }

    DebugMsg( "%ws is installed.\n", ServiceName );

    b = QueryServiceStatus( sch, &status);
    *Started = (BOOL)(b && (status.dwCurrentState == SERVICE_RUNNING));
    DebugMsg( "%ws is %wsrunning.\n", ServiceName, *Started ? L"" : L"not " );

    CloseServiceHandle( sch );

    return TRUE;

} // CheckService

//
// CheckBINL( )
//
HRESULT
CheckBINL(
    SC_HANDLE schSystem )
{
    HRESULT   hr = S_FALSE;
    BOOL      started = TRUE;
    PWSTR szSystem32Path = NULL;
    PWSTR szFile = NULL;
    PWSTR szFullPath = NULL;

    TraceFunc( "CheckBINL( )\n" );

    //
    // Check to see if the service manager can find the service
    //
    if ( !g_Options.fBINLServiceInstalled ) {

        if ( CheckService( schSystem, L"BINLSVC", &started ) ) {
            g_Options.fBINLServiceInstalled = TRUE;
        }
    }

    //
    // Read the REMINST.INF for the files need for the service
    //
    if ( !g_Options.fBINLFilesFound ) {
        UINT  index;
        INFCONTEXT context;

        szSystem32Path = (PWSTR)TraceAlloc( LPTR, (MAX_PATH+1)*sizeof(WCHAR));
        szFile = (PWSTR)TraceAlloc( LPTR, (MAX_PATH+1)*sizeof(WCHAR));
        szFullPath = (PWSTR)TraceAlloc( LPTR, (MAX_PATH+1)*sizeof(WCHAR));
        if (!(szSystem32Path) ||
            !(szFile) ||
            !(szFullPath) ||
            !GetSystemDirectory(szSystem32Path,MAX_PATH) ||
            !SetupFindFirstLine( g_Options.hinf, L"Service.BINLSVC", L"FilesRequired", &context )) {
            Assert(FALSE);
            goto BINLCheckSCP;
        }
        
        index = 1;
        while ( SetupGetStringField( &context, index, szFile, MAX_PATH+1, NULL ) )
        {
            if (_snwprintf(
                      szFullPath,
                      MAX_PATH+1,
                      L"%s\\%s",
                      szSystem32Path,
                      szFile )<0) {
                DebugMsg( "%s is missing for Service BINLSVC.(_snwprintf failed)\n", szFile );
                goto BINLCheckSCP;
            }
            szFullPath[MAX_PATH] = L'\0';

            if ( 0xFFFFffff == GetFileAttributes( szFullPath ) ) {
                DebugMsg( "%s is missing for Service BINLSVC.\n", szFullPath );
                goto BINLCheckSCP;
            }

            DebugMsg( "%s found.\n", szFullPath );

            index++;
        }

        g_Options.fBINLFilesFound = TRUE;
    }

    
BINLCheckSCP:
    if (szSystem32Path) {
        TraceFree(szSystem32Path);
    }

    if (szFile) {
        TraceFree(szFile);
    }

    if (szFullPath) {
        TraceFree(szFullPath);
    }

    //
    // Check to see if the SCP exists
    //
    hr = CheckDSForSCP( );

    if ( hr == S_OK
      && g_Options.fBINLFilesFound
      && g_Options.fBINLServiceInstalled
      && started ) {
        DebugMsg( "All BINL services checked out OK.\n");
        hr = S_OK;
    } else if ( hr == S_OK ) {
        DebugMsg( "BINL check found something strange with the SCP. Ignoring.\n" );
        hr = S_FALSE;
    } else {
        DebugMsg( "BINL check failed.\n" );
    }

    HRETURN(hr);
}

//
// CheckTFTPD( )
//
HRESULT
CheckTFTPD(
    SC_HANDLE schSystem )
{
    HRESULT   hr = S_FALSE;
    HKEY hkey;
    BOOL      started = TRUE;
    PWSTR szSystem32Path = NULL;
    PWSTR szFile = NULL;
    PWSTR szFullPath = NULL;

    TraceFunc( "CheckTFTPD( )\n" );

    //
    // Check to see if the service manager can find the service
    //
    if ( !g_Options.fTFTPDServiceInstalled ) {

        if ( CheckService( schSystem, L"TFTPD", &started ) ) {
            g_Options.fTFTPDServiceInstalled = TRUE;
        }
    }

    //
    // Read the REMINST.INF for the files need for the service
    //
    if ( !g_Options.fTFTPDFilesFound ) {
        UINT  index;
        INFCONTEXT context;

        szSystem32Path = (PWSTR)TraceAlloc( LPTR, (MAX_PATH+1)*sizeof(WCHAR));
        szFile = (PWSTR)TraceAlloc( LPTR, (MAX_PATH+1)*sizeof(WCHAR));
        szFullPath = (PWSTR)TraceAlloc( LPTR, (MAX_PATH+1)*sizeof(WCHAR));
        if (!(szSystem32Path) ||
            !(szFile) ||
            !(szFullPath) ||
            !GetSystemDirectory(szSystem32Path,MAX_PATH) ||
            !SetupFindFirstLine( g_Options.hinf, L"Service.TFTPD", L"FilesRequired", &context )) {
            Assert(FALSE);
            goto TFTPDCheckReg;
        }

        index = 1;
        while ( SetupGetStringField( &context, index, szFile, ARRAYSIZE( szFile ), NULL ) )
        {
            if (_snwprintf( 
                      szFullPath,
                      MAX_PATH+1,
                      L"%s\\%s",
                      szSystem32Path,
                      szFile )<0) {
                DebugMsg( "%s is missing for Service TFTPD (_snwprintf failed).\n", szFile );
                goto TFTPDCheckReg;
            }
            szFullPath[MAX_PATH] = L'\0';

            if ( 0xFFFFffff == GetFileAttributes( szFullPath ) ) {
                DebugMsg( "%s is missing for Service TFTPD.\n", szFullPath );
                goto TFTPDCheckReg;
            }

            DebugMsg( "%s found.\n", szFullPath );

            index++;
        }

        g_Options.fTFTPDFilesFound = TRUE;
    }

TFTPDCheckReg:
    if (szSystem32Path) {
        TraceFree(szSystem32Path);
    }

    if (szFile) {
        TraceFree(szFile);
    }

    if (szFullPath) {
        TraceFree(szFullPath);
        szFullPath = NULL;
    }

    //
    // Check to see if the Directory reg key exists
    //
    if ( !g_Options.fTFTPDDirectoryFound ) {
        szFullPath = (PWSTR)TraceAlloc( LPTR, (MAX_PATH+1)*sizeof(WCHAR));
        if (!(szFullPath) ||
            !LoadString( g_hinstance, IDS_TFTPD_SERVICE_PARAMETERS, szFullPath, MAX_PATH+1)) {
            Assert( FALSE );
            goto e0;
        }

        if ( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                            szFullPath,
                                            0, // options
                                            KEY_QUERY_VALUE,
                                            &hkey ) ) {
            ULONG l;
            DWORD dwType;
            LONG lErr;

            l = sizeof(g_Options.szTFTPDDirectory);
            lErr = RegQueryValueEx( hkey,
                                    L"Directory",
                                    0, // reserved
                                    &dwType,
                                    (LPBYTE) g_Options.szTFTPDDirectory,
                                    &l );
            if ( lErr == ERROR_SUCCESS ) {
                DebugMsg( "TFTPD's Directory RegKey found: %s\n", g_Options.szTFTPDDirectory );
                Assert( wcslen(g_Options.szTFTPDDirectory) < ARRAYSIZE(g_Options.szTFTPDDirectory) );

                if ( 0xFFFFffff == GetFileAttributes( g_Options.szTFTPDDirectory ) ) {
                    DebugMsg( "BUT, %s was not found.\n", g_Options.szTFTPDDirectory );
                }

                g_Options.fTFTPDDirectoryFound = TRUE;
            }

            RegCloseKey( hkey );
        } else {
            DebugMsg( "HKLM\\%s not found.\n", szFullPath );
        }
    }

e0:

    if (szFullPath) {
        TraceFree(szFullPath);
        szFullPath = NULL;
    }

    if ( g_Options.fTFTPDDirectoryFound
      && g_Options.fTFTPDFilesFound
      && g_Options.fTFTPDServiceInstalled
      && started ) {
        DebugMsg( "All TFTPD services checked out OK.\n" );
        hr = S_OK;
    } else {
        DebugMsg( "TFTPD check failed.\n" );
    }

    HRETURN(hr);
}

//
// CheckSIS( )
//
HRESULT
CheckSIS(
    SC_HANDLE schSystem )
{
    HRESULT   hr = S_FALSE;
    BOOL      started = TRUE;
    PWSTR szSystem32Path = NULL;
    PWSTR szFile = NULL;
    PWSTR szFullPath = NULL;

    TraceFunc( "CheckSIS( )\n" );

    //
    // Check to see if the service manager can find the service
    //
    if ( !g_Options.fSISServiceInstalled ) {

        if ( CheckService( schSystem, L"SIS", &started ) ) {
            g_Options.fSISServiceInstalled = TRUE;
        }
    }

    //
    // Read the REMINST.INF for the files need for the service
    //
    if ( !g_Options.fSISFilesFound ) {
        UINT  index;
        INFCONTEXT context;

        szSystem32Path = (PWSTR)TraceAlloc( LPTR, (MAX_PATH+1)*sizeof(WCHAR));
        szFile = (PWSTR)TraceAlloc( LPTR, (MAX_PATH+1)*sizeof(WCHAR));
        szFullPath = (PWSTR)TraceAlloc( LPTR, (MAX_PATH+1)*sizeof(WCHAR));
        
        if (!(szSystem32Path) ||
            !(szFile) ||
            !(szFullPath) ||
            !GetSystemDirectory(szSystem32Path,MAX_PATH) ||
            !SetupFindFirstLine( g_Options.hinf, L"Service.SIS", L"FilesRequired", &context )) {
            Assert(FALSE);
            goto SISCheckVolume;
        }

        index = 1;
        while ( SetupGetStringField( &context, index, szFile, ARRAYSIZE( szFile ), NULL ) )
        {
            if (_snwprintf( 
                      szFullPath,
                      MAX_PATH+1,
                      L"%s\\%s",
                      szSystem32Path,
                      szFile )<0)
            {
                DebugMsg( "%s is missing for Service SIS (_snwprintf failed).\n", szFile );
                goto SISCheckVolume;
            }
            szFullPath[MAX_PATH] = L'\0';

            if ( 0xFFFFffff == GetFileAttributes( szFullPath ) ) {
                DebugMsg( "%s is missing for Service SIS.\n", szFullPath );
                goto SISCheckVolume;
            }

            DebugMsg( "%s found.\n", szFullPath );

            index++;
        }

        g_Options.fSISFilesFound = TRUE;
    }

SISCheckVolume:
    if (szSystem32Path) {
        TraceFree(szSystem32Path);
        szSystem32Path = NULL;
    }

    if (szFile) {
        TraceFree(szFile);
        szFile = NULL;
    }

    if (szFullPath) {
        TraceFree(szFullPath);
        szFullPath = NULL;
    }


    //
    // If we know the IMirrorDirectory (and hence the volume), check
    // to see if the Common Store Directory has been created.
    //
    if ( g_Options.fIMirrorDirectory ) {

        szFullPath = (PWSTR)TraceAlloc( LPTR, (MAX_PATH+1)*sizeof(WCHAR));
        if (!(szFullPath) ||
            FAILED(GetSisVolumePath(szFullPath,MAX_PATH+1)))
        {
            DebugMsg( "error building path to sis common store.\n" );
            goto e0;
        }

        if ( !g_Options.fSISVolumeCreated ) {
            //
            // See if the directory exists
            //
            if ( 0xFFFFffff == GetFileAttributes( szFullPath ) ) {
                DebugMsg( "%s is missing.\n", szFullPath );
                goto e0;
            }

            DebugMsg( "%s found.\n", szFullPath );

            g_Options.fSISVolumeCreated = TRUE;
        }

        //
        //  The directory exists, check its security
        //

        if ( !g_Options.fSISSecurityCorrect ) {
            if (CheckSISCommonStoreSecurity( szFullPath )) {

                g_Options.fSISSecurityCorrect = TRUE;
            }
        } 
    }

e0:
    if (szFullPath) {
        TraceFree(szFullPath);
        szFullPath = NULL;
    }

    if ( g_Options.fSISVolumeCreated
      && g_Options.fSISFilesFound
      && g_Options.fSISServiceInstalled
      && g_Options.fSISSecurityCorrect
      && started ) {
        DebugMsg( "All SIS services checked out OK.\n" );
        hr = S_OK;
    } else {
        DebugMsg( "SIS check failed.\n" );
    }

    HRETURN(hr);

}

//
// CheckSISGroveler( )
//
HRESULT
CheckSISGroveler(
    SC_HANDLE schSystem )
{
    HRESULT   hr = S_FALSE;
    BOOL      started = TRUE;
    PWSTR szSystem32Path = NULL;
    PWSTR szFile = NULL;
    PWSTR szFullPath = NULL;


    TraceFunc( "CheckSISGroveler( )\n" );

    //
    // Check to see if the service manager can find the service
    //
    if ( !g_Options.fSISGrovelerServiceInstalled ) {

        if ( CheckService( schSystem, L"Groveler", &started ) ) {
            g_Options.fSISGrovelerServiceInstalled = TRUE;
        }
    }


    //
    // Check to see if the service manager can find the service
    //
    if ( !g_Options.fSISServiceInstalled ) {

        if ( CheckService( schSystem, L"SIS", &started ) ) {
            g_Options.fSISServiceInstalled = TRUE;
        }
    }

    //
    // Read the REMINST.INF for the files need for the service
    //
    if ( !g_Options.fSISGrovelerFilesFound ) {
        UINT  index;
        INFCONTEXT context;

        szSystem32Path = (PWSTR)TraceAlloc( LPTR, (MAX_PATH+1)*sizeof(WCHAR));
        szFile = (PWSTR)TraceAlloc( LPTR, (MAX_PATH+1)*sizeof(WCHAR));
        szFullPath = (PWSTR)TraceAlloc( LPTR, (MAX_PATH+1)*sizeof(WCHAR));

        if (!(szSystem32Path) ||
            !(szFile)         ||
            !(szFullPath)     ||
            !GetSystemDirectory(szSystem32Path,MAX_PATH) ||
            !SetupFindFirstLine( g_Options.hinf, L"Service.SISGroveler", L"FilesRequired", &context )) {
            Assert(FALSE);
            goto e0;
        }

        index = 1;
        while ( SetupGetStringField( &context, index, szFile, ARRAYSIZE( szFile ), NULL ) )
        {
            if (_snwprintf( 
                      szFullPath,
                      MAX_PATH+1,
                      L"%s\\%s",
                      szSystem32Path,
                      szFile )<0) {
                DebugMsg( "%s is missing for Service SIS Groveler (_snwprintf failed).\n", szFile );
                goto e0;
            }
            szFullPath[MAX_PATH] = L'\0';

            if ( 0xFFFFffff == GetFileAttributes( szFullPath ) ) {
                DebugMsg( "%s is missing for Service SIS Groveler.\n", szFullPath );
                goto e0;
            }

            DebugMsg( "%s found.\n", szFullPath );

            index++;
        }

        g_Options.fSISGrovelerFilesFound = TRUE;
    }

    if ( g_Options.fSISGrovelerFilesFound
      && g_Options.fSISGrovelerServiceInstalled
      && started ) {
        DebugMsg( "All SIS Groveler services checked out OK.\n" );
        hr = S_OK;
    } else {
        DebugMsg( "SIS Groveler check failed.\n" );
    }

e0:
    if (szSystem32Path) {
        TraceFree(szSystem32Path);
    }

    if (szFile) {
        TraceFree(szFile);
    }

    if (szFullPath) {
        TraceFree(szFullPath);
        szFullPath = NULL;
    }


    HRETURN(hr);

}

//
// CheckRegSrvDlls( )
//
HRESULT
CheckRegSrvDlls( )
{
    HRESULT hr = S_FALSE;
    WCHAR   szSection[ SMALL_BUFFER_SIZE ];
    DWORD   dw;
    BOOL    fMissingDll = FALSE;
    BOOL    fRegistrationFailed = FALSE;
    BOOL    b;

    TraceFunc( "CheckRegSrvDlls( )\n" );

    if ( !g_Options.fRegSrvDllsFilesFound ||
        ! g_Options.fRegSrvDllsRegistered ) {
        
        dw = LoadString( g_hinstance, IDS_INF_SECTION, szSection, ARRAYSIZE( szSection ));
        Assert( dw );

        b = SetupInstallFromInfSection(NULL,            // hwndOwner
                                       g_Options.hinf,  // inf handle
                                       szSection,       // name of component
                                       SPINST_REGSVR,
                                       NULL,            // relative key root
                                       NULL,            // source root path
                                       0,               // copy flags
                                       NULL,            // callback routine
                                       NULL,            // callback routine context
                                       NULL,            // device info set
                                       NULL);           // device info struct
        if ( !b )
        {
            DWORD dwErr = GetLastError( );
            DebugMsg( "SetupInstallFromInfSection failed - error 0x%08x\n", dwErr );
            //
            // For now do extra work and try both copying and re-registering the DLL,
            // otw if we want to optimize we might be able to use the error code to 
            // determine which to do.  However, this case is extremely rare, so the 
            // simple extra work is not a burden.
            //
            fMissingDll = TRUE;
            fRegistrationFailed = TRUE;
        }
        
        g_Options.fRegSrvDllsFilesFound = !fMissingDll;
        g_Options.fRegSrvDllsRegistered = !(fMissingDll || fRegistrationFailed);
    }

    if ( g_Options.fRegSrvDllsFilesFound
      && g_Options.fRegSrvDllsRegistered ) {
        DebugMsg( "All DLLs found and registered.\n" );
        hr = S_OK;
    }

    HRETURN(hr);
}

//
// CheckOSChooser( )
//
HRESULT
CheckOSChooser( )
{
    HRESULT hr = S_FALSE;

    TraceFunc( "CheckOSChooser( )\n" );

    //
    // Make sure the OS Chooser files for all platforms
    // are installed
    //
    if ( !g_Options.fOSChooserInstalled
      && g_Options.fOSChooserDirectory ) {
        WCHAR szFile[ MAX_PATH ];
        BOOL  fFound;
        INFCONTEXT context;

        fFound = SetupFindFirstLine( g_Options.hinf, L"OSChooser", NULL, &context );
        Assert( fFound );
        if ( !fFound ) {
            DebugMsg( "Could not find 'OSChooser' section in REMINST.INF.\n" );
            goto OSChooserCheckScreens;
        }

        while ( fFound
             && SetupGetStringField( &context, 1, szFile, ARRAYSIZE(szFile), NULL ) )
        {
            WCHAR szPath[ MAX_PATH ];
            _snwprintf( szPath,
                        ARRAYSIZE(szPath),
                        L"%s\\%s",
                        g_Options.szOSChooserPath,
                        szFile );
            TERMINATE_BUFFER(szPath);

            if ( 0xFFFFffff == GetFileAttributes( szPath ) ) {
                DebugMsg( "%s is missing for OS Chooser.\n", szPath );
                goto OSChooserCheckScreens;
            }

            fFound = SetupFindNextLine( &context, &context );
        }

        DebugMsg( "All OS Chooser files found.\n" );
        g_Options.fOSChooserInstalled = TRUE;
    }

OSChooserCheckScreens:
    //
    // Check to see if all the screens are present
    //
    // Make the check only if we have a language set.
    if ( g_Options.fLanguageSet ) {

        // First check for the directory
        if ( !g_Options.fOSChooserScreensDirectory ) {
            WCHAR szOSChooserScreensPath[ MAX_PATH ];

            _snwprintf( szOSChooserScreensPath,
                        ARRAYSIZE(szOSChooserScreensPath),
                        L"%s\\%s",
                        g_Options.szOSChooserPath,
                        g_Options.szLanguage );
            TERMINATE_BUFFER(szOSChooserScreensPath);


            if ( 0xFFFFffff == GetFileAttributes( szOSChooserScreensPath ) ) {
                DebugMsg( "%s directory not found.\n", szOSChooserScreensPath );
                goto OSChooserExitCheckScreens;
            }

            DebugMsg( "%s directory found.\n", szOSChooserScreensPath );
            g_Options.fOSChooserScreensDirectory = TRUE;
        }

        // now check for files
        if ( !g_Options.fOSChooserScreens
           && g_Options.fOSChooserScreensDirectory ) {
            WCHAR szFile[ MAX_PATH ];
            BOOL  fFound;
            INFCONTEXT context;

            fFound = SetupFindFirstLine( g_Options.hinf, L"OSChooser Screens", NULL, &context );
            Assert( fFound );
            if ( !fFound )
                goto OSChooserExitCheckScreens;

            while ( fFound
                 && SetupGetStringField( &context, 1, szFile, ARRAYSIZE(szFile), NULL ) )
            {
                WCHAR szPath[ MAX_PATH ];
                _snwprintf( szPath,
                            ARRAYSIZE(szPath),
                          L"%s\\%s\\%s",
                          g_Options.szOSChooserPath,
                          g_Options.szLanguage,
                          szFile );
                TERMINATE_BUFFER(szPath);

                if ( 0xFFFFffff == GetFileAttributes( szPath ) ) {
                    DebugMsg( "%s is missing for OS Chooser.\n", szPath );
                    goto OSChooserExitCheckScreens;
                }

                fFound = SetupFindNextLine( &context, &context );
            }

            g_Options.fOSChooserScreens = TRUE;
            DebugMsg( "All OS Chooser screens found for language %s.\n", g_Options.szLanguage );
        }
    }
OSChooserExitCheckScreens:

    if ( g_Options.fOSChooserDirectory
      && g_Options.fOSChooserInstalled
      && ( !g_Options.fLanguageSet
        ||  ( g_Options.fOSChooserScreensDirectory
           && g_Options.fOSChooserScreens ) ) ) {
        DebugMsg( "All OS Chooser services checked out OK.\n" );
        hr = S_OK;
    } else {
        DebugMsg( "OS Chooser check failed.\n" );
    }

    HRETURN(hr);
}

//
// CheckServerVersion( )
//
HRESULT
CheckServerVersion( )
{
    HRESULT hr = S_OK;
    WCHAR szMajor[ SMALL_BUFFER_SIZE ];
    WCHAR szMinor[ SMALL_BUFFER_SIZE ];
    WCHAR szBuild[ SMALL_BUFFER_SIZE ];
    WCHAR szServicePack[ SMALL_BUFFER_SIZE ];
    PWSTR szSection = NULL;

    TraceFunc( "CheckServerVersion( )\n" );

    // DebugMsg( "Fudging Server Version check...\n" );
    // g_Options.fServerCompatible = TRUE;

    if ( !g_Options.fServerCompatible
       && g_Options.szWorkstationRemBootInfPath[0] ) {
        OSVERSIONINFO osver;

        hr = E_FAIL;

        osver.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
        if ( GetVersionEx( &osver ) ) {

            WCHAR szServerMajor[ 10 ];
            WCHAR szServerMinor[ 10 ];
            WCHAR szServerBuild[ 10 ];
            BOOL  fFound;
            HINF  hinf = INVALID_HANDLE_VALUE;
            UINT  uLineNum;
            INFCONTEXT context;
            
            szSection = (PWSTR)TraceAlloc( LPTR, (MAX_PATH+1)*sizeof(WCHAR));
            if (!szSection ||
                !LoadString( g_hinstance, IDS_COMPATIBILITY, szSection, MAX_PATH+1)) {
                Assert(FALSE);
                goto Error;
            }

            _snwprintf( szServerMajor, ARRAYSIZE(szServerMajor), L"%u", osver.dwMajorVersion );
            TERMINATE_BUFFER(szServerMajor);
            _snwprintf( szServerMinor, ARRAYSIZE(szServerMinor), L"%u", osver.dwMinorVersion );
            TERMINATE_BUFFER(szServerMinor);
            _snwprintf( szServerBuild, ARRAYSIZE(szServerBuild), L"%u", osver.dwBuildNumber  );
            TERMINATE_BUFFER(szServerBuild);

            DebugMsg( "Server Version: %u.%u  Build: %u  Service Pack: %s\n",
                      osver.dwMajorVersion,
                      osver.dwMinorVersion,
                      osver.dwMinorVersion,
                      osver.szCSDVersion );

            hinf = SetupOpenInfFile( g_Options.szWorkstationRemBootInfPath, NULL, INF_STYLE_WIN4, &uLineNum);
            if ( hinf == INVALID_HANDLE_VALUE ) {
                ErrorBox( NULL, g_Options.szWorkstationRemBootInfPath );
                goto Error;
            }

            fFound = SetupFindFirstLine( hinf, szSection, NULL, &context );
            if ( !fFound ) {
                ErrorBox( NULL, g_Options.szWorkstationRemBootInfPath );
                goto Error;
            }

            while ( fFound )
            {
                fFound = SetupGetStringField( &context, 1, szMajor, ARRAYSIZE(szMajor), NULL );
                Assert( fFound );
                if (!fFound)
                    break;

                fFound = SetupGetStringField( &context, 2, szMinor, ARRAYSIZE(szMinor), NULL );
                Assert( fFound );
                if (!fFound)
                    break;

                fFound = SetupGetStringField( &context, 3, szBuild, ARRAYSIZE(szBuild), NULL );
                Assert( fFound );
                if (!fFound)
                    break;

                fFound = SetupGetStringField( &context, 4, szServicePack, ARRAYSIZE(szServicePack), NULL );
                Assert( fFound );
                if (!fFound)
                    break;

                // Does it correspond to the server version?
                if ( StrCmpI( szServerMajor, szMajor ) >= 0 // must match or greater
                  && StrCmpI( szServerMinor, szMinor ) >= 0 // must match or greater
                  && StrCmpI( szServerBuild, szBuild ) >= 0 // must match or server build is greater
                  && ( szServicePack[0] == L'\0'            // ignore service pack if not specified
                     || StrCmpI( osver.szCSDVersion, szServicePack ) == 0 ) ) {
                    // found match
                    DebugMsg( "Server is compatiable with Workstation.\n");
                    hr = S_OK;
                    break;
                }

                fFound = SetupFindNextLine( &context, &context );
            }

            if ( FAILED(hr) ) {
                PWSTR szTitle = NULL;
                PWSTR szCaption = NULL;
                PWSTR szBuf = NULL;
                INFCONTEXT infcontext;

                DebugMsg( "Server doesn't look like it is compatiable with the Workstation Build.\n" );

                fFound = SetupFindFirstLine( hinf, szSection, NULL, &infcontext );
                Assert( fFound );

                fFound = SetupGetStringField( &infcontext, 1, szMajor, ARRAYSIZE(szMajor), NULL );
                Assert( fFound );

                fFound = SetupGetStringField( &infcontext, 2, szMinor, ARRAYSIZE(szMinor), NULL );
                Assert( fFound );

                fFound = SetupGetStringField( &infcontext, 3, szBuild, ARRAYSIZE(szBuild), NULL );
                Assert( fFound );

                fFound = SetupGetStringField( &infcontext, 4, szServicePack, ARRAYSIZE(szServicePack), NULL );
                Assert( fFound );

                szTitle = (PWSTR)TraceAlloc( LPTR, (MAX_PATH+1)*sizeof(WCHAR));
                szCaption = (PWSTR)TraceAlloc( LPTR, (4096)*sizeof(WCHAR));
                szBuf = (PWSTR)TraceAlloc( LPTR, (4096)*sizeof(WCHAR));

                if ((szTitle)   &&
                    (szCaption) &&
                    (szBuf)     &&
                    LoadString( g_hinstance, IDS_INCOMPATIBLE_SERVER_VERSION_TITLE, szTitle, MAX_PATH+1) &&
                    LoadString( g_hinstance, IDS_INCOMPATIBLE_SERVER_VERSION_CAPTION, szBuf, 4096) &&
                    _snwprintf(
                         szCaption, 
                         4096,
                         szBuf,
                         szMajor, 
                         szMinor, 
                         szBuild, 
                         szServicePack) >=0) {
                    szCaption[4096-1] = L'\0';
                    MessageBox( NULL, szCaption, szTitle, MB_OK );
                } else {
                    Assert(FALSE);
                }
                if (szTitle) {
                    TraceFree(szTitle);
                }
                if (szBuf) {
                    TraceFree(szBuf);
                }
                if (szCaption) {
                    TraceFree(szCaption);
                }
                Assert( hr == E_FAIL );
            }

Error:
            if ( hinf != INVALID_HANDLE_VALUE ) {
                SetupCloseInfFile( hinf );
            }
        }

        g_Options.fServerCompatible = ( hr == S_OK );

    }

    if (szSection) {
        TraceFree(szSection);
    }

    if (g_Options.fServerCompatible ) {
        DebugMsg( "Server compatibility checked out OK.\n" );
        hr = S_OK;
    } else {
        DebugMsg( "Server compatibility failed.\n" );
    }

    HRETURN(hr);
}

//
// CheckFirstInstall( )
//
// This really checks for the existence of the REMINST directory
// under the system32 directory which was created during OCM setup.
//
HRESULT
CheckFirstInstall( )
{
    HRESULT hr = S_OK;

    TraceFunc( "CheckFirstInstall( )\n" );

    if ( !g_Options.fRemBootDirectory ) {
        DWORD dw;
        WCHAR      szFilePath[ MAX_PATH ];

        dw = ExpandEnvironmentStrings( TEXT("%windir%"), g_Options.szRemBootDirectory, ARRAYSIZE(g_Options.szRemBootDirectory) );
        Assert( dw );

        lstrcpyn( szFilePath, g_Options.szRemBootDirectory, ARRAYSIZE(szFilePath) );
        wcsncat( szFilePath, L"\\System32\\reminst.inf", ARRAYSIZE(szFilePath) - lstrlen(szFilePath) );
        TERMINATE_BUFFER(szFilePath);

        wcsncat( g_Options.szRemBootDirectory, L"\\System32\\REMINST", ARRAYSIZE(g_Options.szRemBootDirectory) - lstrlen(g_Options.szRemBootDirectory) );
        TERMINATE_BUFFER(g_Options.szRemBootDirectory);

        if ( 0xFFFFffff != GetFileAttributes( g_Options.szRemBootDirectory ) ) 
        {
            DebugMsg( "Found the %s directory.\n", g_Options.szRemBootDirectory );

            HINF       hinf = INVALID_HANDLE_VALUE;
            INFCONTEXT context;

            // now check to see if the files are still in there.
            hinf = SetupOpenInfFile( szFilePath, NULL, INF_STYLE_WIN4, NULL );
            if ( hinf != INVALID_HANDLE_VALUE )
            {
                WCHAR szFile[ MAX_PATH ];
                BOOL  fFound;

                fFound = SetupFindFirstLine( hinf, L"OSChooser", NULL, &context );
                Assert( fFound );
                if ( !fFound ) {
                    DebugMsg( "Could not find 'OSChooser' section in REMINST.INF.\n" );
                    hr = S_FALSE;
                    goto bail;
                }

                lstrcpyn( szFilePath, g_Options.szRemBootDirectory, ARRAYSIZE(szFilePath) );
                wcsncat( szFilePath, L"\\", ARRAYSIZE(szFilePath) - lstrlen(szFilePath) );
                TERMINATE_BUFFER(szFilePath);
                dw = (DWORD)wcslen( szFilePath );

                while ( fFound )
                {
                    fFound = SetupGetStringField( &context, 2, szFile, ARRAYSIZE(szFile), NULL );
                    if ( !fFound )
                    {
                        fFound = SetupGetStringField( &context, 2, szFile, ARRAYSIZE(szFile), NULL );
                        if ( !fFound )
                            goto skipit;
                    }

                    lstrcpyn( &szFilePath[ dw ], szFile, ARRAYSIZE(szFilePath) - dw );

                    if ( 0xFFFFffff == GetFileAttributes( szFilePath ) ) {
                        DebugMsg( "%s is missing.\n", szFilePath );
                        goto bail;
                    }

skipit:
                    fFound = SetupFindNextLine( &context, &context );
                }

                DebugMsg( "All REMINST files found.\n" );
                g_Options.fRemBootDirectory = TRUE;
            }
            else
            {
                DebugMsg( "File not found. Error 0x%08x\n", GetLastError( ) );
            }

bail:
            if ( hinf != INVALID_HANDLE_VALUE )
            {
                SetupCloseInfFile( hinf );
            }
        }
    }

    if ( g_Options.fRemBootDirectory )
    {
        DebugMsg( "REMINST directory checked out OK.\n" );
    }
    else
    {
        DebugMsg( "REMINST directory is missing or missing files. This may require the server CD.\n ");
    }

    HRETURN(hr);
}

//
// CheckRegistry( )
//
HRESULT
CheckRegistry( )
{
    HRESULT    hr = S_FALSE;
    WCHAR      szSection[ SMALL_BUFFER_SIZE ];
    INFCONTEXT context;
    BOOL       fFound;
    DWORD      dw;
    INT        index;

    TraceFunc( "CheckRegistry( )\n" );

    if ( !g_Options.fRegistryIntact ) {
        dw = LoadString( g_hinstance, IDS_INF_SECTION, szSection, ARRAYSIZE( szSection ) );
        Assert( dw );

        fFound = SetupFindFirstLine( g_Options.hinf, szSection, L"AddReg", &context );
        Assert( fFound );
        if ( !fFound )
            goto Error;

        // Assume SUCCESS and use it to exit the loop early
        g_Options.fRegistryIntact = TRUE;

        DebugMsg( "Checking Registry:\n" );

        index = 1;
        while ( g_Options.fRegistryIntact
             && SetupGetStringField( &context, index, szSection, ARRAYSIZE(szSection), NULL ) )
        {
            INFCONTEXT subcontext;
            fFound = SetupFindFirstLine( g_Options.hinf, szSection, NULL, &subcontext );
            Assert( fFound );

            while ( fFound && g_Options.fRegistryIntact )
            {
                WCHAR szRootKey[ 10 ];
                WCHAR szBaseKey[ MAX_PATH ];
                WCHAR szValueName[ MAX_PATH ];
                HKEY  hkeyRoot = NULL;
                HKEY  hkeyBase;
                LONG  lResult;

                SetupGetStringField( &subcontext, 1, szRootKey, ARRAYSIZE(szRootKey), NULL );
                SetupGetStringField( &subcontext, 2, szBaseKey, ARRAYSIZE(szBaseKey), NULL );
                SetupGetStringField( &subcontext, 3, szValueName, ARRAYSIZE(szValueName), NULL );

                DebugMsg( "%s, %s, %s - ", szRootKey, szBaseKey, szValueName );

                if ( _wcsicmp( szRootKey, L"HKLM" ) == 0 ) {
                    hkeyRoot = HKEY_LOCAL_MACHINE;
                } else if ( _wcsicmp( szRootKey, L"HKCU" ) == 0 ) {
                    hkeyRoot = HKEY_CURRENT_USER;
                } else if ( _wcsicmp( szRootKey, L"HKCC" ) == 0 ) {
                    hkeyRoot = HKEY_CURRENT_CONFIG;
                } else if ( _wcsicmp( szRootKey, L"HKCR" ) == 0 ) {
                    hkeyRoot = HKEY_CLASSES_ROOT;
                }

                //
                // If this Assert() fires, it is because the INF is malformed
                //
                Assert( hkeyRoot );

                if ( hkeyRoot == NULL )
                    continue;

                
                lResult = RegOpenKeyEx( hkeyRoot, szBaseKey, 0, KEY_QUERY_VALUE, &hkeyBase );
                if ( lResult == ERROR_SUCCESS )
                {
                    lResult = RegQueryValueEx( hkeyBase, szValueName, 0, NULL, NULL, NULL );
                    if ( lResult != ERROR_SUCCESS ) {
                        DebugMsg("NOT " );
                        g_Options.fRegistryIntact = FALSE;
                        hr = S_FALSE;
                    }

                    RegCloseKey( hkeyBase );
                } else {
                    DebugMsg("NOT " );
                    g_Options.fRegistryIntact = FALSE;
                    hr = S_FALSE;
                }

                DebugMsg("found.\n" );
                
                fFound = SetupFindNextLine( &subcontext, &subcontext );
            }

            index++;
        }
    }

    if ( g_Options.fRegistryIntact ) {
        DebugMsg( "Registry checked out OK.\n" );
        hr = S_OK;
    } else {
        DebugMsg( "Registry check failed.\n" );
    }

Error:
    HRETURN(hr);
}

//
// Paranoid( )
//
// Catch all for double checking that common things across services
// match up.
//
HRESULT
Paranoid( )
{
    HRESULT hr = S_OK;

    TraceFunc( "Paranoid( )\n" );

    // Make sure that the IntelliMirror directory are the same
    // for TFTPD and for the IMIRROR share (binlsvc uses this).
    if ( g_Options.fIMirrorDirectory
      && g_Options.fTFTPDDirectoryFound
      && StrCmpI( g_Options.szIntelliMirrorPath, g_Options.szTFTPDDirectory ) != 0 ) {
        //
        // If they are not the same, force the registry to modify the TFTPD key.
        //
        DebugMsg( "TFTPD doesn't agree with IMIRROR share. Forcing TFTPD registry update.\n" );
        g_Options.fTFTPDDirectoryFound = FALSE;
        hr = S_FALSE;
    }

    if ( hr != S_OK ) {
        DebugMsg( "Paranoid found a problem.\n" );
    } else {
        DebugMsg( "Paranoid is happy. 8~)\n" );
    }

    HRETURN( hr );
}

//
// CheckInstallation( )
//
HRESULT
CheckInstallation( )
{
    HRESULT hr = S_OK;
    BOOL    fSomethingbroke = FALSE;
    BOOL    fSomethingFailed = FALSE;
    DWORD   dw;
    DWORD   dwLen;
    UINT    uLineNum;
    SC_HANDLE  schSystem;
    WCHAR   szServerRemBootInfPath[ MAX_PATH ];
    CWaitCursor Wait;

    TraceFunc( "CheckInstallation( )\n");

    szServerRemBootInfPath[0] = L'\0';
    dw = ExpandEnvironmentStrings( TEXT("%SystemRoot%"), szServerRemBootInfPath, ARRAYSIZE( szServerRemBootInfPath ));
    Assert( dw );

    ConcatenatePaths( szServerRemBootInfPath, L"\\System32\\", ARRAYSIZE(szServerRemBootInfPath) );
    
    dwLen = lstrlen( szServerRemBootInfPath );
    dw = LoadString( g_hinstance, IDS_REMBOOTINF, &szServerRemBootInfPath[dwLen], ARRAYSIZE( szServerRemBootInfPath ) - dwLen );
    Assert( dw );

    if ( 0xFFFFffff == GetFileAttributes( szServerRemBootInfPath ) ) {
        MessageBoxFromStrings( NULL,
                               IDS_MISSING_INF_TITLE,
                               IDS_MISSING_INF_MESSAGE,
                               MB_OK );
        fSomethingbroke = TRUE;
        goto e0;
    }

    if ( g_Options.hinf == INVALID_HANDLE_VALUE ) {
        g_Options.hinf = SetupOpenInfFile( szServerRemBootInfPath, NULL, INF_STYLE_WIN4, &uLineNum);
        Assert( g_Options.hinf != INVALID_HANDLE_VALUE );
        if ( g_Options.hinf == INVALID_HANDLE_VALUE ) {
            fSomethingbroke = TRUE;
            goto e0;
        }
    }

    hr = CheckServerVersion( );
    if ( FAILED(hr) ) {
        fSomethingbroke = TRUE;
        goto e0;
    }
    if ( hr == S_FALSE ) {
        fSomethingFailed = TRUE;
    }

    hr = CheckFirstInstall( );
    if ( FAILED(hr) ) {
        fSomethingbroke = TRUE;
    }
    if ( hr == S_FALSE ) {
        fSomethingFailed = TRUE;
    }

    hr = CheckDirectoryTree( );
    if ( FAILED(hr) ) {
        fSomethingbroke = TRUE;
    }
    if ( hr == S_FALSE ) {
        fSomethingFailed = TRUE;
    }

    schSystem = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );
    if ( !schSystem ) {
        hr = THR(E_FAIL);
        fSomethingbroke = TRUE;
        WCHAR szCaption[SMALL_BUFFER_SIZE]; 
        DWORD LoadStringResult;
        szCaption[0] = L'\0';
        LoadStringResult = LoadString( g_hinstance, IDS_OPENING_SERVICE_MANAGER_TITLE, szCaption, ARRAYSIZE( szCaption ));
        Assert( LoadStringResult );
        ErrorBox( NULL, szCaption );
        goto e0;
    }

    Assert( schSystem );

    if ( schSystem ) {
        hr = CheckBINL( schSystem );
        if ( FAILED(hr) ) {
            fSomethingbroke = TRUE;
        }
        if ( hr == S_FALSE ) {
            fSomethingFailed = TRUE;
        }

        hr = CheckTFTPD( schSystem );
        if ( FAILED(hr) ) {
            fSomethingbroke = TRUE;
        }
        if ( hr == S_FALSE ) {
            fSomethingFailed = TRUE;
        }

        hr = CheckSIS( schSystem );
        if ( FAILED(hr) ) {
            fSomethingbroke = TRUE;
        }
        if ( hr == S_FALSE ) {
            fSomethingFailed = TRUE;
        }

        hr = CheckSISGroveler( schSystem );
        if ( FAILED(hr) ) {
            fSomethingbroke = TRUE;
        }
        if ( hr == S_FALSE ) {
            fSomethingFailed = TRUE;
        }

        CloseServiceHandle( schSystem );
    }

    hr = CheckRegSrvDlls( );
    if ( FAILED(hr) ) {
        fSomethingbroke = TRUE;
    }
    if ( hr == S_FALSE ) {
        fSomethingFailed = TRUE;
    }

    hr = CheckRegistry( );
    if ( FAILED(hr) ) {
        fSomethingbroke = TRUE;
    }
    if ( hr == S_FALSE ) {
        fSomethingFailed = TRUE;
    }

    hr = CheckOSChooser( );
    if ( FAILED(hr) ) {
        fSomethingbroke = TRUE;
    }
    if ( hr == S_FALSE ) {
        fSomethingFailed = TRUE;
    }

    hr = Paranoid( );
    if ( FAILED(hr) ) {
        fSomethingbroke = TRUE;
    }
    if ( hr == S_FALSE ) {
        fSomethingFailed = TRUE;
    }

e0:
    if ( fSomethingbroke ) {
        DebugMsg( "Something is broken. Installation check failed to complete.\n" );
        hr = E_FAIL;
    } else if ( fSomethingFailed ) {
        DebugMsg( "Installation check found something wrong.\n" );
        hr = S_FALSE;
    } else {
        DebugMsg( "Installation check succeeded.\n" );
        hr = S_OK;
    }

    HRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rbsetup\server\automate.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997-1999
   All rights reserved

 ***************************************************************************/

#ifndef _AUTOMATE_H_
#define _AUTOMATE_H_

HRESULT
GetAutomatedOptions( );


#endif // _AUTOMATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rbsetup\server\debug.cpp ===
/****************************************************************************

  Copyright (c) Microsoft Corporation 1997
  All rights reserved

  File: DEBUG.CPP

  Debugging utilities

 ***************************************************************************/

#include "pch.h"
#include <shlwapi.h>

DEFINE_MODULE("Debug");

#ifdef DEBUG

// Constants
#define DEBUG_OUTPUT_BUFFER_SIZE  512

// Globals
DWORD g_TraceMemoryIndex = 0;
DWORD g_dwCounter        = 0;
DWORD g_dwTraceFlags     = 0;
CRITICAL_SECTION g_DebugCS;
BOOL  g_fDebugInitialized = FALSE;

// Statics
const TCHAR g_szNULL[]    = TEXT("");
const TCHAR g_szTrue[]    = TEXT("True");
const TCHAR g_szFalse[]   = TEXT("False");
const TCHAR g_szFormat[]  = TEXT("%-50s  %-10.10s ");
const TCHAR g_szUnknown[] = TEXT("<unknown>");

//
// Adds 'g_dwCounter' spaces to debug spew
//
void
dbgspace( void )
{
    for( DWORD dw = 1; dw < g_dwCounter; dw++ )
        DebugMsg( "| " );
}

//
// Makes sure multiple threads don't trample debugging output.
//
void
dbgEnterCS( void )
{
    if ( !g_fDebugInitialized )
    {
        //
        // There is NO matching DeleteCriticalSection( ) since
        // this is only used for debugging purposes.
        //
        InitializeCriticalSection( &g_DebugCS );
        g_fDebugInitialized = TRUE;
    }

    EnterCriticalSection( &g_DebugCS );
}

void
dbgExitCS( void )
{
    LeaveCriticalSection( &g_DebugCS );
}

//
// Takes the filename and line number and put them into a string buffer.
//
// NOTE: the buffer is assumed to be of size DEBUG_OUTPUT_BUFFER_SIZE.
//
LPTSTR
dbgmakefilelinestring(
    LPTSTR  pszBuf,
    LPCTSTR pszFile,
    const int uLine )
{
    LPVOID args[2];

    args[0] = (LPVOID) pszFile;
    args[1] = IntToPtr(uLine);

    FormatMessage(
        FORMAT_MESSAGE_FROM_STRING |
            FORMAT_MESSAGE_ARGUMENT_ARRAY,
        TEXT("%1(%2!u!):"),
        0,                          // error code
        0,                          // default language
        (LPTSTR) pszBuf,            // output buffer
        DEBUG_OUTPUT_BUFFER_SIZE,   // size of buffer
        (va_list*) args );           // arguments

    return pszBuf;
}



//
// TraceMsg() - ascii
//
void
TraceMsg(
    DWORD dwCheckFlags,
    LPCSTR pszFormat,
    ... )
{
    va_list valist;

    if (( dwCheckFlags == TF_ALWAYS
       || !!( g_dwTraceFlags & dwCheckFlags ) ))
    {
        TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];

        TCHAR  szFormat[ DEBUG_OUTPUT_BUFFER_SIZE ];
        mbstowcs( szFormat, pszFormat, lstrlenA( pszFormat ) + 1 );

        va_start( valist, pszFormat );
        wvsprintf( szBuf, szFormat, valist );
        va_end( valist );

        dbgEnterCS( );

        OutputDebugString( szBuf );

        dbgExitCS( );
    }
}


//
// TraceMessage()
//
void
TraceMessage(
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    DWORD   dwCheckFlags,
    LPCTSTR pszFormat,
    ... )
{
    va_list valist;

    if (( dwCheckFlags == TF_ALWAYS
       || !!( g_dwTraceFlags & dwCheckFlags ) ))
    {
        TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];

        if ( !pszModule )
        {
            pszModule = g_szUnknown;
        }

        if ( !pszFile )
        {
            wsprintf( szBuf, g_szFormat, g_szNULL, pszModule );
        }
        else
        {
            TCHAR szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

            dbgmakefilelinestring( szFileLine, pszFile, uLine );
            wsprintf( szBuf, g_szFormat, szFileLine, pszModule );
        }

        dbgEnterCS( );

        OutputDebugString( szBuf );

        dbgspace( );

        va_start( valist, pszFormat );
        wvsprintf( szBuf, pszFormat, valist );
        va_end( valist );

        OutputDebugString( szBuf );

        dbgExitCS( );
    }

}

//
// DebugMsg()
//
void
DebugMsg(
    LPCSTR pszFormat,
    ... )
{
    va_list valist;
    TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];
    TCHAR  szFormat[ DEBUG_OUTPUT_BUFFER_SIZE ];
    
    mbstowcs( szFormat, pszFormat, lstrlenA( pszFormat ) + 1 );

    va_start( valist, pszFormat );
    wvsprintf( szBuf, szFormat, valist);
    va_end( valist );

    dbgEnterCS( );

    OutputDebugString( szBuf );

    dbgExitCS( );
}

//
// Displays a dialog box with the failed assertion. User has the option of
// breaking.
//
BOOL
AssertMessage(
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    LPCTSTR pszfn,
    BOOL    fTrue )
{
    if ( !fTrue )
    {
        TCHAR szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];
        TCHAR szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

        // Make sure everything is cool before we blow up somewhere else.
        if ( pszFile == NULL )
        {
            pszFile = g_szNULL;
        }

        if ( pszModule == NULL )
        {
            pszModule = g_szNULL;
        }

        if ( pszfn == NULL )
        {
            pszfn = g_szNULL;
        }

        dbgmakefilelinestring( szFileLine, pszFile, uLine );

        wsprintf( szBuf, TEXT("%-50s  %-10s ASSERT: %s\n"),
            szFileLine, pszModule, pszfn );

        dbgEnterCS( );

        OutputDebugString( szBuf );

        dbgExitCS( );

        wsprintf( szBuf, TEXT("Module:\t%s\t\nLine:\t%u\t\nFile:\t%s\t\n\nAssertion:\t%s\t\n\nDo you want to break here?"),
            pszModule, uLine, pszFile, pszfn );

        if ( IDNO == MessageBox( NULL, szBuf, TEXT("Assertion Failed!"),
                MB_YESNO|MB_ICONWARNING ) )
            fTrue = !FALSE;   // don't break

    }

    return !fTrue;

}

//
// Traces HRESULT errors. A dialog will appear is there is an error
// in the hr.
//
HRESULT
TraceHR(
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    LPCTSTR pszfn,
    HRESULT hr )
{
    static const LPTSTR pcszFalse = TEXT("S_FALSE\n");

    if ( !( g_dwTraceFlags & TF_HRESULTS ) )
        return hr; // bail

    if ( hr != NOERROR )
    {
        TCHAR  szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];
        TCHAR  szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];
        PTSTR  pszMsgBuf = NULL;

        switch ( hr )
        {
        case S_FALSE:
            pszMsgBuf = pcszFalse;
            break;

        default:
            FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER
                | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                hr,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                (LPTSTR)&pszMsgBuf,
                0,
                NULL
            );
        }

        // Make sure everything is cool before we blow up somewhere else.
        if ( pszMsgBuf == NULL )
        {
            pszMsgBuf = TEXT("<unknown error code returned>\n");
        }
        Assert( pszFile != NULL );
        Assert( pszModule != NULL );
        Assert( pszfn != NULL );

        dbgmakefilelinestring( szFileLine, pszFile, uLine );

        wsprintf( szBuf, TEXT("%-50s  %-10s HRESULT: hr = 0x%08x - %s"),
            szFileLine, pszModule, hr, pszMsgBuf );

        dbgEnterCS( );

        OutputDebugString( szBuf );

        dbgExitCS( );

        wsprintf( szBuf, TEXT("Module:\t%s\t\nLine:\t%u\t\nFile:\t%s\t\n\nFunction:\t%s\t\nhr =\t0x%08x - %s\t\nDo you want to break here?"),
            pszModule, uLine, pszFile, pszfn, hr, pszMsgBuf );

        if ( IDYES == MessageBox( NULL, szBuf, TEXT("Trace HRESULT"),
                MB_YESNO|MB_ICONWARNING ) )
            DEBUG_BREAK;

        if ( pszMsgBuf != pcszFalse ) {
            LocalFree( pszMsgBuf );
        }
    }

    return hr;

}


//
// Memory allocation and tracking
//

typedef struct _MEMORYBLOCK {
    HGLOBAL hglobal;
    DWORD   dwBytes;
    UINT    uFlags;
    LPCTSTR pszFile;
    UINT    uLine;
    LPCTSTR pszModule;
    LPCTSTR pszComment;
    _MEMORYBLOCK *pNext;
} MEMORYBLOCK, *LPMEMORYBLOCK;

//
// Adds a MEMORYBLOCK to the memory tracking list.
//
HGLOBAL
DebugMemoryAdd(
    HGLOBAL hglobal,
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCTSTR pszComment )
{
    if ( hglobal )
    {
        LPMEMORYBLOCK pmbHead = (LPMEMORYBLOCK) TlsGetValue( g_TraceMemoryIndex );
        LPMEMORYBLOCK pmb     = (LPMEMORYBLOCK) GlobalAlloc(
                                                    GMEM_FIXED,
                                                    sizeof(MEMORYBLOCK) );

        if ( !pmb )
        {
            GlobalFree( hglobal );
            return NULL;
        }

        pmb->hglobal    = hglobal;
        pmb->dwBytes    = dwBytes;
        pmb->uFlags     = uFlags;
        pmb->pszFile    = pszFile;
        pmb->uLine      = uLine;
        pmb->pszModule  = pszModule;
        pmb->pszComment = pszComment;
        pmb->pNext      = pmbHead;

        TlsSetValue( g_TraceMemoryIndex, pmb );
        TraceMessage( pmb->pszFile,
                      pmb->uLine,
                      pmb->pszModule,
                      TF_MEMORYALLOCS,
                      L"Alloced %s - %u bytes at 0x%08x (pmb=0x%08x)\n",
                      pszComment,
                      dwBytes,
                      pmb->hglobal,
                      pmb );
    }

    return hglobal;
}

//
// Removes a MEMORYBLOCK to the memory tracking list.
//
void
DebugMemoryDelete(
    HGLOBAL hglobal )
{
    if ( hglobal )
    {
        LPMEMORYBLOCK pmbHead = (LPMEMORYBLOCK) TlsGetValue( g_TraceMemoryIndex );
        LPMEMORYBLOCK pmbLast = NULL;

        while ( pmbHead && pmbHead->hglobal != hglobal )
        {
            pmbLast = pmbHead;
            pmbHead = pmbLast->pNext;
        }

        if ( pmbHead )
        {
            if ( pmbLast )
            {
                pmbLast->pNext = pmbHead->pNext;
            }
            else
            {
                TlsSetValue( g_TraceMemoryIndex, pmbHead->pNext );
            }

            TraceMessage( pmbHead->pszFile,
                          pmbHead->uLine,
                          pmbHead->pszModule,
                          TF_MEMORYALLOCS,
                          L"Freeing %s - %u bytes from 0x%08x (pmb=0x%08x)\n",
                          pmbHead->pszComment,
                          pmbHead->dwBytes,
                          pmbHead->hglobal,
                          pmbHead );
            GlobalFree( pmbHead );
        }
        else
        {
            DebugMsg( "\n**** Attempted to free memory at 0x%08x (ThreadID = 0x%08x) ****\n\n",
                hglobal, GetCurrentThreadId( ) );
        }
    }
}

//
// Allocates memory and adds the MEMORYBLOCK to the memory tracking list.
//
HGLOBAL
DebugAlloc(
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCTSTR pszComment )
{
    HGLOBAL       hglobal = GlobalAlloc( uFlags, dwBytes );

    return DebugMemoryAdd( hglobal, pszFile, uLine, pszModule, uFlags, dwBytes, pszComment );
}

//
// Remove the MEMORYBLOCK to the memory tracking list, memsets the
// memory to 0xFE and then frees the memory.
//
HGLOBAL
DebugFree(
    HGLOBAL hglobal )
{
    DebugMemoryDelete( hglobal );

    return GlobalFree( hglobal );
}

//
// Checks the memory tracking list. If it is not empty, it will dump the
// list and break.
//
void
DebugMemoryCheck( )
{
    BOOL          fFoundLeak = FALSE;
    LPMEMORYBLOCK pmb = (LPMEMORYBLOCK) TlsGetValue( g_TraceMemoryIndex );

    dbgEnterCS( );

    while ( pmb )
    {
        LPVOID args[ 5 ];
        TCHAR  szOutput[ DEBUG_OUTPUT_BUFFER_SIZE ];
        TCHAR  szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

        if ( fFoundLeak == FALSE )
        {
            DebugMsg("\n******** Memory leak detected ******** ThreadID = 0x%08x ******** \n\n", GetCurrentThreadId( ) );
               //OutputDebugString("12345678901234567890123456789012345678901234567890  1234567890 X 0x12345678  12345  1...");
            OutputDebugString(TEXT("Filename(Line Number):                              Module     Addr/HGLOBAL  Size   String\n"));
            fFoundLeak = TRUE;
        }

        if ( StrCmp( pmb->pszComment, TEXT("new( )" ) ) == 0 )
        {
            wsprintf(
                szFileLine,
                TEXT("Caller unknown - (Module %s, line %d)"),
                pmb->pszModule,
                pmb->uLine );
        }
        else
        {
            dbgmakefilelinestring( szFileLine, pmb->pszFile, pmb->uLine );
        }

        args[0] = (LPVOID) pmb->hglobal;
        args[1] = (LPVOID) szFileLine;
        args[2] = (LPVOID) pmb->pszComment;
        args[3] = UlongToPtr(pmb->dwBytes);
        args[4] = (LPVOID) pmb->pszModule;

        if ( !!(pmb->uFlags & GMEM_MOVEABLE) )
        {
            FormatMessage(
                FORMAT_MESSAGE_FROM_STRING |
                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                TEXT("%2!-50s!  %5!-10s! H 0x%1!08x!  %4!-5u!  \"%3\"\n"),
                0,                          // error code
                0,                          // default language
                (LPTSTR) szOutput,         // output buffer
                ARRAYSIZE( szOutput ),   // size of buffer
                (va_list*) args );           // arguments
        }
        else
        {
            FormatMessage(
                FORMAT_MESSAGE_FROM_STRING |
                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                TEXT("%2!-50s!  %5!-10s! A 0x%1!08x!  %4!-5u!  \"%3\"\n"),
                0,                          // error code
                0,                          // default language
                (LPTSTR) szOutput,         // output buffer
                ARRAYSIZE( szOutput ),   // size of buffer
                (va_list*) args );           // arguments
        }

        OutputDebugString( szOutput );

        pmb = pmb->pNext;
    }

    if ( fFoundLeak == TRUE )
    {
        OutputDebugString(TEXT("\n***************************** Memory leak detected *****************************\n\n"));
    }

    dbgExitCS( );

    Assert( !fFoundLeak );

}

//
// Global Management Functions -
//
// These are in debug and retail but internally they change
// depending on the build.
//
#undef new
void* __cdecl operator new( size_t nSize, LPCTSTR pszFile, const int iLine, LPCTSTR pszModule )
{
    return DebugAlloc( pszFile, iLine, pszModule, GPTR, (DWORD)nSize, TEXT("new( )") );
}

void * __cdecl operator new(size_t t_size )
{
    UNREFERENCED_PARAMETER(t_size);
    AssertMsg( 0, "Macro failure" );
    return NULL;
}

void __cdecl operator delete(void *pv)
{
    TraceFree( pv );
}

int __cdecl _purecall(void)
{
    return 0;
}

#else // ! DEBUG -- It's retail

//
// Global Management Functions -
//
// These are in debug and retail but are internally they change
// depending on the build.
//

void * __cdecl operator new(size_t t_size )
{
    return LocalAlloc( GPTR, t_size );
}

void __cdecl operator delete(void *pv)
{
    LocalFree( pv );
}

int __cdecl _purecall(void)
{
    return 0;
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rbsetup\server\automate.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997-1999
   All rights reserved

 ***************************************************************************/

#include "pch.h"

DEFINE_MODULE("RISETUP")

//
// GetAutomatedOptions( )
//
HRESULT
GetAutomatedOptions( )
{
    TraceFunc("GetAutomatedOptions( )\n" );

    HRESULT hr = S_OK;
    BOOL    b;
    DWORD   dwSize;
    WCHAR   szTemp[ 32 ];
    DWORD pathlen,archlen;
    WCHAR archscratch[10];

    INFCONTEXT SectionContext;
    INFCONTEXT context;

    Assert( g_Options.hinfAutomated != INVALID_HANDLE_VALUE );

    // make sure this is our automated file
    b = SetupFindFirstLine( g_Options.hinfAutomated, L"risetup", NULL, &SectionContext );
    if ( !b ) goto Cleanup;

    // Tree Root
    dwSize = ARRAYSIZE( g_Options.szIntelliMirrorPath );
    b = SetupFindFirstLine( g_Options.hinfAutomated, L"risetup", L"RootDir", &context );
    if ( !b ) goto Cleanup;    
    b = SetupGetStringField( &context, 1, g_Options.szIntelliMirrorPath, dwSize, &dwSize );
    if ( !b ) goto Cleanup;
    g_Options.fIMirrorDirectory = TRUE;

    // Source Path
    dwSize = ARRAYSIZE( g_Options.szSourcePath );
    b = SetupFindFirstLine( g_Options.hinfAutomated, L"risetup", L"Source", &context );
    if ( !b ) goto Cleanup;    
    b = SetupGetStringField( &context, 1, g_Options.szSourcePath, dwSize, &dwSize );
    if ( !b ) goto Cleanup;

    // Installation Directory Name
    dwSize = ARRAYSIZE( g_Options.szInstallationName );
    b = SetupFindFirstLine( g_Options.hinfAutomated, L"risetup", L"Directory", &context );
    if ( !b ) goto Cleanup;    
    b = SetupGetStringField( &context, 1, g_Options.szInstallationName, dwSize, &dwSize );
    if ( !b ) goto Cleanup;

    // SIF Description
    dwSize = ARRAYSIZE( g_Options.szDescription );
    b = SetupFindFirstLine( g_Options.hinfAutomated, L"risetup", L"Description", &context );
    if ( !b ) goto Cleanup;    
    b = SetupGetStringField( &context, 1, g_Options.szDescription, dwSize, &dwSize );
    if ( !b ) goto Cleanup;
    g_Options.fRetrievedWorkstationString = TRUE;

    // SIF Help Text
    dwSize = ARRAYSIZE( g_Options.szHelpText );
    b = SetupFindFirstLine( g_Options.hinfAutomated, L"risetup", L"HelpText", &context );
    if ( !b ) goto Cleanup;    
    b = SetupGetStringField( &context, 1, g_Options.szHelpText, dwSize, &dwSize );
    if ( !b ) goto Cleanup;

    // language -- OPTIONAL --
    dwSize = ARRAYSIZE( g_Options.szLanguage );
    b = SetupFindFirstLine( g_Options.hinfAutomated, L"risetup", L"Language", &context );
    if ( b ) {
        b = SetupGetStringField( &context, 1, g_Options.szLanguage, dwSize, &dwSize );
        g_Options.fLanguageSet = TRUE;
        if (b) {
            g_Options.fLanguageOverRide = TRUE;
        }
    }

    // OSC Screens - OPTIONAL - defaults to LeaveAlone
    g_Options.fScreenLeaveAlone = FALSE;
    g_Options.fScreenOverwrite  = FALSE;
    g_Options.fScreenSaveOld    = FALSE;
    dwSize = ARRAYSIZE( szTemp );
    b = SetupFindFirstLine( g_Options.hinfAutomated, L"risetup", L"Screens", &context );
    if ( b ) 
    {
        b = SetupGetStringField( &context, 1, szTemp, dwSize, &dwSize );
        if ( b ) 
        {
            if ( _wcsicmp( szTemp, L"overwrite" ) == 0 )
            {
                DebugMsg( "AUTO: Overwrite existing screens\n" );
                g_Options.fScreenOverwrite = TRUE;
            }
            else if ( _wcsicmp( szTemp, L"backup" ) == 0 )
            {
                g_Options.fScreenSaveOld = TRUE;
            }
        }
    }
    if ( !g_Options.fScreenOverwrite && !g_Options.fScreenSaveOld )
    {
        g_Options.fScreenLeaveAlone = TRUE;
    }

    // Archtecture - OPTIONAL - defaults to INTEL
    dwSize = ARRAYSIZE( szTemp );
    b = SetupFindFirstLine( g_Options.hinfAutomated, L"risetup", L"Architecture", &context );
    if ( b ) 
    {
        b = SetupGetStringField( &context, 1, szTemp, dwSize, &dwSize );
        if ( b ) 
        {
            if ( _wcsicmp( szTemp, L"ia64" ) == 0 )
            {
                g_Options.ProcessorArchitecture = PROCESSOR_ARCHITECTURE_IA64;
                wcscpy( g_Options.ProcessorArchitectureString, L"ia64" );
            }

            if ( _wcsicmp( szTemp, L"x86" ) == 0 )
            {
                g_Options.ProcessorArchitecture = PROCESSOR_ARCHITECTURE_INTEL;
                wcscpy( g_Options.ProcessorArchitectureString, L"i386" );
            }
        }
    }


    if (g_Options.ProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) {
        wcscpy( archscratch, L"\\i386");
        archlen = 5;
    } else {        
        wcscpy( archscratch, L"\\ia64");
        archlen = 5;
    }
    
    pathlen = (DWORD)wcslen(g_Options.szSourcePath);

    // Remove any trailing slashes
    if ( g_Options.szSourcePath[ pathlen - 1 ] == L'\\' ) {
        g_Options.szSourcePath[ pathlen - 1 ] = L'\0';
        pathlen -= 1;
    }

    //
    // remove any processor specific subdir at the end of the path
    // if that's there as well, being careful not to underflow
    // the array
    //
    if ( (pathlen > archlen) &&
         (0 == _wcsicmp(
                    &g_Options.szSourcePath[pathlen-archlen],
                    archscratch))) {
        g_Options.szSourcePath[ pathlen - archlen ] = L'\0';
    }




    g_Options.fNewOS = TRUE;
    b = TRUE;

Cleanup:
    if ( !b )
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( NULL, L"RISETUP" );
    }

    if ( g_Options.hinfAutomated != INVALID_HANDLE_VALUE )
        SetupCloseInfFile( g_Options.hinfAutomated );

    HRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\osdisp\osdisp.c ===
//
// DISPLAY OSCHOOSE SCREENS
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>

#include <windows.h>
#include <winsock.h>

#undef ERROR

#include <stdio.h>


CHAR DomainName[64];
CHAR UserName[64];
CHAR Password[64];

VOID
BiosConsoleWrite(
    IN ULONG FileId,
    OUT PUCHAR Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );


ULONG __cdecl
BiosConsoleGetKey(
    void
    );

ULONG __cdecl
BiosConsoleGetCounter(
    void
    );

#include "..\boot\oschoice\oscheap.c"
#define _BUILDING_OSDISP_
#include "..\boot\oschoice\parse.c"

#if DBG
ULONG NetDebugFlag =
        DEBUG_ERROR             |
        DEBUG_OSC;
#endif

//
// This is declared and expected by parse.c, so we defined the functions
// for the macros it uses (GET_KEY and GET_COUNTER) and NULL the rest out.
//

EXTERNAL_SERVICES_TABLE ServicesTable = {
    NULL,     // RebootProcessor
    NULL,     // DiskIOSystem
    BiosConsoleGetKey,
    BiosConsoleGetCounter,
    NULL,     // Reboot
    NULL,     // AbiosServices
    NULL,     // DetectHardware
    NULL,     // HardwareCursor
    NULL,     // GetDateTime
    NULL,     // ComPort
    NULL,     // IsMcaMachine
    NULL,     // GetStallCount
    NULL,     // InitializeDisplayForNt
    NULL,     // GetMemoryDescriptor
    NULL,     // GetEddsSector
    NULL,     // GetElToritoStatus
    NULL      // GetExtendedInt13Params
};
PEXTERNAL_SERVICES_TABLE ExternalServicesTable = &ServicesTable;

//
// This is used by the ArcWrite function -- it only cares about the firmware vector
// which is the 28th entry.
//

PVOID FirmwareVector[38] = {
    NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, (PVOID)BiosConsoleWrite, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL
};

SYSTEM_PARAMETER_BLOCK GlobalSystemBlock = {
    0,      // Signature
    0,      // Length
    0,      // Version
    0,      // Revision
    NULL,   // RestartBlock
    NULL,   // DebugBlock
    NULL,   // GenerateExceptionVector
    NULL,   // TlbMissExceptionVector
    sizeof(FirmwareVector),
    FirmwareVector,
    0,      // VendorVectorLength
    NULL,   // VendorVector
    0,      // AdapterCount
    0,      // Adapter0Type
    0,      // Adapter0Length
    NULL    // Adapter0Vector
};




//
// Current screen position.
//
USHORT TextColumn = 0;
USHORT TextRow  = 0;

//
// Height and width of the console.
//
USHORT ScreenWidthCells;
USHORT ScreenHeightCells;

//
// Current text attribute
//
UCHAR TextCurrentAttribute = 0x07;      // start with white on black.

//
// Standard input and output handles.
//
HANDLE StandardInput;
HANDLE StandardOutput;

UCHAR EightySpaces[] =
"                                                                                ";

//
// defines for doing console I/O
//
#define CSI 0x95
#define SGR_INVERSE 7
#define SGR_NORMAL 0

//
// static data for console I/O
//
BOOLEAN ControlSequence=FALSE;
BOOLEAN EscapeSequence=FALSE;
BOOLEAN FontSelection=FALSE;
BOOLEAN HighIntensity=FALSE;
BOOLEAN Blink=FALSE;
ULONG PCount=0;

#define CONTROL_SEQUENCE_MAX_PARAMETER 10
ULONG Parameter[CONTROL_SEQUENCE_MAX_PARAMETER];

#define KEY_INPUT_BUFFER_SIZE 16
UCHAR KeyBuffer[KEY_INPUT_BUFFER_SIZE];
ULONG KeyBufferEnd=0;
ULONG KeyBufferStart=0;

//
// array for translating between ANSI colors and the VGA standard
//
UCHAR TranslateColor[] = {0,4,2,6,1,5,3,7};

#define ASCI_ESC  0x1b


//
// Need this to link.
//

ULONG BlConsoleOutDeviceId = 0;



CHAR
BlProcessScreen(
    IN PCHAR InputString,
    OUT PCHAR OutputString
    );

CHAR g_OutputString[1024];

int __cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    DWORD Error;
    int i;
    HANDLE hFile;
    DWORD fileSize, bytesRead;
    PCHAR fileBuffer;
    CONSOLE_SCREEN_BUFFER_INFO bufferInfo;
    CONSOLE_CURSOR_INFO cursorInfo;
    COORD coord;
    PCHAR pszScreenName;
    CHAR LastKey;

    if (argc < 2) {
        printf("USAGE: %s [screen-file-name]\n", argv[0]);
        return -1;
    }

    //
    // Set up the console correctly. We allocate our own and resize
    // it to 80 x 25.
    //

    FreeConsole();
    AllocConsole();

    StandardInput = GetStdHandle(STD_INPUT_HANDLE);
    StandardOutput = GetStdHandle(STD_OUTPUT_HANDLE);

    ScreenWidthCells = 81;
    ScreenHeightCells = 25;

    coord.X = ScreenWidthCells;
    coord.Y = ScreenHeightCells;

    SetConsoleScreenBufferSize(StandardOutput, coord);

    //
    // This actually turns *off* most processing.
    //

    SetConsoleMode(StandardInput, ENABLE_PROCESSED_INPUT);

    //
    // Hide the cursor.
    //

    cursorInfo.dwSize = 1;
    cursorInfo.bVisible = FALSE;

    SetConsoleCursorInfo(StandardOutput, &cursorInfo);

    //
    // Open the first parameter as a file.
    //
    pszScreenName = argv[1];

NextScreen:
    hFile = CreateFileA(pszScreenName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);

    if (hFile == INVALID_HANDLE_VALUE ) {
        printf("Could not open %s!\n", argv[1]);
        return -1;
    }

    fileSize = GetFileSize(hFile, NULL);

    printf("File %s is %d bytes\n", argv[1], fileSize);

    fileBuffer = LocalAlloc(0, fileSize+1);
    if (fileBuffer == NULL) {
        printf("Allocate failed!\n");
        return -1;
    }

    if (!ReadFile(hFile, fileBuffer, fileSize, &bytesRead, NULL)) {
        printf("Read failed\n");
        return -1;
    }

    if (bytesRead != fileSize) {
        printf("Too few bytes read\n");
        return -1;
    }

    CloseHandle(hFile);

    fileBuffer[fileSize] = '\0';

    LastKey = BlProcessScreen(fileBuffer, g_OutputString);
    if (SpecialAction == ACTION_REFRESH)
        goto NextScreen;

    {
        PCHAR psz = strchr( g_OutputString, '\n' );
        if ( psz )
            *psz = '\0';
        pszScreenName = g_OutputString;
        if ( strcmp( pszScreenName, "REBOOT" ) != 0 
            && strcmp( pszScreenName, "LAUNCH" ) != 0 \
            && strcmp( pszScreenName, "" ) != 0 ) {
            // add the extension and jump to the next screen
            strcat( g_OutputString, ".osc" );
            goto NextScreen;
        }
    }
    //
    // I can't figure out how to write to the old console -- so for
    // now just display it and pause.
    //

    BlpClearScreen();

    SetConsoleTextAttribute(StandardOutput, 0x7);

    printf("String returned was <%s>\n", g_OutputString);
    printf("Press any key to exit\n");


    while (GET_KEY() == 0) {
        ;
    }

}



VOID
TextGetCursorPosition(
    OUT PULONG X,
    OUT PULONG Y
    )

/*++

Routine Description:

    Gets the position of the soft cursor.

Arguments:

    X - Receives column coordinate of where character would be written.

    Y - Receives row coordinate of where next character would be written.

Returns:

    Nothing.

--*/

{
    *X = (ULONG)TextColumn;
    *Y = (ULONG)TextRow;
}


VOID
TextSetCursorPosition(
    IN ULONG X,
    IN ULONG Y
    )

/*++

Routine Description:

    Moves the location of the software cursor to the specified X,Y position
    on screen.

Arguments:

    X - Supplies the X-position of the cursor

    Y - Supplies the Y-position of the cursor

Return Value:

    None.

--*/

{
    COORD coord;

    TextColumn = (USHORT)X;
    TextRow = (USHORT)Y;

    coord.X = (USHORT)X;
    coord.Y = (USHORT)Y;

    SetConsoleCursorPosition(StandardOutput, coord);
}


VOID
TextSetCurrentAttribute(
    IN UCHAR Attribute
    )

/*++

Routine Description:

    Sets the character attribute to be used for subsequent text display.

Arguments:

Returns:

    Nothing.

--*/

{
    TextCurrentAttribute = Attribute;

    SetConsoleTextAttribute(StandardOutput, Attribute);
}


UCHAR
TextGetCurrentAttribute(
    VOID
    )
{
    return(TextCurrentAttribute);
}


PUCHAR
TextCharOut(
    IN PUCHAR pc
    )
{
    DWORD numWritten;

    WriteConsoleA(StandardOutput, pc, 1, &numWritten, NULL);

    return(pc+1);
}


VOID
TextClearToEndOfLine(
    VOID
    )

/*++

Routine Description:

    Clears from the current cursor position to the end of the line
    by writing blanks with the current video attribute.

Arguments:

    None

Returns:

    Nothing


--*/

{
    unsigned u;
    ULONG OldX,OldY;
    UCHAR temp;

    //
    // Fill with blanks up to char before cursor position.
    //
    temp = ' ';
    TextGetCursorPosition(&OldX,&OldY);
    for(u=TextColumn; u<ScreenWidthCells; u++) {
        TextCharOut(&temp);
    }
    TextSetCursorPosition(OldX,OldY);
}


VOID
TextClearFromStartOfLine(
    VOID
    )

/*++

Routine Description:

    Clears from the start of the line to the current cursor position
    by writing blanks with the current video attribute.
    The cursor position is not changed.

Arguments:

    None

Returns:

    Nothing

--*/

{
    unsigned u;
    ULONG OldX,OldY;
    UCHAR temp = ' ';

    //
    // Fill with blanks up to char before cursor position.
    //
    TextGetCursorPosition(&OldX,&OldY);
    TextSetCursorPosition(0,OldY);
    for(u=0; u<TextColumn; u++) {
        TextCharOut(&temp);
    }
    TextSetCursorPosition(OldX,OldY);
}

VOID
TextClearToEndOfDisplay(
    VOID
    )

/*++

Routine Description:

    Clears from the current cursor position to the end of the video
    display by writing blanks with the current video attribute.
    The cursor position is not changed.

Arguments:

    None

Returns:

    Nothing

--*/

{
    USHORT x,y;
    ULONG OldX,OldY;
    DWORD numWritten;

    TextGetCursorPosition(&OldX,&OldY);

    //
    // Clear current line
    //
    TextClearToEndOfLine();

    //
    // Clear the remaining lines
    //

    for(y=TextRow+1; y<ScreenHeightCells; y++) {

        TextSetCursorPosition(0, y);
        WriteConsoleA(StandardOutput, EightySpaces, ScreenWidthCells, &numWritten, NULL);

    }

    TextSetCursorPosition(OldX,OldY);
}


VOID
TextClearDisplay(
    VOID
    )

/*++

Routine Description:

    Clears the video display and positions the cursor
    at the upper left corner of the screen (0,0).

Arguments:

    None

Returns:

    Nothing

--*/

{
    USHORT y;
    DWORD numWritten;

    //
    // Clear screen.
    //
    for(y=0; y<ScreenHeightCells; y++) {

        TextSetCursorPosition(0, y);
        WriteConsoleA(StandardOutput, EightySpaces, ScreenWidthCells, &numWritten, NULL);

    }
    TextSetCursorPosition(0,0);
}



//
// This function was stolen from ..\lib\i386\biosdrv.c (except the return
// type was changed to VOID).
//

VOID
BiosConsoleWrite(
    IN ULONG FileId,
    OUT PUCHAR Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    Outputs to the console.  (In this case, the VGA display)

Arguments:

    FileId - Supplies the FileId to be written (should always be 1 for this
             function)

    Buffer - Supplies characters to be output

    Length - Supplies the length of the buffer (in bytes)

    Count  - Returns the actual number of bytes written

Return Value:

    ESUCCESS - Console write completed succesfully.

--*/
{
    ARC_STATUS Status;
    PUCHAR String;
    ULONG Index;
    UCHAR a;
    PUCHAR p;

    //
    // Process each character in turn.
    //

    Status = ESUCCESS;
    String = (PUCHAR)Buffer;

    for ( *Count = 0 ;
          *Count < Length ;
          (*Count)++, String++ ) {

        //
        // If we're in the middle of a control sequence, continue scanning,
        // otherwise process character.
        //

        if (ControlSequence) {

            //
            // If the character is a digit, update parameter value.
            //

            if ((*String >= '0') && (*String <= '9')) {
                Parameter[PCount] = Parameter[PCount] * 10 + *String - '0';
                continue;
            }

            //
            // If we are in the middle of a font selection sequence, this
            // character must be a 'D', otherwise reset control sequence.
            //

            if (FontSelection) {

                //if (*String == 'D') {
                //
                //    //
                //    // Other fonts not implemented yet.
                //    //
                //
                //} else {
                //}

                ControlSequence = FALSE;
                FontSelection = FALSE;
                continue;
            }

            switch (*String) {

            //
            // If a semicolon, move to the next parameter.
            //

            case ';':

                PCount++;
                if (PCount > CONTROL_SEQUENCE_MAX_PARAMETER) {
                    PCount = CONTROL_SEQUENCE_MAX_PARAMETER;
                }
                Parameter[PCount] = 0;
                break;

            //
            // If a 'J', erase part or all of the screen.
            //

            case 'J':

                switch (Parameter[0]) {
                    case 0:
                        //
                        // Erase to end of the screen
                        //
                        TextClearToEndOfDisplay();
                        break;

                    case 1:
                        //
                        // Erase from the beginning of the screen
                        //
                        break;

                    default:
                        //
                        // Erase entire screen
                        //
                        TextClearDisplay();
                        break;
                }

                ControlSequence = FALSE;
                break;

            //
            // If a 'K', erase part or all of the line.
            //

            case 'K':

                switch (Parameter[0]) {

                //
                // Erase to end of the line.
                //

                    case 0:
                        TextClearToEndOfLine();
                        break;

                    //
                    // Erase from the beginning of the line.
                    //

                    case 1:
                        TextClearFromStartOfLine();
                        break;

                    //
                    // Erase entire line.
                    //

                    default :
                        TextClearFromStartOfLine();
                        TextClearToEndOfLine();
                        break;
                }

                ControlSequence = FALSE;
                break;

            //
            // If a 'H', move cursor to position.
            //

            case 'H':
                TextSetCursorPosition(Parameter[1]-1, Parameter[0]-1);
                ControlSequence = FALSE;
                break;

            //
            // If a ' ', could be a FNT selection command.
            //

            case ' ':
                FontSelection = TRUE;
                break;

            case 'm':
                //
                // Select action based on each parameter.
                //
                // Blink and HighIntensity are by default disabled
                // each time a new SGR is specified, unless they are
                // explicitly specified again, in which case these
                // will be set to TRUE at that time.
                //

                HighIntensity = FALSE;
                Blink = FALSE;

                for ( Index = 0 ; Index <= PCount ; Index++ ) {
                    switch (Parameter[Index]) {

                    //
                    // Attributes off.
                    //

                    case 0:
                        TextSetCurrentAttribute(7);
                        HighIntensity = FALSE;
                        Blink = FALSE;
                        break;

                    //
                    // High Intensity.
                    //

                    case 1:
                        TextSetCurrentAttribute(0xf);
                        HighIntensity = TRUE;
                        break;

                    //
                    // Underscored.
                    //

                    case 4:
                        break;

                    //
                    // Blink.
                    //

                    case 5:
                        TextSetCurrentAttribute(0x87);
                        Blink = TRUE;
                        break;

                    //
                    // Reverse Video.
                    //

                    case 7:
                        TextSetCurrentAttribute(0x70);
                        HighIntensity = FALSE;
                        Blink = FALSE;
                        break;

                    //
                    // Font selection, not implemented yet.
                    //

                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                        break;

                    //
                    // Foreground Color
                    //

                    case 30:
                    case 31:
                    case 32:
                    case 33:
                    case 34:
                    case 35:
                    case 36:
                    case 37:
                        a = TextGetCurrentAttribute();
                        a &= 0x70;
                        a |= TranslateColor[Parameter[Index]-30];
                        if (HighIntensity) {
                            a |= 0x08;
                        }
                        if (Blink) {
                            a |= 0x80;
                        }
                        TextSetCurrentAttribute(a);
                        break;

                    //
                    // Background Color
                    //

                    case 40:
                    case 41:
                    case 42:
                    case 43:
                    case 44:
                    case 45:
                    case 46:
                    case 47:
                        a = TextGetCurrentAttribute();
                        a &= 0x8f;
                        a |= TranslateColor[Parameter[Index]-40] << 4;
                        TextSetCurrentAttribute(a);
                        break;

                    default:
                        break;
                    }
                }

            default:
                ControlSequence = FALSE;
                break;
            }

        //
        // This is not a control sequence, check for escape sequence.
        //

        } else {

            //
            // If escape sequence, check for control sequence, otherwise
            // process single character.
            //

            if (EscapeSequence) {

                //
                // Check for '[', means control sequence, any other following
                // character is ignored.
                //

                if (*String == '[') {

                    ControlSequence = TRUE;

                    //
                    // Initialize first parameter.
                    //

                    PCount = 0;
                    Parameter[0] = 0;
                }
                EscapeSequence = FALSE;

            //
            // This is not a control or escape sequence, process single character.
            //

            } else {

                switch (*String) {
                    //
                    // Check for escape sequence.
                    //

                    case ASCI_ESC:
                        EscapeSequence = TRUE;
                        break;

                    default:
                        p = TextCharOut(String);
                        //
                        // Each pass through the loop increments String by 1.
                        // If we output a dbcs char we need to increment by
                        // one more.
                        //
                        (*Count) += (p - String) - 1;
                        String += (p - String) - 1;
                        break;
                }

            }
        }
    }
    return;
}


ULONG __cdecl
BiosConsoleGetKey(
    VOID
    )
{
    INPUT_RECORD inputRecord;
    DWORD numRead;

    //
    // Loop until we see a key event or nothing.
    //

    while (TRUE) {
    
        PeekConsoleInput(
            StandardInput,
            &inputRecord,
            1,
            &numRead);
    
        if (numRead == 0) {
    
            //
            // We read nothing -- sleep for a bit (since callers tend to loop
            // calling this) and return.
            //
    
            Sleep(100);
            return 0;
        }

        ReadConsoleInput(
            StandardInput,
            &inputRecord,
            1,
            &numRead);

        if (inputRecord.EventType != KEY_EVENT) {
            continue;
        }

        //
        // We had a key event -- process the key down ones.
        //

        if (inputRecord.Event.KeyEvent.bKeyDown) {

            //
            // Construct the correct scancode/ASCII value combination.
            //

            //
            // HACK: shift-tab needs to be special-cased for some reason.
            //

            if ((inputRecord.Event.KeyEvent.uChar.AsciiChar == 0x09) &&
                ((inputRecord.Event.KeyEvent.dwControlKeyState & SHIFT_PRESSED) != 0)) {

                return 0x0f00;

            } else {
    
                return
                    (((inputRecord.Event.KeyEvent.wVirtualScanCode) & 0xff) << 8) +
                    inputRecord.Event.KeyEvent.uChar.AsciiChar;

            }

        }

    }

}

ULONG __cdecl
BiosConsoleGetCounter(
    VOID
    )
{
    //
    // GetTickCount is in milliseconds, we want an 18.2/sec counter
    //

    return (GetTickCount() * 182) / 10000;

}



//
// These two functions were taken from ..\lib\regboot.c.
//
VOID
BlpPositionCursor(
    IN ULONG Column,
    IN ULONG Row
    )

/*++

Routine Description:

    Sets the position of the cursor on the screen.

Arguments:

    Column - supplies new Column for the cursor position.

    Row - supplies new Row for the cursor position.

Return Value:

    None.

--*/

{
    CHAR Buffer[16];
    ULONG Count;

    sprintf(Buffer, ASCI_CSI_OUT "%d;%dH", Row, Column);

    PRINTL(Buffer);

}


VOID
BlpClearScreen(
    VOID
    )

/*++

Routine Description:

    Clears the screen.

Arguments:

    None

Return Value:

    None.

--*/

{
    CHAR Buffer[16];
    ULONG Count;

    sprintf(Buffer, ASCI_CSI_OUT "2J");

    PRINTL(Buffer);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\imirror\regtool.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    regtool.c

Abstract:

    This file contains functions for supporting the registry tools
    REGINI, REGDMP, REGDIR and REGFIND

Author:

    Steve Wood (stevewo) 15-Nov-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

LONG
RegLoadHive(
           IN PREG_CONTEXT RegistryContext,
           IN PWSTR HiveFileName,
           IN PWSTR HiveRootName
           );

void
RegUnloadHive(
             IN PREG_CONTEXT RegistryContext
             );

BOOLEAN PrivilegeEnabled;
BOOLEAN RestoreWasEnabled;
BOOLEAN BackupWasEnabled;

BOOLEAN
RTEnableBackupRestorePrivilege( void )
{
    NTSTATUS Status;

    //
    // Try to enable backup and restore privileges
    //
    Status = RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                                 TRUE,               // Enable
                                 FALSE,              // Not impersonating
                                 &RestoreWasEnabled  // previous state
                               );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
    }

    Status = RtlAdjustPrivilege( SE_BACKUP_PRIVILEGE,
                                 TRUE,               // Enable
                                 FALSE,              // Not impersonating
                                 &BackupWasEnabled   // previous state
                               );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
    }

    PrivilegeEnabled = TRUE;
    return TRUE;
}


void
RTDisableBackupRestorePrivilege( void )
{
    //
    // Restore privileges to what they were
    //

    RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                        RestoreWasEnabled,
                        FALSE,
                        &RestoreWasEnabled
                      );

    RtlAdjustPrivilege( SE_BACKUP_PRIVILEGE,
                        BackupWasEnabled,
                        FALSE,
                        &BackupWasEnabled
                      );

    PrivilegeEnabled = FALSE;
    return;
}


LONG
RTConnectToRegistry(
                   IN PWSTR MachineName,
                   IN PWSTR HiveFileName,
                   IN PWSTR HiveRootName,
                   OUT PWSTR *DefaultRootKeyName,
                   OUT PREG_CONTEXT RegistryContext
                   )
{
    LONG Error;

    //
    // This code comes from a library that can support remote machine name
    // for our use though we never support remote machine name, so that
    // bit of code is commented out.
    //
    UNREFERENCED_PARAMETER( MachineName );

#if 0
    if (MachineName != NULL) {
        if (HiveRootName || HiveFileName ) {
            return ERROR_INVALID_PARAMETER;
        }

        Error = RegConnectRegistry( MachineName, HKEY_LOCAL_MACHINE, (PHKEY)&RegistryContext->MachineRoot );
        if (Error == NO_ERROR) {
            Error = RegConnectRegistry( MachineName, HKEY_USERS, (PHKEY)&RegistryContext->UsersRoot );
            if (Error == NO_ERROR) {
                Error = RegOpenKey( RegistryContext->UsersRoot, L".Default", &RegistryContext->CurrentUserRoot );
            }
        }

        if (Error != NO_ERROR) {
            if (RegistryContext->MachineRoot != NULL) {
                RegCloseKey( RegistryContext->MachineRoot );
                RegistryContext->MachineRoot = NULL;
            }

            if (RegistryContext->UsersRoot != NULL) {
                RegCloseKey( RegistryContext->UsersRoot );
                RegistryContext->UsersRoot = NULL;
            }

            return Error;
        }

        wcsncpy( RegistryContext->MachinePath, L"\\Registry\\Machine", MAX_PATH );
        RegistryContext->MachinePath[MAX_PATH-1] = L'\0';
        wcsncpy( RegistryContext->UsersPath, L"\\Registry\\Users", MAX_PATH );
        RegistryContext->UsersPath[MAX_PATH-1] = L'\0';
        wcsncpy( RegistryContext->CurrentUserPath, L"\\Registry\\Users\\.Default",MAX_PATH );
        RegistryContext->CurrentUserPath[MAX_PATH-1] = L'\0';
        RegistryContext->Target = REG_TARGET_REMOTE_REGISTRY;

    } else
#endif         

    if (HiveRootName != NULL || HiveFileName != NULL) {
        
        // If they sent us one, they need to send us both.
        if (HiveRootName == NULL || HiveFileName == NULL ) {
            return ERROR_INVALID_PARAMETER;
        }


        if (!PrivilegeEnabled && !RTEnableBackupRestorePrivilege()) {
            return ERROR_PRIVILEGE_NOT_HELD;
        }

        RegistryContext->MachineRoot = NULL;
        RegistryContext->UsersRoot = NULL;
        RegistryContext->CurrentUserRoot = NULL;

        Error = RegLoadHive( RegistryContext, HiveFileName, HiveRootName );
        if (Error != NO_ERROR) {
            return Error;
        }

        if (DefaultRootKeyName != NULL && *DefaultRootKeyName == NULL) {
            *DefaultRootKeyName = HiveRootName;
        }
        RegistryContext->Target = REG_TARGET_HIVE_REGISTRY;
    } else {
        NTSTATUS Status;
        UNICODE_STRING CurrentUserKeyPath;

        RegistryContext->MachineRoot = HKEY_LOCAL_MACHINE;
        RegistryContext->UsersRoot = HKEY_USERS;
        RegistryContext->CurrentUserRoot = HKEY_CURRENT_USER;

        wcsncpy( RegistryContext->MachinePath, L"\\Registry\\Machine",MAX_PATH );
        RegistryContext->MachinePath[MAX_PATH-1] = L'\0';
        wcsncpy( RegistryContext->UsersPath, L"\\Registry\\Users",MAX_PATH );
        RegistryContext->UsersPath[MAX_PATH-1] = L'\0';
        Status = RtlFormatCurrentUserKeyPath( &CurrentUserKeyPath );
        if (!NT_SUCCESS( Status )) {
            SetLastError( RtlNtStatusToDosError( Status ) );
            return FALSE;
        }

        wcsncpy( RegistryContext->CurrentUserPath, CurrentUserKeyPath.Buffer, MAX_PATH );
        RegistryContext->CurrentUserPath[MAX_PATH-1] = L'\0';
        RtlFreeUnicodeString( &CurrentUserKeyPath );

        RegistryContext->Target = REG_TARGET_LOCAL_REGISTRY;
    }

    if (DefaultRootKeyName != NULL && *DefaultRootKeyName == NULL) {
        *DefaultRootKeyName = L"\\Registry";
    }
    RegistryContext->MachinePathLength = (DWORD)wcslen( RegistryContext->MachinePath );
    RegistryContext->UsersPathLength = (DWORD)wcslen( RegistryContext->UsersPath );
    RegistryContext->CurrentUserPathLength = (DWORD)wcslen( RegistryContext->CurrentUserPath );
    return NO_ERROR;
}


LONG
RTDisconnectFromRegistry(
                        IN PREG_CONTEXT RegistryContext
                        )
{
    switch ( RegistryContext->Target ) {
    case REG_TARGET_DISCONNECTED:
        break;

    case REG_TARGET_LOCAL_REGISTRY:
        break;

    case REG_TARGET_REMOTE_REGISTRY:
        break;

    case REG_TARGET_HIVE_REGISTRY:
        RegUnloadHive( RegistryContext );
        break;
    }

    if (PrivilegeEnabled) {
        RTDisableBackupRestorePrivilege();
    }

    RegistryContext->Target = REG_TARGET_DISCONNECTED;
    return NO_ERROR;
}

UNICODE_STRING RegHiveRootName;

LONG
RegLoadHive(
           IN PREG_CONTEXT RegistryContext,
           IN PWSTR HiveFileName,
           IN PWSTR HiveRootName
           )
{
    NTSTATUS Status;
    UNICODE_STRING NtFileName;
    OBJECT_ATTRIBUTES File;

    if (!RtlDosPathNameToNtPathName_U( HiveFileName,
                                       &NtFileName,
                                       NULL,
                                       NULL
                                     )
       ) {
        return ERROR_BAD_PATHNAME;
    }
    InitializeObjectAttributes( &File,
                                &NtFileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );

    RtlInitUnicodeString( &RegHiveRootName, L"\\Registry");
    InitializeObjectAttributes( &RegistryContext->HiveRootKey,
                                &RegHiveRootName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );
    Status = NtOpenKey( &RegistryContext->HiveRootHandle,
                        MAXIMUM_ALLOWED,
                        &RegistryContext->HiveRootKey
                      );

    RtlFreeHeap(RtlProcessHeap(), 0, NtFileName.Buffer);

    if (!NT_SUCCESS(Status)) {
        return RtlNtStatusToDosError( Status );
    }

    RtlInitUnicodeString( &RegHiveRootName, HiveRootName );
    InitializeObjectAttributes( &RegistryContext->HiveRootKey,
                                &RegHiveRootName,
                                OBJ_CASE_INSENSITIVE,
                                RegistryContext->HiveRootHandle,
                                NULL
                              );
    NtUnloadKey( &RegistryContext->HiveRootKey );
    Status = NtLoadKey( &RegistryContext->HiveRootKey, &File );
    if (!NT_SUCCESS( Status )) {
        return RtlNtStatusToDosError( Status );
    }

    return NO_ERROR;

}

void
RegUnloadHive(
             IN PREG_CONTEXT RegistryContext
             )
{
    NTSTATUS Status;
    HANDLE Handle;
    PREG_CONTEXT_OPEN_HIVE_KEY p, p1;

    Status = NtOpenKey( &Handle,
                        MAXIMUM_ALLOWED,
                        &RegistryContext->HiveRootKey
                      );
    if (NT_SUCCESS( Status )) {
        NtFlushKey( Handle );
        NtClose( Handle );
    }

    p = RegistryContext->OpenHiveKeys;
    while (p) {
        RegCloseKey( p->KeyHandle );
        p1 = p;
        p = p->Next;
        HeapFree( GetProcessHeap(), 0, p1 );
    };

    do {
        Status = NtUnloadKey( &RegistryContext->HiveRootKey );
    }
    while (NT_SUCCESS( Status ) );

    NtClose( RegistryContext->HiveRootHandle );
    return;
}


DWORD
RegRememberOpenKey(
                  IN PREG_CONTEXT RegistryContext,
                  IN HKEY KeyHandle
                  )
{
    PREG_CONTEXT_OPEN_HIVE_KEY p, *pp;
    DWORD RetVal = ERROR_SUCCESS;

    pp = &RegistryContext->OpenHiveKeys;
    while ((p = *pp) != NULL) {
        if (p->KeyHandle == KeyHandle) {
            p->ReferenceCount += 1;
            RetVal = ERROR_SUCCESS;
            goto exit;            
        } else {
            pp = &p->Next;
        }
    }

    p = HeapAlloc( GetProcessHeap(), 0, sizeof( *p ) );
    if (p != NULL) {
        p->KeyHandle = KeyHandle;
        p->ReferenceCount = 1;
        p->Next = NULL;
        *pp = p;
        RetVal = ERROR_SUCCESS;
    } else {
        RetVal = ERROR_OUTOFMEMORY;
    }
exit:
    return(RetVal);
}


void
RegForgetOpenKey(
                IN PREG_CONTEXT RegistryContext,
                IN HKEY KeyHandle
                )
{
    PREG_CONTEXT_OPEN_HIVE_KEY p, *pp;

    pp = &RegistryContext->OpenHiveKeys;
    while ((p = *pp) != NULL) {
        if (p->KeyHandle == KeyHandle) {
            p->ReferenceCount -= 1;
            if (p->ReferenceCount == 0) {
                *pp = p->Next;
                HeapFree( GetProcessHeap(), 0, p );
                return;
            }
        } else {
            pp = &p->Next;
        }
    }

    return;
}

BOOLEAN
RegCheckPrefix(
              IN OUT PCWSTR *s,
              IN PCWSTR Prefix,
              IN ULONG PrefixLength
              )
{
    if (PrefixLength == 0) {
        return FALSE;
    }

    if (!_wcsnicmp( *s, Prefix, PrefixLength )) {
        *s += PrefixLength;
        return TRUE;
    }

    return FALSE;
}


BOOLEAN
RegValidateKeyPath(
                  IN PREG_CONTEXT RegistryContext,
                  IN OUT PHKEY RootKeyHandle,
                  IN OUT PCWSTR *SubKeyName
                  )
{
    PCWSTR s;

    s = *SubKeyName;
    if (*RootKeyHandle == NULL) {
        if (RegCheckPrefix( &s, L"USER:", 5 ) ||
            RegCheckPrefix( &s, L"HKEY_CURRENT_USER", 17 )
           ) {
            if (RegistryContext->CurrentUserRoot == NULL) {
                SetLastError( ERROR_BAD_PATHNAME );
                return FALSE;
            }

            if (*s == L'\\') {
                s += 1;
            } else
                if (s[-1] != L':' && *s != UNICODE_NULL) {
                SetLastError( ERROR_BAD_PATHNAME );
                return FALSE;
            }

            *RootKeyHandle = RegistryContext->CurrentUserRoot;
        } else
            if (RegCheckPrefix( &s, L"HKEY_LOCAL_MACHINE", 18 )) {
            if (*s == L'\\') {
                s += 1;
            } else
                if (*s != UNICODE_NULL) {
                SetLastError( ERROR_BAD_PATHNAME );
                return FALSE;
            }

            *RootKeyHandle = RegistryContext->MachineRoot;
        } else
            if (RegCheckPrefix( &s, L"HKEY_USERS", 10 )) {
            if (*s == L'\\') {
                s += 1;
            } else
                if (*s != UNICODE_NULL) {
                SetLastError( ERROR_BAD_PATHNAME );
                return FALSE;
            }

            *RootKeyHandle = RegistryContext->UsersRoot;
        } else
            if (*s != L'\\') {
            SetLastError( ERROR_BAD_PATHNAME );
            return FALSE;
        } else
            if (RegCheckPrefix( &s, RegistryContext->MachinePath, RegistryContext->MachinePathLength )) {
            *RootKeyHandle = RegistryContext->MachineRoot;
            if (*s == L'\\') {
                s += 1;
            }
        } else
            if (RegCheckPrefix( &s, RegistryContext->UsersPath, RegistryContext->UsersPathLength )) {
            *RootKeyHandle = RegistryContext->UsersRoot;
            if (*s == L'\\') {
                s += 1;
            }
        } else
            if (RegCheckPrefix( &s, RegistryContext->CurrentUserPath, RegistryContext->CurrentUserPathLength )) {
            *RootKeyHandle = RegistryContext->CurrentUserRoot;
            if (*s == L'\\') {
                s += 1;
            }
        } else
            if (!_wcsicmp( *SubKeyName, L"\\Registry" )) {
            *RootKeyHandle = NULL;
        } else {
            SetLastError( ERROR_BAD_PATHNAME );
            return FALSE;
        }
    } else
        if (*s == L'\\') {
        SetLastError( ERROR_BAD_PATHNAME );
        return FALSE;
    }

    *SubKeyName = s;
    return TRUE;
}

LONG
RTCreateKey(
           IN PREG_CONTEXT RegistryContext,
           IN HKEY RootKeyHandle,
           IN PCWSTR SubKeyName,
           IN ACCESS_MASK DesiredAccess,
           IN ULONG CreateOptions,
           IN PVOID SecurityDescriptor,
           OUT PHKEY ReturnedKeyHandle,
           OUT PULONG Disposition
           )
{
    LONG Error;
    SECURITY_ATTRIBUTES SecurityAttributes;

    if (!RegValidateKeyPath( RegistryContext, &RootKeyHandle, &SubKeyName )) {
        return GetLastError();
    }

    if (RootKeyHandle == NULL) {
        *Disposition = REG_OPENED_EXISTING_KEY;
        *ReturnedKeyHandle = HKEY_REGISTRY_ROOT;
        return NO_ERROR;
    } else
        if (RootKeyHandle == HKEY_REGISTRY_ROOT) {
        *ReturnedKeyHandle = NULL;
        if (!_wcsicmp( SubKeyName, L"Machine" )) {
            *ReturnedKeyHandle = RegistryContext->MachineRoot;
        } else
            if (!_wcsicmp( SubKeyName, L"Users" )) {
            *ReturnedKeyHandle = RegistryContext->UsersRoot;
        }


        if (*ReturnedKeyHandle != NULL) {
            return NO_ERROR;
        } else {
            return ERROR_PATH_NOT_FOUND;
        }
    }

    SecurityAttributes.nLength = sizeof( SecurityAttributes );
    SecurityAttributes.lpSecurityDescriptor = SecurityDescriptor;
    SecurityAttributes.bInheritHandle = FALSE;
    Error = RegCreateKeyEx( RootKeyHandle,
                            SubKeyName,
                            0,
                            NULL,
                            CreateOptions,
                            (REGSAM)DesiredAccess,
                            &SecurityAttributes,
                            ReturnedKeyHandle,
                            Disposition
                          );
    if (Error == NO_ERROR &&
        RegistryContext->Target == REG_TARGET_HIVE_REGISTRY
       ) {
        Error = RegRememberOpenKey( RegistryContext, *ReturnedKeyHandle );
    }

    if (Error == NO_ERROR &&
        *Disposition == REG_OPENED_EXISTING_KEY &&
        SecurityDescriptor != NULL
       ) {
        RegSetKeySecurity( *ReturnedKeyHandle,
                           DACL_SECURITY_INFORMATION,
                           SecurityDescriptor
                         );
    }

    return Error;
}

LONG
RTOpenKey(
         IN PREG_CONTEXT RegistryContext,
         IN HKEY RootKeyHandle,
         IN PCWSTR SubKeyName,
         IN ACCESS_MASK DesiredAccess,
         IN ULONG OpenOptions,
         OUT PHKEY ReturnedKeyHandle
         )
{
    LONG Error;

    if (!RegValidateKeyPath( RegistryContext, &RootKeyHandle, &SubKeyName )) {
        return GetLastError();
    }

    if (RootKeyHandle == NULL) {
        *ReturnedKeyHandle = HKEY_REGISTRY_ROOT;
        return NO_ERROR;
    } else
        if (RootKeyHandle == HKEY_REGISTRY_ROOT) {
        *ReturnedKeyHandle = NULL;
        if (!_wcsicmp( SubKeyName, L"Machine" )) {
            *ReturnedKeyHandle = RegistryContext->MachineRoot;
        } else
            if (!_wcsicmp( SubKeyName, L"Users" )) {
            *ReturnedKeyHandle = RegistryContext->UsersRoot;
        }

        if (*ReturnedKeyHandle != NULL) {
            return NO_ERROR;
        } else {
            return ERROR_PATH_NOT_FOUND;
        }
    }

    Error = RegOpenKeyEx( RootKeyHandle,
                          SubKeyName,
                          OpenOptions,
                          DesiredAccess,
                          ReturnedKeyHandle
                        );
    if (Error == NO_ERROR &&
        RegistryContext->Target == REG_TARGET_HIVE_REGISTRY
       ) {
        RegRememberOpenKey( RegistryContext, *ReturnedKeyHandle );
    }

    return Error;
}

LONG
RTCloseKey(
          IN PREG_CONTEXT RegistryContext,
          IN HKEY KeyHandle
          )
{
    LONG Error;

    if (KeyHandle == HKEY_REGISTRY_ROOT) {
        return NO_ERROR;
    } else {
        Error = RegCloseKey( KeyHandle );
        if (Error == NO_ERROR &&
            RegistryContext->Target == REG_TARGET_HIVE_REGISTRY
           ) {
            RegForgetOpenKey( RegistryContext, KeyHandle );
        }

        return Error;
    }
}

LONG
RTEnumerateValueKey(
                   IN PREG_CONTEXT RegistryContext,
                   IN HKEY KeyHandle,
                   IN ULONG Index,
                   OUT PULONG ValueType,
                   IN OUT PULONG ValueNameLength,
                   OUT PWSTR ValueName,
                   IN OUT PULONG ValueDataLength,
                   OUT PVOID ValueData
                   )
{
    ULONG Error;

    UNREFERENCED_PARAMETER(RegistryContext);
    
    if (KeyHandle == HKEY_REGISTRY_ROOT) {
        return ERROR_NO_MORE_ITEMS;
    } else {
        Error = RegEnumValue( KeyHandle,
                              Index,
                              ValueName,
                              ValueNameLength,
                              NULL,
                              ValueType,
                              ValueData,
                              ValueDataLength
                            );
        if (Error == NO_ERROR) {
            RtlZeroMemory( (PCHAR)ValueData + *ValueDataLength, 4 - (*ValueDataLength & 3) );
        }

        return Error;
    }
}

LONG
RTQueryValueKey(
               IN PREG_CONTEXT RegistryContext,
               IN HKEY KeyHandle,
               IN PWSTR ValueName,
               OUT PULONG ValueType,
               IN OUT PULONG ValueDataLength,
               OUT PVOID ValueData
               )
{
    LONG Error;

    UNREFERENCED_PARAMETER(RegistryContext);

    Error = RegQueryValueEx( KeyHandle,
                             ValueName,
                             NULL,
                             ValueType,
                             ValueData,
                             ValueDataLength
                           );

    if (Error == NO_ERROR) {
        RtlZeroMemory( (PCHAR)ValueData + *ValueDataLength, 4 - (*ValueDataLength & 3) );
    }

    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rbsetup\server\check.h ===
/************************************************************************

   Copyright (c) Microsoft Corporation 1997-1998
   All rights reserved
 
 ***************************************************************************/

#ifndef _CHECK_H_
#define _CHECK_H_

HRESULT
CheckInstallation( );

HRESULT
CheckServerVersion( );

DWORD
Ldap_InitializeConnection(
    PLDAP  * LdapHandle );

#endif // _CHECK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rbsetup\server\dhcp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dhcp.h

Abstract:

    Code to allow RIS to automatically authorize for DHCP.

Author:

    Hugh Leather (hughleat) 25-July-2000

Revision History:

--*/

#if !defined SENTINEL_DHCP
# define SENTINEL_DHCP

HRESULT
AuthorizeDhcp( HWND hDlg );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rbsetup\server\debug.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved

  File: DEBUG.H

  Debugging utilities header
 
 ***************************************************************************/


#ifndef _DEBUG_H_
#define _DEBUG_H_

// Trace Flags
#define TF_ALWAYS           0xFFFFFFFF
#define TF_NEVER            0x00000000
#define TF_QUERYINTERFACE   0x00000001   // Query Interface details
#define TF_FUNC             0x00000002   // Functions entrances w/parameters
#define TF_CALLS            0x00000004   // Function calls
#define TF_MEMORYALLOCS     0x00000008   // Memory Allocations
#define TF_DLL              0x00000010   // DLL specific
#define TF_WM               0x00000020   // Window Messages
#define TF_SCP              0x00000030   // SCP objects
#define TF_HRESULTS         0x80000000   // Trace HRESULTs active

#ifdef DEBUG

#pragma message("BUILD: DEBUG macros being built")

// Globals
extern DWORD g_TraceMemoryIndex;
extern DWORD g_dwCounter;
extern DWORD g_dwTraceFlags;

extern const TCHAR g_szTrue[];
extern const TCHAR g_szFalse[];


// Macros
#define DEFINE_MODULE( _module ) static const TCHAR g_szModule[] = TEXT(_module);
#define __MODULE__ g_szModule
#define DEFINE_THISCLASS( _class ) static const TCHAR g_szClass[] = TEXT(_class); 
#define __THISCLASS__ g_szClass
#define DEFINE_SUPER( _super ) static const TCHAR g_szSuper[] = TEXT(_super);
#define __SUPER__ g_szSuper

#define DEBUG_BREAK         DebugBreak( );

#define INITIALIZE_TRACE_MEMORY_PROCESS     \
    g_TraceMemoryIndex = TlsAlloc( );       \
    TlsSetValue( g_TraceMemoryIndex, NULL); \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_DLL, TEXT("Thread Memory tracing initialize.\n") )

#define INITIALIZE_TRACE_MEMORY_THREAD      \
    TlsSetValue( g_TraceMemoryIndex, NULL); \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_DLL, TEXT("Thread Memory tracing initialize.\n") )

#define UNINITIALIZE_TRACE_MEMORY           \
    DebugMemoryCheck( );                    \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_DLL, TEXT("Memory tracing terminated.\n") )

#ifdef Assert
#undef Assert
#endif
#define Assert( _fn ) \
    if ( !(_fn) && AssertMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), !!(_fn) ) ) DEBUG_BREAK

#ifdef AssertMsg
#undef AssertMsg
#endif
#define AssertMsg( _fn, _msg ) \
    if ( !(_fn) && AssertMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT(_msg), !!(_fn) ) ) DEBUG_BREAK

#define TraceAlloc( _flags, _size ) DebugAlloc( TEXT(__FILE__), __LINE__, g_szModule, _flags, _size, TEXT(#_size) )
#define TraceFree( _hmem )          DebugFree( _hmem )

//
// Tracing Macros
//
// All functions that begin with "Trace" are in both DEBUG and RETAIL, but
// in RETAIL they do not spew output.
//

// Displays file, line number, module and "_msg" only if the TF_FUNC is set
// in g_dwTraceFlags.
#define TraceFunc( _msg ) \
    InterlockIncrement(g_dwCounter); \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("+ ") TEXT(_msg) );

// Displays file, line number, module, class name and "_msg" only if the 
// TF_FUNC is set in g_dwTraceFlags.
#define TraceClsFunc( _msg ) \
    InterlockIncrement(g_dwCounter); \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("+ %s::%s"), g_szClass, TEXT(_msg) );

// Return macro for TraceFunc() and TraceClsFunc()
#define TraceFuncExit() { \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("V*\n") ); \
    InterlockDecrement(g_dwCounter); \
    return; \
}
#define RETURN( _rval ) { \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("V\n") ); \
    InterlockDecrement(g_dwCounter); \
    return _rval; \
}

// If the value is not S_OK, it will display it.
#define HRETURN( _hr ) { \
    if ( _hr != S_OK ) \
        TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("V hr = 0x%08x\n"), _hr ); \
    else \
        TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("V\n") ); \
    InterlockDecrement(g_dwCounter); \
    return _hr; \
}

// Displays the file, line number, module and function call and return from the
// function call (no return value displayed) for "_fn" only if the TF_CALLS is 
// set in g_dwTraceFlags. 
#define TraceDo( _fn ) {\
    InterlockIncrement(g_dwCounter); \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_CALLS, TEXT("+ %s\n"), TEXT(#_fn) ); \
    _fn; \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_CALLS, TEXT("V\n") ); \
    InterlockDecrement(g_dwCounter); \
}


// This functions only asserts if the result is ZERO.
#define TraceAssertIfZero( _fn ) \
    if ( !(_fn) && AssertMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), !!(_fn) ) ) DEBUG_BREAK

#define TraceMsgGUID( _flag, _guid ) \
    TraceMsg( _flag, TEXT("{%08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x}"), \
        _guid.Data1, _guid.Data2, _guid.Data3,  \
        _guid.Data4[0], _guid.Data4[1], _guid.Data4[2], _guid.Data4[3], \
        _guid.Data4[4], _guid.Data4[5], _guid.Data4[6], _guid.Data4[7] )

#define ErrorMsg( _fmt, _arg ) \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_ALWAYS, TEXT(_fmt), _arg );

//
// Debug Macros
//
// These calls are only compiled in DEBUG. They are a NOP in RETAIL (not even
// compiled in.
//



//
// HRESULT testing macros
//
// These functions check HRESULT return values and display UI if conditions
// warrant only in DEBUG.
//

// Warning is display if HRESULT is anything but S_OK (0).
#define THR( _fn ) \
    TraceHR( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), _fn )

// Warning is display if HRESULT is anything but S_OK (0).
#define RRETURN( _fn ) { \
    RETURN( TraceHR( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), _fn ) ); \
    }


// Warning is display if HRESULT is not S_OK (0) or "_ok".
#define RRETURN1( _hr, _ok ) {\
    RETURN(TraceHR( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_hr), \
                    ( ( _hr == _ok ) ? S_OK : _hr ) ) ); \
    }

//
// Other
//
#define BOOLTOSTRING( _fBool ) ( !!(_fBool) ? g_szTrue : g_szFalse )

//
// Trace/Debug Functions - these do not exist in RETAIL.
//
void
TraceMsg( 
    DWORD   dwCheckFlags,
    LPCSTR pszFormat,
    ... );

void
TraceMsg( 
    DWORD   dwCheckFlags,
    LPCWSTR pszFormat,
    ... );

void
DebugMsg( 
    LPCSTR pszFormat,
    ... );

void
TraceMessage( 
    LPCTSTR pszFile, 
    const int uLine,
    LPCTSTR pszModule, 
    DWORD   dwCheckFlags,
    LPCTSTR pszFormat,
    ... );

BOOL
AssertMessage( 
    LPCTSTR pszFile, 
    const int uLine, 
    LPCTSTR pszModule, 
    LPCTSTR pszfn, 
    BOOL    fTrue );

HRESULT
TraceHR( 
    LPCTSTR pszFile, 
    const int uLine, 
    LPCTSTR pszModule, 
    LPCTSTR pszfn, 
    HRESULT hr );

//
// Memory tracing functions - these are remapped to the "Global" memory 
// functions when in RETAIL.
//
HGLOBAL
DebugAlloc( 
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCTSTR pszComment );

HGLOBAL
DebugFree( 
    HGLOBAL hMem );

// The memory functions don't exist in RETAIL.
HGLOBAL
DebugMemoryAdd(
    HGLOBAL hglobal,
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCTSTR pszComment );

#define DebugMemoryAddHandle( _handle ) \
    DebugMemoryAdd( _handle, TEXT(__FILE__), __LINE__, __MODULE__, GMEM_MOVEABLE, 0, TEXT(#_handle) );

#define DebugMemoryAddAddress( _pv ) \
    DebugMemoryAdd( _pv, TEXT(__FILE__), __LINE__, __MODULE__, GMEM_FIXED, 0, TEXT(#_pv) );

#define TraceStrDup( _sz ) \
    DebugMemoryAdd( StrDup( _sz ), TEXT(__FILE__), __LINE__, __MODULE__, GMEM_FIXED, 0, TEXT("StrDup(") TEXT(#_sz) TEXT(")") );

void
DebugMemoryDelete( 
    HGLOBAL hglobal );

void
DebugMemoryCheck( );

#ifdef __cplusplus
extern void* __cdecl operator new( size_t nSize, LPCTSTR pszFile, const int iLine, LPCTSTR pszModule );
#define new new( TEXT(__FILE__), __LINE__, __MODULE__ )

#endif

//
//
#else // it's RETAIL    ******************************************************
//
//

// Debugging -> NOPs
#define Assert( _fn )           
#define DebugDo( _fn )
#define DEFINE_MODULE( _module )
#define DEFINE_THISCLASS( _class )
#define DEFINE_SUPER( _super )
#define BOOLTOSTRING( _fBool )  NULL
#define AssertMsg                   1 ? (void)0 : (void) 
#define TraceMsg                    1 ? (void)0 : (void) 
#define TraceMsgGUID( _f, _g )      
#define DebugMsg                    1 ? (void)0 : (void) 
#define ErrorMsg                    1 ? (void)0 : (void) 
#define TraceMessage                1 ? (void)0 : (void) 
#define AssertMessage               1 ? (void)0 : (void) 
#define TraceHR                     1 ? (void)0 : (void) 
#define TraceFunc                   1 ? (void)0 : (void) 
#define TraceClsFunc                1 ? (void)0 : (void) 
#define TraceFuncExit()
#define DebugMemoryAddHandle( _handle )
#define DebugMemoryAddAddress( _pv )
#define INITIALIZE_TRACE_MEMORY_PROCESS
#define INITIALIZE_TRACE_MEMORY_THREAD
#define UNINITIALIZE_TRACE_MEMORY
#define DebugMemoryDelete( _h )

// Tracing -> just do operation
#define TraceDo( _fn )              _fn
#define TraceAssertIfZero( _fn )    _fn

// RETURN testing -> do retail
#define THR
#define RETURN( _fn )               return _fn
#define RRETURN( _fn )              return _fn
#define HRETURN( _hr )              return _hr
#define QIRETURN( _qi, _riid )      return _qi

// Memory Functions -> do retail
#define TraceAlloc( _flags, _size )     GlobalAlloc( _flags, _size )
#define TraceFree( _pv )                GlobalFree( _pv )
#define TraceStrDup( _sz )              StrDup( _sz )

#endif // DBG==1

#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rbsetup\server\dhcp.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dhcp.cpp

Abstract:

    Code to allow RIS to automatically authorize for DHCP.

Author:

    Hugh Leather (hughleat) 25-July-2000

Revision History:

--*/


#include "pch.h"


#include "dhcpapi.h"
#include "dhcp.h"
#include "setup.h"

DEFINE_MODULE("DHCP");

PSTR
pSetupUnicodeToMultiByte(
    IN PCWSTR UnicodeString,
    IN UINT   Codepage
    )

/*++

Routine Description:

    Convert a string from unicode to ansi.

Arguments:

    UnicodeString - supplies string to be converted.

    Codepage - supplies codepage to be used for the conversion.

Return Value:

    NULL if out of memory or invalid codepage.
    Caller can free buffer with pSetupFree().

--*/

{
    UINT WideCharCount;
    PSTR String;
    UINT StringBufferSize;
    UINT BytesInString;
    

    WideCharCount = lstrlenW(UnicodeString) + 1;

    //
    // Allocate maximally sized buffer.
    // If every unicode character is a double-byte
    // character, then the buffer needs to be the same size
    // as the unicode string. Otherwise it might be smaller,
    // as some unicode characters will translate to
    // single-byte characters.
    //
    StringBufferSize = WideCharCount * 2;
    String = (PSTR)TraceAlloc(LPTR, StringBufferSize);
    if(String == NULL) {
        return(NULL);
    }

    //
    // Perform the conversion.
    //
    BytesInString = WideCharToMultiByte(
                        Codepage,
                        0,                      // default composite char behavior
                        UnicodeString,
                        WideCharCount,
                        String,
                        StringBufferSize,
                        NULL,
                        NULL
                        );

    if(BytesInString == 0) {
        TraceFree(String);
        return(NULL);
    }

    return(String);
}



//////////////////////////////////////////////////////////////////////////////////////////////
// Dhcp Authorization
// ------------------
// Authorization works like this:
//     S <- List of authorized servers (from call to DhcpEnumServers)
//   I <- IP addresses for this machine (from gethostaddr( 0 ))
//   c <- fully qualified physical DNS name of local machine (from GetComputerNameEx)
//   for each i such that i is a member of I and i is not a member of S do
//       Authorize( i, c ) (by a call to DhcpAddServer)
//
// Aurguments
//   hDlg
//      Parent window (only used for displaying message boxes modally).  Can be NULL.
//
// Returns
//   Whatever error code is first generated (or ERROR_SUCCESS if none).  A message box will
//   be displayed if there is an error.
//
// Used By
//   This code is only used by dialogs.cpp
////////////////////////////////////////////////////////////////////////////////////////////// 
HRESULT AuthorizeDhcp( HWND hDlg ) {
    DWORD err = ERROR_SUCCESS;
    PWSTR FullDllPath = NULL;
    PWSTR computer_name = NULL;
    // Have to use a dll for dhcp authorization function.
    // This code loads them.
    HMODULE module = NULL;
    DWORD ( __stdcall *EnumServersFn )( DWORD, void* , DHCP_SERVER_INFO_ARRAY** ,void* ,void* ); 
    DWORD ( __stdcall *AddServerFn )( DWORD, void* , DHCP_SERVER_INFO* ,void* ,void* );
    
    
    FullDllPath = (PWSTR)TraceAlloc(LPTR, MAX_PATH*sizeof(WCHAR));
    if( !FullDllPath ) {
        err = ERROR_NOT_ENOUGH_MEMORY;
        DebugMsg( "No Memory!\n" );
        goto fail;
    }

    if( !ExpandEnvironmentStrings(L"%systemroot%\\system32\\dhcpsapi.dll", FullDllPath, MAX_PATH) ) {
        err = GetLastError();         
        DebugMsg( "ExpandEnvironmentStrings failed!  (0x%x)\n", err );
        goto fail;
    }

    module = LoadLibrary(FullDllPath);
    if (!module) {
        err = GetLastError(); 
        DebugMsg( "LoadLibrary(dhcpsapi) failed, ec = %d\n", err );
        goto fail;
    }

    
    EnumServersFn = ( DWORD ( __stdcall * )( DWORD, void* , DHCP_SERVER_INFO_ARRAY** ,void* ,void* )) GetProcAddress( module, "DhcpEnumServers" );
    if( !EnumServersFn ) { 
        err = GetLastError(); 
        DebugMsg( "GetProcAddress(DhcpEnumServers) failed, ec = %d\n", err );
        goto fail;
    }
    AddServerFn = ( DWORD ( __stdcall * )( DWORD, void* , DHCP_SERVER_INFO* ,void* ,void* )) GetProcAddress( module, "DhcpAddServer" );
    if( !AddServerFn ) { 
        err = GetLastError(); 
        DebugMsg( "GetProcAddress(DhcpAddServer) failed, ec = %d\n", err );
        goto fail;
    }
    
    // We need the list of ip addresses associated with this machine.  This we do through sockets.
    HOSTENT* host;
#if 0
    DWORD ip;
    ip = 0;
    host = gethostbyaddr(( const char* )&ip, sizeof( DWORD ), AF_INET );
    if( host == NULL ) { 
        err = WSAGetLastError(); 
        DebugMsg( "gethostbyaddr failed, ec = %d\n", err );
        goto fail;
    }
    if( host->h_addrtype != AF_INET || host->h_length != sizeof( DWORD )) { 
        err = E_FAIL;
        DebugMsg( "gethostbyaddr returned invalid data\n" );
        goto fail;
    }
#endif

    // We get the entire list of dhcp servers.
    DHCP_SERVER_INFO_ARRAY* _servers;
    if(( err = EnumServersFn( 0, NULL, &_servers, NULL, NULL )) != ERROR_SUCCESS ) {
        //
        // if this API fails, it will fail with a private DCHP error code that has
        // no win32 mapping.  So set the error code to something generic and
        // reasonable.
        //
        DebugMsg( "DhcpEnumServers failed, ec = %d\n", err );
        err = ERROR_DS_GENERIC_ERROR;
        goto fail;
    }

    // We will need the name of the machine if we have to authorize it.  Get the physical name as I'm not sure I trust what happens in the 
    // clustered case.
    DWORD computer_name_len = 0;

    if ( !GetComputerNameEx( ComputerNamePhysicalDnsFullyQualified, computer_name, &computer_name_len ) &&
         ERROR_MORE_DATA == GetLastError() )
    {
        computer_name = (PWSTR)TraceAlloc(LPTR, computer_name_len * sizeof(WCHAR));

        if ( NULL == computer_name )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            DebugMsg( "new failed, ec = %d\n", err );
            goto fail;
        }

        if( !GetComputerNameEx( ComputerNamePhysicalDnsFullyQualified, computer_name, &computer_name_len ))
        {
            err = GetLastError();
            DebugMsg( "GetComputerNameEx failed, ec = %d\n", err );
            goto fail;
        }
        DebugMsg( "ComputerName = %s\n", computer_name );
    }
    else // shoudnt hit this unless there are serious problems with the system.
    {
        err = GetLastError();
        DebugMsg( "GetComputerNameEx failed, ec = %d\n", err );
        goto fail;
    }

#if 1
    char ComputerNameA[400];
    DWORD ip;

    WideCharToMultiByte(CP_ACP,
                        0,                      // default composite char behavior
                        computer_name,
                        -1,
                        ComputerNameA,
                        400,
                        NULL,
                        NULL
                        );


    host = gethostbyname( ComputerNameA );
    if( host == NULL ) { 
        err = WSAGetLastError(); 
        DebugMsg( "gethostbyaddr failed, ec = %d\n", err );
        goto fail;
    }
    if( host->h_addrtype != AF_INET || host->h_length != sizeof( DWORD )) { 
        err = ERROR_FUNCTION_FAILED;
        DebugMsg( "gethostbyaddr returned invalid data\n" );
        goto fail;
    }


#endif

    // Cool now that we have all of that jazz, we can check that each of our ip addresses is authorized.
    for( PCHAR* i = host->h_addr_list; *i != 0; ++i ) {
        ip = ntohl( *( DWORD* )*i );
        DebugMsg( "searching server list for %d.%d.%d.%d\n",  
                  ip & 0xFF, 
                  (ip >> 8) & 0xFF,
                  (ip >> 16) & 0xFF,
                  (ip >> 24) & 0xFF );
        BOOL this_address_authorized = FALSE;
        for( unsigned j = 0; j < _servers->NumElements; ++j ) {
            DebugMsg( "server list entry: %d.%d.%d.%d\n",  
                  _servers->Servers[ j ].ServerAddress & 0xFF, 
                  (_servers->Servers[ j ].ServerAddress >> 8) & 0xFF,
                  (_servers->Servers[ j ].ServerAddress >> 16) & 0xFF,
                  (_servers->Servers[ j ].ServerAddress >> 24) & 0xFF );
            if( _servers->Servers[ j ].ServerAddress == ip ) {
                DebugMsg("found a match in list\n");
                this_address_authorized = TRUE;
                err = ERROR_SUCCESS;
                break;
            }
        }
        if( !this_address_authorized ) {
            // Authorize it!
            DHCP_SERVER_INFO server_info = { 0 };
            server_info.ServerAddress = ip;
            server_info.ServerName = computer_name;
            DebugMsg("authorizing %s (%d.%d.%d.%d)\n",
                     server_info.ServerName,
                     server_info.ServerAddress & 0xFF, 
                     (server_info.ServerAddress >> 8) & 0xFF,
                     (server_info.ServerAddress >> 16) & 0xFF,
                     (server_info.ServerAddress >> 24) & 0xFF);
            err = AddServerFn( 0, NULL, &server_info, NULL, NULL );
            if( err != ERROR_SUCCESS ) {
                //
                // if this API fails, it will fail with a private DCHP error code that has
                // no win32 mapping.  So set the error code to something generic and
                // reasonable.
                //
                DebugMsg("DhcpAddServer failed, ec = %d\n",
                         err
                        );
                err = ERROR_DS_GENERIC_ERROR;
                goto fail;
            }
        } else {
            DebugMsg("skipping authorization of interface, it's already authorized\n");
        }
    }
    
    err = ERROR_SUCCESS;
    goto exit;

fail :

    MessageBoxFromStrings( 
                    hDlg, 
                    IDS_AUTHORIZING_DHCP, 
                    IDS_AUTHORIZE_DHCP_FAILURE,
                    MB_OK | MB_ICONERROR );

exit :
    if (computer_name) {
        TraceFree(computer_name);
        computer_name = NULL;
    }

    if (module) {
        FreeLibrary(module);
    }

    if (FullDllPath) {
        TraceFree(FullDllPath);
    }
    return HRESULT_FROM_WIN32( err );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rbsetup\server\dialogs.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved

 ***************************************************************************/

#ifndef _DIALOGS_H_
#define _DIALOGS_H_

INT_PTR CALLBACK
WelcomeDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );

INT_PTR CALLBACK
IntelliMirrorRootDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );

INT_PTR CALLBACK
SCPDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );

INT_PTR CALLBACK
WarningDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );

INT_PTR CALLBACK
OptionsDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );

INT_PTR CALLBACK
ImageSourceDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );

INT_PTR CALLBACK
OSDirectoryDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );

INT_PTR CALLBACK
DefaultSIFDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );

INT_PTR CALLBACK
ScreensDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );

INT_PTR CALLBACK
LanguageDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );

INT_PTR CALLBACK
SummaryDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );

INT_PTR CALLBACK
ServerOKDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );

INT_PTR CALLBACK
AddWelcomeDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );

INT_PTR CALLBACK
CheckWelcomeDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );

INT_PTR CALLBACK
ExamineServerDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );

INT_PTR CALLBACK
SetupDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );

#define SMALL_BUFFER_SIZE   256

enum { STATE_WONTSTART, STATE_NOTSTARTED, STATE_STARTED, STATE_DONE, STATE_ERROR };

typedef HRESULT (*PFNOPERATION)( HWND hDlg );

typedef struct {
    HANDLE hChecked;
    HANDLE hError;
    HANDLE hArrow;
    HANDLE hFontNormal;
    HANDLE hFontBold;
    int    dwWidth;
    int    dwHeight;
} SETUPDLGDATA, *LPSETUPDLGDATA;

typedef struct {
    UINT   uState;
    UINT   rsrcId;
    PFNOPERATION pfn;
    TCHAR  szText[ SMALL_BUFFER_SIZE ];
} LBITEMDATA, *LPLBITEMDATA;

extern LBITEMDATA items[];

#endif // _DIALOGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rbsetup\server\pch.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved

  File: PCH.H

  Precompiled header file.

 ***************************************************************************/

#define UNICODE

#if DBG == 1
#define DEBUG
#endif

#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4127)   // condition expression is constant

#include <windows.h>
#include <windowsx.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#include <stdio.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <setupapi.h>
#include <advpub.h>
#include <lm.h>
#include <commdlg.h>
#include <prsht.h>
#include <pshpack2.h>
#include <poppack.h>
#include <commctrl.h>   // includes the common control header
#include <aclapi.h>
#define SECURITY_WIN32
#include <sspi.h>
#include <winsock.h>
#include <dsgetdc.h>
#include <winldap.h>
#include <dsrole.h>
#include <ntdsapi.h>
#include <secext.h>
extern "C" {
#include <spapip.h>
#include <remboot.h>
}

#include "rbsetup.h"
#include "debug.h"
#include "utils.h"
#include "resource.h"

// from ntioapi.h
#define FILE_ATTRIBUTE_NOT_CONTENT_INDEXED  0x00002000

//
// Inc/decrements macros.
//
#define InterlockDecrement( _var ) --_var;
#define InterlockIncrement( _var ) ++_var;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rbsetup\server\main.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997-1999
   All rights reserved

 ***************************************************************************/

#include "pch.h"

#include "dialogs.h"
#include "check.h"
#include "setup.h"
#include "automate.h"

DEFINE_MODULE("Main");

// Globals
HINSTANCE g_hinstance = NULL;
OPTIONS   g_Options;

// Command line flags
#define OPTION_UNKNOWN              0x00
#define OPTION_VERSIONINGOVERRIDE   0x01
#define OPTION_DEBUG                0x02
#define OPTION_FUNC                 0x03
#define OPTION_CHECK                0x04
#define OPTION_ADD                  0x05
#define OPTION_UPGRADE              0x06

#define OPTION_AUTOMATED            0x08


// Constants
#define NUMBER_OF_PAGES 15

//
// Adds a page to the dialog.
//
void
AddPage(
    LPPROPSHEETHEADER ppsh,
    UINT id,
    DLGPROC pfn,
    UINT idTitle,
    UINT idSubtitle )
{
    PROPSHEETPAGE psp;
    TCHAR szTitle[ SMALL_BUFFER_SIZE ];
    TCHAR szSubTitle[ SMALL_BUFFER_SIZE ];

    ZeroMemory( &psp, sizeof(psp) );
    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_DEFAULT | PSP_USETITLE;
    if ( id == IDD_WELCOME || id == IDD_WELCOME_ADD || id == IDD_WELCOME_CHECK )
    {
        psp.dwFlags |= PSP_HIDEHEADER;
    }
    else
    {
        psp.dwFlags |= PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

        if ( idTitle )
        {
            DWORD dw;

            dw = LoadString( g_hinstance, idTitle, szTitle, ARRAYSIZE(szTitle) );
            Assert( dw );
            psp.pszHeaderTitle = szTitle;
        }
        else
        {
            psp.pszHeaderTitle = NULL;
        }

        if ( idSubtitle )
        {
            DWORD dw;

            dw = LoadString( g_hinstance, idSubtitle , szSubTitle, ARRAYSIZE(szSubTitle) );
            Assert( dw );
            psp.pszHeaderSubTitle = szSubTitle;
        }
        else
        {
            psp.pszHeaderSubTitle = NULL;
        }
    }
    psp.pszTitle    = g_Options.fCheckServer 
                           ? MAKEINTRESOURCE( IDS_CHECK_SERVER_TITLE)
                           : MAKEINTRESOURCE( IDS_APPNAME );
    psp.hInstance   = ppsh->hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(id);
    psp.pfnDlgProc  = pfn;

    ppsh->phpage[ ppsh->nPages ] = CreatePropertySheetPage( &psp );
    if ( ppsh->phpage[ ppsh->nPages ] )
        ppsh->nPages++;
}

//
// Creates the UI pages and kicks off the property sheet.
//
HRESULT
WizardPages( )
{
    TraceFunc( "WizardPages( )\n" );

    HRESULT         hr = S_OK;
    HPROPSHEETPAGE  rPages[ NUMBER_OF_PAGES ];
    PROPSHEETHEADER pshead;

    ZeroMemory( &pshead, sizeof(pshead) );
    pshead.dwSize       = sizeof(pshead);
    pshead.dwFlags      = PSH_WIZARD97 | PSH_PROPTITLE | PSH_USEHICON
                        | PSH_WATERMARK | PSH_HEADER;
    pshead.hInstance    = g_hinstance;
    pshead.pszCaption   = g_Options.fCheckServer 
                           ? MAKEINTRESOURCE( IDS_CHECK_SERVER_TITLE)
                           : MAKEINTRESOURCE( IDS_APPNAME );
    pshead.phpage       = rPages;
    pshead.pszbmWatermark = MAKEINTRESOURCE( IDB_TITLEPAGE );
    pshead.pszbmHeader  = MAKEINTRESOURCE( IDB_HEADER );


    AddPage( &pshead, IDD_WELCOME,           WelcomeDlgProc,           0, 0 );
    AddPage( &pshead, IDD_WELCOME_ADD,       AddWelcomeDlgProc,        0, 0 );
    AddPage( &pshead, IDD_WELCOME_CHECK,     CheckWelcomeDlgProc,      0, 0 );
    AddPage( &pshead, IDD_EXAMINING_SERVER,  ExamineServerDlgProc,     IDS_EXAMINING_TITLE, IDS_EXAMINING_SUBTITLE );
    AddPage( &pshead, IDD_INTELLIMIRRORROOT, IntelliMirrorRootDlgProc, IDS_INTELLIMIRRORROOT_TITLE, IDS_INTELLIMIRRORROOT_SUBTITLE );
    AddPage( &pshead, IDD_SCP,               SCPDlgProc,               IDS_SCP_TITLE, IDS_SCP_SUBTITLE );
    AddPage( &pshead, IDD_OPTIONS,           OptionsDlgProc,           IDS_OPTIONS_TITLE, IDS_OPTIONS_SUBTITLE );
    AddPage( &pshead, IDD_IMAGESOURCE,       ImageSourceDlgProc,       IDS_IMAGESOURCE_TITLE, IDS_IMAGESOURCE_SUBTITLE );
    AddPage( &pshead, IDD_LANGUAGE,          LanguageDlgProc,          IDS_LANGUAGE_TITLE, IDS_LANGUAGE_SUBTITLE );
    AddPage( &pshead, IDD_OSDIRECTORY,       OSDirectoryDlgProc,       IDS_OSDIRECTORY_TITLE, IDS_OSDIRECTORY_SUBTITLE );
    AddPage( &pshead, IDD_DEFAULTSIF,        DefaultSIFDlgProc,        IDS_DEFAULTSIF_TITLE, IDS_DEFAULTSIF_SUBTITLE );
    AddPage( &pshead, IDD_SCREENS,           ScreensDlgProc,           IDS_SCREENS_TITLE, IDS_SCREENS_SUBTITLE );
    AddPage( &pshead, IDD_SUMMARY,           SummaryDlgProc,           IDS_SUMMARY_TITLE, IDS_SUMMARY_SUBTITLE );
    AddPage( &pshead, IDD_WARNING,           WarningDlgProc,           IDS_WARNING_TITLE, IDS_WARNING_SUBTITLE );
    AddPage( &pshead, IDD_SERVEROK,          ServerOKDlgProc,          IDS_SERVEROK_TITLE, IDS_SERVEROK_SUBTITLE );

    PropertySheet( &pshead );

    if ( g_Options.fAbort )
    {
        hr = S_FALSE;
        goto Error;
    }

    if ( g_Options.fError )
    {
       hr = E_FAIL;
       goto Error;
    }

Error:
    RETURN(hr);
}

//
// Initializes g_Options.
//
HRESULT
InitializeOptions( void )
{
    DWORD   dw;
    LRESULT lResult;
    HKEY    hkeySetup;

    TraceFunc( "InitializeOptions( )\n" );

    //
    // Initialize all variable to NULL strings or FALSE
    //
    memset( &g_Options, 0, sizeof(OPTIONS) );

    //
    // Load default strings
    //
    dw = LoadString( g_hinstance, IDS_DEFAULTSETUP,
                     g_Options.szInstallationName, ARRAYSIZE(g_Options.szInstallationName) );
    Assert( dw );

    dw = LoadString( g_hinstance, IDS_UNKNOWN, g_Options.szLanguage, ARRAYSIZE(g_Options.szLanguage) );
    Assert( dw );

    wcscpy( g_Options.szSourcePath, L"C:\\" );
    for( ; g_Options.szSourcePath[0] <= L'Z'; g_Options.szSourcePath[0]++ )
    {
        UINT uDriveType;

        uDriveType = GetDriveType( g_Options.szSourcePath );

        if ( DRIVE_CDROM == uDriveType )
            break;
    }

    if ( g_Options.szSourcePath[0] > L'Z' ) {
        g_Options.szSourcePath[0] = L'\0';
    }

    g_Options.hinf = INVALID_HANDLE_VALUE;

    g_Options.fFirstTime = TRUE;
    lResult = RegOpenKey( HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Windows\\CurrentVersion\\Setup", &hkeySetup );
    if ( lResult == ERROR_SUCCESS )
    {
        DWORD dwValue;
        DWORD cbValue;
        
        // Find out if we should authorize DCHP
        cbValue = sizeof(dwValue);
        lResult = RegQueryValueEx( hkeySetup, L"RemInst_DontAuthorizeDHCP", NULL, NULL, (LPBYTE)&dwValue, &cbValue );
        if ( lResult == ERROR_SUCCESS ) {
            g_Options.fDontAuthorizeDhcp = dwValue;
        }

        RegCloseKey( hkeySetup );
    }

    if (SUCCEEDED(GetSetRanFlag(TRUE, FALSE))) {
        g_Options.fFirstTime = FALSE;
    } else {
        g_Options.fFirstTime = TRUE;
    }

    HRETURN(S_OK);
}

//
// IsWhiteSpace()
//
BOOL
IsWhiteSpace( wchar_t ch )
{
    if ( ch <=32 )
        return TRUE;

    return FALSE;
}

//
// CheckWhichOption()
DWORD
CheckWhichOption(
    LPWSTR pszOption )
{
    DWORD dw;
    WCHAR szOptionTag[ 64 ];

    if ( StrCmpNI( pszOption, L"xyzzy", 6 ) == 0 )
        return OPTION_VERSIONINGOVERRIDE;

    if ( StrCmpNI( pszOption, L"debug", 5 ) == 0 )
        return OPTION_DEBUG;

    if ( StrCmpNI( pszOption, L"func", 4 ) == 0 )
        return OPTION_FUNC;

    if ( StrCmpNI( pszOption, L"add", 3 ) == 0 )
        return OPTION_ADD;

    if ( StrCmpNI( pszOption, L"check", 5 ) == 0 )
        return OPTION_CHECK;

    if ( StrCmpNI( pszOption, L"upgrade", 7 ) == 0 )
        return OPTION_UPGRADE;

    if ( StrCmpNI( pszOption, L"auto", 4 ) == 0 )
        return OPTION_AUTOMATED;

    // Internationalized words
    dw = LoadString( g_hinstance, IDS_ADD, szOptionTag, ARRAYSIZE(szOptionTag) );
    Assert( dw );
    if ( StrCmpNIW( pszOption, szOptionTag, lstrlen(szOptionTag) == 0 ) )
        return OPTION_ADD;

    dw = LoadString( g_hinstance, IDS_CHECK, szOptionTag, ARRAYSIZE(szOptionTag) );
    Assert( dw );
    if ( StrCmpNI( pszOption, szOptionTag, lstrlen(szOptionTag) == 0 ) )
        return OPTION_CHECK;

    return OPTION_UNKNOWN;
}

//
// ParseCommandLine()
// Returns false if the call required useage to be printed else true
//
BOOL
ParseCommandLine( LPWSTR lpCmdLine )
{
    LPWSTR psz = lpCmdLine;

    while (*psz)
    {
        if ( *psz == L'/' || *psz == L'-' )
        {
            LPWSTR pszStartOption = ++psz;

            while (*psz && !IsWhiteSpace( *psz ) )
                psz++;

            *psz = L'\0';    // terminate

            switch ( CheckWhichOption( pszStartOption ) )
            {
#ifdef DEBUG
            case OPTION_VERSIONINGOVERRIDE:
                g_Options.fServerCompatible = TRUE;
                break;
            case OPTION_DEBUG:
                g_dwTraceFlags |= TF_HRESULTS;
                break;

            case OPTION_FUNC:
                g_dwTraceFlags |= TF_FUNC;
                break;
#endif
            case OPTION_ADD:
                g_Options.fAddOption = TRUE;
                break;

            case OPTION_AUTOMATED:
                {
                    LPWSTR pszScriptFilename;
                    UINT ErrLine;
                    g_Options.fAutomated = TRUE;
                    WCHAR   UnattendedFile[MAX_PATH];
                    LPWSTR p;

                    //
                    // get the script name
                    //

                    //
                    // first eat all the whitespace
                    //
                    psz++;
                    while(*psz && IsWhiteSpace( *psz )) {
                        psz++;
                    }

                    //
                    // now get the filename, which may or may not be quoted
                    //
                    if (*psz == L'\"') {                        
                        pszScriptFilename = ++psz;
                        while (*psz && ( L'\"' != *psz ) ) {
                            psz++;
                        }                        
                    } else {                        
                        pszScriptFilename = psz;
                        while (*psz && !IsWhiteSpace( *psz ) ) {
                            psz++;
                        }
                    }
                    
                    //
                    // NULL terminate the filename and try to open the file as
                    // an INF file
                    //

                    *psz = L'\0';

                    g_Options.hinfAutomated = INVALID_HANDLE_VALUE;
                    if( GetFullPathName( pszScriptFilename,
                                         MAX_PATH,
                                         UnattendedFile,
                                         &p ) ) {

                        g_Options.hinfAutomated = SetupOpenInfFileW( UnattendedFile, NULL, INF_STYLE_WIN4, &ErrLine );
                    }

                    if ( g_Options.hinfAutomated == INVALID_HANDLE_VALUE ) {
                        ErrorBox( NULL, L"RISETUP" );
                        g_Options.fError = TRUE;
                        return(FALSE);
                    }
                }
                break;

            case OPTION_CHECK:
                g_Options.fCheckServer = TRUE;
                break;

            case OPTION_UPGRADE:
                g_Options.fUpgrade = TRUE;
                break;

            case OPTION_UNKNOWN :
            default :
                WCHAR szCaption[ SMALL_BUFFER_SIZE ];
                WCHAR szUsage[ SMALL_BUFFER_SIZE * 2 ];
                DWORD dw;
                dw = LoadStringW( g_hinstance, IDS_APPNAME, szCaption, ARRAYSIZE( szCaption ) );
                Assert( dw );
                dw = LoadStringW( g_hinstance, IDS_USAGE, szUsage, ARRAYSIZE( szUsage ));
                Assert( dw );
                MessageBoxW( NULL, szUsage, szCaption, MB_OK );
                return FALSE;
            }
        }

        psz++;
    }
    return TRUE;
}

//
// DoSetup( )
//
HRESULT
DoSetup( )
{
    HRESULT hr = S_OK;
    INT iReturn;

    //
    // Setup dialog
    //
    iReturn = (INT)DialogBox( g_hinstance,
                         MAKEINTRESOURCE(IDD_TASKS),
                         NULL,
                         SetupDlgProc );

    return hr;
}

//
// CheckForReboot( )
//
void
CheckForReboot( )
{
    if ( !g_Options.fSISServiceInstalled )
    {
        MessageBoxFromStrings( NULL,
                               IDS_MUST_REBOOT_TITLE,
                               IDS_MUST_REBOOT_MESSAGE,
                               MB_OK | MB_ICONEXCLAMATION );

        SetupPromptReboot( NULL, NULL, FALSE );
    }
}

//
// RunningOnNTServer( )
//
BOOL
RunningOnNTServer(void)
{
    TraceFunc( "RunningOnNtServer()\n" );

    HKEY  hkey;
    LONG  lResult;
    WCHAR szProductType[50] = { 0 };
    DWORD dwType;
    DWORD dwSize  = ARRAYSIZE(szProductType);
    BOOL  fReturn = FALSE; // assume that we are not on NTServer.

    // Query the registry for the product type.
    lResult = RegOpenKeyEx ( HKEY_LOCAL_MACHINE,
                             L"System\\CurrentControlSet\\Control\\ProductOptions",
                             0,
                             KEY_READ,
                             &hkey);
    Assert( lResult == ERROR_SUCCESS );
    if ( lResult != ERROR_SUCCESS )
        goto Error;

    lResult = RegQueryValueEx ( hkey,
                                L"ProductType",
                                NULL,
                                &dwType,
                                (LPBYTE) szProductType,
                                &dwSize);
    Assert( lResult == ERROR_SUCCESS );
    RegCloseKey (hkey);
    if (lResult != ERROR_SUCCESS)
        goto Error;

    if ( _wcsicmp( szProductType, L"ServerNT" ) == 0 )
    {
        fReturn = TRUE; // yep. NT Server alright.
    }

    if ( _wcsicmp( szProductType, L"LanmanNT" ) == 0 )
    {
        fReturn = TRUE; // yep. NT Server alright.
    }

Error:
    RETURN(fReturn);
}

//
// WinMain()
//
int APIENTRY
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow)
{
    
    TraceFunc( "WinMain( ... )\n" );

    HANDLE  hMutex;
    HRESULT hr = E_FAIL;
    WSADATA wsdata;
    LPWSTR pszCommandLine = GetCommandLine( );

    UNREFERENCED_PARAMETER(nCmdShow);
    UNREFERENCED_PARAMETER(lpCmdLine);
    UNREFERENCED_PARAMETER(hPrevInstance);

    TraceFunc( "WinMain( ... )\n" );


    g_hinstance = hInstance;

    INITIALIZE_TRACE_MEMORY_PROCESS;

    // allow only one instance running at a time
    hMutex = CreateMutex( NULL, TRUE, L"RemoteBootSetup.Mutext");
    if (GetLastError() == ERROR_ALREADY_EXISTS)
    {
        MessageBoxFromStrings( NULL,
                               IDS_ALREADY_RUNNING_TITLE,
                               IDS_ALREADY_RUNNING_MESSAGE,
                               MB_OK | MB_ICONSTOP );
        goto Cleanup;
    }

    CoInitialize(NULL);
    WSAStartup( 0x02, &wsdata );

    if( !pSetupIsUserAdmin()
     || !pSetupDoesUserHavePrivilege(SE_SHUTDOWN_NAME)
     || !pSetupDoesUserHavePrivilege(SE_BACKUP_NAME)
     || !pSetupDoesUserHavePrivilege(SE_RESTORE_NAME)
     || !pSetupDoesUserHavePrivilege(SE_SYSTEM_ENVIRONMENT_NAME)) {

        MessageBoxFromStrings( NULL, IDS_MUST_BE_ADMINISTRATOR_CAPTION, IDS_MUST_BE_ADMINISTRATOR_TEXT, MB_OK );
        goto Cleanup;
    }

    if ( !RunningOnNTServer( ) )
    {
        MessageBoxFromStrings( NULL, IDS_NOT_RUNNING_ON_NT_SERVER_CAPTION, IDS_NOT_RUNNING_ON_NT_SERVER_TEXT, MB_OK );
        goto Cleanup;
    }

    hr = InitializeOptions( );
    if ( FAILED(hr) )
        goto Cleanup;

    if( !ParseCommandLine( pszCommandLine )) {
        goto Cleanup;
    }

    // Change SetupAPI to Non-backup mode.
    // also set a flag that makes it fail all signature checks.
    // since we're subject to non-driver signing policy and that
    // is set to ignore by default, this means that every copy
    // operation will generate a signature warning in setupapi.log
    // ...but the memory footprint and speed of risetup process
    // will both go down significantly since we won't drag the
    // crypto libraries into the process.
    // 
    pSetupSetGlobalFlags( pSetupGetGlobalFlags( ) | PSPGF_NO_BACKUP | PSPGF_AUTOFAIL_VERIFIES );

    //
    // Go figure out a default for what processor we're
    // building an image for.
    //
    GetProcessorType();


    if ( !g_Options.fUpgrade && !g_Options.fAutomated )
    {
        hr = WizardPages( );
        if ( hr != S_OK ) {
            goto Cleanup;
        }

        hr = DoSetup( );
        if ( hr != S_OK ) {
            goto Cleanup;
        }
        
        //
        // We need to add in the entries so that ntlmv2 gets
        // enabled.
        //
        EnumAndOperate( g_Options.szOSChooserPath,
                             L"login.osc",
                             FixLoginOSC );

        CheckForReboot( );
    }
    else if ( g_Options.fAutomated )
    {
        if ( g_Options.fError ) {
            goto Cleanup;
        }

        hr = GetAutomatedOptions( );
        if ( hr != S_OK ) {
            goto Cleanup;
        }

        hr = FindImageSource( NULL );
        if ( hr != S_OK ) {
            MessageBoxFromStrings( NULL, IDS_FILE_NOT_FOUND_TITLE, IDS_FILE_NOT_FOUND_TEXT, MB_OK );
            goto Cleanup;
        }

        hr = CheckImageSource( NULL );
        if ( hr != S_OK ) {
            goto Cleanup;
        }

        hr = CheckInstallation( );
        if ( FAILED(hr) ) {
            goto Cleanup;
        }

        hr = DoSetup( );
        if ( hr != S_OK ) {
            goto Cleanup;
        }


        //
        // We need to add in the entries so that ntlmv2 gets
        // enabled.
        //
        EnumAndOperate( g_Options.szOSChooserPath,
                             L"login.osc",
                             FixLoginOSC );
    }
    else if ( g_Options.fUpgrade )
    {
        hr = UpdateRemoteInstallTree( );


        //
        // We need to add in the entries so that ntlmv2 gets
        // enabled.
        //
        EnumAndOperate( g_Options.szOSChooserPath,
                             L"login.osc",
                             FixLoginOSC );

        //
        //  Generate the name of the SIS path and the set the proper
        //  security for it
        //

        if (SUCCEEDED(hr)) {
            WCHAR sisPathName[MAX_PATH+1];
               
            hr = GetRemoteInstallShareInfo();
            if (SUCCEEDED(hr)) {

                hr = GetSisVolumePath(sisPathName,(sizeof(sisPathName)/sizeof(WCHAR)));
                if (SUCCEEDED(hr)) {

                    hr = SetSISCommonStoreSecurity( sisPathName );
                }
            }
        } 
    }
    else
    {
        AssertMsg( 0, "How did I get here?" );
    }



Cleanup:
    CoUninitialize();    
    if ( hMutex ) {
        CloseHandle( hMutex );
    }
    if ( g_Options.hinf != INVALID_HANDLE_VALUE ) {
        SetupCloseInfFile( g_Options.hinf );
    }

    UNINITIALIZE_TRACE_MEMORY;

    RETURN(hr);
}

// stolen from the CRT, used to shrink our code
int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPSTR pszCmdLine = GetCommandLineA();


    if ( *pszCmdLine == '\"' )
    {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine != '\"') );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
            pszCmdLine++;
    }
    else
    {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' '))
    {
        pszCmdLine++;
    }

    GetStartupInfo(&si);

    i = WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rbsetup\server\dialogs.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved

 ***************************************************************************/

#include "pch.h"

#include "dialogs.h"
#include "setup.h"
#include "check.h"
#include "dhcp.h"

DEFINE_MODULE("Dialogs");

#define BITMAP_WIDTH    16
#define BITMAP_HEIGHT   16
#define LG_BITMAP_WIDTH 32
#define LG_BITMAP_HEIGHT 32

static WNDPROC g_pOldEditWndProc;

//
// global window message for cancelling autoplay.
//
UINT g_uQueryCancelAutoPlay = 0;


//
// Check to see if the directory exists. If not, ask the user if we
// should create it.
//
HRESULT
CheckDirectory( HWND hDlg, LPWSTR pszPath )
{
    TraceFunc( "CheckDirectory( ... )\n" );

    HRESULT hr = E_FAIL;
    DWORD dwAttrib = GetFileAttributes( pszPath );

    if ( dwAttrib != 0xFFFFffff 
      && g_Options.fAutomated == FALSE )
    {
        INT iResult =  MessageBoxFromStrings( hDlg,
                                              IDS_DIRECTORYEXISTS_CAPTION,
                                              IDS_DIRECTORYEXISTS_TEXT,
                                              MB_YESNO );
        if ( iResult == IDNO )
            goto Cleanup;
    }


    hr = S_OK;

Cleanup:
    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, (hr == S_OK ? 0 : -1 ) );

    HRETURN(hr);
}

//
// Base dialog proc - all unhandled calls are passed here. If they are not
// handled here, then the default dialog proc will handle them.
//
INT_PTR CALLBACK
BaseDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{

    UNREFERENCED_PARAMETER(lParam);

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        SetDialogFont( hDlg, IDC_S_TITLE1, DlgFontTitle );
        //SetDialogFont( hDlg, IDC_S_TITLE2, DlgFontTitle );
        //SetDialogFont( hDlg, IDC_S_TITLE3, DlgFontTitle );
        SetDialogFont( hDlg, IDC_S_BOLD1,  DlgFontBold  );
        SetDialogFont( hDlg, IDC_S_BOLD2,  DlgFontBold  );
        SetDialogFont( hDlg, IDC_S_BOLD3,  DlgFontBold  );
        break;

    case WM_PALETTECHANGED:
        if ((HWND)wParam != hDlg)
        {
            InvalidateRect(hDlg, NULL, NULL);
            UpdateWindow(hDlg);
        }
        break;

    default:
        return FALSE;
    }
    return TRUE;
}

//
// WelcomeDlgProc( )
//
// "Welcome's" (the first page's) dialog proc.
//
INT_PTR CALLBACK
WelcomeDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        CenterDialog( GetParent( hDlg ) );
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        lpnmhdr = (NMHDR FAR *) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            if ( g_Options.fAddOption
              || g_Options.fCheckServer )
            {
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );   // don't show
                break;
            }

            PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT );
            ClearMessageQueue( );
            break;
        }
        break;

    default:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}

//
// VerifyRootDirectoryName( )
//
BOOL
VerifyRootDirectoryName( )
{
    TraceFunc( "VerifyRootDirectoryName()\n" );
    BOOL fReturn = FALSE;

    LPWSTR psz = g_Options.szIntelliMirrorPath;

    while ( *psz >= 32 && *psz < 127 )
        psz++;

    if ( *psz == L'\0' )
    {
        fReturn = TRUE;
    }

    RETURN(fReturn);
}

//
// IntelliMirrorRootDlgProc( )
//
INT_PTR CALLBACK
IntelliMirrorRootDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;
    DWORD       dwPathLength;

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        {
            HWND hwndEdit = GetDlgItem( hDlg, IDC_E_INTELLIMIRRORROOT );
            Edit_LimitText( hwndEdit, ARRAYSIZE(g_Options.szIntelliMirrorPath) - 1 );
            Edit_SetText( hwndEdit, g_Options.szIntelliMirrorPath );
            return BaseDlgProc( hDlg, uMsg, wParam, lParam );
        }

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        lpnmhdr = (NMHDR FAR *) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_WIZNEXT:
            Edit_GetText( GetDlgItem( hDlg, IDC_E_INTELLIMIRRORROOT ),
                          g_Options.szIntelliMirrorPath,
                          ARRAYSIZE( g_Options.szIntelliMirrorPath ) );
            if ( SUCCEEDED(CheckIntelliMirrorDrive( hDlg ) ))
            {
                g_Options.fIMirrorDirectory = TRUE;
            }
            //
            // Remove any trailing \ from the path, since NetShareAdd
            // can't handle those.
            //
            dwPathLength = lstrlen( g_Options.szIntelliMirrorPath );
            while ( ( dwPathLength > 0 ) &&
                    ( g_Options.szIntelliMirrorPath[dwPathLength-1] == L'\\' ) ) {
                g_Options.szIntelliMirrorPath[dwPathLength-1] = L'\0';
                --dwPathLength;
            }
            if ( !VerifyRootDirectoryName( ) )
            {
                MessageBoxFromStrings( hDlg, IDS_OSCHOOSER_ROOT_DIRECTORY_RESTRICTION_TITLE, IDS_OSCHOOSER_ROOT_DIRECTORY_RESTRICTION_TEXT, MB_OK );
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );
                break;
            }
            PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_BACK | PSWIZB_NEXT );
            break;

        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            if ( g_Options.fError
              || g_Options.fAbort
              || g_Options.fIMirrorShareFound
              || g_Options.fTFTPDDirectoryFound ) {
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );   // don't show
            }
            else
            {
                DWORD dwLen = Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_INTELLIMIRRORROOT ) );
                PropSheet_SetWizButtons( GetParent( hDlg ),
                                         (dwLen ? PSWIZB_BACK | PSWIZB_NEXT : PSWIZB_BACK) );
                ClearMessageQueue( );
            }
            break;
        }
        break;

    case WM_COMMAND:
        switch( LOWORD( wParam))
        {
        case IDC_E_INTELLIMIRRORROOT:
        {
            if ( HIWORD(wParam) == EN_CHANGE )
            {
                DWORD dwLen = Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_INTELLIMIRRORROOT) );
                PropSheet_SetWizButtons( GetParent( hDlg ), dwLen ? PSWIZB_BACK | PSWIZB_NEXT : PSWIZB_BACK );
            }
        }
        break;

        case IDC_B_BROWSE:
            {
                WCHAR szTitle[ SMALL_BUFFER_SIZE ];
                WCHAR szPath[ MAX_PATH ];

                BROWSEINFO bs;
                DWORD      dw;
                ZeroMemory( &bs, sizeof(bs) );
                bs.hwndOwner = hDlg;
                dw = LoadString( g_hinstance, IDS_BROWSECAPTION_RBDIR, szTitle, ARRAYSIZE( szTitle ));
                Assert( dw );
                bs.lpszTitle = (LPWSTR) szTitle;
                bs.ulFlags = BIF_RETURNONLYFSDIRS | BIF_RETURNFSANCESTORS;
                LPITEMIDLIST pidl = SHBrowseForFolder( &bs );

                if ( pidl && SHGetPathFromIDList( pidl, szPath ) ) {
                    if ( wcslen( szPath ) > ARRAYSIZE(g_Options.szSourcePath) - 2 ) {
                        MessageBoxFromStrings( hDlg, IDS_PATH_TOO_LONG_TITLE, IDS_PATH_TOO_LONG_TEXT, MB_OK );
                        szPath[ ARRAYSIZE(g_Options.szSourcePath) - 1 ] = L'\0';
                    }
                    Edit_SetText( GetDlgItem( hDlg, IDC_E_INTELLIMIRRORROOT ), szPath );
                }
            }
            break;
        }
        break;

    default:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}

//
// SCPCheckWindows( )
//
void
SCPCheckWindows( HWND hDlg )
{
    // LONG lAllowNewClients = Button_GetCheck( GetDlgItem( hDlg, IDC_C_ACCEPTSNEWCLIENTS ) );
    // LONG lLimitClients    = Button_GetCheck( GetDlgItem( hDlg, IDC_C_LIMITCLIENTS ) );
    LONG lAnswerRequests  = Button_GetCheck( GetDlgItem( hDlg, IDC_C_RESPOND ) );

    // EnableWindow( GetDlgItem( hDlg, IDC_C_LIMITCLIENTS ), lAllowNewClients );
    // EnableWindow( GetDlgItem( hDlg, IDC_E_LIMIT ), lAllowNewClients && lLimitClients );
    // EnableWindow( GetDlgItem( hDlg, IDC_SPIN_LIMIT ), lAllowNewClients && lLimitClients );
    EnableWindow( GetDlgItem( hDlg, IDC_C_KNOWNCLIENTS ), lAnswerRequests );
}

//
// SCPDlgProc( )
//
// SCP default setup settings
//
INT_PTR CALLBACK
SCPDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;
    static UINT uDlgState = 0;

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        // Edit_LimitText( GetDlgItem( hDlg, IDC_E_LIMIT ), 3 );
        SCPCheckWindows( hDlg );
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        lpnmhdr = (NMHDR FAR *) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_WIZNEXT:
            {
                LONG lResult;
                //lResult = Button_GetCheck( GetDlgItem( hDlg, IDC_C_ACCEPTSNEWCLIENTS ) );
                //scpdata[0].pszValue = ( lResult == BST_CHECKED ? L"TRUE" : L"FALSE" );

                //lResult = Button_GetCheck( GetDlgItem( hDlg, IDC_C_LIMITCLIENTS ) );
                //scpdata[1].pszValue = ( lResult == BST_CHECKED ? L"TRUE" : L"FALSE" );

                //if ( lResult == BST_CHECKED ) {
                //    GetDlgItemText( hDlg, IDC_E_LIMIT, scpdata[3].pszValue, 4 );
                //}

                lResult = Button_GetCheck( GetDlgItem( hDlg, IDC_C_RESPOND ) );
                scpdata[4].pszValue = ( lResult == BST_CHECKED ? L"TRUE" : L"FALSE" );

                lResult = Button_GetCheck( GetDlgItem( hDlg, IDC_C_KNOWNCLIENTS ) );
                scpdata[5].pszValue = ( lResult == BST_CHECKED ? L"TRUE" : L"FALSE" );
            }
            PropSheet_SetWizButtons( GetParent( hDlg ), 0 );
            break;

        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            if ( g_Options.fError || g_Options.fAbort || g_Options.fBINLSCPFound ) {
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );   // don't show
                break;
            }
            PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT | PSWIZB_BACK );
            ClearMessageQueue( );
            break;
        }
        break;

    case WM_COMMAND:
        {
            if ( HIWORD( wParam ) == BN_CLICKED ) {
                SCPCheckWindows( hDlg );
            }
        }
        break;

    default:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}

//
// WarningDlgProc( )
//
INT_PTR CALLBACK
WarningDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        lpnmhdr = (NMHDR FAR *) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            if ( g_Options.fError || g_Options.fAbort || g_Options.fNewOS) {
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );   // don't show
            }
            else
            {
                HRESULT hr = CheckInstallation( );
                if ( hr == S_OK || g_Options.fFirstTime ) {
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );   // do not show this page
                    break;
                }
                PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_BACK | PSWIZB_FINISH );
                ClearMessageQueue( );
            }
            break;
        }
        break;

    default:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}


//
// OptionsDlgProc( )
//
INT_PTR CALLBACK
OptionsDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;

    switch ( uMsg )
    {
        case WM_INITDIALOG:
            Button_SetCheck( GetDlgItem( hDlg, IDC_B_ADD ), BST_CHECKED );
            return BaseDlgProc( hDlg, uMsg, wParam, lParam );

        case WM_NOTIFY:
            SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
            lpnmhdr = (NMHDR FAR *) lParam;
            switch ( lpnmhdr->code )
            {
            case PSN_WIZNEXT:
                if ( BST_CHECKED == Button_GetCheck( GetDlgItem( hDlg, IDC_B_ADD ) ) ) {
                    g_Options.fNewOS = TRUE;
                } else {
                    g_Options.fNewOS = FALSE;
                }
                PropSheet_SetWizButtons( GetParent( hDlg ), 0 );
                break;

            case PSN_QUERYCANCEL:
                return VerifyCancel( hDlg );

            case PSN_SETACTIVE:
                if ( g_Options.fFirstTime 
                  || g_Options.fAddOption ) {
                    g_Options.fNewOS = TRUE;
                }
                if ( g_Options.fFirstTime
                  || g_Options.fAddOption
                  || g_Options.fError
                  || g_Options.fAbort
                  || g_Options.fCheckServer ) {
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );   // don't show
                    break;
                }
                PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_BACK | PSWIZB_NEXT );
                ClearMessageQueue( );
                break;
            }
            break;

        default:
            return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}

//
// ImageSourceDlgProc( )
//
INT_PTR CALLBACK
ImageSourceDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        {
            HWND hwndEdit = GetDlgItem( hDlg, IDC_E_IMAGESOURCE );
            SHAutoComplete(hwndEdit, SHACF_AUTOSUGGEST_FORCE_ON | SHACF_FILESYSTEM);
            Edit_LimitText( hwndEdit, ARRAYSIZE(g_Options.szSourcePath) - 1 );
            Edit_SetText( hwndEdit, g_Options.szSourcePath );
#ifdef SHOW_ARCHITECTURERADIOBUTTON
            if( g_Options.ProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL ) {
                Button_SetCheck( GetDlgItem( hDlg, IDC_C_X86 ), BST_CHECKED );
            } else if( g_Options.ProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64 ) {
                Button_SetCheck( GetDlgItem( hDlg, IDC_C_IA64 ), BST_CHECKED );
            }
#endif
            return BaseDlgProc( hDlg, uMsg, wParam, lParam );
        }

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        lpnmhdr = (NMHDR FAR *) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_WIZNEXT:
            {
                CWaitCursor Wait;
                HRESULT hr;
                DWORD pathlen,archlen;
                WCHAR archscratch[10];
                BOOL FirstTime = TRUE;

                PropSheet_SetWizButtons( GetParent( hDlg ), 0 );
                Edit_GetText( GetDlgItem( hDlg, IDC_E_IMAGESOURCE ),
                              g_Options.szSourcePath,
                              ARRAYSIZE( g_Options.szSourcePath ) );
#ifdef SHOW_ARCHITECTURERADIOBUTTON
                if( ( 0x0003 & Button_GetState( GetDlgItem( hDlg, IDC_C_X86 ) ) ) == BST_CHECKED ) {
                    g_Options.ProcessorArchitecture = PROCESSOR_ARCHITECTURE_INTEL;
                    wcscpy( g_Options.ProcessorArchitectureString, L"i386" );
                    wcscpy( archscracth, L"\\i386");
                    archlen = 5;
                }

                if( ( 0x0003 & Button_GetState( GetDlgItem( hDlg, IDC_C_IA64 ) ) ) == BST_CHECKED ) {
                    g_Options.ProcessorArchitecture = PROCESSOR_ARCHITECTURE_IA64;
                    wcscpy(g_Options.ProcessorArchitectureString, L"ia64" );
                    wcscpy( archscracth, L"\\ia64");
                    archlen = 5;
                }

                pathlen = wcslen(g_Options.szSourcePath);


                // Remove any trailing slashes
                if ( g_Options.szSourcePath[ pathlen - 1 ] == L'\\' ) {
                    g_Options.szSourcePath[ pathlen - 1 ] = L'\0';
                    pathlen -= 1;
                }

                //
                // remove any processor specific subdir at the end of the path
                // if that's there as well, being careful not to underflow
                // the array
                //
                if ( (pathlen > archlen) &&
                     (0 == _wcsicmp(
                                &g_Options.szSourcePath[pathlen-archlen],
                                archscracth))) {
                    g_Options.szSourcePath[ pathlen - archlen ] = L'\0';
                }

                hr = FindImageSource( hDlg );
                if ( hr != S_OK ) {
                    Edit_SetText( GetDlgItem( hDlg, IDC_E_IMAGESOURCE ), g_Options.szSourcePath );
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );
                    break;
                }
#else
                if (g_Options.ProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) {
                    wcscpy(g_Options.ProcessorArchitectureString, L"i386" );
                    wcscpy( archscratch, L"\\i386");
                    archlen = 5;
                } else {
                    wcscpy(g_Options.ProcessorArchitectureString, L"ia64" );
                    wcscpy( archscratch, L"\\ia64");
                    archlen = 5;
                }
                pathlen = (DWORD)wcslen(g_Options.szSourcePath);

                // Remove any trailing slashes
                if ( g_Options.szSourcePath[ pathlen - 1 ] == L'\\' ) {
                    g_Options.szSourcePath[ pathlen - 1 ] = L'\0';
                    pathlen -= 1;
                }

tryfindimagesource:
                //
                // remove any processor specific subdir at the end of the path
                // if that's there as well, being careful not to underflow
                // the array
                //
                if ( (pathlen > archlen) &&
                     (0 == _wcsicmp(
                                &g_Options.szSourcePath[pathlen-archlen],
                                archscratch))) {
                    g_Options.szSourcePath[ pathlen - archlen ] = L'\0';
                }


                //
                // try the default architecture for the image.
                // If it doesn't work then try again with another architecture.
                //
                hr = FindImageSource( hDlg );
                if ( hr != S_OK ) {
                    if (FirstTime) {
                        FirstTime = FALSE;
                        if (g_Options.ProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64) {
                            g_Options.ProcessorArchitecture = PROCESSOR_ARCHITECTURE_INTEL;
                            wcscpy( g_Options.ProcessorArchitectureString, L"i386" );
                            wcscpy( archscratch, L"\\i386");
                            archlen = 5;
                        } else {
                            g_Options.ProcessorArchitecture = PROCESSOR_ARCHITECTURE_IA64;
                            wcscpy(g_Options.ProcessorArchitectureString, L"ia64" );
                            wcscpy( archscratch, L"\\ia64");
                            archlen = 5;
                        }
                        goto tryfindimagesource;
                    } else {
                        //
                        // We didn't find it.  print a failure message.
                        //
                        MessageBoxFromStrings( hDlg, IDS_FILE_NOT_FOUND_TITLE, IDS_FILE_NOT_FOUND_TEXT, MB_OK );
                        Edit_SetText( GetDlgItem( hDlg, IDC_E_IMAGESOURCE ), g_Options.szSourcePath );
                        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );
                        break;
                    }
                }
#endif

#if 0
#ifndef ANYARCHITECTUREIMAGES
                if (g_Options.ProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL) {
                    MessageBoxFromStrings( hDlg, IDS_NOT_SUPPORTED_ARCHITECTURE_TITLE, IDS_NOT_SUPPORTED_ARCHITECTURE_TEXT, MB_OK );
                    Edit_SetText( GetDlgItem( hDlg, IDC_E_IMAGESOURCE ), g_Options.szSourcePath );
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );
                    break;
                }
#endif
#endif

                hr = CheckImageSource( hDlg );

                if ( hr != S_OK )
                {
                    Edit_SetText( GetDlgItem( hDlg, IDC_E_IMAGESOURCE ), g_Options.szSourcePath );
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );
                    break;
                }

                Edit_SetText( GetDlgItem( hDlg, IDC_E_IMAGESOURCE ), g_Options.szSourcePath );
                hr = CheckInstallation( );
            }
            break;

        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            if ( g_Options.fError
              || g_Options.fAbort
              || !g_Options.fNewOS ) {
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );   // don't show
                break;
            }
            else
            {
                DWORD dwLen = Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_IMAGESOURCE) );
                PropSheet_SetWizButtons( GetParent( hDlg ),
                                         (dwLen ? PSWIZB_BACK | PSWIZB_NEXT : PSWIZB_BACK) );
                ClearMessageQueue( );
            }
            break;
        }
        break;

    case WM_COMMAND:
            DWORD dwLen;
        switch( LOWORD( wParam))
        {
        case IDC_E_IMAGESOURCE:
            if ( HIWORD(wParam) != EN_CHANGE )
                return BaseDlgProc( hDlg, uMsg, wParam, lParam );
            // fall thru...
#ifdef SHOW_ARCHITECTURERADIOBUTTON
        case IDC_C_X86:
        case IDC_C_IA64:
            {
                if( ( 0x0003 & Button_GetState( GetDlgItem( hDlg, IDC_C_X86 ) ) ) == BST_CHECKED ) {
                    g_Options.ProcessorArchitecture = PROCESSOR_ARCHITECTURE_INTEL;
                    wcscpy( g_Options.ProcessorArchitectureString, L"i386" );
                }

                if( ( 0x0003 & Button_GetState( GetDlgItem( hDlg, IDC_C_IA64 ) ) ) == BST_CHECKED ) {
                    g_Options.ProcessorArchitecture = PROCESSOR_ARCHITECTURE_IA64;
                    wcscpy( g_Options.ProcessorArchitectureString, L"ia64" );
                }
                dwLen = Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_IMAGESOURCE ) );
                PropSheet_SetWizButtons( GetParent( hDlg ),
                    ( dwLen) ? PSWIZB_BACK | PSWIZB_NEXT : PSWIZB_BACK );
            }
            break;
#else
            dwLen = Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_IMAGESOURCE ) );
            PropSheet_SetWizButtons( 
                            GetParent( hDlg ), 
                            ( dwLen) ? PSWIZB_BACK | PSWIZB_NEXT : PSWIZB_BACK );
            break;
#endif
        case IDC_B_BROWSE:
            {
                WCHAR szPath[ MAX_PATH ];
                WCHAR szTitle[ SMALL_BUFFER_SIZE ];
                BROWSEINFO bs;
                DWORD dw;
                ZeroMemory( &bs, sizeof(bs) );
                bs.hwndOwner = hDlg;
                dw = LoadString( g_hinstance, IDS_BROWSECAPTION_SOURCEDIR, szTitle, ARRAYSIZE( szTitle ));
                Assert( dw );
                bs.lpszTitle = (LPWSTR) szTitle;
                bs.ulFlags = BIF_RETURNONLYFSDIRS | BIF_RETURNFSANCESTORS;
                LPITEMIDLIST pidl = SHBrowseForFolder( &bs );

                if ( pidl && SHGetPathFromIDList( pidl, szPath) ) {
                    if ( wcslen( szPath ) > ARRAYSIZE(g_Options.szSourcePath) - 2 ) {
                        MessageBoxFromStrings( hDlg, IDS_PATH_TOO_LONG_TITLE, IDS_PATH_TOO_LONG_TEXT, MB_OK );
                        //
                        // SHGetPathFromIDList() returns the path with a 
                        // trailing backslash, which we want to drop
                        // The directory that the user selected will be
                        // validated when the user clicks next
                        szPath[ ARRAYSIZE(g_Options.szSourcePath) - 1 ] = L'\0';
                    }
                    Edit_SetText( GetDlgItem( hDlg, IDC_E_IMAGESOURCE ), szPath );
                }
            }
            break;

        default:
            break;
        }
        break;

    default:           
        //
        // try to cancel CD autoplay
        //
        if (!g_uQueryCancelAutoPlay) {
            g_uQueryCancelAutoPlay = RegisterWindowMessage(TEXT("QueryCancelAutoPlay"));
            DebugMsg( "generate autoplay message %d\n", g_uQueryCancelAutoPlay );
        }

        if (uMsg == g_uQueryCancelAutoPlay) {
            DebugMsg( "received autoplay message\n" );
            SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 1 );
            return 1;       // cancel auto-play
        }

        return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}

//
// VerifyDirectoryName( )
//
BOOL
VerifyDirectoryName( )
{
    TraceFunc( "VerifyDirectoryName()\n" );
    BOOL fReturn = FALSE;

    LPWSTR psz = g_Options.szInstallationName;

    //
    // Make sure there's no control codes in the
    // name.
    //
    while ( *psz > 32 && *psz < 127 )
        psz++;

    if ( *psz == L'\0' )
    {
        fReturn = TRUE;
    }


    //
    // Make sure the directory's name isn't
    // '.' or that it doesn't contain ".."
    //
    fReturn = fReturn && 
              (wcsstr(g_Options.szInstallationName, L"..") == NULL) &&
              (wcscmp(g_Options.szInstallationName, L".") != 0);
    
    
    RETURN(fReturn);
}

//
// OSDirectoryDlgProc( )
//
INT_PTR CALLBACK
OSDirectoryDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        {
            HWND hwndEdit = GetDlgItem( hDlg, IDC_E_OSDIRECTORY );
            Edit_LimitText( hwndEdit, ARRAYSIZE(g_Options.szInstallationName) - 1 );
            Edit_SetText( hwndEdit, g_Options.szInstallationName );
        }
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        lpnmhdr = (NMHDR FAR *) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_WIZNEXT:
            Edit_GetText( GetDlgItem( hDlg, IDC_E_OSDIRECTORY ),
                          g_Options.szInstallationName,
                          ARRAYSIZE( g_Options.szInstallationName ) );
            if ( !VerifyDirectoryName( ) )
            {
                MessageBoxFromStrings( hDlg, IDS_OSCHOOSER_DIRECTORY_RESTRICTION_TITLE, IDS_OSCHOOSER_DIRECTORY_RESTRICTION_TEXT, MB_OK );
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );
                break;
            }
            BuildDirectories( );
            CheckDirectory( hDlg, g_Options.szInstallationPath );
            PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_BACK | PSWIZB_NEXT );
            break;

        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            if ( g_Options.fError
              || g_Options.fAbort
              || !g_Options.fNewOS ) {
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );   // don't show
                break;
            }
            else
            {
                DWORD dwLen = Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_OSDIRECTORY) );
                PropSheet_SetWizButtons( GetParent( hDlg ),
                                         (dwLen ? PSWIZB_BACK | PSWIZB_NEXT : PSWIZB_BACK) );
                ClearMessageQueue( );
            }
            break;
        }
        break;

    case WM_COMMAND:
        {
            if ( HIWORD( wParam ) == EN_CHANGE ) {
                DWORD dwLen = Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_OSDIRECTORY ) );
                PropSheet_SetWizButtons( GetParent( hDlg ), ( dwLen  ? PSWIZB_BACK | PSWIZB_NEXT : PSWIZB_BACK ) );
            }
        }
        break;

    default:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}

//
// HelpTextEditWndProc( )
//
INT_PTR CALLBACK
HelpTextEditWndProc(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    switch ( uMsg )
    {
    case WM_KEYDOWN:
        // ignore CONTROL characters
        if ( 0 <= GetKeyState( VK_CONTROL ) )
        {
            // fake button presses
            if ( LOWORD( wParam ) == VK_RETURN ) {
                PropSheet_PressButton( GetParent( GetParent( hWnd ) ), PSBTN_NEXT );
                return FALSE;
            } else if ( LOWORD( wParam ) == VK_ESCAPE ) {
                PropSheet_PressButton( GetParent( GetParent( hWnd ) ), PSBTN_CANCEL );
                return FALSE;
            }
        }
        break;
    }

    return CallWindowProc(g_pOldEditWndProc, hWnd, uMsg, wParam, lParam);
}

//
// VerifySIFText( )
//
BOOL
VerifySIFText(
    LPWSTR pszText )
{
    TraceFunc( "VerifySIFText()\n" );
    BOOL fReturn = FALSE;

    if ( !pszText )
        RETURN(fReturn);

    //
    // make sure the string consists of valid characters that can be displayed
    // by the OS Chooser.  Note that the OS Chooser is not localized, so this
    // check is really for ASCII chars >= 32 (space) and < 127 (DEL)
    //
    while ( *pszText >= 32 && *pszText < 127 )
        pszText++;

    if ( *pszText == L'\0' )
    {
        fReturn = TRUE;
    }

    RETURN(fReturn);
}

//
// DefaultSIFDlgProc( )
//
// Generates the default SIF.
//
INT_PTR CALLBACK
DefaultSIFDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;
    WCHAR szHelpTextFromInf[200];
    WCHAR szDescriptionFromInf[200];
    WCHAR szHelpTextFormat [200];
    DWORD dw;

    

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        
        Edit_LimitText( GetDlgItem( hDlg, IDC_E_DESCRIPTION ), ARRAYSIZE(g_Options.szDescription) - 1 );
        Edit_LimitText( GetDlgItem( hDlg, IDC_E_HELPTEXT ), ARRAYSIZE(g_Options.szHelpText) - 1 );
        // subclass the edit boxes
        g_pOldEditWndProc = (WNDPROC) SetWindowLongPtr( GetDlgItem( hDlg, IDC_E_HELPTEXT), GWLP_WNDPROC, (LONG_PTR)&HelpTextEditWndProc);
        SetWindowLongPtr( GetDlgItem( hDlg, IDC_E_HELPTEXT), GWLP_WNDPROC, (LONG_PTR)&HelpTextEditWndProc);
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        lpnmhdr = (NMHDR FAR *) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_WIZBACK: //fall through           
        case PSN_WIZNEXT:
            Edit_GetText( GetDlgItem( hDlg, IDC_E_DESCRIPTION ),
                          szDescriptionFromInf,
                          ARRAYSIZE(szDescriptionFromInf) );
            Edit_GetText( GetDlgItem( hDlg, IDC_E_HELPTEXT ),
                          szHelpTextFromInf,
                          ARRAYSIZE(szHelpTextFromInf) );
            if ( !VerifySIFText( szDescriptionFromInf ) )
            {
                MessageBoxFromStrings( hDlg,
                                       IDS_OSCHOOSER_RESTRICTION_FIELDS_TITLE,
                                       IDS_OSCHOOSER_RESTRICTION_FIELDS_TEXT,
                                       MB_OK );
                SetFocus( GetDlgItem( hDlg, IDC_E_DESCRIPTION ) );
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't go to next dialog
                break;
            }

            lstrcpyn( g_Options.szDescription, szDescriptionFromInf, ARRAYSIZE(g_Options.szDescription) );

            if ( !VerifySIFText( szHelpTextFromInf ) )
            {
                MessageBoxFromStrings( hDlg,
                                       IDS_OSCHOOSER_RESTRICTION_FIELDS_TITLE,
                                       IDS_OSCHOOSER_RESTRICTION_FIELDS_TEXT,
                                       MB_OK );
                SetFocus( GetDlgItem( hDlg, IDC_E_HELPTEXT ) );
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );  // don't go to next dialog
                break;
            }

            lstrcpyn( g_Options.szHelpText, szHelpTextFromInf, ARRAYSIZE(g_Options.szHelpText) );

            g_Options.fRetrievedWorkstationString = TRUE;
            PropSheet_SetWizButtons( GetParent( hDlg ), 0 );
            break;

        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            if ( g_Options.fError
              || g_Options.fAbort
              || !g_Options.fNewOS ) {
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );   // don't show
                break;
            }
            
            if (g_Options.szDescription[0] == L'\0') {
                //
                // we did not find a description from txtsetup.sif
                //
                if (SUCCEEDED(GetHelpAndDescriptionTextFromSif(
                                        szHelpTextFromInf,
                                        ARRAYSIZE(szHelpTextFromInf),
                                        szDescriptionFromInf,
                                        ARRAYSIZE(szDescriptionFromInf)))) {
                    lstrcpyn(g_Options.szDescription,szDescriptionFromInf, ARRAYSIZE(g_Options.szDescription));
                    lstrcpyn(g_Options.szHelpText,szHelpTextFromInf, ARRAYSIZE(g_Options.szHelpText));
                }
            } else {
                //
                // We got a description and need to build the Help text
                //
                if (g_Options.szHelpText[0] == L'\0') {
                    dw = LoadString( g_hinstance, IDS_DEFAULT_HELPTEXT,
                                     szHelpTextFormat, ARRAYSIZE(szHelpTextFormat) );
                    Assert( dw );
                    _snwprintf(g_Options.szHelpText, ARRAYSIZE(g_Options.szHelpText), szHelpTextFormat, g_Options.szDescription);
                    TERMINATE_BUFFER(g_Options.szHelpText);
                }
            }
    
            SetDlgItemText( hDlg, IDC_E_DESCRIPTION, g_Options.szDescription );
            SetDlgItemText( hDlg, IDC_E_HELPTEXT, g_Options.szHelpText );

            DWORD dwLen1 = Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_DESCRIPTION) );
            DWORD dwLen2 = Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_HELPTEXT) );
            PropSheet_SetWizButtons( GetParent( hDlg ),
                                     (dwLen1 && dwLen2 ? PSWIZB_BACK | PSWIZB_NEXT : PSWIZB_BACK) );           

            ClearMessageQueue( );
            break;
        }
        break;

    case WM_COMMAND:
        switch( LOWORD( wParam ) )
        {
        case IDC_E_DESCRIPTION:
            if ( HIWORD( wParam ) == EN_CHANGE ) {
                DWORD dwLen1 = Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_DESCRIPTION) );
                DWORD dwLen2 = Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_HELPTEXT) );
                PropSheet_SetWizButtons( GetParent( hDlg ),
                                         (dwLen1 && dwLen2 ? PSWIZB_BACK | PSWIZB_NEXT : PSWIZB_BACK) );                
            }
            break;

        case IDC_E_HELPTEXT:
            if ( HIWORD( wParam ) == EN_CHANGE ) {
                DWORD dwLen1 = Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_DESCRIPTION) );
                DWORD dwLen2 = Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_HELPTEXT) );
                PropSheet_SetWizButtons( GetParent( hDlg ),
                                         (dwLen1 && dwLen2 ? PSWIZB_BACK | PSWIZB_NEXT : PSWIZB_BACK) );                
            }
            break;
        }
        break;

    default:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}

//
// ScreensDlgProc( )
//
INT_PTR CALLBACK
ScreensDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        SetFocus( GetDlgItem( hDlg, IDC_R_SAVEOLDFILES ) );
        BaseDlgProc( hDlg, uMsg, wParam, lParam );
        return FALSE;

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        lpnmhdr = (NMHDR FAR *) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            if ( g_Options.fError
              || g_Options.fAbort
              || !g_Options.fNewOS
              || !g_Options.fOSChooserScreensDirectory
              || g_Options.fFirstTime ) {
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );   // don't show
                break;
            }

            LONG lResult;
            lResult = Button_GetCheck( GetDlgItem( hDlg, IDC_R_LEAVEALONE ) );
            g_Options.fScreenLeaveAlone = !!(lResult == BST_CHECKED);

            lResult = Button_GetCheck( GetDlgItem( hDlg, IDC_R_OVERWRITE ) );
            g_Options.fScreenOverwrite = !!(lResult == BST_CHECKED);

            lResult = Button_GetCheck( GetDlgItem( hDlg, IDC_R_SAVEOLDFILES ) );
            g_Options.fScreenSaveOld = !!(lResult == BST_CHECKED);
            PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_BACK |
                ( g_Options.fScreenLeaveAlone
                | g_Options.fScreenOverwrite
                | g_Options.fScreenSaveOld ? PSWIZB_NEXT : 0 ) );
            ClearMessageQueue( );
            break;

        }
        break;

        case WM_COMMAND:
            if ( HIWORD( wParam ) == BN_CLICKED ) {
                LONG lResult;
                lResult = Button_GetCheck( GetDlgItem( hDlg, IDC_R_LEAVEALONE ) );
                g_Options.fScreenLeaveAlone = !!(lResult == BST_CHECKED);

                lResult = Button_GetCheck( GetDlgItem( hDlg, IDC_R_OVERWRITE ) );
                g_Options.fScreenOverwrite = !!(lResult == BST_CHECKED);

                lResult = Button_GetCheck( GetDlgItem( hDlg, IDC_R_SAVEOLDFILES ) );
                g_Options.fScreenSaveOld = !!(lResult == BST_CHECKED);

                PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_BACK |
                    ( g_Options.fScreenLeaveAlone
                    | g_Options.fScreenOverwrite
                    | g_Options.fScreenSaveOld ? PSWIZB_NEXT : 0 ) );
            }
            break;

    default:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}

//
// LanguageDlgProc( )
//
INT_PTR CALLBACK
LanguageDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;

    switch ( uMsg )
    {
    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        lpnmhdr = (NMHDR FAR *) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            if ( !g_Options.fNewOS 
              || g_Options.fError
              || g_Options.fAbort ) {
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );   // do not show this page
                return TRUE;
            } else {

                DWORD dwCodePage;

                if (g_Options.fAutomated) {
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );
                }

                // we should have the workstation language by now
                Assert( g_Options.fLanguageSet );
                dwCodePage = GetSystemDefaultLCID();
                if (dwCodePage) {                
                    DebugMsg( "Server's Installation Code Page: 0x%04x\n", dwCodePage );
                    if ( PRIMARYLANGID( LANGIDFROMLCID(dwCodePage) ) != PRIMARYLANGID( g_Options.dwWksCodePage ) ) {
                        // Check to see if the OSChooser\<Language> exists. If it does,
                        // we don't show the warning page.
                        WCHAR szPath[ MAX_PATH ];
                        wsprintf( 
                            szPath, 
                            L"%s\\OSChooser\\%s", 
                            g_Options.szIntelliMirrorPath, 
                            g_Options.szLanguage );
                        
                        DebugMsg( "Checking for %s directory....", szPath );
                        if ( 0xFFFFffff == GetFileAttributes( szPath ) ) // doesn't exist
                        {   // show the page
                            DebugMsg( "doesn't exist.\n" );
                            PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT | PSWIZB_BACK );
                            ClearMessageQueue( );
                            return TRUE;
                        }
                        DebugMsg( "does. Skip warning.\n" );
                        // don't show the page, must have already been prompted
                        // before. 
                        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );
                        return TRUE;
                    } else {
                        // don't show the page, the locales match 
                        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );
                        return TRUE;
                    }
                }
            }
            break;
        }
        break;

    default:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}


//
// SummaryDlgProc( )
//
INT_PTR CALLBACK
SummaryDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        lpnmhdr = (NMHDR FAR *) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            if ( !g_Options.fNewOS 
              || g_Options.fError
              || g_Options.fAbort ) {
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );   // do not show this page
                break;
            } else {
                WCHAR szText[ SMALL_BUFFER_SIZE ] = { L'\0' };
                WCHAR szFilepath[ MAX_PATH ];
                DWORD dwLen = 0;
                RECT  rect;

                if( g_Options.ProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL ) {

                    DWORD dw;
                     
                    dw = LoadString( g_hinstance, IDS_X86, szText, ARRAYSIZE( szText ));
                    Assert( dw );

                } else if ( g_Options.ProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64 ) {

                    DWORD dw;
                     
                    dw = LoadString( g_hinstance, IDS_IA64, &szText[ dwLen ], ARRAYSIZE( szText ) - dwLen );                
                    Assert( dw );
                }

                // attempt to ellipsis path
                lstrcpy( szFilepath, g_Options.szSourcePath );
                GetWindowRect( GetDlgItem( hDlg, IDC_S_SOURCEPATH ), &rect );
                PathCompactPath( NULL, szFilepath, rect.right - rect.left );

                SetDlgItemText( hDlg, IDC_S_SOURCEPATH, szFilepath );
                SetDlgItemText( hDlg, IDC_S_OSDIRECTORY, g_Options.szInstallationName );
                SetDlgItemText( hDlg, IDC_S_PLATFORM,   szText );

                SetDlgItemText( hDlg, IDC_S_INTELLIMIRRORROOT, g_Options.szIntelliMirrorPath );
                SetDlgItemText( hDlg, IDC_S_LANGUAGE,   g_Options.szLanguage );

                wsprintf( szFilepath, L"%s.%s", g_Options.szMajorVersion, g_Options.szMinorVersion );
                SetDlgItemText( hDlg, IDC_S_NTVERSION,  szFilepath );

                PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_FINISH | PSWIZB_BACK );
                ClearMessageQueue( );
            }
            break;
        }
        break;

    default:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}

//
// ServerOKDlgProc( )
//
INT_PTR CALLBACK
ServerOKDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        lpnmhdr = (NMHDR FAR *) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            if ( g_Options.fNewOS 
              || g_Options.fError
              || g_Options.fAbort ) {
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );
                break;
            }
            HRESULT hr = CheckInstallation( );
            if ( hr != S_OK ) {
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );
                PropSheet_PressButton( GetParent( hDlg ), PSBTN_FINISH );
                break;
            }
            PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_BACK | PSWIZB_FINISH );
            ClearMessageQueue( );
            break;
        }
        break;

    default:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}


//
// CheckWelcomeDlgProc( )
//
// "Check's Welcome" dialog proc.
//
INT_PTR CALLBACK
CheckWelcomeDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        lpnmhdr = (NMHDR FAR *) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            if ( !g_Options.fCheckServer ) {
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );
                break;
            }
            PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT );
            ClearMessageQueue( );
            break;

        case PSN_WIZNEXT:
            // CheckInstallation( );
            PropSheet_SetWizButtons( GetParent( hDlg ), 0 );
            break;
        }
        break;

    default:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}


//
// AddWelcomeDlgProc( )
//
// "Add's Welcome" dialog proc.
//
INT_PTR CALLBACK
AddWelcomeDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        lpnmhdr = (NMHDR FAR *) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            if ( !g_Options.fAddOption ) {
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );
                break;
            }
            PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT );
            ClearMessageQueue( );
            break;

        case PSN_WIZNEXT:
            // CheckInstallation( );
            PropSheet_SetWizButtons( GetParent( hDlg ), 0 );
            break;
        }
        break;

    default:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}

//
// ExamineServerDlgProc( )
//
// This is the screen that is shown wait CheckInstallation() runs for 
// the first time. I had to move it from the InitializeOptions() because 
// "-upgrade" shouldn't go through the exhaustive search and possibly
// show UI.
//
INT_PTR CALLBACK
ExamineServerDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        lpnmhdr = (NMHDR FAR *) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            if ( g_Options.fAlreadyChecked 
              || g_Options.fError 
              || g_Options.fAbort )
            {
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );
                break;
            }
               
            PropSheet_SetWizButtons( GetParent( hDlg ), 0 );
            ClearMessageQueue( );
            PostMessage( hDlg, WM_USER, 0, 0 );
            break;
        }
        break;

    case WM_USER:
        {
            DWORD hr;
            HANDLE hThread;
            hThread = CreateThread( NULL, NULL, (LPTHREAD_START_ROUTINE) &CheckInstallation, NULL, NULL, NULL );
            while ( WAIT_TIMEOUT == WaitForSingleObject( hThread, 0) )
            {
                MSG Msg;
                if ( PeekMessage( &Msg, NULL, 0, 0, PM_REMOVE ) )
                {
                    DispatchMessage( &Msg );
                }
            }
            if ( GetExitCodeThread( hThread, &hr ) )
            {
                DebugMsg( "Thread Exit Code was 0x%08x\n", hr );
                // If check installation failed, bail!
                if ( FAILED( hr ) ) {
                    // Bail on the whole thing. Fake the finish button so
                    // we can exit without the "Are you sure?" dialog popping up.
                    g_Options.fError = TRUE;
                    PropSheet_SetWizButtons( GetParent( hDlg ), PSBTN_FINISH );
                    PropSheet_PressButton( GetParent( hDlg ), PSBTN_FINISH );
                    break;
                }
            }

            CloseHandle( hThread );
            g_Options.fAlreadyChecked = TRUE;

            // Push the next button
            PropSheet_PressButton( GetParent( hDlg ), PSBTN_NEXT );
        }
        break;

    default:
        return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}


LBITEMDATA items[] = {
    { STATE_NOTSTARTED, IDS_CREATINGDIRECTORYTREE, CreateDirectories,           TEXT("") },  // 0
    { STATE_NOTSTARTED, IDS_COPYSERVERFILES,       CopyServerFiles,             TEXT("") },  // 1
    { STATE_NOTSTARTED, IDS_COPYINGFILES,          CopyClientFiles,             TEXT("") },  // 2
    { STATE_NOTSTARTED, IDS_UPDATINGSCREENS,       CopyScreenFiles,             TEXT("") },  // 3
    { STATE_NOTSTARTED, IDS_COPYTEMPLATEFILES,     CopyTemplateFiles,           TEXT("") },  // 4
    { STATE_NOTSTARTED, IDS_CREATING_SERVICES,     CreateRemoteBootServices,    TEXT("") },  // 5
    { STATE_NOTSTARTED, IDS_UPDATINGREGISTRY,      ModifyRegistry,              TEXT("") },  // 6
    { STATE_NOTSTARTED, IDS_CREATING_SIS_VOLUME,   CreateSISVolume,             TEXT("") },  // 7
    { STATE_NOTSTARTED, IDS_CORRECTING_SIS_ACLS,   CreateSISVolume,             TEXT("") },  // 8
    { STATE_NOTSTARTED, IDS_STARTING_SERVICES,     StartRemoteBootServices,     TEXT("") },  // 9
    { STATE_NOTSTARTED, IDS_AUTHORIZING_DHCP,      AuthorizeDhcp,               TEXT("") }   // 10
};


//
// SetupDlgProc( )
//
INT_PTR CALLBACK
SetupDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    static BOOL bDoneFirstPass;
    static UINT nItems;
    static HBRUSH hBrush = NULL;
    LPSETUPDLGDATA psdd = (LPSETUPDLGDATA) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    switch ( uMsg )
    {
        case WM_INITDIALOG:
            {
                BITMAP bm;

                // grab the bitmaps
                psdd = (LPSETUPDLGDATA) TraceAlloc( GMEM_FIXED, sizeof(SETUPDLGDATA) );

                if (psdd == NULL) {
                    return FALSE;
                }

                psdd->hChecked = LoadImage( g_hinstance,
                                            MAKEINTRESOURCE( IDB_CHECK ),
                                            IMAGE_BITMAP,
                                            0, 0,
                                            LR_DEFAULTSIZE | LR_LOADTRANSPARENT );
                DebugMemoryAddHandle( psdd->hChecked );
                GetObject( psdd->hChecked, sizeof(bm), &bm );
                psdd->dwWidth = bm.bmWidth;

                psdd->hError   = LoadImage( g_hinstance,
                                            MAKEINTRESOURCE( IDB_X ),
                                            IMAGE_BITMAP,
                                            0, 0,
                                            LR_DEFAULTSIZE | LR_LOADTRANSPARENT );
                DebugMemoryAddHandle( psdd->hError );
                GetObject( psdd->hError, sizeof(bm), &bm );
                psdd->dwWidth = ( psdd->dwWidth > bm.bmWidth ? psdd->dwWidth : bm.bmWidth );

                psdd->hArrow   = LoadImage( g_hinstance,
                                            MAKEINTRESOURCE( IDB_ARROW ),
                                            IMAGE_BITMAP,
                                            0, 0,
                                            LR_DEFAULTSIZE | LR_LOADTRANSPARENT );
                DebugMemoryAddHandle( psdd->hArrow );
                GetObject( psdd->hArrow, sizeof(bm), &bm );
                psdd->dwWidth = ( psdd->dwWidth > bm.bmWidth ?
                                  psdd->dwWidth :
                                  bm.bmWidth );

                HWND    hwnd = GetDlgItem( hDlg, IDC_L_SETUP );

                HFONT hFontOld = (HFONT) SendMessage( hwnd, WM_GETFONT, 0, 0);
                if(hFontOld != NULL)
                {
                    LOGFONT lf;
                    if ( GetObject( hFontOld, sizeof(LOGFONT), (LPSTR) &lf ) )
                    {
                        psdd->hFontNormal = CreateFontIndirect(&lf);
                        DebugMemoryAddHandle( psdd->hFontNormal );

                        lf.lfWeight = FW_BOLD;
                        psdd->hFontBold = CreateFontIndirect(&lf);
                        DebugMemoryAddHandle( psdd->hFontBold );
                    }
                }

                HDC hDC = GetDC( NULL );
                HANDLE hOldFont = SelectObject( hDC, psdd->hFontBold );
                TEXTMETRIC tm;
                GetTextMetrics( hDC, &tm );
                psdd->dwHeight = tm.tmHeight + 2;
                SelectObject( hDC, hOldFont );
                ReleaseDC( NULL, hDC );

                ListBox_SetItemHeight( hwnd, -1, psdd->dwHeight );

                SetWindowLongPtr( hDlg, GWLP_USERDATA, (LONG_PTR) psdd );

                //
                // Eliminate things that have already been done
                //
                if ( g_Options.fDirectoryTreeExists
                  && g_Options.fIMirrorShareFound ) {
                    items[ 0 ].uState = STATE_WONTSTART;
                }

                if ( !g_Options.fFirstTime
                  && g_Options.fTFTPDFilesFound
                  && g_Options.fSISFilesFound
                  && g_Options.fSISGrovelerFilesFound
                  && g_Options.fOSChooserInstalled
                  && g_Options.fBINLFilesFound
                  && g_Options.fRegSrvDllsFilesFound ) {
                    items[ 1 ].uState = STATE_WONTSTART;
                }

                if ( !g_Options.fNewOS ) {
                    items[ 2 ].uState = STATE_WONTSTART;
                    items[ 3 ].uState = STATE_WONTSTART;
                }

                if ( !g_Options.fNewOS
                   || ( g_Options.fScreenLeaveAlone
                     && !g_Options.fFirstTime ) ) {
                    items[ 3 ].uState = STATE_WONTSTART;
                }

                if ( !g_Options.fNewOS ) {
                    items[ 4 ].uState = STATE_WONTSTART;
                }

                if ( g_Options.fBINLServiceInstalled
                  && g_Options.fTFTPDServiceInstalled
                  && g_Options.fSISServiceInstalled
                  && g_Options.fSISGrovelerServiceInstalled
                  && g_Options.fBINLSCPFound ) {
                    items[ 5 ].uState = STATE_WONTSTART;
                }

                if ( g_Options.fRegistryIntact
                  && g_Options.fRegSrvDllsRegistered
                  && g_Options.fTFTPDDirectoryFound ) {
                    items[ 6 ].uState = STATE_WONTSTART;
                }

                if ( g_Options.fSISVolumeCreated ) {
                    items[ 7 ].uState = STATE_WONTSTART;
                }

                if ( !g_Options.fSISVolumeCreated
                  || g_Options.fSISSecurityCorrect ) {
                    items[ 8 ].uState = STATE_WONTSTART;
                }

                if( g_Options.fDontAuthorizeDhcp ) {
                    items[ 10 ].uState = STATE_WONTSTART;
                }

                nItems = 0;
                for( int i = 0; i < ARRAYSIZE(items); i++ )
                {
                    if ( items[i].uState != STATE_WONTSTART ) {
                        DWORD dw;
                         
                        dw = LoadString( g_hinstance,
                                               items[ i ].rsrcId,
                                               items[ i ].szText,
                                               ARRAYSIZE( items[ i ].szText ) );
                        Assert( dw );

                        ListBox_AddString( hwnd, &items[ i ] );
                        nItems++;
                    }
                }

                bDoneFirstPass = FALSE;

                //
                // Set a timer to fire in a few seconds so that we can force 
                // the setup to proceed even if we don't get the WM_DRAWITEM
                // messages
                //
                SetTimer(hDlg,1,3 * 1000,NULL);

            }

            CenterDialog( hDlg );
            return BaseDlgProc( hDlg, uMsg, wParam, lParam );

        case WM_DESTROY:
            {
                Assert( psdd );
                if ( hBrush != NULL )
                {
                    DeleteObject(hBrush);
                    hBrush = NULL;
                }
                DeleteObject( psdd->hChecked );
                DebugMemoryDelete( psdd->hChecked );
                DeleteObject( psdd->hError );
                DebugMemoryDelete( psdd->hError );
                DeleteObject( psdd->hArrow );
                DebugMemoryDelete( psdd->hArrow );
                DeleteObject( psdd->hFontNormal );
                DebugMemoryDelete( psdd->hFontNormal );
                DeleteObject( psdd->hFontBold );
                DebugMemoryDelete( psdd->hFontBold );
                TraceFree( psdd );
                SetWindowLongPtr( hDlg, GWLP_USERDATA, NULL );
            }
            break;

        case WM_STARTSETUP:
            {
                HWND hwnd = GetDlgItem( hDlg, IDC_L_SETUP );
                RECT rc;
                INT  nProgressBoxHeight = 0;
                HRESULT hr;

                                SetDlgItemText( hDlg, IDC_S_OPERATION, TEXT("") );
                                SendMessage( GetDlgItem( hDlg, IDC_P_METER) , PBM_SETPOS, 0, 0 );
                GetClientRect( hwnd, &rc );

                //
                // Create the directories paths...
                //
                BuildDirectories( );
                INT i = 0;

                if (g_Options.fError) {
                    // Already tanked, set the first item with an error. 
                    for(i=0;i< ARRAYSIZE(items);i++){
                        if(items[i].uState != STATE_WONTSTART){
                            items[i].uState = STATE_ERROR;
                            break;
                        }
                    }
                }

                while ( i < ARRAYSIZE( items )
                     && !g_Options.fError
                     && !g_Options.fAbort )
                {
                    if ( items[ i ].uState != STATE_WONTSTART )
                    {
                        hr = CheckInstallation( );
                        if ( FAILED(hr) ) {
                            g_Options.fError = TRUE;
                            items[i].uState = STATE_ERROR;
                            break;
                        }
                        items[ i ].uState = STATE_STARTED;
                        InvalidateRect( hwnd, &rc, TRUE );

                        // process some messages
                        MSG Msg;
                        while ( PeekMessage( &Msg, NULL, 0, 0, PM_REMOVE ) )
                        {
                            TranslateMessage( &Msg );
                            DispatchMessage( &Msg );
                        }
                        hr = THR( items[ i ].pfn( hDlg ) );
                        if ( FAILED(hr) ) {
                            // fatal error - halt installation
                            items[ i ].uState = STATE_ERROR;
                            g_Options.fError = TRUE;
                        } else if ( hr == S_FALSE ) {
                            // non-fatal error - but something went wrong
                            items[ i ].uState = STATE_ERROR;
                        } else {
                            items[ i ].uState = STATE_DONE;
                        }
                        InvalidateRect( hwnd, &rc, TRUE );
                    }

                    i++;
                }

                hr = THR( CheckInstallation( ) );

                if (g_Options.fFirstTime) {
                    // We believe this is the first time risetup has been run
                    if ( i > 0 ) {
                        // There were items in the list to start with
                        if ( items[ i - 1].rsrcId == IDS_AUTHORIZING_DHCP) {
                            //
                            // We reached the dhcp task, which implies we 
                            // finished
                            GetSetRanFlag( FALSE, FALSE );
                        } else {
                            //
                            // We never reached dhcp authorization (or we
                            // skipped it)
                            //
                            GetSetRanFlag( FALSE, g_Options.fError );
                        }
                    }                    
                }

                // If no errors, exit.
                if ( g_Options.fAutomated && !g_Options.fError )
                {
                    EndDialog( hDlg, 1 );
                }
                else
                {   // we are not bailing, resize, etc.
                    // disable & hide "Cancel" button
                    HWND hwndCancel = GetDlgItem( hDlg, IDCANCEL );
                    ShowWindow( hwndCancel, SW_HIDE );
                    EnableWindow( hwndCancel, FALSE );

                    // hide progress bar stuff
                    HWND hwndGroupBox = GetDlgItem( hDlg, IDC_G_OPERATION );
                    ShowWindow( GetDlgItem( hDlg, IDC_S_OPERATION), SW_HIDE );
                    ShowWindow( GetDlgItem( hDlg, IDC_P_METER), SW_HIDE );
                    ShowWindow( hwndGroupBox, SW_HIDE );
                    GetWindowRect( hwndGroupBox, &rc );
                    nProgressBoxHeight = rc.bottom - rc.top;

                    // make "Done" button move it up and make it visible
                    HWND hwndOK = GetDlgItem( hDlg, IDOK );
                    GetWindowRect( hwndOK, &rc );
                    MapWindowPoints( NULL, hDlg, (LPPOINT) &rc, 2 );
                    SetWindowPos( hwndOK,
                                  NULL,
                                  rc.left, rc.top - nProgressBoxHeight,
                                  0, 0,
                                  SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW );

                    // make "Done" the default button
                    LONG lStyle = GetWindowLong( hwndOK, GWL_STYLE );
                    lStyle |= BS_DEFPUSHBUTTON;
                    SetWindowLong( hwndOK, GWL_STYLE, lStyle );
                    EnableWindow( hwndOK, TRUE );

                    // Shrink dialog
                    GetWindowRect( hDlg, &rc );
                    MoveWindow( hDlg,
                                rc.left, rc.top,
                                rc.right - rc.left, rc.bottom - rc.top - nProgressBoxHeight,
                                TRUE );
                }
            }
            break;


        case WM_MEASUREITEM:
            {
                LPMEASUREITEMSTRUCT lpmis = (LPMEASUREITEMSTRUCT) lParam;
                RECT    rc;
                HWND    hwnd = GetDlgItem( hDlg, IDC_L_SETUP );

                GetClientRect( hwnd, &rc );

                lpmis->itemWidth = rc.right - rc.left;
                lpmis->itemHeight = 15;
            }
            break;

        case WM_DRAWITEM:
            {
                Assert( psdd );

                LPDRAWITEMSTRUCT lpdis = (LPDRAWITEMSTRUCT) lParam;
                LPLBITEMDATA plbid = (LPLBITEMDATA) lpdis->itemData;
                RECT rc = lpdis->rcItem;
                HANDLE hOldFont = INVALID_HANDLE_VALUE;

                rc.right = rc.bottom = psdd->dwWidth;

                switch ( plbid->uState )
                {
                    case STATE_NOTSTARTED:
                        hOldFont = SelectObject( lpdis->hDC, psdd->hFontNormal );
                        break;

                    case STATE_STARTED:
                        DrawBitmap( psdd->hArrow, lpdis, &rc );
                        hOldFont = SelectObject( lpdis->hDC, psdd->hFontBold );
                        break;

                    case STATE_DONE:
                        DrawBitmap( psdd->hChecked, lpdis, &rc );
                        hOldFont = SelectObject( lpdis->hDC, psdd->hFontNormal );
                        break;

                    case STATE_ERROR:
                        DrawBitmap( psdd->hError, lpdis, &rc );
                        hOldFont = SelectObject( lpdis->hDC, psdd->hFontNormal );
                        break;
                }
                
                rc = lpdis->rcItem;
                rc.left += psdd->dwHeight;

                DrawText( lpdis->hDC, plbid->szText, -1, &rc, DT_LEFT | DT_VCENTER );

                if ( hOldFont != INVALID_HANDLE_VALUE )
                {
                    SelectObject( lpdis->hDC, hOldFont );
                }

                if ( !bDoneFirstPass && lpdis->itemID == nItems - 1 )
                {
                    // delay the message until we have painted at least once.
                    bDoneFirstPass = TRUE;
                    PostMessage( hDlg, WM_STARTSETUP, 0, 0 );
                }

            }
            break;

        case WM_CTLCOLORLISTBOX:
            {
                if ( hBrush == NULL )
                {
                    LOGBRUSH brush;
                    brush.lbColor = GetSysColor( COLOR_3DFACE );
                    brush.lbStyle = BS_SOLID;
                    hBrush = (HBRUSH) CreateBrushIndirect( &brush );
                }
                SetBkMode( (HDC) wParam, OPAQUE );
                SetBkColor( (HDC) wParam, GetSysColor( COLOR_3DFACE ) );
                return (INT_PTR)hBrush;
            }
            break;

        case WM_SETTINGCHANGE:
            if ( hBrush ) {
                DeleteObject( hBrush );
                hBrush = NULL;
            }
            break;

        case WM_COMMAND:
            {
                switch( LOWORD( wParam ) )
                {
                case IDCANCEL:
                    if ( HIWORD(wParam) == BN_CLICKED )
                    {
                        if ( !VerifyCancel( hDlg ) ) {
                            EndDialog( hDlg, 0 );
                        }
                    }
                    break;
                case IDOK:
                    if ( HIWORD(wParam) == BN_CLICKED )
                    {
                        EndDialog( hDlg, 1 );
                    }
                    break;
                }
            }

        case WM_TIMER:
            if ( !bDoneFirstPass && g_Options.fAutomated ) { 
                //
                // we're in an unattended setup.  We haven't gotten the
                // WM_STARTSETUP signal yet, so we'll do that right here.
                //
                bDoneFirstPass = TRUE;
                PostMessage( hDlg, WM_STARTSETUP, 0, 0 );                
            }
            KillTimer(hDlg, 1);
            //
            // fall through
            //
        default:
            return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rbsetup\server\utils.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved
 
 ***************************************************************************/

#ifndef _UTILS_H_
#define _UTILS_H_

void 
CenterDialog( 
    HWND hwndDlg );

void 
ClearMessageQueue( void );

int
MessageBoxFromStrings(
    HWND hParent,
    UINT idsCaption,
    UINT idsText,
    UINT uType );

void
MessageBoxFromError(
    HWND hParent,
    LPTSTR pszTitle,
    DWORD dwErr );

void
ErrorBox(
    HWND hParent,
    LPTSTR pszTitle );

//
// Enum for SetDialogFont().
//
typedef enum {
    DlgFontTitle,
    DlgFontBold
} MyDlgFont;


VOID
SetDialogFont(
    IN HWND      hdlg,
    IN UINT      ControlId,
    IN MyDlgFont WhichFont
    );

void 
DrawBitmap( 
    HANDLE hBitmap,
    LPDRAWITEMSTRUCT lpdis,
    LPRECT prc );

BOOL 
VerifyCancel( 
    HWND hParent );

HRESULT 
CheckImageSource( 
    HWND hDlg );

HRESULT
CheckIntelliMirrorDrive( 
    HWND hDlg );

VOID
ConcatenatePaths( 
    IN OUT LPWSTR Path1,
    IN LPCWSTR Path2,
    IN ULONG Path1Length );



HRESULT
FindImageSource(
    HWND hDlg );

HRESULT
GetHelpAndDescriptionTextFromSif(
    OUT PWSTR HelpText,
    IN  DWORD HelpTextSizeInChars,
    OUT PWSTR DescriptionText,
    IN  DWORD DescriptionTextSizeInChars
    );

HRESULT
GetSetRanFlag(
    BOOL bQuery,
    BOOL bClear
    );

DWORD
MyGetFileVersionInfo(
    PCWSTR  FilePath
    );

BOOLEAN
GetBuildNumberFromImagePath(
    PDWORD pdwVersion,
    PCWSTR SearchDir,
    PCWSTR SubDir OPTIONAL
    );

VOID
GetProcessorType(
    );

class CWaitCursor
{
private:
    HCURSOR _hOldCursor;

public:
    CWaitCursor( ) { _hOldCursor = SetCursor( LoadCursor( NULL, IDC_WAIT ) ); };
    ~CWaitCursor( ) { SetCursor( _hOldCursor ); };
};

#endif // _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rbsetup\server\rbsetup.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: RBSETUP.H
 
 ***************************************************************************/


#ifndef _RBINSTAL_H_
#define _RBINSTAL_H_

#include <remboot.h>

// Global macros
#define ARRAYSIZE(_x)   ( sizeof(_x)/sizeof(_x[0]) )
#define TERMINATE_BUFFER(_x) _x[ARRAYSIZE(_x)-1] = 0;

#define WM_STARTSETUP    WM_USER + 0x200
#define WM_STARTCHECKING WM_USER + 0x200

// Global structures
typedef struct {
    //
    // Directory Tree
    //
    BOOL    fIMirrorDirectory:1;                // szIntelliMirrorPath is valid
    BOOL    fIMirrorShareFound:1;               // the IMIRROR share was found
    BOOL    fDirectoryTreeExists:1;             // If true, skip creating directories
    BOOL    fNewOSDirectoryExists:1;            // the user selected a directory that already existed
    BOOL    fOSChooserDirectory:1;              // directory exists szOSChooserPath is valid
    BOOL    fOSChooserDirectoryTreeExists:1;    // directory tree RemBoot.INF's "[OSChooser Tree]" is valid
    // fLanguageSet hast to be TRUE for these to be checked
    BOOL    fOSChooserScreensDirectory:1;       // the Language subdir exists

    //
    // BINL Service
    //
    BOOL    fBINLServiceInstalled:1;            // Service Manager says BINLSVC is installed
    BOOL    fBINLFilesFound:1;                  // the BINLSVC files are in the System32 directory
    BOOL    fBINLSCPFound:1;                    // We found the IntelliMirror SCP in the DS

    //
    // TFTPD Service
    //
    BOOL    fTFTPDServiceInstalled:1;           // Service Manager says TFTPD is installed
    BOOL    fTFTPDFilesFound:1;                 // the TFTPD files are in the System32 directory
    BOOL    fTFTPDDirectoryFound:1;             // the RegKey is found and matches the szIntelliMirrorPath

    //
    // SIS Service
    //
    BOOL    fSISServiceInstalled:1;             // Service Manager says TFTPD is installed
    BOOL    fSISFilesFound:1;                   // the TFTPD files are in the System32\drivers directory
    BOOL    fSISVolumeCreated:1;                // the "SIS Common Store" directory exists
    BOOL    fSISSecurityCorrect:1;              // the security on the "SIS Common Store" directory is correct

    //
    // SIS Groveler
    //
    BOOL    fSISGrovelerServiceInstalled:1;     // Service Single-Instance Storage Groveler installed
    BOOL    fSISGrovelerFilesFound:1;           // the Groveler files are in the System32 directory

    //
    // Dll Registration/Registry Operations
    //
    BOOL    fRegSrvDllsRegistered:1;            // All DLLs that are RegServered have been
    BOOL    fRegSrvDllsFilesFound:1;            // All DLLs that are RegServered are in the System32 directory
    BOOL    fRegistryIntact:1;                  // Registry modifications made during setup have been entered

    //
    // OS Chooser Installation
    //
    BOOL    fOSChooserInstalled:1;              // all expected files for all platforms are installed
    // fLanguageSet hast to be TRUE for these to be checked
    BOOL    fOSChooserScreens:1;                // all expected screen are installed (per language)
    BOOL    fScreenLeaveAlone:1;                // don't touch the screen files
    BOOL    fScreenOverwrite:1;                 // overwrite the screen files
    BOOL    fScreenSaveOld:1;                   // rename the old screen files before copying

    //
    // Version compatibility
    //
    BOOL    fServerCompatible:1;                // Server is compatible with client workstation

    //
    // Flow Flags
    //
    BOOL    fNewOS:1;                           // This is a new OS installation
    BOOL    fLanguageSet:1;                     // szLanguage is valid
    BOOL    fRemBootDirectory:1;                // szRemBootDirectory is valid and found
    BOOL    fProblemDetected:1;                 // Setup detected a problem with the server.
    BOOL    fRetrievedWorkstationString:1;      // If szWorkstation* have been set.
    BOOL    fCheckServer:1;                     // Force server check (command line -check)
    BOOL    fAddOption:1;                       // -add command line specified
    BOOL    fFirstTime:1;                       // First time this server ever ran RISETUP?
    BOOL    fUpgrade:1;                         // Running during OCM, no GUI, just do the CopyServerFiles()
    BOOL    fAlreadyChecked:1;                  // If CheckInstallation() has run once, this is set to TRUE.
    BOOL    fAutomated:1;                       // Using script to automated installation
	BOOL	fDontAuthorizeDhcp:1;				// Should we authorize DHCP
    BOOL    fLanguageOverRide:1;                // was a language override specified in unattend file?

    //
    // Results of installation
    //
    BOOL    fAbort:1;                           // user abort
    BOOL    fError:1;                           // fatal error occurred

    //
    // Platform
    //
    ULONG   ProcessorArchitecture;              // Which processor architecture are we building an image for?
    WCHAR   ProcessorArchitectureString[16];
    DWORD   dwWksCodePage;                      // The codepage of the image source

    //
    // INF
    //
    HINF    hinf;                               // Server's open REMBOOT.INF handle
    HINF    hinfAutomated;                      // Handle to the automated script INF

    //
    // Image Info
    //
    WCHAR   szMajorVersion[5];
    WCHAR   szMinorVersion[5];
    DWORD   dwBuildNumber;

    //
    // Paths
    //
    WCHAR   szIntelliMirrorPath[ 128 ];                 // X:\IntelliMirror
    WCHAR   szSourcePath[ MAX_PATH ];               // CD:\i386 or \\server\share
    WCHAR   szInstallationName[ REMOTE_INSTALL_MAX_DIRECTORY_CHAR_COUNT ]; // "nt50.wks" or whatever the user chooses
    WCHAR   szLanguage[ 32 ];                           // "English" or a Language string
    WCHAR   szWorkstationRemBootInfPath[ MAX_PATH ];
    WCHAR   szWorkstationDiscName[ 128 ];               // "Windows NT Workstation 5.0"
    WCHAR   szWorkstationSubDir[ 32 ];                  // "\i386" or "\ia64" or ...
    WCHAR   szWorkstationTagFile[ MAX_PATH ];           // "\cdrom_i.5b2" or something similiar
    WCHAR   szTFTPDDirectory[ 128 ];                    // where TFTPD thinks the IntelliMirror directory is
    WCHAR   szRemBootDirectory[ MAX_PATH - (1+8+1+3)];  // %windir%\system32\remboot\ 

    //
    // SIF file stuff
    //
    WCHAR   szDescription[ REMOTE_INSTALL_MAX_DESCRIPTION_CHAR_COUNT ];
    WCHAR   szHelpText[ REMOTE_INSTALL_MAX_HELPTEXT_CHAR_COUNT ];

    //
    // Generated path to be re-used
    //
    WCHAR   szInstallationPath[ MAX_PATH ];             // X:\IntelliMirror\Setup\<Lang>\Images\<Install>
    WCHAR   szOSChooserPath[ MAX_PATH ];                // X:\IntelliMirror\OSChooser

} OPTIONS, *LPOPTIONS;

// Globals
extern HINSTANCE g_hinstance;
extern OPTIONS g_Options;

#endif // _RBINSTAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rbsetup\server\setup.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved
 
 ***************************************************************************/

#ifndef _SETUP_H_
#define _SETUP_H_

typedef struct _sSCPDATA {
    LPWSTR pszAttribute;
    LPWSTR pszValue;
} SCPDATA, * LPSCPDATA;


typedef BOOLEAN
(CALLBACK *POPERATECALLBACK) (
    IN PWSTR FileName
    );


//
// Use this structure to driver changes (lines) that
// need to be added/removed from login.osc when we run
// risetup.  We'll use this mechanism to patch legacy
// instances of login.osc that may be hanging around
// on the machine.
//
typedef struct _LOGIN_PATCHES {
                
    //
    // Are we adding or deleting this string?
    //
    BOOLEAN     AddString;
    
    //
    // Boolean indicating whether the string was successfully added/deleted
    //
    BOOLEAN     OperationCompletedSuccessfully;

    //
    // Index to any other entry that this entry might be dependent on.
    // -1 means we're not dependent on any other entry.  In other words,
    // don't process the operation in this entry unless the other entry's
    // OperationCompletedSuccessfully has been set.
    //
    LONG        DependingEntry;

    //
    // What's the tag that specifies the beginning of
    // the section where our string needs to go?
    //
    PSTR        SectionStartTag;
    
    //
    // What's the tag that specifies the ending of
    // the section where our string needs to go?
    //
    PSTR        SectionEndTag;

    //
    // String to add/delete to the section.
    //
    PSTR        TargetString;

} LOGIN_PATCHES, *PLOGIN_PATCHES;

extern SCPDATA scpdata[];

BOOLEAN
CALLBACK
FixLoginOSC(
    PWSTR   FileName
    );

HRESULT
EnumAndOperate(
    PWSTR   pszDirName,
    PWSTR   pszTargetFile,
    POPERATECALLBACK    FileOperateCallback
    );

HRESULT
BuildDirectories( void );

HRESULT
CreateDirectories( HWND hDlg );

HRESULT
CopyClientFiles( HWND hDlg );

HRESULT
ModifyRegistry( HWND hDlg );

HRESULT
StartRemoteBootServices( HWND hDlg );

HRESULT
CreateRemoteBootShare( HWND hDlg );

HRESULT
CreateRemoteBootServices( HWND hDlg );

HRESULT
CopyServerFiles( HWND hDlg );

HRESULT
CopyScreenFiles( HWND hDlg );

HRESULT
UpdateSIFFile( HWND hDlg );

HRESULT
CopyTemplateFiles( HWND hDlg );

HRESULT
GetSisVolumePath( PWCHAR buffer, DWORD sizeInChars );

HRESULT
CreateSISVolume( HWND hDlg );

HRESULT
SetSISCommonStoreSecurity( PWCHAR szSISPath );

BOOL
CheckSISCommonStoreSecurity( PWCHAR szSISPath );

HRESULT
CreateSCP( HWND hDlg );

HRESULT
RegisterDll( HWND hDlg, LPWSTR pszDLLPath );

HRESULT
UpdateRemoteInstallTree( );

HRESULT
GetRemoteInstallShareInfo();

#endif // _SETUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rbsetup\server\i386\syspart.cpp ===
/*++

Copyright (c) 1993-1999 Microsoft Corporation

Module Name:

    syspart.c

Abstract:

    Routines to determine the system partition on x86 machines.

Author:

    Ted Miller (tedm) 30-June-1994

Revision History:

    Copied from winnt32 to risetup by ChuckL 12-May-1999

--*/

#include "pch.h"
#pragma hdrstop

#include <winioctl.h>

DEFINE_MODULE("SysPart");

#define MALLOC(_size) TraceAlloc(LPTR,(_size))
#define FREE(_p) TraceFree(_p)

UINT
MyGetDriveType(
    IN TCHAR Drive
    );


#define WINNT_DONT_MATCH_PARTITION 0
#define WINNT_MATCH_PARTITION_NUMBER  1
#define WINNT_MATCH_PARTITION_STARTING_OFFSET  2

DWORD
FindSystemPartitionSignature(
    IN  LPCTSTR AdapterKeyName,
    OUT LPTSTR Signature
);

DWORD
GetSystemVolumeGUID(
    IN  LPTSTR Signature,
    OUT LPTSTR SysVolGuid
);

BOOL
DoDiskSignaturesCompare(
    IN      LPCTSTR Signature,
    IN      LPCTSTR DriveName,
    IN OUT  PVOID   Compare,
    IN      DWORD   Action
);

BOOL
x86DetermineSystemPartition(
    IN  HWND   ParentWindow,
    OUT PTCHAR SysPartDrive
    )

/*++

Routine Description:

    Determine the system partition on x86 machines.

    On Win95, we always return C:. For NT, read on.

    The system partition is the primary partition on the boot disk.
    Usually this is the active partition on disk 0 and usually it's C:.
    However the user could have remapped drive letters and generally
    determining the system partition with 100% accuracy is not possible.

    With there being differences in the IO system mapping and introduction of Volumes for NT 50
    this has now become complicated. Listed below are the algorithms
    
    
    NT 5.0 Beta 2 and above :
    
        1. Get the signature from the registry. Located at 
           HKLM\Hardware\Description\System\<MultifunctionAdapter or EisaAdapter>\<some Bus No.>\DiskController\0\DiskPeripheral\0\Identifier
        2. Go Through all of the volumes in the system with FindFirstVolume/FindNextVolume/FindVolumeClose.
        3. Take off the trailing backslash to the name returne to get \\?\Volume{guid}.
        4. IOCTL_STORAGE_GET_DEVICE_NUMBER with \\?\Volume{guid} => Check for FILE_DEVICE_DISK. Remember the partition number. Goto 6
        5. If IOCTL_STORAGE_GET_DEVICE_NUMBER fails then use IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS which returns a list of harddisks.  
           For each harddisk remember the starting offset and goto 6.
        6. Check Harddisk # by using \\.\PhysicalDrive# with IOCTL_DISK_GET_DRIVE_LAYOUT.  If the signature matches then this is the disk we boot from.
        7. To find the partition that we boot from we look for boot indicator. If we used 2 we try to match the partition number stored in 6 
           else if 3 we try to match the starting offset.Then you have a \\?\Volume{guid}\ name for the SYSTEM volume. 
        8. Call GetVolumeNameForVolumeMountPoint with A:\, B:\, C:\, ... and check the result of the form \\?\Volume{guid}\ against your match 
           to see what the drive letter is.
           
           Important: Since the *Volume* APIs are post Beta2 we do dynamic loading of kernel32.dll based on the build number returned.

    Versions below NT 5.0 Beta 2
                                                                                                                                    
        1. Get the signature from the registry. Located at 
           HKLM\Hardware\Description\System\<MultifunctionAdapter or EisaAdapter>\<some Bus No.>\DiskController\0\DiskPeripheral\0\Identifier
        2. Enumerate the \?? directory and look for all entries that begin with PhysicalDrive#. 
        3. For each of the Disks look for a match with the signature above and if they match then find out the partition number used to boot 
           using IOCTL_DISK_GET_DRIVE_LAYOUT and the BootIndicator bit.
        4. On finding the Boot partition create a name of the form \Device\Harddisk#\Partition#
        5. Then go through c:,d:...,z: calling QueryDosDeviceName and look for a match. That would be your system partition drive letter

    
    
Arguments:

    ParentWindow - supplies window handle for window to be the parent for
        any dialogs, etc.

    SysPartDrive - if successful, receives drive letter of system partition.

Return Value:

    Boolean value indicating whether SysPartDrive has been filled in.
    If FALSE, the user will have been infomred about why.

--*/

{
    TCHAR DriveName[4];
    BOOL  GotIt=FALSE;
    TCHAR Drive = TEXT('C');
    TCHAR SysPartSig[20], SysVolGuid[MAX_PATH];
    TCHAR DriveVolGuid[MAX_PATH];
    

    UNREFERENCED_PARAMETER(ParentWindow);

    //Get signature from registry - Step 1 listed above
    
    if( (FindSystemPartitionSignature(TEXT("Hardware\\Description\\System\\EisaAdapter"),SysPartSig) != ERROR_SUCCESS )
        && (FindSystemPartitionSignature(TEXT("Hardware\\Description\\System\\MultiFunctionAdapter"),SysPartSig) != ERROR_SUCCESS ) ){  
        GotIt = FALSE;
        goto c0;
    }

    
        //Get the SystemVolumeGUID - steps 2 through 7 listed above ( Beta 2 and after )

        if( GetSystemVolumeGUID( SysPartSig, SysVolGuid ) != ERROR_SUCCESS ){  
            GotIt = FALSE;
            goto c0;
        }


    
    DriveName[1] = TEXT(':');
    
    // 
    //  Enumerate all drive letters and compare their device names
    //

    for(Drive=TEXT('A'); Drive<=TEXT('Z'); Drive++) {

        if(MyGetDriveType(Drive) == DRIVE_FIXED) {

            DriveName[0] = Drive;

                DriveName[2] = '\\';
                DriveName[3] = 0;

                if((*GetVolumeNameForVolumeMountPoint)((LPWSTR)DriveName, (LPWSTR)DriveVolGuid, ARRAYSIZE(DriveVolGuid))){
                    if(!lstrcmp(DriveVolGuid, SysVolGuid) ){
                        GotIt = TRUE;       // Found it
                        break;
                    }


                }

        }
    }

    
    // This helps for some builds ~1500 < buildnum < 1877 that are in a tough spot

    if(!GotIt) {
        //
        // Strange case, just assume C:
        //
        GotIt = TRUE;
        Drive = TEXT('C');
    }


c0:
    if(GotIt) {
        *SysPartDrive = Drive;
    }
    return(GotIt);
}


DWORD
GetSystemVolumeGUID(
    IN  LPTSTR Signature,
    OUT LPTSTR SysVolGuid
)

/*++

Routine Description:

    This routine enumerates all the volumes and if successful returns the \\?\Volume{guid} name for the system partition.

Arguments:

    Signature -  supplies a disk signature of the Boot disk so that it can be compared against. The details
                 to getting this value are detailed in the comments for x86DetermineSystemPartition.

    SysVolGuid - If successful, will contain a name of form \\?\Volume{guid} for the System Partition (the one we use to boot)

Return Value:

    Returns NO_ERROR if successful, otherwise it contains the error code.
    

--*/
{

    HANDLE hVolume, h;
    TCHAR VolumeName[MAX_PATH];
    TCHAR driveName[30];
    BOOL ret, DoExtent, MatchFound;
    STORAGE_DEVICE_NUMBER   number;
    DWORD Err = NO_ERROR;
    DWORD cnt;
    PVOLUME_DISK_EXTENTS Extent = NULL;
    PDISK_EXTENT Start, i;
    DWORD ExtentSize, bytes;
    ULONG PartitionNumToCompare;
    LARGE_INTEGER StartingOffToCompare;

    
    //Enuberate all volumes

    hVolume = (*FindFirstVolume)( (LPWSTR)VolumeName, MAX_PATH );
    if( hVolume == INVALID_HANDLE_VALUE ){
        return GetLastError();
    }

    MatchFound = FALSE;

    do{

        //Remove trailing backslash

        DoExtent = FALSE;
            
        if( wcsrchr( VolumeName,TEXT('\\') ) ){
            *wcsrchr( VolumeName,TEXT('\\') ) = 0;
        }else{
            continue;
        }


        //Open the volume

        h = CreateFile(VolumeName, GENERIC_READ, FILE_SHARE_READ |
                       FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
        if (h == INVALID_HANDLE_VALUE) {
            continue; // Move on to next volume
        }

        //Get the disk number

        ret = DeviceIoControl(h, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0,
                        &number, sizeof(number), &bytes, NULL);

        if( !ret ){
            
            // Try using IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS if the above failed

            Extent = (PVOLUME_DISK_EXTENTS)MALLOC(1024);
            ExtentSize = 1024;
            if(!Extent) {
                CloseHandle( h );
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }
            
            
        
retry:
        
            ret = DeviceIoControl( h, IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
                    NULL,0,(PVOID)Extent,ExtentSize,&bytes,NULL);
        
            if(!ret) {
        
                if((Err=GetLastError()) == ERROR_INSUFFICIENT_BUFFER) {
        
                    ExtentSize += 1024;
                    FREE(Extent);
                    Extent = (PVOLUME_DISK_EXTENTS)MALLOC(ExtentSize);
                    if( !Extent ) {
                        CloseHandle( h );
                        Err = ERROR_NOT_ENOUGH_MEMORY;
                        goto cleanup;
                    }
                    goto retry;
                } else {
                    CloseHandle( h );
                    continue;
                }
            }else{
                DoExtent = TRUE;
            }

        }
        
        // Done with the handle this time around

        CloseHandle( h );

        if( !DoExtent ){

             //
            //  Check to see if this is a disk and not CDROM etc.
            //

            if( number.DeviceType == FILE_DEVICE_DISK ){
                
                // Remember the partition number
                PartitionNumToCompare = number.PartitionNumber;
                wsprintf( driveName, TEXT("\\\\.\\PhysicalDrive%lu"), number.DeviceNumber );


                if(DoDiskSignaturesCompare( Signature, driveName, (PVOID)&PartitionNumToCompare, WINNT_MATCH_PARTITION_NUMBER  ) ){
                    MatchFound = TRUE;
                    Err = NO_ERROR;
                    lstrcpy( SysVolGuid, VolumeName );
                    SysVolGuid[lstrlen(VolumeName)]=TEXT('\\');
                    SysVolGuid[lstrlen(VolumeName)+1]=0;
                    break;
                }
                
            }
            // Move on ..
            continue;
            
        }else{
            // Go through all disks and try for match

            Start = Extent->Extents;
            cnt = 0;      
            for( i = Start; cnt < Extent->NumberOfDiskExtents; i++ ){
                cnt++;
                // Remember the starting offset
                StartingOffToCompare = i->StartingOffset;
                wsprintf( driveName, TEXT("\\\\.\\PhysicalDrive%lu"), i->DiskNumber );
                if(DoDiskSignaturesCompare( Signature, driveName, (PVOID)&StartingOffToCompare, WINNT_MATCH_PARTITION_STARTING_OFFSET ) ){
                    MatchFound = TRUE;
                    Err = NO_ERROR;
                    lstrcpy( SysVolGuid, VolumeName );
                    SysVolGuid[lstrlen(VolumeName)]=TEXT('\\');
                    SysVolGuid[lstrlen(VolumeName)+1]=0;
                    break;
                }
            }
            
        }
        
        if( MatchFound )
            break;
        

    }while( (*FindNextVolume)( hVolume, (LPWSTR)VolumeName, MAX_PATH ));


cleanup:

    if( hVolume != INVALID_HANDLE_VALUE )
        (*FindVolumeClose)( hVolume );

    if( Extent != NULL ) {
        FREE(Extent);
    }
    return Err;



}



BOOL
DoDiskSignaturesCompare(
    IN      LPCTSTR Signature,
    IN      LPCTSTR DriveName,
    IN OUT  PVOID   Compare,
    IN      DWORD   Action
)
/*++

Routine Description:

    This routine compares the given disk signature with the one for the specified physical disk.

Arguments:

    Signature -  supplies a disk signature of the Boot disk so that it can be compared against. The details
                 to getting this value are detailed in the comments for x86DetermineSystemPartition.

    DriveName -  Physical Drive name of the form \\.\PhysicalDrive#
    
    Compare   -  A pointer to a storage variable. The type depends on the value of Action
    
    Action    -  Should be one of the following
                
                WINNT_DONT_MATCH_PARTITION - Once disk signatures match it returns the boot partition number in Compare. Compare should be a PULONG.
                       
                WINNT_MATCH_PARTITION_NUMBER - Once disk signatures match it tries to match the boot partition number with the number passed in
                                               through Compare. Compare should be PULONG.
                
                WINNT_MATCH_PARTITION_STARTING_OFFSET - Once disk signatures match it tries to match the boot partition starting offset with the 
                                                        starting offset number passed in through Compare. Compare should be PLARGE_INTEGER.

Return Value:

    Returns TRUE if successful in getting a match.
    

--*/

{

    BOOL b,Found = FALSE;
    PLARGE_INTEGER Starting_Off = NULL;
    PPARTITION_INFORMATION Start = NULL, i = NULL;
    HANDLE hDisk;
    PDRIVE_LAYOUT_INFORMATION DriveLayout = NULL;
    DWORD DriveLayoutSize;
    DWORD cnt;
    DWORD DataSize;
    PULONG Disk_Num = NULL;
    ULONG Sig;
    


    if(!Compare )
        return FALSE;

    if( (Action==WINNT_MATCH_PARTITION_STARTING_OFFSET) && Compare ) {
        Starting_Off = (PLARGE_INTEGER) Compare;
    } else {
        Disk_Num = (PULONG) Compare;
    }
    




    // On any failure return FALSE



    //
    // Get drive layout info for this physical disk.
    // If we can't do this something is very wrong.
    //
    hDisk = CreateFile(
                DriveName,
                FILE_READ_ATTRIBUTES | FILE_READ_DATA,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );
    
    if(hDisk == INVALID_HANDLE_VALUE) {

        return FALSE;
    }

    //
    // Get partition information.
    //
    DriveLayout = (PDRIVE_LAYOUT_INFORMATION)MALLOC(1024);
    DriveLayoutSize = 1024;
    if(!DriveLayout) {
        goto cleanexit;
    }
    
    
retry:

    b = DeviceIoControl(
            hDisk,
            IOCTL_DISK_GET_DRIVE_LAYOUT,
            NULL,
            0,
            (PVOID)DriveLayout,
            DriveLayoutSize,
            &DataSize,
            NULL
            );

    if(!b) {

        if(GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

            DriveLayoutSize += 1024;
            FREE(DriveLayout);
            DriveLayout = (PDRIVE_LAYOUT_INFORMATION)MALLOC(DriveLayoutSize);
            if( !DriveLayout ) {
                goto cleanexit;
            }
            goto retry;
        } else {
            goto cleanexit;
        }
    }else{

        // Now walk the Drive_Layout to find the boot partition
        
        Start = DriveLayout->PartitionEntry;
        cnt = 0;

        /*
        _ultot( DriveLayout->Signature, temp, 16 );
        if( lstrcmpi( temp, Signature ) )
            goto cleanexit;
        */

        Sig = wcstoul( Signature, NULL, 16 ); 
        if( Sig != DriveLayout->Signature )
            goto cleanexit;

        for( i = Start; cnt < DriveLayout->PartitionCount; i++ ){
            cnt++;
            
            
            if( i->BootIndicator == TRUE ){
                if( (Disk_Num) && (Action == WINNT_DONT_MATCH_PARTITION) ){
                    *Disk_Num = i->PartitionNumber;
                    Found = TRUE;
                    goto cleanexit;

                }


                if( (Disk_Num) && (Action == WINNT_MATCH_PARTITION_NUMBER) ){
                    if( *Disk_Num == i->PartitionNumber ){
                        Found = TRUE;
                        goto cleanexit;
                    }

                }else{
                    if( (Starting_Off) && (Starting_Off->QuadPart == i->StartingOffset.QuadPart) ){
                        Found = TRUE;
                        goto cleanexit;
                    }

                }
                
                break;
            }
            
        }



    }

cleanexit:

    if( hDisk != INVALID_HANDLE_VALUE )
        CloseHandle( hDisk );

    if( DriveLayout != NULL ) {
        FREE(DriveLayout);
    }


    return Found;
}











DWORD
FindSystemPartitionSignature(
    IN  LPCTSTR AdapterKeyName,
    OUT LPTSTR Signature
)
/*++

Routine Description:

    This routine fetches the disk signature for the first disk that the BIOS sees. This has to be the disk that we boot from on x86s.
    It is at location <AdapterKeyName>\<some Bus No.>\DiskController\0\DiskPeripheral\0\Identifier

Arguments:

    Signature -  If successful will contain the signature of the disk we boot off from in Hex.

Return Value:

    Returns ERROR_SUCCESS if successful, otherwise it contains the error code.
    

--*/
{

    DWORD Err, dwSize;
    HKEY hkey, BusKey, Controller, SystemDiskKey;
    int busnumber;
    TCHAR BusString[20], Identifier[100];



    Err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        AdapterKeyName,
                        0,
                        KEY_READ,
                        &hkey );

    if( Err != ERROR_SUCCESS )
        return Err;

    
    // Start enumerating the buses

    for( busnumber=0; ;busnumber++){

        wsprintf( BusString, TEXT("%d"), busnumber );

        Err = RegOpenKeyEx( hkey,
                        BusString,
                        0,
                        KEY_READ,
                        &BusKey );

        

        if( Err != ERROR_SUCCESS ){
            RegCloseKey( hkey );
            return Err;
        }
        
        Err = RegOpenKeyEx( BusKey,
                        TEXT("DiskController"),
                        0,
                        KEY_READ,
                        &Controller );

        
        RegCloseKey(BusKey);        // Not needed anymore

        
        if( Err != ERROR_SUCCESS )  // Move on to next bus
            continue;

        RegCloseKey( hkey );        // Not needed anymore

        Err = RegOpenKeyEx( Controller,
                        TEXT("0\\DiskPeripheral\\0"),
                        0,
                        KEY_READ,
                        &SystemDiskKey );

        if( Err != ERROR_SUCCESS ){
            RegCloseKey( Controller );
            return Err;
        }

        RegCloseKey( Controller );  // Not needed anymore


        dwSize = sizeof(Identifier);
        Err = RegQueryValueEx( SystemDiskKey,
                               TEXT("Identifier"),
                               NULL,
                               NULL,
                               (PBYTE) Identifier,
                               &dwSize);

        if( Err != ERROR_SUCCESS  ){
            RegCloseKey( SystemDiskKey );
            return Err;
        }

        if( Identifier && (lstrlen(Identifier) > 9 ) ){
            PWCHAR p;

            lstrcpy( Signature,Identifier+9);
            p = wcsrchr( Signature,TEXT('-') );
            if( p ) {
                *p = 0;
            }
            RegCloseKey( SystemDiskKey );
            return ERROR_SUCCESS;
        }
        else{
            RegCloseKey( SystemDiskKey );
            return Err;
        }


         
    }

}





UINT
MyGetDriveType(
    IN TCHAR Drive
    )

/*++

Routine Description:

    Same as GetDriveType() Win32 API except on NT returns
    DRIVE_FIXED for removeable hard drives.

Arguments:

    Drive - supplies drive letter whose type is desired.

Return Value:

    Same as GetDriveType().

--*/

{
    TCHAR DriveNameNt[] = TEXT("\\\\.\\?:");
    TCHAR DriveName[] = TEXT("?:\\");
    HANDLE hDisk;
    BOOL b;
    UINT rc;
    DWORD DataSize;
    DISK_GEOMETRY MediaInfo;

    //
    // First, get the win32 drive type. If it tells us DRIVE_REMOVABLE,
    // then we need to see whether it's a floppy or hard disk. Otherwise
    // just believe the api.
    //
    //
    DriveName[0] = Drive;
    rc = GetDriveType(DriveName);

    if((rc != DRIVE_REMOVABLE) || (Drive < L'C')) {
        return(rc);
    }

    //
    // DRIVE_REMOVABLE on NT.
    //

    //
    // Disallow use of removable media (e.g. Jazz, Zip, ...).
    //


    DriveNameNt[4] = Drive;

    hDisk = CreateFile(
                DriveNameNt,
                FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

    if(hDisk != INVALID_HANDLE_VALUE) {

        b = DeviceIoControl(
                hDisk,
                IOCTL_DISK_GET_DRIVE_GEOMETRY,
                NULL,
                0,
                &MediaInfo,
                sizeof(MediaInfo),
                &DataSize,
                NULL
                );

        //
        // It's really a hard disk if the media type is removable.
        //
        if(b && (MediaInfo.MediaType == RemovableMedia)) {
            rc = DRIVE_FIXED;
        }

        CloseHandle(hDisk);
    }


    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rbsetup\server\utils.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved

 ***************************************************************************/

#include "pch.h"

DEFINE_MODULE("Utils");

#define SMALL_BUFFER_SIZE   1024

BOOL
x86DetermineSystemPartition(
    IN  HWND   ParentWindow,
    OUT PTCHAR SysPartDrive
    );


//
// Centers a dialog.
//
void
CenterDialog(
    HWND hwndDlg )
{
    RECT    rc;
    RECT    rcScreen;
    int     x, y;
    int     cxDlg, cyDlg;
    int     cxScreen;
    int     cyScreen;

    SystemParametersInfo( SPI_GETWORKAREA, 0, &rcScreen, 0 );

    cxScreen = rcScreen.right - rcScreen.left;
    cyScreen = rcScreen.bottom - rcScreen.top;

    GetWindowRect( hwndDlg, &rc );

    cxDlg = rc.right - rc.left;
    cyDlg = rc.bottom - rc.top;

    y = rcScreen.top + ( ( cyScreen - cyDlg ) / 2 );
    x = rcScreen.left + ( ( cxScreen - cxDlg ) / 2 );

    SetWindowPos( hwndDlg, NULL, x, y, 0, 0, SWP_NOSIZE | SWP_NOACTIVATE );
}

//
// Eats all mouse and keyboard messages.
//
void
ClearMessageQueue( void )
{
    MSG   msg;

    while ( PeekMessage( (LPMSG)&msg, NULL, WM_KEYFIRST, WM_MOUSELAST,
                PM_NOYIELD | PM_REMOVE ) );
}

//
// Create a message box from resource strings.
//
int
MessageBoxFromStrings(
    HWND hParent,
    UINT idsCaption,
    UINT idsText,
    UINT uType )
{
    TCHAR szText[ SMALL_BUFFER_SIZE ];
    TCHAR szCaption[ SMALL_BUFFER_SIZE ];
    DWORD dw;

    dw = LoadString( g_hinstance, idsCaption, szCaption, ARRAYSIZE( szCaption ));
    Assert( dw );
    dw = LoadString( g_hinstance, idsText, szText, ARRAYSIZE( szText ));
    Assert( dw );

    return MessageBox( hParent, szText, szCaption, uType );
}

//
// Creates a error message box
//
void
MessageBoxFromError(
    HWND hParent,
    LPTSTR pszTitle,
    DWORD dwErr )
{
    WCHAR szText[ SMALL_BUFFER_SIZE ];
    LPTSTR lpMsgBuf;

    if ( dwErr == ERROR_SUCCESS ) {
        AssertMsg( dwErr, "Why was MessageBoxFromError() called when the dwErr == ERROR_SUCCES?" );
        return;
    }

    if ( !pszTitle ) {
        DWORD dw;
        szText[0] = L'\0';
        dw = LoadString( g_hinstance, IDS_ERROR, szText, ARRAYSIZE( szText ));
        Assert( dw );
        pszTitle = szText;
    }

    if (!FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        dwErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR) &lpMsgBuf,
        0,
        NULL )) {
        lpMsgBuf = NULL;
    }

    if (lpMsgBuf == NULL) {
        AssertMsg( dwErr, "Getting error message failed.  Why?" );
        return;
    }

    MessageBox( hParent, lpMsgBuf, pszTitle, MB_OK | MB_ICONERROR );
    LocalFree( lpMsgBuf );
}

//
// Creates a error message box
//
void
ErrorBox(
    HWND hParent,
    LPTSTR pszTitle )
{
    DWORD dw;
    DWORD dwErr = GetLastError( );
    WCHAR szText[ SMALL_BUFFER_SIZE ];
    WCHAR szString[ 256 ];
    LPTSTR lpMsgBuf;

    if ( dwErr == ERROR_SUCCESS ) {
        AssertMsg( dwErr, "Why was MessageBoxFromError() called when the dwErr == ERROR_SUCCES?" );
        return;
    }

    if ( !pszTitle ) {
        DWORD LoadStringStatus;
        LoadStringStatus = LoadString( g_hinstance, IDS_ERROR, szText, ARRAYSIZE( szText ));
        Assert( LoadStringStatus );
        pszTitle = szText;
    }
    
    switch (dwErr) {
    case ERROR_LINE_NOT_FOUND:
    case ERROR_SECTION_NOT_FOUND:
    case ERROR_WRONG_INF_STYLE:
    case ERROR_EXPECTED_SECTION_NAME: 
    case ERROR_BAD_SECTION_NAME_LINE:
    case ERROR_SECTION_NAME_TOO_LONG:
    case ERROR_GENERAL_SYNTAX:
        dw = LoadString( g_hinstance, IDS_INF_ERROR, szText, ARRAYSIZE(szText));
        Assert( dw );
        MessageBox( hParent, szText, pszTitle, MB_OK | MB_ICONERROR );
        break;
    default:
        dw = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                            NULL,
                            dwErr,
                            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                            (LPTSTR) &lpMsgBuf,
                            0,
                            NULL );
        if ( dw != 0 )
        {
            MessageBox( hParent, lpMsgBuf, pszTitle, MB_OK | MB_ICONERROR );
            LocalFree( lpMsgBuf );
        }
        else
        {
            dw = LoadString( g_hinstance, IDS_UNDEFINED_ERROR_STRING, szString, ARRAYSIZE(szString));
            Assert( dw );
            _snwprintf( szText, ARRAYSIZE(szText), szString, dwErr );
            TERMINATE_BUFFER(szText);
            MessageBox( hParent, szText, pszTitle, MB_OK | MB_ICONERROR );
        }
    }
}

VOID
SetDialogFont(
    IN HWND      hdlg,
    IN UINT      ControlId,
    IN MyDlgFont WhichFont
    )
{
    static HFONT BigBoldFont = NULL;
    static HFONT BoldFont    = NULL;
    static HFONT NormalFont  = NULL;
    HFONT Font;
    LOGFONT LogFont;
    WCHAR FontSizeString[24];
    int FontSize;
    HDC hdc;

    switch(WhichFont) {

    case DlgFontTitle:

        if(!BigBoldFont) {

            Font = (HFONT)SendDlgItemMessage(hdlg, ControlId, WM_GETFONT, 0, 0);
            if ( Font )
            {
                if ( GetObject( Font, sizeof(LOGFONT), &LogFont) )
                {
                    DWORD dw = LoadString( g_hinstance,
                                           IDS_LARGEFONTNAME,
                                           LogFont.lfFaceName,
                                           LF_FACESIZE);
                    Assert( dw );

                    dw =       LoadString( g_hinstance,
                                           IDS_LARGEFONTSIZE,
                                           FontSizeString,
                                           ARRAYSIZE(FontSizeString));
                    Assert( dw );

                    FontSize = wcstoul( FontSizeString, NULL, 10 );

                    // make sure we at least have some basic font
                    if (*LogFont.lfFaceName == 0 || FontSize == 0) {
                       lstrcpy(LogFont.lfFaceName,TEXT("MS Shell Dlg") );
                       FontSize = 18;
                    }
                    
                    LogFont.lfWeight   = FW_BOLD;
                    hdc = GetDC(hdlg);
                    if ( hdc )
                    {
                        LogFont.lfHeight =
                            0 - (GetDeviceCaps(hdc,LOGPIXELSY) * FontSize / 72);

                        BigBoldFont = CreateFontIndirect(&LogFont);

                        ReleaseDC(hdlg,hdc);
                    }
                }
            }
        }
        Font = BigBoldFont;
        break;

    case DlgFontBold:

        if ( !BoldFont )
        {
            Font =  (HFONT)SendDlgItemMessage( hdlg, ControlId, WM_GETFONT, 0, 0 );
            if ( Font ) {
                if ( GetObject( Font, sizeof(LOGFONT), &LogFont ) )
                {

                    LogFont.lfWeight = FW_BOLD;

                    hdc = GetDC( hdlg );
                    if ( hdc )
                    {
                        BoldFont = CreateFontIndirect( &LogFont );
                        ReleaseDC( hdlg, hdc );
                    }
                }
            }
        }
        Font = BoldFont;
        break;

    default:
        //
        // Nothing to do here.
        //
        Font = NULL;
        break;
    }

    if( Font )
    {
        SendDlgItemMessage( hdlg, ControlId, WM_SETFONT, (WPARAM) Font, 0 );
    }
}


//
// Adjusts and draws a bitmap transparently in the RECT prc.
//
void
DrawBitmap(
    HANDLE hBitmap,
    LPDRAWITEMSTRUCT lpdis,
    LPRECT prc )
{
    TraceFunc( "DrawBitmap( ... )\n" );

    BITMAP  bm;
    HDC     hDCBitmap;
    int     dy;

    GetObject( hBitmap, sizeof(bm), &bm );

    hDCBitmap = CreateCompatibleDC( NULL );

    if (hDCBitmap == NULL) {
        return;
    }

    SelectObject( hDCBitmap, hBitmap );

    // center the image
    dy = 2 + prc->bottom - bm.bmHeight;

    StretchBlt( lpdis->hDC, prc->left, prc->top + dy, prc->right, prc->bottom,
          hDCBitmap, 0, 0, bm.bmWidth, bm.bmHeight, SRCAND );

    DeleteDC( hDCBitmap );

    TraceFuncExit( );
}

//
// Verifies that the user wanted to cancel setup.
//
BOOL
VerifyCancel( HWND hParent )
{
    TraceFunc( "VerifyCancel( ... )\n" );

    INT iReturn;
    BOOL fAbort = FALSE;

    iReturn = MessageBoxFromStrings( hParent,
                                     IDS_CANCELCAPTION,
                                     IDS_CANCELTEXT,
                                     MB_YESNO | MB_ICONQUESTION );
    if ( iReturn == IDYES ) {
        fAbort = TRUE;
    }

    SetWindowLongPtr( hParent, DWLP_MSGRESULT, ( fAbort ? 0 : -1 ));

    g_Options.fAbort = fAbort;

    RETURN(!fAbort);
}

//
// RetrieveWorkstationLanguageFromHive
//
HRESULT
RetrieveWorkstationLanguageFromHive( 
    HWND hDlg )
{
    TraceFunc( "RetrieveWorkstationLanguageFromHive( )\n" );

    HRESULT hr = S_FALSE;
    HINF hinf;
    WCHAR szFilepath[ MAX_PATH ];
    INFCONTEXT context;
    WCHAR szCodePage[ 32 ];
    ULONG uResult;
    BOOL b;
    UINT uLineNum;
    LPWSTR psz;

    //
    // build the path to hivesys.inf
    //
    lstrcpyn( szFilepath, g_Options.szSourcePath, ARRAYSIZE(szFilepath) );
    ConcatenatePaths( szFilepath, g_Options.ProcessorArchitectureString, ARRAYSIZE(szFilepath));
    ConcatenatePaths( szFilepath, L"hivesys.inf", ARRAYSIZE(szFilepath) );

    
    //
    // open the file
    //
    hinf = SetupOpenInfFile( szFilepath, NULL, INF_STYLE_WIN4, &uLineNum);
    if ( hinf == INVALID_HANDLE_VALUE ) {
        DWORD dwErr = GetLastError( );
        switch ( dwErr )
        {
        case ERROR_FILE_NOT_FOUND:
            MessageBoxFromStrings( hDlg, IDS_FILE_NOT_FOUND_TITLE, IDS_FILE_NOT_FOUND_TEXT, MB_OK );
            break;

        default:
            ErrorBox( hDlg, szFilepath );
            break;
        }
        hr = HRESULT_FROM_WIN32( dwErr );
        goto Cleanup;
    }

    // Find the "AddReg" section
    b = SetupFindFirstLine( hinf, L"Strings", L"Install_Language", &context );
    if ( !b )
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, szFilepath );
        goto Cleanup;
    }

    b = SetupGetStringField( &context, 1, szCodePage, ARRAYSIZE(szCodePage), NULL );
    if ( !b )
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, szFilepath );
        goto Cleanup;
    }

    g_Options.dwWksCodePage = (WORD) wcstoul( szCodePage, &psz, 16 );
    DebugMsg( "Image CodePage = 0x%04x\n", g_Options.dwWksCodePage );

    uResult = GetLocaleInfo( PRIMARYLANGID(g_Options.dwWksCodePage), 
                             LOCALE_SENGLANGUAGE, 
                             g_Options.szLanguage, 
                             ARRAYSIZE(g_Options.szLanguage));
    if ( uResult == 0 ) {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, szFilepath );
        goto Cleanup;
    }
    DebugMsg( "Image Language: %s\n", g_Options.szLanguage );

    //
    // Fix up the locale string we got back to ensure it
    // contains no spaces and non non-ASCII characters.
    // The localization guys changed this API so that neither
    // of these properties are guarenteed any longer.
    //
    for( uLineNum = 0; uLineNum < wcslen(g_Options.szLanguage); uLineNum++ ) {
        if( (g_Options.szLanguage[uLineNum] <= TEXT(' ')) ||
            (g_Options.szLanguage[uLineNum] > TEXT('~')) ) {
            g_Options.szLanguage[uLineNum] = TEXT('\0');
            break;
        }
    }
    DebugMsg( "Fixed up Image Language: %s\n", g_Options.szLanguage );

    // Success!
    g_Options.fLanguageSet = TRUE;
    hr = S_OK;

Cleanup:
    if ( hinf != INVALID_HANDLE_VALUE ) {
        SetupCloseInfFile( hinf );
    }
    HRETURN(hr);
}


//
// CheckImageSource( )
//
HRESULT
CheckImageSource(
    HWND hDlg )
{
    TraceFunc( "CheckImageSource( ... )\n" );

    HRESULT hr = S_FALSE;
    WCHAR szFilepath[ MAX_PATH ];
    WCHAR szTemp[ 32 ];
    BYTE szPidExtraData[ 14 ];
    HINF hinf;
    UINT uLineNum;
    BOOL b;
    INFCONTEXT context;

    //
    // build the path to hivesys.inf
    //
    lstrcpyn( szFilepath, g_Options.szSourcePath, ARRAYSIZE(szFilepath) );
    ConcatenatePaths( szFilepath, g_Options.ProcessorArchitectureString, ARRAYSIZE(szFilepath));
    ConcatenatePaths( szFilepath, L"txtsetup.sif", ARRAYSIZE(szFilepath));
    
    //
    // open the file
    //
    hinf = SetupOpenInfFile( szFilepath, NULL, INF_STYLE_WIN4, &uLineNum);
    if ( hinf == INVALID_HANDLE_VALUE ) {
        DWORD dwErr = GetLastError( );
        switch ( dwErr )
        {
        case ERROR_FILE_NOT_FOUND:
            MessageBoxFromStrings( hDlg, IDS_FILE_NOT_FOUND_TITLE, IDS_FILE_NOT_FOUND_TEXT, MB_OK );
            break;

        default:
            ErrorBox( hDlg, szFilepath );
            break;
        }
        hr = HRESULT_FROM_WIN32( dwErr );
        goto Cleanup;
    }

#if 0
    //
    // Allow server installs - adamba 2/21/00
    //

    b = SetupFindFirstLine( hinf, L"SetupData", L"ProductType", &context );
    if ( !b )
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        if ( hr == ERROR_LINE_NOT_FOUND ) {
            MessageBoxFromStrings( hDlg, IDS_NOT_NT5_MEDIA_SOURCE_TITLE, IDS_NOT_NT5_MEDIA_SOURCE_TEXT, MB_OK );
        } else {
            ErrorBox( hDlg, szFilepath );
        }
        goto Cleanup;
    }

    b = SetupGetStringField( &context, 1, szTemp, ARRAYSIZE(szTemp), NULL );
    if ( !b )
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, szFilepath );
        goto Cleanup;
    }

    if ( StrCmp( szTemp, L"0" ) )
    {
        MessageBoxFromStrings( hDlg, IDS_NOT_WORKSTATION_TITLE, IDS_NOT_WORKSTATION_TEXT, MB_OK );
        hr = E_FAIL;
        goto Cleanup;
    }
#endif

    b = SetupFindFirstLine( hinf, L"SetupData", L"Architecture", &context );
    if ( !b )
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        if ( hr == HRESULT_FROM_WIN32(ERROR_LINE_NOT_FOUND) ) {
            MessageBoxFromStrings( hDlg, IDS_NOT_NT5_MEDIA_SOURCE_TITLE, IDS_NOT_NT5_MEDIA_SOURCE_TEXT, MB_OK );
        } else {
            ErrorBox( hDlg, szFilepath );
        }
        goto Cleanup;
    }

    b = SetupGetStringField( &context, 1, szTemp, ARRAYSIZE(szTemp), NULL );
    if ( !b )
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, szFilepath );
        goto Cleanup;
    }

    if ( (StrCmp(szTemp,L"i386")) && (StrCmp(szTemp,L"ia64")) )
    {
        MessageBoxFromStrings( hDlg, IDS_NOT_SUPPORTED_ARCHITECTURE_TITLE, IDS_NOT_SUPPORTED_ARCHITECTURE_TEXT, MB_OK );
        hr = E_FAIL;
        goto Cleanup;
    }

    if (StrCmp(g_Options.ProcessorArchitectureString,szTemp))
    {
        MessageBoxFromStrings( hDlg, IDS_NOT_SUPPORTED_ARCHITECTURE_TITLE, IDS_NOT_SUPPORTED_ARCHITECTURE_TEXT, MB_OK );
        hr = E_FAIL;
        goto Cleanup;
    }

    if (!g_Options.fLanguageOverRide) {
        hr = RetrieveWorkstationLanguageFromHive( hDlg );
        if ( FAILED( hr ) )
            goto Cleanup;
    }

    if (!GetBuildNumberFromImagePath(
                        &g_Options.dwBuildNumber,
                        g_Options.szSourcePath, 
                        g_Options.ProcessorArchitectureString)) {
#if 0
        MessageBoxFromStrings( hDlg, IDS_NOT_NT5_MEDIA_SOURCE_TITLE, IDS_NOT_NT5_MEDIA_SOURCE_TEXT, MB_OK );
        hr = E_FAIL;
        goto Cleanup;
#else           
#endif
    }
    

    // Get image Major version
    b = SetupFindFirstLine( hinf, L"SetupData", L"MajorVersion", &context );
    if ( !b )
    {
        DWORD dwErr = GetLastError( );
        switch ( dwErr )
        {
        case ERROR_LINE_NOT_FOUND:
            MessageBoxFromStrings( hDlg, IDS_LINE_MISSING_CAPTION, IDS_LINE_MISSING_TEXT, MB_OK );
            break;

        default:
            ErrorBox( hDlg, szFilepath );
            break;
        }
        hr = HRESULT_FROM_WIN32( dwErr );
        goto Cleanup;
    }
    b = SetupGetStringField( &context, 1, g_Options.szMajorVersion, ARRAYSIZE(g_Options.szMajorVersion), NULL );
    if ( !b )
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, szFilepath );
        goto Cleanup;
    }

    // Get image Minor version
    b = SetupFindFirstLine( hinf, L"SetupData", L"MinorVersion", &context );
    if ( !b )
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, szFilepath );
        goto Cleanup;
    }
    b = SetupGetStringField( &context, 1, g_Options.szMinorVersion, ARRAYSIZE(g_Options.szMinorVersion), NULL );
    if ( !b )
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, szFilepath );
        goto Cleanup;
    }

    // Get image description
    if ( !g_Options.fRetrievedWorkstationString  )
    {
        b = SetupFindFirstLine( hinf, L"SetupData", L"LoadIdentifier", &context );
        if ( !b )
        {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, szFilepath );
            goto Cleanup;
        }
        b = SetupGetStringField( 
                        &context, 
                        1, 
                        g_Options.szDescription, 
                        ARRAYSIZE(g_Options.szDescription), 
                        NULL );
        if ( !b )
        {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, szFilepath );
            goto Cleanup;
        }
        // if this hasn't been substituted from the strings section, then 
        // do the lookup manually.  to do this skip and remove the "%"s
        if (g_Options.szDescription[0] == L'%' && 
            g_Options.szDescription[wcslen(g_Options.szDescription)-1] == L'%') {
            
            g_Options.szDescription[wcslen(g_Options.szDescription)-1] = L'\0';
            
            lstrcpyn(szTemp,&g_Options.szDescription[1],ARRAYSIZE(szTemp));
                   
            b = SetupFindFirstLine( 
                            hinf, 
                            L"Strings", 
                            szTemp, 
                            &context );
            if ( !b ) {
                hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
                ErrorBox( hDlg, szFilepath );
                goto Cleanup;
            }
            b = SetupGetStringField( 
                            &context, 
                            1, 
                            g_Options.szDescription, 
                            ARRAYSIZE(g_Options.szDescription), 
                            NULL );
            if ( !b ) {
                hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
                ErrorBox( hDlg, szFilepath );
                goto Cleanup;
            }            
        }
        
        DebugMsg( "Image Description: %s\n", g_Options.szDescription );


        b = SetupFindFirstLine( hinf, L"SetupData", L"DefaultPath", &context );
        if ( b )
        {
            b = SetupGetStringField( 
                        &context, 
                        1, 
                        szTemp, 
                        ARRAYSIZE(szTemp), 
                        NULL );

            if (b) {
                PWSTR p;
                p = wcschr( szTemp, '\\');
                if (p) {
                    p += 1;
                } else {
                    p = szTemp;
                }
                lstrcpyn( g_Options.szInstallationName, p, ARRAYSIZE(g_Options.szInstallationName) );
                DebugMsg( "Image Path: %s\n", g_Options.szInstallationName );
            }
        }
    }

    SetupCloseInfFile( hinf );

    //
    // build the path to layout.inf
    //
    lstrcpyn( szFilepath, g_Options.szSourcePath, ARRAYSIZE(szFilepath));
    ConcatenatePaths( szFilepath, g_Options.ProcessorArchitectureString, ARRAYSIZE(szFilepath));
    ConcatenatePaths( szFilepath, L"layout.inf", ARRAYSIZE(szFilepath) );

    //
    // open the file
    //
    hinf = SetupOpenInfFile( szFilepath, NULL, INF_STYLE_WIN4, &uLineNum);
    if ( hinf == INVALID_HANDLE_VALUE ) {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, szFilepath );
        goto Cleanup;
    }

    if ( g_Options.ProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL ) {
        b = SetupFindFirstLine( hinf, L"SourceDisksNames.x86", L"1", &context );
        if ( !b )
        {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, szFilepath );
            goto Cleanup;
        }
    }

    if ( g_Options.ProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64 ) {
        b = SetupFindFirstLine( hinf, L"SourceDisksNames.ia64", L"1", &context );
        if ( !b )
        {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, szFilepath );
            goto Cleanup;
        }
    }

    if ( b ) {
        b = SetupGetStringField( &context, 1, g_Options.szWorkstationDiscName, ARRAYSIZE(g_Options.szWorkstationDiscName), NULL );
        if ( !b )
        {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, szFilepath );
            goto Cleanup;
        }
        DebugMsg( "Workstation Disc Name: %s\n", g_Options.szWorkstationDiscName );

        b = SetupGetStringField( &context, 2, g_Options.szWorkstationTagFile, ARRAYSIZE(g_Options.szWorkstationTagFile), NULL );
        if ( !b )
        {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, szFilepath );
            goto Cleanup;
        }
        DebugMsg( "Workstation Tag File: %s\n", g_Options.szWorkstationTagFile);

        b = SetupGetStringField( &context, 4, g_Options.szWorkstationSubDir, ARRAYSIZE(g_Options.szWorkstationSubDir), NULL );
        if ( !b )
        {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, szFilepath );
            goto Cleanup;
        }
        DebugMsg( "Workstation Sub Dir: %s\n", g_Options.szWorkstationSubDir );
    }

    SetupCloseInfFile( hinf );
    hinf = INVALID_HANDLE_VALUE;

    //
    // build the path to setupp.ini
    //
    lstrcpyn( szFilepath, g_Options.szSourcePath, ARRAYSIZE(szFilepath));
    ConcatenatePaths( szFilepath, g_Options.ProcessorArchitectureString, ARRAYSIZE(szFilepath));
    ConcatenatePaths( szFilepath, L"setupp.ini", ARRAYSIZE(szFilepath));    

    b = GetPrivateProfileStruct(L"Pid",
                                L"ExtraData",
                                szPidExtraData,
                                sizeof(szPidExtraData),
                                szFilepath);
    if ( !b )
    {
        MessageBoxFromStrings( hDlg, IDS_NOT_NT5_MEDIA_SOURCE_TITLE, IDS_SETUP_INI_MISSING_OR_INVALID, MB_OK );
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // For a valid full (non-upgrade) PID, the fourth and sixth bytes
    // are odd.
    //
    if (((szPidExtraData[3] % 2) == 0) || ((szPidExtraData[5] % 2) == 0))
    {
        MessageBoxFromStrings( hDlg, IDS_NOT_NT5_MEDIA_SOURCE_TITLE, IDS_UPGRADE_VERSION_NOT_SUPPORTED, MB_OK );
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:
    if ( hinf != INVALID_HANDLE_VALUE ) {
        SetupCloseInfFile( hinf );
    }
    HRETURN(hr);
}

HRESULT
GetHelpAndDescriptionTextFromSif(
    OUT PWSTR HelpText,
    IN  DWORD HelpTextSizeInChars,
    OUT PWSTR DescriptionText,
    IN  DWORD DescriptionTextInChars
    )
{
    WCHAR szSourcePath[MAX_PATH*2];
    WCHAR TempPath[MAX_PATH];
    WCHAR TempFile[MAX_PATH];
    HINF hInf;
    UINT uLineNum;
    HRESULT hr;
    INFCONTEXT context;

    PCWSTR szFileName = L"ristndrd.sif" ;

    //
    // Create the path to the default SIF file
    //
    _snwprintf( szSourcePath,
                ARRAYSIZE(szSourcePath),
              L"%s\\%s",
              g_Options.szSourcePath,
              szFileName );
    TERMINATE_BUFFER(szSourcePath);

    if (GetTempPath(ARRAYSIZE(TempPath), TempPath) &&
        GetTempFileName(TempPath, L"RIS", 0, TempFile ) &&
        SetupDecompressOrCopyFile( szSourcePath, TempFile, NULL ) == ERROR_SUCCESS) {
    
        //
        // first try INF_STYLE_WIN4, and if that fails, then try 
        // INF_STYLE_OLDNT (in case the inf doesn't have a [version] section.
        //
        hInf = SetupOpenInfFile( TempFile, NULL, INF_STYLE_WIN4, &uLineNum);
        if (hInf == INVALID_HANDLE_VALUE) {
            hInf = SetupOpenInfFile( TempFile, NULL, INF_STYLE_OLDNT, &uLineNum);
            if (hInf == INVALID_HANDLE_VALUE) {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto e1;        
            }
        }
    
        if (!SetupFindFirstLine( hInf, L"OSChooser", L"Help", &context )) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto e2;
        }
    
        if (!SetupGetStringField(
                    &context, 
                    1,
                    HelpText, 
                    HelpTextSizeInChars, 
                    NULL )) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto e2;
        }
    
        if (!SetupFindFirstLine( hInf, L"OSChooser", L"Description", &context )) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto e2;
        }
    
        if (!SetupGetStringField(
                    &context, 
                    1,
                    DescriptionText, 
                    DescriptionTextInChars, 
                    NULL )) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto e2;
        }

    } else {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto e0;
    }

    hr = S_OK;
    
e2:
    SetupCloseInfFile( hInf );
e1:
    DeleteFile( TempFile );
e0:
    return(hr);
}


//
// CheckIntelliMirrorDrive( )
//
HRESULT
CheckIntelliMirrorDrive(
    HWND hDlg )
{
    TraceFunc( "CheckIntelliMirrorDrive( )\n" );

    HRESULT hr = S_OK;
    BOOL  b;
    DWORD dw;
    WCHAR sz[ MAX_PATH ];
    WCHAR szExpanded[ MAX_PATH ];
    WCHAR szVolumePath[ MAX_PATH ];
    WCHAR szVolumeName[ MAX_PATH ];
    WCHAR szVolumePath2[ MAX_PATH ];
    WCHAR szVolumeName2[ MAX_PATH ];
    WCHAR szFileSystemType[ MAX_PATH ];
    UINT uDriveType = DRIVE_UNKNOWN;
#ifdef _X86_
    WCHAR szBootDir[3];
#endif

    //
    // Get the real volume name for the target directory.
    //
    b = GetVolumePathName( g_Options.szIntelliMirrorPath, szVolumePath, ARRAYSIZE( szVolumePath ));
    if (b) {
        b = GetVolumeNameForVolumeMountPoint( szVolumePath, szVolumeName, ARRAYSIZE( szVolumeName ));
    }

    //
    // Make sure the device is not a removable media, CDROM, RamDisk, etc...
    // Only allow fixed disks.
    //
    if (b) {
        uDriveType = GetDriveType( szVolumeName );
    }
    if ( !b || (uDriveType != DRIVE_FIXED) ) 
    {
        MessageBoxFromStrings( hDlg,
                               IDS_FIXEDDISK_CAPTION,
                               IDS_FIXEDDISK_TEXT,
                               MB_OK | MB_ICONSTOP );
        goto Error;
    }

    //
    // Get the real volume name for the system volume (%windir%).
    //
    // Get the default path which happens to be the
    // SystemDrive:\IntelliMirror
    //
    dw = LoadString( g_hinstance, IDS_DEFAULTPATH, sz, ARRAYSIZE( sz ));
    Assert( dw );
    dw = ExpandEnvironmentStrings( sz, szExpanded, ARRAYSIZE( szExpanded ));
    Assert( dw );

    b = GetVolumePathName( szExpanded, szVolumePath2, ARRAYSIZE( szVolumePath2 ));
    Assert( b );
    b = GetVolumeNameForVolumeMountPoint( szVolumePath2, szVolumeName2, ARRAYSIZE( szVolumeName2 ));
    Assert( b );

    //
    // Don't let the target directory volume be the same as the system volume.
    //
    if ( StrCmpI( szVolumeName, szVolumeName2 ) == 0 )
    {
        MessageBoxFromStrings( hDlg,
                               IDS_SAME_DRIVE_AS_SYSTEM_TITLE,
                               IDS_SAME_DRIVE_AS_SYSTEM_MESSAGE,
                               MB_OK | MB_ICONSTOP );
        goto Error;
    }

#ifdef _X86_
    //
    // See if the system partition (the one with boot.ini on it)
    // is the drive the user has selected. We can't allow this
    // either since SIS might hide boot.ini.
    //

    b = x86DetermineSystemPartition( NULL, &szBootDir[0] );
    if ( !b )
    {
        szBootDir[0] = L'C';
    }
    szBootDir[1] = L':';
    szBootDir[2] = L'\\';

    b = GetVolumePathName( szBootDir, szVolumePath2, ARRAYSIZE( szVolumePath2 ));
    Assert( b );
    b = GetVolumeNameForVolumeMountPoint( szVolumePath2, szVolumeName2, ARRAYSIZE( szVolumeName2 ));
    Assert( b );

    //
    // Don't let the target directory volume be the same as the boot volume.
    //
    if ( StrCmpI( szVolumeName, szVolumeName2 ) == 0 )
    {
        MessageBoxFromStrings( hDlg,
                               IDS_SAME_DRIVE_AS_BOOT_PARTITION_TITLE,
                               IDS_SAME_DRIVE_AS_BOOT_PARTITION,
                               MB_OK | MB_ICONSTOP );
        goto Error;
    }
#endif

    //
    // Check to see if the IMirror directory will live on an NTFS
    // file system.
    //
    b = GetVolumeInformation( szVolumeName,
                              NULL,
                              0,
                              NULL,
                              NULL,
                              NULL,
                              szFileSystemType,
                              ARRAYSIZE( szFileSystemType ));
    if ( !b || StrCmpNI( szFileSystemType, L"NTFS", 4 ) != 0 ) {
        MessageBoxFromStrings( hDlg,
                               IDS_SHOULD_BE_NTFS_TITLE,
                               IDS_SHOULD_BE_NTFS_MESSAGE,
                               MB_OK | MB_ICONSTOP );
        goto Error;
    }

    if ( 0xFFFFffff != GetFileAttributes( g_Options.szIntelliMirrorPath ) )
    {
        INT iResult = MessageBoxFromStrings( hDlg,
                                             IDS_DIRECTORYEXISTS_CAPTION,
                                             IDS_DIRECTORYEXISTS_TEXT,
                                             MB_YESNO | MB_ICONQUESTION );
        if ( iResult == IDNO )
            goto Error;
    }

Cleanup:
    HRETURN(hr);

Error:
    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );
    hr = E_FAIL;
    goto Cleanup;
}

VOID
ConcatenatePaths(
    IN OUT LPWSTR  Path1,
    IN     LPCWSTR Path2,
    IN     ULONG   Path1Length
    )
/*++

Routine Description:

    Concatenate two path strings together, supplying a path separator
    character (\) if necessary between the 2 parts.

Arguments:

    Path1 - supplies prefix part of path. Path2 is concatenated to Path1.

    Path2 - supplies the suffix part of path. If Path1 does not end with a
            path separator and Path2 does not start with one, then a path sep
            is appended to Path1 before appending Path2.

    Path1Length - supplies the size in WCHARs of the buffer pointed to by 
                  Path1. The string will be truncated as necessary to not 
                  overflow that size.

Return Value:

    None.

--*/
{

    BOOL NeedBackslash = TRUE;
    DWORD l = (DWORD)wcslen( Path1 );

    //
    // Determine whether we need to stick a backslash between the components.
    //

    if ( (l != 0) && (Path1[l-1] == L'\\') ) {
        NeedBackslash = FALSE;
    }

    if ( *Path2 == L'\\' ) {

        if ( NeedBackslash ) {

            NeedBackslash = FALSE;

        } else {

            //
            // Not only do we not need a backslash, but we need to eliminate
            // one before concatenating.
            //

            Path2++;
        }
    }

    if ( NeedBackslash ) {
        wcsncat( Path1, L"\\", Path1Length - lstrlen(Path1) - 1 );
        Path1[Path1Length-1] = 0;
    }
    wcsncat( Path1, Path2, Path1Length - lstrlen(Path1) - 1);
    Path1[Path1Length-1] = 0;

    return;
}

//
// FindImageSource( )
//
HRESULT
FindImageSource(
    HWND hDlg )
{
    TraceFunc( "FindImageSource( )\n" );

    HANDLE  hFile;
    WCHAR   szFilePath[ MAX_PATH ];

    UNREFERENCED_PARAMETER(hDlg);

    //
    // Look for txtsetup.sif where we think the files are located.
    // txtsetup.sif is in an architecture-specific subdirectory.
    //
    lstrcpyn( szFilePath, g_Options.szSourcePath, ARRAYSIZE(szFilePath) );
    ConcatenatePaths( szFilePath, g_Options.ProcessorArchitectureString, ARRAYSIZE(szFilePath));
    ConcatenatePaths( szFilePath, L"\\txtsetup.sif", ARRAYSIZE(szFilePath));
    hFile = CreateFile( szFilePath, 0, 0, NULL, OPEN_EXISTING, 0, NULL );
    if ( hFile != INVALID_HANDLE_VALUE ) 
    {
         CloseHandle( hFile );

         HRETURN(S_OK);
    }    

    HRETURN( HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) );
}



HRESULT
GetSetRanFlag(
    BOOL bQuery,
    BOOL bClear
    )
/*++

Routine Description:

    Set's or Get's the state of a registry flag that indicates setup has been
    run before.

Arguments:

    bQuery - if TRUE, indicates that the registry flag should be queried
    bClear - only valid if bQuery is FALSE.  If this parameter is TRUE, 
             it indicates that the flag should be set to the cleared state.
             FALSE indicates that the flag should be set.

Return Value:

    HRESULT indicating outcome.

--*/
{
    LONG lResult;
    HKEY hkeySetup;
    HRESULT Result = E_FAIL;
    
    lResult = RegOpenKeyEx( 
                    HKEY_LOCAL_MACHINE, 
                    L"Software\\Microsoft\\Windows\\CurrentVersion\\Setup", 
                    0, 
                    bQuery 
                     ? KEY_QUERY_VALUE 
                     : KEY_SET_VALUE, 
                    &hkeySetup);
        
    
    if ( lResult == ERROR_SUCCESS ) {
        DWORD dwValue = (bClear == FALSE) ? 1 : 0;
        DWORD cbValue = sizeof(dwValue);
        DWORD type;

        if (bQuery) {
            lResult = RegQueryValueEx( hkeySetup, L"RemInst", NULL, &type, (LPBYTE)&dwValue, &cbValue );            
            if (lResult == ERROR_SUCCESS) {
                Result = (dwValue == 1) 
                           ? S_OK 
                           : E_FAIL;
            } else {
                Result = HRESULT_FROM_WIN32(lResult);
            }
        } else {
            lResult = RegSetValueEx( hkeySetup, L"RemInst", NULL, REG_DWORD, (LPBYTE)&dwValue, cbValue );
            Result = HRESULT_FROM_WIN32(lResult);
        }
        

        RegCloseKey( hkeySetup );
        
    } else {
        Result = HRESULT_FROM_WIN32(lResult);
    }

    return(Result);
}

//
// GetNtVersionInfo( )
//
// Retrieves the build version from the kernel
//
DWORD
MyGetFileVersionInfo(
    PCWSTR  FilePath
    )
/*++

Routine Description:

    Retrieve the version information from the specified file.

Arguments:

    FilePath    - Fully qualified path to the file we will be
                  examining.

Return Value:

    DWORD   - zero on failure.

--*/
{
    DWORD FileVersionInfoSize;
    DWORD VersionHandle;
    PVOID VersionInfo;
    VS_FIXEDFILEINFO * FixedFileInfo;
    UINT FixedFileInfoLength;
    DWORD   Version = 0;


    FileVersionInfoSize = GetFileVersionInfoSize(FilePath, &VersionHandle);
    if (FileVersionInfoSize == 0) {
        goto e0;
    }


    VersionInfo = LocalAlloc( LPTR, FileVersionInfoSize );
    if (VersionInfo == NULL) {
        goto e0;
    }

    if (!GetFileVersionInfo(
             FilePath,
             VersionHandle,
             FileVersionInfoSize,
             VersionInfo)) {
        goto e1;
    }

    if (!VerQueryValue(
             VersionInfo,
             L"\\",
             (LPVOID*)&FixedFileInfo,
             &FixedFileInfoLength)) {
        goto e1;
    }

    Version = HIWORD(FixedFileInfo->dwFileVersionLS);

e1:
    LocalFree( VersionInfo );
e0:
    RETURN( Version );
}

BOOLEAN
GetBuildNumberFromImagePath(
    PDWORD pdwVersion,
    PCWSTR SearchDir,
    PCWSTR SubDir OPTIONAL
    )
{
    WCHAR Path[MAX_PATH];
    BOOLEAN fResult = FALSE;

    TraceFunc("GetNtVersionInfo( )\n");

    *pdwVersion = 0;

    //
    // build a path to the kernel
    //
    // Resulting string should be something like:
    //      "\\server\reminst\Setup\English\Images\nt50.wks\i386\ntoskrnl.exe"
    //
    if (!SearchDir) {
        RETURN( fResult );
    }
    lstrcpyn(Path, SearchDir, ARRAYSIZE(Path));
    if (SubDir) {
        ConcatenatePaths( Path, SubDir, ARRAYSIZE(Path));
    }
    ConcatenatePaths( Path, L"ntkrnlmp.exe", ARRAYSIZE(Path));

    //
    // Go get his version info.  We'll get zero back on failure.
    //
    *pdwVersion = MyGetFileVersionInfo( Path );
    fResult = (*pdwVersion != 0);

    RETURN( fResult );
}


VOID
GetProcessorType(
    )
/*++

Routine Description:

    This function will pre-populate the g_Options.ProcessorArchitectureString variable
    with a default value.  This value is based on the processor
    architecture we're currently running on.

    We'll use this value to determine which backing file should
    be used to generate the remote install flat image on the
    server.

Arguments:

    None.

Return Value:

    None.

--*/
{
SYSTEM_INFO si;

    if( g_Options.ProcessorArchitectureString[0] == TEXT('\0') ) {

        //
        // We haven't been initialized yet.
        //

        GetSystemInfo( &si );
        switch (si.wProcessorArchitecture) {

            case PROCESSOR_ARCHITECTURE_IA64:
                g_Options.ProcessorArchitecture = PROCESSOR_ARCHITECTURE_IA64;
                lstrcpyn( g_Options.ProcessorArchitectureString, L"ia64", ARRAYSIZE(g_Options.ProcessorArchitectureString));
                break;

            //
            // if we get here, assume it's x86
            //
            default:
                g_Options.ProcessorArchitecture = PROCESSOR_ARCHITECTURE_INTEL;
                lstrcpyn( g_Options.ProcessorArchitectureString, L"i386", ARRAYSIZE(g_Options.ProcessorArchitectureString));
                break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rbsetup\server\setup.cpp ===
/************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved

 ***************************************************************************/

#include "pch.h"

#include <aclapip.h>
#include <winldap.h>
#include "check.h"
#include "dialogs.h"
#include "setup.h"
#include "check.h"
#include <sddl.h>

DEFINE_MODULE( "Setup" );

#ifdef SMALL_BUFFER_SIZE
#undef SMALL_BUFFER_SIZE
#endif

#define SMALL_BUFFER_SIZE   512
#define MAX_FILES_SIZE      1920000
#define BIG_BUFFER          4096
#define MACHINENAME_SIZE    32

static const WCHAR chSlash = TEXT('\\');
static const WCHAR SISCommonStoreDir[] = L"SIS Common Store";

typedef LONGLONG INDEX;

SCPDATA scpdata[] = {
    { L"netbootAllowNewClients",           L"TRUE" },
    { L"netbootLimitClients",              L"FALSE" },
    { L"netbootCurrentClientCount",        L"0" },
    { L"netbootMaxClients",                L"100" },
    { L"netbootAnswerRequests",            L"TRUE" },
    { L"netbootAnswerOnlyValidClients",    L"FALSE" },
    { L"netbootNewMachineNamingPolicy",    L"%61Username%#" },
    { L"netbootNewMachineOU",              NULL },
    { L"netbootServer",                    NULL }

};



//
// Use this structure to drive changes (lines) that
// need to be added/removed from login.osc when we run
// risetup.  We'll use this mechanism to patch legacy
// instances of login.osc that may be hanging around
// on the machine.
//
// Note: Don't re-order these entries unless you fix up the index
// entries.  For example, you'll see that entry 3 has a dependency
// on entry 2 (but the reverse is not true).  That means that when
// we're about to look at processing entry 3, we'll go check entry
// 2's OperationCompletedSuccessfully value to see if we should indeed
// process entry 3.
//
LOGIN_PATCHES   LoginOSCPatches[] = {
   // Add (TRUE) or remove (FALSE) the specified string from the file.
   // |      Did the operation complete successfully?
   // |      |      Index to any entries we're dependent on.
   // |      |      |     Tag which specifies the start of the section where our string will be found.
   // |      |      |     |        Tag which specifies the end of the section where our string will be found.
   // |      |      |     |        |          String to be added or removed from the specified section.
   // |      |      |     |        |          |
    { TRUE,  FALSE, (-1), "<FORM", "</FORM>", "<INPUT NAME=\"NTLMV2Enabled\" VALUE=%NTLMV2Enabled% MAXLENGTH=255 type=VARIABLE>" },
    { TRUE,  FALSE, (-1), "<FORM", "</FORM>", "<INPUT NAME=\"ServerUTCFileTime\" VALUE=%ServerUTCFileTime% MAXLENGTH=255 type=VARIABLE>" },
    { FALSE, FALSE, (-1), "<FORM", "</FORM>", "Domain Name: <INPUT NAME=\"USERDOMAIN\" MAXLENGTH=255>" },
    { TRUE,  FALSE,    2, "<FORM", "</FORM>", "Domain Name: <INPUT NAME=\"USERDOMAIN\" VALUE=%SERVERDOMAIN% MAXLENGTH=255>" }
};


//
// This set of strings defines the ACLs we'll place on the d:\reminst
// directory.
//
WCHAR  *REMINSTszSecurityDescriptor = L"D:"                   // DACL
                                      L"(A;OICI;GA;;;SY)"     // Allow SYSTEM Generic All (full control)
                                      L"(A;OICI;GA;;;BA)"     // Allow Builtin Administrators Generic All (full control)
                                      L"(A;OICI;GRGX;;;AU)";  // Allow Authenticated generic read/execute

#define MACHINEOU_INDEX       7
#define NETBOOTSERVER_INDEX   8


#define BINL_PARAMETERS_KEY       L"System\\CurrentControlSet\\Services\\Binlsvc\\Parameters"

PCWSTR
SetupExtensionFromProcessorTag(
    PCWSTR ProcessorTag
    )
{
    if (wcscmp(ProcessorTag,L"i386")==0) {
        return(L"x86");
    } else {
        return(ProcessorTag);
    }
}



//
// KeepUIAlive( )
//
BOOL
KeepUIAlive(
    HWND hDlg )
{
    MSG Msg;
    //
    // process messages to keep UI alive
    //
    while ( PeekMessage( &Msg, NULL, 0, 0, PM_REMOVE ) )
    {
        TranslateMessage( &Msg );
        DispatchMessage( &Msg );
        if ( hDlg != NULL && Msg.message == WM_KEYUP && Msg.wParam == VK_ESCAPE ) {
            VerifyCancel( hDlg );
        }
    }

    return( g_Options.fError || g_Options.fAbort );
}

//
// CreateSCP( )
//
HRESULT
CreateSCP( 
    HWND hDlg
    )
/*++

Routine Description:

    Creates SCP information so that BINL can create the SCP when it starts up.

Arguments:

    hDlg - dialog window handle for putting up error messages.

Return Value:

    HRESULT indicating outcome.
    
--*/
{
    TraceFunc( "CreateSCP( )\n" );

    HRESULT hr;
    ULONG  ulSize;
    LPWSTR pszMachinePath = NULL;
   
    DWORD i,Err;
    HKEY hKey = 0;
    DWORD DontCare;

    Err = RegCreateKeyEx(
                    HKEY_LOCAL_MACHINE,
                    BINL_PARAMETERS_KEY,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_SET_VALUE,
                    NULL,
                    &hKey,
                    &DontCare);

    if (Err != ERROR_SUCCESS) {
        hr = HRESULT_FROM_WIN32( Err );
        goto e0;
    }
    
    
    if ( !GetComputerObjectName( NameFullyQualifiedDN, NULL, &ulSize )) {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto e1;
    }

    pszMachinePath = (LPWSTR) TraceAlloc( LPTR, ulSize * sizeof(WCHAR) );
    if ( !pszMachinePath ) {
        hr = THR( E_OUTOFMEMORY );
        goto e1;
    }

    if ( !GetComputerObjectName( NameFullyQualifiedDN, pszMachinePath, &ulSize )) {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto e2;
    }
        
    
    scpdata[MACHINEOU_INDEX].pszValue = pszMachinePath;
    scpdata[NETBOOTSERVER_INDEX].pszValue = pszMachinePath;

    //
    // Add default attribute values
    //
    for( i = 0; i < ARRAYSIZE(scpdata); i++ )
    {
        Err = RegSetValueEx( 
                    hKey, 
                    scpdata[i].pszAttribute, 
                    NULL, 
                    REG_SZ, 
                    (LPBYTE)scpdata[i].pszValue, 
                    ((DWORD)wcslen(scpdata[i].pszValue)+1)*sizeof(WCHAR) );

        if (Err != ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32( Err );
            goto e3;
        }
    }


    hr = S_OK;

    Err = 0;

    RegSetValueEx( 
                hKey, 
                L"ScpCreated", 
                NULL, 
                REG_DWORD, 
                (LPBYTE)&Err, 
                sizeof(DWORD) );

e3:

    if (FAILED(hr)) {
        for( i = 0; i < ARRAYSIZE(scpdata); i++ ) {
            RegDeleteValue( 
                        hKey, 
                        scpdata[i].pszAttribute );
        }        
    } 

e2:
    TraceFree( pszMachinePath );    
e1:
    RegCloseKey(hKey);
e0:

    if ( FAILED(hr)) {
        MessageBoxFromStrings( hDlg, IDS_SCPCREATIONFAIL_CAPTION, IDS_SCPCREATIONFAIL_TEXT, MB_OK );
        ErrorMsg( "Error 0x%08x occurred.\n", hr );
    }    
    
    HRETURN(hr);
}

PWSTR
GenerateCompressedName(
    IN PCWSTR Filename
    )

/*++

Routine Description:

    Given a filename, generate the compressed form of the name.
    The compressed form is generated as follows:

    Look backwards for a dot.  If there is no dot, append "._" to the name.
    If there is a dot followed by 0, 1, or 2 charcaters, append "_".
    Otherwise there is a 3-character or greater extension and we replace
    the last character with "_".

Arguments:

    Filename - supplies filename whose compressed form is desired.

Return Value:

    Pointer to buffer containing nul-terminated compressed-form filename.
    The caller must free this buffer via TraceFree().

--*/

{
    PWSTR CompressedName,p,q;
    UINT u;

    //
    // The maximum length of the compressed filename is the length of the
    // original name plus 2 (for ._).
    //
    CompressedName = (PWSTR)TraceAlloc(LPTR, ((DWORD)wcslen(Filename)+3)*sizeof(WCHAR));
    if(CompressedName) {

        wcscpy(CompressedName,Filename);

        p = wcsrchr(CompressedName,L'.');
        q = wcsrchr(CompressedName,L'\\');
        if(q < p) {
            //
            // If there are 0, 1, or 2 characters after the dot, just append
            // the underscore.  p points to the dot so include that in the length.
            //
            u = (DWORD)wcslen(p);
            if(u < 4) {
                wcscat(CompressedName,L"_");
            } else {
                //
                // There are at least 3 characters in the extension.
                // Replace the final one with an underscore.
                //
                p[u-1] = L'_';
            }
        } else {
            //
            // No dot, just add ._.
            //
            wcscat(CompressedName,L"._");
        }
    }

    return(CompressedName);
}


BOOL
IsFileOrCompressedVersionPresent(
    LPCWSTR FilePath,
    PWSTR *pCompressedName OPTIONAL
    ) 
/*++

Routine Description:

    Check if a file or a compressed version of it is present at the
    specified location.
        

Arguments:

    FilePath       - fully qualified path to the file to check for.
    pCompressedName - if the file is compressed, this can receive the compressed
                     name

Return Value:

    TRUE indicats the file or a compressed copy of it is present.
    
--*/
{
    BOOL FileIsPresent = FALSE, IsCompressed = FALSE;
    WCHAR ActualName[MAX_PATH];
    PWSTR p;


    lstrcpyn( ActualName, FilePath, ARRAYSIZE(ActualName)) ;

    if (0xFFFFFFFF != GetFileAttributes( ActualName )) {
        FileIsPresent = TRUE;
    } else {
        //
        // the file isn't present, so try generating the compressed name
        //
        p = GenerateCompressedName( ActualName );
        if (p) {
            lstrcpyn( ActualName, p, ARRAYSIZE(ActualName) );
            TraceFree( p );
            p = NULL;
                
            if (0xFFFFFFFF != GetFileAttributes( ActualName )) {
                IsCompressed = TRUE;
                FileIsPresent = TRUE;
            }
        }
        
    }

    if (FileIsPresent && IsCompressed && pCompressedName) {
        *pCompressedName = (PWSTR)TraceAlloc( LPTR, ((DWORD)wcslen(ActualName)+1) * sizeof(WCHAR));
        if (*pCompressedName) {
            wcscpy( *pCompressedName, ActualName) ;
        }
    }

    return( FileIsPresent == TRUE);

} 


//
// Builds the pathes used for installation
//
HRESULT
BuildDirectories( void )
{
    TraceFunc( "BuildDirectories( void )\n" );


    //
    // Create
    // "D:\IntelliMirror\Setup\English\Images\nt50.wks"
    //
    lstrcpyn( g_Options.szInstallationPath, g_Options.szIntelliMirrorPath, ARRAYSIZE(g_Options.szInstallationPath));
    ConcatenatePaths( g_Options.szInstallationPath, L"\\Setup", ARRAYSIZE(g_Options.szInstallationPath));
    ConcatenatePaths( g_Options.szInstallationPath, g_Options.szLanguage, ARRAYSIZE(g_Options.szInstallationPath));
    ConcatenatePaths( g_Options.szInstallationPath, REMOTE_INSTALL_IMAGE_DIR_W, ARRAYSIZE(g_Options.szInstallationPath));
    ConcatenatePaths( g_Options.szInstallationPath, g_Options.szInstallationName, ARRAYSIZE(g_Options.szInstallationPath));
    //ConcatenatePaths( g_Options.szInstallationPath, g_Options.ProcessorArchitectureString, ARRAYSIZE(g_Options.szInstallationPath));

    Assert( wcslen(g_Options.szInstallationPath) < ARRAYSIZE(g_Options.szInstallationPath) );

    HRETURN(S_OK);
}

//
// Creates the IntelliMirror directory tree.
//
HRESULT
CreateDirectoryPath(
    HWND hDlg,
    LPWSTR DirectoryPath,
    PSECURITY_ATTRIBUTES SecurityAttributes,
    BOOL fAllowExisting
    )
{
    PWCHAR p, pBackslash;
    BOOL f;
    DWORD attributes;

    //
    // Find the \ that indicates the root directory. There should be at least
    // one \, but if there isn't, we just fall through.
    //

    p = wcschr( DirectoryPath, L'\\' );
    if ( p != NULL ) {

        //
        // Find the \ that indicates the end of the first level directory. It's
        // probable that there won't be another \, in which case we just fall
        // through to creating the entire path.
        //

        p = wcschr( p + 1, L'\\' );
        while ( p != NULL ) {

            //
            // Skip multiple \ that appear together.
            //
            pBackslash = p;
            ++p;
            while (*p == L'\\') {
                ++p;
            }
            if (*p == 0) {

                //
                // These \ are all at the end of the string, so we can
                // proceed to the creation of the leaf directory.
                //

                break;
            }

            //
            // Terminate the directory path at the current level.
            //

            *pBackslash = 0;

            //
            // Create a directory at the current level.
            //

            attributes = GetFileAttributes( DirectoryPath );
            if ( 0xFFFFffff == attributes ) {
                f = CreateDirectory( DirectoryPath, NULL );
                if ( !f ) {
                    if ( GetLastError() != ERROR_ALREADY_EXISTS ) {
                        ErrorBox( hDlg, DirectoryPath );
                        HRETURN(E_FAIL);
                    }
                }
            } else if ( (attributes & FILE_ATTRIBUTE_DIRECTORY) == 0 ) {
                MessageBoxFromError( hDlg, DirectoryPath, ERROR_DIRECTORY );
                HRETURN(E_FAIL);
            }

            //
            // Restore the \ and find the next one.
            //

            *pBackslash = L'\\';
            p = wcschr( p, L'\\' );
        }
    }

    //
    // Create the target directory.
    //

    f = CreateDirectory( DirectoryPath, SecurityAttributes );
    if ( !f && (!fAllowExisting || (GetLastError() != ERROR_ALREADY_EXISTS)) ) {
        ErrorBox( hDlg, DirectoryPath );
        HRETURN(E_FAIL);
    }

    HRETURN(NO_ERROR);
}

DWORD
ApplyDaclToFileDirectory(
    PWSTR                           FileDirectoryName,
    SECURITY_DESCRIPTOR_RELATIVE    *IncomingSecDescriptorRelative
    )
/*++

Routine Description:

    This function will apply the specified security descriptor
    to the given file or directory name.

Arguments:

    FileDirectoryName - Full path specifying location of file
                        or directory we're operating on.

    IncomingSecDescriptorRelative - Security descriptor we'll attempt
                                    to apply to the file/directory.

Return Value:

    win32 status code indicating whether we succeeded or failed (and why).
    
--*/
{
    SECURITY_DESCRIPTOR_RELATIVE *pRel = (SECURITY_DESCRIPTOR_RELATIVE *)(IncomingSecDescriptorRelative);
    DWORD   dw         = ERROR_SUCCESS;
    DWORD   dwLen      = 0;
    DWORD   dwLenDACL  = 0;
    DWORD   dwLenSACL  = 0;
    DWORD   dwLenOWNER = 0;
    DWORD   dwLenGRP   = 0;
    PACL    pDacl      = NULL;
    SECURITY_INFORMATION SecurityInfo = DACL_SECURITY_INFORMATION |
                                        PROTECTED_DACL_SECURITY_INFORMATION;

    //
    // We were given a relative security descriptor.  Convert it to an
    // absolute descriptor.
    //
    MakeAbsoluteSD( IncomingSecDescriptorRelative,
                    NULL,&dwLen,
                    NULL,&dwLenDACL,
                    NULL,&dwLenSACL,
                    NULL,&dwLenOWNER,
                    NULL,&dwLenGRP );
    pDacl = (PACL)LocalAlloc( 0, dwLenDACL );
    if( pDacl == NULL ) {
        dw = GetLastError();
        return dw;
    }

    memcpy( pDacl, (BYTE *)pRel +  pRel->Dacl, dwLenDACL );

    //
    // Try to set the security descriptor on the file/directory.
    //
    dw = SetNamedSecurityInfo( FileDirectoryName,   // Name of object
                               SE_FILE_OBJECT,      // It's a file/directory
                               SecurityInfo,        // bit vector flags.
                               NULL,                // *SidOwner
                               NULL,                // *SidGroup
                               pDacl,               // Our new DACL
                               NULL );              // Our new SACL

    //
    // Clean up and exit.
    //
    LocalFree( pDacl );

    return( dw );
}

//
// Creates the IntelliMirror directory tree.
//
HRESULT
CreateDirectories( HWND hDlg )
{
    HRESULT hr = S_OK;
    WCHAR szPath[ MAX_PATH ];
    WCHAR szCreating[ SMALL_BUFFER_SIZE ];
    HWND  hProg = GetDlgItem( hDlg, IDC_P_METER );
    DWORD dwLen;
    DWORD dw;
    BOOL  f;
    LPARAM lRange;
    DWORD attributes;
    SECURITY_ATTRIBUTES sa;
    

    TraceFunc( "CreateDirectories( hDlg )\n" );

    lRange = MAKELPARAM( 0 , 0
        + ( g_Options.fIMirrorShareFound    ? 0 : 1 )
        + ( g_Options.fDirectoryTreeExists  ? 0 : 7 )
        + ( g_Options.fOSChooserInstalled   ? 0 : 1 )
        + ( g_Options.fNewOSDirectoryExists ? 0 : 1 )
        + ( g_Options.fOSChooserScreensDirectory ? 0 : (g_Options.fLanguageSet ? 1 : 0 ) ) );

    SendMessage( hProg, PBM_SETRANGE, 0, lRange );
    SendMessage( hProg, PBM_SETSTEP, 1, 0 );

    dw = LoadString( g_hinstance, IDS_CREATINGDIRECTORIES, szCreating, ARRAYSIZE(szCreating));
    Assert( dw );
    SetWindowText( GetDlgItem( hDlg, IDC_S_OPERATION ), szCreating );


    //
    // Create a security descriptor based on the ACLs
    // defined in REMINSTszSecurityDescriptor.
    //
    // If our directories exist, we'll apply this security
    // descriptor on them.  If our directories don't exist, then
    // we'll use this security descriptor when we create them.
    //
    RtlZeroMemory( &sa, sizeof(SECURITY_ATTRIBUTES) );
    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.bInheritHandle = TRUE;
    f = ConvertStringSecurityDescriptorToSecurityDescriptor( REMINSTszSecurityDescriptor,
                                                             SDDL_REVISION_1,
                                                             &(sa.lpSecurityDescriptor),
                                                             NULL );
    if( !f ) {
        dw = GetLastError();
        MessageBoxFromError( hDlg, NULL, dw );
        hr = THR(HRESULT_FROM_WIN32(dw));
        goto Error;
    }




    attributes = GetFileAttributes( g_Options.szIntelliMirrorPath );
    if ( (attributes & FILE_ATTRIBUTE_DIRECTORY) == 0 ) {
        //
        // There's a file there.
        //
#if 0
        // whack the file and move on.
        DeleteFile( g_Options.szIntelliMirrorPath );
#else
        MessageBoxFromError( hDlg, g_Options.szIntelliMirrorPath, ERROR_DIRECTORY );
        hr = E_FAIL;
        goto Error;
#endif
    }
    

    if( attributes == 0xFFFFFFFF ) {
        //
        // Probably doesn't exist.  Go create it (with our specified
        // access rights).
        //
        hr = CreateDirectoryPath( hDlg, g_Options.szIntelliMirrorPath, &sa, FALSE );
        if ( hr != NO_ERROR ) {
            goto Error;
        }
    } else {

        //
        // The directory is already there.  Go fixup security on it.
        //
        dw = ApplyDaclToFileDirectory( g_Options.szIntelliMirrorPath,
                                       (SECURITY_DESCRIPTOR_RELATIVE *)(sa.lpSecurityDescriptor) );

        if( dw != ERROR_SUCCESS ) {
        
            MessageBoxFromError( hDlg, NULL, dw );
            hr = HRESULT_FROM_WIN32(dw);
            goto Error;
        }

    }



    //
    // Our base directory should be created by now.
    // Prevent the index server from indexing the IntelliMirror directory.
    //
    attributes = GetFileAttributes( g_Options.szIntelliMirrorPath );
    attributes |= FILE_ATTRIBUTE_NOT_CONTENT_INDEXED;
    f = SetFileAttributes( g_Options.szIntelliMirrorPath, attributes );
    if ( !f ) {
        ErrorBox( hDlg, g_Options.szIntelliMirrorPath );
        hr = THR(S_FALSE);
    }
    SendMessage( hProg, PBM_DELTAPOS, 1, 0 );


    //
    // Create
    // "D:\<reminst>\Setup"
    //
    lstrcpyn( szPath, g_Options.szIntelliMirrorPath, ARRAYSIZE(szPath) );
    ConcatenatePaths( szPath, L"\\Setup", ARRAYSIZE(szPath) );
    Assert( wcslen(szPath) < ARRAYSIZE(szPath) );
    if ( 0xFFFFffff == GetFileAttributes( szPath ) ) {
        f = CreateDirectory( szPath, NULL );
        if ( !f ) {
            ErrorBox( hDlg, szPath );
            hr = THR(S_FALSE);
        }
    }
    SendMessage( hProg, PBM_DELTAPOS, 1, 0 );

    //
    // Create
    // "D:\<reminst>\Setup\English"
    //
    lstrcpyn( szPath, g_Options.szIntelliMirrorPath, ARRAYSIZE(szPath) );
    ConcatenatePaths( szPath, L"\\Setup", ARRAYSIZE(szPath));
    ConcatenatePaths( szPath, g_Options.szLanguage, ARRAYSIZE(szPath));
    Assert( wcslen(szPath) < ARRAYSIZE(szPath) );
    if ( 0xFFFFffff == GetFileAttributes( szPath ) ) {
        f = CreateDirectory( szPath, NULL );
        if ( !f ) {
            ErrorBox( hDlg, szPath );
            hr = THR(S_FALSE);
        }
    }
    SendMessage( hProg, PBM_DELTAPOS, 1, 0 );

    //
    // Create
    // "D:\<reminst>\Setup\English\Images"
    //
    lstrcpyn( szPath, g_Options.szIntelliMirrorPath, ARRAYSIZE(szPath) );
    ConcatenatePaths( szPath, L"\\Setup", ARRAYSIZE(szPath));
    ConcatenatePaths( szPath, g_Options.szLanguage, ARRAYSIZE(szPath));
    ConcatenatePaths( szPath, REMOTE_INSTALL_IMAGE_DIR_W, ARRAYSIZE(szPath));
    Assert( wcslen(szPath) < ARRAYSIZE(szPath) );
    if ( 0xFFFFffff == GetFileAttributes( szPath ) ) {
        f = CreateDirectory( szPath, NULL );
        if ( !f ) {
            ErrorBox( hDlg, szPath );
            hr = THR(S_FALSE);
        }
    }
    SendMessage( hProg, PBM_DELTAPOS, 1, 0 );




    if ( !g_Options.fNewOSDirectoryExists
       && g_Options.fNewOS ) {       

        //
        // Create
        // "D:\<reminst>\Setup\English\Images\nt50.wks\i386"
        //
        if ( 0xFFFFffff == GetFileAttributes( g_Options.szInstallationPath ) ) {
            f = CreateDirectory( g_Options.szInstallationPath, NULL );
            if ( !f ) {
                ErrorBox( hDlg, g_Options.szInstallationPath );
                hr = THR(S_FALSE);
            }
        }
        SendMessage( hProg, PBM_DELTAPOS, 1, 0 );
    }

    if ( !g_Options.fOSChooserDirectory ) {
        //
        // Create the OS Chooser tree
        // "D:\<reminst>\OSChooser"
        //
        lstrcpyn( g_Options.szOSChooserPath, g_Options.szIntelliMirrorPath, ARRAYSIZE(g_Options.szOSChooserPath) );
        ConcatenatePaths( g_Options.szOSChooserPath, L"\\OSChooser", ARRAYSIZE(g_Options.szOSChooserPath));
        Assert( wcslen(g_Options.szOSChooserPath) < ARRAYSIZE(g_Options.szOSChooserPath) );
        if ( 0xFFFFffff == GetFileAttributes( g_Options.szOSChooserPath ) ) {
            f = CreateDirectory( g_Options.szOSChooserPath, NULL );
            if ( !f ) {
                ErrorBox( hDlg, g_Options.szOSChooserPath );
                hr = THR(E_FAIL);
                goto Error;
            }
        }
        SendMessage( hProg, PBM_DELTAPOS, 1, 0 );
    }

    if ( g_Options.hinf != INVALID_HANDLE_VALUE
      && !g_Options.fOSChooserDirectoryTreeExists ) {
        WCHAR szFile[ MAX_PATH ];
        BOOL fFound;
        INFCONTEXT context;

        fFound = SetupFindFirstLine( g_Options.hinf, L"OSChooser", NULL, &context );
        AssertMsg( fFound, "Could not find 'OSChooser' section in REMINST.INF.\n" );

        while ( fFound
             && SetupGetStringField( &context, 1, szFile, ARRAYSIZE(szFile), NULL ) )
        {
            dwLen = lstrlen( szFile );
            LPWSTR psz = StrRChr( szFile, &szFile[ dwLen ], L'\\' );
            if ( psz ) {
                *psz = L'\0';       // terminate
                _snwprintf( szPath,
                            ARRAYSIZE(szPath),
                          L"%s\\%s",
                          g_Options.szOSChooserPath,
                          szFile );
                TERMINATE_BUFFER(szPath);

                if ( 0xFFFFffff == GetFileAttributes( szPath ) ) {
                    HRESULT hr2;
                    hr2 = CreateDirectoryPath( hDlg, szPath, NULL, TRUE );
                    if ( FAILED ( hr2 )) {
                        hr = hr2;
                    }
                }
            }

            fFound = SetupFindNextLine( &context, &context );
        }
    }
    if ( FAILED( hr )) goto Error;

    if ( !g_Options.fOSChooserScreensDirectory
      && g_Options.fLanguageSet ) {
        //
        // Create
        // "D:\<reminst>\OSChooser\English"
        //
        lstrcpyn( szPath, g_Options.szIntelliMirrorPath, ARRAYSIZE(szPath) );
        ConcatenatePaths( szPath, L"\\OSChooser", ARRAYSIZE(szPath));
        ConcatenatePaths( szPath, g_Options.szLanguage, ARRAYSIZE(szPath));
        Assert( wcslen(szPath) < ARRAYSIZE(szPath) );
        if ( 0xFFFFffff == GetFileAttributes( szPath ) ) {
            f = CreateDirectory( szPath, NULL );
            if ( !f ) {
                ErrorBox( hDlg, szPath );
                hr = THR(E_FAIL);    // major error
                goto Error;
            }
        }
        SendMessage( hProg, PBM_DELTAPOS, 1, 0 );
    }

    // do this last
    if ( !g_Options.fIMirrorShareFound ) {
        //
        // Add the share
        //
        hr = CreateRemoteBootShare( hDlg );

        SendMessage( hProg, PBM_SETPOS, 1 , 0 );
    }

Error:
    if( sa.lpSecurityDescriptor ) {
        LocalFree(sa.lpSecurityDescriptor);
    }
    HRETURN(hr);
}


//
// Find the filename part from a complete path.
//
LPWSTR FilenameOnly( LPWSTR pszPath )
{
    LPWSTR psz = pszPath;

    // find the end
    while ( *psz )
        psz++;

    // find the slash
    while ( psz > pszPath && *psz != chSlash )
        psz--;

    // move in front of the slash
    if ( psz != pszPath )
        psz++;

    return psz;
}

//
// Private structure containing information that the CopyFilesCallback()
// needs.
//
typedef struct {
    PVOID pContext;                             // "Context" for DefaultQueueCallback
    HWND  hProg;                                // hwnd to the progress meter
    HWND  hOperation;                           // hwnd to the "current operation"
    DWORD nCopied;                              // number of files copied
    DWORD nToBeCopied;                          // number of file to be copied
    DWORD dwCopyingLength;                      // length of the IDS_COPYING
    WCHAR szCopyingString[ SMALL_BUFFER_SIZE ]; // buffer to create "Copying file.ext..."
    BOOL  fQuiet;                               // do things quietly
    HWND  hDlg;                                 // hwnd to the Tasks Dialog
} MYCONTEXT, *LPMYCONTEXT;

//
// Callback that the SETUP APIs calls. It handles updating the
// progress meters as well as UI updating. Any messages not
// handled are passed to the default SETUP callback.
//
UINT CALLBACK
CopyFilesCallback(
    IN PVOID Context,
    IN UINT Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
{
    LPMYCONTEXT pMyContext = (LPMYCONTEXT) Context;

    KeepUIAlive( pMyContext->hDlg );

    if ( g_Options.fAbort )
    {
        if ( !g_Options.fError )
        {
            WCHAR    szAbort[ SMALL_BUFFER_SIZE ];

            // change filename text to aborting...
            DWORD dw;
            dw = LoadString( g_hinstance, IDS_ABORTING, szAbort, ARRAYSIZE(szAbort) );
            Assert( dw );
            SetWindowText( pMyContext->hOperation, szAbort );

            g_Options.fError = TRUE;
        }

        if ( g_Options.fError ) {
            SetLastError(ERROR_CANCELLED);
            return FILEOP_ABORT;
        }
    }

    switch ( Notification )
    {
    case SPFILENOTIFY_ENDCOPY:
        if ( !(pMyContext->fQuiet) ) {
            pMyContext->nCopied++;
            SendMessage( pMyContext->hProg, PBM_SETPOS,
                (5000 * pMyContext->nCopied) / pMyContext->nToBeCopied, 0 );
        }
        break;

    case SPFILENOTIFY_STARTCOPY:
        if ( !(pMyContext->fQuiet) ) {
            DWORD    dwLen;
            LPWSTR * ppszCopyingFile = (LPWSTR *) Param1;

            lstrcpy( &pMyContext->szCopyingString[ pMyContext->dwCopyingLength ],
                FilenameOnly( *ppszCopyingFile ) );
            dwLen = lstrlen( pMyContext->szCopyingString );
            lstrcpy( &pMyContext->szCopyingString[ dwLen ], L"..." );

            SetWindowText( pMyContext->hOperation, pMyContext->szCopyingString );
        }
        break;

    case SPFILENOTIFY_LANGMISMATCH:
    case SPFILENOTIFY_TARGETEXISTS:
    case SPFILENOTIFY_TARGETNEWER:
        if ( !pMyContext->fQuiet )
        {
            UINT u = SetupDefaultQueueCallback( pMyContext->pContext, Notification, Param1, Param2 );
            return u;
        }
        break;

    case SPFILENOTIFY_RENAMEERROR:
    case SPFILENOTIFY_DELETEERROR:
    case SPFILENOTIFY_COPYERROR:
        {
            
            FILEPATHS *fp = (FILEPATHS *) Param1;
            Assert( fp->Win32Error != ERROR_FILE_NOT_FOUND );  // Malformed DRIVERS.CAB file 
            
            if ( fp->Win32Error == ERROR_FILE_NOT_FOUND )
                return FILEOP_SKIP;

        }

    case SPFILENOTIFY_NEEDMEDIA:
        UINT u = SetupDefaultQueueCallback( pMyContext->pContext, Notification, Param1, Param2 );
        if ( u == FILEOP_ABORT )
        {
            g_Options.fAbort = g_Options.fError = TRUE;
        }
        return u;

    }

    return FILEOP_DOIT;
}

//
// CopyInfSection( )
//
HRESULT
CopyInfSection(
    HSPFILEQ Queue,
    HINF     hinf,
    LPCWSTR  pszSection,
    LPCWSTR  pszSourcePath,
    LPCWSTR  pszSubPath, OPTIONAL
    LPCWSTR  pszDescName,
    LPCWSTR  pszTagFile,
    LPCWSTR  pszDestinationRoot,
    LPDWORD  pdwCount )

/*++

Routine Description:

    queues up files from the specified section to be installed into the
    remote install directory.

Arguments:

    Queue      - queue handle to queue the copy operations to.
    hinf       - handle to inf which specifies the list of files to be copied
    pszSection - section listing files to be copied
    pszSourcePath - specifies the base source path,where the files may 
                 be found on the *source* media
    pszSubPath - specifies the subdirectory, if any, where the files may 
                 be found on the *source* media
    pszDescName- user printable description of the media where this file is
                  located.  this may be used when the queue is committed.
    pszTagFile - specifies the tag file that is to uniquely describe the media
                 where these files are located
    pszDestinationRoot - specifies the root location where files are to be 
                        copied to
    pdwCount   - specifies the number of files that were queued from this 
                 section on return.  if the function fails, this value is
                 undefined.    

Return Value:

    An HRESULT indicating the outcome.

--*/
{
    HRESULT hr = S_OK;
    INFCONTEXT context;
    BOOL b;

    TraceFunc( "CopyInfSection( ... )\n" );

    //
    // make sure the section we're looking for exists.  
    // We'll use this context to enumerate the files in the section
    //
    b = SetupFindFirstLine( hinf, pszSection, NULL, &context );
    AssertMsg( b, "Missing section?" );
    if ( !b ) {
        hr = S_FALSE;
    }

    while ( b )
    {
        LPWSTR pszDestRename = NULL;
        WCHAR  szDestPath[ MAX_PATH ],szRename[100];;
        WCHAR  szSrcName[ 64 ];
        DWORD  dw;

        KeepUIAlive( NULL );

        lstrcpyn(szDestPath, pszSubPath, ARRAYSIZE(szDestPath) );

        dw = SetupGetFieldCount( &context );

        if ( dw > 1 ) {     
            //
            // first field is the destination name.
            // we overload this field to also contain a subdirectory where
            // the files should be placed as well
            //
            b = SetupGetStringField( 
                            &context,
                            1, 
                            szRename, 
                            ARRAYSIZE( szRename ), 
                            NULL );
            AssertMsg( b, "Missing field?" );
            if ( b ) {
                //
                // 2nd field is the actual source filename
                //
                b = SetupGetStringField( 
                                &context, 
                                2, 
                                szSrcName, 
                                ARRAYSIZE(szSrcName), 
                                NULL );
                AssertMsg( b, "Missing field?" );
                pszDestRename = szRename;
            }
        } else {
            //
            // if there's only one field, this is the actual source name.  the 
            // destination name will be the same as the source name.
            //
            b = SetupGetStringField( 
                            &context, 
                            1, 
                            szSrcName, 
                            ARRAYSIZE(szSrcName),
                            NULL );
            AssertMsg( b, "Missing field?" );
            
        }

        if ( !b ) {
            hr = S_FALSE;
            goto SkipIt;
        }

        ConcatenatePaths( 
                    szDestPath, 
                    pszDestRename 
                     ? pszDestRename
                     : szSrcName,
                    ARRAYSIZE(szDestPath) );

        //
        // all files are installed into the 
        //
        b = SetupQueueCopy( Queue,
                            pszSourcePath,
                            pszSubPath,
                            szSrcName,
                            pszDescName,
                            pszTagFile,
                            pszDestinationRoot,
                            szDestPath,
                            SP_COPY_NEWER_ONLY | SP_COPY_FORCE_NEWER
                            | SP_COPY_WARNIFSKIP | SP_COPY_SOURCE_ABSOLUTE );
        if ( !b ) {
            ErrorBox( NULL, szSrcName );
            hr = THR(S_FALSE);
            goto SkipIt;
        }

        // increment file count
        (*pdwCount)++;

SkipIt:
        b = SetupFindNextLine( &context, &context );
    }

    HRETURN(hr);
}

typedef struct _EXPANDCABLISTPARAMS {
    HWND     hDlg;
    HINF     hinf;
    LPCWSTR  pszSection;
    LPCWSTR  pszSourcePath;
    LPCWSTR  pszDestPath;
    LPCWSTR  pszSubDir;
} EXPANDCABLISTPARAMS, *PEXPANDCABLISTPARAMS;


//
// ExpandCabList( )
//
DWORD WINAPI
ExpandCabList( LPVOID lpVoid )
{
    PEXPANDCABLISTPARAMS pParams = (PEXPANDCABLISTPARAMS) lpVoid;
    HRESULT hr = S_OK;
    INFCONTEXT context;
    WCHAR   TempDstPath[MAX_PATH];
    WCHAR   TempSrcPath[MAX_PATH];
    BOOL b;

    TraceFunc( "ExpandCabList( ... )\n" );

    // First make sure the DestPath exists, since we may call this
    // before we commit the setup copy queue.

    Assert( pParams->pszSection );
    Assert( pParams->pszSourcePath );
    Assert( pParams->pszDestPath );
    Assert( pParams->pszSubDir );

    DebugMsg( "Expand section %s from %s to %s\n",
              pParams->pszSection,
              pParams->pszSourcePath,
              pParams->pszDestPath );

    lstrcpyn( TempDstPath, pParams->pszDestPath, ARRAYSIZE(TempDstPath));
    ConcatenatePaths( TempDstPath, pParams->pszSubDir, ARRAYSIZE(TempDstPath) );
    hr = CreateDirectoryPath( pParams->hDlg, TempDstPath, NULL, TRUE );
    if ( ! SUCCEEDED(hr) ) {
        HRETURN(hr);
    }

    lstrcpyn( TempSrcPath, pParams->pszSourcePath, ARRAYSIZE(TempSrcPath));
    ConcatenatePaths( TempSrcPath, pParams->pszSubDir, ARRAYSIZE(TempSrcPath) );

    b = SetupFindFirstLine( pParams->hinf, pParams->pszSection, NULL, &context );
    AssertMsg( b, "Missing section?" );
    if ( !b ) {
        hr = S_FALSE;
    }

    while ( b && !g_Options.fError && !g_Options.fAbort )
    {
        WCHAR wszCabName[ MAX_PATH ];
        CHAR szCabPath[ MAX_PATH ];
        CHAR szDestPath[ MAX_PATH ];
        DWORD dwSourcePathLen;

        b = SetupGetStringField( &context, 1, wszCabName, ARRAYSIZE(wszCabName), NULL );
        AssertMsg( b, "Missing field?" );
        if ( !b ) {
            hr = S_FALSE;
            goto SkipIt;
        }

        // szCabPath is pszSourcePath\wszCabName, in ANSI

        dwSourcePathLen = (DWORD)wcslen(TempSrcPath);
        wcstombs( szCabPath, TempSrcPath, dwSourcePathLen );
        if (szCabPath[dwSourcePathLen-1] != '\\') {
            szCabPath[dwSourcePathLen] = '\\';
            ++dwSourcePathLen;
        }
        wcstombs( &szCabPath[dwSourcePathLen], wszCabName, wcslen(wszCabName)+1 );

        wcstombs( szDestPath, TempDstPath, wcslen(TempDstPath)+1 );

        hr = ExtractFiles( szCabPath, szDestPath, 0, NULL, NULL, 0 );

        if ( !SUCCEEDED(hr) ) {
            ErrorBox( pParams->hDlg, wszCabName );
            goto SkipIt;
        }

SkipIt:
        b = SetupFindNextLine( &context, &context );
    }

    HRETURN(hr);
}

//
// RecursiveCopySubDirectory
//
HRESULT
RecursiveCopySubDirectory(
    HSPFILEQ Queue,         // Setup queue
    LPWSTR pszSrcDir,       // points to a buffer MAX_PATH big and contains the source dir to recurse
    LPWSTR pszDestDir,      // points to a buffer MAX_PATH big and contains the destination dir to recurse
    LPWSTR pszDiscName,     // CD name, if any
    LPWSTR pszTagFile,      // tagfile to look for, if any
    LPDWORD pdwCount )      // copy file counter

{
    HRESULT hr = S_OK;
    BOOL b;

    TraceFunc( "RecursiveCopySubDirectory( ... )\n" );

    WIN32_FIND_DATA fda;
    HANDLE hfda = INVALID_HANDLE_VALUE;

    LONG uOrginalSrcLength = (DWORD)wcslen( pszSrcDir );
    LONG uOrginalDstLength = (DWORD)wcslen( pszDestDir );

    ConcatenatePaths( pszSrcDir, L"*", MAX_PATH ); // trust the caller

    hfda = FindFirstFile( pszSrcDir, &fda );
    if ( hfda == INVALID_HANDLE_VALUE )
    {
        ErrorBox( NULL, pszSrcDir );
        hr = E_FAIL;
        goto Cleanup;
    }

    pszSrcDir[ uOrginalSrcLength ] = L'\0';

    do
    {
        KeepUIAlive( NULL );

        if (( fda.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
           && ( wcscmp( fda.cFileName, L"." ) )
           && ( wcscmp( fda.cFileName, L".." ) ))  // no dot dirs
        {
            if ( wcslen( fda.cFileName ) + uOrginalDstLength >= MAX_PATH
              || wcslen( fda.cFileName ) + uOrginalSrcLength >= MAX_PATH )
            {
                SetLastError( ERROR_BUFFER_OVERFLOW );
                ErrorBox( NULL, fda.cFileName );
                hr = E_FAIL;
                goto Cleanup;
            }

            ConcatenatePaths( pszSrcDir, fda.cFileName, MAX_PATH ); // trust the caller
            ConcatenatePaths( pszDestDir, fda.cFileName, MAX_PATH ); // trust the caller
            
            RecursiveCopySubDirectory( Queue,
                                       pszSrcDir,
                                       pszDestDir,
                                       pszDiscName,
                                       pszTagFile,
                                       pdwCount );

            pszSrcDir[ uOrginalSrcLength ] = L'\0';
            pszDestDir[ uOrginalDstLength ] = L'\0';
            goto SkipFile;
        }
        else if (fda.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
            goto SkipFile;

        b = SetupQueueCopy( Queue,
                            pszSrcDir,
                            NULL,
                            fda.cFileName,
                            pszDiscName,
                            pszTagFile,
                            pszDestDir,
                            NULL,
                            SP_COPY_NEWER_ONLY | SP_COPY_FORCE_NEWER
                            | SP_COPY_WARNIFSKIP | SP_COPY_SOURCE_ABSOLUTE );
        if ( !b ) {
            ErrorBox( NULL, fda.cFileName );
            hr = THR(S_FALSE);
            goto SkipFile;
        }

        // increment file counter
        (*pdwCount)++;
SkipFile:
        ;   // nop
    } while ( FindNextFile( hfda, &fda ) );

Cleanup:
    if ( hfda != INVALID_HANDLE_VALUE ) {
        FindClose( hfda );
        hfda = INVALID_HANDLE_VALUE;
    }

    HRETURN(hr);
}


#define COPY_OPTIONAL_DIRS_OPTIONAL      (0x00000001)    

//
// CopyOptionalDirs
//
HRESULT
CopyOptionalDirs(
    HSPFILEQ Queue,
    HINF     hinf,
    LPWSTR   pszSection,
    LPWSTR   pszDiscName,
    LPWSTR   pszTagFile,
    LPDWORD  pdwCount )
{
    HRESULT    hr = S_OK;
    INFCONTEXT context;
    BOOL b;

    TraceFunc( "CopyOptionalDirs( ... )\n" );

    b = SetupFindFirstLine( hinf, pszSection, NULL, &context );
#if 0
    // this will hit installing a 2195 build because [AdditionalClientDirs]
    // is missing, so take it out for now
    AssertMsg( b, "Missing section?" );
#endif
    if ( !b ) {
        hr = S_FALSE;
    }

    while ( b && hr == S_OK )
    {
        WCHAR  szSrcPath[ 40 ]; // should be 8.3 directory name
        WCHAR  szSrcDir[ MAX_PATH ];
        WCHAR  szDestDir[ MAX_PATH ];
        INT iOptions = 0;
        DWORD dwAttribs;
        DWORD Fields;

        Fields = SetupGetFieldCount(&context);

        //
        // Contains optionality flag?
        //
        if (Fields > 1) {
            b  = SetupGetStringField( &context, 1, szSrcPath, ARRAYSIZE(szSrcPath), NULL );        
            AssertMsg( b, "Missing field?" );
            if ( !b ) {
                hr = S_FALSE;
                goto Cleanup;
            }

            b = SetupGetIntField(&context, 2, &iOptions);
            AssertMsg(b, "Missing optionality field?");
            if (!b) {
                hr = S_FALSE;
                goto Cleanup;
            }

        }
        //
        // Otherwise, just use the base string in the inf file
        //
        else {
            b  = SetupGetStringField( &context, 0, szSrcPath, ARRAYSIZE(szSrcPath), NULL );        
            AssertMsg( b, "Missing field?" );
            if ( !b ) {
                hr = S_FALSE;
                goto Cleanup;
            }
        }

        lstrcpyn( szSrcDir, g_Options.szSourcePath, ARRAYSIZE(szSrcDir) );
        //
        // If we're on an x86 platform, we have to deal with backwards
        // compatibility.  The problem is that w2k didn't have the subdirectory
        // listed in the optional source dirs, so we have to append it here.
        // on ia64, we have multiple optional source dirs, and it's easiest
        // if we just get the subdir from the source directory.
        //
        if (g_Options.ProcessorArchitecture != PROCESSOR_ARCHITECTURE_IA64) {
            ConcatenatePaths( szSrcDir, g_Options.ProcessorArchitectureString, ARRAYSIZE(szSrcDir) );
        }
        ConcatenatePaths( szSrcDir, szSrcPath, ARRAYSIZE(szSrcDir));
        Assert( wcslen( szSrcDir ) < ARRAYSIZE(szSrcDir) );

        lstrcpyn( szDestDir, g_Options.szInstallationPath, ARRAYSIZE(szDestDir) );
        if (g_Options.ProcessorArchitecture != PROCESSOR_ARCHITECTURE_IA64) {
            ConcatenatePaths( szDestDir, g_Options.ProcessorArchitectureString, ARRAYSIZE(szDestDir));
        }        
        ConcatenatePaths( szDestDir, szSrcPath, ARRAYSIZE(szDestDir) );
        Assert( wcslen( szDestDir ) < ARRAYSIZE(szDestDir) );

        //
        // If the file is missing, and the 'optional' bit is set on the file, then
        // we can skip it.
        //
        dwAttribs = GetFileAttributes(szSrcDir);
        if ((dwAttribs == INVALID_FILE_ATTRIBUTES) && 
             ((GetLastError() == ERROR_FILE_NOT_FOUND) || (GetLastError() == ERROR_PATH_NOT_FOUND)))
        {
            //
            // If the directory isn't there, but it's really marked as optional, then we can skip
            // it without saying anything.
            //
            if (iOptions & COPY_OPTIONAL_DIRS_OPTIONAL)
            {
                b = SetupFindNextLine( &context, &context );
                continue;                
            }
        }

        hr = RecursiveCopySubDirectory( Queue,
                                        szSrcDir,
                                        szDestDir,
                                        pszDiscName,
                                        pszTagFile,
                                        pdwCount );
        if (! SUCCEEDED(hr)) {
            goto Cleanup;
        }

        b = SetupFindNextLine( &context, &context );
    }

Cleanup:

    HRETURN(hr);
}


//
// IsEntryInCab( )
BOOL
IsEntryInCab(
    HINF    hinf,
    PCWSTR  pszFileName
    )
{

    TraceFunc( "IsEntryInCab( ... )\n" );

    INFCONTEXT Context;
    INFCONTEXT SectionContext;
    WCHAR      szCabinetName[ MAX_PATH ];
    UINT       uField;
    UINT       uFieldCount;
    DWORD      dwLen = ARRAYSIZE( szCabinetName );

    Assert( hinf != INVALID_HANDLE_VALUE );
    Assert( pszFileName );

    // Find the cab files listing section
    if ( !SetupFindFirstLineW( hinf, L"Version", L"CabFiles", &SectionContext ) )
    {
        RETURN( FALSE );
    }

    do
    {
        uFieldCount = SetupGetFieldCount( &SectionContext );

        for( uField = 1; uField <= uFieldCount; uField++ )
        {
            SetupGetStringField( &SectionContext, uField, szCabinetName, dwLen, NULL );

            if( SetupFindFirstLineW( hinf, szCabinetName, pszFileName, &Context ) )
            {
                RETURN( TRUE ); // it's in a CAB
            }
        }

    } while ( SetupFindNextMatchLine( &SectionContext, L"CabFiles", &SectionContext ) );

    RETURN( FALSE );
}

typedef struct _LL_FILES_TO_EXTRACT LL_FILES_TO_EXTRACT;
typedef struct _LL_FILES_TO_EXTRACT {
    LL_FILES_TO_EXTRACT * Next;
    DWORD dwLen;
    WCHAR szFilename[ MAX_PATH ];
    WCHAR szSubDir[ MAX_PATH ];
} LL_FILES_TO_EXTRACT, * PLL_FILES_TO_EXTRACT;

PLL_FILES_TO_EXTRACT pExtractionList;

//
// AddEntryToExtractionQueue( )
//
HRESULT
AddEntryToExtractionQueue(
    LPWSTR pszFileName )
{
    TraceFunc( "AddEntryToExtractionQueue( ... )\n" );

    HRESULT hr = S_OK;
    PLL_FILES_TO_EXTRACT  pNode = pExtractionList;
    DWORD   dwLen;

    dwLen = (DWORD)wcslen( pszFileName );
    while ( pNode )
    {
        if ( dwLen == pNode->dwLen
          && _wcsicmp( pszFileName, pNode->szFilename ) == 0 )
        {
            hr = S_FALSE;
            goto exit; // duplicate
        }
        pNode = pNode->Next;
    }

    pNode = (PLL_FILES_TO_EXTRACT) LocalAlloc( LMEM_FIXED, sizeof(LL_FILES_TO_EXTRACT) );
    if ( pNode )
    {
        pNode->dwLen = dwLen;
        pNode->Next = pExtractionList;
        wcscpy( pNode->szFilename, pszFileName );

        pExtractionList = pNode;

        DebugMsg( "QUEUEING  : %s to be extracted.\n", pszFileName );
    }
    else
    {
        hr = THR( E_OUTOFMEMORY );
    }

exit:
    HRETURN(hr);
}

BOOL
MySetupGetSourceInfo( 
    IN HINF hInf, 
    IN UINT SrcId, 
    IN UINT InfoDesired,
    IN PCWSTR ProcessorArchitectureOverride, OPTIONAL
    OUT PWSTR Buffer,
    IN DWORD BufferSizeInBytes,
    OUT LPDWORD RequiredSize OPTIONAL
    )
/*++

Routine Description:

    Wrapper for SetupGetSourceInfo because it doesn't handle platform path 
    override correctly.

--*/
{
    WCHAR TempSectionName[MAX_PATH];
    WCHAR SourceId[20];
    INFCONTEXT Context;
    BOOL RetVal = FALSE;
    
    if (!ProcessorArchitectureOverride) {
        return SetupGetSourceInfo(
                            hInf,
                            SrcId,
                            InfoDesired,
                            Buffer,
                            BufferSizeInBytes,
                            RequiredSize );
    }

    Assert( InfoDesired == SRCINFO_PATH );


    wsprintf( TempSectionName, L"SourceDisksNames.%s", ProcessorArchitectureOverride );
    wsprintf( SourceId, L"%d", SrcId );
    
    if (!SetupFindFirstLine( hInf, TempSectionName,SourceId, &Context )) {
        lstrcpyn( TempSectionName, L"SourceDisksNames", ARRAYSIZE(TempSectionName) );
        if (!SetupFindFirstLine( hInf, TempSectionName,SourceId, &Context )) {
            goto exit;
        }
    }

    RetVal = SetupGetStringField( &Context, 4, Buffer, BufferSizeInBytes/sizeof(TCHAR), NULL );

exit:

    return(RetVal);

}     


//
// CopyLayoutInfSection( )
//
HRESULT
CopyLayoutInfSection(
    HSPFILEQ Queue,
    HINF     hinf,
    HINF     hinfDrivers,
    LPCWSTR   pszSection,
    LPCWSTR   pszDescName,
    LPCWSTR   pszTagFile,
    LPCWSTR  pszDestination,
    LPDWORD  pdwCount )
/*++

Routine Description:

    Queues up files from the specified section in layout.inf to be installed
    into the remote install image directory.  This code is similar to what
    textmode setup does, and it reads several of the extended layout flags
    that textmode setup reads and setupapi doesn't have intrinsic knowledge
    about.

Arguments:

    Queue      - queue handle to queue the copy operations to.
    hinf       - handle to layout.inf
    hinfDrivers - handle to drvindex.inf, to be used to see if files are
                  located in the driver cabinet or not
    pszSection - section listing files to be copied
    pszDescName- user printable description of the media where this file is
                  located.  this may be used when the queue is committed.
    pszTagFile - specifies the tag file that is to uniquely describe the media
                 where these files are located
    pszDestination - specifies the location where files are to be 
                        copied to
    pdwCount   - specifies the number of files that were queued from this 
                 section on return.  if the function fails, this value is
                 undefined.    

Return Value:

    An HRESULT indicating the outcome.

--*/
{
    HRESULT hr = S_OK;
    INFCONTEXT context;
    BOOL b;

    TraceFunc( "CopyLayoutInfSection( ... )\n" );

    b = SetupFindFirstLine( hinf, pszSection, NULL, &context );
    AssertMsg( b, "Missing section?" );
    if ( !b ) {
        hr = S_FALSE;
    }

    while ( b )
    {
        BOOL   fDecompress = FALSE;
        WCHAR  szTemp[ 5 ]; // "_x" is the biggest string right now
        DWORD  SrcId;
        WCHAR  szSrcName[ MAX_PATH ];
        WCHAR  szSubDir[20];
        WCHAR  szSubDirPlusFileName[MAX_PATH];
        LPWSTR pszPeriod;

        KeepUIAlive( NULL );

        b  = SetupGetStringField( &context, 0, szSrcName, ARRAYSIZE(szSrcName), NULL );
        AssertMsg( b, "Missing field?" );
        if ( !b ) {
            hr = S_FALSE;
            goto SkipIt;
        }

        //
        // get the subdirectory that this file is located in, based on the 
        // sourcedisksnames data in field 1
        //
        b  = SetupGetStringField( &context, 1, szTemp, ARRAYSIZE(szTemp), NULL );
        AssertMsg( b, "Missing field?" );
        if ( !b ) {
            hr = S_FALSE;
            goto SkipIt;
        }

        SrcId = _wtoi(szTemp);

        b = MySetupGetSourceInfo( 
                    hinf, 
                    SrcId, 
                    SRCINFO_PATH,
                    SetupExtensionFromProcessorTag(g_Options.ProcessorArchitectureString),
                    szSubDir,
                    ARRAYSIZE(szSubDir),
                    NULL );
        if (!b) {
            hr = S_FALSE;
            goto SkipIt;
        }

        // If there is an "_" in the 2nd character of "source" column of the
        // layout.inf file, then this file should be decompressed because
        // it is a file needed for booting.
        szTemp[1] = 0;
        b = SetupGetStringField( &context, 7, szTemp, ARRAYSIZE(szTemp), NULL );
        AssertMsg( b, "Missing field?" );
        if ( szTemp[1] == L'_' ) {
            fDecompress = TRUE;
            DebugMsg( "DECOMPRESS: %s is a boot driver.\n", szSrcName );
            goto CopyIt;
        }

        // If the 7th field isn't NULL, then the file exists outside the
        // CABs so just copy it.
        if ( wcslen( szTemp ) > 0 ) {
            DebugMsg( "BOOTFLOPPY: %s is external from CAB.\n", szSrcName );
            goto CopyIt;
        }

        // If it is in the CAB and didn't meet any of the conditions above,
        // don't copy the file. It'll be in the CAB when/if setup needs it.
        if ( IsEntryInCab( hinfDrivers, szSrcName ) ) {
#if DBG
            pszPeriod = wcschr(szSrcName, L'.');
            if ((pszPeriod != NULL) && (_wcsicmp(pszPeriod, L".inf") == 0)) {
                DebugMsg( 
                    "WARNING: %s is an INF in a cab.  This file will not be available for network inf processing .\n", 
                    szSrcName );
            }
#endif                
            DebugMsg( "SKIPPING  : %s in a CAB.\n", szSrcName );
            goto SkipIt;
        }

        // If the extension is ".inf", then decompress so binlsvc
        // can do its network .inf processing.
        pszPeriod = wcschr(szSrcName, L'.');
        if ((pszPeriod != NULL) && (_wcsicmp(pszPeriod, L".inf") == 0)) {
            fDecompress = TRUE;
            DebugMsg( "DECOMPRESS: %s is an INF.\n", szSrcName );            
        }

CopyIt:
        //
        // we do this so that files end up in the proper subdirectory
        //
        lstrcpyn(szSubDirPlusFileName, szSubDir, ARRAYSIZE(szSubDirPlusFileName) );
        ConcatenatePaths( szSubDirPlusFileName, szSrcName, ARRAYSIZE(szSubDirPlusFileName) );

        b = SetupQueueCopy( Queue,
                            g_Options.szSourcePath,
                            szSubDir,
                            szSrcName,
                            pszDescName,
                            pszTagFile,
                            pszDestination,
                            szSubDirPlusFileName,
                            SP_COPY_NEWER_ONLY | SP_COPY_FORCE_NEWER | SP_COPY_WARNIFSKIP
                            | SP_COPY_SOURCE_ABSOLUTE | ( fDecompress ? 0 : SP_COPY_NODECOMP ) );
        if ( !b ) {
            ErrorBox( NULL, szSrcName );
            hr = THR(S_FALSE);
            goto SkipIt;
        }

        // increment file counter
        (*pdwCount)++;

SkipIt:
        b = SetupFindNextLine( &context, &context );
    }

    HRETURN(hr);
}

//
// EnumNetworkDriversCallback( )
//
ULONG
EnumNetworkDriversCallback(
    LPVOID pContext,
    LPWSTR pszInfName,
    LPWSTR pszFileName )
{
    
    UNREFERENCED_PARAMETER(pszInfName);

    TraceFunc( "EnumNetworkDriversCallback( ... )\n" );

    MYCONTEXT * pMyContext = (MYCONTEXT *) pContext;
    HRESULT hr;

    Assert( pszFileName );
    Assert( pszInfName );

    //DebugMsg( "In %s: %s\n", pszInfName, pszFileName );

    if ( KeepUIAlive( pMyContext->hDlg ) )
    {
        RETURN(ERROR_CANCELLED);
    }

    hr = AddEntryToExtractionQueue( pszFileName );
    if ( hr == S_OK )
    {
        pMyContext->nToBeCopied++;
    }
    else if ( hr == S_FALSE )
    {   // duplicate found in queue... keep going
        hr = S_OK;
    }

    HRETURN(hr);
}

//
// EnumCabinetCallback( )
//
UINT CALLBACK
EnumCabinetCallback(
    IN PVOID Context,
    IN UINT Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
{
    
    UNREFERENCED_PARAMETER(Param2);
    
    TraceFunc( "EnumCabinetCallback( ... )\n" );

    UINT   uResult = 0;
    PLL_FILES_TO_EXTRACT pNode = pExtractionList;
    PLL_FILES_TO_EXTRACT pLast = NULL;
    DWORD  dwLen;
    PFILE_IN_CABINET_INFO pfici;

    MYCONTEXT *pMyContext = (MYCONTEXT *) Context;

    Assert( pMyContext );

    KeepUIAlive( pMyContext->hDlg );

    if ( g_Options.fAbort )
    {
        if ( !g_Options.fError )
        {
            WCHAR    szAbort[ SMALL_BUFFER_SIZE ];

            // change filename text to aborting...
            DWORD dw;
            dw = LoadString( g_hinstance, IDS_ABORTING, szAbort, ARRAYSIZE(szAbort) );
            Assert( dw );
            SetWindowText( pMyContext->hOperation, szAbort );

            g_Options.fError = TRUE;
        }

        if ( g_Options.fError ) {
            SetLastError(ERROR_CANCELLED);
            uResult = FILEOP_ABORT;
            goto exit;
        }
    }

    if ( Notification == SPFILENOTIFY_FILEINCABINET )
    {
        pfici = (PFILE_IN_CABINET_INFO) Param1;
        Assert( pfici );
        Assert( pfici->NameInCabinet );

        dwLen = (DWORD)wcslen( pfici->NameInCabinet );
        while ( pNode )
        {
            if ( dwLen == pNode->dwLen
              && _wcsicmp( pfici->NameInCabinet, pNode->szFilename ) == 0 )
            {   // match! remove it from the list and extract it.
                if ( pNode == pExtractionList )
                {
                    pExtractionList = pNode->Next;
                }
                else
                {
                    if( pLast ) {
                        pLast->Next = pNode->Next;
                    }
                }
                LocalFree( pNode );

                // create target path
                lstrcpyn( pfici->FullTargetName, g_Options.szInstallationPath, MAX_PATH );
                ConcatenatePaths( pfici->FullTargetName, g_Options.ProcessorArchitectureString, MAX_PATH );
                ConcatenatePaths( pfici->FullTargetName, pfici->NameInCabinet, MAX_PATH );

                if ( !(pMyContext->fQuiet) ) {
                    wcscpy( &pMyContext->szCopyingString[ pMyContext->dwCopyingLength ],
                        pfici->NameInCabinet );
                    dwLen = (DWORD)wcslen( pMyContext->szCopyingString );
                    wcscpy( &pMyContext->szCopyingString[ dwLen ], L"..." );

                    SetWindowText( pMyContext->hOperation, pMyContext->szCopyingString );
                }

                DebugMsg( "EXTRACTING: %s from CAB.\n", pfici->NameInCabinet );

                uResult = FILEOP_DOIT;
                goto exit;
            }
            pLast = pNode;
            pNode = pNode->Next;
        }

        uResult = FILEOP_SKIP;
    }
    else if ( Notification == SPFILENOTIFY_FILEEXTRACTED )
    {
        PFILEPATHS pfp = (PFILEPATHS) Param1;
        Assert( pfp );

        pMyContext->nCopied++;
        SendMessage( pMyContext->hProg, PBM_SETPOS, (5000 * pMyContext->nCopied) / pMyContext->nToBeCopied, 0 );

        uResult = pfp->Win32Error;
    }

exit:
    RETURN(uResult);
}

//
// AddInfSectionToExtractQueue( )
//
HRESULT
AddInfSectionToExtractQueue(
    HINF    hinf,
    LPWSTR  pszSection,
    LPMYCONTEXT Context )
{
    TraceFunc( "AddInfSectionToExtractQueue( ... )\n" );

    HRESULT hr = S_OK;
    BOOL    b;

    INFCONTEXT context;

    b = SetupFindFirstLine( hinf, pszSection, NULL, &context );
    if ( !b ) goto Cleanup; // nothing to do - don't complain!

    while ( b )
    {
        WCHAR szFilename[ MAX_PATH ];
        DWORD dwLen = ARRAYSIZE( szFilename );
        b = SetupGetStringField( &context, 1, szFilename, dwLen, NULL );
        if ( !b ) goto Error;

        hr = AddEntryToExtractionQueue( szFilename );
        if (FAILED( hr )) goto Cleanup;

        if (hr == S_OK) {
            Context->nToBeCopied += 1;
        }

        b = SetupFindNextLine( &context, &context );
    }

Cleanup:
    HRETURN(hr);
Error:
    hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
    goto Cleanup;
}


//
// Copies the files into the setup directory.
//
HRESULT
CopyClientFiles( HWND hDlg )
{
    HRESULT hr = S_OK;
    DWORD   dwLen;
    BOOL    b;
    HWND    hProg    = GetDlgItem( hDlg, IDC_P_METER );
    DWORD   dwCount  = 0;
    DWORD   dw;
    WCHAR   szText[ SMALL_BUFFER_SIZE ];
    WCHAR   szFilepath[ MAX_PATH ];
    WCHAR   szTempPath[ MAX_PATH ];
    WCHAR   szInsertMedia[ MAX_PATH ];
    HINF    hinfLayout = INVALID_HANDLE_VALUE;
    HINF    hinfReminst = INVALID_HANDLE_VALUE;
    HINF    hinfDrivers = INVALID_HANDLE_VALUE;
    HINF    hinfDosnet = INVALID_HANDLE_VALUE;
    UINT    uLineNum;
    DWORD   dwFlags = IDF_CHECKFIRST | IDF_NOSKIP;
    WCHAR   *p;
    PWSTR   FullDllPath = NULL;

    PLL_FILES_TO_EXTRACT  pNode;
    HMODULE hBinlsvc = NULL;
    PNETINFENUMFILES pfnNetInfEnumFiles = NULL;

    HANDLE hThread = NULL;
    EXPANDCABLISTPARAMS ExpandParams;

    INFCONTEXT context;

    HSPFILEQ  Queue = INVALID_HANDLE_VALUE;
    MYCONTEXT MyContext;

    TraceFunc( "CopyClientFiles( hDlg )\n" );

    //
    // Setup and display next section of dialog
    //
    SendMessage( hProg, PBM_SETRANGE, 0, MAKELPARAM(0, 5000 ));
    SendMessage( hProg, PBM_SETPOS, 0, 0 );
    dw = LoadString( g_hinstance, IDS_BUILDINGFILELIST, szText, ARRAYSIZE(szText));
    Assert( dw );
    SetDlgItemText( hDlg, IDC_S_OPERATION, szText );

    // Initialize
    ZeroMemory( &MyContext, sizeof(MyContext) );
    pExtractionList = NULL;
    ZeroMemory( &ExpandParams, sizeof(ExpandParams) );

    FullDllPath = (PWSTR)TraceAlloc(LPTR, MAX_PATH*sizeof(WCHAR));
    if( !FullDllPath ) {
        hr = THR( HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY ) );
        ErrorBox( hDlg, L"BINLSVC.DLL" );
        goto Cleanup;
    }

    if (!ExpandEnvironmentStrings(L"%systemroot%\\system32\\binlsvc.dll", FullDllPath, MAX_PATH) ) {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, L"BINLSVC.DLL" );
        goto Cleanup;
    }

    hBinlsvc = LoadLibrary( FullDllPath );
    if (!hBinlsvc) {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, L"BINLSVC.DLL" );
        goto Cleanup;
    }

    pfnNetInfEnumFiles = (PNETINFENUMFILES) GetProcAddress( hBinlsvc, NETINFENUMFILESENTRYPOINT );
    if ( pfnNetInfEnumFiles == NULL )
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, L"BINLSVC.DLL" );
        goto Cleanup;
    }

    // Make sure the workstation CD is the CD-ROM drive
    dw = LoadString( g_hinstance, IDS_INSERT_MEDIA, szInsertMedia, ARRAYSIZE(szInsertMedia) );
    Assert( dw );

AskForDisk:
    lstrcpyn(szTempPath, g_Options.szSourcePath, ARRAYSIZE(szTempPath));
    ConcatenatePaths( szTempPath, g_Options.ProcessorArchitectureString, ARRAYSIZE(szTempPath));

    if ( DPROMPT_SUCCESS !=
            SetupPromptForDisk( hDlg,
                                szInsertMedia,
                                g_Options.szWorkstationDiscName,
                                szTempPath,
                                L"layout.inf",
                                g_Options.szWorkstationTagFile,
                                dwFlags,
                                g_Options.szSourcePath,
                                MAX_PATH,
                                NULL ) )
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        goto Cleanup;
    }

    //
    // if they gave us a trailing architecture tag, then remove it
    //
    if (g_Options.szSourcePath[wcslen(g_Options.szSourcePath)-1] == L'\\') {
        //
        // lose the trailing backslash if present
        //
        g_Options.szSourcePath[wcslen(g_Options.szSourcePath)-1] = L'\0';
    }

    p = wcsrchr( g_Options.szSourcePath, L'\\');
    if (p) {
        p = StrStrI(p,g_Options.ProcessorArchitectureString);
            if (p) {
            *(p-1) = L'\0';
        }
    }

    dw = CheckImageSource( hDlg );
    if ( dw != ERROR_SUCCESS )
    {
        dwFlags = IDF_NOSKIP;
        goto AskForDisk;
    }

    if ( g_Options.fAbort || g_Options.fError )
        goto Cleanup;

    lstrcpyn(szFilepath, g_Options.szSourcePath, ARRAYSIZE(szFilepath));
    ConcatenatePaths( szFilepath, g_Options.ProcessorArchitectureString, ARRAYSIZE(szFilepath));
    ConcatenatePaths( szFilepath, L"layout.inf", ARRAYSIZE(szFilepath));
    
    Assert( wcslen( szFilepath ) < ARRAYSIZE(szFilepath) );

    hinfLayout = SetupOpenInfFile( szFilepath, NULL, INF_STYLE_WIN4, &uLineNum);
    if ( hinfLayout == INVALID_HANDLE_VALUE ) {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, szFilepath );
        goto Cleanup;
    }

    // Openning layout can take a long time. Update the UI and check to see
    // if the user wants to abort.
    if ( KeepUIAlive( hDlg ) )
    {
        hr = HRESULT_FROM_WIN32( ERROR_CANCELLED );
        goto Cleanup;
    }

    lstrcpyn(szFilepath, g_Options.szSourcePath, ARRAYSIZE(szFilepath));
    ConcatenatePaths( szFilepath, g_Options.ProcessorArchitectureString, ARRAYSIZE(szFilepath));
    ConcatenatePaths( szFilepath, L"drvindex.inf", ARRAYSIZE(szFilepath));

    Assert( wcslen( szFilepath ) < ARRAYSIZE(szFilepath) );

    hinfDrivers = SetupOpenInfFile( szFilepath, NULL, INF_STYLE_WIN4, &uLineNum);
    if ( hinfDrivers == INVALID_HANDLE_VALUE ) {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, szFilepath );
        goto Cleanup;
    }

    //
    // Create the Queue
    //
    Queue = SetupOpenFileQueue( );

    //
    // Copy to REMINST.inf quietly
    //
    dw = GetEnvironmentVariable( L"TMP",
                                 g_Options.szWorkstationRemBootInfPath,
                                 ARRAYSIZE(g_Options.szWorkstationRemBootInfPath) );
    Assert( dw );

    ConcatenatePaths( g_Options.szWorkstationRemBootInfPath, L"\\REMINST.inf", ARRAYSIZE(g_Options.szWorkstationRemBootInfPath));
    Assert( wcslen(g_Options.szWorkstationRemBootInfPath) < ARRAYSIZE(g_Options.szWorkstationRemBootInfPath) );

    lstrcpyn(szTempPath, g_Options.szSourcePath, ARRAYSIZE(szTempPath));
    ConcatenatePaths( szTempPath, g_Options.ProcessorArchitectureString, ARRAYSIZE(szTempPath));
    
    b = SetupInstallFile( hinfLayout,
                          NULL,
                          L"REMINST.inf",
                          szTempPath,
                          g_Options.szWorkstationRemBootInfPath,
                          SP_COPY_FORCE_NEWER,
                          NULL,
                          NULL );
    if ( !b ) {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        WCHAR szCaption[SMALL_BUFFER_SIZE]; 
        DWORD LoadStringResult;
        szCaption[0] = L'\0';
        LoadStringResult = LoadString( g_hinstance, IDS_COPYING_REMINST_TITLE, szCaption, SMALL_BUFFER_SIZE );
        Assert( LoadStringResult );
        ErrorBox( hDlg, szCaption );
        AssertMsg( b, "Failed to copy REMINST.INF to TEMP" );
        goto Cleanup;
    }

    // The above call will initialize a lot of the SETUPAPI. This might take
    // a long time as well. Refresh the UI and check for user abort.
    if ( KeepUIAlive( hDlg ) )
    {
        hr = HRESULT_FROM_WIN32( ERROR_CANCELLED );
        goto Cleanup;
    }



    // Now check the version of the workstation to make sure it's compatible
    hr = CheckServerVersion( );
    if ( FAILED(hr) )
        goto Cleanup;


    //
    // Copy architecture-indepenedent files.
    //
    hr = CopyLayoutInfSection( Queue,
                               hinfLayout,
                               hinfDrivers,
                               L"SourceDisksFiles",                               
                               g_Options.szWorkstationDiscName,
                               g_Options.szWorkstationTagFile,
                               g_Options.szInstallationPath,
                               &dwCount );
    if ( FAILED(hr) ) {
        goto Cleanup;
    }

    //
    // Copy architecture-depenedent files.
    //
    wsprintf( 
        szTempPath, 
        L"SourceDisksFiles.%s", 
        SetupExtensionFromProcessorTag(g_Options.ProcessorArchitectureString) );

    hr = CopyLayoutInfSection( Queue,
                               hinfLayout,
                               hinfDrivers,
                               szTempPath,
                               g_Options.szWorkstationDiscName,
                               g_Options.szWorkstationTagFile,
                               g_Options.szInstallationPath,
                               &dwCount );
    if ( FAILED(hr) ) {
        goto Cleanup;
    }

    //
    // build the path to dosnet.inf
    //
    lstrcpyn( szFilepath, g_Options.szSourcePath, ARRAYSIZE(szFilepath) );
    ConcatenatePaths( szFilepath, g_Options.ProcessorArchitectureString, ARRAYSIZE(szFilepath) );
    ConcatenatePaths( szFilepath, L"dosnet.inf", ARRAYSIZE(szTempPath));

    Assert( wcslen( szFilepath ) < ARRAYSIZE(szFilepath));

    hinfDosnet = SetupOpenInfFile( szFilepath, NULL, INF_STYLE_WIN4, &uLineNum);
    if ( hinfDosnet == INVALID_HANDLE_VALUE ) {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( NULL, szFilepath );
        goto Cleanup;
    }

    //
    // we only do this so that we can install w2k x86 images.  It's not
    // necessary and causes an error on ia64.  The proper place to add
    // directories is in the AdditionalClientDirs section of reminst.inf
    //
    if (g_Options.ProcessorArchitecture != PROCESSOR_ARCHITECTURE_IA64) {
        hr = CopyOptionalDirs( Queue,
                               hinfDosnet,
                               L"OptionalSrcDirs",
                               g_Options.szWorkstationDiscName,
                               g_Options.szWorkstationTagFile,
                               &dwCount );
    }

    if ( FAILED(hr) )
        goto Cleanup;


    SetupCloseInfFile( hinfLayout );
    hinfLayout = INVALID_HANDLE_VALUE;

    SetupCloseInfFile( hinfDosnet );
    hinfDosnet = INVALID_HANDLE_VALUE;


    //
    // Add additional files not specified in the LAYOUT.INF
    //
    hinfReminst = SetupOpenInfFile( g_Options.szWorkstationRemBootInfPath, NULL, INF_STYLE_WIN4, &uLineNum);
    if ( hinfReminst == INVALID_HANDLE_VALUE ) {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, g_Options.szWorkstationRemBootInfPath );
        goto Cleanup;
    }

    hr = CopyInfSection( Queue,
                         hinfReminst,
                         L"AdditionalClientFiles",
                         g_Options.szSourcePath,
                         g_Options.szWorkstationSubDir,
                         g_Options.szWorkstationDiscName,
                         g_Options.szWorkstationTagFile,
                         g_Options.szInstallationPath,
                         &dwCount );
    if( FAILED(hr) )
        goto Cleanup;

    //
    // Add additional directories not specified in LAYOUT.INF
    //
    hr = CopyOptionalDirs( Queue,
                           hinfReminst,
                           L"AdditionalClientDirs",
                           g_Options.szWorkstationDiscName,
                           g_Options.szWorkstationTagFile,
                           &dwCount );
    if ( FAILED(hr) )
        goto Cleanup;

    //
    // This information will be passed to CopyFileCallback() as
    // the Context.
    //
    MyContext.nToBeCopied        = dwCount;
    MyContext.nCopied            = 0;
    MyContext.pContext           = SetupInitDefaultQueueCallbackEx(NULL,(HWND)INVALID_HANDLE_VALUE,0,0,NULL);
    MyContext.hProg              = hProg;
    MyContext.hOperation         = GetDlgItem( hDlg, IDC_S_OPERATION );
    MyContext.hDlg               = hDlg;
    MyContext.fQuiet             = FALSE;
    MyContext.dwCopyingLength =
        LoadString( g_hinstance, IDS_COPYING, MyContext.szCopyingString, ARRAYSIZE(MyContext.szCopyingString));
    Assert(MyContext.dwCopyingLength);

    //
    // Start copying
    //
    Assert( dwCount );
    if ( dwCount != 0 )
    {
        b = SetupCommitFileQueue( NULL,
                                  Queue,
                                  (PSP_FILE_CALLBACK) CopyFilesCallback,
                                  (PVOID) &MyContext );
        if ( !b ) {
            DWORD dwErr = GetLastError( );
            switch ( dwErr )
            {
            case ERROR_CANCELLED:
                hr = THR( HRESULT_FROM_WIN32( ERROR_CANCELLED ) );
                goto Cleanup;

            default:
                hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
                MessageBoxFromError( hDlg, NULL, dwErr );
                goto Cleanup;
            }
        }
    }

    SetupCloseFileQueue( Queue );
    Queue = INVALID_HANDLE_VALUE;

    //
    // Ask BINL to go through the INFs to find the drivers
    // that we need to extract from the CABs.
    //
    dw = LoadString( g_hinstance, IDS_BUILDINGFILELIST, szText, ARRAYSIZE(szText));
    Assert( dw );
    SetDlgItemText( hDlg, IDC_S_OPERATION, szText );
    SendMessage( hProg, PBM_SETPOS, 0, 0 );

    // Re-init these values
    MyContext.nCopied = 0;
    MyContext.nToBeCopied = 0;

    // Pre-fill the link list of things to extract from the cab with
    // things in the workstations REMINST.INF if needed. The section
    // can be missing if there is nothing to pre-fill.
    hr = AddInfSectionToExtractQueue( hinfReminst, L"ExtractFromCabs", &MyContext );
    if (FAILED( hr ))
        goto Cleanup;

    
    // compile the list of files
    lstrcpyn( szTempPath, g_Options.szInstallationPath, ARRAYSIZE(szTempPath) );
    ConcatenatePaths( szTempPath, g_Options.ProcessorArchitectureString, ARRAYSIZE(szTempPath));
    dw = pfnNetInfEnumFiles( szTempPath,
                             g_Options.ProcessorArchitecture,
                             &MyContext,
                             EnumNetworkDriversCallback );

    if ( dw != ERROR_SUCCESS )
    {
        hr = THR( HRESULT_FROM_WIN32( dw ) );
        MessageBoxFromError( hDlg, NULL, dw );
        goto Cleanup;
    }

    DebugMsg( "%d files need to be extracted from CABs.\n", MyContext.nToBeCopied );

    // Go through the CABs extracting only the ones in the link list
    if ( !SetupFindFirstLineW( hinfDrivers, L"Version", L"CabFiles", &context) )
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, NULL );
        goto Cleanup;
    }

    do
    {
        UINT uFieldCount = SetupGetFieldCount( &context );
        DebugMsg( "uFieldCount = %u\n", uFieldCount );
        for( UINT uField = 1; uField <= uFieldCount; uField++ )
        {
            WCHAR CabinetNameKey[64];
            INFCONTEXT DrvContext;
            WCHAR szCabinetName[ MAX_PATH ];

            dwLen = ARRAYSIZE( szCabinetName );
            if (!SetupGetStringField( &context, uField, CabinetNameKey, ARRAYSIZE( CabinetNameKey ), NULL ) ||
                !SetupFindFirstLine( hinfDrivers, L"Cabs", CabinetNameKey, &DrvContext) ||
                !SetupGetStringField( &DrvContext, 1, szCabinetName, dwLen, NULL )) {
                hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
                ErrorBox( hDlg, NULL );
                goto Cleanup;
            }

            lstrcpyn( szFilepath, g_Options.szInstallationPath, ARRAYSIZE(szFilepath));
            ConcatenatePaths( szFilepath, g_Options.ProcessorArchitectureString, ARRAYSIZE(szFilepath));
            ConcatenatePaths( szFilepath, szCabinetName, ARRAYSIZE(szFilepath));
            DebugMsg( "Iterating: %s\n", szFilepath );
            if ( szCabinetName[0] == L'\0' )
                continue; // skip blanks
            b = SetupIterateCabinet( szFilepath,
                                     0,
                                     EnumCabinetCallback,
                                     &MyContext );
            if ( !b )
            {
                hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
                ErrorBox( hDlg, szFilepath );
                goto Cleanup;
            }
        }
    } while ( SetupFindNextMatchLine( &context, L"CabFiles", &context ) );

    //
    // comment out this assert because it always fires -- some files we are 
    // queuing up (the ones in the ExtractFromCabs section) are not part of
    // any cab, so they are handled in the following section.
    //
#if 0
    // This should be empty - if not tell someone on the CHKed version.
    AssertMsg( pExtractionList == NULL, "Some network drivers are not in the CABs.\n\nIgnore this if you do not care." );
#endif
    if ( pExtractionList != NULL )
    {
        WCHAR szDstPath[ MAX_PATH ];

        // Ok. Someone decided that these files shouldn't be in the CAB. So
        // let's try to get them from outside the CAB.
        pNode = pExtractionList;
        while ( pNode )
        {
            DWORD dwConditionalFlags = 0;
            PWSTR CompressedName = NULL;
            //
            // see if we copied the file to the installation image already
            //
            // if the file is already at the destination, we can skip copying 
            // this file or just decompress it (and delete the compressed 
            // source).  In the case where the file is compressed, we may need
            // to tweak the file attributes so that the source file can be
            // successfully retreived.
            //
            lstrcpyn( szFilepath, g_Options.szInstallationPath, ARRAYSIZE(szFilepath));
            ConcatenatePaths( szFilepath, g_Options.ProcessorArchitectureString, ARRAYSIZE(szFilepath));
            ConcatenatePaths( szFilepath, pNode->szFilename, ARRAYSIZE(szFilepath));
            if ( !IsFileOrCompressedVersionPresent( szFilepath, &CompressedName )) {
                //
                // It's not already there, so check the source.
                //
                // Note that we don't care if the file is compressed or not, we
                // just want the file to be there, because setupapi can do the
                // rest without any help from us.
                //
                lstrcpyn( szFilepath, g_Options.szSourcePath, ARRAYSIZE(szFilepath));
                ConcatenatePaths( szFilepath, g_Options.ProcessorArchitectureString, ARRAYSIZE(szFilepath));
                ConcatenatePaths( szFilepath, pNode->szFilename, ARRAYSIZE(szFilepath));
                if ( !IsFileOrCompressedVersionPresent( szFilepath, &CompressedName )) {
                    //
                    // it's not there on the source - we must give up
                    //
                    hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
                    MessageBoxFromError( hDlg, pNode->szFilename, ERROR_FILE_NOT_FOUND );
                    goto Cleanup;
                }
            } else {
                if (CompressedName) {
                    //
                    // Make sure we can delete the compressed source file at 
                    // the destination path since we're going to decompress
                    // this file
                    //
                    DWORD dwAttribs = GetFileAttributes( CompressedName );
                    DebugMsg( "!!compressed name!!: %s\n", CompressedName );                    
                    if ( dwAttribs & FILE_ATTRIBUTE_READONLY )
                    {
                        dwAttribs &= ~FILE_ATTRIBUTE_READONLY;
                        SetFileAttributes( CompressedName, dwAttribs );
                    }
                    
                    dwConditionalFlags = SP_COPY_DELETESOURCE;

                    TraceFree( CompressedName );

                } else {
                    //
                    // the file is already expanded in the destination - NOP.
                    //
                    goto DeleteIt;
                }
            }

            // Update UI
            wcscpy( &MyContext.szCopyingString[ MyContext.dwCopyingLength ], pNode->szFilename );
            wcscpy( &MyContext.szCopyingString[ wcslen( MyContext.szCopyingString ) ], L"..." );
            SetWindowText( MyContext.hOperation, MyContext.szCopyingString );

            DebugMsg( "!!COPYING!!: %s\n", szFilepath );

            lstrcpyn( szDstPath, g_Options.szInstallationPath, ARRAYSIZE(szDstPath));
            ConcatenatePaths( szDstPath, g_Options.ProcessorArchitectureString, ARRAYSIZE(szDstPath));
            ConcatenatePaths( szDstPath, pNode->szFilename, ARRAYSIZE(szDstPath));

            b= SetupInstallFile( NULL,
                                 NULL,
                                 szFilepath,
                                 NULL,
                                 szDstPath,
                                 SP_COPY_SOURCE_ABSOLUTE | SP_COPY_NEWER_ONLY
                                 | SP_COPY_FORCE_NEWER | dwConditionalFlags,
                                 NULL,
                                 NULL );
            if ( !b )
            {
                hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
                ErrorBox( hDlg, szFilepath );
                goto Cleanup;
            }

            if ( KeepUIAlive( hDlg ) )
            {
                hr = HRESULT_FROM_WIN32( ERROR_CANCELLED );
                goto Cleanup;
            }

DeleteIt:
            // Update meter
            MyContext.nCopied++;
            SendMessage( MyContext.hProg, PBM_SETPOS, (5000 * MyContext.nCopied) / MyContext.nToBeCopied, 0 );

            pExtractionList = pNode->Next;
            LocalFree( pNode );
            pNode = pExtractionList;
        }
    }

    //
    // Finally, blow out all the files in these cabs
    //
    dw = LoadString( g_hinstance, IDS_EXPANDING_CABS, szText, ARRAYSIZE(szText));
    Assert( dw );
    SetDlgItemText( hDlg, IDC_S_OPERATION, szText );

    ExpandParams.hDlg          = hDlg;
    ExpandParams.hinf          = hinfReminst;
    ExpandParams.pszSection    = L"CabsToExpand";
    ExpandParams.pszSourcePath = g_Options.szSourcePath;
    ExpandParams.pszDestPath   = g_Options.szInstallationPath;
    ExpandParams.pszSubDir     = g_Options.ProcessorArchitectureString;

    // Expand CABs in background to keep UI alive
    hThread = CreateThread( NULL, NULL, (LPTHREAD_START_ROUTINE) ExpandCabList, (LPVOID) &ExpandParams, NULL, NULL );
    while ( WAIT_TIMEOUT == WaitForSingleObject( hThread, 10 ) )
    {
        KeepUIAlive( hDlg );
    }
    GetExitCodeThread( hThread, (ULONG*)&hr );
    DebugMsg( "Thread Exit Code was 0x%08x\n", hr );
    if ( FAILED( hr ) ) {
        goto Cleanup;
    }


    //
    // Make sure there's an oschoice loader in the \oschoice directory.  It
    // may not have been put there because it's difficult to get all
    // the oschoice loaders on the CDROM that was used to install the
    // server we're running on and the \oschoice directory is essentially
    // populated from the %windir%\system32\reminst directory.
    //
    // For that reason, if there's no oschoice loader present in our
    // \oschoice directory, then let's get it off the CDROM we're using
    // to create this client image.
    //

    //
    // Build a path to our oschoice loader.
    //
    lstrcpyn( szFilepath, g_Options.szOSChooserPath, ARRAYSIZE(szFilepath) );
    ConcatenatePaths( szFilepath, g_Options.ProcessorArchitectureString, ARRAYSIZE(szFilepath));
    
    //
    // d:\reminst\oschooser should have been built by now, but maybe not
    // d:\reminst\oschooser\<architecture>
    //
    CreateDirectoryPath( hDlg, szFilepath, NULL, TRUE );


    //
    // Build a path to our source file.
    //
    lstrcpyn(szTempPath, g_Options.szSourcePath, ARRAYSIZE(szTempPath));
    ConcatenatePaths( szTempPath, g_Options.ProcessorArchitectureString, ARRAYSIZE(szTempPath));

    // That loader file name will be different depending on our
    // architecture.
    switch( g_Options.ProcessorArchitecture ) {
        case PROCESSOR_ARCHITECTURE_IA64:
            ConcatenatePaths( szFilepath, L"oschoice.efi", ARRAYSIZE(szFilepath) );
            ConcatenatePaths( szTempPath, L"oschoice.efi", ARRAYSIZE(szTempPath) );
            break;
        default:
            // assume the x86 case.
            ConcatenatePaths( szFilepath, L"ntldr", ARRAYSIZE(szFilepath) );
            ConcatenatePaths( szTempPath, L"oschoice.exe", ARRAYSIZE(szTempPath) );
            break;
    }

    //
    // Now see if our oschoice loader is present.
    //
    dw = GetFileAttributes( szFilepath );
    if( dw == 0xFFFFFFFF ) {

        SetupInstallFile( NULL,         // InfHandle
                          NULL,         // pInfContext
                          szTempPath,   // Src
                          NULL,         // Src path
                          szFilepath,   // Dst
                          SP_COPY_SOURCE_ABSOLUTE | SP_COPY_NOOVERWRITE, // copy flags
                          NULL,         // copy callback
                          NULL );       // Context for callback.
    } else {
        DWORD   OSChoiceBuildNumber;

        //
        // The file's there, but for ia64 (and maybe x86), we need
        // to see if we should update the oschoice file.
        // to do that, we'll go check the version of the kernel on
        // our install media and compare it against the version of the
        // oschoice file.  If it's newer, we'll replace it.
        // We don't check against the oschoice on the CDROM because
        // it's compressed.
        //
        OSChoiceBuildNumber = MyGetFileVersionInfo( szFilepath );
        if( (OSChoiceBuildNumber != 0) &&
            (g_Options.dwBuildNumber > OSChoiceBuildNumber) ) {
            //
            // Copy it.
            //
            SetupInstallFile( NULL,         // InfHandle
                              NULL,         // pInfContext
                              szTempPath,   // Src
                              NULL,         // Src path
                              szFilepath,   // Dst
                              SP_COPY_SOURCE_ABSOLUTE, // copy flags
                              NULL,         // copy callback
                              NULL );       // Context for callback.
        }
    }

Cleanup:
    if ( hThread != NULL ) {
        CloseHandle( hThread );
    }

    if ( MyContext.pContext ) {
        SetupTermDefaultQueueCallback( MyContext.pContext );
    }

    if ( Queue != INVALID_HANDLE_VALUE ) {
        SetupCloseFileQueue( Queue );
    }

    if ( hinfLayout != INVALID_HANDLE_VALUE ) {
        SetupCloseInfFile( hinfLayout );
    }

    if ( hinfReminst != INVALID_HANDLE_VALUE ) {
        SetupCloseInfFile( hinfReminst );
    }

    if ( hinfDrivers != INVALID_HANDLE_VALUE ) {
        SetupCloseInfFile( hinfDrivers );
    }

    if ( hinfDosnet != INVALID_HANDLE_VALUE ) {
        SetupCloseInfFile( hinfDosnet );
    }

    if (FullDllPath) {
        TraceFree(FullDllPath);
    }

    if ( hBinlsvc != NULL ) {
        FreeLibrary( hBinlsvc );
    }

    AssertMsg( pExtractionList == NULL, "The list still isn't empty.\n\nThe image will be missing some drivers.\n" );
    while ( pExtractionList )
    {
        PLL_FILES_TO_EXTRACT pExtractNode = pExtractionList;
        pExtractionList = pExtractionList->Next;
        LocalFree( pExtractNode );
    }

    b = DeleteFile( g_Options.szWorkstationRemBootInfPath );
    AssertMsg( b, "Failed to delete temp\\REMINST.INF\nThis was just a warning and can be ignored." );
    g_Options.szWorkstationRemBootInfPath[0] = L'\0';

    SendMessage( hProg, PBM_SETPOS, 5000, 0 );
    SetDlgItemText( hDlg, IDC_S_OPERATION, L"" );

    HRETURN(hr);
}


//
// Modifies registry from the registry section of the REMINST.INF
//
HRESULT
ModifyRegistry( HWND hDlg )
{
    HRESULT hr = S_OK;
    HWND    hProg = GetDlgItem( hDlg, IDC_P_METER );
    WCHAR   szText[ SMALL_BUFFER_SIZE ];
    WCHAR   szSection[ SMALL_BUFFER_SIZE ];
    WCHAR   szPath[ MAX_PATH ];
    BOOL    b;
    DWORD   dw;
    UINT    spinstFlags = 0;
    
    TraceFunc( "ModifyRegistry( hDlg )\n" );

    Assert( g_Options.hinf != INVALID_HANDLE_VALUE );
    if ( g_Options.hinf == INVALID_HANDLE_VALUE )
        HRETURN( HRESULT_FROM_WIN32( ERROR_INVALID_HANDLE ) );    // need this handle!

    //
    // Update UI
    //
    SendMessage( hProg, PBM_SETRANGE, 0, MAKELPARAM( 0, 1 ) );
    dw = LoadString( g_hinstance, IDS_UPDATING_REGISTRY, szText, ARRAYSIZE(szText));
    Assert( dw );
    SetDlgItemText( hDlg, IDC_S_OPERATION, szText );

    dw = LoadString( g_hinstance, IDS_INF_SECTION, szSection, ARRAYSIZE(szSection));
    Assert( dw );

    //
    // Process the INF's registry section
    //
    if ( !g_Options.fRegistryIntact ) {
        spinstFlags |= SPINST_REGISTRY;
    }
    if ( !g_Options.fRegSrvDllsRegistered ) {
        spinstFlags |= SPINST_REGSVR;
    }

    b = SetupInstallFromInfSection( hDlg,           // hwndOwner
                                    g_Options.hinf, // inf handle
                                    szSection,      // name of component
                                    spinstFlags,
                                    NULL,           // relative key root
                                    NULL,           // source root path
                                    0,              // copy flags
                                    NULL,           // callback routine
                                    NULL,           // callback routine context
                                    NULL,           // device info set
                                    NULL);          // device info struct
    if ( !b ) {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, szSection );
        goto Error;
    }

    //
    // Add the Reg Key for TFTPD
    //
    if ( !g_Options.fTFTPDDirectoryFound ) {        
        HKEY hkey;
        dw = LoadString( g_hinstance, IDS_TFTPD_SERVICE_PARAMETERS, szPath, ARRAYSIZE(szPath));
        Assert( dw );

        if ( ERROR_SUCCESS == RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                                              szPath,
                                              0,    // options
                                              NULL, // class
                                              0,    // options
                                              KEY_WRITE,
                                              NULL, // security
                                              &hkey,
                                              &dw   ) ) {   // disposition
            ULONG lLen;
            LONG lErr;

            // paranoid
            Assert( wcslen(g_Options.szIntelliMirrorPath) < ARRAYSIZE(g_Options.szIntelliMirrorPath));
            lLen = lstrlen( g_Options.szIntelliMirrorPath ) * sizeof(WCHAR);
            lErr = RegSetValueEx( hkey,
                                  L"Directory",
                                  0, // reserved
                                  REG_SZ,
                                  (LPBYTE) g_Options.szIntelliMirrorPath,
                                  lLen );

            RegCloseKey( hkey );

            if ( lErr == ERROR_SUCCESS ) {
                DebugMsg( "TFTPD's Directory RegKey set.\n" );
            } else {
                hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
                ErrorBox( hDlg, szPath );
                DebugMsg( "HKLM\\%s could be not created.\n", szPath );
                goto Error;
            }
            
        } else {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, szPath );
            DebugMsg( "HKLM\\%s could be not created.\n", szPath );
            goto Error;
        }
    }

Error:
    SendMessage( hProg, PBM_SETPOS, 1 , 0 );
    SetDlgItemText( hDlg, IDC_S_OPERATION, L"" );
    HRETURN(hr);
}

//
// Stop a specific service
//
HRESULT
StopRBService(
    HWND hDlg,
    SC_HANDLE schSystem,
    LPWSTR pszService
    ) 
{
    HRESULT hr = S_OK;
    SC_HANDLE schService = NULL;
    SERVICE_STATUS ssStatus;
    BOOL b;
    DWORD dwErr;

    UNREFERENCED_PARAMETER(hDlg);

    TraceFunc( "StopRBService( ... )\n" );

    Assert( schSystem );
    Assert( pszService );
    
    schService = OpenService( schSystem,
                              pszService,
                              SERVICE_STOP | SERVICE_QUERY_STATUS );
    if ( !schService ) {
        goto Cleanup;
    }

    b = ControlService( schService, SERVICE_CONTROL_STOP, &ssStatus );
    

#define SLEEP_TIME 2000
#define LOOP_COUNT 30

    if ( !b && GetLastError() != ERROR_SERVICE_NOT_ACTIVE ) {
        dwErr = GetLastError( );
    } else {
        DWORD loopCount = 0;
        do {
            b = QueryServiceStatus( schService, &ssStatus);
            if ( !b ) {
                goto Cleanup;
            }
            if (ssStatus.dwCurrentState == SERVICE_STOP_PENDING) {
                if ( loopCount++ == LOOP_COUNT ) {
                    dwErr = ERROR_SERVICE_REQUEST_TIMEOUT;
                    break;
                }
                Sleep( SLEEP_TIME );
            } else {
                if ( ssStatus.dwCurrentState != SERVICE_STOPPED ) {
                    dwErr = ssStatus.dwWin32ExitCode;
                    if ( dwErr == ERROR_SERVICE_SPECIFIC_ERROR ) {
                        dwErr = ssStatus.dwServiceSpecificExitCode;
                    }
                } else {
                    dwErr = NO_ERROR;
                }
                break;
            }
        } while ( TRUE );
    }

Cleanup:
    if ( schService )
        CloseServiceHandle( schService );

    HRETURN(hr);

}

//
// Start a specific service
//
HRESULT
StartRBService(
    HWND      hDlg,
    SC_HANDLE schSystem,
    LPWSTR    pszService,
    LPWSTR    pszServiceName,
    LPWSTR    pszServiceDescription )
{
    HRESULT hr = S_OK;
    SC_HANDLE schService = NULL;
    SERVICE_STATUS ssStatus;
    BOOL b;
    DWORD dwErr;

    TraceFunc( "StartRBService( ... )\n" );

    Assert( schSystem );
    Assert( pszService );
    Assert( pszServiceName );

    schService = OpenService( schSystem,
                              pszService,
                              SERVICE_ALL_ACCESS );
    if ( !schService ) {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, pszServiceName );
        goto Cleanup;
    }

    b = ChangeServiceConfig( schService,
                             SERVICE_NO_CHANGE,
                             SERVICE_AUTO_START,
                             SERVICE_NO_CHANGE,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL );
    if ( !b ) {
        ErrorBox( hDlg, pszServiceName );
        hr = THR(S_FALSE);
    }

    // If the service is paused, continue it; else try to start it.

    b = QueryServiceStatus( schService, &ssStatus);
    if ( !b ) {
        ErrorBox( hDlg, pszServiceName );
        hr = THR(S_FALSE);
        goto Cleanup;
    }

    if ( ssStatus.dwCurrentState == SERVICE_PAUSED ) {
        b = ControlService( schService, SERVICE_CONTROL_CONTINUE, &ssStatus );
    } else {
        b = StartService( schService, 0, NULL );
    }

#define SLEEP_TIME 2000
#define LOOP_COUNT 30

    if ( !b ) {
        dwErr = GetLastError( );
    } else {
        DWORD loopCount = 0;
        do {
            b = QueryServiceStatus( schService, &ssStatus);
            if ( !b ) {
                ErrorBox( hDlg, pszServiceName );
                hr = THR(S_FALSE);
                goto Cleanup;
            }
            if ( ssStatus.dwCurrentState != SERVICE_RUNNING ) {
                if ( loopCount++ == LOOP_COUNT ) {

                    if ( (ssStatus.dwCurrentState == SERVICE_CONTINUE_PENDING) ||
                         (ssStatus.dwCurrentState == SERVICE_START_PENDING) ) {
                        
                        dwErr = ERROR_SERVICE_REQUEST_TIMEOUT;
                    } else {
                        dwErr = ssStatus.dwWin32ExitCode;
                        if ( dwErr == ERROR_SERVICE_SPECIFIC_ERROR ) {
                            dwErr = ssStatus.dwServiceSpecificExitCode;
                        }
                    }
                
                    break;
                }

                Sleep( SLEEP_TIME );
            } else {
                dwErr = NO_ERROR;
                break;
            }

        } while ( TRUE );
    }

    if ( dwErr != NO_ERROR ) {
        switch ( dwErr )
        {
        default:
            hr = THR( HRESULT_FROM_WIN32( dwErr ) );
            MessageBoxFromError( hDlg, pszServiceName, dwErr );
            break;

        case ERROR_SERVICE_ALREADY_RUNNING:
            {
                // Attempt to HUP the service
                SERVICE_STATUS ss;
                ControlService( schService, SERVICE_CONTROL_INTERROGATE, &ss );
            }
            break;
        }
    }
    else {
        // There is a pathological case where the service is deleted and then risetup restarts it.  When it does so, it doesn't set the description string.
        // We check here if there is a description for the service and if not we give it one.
        // We can't do this in CreateRemoteBootServices beacuse the services must be started.
        SERVICE_DESCRIPTION description;
        DWORD bytes_needed;
        if( QueryServiceConfig2( schService, SERVICE_CONFIG_DESCRIPTION, ( LPBYTE )&description, sizeof( description ), &bytes_needed )) {
            // Now, if there were a description the previous call would have failed with a ERROR_INSUFFICIENT_BUFFER error.
            // We do a quick check to make sure that everything is valid.
            Assert( description.lpDescription == NULL );
            // Now we can change it.
            description.lpDescription = pszServiceDescription;
            ChangeServiceConfig2( schService, SERVICE_CONFIG_DESCRIPTION, &description );
            // If that caused an error, we'll ignore it since the description is not essential to the operation of RIS.
        }
        // Whatever error the query threw we don't care as the description isn't sufficiently vital to RIS.
    }


Cleanup:
    if ( schService )
        CloseServiceHandle( schService );

    HRETURN(hr);
}

//
// Start the services needed for remote boot.
//
HRESULT
StartRemoteBootServices( HWND hDlg )
{
    WCHAR     szServiceName[ SMALL_BUFFER_SIZE ];
    WCHAR     szServiceDescription[ 1024 ]; // Size is the maximum allowed by ChangeServiceConfig2
    WCHAR     szText[ SMALL_BUFFER_SIZE ];
    SC_HANDLE schSystem;
    HWND      hProg = GetDlgItem( hDlg, IDC_P_METER );
    DWORD     dw;
    HRESULT   hr;
    HRESULT   hrFatalError = S_OK;
    HRESULT   hrStartFailure = S_OK;

    HWND hOper = GetDlgItem( hDlg, IDC_S_OPERATION );

    TraceFunc( "StartRemoteBootServices( hDlg )\n" );

    SendMessage( hProg, PBM_SETRANGE, 0, MAKELPARAM( 0, 2 ) );
    SendMessage( hProg, PBM_SETPOS, 0, 0 );

    szText[0]= L'\0';
    dw = LoadString( g_hinstance, IDS_STARTING_SERVICES, szText, ARRAYSIZE(szText));
    Assert( dw );
    SetDlgItemText( hDlg, IDC_S_OPERATION, szText );

    schSystem = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );
    Assert( schSystem );
    if ( !schSystem ) {
        hrFatalError = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        WCHAR szCaption[SMALL_BUFFER_SIZE];     
        szCaption[0] = L'\0';
        dw = LoadString( g_hinstance, IDS_OPENING_SERVICE_MANAGER_TITLE, szCaption, SMALL_BUFFER_SIZE );
        Assert( dw );
        ErrorBox( hDlg, szCaption );
        goto Cleanup;
    }

    //
    // start TFTPD services
    //
    szServiceName[0]= L'\0';
    dw = LoadString( g_hinstance, IDS_TFTPD_SERVICENAME, szServiceName, ARRAYSIZE(szServiceName));
    Assert( dw );
    szServiceDescription[0]= L'\0';
    dw = LoadString( g_hinstance, IDS_TFTPD_DESCRIPTION, szServiceDescription, ARRAYSIZE(szServiceDescription));
    Assert( dw );
    SetWindowText( hOper, szServiceName );

    hr = StartRBService( hDlg, schSystem, L"TFTPD", szServiceName, szServiceDescription );
    if ( FAILED(hr) ) {
        hrFatalError = hr;
        goto Cleanup;
    } else if ( hr != S_OK ) {
        hrStartFailure = hr;
    }

    //
    // start BINLSVC services
    //
    szServiceName[0]= L'\0';
    dw = LoadString( g_hinstance, IDS_BINL_SERVICENAME, szServiceName, ARRAYSIZE(szServiceName));
    Assert( dw );
    szServiceDescription[0]= L'\0';
    dw = LoadString( g_hinstance, IDS_BINL_DESCRIPTION, szServiceDescription, ARRAYSIZE(szServiceDescription));
    Assert( dw );
    SetWindowText( hOper, szServiceName );    
    if (!g_Options.fBINLSCPFound) {
        StopRBService( hDlg, schSystem, L"BINLSVC" );
    }

    hr = StartRBService( hDlg, schSystem, L"BINLSVC", szServiceName, szServiceDescription );
    if ( FAILED(hr) ) {
        hrFatalError = hr;
        goto Cleanup;
    } else if ( hr != S_OK ) {
        hrStartFailure = hr;
    }

    //
    // start GROVELER services
    //
    szServiceName[0]= L'\0';
    dw = LoadString( g_hinstance, IDS_SISGROVELER_SERVICENAME, szServiceName, ARRAYSIZE(szServiceName));
    Assert( dw );
    szServiceDescription[0]= L'\0';
    dw = LoadString( g_hinstance, IDS_SISGROVELER_DESCRIPTION, szServiceDescription, ARRAYSIZE(szServiceDescription));
    Assert( dw );
    SetWindowText( hOper, szServiceName );

    hr = StartRBService( hDlg, schSystem, L"GROVELER", szServiceName, szServiceDescription );
    if ( FAILED(hr) ) {
        hrFatalError = hr;
        goto Cleanup;
    } else if ( hr != S_OK ) {
        hrStartFailure = hr;
    }

Cleanup:
    SetDlgItemText( hDlg, IDC_S_OPERATION, L"" );

    if ( schSystem )
        CloseServiceHandle( schSystem );

    if ( hrFatalError != S_OK ) {
        hr = hrFatalError;
    } else if ( hrStartFailure != S_OK ) {
        hr = hrStartFailure;
    } else {
        hr = S_OK;
    }

    RETURN(hr);
}

//
// create IntelliMirror share
//
HRESULT
CreateRemoteBootShare( HWND hDlg )
{
    SHARE_INFO_502  si502;
    WCHAR szRemark[ SMALL_BUFFER_SIZE ];
    WCHAR szRemoteBoot[ SMALL_BUFFER_SIZE ];
    WCHAR szText[ SMALL_BUFFER_SIZE ];
    WCHAR szPath[ 129 ];
    DWORD dwErr;
    DWORD dw;
    HRESULT hr;

    TraceFunc( "CreateRemoteBootShare( hDlg )\n" );

    dw = LoadString( g_hinstance, IDS_CREATINGSHARES, szText, ARRAYSIZE(szText));
    Assert( dw );
    SetDlgItemText( hDlg, IDC_S_OPERATION, szText );

    dw = LoadString( g_hinstance, IDS_REMOTEBOOTSHAREREMARK, szRemark, ARRAYSIZE(szRemark));
    Assert( dw );
    dw = LoadString( g_hinstance, IDS_REMOTEBOOTSHARENAME, szRemoteBoot, ARRAYSIZE(szRemoteBoot));
    Assert( dw );

    lstrcpyn( szPath, g_Options.szIntelliMirrorPath, ARRAYSIZE(szPath) );
    if ( wcslen( szPath ) == 2 ) {
        wcscat( szPath, L"\\" );
    }

    si502.shi502_netname             = szRemoteBoot;
    si502.shi502_type                = STYPE_DISKTREE;
    si502.shi502_remark              = szRemark;
    si502.shi502_permissions         = ACCESS_ALL;
    si502.shi502_max_uses            = (DWORD)(-1);   // unlimited
    si502.shi502_current_uses        = 0;
    si502.shi502_path                = szPath;
    si502.shi502_passwd              = NULL; // ignored
    si502.shi502_reserved            = 0;    // must be zero
    si502.shi502_security_descriptor = NULL;
    Assert( wcslen(g_Options.szIntelliMirrorPath) < ARRAYSIZE(g_Options.szIntelliMirrorPath) ); // paranoid

    dwErr = NetShareAdd( NULL, 502, (LPBYTE) &si502, NULL );
    switch ( dwErr )
    {
        // ignore these
    case NERR_Success:
    case NERR_DuplicateShare:
        dwErr = ERROR_SUCCESS;
        break;

    default:
        MessageBoxFromError( hDlg, g_Options.szIntelliMirrorPath, dwErr );
        goto Error;
    }

#ifdef REMOTE_BOOT
#error("Remote boot is dead!! Turn off the REMOTE_BOOT flag.")
    si1005.shi1005_flags = CSC_CACHE_AUTO_REINT;
    NetShareSetInfo( NULL, szRemoteBoot, 1005, (LPBYTE)&si1005, &dwErr );
    switch ( dwErr )
    {
        // ignore these
    case NERR_Success:
        dwErr = ERROR_SUCCESS;
        break;

    default:
        MessageBoxFromError( hDlg, g_Options.szIntelliMirrorPath, dwErr );
    }
#endif // REMOTE_BOOT

Error:
    hr = THR( HRESULT_FROM_WIN32(dwErr) );
    HRETURN(hr);
}


typedef int (WINAPI * REGISTERDLL)( void );

//
// Register Dlls
//
// If hDlg is NULL, this will fail silently.
//
HRESULT
RegisterDll( HWND hDlg, LPWSTR pszDLLPath )
{
    REGISTERDLL pfnRegisterDll = NULL;
    HINSTANCE hLib;
    HRESULT hr = S_OK;

    TraceFunc( "RegisterDll( ... )\n" );

    //
    // We'll try to register it locally, but if fails MMC should
    // grab it from the DS and register it on the machine.
    //
    hLib = LoadLibrary( pszDLLPath );
    AssertMsg( hLib, "RegisterDll: Missing DLL?" );
    if ( !hLib ) {
        hr = S_FALSE;
        goto Cleanup;
    }

    pfnRegisterDll = (REGISTERDLL) GetProcAddress( hLib, "DllRegisterServer" );
    AssertMsg( pfnRegisterDll, "RegisterDll: Missing entry point?" );
    if ( pfnRegisterDll != NULL )
    {
        hr = THR( pfnRegisterDll() );
        if ( FAILED(hr) && hDlg ) {
            MessageBoxFromStrings( hDlg,
                                   IDS_REGISTER_IMADMIU_FAILED_CAPTION,
                                   IDS_REGISTER_IMADMIU_FAILED_TEXT,
                                   MB_OK );
        }
    }

    FreeLibrary( hLib );

Cleanup:
    HRETURN(hr);
}


//
// Creates the services needed for remote boot.
//
HRESULT
CreateRemoteBootServices( HWND hDlg )
{
    HRESULT   hr = S_OK;
    WCHAR     szServiceName[ SMALL_BUFFER_SIZE ]; // TFTPD service name
    WCHAR     szText[ SMALL_BUFFER_SIZE ];      // general use
    WCHAR     szGroup[ SMALL_BUFFER_SIZE ];
    SC_HANDLE schSystem;        // Handle to System Services
    SC_HANDLE schService;       // Temp handle to new service

    DWORD     dw;               // general use
    LPARAM    lRange;

    HWND hProg = GetDlgItem( hDlg, IDC_P_METER );
    HWND hOper = GetDlgItem( hDlg, IDC_S_OPERATION );

    TraceFunc( "CreateRemoteBootServices( hDlg )\n" );

    lRange = 0;
    if ( !g_Options.fBINLServiceInstalled ) {
        lRange++;
    }
    if ( !g_Options.fBINLSCPFound ) {
        lRange++;
    }
    if ( !g_Options.fTFTPDServiceInstalled ) {
        lRange++;
    }
    if ( !g_Options.fSISServiceInstalled ) {
        lRange++;
    }
    lRange = MAKELPARAM( 0, lRange );

    SendMessage( hProg, PBM_SETRANGE, 0, lRange );
    SendMessage( hProg, PBM_SETPOS, 0, 0 );

    //
    // Display what we are doing in operations area
    //
    dw = LoadString( g_hinstance, IDS_STARTING_SERVICES, szText, ARRAYSIZE(szText));
    Assert( dw );
    SetWindowText( hOper, szText );

    //
    // Open System Services Manager
    //
    schSystem = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );
    Assert( schSystem );
    if ( !schSystem ) {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        WCHAR szCaption[SMALL_BUFFER_SIZE]; 
        dw = LoadString( g_hinstance, IDS_OPENING_SERVICE_MANAGER_TITLE, szCaption, SMALL_BUFFER_SIZE );
        Assert( dw );
        ErrorBox( hDlg, szCaption );
        goto Cleanup;
    }

    //
    // Create TFTPD service
    //
    if ( !g_Options.fTFTPDServiceInstalled ) {
        dw = LoadString( g_hinstance, IDS_TFTPD_SERVICENAME, szServiceName, ARRAYSIZE(szServiceName));
        Assert( dw );
        dw = LoadString( g_hinstance, IDS_TFTPD, szText, ARRAYSIZE(szText));
        Assert( dw );
        SetWindowText( hOper, szServiceName );
        dw = LoadString( g_hinstance, IDS_TFTPD_PATH, szText, ARRAYSIZE(szText));
        Assert( dw );
        schService = CreateService(
                        schSystem,
                        L"TFTPD",
                        szServiceName,
                        STANDARD_RIGHTS_REQUIRED | SERVICE_START,
                        SERVICE_WIN32_OWN_PROCESS,
                        SERVICE_AUTO_START,
                        SERVICE_ERROR_NORMAL,
                        szText,
                        NULL,
                        NULL,
                        L"Tcpip\0",
                        NULL,
                        NULL );
        if ( !schService ) {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, szServiceName );
        } else {
            CloseServiceHandle( schService );
        }

        SendMessage( hProg, PBM_DELTAPOS, 1 , 0 );
    }

    //
    // Create BINLSVC
    //
    if ( !g_Options.fBINLServiceInstalled ) {
        dw = LoadString( g_hinstance, IDS_BINL_SERVICENAME, szServiceName, ARRAYSIZE(szServiceName));
        Assert( dw );
        SetWindowText( hOper, szServiceName );
        dw = LoadString( g_hinstance, IDS_BINL_PATH, szText, ARRAYSIZE(szText));
        Assert( dw );
        schService = CreateService(
                        schSystem,
                        L"BINLSVC",
                        szServiceName,
                        STANDARD_RIGHTS_REQUIRED | SERVICE_START,
                        SERVICE_WIN32_SHARE_PROCESS,
                        SERVICE_AUTO_START,
                        SERVICE_ERROR_NORMAL,
                        szText,
                        NULL,
                        NULL,
                        L"Tcpip\0LanmanServer\0",
                        NULL,
                        NULL );
        if ( !schService ) {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, szServiceName );
        } else {
            CloseServiceHandle( schService );
        }

        SendMessage( hProg, PBM_DELTAPOS, 1 , 0 );
    }

    //
    // Create SIS
    //
    if ( !g_Options.fSISServiceInstalled ) {
        dw = LoadString( g_hinstance, IDS_SIS_SERVICENAME, szServiceName, ARRAYSIZE(szServiceName));
        Assert( dw );
        SetWindowText( hOper, szServiceName );
        dw = LoadString( g_hinstance, IDS_SIS_PATH, szText, ARRAYSIZE(szText));
        Assert( dw );
        dw = LoadString( g_hinstance, IDS_SIS_GROUP, szGroup, ARRAYSIZE(szGroup));
        Assert( dw );
        schService = CreateService(
                        schSystem,
                        L"SIS",
                        szServiceName,
                        STANDARD_RIGHTS_REQUIRED | SERVICE_START,
                        SERVICE_FILE_SYSTEM_DRIVER,
                        SERVICE_BOOT_START,
                        SERVICE_ERROR_NORMAL,
                        szText,
                        szGroup,
                        NULL,
                        NULL,
                        NULL,
                        NULL );
        if ( !schService ) {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, szServiceName );
        } else {
            CloseServiceHandle( schService );
        }

        SendMessage( hProg, PBM_DELTAPOS, 1 , 0 );
    }

    //
    // Create SIS Groveler
    //
    if ( !g_Options.fSISGrovelerServiceInstalled ) {
        dw = LoadString( g_hinstance, IDS_SISGROVELER_SERVICENAME, szServiceName, ARRAYSIZE(szServiceName));
        Assert( dw );
        SetWindowText( hOper, szServiceName );
        dw = LoadString( g_hinstance, IDS_SISGROVELER_PATH, szText, ARRAYSIZE(szText));
        Assert( dw );
        dw = LoadString( g_hinstance, IDS_SISGROVELER_GROUP, szGroup, ARRAYSIZE(szGroup));
        Assert( dw );
        schService = CreateService(
                        schSystem,
                        L"Groveler",
                        szServiceName,
                        STANDARD_RIGHTS_REQUIRED | SERVICE_START,
                        SERVICE_WIN32_OWN_PROCESS,
                        SERVICE_AUTO_START,
                        SERVICE_ERROR_NORMAL,
                        szText,
                        NULL,
                        NULL,
                        L"SIS\0",
                        NULL,
                        NULL );
        if ( !schService ) {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, szServiceName );
        } else {
            CloseServiceHandle( schService );
        }

        SendMessage( hProg, PBM_DELTAPOS, 1 , 0 );
    }

    //
    // Create the BINL SCP
    //
    if ( !g_Options.fBINLSCPFound ) {
        dw = LoadString( g_hinstance, IDS_BINL_SERVICECONTROLPOINT, szText, ARRAYSIZE(szText) );
        Assert( dw );
        SetWindowText( hOper, szText );

        hr = CreateSCP( hDlg );

        SendMessage( hProg, PBM_DELTAPOS, 1 , 0 );
    }



Cleanup:
    SetDlgItemText( hDlg, IDC_S_OPERATION, L"" );
    HRETURN(hr);
}

//
// Reads the server's layout.inf file for disc name, tag file and
// optional sub-dir. All parameters are assumed to be MAX_PATH in
// size except the tag files which can only be 10.3 format.
//
HRESULT
RetrieveServerDiscInfo(
    HWND   hDlg,
    LPWSTR pszDiscName,
    LPWSTR pszTagFile,
    LPWSTR pszSubDir )
{
    TraceFunc("RetrieveServerDiscInfo()\n");

    HRESULT hr = S_OK;
    HINF    hinf = INVALID_HANDLE_VALUE;
    UINT   uLineNum;
    INFCONTEXT context;
    WCHAR   szSourcePath[ MAX_PATH ];
    BOOL b;

    if ( !GetEnvironmentVariable(L"windir", szSourcePath, ARRAYSIZE(szSourcePath)) )
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, szSourcePath );
        goto Cleanup;
    }
    wcscat( szSourcePath, L"\\inf\\layout.inf" );

    hinf = SetupOpenInfFile( szSourcePath, NULL, INF_STYLE_WIN4, &uLineNum);
    if ( hinf == INVALID_HANDLE_VALUE ) {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, szSourcePath );
        goto Cleanup;
    }


    b = FALSE;
    if ( g_Options.ProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL ) {
        b = SetupFindFirstLine( hinf, L"SourceDisksNames.x86", L"1", &context );
    } else if ( g_Options.ProcessorArchitecture  == PROCESSOR_ARCHITECTURE_IA64 ) {
        b = SetupFindFirstLine( hinf, L"SourceDisksNames.ia64", L"1", &context );
    }

    if ( !b )
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, szSourcePath );
        goto Cleanup;
    }



    if ( pszDiscName ) {
        b = SetupGetStringField( &context, 1, pszDiscName, MAX_PATH, NULL );
        if ( !b )
        {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, szSourcePath );
            goto Cleanup;
        }
    }

    if ( pszTagFile )
    {
        b = SetupGetStringField( &context, 2, pszTagFile, 14 /* 10.3 + NULL */, NULL );
        if ( !b )
        {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, szSourcePath );
            goto Cleanup;
        }
    }

    if ( pszSubDir )
    {
        b = SetupGetStringField( &context, 4, pszSubDir, MAX_PATH, NULL );
        if ( !b )
        {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, szSourcePath );
            goto Cleanup;
        }
    }

Cleanup:
    if ( hinf != INVALID_HANDLE_VALUE )
        SetupCloseInfFile( hinf );

    HRETURN(hr);
}

//
// Copies the files needed by the server from where the server
// was orginally installed from.
//
HRESULT
CopyServerFiles( HWND hDlg )
{
    HRESULT hr = S_OK;
    HSPFILEQ Queue = INVALID_HANDLE_VALUE;
    WCHAR   szSection[ SMALL_BUFFER_SIZE ];
    HWND    hProg    = GetDlgItem( hDlg, IDC_P_METER );
    DWORD   dwCount  = 0;
    DWORD   dw;
    BOOL    b;
    UINT    iResult;
    WCHAR   szServerDiscName[ MAX_PATH ] = { L'\0' };
    MYCONTEXT MyContext;
    INFCONTEXT context;
    
    ZeroMemory( &MyContext, sizeof(MyContext) );

    TraceFunc( "CopyServerFiles( hDlg )\n" );

    Assert( g_Options.hinf != INVALID_HANDLE_VALUE );
    if ( g_Options.hinf == INVALID_HANDLE_VALUE ) {
        hr = E_FAIL;   // need this handle!
        goto Cleanup;
    }

    //
    // Setup and display next section of dialog
    //
    SendMessage( hProg, PBM_SETRANGE, 0, MAKELPARAM(0, 5000 ));
    SendMessage( hProg, PBM_SETPOS, 0, 0 );

    //
    // Ask for CD if any of the Services files are missing.
    // Or if the System32\RemBoot directory is missing and we
    // need the OS Chooser files (not screens).
    //
    if ( !g_Options.fBINLFilesFound
      || !g_Options.fTFTPDFilesFound
      || !g_Options.fSISFilesFound
      || !g_Options.fSISGrovelerFilesFound
      || !g_Options.fRegSrvDllsFilesFound
      || ( !g_Options.fRemBootDirectory && !g_Options.fOSChooserInstalled ) ) {

        WCHAR   szSourcePath[ MAX_PATH ];
        WCHAR   szServerTagFile[ 14 ] = { L'\0' };
        WCHAR   szInsertMedia[ 64 ];
        WCHAR   szServerSubDir[ MAX_PATH ] = { L'\0' };
        
        DebugMsg( "Queue and copy reminst files\n" );

        //
        // Ask user to check the CDROM to make sure the right CD is in the drive.
        // We skip this if it was installed from a share.
        //
        szInsertMedia[63] = L'\0';
        dw = LoadString( g_hinstance, IDS_INSERT_MEDIA, szInsertMedia, ARRAYSIZE(szInsertMedia) );
        Assert( dw );

        hr = RetrieveServerDiscInfo( hDlg, szServerDiscName, szServerTagFile, szServerSubDir );
        // if it fails, try to proceed anyway to see if the user is smart enough
        // to fix the problem.

        iResult = SetupPromptForDisk( hDlg,               // parent window of the dialog box
                                      szInsertMedia,      // optional, title of the dialog box
                                      szServerDiscName,   // optional, name of disk to insert
                                      NULL,               // optional, expected source path
                                      szServerTagFile,    // name of file needed
                                      szServerTagFile,    // optional, source media tag file
                                      IDF_CHECKFIRST | IDF_NODETAILS | IDF_NOSKIP, // specifies dialog box behavior
                                      szSourcePath,       // receives the source location
                                      MAX_PATH,           // size of the supplied buffer
                                      NULL );             // optional, buffer size needed
        if ( iResult != DPROMPT_SUCCESS )
        {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            goto Cleanup;
        }

        szSection[SMALL_BUFFER_SIZE-1] = L'\0';
        dw = LoadString( g_hinstance, IDS_INF_SECTION, szSection, ARRAYSIZE(szSection) );
        Assert( dw );

        //
        // Create the Queue
        //
        Queue = SetupOpenFileQueue( );

        //
        // Add the files
        //
        b = SetupInstallFilesFromInfSection( g_Options.hinf,
                                             NULL,
                                             Queue,
                                             szSection,
                                             szSourcePath,
                                             SP_COPY_WARNIFSKIP | SP_COPY_FORCE_NEWER
                                             | SP_COPY_NEWER_ONLY ); // copy flags
        Assert( b );
        if ( !b ) {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, szSection );
            goto Cleanup;
        }

        //
        // Add a section that is done during textmode setup
        //
        b = SetupQueueCopySection(  Queue,
                                    szSourcePath,
                                    g_Options.hinf,
                                    NULL,
                                    L"REMINST.OtherSystemFiles",
                                    SP_COPY_WARNIFSKIP | SP_COPY_FORCE_NEWER
                                    | SP_COPY_NEWER_ONLY ); // copy flags
        Assert( b );
        if ( !b ) {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, L"REMINST.OtherSystemFiles" );
            goto Cleanup;
        }

        //
        // This information will be passed to CopyFileCallback() as
        // the Context.
        //
        MyContext.nToBeCopied        = 12;  // todo: generate this dynamically
        MyContext.nCopied            = 0;
        MyContext.pContext           = SetupInitDefaultQueueCallbackEx(NULL,(HWND)INVALID_HANDLE_VALUE,0,0,NULL);
        MyContext.hProg              = hProg;
        MyContext.hOperation         = GetDlgItem( hDlg, IDC_S_OPERATION );
        MyContext.hDlg               = hDlg;
        MyContext.dwCopyingLength =
            LoadString( g_hinstance, IDS_COPYING, MyContext.szCopyingString, ARRAYSIZE(MyContext.szCopyingString));
        b = SetupCommitFileQueue( NULL, Queue, (PSP_FILE_CALLBACK) CopyFilesCallback, (PVOID) &MyContext );
        if ( !b ) {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, NULL );
        }

        SetupTermDefaultQueueCallback( MyContext.pContext );
        ZeroMemory( &MyContext, sizeof(MyContext) );

        SetupCloseFileQueue( Queue );
        Queue = INVALID_HANDLE_VALUE;

        // recheck
        HRESULT hr2 = CheckInstallation( );
        if ( FAILED(hr2) ) {
            hr = THR( hr2 );
            goto Cleanup;
        }

        // because of the recheck, this flag should be set
        Assert( g_Options.fRemBootDirectory );
        
        g_Options.fRemBootDirectory = TRUE;
    }

    //
    // Move OS Chooser files to the IntelliMirror\OSChooser tree.
    //
    if ( !g_Options.fOSChooserInstalled
      && g_Options.fRemBootDirectory ) {

        DebugMsg( "Queue and copy os chooser files\n" );

        Assert( g_Options.fIMirrorDirectory );
        Assert( g_Options.fOSChooserDirectory );

        b = SetupFindFirstLine( g_Options.hinf, L"OSChooser", NULL, &context );
        AssertMsg( b, "Missing section?" );
        if ( !b ) {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        }

        if ( szServerDiscName[0] == L'\0' )
        {
            hr = RetrieveServerDiscInfo( hDlg, szServerDiscName, NULL, NULL );
            // if it fails, try to proceed anyway to see if the user is smart enough
            // to fix the problem.
        }

        dwCount = 0;

        //
        // Create the Queue
        //
        Queue = SetupOpenFileQueue( );

        while ( b )
        {
            WCHAR  szSrcFile[ MAX_PATH ];
            WCHAR  szDestFile[ MAX_PATH ];
            LPWSTR pszDest = NULL;

            dw = SetupGetFieldCount( &context );

            if ( dw > 1 ) {
                b = SetupGetStringField( &context, 1, szDestFile, ARRAYSIZE(szDestFile) , NULL );
                AssertMsg( b, "Missing field?" );
                if ( b ) {
                    b = SetupGetStringField( &context, 2, szSrcFile, ARRAYSIZE(szSrcFile), NULL );
                    AssertMsg( b, "Missing field?" );
                    pszDest = szDestFile;
                }
            } else {
                b = SetupGetStringField( &context, 1, szSrcFile, ARRAYSIZE(szSrcFile), NULL );
                AssertMsg( b, "Missing field?" );
            }

            if ( !b ) {
                hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
                goto SkipIt;
            }

            b = SetupQueueCopy( Queue,
                                g_Options.szRemBootDirectory,
                                NULL,
                                szSrcFile,
                                szServerDiscName,
                                NULL,
                                g_Options.szOSChooserPath,
                                pszDest,
                                SP_COPY_NEWER_ONLY | SP_COPY_FORCE_NEWER
                                | SP_COPY_WARNIFSKIP | SP_COPY_SOURCEPATH_ABSOLUTE );
            if ( !b ) {
                hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
                ErrorBox( NULL, szSrcFile );
                goto SkipIt;
            }

            // increment file count
            dwCount++;

SkipIt:
            b = SetupFindNextLine( &context, &context );
        }

        b = SetupFindFirstLine( g_Options.hinf, L"OSChooser.NoOverwrite", NULL, &context );
        AssertMsg( b, "Missing section?" );
        if ( !b ) {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        }

        while ( b )
        {
            WCHAR  szSrcFile[ MAX_PATH ];
            WCHAR  szDestFile[ MAX_PATH ];
            LPWSTR pszDest = NULL;

            dw = SetupGetFieldCount( &context );

            if ( dw > 1 ) {
                b = SetupGetStringField( &context, 1, szDestFile, ARRAYSIZE(szDestFile) , NULL );
                AssertMsg( b, "Missing field?" );
                if ( b ) {
                    b = SetupGetStringField( &context, 2, szSrcFile, ARRAYSIZE(szSrcFile) , NULL );
                    AssertMsg( b, "Missing field?" );
                    pszDest = szDestFile;
                }
            } else {
                b = SetupGetStringField( &context, 1, szSrcFile, ARRAYSIZE(szSrcFile) , NULL );
                AssertMsg( b, "Missing field?" );
            }

            if ( !b ) {
                hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
                goto SkipNonCritical;
            }

            b = SetupQueueCopy( Queue,
                                g_Options.szRemBootDirectory,
                                NULL,
                                szSrcFile,
                                szServerDiscName,
                                NULL,
                                g_Options.szOSChooserPath,
                                pszDest,
                                SP_COPY_NOOVERWRITE
                                | SP_COPY_WARNIFSKIP 
                                | SP_COPY_SOURCEPATH_ABSOLUTE );
            if ( !b ) {
                hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
                ErrorBox( NULL, szSrcFile );
                goto SkipNonCritical;
            }

            // increment file count
            dwCount++;

SkipNonCritical:
            b = SetupFindNextLine( &context, &context );
        }


        //
        // This information will be passed to CopyFileCallback() as
        // the Context.
        //
        MyContext.nToBeCopied        = dwCount;
        MyContext.nCopied            = 0;
        MyContext.pContext           = SetupInitDefaultQueueCallbackEx(NULL,(HWND)INVALID_HANDLE_VALUE,0,0,NULL);
        MyContext.hProg              = hProg;
        MyContext.hDlg               = hDlg;
        MyContext.hOperation         = GetDlgItem( hDlg, IDC_S_OPERATION );
        MyContext.dwCopyingLength =
            LoadString( g_hinstance, IDS_COPYING, MyContext.szCopyingString, ARRAYSIZE(MyContext.szCopyingString));

        b = SetupCommitFileQueue( NULL, Queue, (PSP_FILE_CALLBACK) CopyFilesCallback, (PVOID) &MyContext );
        if ( !b ) {
            DWORD dwErr = GetLastError( );
            hr = THR( HRESULT_FROM_WIN32( dwErr ) );
            switch ( dwErr )
            {
            case ERROR_CANCELLED:
                goto Cleanup;
                break; // expected

            default:
                MessageBoxFromError( hDlg, NULL, dwErr );
                goto Cleanup;
                break;
            }
        }

    }
    

Cleanup:
    if ( MyContext.pContext )
        SetupTermDefaultQueueCallback( MyContext.pContext );

    if ( Queue != INVALID_HANDLE_VALUE )
        SetupCloseFileQueue( Queue );

    HRETURN(hr);
}

//
// CopyTemplateFiles( )
//
HRESULT
CopyTemplateFiles( HWND hDlg )
{
    HRESULT hr = S_OK;
    WCHAR sz[ SMALL_BUFFER_SIZE ];
    WCHAR szSourcePath[ MAX_PATH ];
    WCHAR szTemplatePath[ MAX_PATH ];
    WCHAR szFileName[ MAX_PATH ];
    BOOL  fNotOverwrite;
    BOOL  b;
    DWORD dw;

    TraceFunc( "CopyTemplateFiles( ... )\n" );

    dw = LoadString( g_hinstance, IDS_UPDATING_SIF_FILE, sz, ARRAYSIZE(sz) );
    Assert( dw );
    SetDlgItemText( hDlg, IDC_S_OPERATION, sz );

    dw = LoadString( g_hinstance, IDS_DEFAULT_SIF, szFileName, ARRAYSIZE(szFileName) );
    Assert( dw );

    //
    // Create the path "IntelliMirror\Setup\English\nt50.wks\i386\default.sif"
    //
    lstrcpyn( szSourcePath, g_Options.szInstallationPath, ARRAYSIZE(szSourcePath));
    ConcatenatePaths( szSourcePath, g_Options.ProcessorArchitectureString, ARRAYSIZE(szSourcePath));
    ConcatenatePaths( szSourcePath, szFileName, ARRAYSIZE(szSourcePath));
    
    Assert( wcslen( szSourcePath ) < ARRAYSIZE(szSourcePath) );

    //
    // Create the path "IntelliMirror\Setup\English\nt50.wks\i386\Templates"
    //
    lstrcpyn( szTemplatePath, g_Options.szInstallationPath, ARRAYSIZE(szTemplatePath));
    ConcatenatePaths( szTemplatePath, g_Options.ProcessorArchitectureString, ARRAYSIZE(szTemplatePath));
    ConcatenatePaths( szTemplatePath, L"Templates", ARRAYSIZE(szTemplatePath));
    
    Assert( wcslen( szTemplatePath ) < ARRAYSIZE(szTemplatePath) );
    if ( 0xFFFFffff == GetFileAttributes( szTemplatePath ) ) {
        b = CreateDirectory( szTemplatePath, NULL );
        if ( !b ) {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, szTemplatePath );
            goto Error;
        }
    }

    //
    // Create the path "IntelliMirror\Setup\English\nt50.wks\i386\Templates\default.sif"
    //
    ConcatenatePaths( szTemplatePath, szFileName, ARRAYSIZE(szTemplatePath));    
    Assert( wcslen( szTemplatePath ) < ARRAYSIZE(szTemplatePath) );

    DebugMsg( "Copying %s to %s...\n", szSourcePath, szTemplatePath );
    fNotOverwrite = TRUE;
    while ( hr == S_OK && !CopyFile( szSourcePath, szTemplatePath, fNotOverwrite) )
    {
        DWORD dwErr = GetLastError( );

        switch (dwErr)
        {
        case ERROR_FILE_EXISTS:
            {
                dw = LoadString( g_hinstance, IDS_OVERWRITE_TEXT, sz, ARRAYSIZE(sz) );
                Assert( dw );

                if ( IDYES == MessageBox( hDlg, sz, szFileName, MB_YESNO ) )
                {
                    fNotOverwrite = FALSE;
                }
                else
                {
                    OPENFILENAME ofn;

                    dw = LoadString( g_hinstance, IDS_SAVE_SIF_TITLE, sz, ARRAYSIZE(sz) );
                    Assert( dw );

GetFileNameAgain:
                    memset( &ofn, 0, sizeof( ofn ) );
                    ofn.lStructSize = sizeof( ofn );
                    ofn.hwndOwner = hDlg;
                    ofn.hInstance = g_hinstance;
                    ofn.lpstrFilter = L"Unattended Setup Answer Files\0*.SIF\0\0";
                    ofn.lpstrFile = szTemplatePath;
                    ofn.nMaxFile = MAX_PATH;
                    ofn.lpstrInitialDir = szTemplatePath;
                    ofn.lpstrTitle = sz;
                    ofn.Flags = OFN_CREATEPROMPT |
                                OFN_NOCHANGEDIR |
                                OFN_NONETWORKBUTTON |
                                OFN_NOREADONLYRETURN |
                                OFN_OVERWRITEPROMPT |
                                OFN_PATHMUSTEXIST;
                    ofn.nFileOffset = (WORD)(lstrlen( szTemplatePath ) - lstrlen( szFileName ));
                    ofn.nFileExtension = (WORD)lstrlen( szTemplatePath ) - 3;
                    ofn.lpstrDefExt = L"SIF";

                    b = GetSaveFileName( &ofn );
                    if ( !b ) {
                        hr = S_FALSE;
                    }

                    // paranoid
                    Assert( wcslen(szTemplatePath) < ARRAYSIZE(szTemplatePath) );
                    Assert( wcslen(g_Options.szIntelliMirrorPath) < ARRAYSIZE(g_Options.szIntelliMirrorPath) );

                    if ( wcslen(szTemplatePath) - wcslen(g_Options.szIntelliMirrorPath) + 53 >= 128 )
                    {
                        MessageBoxFromStrings( hDlg, IDS_BOOTP_FILENAME_LENGTH_RESTRICTION_TITLE, IDS_BOOTP_FILENAME_LENGTH_RESTRICTION_TEXT, MB_OK );
                        goto GetFileNameAgain;
                    }
                }
            }
            break;

        default:
            MessageBoxFromError( hDlg, szFileName, dwErr );
            hr = S_FALSE;
        }
    }

    if ( hr == S_OK )
    {
        //
        // Need to add "Quotes" around the text
        //
        WCHAR szDescription[ REMOTE_INSTALL_MAX_DESCRIPTION_CHAR_COUNT + 2 ];
        WCHAR szHelpText[ REMOTE_INSTALL_MAX_HELPTEXT_CHAR_COUNT + 2 ];
        WCHAR szOSVersion[ 32 ];

        wsprintf( szDescription, L"\"%s\"", g_Options.szDescription );
        Assert( wcslen(szDescription) < ARRAYSIZE(szDescription) );
        wsprintf( szHelpText, L"\"%s\"", g_Options.szHelpText );
        Assert( wcslen(szHelpText) < ARRAYSIZE(szHelpText) );
        wsprintf( szOSVersion, L"\"%s.%s (%d)\"", g_Options.szMajorVersion, g_Options.szMinorVersion, g_Options.dwBuildNumber );
        Assert( wcslen(szOSVersion) < ARRAYSIZE(szOSVersion) );

        WritePrivateProfileString( L"OSChooser",
                                   L"Description",
                                   szDescription,
                                   szTemplatePath );

        WritePrivateProfileString( L"OSChooser",
                                   L"Help",
                                   szHelpText,
                                   szTemplatePath );

        WritePrivateProfileString( L"OSChooser",
                                   L"ImageType",
                                   L"Flat",
                                   szTemplatePath );

        WritePrivateProfileString( L"OSChooser",
                                   L"Version",
                                   szOSVersion,
                                   szTemplatePath );
    }

Error:
    HRETURN(hr);
}


HRESULT
GetSisVolumePath(
    PWCHAR buffer,
    DWORD sizeInChars   //buffer size in characters
    )
{
    HRESULT hr = S_OK;
    size_t ln;

    Assert(g_Options.szIntelliMirrorPath[0] != NULL);

    if (!GetVolumePathName( g_Options.szIntelliMirrorPath, buffer, sizeInChars )) {

        hr = HRESULT_FROM_WIN32(GetLastError());

    } else {

        ln = wcslen(buffer);

        if ((ln <= 0) || (buffer[ln-1] != L'\\')) {

            hr = StringCchCat(buffer,sizeInChars,L"\\");
        }

        if (SUCCEEDED(hr)) {

            hr = StringCchCat( buffer, sizeInChars, SISCommonStoreDir );
        }
    }
    HRETURN(hr);
}


//
// Create Common Store Volume
//
HRESULT
CreateSISVolume( HWND hDlg )
{
    HRESULT hr = E_FAIL;
    WCHAR sz[ SMALL_BUFFER_SIZE ];
    DWORD dw;
    BOOL  b;

    WCHAR szSISPath[ MAX_PATH ];

    HANDLE hMaxIndex;
    WCHAR szIndexFilePath[ MAX_PATH ];

    TraceFunc( "CreateSISVolume( hDlg )\n" );

    //
    //  Get volume name
    //

    hr = GetSisVolumePath( szSISPath, sizeof(szSISPath)/sizeof(WCHAR));

    if (FAILED(hr)) {

        goto Error;
    }

    TraceMsg( TF_ALWAYS, "Creating %s...\n", szSISPath );

    //
    //  We may have not known the IntelliMirror Drive/Directory
    //  until now and it was previously an SIS volume.
    //
    //  If the directory already exists, force set the ACLs
    //

    if ( g_Options.fSISVolumeCreated ) {
        //
        //  Identify what we are doing
        //

        dw = LoadString( g_hinstance, IDS_CORRECTING_SIS_ACLS, sz, ARRAYSIZE(sz) );
        if (!dw) {
            hr = THR(HRESULT_FROM_WIN32(GetLastError()));
            goto Error;
        }

        SetDlgItemText( hDlg, IDC_S_OPERATION, sz );

        //
        //  Set the correct ACLs
        //

        hr = SetSISCommonStoreSecurity( szSISPath );
        hr = S_OK;      //ignore if it fails
        goto Error;
    }

    //
    //  Identify what we are doing
    //

    dw = LoadString( g_hinstance, IDS_CREATING_SIS_VOLUME, sz, ARRAYSIZE(sz) );
    if (dw == 0) {
        hr = THR(HRESULT_FROM_WIN32(GetLastError()));
        goto Error;
    }

    SetDlgItemText( hDlg, IDC_S_OPERATION, sz );

    //
    // Create and zero SIS store
    //

    b = CreateDirectory( szSISPath, NULL );
    if ( !b ) {

        dw = GetLastError();
        if (ERROR_ALREADY_EXISTS != dw)  {

            hr = THR( HRESULT_FROM_WIN32( dw ) );
            ErrorBox( hDlg, szSISPath );
            DebugMsg( "Cannot create Common Store directory." );
            goto Error;
        }
    }

    b = SetFileAttributes( szSISPath, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM );
    if ( !b ) {
        ErrorBox( hDlg, szSISPath );
        DebugMsg( "Could not mark SIS Common Store directory as hidden and system. Error: %u\n", GetLastError() );
    }

    //
    // Create the MaxIndex file.
    //
    _snwprintf( szIndexFilePath, ARRAYSIZE(szIndexFilePath), L"%s\\MaxIndex", szSISPath );
    TERMINATE_BUFFER(szIndexFilePath);
    hMaxIndex = CreateFile( szIndexFilePath,
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_NEW,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);
    if ( hMaxIndex == INVALID_HANDLE_VALUE ) {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, szIndexFilePath );
        DebugMsg( "Can't create %s.\n", szIndexFilePath );
        goto Error;
    } else {
        DWORD bytesWritten;
        INDEX maxIndex = 1;

        if ( !WriteFile( hMaxIndex, &maxIndex, sizeof maxIndex, &bytesWritten, NULL )
          || ( bytesWritten < sizeof maxIndex ) ) {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, szIndexFilePath );
            DebugMsg( "Can't write MaxIndex. Error: %u\n", GetLastError() );
            CloseHandle( hMaxIndex );
            goto Error;
        } else {
            CloseHandle( hMaxIndex );

            TraceMsg( TF_ALWAYS, "MaxIndex of %lu written\n", maxIndex );

            hr = S_OK;
        }
    }

    //
    // Set security information on the common store directory
    //

    hr = SetSISCommonStoreSecurity( szSISPath );

    if (FAILED(hr)) {
        MessageBoxFromError( hDlg, NULL, hr );
        goto Error;
    }

Error:

    HRETURN(hr);
}


//
//  This routine will setup the correct security on the given SIS common
//  store directory
//

HRESULT
SetSISCommonStoreSecurity( PWCHAR szSISPath )
{
    HRESULT hr = S_OK;
    DWORD dw;
    PACL newAcl = NULL;
    PSID systemSid = NULL;
    SID_IDENTIFIER_AUTHORITY ntSidAuthority = SECURITY_NT_AUTHORITY;
    EXPLICIT_ACCESS explicitEntries;
    SECURITY_DESCRIPTOR secDescriptor;

    //
    //  setup SYSTEM sid
    //

    if (!AllocateAndInitializeSid( &ntSidAuthority,
                                   1,
                                   SECURITY_LOCAL_SYSTEM_RID,
                                   0, 0, 0, 0, 0, 0, 0,
                                   &systemSid ))
    {
        hr = THR(HRESULT_FROM_WIN32(GetLastError()));
        goto Cleanup;
    }

    //
    //  Build a new ACL with SYSTEM access in it
    //
    //  Set the access control information
    //

    explicitEntries.grfAccessPermissions = FILE_ALL_ACCESS;
    explicitEntries.grfAccessMode = SET_ACCESS;
    explicitEntries.grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    BuildTrusteeWithSid( &explicitEntries.Trustee, systemSid );

    //
    // Set the Acl with the ExplicitEntry rights
    //

    dw = SetEntriesInAcl( 1,
                          &explicitEntries,
                          NULL,
                          &newAcl );

    if ( dw != ERROR_SUCCESS ) {
        hr = THR(HRESULT_FROM_WIN32(dw));
        goto Cleanup;
    }

    //
    // Create the Security Descriptor
    //

    InitializeSecurityDescriptor( &secDescriptor, SECURITY_DESCRIPTOR_REVISION );

    if (!SetSecurityDescriptorDacl( &secDescriptor, TRUE, newAcl, FALSE )) {
        hr = THR(HRESULT_FROM_WIN32(GetLastError()));
        goto Cleanup;
    }

    //
    //  SET security on the Directory
    //

    if (!SetFileSecurity(szSISPath,
                         DACL_SECURITY_INFORMATION,
                         &secDescriptor))
    {
        hr = THR(HRESULT_FROM_WIN32(GetLastError()));
        goto Cleanup;
    }

    //
    //  Cleanup our variables
    //

Cleanup:

    if (systemSid) {
        FreeSid( systemSid );
    }

    if (newAcl) {
        LocalFree( newAcl );
    }

    return hr;
}


//
//  This routine will check to see if the security of the common store
//  directory is correct.  If it is TRUE will be returned, else FALSE
//  is returned.
//

BOOL
CheckSISCommonStoreSecurity( PWCHAR szSISPath )
{
    DWORD dw;
    BOOL retval = FALSE;
    PSECURITY_DESCRIPTOR secDes = NULL;
    PACL dacl;
    PSID systemSid = NULL;
    PACCESS_ALLOWED_ACE ace;
    PACCESS_ALLOWED_ACE systemAce;
    SID_IDENTIFIER_AUTHORITY ntSidAuthority = SECURITY_NT_AUTHORITY;
    ULONG i;

    //
    //  Get the current security settings of the "SIS Common Store" directory
    //

    dw = GetNamedSecurityInfo( szSISPath,
                               SE_FILE_OBJECT,
                               (DACL_SECURITY_INFORMATION |
                                OWNER_SECURITY_INFORMATION),
                               NULL,
                               NULL,
                               &dacl,
                               NULL,
                               &secDes );

    if (dw != ERROR_SUCCESS) {
        secDes = NULL;
        goto Cleanup;
    }                

    //
    //  setup SYSTEM sid
    //

    if (!AllocateAndInitializeSid( &ntSidAuthority,
                                   1,
                                   SECURITY_LOCAL_SYSTEM_RID,
                                   0, 0, 0, 0, 0, 0, 0,
                                   &systemSid ))
    {
        systemSid = NULL;
        goto Cleanup;
    }

    //
    //  Make sure we have a valid ACL
    //

    if (!dacl || 
        !IsValidAcl( dacl ))
    {
        goto Cleanup;
    }

    //
    //  Examine the ACE's inside the ACL, make sure there is ONLY a
    //  SYSTEM ACE.  If there is any other ACE, reset things.
    //

    systemAce = NULL;

    for (i=0; ; i++) {

        if (!GetAce( dacl, i, (LPVOID *)&ace )) {
            break;
        }

        if (ace->Header.AceType != ACCESS_ALLOWED_ACE_TYPE) {
            continue;
        }

        //
        //  If we find the SYSTEM sid, save it, if we find any other
        //  SID, flag we want to RESET things
        //

        if (EqualSid(((PSID)&ace->SidStart),systemSid)) {
            systemAce = ace;
        } else {
            goto Cleanup;
        }
    }

    //
    //  If no SYSTEM ACE was found, return FALSE.
    //

    if (!systemAce) {
        goto Cleanup; 
    }

    //
    //  We found the SYSTEM ace, verify it has proper inheritence.
    //  If not, return FALSE
    //

    if (!(systemAce->Header.AceFlags & OBJECT_INHERIT_ACE) ||
        !(systemAce->Header.AceFlags & CONTAINER_INHERIT_ACE) ||
         ((systemAce->Mask & STANDARD_RIGHTS_ALL) != STANDARD_RIGHTS_ALL))
    {
        goto Cleanup;
    }
    
    //
    //  Everything is fine, return "security valid" value
    //

    retval = TRUE;
    

Cleanup:

    if (secDes) {
        LocalFree( secDes );
    }

    if (systemSid) {
        FreeSid( systemSid );
    }

    return retval;
}


//
// CopyScreenFiles( )
//
HRESULT
CopyScreenFiles( HWND hDlg )
{
    HRESULT hr = S_OK;
    WCHAR   szText[ SMALL_BUFFER_SIZE ];
    WCHAR   szRembootPath[ MAX_PATH ];
    WCHAR   szScreenDirectory[ MAX_PATH ];
    WCHAR   szRemboot[ 14 ];
    UINT    uLineNum;
    HINF    hinf = INVALID_HANDLE_VALUE;
    DWORD   dwCount = 0;
    DWORD   dw;
    BOOL    b;
    INFCONTEXT context;
    HSPFILEQ Queue = INVALID_HANDLE_VALUE;
    HWND    hProg    = GetDlgItem( hDlg, IDC_P_METER );
    MYCONTEXT MyContext;
    ZeroMemory( &MyContext, sizeof(MyContext) );

    TraceFunc( "CopyScreenFiles( ... )\n" );

    AssertMsg( !g_Options.fScreenLeaveAlone, "Should not have made it here with this flag set." );

    SendMessage( hProg, PBM_SETRANGE, 0, MAKELPARAM(0, 5000 ));
    SendMessage( hProg, PBM_SETPOS, 0, 0 );
    szText[SMALL_BUFFER_SIZE-1] = L'\0';
    dw = LoadString( g_hinstance, IDS_BUILDINGLIST, szText, ARRAYSIZE(szText));
    Assert( dw );
    SetDlgItemText( hDlg, IDC_S_OPERATION, szText );

    szRemboot[13] = L'\0';
    dw = LoadString( g_hinstance, IDS_REMBOOTINF, szRemboot, ARRAYSIZE(szRemboot) );
    Assert( dw );

    Assert( g_Options.fLanguageSet );

    lstrcpyn( szRembootPath, g_Options.szInstallationPath, ARRAYSIZE(szRembootPath));
    ConcatenatePaths( szRembootPath, g_Options.ProcessorArchitectureString, ARRAYSIZE(szRembootPath));
    ConcatenatePaths( szRembootPath, szRemboot, ARRAYSIZE(szRembootPath));
    Assert( wcslen( szRembootPath ) < ARRAYSIZE(szRembootPath) );
    DebugMsg( "REMINST.INF: %s\n", szRembootPath );

    lstrcpyn( szScreenDirectory, g_Options.szOSChooserPath, ARRAYSIZE(szScreenDirectory));
    ConcatenatePaths( szScreenDirectory, g_Options.szLanguage, ARRAYSIZE(szScreenDirectory));
    Assert( wcslen(szScreenDirectory) < ARRAYSIZE(szScreenDirectory) );
    DebugMsg( "Destination: %s\n", szScreenDirectory );

    hinf = SetupOpenInfFile( szRembootPath, NULL, INF_STYLE_WIN4, &uLineNum);
    if ( hinf == INVALID_HANDLE_VALUE ) {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        ErrorBox( hDlg, szRembootPath );
        goto Cleanup;
    }

    Queue = SetupOpenFileQueue( );

    b = SetupFindFirstLine( hinf, L"OSChooser Screens", NULL, &context );
    if ( !b ) {
        ErrorBox( hDlg, szRembootPath );
        hr = THR(S_FALSE);
    }

    while ( b )
    {
        LPWSTR pszDest = NULL;
        WCHAR  szSrcPath[ MAX_PATH ];
        WCHAR  szDestPath[ MAX_PATH ];

        dw = SetupGetFieldCount( &context );

        if ( dw > 1 ) {
            b = SetupGetStringField( &context, 1, szDestPath, ARRAYSIZE( szDestPath ), NULL );
            AssertMsg( b, "REMINST: Missing field?" );
            if ( b ) {
                b = SetupGetStringField( &context, 2, szSrcPath, ARRAYSIZE(szSrcPath), NULL );
                AssertMsg( b, "REMINST: Missing field?" );
                pszDest = szDestPath;
            }
        } else {
            b = SetupGetStringField( &context, 1, szSrcPath, ARRAYSIZE(szSrcPath), NULL );
            AssertMsg( b, "REMINST: Missing field?" );
        }

        if ( !b ) {
            hr = S_FALSE;
            goto SkipIt;
        }

        if ( g_Options.fScreenSaveOld ) {
            WCHAR szPath[ MAX_PATH ];
            WCHAR szMovePath[ MAX_PATH ];
            DWORD  dwLen;

            if ( pszDest ) {
                lstrcpyn( szPath, szScreenDirectory, ARRAYSIZE( szPath ) );
                ConcatenatePaths( szPath, pszDest, ARRAYSIZE( szPath ) );                
            } else {
                lstrcpyn( szPath, szScreenDirectory, ARRAYSIZE( szPath ) );
                ConcatenatePaths( szPath, szSrcPath, ARRAYSIZE( szPath ) );                                
            }

            // Rename to *.BAK
            lstrcpyn( szMovePath, szPath, ARRAYSIZE(szMovePath) );
            dwLen = lstrlen( szMovePath );
            Assert( _wcsicmp( &szMovePath[ dwLen - 3 ], L"OSC" ) == 0 );
            lstrcpyn( &szMovePath[ dwLen - 3 ], L"BAK", ARRAYSIZE(szMovePath) - dwLen - 3);

            DebugMsg( "Renaming %s to %s...\n", szPath, szMovePath );

            b = DeleteFile( szMovePath );
            b = MoveFile( szPath, szMovePath );
            if ( !b ) {
                DWORD dwErr = GetLastError( );
                switch ( dwErr )
                {
#if 0   // blast over files
                case ERROR_FILE_EXISTS:
                    if ( !fWarning ) {
                        MessageBoxFromStrings( hDlg,
                                               IDS_BACKUPSCREENFILEEXISTS_CAPTION,
                                               IDS_BACKUPSCREENFILEEXISTS_TEXT,
                                               MB_OK );
                        fWarning = TRUE;
                    }
#endif
                case ERROR_FILE_NOT_FOUND:
                    break; // ignore this error
                    // It is possible that the user deleted the source files (old OSCs).

                default:
                    MessageBoxFromError( hDlg, NULL, dwErr );
                    break;
                }
            }
        }

        b = SetupQueueCopy( Queue,
                            g_Options.szInstallationPath,
                            g_Options.ProcessorArchitectureString,
                            szSrcPath,
                            NULL,
                            NULL,
                            szScreenDirectory,
                            pszDest,
                            g_Options.fScreenOverwrite ?
                                SP_COPY_FORCE_NEWER | SP_COPY_WARNIFSKIP :
                                SP_COPY_NOOVERWRITE  | SP_COPY_WARNIFSKIP  );
        if ( !b ) {
            ErrorBox( hDlg, szSrcPath );
            hr = THR(S_FALSE);
            goto SkipIt;
        }

        dwCount++;

SkipIt:
        b = SetupFindNextLine( &context, &context );
    }

    //
    // This information will be passed to CopyFileCallback() as
    // the Context.
    //
    MyContext.nToBeCopied        = dwCount;
    MyContext.nCopied            = 0;
    MyContext.pContext           = SetupInitDefaultQueueCallbackEx(NULL,(HWND)INVALID_HANDLE_VALUE,0,0,NULL);
    MyContext.hProg              = hProg;
    MyContext.hOperation         = GetDlgItem( hDlg, IDC_S_OPERATION );
    MyContext.hDlg               = hDlg;
    MyContext.fQuiet             = FALSE;
    MyContext.dwCopyingLength =
    LoadString( g_hinstance, IDS_COPYING, MyContext.szCopyingString, ARRAYSIZE(MyContext.szCopyingString));
    Assert(MyContext.dwCopyingLength);

    //
    // Start copying
    //
    if ( dwCount != 0 )
    {
        b = SetupCommitFileQueue( NULL,
                                  Queue,
                                  (PSP_FILE_CALLBACK) CopyFilesCallback,
                                  (PVOID) &MyContext );
        if ( !b ) {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            ErrorBox( hDlg, NULL );
            goto Cleanup;
        }
    }

Cleanup:
    SendMessage( hProg, PBM_SETPOS, 5000, 0 );
    SetDlgItemText( hDlg, IDC_S_OPERATION, L"" );

    if ( MyContext.pContext )
        SetupTermDefaultQueueCallback( MyContext.pContext );

    if ( Queue != INVALID_HANDLE_VALUE )
        SetupCloseFileQueue( Queue );

    if ( hinf != INVALID_HANDLE_VALUE )
        SetupCloseInfFile( hinf );

    HRETURN( hr );
}

BOOLEAN
CALLBACK
FixLoginOSC(
    PWSTR   FileName
    )
/*++

Routine Description:

    This function will open the specified login.osc file and add
    in the ntlmv2 flags.

Arguments:

    FileName - Full path specifying location of login.osc file.


Return Value:

    BOOLEAN specifiying success.
    
--*/
{
    PCHAR   Buffer = NULL;
    PCHAR   Buffer2 = NULL;
    PCHAR   p = NULL;
    ULONG   CurrentFileSize = 0;
    ULONG   BytesRead = 0;
    ULONG   i = 0;
    HANDLE  FileHandle = INVALID_HANDLE_VALUE;
    BOOLEAN RetValue = TRUE;

    //
    // Open the file and read it in.
    //
    if( !FileName ) {
        RetValue = FALSE;
        goto FixLoginOSCExit;
    }
    FileHandle = CreateFile( FileName,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             0,
                             NULL );
    if( FileHandle == INVALID_HANDLE_VALUE ) {
        RetValue = FALSE;
        goto FixLoginOSCExit;
    }
    
    CurrentFileSize = GetFileSize( FileHandle, NULL );
    if( CurrentFileSize == (DWORD)(-1) ) {
        RetValue = FALSE;
        goto FixLoginOSCExit;
    }

    Buffer = (PCHAR)TraceAlloc(LPTR, CurrentFileSize + 3 );
    if( Buffer == NULL ) {
        RetValue = FALSE;
        goto FixLoginOSCExit;
    }

    RetValue = (BOOLEAN)ReadFile(FileHandle,Buffer,CurrentFileSize,&BytesRead,NULL);
    if( !RetValue ) {
        goto FixLoginOSCExit;
    }


    
    //
    // We now have the file up in memory.  Go walk through our
    // data structure and operate on the buffer.
    //

    //
    // Walk through our data structure and take
    // care of deleting any of the lines we're asked to.
    //
    for( i = 0; i < (sizeof(LoginOSCPatches)/sizeof(LoginOSCPatches[0])); i++ ) {

        if( LoginOSCPatches[i].AddString == FALSE ) {
            //
            // This is a delete operation.
            //

            //
            // Find the tag that specifies the start of our
            // specified section.
            //
            p = Buffer;
            CurrentFileSize = (ULONG)strlen(Buffer);
            while( (p < (Buffer + CurrentFileSize - strlen(LoginOSCPatches[i].SectionStartTag))) &&
                   (_strnicmp(p, LoginOSCPatches[i].SectionStartTag, strlen(LoginOSCPatches[i].SectionStartTag))) ) {
                p++;
            }

            // make sure we found the tag.
            if( _strnicmp(p, LoginOSCPatches[i].SectionStartTag, strlen(LoginOSCPatches[i].SectionStartTag)) ) {
                // nope.
                continue;
            }


            //
            // Look for the specified string.
            //
            while( 
                   // make sure we don't walk off the end of our buffer.
                   (p < (Buffer + CurrentFileSize - strlen(LoginOSCPatches[i].TargetString))) &&

                   // make sure we don't walk off the end of our section.
                   _strnicmp(p, LoginOSCPatches[i].SectionEndTag, strlen(LoginOSCPatches[i].SectionEndTag)) &&

                   // see if we actually found our target string.
                   _strnicmp(p, LoginOSCPatches[i].TargetString, strlen(LoginOSCPatches[i].TargetString)) ) {
                p++;            
            }


            //
            // Three cases to consider here:
            // 1. p points to our string.  Here we must remove our string.
            //    from the buffer.
            // 2. p points to the closing tag, meaning we didn't find our string.
            //    We do nothing here.
            // 3. p points to the end of the buffer, meaning we never found
            //    our close block, which is invalid, but it means we do nothing.
            //
            // So all we really care about is case 1...
            //
            if( !_strnicmp(p, LoginOSCPatches[i].TargetString, strlen(LoginOSCPatches[i].TargetString)) ) {
                //
                // Here, we just copy the buffer as it exists after our string, right ontop of our
                // string.
                //
                
                //
                // Make sure that if we're dependent on any other entry having been
                // completed successfully, we actually go check that that entry
                // did indeed complete successfully.
                //
                if( (LoginOSCPatches[i].DependingEntry == (-1)) ||
                    ( (LoginOSCPatches[i].DependingEntry < ARRAYSIZE(LoginOSCPatches)) &&
                      (LoginOSCPatches[LoginOSCPatches[i].DependingEntry].OperationCompletedSuccessfully) ) ) {
                    strcpy( p, p+strlen(LoginOSCPatches[i].TargetString) );
                
                    //
                    // Remember that we did this one.
                    //
                    LoginOSCPatches[i].OperationCompletedSuccessfully = TRUE;
                
                }
            }
        }
    }
    
    



    //
    // Walk through our data structure and take
    // care of adding any of the lines we're asked to.
    //
    for( i = 0; i < (sizeof(LoginOSCPatches)/sizeof(LoginOSCPatches[0])); i++ ) {

        if( LoginOSCPatches[i].AddString == TRUE ) {
            //
            // This is an add operation.
            //

            //
            // Find the tag that specifies the start of our
            // specified section.
            //
            p = Buffer;
            CurrentFileSize = (ULONG)strlen(Buffer);
            while( (p < (Buffer + CurrentFileSize - strlen(LoginOSCPatches[i].SectionStartTag))) &&
                   (_strnicmp(p, LoginOSCPatches[i].SectionStartTag, strlen(LoginOSCPatches[i].SectionStartTag))) ) {
                p++;
            }

            // make sure we found the tag.
            if( _strnicmp(p, LoginOSCPatches[i].SectionStartTag, strlen(LoginOSCPatches[i].SectionStartTag)) ) {
                // nope.
                continue;
            }


            //
            // Look for the specified string.
            //
            while( 
                   // make sure we don't walk off the end of our buffer.
                   (p < (Buffer + CurrentFileSize - strlen(LoginOSCPatches[i].TargetString))) &&

                   // make sure we don't walk off the end of our section.
                   _strnicmp(p, LoginOSCPatches[i].SectionEndTag, strlen(LoginOSCPatches[i].SectionEndTag)) &&

                   // see if we actually found our target string.
                   _strnicmp(p, LoginOSCPatches[i].TargetString, strlen(LoginOSCPatches[i].TargetString)) ) {
                p++;            
            }


            //
            // Three cases to consider here:
            // 1. p points to our string.  This means our string already
            //    exists, so we do nothing.
            // 2. p points to the closing tag, meaning we didn't find our string.
            //    This means we must add our string right here.
            // 3. p points to the end of the buffer, meaning we never found
            //    our close block, which is invalid, but it means we do nothing.
            //
            // So all we really care about is case 2...
            //
            if( !_strnicmp(p, LoginOSCPatches[i].SectionEndTag, strlen(LoginOSCPatches[i].SectionEndTag)) ) {
                
                //
                // Make sure that if we're dependent on any other entry having been
                // completed successfully, we actually go check that that entry
                // did indeed complete successfully.
                //
                if( (LoginOSCPatches[i].DependingEntry == (-1)) ||
                    ( (LoginOSCPatches[i].DependingEntry < ARRAYSIZE(LoginOSCPatches)) &&
                      (LoginOSCPatches[LoginOSCPatches[i].DependingEntry].OperationCompletedSuccessfully) ) ) {
                
                
                    // Alloc a buffer big enough for our additional string.
                    Buffer2 = (PCHAR)TraceAlloc( LPTR,
                                                 CurrentFileSize + 3 +
                                                 (DWORD)strlen(LoginOSCPatches[i].TargetString) + 3); // 2 for \r\n, 1 for null
                    if( !Buffer2 ) {
                        RetValue = FALSE;
                        goto FixLoginOSCExit;
                    }
    
                    // insert our new string.
                    *p = '\0';
                    strcpy( Buffer2, Buffer );
                    strcat( Buffer2, LoginOSCPatches[i].TargetString );
                    strcat( Buffer2, "\r\n" );
                    *p = LoginOSCPatches[i].SectionEndTag[0];
                    strcat( Buffer2, p );
    
                    //
                    // Buffer2 now contains our fixed up file with 
                    // the new entry.  Realloc Buffer and copy in
                    // the contents of Buffer2, then free Buffer2.
                    //
                    TraceFree( Buffer );
                    Buffer = (PCHAR)TraceAlloc(LPTR, (DWORD)strlen(Buffer2)+2);
                    if( !Buffer ) {
                        RetValue = FALSE;
                        goto FixLoginOSCExit;
                    }
                    strcpy( Buffer, Buffer2 );
                    TraceFree( Buffer2 );
                    Buffer2 = NULL;


                    //
                    // Remember that we did this one.
                    //
                    LoginOSCPatches[i].OperationCompletedSuccessfully = TRUE;
                }
            }
        }
    }
    
            
    //
    // re-write our file with the new Buffer.
    //
    SetFilePointer(FileHandle, 0, NULL, FILE_BEGIN);
    WriteFile( FileHandle,
               Buffer,
               (DWORD)strlen(Buffer),
               &BytesRead,
               NULL );
    SetEndOfFile( FileHandle );
    

FixLoginOSCExit:
    
    if( FileHandle != INVALID_HANDLE_VALUE ) {
        CloseHandle( FileHandle );
    }

    if( Buffer != NULL ) {
        TraceFree( Buffer );
    }

    if( Buffer2 != NULL ) {
        TraceFree( Buffer2 );
    }
    
    return RetValue;
}

HRESULT
EnumAndOperate(
    PWSTR               pszDirName,
    PWSTR               pszTargetFile,
    POPERATECALLBACK    FileOperateCallback
    )
/*++

Routine Description:

    Recursively searches a directory for any instances of the specified
    file.  If 'file' is found, the specified callback is called.

Arguments:

    pszDirName - Root directory to start searching.

    pszTargetFile - File to be searched for.

    FileOperateCallback - Function to be called if pszTargetFile is found.

Return Value:

    HRESULT indicating outcome.
    
--*/
{

    WIN32_FIND_DATA FindData;
    HANDLE  hFindData = INVALID_HANDLE_VALUE;
    PWCHAR  pOrigDirName = pszDirName + wcslen(pszDirName);

    ConcatenatePaths( pszDirName, L"*", MAX_PATH );
    hFindData = FindFirstFile( pszDirName, &FindData );

    if( hFindData != INVALID_HANDLE_VALUE ) {
        do {
            if( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {

                if( wcscmp(FindData.cFileName, L".") &&
                    wcscmp(FindData.cFileName, L"..") ) {

                    // get rid of the \* on the end of the path and
                    // append our new directory name.
                    *pOrigDirName = L'\0';
                    ConcatenatePaths( pszDirName, FindData.cFileName, MAX_PATH );
                    EnumAndOperate( pszDirName,
                                    pszTargetFile,
                                    FileOperateCallback );
                    *pOrigDirName = L'\0';
                }
            } else {
                if( !_wcsicmp(pszTargetFile,FindData.cFileName) ) {
                    *pOrigDirName = L'\0';
                    ConcatenatePaths( pszDirName, FindData.cFileName, MAX_PATH );
                    FileOperateCallback( pszDirName );
                    *pOrigDirName = L'\0';
                }
            }

        } while ( FindNextFile( hFindData, &FindData ) );
    }

    return( S_OK );
}


//
// UpdateRemoteInstallTree( )
//
HRESULT
UpdateRemoteInstallTree( )
{
    TraceFunc( "UpdateRemoteInstallTree( )\n" );

    HRESULT hr = S_OK;
    HKEY    hkey;
    DWORD   dw;
    BOOL    b;
    HINF    hinf = INVALID_HANDLE_VALUE;
    WCHAR   szServerRemBootInfPath[ MAX_PATH ];
    WCHAR   szRemInstSetupPath[ MAX_PATH ];
    WCHAR   szRemoteInstallPath[ MAX_PATH ];
    WCHAR   szPath[ MAX_PATH ];
    UINT    uLineNum;
    INFCONTEXT context;
    SECURITY_ATTRIBUTES sa;
    PWSTR   EndOfOriginalszRemoteInstallPath = NULL;
    

    //
    // Try finding TFTPD's regkey to find the IntelliMirror Directory
    //
    szPath[MAX_PATH-1] = L'\0';
    dw = LoadString( g_hinstance, IDS_TFTPD_SERVICE_PARAMETERS, szPath, ARRAYSIZE( szPath ));
    Assert( dw );

    if ( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                        szPath,
                                        0, // options
                                        KEY_QUERY_VALUE,
                                        &hkey ) ) {
        ULONG l;
        DWORD dwType;
        LONG lErr;

        l = sizeof(szRemoteInstallPath);
        lErr = RegQueryValueEx( hkey,
                                L"Directory",
                                0, // reserved
                                &dwType,
                                (LPBYTE) szRemoteInstallPath,
                                &l );
        if ( lErr == ERROR_SUCCESS ) {
            DebugMsg( "Found TFTPD's Directory regkey: %s\n", szRemoteInstallPath );
            // Remember where our original remote install path ends so we can
            // write a NULL there and get back our original path later on.
            EndOfOriginalszRemoteInstallPath = szRemoteInstallPath + wcslen(szRemoteInstallPath);
            
            // now append "OSChooser"
            wcscat( szRemoteInstallPath, L"\\OSChooser" );

            if ( 0xFFFFffff == GetFileAttributes( szRemoteInstallPath ) ) {
                DebugMsg( "%s - directory doesn't exist.\n", szRemoteInstallPath );
                hr = S_FALSE;
            }

        } else {
            hr = S_FALSE;
        }
        RegCloseKey( hkey );
    }
    else
    {
        hr = S_FALSE;
    }


    if ( hr == S_OK )
    {
        // make x:\winnt
        dw = ExpandEnvironmentStrings( TEXT("%SystemRoot%"), szServerRemBootInfPath, ARRAYSIZE( szServerRemBootInfPath ));
        Assert( dw );

        // make x:\winnt\system32
        ConcatenatePaths( szServerRemBootInfPath, L"\\System32\\", ARRAYSIZE(szServerRemBootInfPath) );
        lstrcpyn( szRemInstSetupPath, szServerRemBootInfPath, ARRAYSIZE(szRemInstSetupPath) );

        // make x:\winnt\system32\reminst.inf
        dw = lstrlen( szServerRemBootInfPath );
        dw = LoadString( g_hinstance, IDS_REMBOOTINF, &szServerRemBootInfPath[dw], ARRAYSIZE( szServerRemBootInfPath ) - dw );
        Assert( dw );

        // make x:\winnt\system32\reminst
        ConcatenatePaths( szRemInstSetupPath, L"reminst", ARRAYSIZE(szRemInstSetupPath) );

        DebugMsg( "RemBoot.INF Path: %s\n", szServerRemBootInfPath );
        DebugMsg( "RemInst Setup Path: %s\n", szRemInstSetupPath );

        hinf = SetupOpenInfFile( szServerRemBootInfPath, NULL, INF_STYLE_WIN4, &uLineNum);
        if ( hinf != INVALID_HANDLE_VALUE ) {

            b = SetupFindFirstLine( hinf, L"OSChooser", NULL, &context );
            AssertMsg( b, "Missing section?" );
            if ( !b ) {
                hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            }

        } else {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        }
    }

    if ( hr == S_OK )
    {
        HSPFILEQ Queue;

        //
        // Create the Queue
        //
        Queue = SetupOpenFileQueue( );

        b = TRUE;
        while ( b )
        {
            WCHAR  szSrcFile[ MAX_PATH ];
            WCHAR  szDestFile[ MAX_PATH ];
            LPWSTR pszDest = NULL;

            dw = SetupGetFieldCount( &context );

            if ( dw > 1 ) {
                b = SetupGetStringField( &context, 1, szDestFile, ARRAYSIZE(szDestFile), NULL );
                AssertMsg( b, "Missing field?" );
                if ( b ) {
                    b = SetupGetStringField( &context, 2, szSrcFile, ARRAYSIZE(szSrcFile), NULL );
                    AssertMsg( b, "Missing field?" );
                    pszDest = szDestFile;
                }
            } else {
                b = SetupGetStringField( &context, 1, szSrcFile, ARRAYSIZE(szSrcFile), NULL );
                AssertMsg( b, "Missing field?" );
            }

            if ( !b ) {
                hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
                goto SkipIt;
            }

            b = SetupQueueCopy( Queue,
                                szRemInstSetupPath,
                                NULL,
                                szSrcFile,
                                NULL,
                                NULL,
                                szRemoteInstallPath,
                                pszDest,
                                SP_COPY_NEWER | SP_COPY_FORCE_NEWER
                                | SP_COPY_WARNIFSKIP | SP_COPY_SOURCEPATH_ABSOLUTE );
            if ( !b ) {
                THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            }

SkipIt:
            b = SetupFindNextLine( &context, &context );
        }

        b = SetupCommitFileQueue( NULL,
                                  Queue,
                                  SetupDefaultQueueCallback,
                                  SetupInitDefaultQueueCallbackEx(NULL,(HWND)INVALID_HANDLE_VALUE,0,0,NULL) );
        if ( !b ) {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        }

        SetupCloseFileQueue( Queue );
    }

    if ( hinf != INVALID_HANDLE_VALUE ) {
        SetupCloseInfFile( hinf );
    }

    
    //
    //
    // Fix ACLs on the reminst sharepoint.
    //
    //

    //
    // Create a security descriptor based on the ACLs
    // defined in REMINSTszSecurityDescriptor.
    //
    RtlZeroMemory( &sa, sizeof(SECURITY_ATTRIBUTES) );
    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.bInheritHandle = TRUE;
    b = ConvertStringSecurityDescriptorToSecurityDescriptor( REMINSTszSecurityDescriptor,
                                                             SDDL_REVISION_1,
                                                             &(sa.lpSecurityDescriptor),
                                                             NULL );

    //
    // Fix up szRemoteInstallPath.  He's got L"\\OSChooser"
    // concatenated, so we need to get rid of that part
    // of the path.
    //
    if( EndOfOriginalszRemoteInstallPath != NULL ) {
        *EndOfOriginalszRemoteInstallPath = L'\0';
    }

    if( !b ) {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
    } else {

        //
        // Go apply our security descriptor to the d:\reminst sharepoint.
        //
        dw = ApplyDaclToFileDirectory( szRemoteInstallPath,
                                       (SECURITY_DESCRIPTOR_RELATIVE *)(sa.lpSecurityDescriptor) );

        LocalFree(sa.lpSecurityDescriptor);

        if( dw != ERROR_SUCCESS ) {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        }
    }


    HRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rbsetup\server\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rbsetup.rc
//
#define IDS_APPNAME                     1
#define IDB_CHECK                       1
#define IDB_X                           2
#define IDB_ARROW                       3
#define IDS_CANCELCAPTION               4
#define IDS_CANCELTEXT                  5
#define IDS_DEFAULTPATH                 6
#define IDS_DIRECTORYEXISTS_CAPTION     7
#define IDS_DIRECTORYEXISTS_TEXT        8
#define IDS_BROWSECAPTION_RBDIR         11
#define IDS_BROWSECAPTION_SOURCEDIR     12
#define IDS_CLOSE                       16
#define IDS_DEFAULTSETUP                17
#define IDS_INVALIDSOURCECAPTION        20
#define IDS_INVALIDSOURCETEXT           21
#define IDS_INTELPATH                   22
#define IDS_ABORTING                    23
#define IDS_STARTING_SERVICES           26
#define IDS_CREATINGDIRECTORIES         28
#define IDS_REGISTRYFAILEDCAPTION       30
#define IDS_REGISTRYFAILEDTEXT          31
#define IDS_COPYING                     32
#define IDS_TFTPD                       33
#define IDS_TFTPD_SERVICENAME           34
#define IDS_BINL                        35
#define IDS_BINL_SERVICENAME            36
#define IDS_REMOTEBOOTSHAREREMARK       37
#define IDS_REMOTEBOOTSHARENAME         38
#define IDS_SHAREERRORCAPTION           39
#define IDS_CREATINGSHARES              41
#define IDS_TFTPD_PATH                  44
#define IDS_BINL_PATH                   45
#define IDS_UPDATING_REGISTRY           46
#define IDS_MUSTSELECTCAPTION           47
#define IDS_MUSTSELECTTEXT              48
#define IDS_ALPHAPATH                   49
#define IDS_LARGEFONTSIZE               52
#define IDS_LARGEFONTNAME               53
#define IDS_NORMALFONTNAME              55
#define IDS_X86                         56
#define IDS_AND                         57
#define IDS_IA64                        58
#define IDS_CREATINGDIRECTORYTREE       59
#define IDS_COPYINGFILES                60
#define IDS_UPDATINGREGISTRY            61
#define IDS_BUILDINGFILELIST            62
#define IDS_CREATING_SERVICES           63
#define IDS_COPYSERVERFILES             65
#define IDS_INSERTSERVER_CAPTION        67
#define IDS_INSERTSERVER                68
#define IDS_COPYTEMPLATEFILES           72
#define IDS_DEFAULT_SIF                 77
#define IDS_DEFAULT_DESCRIPTION         83
#define IDS_DEFAULT_HELPTEXT            84
#define IDS_UPDATING_SIF_FILE           85
#define IDS_OVERWRITE_CAPTION           86
#define IDS_OVERWRITE_TEXT              87
#define IDS_SAVE_SIF_TITLE              88
#define IDS_SIS                         90
#define IDS_SIS_SERVICENAME             91
#define IDS_SIS_PATH                    92
#define IDS_SIS_GROUP                   93
#define IDI_SETUP                       97
#define IDS_INTELLIMIRRORROOT_SUBTITLE  97
#define IDS_IMAGESOURCE_TITLE           98
#define IDB_TITLEPAGE                   99
#define IDS_IMAGESOURCE_SUBTITLE        99
#define IDD_WELCOME                     101
#define IDS_DEFAULTSIF_TITLE            102
#define IDD_IMAGESOURCE                 103
#define IDS_DEFAULTSIF_SUBTITLE         103
#define IDD_SUMMARY                     104
#define IDS_SUMMARY_SUBTITLE            104
#define IDS_MUST_REBOOT_TITLE           105
#define IDD_TASKS                       105
#define IDC_S_BOLD2                     105
#define IDS_MUST_REBOOT_MESSAGE         106
#define IDS_ALREADY_RUNNING_TITLE       107
#define IDD_OSDIRECTORY                 107
#define IDS_ALREADY_RUNNING_MESSAGE     108
#define IDB_HEADER                      109
#define IDS_SAME_DRIVE_AS_SYSTEM_TITLE  109
#define IDS_SAME_DRIVE_AS_SYSTEM_MESSAGE 110
#define IDD_DEFAULTSIF                  110
#define IDD_INTELLIMIRRORROOT           113
#define IDD_SCP                         117
#define IDD_OPTIONS                     118
#define IDD_SCREENS                     119
#define IDS_SUMMARY_TITLE               119
#define IDD_WARNING                     120
#define IDS_OSDIRECTORY_TITLE           120
#define IDS_OSDIRECTORY_SUBTITLE        121
#define IDD_SERVEROK                    121
#define IDS_INTELLIMIRRORROOT_TITLE     122
#define IDD_LANGUAGE                    122
#define IDS_OPTIONS_TITLE               123
#define IDD_WELCOME_ADD                 123
#define IDS_OPTIONS_SUBTITLE            124
#define IDD_WELCOME_CHECK               124
#define IDS_DRIVERSPATH                 125
#define IDD_EXAMINING_SERVER            125
#define IDS_SERVERNOTALLOWED_CAPTION    127
#define IDS_FIXEDDISK_CAPTION           129
#define IDS_FIXEDDISK_TEXT              130
#define IDS_CREATING_SIS_VOLUME         131
#define IDS_INTELLIMIRRORSCP            132
#define IDS_REMOVABLEDISK_CAPTION       133
#define IDS_REMOVABLEDISK_TEXT          134
#define IDS_SCP_TITLE                   135
#define IDS_SCP_SUBTITLE                136
#define IDS_TFTPD_SERVICE_PARAMETERS    137
#define IDS_REGISTER_IMADMIU_FAILED_CAPTION 139
#define IDS_REGISTER_IMADMIU_FAILED_TEXT 140
#define IDS_OSCHOOSER_SCREENS           142
#define IDS_INCOMPATIBLE_SERVER_VERSION_TITLE 143
#define IDS_INCOMPATIBLE_SERVER_VERSION_CAPTION 144
#define IDS_COMPATIBILITY               145
#define IDS_INF_SECTION                 146
#define IDS_REMBOOTINF                  147
#define IDS_INF_ERROR                   148
#define IDS_SHOULD_BE_NTFS_TITLE        150
#define IDS_SHOULD_BE_NTFS_MESSAGE      151
#define IDS_MISSING_INF_TITLE           152
#define IDS_MISSING_INF_MESSAGE         153
#define IDS_WARNING_TITLE               154
#define IDS_WARNING_SUBTITLE            155
#define IDS_BINL_SERVICECONTROLPOINT    156
#define IDS_ERROR                       157
#define IDS_SCPCREATIONFAIL_CAPTION     158
#define IDS_SCPCREATIONFAIL_TEXT        159
#define IDS_UPDATINGSCREENS             160
#define IDS_BUILDINGLIST                161
#define IDS_SCREENS_TITLE               162
#define IDS_SCREENS_SUBTITLE            163
#define IDS_BACKUPSCREENFILEEXISTS_CAPTION 164
#define IDS_BACKUPSCREENFILEEXISTS_TEXT 165
#define IDS_UNDEFINED_ERROR_STRING      166
#define IDS_INSERT_MEDIA                167
#define IDS_SERVEROK_TITLE              168
#define IDS_SERVEROK_SUBTITLE           169
#define IDS_DOMAINMEMBERSHIP_TITLE      170
#define IDS_DOMAINMEMBERSHIP_TEXT       171
#define IDS_NOT_WORKSTATION_TITLE       172
#define IDS_NOT_WORKSTATION_TEXT        173
#define IDS_SISGROVELER_SERVICENAME     174
#define IDS_SISGROVELER_PATH            175
#define IDS_SISGROVELER_GROUP           176
#define IDS_OSCHOOSER_DIRECTORY_RESTRICTION_TITLE 177
#define IDS_OSCHOOSER_DIRECTORY_RESTRICTION_TEXT 178
#define IDS_OSCHOOSER_RESTRICTION_FIELDS_TITLE 179
#define IDS_OSCHOOSER_RESTRICTION_FIELDS_TEXT 180
#define IDS_BOOTP_FILENAME_LENGTH_RESTRICTION_TITLE 181
#define IDS_BOOTP_FILENAME_LENGTH_RESTRICTION_TEXT 182
#define IDS_UNKNOWN                     183
#define IDS_ADD                         184
#define IDS_CHECK                       185
#define IDS_NOT_RUNNING_ON_NT_SERVER_CAPTION 186
#define IDS_NOT_RUNNING_ON_NT_SERVER_TEXT 187
#define IDS_LANGUAGE_TITLE              188
#define IDS_LANGUAGE_SUBTITLE           189
#define IDS_LINE_MISSING_CAPTION        190
#define IDS_LINE_MISSING_TEXT           191
#define IDS_FILE_NOT_FOUND_TITLE        192
#define IDS_FILE_NOT_FOUND_TEXT         193
#define IDS_NOT_SUPPORTED_ARCHITECTURE_TITLE 194
#define IDS_NOT_SUPPORTED_ARCHITECTURE_TEXT 195
#define IDS_PATH_TOO_LONG_TITLE         196
#define IDS_PATH_TOO_LONG_TEXT          197
#define IDS_EXAMINING_TITLE             198
#define IDS_EXAMINING_SUBTITLE          199
#define IDS_NOT_NT5_MEDIA_SOURCE_TITLE  200
#define IDS_NOT_NT5_MEDIA_SOURCE_TEXT   201
#define IDS_EXPANDING_CABS              202
#define IDS_OSCHOOSER_ROOT_DIRECTORY_RESTRICTION_TITLE 203
#define IDS_OSCHOOSER_ROOT_DIRECTORY_RESTRICTION_TEXT 204
#define IDS_SAME_DRIVE_AS_BOOT_PARTITION 205
#define IDS_SAME_DRIVE_AS_BOOT_PARTITION_TITLE 206
#define IDS_COPYING_REMINST_TITLE       207
#define IDS_OPENING_SERVICE_MANAGER_TITLE 208
#define IDS_MUST_BE_ADMINISTRATOR_CAPTION 209
#define IDS_MUST_BE_ADMINISTRATOR_TEXT  210
#define IDS_SETUP_INI_MISSING_OR_INVALID 211
#define IDS_UPGRADE_VERSION_NOT_SUPPORTED 212
#define IDS_TFTPD_DESCRIPTION           213
#define IDS_BINL_DESCRIPTION            214
#define IDS_SISGROVELER_DESCRIPTION     215
#define IDS_USAGE                       216
#define IDS_AUTHORIZING_DHCP            217
#define IDS_AUTHORIZE_DHCP_FAILURE      218
#define IDS_RISETUP_STARTMENU_TITLE     219
#define IDS_RISETUP_STARTMENU_TOOLTIP   220
#define IDS_CHECK_SERVER_TITLE          221
#define IDC_L_SETUP                     1000
#define IDC_E_INTELLIMIRRORROOT         1001
#define IDC_E_IMAGESOURCE               1002
#define IDC_B_BROWSE                    1003
#define IDC_P_METER                     1004
#define IDC_E_LIMIT                     1004
#define IDC_S_OPERATION                 1005
#define IDC_C_X86                     1006
#define IDC_C_IA64                      1007
#define IDC_S_BOLD1                     1009
#define IDC_S_BOLD3                     1010
#define IDC_S_TITLE1                    1012
#define IDC_C_LIMITCLIENTS              1014
#define IDC_C_RESPOND                   1015
#define IDC_C_KNOWNCLIENTS              1016
#define IDC_C_ACCEPTSNEWCLIENTS         1022
#define IDC_E_OSDIRECTORY               1022
#define IDC_G_OPERATION                 1023
#define IDC_S_SOURCEPATH                1024
#define IDC_S_INTELLIMIRRORROOT         1026
#define IDC_S_PLATFORM                  1027
#define IDC_E_HELPTEXT                  1030
#define IDC_SPIN_LIMIT                  1031
#define IDC_S_OSDIRECTORY               1033
#define IDC_E_DESCRIPTION               1042
#define IDC_R_LEAVEALONE                1050
#define IDC_R_OVERWRITE                 1051
#define IDC_R_SAVEOLDFILES              1052
#define IDC_S_LANGUAGE                  1054
#define IDC_S_NTVERSION                 1055
#define IDC_B_ADD                       1057
#define IDC_B_CHECK                     1058
#define IDS_CORRECTING_SIS_ACLS         1059

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        124
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1070
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rigpsnap\dataobj.cpp ===
//
// Microsoft Corporation 1998
//
// DATAOBJ.H - CDataObject routines
//
#include "main.h"
#include <initguid.h>
#include "dataobj.h"


unsigned int CDataObject::m_cfNodeType       = RegisterClipboardFormat(CCF_NODETYPE);
unsigned int CDataObject::m_cfNodeTypeString = RegisterClipboardFormat(CCF_SZNODETYPE);
unsigned int CDataObject::m_cfDisplayName    = RegisterClipboardFormat(CCF_DISPLAY_NAME);
unsigned int CDataObject::m_cfCoClass        = RegisterClipboardFormat(CCF_SNAPIN_CLASSID);

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CDataObject implementation                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


CDataObject::CDataObject(CComponentData *pComponent)
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);

    m_pcd = pComponent;
    m_type = CCT_UNINITIALIZED;
    m_cookie = -1;
}

CDataObject::~CDataObject()
{
    InterlockedDecrement(&g_cRefThisDll);
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CDataObject object implementation (IUnknown)                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CDataObject::QueryInterface (REFIID riid, void **ppv)
{

    if (IsEqualIID(riid, IID_IGPTDataObject))
    {
        *ppv = (LPGPTDATAOBJECT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IDataObject) ||
             IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPDATAOBJECT)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CDataObject::AddRef (void)
{
    return ++m_cRef;
}

ULONG CDataObject::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CDataObject object implementation (IDataObject)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CDataObject::GetDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if(cf == m_cfNodeType)
    {
        hr = CreateNodeTypeData(lpMedium);
    }
    else if(cf == m_cfNodeTypeString)
    {
        hr = CreateNodeTypeStringData(lpMedium);
    }
    else if (cf == m_cfDisplayName)
    {
        hr = CreateDisplayName(lpMedium);
    }
    else if (cf == m_cfCoClass)
    {
        hr = CreateCoClassID(lpMedium);
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CDataObject object implementation (Internal functions)                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT CDataObject::Create(LPVOID pBuffer, INT len, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_TYMED;

    // Do some simple validation
    if (pBuffer == NULL || lpMedium == NULL)
        return E_POINTER;

    // Make sure the type medium is HGLOBAL
    if (lpMedium->tymed == TYMED_HGLOBAL)
    {
        // Create the stream on the hGlobal passed in
        LPSTREAM lpStream;
        hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

        if (SUCCEEDED(hr))
        {
            // Write to the stream the number of bytes
            unsigned long written;

            hr = lpStream->Write(pBuffer, len, &written);

            // Because we told CreateStreamOnHGlobal with 'FALSE',
            // only the stream is released here.
            // Note - the caller (i.e. snap-in, object) will free the HGLOBAL
            // at the correct time.  This is according to the IDataObject specification.
            lpStream->Release();
        }
    }

    return hr;
}

HRESULT CDataObject::CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
    const GUID * pGUID;
    LPRESULTITEM lpResultItem = (LPRESULTITEM) m_cookie;


    if (m_cookie == -1)
        return E_UNEXPECTED;

    if (m_type == CCT_RESULT)
        pGUID = g_NameSpace[lpResultItem->dwNameSpaceItem].pNodeID;
    else
        pGUID = g_NameSpace[m_cookie].pNodeID;

    // Create the node type object in GUID format
    return Create((LPVOID)pGUID, sizeof(GUID), lpMedium);

}

HRESULT CDataObject::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    const GUID * pGUID;
    LPRESULTITEM lpResultItem = (LPRESULTITEM) m_cookie;
    TCHAR szNodeType[50];

    if (m_cookie == -1)
        return E_UNEXPECTED;

    if (m_type == CCT_RESULT)
        pGUID = g_NameSpace[lpResultItem->dwNameSpaceItem].pNodeID;
    else
        pGUID = g_NameSpace[m_cookie].pNodeID;

    szNodeType[0] = TEXT('\0');
    StringFromGUID2 (*pGUID, szNodeType, ARRAYSIZE( szNodeType ));

    // Create the node type object in GUID string format
    return Create((LPVOID)szNodeType, ((lstrlenW(szNodeType)+1) * sizeof(WCHAR)), lpMedium);
}

HRESULT CDataObject::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
    WCHAR  szDispName[50];
    WCHAR  szDisplayName[100];

    if (!LoadStringW (
                g_hInstance, 
                IDS_SNAPIN_NAME, 
                szDisplayName, 
                ARRAYSIZE( szDisplayName ))) {
        return(HRESULT_FROM_WIN32(GetLastError()));
    }

    return Create((LPVOID)szDisplayName, (lstrlenW(szDisplayName) + 1) * sizeof(WCHAR), lpMedium);
}

HRESULT CDataObject::CreateCoClassID(LPSTGMEDIUM lpMedium)
{
    // Create the CoClass information
    return Create((LPVOID)&CLSID_GPTRemoteInstall, sizeof(CLSID), lpMedium);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rigpsnap\dataobj.h ===
//
// Microsoft Corporation 1998
//
// DATAOBJ.H - IGPTDataobject
//

// {70f05689-5af0-41e6-a292-396697f04fce}
DEFINE_GUID(IID_IGPTDataObject,
0x70f05689, 0x5af0, 0x41e6, 0xa2, 0x92, 0x39, 0x66, 0x97, 0xf0, 0x4f, 0xce);

#ifndef _DATAOBJ_H_
#define _DATAOBJ_H_

//
// This is a private dataobject interface for GPTs.
// When the GPT snapin receives a dataobject and needs to determine
// if it came from the GPT snapin or a different component, it can QI for
// this interface.
//

#undef INTERFACE
#define INTERFACE   IGPTDataObject
DECLARE_INTERFACE_(IGPTDataObject, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;


    // *** IGPTDataObject methods ***

    STDMETHOD(SetType) (THIS_ DATA_OBJECT_TYPES type) PURE;
    STDMETHOD(GetType) (THIS_ DATA_OBJECT_TYPES *type) PURE;

    STDMETHOD(SetCookie) (THIS_ MMC_COOKIE cookie) PURE;
    STDMETHOD(GetCookie) (THIS_ MMC_COOKIE *cookie) PURE;
};
typedef IGPTDataObject *LPGPTDATAOBJECT;

// CDataObject class
class CDataObject : public IDataObject,
                    public IGPTDataObject
{
    friend class CSnapIn;

protected:
    ULONG                  m_cRef;
    CComponentData        *m_pcd;
    DATA_OBJECT_TYPES      m_type;
    MMC_COOKIE             m_cookie;

    // Clipboard formats that are required by the console
    static unsigned int    m_cfNodeType;
    static unsigned int    m_cfNodeTypeString;
    static unsigned int    m_cfDisplayName;
    static unsigned int    m_cfCoClass;

public:
    CDataObject(CComponentData *pComponent);
    ~CDataObject();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


    // Implemented IDataObject methods
    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);


    // Unimplemented IDataObject methods
    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL; };

    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };

    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc)
    { return E_NOTIMPL; };

    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };

    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,
                LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(DUnadvise)(DWORD dwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };


    // Implemented IGPTDataObject methods
    STDMETHOD(SetType) (DATA_OBJECT_TYPES type)
    { m_type = type; return S_OK; };

    STDMETHOD(GetType) (DATA_OBJECT_TYPES *type)
    { *type = m_type; return S_OK; };

    STDMETHOD(SetCookie) (MMC_COOKIE cookie)
    { m_cookie = cookie; return S_OK; };

    STDMETHOD(GetCookie) (MMC_COOKIE *cookie)
    { *cookie = m_cookie; return S_OK; };


private:
    HRESULT CreateNodeTypeData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
    HRESULT CreateDisplayName(LPSTGMEDIUM lpMedium);
    HRESULT CreateCoClassID(LPSTGMEDIUM lpMedium);

    HRESULT Create(LPVOID pBuffer, INT len, LPSTGMEDIUM lpMedium);
};

#endif // _DATAOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rigpsnap\debug.cpp ===
//
// Microsoft Corporation 1998
//
// DEBUG.CPP - Debug library
//
#include "main.h"

#if DBG

//
// Global Variable containing the debugging level.
//

DWORD   dwDebugLevel;

//
// Debug strings
//

const TCHAR c_szGPTDemo[] = TEXT("RIGPSNAP(%x): ");
const TCHAR c_szCRLF[]    = TEXT("\r\n");


//
// Registry debug information
//

#define DEBUG_REG_LOCATION  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define DEBUG_KEY_NAME      TEXT("RIGPSNAP")

//*************************************************************
//
//  InitDebugSupport()
//
//  Purpose:    Sets the debugging level.
//              Also checks the registry for a debugging level.
//
//  Parameters: None
//
//  Return:     void
//
//  Comments:
//
//
//  History:    Date        Author     Comment
//              5/25/95     ericflo    Created
//
//*************************************************************

void InitDebugSupport(void)
{
    LONG lResult;
    HKEY hKey;
    DWORD dwType, dwSize;

    //
    // Initialize the debug level to normal
    //

    dwDebugLevel = DL_NORMAL;


    //
    // Check the registry
    //

    lResult = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE, 
                    DEBUG_REG_LOCATION,
                    0,
                    KEY_READ,
                    &hKey);

    if (lResult == ERROR_SUCCESS) {

        dwSize = sizeof(dwDebugLevel);
        RegQueryValueEx(hKey, DEBUG_KEY_NAME, NULL, &dwType,
                        (LPBYTE)&dwDebugLevel, &dwSize);

        RegCloseKey(hKey);
    }
}

//*************************************************************
//
//  DebugMsg()
//
//  Purpose:    Displays debug messages based on the debug level
//              and type of debug message.
//
//  Parameters: mask    -   debug message type
//              pszMsg  -   debug message
//              ...     -   variable number of parameters
//      
//  Return:     void
//
//
//  Comments:
//
//
//  History:    Date        Author     Comment
//              5/25/95     ericflo    Created
//
//*************************************************************

void _DebugMsg(UINT mask, LPCTSTR pszMsg, ...)
{
    BOOL bOutput;
    TCHAR szDebugTitle[30];
    TCHAR szDebugBuffer[2*MAX_PATH+40];
    va_list marker;
    DWORD dwErrCode;


    //
    // Save the last error code (so the debug output doesn't change it).
    //

    dwErrCode = GetLastError();


    //
    // Detemerine the correct amount of debug output
    //

    switch (LOWORD(dwDebugLevel)) {

        case DL_VERBOSE:
            bOutput = TRUE;
            break;

        case DL_NORMAL:

            //
            // Normal debug output.  Don't
            // display verbose stuff, but
            // do display warnings/asserts.
            //

            if (mask != DM_VERBOSE) {
                bOutput = TRUE;
            } else {
                bOutput = FALSE;
            }
            break;

        case DL_NONE:
        default:

            //
            // Only display asserts
            //

            if (mask == DM_ASSERT) {
                bOutput = TRUE;
            } else {
                bOutput = FALSE;
            }
            break;
    }


    //
    // Display the error message if appropriate
    //

    if (bOutput) {
        wsprintf (szDebugTitle, c_szGPTDemo, GetCurrentProcessId());
        OutputDebugString(szDebugTitle);

        va_start(marker, pszMsg);
        wvsprintf(szDebugBuffer, pszMsg, marker);
        OutputDebugString(szDebugBuffer);
        OutputDebugString(c_szCRLF);
        va_end(marker);

        if (dwDebugLevel & DL_LOGFILE) {
            HANDLE hFile;
            DWORD dwBytesWritten;

            hFile = CreateFile(TEXT("c:\\rigpsnap.log"),
                               GENERIC_WRITE,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);

            if (hFile != INVALID_HANDLE_VALUE) {

                if (SetFilePointer (hFile, 0, NULL, FILE_END) != 0xFFFFFFFF) {

                    WriteFile (hFile, (LPCVOID) szDebugTitle,
                               lstrlen (szDebugTitle) * sizeof(TCHAR),
                               &dwBytesWritten,
                               NULL);

                    WriteFile (hFile, (LPCVOID) szDebugBuffer,
                               lstrlen (szDebugBuffer) * sizeof(TCHAR),
                               &dwBytesWritten,
                               NULL);

                    WriteFile (hFile, (LPCVOID) c_szCRLF,
                               lstrlen (c_szCRLF) * sizeof(TCHAR),
                               &dwBytesWritten,
                               NULL);
                }

                CloseHandle (hFile);
            }

        }

    }


    //
    // Restore the last error code
    //

    SetLastError(dwErrCode);


    //
    // Break to the debugger if appropriate
    //

    if (mask == DM_ASSERT) {
        DebugBreak();
    }
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rigpsnap\compdata.cpp ===
//
// Microsoft Corporation 1998
//
// COMPDATA.CPP - CComponentData and CComponentDataCF routines
//
#include "main.h"


///////////////////////////////////////////////////////////////////////////////
// CComponentData object implementation

CComponentData::CComponentData()
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);
    m_hwndFrame = NULL;
    m_pScope = NULL;
    m_pConsole = NULL;
    m_hRoot = NULL;
    m_pGPTInformation = NULL;
}

CComponentData::~CComponentData()
{
    if (m_pScope)
    {
        m_pScope->Release();
    }

    if (m_pConsole)
    {
        m_pConsole->Release();
    }

    if (m_pGPTInformation)
    {
        m_pGPTInformation->Release();
    }

    InterlockedDecrement(&g_cRefThisDll);

}


///////////////////////////////////////////////////////////////////////////////
// CComponentData object implementation (IUnknown)

HRESULT CComponentData::QueryInterface (REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IComponentData) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPCOMPONENT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_ISnapinHelp ))
    {
        *ppv = (ISnapinHelp *) this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IPersistStreamInit))
    {
        *ppv = (LPPERSISTSTREAMINIT)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CComponentData::AddRef (void)
{
    return ++m_cRef;
}

ULONG CComponentData::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////////
// CComponentData object implementation (IComponentData)

STDMETHODIMP CComponentData::Initialize(LPUNKNOWN pUnknown)
{
    HRESULT hr;
    HBITMAP bmp16x16;
    LPIMAGELIST lpScopeImage;


    //
    // QI for IConsoleNameSpace
    //

    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (LPVOID *)&m_pScope);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Initialize: Failed to QI for IConsoleNameSpace.")));
        return hr;
    }


    //
    // QI for IConsole
    //

    hr = pUnknown->QueryInterface(IID_IConsole, (LPVOID *)&m_pConsole);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Initialize: Failed to QI for IConsole.")));
        m_pScope->Release();
        m_pScope = NULL;
        return hr;
    }

    m_pConsole->GetMainWindow (&m_hwndFrame);


    //
    // Query for the scope imagelist interface
    //

    hr = m_pConsole->QueryScopeImageList(&lpScopeImage);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Initialize: Failed to QI for scope imagelist.")));
        m_pScope->Release();
        m_pScope = NULL;
        m_pConsole->Release();
        m_pConsole=NULL;
        return hr;
    }

    // Load the bitmaps from the dll
    bmp16x16=LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_16x16));

    // Set the images
    lpScopeImage->ImageListSetStrip(reinterpret_cast<PLONG_PTR>(bmp16x16),
                      reinterpret_cast<PLONG_PTR>(bmp16x16),
                       0, RGB(255, 0, 255));

    lpScopeImage->Release();

    DeleteObject( bmp16x16 );

    return S_OK;
}

STDMETHODIMP CComponentData::Destroy(VOID)
{
    return S_OK;
}

STDMETHODIMP CComponentData::CreateComponent(LPCOMPONENT *ppComponent)
{
    HRESULT hr;
    CSnapIn *pSnapIn;


    DebugMsg((DM_VERBOSE, TEXT("CComponentData::CreateComponent: Entering.")));

    //
    // Initialize
    //

    *ppComponent = NULL;


    //
    // Create the snapin view
    //

    pSnapIn = new CSnapIn(this);

    if (!pSnapIn)
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::CreateComponent: Failed to create CSnapIn.")));
        return E_OUTOFMEMORY;
    }


    //
    // QI for IComponent
    //

    hr = pSnapIn->QueryInterface(IID_IComponent, (LPVOID *)ppComponent);
    pSnapIn->Release();     // release QI


    return hr;
}

STDMETHODIMP CComponentData::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                                             LPDATAOBJECT* ppDataObject)
{
    HRESULT hr = E_NOINTERFACE;
    CDataObject *pDataObject;
    LPGPTDATAOBJECT pGPTDataObject;


    //
    // Create a new DataObject
    //

    pDataObject = new CDataObject(this);   // ref == 1

    if (!pDataObject)
        return E_OUTOFMEMORY;


    //
    // QI for the private GPTDataObject interface so we can set the cookie
    // and type information.
    //

    hr = pDataObject->QueryInterface(IID_IGPTDataObject, (LPVOID *)&pGPTDataObject);

    if (FAILED(hr))
    {
        pDataObject->Release();
        return (hr);
    }

    pGPTDataObject->SetType(type);
    pGPTDataObject->SetCookie(cookie);
    pGPTDataObject->Release();


    //
    // QI for a normal IDataObject to return.
    //

    hr = pDataObject->QueryInterface(IID_IDataObject, (LPVOID *)ppDataObject);

    pDataObject->Release();     // release initial ref

    return hr;
}

STDMETHODIMP CComponentData::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;

    switch(event)
    {
        case MMCN_EXPAND:
            if (arg == TRUE)

                if (!m_pGPTInformation)
                {
                    lpDataObject->QueryInterface(IID_IGPEInformation, (LPVOID *)&m_pGPTInformation);
                }

                if (m_pGPTInformation)
                {
                    hr = EnumerateScopePane(lpDataObject, (HSCOPEITEM)param);
                }
            break;

        default:
            break;
    }

    return hr;
}

STDMETHODIMP CComponentData::GetDisplayInfo(LPSCOPEDATAITEM pItem)
{
    DWORD dwIndex;

    if (pItem == NULL)
        return E_POINTER;

    for (dwIndex = 0; dwIndex < NUM_NAMESPACE_ITEMS; dwIndex++)
    {
        if (g_NameSpace[dwIndex].dwID == (DWORD) pItem->lParam)
            break;
    }

    if (dwIndex == NUM_NAMESPACE_ITEMS)
        pItem->displayname = NULL;
    else
    {
        pItem->displayname = g_NameSpace[dwIndex].szDisplayName;
    }

    return S_OK;
}

STDMETHODIMP CComponentData::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    HRESULT hr = S_FALSE;
    LPGPTDATAOBJECT pGPTDataObjectA, pGPTDataObjectB;
    MMC_COOKIE cookie1, cookie2;


    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    //
    // QI for the private GPTDataObject interface
    //

    if (FAILED(lpDataObjectA->QueryInterface(IID_IGPTDataObject,
                                            (LPVOID *)&pGPTDataObjectA)))
    {
        return S_FALSE;
    }


    if (FAILED(lpDataObjectB->QueryInterface(IID_IGPTDataObject,
                                            (LPVOID *)&pGPTDataObjectB)))
    {
        pGPTDataObjectA->Release();
        return S_FALSE;
    }

    pGPTDataObjectA->GetCookie(&cookie1);
    pGPTDataObjectB->GetCookie(&cookie2);

    if (cookie1 == cookie2)
    {
        hr = S_OK;
    }


    pGPTDataObjectA->Release();
    pGPTDataObjectB->Release();

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
// CComponentData object implementation (IPersistStreamInit)

STDMETHODIMP CComponentData::GetClassID(CLSID *pClassID)
{

    if (!pClassID)
    {
        return E_POINTER;
    }

    *pClassID = CLSID_GPTRemoteInstall;

    return S_OK;
}

STDMETHODIMP CComponentData::IsDirty(VOID)
{
    return S_FALSE;
}

STDMETHODIMP CComponentData::Load(IStream *pStm)
{
    return S_OK;
}


STDMETHODIMP CComponentData::Save(IStream *pStm, BOOL fClearDirty)
{
    return S_OK;
}


STDMETHODIMP CComponentData::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    DWORD dwSize = 0;


    if (!pcbSize)
    {
        return E_POINTER;
    }

    ULISet32(*pcbSize, dwSize);

    return S_OK;
}

STDMETHODIMP CComponentData::InitNew(void)
{
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// CComponentData object implementation (Internal functions)

HRESULT CComponentData::EnumerateScopePane (LPDATAOBJECT lpDataObject, HSCOPEITEM hParent)
{
    SCOPEDATAITEM item;
    HRESULT hr;
    DWORD dwIndex, i;


    if (!m_hRoot)
        m_hRoot = hParent;


    if (m_hRoot == hParent)
        dwIndex = 0;
    else
    {
        item.mask = SDI_PARAM;
        item.ID = hParent;

        hr = m_pScope->GetItem (&item);

        if (FAILED(hr))
            return hr;

        dwIndex = (DWORD) item.lParam;
    }

    for (i = 0; i < NUM_NAMESPACE_ITEMS; i++)
    {
        if (g_NameSpace[i].dwParent == dwIndex)
        {
            item.mask = SDI_STR | SDI_STATE | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM | SDI_CHILDREN;
            item.displayname = MMC_CALLBACK;
            item.nImage = 0;
            item.nOpenImage = 0;
            item.nState = 0;
            item.cChildren = g_NameSpace[i].cChildren;
            item.lParam = g_NameSpace[i].dwID;
            item.relativeID =  hParent;

            m_pScope->InsertItem (&item);
        }
    }

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Class factory object implementation

CComponentDataCF::CComponentDataCF()
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);
}

CComponentDataCF::~CComponentDataCF()
{
    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
// Class factory object implementation (IUnknown)

STDMETHODIMP_(ULONG)
CComponentDataCF::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CComponentDataCF::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CComponentDataCF::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (LPCLASSFACTORY)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


///////////////////////////////////////////////////////////////////////////////
// Class factory object implementation (IClassFactory)


STDMETHODIMP
CComponentDataCF::CreateInstance(LPUNKNOWN   pUnkOuter,
                             REFIID      riid,
                             LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    CComponentData *pComponentData = new CComponentData(); // ref count == 1

    if (!pComponentData)
        return E_OUTOFMEMORY;

    HRESULT hr = pComponentData->QueryInterface(riid, ppvObj);
    pComponentData->Release();                       // release initial ref

    return hr;
}


STDMETHODIMP
CComponentDataCF::LockServer(BOOL fLock)
{
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////////////////////////
// Class factory object creation (IClassFactory)

HRESULT CreateComponentDataClassFactory (REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;

    if (IsEqualCLSID (rclsid, CLSID_GPTRemoteInstall)) {

        CComponentDataCF *pComponentDataCF = new CComponentDataCF();   // ref == 1

        if (!pComponentDataCF)
            return E_OUTOFMEMORY;

        hr = pComponentDataCF->QueryInterface(riid, ppv);

        pComponentDataCF->Release();     // release initial ref

        return hr;
    }

    return CLASS_E_CLASSNOTAVAILABLE;
}

///////////////////////////////////////////////////////////////////////////////
//
// CComponentData object implementation (ISnapinHelp)
//

STDMETHODIMP CComponentData::GetHelpTopic(LPOLESTR *lpCompiledHelpFile)
{
    LPOLESTR lpHelpFile;

    lpHelpFile = (LPOLESTR) CoTaskMemAlloc (MAX_PATH * sizeof(WCHAR));

    if (!lpHelpFile)
    {
        return E_OUTOFMEMORY;
    }

    if (!ExpandEnvironmentStringsW (L"%SystemRoot%\\Help\\ris.chm",
                               lpHelpFile, MAX_PATH)) {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
        CoTaskMemFree(lpHelpFile);
        return hr;
    }

    *lpCompiledHelpFile = lpHelpFile;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rigpsnap\debug.h ===
//
// Microsoft Corporation 1998
//
// DEBUG.H - Debugging flags and macros
//
#if DBG

//
// Debug Levels
//

#define DL_NONE     0x00000000
#define DL_NORMAL   0x00000001
#define DL_VERBOSE  0x00000002
#define DL_LOGFILE  0x00010000


//
// Debug message types
//

#define DM_WARNING  0
#define DM_ASSERT   1
#define DM_VERBOSE  2


//
// Debug macros
//

#define DebugMsg(x) _DebugMsg x


//
// Debug function proto-types
//

void _DebugMsg(UINT mask, LPCTSTR pszMsg, ...);
void InitDebugSupport(void);

#else

#define DebugMsg(x)


#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rigpsnap\guids.cpp ===
//
// Microsoft Corporation 1998
//
// GUIDS.CPP - External GUID library
//
#include "main.h"
#include <initguid.h>
#include "guids.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rigpsnap\compdata.h ===
//
// Microsoft Corporation 1998
//
// COMPDATA.H -  CComponentData class
//

class CComponentData:
    public IComponentData,
    public IPersistStreamInit,
    public ISnapinHelp
{
    friend class CDataObject;
    friend class CSnapIn;

protected:
    ULONG                m_cRef;
    HWND                 m_hwndFrame;
    LPCONSOLENAMESPACE   m_pScope;
    LPCONSOLE            m_pConsole;
    HSCOPEITEM           m_hRoot;
    LPGPEINFORMATION     m_pGPTInformation;

public:
    CComponentData();
    ~CComponentData();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // Implemented IComponentData methods
    STDMETHODIMP         Initialize(LPUNKNOWN pUnknown);
    STDMETHODIMP         CreateComponent(LPCOMPONENT* ppComponent);
    STDMETHODIMP         QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHODIMP         Destroy(void);
    STDMETHODIMP         Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHODIMP         GetDisplayInfo(LPSCOPEDATAITEM pItem);
    STDMETHODIMP         CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);


    // Implemented IPersistStreamInit interface members
    STDMETHODIMP         GetClassID(CLSID *pClassID);
    STDMETHODIMP         IsDirty(VOID);
    STDMETHODIMP         Load(IStream *pStm);
    STDMETHODIMP         Save(IStream *pStm, BOOL fClearDirty);
    STDMETHODIMP         GetSizeMax(ULARGE_INTEGER *pcbSize);
    STDMETHODIMP         InitNew(VOID);

    //
    // ISnapinHelp
    //
    STDMETHODIMP        GetHelpTopic( LPOLESTR * lpCompiledHelpFile );
        
private:
    HRESULT EnumerateScopePane(LPDATAOBJECT lpDataObject, HSCOPEITEM hParent);
};



// ComponentData class factory
class CComponentDataCF : public IClassFactory
{
protected:
    ULONG m_cRef;

public:
    CComponentDataCF();
    ~CComponentDataCF();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IClassFactory methods
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR *);
    STDMETHODIMP LockServer(BOOL);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rigpsnap\layout.cpp ===
//
// Microsoft Corporation 1998
//
// LAYOUT.CPP - This file contains the tool's namespace and result pane items
//
#include "main.h"

RESULTITEM g_Undefined[] =
{
    { 1, 1, 0, 0, {0} }
};


RESULTITEM g_Samples[] =
{
    { 2, 1, IDS_CHOICEOSC, 0, {0} }
};

// KB: Be sure to update NUM_NAMESPACE_ITEMS define in layout.h if you
// add / remove from this array.

NAMESPACEITEM g_NameSpace[] =
{
    { 0, -1, 0,          0, {0}, 0, g_Undefined, &NODEID_User },   // Root
    { 1, 0, IDS_SAMPLES, 0, {0}, 1, g_Samples,   &NODEID_RemoteInstall }
};

//
// InitNameSpace()
//
BOOL InitNameSpace()
{
    DWORD dwIndex;
	DWORD dw;

    for (dwIndex = 1; dwIndex < NUM_NAMESPACE_ITEMS; dwIndex++)
    {
        if (!LoadString (g_hInstance, g_NameSpace[dwIndex].iStringID,
                    g_NameSpace[dwIndex].szDisplayName,
                    ARRAYSIZE( g_NameSpace[dwIndex].szDisplayName ))) {
            return(FALSE);
        }
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rigpsnap\guids.h ===
//
// Microsoft Corporation 1998
//
//
// GUIDS.H
//


// {E69275E8-6FAF-11d2-842D-00C04FA372D4}
DEFINE_GUID( NODEID_GPERoot, 
0xe69275e8, 0x6faf, 0x11d2, 0x84, 0x2d, 0x0, 0xc0, 0x4f, 0xa3, 0x72, 0xd4);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rigpsnap\main.h ===
//
// Microsoft Corporation 1998
//
// MAIN.H - Precompiled Header
//
#define INLINE_HRESULT_FROM_WIN32
#include <windows.h>
#include <stdio.h>
#include <windowsx.h>
#include <lm.h>
#include <ole2.h>
#include <olectl.h>
#include <shellapi.h>
#include <shlobj.h>
#include <commctrl.h>
#include <prsht.h>
#include <mmc.h>
#include <gpedit.h>

#include "rigpsnap.h"
class CSnapIn;

#include "layout.h"
#include "compdata.h"
#include "snapin.h"
#include "dataobj.h"
#include "debug.h"
#include "util.h"
#include "resource.h"

// Global variables
extern LONG g_cRefThisDll;
extern HINSTANCE g_hInstance;

// Macros
#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

// Functions to create class factories
HRESULT CreateComponentDataClassFactory (REFCLSID rclsid, REFIID riid, LPVOID* ppv);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rigpsnap\layout.h ===
//
// Microsoft Corporation 1998
//
// LAYOUT.H - Tool layout structures and constants
//
#define NUM_NAMESPACE_ITEMS       2
#define MAX_DISPLAYNAME_SIZE    100

typedef struct _RESULTITEM
{
    DWORD        dwID;
    DWORD        dwNameSpaceItem;
    INT          iStringID;
    INT          iImage;
    TCHAR        szDisplayName[MAX_DISPLAYNAME_SIZE];
} RESULTITEM, *LPRESULTITEM;

typedef struct _NAMESPACEITEM
{
    DWORD        dwID;
    DWORD        dwParent;
    INT          iStringID;
    INT          cChildren;
    TCHAR        szDisplayName[MAX_DISPLAYNAME_SIZE];
    INT          cResultItems;
    LPRESULTITEM pResultItems;
    const GUID   *pNodeID;
} NAMESPACEITEM, *LPNAMESPACEITEM;

extern RESULTITEM g_Root[];
extern RESULTITEM g_Undefined[];
extern NAMESPACEITEM g_NameSpace[];

BOOL InitNameSpace();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rigpsnap\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rigpsnap.rc
//
#define IDS_SAMPLES                     1
#define IDI_POLICY                      1
#define IDB_16x16                       1
#define IDS_SNAPIN_NAME                 1
#define IDI_README                      2
#define IDB_32x32                       2
#define IDI_NETHOOD                     3
#define IDI_STARTMENU                   4
#define IDI_MYDOCS                      5
#define IDI_PUBDOCS                     6
#define IDI_APPEAR                      7
#define IDS_CHOICEOSC                   8
#define IDS_AUTO                        21
#define IDS_CUSTOM                      22
#define IDS_RESTART                     23
#define IDS_TOOLS                       24
#define IDS_NAME                        25
#define IDD_SCREEN                      100
#define IDD_README                      101
#define IDI_REMOTEINSTAL                101
#define IDC_FIRST_RADIO_BUTTON          1000
#define IDC_R_AUTO_ALLOW                1001
#define IDC_R_AUTO_DONTCARE             1002
#define IDC_R_AUTO_DENY                 1003
#define IDC_R_CUST_ALLOW                1004
#define IDC_R_CUST_DONTCARE             1005
#define IDC_R_CUST_DENY                 1006
#define IDC_R_RESTART_ALLOW             1007
#define IDC_R_RESTART_DONTCARE          1008
#define IDC_R_RESTART_DENY              1009
#define IDC_R_TOOLS_ALLOW               1010
#define IDC_R_TOOLS_DONTCARE            1011
#define IDC_R_TOOLS_DENY                1012
#define IDC_LAST_RADIO_BUTTON           1013
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1020
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rigpsnap\rigpsnap.cpp ===
//
// Microsoft Corporation 1998
//
// RIGPSNAP.CPP - DLL entry and registration routines
//
#include "main.h"
#include <initguid.h>
#include <rigpsnap.h>
#include <gpedit.h>

// Globals
LONG g_cRefThisDll = 0;
HINSTANCE g_hInstance;

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
       g_hInstance = hInstance;
       DisableThreadLibraryCalls(hInstance);
       InitNameSpace();
#if DBG
       InitDebugSupport();
#endif
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (g_cRefThisDll == 0 ? S_OK : S_FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return (CreateComponentDataClassFactory (rclsid, riid, ppv));
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

const TCHAR szSnapInLocation[] = TEXT("%SystemRoot%\\System32\\RIGPSNAP.dll");

STDAPI DllRegisterServer(void)
{
    TCHAR szSnapInKey[50];
    TCHAR szSubKey[200];
    TCHAR szSnapInName[100];
    TCHAR szGUID[50];
    DWORD dwDisp, dwIndex;
    LONG lResult;
    HKEY hKey;


    StringFromGUID2 (CLSID_GPTRemoteInstall, szSnapInKey, ARRAYSIZE( szSnapInKey ));

    //
    // Register SnapIn in HKEY_CLASSES_ROOT
    //

    if (!LoadString (
            g_hInstance, 
            IDS_SNAPIN_NAME, 
            szSnapInName, 
            ARRAYSIZE( szSnapInName ))) {
        return SELFREG_E_CLASS;
    }

    if (_snwprintf(szSubKey,
                   ARRAYSIZE(szSubKey),
                   TEXT("CLSID\\%s"), szSnapInKey) < 0) {
        return SELFREG_E_CLASS;
    }

    szSubKey[ARRAYSIZE(szSubKey)-1] = TEXT('\0');
    
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    lResult = RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));
    
    RegCloseKey (hKey);

    if (lResult != ERROR_SUCCESS) {        
        return SELFREG_E_CLASS;
    }

    if (_snwprintf(szSubKey,
                   ARRAYSIZE(szSubKey),
                   TEXT("CLSID\\%s\\InProcServer32"), szSnapInKey) < 0) {
        return SELFREG_E_CLASS;
    }
    
    szSubKey[ARRAYSIZE(szSubKey)-1] = TEXT('\0');

    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    lResult = RegSetValueEx (hKey, NULL, 0, REG_EXPAND_SZ, (LPBYTE)szSnapInLocation,
                   (lstrlen(szSnapInLocation) + 1) * sizeof(TCHAR));
    RegCloseKey (hKey);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    //
    // Register SnapIn with MMC
    //
    if (_snwprintf(szSubKey,
                   ARRAYSIZE(szSubKey),
                   TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s"), szSnapInKey) < 0) {
        return SELFREG_E_CLASS;
    }
    szSubKey[ARRAYSIZE(szSubKey)-1] = TEXT('\0');

    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    TCHAR szModuleFileName[MAX_PATH];
    ZeroMemory(szModuleFileName, sizeof(szModuleFileName));
    DWORD dwRet = GetModuleFileName(
                            g_hInstance,
                            szModuleFileName,
                            ARRAYSIZE(szModuleFileName));
    if (0 != dwRet) {
        TCHAR strNameIndirect[MAX_PATH];

        szModuleFileName[ARRAYSIZE(szModuleFileName)-1] = TEXT('\0');
        if (_snwprintf(
                strNameIndirect,
                ARRAYSIZE(strNameIndirect),
                TEXT("@%s,-%u"), 
                szModuleFileName, 
                IDS_SNAPIN_NAME) < 0) {
            lResult = ERROR_INSUFFICIENT_BUFFER;
        } else {
            strNameIndirect[ARRAYSIZE(strNameIndirect)-1] = TEXT('\0');
            lResult = RegSetValueEx(
                            hKey, 
                            TEXT("NameStringIndirect"), 
                            0, 
                            REG_SZ, 
                            (LPBYTE)strNameIndirect,
                            (lstrlen(strNameIndirect) + 1) * sizeof(TCHAR));
        }

    } else {
        lResult = (LONG)dwRet;
    }

    if (lResult != ERROR_SUCCESS) {
        RegCloseKey (hKey);
        return SELFREG_E_CLASS;
    }

    lResult = RegSetValueEx (hKey, TEXT("NameString"), 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }


    for (dwIndex = 0; dwIndex < NUM_NAMESPACE_ITEMS; dwIndex++)
    {
        StringFromGUID2 (*g_NameSpace[dwIndex].pNodeID, szGUID, ARRAYSIZE( szGUID ));

        if (_snwprintf(
                szSubKey, 
                ARRAYSIZE(szSubKey),
                TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s\\NodeTypes\\%s"),
                szSnapInKey, 
                szGUID) < 0) {
            return SELFREG_E_CLASS;
        }
        szSubKey[ARRAYSIZE(szSubKey)-1] = TEXT('\0');

        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegCloseKey (hKey);
    }


    //
    // Register in the NodeTypes key
    //

    for (dwIndex = 0; dwIndex < NUM_NAMESPACE_ITEMS; dwIndex++)
    {
        StringFromGUID2 (*g_NameSpace[dwIndex].pNodeID, szGUID, ARRAYSIZE( szGUID ));

        if (_snwprintf(
                szSubKey,
                ARRAYSIZE(szSubKey),
                TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s"),
                szGUID) < 0) {
            return SELFREG_E_CLASS;
        }
        szSubKey[ARRAYSIZE(szSubKey)-1] = TEXT('\0');
        
        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegCloseKey (hKey);
    }


    //
    // Register as an extension for various nodes
    //

    StringFromGUID2 (NODEID_User, szGUID, 50);

    if (_snwprintf(
                szSubKey,
                ARRAYSIZE(szSubKey),
                TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\NameSpace"), 
                szGUID) < 0 ) {
        return SELFREG_E_CLASS;
    }
    szSubKey[ARRAYSIZE(szSubKey)-1] = TEXT('\0');

    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    lResult = RegSetValueEx (hKey, szSnapInKey, 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));


    RegCloseKey (hKey);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    TCHAR szSnapInKey[50];
    TCHAR szSubKey[200];
    TCHAR szGUID[50];
    DWORD dwIndex;
    LONG lResult;
    HKEY hKey;
    DWORD dwDisp;

    StringFromGUID2 (CLSID_GPTRemoteInstall, szSnapInKey, ARRAYSIZE( szSnapInKey ));

    if (_snwprintf(
            szSubKey,
            ARRAYSIZE(szSubKey),
            TEXT("CLSID\\%s"), 
            szSnapInKey) < 0) {
        return SELFREG_E_CLASS;
    }
    szSubKey[ARRAYSIZE(szSubKey)-1] = TEXT('\0');
    
    RegDelnode (HKEY_CLASSES_ROOT, szSubKey);

    if (_snwprintf(
              szSubKey,
              ARRAYSIZE(szSubKey),
              TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s"), 
              szSnapInKey) < 0) {
        return SELFREG_E_CLASS;
    }
    szSubKey[ARRAYSIZE(szSubKey)-1] = TEXT('\0');

    RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);

#if 0
    //
    // Don't delete these keys because they aren't RIS-specific.  Whacking
    // them here means we might be killing someone else.
    //
    for (dwIndex = 0; dwIndex < NUM_NAMESPACE_ITEMS; dwIndex++)
    {
        StringFromGUID2 (*g_NameSpace[dwIndex].pNodeID, szGUID, ARRAYSIZE( szGUID ));
        wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s"), szGUID);
        RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);
    }
#endif

    StringFromGUID2 (NODEID_User, szGUID, ARRAYSIZE( szGUID ));
    if (_snwprintf(
            szSubKey, 
            ARRAYSIZE(szSubKey),
            TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\NameSpace"), 
            szGUID) < 0) {
        return SELFREG_E_CLASS;
    }
    szSubKey[ARRAYSIZE(szSubKey)-1] = TEXT('\0');
    
    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0,
                              KEY_WRITE, &hKey);


    if (lResult == ERROR_SUCCESS) {
        RegDeleteValue (hKey, szSnapInKey);
        RegCloseKey (hKey);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rigpsnap\rigpsnap.h ===
//
// Microsoft Corporation 1998
//
// RIGPSNAP.H - Tool GUIDs
//

// {3060E8CE-7020-11d2-842D-00C04FA372D4}
DEFINE_GUID(CLSID_GPTRemoteInstall, 
0x3060e8ce, 0x7020, 0x11d2, 0x84, 0x2d, 0x0, 0xc0, 0x4f, 0xa3, 0x72, 0xd4);

// {3060E8CF-7020-11d2-842D-00C04FA372D4}
DEFINE_GUID(NODEID_RemoteInstall, 
0x3060e8cf, 0x7020, 0x11d2, 0x84, 0x2d, 0x0, 0xc0, 0x4f, 0xa3, 0x72, 0xd4);

// {E69275E8-6FAF-11d2-842D-00C04FA30000}
DEFINE_GUID(CLSID_RIClientExtension, 
0x3060e8d0, 0x7020, 0x11d2, 0x84, 0x2d, 0x0, 0xc0, 0x4f, 0xa3, 0x72, 0xd4);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rigpsnap\snapin.cpp ===
//
// Microsoft Corporation 1998
//
// SNAPIN.CPP - CSnapin rountines
//
#include "main.h"
#include <shlwapi.h>

#define MAX_INI_SECTION_SIZE 10
#define MAX_OPTION_SIZE 256

#define RIGPSNAP_HELP_TOPIC L"RISconcepts.chm::/sag_RIS_CIW_Policy_and_ACLs.htm"

unsigned int CSnapIn::m_cfNodeType = RegisterClipboardFormat(CCF_NODETYPE);
TCHAR CSnapIn::m_szDefaultIcon[] = TEXT("mydocs.dll,0");


struct {
    DWORD dwCtlIdAllow;     // dialog control IDs
    DWORD dwCtlIdDontCare;  // dialog control IDs
    DWORD dwCtlIdDeny;      // dialog control IDs
    DWORD dwValId;          // string resouce ID for the option's name
} g_ChoiceOptions[] = {
    { IDC_R_AUTO_ALLOW,     IDC_R_AUTO_DONTCARE,    IDC_R_AUTO_DENY,    IDS_AUTO    },
    { IDC_R_CUST_ALLOW,     IDC_R_CUST_DONTCARE,    IDC_R_CUST_DENY,    IDS_CUSTOM  },
    { IDC_R_RESTART_ALLOW,  IDC_R_RESTART_DONTCARE, IDC_R_RESTART_DENY, IDS_RESTART },
    { IDC_R_TOOLS_ALLOW,    IDC_R_TOOLS_DONTCARE,   IDC_R_TOOLS_DENY,   IDS_TOOLS   }
};

///////////////////////////////////////////////////////////////////////////////
//
// CSnapIn object implementation
//
CSnapIn::CSnapIn(CComponentData *pComponent)
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);

    m_pcd = pComponent;

    m_pConsole = NULL;
    m_pResult = NULL;
    m_pHeader = NULL;
    m_pImageResult = NULL;
    m_pConsoleVerb = NULL;
    m_nColumnSize = 180;
    m_lViewMode = LVS_ICON;

    //LoadString(g_hInstance, IDS_NAME, m_column1, sizeof(m_column1));
}

CSnapIn::~CSnapIn()
{
    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//
// CSnapIn object implementation (IUnknown)
//

HRESULT CSnapIn::QueryInterface (REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IComponent) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPCOMPONENT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IExtendPropertySheet))
    {
        *ppv = (LPEXTENDPROPERTYSHEET)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CSnapIn::AddRef (void)
{
    return ++m_cRef;
}

ULONG CSnapIn::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////////
//
// CSnapIn object implementation (IComponent)
//
STDMETHODIMP CSnapIn::Initialize(LPCONSOLE lpConsole)
{
    HRESULT hr;

    if (!LoadString(g_hInstance, IDS_NAME, m_column1, ARRAYSIZE(m_column1))) {
        return(HRESULT_FROM_WIN32(GetLastError()));
    }

    // Save the IConsole pointer
    m_pConsole = lpConsole;
    m_pConsole->AddRef();

    hr = m_pConsole->QueryInterface(IID_IHeaderCtrl,
                        reinterpret_cast<void**>(&m_pHeader));

    // Give the console the header control interface pointer
    if (SUCCEEDED(hr))
        m_pConsole->SetHeader(m_pHeader);

    m_pConsole->QueryInterface(IID_IResultData,
                        reinterpret_cast<void**>(&m_pResult));

    hr = m_pConsole->QueryResultImageList(&m_pImageResult);

    hr = m_pConsole->QueryConsoleVerb(&m_pConsoleVerb);


    return S_OK;
}

STDMETHODIMP CSnapIn::Destroy(MMC_COOKIE cookie)
{

    if (m_pConsole != NULL)
    {
        m_pConsole->SetHeader(NULL);
        m_pConsole->Release();
        m_pConsole = NULL;
    }

    if (m_pHeader != NULL)
    {
        m_pHeader->Release();
        m_pHeader = NULL;
    }
    if (m_pResult != NULL)
    {
        m_pResult->Release();
        m_pResult = NULL;
    }
    if (m_pImageResult != NULL)
    {
        m_pImageResult->Release();
        m_pImageResult = NULL;
    }

    if (m_pConsoleVerb != NULL)
    {
        m_pConsoleVerb->Release();
        m_pConsoleVerb = NULL;
    }

    return S_OK;
}

STDMETHODIMP CSnapIn::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;

    switch(event)
    {
    case MMCN_CONTEXTHELP:
        {
            IDisplayHelp * phelp = NULL;
            hr = m_pConsole->QueryInterface( IID_IDisplayHelp,
                                           (void **)&phelp );
            if (SUCCEEDED( hr ))
            {
                phelp->ShowTopic ( RIGPSNAP_HELP_TOPIC );
            }
            if ( phelp != NULL )
            {
                phelp->Release();
            }
        }
        break;

    case MMCN_DBLCLICK:
        hr = S_FALSE;
        break;

    case MMCN_ADD_IMAGES:
        HBITMAP hbmp16x16;
        HBITMAP hbmp32x32;

        hbmp16x16 = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_16x16));
        hbmp32x32 = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_32x32));

        if (hbmp16x16 && hbmp32x32) {        
            // Set the images
            m_pImageResult->ImageListSetStrip(reinterpret_cast<PLONG_PTR>(hbmp16x16),
                                              reinterpret_cast<PLONG_PTR>(hbmp32x32),
                                              0, RGB(255, 0, 255));
        }

        if (hbmp16x16) {
            DeleteObject(hbmp16x16);
        }

        if (hbmp32x32) {
            DeleteObject(hbmp32x32);
        }
        break;

    case MMCN_SHOW:
        if (arg == TRUE)
        {
            RESULTDATAITEM resultItem;
            LPGPTDATAOBJECT pGPTDataObject;
            MMC_COOKIE cookie;
            INT i;

            //
            // Get the cookie of the scope pane item
            //

            hr = lpDataObject->QueryInterface(IID_IGPTDataObject, (LPVOID *)&pGPTDataObject);

            if (FAILED(hr))
                return S_OK;

            hr = pGPTDataObject->GetCookie(&cookie);

            pGPTDataObject->Release();     // release initial ref
            if (FAILED(hr))
                return S_OK;


            //
            // Prepare the view
            //

            m_pHeader->InsertColumn(0, m_column1, LVCFMT_LEFT, m_nColumnSize);
            m_pResult->SetViewMode(m_lViewMode);


            //
            // Add result pane items for this node
            //

            for (i = 0; i < g_NameSpace[cookie].cResultItems; i++)
            {
                resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
                resultItem.str = MMC_CALLBACK;
                resultItem.nImage = g_NameSpace[cookie].pResultItems[i].iImage;
                resultItem.lParam = (LPARAM) &g_NameSpace[cookie].pResultItems[i];
                m_pResult->InsertItem(&resultItem);
            }

            //m_pResult->Sort(0, 0, -1);
        }
        else
        {
            m_pHeader->GetColumnWidth(0, &m_nColumnSize);
            m_pResult->GetViewMode(&m_lViewMode);
        }
        break;


    case MMCN_SELECT:

        if (m_pConsoleVerb)
        {
            LPRESULTITEM pItem;
            LPGPTDATAOBJECT pGPTDataObject;
            DATA_OBJECT_TYPES type;
            MMC_COOKIE  cookie;

            //
            // Set the default verb to open
            //

            m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);


            //
            // See if this is one of our items.
            //

            hr = lpDataObject->QueryInterface(IID_IGPTDataObject, (LPVOID *)&pGPTDataObject);

            if (FAILED(hr))
                break;

            pGPTDataObject->GetType(&type);
            pGPTDataObject->GetCookie(&cookie);

            pGPTDataObject->Release();


            //
            // If this is a result pane item or the root of the namespace
            // nodes, enable the Properties menu item
            //

            if ((type == CCT_RESULT) || ((type == CCT_SCOPE) && (cookie == 0)))
            {
                m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);


                //
                // If this is a result pane item, then change the default
                // verb to Properties.
                //

                if (type == CCT_RESULT)
                    m_pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
            }

        }
        break;

    default:
        hr = E_UNEXPECTED;
        break;
    }

    return hr;
}

STDMETHODIMP CSnapIn::GetDisplayInfo(LPRESULTDATAITEM pResult)
{
    if (pResult)
    {
        if (pResult->bScopeItem == TRUE)
        {
            if (pResult->mask & RDI_STR)
            {
                if (pResult->nCol == 0)
                    pResult->str = g_NameSpace[pResult->lParam].szDisplayName;
                else
                    pResult->str = L"";
            }

            if (pResult->mask & RDI_IMAGE)
            {
                pResult->nImage = 0;
            }
        }
        else
        {
            if (pResult->mask & RDI_STR)
            {
                if (pResult->nCol == 0)
                {
                    LPRESULTITEM lpResultItem = (LPRESULTITEM)pResult->lParam;

                    if (lpResultItem->szDisplayName[0] == TEXT('\0'))
                    {
                        if (!LoadString (g_hInstance, lpResultItem->iStringID,
                                    lpResultItem->szDisplayName,
                                    MAX_DISPLAYNAME_SIZE)) {
                            return(HRESULT_FROM_WIN32(GetLastError()));
                        }
                    }

                    pResult->str = lpResultItem->szDisplayName;
                }

                if (pResult->str == NULL)
                    pResult->str = (LPOLESTR)L"";
            }
        }
    }

    return S_OK;
}

STDMETHODIMP CSnapIn::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT *ppDataObject)
{
    return m_pcd->QueryDataObject(cookie, type, ppDataObject);
}


STDMETHODIMP CSnapIn::GetResultViewType(MMC_COOKIE cookie, LPOLESTR *ppViewType,
                                        LONG *pViewOptions)
{
    return S_FALSE;
}

STDMETHODIMP CSnapIn::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    HRESULT hr = S_FALSE;
    LPGPTDATAOBJECT pGPTDataObjectA, pGPTDataObjectB;
    MMC_COOKIE  cookie1, cookie2;


    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    //
    // QI for the private GPTDataObject interface
    //

    if (FAILED(lpDataObjectA->QueryInterface(IID_IGPTDataObject,
                                            (LPVOID *)&pGPTDataObjectA)))
    {
        return S_FALSE;
    }


    if (FAILED(lpDataObjectB->QueryInterface(IID_IGPTDataObject,
                                            (LPVOID *)&pGPTDataObjectB)))
    {
        pGPTDataObjectA->Release();
        return S_FALSE;
    }

    pGPTDataObjectA->GetCookie(&cookie1);
    pGPTDataObjectB->GetCookie(&cookie2);

    if (cookie1 == cookie2)
    {
        hr = S_OK;
    }


    pGPTDataObjectA->Release();
    pGPTDataObjectB->Release();

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
// CComponentData object implementation (IExtendPropertySheet)
//
STDMETHODIMP CSnapIn::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                             LONG_PTR handle, LPDATAOBJECT lpDataObject)

{
    HRESULT hr;
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hPage[2];
    LPGPTDATAOBJECT pGPTDataObject;
    LPRESULTITEM pItem;
    MMC_COOKIE cookie;


    //
    // Make sure this is one of our objects
    //

    if (FAILED(lpDataObject->QueryInterface(IID_IGPTDataObject,
                                            (LPVOID *)&pGPTDataObject)))
    {
        return S_OK;
    }


    //
    // Get the cookie
    //

    pGPTDataObject->GetCookie(&cookie);
    pGPTDataObject->Release();


    pItem = (LPRESULTITEM)cookie;


    //
    // Initialize the common fields in the property sheet structure
    //

    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = 0;
    psp.hInstance = g_hInstance;
    psp.lParam = (LPARAM) this;


    //
    // Do the page specific stuff
    //

    switch (pItem->dwID)
    {
        case 2:
            psp.pszTemplate = MAKEINTRESOURCE(IDD_SCREEN);
            psp.pfnDlgProc = ChoiceDlgProc;

            hPage[0] = CreatePropertySheetPage(&psp);

            if (hPage[0])
            {
                hr = lpProvider->AddPage(hPage[0]);
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CSnapIn::CreatePropertyPages: Failed to create property sheet page with %d."),
                         GetLastError()));
                hr = E_FAIL;
            }
            break;
    }


    return (hr);
}

STDMETHODIMP CSnapIn::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    LPGPTDATAOBJECT pGPTDataObject;
    DATA_OBJECT_TYPES type;

    if (SUCCEEDED(lpDataObject->QueryInterface(IID_IGPTDataObject,
                                               (LPVOID *)&pGPTDataObject)))
    {
        pGPTDataObject->GetType(&type);
        pGPTDataObject->Release();

        if (type == CCT_RESULT)
            return S_OK;
    }

    return S_FALSE;
}

///////////////////////////////////////////////////////////////////////////////
//
// CSnapIn object implementation (Internal functions)
//

INT_PTR CALLBACK CSnapIn::ReadmeDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    return FALSE;
}

INT_PTR CALLBACK CSnapIn::_CreateDirectoryIfNeeded( LPOLESTR pszPath )
{
    BOOL b = FALSE;
    LPOLESTR psz = &pszPath[ wcslen( pszPath ) ];
    DWORD dwErr;

    while ( psz = StrRChr( pszPath, psz, L'\\' ) )
    {
        WCHAR tmp = *psz;           // save
        *psz = L'\0';               // terminate
        b = CreateDirectory( pszPath, NULL );
        *psz = tmp;                 // restore

        if (b)
        { // success in creating directory
            psz++;
            while ( psz = StrChr( psz, L'\\' ) )
            {
                tmp = *psz;           // save
                *psz = L'\0';               // terminate
                b = CreateDirectory( pszPath, NULL );
                *psz = tmp;                 // restore

                if ( !b )
                {
                    dwErr = GetLastError();
                    break;
                }
                psz++;
            }
            break;
        }
        // else failed... keep backing up
        dwErr = GetLastError();
        psz--;
    }

    return b;
}

INT_PTR CALLBACK CSnapIn::ChoiceDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CSnapIn * pCS = (CSnapIn*) GetWindowLongPtr( hDlg, DWLP_USER );
    static BOOL bDirty;
    BOOL fReturn = FALSE;
    HRESULT hr;
    BSTR pszPath = NULL;


    if ( message == WM_INITDIALOG )
    {
        bDirty = FALSE;
        pCS = (CSnapIn *) (((LPPROPSHEETPAGE)lParam)->lParam);
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) pCS);
        if (!pCS)
            goto Cleanup;

        pszPath = SysAllocStringByteLen( NULL, MAX_PATH * sizeof(OLECHAR) );
        if (!pszPath)
            goto Cleanup;

        hr = pCS->m_pcd->m_pGPTInformation->GetFileSysPath( GPO_SECTION_USER, pszPath, MAX_PATH );
        if (SUCCEEDED(hr) &&
            (wcslen(pszPath) + ARRAYSIZE(L"\\Microsoft\\RemoteInstall\\oscfilter.ini")  <= MAX_PATH ))
        {
            wcscat( pszPath, L"\\Microsoft\\RemoteInstall\\oscfilter.ini");

            for ( INT i = 0; i < ARRAYSIZE(g_ChoiceOptions); i++ )
            {
                WCHAR szValue[MAX_INI_SECTION_SIZE];
                LONG lValue = -1;   // don't care
                DWORD dw;
                WCHAR szOption[ MAX_OPTION_SIZE ];

                if (!LoadString( 
                            g_hInstance, 
                            g_ChoiceOptions[i].dwValId, 
                            szOption, 
                            ARRAYSIZE( szOption ))) {
                    lValue = -1;
                } else {
                    dw = GetPrivateProfileString( L"Choice", szOption, L"", szValue, ARRAYSIZE( szValue ), pszPath );
    
                    if ( dw != 0 )
                    {
                        lValue = wcstol( szValue, NULL, 10 );
                    }
                }

                switch (lValue)
                {
                case 0: // Deny
                    Button_SetCheck( GetDlgItem( hDlg, g_ChoiceOptions[i].dwCtlIdDeny ), BST_CHECKED );
                    break;

                case 1: // Allow
                    Button_SetCheck( GetDlgItem( hDlg, g_ChoiceOptions[i].dwCtlIdAllow ), BST_CHECKED );
                    break;

                default: // don't care / unknown value
                    Button_SetCheck( GetDlgItem( hDlg, g_ChoiceOptions[i].dwCtlIdDontCare ), BST_CHECKED );
                    break;

                }
            }
        }
    }

    if (!pCS)
        goto Cleanup;

    switch (message)
    {
    case WM_HELP:
    case WM_CONTEXTMENU:
        {
            MMCPropertyHelp( RIGPSNAP_HELP_TOPIC );
        }
        break;

    case WM_COMMAND:
        if ( ( LOWORD(wParam) >= IDC_FIRST_RADIO_BUTTON )
          && ( LOWORD(wParam) <= IDC_LAST_RADIO_BUTTON ) )
        {
            if ( !bDirty )
            {
                SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);
                bDirty = TRUE;
            }
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR*)lParam)->code)
        {
            case PSN_APPLY:
            {
                if (bDirty)
                {
                    pszPath = SysAllocStringByteLen( NULL, MAX_PATH );
                    if (!pszPath)
                        goto Cleanup;

                    hr = pCS->m_pcd->m_pGPTInformation->GetFileSysPath( GPO_SECTION_USER, pszPath, MAX_PATH );
                    if (SUCCEEDED(hr) &&
                       (wcslen(pszPath) + ARRAYSIZE(L"\\Microsoft\\RemoteInstall\\oscfilter.ini") <= MAX_PATH ))
                    {
                        wcscat( pszPath, L"\\Microsoft\\RemoteInstall\\oscfilter.ini");
                        pCS->_CreateDirectoryIfNeeded( pszPath );

                        for ( INT i = 0; i < ARRAYSIZE(g_ChoiceOptions); i++ )
                        {
                            DWORD dw;
                            WCHAR szOption[ MAX_OPTION_SIZE ];

                            if (LoadString( 
                                        g_hInstance, 
                                        g_ChoiceOptions[i].dwValId, 
                                        szOption, 
                                        ARRAYSIZE( szOption ))) {
                                if ( Button_GetCheck( GetDlgItem( hDlg, g_ChoiceOptions[i].dwCtlIdDeny ) ) == BST_CHECKED )
                                {
                                    WritePrivateProfileString( L"Choice", szOption, L"0", pszPath );
                                }
    
                                if ( Button_GetCheck( GetDlgItem( hDlg, g_ChoiceOptions[i].dwCtlIdAllow ) ) == BST_CHECKED )
                                {
                                    WritePrivateProfileString( L"Choice", szOption, L"1", pszPath );
                                }
    
                                if ( Button_GetCheck( GetDlgItem( hDlg, g_ChoiceOptions[i].dwCtlIdDontCare ) ) ==  BST_CHECKED )
                                {
                                    WritePrivateProfileString( L"Choice", szOption, NULL, pszPath );
                                }
                            }
                        }

                        // Notify the GPT manager that policy has changed

                        pCS->m_pcd->m_pGPTInformation->PolicyChanged( FALSE, TRUE, (GUID *)&CLSID_RIClientExtension, (GUID *)&CLSID_GPTRemoteInstall );
                    }
                }
            }
            // fall through...

            case PSN_RESET:
                SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                bDirty = FALSE;
                fReturn = TRUE;
                break;

        }
        break;
    }

Cleanup:
    if ( pszPath )
        SysFreeString( pszPath );

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rigpsnap\util.h ===
//
// Microsoft Corporation 1998
//
// UTIL.H - Function proto-types for util.cpp
//

LPTSTR CheckSlash (LPTSTR lpDir);
BOOL RegDelnode (HKEY hKeyRoot, LPTSTR lpSubKey);
BOOL RegCleanUpValue (HKEY hKeyRoot, LPTSTR lpSubKey, LPTSTR lpValueName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rigpsnap\util.cpp ===
//
// Microsoft Corporation 1998
//
// UTIL.CPP - Utility routines
//
#include "main.h"

//*************************************************************
//
//  CheckSlash()
//
//  Purpose:    Checks for an ending slash and adds one if
//              it is missing.
//
//  Parameters: lpDir   -   directory
//
//  Return:     Pointer to the end of the string
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericflo    Created
//
//*************************************************************
LPTSTR CheckSlash (LPTSTR lpDir)
{
    DWORD dwStrLen;
    LPTSTR lpEnd;

    lpEnd = lpDir + lstrlen(lpDir);

    if (*(lpEnd - 1) != TEXT('\\')) {
        *lpEnd =  TEXT('\\');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }

    return lpEnd;
}


//*************************************************************
//
//  RegDelnodeRecurse()
//
//  Purpose:    Deletes a registry key and all it's subkeys / values.
//              Called by RegDelnode
//
//  Parameters: hKeyRoot    -   Root key
//              lpSubKey    -   SubKey to delete
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//
//*************************************************************

BOOL RegDelnodeRecurse (HKEY hKeyRoot, LPTSTR lpSubKey)
{
    LPTSTR lpEnd;
    LONG lResult;
    DWORD dwSize;
    TCHAR szName[MAX_PATH];
    HKEY hKey;
    FILETIME ftWrite;

    //
    // First, see if we can delete the key without having
    // to recurse.
    //


    lResult = RegDeleteKey(hKeyRoot, lpSubKey);

    if (lResult == ERROR_SUCCESS) {
        return TRUE;
    }


    lResult = RegOpenKeyEx (hKeyRoot, lpSubKey, 0, KEY_READ, &hKey);

    if (lResult != ERROR_SUCCESS) {
        return FALSE;
    }


    lpEnd = CheckSlash(lpSubKey);

    //
    // Enumerate the keys
    //

    dwSize = MAX_PATH;
    lResult = RegEnumKeyEx(hKey, 0, szName, &dwSize, NULL,
                           NULL, NULL, &ftWrite);

    if (lResult == ERROR_SUCCESS) {

        do {

            lstrcpy (lpEnd, szName);

            if (!RegDelnodeRecurse(hKeyRoot, lpSubKey)) {
                break;
            }

            //
            // Enumerate again
            //

            dwSize = MAX_PATH;

            lResult = RegEnumKeyEx(hKey, 0, szName, &dwSize, NULL,
                                   NULL, NULL, &ftWrite);


        } while (lResult == ERROR_SUCCESS);
    }

    lpEnd--;
    *lpEnd = TEXT('\0');


    RegCloseKey (hKey);


    //
    // Try again to delete the key
    //

    lResult = RegDeleteKey(hKeyRoot, lpSubKey);

    if (lResult == ERROR_SUCCESS) {
        return TRUE;
    }

    return FALSE;
}

//*************************************************************
//
//  RegDelnode()
//
//  Purpose:    Deletes a registry key and all it's subkeys / values
//
//  Parameters: hKeyRoot    -   Root key
//              lpSubKey    -   SubKey to delete
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//
//*************************************************************

BOOL RegDelnode (HKEY hKeyRoot, LPTSTR lpSubKey)
{
    #define DELKEY_SIZE (2 * MAX_PATH)
    TCHAR szDelKey[DELKEY_SIZE];


    lstrcpyn( szDelKey, lpSubKey, DELKEY_SIZE );
    szDelKey[DELKEY_SIZE-1] = TEXT('\0');

    return RegDelnodeRecurse(hKeyRoot, szDelKey);

}

//*************************************************************
//
//  RegCleanUpValue()
//
//  Purpose:    Removes the target value and if no more values / keys
//              are present, removes the key.  This function then
//              works up the parent tree removing keys if they are
//              also empty.  If any parent key has a value / subkey,
//              it won't be removed.
//
//  Parameters: hKeyRoot    -   Root key
//              lpSubKey    -   SubKey
//              lpValueName -   Value to remove
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL RegCleanUpValue (HKEY hKeyRoot, LPTSTR lpSubKey, LPTSTR lpValueName)
{
    #define DELKEY_SIZE (2 * MAX_PATH)
    TCHAR szDelKey[DELKEY_SIZE];
    LPTSTR lpEnd;
    DWORD dwKeys, dwValues;
    LONG lResult;
    HKEY hKey;


    //
    // Make a copy of the subkey so we can write to it.
    //

    lstrcpyn( szDelKey, lpSubKey, DELKEY_SIZE );
    szDelKey[DELKEY_SIZE-1] = TEXT('\0');

    //
    // First delete the value
    //

    lResult = RegOpenKeyEx (hKeyRoot, szDelKey, 0, KEY_WRITE, &hKey);

    if (lResult == ERROR_SUCCESS)
    {
        lResult = RegDeleteValue (hKey, lpValueName);

        RegCloseKey (hKey);

        if (lResult != ERROR_SUCCESS)
        {
            if (lResult != ERROR_FILE_NOT_FOUND)
            {
                DebugMsg((DM_WARNING, TEXT("RegCleanUpKey:  Failed to delete value <%s> with %d."), lpValueName, lResult));
                return FALSE;
            }
        }
    }

    //
    // Now loop through each of the parents.  If the parent is empty
    // eg: no values and no other subkeys, then remove the parent and
    // keep working up.
    //

    lpEnd = szDelKey + lstrlen(szDelKey) - 1;

    while (lpEnd >= szDelKey)
    {

        //
        // Find the parent key
        //

        while ((lpEnd > szDelKey) && (*lpEnd != TEXT('\\')))
            lpEnd--;


        //
        // Open the key
        //

        lResult = RegOpenKeyEx (hKeyRoot, szDelKey, 0, KEY_READ, &hKey);

        if (lResult != ERROR_SUCCESS)
        {
            if (lResult == ERROR_FILE_NOT_FOUND)
            {
                goto LoopAgain;
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("RegCleanUpKey:  Failed to open key <%s> with %d."), szDelKey, lResult));
                return FALSE;
            }
        }

        //
        // See if there any any values / keys
        //

        lResult = RegQueryInfoKey (hKey, NULL, NULL, NULL, &dwKeys, NULL, NULL,
                         &dwValues, NULL, NULL, NULL, NULL);

        RegCloseKey (hKey);

        if (lResult != ERROR_SUCCESS)
        {
            DebugMsg((DM_WARNING, TEXT("RegCleanUpKey:  Failed to query key <%s> with %d."), szDelKey, lResult));
            return FALSE;
        }


        //
        // Exit now if this key has values or keys
        //

        if ((dwKeys != 0) || (dwValues != 0))
        {
            return TRUE;
        }

        RegDeleteKey (hKeyRoot, szDelKey);

LoopAgain:
        //
        // If we are at the beginning of the subkey, we can leave now.
        //

        if (lpEnd == szDelKey)
        {
            return TRUE;
        }


        //
        // There is a parent key.  Remove the slash and loop again.
        //

        if (*lpEnd == TEXT('\\'))
        {
            *lpEnd = TEXT('\0');
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\rigpsnap\snapin.h ===
//
// Microsoft Corporation 1998
//
// SNAPIN.H - SnapIn class
//

class CSnapIn:
    public IComponent,
    public IExtendPropertySheet
{
protected:
    ULONG                m_cRef;
    LPCONSOLE            m_pConsole;   // Console's IFrame interface
    CComponentData      *m_pcd;
    LPRESULTDATA         m_pResult;      // Result pane's interface
    LPHEADERCTRL         m_pHeader;      // Result pane's header control interface
    LPIMAGELIST          m_pImageResult; // Result pane's image list interface
    LPCONSOLEVERB        m_pConsoleVerb; // pointer the console verb
    WCHAR                m_column1[20];  // Text for column 1
    INT                  m_nColumnSize;  // Size of column 1
    LONG                 m_lViewMode;    // View mode

    static unsigned int  m_cfNodeType;
    static TCHAR m_szDefaultIcon[];

public:
    CSnapIn(CComponentData *pComponent);
    ~CSnapIn();


    //
    // IUnknown methods
    //

    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


    //
    // Implemented IComponent methods
    //

    STDMETHODIMP         Initialize(LPCONSOLE);
    STDMETHODIMP         Destroy(MMC_COOKIE);
    STDMETHODIMP         Notify(LPDATAOBJECT, MMC_NOTIFY_TYPE, LPARAM, LPARAM);
    STDMETHODIMP         QueryDataObject(MMC_COOKIE, DATA_OBJECT_TYPES, LPDATAOBJECT *);
    STDMETHODIMP         GetDisplayInfo(LPRESULTDATAITEM);
    STDMETHODIMP         GetResultViewType(MMC_COOKIE, LPOLESTR*, LONG*);
    STDMETHODIMP         CompareObjects(LPDATAOBJECT, LPDATAOBJECT);


    //
    // Implemented IExtendPropertySheet methods
    //

    STDMETHODIMP         CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                      LONG_PTR handle, LPDATAOBJECT lpDataObject);
    STDMETHODIMP         QueryPagesFor(LPDATAOBJECT lpDataObject);
        
private:
    static INT_PTR CALLBACK ChoiceDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK ReadmeDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    INT_PTR CALLBACK _CreateDirectoryIfNeeded( LPOLESTR pszPath );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\appldlg.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: ApplDlg.CPP

 ***************************************************************************/

#include "pch.h"
#include <winperf.h>
#include "utils.h"
#include <commctrl.h>

DEFINE_MODULE("RIPREP")

#define INITIAL_SIZE        51200
#define EXTEND_SIZE         25600
#define REGKEY_PERF         L"software\\microsoft\\windows nt\\currentversion\\perflib"
#define REGSUBKEY_COUNTERS  L"Counters"
#define PROCESS_COUNTER     L"process"


// Globals
LPBYTE g_pBuffer  = NULL;
DWORD  g_cbBuffer = 1;

typedef struct _TASKITEM {
    LPWSTR pszImageName;
    LPWSTR pszServiceName;
    DWORD  dwProcessId;
} TASKITEM, * LPTASKITEM;

//
// GetServiceProcessInfo( )
//
// BORROWED FROM "TLIST"'s common.c
//
DWORD
GetServiceProcessInfo(
    LPENUM_SERVICE_STATUS_PROCESS*  ppInfo
    )

/*++

Routine Description:

    Provides an API for getting a list of process information for Win 32
    services that are running at the time of the API call.

Arguments:

    ppInfo  - address of a pointer to return the information.
              *ppInfo points to memory allocated with malloc.

Return Value:

    Number of ENUM_SERVICE_STATUS_PROCESS structures pointed at by *ppInfo.

--*/

{
    DWORD       dwNumServices = 0;
    SC_HANDLE   hScm;

    TraceFunc( "GetServiceProcessInfo( )\n" );

    // Initialize the output parmeter.
    *ppInfo = NULL;

    // Connect to the service controller.
    //
    hScm = OpenSCManager(
                NULL,
                NULL,
                SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE);
    if (hScm) {
        LPENUM_SERVICE_STATUS_PROCESS   pInfo    = NULL;
        DWORD                           cbInfo   = 4 * 1024;
        DWORD                           dwErr    = ERROR_SUCCESS;
        DWORD                           dwResume = 0;
        DWORD                           cLoop    = 0;
        const DWORD                     cLoopMax = 2;

        // First pass through the loop allocates from an initial guess. (4K)
        // If that isn't sufficient, we make another pass and allocate
        // what is actually needed.  (We only go through the loop a
        // maximum of two times.)
        //
        do {

            if (pInfo != NULL) {
                TraceFree(pInfo);
            }
            pInfo = (LPENUM_SERVICE_STATUS_PROCESS)TraceAlloc( LMEM_FIXED, cbInfo );
            if (!pInfo) {
                dwErr = ERROR_OUTOFMEMORY;
                break;
            }

            dwErr = ERROR_SUCCESS;
            if (!EnumServicesStatusEx(
                    hScm,
                    SC_ENUM_PROCESS_INFO,
                    SERVICE_WIN32,
                    SERVICE_ACTIVE,
                    (LPBYTE)pInfo,
                    cbInfo,
                    &cbInfo,
                    &dwNumServices,
                    &dwResume,
                    NULL)) {
                dwErr = GetLastError();
            }
        }
        while ((ERROR_MORE_DATA == dwErr) && (++cLoop < cLoopMax));

        if ((ERROR_SUCCESS == dwErr) && dwNumServices) {
            *ppInfo = pInfo;
        } else {
            if (pInfo != NULL) {
                TraceFree(pInfo);
                pInfo = NULL;
            }
            dwNumServices = 0;
        }

        CloseServiceHandle(hScm);
    }

    RETURN(dwNumServices);
}

//
// EnumWindowsProc( )
//
BOOL CALLBACK
EnumWindowsProc(
    HWND    hwnd,
    LPARAM  lParam
    )
{
    // TraceFunc( "EnumWindowsProc( )\n" );

    LPTASKITEM pTask = (LPTASKITEM) lParam;
    DWORD pid;
    DWORD dwLen;

    if (!GetWindowThreadProcessId( hwnd, &pid ))
    {
        // RETURN(TRUE); // keep enumerating
        return TRUE;
    }

    if ( pTask->dwProcessId != pid )
    {
        // RETURN(TRUE); // keep enumerating
        return TRUE;
    }

    if ( GetWindow( hwnd, GW_OWNER )
      || !(GetWindowLong( hwnd, GWL_STYLE ) & WS_VISIBLE ) )
    {   // not a top level window
        // RETURN(TRUE); // keep enumerating
        return TRUE;
    }

    dwLen = GetWindowTextLength( hwnd ) + 1;
    pTask->pszServiceName = (LPWSTR) TraceAllocString( LMEM_FIXED, dwLen );
    if ( pTask->pszServiceName )
    {
        GetWindowText( hwnd, pTask->pszServiceName, dwLen );
    }

    // RETURN(FALSE);  // hummm ... found it - stop enumeration
    return FALSE;
}

//
// CheckForRunningApplications( )
//
// Returns: TRUE - possibly "unsafe" running applications/services
//          FALSE - Ok to continue.
//
BOOL
CheckForRunningApplications(
    HWND hwndList )
{
    PSYSTEM_PROCESS_INFORMATION  ProcessInfo;
    NTSTATUS    status;
    ULONG       TotalOffset;
    LV_ITEM     lvI;
    LPENUM_SERVICE_STATUS_PROCESS pServiceInfo = NULL;
    BOOL        fReturn = FALSE;
    SC_HANDLE   hScm = 0;
    LPTASKITEM  pTask = NULL;
    HKEY        hkey = 0;
    LRESULT     lResult = 0;
    DWORD       dwNumServices = 0;

    TraceFunc( "CheckForRunningApplications( )\n" );

    ListView_DeleteAllItems( hwndList );

    lvI.mask        = LVIF_TEXT | LVIF_PARAM;
    lvI.iSubItem    = 0;

    hScm = OpenSCManager(
                NULL,
                NULL,
                SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE);

    lResult = RegOpenKey( HKEY_LOCAL_MACHINE, L"System\\CurrentControlSet\\Services", &hkey );
    Assert( lResult == ERROR_SUCCESS );

    if( lResult != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    dwNumServices = GetServiceProcessInfo( &pServiceInfo );

    hScm = OpenSCManager(
                NULL,
                NULL,
                SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE);
retry:

    if ( g_pBuffer == NULL )
    {
        g_pBuffer = (LPBYTE) VirtualAlloc ( NULL, g_cbBuffer, MEM_COMMIT, PAGE_READWRITE);
        if ( g_pBuffer == NULL )
        {
            RRETURN(TRUE); // be paranoid and show page
        }
    }

    status = NtQuerySystemInformation( SystemProcessInformation,
                                       g_pBuffer,
                                       g_cbBuffer,
                                       NULL );

    if ( status == STATUS_INFO_LENGTH_MISMATCH ) {
        g_cbBuffer += 8192;
        VirtualFree ( g_pBuffer, 0, MEM_RELEASE );
        g_pBuffer = NULL;
        goto retry;
    }

    if( !NT_SUCCESS(status) ) {
        goto Cleanup;
    }

    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) g_pBuffer;
    TotalOffset = 0;
    while ( TRUE )
    {
        LPWSTR pszImageName;
        INT    iCount = 0;

        if ( ProcessInfo->ImageName.Buffer )
        {
            pszImageName = wcsrchr( ProcessInfo->ImageName.Buffer, L'\\' );
            if ( pszImageName ) {
                pszImageName++;
            }
            else {
                pszImageName = ProcessInfo->ImageName.Buffer;
            }
        }
        else {
            goto skiptask;            // system process, skip it
        }

        if (g_hCompatibilityInf != INVALID_HANDLE_VALUE) {
            INFCONTEXT Context;
            if (SetupFindFirstLine( 
                        g_hCompatibilityInf,
                        L"ProcessesToIgnore",
                        pszImageName,
                        &Context )) {
                DebugMsg( "Skipping process %s, it's listed in inf exemption list...\n", pszImageName );
                goto skiptask;
            }
        }

#ifdef DEBUG
        if ( StrStrI( L"MSDEV.EXE", pszImageName ) || StrStrI( L"NTSD.EXE", pszImageName ) )
            goto skiptask; // allowed process
#endif

        //
        // othewize, it is an unknown or not allowed process
        // add it to the listview
        //
        fReturn = TRUE;

        pTask = (LPTASKITEM) TraceAlloc( LMEM_FIXED, sizeof(TASKITEM) );
        if ( !pTask )
            goto skiptask;
        pTask->pszImageName = (LPWSTR) TraceStrDup( pszImageName );
        if ( !pTask->pszImageName )
            goto skiptask;
        pTask->dwProcessId = (DWORD)(DWORD_PTR)ProcessInfo->UniqueProcessId;
        pTask->pszServiceName = NULL;

        if ( dwNumServices )
        {
            // For each service with this process id, append it's service
            // name to the buffer.  Separate each with a comma.
            //
            DWORD  iSvc;
            WCHAR  szText[ MAX_PATH ];  // random

            for ( iSvc = 0; iSvc < dwNumServices; iSvc++ )
            {
                if ( pTask->dwProcessId == pServiceInfo[iSvc].ServiceStatusProcess.dwProcessId )
                {
                    LPWSTR pszServiceName = pServiceInfo[iSvc].lpServiceName;

                    if (hScm)
                    {
                        ULONG cbSize = ARRAYSIZE(szText);
                        if ( GetServiceDisplayName( hScm, pServiceInfo[iSvc].lpServiceName, szText, &cbSize ) )
                        {
                            pszServiceName = szText;
                        }
                    }

                    size_t cch = wcslen( pszServiceName ) + 1;

                    if ( !pTask->pszServiceName )
                    {
                        pTask->pszServiceName = (LPWSTR) TraceAllocString( LMEM_FIXED, cch);
                        if ( pTask->pszServiceName )
                        {
                            wcscpy( pTask->pszServiceName, pszServiceName );
                        }
                    }
                    else
                    {   // not the most efficent, but it'll work
                        LPWSTR pszNew = (LPWSTR) TraceAllocString( LMEM_FIXED, wcslen(pTask->pszServiceName) + 1 + cch );
                        if ( pszNew )
                        {
                            wcscpy( pszNew, pTask->pszServiceName );
                            wcscat( pszNew, L"," );
                            wcscat( pszNew, pszServiceName );
                            TraceFree( pTask->pszServiceName );
                            pTask->pszServiceName = pszNew;
                        }
                    }
                }
            }
        }

        if ( hkey && !pTask->pszServiceName )
        {
            DWORD  iSvc = 0;
            WCHAR  szService[ MAX_PATH ]; // random

            while ( RegEnumKey( hkey, iSvc, szService, ARRAYSIZE(szService) ) )
            {
                HKEY  hkeyService;
                WCHAR szPath[ MAX_PATH ];
                LONG  cb = ARRAYSIZE(szPath);
                lResult = RegOpenKey( hkey, szService, &hkeyService );
                Assert( lResult == ERROR_SUCCESS );
                if( lResult != ERROR_SUCCESS ) {
                    goto Cleanup;
                }


                lResult = RegQueryValue( hkeyService, L"ImagePath", szPath, &cb );
                Assert( lResult == ERROR_SUCCESS );
                if( lResult != ERROR_SUCCESS ) {
                    goto Cleanup;
                }

                if ( StrStrI( szPath, pTask->pszImageName ) )
                {   // match!
                    WCHAR  szText[ MAX_PATH ];  // random
                    cb = ARRAYSIZE(szText);
                    lResult = RegQueryValue( hkeyService, L"DisplayName", szText, &cb );
                    if ( lResult == ERROR_SUCCESS )
                    {
                        pTask->pszServiceName = (LPWSTR) TraceStrDup( szText );
                        break;
                    }
                }

                RegCloseKey( hkeyService );
                iSvc++;
            }
        }

        if ( !pTask->pszServiceName )
        {
            EnumWindows( &EnumWindowsProc, (LPARAM) pTask );
        }

        lvI.cchTextMax  = wcslen(pTask->pszImageName);
        lvI.lParam      = (LPARAM) pTask;
        lvI.iItem       = iCount;
        lvI.pszText     = pTask->pszImageName;

        iCount = ListView_InsertItem( hwndList, &lvI );
        Assert( iCount != -1 );
        if ( iCount == -1 )
            goto skiptask;

        if ( pTask->pszServiceName )
        {
            ListView_SetItemText( hwndList, iCount, 1, pTask->pszServiceName );
        }

skiptask:
        if ( ProcessInfo->NextEntryOffset == 0 ) {
            break;
        }

        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&g_pBuffer[TotalOffset];
    }

Cleanup:

    if ( hScm )
    {
        CloseServiceHandle(hScm);
    }

    if ( pServiceInfo )
    {
        TraceFree( pServiceInfo );
    }

    if( hkey ) {
        RegCloseKey( hkey );
    }

    RETURN(fReturn);
}

//
// ApplicationDlgProc()
//
INT_PTR CALLBACK
ApplicationDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    
    UNREFERENCED_PARAMETER(wParam);
    
    switch (uMsg)
    {
    default:
        return FALSE;

    case WM_INITDIALOG:
        {
            LV_COLUMN   lvC;
            WCHAR       szText[ 80 ];
            INT         i;
            HWND        hwndList = GetDlgItem( hDlg, IDC_L_PROCESSES );
            RECT        rect;
            DWORD       dw;

            // Create the columns
            lvC.mask    = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
            lvC.fmt     = LVCFMT_LEFT;
            lvC.pszText = szText;

            // Add first column
            lvC.iSubItem = 0;
            lvC.cx       = 100;
            dw = LoadString( g_hinstance, IDS_PROCESS_NAME_COLUMN, szText, ARRAYSIZE(szText));
            Assert( dw );
            i = ListView_InsertColumn ( hwndList, 0, &lvC );
            Assert( i != -1 );

            // Add second column
            lvC.iSubItem++;
            GetWindowRect( hwndList, &rect );
            lvC.cx       = ( rect.right - rect.left ) - lvC.cx; // autosize - make Tony happy
            dw = LoadString( g_hinstance, IDS_APPL_NAME_COLUMN, szText, ARRAYSIZE(szText));
            Assert( dw );
            i = ListView_InsertColumn ( hwndList, lvC.iSubItem, &lvC );
            Assert( i != -1 );
        }
        return FALSE;

    case WM_DESTROY:
        VirtualFree ( g_pBuffer, 0, MEM_RELEASE );
        g_pBuffer = NULL; // paranoid
        break;

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        LPNMHDR lpnmhdr = (LPNMHDR) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_WIZNEXT:
#if 0
            if ( CheckForRunningApplications( GetDlgItem( hDlg, IDC_L_PROCESSES ) ) )
            {
                MessageBoxFromStrings( hDlg, IDS_NOT_ALL_PROCESSES_KILLED_TITLE, IDS_NOT_ALL_PROCESSES_KILLED_TEXT, MB_OK );
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );   // don't show
            }
#endif
            break;

        case PSN_SETACTIVE:
            {
                if ( !CheckForRunningApplications( GetDlgItem( hDlg, IDC_L_PROCESSES ) ) )
                {
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );   // don't show
                    break;
                }
                PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT | PSWIZB_BACK );
                ClearMessageQueue( );
            }
            break;

        case LVN_DELETEALLITEMS:
            DebugMsg( "LVN_DELETEALLITEMS - Deleting all items.\n" );
            break;

        case LVN_DELETEITEM:
            DebugMsg( "LVN_DELETEITEM - Deleting an item.\n" );
            {
                LPNMLISTVIEW pnmv = (LPNMLISTVIEW) lParam;
                HWND   hwndList = GetDlgItem( hDlg, IDC_L_PROCESSES );
                LPTASKITEM pTask;
                LVITEM lvi;
                BOOL   b;

                lvi.iItem    = pnmv->iItem;
                lvi.iSubItem = 0;
                lvi.mask     = LVIF_PARAM;
                b = ListView_GetItem( hwndList, &lvi );
                Assert( b );
                pTask = (LPTASKITEM) lvi.lParam;
                Assert( pTask );
                if( pTask ) {
                    TraceFree( pTask->pszImageName );
                    TraceFree( pTask->pszServiceName );
                    TraceFree( pTask );
                }
            }
            break;
        }
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\appldlg.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: ApplDlg.H


 ***************************************************************************/

#ifndef _APPLDLG_H_
#define _APPLDLG_H_

INT_PTR CALLBACK
ApplicationDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );


#endif // _APPLDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\callback.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: CALLBACK.CPP

 ***************************************************************************/

#include "pch.h"
#include "utils.h"
#include "tasks.h"
#include "setup.h"
#include "callback.h"
#include "logging.h"
#include "userenv.h"

// Must have this...
extern "C" {
#include <sysprep_.h>
//
// SYSPREP globals
//
extern BOOL    NoSidGen;
extern BOOL    PnP;
}

DEFINE_MODULE("RIPREP")

DWORD g_WorkerThreadId = 0;
HANDLE g_WorkerThreadHandle = INVALID_HANDLE_VALUE;
HWND g_hMainWindow = NULL;
HWND g_hTasksDialog = NULL;
DWORD g_NeedDlg = NULL;

#define NCOLORSHADES        32

//
// Spin( )
//
DWORD
Spin( )
{
    TraceFunc( "Spin( )\n" );
    DWORD dwResult;
    MSG Msg;

    // We will spin in here until the end
    while ( WAIT_TIMEOUT == (dwResult = WaitForSingleObject( g_WorkerThreadHandle, 50 )) )
    {
        while ( PeekMessage( &Msg, NULL, NULL, NULL, PM_REMOVE ) )
        {
            if (Msg.message == WM_SYSKEYUP)
                continue; // ignore

            if (Msg.message == WM_KEYDOWN)
                continue; // ignore

            if (Msg.message == WM_KEYUP)
                continue; // ignore

            TranslateMessage( &Msg );
            DispatchMessage( &Msg );
        }
    }

    RETURN(dwResult);
}
//
// WorkerThreadProc( )
//
DWORD
WorkerThreadProc(
    LPVOID lParam )
{
    
    UNREFERENCED_PARAMETER(lParam);
    
    // Place in the log all the gathered information for the wizard
    // as well as system APIs.
    LogMsg( L"Server      : %s\r\n", g_ServerName );
    LogMsg( L"Image Dir   : %s\r\n", g_MirrorDir );
    LogMsg( L"Language    : %s\r\n", g_Language );
    LogMsg( L"Architecture: %s\r\n", g_Architecture );
    LogMsg( L"Description : %s\r\n", g_Description );
    LogMsg( L"HelpText    : %s\r\n", g_HelpText );
    LogMsg( L"SystemRoot  : %s\r\n", g_SystemRoot );
    LogMsg( L"Winnt Dir   : %s\r\n", g_WinntDirectory );

    // Start the IMIRROR task list
    DWORD dw = ProcessToDoItems( );
    DebugMsg( "ProcessToDoItems( ) completed: 0x%08x\n", dw );
    return dw;
}

HWND g_hParent = NULL;

//
// MainWindowProc ( )
//
LRESULT CALLBACK
MainWindowProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    static WCHAR szTitle[ 256 ];
    static DWORD dwTitleLength;
    static HFONT BigBoldFont = NULL;

    switch(uMsg)
    {
    case WM_NCCREATE:
        return TRUE;   // keep going

    case WM_CREATE:
        {
            DWORD dw;
            dw = LoadString( g_hinstance, IDS_APPNAME, szTitle, ARRAYSIZE(szTitle));
            Assert(dw);
            dwTitleLength = wcslen( szTitle );
        }
        break;

    case WM_PAINT:
        {
            PAINTSTRUCT ps;
            RECT rc;
            LOGBRUSH brush;
            HBRUSH hBrush;
            HBRUSH hOldBrush;
            INT    n = 0;

            BeginPaint( hDlg, &ps );
            rc.left = 0;
            rc.right = GetSystemMetrics(SM_CXVIRTUALSCREEN);
            rc.bottom = GetSystemMetrics(SM_CYVIRTUALSCREEN);
            INT yDelta= max(rc.bottom/NCOLORSHADES,1);  // height of one shade band
            rc.top = rc.bottom - yDelta;

            // Shade the background
            while (rc.top >= 0)
            {
                brush.lbColor = RGB(0, 0, (256*n)/NCOLORSHADES);
                brush.lbStyle = BS_SOLID;
                hBrush = (HBRUSH) CreateBrushIndirect( &brush );
                hOldBrush = (HBRUSH) SelectObject(ps.hdc, hBrush);
                FillRect( ps.hdc, &rc, hBrush );
                SelectObject(ps.hdc, hOldBrush);
                DeleteObject(hBrush);
                rc.top -= yDelta;
                rc.bottom -= yDelta;
                n++;
            }

            if ( !BigBoldFont )
            {
                HFONT Font;
                LOGFONT LogFont;
                INT FontSize;

                Font = (HFONT) GetStockObject( SYSTEM_FONT );
                if ( (Font ) && GetObject( Font, sizeof(LOGFONT), &LogFont) )
                {
                    DWORD dw;
                     
                    dw = LoadString( g_hinstance,
                                           IDS_LARGEFONTNAME,
                                           LogFont.lfFaceName,
                                           LF_FACESIZE);
                    Assert( dw );

                    LogFont.lfWeight = 700;
                    FontSize = yDelta;

                    LogFont.lfHeight = 0 - (GetDeviceCaps(ps.hdc,LOGPIXELSY) * FontSize / 72);
                    LogFont.lfWidth = 0;

                    BigBoldFont = CreateFontIndirect(&LogFont);

                }
            }

            // Redraw the title
            SetBkMode( ps.hdc, TRANSPARENT );
            SelectObject( ps.hdc, BigBoldFont );
            SetTextColor( ps.hdc, RGB( 255, 255, 255 ) );
            TextOut(ps.hdc, yDelta, yDelta, szTitle, dwTitleLength );

            EndPaint( hDlg, &ps );
        }
        break;

    case WM_CHAR:
    case WM_KEYDOWN:
    case WM_KEYUP:
    case WM_MOUSEACTIVATE:
    case WM_MOUSEMOVE:
    case WM_MOUSEWHEEL:
        break; // ignore

    case WM_DESTROY:
        if ( BigBoldFont )
            DeleteObject( BigBoldFont );
        break;

    case WM_ERASEBKGND:
        // Don't waste time erasing
        return TRUE; // non-zero

    default:
        return DefWindowProc( hDlg, uMsg, wParam, lParam );
    }

    return FALSE;
}


//
// BeginProcess( )
//
HRESULT
BeginProcess(
    HWND hParent)
{
    TraceFunc( "BeginProcess( )\n" );

    WNDCLASSEX wndClass;
    ATOM atom;
    RECT rc;
    HWND hwndDesktop = GetDesktopWindow( );
    DWORD dwExStyle;
    GetWindowRect( hwndDesktop, &rc );

    // Create our window class
    ZeroMemory( &wndClass, sizeof(wndClass) );
    wndClass.cbSize         = sizeof(wndClass);
    wndClass.hbrBackground  = (HBRUSH) COLOR_BACKGROUND;
    wndClass.hInstance      = g_hinstance;
    wndClass.lpfnWndProc    = MainWindowProc;
    wndClass.lpszClassName  = L"MondoWindow";
    wndClass.style          = CS_CLASSDC | CS_NOCLOSE;

    atom = RegisterClassEx( &wndClass );
    Assert( atom );

    g_hParent = hParent;
#ifdef DEBUG
    dwExStyle = ( g_dwTraceFlags ? 0 :  WS_EX_TOPMOST );
#else
    dwExStyle = WS_EX_TOPMOST;
#endif
    g_hMainWindow = CreateWindowEx( dwExStyle,
                                    L"MondoWindow",
                                    L"",
                                    WS_POPUP | WS_VISIBLE,
                                    GetSystemMetrics(SM_XVIRTUALSCREEN), GetSystemMetrics(SM_YVIRTUALSCREEN),
                                    GetSystemMetrics(SM_CXVIRTUALSCREEN), GetSystemMetrics(SM_CYVIRTUALSCREEN),
                                    NULL,
                                    NULL,
                                    g_hinstance,
                                    NULL );
    Assert( g_hMainWindow );
    g_hTasksDialog = CreateDialog(g_hinstance, MAKEINTRESOURCE(IDD_TASKS), g_hMainWindow, TasksDlgProc );

    if ( g_hTasksDialog )
    {
        g_WorkerThreadHandle = CreateThread( NULL, NULL, WorkerThreadProc, NULL, 0, &g_WorkerThreadId );
        Spin( );
        SendMessage( g_hTasksDialog, WM_DESTROY, 0, 0 );
    }

    HRETURN(S_OK);
}


//
// IsFileInExclusionList()
//
BOOLEAN
IsFileInExclusionList(
    IN PCWSTR FileName
    )
/*++

Description:

    This routine searches the exclusion list in our INF file.

Parameters:

    FileName   : File to search the INF for.

Return Value:

    TRUE - The file does exist in the INF
    
    FALSE - The file does not exist in the INF

++*/
{
    #define SKIPFLAG_DIRECTORY       1
    #define SKIPFLAG_FILTEREXTENSION 2
    
    PWSTR           FullPath = NULL;
    PWSTR           DirectoryName = NULL;
    INFCONTEXT      Context;
    INT             Flags = 0;
    WCHAR           FilterExtension[10];
    BOOLEAN         ReturnValue = FALSE;


    //
    // Make sure we have our INF.
    //
    if( g_hCompatibilityInf == INVALID_HANDLE_VALUE ) {

        //
        // Probably hasn't been initialized yet.  Assume the
        // file isn't in the INF.
        //
        return FALSE;
    }


    if( FileName == NULL ) {
        return FALSE;
    }


    //
    // Get a local copy of the filename so we can operate on it
    // without worry of corrupting the caller's data.
    //
    if( wcsncmp(FileName, L"\\\\?\\", 4) == 0 ) {
        FullPath = (PWSTR)TraceStrDup( FileName+4 );    
    } else {
        FullPath = (PWSTR)TraceStrDup( FileName );    
    }

    if( FullPath == NULL ) {
        DebugMsg( "IsFileInExclusionList: Odd pathname %s.\n",
                  FileName );
        return FALSE;
    }


    //
    // See if it's explicitly listed in the INF
    //
    if (SetupFindFirstLine( g_hCompatibilityInf,
                            L"FilesToSkipCopy",
                            FullPath,
                            &Context)) {
        DebugMsg( "IsFileInExclusionList: Found file %s in the INF exclusion list.\n",
                  FullPath );
        ReturnValue = TRUE;
        goto Cleanup;
    }



    //
    // The file isn't specifically listed in the INF.  See if
    // the directory this file is in is listed.
    //
    // Start whacking file/directory names off the end of the
    // path to see if the result is in our exclusion list.
    //

    //
    // Remember the filename.
    //
    FileName = wcsrchr(FullPath, L'\\');

    if( FileName == NULL ) {
        DebugMsg( "IsFileInExclusionList: File isn't in exclusion list and has no directory path.\n" );
        ReturnValue = FALSE;
        goto Cleanup;
    }

    FileName++;


    while( DirectoryName = wcsrchr(FullPath, L'\\') ) {
        *DirectoryName = NULL;

        if( SetupFindFirstLine( g_hCompatibilityInf,
                                L"FilesToSkipCopy",
                                FullPath,
                                &Context)) {

            //
            // The directory name *IS* in there.  See if we need to
            // skip all files in this directory, or only some.
            //
            Flags = 0;
            if( SetupGetIntField( &Context, 1, &Flags)  &&
                ((Flags & SKIPFLAG_FILTEREXTENSION) == 0)) {

                //
                // We don't have the filter flag, so we will just
                // skip all files in this directory.
                //
                DebugMsg( "IsFileInExclusionList: Found file %s in %s in the exclusion list (based on the name of his directory).\n", 
                          FileName,
                          FullPath );

                ReturnValue = TRUE;
                goto Cleanup;
            }

            //
            // See if we should skip files with a specified extension.
            //
            if( SetupGetStringField( &Context,
                                     2,
                                     FilterExtension,
                                     ARRAYSIZE(FilterExtension),
                                     NULL )) {
                PCWSTR q = wcsrchr( FileName, L'.' );
                if (q) {
                    q++;
                    
                    if (_wcsicmp(q, FilterExtension) == 0) {
                        DebugMsg( "IsFileInExclusionList: Found file %s in %s with extension %s in the exclusion list (based on the directory and extension of the file).\n",
                                  FileName,
                                  FullPath,
                                  q );
                        ReturnValue = TRUE;
                        goto Cleanup;
                    }
                }
            }
        }
    }

Cleanup:
    if( FullPath ) {
        DebugMemoryDelete( FullPath );
    }

    return ReturnValue;
}



//
// ConvTestErrorFn()
//
NTSTATUS
ConvTestErrorFn(
    IN PVOID Context,
    IN NTSTATUS Status,
    IN IMIRROR_TODO IMirrorFunctionId
    )
{
    TraceFunc( "ConvTestErrorFn( ... )\n" );

    WCHAR szMessage[ 256 ];
    DWORD dw;

    LBITEMDATA item;

    if ( Status != ERROR_SUCCESS )
    {
        DebugMsg("ERROR REPORTED! : Context 0x%x, Status 0x%x, In Func 0x%x\n", Context, Status, IMirrorFunctionId );

        // Error will be logged in TASKS.CPP
        item.fSeen = FALSE;
        item.pszText = (IMirrorFunctionId == CheckPartitions) ? NULL : (LPWSTR)Context;
        item.uState = Status;   // used as input and output
        item.todo = IMirrorFunctionId;

        BOOL b = (BOOL)SendMessage( g_hTasksDialog, WM_ERROR, 0, (LPARAM) &item );
        if ( !b )
        {
            Status = ERROR_REQUEST_ABORTED;
        }
        else
        {
            Status = item.uState;
        }

        if ( Status == ERROR_SUCCESS )
        {
            dw = LoadString( g_hinstance, IDS_ERROR_IGNORED, szMessage, ARRAYSIZE( szMessage ));
            Assert( dw );
        }
        else if ( (Status == STATUS_RETRY) || (Status == ERROR_RETRY) )
        {
            dw = LoadString( g_hinstance, IDS_STATUS_RETRY, szMessage, ARRAYSIZE( szMessage ));
            Assert( dw );
        }
        else // other should be abort
        {
            Assert( Status == ERROR_REQUEST_ABORTED );
            dw = LoadString( g_hinstance, IDS_OPERATION_ABORTED, szMessage, ARRAYSIZE( szMessage ));
            Assert( dw );
            ClearAllToDoItems(FALSE);
        }

        Assert( dw );
        LogMsg( szMessage );
    }

    RETURN(Status);
}

NTSTATUS
ConvTestNowDoingFn(
    IN PVOID Context,
    IN IMIRROR_TODO Function,
    IN PWSTR String
    )
{
    
    UNREFERENCED_PARAMETER(Context);
    
    TraceFunc( "ConvTestNowDoingFn( )\n" );
    LPWSTR  pszMessage;
    WCHAR   szMessage[ 256 ];
    LPWSTR  pszString;
    HWND    hwnd = GetDlgItem( g_hTasksDialog, IDC_L_TASKS );
    INT     uCount;
    DWORD   dw;
    LPLBITEMDATA pitem = NULL;
    NTSTATUS Status = ERROR_SUCCESS;

    static  lastToDo = IMirrorNone;

    static BOOL fAlreadyAdjusted = FALSE;

    if ( String ) {
        pszString = (LPWSTR)TraceStrDup( String );
    } else {
        pszString = NULL;
    }

    // if we are onto another task, mark the previous one done
    // and mark this one as started.
    if ( lastToDo != Function )
    {
        uCount = ListBox_GetCount( hwnd );
        while (uCount>=0)
        {
            LRESULT lResult = ListBox_GetItemData( hwnd, uCount );
            uCount--;
            if ( lResult == LB_ERR )
                continue;

            pitem = (LPLBITEMDATA) lResult;
            pitem->fSeen = TRUE;

            if ( pitem->todo == Function )
            {
                if ( pitem->uState == STATE_NOTSTARTED )
                {
                    pitem->uState = STATE_STARTED;
                    InvalidateRect( hwnd, NULL, TRUE );    // force redraw
                }
            }
            else
            {
                if ( pitem->uState == STATE_STARTED )
                {
                    pitem->uState = STATE_DONE;
                    InvalidateRect( hwnd, NULL, TRUE );    // force redraw
                }
            }
        }

        lastToDo = Function;
    }

    switch (Function) {
    case IMirrorInitialize:
        dw = LoadString( g_hinstance, IDS_INITIALIZING, szMessage, ARRAYSIZE(szMessage) );
        Assert(dw);
        break;
    case VerifySystemIsNt5:
        dw = LoadString( g_hinstance, IDS_VERIFYING_WINDOWS_VERSION, szMessage, ARRAYSIZE(szMessage) );
        Assert(dw);
        break;
    case CheckPartitions:
        dw = LoadString( g_hinstance, IDS_ANALYZING_PARTITIONS, szMessage, ARRAYSIZE(szMessage) );
        Assert(dw);
        break;
    case CopyPartitions:
        dw = LoadString( g_hinstance, IDS_COPYING_PARTITIONS, szMessage, ARRAYSIZE(szMessage) );
        Assert(dw);
        break;
    case CopyFiles:
        if ( pszString == NULL )
        { // Only need to do this once.

            WCHAR           ProfilesDirectory[MAX_PATH];
            DWORD           rc;
            DWORD           disp;
            HKEY            hKey;


            //
            // Begin SYSPREP ops
            //


            //
            // Fix the registry so that the desktop doesn't get cleared up.
            //
            if( !g_OEMDesktop ) {

                //
                // The user hasn't asked us to clean the desktop, so by default,
                // we're going to assume he wants to keep it.
                //

                //
                // Create HKLM\Software\Microsoft\Windows\CurrentVersion\OemStartMenuData
                //
                rc = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                                     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\OemStartMenuData"),
                                     0L,
                                     NULL,
                                     REG_OPTION_NON_VOLATILE,
                                     KEY_ALL_ACCESS,
                                     NULL,
                                     &hKey,
                                     &disp );

                if( rc == ERROR_SUCCESS ) {

                    //
                    // Create the value DesktopShortcutsCleanupDisable (DWORD) = 1
                    //
                    disp = 1;
                    rc = RegSetValueEx( hKey,
                                        TEXT("DesktopShortcutsCleanupDisable"),
                                        0,
                                        REG_DWORD,
                                        (CONST BYTE *)&disp,
                                        sizeof(DWORD));

                    RegCloseKey( hKey );
                }
            } else {

                //
                // Try to delete the key.
                //
                rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\OemStartMenuData"),
                                   0L,
                                   KEY_READ | KEY_WRITE,
                                   &hKey );

                if( rc == ERROR_SUCCESS ) {

                    //
                    // Delete DesktopShortcutsCleanupDisable
                    //
                    rc = RegDeleteValue( hKey,
                                         TEXT("DesktopShortcutsCleanupDisable") );

                    RegCloseKey( hKey );
                }
            }



            if( !NoSidGen && !IsSetupClPresent() )
            {
                LBITEMDATA item;

                // Error will be logged in TASKS.CPP
                item.fSeen   = FALSE;
                item.pszText = L"SETUPCL.EXE";
                item.uState  = ERROR_FILE_NOT_FOUND;
                item.todo    = Function;

                SendMessage( g_hTasksDialog, WM_ERROR_OK, 0, (LPARAM) &item );
                Status = STATUS_REQUEST_ABORTED;
            }

            //
            // Prepare to run Setupcl.  This will also call into
            // RunExternalUniqueness which gives others a chance to save 
            // any info that needs to be copied to the server.
            //
            if (!NoSidGen && !PrepForSidGen())
            {
                LBITEMDATA item;

                // Error will be logged in TASKS.CPP
                item.fSeen   = FALSE;
                item.pszText = L"Preparing SIDs error";
                item.uState  = ERROR_FILE_NOT_FOUND;
                item.todo    = Function;

                SendMessage( g_hTasksDialog, WM_ERROR_OK, 0, (LPARAM) &item );
                Status = STATUS_REQUEST_ABORTED;
            } 
            
            //
            // Syprep cleanup which updates files that are required to be copied
            // over to the server.
            //            
            if (!AdjustFiles())
            {
                LBITEMDATA item;

                // Error will be logged in TASKS.CPP
                item.fSeen   = FALSE;
                item.pszText = L"Adjusting files error";
                item.uState  = ERROR_FILE_NOT_FOUND;
                item.todo    = Function;

                SendMessage( g_hTasksDialog, WM_ERROR_OK, 0, (LPARAM) &item );
                Status = STATUS_REQUEST_ABORTED;
            }                    


#ifndef _IA64_

            //
            // Make sure we're on something reasonably current before
            // we attempt to ReArm the license.  The APIs just didn't
            // exist on win2k.
            //

            if( (OsVersion.dwMajorVersion >= 5) &&
                (OsVersion.dwMinorVersion >= 1) ) {

                dw = ReArm();
                if( dw != ERROR_SUCCESS ) {

                    MessageBoxFromStrings( g_hTasksDialog,
                                           IDS_ACCESS_DENIED_TITLE,
                                           IDS_ACTIVIATION_COUNT_EXCEEDED,
                                           MB_OK | MB_ICONSTOP );
                }

            }
#endif


            //
            // We need to assign a DirectoryID to the directory containing
            // the user profiles.  There is no hardcoded DirID for this, so
            // we'll make one up and tell Setupapi about it.
            //
            dw = MAX_PATH;
            if( !GetProfilesDirectory( ProfilesDirectory,
                                       &dw ) ) {

                //
                // We should never get here, but just in case.
                //
                wcscpy( ProfilesDirectory, L"C:\\Documents and Settings" );
            }

            if (g_hCompatibilityInf != INVALID_HANDLE_VALUE) {

                if( !SetupSetDirectoryId( g_hCompatibilityInf,
                                          PROFILES_DIRID,
                                          ProfilesDirectory ) ) {

                    ASSERT( FALSE && L"Unable to SetupSetDirectoryId for user profiles" );
                }
            }


            //
            // End SYSPREP ops
            //
        }
        else // if ( pszString )
        {

            // Sanity
            ASSERT( wcslen(String) < MAX_PATH );


            if( IsFileInExclusionList(pszString) ) {

                //
                // It's in the exclusion list.
                //
                DebugMsg( "ConvTestNowDoingFn: Skipping file %s because it's in the INF exclusion list.\n", 
                          pszString );
                RETURN(E_FAIL);
            } else {
                DebugMsg( "ConvTestNowDoingFn: Processing file %s\n", pszString );
            }
        
        }
        dw = LoadString( g_hinstance, IDS_COPYING_FILES, szMessage, ARRAYSIZE(szMessage) );
        Assert(dw);
        break;

    case CopyRegistry:
        //
        // Begin SYSPREP ops
        //

        Status = ERROR_SUCCESS;
        if ( IsDomainMember( ) )
        {
RetryUnjoin:
            Status = NetUnjoinDomain( NULL, NULL, NULL, 0 );
            if ( Status != NERR_Success )
            {
                LBITEMDATA item;

                // Error will be logged in TASKS.CPP
                item.fSeen   = FALSE;
                item.pszText = L"Remove from Domain Error";
                item.uState  = Status;
                item.todo    = Function;

                SendMessage( g_hTasksDialog, WM_ERROR, 0, (LPARAM) &item );

                if ( Status == ERROR_SUCCESS )
                {
                    dw = LoadString( g_hinstance, IDS_ERROR_IGNORED, szMessage, ARRAYSIZE( szMessage ));
                }
                else if ( Status == STATUS_RETRY )
                {
                    dw = LoadString( g_hinstance, IDS_STATUS_RETRY, szMessage, ARRAYSIZE( szMessage ));
                }
                else // other should be abort
                {
                    Assert( Status == ERROR_REQUEST_ABORTED );
                    dw = LoadString( g_hinstance, IDS_OPERATION_ABORTED, szMessage, ARRAYSIZE( szMessage ));
                }

                Assert( dw );
                LogMsg( szMessage );

                if ( Status == STATUS_RETRY )
                {
                    goto RetryUnjoin;
                }
            }
        }

        if( !fAlreadyAdjusted )
        {
            WCHAR szSrcPath[MAX_PATH];
            fAlreadyAdjusted = TRUE;

            _snwprintf( szSrcPath, ARRAYSIZE(szSrcPath), L"%s\\ristndrd.sif", g_ImageName );
            TERMINATE_BUFFER(szSrcPath);

            
            //
            // We are going to munge some system values. Prevent us for bailing
            // without a reboot.
            //
            g_fRebootOnExit = TRUE;
            
            
            if ( Status != ERROR_SUCCESS
                 || !RemoveNetworkSettings(szSrcPath)
                 || !AdjustRegistry( FALSE /* no, do not remove networking*/) )
            {
                LBITEMDATA item;

                // Error will be logged in TASKS.CPP
                item.fSeen   = FALSE;
                item.pszText = L"Registry Error";
                item.uState  = GetLastError( );
                item.todo    = Function;

                SendMessage( g_hTasksDialog, WM_ERROR_OK, 0, (LPARAM) &item );
                Status = STATUS_REQUEST_ABORTED;
            }
        }

        if ( Status == ERROR_SUCCESS )
        {
            NukeMruList();
        }
        else
        {
            ClearAllToDoItems(FALSE);
        }

        //
        // End SYSPREP ops
        //

        dw = LoadString( g_hinstance, IDS_COPYING_REGISTRY, szMessage, ARRAYSIZE( szMessage ));
        Assert(dw);
        break;
    case PatchDSEntries:
        dw = LoadString( g_hinstance, IDS_UPDATING_DS_ENTRIES, szMessage, ARRAYSIZE( szMessage ));
        Assert(dw);
        break;
    case RebootSystem:
        dw = LoadString( g_hinstance, IDS_REBOOTING_SYSTEM, szMessage, ARRAYSIZE( szMessage ));
        Assert(dw);
        break;
    default:
        dw = LoadString( g_hinstance, IDS_DOING_UNKNOWN_TASK, szMessage, ARRAYSIZE( szMessage ));
        Assert(dw);
    }

    pszMessage = (LPWSTR) TraceStrDup( szMessage );
    if ( !pszMessage )
        RETURN(E_OUTOFMEMORY);

    PostMessage( g_hTasksDialog, WM_UPDATE, (WPARAM)pszMessage, (LPARAM)pszString );
    // These were handed off to another thread. Don't track them anymore in
    // this thread.
    DebugMemoryDelete( pszMessage );
    if (pszString) {
        DebugMemoryDelete( pszString );
    }

    if ( Status != NO_ERROR )
    {
        if( pitem ) {
            pitem->uState = STATE_ERROR;
        }
        InvalidateRect( hwnd, NULL, TRUE );    // force redraw
        ClearAllToDoItems(FALSE);
    }

    RETURN(Status);
}

NTSTATUS
ConvTestGetMirrorDirFn(
    IN PVOID Context,
    OUT PWSTR Mirror,
    IN OUT PULONG Length
    )
{
    
    UNREFERENCED_PARAMETER(Context);

    TraceFunc( "ConvTestGetMirrorDirFn( )\n" );
    
    Assert( Length && *Length );

    _snwprintf( Mirror,
                *Length,
                L"\\\\%s\\REMINST\\Setup\\%s\\%s\\%s",
                g_ServerName,
                g_Language,
                REMOTE_INSTALL_IMAGE_DIR_W,
                g_MirrorDir );
    Mirror[*Length-1] = L'\0';
    CreateDirectory( Mirror, NULL );

    _snwprintf( Mirror,
                *Length,
                L"\\\\%s\\REMINST\\Setup\\%s\\%s\\%s\\%s",
                g_ServerName,
                g_Language,
                REMOTE_INSTALL_IMAGE_DIR_W,
                g_MirrorDir,
                g_Architecture );
    Mirror[*Length-1] = L'\0';
    CreateDirectory( Mirror, NULL );

    *Length = (wcslen(Mirror) + 1) * sizeof(WCHAR);

    DebugMsg( "Sending: %s\n", Mirror );

    RETURN((*Length == sizeof(WCHAR)) ? STATUS_UNSUCCESSFUL : STATUS_SUCCESS);
}


NTSTATUS
ConvTestFileCreateFn(
    IN PVOID Context,
    IN PWSTR FileName,
    IN ULONG FileAction,
    IN ULONG Status
    )
{
    
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(FileAction);
    
    TraceFunc( "ConvTestFileCreateFn( )\n" );

    if (Status != 0) {

        if( IsFileInExclusionList( FileName ) ) {
            //
            // It's in the exclusion list.
            //
            DebugMsg( "ConvTestFileCreateFn: Skipping file %s because it's in the INF exclusion list.\n", 
                      FileName );
            Status = 0;
        }

        if (Status != 0) {
            Status = ConvTestErrorFn( FileName, Status, CopyFiles );
        }
    } else {

        DebugMsg("created %s\n", FileName);
    }

    RETURN(Status);
}

NTSTATUS
ConvTestReinitFn(
    IN PVOID Context
    )
{
    
    UNREFERENCED_PARAMETER(Context);
    
    TraceFunc( "ConvTestReinitFn()\n" );

    RETURN(STATUS_SUCCESS);
}

NTSTATUS
ConvTestGetSetupFn(
    IN PVOID Context,
    IN PWSTR Server,
    OUT PWSTR SetupPath,
    IN OUT PULONG Length
    )
{
    
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(Server);
    
    TraceFunc( "ConvTestGetSetupFn()\n" );

    lstrcpyn( SetupPath, g_ImageName, *Length );
    *Length = wcslen( SetupPath );

    DebugMsg( "Sending: %s\n", SetupPath );

    RETURN(STATUS_SUCCESS);
}

NTSTATUS
ConvTestSetSystemFn(
    IN PVOID Context,
    IN PWSTR SystemPath,
    IN ULONG Length
    )
{
    NTSTATUS err;

    UNREFERENCED_PARAMETER(Context);
    
    TraceFunc( "ConvTestSetSystemFn()\n" );

    if (Length <= ARRAYSIZE(g_SystemRoot)) {

        wcscpy( g_SystemRoot, SystemPath );
        err = STATUS_SUCCESS;

    } else {

        err = ERROR_BAD_LENGTH;
    }

    RETURN(err);
}

NTSTATUS
ConvAddToDoItemFn(
    IN PVOID Context,
    IN IMIRROR_TODO Function,
    IN PWSTR String,
    IN ULONG Length
    )
{
    LPLBITEMDATA pitem;
    HWND hwnd = GetDlgItem( g_hTasksDialog, IDC_L_TASKS );
    WCHAR szMessage[ 256 ];
    DWORD dw;
    INT  uCount;

    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(String);
    UNREFERENCED_PARAMETER(Length);

    TraceFunc( "ConvAddToDoItemFn()\n" );

    pitem = (LPLBITEMDATA) TraceAlloc( LMEM_FIXED, sizeof(LBITEMDATA));
    if ( !pitem)
        RETURN(E_OUTOFMEMORY);

    switch (Function) {
    case IMirrorInitialize:
        dw = LoadString( g_hinstance, IDS_INITIALIZE, szMessage, ARRAYSIZE( szMessage ));
        Assert(dw);
        break;
    case VerifySystemIsNt5:
        dw = LoadString( g_hinstance, IDS_VERIFY_WINDOWS_VERSION, szMessage, ARRAYSIZE( szMessage ));
        Assert(dw);
        break;
    case CheckPartitions:
        dw = LoadString( g_hinstance, IDS_ANALYZE_PARTITIONS, szMessage, ARRAYSIZE( szMessage ));
        Assert(dw);
        break;
    case CopyPartitions:
        dw = LoadString( g_hinstance, IDS_COPY_PARTITIONS, szMessage, ARRAYSIZE( szMessage ));
        Assert(dw);
        break;
    case CopyFiles:
        dw = LoadString( g_hinstance, IDS_COPY_FILES, szMessage, ARRAYSIZE( szMessage ));
        Assert(dw);
        break;
    case CopyRegistry:
        dw = LoadString( g_hinstance, IDS_COPY_REGISTRY, szMessage, ARRAYSIZE( szMessage ));
        Assert(dw);
        break;
    case PatchDSEntries:
        dw = LoadString( g_hinstance, IDS_PATH_DS_ENTRIES, szMessage, ARRAYSIZE( szMessage ));
        Assert(dw);
        break;
    case RebootSystem:
        dw = LoadString( g_hinstance, IDS_REBOOT_SYSTEM, szMessage, ARRAYSIZE( szMessage ));
        Assert(dw);
        break;
    default:
        dw = LoadString( g_hinstance, IDS_UNKNOWN_TASK, szMessage, ARRAYSIZE( szMessage ));
        Assert(dw);
    }

    pitem->pszText = (LPWSTR) TraceStrDup( szMessage );
    pitem->uState = STATE_NOTSTARTED;
    pitem->todo = Function;
    pitem->fSeen = FALSE;

    if ( !pitem->pszText )
    {
        TraceFree( pitem );
        RETURN(E_OUTOFMEMORY);
    }

    // skip the "done" items
    uCount = 0;
    while (uCount>=0)
    {
        LRESULT lResult = ListBox_GetItemData( hwnd, uCount );
        if ( lResult == LB_ERR )
            break;

        LPLBITEMDATA panitem = (LPLBITEMDATA) lResult;

        if ( panitem->uState == STATE_STARTED )
        {
            uCount++;
            break;
        }
        if ( panitem->uState != STATE_DONE )
            break;

        uCount++;
    }

    // go to end of the "unseen" items
    while (uCount>=0)
    {
        LRESULT lResult = ListBox_GetItemData( hwnd, uCount );
        if ( lResult == LB_ERR )
            break;

        LPLBITEMDATA panitem = (LPLBITEMDATA) lResult;

        uCount++;

        if ( panitem->fSeen )
        {
            uCount--;
            break;
        }
    }

    ListBox_InsertString( hwnd, uCount, pitem );
    InvalidateRect( hwnd, NULL, TRUE );    // force redraw
    DebugMsg( "Added ToDo Item (%d): %s\n", uCount, pitem->pszText );

    RETURN(STATUS_SUCCESS);
}

NTSTATUS
ConvRemoveToDoItemFn(
    IN PVOID Context,
    IN IMIRROR_TODO Function,
    IN PWSTR String,
    IN ULONG Length
    )
{
    LPLBITEMDATA pitem;
    HWND hwnd = GetDlgItem( g_hTasksDialog, IDC_L_TASKS );
    INT uCount;

    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(String);
    UNREFERENCED_PARAMETER(Length);

    
    TraceFunc( "ConvRemoveToDoItemFn()\n" );

    uCount = ListBox_GetCount( hwnd );
    while (uCount>=0)
    {
        LRESULT lResult = ListBox_GetItemData( hwnd, uCount );
        uCount--;
        if ( lResult == LB_ERR )
            continue;

        pitem = (LPLBITEMDATA) lResult;

        if ( pitem->todo == Function )
        {
            pitem->uState = STATE_STARTED;
            break;
        }
    }

    RETURN(STATUS_SUCCESS);
}

NTSTATUS
ConvRebootFn(
    IN PVOID Context
    )
{

    UNREFERENCED_PARAMETER(Context);


    // do the last minute things
    EndProcess( g_hTasksDialog );

#ifdef DEBUG
    // if Debugging, don't reboot
    if ( !g_dwTraceFlags )
    {
#endif

    if (!DoShutdown(FALSE)) {
        LBITEMDATA item;

        // Error will be logged in TASKS.CPP
        item.fSeen   = FALSE;
        item.pszText = L"Shutdown Error";
        item.uState  = GetLastError( );
        item.todo    = RebootSystem;

        SendMessage( g_hTasksDialog, WM_ERROR_OK, 0, (LPARAM) &item );
        return item.uState;
    }

    //
    // Prevent the error log from being displayed twice. Since
    // we are set to reboot/shutdown now, this flag can be    
    // safely reset.
    //
    g_fRebootOnExit = FALSE;

#ifdef DEBUG
    }
#endif

    return STATUS_SUCCESS;
}

BOOL
DoShutdown(
    IN BOOL Restart
    )
{
    NTSTATUS Status;
    BOOLEAN WasEnabled;

    Status = RtlAdjustPrivilege( SE_SHUTDOWN_PRIVILEGE,
                                 (BOOLEAN)TRUE,
                                 TRUE,
                                 &WasEnabled
                               );

    if (Status == STATUS_NO_TOKEN) {

        //
        // No thread token, use the process token
        //

        Status = RtlAdjustPrivilege( SE_SHUTDOWN_PRIVILEGE,
                                     (BOOLEAN)TRUE,
                                     FALSE,
                                     &WasEnabled
                                   );
    }

    if (Restart) {
        return ExitWindowsEx( EWX_REBOOT | EWX_FORCEIFHUNG, SHTDN_REASON_FLAG_PLANNED | SHTDN_REASON_MAJOR_OPERATINGSYSTEM | SHTDN_REASON_MINOR_INSTALLATION );
    } else {
        return InitiateSystemShutdownEx(NULL, NULL, 0, TRUE, FALSE, SHTDN_REASON_FLAG_PLANNED | SHTDN_REASON_MAJOR_OPERATINGSYSTEM | SHTDN_REASON_MINOR_INSTALLATION);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\callback.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: CALLBACK.H

 ***************************************************************************/

#ifndef _CALLBACK_H_
#define _CALLBACK_H_

extern DWORD g_NeedDlg;
extern HWND g_hMainWindow;

HRESULT
BeginProcess(
    HWND hParent );

NTSTATUS
ConvTestErrorFn(
    IN PVOID Context,
    IN NTSTATUS Status,
    IN IMIRROR_TODO IMirrorFunctionId
    );

NTSTATUS
ConvTestNowDoingFn(
    IN PVOID Context,
    IN IMIRROR_TODO Function,
    IN PWSTR String
    );

NTSTATUS
ConvTestGetMirrorDirFn(
    IN PVOID Context,
    OUT PWSTR Mirror,
    IN OUT PULONG Length
    );

NTSTATUS
ConvTestFileCreateFn(
    IN PVOID Context,
    IN PWSTR FileName,
    IN ULONG FileAction,
    IN ULONG Status
    );

NTSTATUS
ConvTestReinitFn(
    IN PVOID Context
    );

NTSTATUS
ConvTestGetSetupFn(
    IN PVOID Context,
    IN PWSTR Server,
    OUT PWSTR SetupPath,
    IN OUT PULONG Length
    );

NTSTATUS
ConvTestSetSystemFn(
    IN PVOID Context,
    IN PWSTR SystemPath,
    IN ULONG Length
    );

NTSTATUS
ConvAddToDoItemFn(
    IN PVOID Context,
    IN IMIRROR_TODO Function,
    IN PWSTR String,
    IN ULONG Length
    );

NTSTATUS
ConvRemoveToDoItemFn(
    IN PVOID Context,
    IN IMIRROR_TODO Function,
    IN PWSTR String,
    IN ULONG Length
    );

NTSTATUS
ConvRebootFn(
    IN PVOID Context
    );

BOOL
DoShutdown(
    IN BOOL Restart
    );

#endif // _CALLBACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\complete.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: COMPLETE.H


 ***************************************************************************/

#ifndef _COMPLETE_H_
#define _COMPLETE_H_

INT_PTR CALLBACK
CompleteDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );


#endif // _COMPLETE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\complete.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: SERVERDLG.CPP


 ***************************************************************************/

#include "pch.h"
#include "callback.h"
#include "utils.h"

//
// CompleteDlgProc()
//
INT_PTR CALLBACK
CompleteDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    
    UNREFERENCED_PARAMETER(wParam);
    
    switch (uMsg)
    {
    case WM_INITDIALOG:
        SetDialogFont( hDlg, IDC_TITLE, DlgFontTitle );
        break;

    default:
        return FALSE;

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        LPNMHDR lpnmhdr = (LPNMHDR) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_WIZNEXT:
            PropSheet_PressButton( GetParent( hDlg ), PSBTN_FINISH );
            break;

        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT | PSWIZB_BACK );
            ClearMessageQueue( );
            break;
        }
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\compat.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 2000
   All rights reserved

  File: COMPAT.H


 ***************************************************************************/

#ifndef _COMPAT_H_
#define _COMPAT_H_

INT_PTR CALLBACK
CompatibilityDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );

INT_PTR CALLBACK
StopServiceWrnDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );

INT_PTR CALLBACK
DoStopServiceDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );


BOOL
ProcessCompatibilityData(
    VOID
    );

BOOL
CleanupCompatibilityData(
    VOID
    );


#define COMPFLAG_HIDE           0x00000001
#define COMPFLAG_STOPINSTALL    0x00000002
#define COMPFLAG_ALLOWNT5COMPAT 0x00000004
#define COMPFLAG_SERVICERUNNING 0x00000008
#define COMPFLAG_CHANGESTATE    0x00000010
#define COMPFLAG_ALREADYSTOPPED 0x10000000

#define COMP_ERR_DESC_NOT_UNICODE           (ULONG)0xc0000001
#define COMP_ERR_TEXTNAME_NOT_UNICODE       (ULONG)0xc0000002
#define COMP_ERR_HTMLNAME_NOT_UNICODE       (ULONG)0xc0000003
#define COMP_ERR_REGKEYNAME_NOT_UNICODE     (ULONG)0xc0000004
#define COMP_ERR_REGVALNAME_NOT_UNICODE     (ULONG)0xc0000005
#define COMP_ERR_REGVALNAME_MISSING         (ULONG)0xc0000006
#define COMP_ERR_REGVALDATA_MISSING         (ULONG)0xc0000007
#define COMP_ERR_TEXTNAME_MISSING           (ULONG)0xc0000008
#define COMP_ERR_DESC_MISSING               (ULONG)0xc0000009
#define COMP_ERR_INFNAME_NOT_UNICODE        (ULONG)0xc000000A
#define COMP_ERR_INFSECTION_NOT_UNICODE     (ULONG)0xc000000B
#define COMP_ERR_INFSECTION_MISSING         (ULONG)0xc000000C


typedef struct _RIPREP_COMPATIBILITY_ENTRY {
    DWORD   SizeOfStruct;
    LPTSTR  Description;
    LPTSTR  HtmlName;
    LPTSTR  TextName;
    LPTSTR  RegKeyName;
    LPTSTR  RegValName;
    DWORD   RegValDataSize;
    LPVOID  RegValData;    
    DWORD   Flags;
    DWORD   MsgResourceId;
} RIPREP_COMPATIBILITY_ENTRY, *PRIPREP_COMPATIBILITY_ENTRY;

typedef struct _RIPREP_COMPATIBILITY_DATA {
    //
    // general
    //
    LIST_ENTRY ListEntry;
    //
    // what type of entry
    //
    TCHAR    Type;
    //
    // service-driver data
    //
    LPCTSTR  ServiceName;
    //
    // registry data
    //
    LPCTSTR  RegKey;
    LPCTSTR  RegValue;
    LPCTSTR  RegValueExpect;
    //
    // file data
    //
    LPCTSTR  FileName;
    LPCTSTR  FileVer;
    //
    // common
    //
    LPCTSTR  Description;
    LPCTSTR  HtmlName;
    LPCTSTR  TextName;
    LPTSTR   RegKeyName;
    LPTSTR   RegValName;
    LPVOID   RegValData;
    DWORD    RegValDataSize;
    DWORD    Flags;
    LPCTSTR  InfName;
    LPCTSTR  InfSection;

    DWORD MsgResourceId;

    HMODULE                 hModDll;
    
} RIPREP_COMPATIBILITY_DATA, *PRIPREP_COMPATIBILITY_DATA;

typedef struct _RIPREP_COMPATIBILITY_CONTEXT {
    DWORD                   SizeOfStruct;
    DWORD                   Count;
    HMODULE                 hModDll;
    DWORD                   Flags;
} RIPREP_COMPATIBILITY_CONTEXT, *PRIPREP_COMPATIBILITY_CONTEXT;

typedef BOOL
(CALLBACK *PCOMPATIBILITYCALLBACK)(
    PRIPREP_COMPATIBILITY_ENTRY CompEntry,
    LPVOID Context
    );

typedef BOOL
(WINAPI *PCOMPATIBILITYCHECK)(
    PCOMPATIBILITYCALLBACK CompatibilityCallback,
    LPVOID Context
    );



#endif // _COMPAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\compchk.cpp ===
#include "pch.h"
#pragma hdrstop

#include "compat.h"
#include <userenv.h>


DEFINE_MODULE( "RIPREP" )


BOOL
pIsDomainController(
    IN      PWSTR Server,
    OUT     PBOOL DomainControllerFlag
    )

/*++

Routine Description:

    Queries if the machine is a server or workstation via
    the NetServerGetInfo API.

Arguments:

    Server - The machine to query, or NULL for the local machine

    DomainControllerFlag - Receives TRUE if the machine is a
                           domain controller, or FALSE if the
                           machine is a workstation.

Return value:

    TRUE if the API was successful, or FALSE if not.  GetLastError
    gives failure code.

--*/


{
    PSERVER_INFO_101 si101;
    NET_API_STATUS nas;

    nas = NetServerGetInfo(
        Server,
        101,    // info-level
        (PBYTE *) &si101
        );

    if (nas != NO_ERROR) {
        SetLastError (nas);
        return FALSE;
    }

    if ((si101->sv101_type & SV_TYPE_DOMAIN_CTRL) ||
        (si101->sv101_type & SV_TYPE_DOMAIN_BAKCTRL)) {
        //
        // We are dealing with a DC
        //
        *DomainControllerFlag = TRUE;
    } else {
        *DomainControllerFlag = FALSE;
    }

    NetApiBufferFree (si101);

    return TRUE;
}

BOOL
DCCheck(
    PCOMPATIBILITYCALLBACK CompatibilityCallback,
    LPVOID Context
    )

/*++

Routine Description:

    Check if the machine is a DC.  If so, then we add a compatibility
    entry.  DC's currently cannot be duplicated by RIPREP.

Arguments:

    CompatibilityCallback   - pointer to call back function
    Context     - context pointer

Return Value:

    Returns always TRUE.

--*/


{
    BOOL IsDC;
    
    if (!pIsDomainController(NULL, &IsDC) || (IsDC == TRUE)) {
        RIPREP_COMPATIBILITY_ENTRY CompEntry;
        WCHAR  Text[100];
         
        LoadString(g_hinstance, IDS_CANT_BE_DC_TITLE, Text, ARRAYSIZE(Text));
        ZeroMemory(&CompEntry, sizeof(CompEntry));
        CompEntry.SizeOfStruct= sizeof(RIPREP_COMPATIBILITY_ENTRY);
        CompEntry.Description = Text;
        CompEntry.TextName = L"dummy.txt";
        CompEntry.MsgResourceId = IDS_CANT_BE_DC_TEXT;
        CompatibilityCallback(&CompEntry,Context);

    }

    return(TRUE);

}


BOOL
MultipleProfileCheck(
    PCOMPATIBILITYCALLBACK CompatibilityCallback,
    LPVOID Context
    )
/*++

Routine Description:

    Check if the machine has multiple user profiles.  If so, add a
    compatibility entry.
    
    If the machine has multiple user profiles, we want to warn the user as
    there may be sensitive data under the profiles that may make it
    onto a public server.
    

Arguments:

    CompatibilityCallback   - pointer to call back function
    Context     - context pointer

Return Value:

    Returns TRUE.

--*/
{
    WCHAR ProfilePath[MAX_PATH];
    WIN32_FIND_DATA FindData;
    DWORD DirectoryCount = 0;
    DWORD DirectoryLength;
    BOOL DoWarning = TRUE;
    
    DirectoryLength = ARRAYSIZE(ProfilePath);
    if (GetProfilesDirectory( ProfilePath, &DirectoryLength )) {
        HANDLE hFind;

        wcscat( ProfilePath, L"\\*.*" );
        
        hFind =FindFirstFile(ProfilePath,&FindData);
        
        if (hFind != INVALID_HANDLE_VALUE) {
            do {
                if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                    DirectoryCount += 1;
                }

            } while ( FindNextFile( hFind, &FindData));

            FindClose( hFind );
        }
    }

    //
    // if there are more than 5 directories, make a warning.  These directories
    // are:
    //          "."
    //          ".."
    //          "Administrator"
    //          "All Users"
    //          "Default User"
    //          "LocalService"
    //          "NetworkService"
    //
    if (DirectoryCount <= 7 && DirectoryCount != 0) {
        DoWarning = FALSE;
    }

    if (DoWarning) {   
        RIPREP_COMPATIBILITY_ENTRY CompEntry;
        WCHAR  Text[100];
    
        LoadString(g_hinstance, IDS_MULTIPLE_PROFILES, Text, ARRAYSIZE(Text));
        ZeroMemory(&CompEntry, sizeof(CompEntry));
        CompEntry.SizeOfStruct= sizeof(RIPREP_COMPATIBILITY_ENTRY);
        CompEntry.Description = Text;
        CompEntry.MsgResourceId = IDS_MULTIPLE_PROFILES_DESC;
        CompEntry.TextName = L"dummy.txt";
        CompatibilityCallback(&CompEntry,Context);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\compat.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    compat.cpp

Abstract:

    compatibility code -- adapted from winnt32u.dll's compatibility code.
    
Author:

    Andrew Ritz (AndrewR) 7-Jul-2000

Revision History:

    Andrew Ritz (andrewr) 7-Jul-2000 : Created It

--*/


#include "pch.h"
#pragma hdrstop

#include <TCHAR.H>
#include <commctrl.h>
#include <setupapi.h>
#include <spapip.h>
#include <stdlib.h>
#include "callback.h"
#include "utils.h"
#include "compat.h"
#include "logging.h"

DEFINE_MODULE( "RIPREP" )

#define HideWindow(_hwnd)   SetWindowLong((_hwnd),GWL_STYLE,GetWindowLong((_hwnd),GWL_STYLE)&~WS_VISIBLE)
#define UnHideWindow(_hwnd) SetWindowLong((_hwnd),GWL_STYLE,GetWindowLong((_hwnd),GWL_STYLE)|WS_VISIBLE)

#define MALLOC(_sz_) TraceAlloc(LMEM_FIXED,_sz_)
#define FREE(_ptr_)  TraceFree((PVOID)_ptr_)

#define AppTitleStringId  (IDS_APPNAME)

#define WM_MYSTOPSVC WM_APP+3
#define WM_DOSTOPSVC WM_APP+4
#define WM_STOPSVCCOMPLETE WM_APP+5

CRITICAL_SECTION CompatibilityCS;
HINF g_hCompatibilityInf = INVALID_HANDLE_VALUE;
LIST_ENTRY CompatibilityData;
DWORD CompatibilityCount;
DWORD ServicesToStopCount;
DWORD IncompatibilityStopsInstallation = FALSE;
DWORD GlobalCompFlags;
BOOL  UserCancelled;

BOOL AnyNt5CompatDlls = FALSE;

WNDPROC OldEditProc;

BOOL
FileExists(
    IN LPCTSTR FileName
    )
{
    WIN32_FIND_DATA fd;
    HANDLE hFile;

    hFile = FindFirstFile( FileName, &fd);
    if (hFile != INVALID_HANDLE_VALUE) {
        FindClose( hFile );
        return(TRUE);
    }

    return(FALSE);

}

LPTSTR
DupString(
    IN LPCTSTR String
    )

/*++

Routine Description:

    Make a duplicate of a nul-terminated string.

Arguments:

    String - supplies pointer to nul-terminated string to copy.

Return Value:

    Copy of string or NULL if OOM. Caller can free with FREE().

--*/

{
    LPTSTR p = NULL;

    if(p = (LPTSTR)MALLOC((lstrlen(String)+1)*sizeof(TCHAR))) {
        lstrcpy(p,String);
    }

    return(p);
}

DWORD
MapFileForRead(
    IN  LPCTSTR  FileName,
    OUT PDWORD   FileSize,
    OUT PHANDLE  FileHandle,
    OUT PHANDLE  MappingHandle,
    OUT PVOID   *BaseAddress
    )

/*++

Routine Description:

    Open and map an entire file for read access. The file must
    not be 0-length or the routine fails.

Arguments:

    FileName - supplies pathname to file to be mapped.

    FileSize - receives the size in bytes of the file.

    FileHandle - receives the win32 file handle for the open file.
        The file will be opened for generic read access.

    MappingHandle - receives the win32 handle for the file mapping
        object.  This object will be for read access.  This value is
        undefined if the file being opened is 0 length.

    BaseAddress - receives the address where the file is mapped.  This
        value is undefined if the file being opened is 0 length.

Return Value:

    NO_ERROR if the file was opened and mapped successfully.
        The caller must unmap the file with UnmapFile when
        access to the file is no longer desired.

    Win32 error code if the file was not successfully mapped.

--*/

{
    DWORD rc;

    //
    // Open the file -- fail if it does not exist.
    //
    *FileHandle = CreateFile(
                    FileName,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );

    if(*FileHandle == INVALID_HANDLE_VALUE) {

        rc = GetLastError();

    } else {
        //
        // Get the size of the file.
        //
        *FileSize = GetFileSize(*FileHandle,NULL);
        if(*FileSize == (DWORD)(-1)) {
            rc = GetLastError();
        } else {
            //
            // Create file mapping for the whole file.
            //
            *MappingHandle = CreateFileMapping(
                                *FileHandle,
                                NULL,
                                PAGE_READONLY,
                                0,
                                *FileSize,
                                NULL
                                );

            if(*MappingHandle) {

                //
                // Map the whole file.
                //
                *BaseAddress = MapViewOfFile(
                                    *MappingHandle,
                                    FILE_MAP_READ,
                                    0,
                                    0,
                                    *FileSize
                                    );

                if(*BaseAddress) {
                    return(NO_ERROR);
                }

                rc = GetLastError();
                CloseHandle(*MappingHandle);
            } else {
                rc = GetLastError();
            }
        }

        CloseHandle(*FileHandle);
    }

    return(rc);
}



DWORD
UnmapFile(
    IN HANDLE MappingHandle,
    IN PVOID  BaseAddress
    )

/*++

Routine Description:

    Unmap and close a file.

Arguments:

    MappingHandle - supplies the win32 handle for the open file mapping
        object.

    BaseAddress - supplies the address where the file is mapped.

Return Value:

    NO_ERROR if the file was unmapped successfully.

    Win32 error code if the file was not successfully unmapped.

--*/

{
    DWORD rc;

    rc = UnmapViewOfFile(BaseAddress) ? NO_ERROR : GetLastError();

    if(!CloseHandle(MappingHandle)) {
        if(rc == NO_ERROR) {
            rc = GetLastError();
        }
    }

    return(rc);
}


LRESULT
CALLBACK
TextEditSubProc(
    IN HWND   hwnd,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    //
    // For setsel messages, make start and end the same.
    //
    if ((msg == EM_SETSEL) && ((LPARAM)wParam != lParam)) {
        lParam = wParam;
    }

    return CallWindowProc( OldEditProc, hwnd, msg, wParam, lParam );
}


BOOL
SetTextInDialog(
    HWND hwnd,
    LPTSTR FileName
    )
{
    DWORD FileSize;
    HANDLE FileHandle;
    HANDLE MappingHandle;
    PVOID BaseAddress;
    LPSTR Text;
    


    OldEditProc = (WNDPROC) GetWindowLongPtr( hwnd, GWLP_WNDPROC );
    SetWindowLongPtr( hwnd, GWLP_WNDPROC, (LONG_PTR)TextEditSubProc );

    if (MapFileForRead( FileName, &FileSize, &FileHandle, &MappingHandle, &BaseAddress )) {
        return FALSE;
    }


    Text = (LPSTR) MALLOC( FileSize + 16 );
    if( Text ) {
        CopyMemory( Text, BaseAddress, FileSize );
        Text[FileSize] = '\0';

    
        SendMessageA( hwnd, WM_SETTEXT, 0, (LPARAM)Text );
    
        FREE( Text );
    }

    UnmapFile( MappingHandle, BaseAddress );
    CloseHandle( FileHandle );

    return TRUE;
}

INT_PTR
CALLBACK
CompatibilityTextDlgProc(
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
   )
{
    switch(uMsg) {
        case WM_INITDIALOG:
            SetTextInDialog( GetDlgItem( hwndDlg, IDC_TEXT ), (LPTSTR) lParam );
            break;

        case WM_COMMAND:
            if (wParam == IDOK) {
                EndDialog( hwndDlg, IDOK );
            }
            break;

        case WM_CTLCOLOREDIT: 
            SetBkColor( (HDC)wParam, GetSysColor(COLOR_BTNFACE));
            return (INT_PTR)GetSysColorBrush(COLOR_WINDOW);
            break;

    }

    return 0;
}

BOOL
LaunchIE4Instance(
    LPWSTR szResourceURL
    );

BOOL
LaunchIE3Instance(
    LPWSTR szResourceURL
    );

INT_PTR
CompatibilityDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
BOOL            b = FALSE;
PRIPREP_COMPATIBILITY_DATA CompData;
DWORD           Index;
static int CurrentSelectionIndex=0;
static DWORD    Count = 0;
LV_ITEM         lvi = {0};
HWND            TmpHwnd;
static BOOL     WarningsPresent = FALSE;
static BOOL     ErrorsPresent = FALSE;
static BOOL     CheckUpgradeNoItems = TRUE;
DWORD           dw;

    switch(msg) {

        case WM_INITDIALOG:

            if (CompatibilityCount) {

                HWND hList =    GetDlgItem( hdlg, IDC_ROOT_LIST );
                PLIST_ENTRY     Next;
                HIMAGELIST      himl;
                HICON           hIcon;
                LV_COLUMN       lvc = {0};
                RECT            rc;

                GetClientRect( hList, &rc );
                lvc.mask = LVCF_WIDTH;
                lvc.cx = rc.right - rc.left - 16;
                ListView_InsertColumn( hList, 0, &lvc );

                Next = CompatibilityData.Flink;
                if (Next) {
                    himl = ImageList_Create( GetSystemMetrics(SM_CXSMICON),
                                             GetSystemMetrics(SM_CXSMICON),
                                             ILC_COLOR,
                                             2,
                                             0 );
                    ListView_SetImageList( hList, himl, LVSIL_SMALL );
                    hIcon = LoadIcon( NULL, IDI_HAND );
                    ImageList_AddIcon( himl, hIcon );
                    hIcon = LoadIcon( NULL, IDI_EXCLAMATION );
                    ImageList_AddIcon( himl, hIcon );

                    lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
                    lvi.state     = 0;
                    lvi.stateMask = 0;
                    while ((ULONG_PTR)Next != (ULONG_PTR)&CompatibilityData) {
                        CompData = CONTAINING_RECORD( Next, RIPREP_COMPATIBILITY_DATA, ListEntry );

                        Next = CompData->ListEntry.Flink;

                        if (OsVersion.dwMajorVersion < 5) {
                            if ( CompData->Flags & COMPFLAG_ALLOWNT5COMPAT ) {
                                AnyNt5CompatDlls = TRUE;
                            } else {
                                goto NextIteration;
                            }
                        }

                        if (((CompData->Flags & COMPFLAG_HIDE) == 0) &&
                            ((CompData->Flags & COMPFLAG_CHANGESTATE) == 0)) {

                            //
                            // Add the icon.
                            //
                            if( himl ) {
                                if( CompData->Flags & COMPFLAG_STOPINSTALL ) {
                                    lvi.iImage = 0;
                                    ErrorsPresent = TRUE;
                                } else {
                                    lvi.iImage = 1;
                                    WarningsPresent = TRUE;
                                }
                            }

                            //
                            // And the text...
                            //
                            lvi.pszText   = (LPTSTR)CompData->Description;
                            lvi.lParam    = (LPARAM)CompData;
                            Index = ListView_InsertItem( hList, &lvi );

                            Count += 1;
                        }

NextIteration:
                    NOTHING;
                    }

                }

                // If we have an item then make it the default selection

                if( ErrorsPresent || WarningsPresent ){
                


                    SetFocus( hList );
                    ListView_SetItemState( hList,
                                           0, 
                                           LVIS_SELECTED | LVIS_FOCUSED, 
                                           LVIS_SELECTED | LVIS_FOCUSED);
                    CurrentSelectionIndex = 0;
    
                    lvi.mask = LVIF_PARAM;
                    lvi.iItem = 0;
                    lvi.iSubItem = 0;
                    ListView_GetItem( GetDlgItem( hdlg, IDC_ROOT_LIST ), &lvi );
                    CompData = (PRIPREP_COMPATIBILITY_DATA)lvi.lParam;
    
                    
                }
            }
            break;

        case WM_NOTIFY:

            {
                LPNMLISTVIEW pnmv = (LPNMLISTVIEW) lParam; 
                LPNMHDR lpnmhdr = (LPNMHDR) lParam;

                switch (lpnmhdr->code) {
                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons( 
                                GetParent( hdlg ), 
                                PSWIZB_BACK | 
                                    (ErrorsPresent ? 0 : PSWIZB_NEXT) );
                    ClearMessageQueue( );

                    if (Count) {
                        //
                        // only need this page if there are incompatibities
                        //
                    
                         TCHAR Text[512];
                    
                        //
                        // Customize the look of the page, depending on
                        // what we have to display.  3 cases are possible:
                        // 1. Warnings only (services we'll stop).
                        // 2. Errors only (items that will prevent installation).
                        // 3. combination of 1. and 2.
                        //
                        if( (WarningsPresent == TRUE) && (ErrorsPresent == TRUE) ) {
                            dw = LoadString(g_hinstance,IDS_COMPAT_ERR_WRN,Text,ARRAYSIZE(Text));
                            Assert( dw );
                        } else if( WarningsPresent == TRUE ) {
                            dw = LoadString(g_hinstance,IDS_COMPAT_WRN,Text,ARRAYSIZE(Text));
                            Assert( dw );
                        } else if( ErrorsPresent == TRUE ) {
                            dw = LoadString(g_hinstance,IDS_COMPAT_ERR,Text,ARRAYSIZE(Text));
                            Assert( dw );
                        } else {
                            Assert(FALSE);
                        }
                        SetDlgItemText(hdlg,IDC_INTRO_TEXT,Text);
                    
                        return(TRUE);
                    
                    } else {
                        DebugMsg( "Skipping compatibility page, no incompatibilities...\n" );
                        SetWindowLongPtr( hdlg, DWLP_MSGRESULT, -1 );   // don't show
                    }

                    return(TRUE);
                    break;
                case PSN_QUERYCANCEL:
                    return VerifyCancel( hdlg );
                    break;
                
                }

                if( (pnmv->hdr.code == LVN_ITEMCHANGED) ) {

                    
                    Index = ListView_GetNextItem( GetDlgItem( hdlg, IDC_ROOT_LIST ),
                                                  (int)-1,
                                                  (UINT) (LVNI_ALL | LVNI_SELECTED | LVNI_FOCUSED) );
                    
                    

                    if( (Index != LB_ERR) && (pnmv->iItem != CurrentSelectionIndex)) {
                        
                        // Always set the Details button
                        TmpHwnd = GetDlgItem( hdlg, IDC_DETAILS );
                        EnableWindow( TmpHwnd, TRUE );

                        InvalidateRect( GetParent(hdlg), NULL, FALSE );

                    }else if((Index != LB_ERR) && (pnmv->uNewState == (LVIS_SELECTED|LVIS_FOCUSED))){ 
                        
                        //Transition from nothing selected to previous selection
                    
                        TmpHwnd = GetDlgItem( hdlg, IDC_DETAILS );
                        EnableWindow( TmpHwnd, TRUE );
                        
                    }else if( Index == LB_ERR){
                        
                        // Disable the "Details" button as nothing is selected

                        TmpHwnd = GetDlgItem( hdlg, IDC_DETAILS );
                        EnableWindow( TmpHwnd, FALSE );

                    }
                }
            }
            break;
        case WM_COMMAND:

            if ((LOWORD(wParam) == IDC_DETAILS) && (HIWORD(wParam) == BN_CLICKED)) {
                TCHAR MessageText[300];
                TCHAR FormatText[300];

                Index = ListView_GetNextItem( GetDlgItem( hdlg, IDC_ROOT_LIST ),
                                              (int)-1,
                                              (UINT) (LVNI_ALL | LVNI_SELECTED) );
                if (Index == LB_ERR) {
                    return FALSE;
                }

                //
                // Select the item, and get the compatibility data for the item
                //
                lvi.mask = LVIF_PARAM;
                lvi.iItem = Index;
                lvi.iSubItem = 0;
                ListView_GetItem( GetDlgItem( hdlg, IDC_ROOT_LIST ), &lvi );
                CompData = (PRIPREP_COMPATIBILITY_DATA)lvi.lParam;

                if (CompData->MsgResourceId) {
                    dw = LoadString(g_hinstance,CompData->MsgResourceId,MessageText,ARRAYSIZE(MessageText));
                    Assert( dw );
                } else {
                    LoadString(
                        g_hinstance,
                        ((CompData->Flags & COMPFLAG_STOPINSTALL) 
                         ? IDS_INCOMPAT_STOP_FORMAT
                         : IDS_INCOMPAT_WARN_FORMAT ),
                               FormatText,ARRAYSIZE(FormatText));
                    _snwprintf(MessageText, ARRAYSIZE(MessageText), FormatText, CompData->Description );                    
                    TERMINATE_BUFFER(MessageText);
                }

                dw = LoadString(g_hinstance,IDS_INCOMPAT_MSG_TITLE,FormatText,ARRAYSIZE(FormatText));
                Assert( dw );

                MessageBox( 
                    hdlg,
                    MessageText,
                    FormatText,
                    ((CompData->Flags & COMPFLAG_STOPINSTALL) 
                     ? MB_OK | MB_ICONERROR
                     : MB_OK | MB_ICONWARNING ));
                
            }

            break;

        default:
            break;
    }

    return(b);
}

INT_PTR
StopServiceWrnDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL            b = FALSE;
    DWORD           i;
    PRIPREP_COMPATIBILITY_DATA CompData;
    DWORD           Index;
    static int CurrentSelectionIndex=0;
    static DWORD    Count = 0;
    LV_ITEM         lvi = {0};
    static BOOL     TriedStoppingServices = FALSE;
    PLIST_ENTRY     Next;
    HIMAGELIST      himl;
    HICON           hIcon;
    LV_COLUMN       lvc = {0};
    RECT            rc;
    WCHAR       szText[ 80 ];
    HWND hList =    GetDlgItem( hdlg, IDC_ROOT_LIST );
    DWORD dw;

    UNREFERENCED_PARAMETER(wParam);

    switch(msg) {

        case WM_INITDIALOG:

            if (ServicesToStopCount) {

                //
                // add a column
                //
                lvc.mask    = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
                lvc.fmt     = LVCFMT_LEFT;
                lvc.pszText = szText;
                lvc.iSubItem = 0;
                lvc.cx       = 100;
                LoadString( 
                    g_hinstance, 
                    IDS_SERVICE_NAME_COLUMN, 
                    szText, 
                    sizeof(szText)/sizeof(WCHAR));
                
                i = ListView_InsertColumn( hList, 0, &lvc );
                Assert( i != -1 );

                //
                // add a 2nd column
                //
                GetClientRect( hList, &rc );
                lvc.iSubItem++;
                lvc.cx       = ( rc.right - rc.left ) - lvc.cx;
                dw = LoadString( 
                    g_hinstance, 
                    IDS_SERVICE_DESCRIPTION_COLUMN, 
                    szText, 
                    ARRAYSIZE(szText));
                Assert( dw );
                i = ListView_InsertColumn ( hList, lvc.iSubItem, &lvc );
                Assert( i != -1 );
                
            }
            break;

        case WM_NOTIFY:

            {
                LPNMHDR lpnmhdr = (LPNMHDR) lParam;

                switch (lpnmhdr->code) {
                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons( 
                                GetParent( hdlg ), 
                                PSWIZB_BACK | PSWIZB_NEXT );
                    ClearMessageQueue( );


                    Next = CompatibilityData.Flink;
                    if (Next && (Count == 0)) {
                        himl = ImageList_Create( GetSystemMetrics(SM_CXSMICON),
                                                 GetSystemMetrics(SM_CXSMICON),
                                                 ILC_COLOR,
                                                 2,
                                                 0 );
                        ListView_SetImageList( hList, himl, LVSIL_SMALL );
                        hIcon = LoadIcon( NULL, IDI_HAND );
                        ImageList_AddIcon( himl, hIcon );
                        hIcon = LoadIcon( NULL, IDI_EXCLAMATION );
                        ImageList_AddIcon( himl, hIcon );
    
                        lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
                        lvi.state     = 0;
                        lvi.stateMask = 0;
                        while ((ULONG_PTR)Next != (ULONG_PTR)&CompatibilityData) {
                            CompData = CONTAINING_RECORD( Next, RIPREP_COMPATIBILITY_DATA, ListEntry );
    
                            Next = CompData->ListEntry.Flink;
    
                            if (OsVersion.dwMajorVersion < 5) {
                                if ( CompData->Flags & COMPFLAG_ALLOWNT5COMPAT ) {
                                    AnyNt5CompatDlls = TRUE;
                                } else {
                                    goto NextIteration;
                                }
                            }
    
                            if (CompData->Flags & COMPFLAG_CHANGESTATE) {
    
                                //
                                // Add the icon.
                                //
                                if( himl ) {
                                    lvi.iImage = 0;                                
                                }
    
                                //
                                // And the text...
                                //
                                lvi.pszText   = (LPTSTR)CompData->ServiceName;
                                lvi.lParam    = (LPARAM)CompData;
                                Index = ListView_InsertItem( hList, &lvi );
    
                                //
                                // and the description
                                //
                                
                                ListView_SetItemText( 
                                                hList, 
                                                Index, 
                                                1, 
                                                (LPWSTR)CompData->Description );
    
                                Count += 1;
                            }
    
    NextIteration:
                        NOTHING;
                        }
    
                    }
    
                    // If we have an item then make it the default selection
    
                    if( Count && !TriedStoppingServices ){                
                        TCHAR Text[512];

                        SetFocus( hList );
                        ListView_SetItemState( hList,
                                               0, 
                                               LVIS_SELECTED | LVIS_FOCUSED, 
                                               LVIS_SELECTED | LVIS_FOCUSED);
                        CurrentSelectionIndex = 0;
        
                        lvi.mask = LVIF_PARAM;
                        lvi.iItem = 0;
                        lvi.iSubItem = 0;
                        ListView_GetItem( GetDlgItem( hdlg, IDC_ROOT_LIST ), &lvi );
                        
                        //
                        // only need this page if there are incompatibities
                        //
                    
                        
                    
                        dw = LoadString(g_hinstance,IDS_STOPSVC_WRN,Text,ARRAYSIZE(Text));
                        Assert( dw );
                        SetDlgItemText(hdlg,IDC_INTRO_TEXT,Text);


                    } else {
                        DebugMsg( "Skipping StopService page, no services to stop...\n" );
                        SetWindowLongPtr( hdlg, DWLP_MSGRESULT, -1 );   // don't show
                    }

                    return(TRUE);
                    break;
                case PSN_QUERYCANCEL:
                    return VerifyCancel( hdlg );
                    break;

                case PSN_WIZNEXT:

                    if (!TriedStoppingServices) {
                        TriedStoppingServices = TRUE;
                    }
                
                }
                
            }
            break;
        
        default:
            break;
    }

    return(b);
}

BOOL
MyStopService(
    IN LPCTSTR ServiceName
    )
{
    SC_HANDLE hSC;
    SC_HANDLE hService;
    SERVICE_STATUS ServiceStatus;
    BOOL Status = FALSE;
    
    hSC = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (hSC != NULL) {
        hService = OpenService( hSC, ServiceName, SERVICE_STOP | SERVICE_QUERY_STATUS);

        if (hService != NULL) {
            if (QueryServiceStatus(
                            hService,
                            &ServiceStatus) &&
                ServiceStatus.dwCurrentState == SERVICE_STOPPED)  {
                Status = TRUE;
            } else {

                ULONG   StartTime = GetTickCount();
                
                while( ((GetTickCount() - StartTime) <= (30 * 1000)) &&         // Did we run over 30 seconds?
                       (!UserCancelled) ) {                                     // Did the user cancel via the UI?

                    if (ControlService( hService, 
                                        SERVICE_CONTROL_STOP,
                                        &ServiceStatus ) &&
                        (ServiceStatus.dwCurrentState == SERVICE_STOPPED)) {

                        Status = TRUE;
                        break;
                    }

                    if (QueryServiceStatus( hService,
                                            &ServiceStatus) &&
                        (ServiceStatus.dwCurrentState == SERVICE_STOPPED))  {

                        Status = TRUE;
                        break;
                    }

                    //
                    // Make sure we didn't wrap over 32-bits in our counter.
                    //
                    if( GetTickCount() < StartTime ) {

                        // he wrapped.  Reset StartTime.
                        StartTime = GetTickCount();
                    }


                    //
                    // It hasn't stopped yet.  Sleep and try again.
                    //
                    Sleep(1000);
                }
            }

            CloseServiceHandle( hService );
        }

        CloseServiceHandle( hSC );
    }

    return(Status);

}

DWORD
StopServiceThreadProc(
    LPVOID lParam 
    )
{
    PLIST_ENTRY     Next;
    BOOL RetVal = FALSE;
    PRIPREP_COMPATIBILITY_DATA CompData;
    DWORD StoppedServicesCount = 0;
    HWND hDlg = (HWND)lParam;
    CWaitCursor Cursor;
    
    EnterCriticalSection(&CompatibilityCS);
    Next = CompatibilityData.Flink;
    if (Next) {
    
        while (((ULONG_PTR)Next != (ULONG_PTR)&CompatibilityData) && !UserCancelled) {
        
            CompData = CONTAINING_RECORD( Next, RIPREP_COMPATIBILITY_DATA, ListEntry );
    
            Next = CompData->ListEntry.Flink;
    
            if (CompData->Flags & COMPFLAG_CHANGESTATE) {
    
                DebugMsg( "Stopping %s...\n", CompData->ServiceName );
                SetDlgItemText( hDlg, IDC_STOP_SERVICE, CompData->Description );
                
                if (MyStopService(CompData->ServiceName)) {
                    StoppedServicesCount += 1;
                } else {
                    LogMsg( L"Failed to stop service: %s\r\n", CompData->ServiceName );
                }
            }
        }
        
    }

    LeaveCriticalSection(&CompatibilityCS);
    
    if (!RetVal) {
        PostMessage( 
            hDlg, 
            WM_STOPSVCCOMPLETE, 
            (StoppedServicesCount == ServicesToStopCount),
            0);
    }
    
    return(0);
    
}


INT_PTR
DoStopServiceDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    static DWORD StoppedServicesCount = 0;
    static BOOL TriedStoppingServices = FALSE;
    static BOOL AlreadyPostedMessage = FALSE;
    BOOL b = FALSE;
    
    switch(msg) {    

        case WM_NOTIFY:

            {
                LPNMHDR lpnmhdr = (LPNMHDR) lParam;

                switch (lpnmhdr->code) {
                    case PSN_SETACTIVE:
                        PropSheet_SetWizButtons( 
                                    GetParent( hdlg ), 0 );                                
                        
                        ClearMessageQueue( );
    
                        if (TriedStoppingServices || ServicesToStopCount == 0) {
                            DebugMsg( "Skipping DoStopService page, already tried to stop services...\n" );
                            SetWindowLongPtr( hdlg, DWLP_MSGRESULT, -1 );   // don't show
                        }
    
                        if (!AlreadyPostedMessage && ServicesToStopCount) {
                            PostMessage( hdlg, WM_MYSTOPSVC, 0, 0 );
                            AlreadyPostedMessage = TRUE;
    
                        } 
    
                        return(TRUE);
                        break;

                    case PSN_QUERYCANCEL:
                        b = VerifyCancel( hdlg );
                        if (!b) {
                            UserCancelled = TRUE;
                        }
                        return(b);
                        break;

                }                            
            }
            break;
        case WM_MYSTOPSVC:
            {
                HANDLE hThread;
                DWORD dontcare;    
                
                DebugMsg( "received WM_MYSTOPSVC...\n" );
                hThread = CreateThread( NULL, 0, StopServiceThreadProc, hdlg, 0, &dontcare);
                if (hThread) {
                    CloseHandle(hThread);
                } else {
                    PostMessage( hdlg, WM_STOPSVCCOMPLETE, 0, 0);
                }
            }
            
            break;

        case WM_STOPSVCCOMPLETE:
            DebugMsg( "received WM_STOPSVCCOMPLETE...\n" );           
            TriedStoppingServices = TRUE;
            if (wParam == (WPARAM)FALSE) {
                MessageBoxFromStrings( hdlg, IDS_STOPSVC_FAIL_TITLE, IDS_STOPSVC_FAIL_TEXT, MB_OK );
            }
            PropSheet_SetWizButtons(
                        GetParent( hdlg ), PSWIZB_BACK | PSWIZB_NEXT );
            PropSheet_PressButton( GetParent( hdlg ), PSBTN_NEXT );        
            break;
                
        default:
            break;
    }

    return(b);
}



BOOLEAN
CheckForFileVersion(
    LPCTSTR FileName,
    LPCTSTR FileVer
    )
/*
    Arguments -
    
        FileName - Full path to the file to check
        Filever  - Version value to check against of the for x.x.x.x
        
    Function will check the actual file against the version specified. The depth of the check 
    is as deep as specified in "x.x.x.x" i..e if FileVer = 3.5.1 and actual version on the file
    is 3.5.1.4 we only compare upto 3.5.1.
    
    Return values - 
    
    TRUE - If the version of the file is <= FileVer which means that the file is an incompatible one
        
    else we return FALSE            
  
*/

{
    TCHAR Buffer[MAX_PATH];
    DWORD dwLength, dwTemp;
    TCHAR Datum[2];
    UINT DataLength;
    LPVOID lpData;
    VS_FIXEDFILEINFO *VsInfo;
    LPTSTR s,e;
    DWORD Vers[5],File_Vers[5];//MajVer, MinVer;
    int i=0, Depth=0;


    if (!ExpandEnvironmentStrings( FileName, Buffer, ARRAYSIZE(Buffer) )) {
        return FALSE;
    }


    if(!FileExists(Buffer))
        return FALSE;
    
    if( !FileVer || !(*FileVer) ){ // Since no version info is provided this boils down to a 
        return TRUE;               // presence check which was already done above
    }


    //
    // NT3.51 VerQueryValue writes into the buffer, can't use
    // a string constant.
    //
    lstrcpy( Datum, TEXT("\\") );

    if(dwLength = GetFileVersionInfoSize( Buffer, &dwTemp )) {
        if(lpData = LocalAlloc( LPTR, dwLength )) {
            if(GetFileVersionInfo( Buffer, 0, dwLength, lpData )) { 
                if (VerQueryValue( 
                            lpData, 
                            Datum, 
                            (LPVOID *)&VsInfo, 
                            &DataLength )) {

                    File_Vers[0] = (HIWORD(VsInfo->dwFileVersionMS));
                    File_Vers[1] = (LOWORD(VsInfo->dwFileVersionMS));
                    File_Vers[2] = (HIWORD(VsInfo->dwFileVersionLS));
                    File_Vers[3] = (LOWORD(VsInfo->dwFileVersionLS));


                    lstrcpyn( Buffer, FileVer, ARRAYSIZE(Buffer) );

                    //Parse and get the depth of versioning we look for

                    s = e = Buffer;
                    while( e  ){

                        if ( ((*e < TEXT('0')) || (*e > TEXT('9'))) && ((*e != TEXT('.')) && (*e != TEXT('\0'))) )
                            return FALSE;


                        if(*e == TEXT('\0')){
                            *e = 0;
                            Vers[i] = (DWORD)_ttoi(s);
                            break;
                        }


                        if( *e == TEXT('.') ){
                            *e = 0;
                            Vers[i++] = (DWORD)_ttoi(s);
                            s = e+1;
                        }

                        e++;

                    }// while

                    Depth = i+1;
                    if (Depth > 4)
                        Depth = 4;


                    for( i=0; i < Depth; i++ ){

                        if( File_Vers[i] > Vers[i] ){
                            LocalFree( lpData );
                            return FALSE;
                        }
                        else if( File_Vers[i] ==  Vers[i] )
                            continue;
                        else
                            break;


                    }




                }
            }

            LocalFree( lpData );

        }
    }
    return TRUE;

}



DWORD
ProcessRegistryLine(
    PINFCONTEXT InfContext
    )
{
    LONG Error;
    HKEY hKey;
    DWORD Size, Reg_Type;
    LPBYTE Buffer;
    PRIPREP_COMPATIBILITY_DATA CompData;
    TCHAR RegKey[100];
    TCHAR RegValue[100];
    TCHAR RegValueExpect[100];
    TCHAR Path[MAX_PATH];
    TCHAR Value[20];
    INT Flags = 0;

    RegKey[0] = NULL;
    RegValue[0] = NULL;
    RegValueExpect[0] = NULL;

    SetupGetStringField( InfContext, 2, RegKey, ARRAYSIZE( RegKey ), NULL);
    SetupGetStringField( InfContext, 3, RegValue, ARRAYSIZE( RegValue ), NULL);
    SetupGetStringField( InfContext, 4, RegValueExpect, ARRAYSIZE( RegValueExpect ), NULL);

    //
    // open the reg key
    //

    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        RegKey,
        0,
        KEY_READ,
        &hKey
        );
    if( Error != ERROR_SUCCESS ) {
        //
        // bogus reg key
        //
        return 0;
    }


    if(  *RegValue ){


        //
        // find out how much data there is
        //

        Error = RegQueryValueEx(
            hKey,
            RegValue,
            NULL,
            &Reg_Type,
            NULL,
            &Size
            );
        if( Error != ERROR_SUCCESS ) {
            RegCloseKey( hKey );
            return 0;
        }

        //
        // allocate the buffer
        //

        Buffer = (LPBYTE) MALLOC( Size );
        if (Buffer == NULL) {
            RegCloseKey( hKey );
            return 0;
        }

        //
        // read the data
        //

        Error = RegQueryValueEx(
            hKey,
            RegValue,
            NULL,
            NULL,
            Buffer,
            &Size
            );
        if( Error != ERROR_SUCCESS ) {
            RegCloseKey( hKey );
            FREE( Buffer );
            return 0;
        }

        RegCloseKey( hKey );


        if( Reg_Type == REG_DWORD ){
            _itot( (DWORD)*Buffer, Value, 10 );
            FREE( Buffer );
            Buffer = (LPBYTE) DupString(Value);
            if (!Buffer) {
                return(0);
            }
        }

        if ( *RegValueExpect && lstrcmp( RegValueExpect, (LPTSTR)Buffer ) != 0) {
            FREE( Buffer );
            return 0;
        }

        FREE( Buffer );

    } else {
        RegCloseKey( hKey );
    }

    CompData = (PRIPREP_COMPATIBILITY_DATA) MALLOC( sizeof(RIPREP_COMPATIBILITY_DATA) );
    if (CompData == NULL) {
        return 0;
    }

    ZeroMemory(CompData,sizeof(RIPREP_COMPATIBILITY_DATA));

    CompData->RegKey         = DupString(RegKey);
    CompData->RegValue       = DupString(RegValue);
    CompData->RegValueExpect = DupString(RegValueExpect);

    SetupGetStringField( InfContext, 5, Path, ARRAYSIZE( Path ), NULL);
    CompData->HtmlName       = DupString(Path);
    SetupGetStringField( InfContext, 6, Path, ARRAYSIZE( Path ), NULL);
    CompData->TextName       = DupString(Path);
    SetupGetStringField( InfContext, 7, Path, ARRAYSIZE( Path ), NULL);
    CompData->Description    = DupString(Path);   
    
    SetupGetIntField( InfContext,10,&Flags);
    CompData->Flags |= (GlobalCompFlags | Flags);


    EnterCriticalSection(&CompatibilityCS);
    InsertTailList( &CompatibilityData, &CompData->ListEntry );
    LeaveCriticalSection(&CompatibilityCS);

    return 1;
}



BOOL
MyGetServiceDescription(
    IN LPCTSTR ServiceName,
    IN OUT LPTSTR Buffer,
    IN DWORD BufferSizeInChars
    )
{
    SC_HANDLE hSC;
    SC_HANDLE hService;
    LPQUERY_SERVICE_CONFIG pServiceConfig;
    DWORD SizeNeeded;
    BOOL Status = FALSE;

    hSC = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (hSC != NULL) {
        hService = OpenService( hSC, ServiceName, SERVICE_QUERY_CONFIG);

        if (hService != NULL) {
            if (!QueryServiceConfig(
                            hService, 
                            NULL, 
                            0, 
                            &SizeNeeded) &&
                GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
                (pServiceConfig = (LPQUERY_SERVICE_CONFIG)MALLOC(SizeNeeded)) &&
                QueryServiceConfig(
                            hService,
                            pServiceConfig, 
                            SizeNeeded, 
                            &SizeNeeded) &&
                wcslen(pServiceConfig->lpDisplayName)+1 <= BufferSizeInChars) {
                wcscpy(Buffer,pServiceConfig->lpDisplayName);
                FREE(pServiceConfig);
                Status = TRUE;
            }

            CloseServiceHandle( hService );
        }

        CloseServiceHandle( hSC );
    }

    return(Status);

}

BOOL
IsServiceStopped(
    IN LPCTSTR ServiceName
    )
{
    SC_HANDLE hSC;
    SC_HANDLE hService;
    BOOL Status = FALSE;
    SERVICE_STATUS ServiceStatus;

    hSC = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (hSC != NULL) {
        hService = OpenService( hSC, ServiceName, SERVICE_QUERY_STATUS);

        if (hService != NULL) {
            if (QueryServiceStatus( 
                            hService,
                            &ServiceStatus) &&
                ServiceStatus.dwCurrentState == SERVICE_STOPPED ) {

                Status = TRUE;

            }

            CloseServiceHandle( hService );
        } else if (GetLastError() == ERROR_SERVICE_DOES_NOT_EXIST) {
            Status = TRUE;
        }

        CloseServiceHandle( hSC );
    }

    return(Status);

}




DWORD
ProcessServiceLine(
    PINFCONTEXT InfContext,
    BOOL SetCheckedFlag
    )
{
    TCHAR Buffer[100],Buffer2[64],Buffer3[MAX_PATH];
    LONG Error;
    HKEY hKey;
    INT Flags = 0;
    PRIPREP_COMPATIBILITY_DATA CompData;
    LPDWORD RegData;
    DWORD Value;
    DWORD ValueSize;
    TCHAR FileVersion[20];
    LPTSTR KeyName = NULL;
    LPTSTR FileName = Buffer3;
    DWORD dw;


    SetupGetStringField( InfContext, 2, Buffer, ARRAYSIZE( Buffer ), NULL);

    lstrcpyn( Buffer2, TEXT("SYSTEM\\CurrentControlSet\\Services\\"), ARRAYSIZE(Buffer2) );
    wcsncat( Buffer2, Buffer, ARRAYSIZE(Buffer2) - wcslen(Buffer2) );
    TERMINATE_BUFFER(Buffer2);
    KeyName = Buffer2;

    //
    // get an open key to the services database
    //

    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        KeyName,
        0,
        KEY_READ | KEY_WRITE,
        &hKey
        );
    if( Error != ERROR_SUCCESS ) {
        return 0;
    }

    //
    // We'll ceate a key here so that others will know that we've
    // already checked this service.  We'll remove it later.  We
    // don't care about error codes here because this is only used
    // as a safety net for checks that may come after us.
    //
    if( SetCheckedFlag ) {
        Value = 1;
        RegSetValueEx( hKey,
                       TEXT("SetupChecked"),
                       0,
                       REG_DWORD,
                       (CONST BYTE *)&Value,
                       sizeof(DWORD) );
    } else {
        //
        // The user has asked us to simply remove these 'checked' flags
        // from the services that we've examined.
        //
        RegDeleteValue( hKey,
                        TEXT("SetupChecked") );
        RegCloseKey( hKey );
        return 0;
    }

    //
    // Check the start value of our target service.  If it's disabled,
    // then we don't have an incompatibility.
    //
    ValueSize = sizeof(Value);

    Error = RegQueryValueEx(
        hKey,
        TEXT("Start"),
        NULL,
        NULL,
        (LPBYTE)&Value,
        &ValueSize
        );

    if( (Error == ERROR_SUCCESS) && (Value == SERVICE_DISABLED) ){
        RegCloseKey( hKey );
        return 0;
    }

    RegCloseKey( hKey );

    //
    // Check the version of a file for the service.  If only some
    // versions are bad, then we may or may not have an incompatibility.
    //
    FileName[0] = NULL;
    FileVersion[0] = NULL;
    SetupGetStringField( InfContext, 6, FileName, ARRAYSIZE( Buffer3 ), NULL);
    SetupGetStringField( InfContext, 7, FileVersion, ARRAYSIZE( FileVersion ), NULL);
    SetupGetIntField( InfContext, 8 , &Flags);

    Flags |= GlobalCompFlags;

    if( *FileName && *FileVersion ){

        if( !CheckForFileVersion( FileName, FileVersion ) )
            return 0;

    }

    //
    // if we're only incompatible if the service is actually running at the
    // moment, then check that.  Note that we check for the service being 
    // stopped instead of running, as we don't want to the service to be in
    // some pending state when we continue on.
    //
    if (Flags & COMPFLAG_SERVICERUNNING) {
        if (IsServiceStopped(Buffer)) {
            return 0;
        }
    }


    RegData = (LPDWORD)MALLOC( sizeof(DWORD) );
    if (RegData == NULL) {
        return 0;
    }

    CompData = (PRIPREP_COMPATIBILITY_DATA) MALLOC( sizeof(RIPREP_COMPATIBILITY_DATA) );
    if (CompData == NULL) {
        FREE(RegData);
        return 0;
    }

    ZeroMemory(CompData,sizeof(RIPREP_COMPATIBILITY_DATA));

    CompData->ServiceName           = DupString(Buffer);
    SetupGetStringField( InfContext, 3, Buffer, ARRAYSIZE( Buffer ), NULL);
    CompData->HtmlName              = DupString(Buffer);
    SetupGetStringField( InfContext, 4, Buffer, ARRAYSIZE( Buffer ), NULL);
    CompData->TextName              = DupString(Buffer);
    Buffer[0] = UNICODE_NULL;
    SetupGetStringField( InfContext, 5, Buffer, ARRAYSIZE( Buffer ), NULL);
    if (Buffer[0] == UNICODE_NULL) {
        if (!MyGetServiceDescription(CompData->ServiceName,Buffer,ARRAYSIZE(Buffer))) {
            LPVOID Args[2];
            dw = LoadString(g_hinstance,IDS_SERVICE_DESC_UNKNOWN,Buffer2,ARRAYSIZE(Buffer2));
            Assert( dw );
            dw = LoadString(g_hinstance,IDS_SERVICE_DESC_FORMAT,Buffer3,ARRAYSIZE(Buffer3));
            Assert( dw );
            Args[0] = (LPVOID)CompData->ServiceName;
            Args[1] = (LPVOID)Buffer2;
            FormatMessage(
                FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                Buffer3,
                0,
                0,
                Buffer,
                ARRAYSIZE(Buffer),   // size of buffer
                (va_list*) Args );           // arguments

        }
    }
    CompData->Description           = DupString(Buffer);
    CompData->RegKeyName            = DupString( KeyName );
    CompData->RegValName            = DupString( TEXT("Start") );
    RegData[0]                      = 4;
    CompData->RegValData            = RegData;
    CompData->RegValDataSize        = sizeof(DWORD);
    CompData->Flags                |= Flags ;
    
    EnterCriticalSection(&CompatibilityCS);
    InsertTailList( &CompatibilityData, &CompData->ListEntry );
    LeaveCriticalSection(&CompatibilityCS);

    return 1;
}


DWORD
ProcessFileLine(
    PINFCONTEXT InfContext
    )
{

    PRIPREP_COMPATIBILITY_DATA CompData;
    TCHAR FileName[MAX_PATH];
    TCHAR FileVer[100];
    INT Flags;


    FileVer[0] = NULL;
    FileName[0] = NULL;

    SetupGetStringField( InfContext, 2, FileName, ARRAYSIZE( FileName ), NULL);
    SetupGetStringField( InfContext, 3, FileVer, ARRAYSIZE( FileVer ), NULL);
    
    if( *FileName ){

        if( !CheckForFileVersion( FileName, FileVer ) )
            return 0;
    } else{
        return 0;
    }


    CompData = (PRIPREP_COMPATIBILITY_DATA) MALLOC( sizeof(RIPREP_COMPATIBILITY_DATA) );
    if (CompData == NULL) {
        return 0;
    }

    ZeroMemory(CompData,sizeof(RIPREP_COMPATIBILITY_DATA));

    CompData->FileName       = DupString( FileName );
    CompData->FileVer        = DupString( FileVer );

    SetupGetStringField( InfContext, 4, FileName, ARRAYSIZE( FileName ), NULL);
    CompData->HtmlName       = DupString( FileName );
    SetupGetStringField( InfContext, 5, FileName, ARRAYSIZE( FileName ), NULL);
    CompData->TextName       = DupString( FileName );
    SetupGetStringField( InfContext, 6, FileName, ARRAYSIZE( FileName ), NULL);
    CompData->Description       = DupString( FileName );
    Flags = 0;
    SetupGetIntField( InfContext, 7 , &Flags);

    CompData->Flags |= (GlobalCompFlags | Flags);

    EnterCriticalSection(&CompatibilityCS);
    InsertTailList( &CompatibilityData, &CompData->ListEntry );
    LeaveCriticalSection(&CompatibilityCS);

    return 1;
}

BOOL
CompatibilityCallback(
    PRIPREP_COMPATIBILITY_ENTRY CompEntry,
    PRIPREP_COMPATIBILITY_CONTEXT CompContext
    )
{
    PRIPREP_COMPATIBILITY_DATA CompData;

    //
    // parameter validation
    //

    if (CompEntry->Description == NULL || CompEntry->Description[0] == 0) {
        SetLastError( COMP_ERR_DESC_MISSING );
        return FALSE;
    }

    if (CompEntry->TextName == NULL || CompEntry->TextName[0] ==0) {
        SetLastError( COMP_ERR_TEXTNAME_MISSING );
        return FALSE;
    }

    if (CompEntry->RegKeyName) {
        if (CompEntry->RegValName == NULL) {
            SetLastError( COMP_ERR_REGVALNAME_MISSING );
            return FALSE;
        }
        if (CompEntry->RegValData == NULL) {
            SetLastError( COMP_ERR_REGVALDATA_MISSING );
            return FALSE;
        }
    }


#ifdef UNICODE
    if (IsTextUnicode( CompEntry->Description, wcslen(CompEntry->Description)*sizeof(WCHAR), NULL ) == 0) {
        SetLastError( COMP_ERR_DESC_NOT_UNICODE );
        return FALSE;
    }
    if (IsTextUnicode( CompEntry->TextName, wcslen(CompEntry->TextName)*sizeof(WCHAR), NULL ) == 0) {
        SetLastError( COMP_ERR_TEXTNAME_NOT_UNICODE );
        return FALSE;
    }
    if (CompEntry->HtmlName) {
        if (IsTextUnicode( CompEntry->HtmlName, wcslen(CompEntry->HtmlName)*sizeof(WCHAR), NULL ) == 0) {
            SetLastError( COMP_ERR_HTMLNAME_NOT_UNICODE );
            return FALSE;
        }
    }
    if (CompEntry->RegKeyName) {
        if (IsTextUnicode( CompEntry->RegKeyName, wcslen(CompEntry->RegKeyName)*sizeof(WCHAR), NULL ) == 0) {
            SetLastError( COMP_ERR_REGKEYNAME_NOT_UNICODE );
            return FALSE;
        }
        if (IsTextUnicode( CompEntry->RegValName, wcslen(CompEntry->RegValName)*sizeof(WCHAR), NULL ) == 0) {
            SetLastError( COMP_ERR_REGVALNAME_NOT_UNICODE );
            return FALSE;
        }
    }


#endif

    //
    // allocate the compatibility structure
    //

    CompData = (PRIPREP_COMPATIBILITY_DATA) MALLOC( sizeof(RIPREP_COMPATIBILITY_DATA) );
    if (CompData == NULL) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    ZeroMemory(CompData, sizeof(RIPREP_COMPATIBILITY_DATA));

    //
    // save the sata
    //

    CompData->Description     = DupString( CompEntry->Description );
    CompData->HtmlName        = CompEntry->HtmlName ? DupString( CompEntry->HtmlName ) : NULL;
    CompData->TextName        = DupString( CompEntry->TextName );    
    CompData->Flags           = CompEntry->Flags;
    CompData->Flags          |= CompContext->Flags;
    CompData->Flags          |= GlobalCompFlags;
    CompData->hModDll         = CompContext->hModDll;
    CompData->MsgResourceId   = CompEntry->MsgResourceId;
    if (CompEntry->RegKeyName) {
        CompData->RegKeyName      = DupString( CompEntry->RegKeyName );
        CompData->RegValName      = DupString( CompEntry->RegValName );
        CompData->RegValDataSize  = CompEntry->RegValDataSize;
        CompData->RegValData      = MALLOC(CompEntry->RegValDataSize);
        if (CompData->RegValData) {
            CopyMemory( CompData->RegValData, CompEntry->RegValData, CompEntry->RegValDataSize );
        }
    }

    EnterCriticalSection(&CompatibilityCS);
    InsertTailList( &CompatibilityData, &CompData->ListEntry );
    LeaveCriticalSection(&CompatibilityCS);

    CompContext->Count += 1;

    return TRUE;

}


DWORD
ProcessDLLLine(
    PINFCONTEXT InfContext
    )
{
    TCHAR Buffer[MAX_PATH];
    HMODULE hMod;
    CHAR CompCheckEntryPoint[MAX_PATH];
    PCOMPATIBILITYCHECK CompCheck;
    TCHAR DllName[100];
    TCHAR CompCheckEntryPointW[100];
    INT AllowCompatibilityErrorOnNT5;
    RIPREP_COMPATIBILITY_CONTEXT CompContext;
    BOOL Rslt;
    DWORD Status;


    SetupGetStringField( InfContext, 2, DllName, ARRAYSIZE( DllName ), NULL);
    SetupGetStringField( InfContext, 3, CompCheckEntryPointW, ARRAYSIZE( CompCheckEntryPointW ), NULL);
    
    SetupGetIntField( InfContext, 6, &AllowCompatibilityErrorOnNT5);
    
    if (!ExpandEnvironmentStrings( DllName, Buffer, ARRAYSIZE(Buffer) )) {
        return 0;
    }

    hMod = LoadLibrary( Buffer );
    if (hMod == NULL) {
        return 0;
    }

#ifdef UNICODE
    WideCharToMultiByte(
        CP_ACP,
        0,
        CompCheckEntryPointW,
        -1,
        CompCheckEntryPoint,
        sizeof(CompCheckEntryPoint),
        NULL,
        NULL
        );
#else
    lstrcpy( CompCheckEntryPoint, CompCheckEntryPointW );
#endif

    CompCheck = (PCOMPATIBILITYCHECK) GetProcAddress( hMod, CompCheckEntryPoint );
    if (CompCheck == NULL) {
        FreeLibrary( hMod );
        return 0;
    }

    CompContext.SizeOfStruct = sizeof(CompContext);
    CompContext.Count = 0;
    CompContext.hModDll = hMod;
    CompContext.Flags = (AllowCompatibilityErrorOnNT5) ? COMPFLAG_ALLOWNT5COMPAT : 0;

    if ((OsVersion.dwMajorVersion < 5 )
        && ((CompContext.Flags & COMPFLAG_ALLOWNT5COMPAT)==0)) {
        Rslt = FALSE;
    } else {
        __try {
            Rslt = CompCheck( (PCOMPATIBILITYCALLBACK)CompatibilityCallback, (LPVOID)&CompContext );
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
            Rslt = FALSE;
        }
    }

    if (!Rslt) {
        FreeLibrary( hMod );
        return 0;
    }

    if (CompContext.Count == 0) {
        FreeLibrary( hMod );
    }

    return CompContext.Count;
}


DWORD
ProcessCompatibilitySection(
    HINF hInf,
    LPTSTR SectionName
    )
{
    DWORD LineCount;
    DWORD Count;
    DWORD i;
    TCHAR Type[20];
    INFCONTEXT InfContext;


    //
    // get the section count, zero means bail out
    //

    LineCount = SetupGetLineCount( hInf, SectionName );
    if (LineCount == 0 || LineCount == 0xffffffff) {
        return 0;
    }

    for (i=0,Count=0; i<LineCount; i++) {

        if (SetupGetLineByIndex( hInf , SectionName, i, &InfContext ) && 
            SetupGetStringField( &InfContext, 1, Type, ARRAYSIZE( Type ), NULL)) {

            switch (_totlower(Type[0])) {
                case TEXT('r'):
                    //
                    // registry value
                    //
                    Count += ProcessRegistryLine( &InfContext );
                    break;
    
                case TEXT('s'):
                    //
                    // service or driver
                    //
                    Count += ProcessServiceLine( &InfContext, TRUE );
                    break;
    
                case TEXT('f'):
                    //
                    // presence of a file
                    //
                    Count += ProcessFileLine( &InfContext );
                    break;
    
                case TEXT('d'):
                    //
                    // run an external dll
                    //
                    Count += ProcessDLLLine( &InfContext );
                    break;
    
                default:
                    break;
            }
        }
    }

    return Count;
}


VOID
RemoveCompatibilityServiceEntries(
    HINF   hInf,
    LPTSTR SectionName
    )
{
    DWORD LineCount;
    DWORD Count;
    DWORD i;
    TCHAR Type[20];
    INFCONTEXT InfContext;

    //
    // get the section count, zero means bail out
    //

    LineCount = SetupGetLineCount( hInf , SectionName );
    if (LineCount == 0 || LineCount == 0xffffffff) {
        return;
    }

    for (i=0,Count=0; i<LineCount; i++) {

        if (SetupGetLineByIndex( hInf , SectionName, i, &InfContext ) && 
            SetupGetStringField( &InfContext, 1, Type, ARRAYSIZE( Type ), NULL)) {
                
                switch (_totlower(Type[0])) {
                    case TEXT('s'):
                        //
                        // service or driver
                        //
                        Count += ProcessServiceLine( &InfContext, FALSE );
                        break;
        
                    default:
                        break;
                }
        }
    }
}


BOOL
ProcessCompatibilityData(
    VOID
    )
{
    HINF hInf = INVALID_HANDLE_VALUE;
    TCHAR Path[MAX_PATH], *p;

    if( !CompatibilityData.Flink ) {
        InitializeListHead( &CompatibilityData );
        InitializeCriticalSection( &CompatibilityCS );
    } else {
        Assert(FALSE);
        return (CompatibilityCount != 0);
    }

    GetModuleFileName( NULL, Path, ARRAYSIZE( Path ));
    Path[ARRAYSIZE( Path ) -1] = TEXT('\0');
    if (p = _tcsrchr(Path, TEXT('\\'))) {
        *p = NULL;
        lstrcat(Path, TEXT("\\riprep.inf"));

        hInf = SetupOpenInfFile( 
                               Path, 
                               NULL, 
                               INF_STYLE_WIN4,
                               NULL );
        if (hInf == INVALID_HANDLE_VALUE) {
            return(TRUE);
        }
    }

    g_hCompatibilityInf = hInf;

    GlobalCompFlags = COMPFLAG_STOPINSTALL;
    CompatibilityCount = 0;
    
    CompatibilityCount += ProcessCompatibilitySection(hInf, TEXT("ServicesToStopInstallation") );
    if (CompatibilityCount) {
        IncompatibilityStopsInstallation = TRUE;
    }

    GlobalCompFlags = 0;
    CompatibilityCount += ProcessCompatibilitySection(hInf, TEXT("ServicesToWarn") );

    GlobalCompFlags = COMPFLAG_SERVICERUNNING | COMPFLAG_CHANGESTATE;
    ServicesToStopCount = ProcessCompatibilitySection(hInf, TEXT("ServicesToStop") );

    //
    // Now cleanup any turds we left in the registry on the services we checked.
    //
    RemoveCompatibilityServiceEntries(hInf, TEXT("ServicesToStopInstallation") );
    RemoveCompatibilityServiceEntries(hInf, TEXT("ServicesToWarn") );
    RemoveCompatibilityServiceEntries(hInf, TEXT("ServicesToStop") );

    if( CompatibilityCount ) {
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL CleanupCompatibilityData(
    VOID
    )
{
    PLIST_ENTRY Next = CompatibilityData.Flink;
    PRIPREP_COMPATIBILITY_DATA CompData;
    
    if (CompatibilityData.Flink) {
        EnterCriticalSection(&CompatibilityCS);

        while ((ULONG_PTR)Next != (ULONG_PTR)&CompatibilityData) {
            CompData = CONTAINING_RECORD( Next, RIPREP_COMPATIBILITY_DATA, ListEntry );
            
            RemoveEntryList( &CompData->ListEntry );
            
            Next = CompData->ListEntry.Flink;
    
            if (CompData->ServiceName) {
                FREE(CompData->ServiceName);
            }
            
            if (CompData->RegKey) {
                FREE(CompData->RegKey);
            }
    
            if (CompData->RegValue) {
                FREE(CompData->RegValue);
            }
    
            if (CompData->RegValueExpect) {
                FREE(CompData->RegValueExpect);
            }
    
            if (CompData->FileName) {
                FREE(CompData->FileName);
            }
            
            if (CompData->FileVer) {
                FREE(CompData->FileVer);
            }
    
            if (CompData->Description) {
                FREE(CompData->Description);
            }
            
            if (CompData->HtmlName) {
                FREE(CompData->HtmlName);
            }
            
            if (CompData->TextName) {
                FREE(CompData->TextName);
            }
            
            if (CompData->RegKeyName) {
                FREE(CompData->RegKeyName);
            }
            
            if (CompData->RegValName) {
                FREE(CompData->RegValName);
            }
            
            if (CompData->RegValData) {
                FREE(CompData->RegValData);
            }
            
            FREE(CompData);
        }
    
        LeaveCriticalSection(&CompatibilityCS);

    }

    return(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\debug.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved

  File: DEBUG.H

  Debugging utilities header
 
 ***************************************************************************/


#ifndef _DEBUG_H_
#define _DEBUG_H_

// Trace Flags
#define TF_ALWAYS           0xFFFFFFFF
#define TF_NEVER            0x00000000
#define TF_QUERYINTERFACE   0x00000001   // Query Interface details
#define TF_FUNC             0x00000002   // Functions entrances w/parameters
#define TF_CALLS            0x00000004   // Function calls
#define TF_MEMORYALLOCS     0x00000008   // Memory Allocations
#define TF_DLL              0x00000010   // DLL specific
#define TF_WM               0x00000020   // Window Messages
#define TF_SCP              0x00000030    // SCP objects

#ifdef DEBUG

#pragma message("BUILD: DEBUG macros being built")

// Globals
extern DWORD g_TraceMemoryIndex;
extern DWORD g_dwCounter;
extern DWORD g_dwTraceFlags;

extern const TCHAR g_szTrue[];
extern const TCHAR g_szFalse[];


// Macros
#define DEFINE_MODULE( _module ) static const TCHAR g_szModule[] = TEXT(_module);
#define __MODULE__ g_szModule
#define DEFINE_THISCLASS( _class ) static const TCHAR g_szClass[] = TEXT(_class); 
#define __THISCLASS__ g_szClass
#define DEFINE_SUPER( _super ) static const TCHAR g_szSuper[] = TEXT(_super);
#define __SUPER__ g_szSuper

#if defined(_X86_)
#define DEBUG_BREAK        do { _try { _asm int 3 } _except (EXCEPTION_EXECUTE_HANDLER) {;} } while (0)
#else
#define DEBUG_BREAK         DebugBreak( );
#endif

#define INITIALIZE_TRACE_MEMORY_PROCESS     \
    g_TraceMemoryIndex = TlsAlloc( );       \
    TlsSetValue( g_TraceMemoryIndex, NULL); \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_DLL, TEXT("Thread Memory tracing initialize.\n") )

#define INITIALIZE_TRACE_MEMORY_THREAD      \
    TlsSetValue( g_TraceMemoryIndex, NULL); \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_DLL, TEXT("Thread Memory tracing initialize.\n") )

#define UNINITIALIZE_TRACE_MEMORY           \
    DebugMemoryCheck( );                    \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_DLL, TEXT("Memory tracing terminated.\n") )

#ifdef Assert
#undef Assert
#endif
#define Assert( _fn ) \
    if ( !(_fn) && AssertMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), !!(_fn) ) ) DEBUG_BREAK

#ifdef AssertMsg
#undef AssertMsg
#endif
#define AssertMsg( _fn, _msg ) \
    if ( !(_fn) && AssertMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT(_msg), !!(_fn) ) ) DEBUG_BREAK

#define TraceAlloc( _flags, _size ) DebugAlloc( TEXT(__FILE__), __LINE__, g_szModule, _flags, _size, TEXT(#_size) )
#define TraceAllocString( _flags, _size ) DebugAlloc( TEXT(__FILE__), __LINE__, g_szModule, _flags, (_size) * sizeof(TCHAR), TEXT(#_size) )
#define TraceFree( _hmem )          DebugFree( _hmem )

//
// Tracing Macros
//
// All functions that begin with "Trace" are in both DEBUG and RETAIL, but
// in RETAIL they do not spew output.
//

// Displays file, line number, module and "_msg" only if the TF_FUNC is set
// in g_dwTraceFlags.
#define TraceFunc( _msg ) \
    InterlockIncrement(g_dwCounter); \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("+ ") TEXT(_msg) );

// Displays file, line number, module, class name and "_msg" only if the 
// TF_FUNC is set in g_dwTraceFlags.
#define TraceClsFunc( _msg ) \
    InterlockIncrement(g_dwCounter); \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("+ %s::%s"), g_szClass, TEXT(_msg) );

// Return macro for TraceFunc() and TraceClsFunc()
#define TraceFuncExit() { \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("V*\n") ); \
    InterlockDecrement(g_dwCounter); \
    return; \
}
#define RETURN( _rval ) { \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("V\n") ); \
    InterlockDecrement(g_dwCounter); \
    return _rval; \
}

// If the value is not S_OK, it will display it.
#define HRETURN( _hr ) { \
    if ( _hr ) \
        TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("V hr = 0x%08x\n"), _hr ); \
    else \
        TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("V\n") ); \
    InterlockDecrement(g_dwCounter); \
    return _hr; \
}

// Displays the file, line number, module and function call and return from the
// function call (no return value displayed) for "_fn" only if the TF_CALLS is 
// set in g_dwTraceFlags. 
#define TraceDo( _fn ) {\
    InterlockIncrement(g_dwCounter); \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_CALLS, TEXT("+ %s\n"), TEXT(#_fn) ); \
    _fn; \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_CALLS, TEXT("V\n") ); \
    InterlockDecrement(g_dwCounter); \
}

// This functions only asserts if the result is ZERO.
#define TraceAssertIfZero( _fn ) \
    if ( !(_fn) && AssertMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), !!(_fn) ) ) DEBUG_BREAK


#define ErrorMsg( _fmt, _arg ) \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_ALWAYS, TEXT(_fmt), _arg );


//
// HRESULT testing macros
//
// These functions check HRESULT return values and display UI if conditions
// warrant only in DEBUG.
//

// Warning is display if HRESULT is anything but S_OK (0).
#define THR( _fn ) \
    TraceHR( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), _fn )

// Warning is display if HRESULT is anything but S_OK (0).
#define RRETURN( _fn ) { \
    RETURN( TraceHR( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), _fn ) ); \
    }


//
// Other
//
#define BOOLTOSTRING( _fBool ) ( !!(_fBool) ? g_szTrue : g_szFalse )

//
// Trace/Debug Functions - these do not exist in RETAIL.
//
void
TraceMsg( 
    DWORD   dwCheckFlags,
    LPCSTR pszFormat,
    ... );

void
TraceMsg( 
    DWORD   dwCheckFlags,
    LPCWSTR pszFormat,
    ... );

void
DebugMsg( 
    LPCSTR pszFormat,
    ... );

void
DebugMsg( 
    LPCWSTR pszFormat,
    ... );

void
TraceMessage( 
    LPCTSTR pszFile, 
    const int uLine,
    LPCTSTR pszModule, 
    DWORD   dwCheckFlags,
    LPCTSTR pszFormat,
    ... );

void
TraceMessageDo( 
    LPCTSTR pszFile, 
    const int uLine, 
    LPCTSTR pszModule, 
    DWORD   dwCheckFlags,
    LPCTSTR pszFormat,
    LPCTSTR pszFunc,
    ... );


BOOL
AssertMessage( 
    LPCTSTR pszFile, 
    const int uLine, 
    LPCTSTR pszModule, 
    LPCTSTR pszfn, 
    BOOL    fTrue );

HRESULT
TraceHR( 
    LPCTSTR pszFile, 
    const int uLine, 
    LPCTSTR pszModule, 
    LPCTSTR pszfn, 
    HRESULT hr );

//
// Memory tracing functions - these are remapped to the "Global" memory 
// functions when in RETAIL.
//
HGLOBAL
DebugAlloc( 
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCTSTR pszComment );

HGLOBAL
DebugFree( 
    HGLOBAL hMem );

// The memory functions don't exist in RETAIL.
HGLOBAL
DebugMemoryAdd(
    HGLOBAL hglobal,
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCTSTR pszComment );

#define DebugMemoryAddHandle( _handle ) \
    DebugMemoryAdd( _handle, TEXT(__FILE__), __LINE__, __MODULE__, GMEM_MOVEABLE, 0, TEXT(#_handle) );

#define DebugMemoryAddAddress( _pv ) \
    DebugMemoryAdd( _pv, TEXT(__FILE__), __LINE__, __MODULE__, GMEM_FIXED, 0, TEXT(#_pv) );

#define TraceStrDup( _sz ) \
    DebugMemoryAdd( StrDup( _sz ), TEXT(__FILE__), __LINE__, __MODULE__, GMEM_FIXED, 0, TEXT("StrDup(") TEXT(#_sz) TEXT(")") );

void
DebugMemoryDelete( 
    HGLOBAL hglobal );

void
DebugMemoryCheck( );

#ifdef __cplusplus
extern void* __cdecl operator new( size_t nSize, LPCTSTR pszFile, const int iLine, LPCTSTR pszModule );
#define new new( TEXT(__FILE__), __LINE__, __MODULE__ )

#endif

//
//
#else // it's RETAIL    ******************************************************
//
//

// Debugging -> NOPs
#define Assert( _fn )           
#define DEFINE_MODULE( _module )
#define DEFINE_THISCLASS( _class )
#define DEFINE_SUPER( _super )
#define BOOLTOSTRING( _fBool )  NULL
#define AssertMsg                   1 ? (void)0 : (void) 
#define TraceMsg                    1 ? (void)0 : (void) 
#define DebugMsg                    1 ? (void)0 : (void) 
#define ErrorMsg                    1 ? (void)0 : (void) 
#define TraceMessage                1 ? (void)0 : (void) 
#define AssertMessage               1 ? (void)0 : (void) 
#define TraceHR                     1 ? (void)0 : (void) 
#define TraceFunc                   1 ? (void)0 : (void) 
#define TraceClsFunc                1 ? (void)0 : (void) 
#define TraceFuncExit()
#define DebugMemoryAddHandle( _handle )
#define DebugMemoryAddAddress( _pv )
#define INITIALIZE_TRACE_MEMORY_PROCESS
#define INITIALIZE_TRACE_MEMORY_THREAD
#define UNINITIALIZE_TRACE_MEMORY
#define DebugMemoryDelete( _h )

// Tracing -> just do operation
#define TraceDo( _fn )              _fn
#define TraceMsgDo( _fn, _msg )     _fn
#define TraceAssertIfZero( _fn )    _fn

// RETURN testing -> do retail
#define THR
#define RETURN( _fn )               return _fn
#define RRETURN( _fn )              return _fn
#define HRETURN( _hr )              return _hr
#define QIRETURN( _qi, _riid )      return _qi

// Memory Functions -> do retail
#define TraceAlloc( _flags, _size )     GlobalAlloc( _flags, _size )
#define TraceAllocString( _flags, _size ) GlobalAlloc( _flags, (_size) * sizeof(TCHAR) )
#define TraceFree( _pv )                GlobalFree( _pv )
#define TraceStrDup( _sz )              StrDup( _sz )

#endif // DBG==1

#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\directory.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: SERVERDLG.CPP


 ***************************************************************************/

#include "pch.h"
#include <remboot.h>
#include "callback.h"
#include "utils.h"

DEFINE_MODULE( "RIPREP" );

//
// VerifyDirectoryName( )
//
// Make sure that the directory name entered conforms to the
// restrictions that OSChooser has. Directory names also
// can not contain spaces.
//
// Returns: S_OK if it does
//          E_FAIL if it does not
//
HRESULT
VerifyDirectoryName(
    )
{
    HRESULT hr = S_OK;

    TraceFunc( "VerifyDirectoryName()\n" );

    LPWSTR pszDir = g_MirrorDir;

    while ( *pszDir > 32 && *pszDir <= 127 )
    {
        pszDir++;
    }

    if ( *pszDir != L'\0' )
    {
        hr = E_FAIL;
    }

    HRETURN(hr);
}

//
// CheckDirectory( )
//
// Make sure the directory doesn't exist on the server already.
// If it does, ask the user what to do next.
//
// Returns: S_OK if the directory does NOT exist or if the user
//               said it was alright to overwrite.
//          E_FAIL if the directory existed and the user said
//                 it was NOT ok to overwrite
//
HRESULT
CheckDirectory(
    HWND hDlg )
{
    TraceFunc( "CheckDirectory( ... )\n" );

    HRESULT hr = E_FAIL;
    WCHAR szPath[ MAX_PATH ];

    _snwprintf( szPath,
                ARRAYSIZE(szPath),
                L"\\\\%s\\REMINST\\Setup\\%s\\%s\\%s",
                g_ServerName,
                g_Language,
                REMOTE_INSTALL_IMAGE_DIR_W,
                g_MirrorDir );
    TERMINATE_BUFFER(szPath);

    DWORD dwAttrib = GetFileAttributes( szPath );

    if ( dwAttrib != 0xFFFFffff )
    {
        INT iResult =  MessageBoxFromStrings( hDlg,
                                              IDS_DIRECTORY_EXISTS_TITLE,
                                              IDS_DIRECTORY_EXISTS_TEXT,
                                              MB_YESNO );
        if ( iResult == IDNO )
            goto Cleanup;
    }

    hr = S_OK;

Cleanup:
    HRETURN(hr);
}

//
// DirectoryDlgCheckNextButtonActivation( )
//
VOID
DirectoryDlgCheckNextButtonActivation(
    HWND hDlg )
{
    TraceFunc( "DirectoryDlgCheckNextButtonActivation( )\n" );
    GetDlgItemText( hDlg, IDC_E_OSDIRECTORY, g_MirrorDir, ARRAYSIZE(g_MirrorDir));
    PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_BACK | (wcslen(g_MirrorDir) ? PSWIZB_NEXT : 0 ) );
    TraceFuncExit( );
}


//
// DirectoryDlgProc()
//
INT_PTR CALLBACK
DirectoryDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    switch (uMsg)
    {
    default:
        return FALSE;

    case WM_INITDIALOG:
        // Per bug 208881 - limit directory name to 67 chars
        Edit_LimitText( GetDlgItem( hDlg, IDC_E_OSDIRECTORY ), REMOTE_INSTALL_MAX_DIRECTORY_CHAR_COUNT - 1 );
        return FALSE;

    case WM_COMMAND:
        switch ( LOWORD( wParam ) )
        {
        case IDC_E_OSDIRECTORY:
            if ( HIWORD( wParam ) == EN_CHANGE )
            {
                DirectoryDlgCheckNextButtonActivation( hDlg );
            }
            break;
        }
        break;

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        LPNMHDR lpnmhdr = (LPNMHDR) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_WIZNEXT:
            GetDlgItemText( hDlg, IDC_E_OSDIRECTORY, g_MirrorDir, ARRAYSIZE(g_MirrorDir) );
            Assert( wcslen( g_MirrorDir ) );
            if ( FAILED( VerifyDirectoryName( ) ) )
            {
                MessageBoxFromStrings( hDlg, IDS_OSCHOOSER_RESTRICTION_TITLE, IDS_OSCHOOSER_RESTRICTION_TEXT, MB_OK );
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );    // don't go on
                break;
            }
            if ( FAILED( CheckDirectory( hDlg ) ) )
            {
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );    // don't go on
                break;
            }
            break;

        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            DirectoryDlgCheckNextButtonActivation( hDlg );
            ClearMessageQueue( );
            break;
        }
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\debug.cpp ===
/****************************************************************************

  Copyright (c) Microsoft Corporation 1997
  All rights reserved

  File: DEBUG.CPP

  Debugging utilities

 ***************************************************************************/

#include "pch.h"
#include <shlwapi.h>

DEFINE_MODULE("RIPREP")

#ifdef DEBUG

// Constants
#define DEBUG_OUTPUT_BUFFER_SIZE  512

// Globals
DWORD g_TraceMemoryIndex = 0;
DWORD g_dwCounter        = 0;
DWORD g_dwTraceFlags     = 0;
CRITICAL_SECTION g_DebugCS;
BOOL  g_fDebugInitialized = FALSE;

// Statics
static const TCHAR g_szNULL[]    = TEXT("");
static const TCHAR g_szTrue[]    = TEXT("True");
static const TCHAR g_szFalse[]   = TEXT("False");
static const TCHAR g_szFormat[]  = TEXT("%-50s  %-10.10s ");
static const TCHAR g_szUnknown[] = TEXT("<unknown>");

//
// Adds 'g_dwCounter' spaces to debug spew
//
void
dbgspace( void )
{
    for( DWORD dw = 1; dw < g_dwCounter; dw++ )
        OutputDebugStringA( "| " );
}

//
// Makes sure multiple threads don't trample debugging output.
//
void
dbgEnterCS( void )
{
    if ( !g_fDebugInitialized )
    {
        //
        // There is NO matching DeleteCriticalSection( ) since
        // this is only used for debugging purposes.
        //
        InitializeCriticalSection( &g_DebugCS );
        g_fDebugInitialized = TRUE;
    }

    EnterCriticalSection( &g_DebugCS );
}

void
dbgExitCS( void )
{
    LeaveCriticalSection( &g_DebugCS );
}

//
// Takes the filename and line number and put them into a string buffer.
//
// NOTE: the buffer is assumed to be of size DEBUG_OUTPUT_BUFFER_SIZE.
//
LPTSTR
dbgmakefilelinestring(
    LPTSTR  pszBuf,
    LPCTSTR pszFile,
    const int uLine )
{
    LPVOID args[2];

    args[0] = (LPVOID) pszFile;
    args[1] = IntToPtr(uLine);

    FormatMessage(
        FORMAT_MESSAGE_FROM_STRING |
            FORMAT_MESSAGE_ARGUMENT_ARRAY,
        TEXT("%1(%2!u!):"),
        0,                          // error code
        0,                          // default language
        (LPTSTR) pszBuf,            // output buffer
        DEBUG_OUTPUT_BUFFER_SIZE,   // size of buffer
        (va_list*) &args );           // arguments

    return pszBuf;
}




//
// TraceMessage()
//
void
TraceMessage(
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    DWORD   dwCheckFlags,
    LPCTSTR pszFormat,
    ... )
{
    va_list valist;

    if (( dwCheckFlags == TF_ALWAYS
       || !!( g_dwTraceFlags & dwCheckFlags ) ))
    {
        TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];

        if ( !pszModule )
        {
            pszModule = g_szUnknown;
        }

        if ( !pszFile )
        {
            wsprintf( szBuf, g_szFormat, g_szNULL, pszModule );
            TERMINATE_BUFFER(szBuf);
        }
        else
        {
            TCHAR szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

            dbgmakefilelinestring( szFileLine, pszFile, uLine );
            wsprintf( szBuf, g_szFormat, szFileLine, pszModule );
            TERMINATE_BUFFER(szBuf);
        }

        dbgEnterCS( );

        OutputDebugString( szBuf );

        dbgspace( );

        va_start( valist, pszFormat );
        wvsprintf( szBuf, pszFormat, valist );
        TERMINATE_BUFFER(szBuf);
        va_end( valist );

        OutputDebugString( szBuf );

        dbgExitCS( );
    }

}



//
// DebugMsg()
//
void
DebugMsg(
    LPCSTR pszFormat,
    ... )
{
    va_list valist;
    TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];
    TCHAR  szFormat[ DEBUG_OUTPUT_BUFFER_SIZE ];
    
    mbstowcs( szFormat, pszFormat, lstrlenA( pszFormat ) + 1 );

    va_start( valist, pszFormat );
    wvsprintf( szBuf, szFormat, valist);
    va_end( valist );

    dbgEnterCS( );

    OutputDebugString( szBuf );

    dbgExitCS( );
}


//
// Displays a dialog box with the failed assertion. User has the option of
// breaking.
//
BOOL
AssertMessage(
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    LPCTSTR pszfn,
    BOOL    fTrue )
{
    if ( !fTrue )
    {
        TCHAR szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];
        TCHAR szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

        // Make sure everything is cool before we blow up somewhere else.
        if ( pszFile == NULL )
        {
            pszFile = g_szNULL;
        }

        if ( pszModule == NULL )
        {
            pszModule = g_szNULL;
        }

        if ( pszfn == NULL )
        {
            pszfn = g_szNULL;
        }

        dbgmakefilelinestring( szFileLine, pszFile, uLine );

        wsprintf( szBuf, TEXT("%-50s  %-10s ASSERT: %s\n"),
            szFileLine, pszModule, pszfn );

        dbgEnterCS( );

        OutputDebugString( szBuf );

        dbgExitCS( );

        wsprintf( szBuf, TEXT("Module:\t%s\t\nLine:\t%u\t\nFile:\t%s\t\n\nAssertion:\t%s\t\n\nDo you want to break here?"),
            pszModule, uLine, pszFile, pszfn );
        TERMINATE_BUFFER(szBuf);

        if ( IDNO == MessageBox( NULL, szBuf, TEXT("Assertion Failed!"),
                MB_YESNO|MB_ICONWARNING ) )
            fTrue = !FALSE;   // don't break

    }

    return !fTrue;

}

//
// Traces HRESULT errors. A dialog will appear is there is an error
// in the hr.
//
HRESULT
TraceHR(
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    LPCTSTR pszfn,
    HRESULT hr )
{
    if ( hr )
    {
        TCHAR  szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];
        TCHAR  szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];
        LPTSTR pszMsgBuf;

        switch ( hr )
        {
        case S_FALSE:
            pszMsgBuf = TEXT("S_FALSE\n");
            break;

        default:
            FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER
                | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                hr,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                (LPTSTR)&pszMsgBuf,
                0,
                NULL
            );
        }

        // Make sure everything is cool before we blow up somewhere else.
        if ( pszMsgBuf == NULL )
        {
            pszMsgBuf = TEXT("<unknown error code returned>\n");
        }
        Assert( pszFile != NULL );
        Assert( pszModule != NULL );
        Assert( pszfn != NULL );

        dbgmakefilelinestring( szFileLine, pszFile, uLine );

        _snwprintf( szBuf, ARRAYSIZE(szBuf), TEXT("%-50s  %-10s HRESULT: hr = 0x%08x - %s"),
            szFileLine, pszModule, hr, pszMsgBuf );
        TERMINATE_BUFFER(szBuf);
        
        dbgEnterCS( );

        OutputDebugString( szBuf );

        dbgExitCS( );

        _snwprintf( szBuf, ARRAYSIZE(szBuf), TEXT("Module:\t%s\t\nLine:\t%u\t\nFile:\t%s\t\n\nFunction:\t%s\t\nhr =\t0x%08x - %s\t\nDo you want to break here?"),
            pszModule, uLine, pszFile, pszfn, hr, pszMsgBuf );
        TERMINATE_BUFFER(szBuf);
        
        if ( IDYES == MessageBox( NULL, szBuf, TEXT("Trace HRESULT"),
                MB_YESNO|MB_ICONWARNING ) )
            DEBUG_BREAK;

        if ( hr != S_OK && hr != S_FALSE )
        {
            LocalFree( pszMsgBuf );
        }
    }

    return hr;

}


//
// Memory allocation and tracking
//

typedef struct _MEMORYBLOCK {
    HGLOBAL hglobal;
    DWORD   dwBytes;
    UINT    uFlags;
    LPCTSTR pszFile;
    int     uLine;
    LPCTSTR pszModule;
    LPCTSTR pszComment;
    _MEMORYBLOCK *pNext;
} MEMORYBLOCK, *LPMEMORYBLOCK;

//
// Adds a MEMORYBLOCK to the memory tracking list.
//
HGLOBAL
DebugMemoryAdd(
    HGLOBAL hglobal,
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCTSTR pszComment )
{
    if ( hglobal )
    {
        LPMEMORYBLOCK pmbHead = (LPMEMORYBLOCK) TlsGetValue( g_TraceMemoryIndex );
        LPMEMORYBLOCK pmb     = (LPMEMORYBLOCK) GlobalAlloc(
                                                    GMEM_FIXED,
                                                    sizeof(MEMORYBLOCK) );

        if ( !pmb )
        {
            GlobalFree( hglobal );
            return NULL;
        }

        pmb->hglobal    = hglobal;
        pmb->dwBytes    = dwBytes;
        pmb->uFlags     = uFlags;
        pmb->pszFile    = pszFile;
        pmb->uLine      = uLine;
        pmb->pszModule  = pszModule;
        pmb->pszComment = pszComment;
        pmb->pNext      = pmbHead;

        TlsSetValue( g_TraceMemoryIndex, pmb );
        TraceMessage( pmb->pszFile,
                      pmb->uLine,
                      pmb->pszModule,
                      TF_MEMORYALLOCS,
                      L"Alloced %s - %u bytes at 0x%08x (pmb=0x%08x)\n",
                      pszComment,
                      dwBytes,
                      pmb->hglobal,
                      pmb );
    }

    return hglobal;
}

//
// Removes a MEMORYBLOCK to the memory tracking list.
//
void
DebugMemoryDelete(
    HGLOBAL hglobal )
{
    if ( hglobal )
    {
        LPMEMORYBLOCK pmbHead = (LPMEMORYBLOCK) TlsGetValue( g_TraceMemoryIndex );
        LPMEMORYBLOCK pmbLast = NULL;

        while ( pmbHead && pmbHead->hglobal != hglobal )
        {
            pmbLast = pmbHead;
            pmbHead = pmbLast->pNext;
        }

        if ( pmbHead )
        {
            if ( pmbLast )
            {
                pmbLast->pNext = pmbHead->pNext;
            }
            else
            {
                TlsSetValue( g_TraceMemoryIndex, pmbHead->pNext );
            }

            TraceMessage( pmbHead->pszFile,
                          pmbHead->uLine,
                          pmbHead->pszModule,
                          TF_MEMORYALLOCS,
                          L"Freeing %s - %u bytes from 0x%08x (pmb=0x%08x)\n",
                          pmbHead->pszComment,
                          pmbHead->dwBytes,
                          pmbHead->hglobal,
                          pmbHead );
            memset( pmbHead->hglobal, 0xFA, pmbHead->dwBytes );
            memset( pmbHead, 0xFE, sizeof(*pmbHead) );
            GlobalFree( pmbHead );
        }
    }
}

//
// Allocates memory and adds the MEMORYBLOCK to the memory tracking list.
//
HGLOBAL
DebugAlloc(
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCTSTR pszComment )
{
    HGLOBAL       hglobal = GlobalAlloc( uFlags, dwBytes );

    return DebugMemoryAdd( hglobal, pszFile, uLine, pszModule, uFlags, dwBytes, pszComment );
}

//
// Remove the MEMORYBLOCK to the memory tracking list, memsets the
// memory to 0xFE and then frees the memory.
//
HGLOBAL
DebugFree(
    HGLOBAL hglobal )
{
    DebugMemoryDelete( hglobal );

    return GlobalFree( hglobal );
}

//
// Checks the memory tracking list. If it is not empty, it will dump the
// list and break.
//
void
DebugMemoryCheck( )
{
    BOOL          fFoundLeak = FALSE;
    LPMEMORYBLOCK pmb = (LPMEMORYBLOCK) TlsGetValue( g_TraceMemoryIndex );

    dbgEnterCS( );

    while ( pmb )
    {
        LPVOID args[ 5 ];
        TCHAR  szOutput[ DEBUG_OUTPUT_BUFFER_SIZE ];
        TCHAR  szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

        if ( fFoundLeak == FALSE )
        {
            DebugMsg("\n******** Memory leak detected ******** ThreadID = 0x%08x ******** \n\n", GetCurrentThreadId( ) );
               //OutputDebugString("12345678901234567890123456789012345678901234567890  1234567890 X 0x12345678  12345  1...");
            OutputDebugString(TEXT("Filename(Line Number):                              Module     Addr/HGLOBAL  Size   String\n"));
            fFoundLeak = TRUE;
        }

        dbgmakefilelinestring( szFileLine, pmb->pszFile, pmb->uLine );

        args[0] = (LPVOID) pmb->hglobal;
        args[1] = (LPVOID) &szFileLine;
        args[2] = (LPVOID) pmb->pszComment;
        args[3] = UlongToPtr(pmb->dwBytes);
        args[4] = (LPVOID) pmb->pszModule;

        if ( !!(pmb->uFlags & GMEM_MOVEABLE) )
        {
            FormatMessage(
                FORMAT_MESSAGE_FROM_STRING |
                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                TEXT("%2!-50s!  %5!-10s! H 0x%1!08x!  %4!-5u!  \"%3\"\n"),
                0,                          // error code
                0,                          // default language
                (LPTSTR) &szOutput,         // output buffer
                ARRAYSIZE( szOutput ),   // size of buffer
                (va_list*) &args );           // arguments
        }
        else
        {
            FormatMessage(
                FORMAT_MESSAGE_FROM_STRING |
                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                TEXT("%2!-50s!  %5!-10s! A 0x%1!08x!  %4!-5u!  \"%3\"\n"),
                0,                          // error code
                0,                          // default language
                (LPTSTR) &szOutput,         // output buffer
                ARRAYSIZE( szOutput ),   // size of buffer
                (va_list*) &args );           // arguments
        }

        OutputDebugString( szOutput );

        pmb = pmb->pNext;
    }

    if ( fFoundLeak == TRUE )
    {
        OutputDebugString(TEXT("\n***************************** Memory leak detected *****************************\n\n"));
    }

    dbgExitCS( );

    Assert( !fFoundLeak );

}

//
// Global Management Functions -
//
// These are in debug and retail but internally they change
// depending on the build.
//

#undef new
void* __cdecl operator new( size_t nSize, LPCTSTR pszFile, const int iLine, LPCTSTR pszModule )
{
    return DebugAlloc( pszFile, iLine, pszModule, GPTR, nSize, TEXT("new()") );
}

void * __cdecl operator new(size_t t_size )
{
    AssertMsg( 0, "Macro failure" );
    return NULL;
}

void __cdecl operator delete(void *pv)
{
    TraceFree( pv );
}

int __cdecl _purecall(void)
{
    return 0;
}

#else // ! DEBUG -- It's retail

//
// Global Management Functions -
//
// These are in debug and retail but are internally they change
// depending on the build.
//

void * __cdecl operator new(size_t t_size )
{
    return LocalAlloc( GPTR, t_size );
}

void __cdecl operator delete(void *pv)
{
    LocalFree( pv );
}

int __cdecl _purecall(void)
{
    return 0;
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\directory.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: SERVERDLG.H


 ***************************************************************************/

#ifndef _DIRECTORY_H_
#define _DIRECTORY_H_

INT_PTR CALLBACK
DirectoryDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );


#endif // _DIRECTORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\errorlog.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: ERRORLOG.H


 ***************************************************************************/

#ifndef _ERRORLOG_H_
#define _ERRORLOG_H_


INT_PTR CALLBACK
ErrorsDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );


#endif // _ERRORLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\errorlog.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: ERRORLOG.CPP


 ***************************************************************************/

#include "pch.h"
#include "utils.h"
#include "logging.h"
#include <richedit.h>

DEFINE_MODULE("RIPREP");

//
// EditStreamCallback( )
//
// Callback routine used by the rich edit control to read in the log file.
//
// Returns: 0 - to continue.
//          Otherwize, Win32 error code.
//
DWORD CALLBACK
EditStreamCallback (
    HANDLE   hLogFile,
    LPBYTE   Buffer,
    LONG     cb,
    PULONG   pcb
    )
{
    DWORD error;

    UNREFERENCED_PARAMETER(hLogFile);
    
    TraceFunc( "EditStreamCallback( )\n" );

    if ( !ReadFile ( g_hLogFile, Buffer, cb, pcb, NULL ) ) {
        error = GetLastError( );
        DebugMsg( "Error - EditStreamCallback: GetLastError() => 0x%08x \n", error );
        RETURN(error);
    }

    RETURN(0);
}
//
// ErrorsDlgProc()
//
INT_PTR CALLBACK
ErrorsDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
        
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
    
    switch (uMsg)
    {
    default:
        return FALSE;
        
    case WM_INITDIALOG:
        {
            HRESULT     hr;
            HWND        hWndRichEdit = GetDlgItem( hDlg, IDC_E_ERRORS );
            EDITSTREAM  eStream;        // structure used by EM_STREAMIN message

            Assert( hWndRichEdit );
            ZeroMemory( &eStream, sizeof(eStream) );

            hr = THR( LogOpen( ) );
            if ( FAILED( hr ) )
            {
                HWND hParent = GetParent( hDlg );
                DestroyWindow( hDlg );
                SetFocus( hParent );
                return FALSE;
            }

            // move to the beginning of the newest log
            SetFilePointer( g_hLogFile, g_dwLogFileStartLow, (LONG*)&g_dwLogFileStartHigh, FILE_BEGIN );

            eStream.pfnCallback = (EDITSTREAMCALLBACK) EditStreamCallback;
            SendMessage ( hWndRichEdit, EM_STREAMIN, SF_TEXT, (LPARAM) &eStream );
            SendMessage ( hWndRichEdit, EM_SETMODIFY, TRUE, 0 );

            CloseHandle( g_hLogFile );
            g_hLogFile = INVALID_HANDLE_VALUE;
            LogClose( );

            CenterDialog( hDlg );

            PostMessage( hDlg, WM_USER, 0, 0 );
        }
        break;

    case WM_COMMAND:
        switch ( wParam ) 
        {
        case IDCANCEL:
            EndDialog ( hDlg, 0 );
            break;

        default:
            return FALSE;
        }

    case WM_USER:
        {
            HWND        hWndRichEdit = GetDlgItem( hDlg, IDC_E_ERRORS );
            // These have to be delayed or the Edit control will
            // highlight all the text.
            SendMessage(hWndRichEdit,EM_SETSEL,0,0);
            SendMessage(hWndRichEdit,EM_SCROLLCARET,0,0);
        }
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\logging.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

 ***************************************************************************/

#include "pch.h"
DEFINE_MODULE("RIPREP")
#define LOG_OUTPUT_BUFFER_SIZE 256

//
// CreateDirectoryPath( )
//
// Creates the directory tree.
//
HRESULT
CreateDirectoryPath(
    LPWSTR DirectoryPath )
{
    PWCHAR p;
    BOOL f;
    DWORD attributes;
    HRESULT hr = S_OK;

    //
    // Find the \ that indicates the root directory. There should be at least
    // one \, but if there isn't, we just fall through.
    //

    // skip \\server\reminst\ part
    p = wcschr( DirectoryPath, L'\\' );
    Assert(p);
    p = wcschr( p + 1, L'\\' );
    Assert(p);
    p = wcschr( p + 1, L'\\' );
    Assert(p);
    p = wcschr( p + 1, L'\\' );
    Assert(p);
    p = wcschr( p + 1, L'\\' );
    if ( p != NULL ) {

        //
        // Find the \ that indicates the end of the first level directory. It's
        // probable that there won't be another \, in which case we just fall
        // through to creating the entire path.
        //

        p = wcschr( p + 1, L'\\' );
        while ( p != NULL ) {

            //
            // Terminate the directory path at the current level.
            //

            *p = 0;

            //
            // Create a directory at the current level.
            //

            attributes = GetFileAttributes( DirectoryPath );
            if ( 0xFFFFffff == attributes ) {
                DebugMsg( "Creating %s\n", DirectoryPath );
                f = CreateDirectory( DirectoryPath, NULL );
                if ( !f ) {
                    hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
                    goto Error;
                }
            } else if ( (attributes & FILE_ATTRIBUTE_DIRECTORY) == 0 ) {
                hr = THR(E_FAIL);
                goto Error;
            }

            //
            // Restore the \ and find the next one.
            //

            *p = L'\\';
            p = wcschr( p + 1, L'\\' );
        }
    }

    //
    // Create the target directory.
    //

    attributes = GetFileAttributes( DirectoryPath );
    if ( 0xFFFFffff == attributes ) {
        f = CreateDirectory( DirectoryPath, NULL );
        if ( !f ) {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        }
    }

Error:
    return hr;
}

//
// LogOpen( )
//
// This function:
//  - initializes the log critical section
//  - enters the log critical section assuring only one thread is
//    writing to the log at a time
//  - creates the directory tree to the log file (if needed)
//  - initializes the log file by:
//     - creating a new log file if one doesn't exist.
//     - opens an existing log file (for append)
//     - appends a time/date stamp that the log was (re)openned.
//
// Use LogClose() to exit the log critical section.
//
// If there is a failure inside this function, the log critical
// section will be released before returning.
//
// Returns: S_OK - log critical section held and log open successfully
//          Otherwize HRESULT error code.
//
HRESULT
LogOpen( )
{
    TCHAR   szFilePath[ MAX_PATH ];
    CHAR    szBuffer[ LOG_OUTPUT_BUFFER_SIZE ];
    DWORD   dwWritten;
    HRESULT hr;
    SYSTEMTIME SystemTime;
    BOOL    CloseLog = FALSE;

    if ( !g_pLogCritSect ) {
        PCRITICAL_SECTION pNewCritSect =
            (PCRITICAL_SECTION) LocalAlloc( LPTR, sizeof(CRITICAL_SECTION) );
        if ( !pNewCritSect ) {
            DebugMsg( "Out of Memory. Logging disabled.\n " );
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        InitializeCriticalSection( pNewCritSect );

        // Make sure we only have one log critical section
        InterlockedCompareExchangePointer( (PVOID *)&g_pLogCritSect, pNewCritSect, 0 );
        if ( g_pLogCritSect != pNewCritSect ) {
            DebugMsg( "Another thread already created the CS. Deleting this one.\n ");
            DeleteCriticalSection( pNewCritSect );
            LocalFree( pNewCritSect );
        }
    }

    Assert( g_pLogCritSect );
    EnterCriticalSection( g_pLogCritSect );

    // Make sure the log file is open
    if ( g_hLogFile == INVALID_HANDLE_VALUE ) {

        if (!*g_ServerName) {
            wsprintf( 
                szFilePath, 
                L"%s\\%s", 
                g_WinntDirectory, 
                L"riprep.log");
            CloseLog = TRUE;
        } else {
        
            // Place
            wsprintf( szFilePath,
                      TEXT("\\\\%s\\REMINST\\Setup\\%s\\%s\\%s\\%s"),
                      g_ServerName,
                      g_Language,
                      REMOTE_INSTALL_IMAGE_DIR_W,
                      g_MirrorDir,
                      g_Architecture );
    
            // Create the directory tree
            DebugMsg( "Creating log at %s\n", szFilePath );
            hr = CreateDirectoryPath( szFilePath );
            if (FAILED( hr )) goto Error;
    
            wcscat( szFilePath, L"\\riprep.log" );

        }

        g_hLogFile = CreateFile( szFilePath,
                                 GENERIC_WRITE | GENERIC_READ,
                                 FILE_SHARE_READ,
                                 NULL,
                                 OPEN_ALWAYS,
                                 NULL,
                                 NULL );
        if ( g_hLogFile == INVALID_HANDLE_VALUE ) {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            goto Error;
        }

        // Seek to the end
        SetFilePointer( g_hLogFile, 0, NULL, FILE_END );
        g_dwLogFileStartLow = GetFileSize( g_hLogFile, &g_dwLogFileStartHigh );

        // Write the time/date the log was (re)openned.
        GetLocalTime( &SystemTime );
        wsprintfA( szBuffer,
                   "*\r\n* %02u/%02u/%04u %02u:%02u:%02u\r\n*\r\n",
                   SystemTime.wMonth,
                   SystemTime.wDay,
                   SystemTime.wYear,
                   SystemTime.wHour,
                   SystemTime.wMinute,
                   SystemTime.wSecond );

        if ( !WriteFile( g_hLogFile, szBuffer, lstrlenA(szBuffer), &dwWritten, NULL ) ) {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            goto Error;
        }
    }

    hr = S_OK;

Cleanup:
    if (CloseLog) {
        CloseHandle( g_hLogFile );
        g_hLogFile = INVALID_HANDLE_VALUE;
    }
    return hr;
Error:
    DebugMsg( "LogOpen: Failed hr = 0x%08x\n", hr );
    if ( g_hLogFile != INVALID_HANDLE_VALUE ) {
        CloseHandle( g_hLogFile );
        g_hLogFile = INVALID_HANDLE_VALUE;
    }
    LeaveCriticalSection( g_pLogCritSect );
    goto Cleanup;
}

//
// LogClose( )
//
// This actually just leaves the log critical section.
//
HRESULT
LogClose( )
{
    Assert( g_pLogCritSect );
    LeaveCriticalSection( g_pLogCritSect );
    return S_OK;
}


//
// LogMsg()
//
void
LogMsg(
    LPCWSTR pszFormat,
    ... )
{
    va_list valist;
    CHAR   szBuf[ LOG_OUTPUT_BUFFER_SIZE ];
    DWORD  dwWritten;

    WCHAR  szTmpBuf[ LOG_OUTPUT_BUFFER_SIZE ];

    va_start( valist, pszFormat );
    wvsprintf( szTmpBuf, pszFormat, valist);
    va_end( valist );

    wcstombs( szBuf, szTmpBuf, wcslen( szTmpBuf ) + 1 );

    if ( FAILED(LogOpen( ) )) {
        return;
    }

    WriteFile( g_hLogFile, szBuf, lstrlenA(szBuf), &dwWritten, NULL );

    LogClose( );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\logging.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

 ***************************************************************************/

#ifndef _LOGGING_H_
#define _LOGGING_H_

HRESULT
LogOpen( );

HRESULT
LogClose( );

void
LogMsg( 
    LPCWSTR pszFormat,
    ... );

#endif // _LOGGING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\pch.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: PCH.H

  Precompiled header file.
 
 ***************************************************************************/

#if DBG == 1
#define DEBUG
#endif

#pragma warning(disable:4127)   // condition expression is constant
#pragma warning(disable:4706)   // assignment within conditional

#define SECURITY_WIN32
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windowsx.h>
#include <commdlg.h>
#include <shlwapi.h>
#include <lm.h>
#include <remboot.h>
#include <setupapi.h>
#include <stdio.h>
extern "C" {
#include "..\imirror\imirror.h"
}

#include "debug.h"
#include "resource.h"
#include "msg.h"

// Globals
extern HINSTANCE g_hinstance;
extern HWND g_hCurrentWindow;
extern WCHAR g_ServerName[ MAX_PATH ];
extern WCHAR g_MirrorDir[ MAX_PATH ];
extern WCHAR g_Language[ MAX_PATH ];
extern WCHAR g_ImageName[ MAX_PATH ];
extern WCHAR g_Architecture[ 16 ];
extern WCHAR g_Description[ REMOTE_INSTALL_MAX_DESCRIPTION_CHAR_COUNT ];
extern WCHAR g_HelpText[ REMOTE_INSTALL_MAX_HELPTEXT_CHAR_COUNT ];
extern WCHAR g_SystemRoot[ MAX_PATH ];
extern WCHAR g_WinntDirectory[ MAX_PATH ];
extern DWORD g_dwWinntDirLength;
extern BOOLEAN g_fQuietFlag;
extern BOOLEAN g_fErrorOccurred;
extern BOOLEAN g_fRebootOnExit;
extern DWORD g_dwLogFileStartLow;
extern DWORD g_dwLogFileStartHigh;
extern PCRITICAL_SECTION g_pLogCritSect;
extern HANDLE g_hLogFile;
extern OSVERSIONINFO OsVersion;
extern HINF g_hCompatibilityInf;
extern WCHAR g_HalName[32];
extern WCHAR g_ProductId[4];
extern BOOLEAN g_OEMDesktop;

//
// Inc/decrements macros.
//
#define InterlockDecrement( _var ) --_var;
#define InterlockIncrement( _var ) ++_var;

// Array Macros
#define ARRAYSIZE( _x ) ((UINT) (sizeof(_x) / sizeof(_x[0])))
#define TERMINATE_BUFFER( _x ) ASSERT(sizeof(_x) > 4); _x[ARRAYSIZE(_x)-1] = 0;

// Private Messages
#define WM_ERROR            WM_USER
#define WM_UPDATE           WM_USER + 1
#define WM_CONTINUE         WM_USER + 2
#define WM_ERROR_OK         WM_USER + 3

//
// Made-up DirID for the UserProfiles directory.
//
// If you change this value, you *must* also change
// the corresponding value in riprep.inf
//
#define PROFILES_DIRID      (0x8001)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\main.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

 ***************************************************************************/

#include "pch.h"
#include "utils.h"
#include "callback.h"
#include "welcome.h"
#include "compat.h"
#include "serverdlg.h"
#include "directory.h"
#include "sif.h"
#include "complete.h"
#include "summary.h"
#include "tasks.h"
#include "setupdlg.h"
#include "appldlg.h"
#include "setup.h"
#include "errorlog.h"

// Must have this...
extern "C" {
#include <sysprep_.h>
#include <spapip.h>
//
// SYSPREP globals
//
BOOL    NoSidGen = FALSE;   // always generate new SID
BOOL    PnP      = FALSE;   // always PNP the system
BOOL    FactoryPreinstall = FALSE;  // NOT a Factory Pre-Install case
BOOL    bMiniSetup = TRUE;    // Run Mini-Setup, not MSOOBE
HINSTANCE ghInstance = NULL;     // Global instance handle
}

DEFINE_MODULE("RIPREP");

// Globals
HINSTANCE g_hinstance = NULL;
WCHAR g_ServerName[ MAX_PATH ];
WCHAR g_MirrorDir[ MAX_PATH ];
WCHAR g_Language[ MAX_PATH ];
WCHAR g_ImageName[ MAX_PATH ];
WCHAR g_Architecture[ 16 ];
WCHAR g_Description[ REMOTE_INSTALL_MAX_DESCRIPTION_CHAR_COUNT  ];
WCHAR g_HelpText[ REMOTE_INSTALL_MAX_HELPTEXT_CHAR_COUNT ];
WCHAR g_SystemRoot[ MAX_PATH ] = L"Mirror1\\userdata\\winnt";
WCHAR g_WinntDirectory[ MAX_PATH ];
WCHAR g_HalName[32];
WCHAR g_ProductId[4];
DWORD g_dwWinntDirLength;
BOOLEAN g_fQuietFlag = FALSE;
BOOLEAN g_fErrorOccurred = FALSE;
BOOLEAN g_fRebootOnExit = FALSE;
DWORD g_dwLogFileStartLow;
DWORD g_dwLogFileStartHigh;
PCRITICAL_SECTION g_pLogCritSect = NULL;
HANDLE g_hLogFile = INVALID_HANDLE_VALUE;
OSVERSIONINFO OsVersion;
BOOLEAN g_CommandLineArgsValid = TRUE;
BOOLEAN g_OEMDesktop = FALSE;


// Constants
#define NUMBER_OF_PAGES     15
#define SMALL_BUFFER_SIZE   256
#define OPTION_UNKNOWN      0
#define OPTION_DEBUG        1
#define OPTION_FUNC         2
#define OPTION_QUIET        3
#define OPTION_PNP          4
#define OPTION_OEMDESKTOP   5

//
// Adds a page to the dialog.
//
void
AddPage(
    LPPROPSHEETHEADER ppsh,
    UINT id,
    DLGPROC pfn,
    UINT idTitle,
    UINT idSubtitle )
{
    PROPSHEETPAGE psp;
    TCHAR szTitle[ SMALL_BUFFER_SIZE ];
    TCHAR szSubTitle[ SMALL_BUFFER_SIZE ];

    ZeroMemory( &psp, sizeof(psp) );
    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_DEFAULT | PSP_USETITLE;
    if ( id == IDD_WELCOME || id == IDD_COMPLETE )
    {
        psp.dwFlags |= PSP_HIDEHEADER;
    }
    else
    {
        psp.dwFlags |= PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

        if ( idTitle )
        {
            DWORD dw;

            dw = LoadString( g_hinstance, idTitle, szTitle, ARRAYSIZE(szTitle) );
            Assert( dw );
            psp.pszHeaderTitle = szTitle;
        }
        else
        {
            psp.pszHeaderTitle = NULL;
        }

        if ( idSubtitle )
        {
            DWORD dw;

            dw = LoadString( g_hinstance, idSubtitle , szSubTitle, ARRAYSIZE(szSubTitle) );
            Assert( dw );
            psp.pszHeaderSubTitle = szSubTitle;
        }
        else
        {
            psp.pszHeaderSubTitle = NULL;
        }
    }
    psp.pszTitle    = MAKEINTRESOURCE( IDS_APPNAME );
    psp.hInstance   = ppsh->hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(id);
    psp.pfnDlgProc  = pfn;

    ppsh->phpage[ ppsh->nPages ] = CreatePropertySheetPage( &psp );
    if ( ppsh->phpage[ ppsh->nPages ] )
        ppsh->nPages++;
}

//
// Creates the UI pages and kicks off the property sheet.
//
HRESULT
WizardPages( )
{
    TraceFunc( "WizardPages( )\n" );

    HRESULT         hr;
    HPROPSHEETPAGE  rPages[ NUMBER_OF_PAGES ];
    PROPSHEETHEADER pshead;
    INT_PTR iResult;

    ZeroMemory( &pshead, sizeof(pshead) );
    pshead.dwSize       = sizeof(pshead);
    pshead.dwFlags      = PSH_WIZARD97 | PSH_PROPTITLE | PSH_USEHICON
                        | PSH_WATERMARK | PSH_HEADER;
    pshead.hInstance    = g_hinstance;
    pshead.pszCaption   