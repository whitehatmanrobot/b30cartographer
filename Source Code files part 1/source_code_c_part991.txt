emUnboundObjectSink** ppSink )
{
    HRESULT hr;

    *ppSink = NULL;

    CWbemPtr<CFwdConsSink> pSink = new CFwdConsSink( pCtl );

    if ( pSink == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    hr = pSink->Initialize( pNspc, pCons );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pSink->QueryInterface( IID_IWbemUnboundObjectSink, (void**)ppSink );

    assert( SUCCEEDED(hr) );

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\forwarding\fconsend.cpp ===
#include "precomp.h"
#include <wbemutil.h>
#include <arrtempl.h>
#include <wmimsg.h>
#include <ntdsapi.h>
#include "fconsend.h"

// flags below 0x10000 are reserved for msg implementations.

#define FWD_FLAG_NO_INDIRECT 0x00010000

// {DDE18466-D244-4a5b-B91F-93D17E13178D}
static const GUID g_guidQueueType = 
{0xdde18466, 0xd244, 0x4a5b, {0xb9, 0x1f, 0x93, 0xd1, 0x7e, 0x13, 0x17, 0x8d}};

HRESULT IsTcpIpAddress( LPCWSTR wszTarget )
{
    HRESULT hr;
    WSADATA wsaData; 
    WORD wVersionRequested;
    wVersionRequested = MAKEWORD( 2, 2 );
 
    int err = WSAStartup( wVersionRequested, &wsaData );

    if ( err == 0 ) 
    {
        IN_ADDR ia;

        //
        // convert unicode addr to ansi .. 
        // 

        int cTarget = wcstombs( NULL, wszTarget, 0 );
        LPSTR szTarget = new char[cTarget+1];

        if ( szTarget != NULL )
        {
            wcstombs( szTarget, wszTarget, cTarget+1 );
            ULONG in_ad = inet_addr( szTarget );   
            hr = in_ad == INADDR_NONE ? WBEM_S_FALSE : WBEM_S_NO_ERROR;
            delete [] szTarget;
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }

        WSACleanup();                
    }
    else
    {
        hr = WMIMSG_E_REQSVCNOTAVAIL;
    }

    return hr;
}

HRESULT GetDnsName( LPCWSTR wszTarget, LPWSTR* pwszDnsName )
{
    HRESULT hr;
    *pwszDnsName = NULL;

    //
    // first make sure winsock is initialized.
    //

    WSADATA wsaData; 
    WORD wVersionRequested;
    wVersionRequested = MAKEWORD( 2, 2 );
 
    int err = WSAStartup( wVersionRequested, &wsaData );

    if ( err == 0 ) 
    {
        IN_ADDR ia;
        HOSTENT* pHost;

        //
        // convert unicode addr to ansi .. 
        // 

        int cTarget = wcstombs( NULL, wszTarget, 0 );
        LPSTR szTarget = new char[cTarget+1];

        if ( szTarget != NULL )
        {
            wcstombs( szTarget, wszTarget, cTarget+1 );

            //
            // see if its an ip address ...
            //
            
            ULONG in_ad = inet_addr( szTarget );
            
            if ( in_ad == INADDR_NONE )
            {
                pHost = gethostbyname( szTarget );
            }
            else
            {
                pHost = gethostbyaddr( (char*)&in_ad, 4, PF_INET );
            }
            
            if ( pHost != NULL )
            {
                int cDnsTarget = MultiByteToWideChar( CP_ACP,
                                                      0,
                                                      pHost->h_name,
                                                      -1,
                                                      NULL,
                                                      0 );
            
                *pwszDnsName = new WCHAR[cDnsTarget+1];

                if ( *pwszDnsName != NULL )
                {
                    MultiByteToWideChar( CP_ACP,
                                         0,
                                         pHost->h_name,
                                         -1,
                                         *pwszDnsName,
                                         cDnsTarget+1 );

                    hr = WBEM_S_NO_ERROR;
                }
                else
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }
            }
            else
            {
                hr = WMIMSG_E_INVALIDADDRESS;
            }

            delete [] szTarget;
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }

        WSACleanup();
    }
    else
    {
        hr = WMIMSG_E_REQSVCNOTAVAIL;
    }

    return hr;
}

HRESULT GetSpn( LPCWSTR wszTarget, LPWSTR* wszSpn )
{
    HRESULT hr;
    *wszSpn = NULL;

    LPWSTR wszDnsTarget = NULL;

    //
    // Since we must use the dns name of the target machine for the 
    // principal, we must resolve the target addr.    
    //

    hr = GetDnsName( wszTarget, &wszDnsTarget );

    if ( FAILED(hr) )
    {
        return hr;
    }

    CVectorDeleteMe<WCHAR> vdm( &wszDnsTarget );
                                          
    DWORD cSpn = 0;
    
    DWORD dwRes = DsMakeSpn( L"Wmi", wszDnsTarget, NULL, 0, NULL, &cSpn, NULL);

    if ( dwRes == ERROR_MORE_DATA || dwRes == ERROR_BUFFER_OVERFLOW )
    {
        *wszSpn = new WCHAR[cSpn];
        
        if ( *wszSpn != NULL )
        {
            dwRes = DsMakeSpn( L"Wmi", 
                               wszDnsTarget, 
                               NULL, 
                               0, 
                               NULL, 
                               &cSpn, 
                               *wszSpn );

            if ( dwRes == ERROR_SUCCESS )
            {
                hr = WBEM_S_NO_ERROR;
            }
            else
            {
                delete [] *wszSpn;
                *wszSpn = NULL;
                hr = HRESULT_FROM_WIN32( dwRes );
            }
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32( dwRes );
    }

    return hr;
}

/********************************************************************
  CFwdConsSend
*********************************************************************/

HRESULT CFwdConsSend::AddMSMQSender( LPCWSTR wszName )
{
    HRESULT hr;

    //
    // need to construct the Ack address for this sender.
    //

    TCHAR atchComputer[MAX_COMPUTERNAME_LENGTH+1];
    DWORD cComputer = MAX_COMPUTERNAME_LENGTH+1; 
    GetComputerName( atchComputer, &cComputer );
    WCHAR awchComputer[MAX_COMPUTERNAME_LENGTH+1];
    cComputer = MAX_COMPUTERNAME_LENGTH+1;
    
    tsz2wsz( atchComputer, awchComputer, &cComputer );
    
    WString wsAckQueueName = L"DIRECT=OS:";
    wsAckQueueName += awchComputer;
    wsAckQueueName += L"\\private$\\WMIFwdAck";

    //
    // create the sender object and add it to the multisender.
    //

    CWbemPtr<IWmiMessageSender> pSender;

    hr = CoCreateInstance( CLSID_WmiMessageMsmqSender,
                          NULL,
                          CLSCTX_INPROC,
                          IID_IWmiMessageSender,
                          (void**)&pSender );
    if ( FAILED(hr) )
    {
        return hr;
    }

    CWbemPtr<IWmiMessageSendReceive> pSend;

    DWORD dwFlags = m_dwFlags | 
    WMIMSG_FLAG_SNDR_LAZY_INIT | 
    WMIMSG_FLAG_SNDR_PRIV_SIGN | 
    WMIMSG_FLAG_SNDR_NACK_ONLY;

    hr = pSender->Open( wszName,
                        dwFlags,
                        NULL,
                        wsAckQueueName,
                        m_pTraceSink,
                        &pSend );

    if ( FAILED(hr) )
    {
        return hr;
    }

    return m_pMultiSend->Add( WMIMSG_FLAG_MULTISEND_TERMINATING_SENDER, pSend);
}

HRESULT CFwdConsSend::AddAsyncSender( LPCWSTR wszMachine )
{
    HRESULT hr;

    //
    // derive the msmq address from the target and add the sender.
    //

    WString wsQueueName;

    if ( (m_dwFlags & WMIMSG_FLAG_SNDR_ENCRYPT) == 0 )
    {
        //
        // we can use a direct format name to identify the target.  This is 
        // the most flexible type of address besides a private format name, 
        // but those cannot be derived.  ( public pathnames can only be used 
        // when online )
        // 

        wsQueueName = L"DIRECT=";

        hr = IsTcpIpAddress( wszMachine );

        if ( FAILED(hr) )
        {
            return hr;
        }

        if ( hr == WBEM_S_NO_ERROR )
        {
            wsQueueName += L"TCP:";
        }
        else
        {
            wsQueueName += L"OS:";
        }

        wsQueueName += wszMachine;
        wsQueueName += L"\\private$\\";
    }
    else
    {
        //
        // we must use a public queue pathname to reference the queue.  this is
        // because msmq will not accept direct format names for encryption.
        // encryption is supported by msmq only when the sender has access to
        // ds.  This means when this machine is offline, we cannot encrypt 
        // messages.
        // 
        wsQueueName = L"wszMachine\\";
    }

    DWORD dwQos = m_dwFlags & WMIMSG_MASK_QOS;

    _DBG_ASSERT( dwQos != WMIMSG_FLAG_QOS_SYNCHRONOUS );

    if( dwQos == WMIMSG_FLAG_QOS_EXPRESS )
    {
        wsQueueName += L"WMIFwdExpress";
    }
    else if( dwQos == WMIMSG_FLAG_QOS_GUARANTEED )
    {
        wsQueueName += L"WMIFwdGuaranteed";
    }
    else if ( dwQos == WMIMSG_FLAG_QOS_XACT )
    {
        wsQueueName += L"WMIFwdXact";
    }

    if ( m_dwFlags & WMIMSG_FLAG_SNDR_ENCRYPT )
    {
        wsQueueName += L"Encrypt";
    }
    else if ( m_dwFlags & WMIMSG_FLAG_SNDR_AUTHENTICATE )
    {
        wsQueueName += L"Auth";
    }

    return AddMSMQSender(wsQueueName);    
}

HRESULT CFwdConsSend::AddSyncSender( LPCWSTR wszMachine )
{
    HRESULT hr;

    CWbemPtr<IWmiMessageSender> pSender;

    hr = CoCreateInstance( CLSID_WmiMessageRpcSender,
                          NULL,
                          CLSCTX_INPROC,
                          IID_IWmiMessageSender,
                          (void**)&pSender );
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // construct target binding : OBJID@ncacn_ip_tcp:target
    // 

    WString wsTarget = L"7879E40D-9FB5-450a-8A6D-00C89F349FCE@ncacn_ip_tcp:";
    wsTarget += wszMachine;

    //
    // construct the target principal name - for kerberos.  We expect that 
    // has registered its SPN with AD.  we only need to do this if we 
    // are sending authenticated though ...
    //

    LPWSTR wszSpn = NULL;

    if ( m_dwFlags & WMIMSG_FLAG_SNDR_AUTHENTICATE )
    {  
        hr = GetSpn( wszMachine, &wszSpn );

        if ( FAILED(hr) )
        {
            DEBUGTRACE((LOG_ESS,"FC: Could not determine SPN for target %S. "
                    "hr=0x%x. Will try to forward events using NTLM\n",
                     wszMachine, hr ));
        }
    }

    CVectorDeleteMe<WCHAR> vdm2( wszSpn );

    WMIMSG_SNDR_AUTH_INFO AuthInfo;
    ZeroMemory( &AuthInfo, sizeof( WMIMSG_SNDR_AUTH_INFO ) );

    AuthInfo.wszTargetPrincipal = wszSpn;

    //
    // open sender
    //
    
    CWbemPtr<IWmiMessageSendReceive> pSend;

    hr = pSender->Open( wsTarget,
                        m_dwFlags | WMIMSG_FLAG_SNDR_LAZY_INIT,
                        &AuthInfo,
                        NULL,
                        m_pTraceSink,
                        &pSend );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // add to multi sender and return.
    //

    return m_pMultiSend->Add(WMIMSG_FLAG_MULTISEND_TERMINATING_SENDER, pSend );
}

HRESULT CFwdConsSend::AddPhysicalSender( LPCWSTR wszMachine )
{
    HRESULT hr;

#ifndef __WHISTLER_UNCUT

    if ( (m_dwFlags & WMIMSG_MASK_QOS) != WMIMSG_FLAG_QOS_SYNCHRONOUS )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    return AddSyncSender( wszMachine );

#else

    //
    // here, we always add a sync sender first even if a qos
    // of async is specified. Later this type of service may change to
    // be its own QoS class.
    //

    hr = AddSyncSender( wszMachine );

    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( (m_dwFlags & WMIMSG_MASK_QOS) == WMIMSG_FLAG_QOS_SYNCHRONOUS )
    {
        return WBEM_S_NO_ERROR;
    }

    return AddAsyncSender( wszMachine );

#endif

}

HRESULT CFwdConsSend::AddLogicalSender( LPCWSTR wszTarget )
{
    HRESULT hr;

    CWbemPtr<IWmiMessageSendReceive> pSend;

    hr = Create( m_pControl,
                wszTarget,
                m_dwFlags | FWD_FLAG_NO_INDIRECT,
                NULL,
                m_pTraceSink,
                &pSend );

    if ( FAILED(hr) )
    {
        return hr;
    }

    return m_pMultiSend->Add( 0, pSend );
}

HRESULT CFwdConsSend::AddLogicalSender( LPCWSTR wszObjpath, LPCWSTR wszProp )
{
    HRESULT hr;

    //
    // Check to make sure that indirect names are supported.
    // This flag is mostly used to prohibit recursive indirect
    // addesses.
    //

    if ( m_dwFlags & FWD_FLAG_NO_INDIRECT )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    CWbemBSTR bsObjPath = wszObjpath;

    //
    // Resolve the address by obtaining the object and getting
    // the value of the specified property.
    //

    VARIANT var;
    CWbemPtr<IWbemClassObject> pObj;

    hr = m_pDefaultSvc->GetObject( bsObjPath, 0, NULL, &pObj, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pObj->Get( wszProp, 0, &var, NULL, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    CClearMe cmvar(&var);

    //
    // Add a new logical sender after resolving the address.
    // Before adding the new sender, make sure we disable indirect
    // addresses on it to prohibit recursive resolution.
    //

    DWORD dwFlags = m_dwFlags | FWD_FLAG_NO_INDIRECT;

    if ( V_VT(&var) == VT_BSTR )
    {
        return AddLogicalSender( V_BSTR(&var) );
    }
    else if ( V_VT(&var) == (VT_ARRAY | VT_BSTR) )
    {
        BSTR* abstrNames;
        hr = SafeArrayAccessData( V_ARRAY(&var), (void**)&abstrNames );

        if ( FAILED(hr) )
        {
            return hr;
        }

        long lUbound;
        hr = SafeArrayGetUBound( V_ARRAY(&var), 0, &lUbound );
        _DBG_ASSERT(SUCCEEDED(hr));

        for( long i=0; i < lUbound+1; i++ )
        {
            AddLogicalSender( V_BSTR(&var) );
        }

        SafeArrayUnaccessData( V_ARRAY(&var) );
    }
    else
    {
        return WBEM_E_TYPE_MISMATCH;
    }

    return hr;
}

HRESULT CFwdConsSend::EnsureSender()
{
    HRESULT hr;

    CInCritSec ics(&m_cs);

    if ( m_bResolved )
    {
        return S_OK;
    }

    WString wsTarget = m_wsTarget;

    LPWSTR wszToken = wcstok( wsTarget, L"!" );

    LPWSTR wszToken2 = wcstok( NULL, L"!" );

    if ( wszToken2 == NULL )
    {
        hr = AddPhysicalSender( wszToken );
    }
#ifdef __WHISTLER_UNCUT
    else if ( _wcsicmp( wszToken, L"msmq" ) == 0 )
    {
        hr = AddMSMQSender( wszToken2 );
    }
    else if ( _wcsicmp( wszToken, L"wmi" ) == 0 )
    {
        LPWSTR wszToken3 = wcstok( NULL, L"!" );

        if ( wszToken3 == NULL )
        {
            return WMIMSG_E_INVALIDADDRESS;
        }

        hr = AddLogicalSender( wszToken2, wszToken3 );
    }
#endif
    else
    {
        return WMIMSG_E_INVALIDADDRESS;
    }

    if ( FAILED(hr) )
    {
        return hr;
    }

    m_bResolved = TRUE;

    return hr;
}

HRESULT CFwdConsSend::HandleTrace( HRESULT hr, IUnknown* pCtx )
{
    if ( m_pTraceSink == NULL )
    {
        return WBEM_S_NO_ERROR;
    }

    return m_pTraceSink->Notify( hr, g_guidQueueType, m_wsTarget, pCtx );
}

HRESULT CFwdConsSend::SendReceive( PBYTE pData,
                                  ULONG cData,
                                  PBYTE pAuxData,
                                  ULONG cAuxData,
                                  DWORD dwFlagStatus,
                                  IUnknown* pCtx )
{
    HRESULT hr;

    hr = EnsureSender();

    if ( FAILED(hr) )
    {
        HandleTrace( hr, pCtx );
        return hr;
    }

    return m_pMultiSend->SendReceive( pData,
                                     cData,
                                     pAuxData,
                                     cAuxData,
                                     dwFlagStatus,
                                     pCtx );
}

HRESULT CFwdConsSend::Create( CLifeControl* pCtl,
                             LPCWSTR wszTarget,
                             DWORD dwFlags,
                             IWbemServices* pDefaultSvc,
                             IWmiMessageTraceSink* pTraceSink,
                             IWmiMessageSendReceive** ppSend )
{
    HRESULT hr;

    *ppSend = NULL;

    CWbemPtr<IWmiMessageMultiSendReceive> pMultiSend;

    hr = CoCreateInstance( CLSID_WmiMessageMultiSendReceive,
                          NULL,
                          CLSCTX_INPROC,
                          IID_IWmiMessageMultiSendReceive,
                          (void**)&pMultiSend );
    if ( FAILED(hr) )
    {
	return hr;
    }

    CWbemPtr<CFwdConsSend> pSend = new CFwdConsSend( pCtl );

    if ( pSend == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    if ( wszTarget != NULL && *wszTarget != 0 )
    {
        pSend->m_wsTarget = wszTarget;
    }
    else
    {
        //
        // the default is to send to local computer.
        //

        TCHAR achComputer[MAX_COMPUTERNAME_LENGTH+1];
        ULONG ulSize = MAX_COMPUTERNAME_LENGTH+1;
        GetComputerName( achComputer, &ulSize );
        pSend->m_wsTarget = achComputer;
    }

    pSend->m_dwFlags = dwFlags;
    pSend->m_pDefaultSvc = pDefaultSvc;
    pSend->m_pTraceSink = pTraceSink;
    pSend->m_pMultiSend = pMultiSend;

    hr = pSend->QueryInterface( IID_IWmiMessageSendReceive, (void**)ppSend );
    _DBG_ASSERT(SUCCEEDED(hr));

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\forwarding\fevprov.h ===
#ifndef __FEVPROV_H__
#define __FEVPROV_H__

#include <unk.h>
#include <comutl.h>
#include <wbemcli.h>
#include <wbemprov.h>
#include <wmimsg.h>
#include "fwdhdr.h"

class CFwdEventProv : public CUnk
{
    class XProv : public CImpl< IWbemEventProvider, CFwdEventProv >
    { 
    public:

        STDMETHOD(ProvideEvents)( IWbemObjectSink* pSink, long lFlags )
 	{
	    return m_pObject->ProvideEvents( pSink, lFlags );
	}

        XProv( CFwdEventProv* pObj )
	 : CImpl<IWbemEventProvider, CFwdEventProv> ( pObj ) {}

    } m_XProv;

    class XQuery : public CImpl<IWbemEventProviderQuerySink, CFwdEventProv>
    {
    public:
        
        STDMETHOD(NewQuery)( DWORD dwId, LPWSTR wszLanguage, LPWSTR wszQuery )
	{
	    return m_pObject->NewQuery( dwId, wszQuery );
	}

        STDMETHOD(CancelQuery)( DWORD dwId )
	{
	    return m_pObject->CancelQuery( dwId );
	}

        XQuery( CFwdEventProv* pObj) 
	 : CImpl<IWbemEventProviderQuerySink, CFwdEventProv> ( pObj ) {}

    } m_XQuery;

    class XInit : public CImpl<IWbemProviderInit, CFwdEventProv>
    {
    public:

        STDMETHOD(Initialize)( LPWSTR wszUser, 
                               LONG lFlags, 
                               LPWSTR wszNamespace,
                               LPWSTR wszLocale, 
                               IWbemServices* pNamespace,
                               IWbemContext* pContext,
                               IWbemProviderInitSink* pInitSink )
        {
            return m_pObject->Init( pNamespace, pInitSink );
        }

        XInit( CFwdEventProv* pObj) 
         : CImpl<IWbemProviderInit, CFwdEventProv>(pObj) { }

    } m_XInit;

    //
    // the next two interface impls are not associated with this objects's 
    // identity.  Reasons is there would be a circular ref problem if they 
    // were because we hold onto the receiver, which in turn holds on to
    // the send/recv and error sink objects.
    //

    class XSendReceive : public IWmiMessageSendReceive
    {
        CFwdEventProv* m_pOwner; // no add-ref or circular reference.

        STDMETHOD(QueryInterface)(REFIID riid, void** ppv)
        {
            if ( riid == IID_IUnknown || riid == IID_IWmiMessageSendReceive )
            {
                *ppv = this;
                return S_OK;
            }
            return E_NOINTERFACE;
        }
            
        STDMETHOD_(ULONG, AddRef)() { return 1; }
        STDMETHOD_(ULONG, Release)() { return 1; }

    public:

        STDMETHOD(SendReceive)( PBYTE pData, 
                                ULONG cData,
                                PBYTE pAuxData,
                                ULONG cAuxData,
                                DWORD dwFlagStatus,
                                IUnknown* pCtx )
 	{
	    return m_pOwner->Receive( pData, 
                                      cData, 
                                      pAuxData,
                                      cAuxData,
                                      dwFlagStatus,
                                      pCtx );
	}

        XSendReceive( CFwdEventProv* pOwner ) : m_pOwner( pOwner ) { }

    } m_XSendReceive;

    class XErrorSink : public IWmiMessageTraceSink
    { 
        CFwdEventProv* m_pOwner; // no add-ref or circular reference.

        STDMETHOD(QueryInterface)(REFIID riid, void** ppv)
        {
            if ( riid == IID_IUnknown || riid == IID_IWmiMessageTraceSink )
            {
                *ppv = this;
                return S_OK;
            }
            return E_NOINTERFACE;
        }
            
        STDMETHOD_(ULONG, AddRef)() { return 1; }
        STDMETHOD_(ULONG, Release)() { return 1; }

    public:

	STDMETHOD(Notify)( HRESULT hRes, 
                           GUID guidSource, 
                           LPCWSTR wszError, 
                           IUnknown* pCtx )
	{
	    return m_pOwner->HandleRecvError( hRes, wszError );
	}

        XErrorSink( CFwdEventProv* pOwner ) : m_pOwner( pOwner ) { }

    } m_XErrorSink;
              
    CWbemPtr<IWbemServices> m_pSvc;
    CWbemPtr<IWbemObjectSink> m_pEventSink;
    CWbemPtr<IWbemClassObject> m_pEventClass;
    CWbemPtr<IWbemClassObject> m_pDataClass;    
    
    CWbemPtr<IWmiObjectMarshal> m_pMrsh;
    CWbemPtr<IWmiMessageReceiver> m_pDcomRcvr;
    CWbemPtr<IWmiMessageReceiver> m_apQueueRcvr[16];

    long m_lMachineProp;
    long m_lConsumerProp;
    long m_lNamespaceProp;
    long m_lAuthProp;
    long m_lSDProp;
    long m_lAccountProp;
    long m_lTimeProp;

    HRESULT InitializeQueues( BOOL bAllowUnauth );
    HRESULT InitializeReceivers( BOOL bAllowUnauth );

    HRESULT InitializeEvent( IWbemClassObject* pOriginalEvent,
                             IWmiMessageReceiverContext* pRecvCtx,
                             LPCWSTR wszConsumer,
                             LPCWSTR wszNamespace,
                             PBYTE pSD,
                             ULONG cSD,
                             IWbemClassObject* pEvent ); 

    void* GetInterface( REFIID riid );

public:

    CFwdEventProv( CLifeControl* pCtl, IUnknown* pUnk = NULL );
    virtual ~CFwdEventProv();

    HRESULT Init( IWbemServices* pSvc, IWbemProviderInitSink* pInitSink);
    HRESULT ProvideEvents( IWbemObjectSink* pSink, long lFlags );
    HRESULT NewQuery( DWORD dwId, LPWSTR wszQuery );
    HRESULT CancelQuery( DWORD dwId );	
    HRESULT HandleRecvError( HRESULT hRes, LPCWSTR wszError );
    HRESULT Receive( PBYTE pData, 
                     ULONG cData, 
                     PBYTE pAuxData,
                     ULONG cAuxData,
                     DWORD dwFlagStatus,
                     IUnknown* pCtx );
};

#endif // __FEVPROV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\forwarding\fwdhdr.h ===
#ifndef __FWDHDR_H__
#define __FWDHDR_H__

#include <buffer.h>
#include <comutl.h>
#include <wbemcli.h>

/**************************************************************************
  CFwdMsgHeader
***************************************************************************/

class CFwdMsgHeader
{
    DWORD m_dwNumObjs;
    char m_chQos;
    char m_chAuth;
    char m_chEncrypt;
    GUID m_guidExecution;
    LPCWSTR m_wszConsumer;
    LPCWSTR m_wszNamespace;
    PBYTE m_pTargetSD;
    DWORD m_cTargetSD;

public:

    CFwdMsgHeader();

    CFwdMsgHeader( DWORD dwNumObjs, 
                   DWORD dwQos,
                   BOOL bAuth,
                   BOOL bEncrypt,
                   GUID& rguidExecution,
                   LPCWSTR wszConsumer,
                   LPCWSTR wszNamespace,
                   PBYTE pTargetSD,
                   DWORD cTargetSD );

    DWORD GetNumObjects() { return m_dwNumObjs; }
    DWORD GetQos() { return m_chQos; }
    BOOL GetAuthentication() { return m_chAuth; }
    BOOL GetEncryption() { return m_chEncrypt; }
    GUID& GetExecutionId() { return m_guidExecution; }
    LPCWSTR GetConsumer() { return m_wszConsumer; }
    LPCWSTR GetNamespace() { return m_wszNamespace; }
    PBYTE GetTargetSD() { return m_pTargetSD; }
    DWORD GetTargetSDLength() { return m_cTargetSD; }

    HRESULT Persist( CBuffer& rStrm );
    HRESULT Unpersist( CBuffer& rStrm );
};

#endif __FWDHDR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\forwarding\precomp.h ===
#undef _CRTIMP
#define _CRTIMP
#include <yvals.h>
#undef _CRTIMP
#define _CRTIMP __declspec(dllimport)

#include <ole2.h>
#include <winsock2.h>
#include <windows.h>
#include <wincrypt.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\forwarding\makefile.inc ===
$(O)\fconprov.mof: fconprov.mof
    copy copyright.mof+fconprov.mof $(O)\fconprov.mof

$(O)\fconprov.mfl: fconprov.mof
    copy copyright.mof+fconprov.mfl $(O)\fconprov.mfl

$(O)\fevprov.mof $(O)\fevprov.mfl: fevprov.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\fevprovTmp.mof -MFL:$(O)\fevprovTmp.mfl fevprov.mof
    copy copyright.mof+$(O)\fevprovTmp.mof+$(O)\fevprovTmp.mfl $(O)\fevprov.mof
    copy copyright.mof+$(O)\fevprovTmp.mfl $(O)\fevprov.mfl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\forwarding\fwdmain.cpp ===
#include "precomp.h"
#include <commain.h>
#include <clsfac.h>
#include <arrtempl.h>
#include <tchar.h>
#include "fconprov.h"
#include "fevprov.h"
#include "faevprov.h"

// {AD1B46E8-0AAC-401b-A3B8-FCDCF8186F55}
static const CLSID CLSID_FwdConsProvider = 
{0xad1b46e8, 0xaac, 0x401b, {0xa3, 0xb8, 0xfc, 0xdc, 0xf8, 0x18, 0x6f, 0x55}};

// {7879E40D-9FB5-450a-8A6D-00C89F349FCE}
static const CLSID CLSID_FwdEventProvider =  
{0x7879e40d, 0x9fb5, 0x450a, {0x8a, 0x6d, 0x0, 0xc8, 0x9f, 0x34, 0x9f, 0xce}};

// {D6C74FF3-3DCD-4c23-9F58-DD86F371EC73}
static const CLSID CLSID_FwdAckEventProvider =  
{0xd6c74ff3, 0x3dcd, 0x4c23, {0x9f, 0x58, 0xdd, 0x86, 0xf3, 0x71, 0xec, 0x73}};

#define REG_WBEM_FWD _T("Software\\Microsoft\\WBEM\\FWD")

class CFwdConsProviderServer : public CComServer
{
protected:

    void Register();
    void Unregister();
    HRESULT Initialize();
    void Uninitialize() { CFwdConsProv::UninitializeModule(); }

} g_Server;


BOOL AllowUnauthenticatedEvents()
{
    //
    // look up in registry if we will allow unauthenticated forwarded events.
    // 

    HKEY hKey;
    LONG lRes;
    BOOL bAllowUnauth = FALSE;

    lRes = RegOpenKey( HKEY_LOCAL_MACHINE, REG_WBEM_FWD, &hKey );

    if ( lRes == ERROR_SUCCESS )
    {
        DWORD dwAllowUnauth;
        DWORD dwBuffSize = 4;

        lRes = RegQueryValueEx( hKey, 
                                TEXT("AllowUnauthenticatedEvents"), 
                                0, 
                                NULL, 
                                (BYTE*)&dwAllowUnauth, 
                                &dwBuffSize );

        if ( lRes == ERROR_SUCCESS )
        {
            bAllowUnauth = dwAllowUnauth != 0 ? TRUE : FALSE;
        }
        
        RegCloseKey( hKey );
    }

    return bAllowUnauth;
}


HRESULT CFwdConsProviderServer::Initialize()
{
    ENTER_API_CALL

    HRESULT hr;

    hr = CFwdConsProv::InitializeModule();

    if ( FAILED(hr) )
    {
        return hr;
    }

    CWbemPtr<CBaseClassFactory> pFactory;

    pFactory = new CSimpleClassFactory<CFwdConsProv>(GetLifeControl());

    if ( pFactory == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    hr = AddClassInfo( CLSID_FwdConsProvider, 
                      pFactory,
                      _T("Forwarding Consumer Provider"), 
                      TRUE );

    if ( FAILED(hr) )
    {
        return hr;
    }

    pFactory = new CClassFactory<CFwdEventProv>( GetLifeControl() );

    if ( pFactory == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    hr = AddClassInfo( CLSID_FwdEventProvider, 
                      pFactory,
                      _T("Forwarding Event Provider"), 
                      TRUE );

    if ( FAILED(hr) )
    {
        return hr;
    }

#ifdef __WHISTLER_UNCUT
    
    pFactory = new CClassFactory<CFwdAckEventProv>( GetLifeControl() );

    if ( pFactory == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    hr = AddClassInfo( CLSID_FwdAckEventProvider, 
                      pFactory,
                      _T("Forwarding Ack Event Provider"), 
                      TRUE );

#endif

    return hr;
    
    EXIT_API_CALL
}

void CFwdConsProviderServer::Register()
{    
    HKEY hKey;
    LONG lRes;
    DWORD dwDisposition;

    lRes = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                           REG_WBEM_FWD,
                           0,
                           NULL,
                           0,
                           KEY_ALL_ACCESS,
                           NULL,
                           &hKey,
                           &dwDisposition );

    if ( lRes == ERROR_SUCCESS )
    {
        if ( dwDisposition == REG_CREATED_NEW_KEY )
        {
            DWORD dwAllowUnauth = 0;

            lRes = RegSetValueEx( hKey, 
                                  TEXT("AllowUnauthenticatedEvents"), 
                                  0, 
                                  REG_DWORD,
                                  (BYTE*)&dwAllowUnauth, 
                                  4 );
        }

        RegCloseKey( hKey );
    }
}

void CFwdConsProviderServer::Unregister()
{
    RegDeleteKey( HKEY_LOCAL_MACHINE, REG_WBEM_FWD );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\forwarding\localloc.cpp ===
#include "precomp.h"
#include <arena.h>
#include <corex.h>

static class WbemComnInitializer
{
public:

    WbemComnInitializer()
    {
        CWin32DefaultArena::WbemHeapInitialize( GetProcessHeap() );
    }

} g_WbemComnInitializer;

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\krnlprov\krnlprov.cpp ===
// krnlprov.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f krnlprovps.mk in the project directory.

#include "precomp.h"
#include "resource.h"
#include <initguid.h>
#include "krnlprov.h"

#include "krnlprov_i.c"
#include "KernelTraceProvider.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_KernelTraceProvider, CKernelTraceProvider)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_KRNLPROVLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\krnlprov\kerneltraceprovider.h ===
// KernelTraceProvider.h : Declaration of the CKernelTraceProvider

#ifndef __KERNELTRACEPROVIDER_H_
#define __KERNELTRACEPROVIDER_H_

#include "resource.h"       // main symbols

#include "ObjAccess.h"
#include "Sync.h"

_COM_SMARTPTR_TYPEDEF(IWbemEventSink, __uuidof(IWbemEventSink));
_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));

struct EVENT_TRACE_PROPERTIES_EX : public EVENT_TRACE_PROPERTIES
{
    EVENT_TRACE_PROPERTIES_EX()
    {
        ZeroMemory(this, sizeof(*this));

        Wnode.BufferSize = sizeof(*this);
        Wnode.Flags = WNODE_FLAG_TRACED_GUID;

        LogFileNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
        LogFileNameOffset = (DWORD) ((LPBYTE) szLogFileName - (LPBYTE) this);
        LoggerNameOffset = (DWORD) ((LPBYTE) szLoggerName - (LPBYTE) this);
    }
        
    TCHAR szLogFileName[MAX_PATH];
    TCHAR szLoggerName[MAX_PATH];
};
    
/////////////////////////////////////////////////////////////////////////////
// CKernelTraceProvider
class ATL_NO_VTABLE CKernelTraceProvider : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CKernelTraceProvider, &CLSID_KernelTraceProvider>,
	public IWbemProviderInit,
    public IWbemEventProvider
{
public:
	CKernelTraceProvider();
	~CKernelTraceProvider();

DECLARE_REGISTRY_RESOURCEID(IDR_KERNELTRACEPROVIDER)
DECLARE_NOT_AGGREGATABLE(CKernelTraceProvider)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CKernelTraceProvider)
	COM_INTERFACE_ENTRY(IWbemProviderInit)
	COM_INTERFACE_ENTRY(IWbemEventProvider)
END_COM_MAP()


// IWbemProviderInit
public:
    HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPWSTR pszUser,
            /* [in] */ LONG lFlags,
            /* [in] */ LPWSTR pszNamespace,
            /* [in] */ LPWSTR pszLocale,
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink);


// IWbemEventProvider
public:
    HRESULT STDMETHODCALLTYPE ProvideEvents( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink,
            /* [in] */ long lFlags);


    enum SINK_TYPE
    {
        //SINK_PROCESS_CREATION,
        //SINK_PROCESS_DELETION,
        SINK_PROCESS_START,
        SINK_PROCESS_STOP,

        //SINK_THREAD_CREATION,
        //SINK_THREAD_DELETION,
        SINK_THREAD_START,
        SINK_THREAD_STOP,

        SINK_MODULE_LOAD,
        
        SINK_COUNT
    };

// Implementation
protected:
    IWbemEventSinkPtr   m_pSinks[SINK_COUNT];
    IWbemServicesPtr    m_pNamespace;
    EVENT_TRACE_PROPERTIES_EX 
                        m_properties;
    TRACEHANDLE         m_hSession,
                        m_hTrace;
    BOOL                m_bDone;
    CCritSec            m_cs;

    // Process events
    CObjAccess          //m_eventProcessInstCreation,
                        //m_eventProcessInstDeletion,
                        //m_objProcessCreated,
                        //m_objProcessDeleted,
                        m_eventProcessStart,
                        m_eventProcessStop;

    // Thread events
    CObjAccess          //m_eventThreadInstCreation,
                        //m_eventThreadInstDeletion,
                        //m_objThread,
                        m_eventThreadStart,
                        m_eventThreadStop;

    // Module load
    CObjAccess          m_eventModuleLoad;

    HRESULT InitEvents();
    HRESULT InitTracing();
    void StopTracing();

    static DWORD WINAPI DoProcessTrace(CKernelTraceProvider *pThis);
    static void WINAPI OnProcessEvent(PEVENT_TRACE pEvent);
    static void WINAPI OnThreadEvent(PEVENT_TRACE pEvent);
    static void WINAPI OnImageEvent(PEVENT_TRACE pEvent);
};

#endif //__KERNELTRACEPROVIDER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\krnlprov\kerneltraceprovider.cpp ===
// KernelTraceProvider.cpp : Implementation of CKernelTraceProvider
#include "precomp.h"
#include "Krnlprov.h"
#include "KernelTraceProvider.h"

void Trace(LPCTSTR szFormat, ...)
{
	va_list ap;

	TCHAR szMessage[512];

    va_start(ap, szFormat);
	_vstprintf(szMessage, szFormat, ap);
	va_end(ap);

	lstrcatW(szMessage, _T("\n"));

    OutputDebugString(szMessage);
}

/////////////////////////////////////////////////////////////////////////////
// CKernelTraceProvider

// Because the event trace API won't allow you to get back a user-defined 
// value when events are received!
CKernelTraceProvider *g_pThis;

CKernelTraceProvider::CKernelTraceProvider()
{
    g_pThis = this;
}

CKernelTraceProvider::~CKernelTraceProvider()
{
    StopTracing();
}

HRESULT STDMETHODCALLTYPE CKernelTraceProvider::Initialize( 
    /* [in] */ LPWSTR pszUser,
    /* [in] */ LONG lFlags,
    /* [in] */ LPWSTR pszNamespace,
    /* [in] */ LPWSTR pszLocale,
    /* [in] */ IWbemServices __RPC_FAR *pNamespace,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink)
{
    HRESULT hr = S_OK;

    m_pNamespace = pNamespace;

    // Tell Windows Management our initialization status.
    pInitSink->SetStatus(SUCCEEDED(hr) ? WBEM_S_INITIALIZED : WBEM_E_FAILED, 0);
    
    return hr;
}

#define COUNTOF(x)  (sizeof(x)/sizeof(x[0]))

HRESULT CKernelTraceProvider::InitEvents()
{
    /////////////////////////////////////////////////////////////////////////
    // Win32_ProcessStartTrace

    LPCWSTR szProcessNames[] =
    {
        L"PageDirectoryBase",
		L"ProcessID",
        L"ParentProcessID",
		L"SessionID",
        L"Sid",
        L"ProcessName"
    };

    m_eventProcessStart.Init(
        m_pNamespace,
        L"Win32_ProcessStartTrace",
        szProcessNames,
        COUNTOF(szProcessNames),
        CObjAccess::FAILED_PROP_FAIL);


    /////////////////////////////////////////////////////////////////////////
    // Win32_ProcessStopTrace

    m_eventProcessStop.Init(
        m_pNamespace,
        L"Win32_ProcessStopTrace",
        szProcessNames,
        COUNTOF(szProcessNames),
        CObjAccess::FAILED_PROP_FAIL);

    /////////////////////////////////////////////////////////////////////////
    // Win32_ThreadStartTrace

    LPCWSTR szThreadStartNames[] =
    {
		L"StackBase",
		L"StackLimit",
		L"UserStackBase",
		L"UserStackLimit",
		L"StartAddr",
		L"Win32StartAddr",
        L"ProcessID",
        L"ThreadID",
		L"WaitMode",
    };

    m_eventThreadStart.Init(
        m_pNamespace,
        L"Win32_ThreadStartTrace",
        szThreadStartNames,
        COUNTOF(szThreadStartNames),
        CObjAccess::FAILED_PROP_FAIL);


    /////////////////////////////////////////////////////////////////////////
    // Win32_ThreadStopTrace

    LPCWSTR szThreadStopNames[] =
    {
        L"ProcessID",
        L"ThreadID",
    };

    m_eventThreadStop.Init(
        m_pNamespace,
        L"Win32_ThreadStopTrace",
        szThreadStopNames,
        COUNTOF(szThreadStopNames),
        CObjAccess::FAILED_PROP_FAIL);


    /////////////////////////////////////////////////////////////////////////
    // Win32_ModuleLoadTrace

    LPCWSTR szModuleNames[] =
    {
        L"ImageBase",
        L"ImageSize",
        L"ProcessID",
        L"FileName",
    };

    m_eventModuleLoad.Init(
        m_pNamespace,
        L"Win32_ModuleLoadTrace",
        szModuleNames,
        COUNTOF(szModuleNames),
        CObjAccess::FAILED_PROP_FAIL);

    return S_OK;
}

#define REALTIME
#define BUFFER_SIZE 64
#define MIN_BUFFERS 20
#define MAX_BUFFERS 200
#define FLUSH_TIME  1

//#define USE_KERNEL_GUID

#ifdef USE_KERNEL_GUID
#define LOGGER_NAME           L"NT Kernel Logger"
#define WMI_KERNEL_TRACE_GUID guidSystemTrace
#define ENABLE_FLAGS          EVENT_TRACE_FLAG_PROCESS | EVENT_TRACE_FLAG_THREAD | EVENT_TRACE_FLAG_IMAGE_LOAD
#else
#define LOGGER_NAME           L"WMI Event Logger"
#define WMI_KERNEL_TRACE_GUID guidWMITrace
#define ENABLE_FLAGS          0
#endif

#ifndef REALTIME
#define MAX_FILE_SIZE         20     // In MB
#define LOGGER_FILE           L"c:\\temp\\wmi.etl"
#endif

GUID guidProcess = 
    // {3d6fa8d0-fe05-11d0-9dda-00c04fd7ba7c}
    {0x3d6fa8d0, 0xfe05, 0x11d0, 0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c};

GUID guidThread = 
    // {3d6fa8d1-fe05-11d0-9dda-00c04fd7ba7c}
    {0x3d6fa8d1, 0xfe05, 0x11d0, 0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c};

GUID guidImage = 
    // {2cb15d1d-5fc1-11d2-abe1-00a0c911f518}
    {0x2cb15d1d, 0x5fc1, 0x11d2, 0xab, 0xe1, 0x00, 0xa0, 0xc9, 0x11, 0xf5, 0x18};

GUID guidSystemTrace = 
    // 9e814aad-3204-11d2-9a82-006008a86939 
    {0x9e814aad, 0x3204, 0x11d2, 0x9a, 0x82, 0x00, 0x60, 0x08, 0xa8, 0x69, 0x39};

GUID guidWMITrace = 
    // 44608a51-1851-4456-98b2-b300e931ee41 
    {0x44608a51, 0x1851, 0x4456, 0x98, 0xb2, 0xb3, 0x00, 0xe9, 0x31, 0xee, 0x41};

HRESULT CKernelTraceProvider::InitTracing()
{
    DWORD status;
    
    m_bDone = FALSE;

    // See if the logger is already running.  If not, set it up.
    if (QueryTrace(
        NULL,
        LOGGER_NAME,
        &m_properties) != ERROR_SUCCESS)
    {
        // Initialize property values here.
#ifdef REALTIME
        m_properties.LogFileMode = EVENT_TRACE_REAL_TIME_MODE;
        lstrcpy(m_properties.szLoggerName, LOGGER_NAME);
#else
        m_properties.LogFileMode = EVENT_TRACE_FILE_MODE_SEQUENTIAL;
        //properties.LogFileMode = EVENT_TRACE_FILE_MODE_CIRCULAR;

        // MaximumFileSize is in MB.
        m_properties.MaximumFileSize = MAX_FILE_SIZE;

        lstrcpy(m_properties.szLogFileName, LOGGER_FILE);
#endif

        m_properties.Wnode.Guid = WMI_KERNEL_TRACE_GUID;
    
        // Set the buffer size.  BufferSize is in KB.
        m_properties.BufferSize = BUFFER_SIZE;
        m_properties.MinimumBuffers = MIN_BUFFERS;
        m_properties.MaximumBuffers = MAX_BUFFERS;
    
        // Number of seconds before timer is flushed.
        m_properties.FlushTimer = FLUSH_TIME;

        m_properties.EnableFlags |= ENABLE_FLAGS;

        // Start tracing.
        status = 
            StartTrace(
                &m_hSession,
                LOGGER_NAME,
                &m_properties);

        if (status != ERROR_SUCCESS) 
        {
            TRACE(L"StartTrace error=%d (GetLastError=0x%x)",
                status, GetLastError());

            return WBEM_E_FAILED;
        }
    }
    else
        m_hSession = NULL;

    EVENT_TRACE_LOGFILE eventFile;

    ZeroMemory(&eventFile, sizeof(eventFile));

    //eventFile.BufferCallback = BufferCallback;
    //eventFile.EventCallback = DumpEvent;
    eventFile.LoggerName = (LPTSTR) LOGGER_NAME;

#ifdef REALTIME
    eventFile.LogFileMode = EVENT_TRACE_REAL_TIME_MODE;
#else
    eventFile.LogFileMode = 0;
    eventFile.LogFileName = (LPTSTR) LOGGER_FILE;
#endif


    SetTraceCallback(&guidProcess, OnProcessEvent);
    SetTraceCallback(&guidThread, OnThreadEvent);
    SetTraceCallback(&guidImage, OnImageEvent);

    m_hTrace = OpenTrace(&eventFile);
    
    TRACE(L"Ready to call ProcessTrace (m_hTrace = %d)...\n", m_hTrace);

    DWORD dwID;

    CloseHandle(
        CreateThread(
            NULL,
            0,
            (LPTHREAD_START_ROUTINE) DoProcessTrace,
            this,
            0,
            &dwID));

    return S_OK;
}

DWORD WINAPI CKernelTraceProvider::DoProcessTrace(CKernelTraceProvider *pThis)
{
#ifndef REALTIME
    FILETIME filetime;

    GetSystemTimeAsFileTime(&filetime);
#endif

    while(!pThis->m_bDone)
    {
        DWORD status;

        status =
            ProcessTrace(
                &pThis->m_hTrace,
                1,
#ifdef REALTIME
                NULL,
#else
                &filetime, 
#endif
                NULL);

#ifndef REALTIME
        // Save this off for our next all.
        GetSystemTimeAsFileTime(&filetime);
#endif

        if (status != ERROR_SUCCESS) 
        {
            TRACE(L"Error processing with status=%dL (GetLastError=0x%x)",
                status, GetLastError());
            
            break;
        }
        else
        {
#ifndef REALTIME
            TRACE(L"ProcessTrace exited successfully, sleeping...");
            
            Sleep(5000);
#endif
        }
    }

    TRACE(L"Exiting StartTracing.");

    return 0;
}

void CKernelTraceProvider::StopTracing()
{
    CInCritSec cs(&g_pThis->m_cs);
    DWORD      status;
    
    m_bDone = TRUE;

    status = CloseTrace(m_hTrace);

    status = 
        StopTrace(
            m_hSession,
            LOGGER_NAME,
            &m_properties);

    if (status != ERROR_SUCCESS) 
    {
        TRACE(L"StopTrace error=%d (GetLastError=0x%x)\n",
            status, GetLastError());
    }
}

const LPCWSTR szQueries[CKernelTraceProvider::SINK_COUNT] =
{
    /////////////////////////////////////////////////////////////////////
    // Process queries
        
    L"select * from Win32_ProcessStartTrace",
    L"select * from Win32_ProcessStopTrace",


    /////////////////////////////////////////////////////////////////////
    // Thread queries
        
    L"select * from Win32_ThreadStartTrace",
    L"select * from Win32_ThreadStopTrace",


    /////////////////////////////////////////////////////////////////////
    // Module queries
        
    L"select * from Win32_ModuleLoadTrace"
};

HRESULT STDMETHODCALLTYPE CKernelTraceProvider::ProvideEvents( 
    /* [in] */ IWbemObjectSink __RPC_FAR *pSink,
    /* [in] */ long lFlags)
{
    HRESULT           hr;
    IWbemEventSinkPtr pEventSink;

    hr = pSink->QueryInterface(IID_IWbemEventSink, (LPVOID*) &pEventSink);
    
    for (int i = 0; i < SINK_COUNT && SUCCEEDED(hr); i++)
    {
        hr =
            pEventSink->GetRestrictedSink(
                1,
                &szQueries[i],
                NULL,
                &m_pSinks[i]);
    }

    if (SUCCEEDED(hr))
        hr = InitEvents();

    if (SUCCEEDED(hr))
        hr = InitTracing();

    return hr;
}

#define PROCESS_START   1
#define PROCESS_END     2

struct CProcessTrace
{
    DWORD_PTR dwPageDirBase;
    DWORD     dwProcessID,
              dwParentProcessID,
              dwSessionID;
    DWORD     dwExitStatus;
    BYTE      cSidBegin[1];    
};

void WINAPI CKernelTraceProvider::OnProcessEvent(PEVENT_TRACE pEvent)
{
    CInCritSec     cs(&g_pThis->m_cs);
    CObjAccess     *pObjEx;
    IWbemEventSink *pSink;

    if (pEvent->Header.Class.Type == PROCESS_START)
    {
        pSink = g_pThis->m_pSinks[SINK_PROCESS_START];

        if (pSink->IsActive() != WBEM_S_NO_ERROR)
            return;
        
        pObjEx = &g_pThis->m_eventProcessStart;
    }
    else if (pEvent->Header.Class.Type == PROCESS_END)
    {
        pSink = g_pThis->m_pSinks[SINK_PROCESS_STOP];

        if (pSink->IsActive() != WBEM_S_NO_ERROR)
            return;
        
        pObjEx = &g_pThis->m_eventProcessStop;
    }
    else
        // Ignore anything else.
        return;
                
    CProcessTrace *pProcess = (CProcessTrace*) pEvent->MofData;

    // Find out where the SID is.
    LPBYTE pCurrent = (LPBYTE) &pProcess->cSidBegin,
           pSid;
    DWORD  nSidLen;

    if (*(DWORD*) pCurrent == 0)
    {
        pSid = NULL;
        pCurrent += sizeof(DWORD);
    }
    else
    {
        // These numbers were taken from tracedmp.c of the sdktool 
        // tracedmp.exe.  There's no explanation as to how they came up with 
        // them, but I'm assuming it's documented somewhere in the SDK.
        pCurrent += 8;
        nSidLen = 8 + (4 * pCurrent[1]);
        pSid = pCurrent;
        pCurrent += nSidLen;
    }

    _bstr_t strProcess = (LPSTR) pCurrent;

    // Extrinsic events
    pObjEx->WriteDWORD64(0, pProcess->dwPageDirBase);
    pObjEx->WriteDWORD(1, pProcess->dwProcessID);
    pObjEx->WriteDWORD(2, pProcess->dwParentProcessID);
    pObjEx->WriteDWORD(3, pProcess->dwSessionID);
    
    if (pSid)
        pObjEx->WriteNonPackedArrayData(4, pSid, nSidLen, nSidLen);
    else
        pObjEx->WriteNULL(4);

    pObjEx->WriteString(5, (LPCWSTR) strProcess);

    pSink->Indicate(1, pObjEx->GetObjForIndicate());
}

struct CThreadStart
{
	DWORD	  dwProcessID,
		      dwThreadID;
	DWORD_PTR dwStackBase,
			  dwStackLimit,
			  dwUserStackBase,
              dwUserStackLimit,
			  dwStartAddr,
			  dwWin32StartAddr;
	char	  cWaitMode;
};

struct CThreadStop
{
	DWORD	  dwProcessID,
		      dwThreadID;
};

void WINAPI CKernelTraceProvider::OnThreadEvent(PEVENT_TRACE pEvent)
{
    CInCritSec cs(&g_pThis->m_cs);

    if (pEvent->Header.Class.Type == PROCESS_START)
    {
		if (g_pThis->m_pSinks[SINK_THREAD_START]->IsActive() != WBEM_S_NO_ERROR)
			return;

	    CObjAccess   *pObjEx = &g_pThis->m_eventThreadStart;
		CThreadStart *pStart = (CThreadStart*) pEvent->MofData;

		pObjEx->WriteDWORD64(0, pStart->dwStackBase);
		pObjEx->WriteDWORD64(1, pStart->dwStackLimit);
		pObjEx->WriteDWORD64(2, pStart->dwUserStackBase);
		pObjEx->WriteDWORD64(3, pStart->dwUserStackLimit);
		pObjEx->WriteDWORD64(4, pStart->dwStartAddr);
		pObjEx->WriteDWORD64(5, pStart->dwWin32StartAddr);
		pObjEx->WriteDWORD(6, pStart->dwProcessID);
		pObjEx->WriteDWORD(7, pStart->dwThreadID);
		pObjEx->WriteDWORD(8, pStart->cWaitMode);
    
		g_pThis->m_pSinks[SINK_THREAD_START]->
			Indicate(1, pObjEx->GetObjForIndicate());
    }
    else if (pEvent->Header.Class.Type == PROCESS_END)
    {
		if (g_pThis->m_pSinks[SINK_THREAD_STOP]->IsActive() != WBEM_S_NO_ERROR)
			return;

	    CObjAccess  *pObjEx = &g_pThis->m_eventThreadStop;
		CThreadStop *pStop = (CThreadStop*) pEvent->MofData;

		pObjEx->WriteDWORD(0, pStop->dwProcessID);
		pObjEx->WriteDWORD(1, pStop->dwThreadID);
    
		g_pThis->m_pSinks[SINK_THREAD_STOP]->
			Indicate(1, pObjEx->GetObjForIndicate());
    }
}

struct CImageLoad
{
	DWORD_PTR dwImageBase;
	DWORD     dwImageSize;
    DWORD     dwProcessID;
    WCHAR     szFileName[4];
};

void WINAPI CKernelTraceProvider::OnImageEvent(PEVENT_TRACE pEvent)
{
    CInCritSec cs(&g_pThis->m_cs);

    if (g_pThis->m_pSinks[SINK_MODULE_LOAD]->IsActive() == WBEM_S_NO_ERROR)
    {
        CObjAccess *pObjEx = &g_pThis->m_eventModuleLoad;
        CImageLoad *pLoad = (CImageLoad*) pEvent->MofData;
        LPBYTE     pData = (LPBYTE) pEvent->MofData;

        // Extrinsic events
        pObjEx->WriteDWORD64(0, pLoad->dwImageBase);
        pObjEx->WriteDWORD(1, pLoad->dwImageSize);
        pObjEx->WriteDWORD(2, pLoad->dwProcessID);
        pObjEx->WriteString(3, pLoad->szFileName);
    
        g_pThis->m_pSinks[SINK_MODULE_LOAD]->Indicate(1, pObjEx->GetObjForIndicate());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\krnlprov\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "precomp.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\krnlprov\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by krnlprov.rc
//
#define IDS_PROJNAME                    100
#define IDR_KERNELTRACEPROVIDER         101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\krnlprov\precomp.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__7393E509_39EB_49E1_A775_08A22949E117__INCLUDED_)
#define AFX_STDAFX_H__7393E509_39EB_49E1_A775_08A22949E117__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <comdef.h>

#ifndef _WIN64
#define ULONG_PTR ULONG
#endif

#include <wmistr.h>
#include <evntrace.h>

extern "C" void Trace(LPCTSTR szFormat, ...);

#ifndef _DEBUG
#define TRACE  1 ? (void)0 : ::Trace
#else
#define TRACE  ::Trace
#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7393E509_39EB_49E1_A775_08A22949E117__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\krnlprov\sync.h ===
// Sync.h

class CCritSec : public CRITICAL_SECTION
{
public:
    CCritSec() 
    {
        InitializeCriticalSection(this);
    }
    ~CCritSec()
    {
        DeleteCriticalSection(this);
    }
    void Enter()
    {
        EnterCriticalSection(this);
    }
    void Leave()
    {
        LeaveCriticalSection(this);
    }
};

class CInCritSec
{
protected:
    CRITICAL_SECTION* m_pcs;
public:
    CInCritSec(CRITICAL_SECTION* pcs) : m_pcs(pcs)
    {
        EnterCriticalSection(m_pcs);
    }
    inline ~CInCritSec()
    {
        LeaveCriticalSection(m_pcs);
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\misc\evgen\evgen.cpp ===
#include <windows.h>
#include <wbemcli.h>
#include <wbemprov.h>
#include <stdio.h>
#include <wbemint.h>
#include <comutl.h>

int g_nRate = 0;
int g_cEvents = 0;
IWbemDecoupledBasicEventProvider* g_pDEP;

HRESULT Run( LPCWSTR wszObjPath, 
             int cIndicate, 
             int nBatchSize, 
             int nBatchDelay )
{
    HRESULT hr;

    if ( cIndicate < 1 )
    {
        cIndicate = 1;
    }

    CWbemPtr<IWbemDecoupledBasicEventProvider> pDEP;

    hr = CoCreateInstance( CLSID_WbemDecoupledBasicEventProvider, 
                           NULL, 
       			   CLSCTX_INPROC_SERVER, 
       			   IID_IWbemDecoupledBasicEventProvider,
       			   (void**)&pDEP );
    if ( FAILED(hr) )
    {
        printf( "Error CoCIing decoupled event provider. HR=0x%x\n", hr);
        return hr;
    }

    hr = pDEP->Register( 0,
                         NULL,
                         NULL,
                         NULL,
                         L"root\\default",
                         L"EvGenEventProvider",
                         NULL );
     
    if ( FAILED(hr) )
    {
        printf( "Error getting registering decoupled provider. HR=0x%x\n", hr);
        return hr;
    }

    g_pDEP = pDEP;
    g_pDEP->AddRef();

    CWbemPtr<IWbemServices> pSvc;

    hr = pDEP->GetService( 0, NULL, &pSvc );

    if ( FAILED(hr) )
    {
        printf( "Error getting Decoupled Svc. HR=0x%x\n", hr );
        return hr;
    }

    CWbemPtr<IWbemObjectSink> pSink;

    hr = pDEP->GetSink( 0, NULL, &pSink );

    if ( FAILED(hr) )
    {
        printf( "Error getting Event Sink. HR=0x%x\n", hr );
        return hr;
    }

    CWbemPtr<IWbemClassObject> pEventClass;

    hr = pSvc->GetObject( CWbemBSTR(L"EvGenEvent"), 
                          0,
                          NULL, 
                          &pEventClass, 
                          NULL );

    if ( FAILED(hr) )
    {
        printf( "Error getting EvGenEvent class. HR=0x%x\n", hr );
        return hr;
    }

    CWbemPtr<IWbemClassObject> pObj;

    hr = pSvc->GetObject( CWbemBSTR( wszObjPath ),
                          0, 
                          NULL,
                          &pObj, 
                          NULL );
    if ( FAILED(hr) )
    {
        printf("Error getting object with path %S. HR=0x%x\n", wszObjPath, hr);
        return hr;
    }

    CWbemPtr<IWbemClassObject> pEvent;

    hr = pEventClass->SpawnInstance( NULL, &pEvent );

    if ( FAILED(hr) )
    {
        return hr;
    }

    IWbemClassObject** apEvents = new IWbemClassObject*[cIndicate];

    for( int i=0 ; i < cIndicate; i++ )
    {
        apEvents[i] = pEvent;
    }

    VARIANT v;

    V_VT(&v) = VT_UNKNOWN;
    V_UNKNOWN(&v) = pObj;

    hr = pEvent->Put( L"Object", 0, &v, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    CWbemPtr<_IWmiObject> pIntObj;

    hr = pEvent->QueryInterface( IID__IWmiObject, (void**)&pIntObj );

    if ( SUCCEEDED(hr) )
    {
        DWORD dwSize;

        hr = pIntObj->GetObjectMemory( NULL, 0, &dwSize );

        printf( "Size of event is %d bytes\n", dwSize ); 
    }

    if ( nBatchSize != -1 )
    {
        CWbemPtr<IWbemEventSink> pEventSink;
        hr = pSink->QueryInterface( IID_IWbemEventSink, (void**)&pEventSink );
        
        if ( SUCCEEDED(hr) )
        {
            hr = pEventSink->SetBatchingParameters( WBEM_FLAG_MUST_BATCH,
                                                    nBatchSize,
                                                    nBatchDelay );
        }

        if ( FAILED(hr) )
        {
            printf( "Failed to set Batching Parameters. hr=0x%x\n" );
            return hr;
        }
    }

    while( g_nRate != 0 )
    {
        DWORD dwStart = GetTickCount();
        DWORD dwElapsed;
       
        int cEvents = 0;

        do
        {
            hr = pSink->Indicate( cIndicate, apEvents );
        
            if( FAILED(hr) )
            {
                printf("Error indicating event. HR=0x%x\n", hr );
                return hr;
            }

            cEvents += cIndicate;

            dwElapsed = GetTickCount() - dwStart;

        } while( cEvents < g_nRate && dwElapsed < 1000 );

        if ( dwElapsed < 1000 )
        {
            Sleep( 1000 - dwElapsed );
        }

        g_cEvents += cEvents;
    }
    
    return WBEM_S_NO_ERROR;
}

DWORD WINAPI WaitForShutdown( LPVOID )
{
    do
    {
        int c;
        scanf( "%d", &c );
        g_nRate = c;
        printf("\nRate is now : %d Events/Sec\n", g_nRate );

    } while ( g_nRate > 0 );

    return 1;
}    
    
extern "C" int __cdecl wmain( int argc, wchar_t** argv )
{
    HRESULT hr;

    if ( argc != 4 && argc != 6 )
    {
        printf( "Usage: evgen <objpath> <initial rate> <#perindicate>"
                "[batchsize(kb) batchdelay(ms)]\n" );
        return 1;
    }

    LPCWSTR wszObjPath = argv[1];
    g_nRate = _wtoi(argv[2]);
    int cIndicate = _wtoi(argv[3]);
    
    int nBatchSize = -1;
    int nBatchDelay = 0;
    
    if ( argc == 5 )
    {
        nBatchSize = _wtoi( argv[3] );
        nBatchDelay = _wtoi( argv[4] );
    }
    
    CreateThread( NULL, 0, WaitForShutdown, NULL, 0, NULL );

    CoInitializeEx( NULL, COINIT_MULTITHREADED );

    CoInitializeSecurity( NULL, -1, NULL, NULL,
                          RPC_C_AUTHN_LEVEL_CONNECT,
                          RPC_C_IMP_LEVEL_IMPERSONATE, 
                          NULL, EOAC_NONE, NULL ); 

    hr = Run( wszObjPath, cIndicate, nBatchSize, nBatchDelay );

    printf( "Total Iterations was %d", g_cEvents );

    if ( g_pDEP != NULL )
    {
        g_pDEP->UnRegister();
        g_pDEP->Release();
    }

    CoUninitialize();         
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\misc\eviprov\eviprov.cpp ===
#include <windows.h>
#include <commain.h>
#include <clsfac.h>
#include "eviprov.h"

HRESULT CEventInstProv::PutInstance( IWbemClassObject* pInst, 
                                     long lFlags,
                                     IWbemObjectSink* pResponseHndlr )
{
    HRESULT hr;
    CPropVar vEvent;

    hr = pInst->Get( L"Event", 0, &vEvent, NULL, NULL );

    if ( FAILED(hr) || FAILED(hr=vEvent.CheckType(VT_UNKNOWN)) )
    {
        return hr;
    }

    CWbemPtr<IWbemClassObject> pEvent;
    V_UNKNOWN(&vEvent)->QueryInterface(IID_IWbemClassObject, (void**)&pEvent);

    hr = m_pEventSink->Indicate( 1, &pEvent );

    return pResponseHndlr->SetStatus( WBEM_STATUS_COMPLETE, 
                                      hr, 
                                      NULL,
                                      NULL );
}

HRESULT CEventInstProv::Init( IWbemServices* pSvc, 
                              LPWSTR wszNamespace,
                              IWbemProviderInitSink* pInitSink )
{
    HRESULT hr;
    
    CWbemPtr<IWbemServices> pDummySvc;

    hr = CoCreateInstance( CLSID_PseudoSink, 
                           NULL, 
                           CLSCTX_INPROC_SERVER, 
                           IID_IWbemDecoupledEventSink,
                           (void**)&m_pDES );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = m_pDES->Connect( wszNamespace, 
                          L"EVIEventProvider",
                          NULL, 
                          &m_pEventSink,
                          &pDummySvc );
    if ( FAILED(hr) )
    {
        return hr;
    }

    return pInitSink->SetStatus( WBEM_S_INITIALIZED , 0 );
}

CEventInstProv::CEventInstProv( CLifeControl* pCtl, IUnknown* pUnk )
: m_XServices(this), m_XInitialize(this), CUnk( pCtl, pUnk )
{

}

CEventInstProv::~CEventInstProv()
{
    if ( m_pDES.m_pObj != NULL )
    {
        m_pDES->Disconnect();
    }
}

void* CEventInstProv::GetInterface( REFIID riid )
{
    if ( riid == IID_IWbemProviderInit )
    {
        return &m_XInitialize;
    }

    if ( riid == IID_IWbemServices )
    {
        return &m_XServices;
    }

    return NULL;
}

CEventInstProv::XServices::XServices( CEventInstProv* pProv )
: CImpl< IWbemServices, CEventInstProv> ( pProv )
{

}

CEventInstProv::XInitialize::XInitialize(CEventInstProv* pProv)
: CImpl< IWbemProviderInit, CEventInstProv> ( pProv )
{

}

// {C336AB33-1AF6-11d3-865E-00C04F63049B}
static const CLSID CLSID_EventInstanceProvider =
{ 0xc336ab33, 0x1af6, 0x11d3, {0x86, 0x5e, 0x0, 0xc0, 0x4f, 0x63, 0x4, 0x9b} };

class CEventInstProvServer : public CComServer
{
protected:
    
    void Initialize()
    {
        AddClassInfo( CLSID_EventInstanceProvider,
                      new CClassFactory<CEventInstProv>( GetLifeControl() ),
                      "Event Instance Provider", TRUE );
    }

} g_Server;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\misc\eviprov\eviprov.h ===
#ifndef __EVIPROV_H__
#define __EVIPROV_H__

#include <wbemcli.h>
#include <wbemprov.h>
#include <wbemdcpl.h>
#include <unk.h>
#include <comutl.h>
#include <wstring.h>

class CEventInstProv : public CUnk
{
    // IWbemProviderInit
    struct XInitialize : public CImpl<IWbemProviderInit,CEventInstProv>
    {
        XInitialize( CEventInstProv* pProv );

        STDMETHOD(Initialize)( 
            /* [string][unique][in] */ LPWSTR wszUser,
            /* [in] */ LONG lFlags,
            /* [string][in] */ LPWSTR wszNamespace,
            /* [string][unique][in] */ LPWSTR wszLocale,
            /* [in] */ IWbemServices* pNamespace,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemProviderInitSink* pInitSink )
        {
            return m_pObject->Init( pNamespace, wszNamespace, pInitSink );
        }

    } m_XInitialize;

    // IWbemServices
    struct XServices : public CImpl< IWbemServices, CEventInstProv>
    {
        XServices( CEventInstProv* pProv );

	STDMETHOD(OpenNamespace)( 
            /* [in] */ const BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemServices** ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult** ppResult )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
  
        STDMETHOD(CancelAsyncCall)( /* [in] */ IWbemObjectSink* pSink )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(QueryObjectSink)( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink** ppResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(GetObject)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemClassObject** ppObject,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(GetObjectAsync)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(PutClass)( 
            /* [in] */ IWbemClassObject* pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(PutClassAsync)( 
            /* [in] */ IWbemClassObject* pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
             
        STDMETHOD(DeleteClass)( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(DeleteClassAsync)( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(CreateClassEnum)( 
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [out] */ IEnumWbemClassObject** ppEnum )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(CreateClassEnumAsync)( 
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext  *pCtx,
            /* [in] */ IWbemObjectSink  *pResponseHandler)
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(PutInstance)( 
            /* [in] */ IWbemClassObject* pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(PutInstanceAsync)( 
            /* [in] */ IWbemClassObject* pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler)
        {
            return m_pObject->PutInstance( pInst, lFlags, pResponseHandler );
        }
        
        STDMETHOD(DeleteInstance)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult)
        {
            return WBEM_E_NOT_SUPPORTED;
        }
    
        STDMETHOD(DeleteInstanceAsync)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(CreateInstanceEnum)( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [out] */ IEnumWbemClassObject** ppEnum )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(CreateInstanceEnumAsync)( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(ExecQuery)( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [out] */ IEnumWbemClassObject** ppEnum )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
    
        STDMETHOD(ExecQueryAsync)( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(ExecNotificationQuery)( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [out] */ IEnumWbemClassObject** ppEnum ) 
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(ExecNotificationQueryAsync)( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(ExecMethod)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemClassObject *pInParams,
            /* [unique][in][out] */ IWbemClassObject** ppOutParams,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult)
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(ExecMethodAsync)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemClassObject* pInParams,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }

    } m_XServices;

    CWbemPtr<IWbemObjectSink> m_pEventSink;
    CWbemPtr<IWbemDecoupledEventSink> m_pDES;

public:
    
    CEventInstProv( CLifeControl* pCtl=NULL, IUnknown* pUnk=NULL );
    void* GetInterface( REFIID riid );
    ~CEventInstProv();

    HRESULT Init( IWbemServices* pSvc, 
                  LPWSTR wszNamespace, 
                  IWbemProviderInitSink* pInitSink );

    HRESULT PutInstance( IWbemClassObject* pObj, 
                         long lFlags, 
                         IWbemObjectSink* pRspHndlr );
};

#endif // __EVIPROV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncobjapi\dutils.h ===
// dutils.h

#pragma once

extern "C" void MBTrace(LPCTSTR szFormat, ...);
extern "C" void FTrace(LPCTSTR szFormat, ...);
extern "C" void Trace(LPCTSTR szFormat, ...);

#ifdef USE_FTRACE
#define TRACE  FTrace
#else

#ifndef _DEBUG
#define TRACE  1 ? (void)0 : ::Trace
#else
#define TRACE  ::Trace
#endif

#endif // #ifdef USE_FTRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\misc\svccmd\svccmd.cpp ===
#include <windows.h>
#include <tchar.h>

HANDLE g_hShutdown;
SERVICE_STATUS_HANDLE g_hStatus;

void WINAPI ServiceHandler(DWORD dwControl)
{
    SERVICE_STATUS Status;
    Status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    Status.dwCurrentState = SERVICE_RUNNING;
    Status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    Status.dwWin32ExitCode = NO_ERROR;
    Status.dwCheckPoint = 0;
    Status.dwWaitHint = 0;

    SetServiceStatus(g_hStatus, &Status);

    switch(dwControl)
    {
    case SERVICE_CONTROL_STOP:
        Status.dwCurrentState = SERVICE_STOPPED;
        SetServiceStatus(g_hStatus, &Status);
        SetEvent(g_hShutdown);
        return;
    case SERVICE_CONTROL_PAUSE:
    case SERVICE_CONTROL_CONTINUE:
    case SERVICE_CONTROL_INTERROGATE:
    case SERVICE_CONTROL_SHUTDOWN:
        return;
    };
}

void WINAPI ServiceMain(DWORD dwArgc, LPTSTR *lpszArgv)
{
    g_hStatus = RegisterServiceCtrlHandler( _T("svccmd"), ServiceHandler );

    SERVICE_STATUS Status;
    Status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    Status.dwCurrentState = SERVICE_START_PENDING;
    Status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    Status.dwWin32ExitCode = NO_ERROR;
    Status.dwCheckPoint = 0;
    Status.dwWaitHint = 10000;

    SetServiceStatus( g_hStatus, &Status);

    PROCESS_INFORMATION Info;
    STARTUPINFO Start;

    GetStartupInfo( &Start );

    CreateProcess( NULL,
                   _T("cmd.exe"),
                   NULL,
                   NULL,
                   FALSE,
                   0,
                   NULL,
                   NULL,
                   &Start,
                   &Info );

    Status.dwCurrentState = SERVICE_RUNNING;

    SetServiceStatus( g_hStatus, &Status);
}
    

BOOL RegisterService()
{
    SC_HANDLE hManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    TCHAR tszFilename[1024];
    GetModuleFileName(NULL, tszFilename, 1023);

    SC_HANDLE hService;

    hService = CreateService( hManager, 
                              _T("svccmd"), 
                              _T("CommandPromptService"),
                              SERVICE_ALL_ACCESS,
                              SERVICE_WIN32_OWN_PROCESS | 
                                SERVICE_INTERACTIVE_PROCESS ,
                              SERVICE_DEMAND_START,
                              SERVICE_ERROR_NORMAL,
                              tszFilename, 
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL );

    CloseServiceHandle( hService );
    CloseServiceHandle( hManager );
    
    return hService != NULL;
}

BOOL UnregisterService()
{
    SC_HANDLE hManager, hService;

    hManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    hService = OpenService( hManager, _T("svccmd"), SERVICE_ALL_ACCESS );

    BOOL bRes = DeleteService(hService);

    CloseServiceHandle( hService );
    CloseServiceHandle( hManager );

    return bRes;
}

extern "C" int __cdecl main()
{
    LPTSTR tszCommandLine = GetCommandLine();

    tszCommandLine = _tcstok( tszCommandLine, _T("/") );

    tszCommandLine = _tcstok( NULL, _T("/") );

    if ( tszCommandLine != NULL )
    {
        if ( _tcsicmp( tszCommandLine, _T("register") ) == 0 )
        {
            RegisterService();
            return 0;
        }
        else if ( _tcsicmp( tszCommandLine, _T("unregister") ) == 0 )
        {
            UnregisterService();
            return 0;
        }
    }

    g_hShutdown = CreateEvent( NULL, TRUE, FALSE, NULL );

    SERVICE_TABLE_ENTRY dispatchTable[] = 
    {
        { _T("svccmd"),(LPSERVICE_MAIN_FUNCTION) ServiceMain },
        { NULL, NULL }
    };

    StartServiceCtrlDispatcher(dispatchTable);

    WaitForSingleObject( g_hShutdown, INFINITE );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\common\ncdefs.h ===
// NCEDefs.h

#ifndef _NCEDEFS_H
#define _NCEDEFS_H

#include <comdef.h>

#define WMI_INIT_EVENT_NAME           L"WBEM_ESS_OPEN_FOR_BUSINESS"

#define OBJNAME_EVENT_READY           L"EVENT_READY"
#define OBJNAME_NAMED_PIPE            L"PIPE_EVENT"

#define MAX_MSG_SIZE                  131072
#define MAX_EVENT_SIZE                16384

#define PIPE_TIMEOUT                  32000   

#define NC_SRVMSG_CLIENT_INFO         0
#define NC_SRVMSG_EVENT_LAYOUT        1
#define NC_SRVMSG_PREPPED_EVENT       2
#define NC_SRVMSG_BLOB_EVENT          3
#define NC_SRVMSG_RESTRICTED_SINK     4

#ifdef USE_SD
#define NC_SRVMSG_SET_SINK_SD         5
#define NC_SRVMSG_SET_EVENT_SD        6
#endif

#define NC_SRVMSG_ACCESS_CHECK_REPLY 10
#define NC_SRVMSG_NEW_QUERY_REPLY    11
#define NC_SRVMSG_CANCEL_QUERY_REPLY 12

#define NC_CLIMSG_ACCESS_CHECK_REQ   10
#define NC_CLIMSG_NEW_QUERY_REQ      11
#define NC_CLIMSG_CANCEL_QUERY_REQ   12
#define NC_CLIMSG_PROVIDER_UNLOADING 13

struct NC_SRVMSG_REPLY
{
    DWORD     dwMsg;
    HRESULT   hrRet;
    DWORD_PTR dwMsgCookie;
};

class IPostBuffer
{
public:
    virtual ULONG AddRef() = 0;
    virtual ULONG Release() = 0;
    
    virtual HRESULT PostBuffer(LPBYTE pData, DWORD dwSize) = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncobjapi\dutils.cpp ===
#include "precomp.h"
#include <tchar.h>
#include "dutils.h"
#include <stdio.h>

HANDLE hMutex;

void FTrace(LPCTSTR szFormat, ...)
{
	va_list ap;

	TCHAR szMessage[512];

	if (!hMutex)
        hMutex = CreateMutex(NULL, FALSE, "FTraceMutex");

    va_start(ap, szFormat);
	_vstprintf(szMessage, szFormat, ap);
	va_end(ap);

	lstrcat(szMessage, "\n");

    WaitForSingleObject(hMutex, INFINITE);

    FILE *pFile = fopen("c:\\temp\\ncobjapi.log", "a+"); 

    if (pFile)
    {
        TCHAR szProcID[100];

        _stprintf(szProcID, "%d: ", GetCurrentProcessId());
        fputs(szProcID, pFile);
        
        fputs(szMessage, pFile);
        fclose(pFile);
    }

    ReleaseMutex(hMutex);
}

void Trace(LPCTSTR szFormat, ...)
{
	va_list ap;

	TCHAR szMessage[512];

    va_start(ap, szFormat);
	_vstprintf(szMessage, szFormat, ap);
	va_end(ap);

	lstrcat(szMessage, "\n");

    OutputDebugString(szMessage);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncobjapi\connection.h ===
// Connection.h
// This class is the hSource returned by WMIEventSourceConnect.

#pragma once

/////////////////////////////////////////////////////////////////////////////
// CConnection

#include "NCObjApi.h"
#include "Buffer.h"
#include "ReportEvent.h"
#include "NamedPipe.h"

#include "corex.h"
#include <list>
#include <map>

class CMyString
{
    LPWSTR m_wsz;

    void Set( LPCWSTR wsz )
    {
        delete [] m_wsz;
        
        if ( wsz != NULL )
        {
            m_wsz = new WCHAR[wcslen(wsz)+1];
            if ( m_wsz != NULL )
            {
                wcscpy( m_wsz, wsz );
            }
            else
            {
                throw CX_MemoryException();
            }
        }
        else
        {
            m_wsz = NULL;
        }
    }

public:

    CMyString( LPCWSTR wsz = NULL ) : m_wsz( NULL ) { Set(wsz); }
    CMyString( const CMyString& rws ) : m_wsz(NULL) { *this = rws; }
    const CMyString & operator=( const CMyString& rws ) { Set( rws.m_wsz ); return *this; }
    
    ~CMyString() { delete [] m_wsz; }
    
    bool operator< ( const CMyString& rws ) const
      { return _wcsicmp( m_wsz, rws.m_wsz ) < 0; }
};
    
typedef CMyString wstring;

class CEvent;
class CTransport;

typedef std::list< CEvent*, wbem_allocator<CEvent*> > CEventList;
typedef CEventList::iterator CEventListIterator;

#define NUM_TRANSPORTS    2

enum TRANSPORT_INDEX
{
    TRANS_NAMED_PIPE,
    TRANS_EVENT_TRACE,
};

struct NC_SRVMSG_REPLY;

class CSink
{
public:
    LPEVENT_SOURCE_CALLBACK 
                     m_pCallback;
    LPVOID           m_pUserData;
    CReportEventMap  m_mapReportEvents;
    CRITICAL_SECTION m_cs;

    CSink();
    ~CSink();

    BOOL Init(
        CConnection *pConnection, 
        DWORD dwID,
        LPVOID pUserData,
        LPEVENT_SOURCE_CALLBACK pCallback);
    BOOL IsReady();

    BOOL AddRestrictions(DWORD nQueries, LPCWSTR *pszQueries);

    DWORD GetSinkID() { return m_dwSinkID; }

    // Used for keeping track of the events created with the CConnection.
    void AddEvent(CEvent *pEvent);
    void RemoveEvent(CEvent *pEvent);

#ifdef USE_SD
    BOOL SetSD(SECURITY_DESCRIPTOR *pSD);
#endif

    void ResetEventBufferLayoutSent();
    BOOL IsEventClassEnabled(LPCWSTR szEventClass);

    CConnection *GetConnection() { return m_pConnection; }

    void Lock() { EnterCriticalSection(&m_cs); }
    void Unlock() { LeaveCriticalSection(&m_cs); }

    void EnableEventUsingList(CEvent *pEvent);

protected:
    friend CConnection;

    typedef std::map<wstring, int, std::less<wstring>, wbem_allocator<int> > CStrToIntMap;
    typedef CStrToIntMap::iterator CStrToIntMapIterator;

    CConnection  *m_pConnection;
    CBuffer      m_bufferRestrictions;
#ifdef USE_SD
    CBuffer      m_bufferSD;
#endif
    CEventList   m_listEvents;
    CStrToIntMap m_mapEnabledEvents;
    DWORD        m_dwSinkID;

    void AddToEnabledEventList(CBuffer *pBuffer);
    void RemoveFromEnabledEventList(CBuffer *pBuffer);
    void EnableAndDisableEvents();
};

class CConnection
{
public:
    BOOL   m_bDone;
    HANDLE m_heventDone,
           m_hthreadSend,
           m_heventEventsPending,
           m_heventBufferNotFull,
           m_heventBufferFull;
    WCHAR  m_szBaseNamespace[MAX_PATH * 2],
           m_szBaseProviderName[MAX_PATH * 2];
    CRITICAL_SECTION
           m_cs,
           m_csBuffer;
    
    DWORD  m_dwSendLatency;
    BOOL   m_bUseBatchSend;
    BOOL   m_bWMIResync;

    HANDLE m_heventWMIInit,
           m_hthreadWMIInit;

    CTransport *m_pTransport;

    CConnection(BOOL bBatchSend, DWORD dwBatchBufferSize, DWORD dwMaxSendLatency);
    ~CConnection();

    BOOL Init(
        LPCWSTR szNamespace, 
        LPCWSTR szProviderName,
        LPVOID pUserData,
        LPEVENT_SOURCE_CALLBACK pCallback);

    void Deinit();

    void Lock() { EnterCriticalSection(&m_cs); }
    void Unlock() { LeaveCriticalSection(&m_cs); }

    BOOL SendData(LPBYTE pBuffer, DWORD dwSize);

    BOOL ResyncWithWMI();
    BOOL IndicateProvEnabled();
    void IndicateProvDisabled();
    void StopThreads();

    BOOL SendInitInfo();

    BOOL WaitingForWMIInit() { return m_bWMIResync; }

    HRESULT ProcessMessage(LPBYTE pData, DWORD dwSize);

    BOOL IsReady() { return m_pTransport && m_pTransport->IsReady(); }

    CSink *CreateSink(
        LPVOID pUserData, 
        LPEVENT_SOURCE_CALLBACK pCallback);
    CSink *GetSink(DWORD dwID);
    CSink *GetMainSink() { return &m_sinkMain; }
    void RemoveSink(CSink *pSink);

protected:
    typedef std::map<DWORD, CSink*, std::less<DWORD>, wbem_allocator<CSink*> > CSinkMap;
    typedef CSinkMap::iterator CSinkMapIterator;

    CSink    m_sinkMain;
    CSinkMap m_mapSink;
    DWORD    m_dwNextSinkID;

    CBuffer  m_bufferSend;

    BOOL StartProviderReadyThread();
    BOOL StartSendThread();
    void StopSendThread();

    BOOL SendDataOverTransports(LPBYTE pBuffer, DWORD dwSize);

    static DWORD WINAPI SendThreadProc(CConnection *pThis);
    static void GetBaseName(LPCWSTR szName, LPWSTR szBase);

    BOOL StartWaitWMIInitThread();
    BOOL InitTransport();
    static DWORD WINAPI WaitWMIInitThreadProc(CConnection *pThis);
};

class CInCritSec
{
public:
    CInCritSec(CRITICAL_SECTION *pCS) 
    { 
        EnterCriticalSection(pCS);

        m_pCS = pCS;
    }

    ~CInCritSec()
    {
        LeaveCriticalSection(m_pCS);
    }

protected:
    CRITICAL_SECTION *m_pCS;
};

class CCondInCritSec
{
public:
    CCondInCritSec(CRITICAL_SECTION *pCS, BOOL bDoLock) 
    { 
        if (bDoLock)
        {
            EnterCriticalSection(pCS);

            m_pCS = pCS;
        }
        else
            m_pCS = NULL;
    }

    ~CCondInCritSec()
    {
        if (m_pCS)
            LeaveCriticalSection(m_pCS);
    }

protected:
    CRITICAL_SECTION *m_pCS;
};

// SDDL string description:
// D:        Security Descriptor
// A:        Access allowed
// 0x1f0003: EVENT_ALL_ACCESS
// BA:       Built-in administrators
// 0x100000: SYNCHRONIZE
// WD:       Everyone
#define ESS_EVENT_SDDL L"D:(A;;0x1f0003;;;BA)(A;;0x100000;;;WD)"


// Security helper
BOOL GetRelativeSD(
    SECURITY_DESCRIPTOR *pSDIn, 
    SECURITY_DESCRIPTOR **ppSDOut,
    BOOL *pbFree);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\common\ncobjapi.h ===
// NCEvent.h

#ifndef _NCEVENT_H
#define _NCEVENT_H

#ifdef ISP2PDLL
//#define WMIAPI __declspec(dllexport) WINAPI
#define WMIAPI WINAPI
#else
#define WMIAPI __declspec(dllimport) WINAPI
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef enum _tagEVENT_SOURCE_MSG
{
    ESM_START_SENDING_EVENTS,
    ESM_STOP_SENDING_EVENTS,
    ESM_NEW_QUERY,
    ESM_CANCEL_QUERY,
    ESM_ACCESS_CHECK,
} EVENT_SOURCE_MSG;

typedef HRESULT (WINAPI *LPEVENT_SOURCE_CALLBACK)(HANDLE, EVENT_SOURCE_MSG, LPVOID, LPVOID);
    
typedef struct _tagES_ACCESS_CHECK
{
    LPCWSTR szQueryLanguage;
    LPCWSTR szQuery;
    DWORD   dwSidLen;
    LPBYTE  pSid;
} ES_ACCESS_CHECK;

typedef struct _tagES_NEW_QUERY
{
    DWORD   dwID;
    LPCWSTR szQueryLanguage;
    LPCWSTR szQuery;
} ES_NEW_QUERY;

typedef struct _tagES_CANCEL_QUERY
{
    DWORD dwID;
} ES_CANCEL_QUERY;

typedef long CIMTYPE;

// Flags for all Create functions
#define WMI_CREATEOBJ_LOCKABLE              1

// Flags for WmiSetAndCommit
#define WMI_SENDCOMMIT_SET_NOT_REQUIRED     1
#define WMI_USE_VA_LIST                     2


#ifndef __WbemClient_v1_LIBRARY_DEFINED__
typedef /* [v1_enum] */ 
enum tag_CIMTYPE_ENUMERATION
    {	CIM_ILLEGAL	= 0xfff,
	CIM_EMPTY	= 0,
	CIM_SINT8	= 16,
	CIM_UINT8	= 17,
	CIM_SINT16	= 2,
	CIM_UINT16	= 18,
	CIM_SINT32	= 3,
	CIM_UINT32	= 19,
	CIM_SINT64	= 20,
	CIM_UINT64	= 21,
	CIM_REAL32	= 4,
	CIM_REAL64	= 5,
	CIM_BOOLEAN	= 11,
	CIM_STRING	= 8,
	CIM_DATETIME	= 101,
	CIM_REFERENCE	= 102,
	CIM_CHAR16	= 103,
	CIM_OBJECT	= 13,
	CIM_IUNKNOWN	= 104,
	CIM_FLAG_ARRAY	= 0x2000
    }	CIMTYPE_ENUMERATION;
#endif

// Register to send events
HANDLE WMIAPI WmiEventSourceConnect(
    LPCWSTR szNamespace,
    LPCWSTR szProviderName,
    BOOL bBatchSend,
    DWORD dwBatchBufferSize,
    DWORD dwMaxSendLatency,
    LPVOID pUserData,
    LPEVENT_SOURCE_CALLBACK pCallback);

HANDLE WMIAPI WmiCreateRestrictedConnection(
    HANDLE hSource,
    DWORD nQueries,
    LPCWSTR *szQueries,
    LPVOID pUserData,
    LPEVENT_SOURCE_CALLBACK pCallback);

BOOL WMIAPI WmiSetConnectionSecurity(
    HANDLE hSource,
    SECURITY_DESCRIPTOR *pSD);

void WMIAPI WmiEventSourceDisconnect(
    HANDLE hSource);

HANDLE WMIAPI WmiCreateObject(
    HANDLE hSource,
    LPCWSTR szClassName,
    DWORD dwFlags);

HANDLE WMIAPI WmiCreateObjectFromBuffer(
    HANDLE hSource,
    DWORD dwFlags,
    LPVOID pLayoutBuffer,
    DWORD dwLayoutSize,
    LPVOID pDataBuffer,
    DWORD dwDataSize);

BOOL WMIAPI WmiCommitObject(
    HANDLE hObject);

BOOL WMIAPI WmiResetObject(
    HANDLE hObject);

BOOL WMIAPI WmiDestroyObject(
    HANDLE hObject);

HANDLE WMIAPI WmiCreateObjectWithProps(
    HANDLE hSource,
    LPCWSTR szEventName,
    DWORD dwFlags,
    DWORD nPropertyCount,
    LPCWSTR *pszPropertyNames,
    CIMTYPE *pPropertyTypes);

HANDLE WMIAPI WmiCreateObjectWithFormat(
    HANDLE hSource,
    LPCWSTR szEventName,
    DWORD dwFlags,
    LPCWSTR szFormat);

HANDLE WMIAPI WmiCreateObjectPropSubset(
    HANDLE hObject,
    DWORD dwFlags,
    DWORD nPropertyCount,
    DWORD *pdwPropIndexes);

BOOL WMIAPI WmiAddObjectProp(
    HANDLE hObject,
    LPCWSTR szPropertyName,
    CIMTYPE type,
    DWORD *pdwPropIndex);

BOOL WMIAPI WmiSetObjectProp(
    HANDLE hObject,
    DWORD dwPropIndex,
    ...);

BOOL WMIAPI WmiGetObjectProp(
    HANDLE hObject,
    DWORD dwPropIndex,
    LPVOID pData,
    DWORD dwBufferSize,
    DWORD *pdwBytesRead);

BOOL WMIAPI WmiSetObjectPropNull(
    HANDLE hObject,
    DWORD dwPropIndex);

BOOL WMIAPI WmiSetObjectProps(
    HANDLE hObject,
    ...);

BOOL WMIAPI WmiSetAndCommitObject(
    HANDLE hObject,
    DWORD dwFlags,
    ...);

BOOL WMIAPI WmiReportEvent(
    HANDLE hConnection,
    LPCWSTR szClassName,
    LPCWSTR szFormat,
    ...);

BOOL WMIAPI WmiGetObjectBuffer(
    HANDLE hObject,
    LPVOID *ppLayoutBuffer,
    DWORD *pdwLayoutSize,
    LPVOID *ppDataBuffer,
    DWORD *pdwDataSize);

BOOL WMIAPI WmiReportEventBlob(
    HANDLE hConnection,
    LPCWSTR szClassName,
    LPVOID pData,
    DWORD dwSize);

void WMIAPI WmiLockObject(HANDLE hObject);

void WMIAPI WmiUnlockObject(HANDLE hObject);

HANDLE WMIAPI WmiDuplicateObject(
    HANDLE hOldObject,
    HANDLE hNewSource,
    DWORD dwFlags);

BOOL WMIAPI WmiIsObjectActive(HANDLE hObject);

BOOL WMIAPI WmiSetObjectSecurity(
    HANDLE hObject,
    SECURITY_DESCRIPTOR *pSD);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncobjapi\connection.cpp ===
// Connection.cpp

#include "precomp.h"
#include "Connection.h"
#include "Event.h"

#include "Transport.h"
#include "NamedPipe.h"
#include "Inproc.h"

#include "NCDefs.h"
#include "dutils.h"

#define DEF_BATCH_BUFFER_SIZE  131072
#define DEF_SEND_LATENCY       1000
 
/////////////////////////////////////////////////////////////////////////////
// CSink

#ifdef USE_SD
CSink::CSink() :
    m_bufferSD(0)
#else
CSink::CSink()
#endif
{
    InitializeCriticalSection(&m_cs);
}

CSink::~CSink()
{
    // Make sure none of the still alive events are referencing us.
    {
        CInCritSec cs(&m_cs);

        for (CEventListIterator event = m_listEvents.begin();
            event != m_listEvents.end(); event++)
        {
            CEvent *pEvent = *event;

            pEvent->m_pSink = NULL;
        }
    }

    DeleteCriticalSection(&m_cs);
}

BOOL CSink::Init(
    CConnection *pConnection, 
    DWORD dwSinkID,
    LPVOID pUserData,
    LPEVENT_SOURCE_CALLBACK pCallback)
{
    m_pConnection = pConnection;
    m_dwSinkID = dwSinkID;
    m_pUserData = pUserData;
    m_pCallback = pCallback;

    return TRUE;
}

void CSink::AddEvent(CEvent *pEvent)
{
    CInCritSec cs(&m_cs);

    m_listEvents.push_back(pEvent);
}

void CSink::RemoveEvent(CEvent *pEvent)
{
    CInCritSec cs(&m_cs);

    m_listEvents.remove(pEvent);
}

void CSink::ResetEventBufferLayoutSent()
{
    CInCritSec cs(&m_cs);

    for (CEventListIterator i = m_listEvents.begin();
        i != m_listEvents.end(); i++)
    {
        CEvent *pEvent = *i;

        pEvent->ResetLayoutSent();
#ifdef USE_SD
        pEvent->ResetSDSent();
#endif
        pEvent->SetEnabled(FALSE);
    }
}

void CSink::EnableAndDisableEvents()
{
    // For each event, set its enabled value.
    for (CEventListIterator i = m_listEvents.begin(); 
        i != m_listEvents.end(); 
        i++)
    {
        CEvent *pEvent = *i;

        EnableEventUsingList(pEvent);
    }
}

void CSink::AddToEnabledEventList(CBuffer *pBuffer)
{
    DWORD dwLen;

    // Add the event names to our enabled map.
    for (LPCWSTR szCurrentEvent = pBuffer->ReadAlignedLenString(&dwLen);
        *szCurrentEvent != 0;
        szCurrentEvent = pBuffer->ReadAlignedLenString(&dwLen))
    {
        m_mapEnabledEvents[szCurrentEvent] = 1;

        TRACE("Enabled: %S", szCurrentEvent);
    }

    EnableAndDisableEvents();
}

void CSink::RemoveFromEnabledEventList(CBuffer *pBuffer)
{
    DWORD dwLen;

    for (LPCWSTR szCurrentEvent = pBuffer->ReadAlignedLenString(&dwLen);
        *szCurrentEvent != 0;
        szCurrentEvent = pBuffer->ReadAlignedLenString(&dwLen))
    {
        m_mapEnabledEvents.erase(szCurrentEvent);    

        TRACE("Disabled: %S", szCurrentEvent);
    }

    EnableAndDisableEvents();
}

BOOL CSink::IsEventClassEnabled(LPCWSTR szEventClass)
{
    BOOL  bEnable;
    WCHAR szTempClassName[1024];

    if (szEventClass)
    {
        wcscpy(szTempClassName, szEventClass);
        _wcsupr(szTempClassName);

        bEnable =
            m_mapEnabledEvents.find(szTempClassName) != m_mapEnabledEvents.end();
    }
    else
        bEnable = FALSE;

    return bEnable;
}

void CSink::EnableEventUsingList(CEvent *pEvent)
{
    BOOL bEnable;

    bEnable = IsEventClassEnabled(pEvent->GetClassName());

    pEvent->SetEnabled(bEnable);
}

#ifdef USE_SD
BOOL CSink::SetSD(SECURITY_DESCRIPTOR *pSD)
{
    SECURITY_DESCRIPTOR *pSDRelative;
    BOOL                bRet,
                        bFree;

    if (GetRelativeSD(pSD, &pSDRelative, &bFree))
    {
        DWORD dwLen = GetSecurityDescriptorLength(pSDRelative);

        {
            CInCritSec cs(&m_cs);


            m_bufferSD.Reset(dwLen + sizeof(DWORD) * 3);
        
            m_bufferSD.Write((DWORD) NC_SRVMSG_SET_SINK_SD);
            m_bufferSD.Write(GetSinkID());
            m_bufferSD.Write(dwLen);
            m_bufferSD.Write(pSDRelative, dwLen);

            if (m_pConnection->IsReady())
            {
                m_pConnection->m_pTransport->SendData(
                    m_bufferSD.m_pBuffer,
                    m_bufferSD.GetUsedSize());
            }
        }

        bRet = TRUE;

        if (bFree)
            delete pSDRelative;
    }
    else
        bRet = FALSE;

    return bRet;
}
#endif

BOOL CSink::AddRestrictions(DWORD nQueries, LPCWSTR *pszQueries)
{
    DWORD nLenNeeded = sizeof(DWORD) * 2;

    for (DWORD i = 0; i < nQueries; i++)
        nLenNeeded += (wcslen(pszQueries[i]) + 1) * sizeof(WCHAR);

    // Grow the buffer to the right size.
    m_bufferRestrictions.Reset(nLenNeeded);
    
    m_bufferRestrictions.Write((DWORD) NC_SRVMSG_RESTRICTED_SINK);
    m_bufferRestrictions.Write(GetSinkID());
    m_bufferRestrictions.Write(nQueries);
    
    for (i = 0; i < nQueries; i++)
        m_bufferRestrictions.Write(pszQueries[i]);

    // Send the restrictions if our connection is ready.
    if (GetConnection()->IsReady())
    {
        GetConnection()->m_pTransport->SendData(
                m_bufferRestrictions.m_pBuffer,
                m_bufferRestrictions.GetUsedSize());
    }

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CConnection

CConnection::CConnection(BOOL bBatchSend, DWORD dwBatchBufferSize, 
    DWORD dwMaxSendLatency) :
    m_bDone(FALSE),
    m_bUseBatchSend(bBatchSend),
    m_dwSendLatency(dwMaxSendLatency ? dwMaxSendLatency : DEF_SEND_LATENCY),
    m_heventBufferNotFull(NULL),
    m_heventBufferFull(NULL),
    m_heventEventsPending(NULL),
    m_heventDone(NULL),
    m_hthreadSend(NULL),
    m_pTransport(NULL),
    m_hthreadWMIInit(NULL),
    m_heventWMIInit(NULL),
    m_bWMIResync(TRUE),
    m_dwNextSinkID(1)
{
    if (bBatchSend)
    {
        if (dwBatchBufferSize == 0)
            dwBatchBufferSize = DEF_BATCH_BUFFER_SIZE;

        m_bufferSend.Reset(dwBatchBufferSize);
    }
    else
        m_bufferSend.Reset(DEF_BATCH_BUFFER_SIZE);
}

CConnection::~CConnection()
{
    Deinit();
}

void CConnection::GetBaseName(LPCWSTR szName, LPWSTR szBase)
{
    wcscpy(szBase, szName);
    _wcsupr(szBase);

    // Get rid of the '\' chars since we can't use it in OS object names.
    for (WCHAR *szCurrent = szBase; *szCurrent; szCurrent++)
    {
        if (*szCurrent == '\\')
            *szCurrent = '/';
    }
}

BOOL CConnection::Init(
    LPCWSTR szNamespace, 
    LPCWSTR szProviderName,
    LPVOID pUserData,
    LPEVENT_SOURCE_CALLBACK pCallback)
{
    if (!m_sinkMain.Init(this, 0, pUserData, pCallback))
        return FALSE;
    
    GetBaseName(szNamespace, m_szBaseNamespace);
    GetBaseName(szProviderName, m_szBaseProviderName);

    try
    {
        InitializeCriticalSection(&m_cs);

        // The rest of these are for batch sending.
        InitializeCriticalSection(&m_csBuffer);
    }
    catch(...)
    {
        return FALSE;
    }
    

    m_heventDone =
        CreateEvent(
            NULL,
            TRUE,
            FALSE,
            NULL);
    if(m_heventDone == NULL)
        return FALSE;

    m_heventBufferNotFull =
        CreateEvent(
            NULL,
            TRUE,
            TRUE,
            NULL);
    if(m_heventBufferNotFull == NULL)
        return FALSE;

    m_heventBufferFull =
        CreateEvent(
            NULL,
            TRUE,
            FALSE,
            NULL);
    if(m_heventBufferFull == NULL)
        return FALSE;

    m_heventEventsPending =
        CreateEvent(
            NULL,
            TRUE,
            FALSE,
            NULL);
    if(m_heventEventsPending == NULL)
        return FALSE;

    if(!StartWaitWMIInitThread())
        return FALSE;

    return TRUE;
}

BOOL CConnection::StartWaitWMIInitThread()
{
    TRACE("Entered StartWaitWMIInitThread.");

    m_heventWMIInit =
        OpenEventW(
            SYNCHRONIZE,
            FALSE,
            WMI_INIT_EVENT_NAME);

    if (!m_heventWMIInit)
    {
        PSECURITY_DESCRIPTOR pSD = NULL;
        DWORD                dwSize;

        ConvertStringSecurityDescriptorToSecurityDescriptorW(
            ESS_EVENT_SDDL,  // security descriptor string
            SDDL_REVISION_1, // revision level
            &pSD,            // SD
            &dwSize);

        SECURITY_ATTRIBUTES sa = { sizeof(sa), pSD, FALSE };

        m_heventWMIInit =
            CreateEventW(
                &sa,
                TRUE,
                FALSE,
                WMI_INIT_EVENT_NAME);

        if (pSD)
            LocalFree((HLOCAL) pSD);

        if (!m_heventWMIInit)
        {
            TRACE("Couldn't create ESS ready event: %d", GetLastError());
            return FALSE;
        }
    }

    if (WaitForSingleObject(m_heventWMIInit, 0) == 0)
    {
        TRACE("ESS event was already set, so going to init transport...");

        if(!InitTransport())
            return FALSE;
    }
    else
    {
        DWORD dwID;

        TRACE("Creating WaitWMIInitThreadProc thread.");

        m_hthreadWMIInit =
            CreateThread(
                NULL,
                0,
                (LPTHREAD_START_ROUTINE) WaitWMIInitThreadProc,
                this,
                0,
                &dwID);

        if(m_hthreadWMIInit == NULL)
            return FALSE;
    }

    return TRUE;
}

#define COUNTOF(x)  (sizeof(x)/sizeof(x[0]))

BOOL CConnection::InitTransport()
{
    if ( m_pTransport != NULL )
    {
        return TRUE;
    }

    TRACE("Entered InitTransport.");

    // Figure out which transport to use.
    WCHAR szFullFileName[MAX_PATH * 2] = L"",
          *szFileName;
    BOOL  bRet;

    TRACE("Entered InitTransport.");

    GetModuleFileNameW(
            NULL, szFullFileName, COUNTOF(szFullFileName));
    szFileName = wcsrchr(szFullFileName, '\\');

	try
	{
		if (!szFileName || _wcsicmp(szFileName + 1, L"WINMGMT.EXE"))
			m_pTransport = new CNamedPipeClient;
		else
			m_pTransport = new CInprocClient;
	}
	catch(...)
	{
		// this page intentionally left blank - m_pTransport will still be NULL.
	}

    if (m_pTransport)
    {
        m_pTransport->SetConnection(this);
        m_pTransport->Init(m_szBaseNamespace, m_szBaseProviderName);

        bRet = TRUE;
    }
    else
        bRet = FALSE;

    return bRet;
}

DWORD CConnection::WaitWMIInitThreadProc(CConnection *pThis)
{
    TRACE("Entered WaitWMIInitThreadProc");

    HANDLE hWait[2] = { pThis->m_heventDone, pThis->m_heventWMIInit };
    DWORD  dwWait;

    dwWait = WaitForMultipleObjects(2, hWait, FALSE, INFINITE);

    if (dwWait == 1)
    {
        TRACE("ESS event fired, going to init transport");

        // If WMI is now ready, startup our transport.
        pThis->InitTransport();
        pThis->m_bWMIResync = FALSE;
    }
    else
    {
        TRACE("dwWait in WaitWMIInitThreadProc = %d", dwWait);
    }

    return 0;
}    

BOOL CConnection::ResyncWithWMI()
{
    m_bWMIResync = TRUE;

    StopThreads();

    ResetEvent( m_heventDone) ;

    m_hthreadWMIInit = CreateThread(
                                NULL,
                                0,
                                (LPTHREAD_START_ROUTINE)WaitWMIInitThreadProc,
                                this,
                                0,
                                NULL );

    return m_hthreadWMIInit != NULL ? TRUE : FALSE;
}

void CConnection::StopThreads()
{
    if (m_hthreadSend)
    {
        BOOL bDoneSending;

        do
        {
            Lock();

            bDoneSending = m_bufferSend.GetUsedSize() == 0;

            // If there's still stuff left to send, make sure it
            // gets sent.
            if (bDoneSending)
            {
                SetEvent(m_heventDone);

                Unlock();

                WaitForSingleObject(m_hthreadSend, INFINITE);

                CloseHandle(m_hthreadSend);
                m_hthreadSend = NULL;
            }
            else
            {
                SetEvent(m_heventBufferFull);

                Unlock();

                // Sleep a little to give the send thread a chance to do its 
                // thing.
                Sleep(1);
            }

        } while (!bDoneSending);
    }

    if ( m_hthreadWMIInit != NULL )
    {
        SetEvent(m_heventDone);
        WaitForSingleObject(m_hthreadWMIInit, INFINITE);
        CloseHandle(m_hthreadWMIInit);
    }

    m_hthreadWMIInit = NULL;
    m_hthreadSend = NULL;
}
    
void CConnection::Deinit()
{
    m_bDone = TRUE;
    
    StopThreads();

    if (m_heventWMIInit)
        CloseHandle(m_heventWMIInit);

    CloseHandle(m_heventDone);
    CloseHandle(m_heventBufferNotFull);
    CloseHandle(m_heventBufferFull);
    CloseHandle(m_heventEventsPending);

    // Give the transport a chance to clean up.
    if (m_pTransport)
        m_pTransport->Deinit();

    // Make sure no sinks are referencing us anymore.
    for (CSinkMapIterator i = m_mapSink.begin();
        i != m_mapSink.end(); 
        i++)
    {
        CSink *pSink = (*i).second;

        pSink->m_pConnection = NULL;
    }

    DeleteCriticalSection(&m_csBuffer);
    DeleteCriticalSection(&m_cs);
}

BOOL CConnection::StartSendThread()
{
    DWORD dwID;
    
    m_hthreadSend =
        CreateThread(
            NULL,
            0,
            (LPTHREAD_START_ROUTINE) SendThreadProc,
            this,
            0,
            &dwID);
    if(m_hthreadSend == NULL)
        return FALSE;

    return TRUE;
}

DWORD WINAPI CConnection::SendThreadProc(CConnection *pThis)
{
    HANDLE           hWait[2] = { pThis->m_heventDone, pThis->m_heventEventsPending },
                     hwaitSendLatency[2] = { pThis->m_heventDone, pThis->m_heventBufferFull },
                     heventBufferNotFull = pThis->m_heventBufferNotFull;
    DWORD            dwSendLatency = pThis->m_dwSendLatency;
    LPBYTE           pData = pThis->m_bufferSend.m_pBuffer;
    CBuffer          *pBuffer = &pThis->m_bufferSend;
    CRITICAL_SECTION *pCS = &pThis->m_csBuffer;

    while (WaitForMultipleObjects(2, hWait, FALSE, INFINITE) != 0)
    {
        // If we have a send latency, wait for that time or until the send 
        // buffer is full.  If the done event fires, get out.
        if (dwSendLatency)
        {
            if (WaitForMultipleObjects(2, hwaitSendLatency, FALSE, 
                dwSendLatency) == 0)
                break;

            // Reset m_heventBufferFull.
            ResetEvent(hwaitSendLatency[1]);
        }

        EnterCriticalSection(pCS);
    
        pThis->SendDataOverTransports(
            pData, 
            pBuffer->GetUsedSize());

        pBuffer->Reset();

        SetEvent(heventBufferNotFull);

        // Reset m_heventEventsPending
        ResetEvent(hWait[1]);

        LeaveCriticalSection(pCS);
    }

    return 0;
}

//#define NO_SEND

BOOL CConnection::IndicateProvEnabled()
{
    // Get out if we're already done.
    if (m_bDone)
        return TRUE;

    CInCritSec cs(&m_cs);

    // Tell the callback that the provider is now activated.
    if (m_sinkMain.m_pCallback)
        m_sinkMain.m_pCallback(
            (HANDLE) this, ESM_START_SENDING_EVENTS, m_sinkMain.m_pUserData, NULL);

    // Tell the server about us.
    if(!SendInitInfo())
        return FALSE;


    // See if we've buffered any events while we were waiting for WMI to come
    // up.  If we did, send them on their way.
    DWORD dwSize;

    EnterCriticalSection(&m_csBuffer);

    dwSize = m_bufferSend.GetUsedSize();
    
    if (dwSize)
    {
        m_pTransport->SendData(m_bufferSend.m_pBuffer, dwSize);
        m_bufferSend.Reset();
    }
        
    LeaveCriticalSection(&m_csBuffer);


    if (m_bUseBatchSend && m_hthreadSend == NULL)
        return StartSendThread();
    else
        return TRUE;
}

void CConnection::IndicateProvDisabled()
{
    // Get out if we're already done.
    if (m_bDone)
        return;

    CInCritSec cs(&m_cs);

    for (CSinkMapIterator i = m_mapSink.begin();
        i != m_mapSink.end();
        i++)
    {
        CSink *pSink = (*i).second;

        pSink->ResetEventBufferLayoutSent();

        if (pSink->m_pCallback)
        {
            pSink->m_pCallback(
                (HANDLE) pSink, 
                ESM_STOP_SENDING_EVENTS, 
                pSink->m_pUserData, 
                NULL);
        }
    }

    // Tell the callback that the provider is now deactivated.
    m_sinkMain.ResetEventBufferLayoutSent();

    if (m_sinkMain.m_pCallback)
    {
        m_sinkMain.m_pCallback(
            (HANDLE) &m_sinkMain, 
            ESM_STOP_SENDING_EVENTS, 
            m_sinkMain.m_pUserData, 
            NULL);
    }

    ResyncWithWMI();
}

BOOL CConnection::SendData(LPBYTE pBuffer, DWORD dwSize)
{
    // Make sure this event isn't too big.
    if (dwSize > m_bufferSend.m_dwSize)
        return FALSE;

    if (m_bUseBatchSend || WaitingForWMIInit())
    {
        BOOL bRet = FALSE;

        do
        {
            BOOL bWasEmpty;

            EnterCriticalSection(&m_csBuffer);

            // See if we have enough room to add our event.
            if (dwSize <= m_bufferSend.GetUnusedSize())
            {
                bWasEmpty = m_bufferSend.GetUsedSize() == 0;

                m_bufferSend.Write(pBuffer, dwSize);

                bRet = TRUE;

                if (bWasEmpty)
                    SetEvent(m_heventEventsPending);

                LeaveCriticalSection(&m_csBuffer);
            }
            else
            {
                // If we're not waiting for WMI to initialize, we just need to
                // wait for the send thread to finish sending what's in our
                // buffer.
                if (!WaitingForWMIInit())
                {
                    // Wake up the send latency thread if necessary.
                    if (m_dwSendLatency)
                        SetEvent(m_heventBufferFull);
                
                    // So we'll block until the send thread sets the event.
                    ResetEvent(m_heventBufferNotFull);

                    LeaveCriticalSection(&m_csBuffer);

                    WaitForSingleObject(m_heventBufferNotFull, INFINITE);
                }
                // If we're still waiting for WMI to initialize but our buffer
                // is full, we need to remove an event to make some room.  Make
                // sure we only remove event data and not any buffer layouts.
                else
                {
                    LPBYTE pCurrent = m_bufferSend.m_pBuffer;
                    
                    bRet = FALSE;

                    do
                    {
                        // The message is always the 1st, the size 2nd.
                        DWORD dwMsg = *(DWORD*) pCurrent,
                              dwMsgSize = ((DWORD*) pCurrent)[1];
                    
#ifdef USE_SD
                        if (dwMsg != NC_SRVMSG_EVENT_LAYOUT && 
                            dwMsg != NC_SRVMSG_SET_EVENT_SD)
#else
                        if (dwMsg != NC_SRVMSG_EVENT_LAYOUT)
#endif
                        {
                            // Move back all the data that comes after this event.
                            memmove(
                                pCurrent, 
                                pCurrent + dwMsgSize, 
                                m_bufferSend.m_pCurrent - pCurrent - dwMsgSize);

                            m_bufferSend.m_pCurrent -= dwMsgSize;

                            // If we finally made enough room, copy in the data
                            // and get out.
                            if (dwSize <= m_bufferSend.GetUnusedSize())
                            {
                                m_bufferSend.Write(pBuffer, dwSize);

                                bRet = TRUE;
                            }
                        }
                        else
                            pCurrent += dwMsgSize;
                    
                    } while (pCurrent < m_bufferSend.m_pCurrent && !bRet);
                                            
                    LeaveCriticalSection(&m_csBuffer);

                    // If after going through the buffer we couldn't make 
                    // enough room for this event, return FALSE and get out.
                    if (!bRet)
                        break;
                }
            } // else from if (dwSize <= m_bufferSend.GetUnusedSize())
        } while (!bRet);

        return bRet;
    }
    else
        return SendDataOverTransports(pBuffer, dwSize);
}

BOOL CConnection::SendDataOverTransports(LPBYTE pBuffer, DWORD dwSize)
{
    if (m_pTransport->IsReady())
        m_pTransport->SendData(pBuffer, dwSize);

    return TRUE;
}

BOOL CConnection::SendInitInfo()
{
    BYTE    cBuffer[sizeof(DWORD) * 2];
    CBuffer buffer(cBuffer, sizeof(cBuffer), CBuffer::ALIGN_DWORD);
    BOOL    bRet;

    buffer.Write((DWORD) NC_SRVMSG_CLIENT_INFO);
    buffer.Write((DWORD) (m_bUseBatchSend ? m_bufferSend.m_dwSize : MAX_EVENT_SIZE));
    
    if(!m_pTransport->InitCallback())
        return FALSE;
    
    bRet = m_pTransport->SendData(cBuffer, buffer.GetUsedSize());

#ifdef USE_SD
    // Send the main SD, if any.
    if (m_sinkMain.m_bufferSD.GetUsedSize())
    {
        bRet = 
            m_pTransport->SendData(
                m_sinkMain.m_bufferSD.m_pBuffer,
                m_sinkMain.m_bufferSD.GetUsedSize());
    }
#endif

    // Send the restricted sinks restrictions and SDs.
    for (CSinkMapIterator i = m_mapSink.begin(); 
        bRet && i != m_mapSink.end(); 
        i++)
    {
        CSink *pSink = (*i).second;

        bRet = 
            m_pTransport->SendData(
                pSink->m_bufferRestrictions.m_pBuffer,
                pSink->m_bufferRestrictions.GetUsedSize());

#ifdef USE_SD
        if (pSink->m_bufferSD.GetUsedSize())
        {
            bRet = 
                m_pTransport->SendData(
                    pSink->m_bufferSD.m_pBuffer,
                    pSink->m_bufferSD.GetUsedSize());
        }
#endif
    }

    return bRet;
}

HRESULT CConnection::ProcessMessage(LPBYTE pData, DWORD dwSize)
{
    // Get out if we're already done.
    if (m_bDone)
        return S_OK;

    DWORD     *pdwMsg = (DWORD*) pData;
    DWORD     *pdwSinkID = (DWORD*) (pdwMsg + 1);
    
    DWORD_PTR dwMsgCookie;
    memcpy( &dwMsgCookie, pdwMsg+2, sizeof(dwMsgCookie) );

    LPBYTE    pMsgBits = (LPBYTE)(pData+sizeof(DWORD)*2+sizeof(DWORD_PTR));
    CBuffer   buffer(pMsgBits, dwSize - sizeof(DWORD)*2 - sizeof(DWORD_PTR));
    HRESULT   hr = S_OK; 
    DWORD     dwLen;

    switch(*pdwMsg)
    {
        case NC_CLIMSG_ACCESS_CHECK_REQ:
        {
            ES_ACCESS_CHECK check;

            check.szQueryLanguage = buffer.ReadAlignedLenString(&dwLen);

            check.szQuery = buffer.ReadAlignedLenString(&dwLen);

            check.dwSidLen = buffer.ReadDWORD();
            
            if (check.dwSidLen != 0)
                check.pSid = buffer.m_pCurrent;
            else
                check.pSid = NULL;

            if (m_sinkMain.m_pCallback)
            {
                hr =
                    m_sinkMain.m_pCallback(
                        (HANDLE) &m_sinkMain, 
                        ESM_ACCESS_CHECK, 
                        m_sinkMain.m_pUserData, 
                        &check);
            }

            NC_SRVMSG_REPLY reply = { NC_SRVMSG_ACCESS_CHECK_REPLY, 
                                        hr, dwMsgCookie };
                    
            m_pTransport->SendMsgReply(&reply);

            break;
        }

        case NC_CLIMSG_NEW_QUERY_REQ:
        {
            ES_NEW_QUERY query;
            CSink        *pSink = GetSink(*pdwSinkID);

            if (pSink)
            {
                query.dwID = buffer.ReadDWORD();
                query.szQueryLanguage = buffer.ReadAlignedLenString(&dwLen);
                query.szQuery = buffer.ReadAlignedLenString(&dwLen);

                // This is the list of event class names that are now
                // enabled thanks to this query.
                pSink->AddToEnabledEventList(&buffer);

                if (pSink->m_pCallback)
                {
                    hr =
                        pSink->m_pCallback(
                            (HANDLE) pSink, ESM_NEW_QUERY, pSink->m_pUserData, &query);
                }
            }
            else
                TRACE("Sink %d not found.", *pdwSinkID);

            m_pTransport->SendMsgReply(NULL);

            break;                    
        }

        case NC_CLIMSG_CANCEL_QUERY_REQ:
        {
            ES_CANCEL_QUERY query;
            CSink           *pSink = GetSink(*pdwSinkID);

            if (pSink)
            {
                query.dwID = buffer.ReadDWORD();

                // This is the list of event class names that are now
                // disabled thanks to this query.
                pSink->RemoveFromEnabledEventList(&buffer);

                if (pSink->m_pCallback)
                {
                    hr =
                        pSink->m_pCallback(
                            (HANDLE) pSink, ESM_CANCEL_QUERY, pSink->m_pUserData, 
                            &query);

                    m_pTransport->SendMsgReply(NULL);

                    break;                    
                }
                else
                    hr = S_OK;
            }
            else
                TRACE("Sink %d not found.", *pdwSinkID);

            break;
        }

        case NC_CLIMSG_PROVIDER_UNLOADING:
            TRACE("Got the NC_CLIMSG_PROVIDER_UNLOADING message.");

            // Give our named pipe client a chance to go see if it 
            // should deactivate itself (if the server doesn't need
            // us anymore).
            m_pTransport->SignalProviderDisabled();

            hr = S_OK;

            break;

        default:
            TRACE("Bad message from server!");
            break;    
    } // switch(*(DWORD*)cBuffer)

    return hr;
}

#ifdef USE_SD
// Security helper
BOOL GetRelativeSD(
    SECURITY_DESCRIPTOR *pSDIn, 
    SECURITY_DESCRIPTOR **ppSDOut,
    BOOL *pbFree)
{
    SECURITY_DESCRIPTOR_CONTROL ctrl;
    BOOL                        bRet;
    DWORD                       dwRev;

    bRet =
        GetSecurityDescriptorControl(
            pSDIn,
            &ctrl,
            &dwRev);

    if (bRet)
    {
        if (ctrl & SE_SELF_RELATIVE)
        {
            *ppSDOut = pSDIn;
            *pbFree = FALSE;
        }
        else
        {
            DWORD dwSizeNeeded = 0;

            // Until we prove otherwise...
            bRet = FALSE;

            MakeSelfRelativeSD(
                pSDIn,
                pSDIn,
                &dwSizeNeeded);

            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                *ppSDOut = (SECURITY_DESCRIPTOR*) new BYTE[dwSizeNeeded];
                
                if (*ppSDOut)
                {
                    bRet =
                        MakeSelfRelativeSD(
                            pSDIn,
                            *ppSDOut,
                            &dwSizeNeeded);

                    *pbFree = TRUE;
                }
            }
        }
    }

    return bRet;
}
#endif

CSink *CConnection::CreateSink(
    LPVOID pUserData, 
    LPEVENT_SOURCE_CALLBACK pCallback)
{
    CInCritSec cs(&m_cs);

    DWORD dwID = m_dwNextSinkID;
    CSink *pSink = new CSink;
    
    if (pSink && pSink->Init(this, dwID, pUserData, pCallback))
    {
        m_mapSink[dwID] = pSink;
        m_dwNextSinkID++;
    }

    return pSink;
}

CSink *CConnection::GetSink(DWORD dwID)
{
    if (dwID == 0)
        return &m_sinkMain;
    else
    {
        CInCritSec cs(&m_cs);
    
        CSinkMapIterator i = m_mapSink.find(dwID);
        CSink            *pSink;

        if (i != m_mapSink.end())
            pSink = (*i).second;
        else
            pSink = NULL;

        return pSink;
    }
}

void CConnection::RemoveSink(CSink *pSink)
{
    CInCritSec cs(&m_cs);

    for (CSinkMapIterator i = m_mapSink.begin(); i != m_mapSink.end(); i++)
    {
        if ((*i).second == pSink)
        {
            m_mapSink.erase(i);

            pSink->m_pConnection = NULL;

            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncobjapi\event.cpp ===
// Event.cpp
#include "precomp.h"
#include "buffer.h"
#include "Connection.h"
#include "Event.h"
#include "NCDefs.h"
#include <corex.h>

#define DEF_EVENT_DATA_SIZE   512
#define DEF_EVENT_LAYOUT_SIZE 256

#define DWORD_ALIGNED(x)    ((DWORD)((((x) * 8) + 31) & (~31)) / 8)

#define wbem_towlower(C) \
    (((C) >= 0 && (C) <= 127)?          \
        (((C) >= 'A' && (C) <= 'Z')?          \
            ((C) + ('a' - 'A')):          \
            (C)          \
        ):          \
        towlower(C)          \
    )

inline int wbem_wcsicmp(const wchar_t* wsz1, const wchar_t* wsz2)
{
    while(*wsz1 || *wsz2)
    {
        int diff = wbem_towlower(*wsz1) - wbem_towlower(*wsz2);
        if(diff) return diff;
        wsz1++; wsz2++;
    }

    return 0;
}

BOOL isunialpha(wchar_t c)
{
    if(c == 0x5f || (0x41 <= c && c <= 0x5a) ||
       (0x61  <= c && c <= 0x7a) || (0x80  <= c && c <= 0xfffd))
        return TRUE;
    else
        return FALSE;
}

BOOL isunialphanum(wchar_t c)
{
    if(isunialpha(c))
        return TRUE;
    else
        return iswdigit(c);
}

/////////////////////////////////////////////////////////////////////////////
// CPropInfo

BOOL CPropInfo::Init(CIMTYPE type)
{
    m_bPointer = FALSE;

    switch(type & ~CIM_FLAG_ARRAY)
    {
        case CIM_STRING:
        case CIM_REFERENCE:
        case CIM_DATETIME:
            m_pFunc = CEvent::AddStringW;
            m_dwElementSize = 1;
            m_bCountPrefixNeeded = TRUE;
            m_bPointer = TRUE;
            break;

        case CIM_REAL32:
            // We can't use AddDWORD because the compiler converts 32-bit 
            // floats to 64-bit doubles before pushing them on the stack.
            m_pFunc = CEvent::AddFloat;
            m_dwElementSize = sizeof(float);
            m_bCountPrefixNeeded = FALSE;
            break;

        case CIM_UINT32:
        case CIM_SINT32:
            m_pFunc = CEvent::AddDWORD;
            m_dwElementSize = sizeof(DWORD);
            m_bCountPrefixNeeded = FALSE;
            break;

        case CIM_UINT16:
        case CIM_SINT16:
        case CIM_CHAR16:
        case CIM_BOOLEAN:
            m_pFunc = CEvent::AddDWORD;
            m_dwElementSize = sizeof(DWORD);
            m_bCountPrefixNeeded = FALSE;
            break;

        case CIM_SINT64:
        case CIM_UINT64:
        case CIM_REAL64:
            m_pFunc = CEvent::AddDWORD64;
            m_dwElementSize = sizeof(__int64);
            m_bCountPrefixNeeded = FALSE;
            m_bPointer = TRUE;
            break;

        case CIM_UINT8:
        case CIM_SINT8:
            m_pFunc = CEvent::AddBYTE;
            m_dwElementSize = sizeof(BYTE);
            m_bCountPrefixNeeded = FALSE;
            break;

        case CIM_OBJECT:
            m_pFunc = CEvent::AddObject;
            m_dwElementSize = 1;
            m_bCountPrefixNeeded = TRUE;
            m_bPointer = TRUE;
            break;

        case CIM_IUNKNOWN:
            m_pFunc = CEvent::AddWmiObject;
            m_dwElementSize = 1;
            m_bCountPrefixNeeded = TRUE;
            m_bPointer = TRUE;
            break;

        default:
            // Bad type passed!
            return FALSE;
    }

    // Change some things if this is an array.
    if (type & CIM_FLAG_ARRAY)
    {
        m_bPointer = TRUE;

        // All arrays need to have the number of elements prefixed to the data.
        m_bCountPrefixNeeded = TRUE;

        if (m_pFunc == CEvent::AddStringW)
            m_pFunc = CEvent::AddStringArray;
        else if (m_pFunc == CEvent::AddObject)
            m_pFunc = CEvent::AddObjectArray;
        else if (m_pFunc == CEvent::AddWmiObject)
            // m_pFunc = CEvent::AddWmiObjectArray;
            return FALSE;
        else
            m_pFunc = CEvent::AddScalarArray;
    }

    if (m_bPointer == FALSE)
    {
        // We no longer need element size, since it's the same as current size.
        // So, set current size and clear element size so we'll ignore it.
        m_dwCurrentSize = m_dwElementSize;
        m_dwElementSize = 0;
    }
        
    return TRUE;
}

void CPropInfo::InitCurrentSize(LPBYTE pData)
{
    DWORD dwTotalSize;

    if (IsPointer())
    {
        DWORD dwItems = *(DWORD*)pData;

        if (m_pFunc != CEvent::AddObjectArray && 
            m_pFunc != CEvent::AddStringArray &&
            m_pFunc != CEvent::AddWmiObjectArray)
        {
            // This works for all pointer types except for object and string
            // arrays.
            dwTotalSize = dwItems * m_dwElementSize + sizeof(DWORD);
        }
        else
        {
            // Account for the number in the array.
            dwTotalSize = sizeof(DWORD);

            // For each item in the array, get its size and add it to the total
            // length.
            for (DWORD i = 0; i < dwItems; i++)
            {
                dwTotalSize += 
                    sizeof(DWORD) +
                    DWORD_ALIGNED(*(DWORD*) (pData + dwTotalSize));
            }
        }
    }
    else
        dwTotalSize = m_dwElementSize; 

    // Align the total size.
    m_dwCurrentSize = dwTotalSize;
}

/////////////////////////////////////////////////////////////////////////////
// CEventWrap

CEventWrap::CEventWrap(CSink *pSink, DWORD dwFlags) :
    m_bFreeEvent(TRUE)
{
    m_pEvent = new CEvent(pSink, dwFlags);
    
    if ( NULL == m_pEvent )
    {
        throw CX_MemoryException();
    }

    pSink->AddEvent(m_pEvent);
}

CEventWrap::CEventWrap(CEvent *pEvent, int nIndexes, DWORD *pdwIndexes) :
    m_bFreeEvent(FALSE)
{
    m_pEvent = pEvent;

    m_pIndexes.Init(nIndexes);
    for (int i = 0; i < nIndexes; i++)
        m_pIndexes.AddVal(pdwIndexes[i]);
}

CEventWrap::~CEventWrap()
{
    if (m_bFreeEvent && m_pEvent)
    {
        if (m_pEvent->m_pSink)
            m_pEvent->m_pSink->RemoveEvent(m_pEvent);

        delete m_pEvent;
    }
}

/////////////////////////////////////////////////////////////////////////////
// CEvent

CEvent::CEvent(CSink *pSink, DWORD dwFlags) :
    m_pSink(pSink),
    CBuffer(DEF_EVENT_DATA_SIZE),
    m_bufferEventLayout(DEF_EVENT_LAYOUT_SIZE),
#ifdef USE_SD
    m_bufferSD(0),
    m_bSDSent(TRUE),
#endif
    m_bLayoutSent(FALSE),
    m_bEnabled(FALSE),
    m_pProps(0),
    m_dwFlags(dwFlags)
{
    if (IsLockable())
        InitializeCriticalSection(&m_cs);
}

CEvent::~CEvent()
{
    if (IsLockable())
        DeleteCriticalSection(&m_cs);
}

void CEvent::ResetEvent()
{
    CCondInCritSec cs(&m_cs, IsLockable());

    // Clear all our data.
    m_pCurrent = (LPBYTE) m_pdwHeapData;
    
    // Zero out our null table to make everything null.
    ZeroMemory(m_pdwNullTable, m_pdwPropTable - m_pdwNullTable);
}

static DWORD g_dwEventIndex = 0;

BOOL CEvent::PrepareEvent(
    LPCWSTR szEventName,
    DWORD nPropertyCount,
    LPCWSTR *pszPropertyNames,
    CIMTYPE *pPropertyTypes)
{
    DWORD dwEventIndex = InterlockedExchangeAdd((long*) &g_dwEventIndex, 1);

    CCondInCritSec cs(&m_cs, IsLockable());

    // Setup the event layout buffer.
    m_bufferEventLayout.Reset();
    
    m_bufferEventLayout.Write((DWORD) NC_SRVMSG_EVENT_LAYOUT);
    
    // This serves as a place holder for the size of the message.
    m_bufferEventLayout.Write((DWORD) 0);
    
    m_bufferEventLayout.Write(dwEventIndex);

    m_bufferEventLayout.Write(m_pSink->GetSinkID());
    
    m_bufferEventLayout.Write(nPropertyCount);
    
    m_bufferEventLayout.WriteAlignedLenString(szEventName);
    
    
    // Make this upper case to simplify lookups.
    _wcsupr((LPWSTR) GetClassName());
    
    // Setup the main event buffer    
    Reset();

    Write((DWORD) NC_SRVMSG_PREPPED_EVENT);

    // This serves as a place holder for the size of the message.
    Write((DWORD) 0);

    Write(dwEventIndex);
    
    // This will setup our table pointers.
    RecalcTables();

    // Set mask to indicate all values are null.
    ZeroMemory(m_pdwNullTable, (LPBYTE) m_pdwPropTable - (LPBYTE) m_pdwNullTable);

    // Point our buffer to where we'll put all the object data.
    m_pCurrent = (LPBYTE) m_pdwHeapData;

    m_pProps.Init(nPropertyCount);
    m_pProps.SetCount(nPropertyCount);

    for (DWORD i = 0; i < nPropertyCount; i++)
    {
        CPropInfo &info = m_pProps[i];

        if(!info.Init(pPropertyTypes[i]))
            return FALSE;

        m_bufferEventLayout.Write((DWORD) pPropertyTypes[i]);
        m_bufferEventLayout.WriteAlignedLenString(pszPropertyNames[i]);
    }

    return TRUE;
}

BOOL CEvent::FindProp(LPCWSTR szName, CIMTYPE* ptype, DWORD* pdwIndex)
{
    CCondInCritSec cs(&m_cs, IsLockable());

    DWORD dwSize = 0;
    BYTE* pProps = NULL;

    GetLayoutBuffer(&pProps, &dwSize, FALSE);
    CBuffer Buffer(pProps, dwSize);
    
    //
    // Skip the name of the event
    //

    DWORD dwNumProps = Buffer.ReadDWORD();

    DWORD dwIgnore;
    Buffer.ReadAlignedLenString(&dwIgnore);

    for(DWORD i = 0; i < dwNumProps; i++)
    {
        *ptype = Buffer.ReadDWORD();
        LPCWSTR szThisName = Buffer.ReadAlignedLenString(&dwIgnore);

        if(!wbem_wcsicmp(szName, szThisName))
        {
            *pdwIndex = i;
            return TRUE;
        }
    }

    return FALSE;
}
        
BOOL CEvent::AddProp(LPCWSTR szName, CIMTYPE type, DWORD *pdwIndex)
{
    //
    // Check the name for validity
    //

    if(szName[0] == 0)
        return FALSE;
    
    const WCHAR* pwc = szName;
 
    // Check the first letter
    // ======================
 
    if(!isunialpha(*pwc) || *pwc == '_')
        return FALSE;
    pwc++;
 
    // Check the rest
    // ==============
    
    while(*pwc)
    {
        if(!isunialphanum(*pwc))
            return FALSE;
        pwc++;
    }
 
    if(pwc[-1] == '_')
        return FALSE;

    //
    // Check the type for validity
    //

    CPropInfo info;

    if(!info.Init(type))
        return FALSE;

    CCondInCritSec cs(&m_cs, IsLockable());

    //
    // Check if the property is already there
    //

    CIMTYPE typeOld;
    DWORD dwOldIndex;
    if(FindProp(szName, &typeOld, &dwOldIndex))
    {
        return FALSE;
    }
    
    // Our layout changed, so make sure we resend it.
    ResetLayoutSent();

    DWORD nProps = GetPropertyCount();
    BOOL  bExtraNullSpaceNeeded;
    DWORD dwHeapMove;

    // If the caller cares, return the index of this property.
    if (pdwIndex)
        *pdwIndex = nProps;
    
    // Increase the number of properties.
    SetPropertyCount(++nProps);
    
    // See if we need another DWORD for our null flags.
    bExtraNullSpaceNeeded = (nProps % 32) == 1 && nProps != 1;

    // Figure how many slots we need to move up the heap pointer.
    // Always one for the new property data/pointer, and maybe one
    // if we need more null space.
    dwHeapMove = 1 + bExtraNullSpaceNeeded;

    // Move the heap pointer;
    m_pdwHeapData += dwHeapMove;

    // Convert to number of bytes.
    dwHeapMove *= sizeof(DWORD);

    // Scoot all property pointers up by the number of bytes the heap moved.
    for (int i = 0; i < nProps - 1; i++)
    {
        if (m_pProps[i].IsPointer())
            m_pdwPropTable[i] += dwHeapMove; 
    }

    // Move the current pointer up.
    MoveCurrent(dwHeapMove);

    // Slide the property data forward by dwHeapMove bytes.
    memmove(
        m_pdwHeapData, 
        (LPBYTE) m_pdwHeapData - dwHeapMove,
        m_pCurrent - (LPBYTE) m_pdwHeapData);

    // See if we're going to require another DWORD in our null table once
    // we add this property.  If so, we have some work to do.
    if (bExtraNullSpaceNeeded)
    {
        DWORD dwTableIndex;

        // Slide forward the tables by one DWORD.
        m_pdwPropTable++;

        dwTableIndex = nProps / 32;

        // Set our new entry in our table to 0 (all props null).
        m_pdwNullTable[dwTableIndex] = 0;

        // Slide forward the prop data by one slot.
        memmove(
            m_pdwPropTable,
            m_pdwPropTable - 1,
            (LPBYTE) m_pdwHeapData - (LPBYTE) m_pdwNullTable);
    }

    m_pProps.AddVal(info);

    m_bufferEventLayout.Write((DWORD) type);
    m_bufferEventLayout.WriteAlignedLenString(szName);

    return TRUE;
}

BOOL CEvent::SetSinglePropValue(DWORD dwIndex, va_list list)
{
    PROP_FUNC pFunc;
    BOOL      bRet;

    CCondInCritSec cs(&m_cs, IsLockable());

    //m_pStack = (LPVOID*) pStack;
    m_valist = list;
    m_iCurrentVar = dwIndex;

    pFunc = m_pProps[dwIndex].m_pFunc;

    bRet = (this->*pFunc)();

    return bRet;
}

BOOL CEvent::SetPropValues(CIntArray *pArr, va_list list)
{
    BOOL bRet = TRUE;

    CCondInCritSec cs(&m_cs, IsLockable());

    // Is this a 'normal' event?
    if (!pArr)
    {
        DWORD nProps = GetPropertyCount();

        //m_pStack = (LPVOID*) pStack;
        m_valist = list;
    
        for (m_iCurrentVar = 0; m_iCurrentVar < nProps && bRet; m_iCurrentVar++)
        {
            PROP_FUNC pFunc = m_pProps[m_iCurrentVar].m_pFunc;

            bRet = (this->*pFunc)();
        }
    }
    // Must be a property subset.
    else
    {
        DWORD nProps = pArr->GetCount();

        //m_pStack = (LPVOID*) pStack;
        m_valist = list;
    
        for (DWORD i = 0; i < nProps && bRet; i++)
        {
            PROP_FUNC pFunc;
            int       iRealIndex = (*pArr)[i];
            
            m_iCurrentVar = iRealIndex;
            
            pFunc = m_pProps[iRealIndex].m_pFunc;

            bRet = (this->*pFunc)();
        }
    }

    return bRet;
}

BOOL CEvent::SetPropValue(DWORD dwPropIndex, LPVOID pData, DWORD dwElements, 
    DWORD dwSize)
{
    if(dwPropIndex >= GetPropertyCount())
    {
        _ASSERT(FALSE);
        return FALSE;
    }

    if(dwSize == 0)
    {
        _ASSERT(FALSE);
        return FALSE;
    }

    CCondInCritSec cs(&m_cs, IsLockable());

    CPropInfo *pProp = &m_pProps[dwPropIndex];

    if (!pProp->IsPointer())
    {
        SetPropNull(dwPropIndex, FALSE);

        m_pdwPropTable[dwPropIndex] = *(DWORD*) pData;

        return TRUE;
    }

    BOOL  bRet = FALSE;
    BOOL  bLengthPrefixed = pProp->CountPrefixed();
    DWORD dwSizeNeeded = bLengthPrefixed ? dwSize + sizeof(DWORD) : dwSize;

    // Align the size.
    dwSizeNeeded = DWORD_ALIGNED(dwSizeNeeded);

    // If the value is null we'll have to make some room for the new value.
    if (IsPropNull(dwPropIndex))
    {
        LPBYTE pStart;

        // Increase our buffer size.
        MoveCurrent(dwSizeNeeded);
        
        // Make sure we get this after we call MoveCurrent, in case the
        // buffer is reallocated.
        pStart = m_pCurrent - dwSizeNeeded;

        // Copy in the new value.
        if (bLengthPrefixed)
        {
            *((DWORD*) pStart) = dwElements;
                
            if (pData)
                memcpy(pStart + sizeof(DWORD), pData, dwSize);
        }
        else
        {                
            if (pData)
                memcpy(pStart, pData, dwSize);
        }

        // Set this value as non-null.
        SetPropNull(dwPropIndex, FALSE);

        // Point to our new data.
        m_pdwPropTable[dwPropIndex] = pStart - m_pBuffer;

        pProp->m_dwCurrentSize = dwSizeNeeded;

        bRet = TRUE;
    }
    else // Value is currently non-null.
    {
        // Does the old size match the new one?  If so, just copy it in.
        if (pProp->m_dwCurrentSize == dwSizeNeeded)
        {
            if (pData)
            {
                DWORD  dwDataOffset = m_pdwPropTable[dwPropIndex];
                LPBYTE pPropData = m_pBuffer + dwDataOffset; 

                // We always have to copy this in because the elements can
                // vary for the same current size because of DWORD aligning.
                *((DWORD*) pPropData) = dwElements;

                if (bLengthPrefixed)
                    memcpy(pPropData + sizeof(DWORD), pData, dwSize);
                else
                    memcpy(pPropData, pData, dwSize);
            }

            bRet = TRUE;
        }
        else // If the sizes don't match we have a little more work to do.
        {
            int    iSizeDiff = dwSizeNeeded - pProp->m_dwCurrentSize;
            DWORD  dwOldCurrentOffset = m_pCurrent - m_pBuffer;

            // Change our buffer size.
            // This has to be done before we get the pointers below, because
            // MoveCurrent can potentially get our buffer reallocated.
            MoveCurrent(iSizeDiff);

            DWORD  dwDataOffset = m_pdwPropTable[dwPropIndex];
            LPBYTE pPropData = m_pBuffer + dwDataOffset; 
            LPBYTE pOldDataEnd = pPropData + pProp->m_dwCurrentSize;

            memmove(
                pOldDataEnd + iSizeDiff, 
                pOldDataEnd,
                m_pBuffer + dwOldCurrentOffset - pOldDataEnd);

            // Copy in the new value.
            if (bLengthPrefixed)
            {
                *((DWORD*) pPropData) = dwElements;
    
                if (pData)
                    memcpy(pPropData + sizeof(DWORD), pData, dwSize);
            }
            else
            {
                if (pData)
                    memcpy(pPropData, pData, dwSize);
            }

            // Init this property's data.
            pProp->m_dwCurrentSize = dwSizeNeeded;

            // Increment all the data pointers by the amount we just added.
            CPropInfo *pProps = m_pProps.GetData();
    
            // We have to look at them all since we're now allowing properties
            // to store data in the heap non-sequentially (e.g. property 3
            // can point to data that comes after property 4's data).
            DWORD nProps = GetPropertyCount();

            for (DWORD i = 0; i < nProps; i++)
            {
                if (pProps[i].IsPointer() && m_pdwPropTable[i] > dwDataOffset)
                    m_pdwPropTable[i] += iSizeDiff;
            }
                    
            bRet = TRUE;
        }
    }

    return bRet;
}

BOOL CEvent::SetPropNull(DWORD dwPropIndex)
{
    CCondInCritSec cs(&m_cs, IsLockable());

    if(dwPropIndex >= GetPropertyCount())
    {
        _ASSERT(FALSE);
        return FALSE;
    }

    // Only do something if the value isn't already null.
    if (!IsPropNull(dwPropIndex))
    {
        // Mark the given index as null.
        SetPropNull(dwPropIndex, TRUE);

        if (m_pProps[dwPropIndex].IsPointer())
        {
            CPropInfo *pProps = m_pProps.GetData();
            DWORD      nProps = GetPropertyCount(),
                       dwSizeToRemove = pProps[dwPropIndex].m_dwCurrentSize;
            DWORD      dwDataOffset = m_pdwPropTable[dwPropIndex];
            LPBYTE     pDataToRemove = m_pBuffer + dwDataOffset; 

            // Slide up all the data that comes after the one we're nulling 
            // out.
            memmove(
                pDataToRemove, 
                pDataToRemove + dwSizeToRemove, 
                m_pCurrent - pDataToRemove - dwSizeToRemove);
    
            // Reduce the size of our send buffer.
            MoveCurrent(-dwSizeToRemove);

            // Decrement all the data pointers by the amount we just removed.
            for (DWORD i = 0; i < nProps; i++)
            {
                if (pProps[i].IsPointer() && 
                    m_pdwPropTable[i] > dwDataOffset) 
                {
                    m_pdwPropTable[i] -= dwSizeToRemove;
                }
            }
        }
    }

    return TRUE;
}

LPBYTE CEvent::GetPropData(DWORD dwPropIndex)
{
    CPropInfo *pProp = &m_pProps[dwPropIndex];
    LPBYTE    pData;

    if (pProp->IsPointer())
    {
        DWORD dwDataOffset = m_pdwPropTable[dwPropIndex];
        
        pData = m_pBuffer + dwDataOffset;
    }
    else
        pData = (LPBYTE) &m_pdwPropTable[dwPropIndex];

    return pData;   
}

BOOL CEvent::GetPropValue(
    DWORD dwPropIndex, 
    LPVOID pData, 
    DWORD dwBufferSize,
    DWORD *pdwBytesRead)
{
    CCondInCritSec cs(&m_cs, IsLockable());

    if(dwPropIndex >= GetPropertyCount())
    {
        _ASSERT(FALSE);
        return FALSE;
    }

    if(dwBufferSize == 0)
    {
        _ASSERT(FALSE);
        return FALSE;
    }

    BOOL      bRet = FALSE;

    // If the value is non-null then read it.
    if (!IsPropNull(dwPropIndex))
    {
        CPropInfo *pProp = &m_pProps[dwPropIndex];
        DWORD     dwSizeToRead = pProp->m_dwCurrentSize;
        LPBYTE    pPropData = GetPropData(dwPropIndex);

        // Get rid of the prefix if there is any.
        if (pProp->CountPrefixed())
        {
            pPropData += sizeof(DWORD);
            dwSizeToRead -= sizeof(DWORD);
        }

        // Make sure we have enough room for the output data.
        if (dwBufferSize >= dwSizeToRead)
        {
            memcpy(pData, pPropData, dwSizeToRead);
            *pdwBytesRead = dwSizeToRead;
            bRet = TRUE;
        }
    }
    else
    {
        *pdwBytesRead = 0;
        bRet = TRUE;
    }

    return bRet;
}

BOOL CEvent::AddStringW()
{
    BOOL    bRet = TRUE;
    LPCWSTR szVal = va_arg(m_valist, LPCWSTR);

    if (!szVal)
        SetPropNull(m_iCurrentVar);
    else
    {
        DWORD dwLen = (wcslen(szVal) + 1) * sizeof(WCHAR);
        
        bRet = 
            SetPropValue(
                m_iCurrentVar, 
                (LPVOID) szVal, 
                dwLen,    // This will be written into the buffer as the size
                          // of the string.
                dwLen);   // The number of bytes we need.
    }

    //m_pStack++;
    
    return bRet;
}

BOOL CEvent::AddScalarArray()
{
    BOOL   bRet = TRUE;
    LPBYTE pData = va_arg(m_valist, LPBYTE);
    DWORD  dwElements = va_arg(m_valist, DWORD);

    if (!pData)
        SetPropNull(m_iCurrentVar);
    else
    {
        DWORD dwSize;

        // The caller gives us the number of elements in the array.  So,
        // multiply the number of elements by the element size.
        dwSize = m_pProps[m_iCurrentVar].m_dwElementSize * dwElements;

        bRet = SetPropValue(m_iCurrentVar, pData, dwElements, dwSize);

        // Moves past the LPVOID and the DWORD.
        //m_pStack += 2;
    }

    return bRet;
}


BOOL CEvent::AddStringArray()
{
    BOOL    bRet = TRUE;
    LPCWSTR *pszStrings = va_arg(m_valist, LPCWSTR*);
    DWORD   dwItems = va_arg(m_valist, DWORD);

    if (!pszStrings)
        SetPropNull(m_iCurrentVar);
    else
    {
        // Copy the strings into our buffer.
        DWORD dwTotalLen = 0;

        // Calculate the total length.
        for (DWORD i = 0; i < dwItems; i++)
        {
            // The amount of buffer each string takes must be DWORD aligned.
            dwTotalLen += DWORD_ALIGNED(wcslen(pszStrings[i]) + 1) * sizeof(WCHAR);
        }

        // Account for the DWORDs before each string.
        dwTotalLen += sizeof(DWORD) * dwItems;

        // Use a NULL for the data pointer to just make room for the strings
        // without copying in the data.
        bRet = SetPropValue(m_iCurrentVar, NULL, dwItems, dwTotalLen);

        if (bRet)
        {
            // Copy the strings into our buffer.
            LPBYTE pCurrent = GetPropData(m_iCurrentVar) + sizeof(DWORD);

            for (DWORD i = 0; i < dwItems; i++)
            {
                DWORD dwLen = (wcslen(pszStrings[i]) + 1) * sizeof(WCHAR);

                // Add the prefixed size.
                *(DWORD*) pCurrent = dwLen;

                // Copy in the string.  Don't use an aligned len because
                // we only copy exactly dwLen bytes.
                memcpy(pCurrent + sizeof(DWORD), pszStrings[i], dwLen);
                
                pCurrent += 
                    sizeof(DWORD) + 
                    DWORD_ALIGNED(*(DWORD*) pCurrent);
            }

            // Moves past the LPVOID and the DWORD.
            //m_pStack += 2;
        }
        else
            bRet = FALSE;
    }

    return bRet;
}

BOOL CEvent::AddObject()
{
    BOOL   bRet = TRUE;
    HANDLE hEvent = va_arg(m_valist, HANDLE);

    if (!hEvent)
        SetPropNull(m_iCurrentVar);
    else
    {
        CEvent *pEvent = ((CEventWrap*) hEvent)->GetEvent();
        DWORD  dwTotalLen,
               dwLayoutLen,
               dwDataLen;
        LPBYTE pLayout,
               pData;
                   
        pEvent->GetLayoutBuffer(&pLayout, &dwLayoutLen, FALSE); 
        pEvent->GetDataBuffer(&pData, &dwDataLen, FALSE); 

        dwTotalLen = dwLayoutLen + dwDataLen;
        
        // Use a NULL for the data pointer to just make room for the event
        // buffers without copying in the data.
        // Note that because the property has m_bCountPrefixNeeded set to 
        // TRUE, SetPropValue will write in the 3rd argument (the length of 
        // the object) into the first DWORD.
        bRet = 
            SetPropValue(
                m_iCurrentVar, 
                NULL, 
                // Aligned since this will represent the size of the buffer
                // taken by the object.
                DWORD_ALIGNED(dwTotalLen),
                // This one should not be aligned because it's the literal number
                // of bytes we're going to copy into the buffer.
                dwTotalLen);
            
        if (bRet)
        {
            // Now that we have some room, copy in the data.
            // The sizeof(DWORD) gets us past the length of the object.
            LPBYTE pDestData = GetPropData(m_iCurrentVar) + sizeof(DWORD);

            memcpy(pDestData, pLayout, dwLayoutLen);
            memcpy(pDestData + dwLayoutLen, pData, dwDataLen);
        }
    }

    //m_pStack++;
    
    return bRet;
}

BOOL CEvent::AddObjectArray()
{
    BOOL   bRet = TRUE;
    HANDLE *phEvents = va_arg(m_valist, HANDLE*);
    DWORD  dwItems = va_arg(m_valist, DWORD);

    if (!phEvents)
        SetPropNull(m_iCurrentVar);
    else
    {
        CEventWrap **pWraps = (CEventWrap**) phEvents;
        DWORD      dwTotalLen = 0;

        // Calculate the total length.
        for (DWORD i = 0; i < dwItems; i++)
        {
            CEvent *pEvent = pWraps[i]->GetEvent();
            DWORD  dwLayoutLen,
                   dwDataLen;
            LPBYTE pLayout,
                   pData;
                   
            pEvent->GetLayoutBuffer(&pLayout, &dwLayoutLen, FALSE); 
            pEvent->GetDataBuffer(&pData, &dwDataLen, FALSE); 
            
            // The extra sizeof(DWORD) is for the size of each object.
            dwTotalLen += DWORD_ALIGNED(dwLayoutLen + dwDataLen) + 
                            sizeof(DWORD);
        }

        // Use a NULL for the data pointer to just make room for the event
        // buffers without copying in the data.
        bRet = SetPropValue(m_iCurrentVar, NULL, dwItems, dwTotalLen);

        if (bRet)
        {
            // Now that we have some room, copy in the data.
            // Note that SetPropValue sets the first DWORD to dwItems.
            LPBYTE pDestData = GetPropData(m_iCurrentVar) + sizeof(DWORD);

            for (DWORD i = 0; i < dwItems; i++)
            {
                CEvent *pEvent = pWraps[i]->GetEvent();
                DWORD  dwLayoutLen,
                       dwDataLen,
                       dwTotalDestLen;
                LPBYTE pLayout,
                       pData;
                   
                pEvent->GetLayoutBuffer(&pLayout, &dwLayoutLen, FALSE); 
                pEvent->GetDataBuffer(&pData, &dwDataLen, FALSE); 
            
                // Copy in the size of the object.
                dwTotalDestLen = DWORD_ALIGNED(dwLayoutLen + dwDataLen);
                *(DWORD*) pDestData = dwTotalDestLen;
                pDestData += sizeof(DWORD);

                // Copy in the object bits.
                memcpy(pDestData, pLayout, dwLayoutLen);
                memcpy(pDestData + dwLayoutLen, pData, dwDataLen);

                pDestData += dwTotalDestLen;
            }

            // Moves past the LPVOID and the DWORD.
            //m_pStack += 2;
        }
    }

    return bRet;
}

BOOL CEvent::AddWmiObject()
{
    BOOL        bRet = TRUE;
    _IWmiObject *pObj = 
                    (_IWmiObject*) (IWbemClassObject*) va_arg(m_valist, IWbemClassObject*);

    if (!pObj)
        SetPropNull(m_iCurrentVar);
    else
    {
        DWORD   dwTotalLen = 0;
        HRESULT hr;
                   
        hr = 
            pObj->GetObjectParts(
                NULL, 
                0, 
                WBEM_OBJ_DECORATION_PART | WBEM_OBJ_INSTANCE_PART | 
                    WBEM_OBJ_CLASS_PART,
                &dwTotalLen);
            
        // This should never happen, but just in case...
        if (hr != WBEM_E_BUFFER_TOO_SMALL)
            return FALSE;

        // Use a NULL for the data pointer to just make room for the event
        // buffers without copying in the data.
        // Note that because the property has m_bCountPrefixNeeded set to 
        // TRUE, SetPropValue will write in the 3rd argument (the length of 
        // the object) into the first DWORD.
        bRet = 
            SetPropValue(
                m_iCurrentVar, 
                NULL, 
                // Aligned since this will represent the size of the buffer
                // taken by the object.
                DWORD_ALIGNED(dwTotalLen),
                // This one should not be aligned because it's the literal number
                // of bytes we're going to copy into the buffer.
                dwTotalLen);
            
        if (bRet)
        {
            // Now that we have some room, copy in the data.
            // The sizeof(DWORD) gets us past the length of the object.
            LPBYTE pDestData = GetPropData(m_iCurrentVar) + sizeof(DWORD);

            hr = 
                pObj->GetObjectParts(
                    pDestData, 
                    dwTotalLen, 
                    WBEM_OBJ_DECORATION_PART | WBEM_OBJ_INSTANCE_PART | 
                        WBEM_OBJ_CLASS_PART,
                    &dwTotalLen);

            bRet = SUCCEEDED(hr);
        }
    }

    return bRet;
}

BOOL CEvent::AddWmiObjectArray()
{
    BOOL        bRet = TRUE;
    _IWmiObject **pObjs = 
                    (_IWmiObject**) (IWbemClassObject**) va_arg(m_valist, IWbemClassObject**);
    DWORD       dwItems = va_arg(m_valist, DWORD);

    if (!pObjs)
        SetPropNull(m_iCurrentVar);
    else
    {
        DWORD dwTotalLen = 0;

        // Calculate the total length.
        for (DWORD i = 0; i < dwItems; i++)
        {
            DWORD dwLen = 0;
            
            if (pObjs[i])
            {
                pObjs[i]->GetObjectParts(
                    NULL, 
                    0, 
                    WBEM_OBJ_DECORATION_PART | WBEM_OBJ_INSTANCE_PART | 
                        WBEM_OBJ_CLASS_PART,
                    &dwLen);
            }
            
            // The extra sizeof(DWORD) is for the size of each object.
            dwTotalLen += DWORD_ALIGNED(dwLen) + sizeof(DWORD);
        }

        // Use a NULL for the data pointer to just make room for the event
        // buffers without copying in the data.
        bRet = SetPropValue(m_iCurrentVar, NULL, dwItems, dwTotalLen);

        if (bRet)
        {
            // Now that we have some room, copy in the data.
            // Note that SetPropValue sets the first DWORD to dwItems.
            LPBYTE pDestData = GetPropData(m_iCurrentVar) + sizeof(DWORD);

            for (DWORD i = 0; i < dwItems; i++)
            {
                DWORD dwLen = 0;
                   
                if (pObjs[i])
                {
                    // Get the size again.
                    pObjs[i]->GetObjectParts(
                        NULL, 
                        0, 
                        WBEM_OBJ_DECORATION_PART | WBEM_OBJ_INSTANCE_PART | 
                            WBEM_OBJ_CLASS_PART,
                        &dwLen);
                }

                // Copy in the size of the object.
                *(DWORD*) pDestData = dwLen;
                pDestData += sizeof(DWORD);

                if (dwLen)
                {
                    // Copy in the object bits.
                    pObjs[i]->GetObjectParts(
                        pDestData, 
                        dwLen, 
                        WBEM_OBJ_DECORATION_PART | WBEM_OBJ_INSTANCE_PART | 
                            WBEM_OBJ_CLASS_PART,
                        &dwLen);

                    pDestData += DWORD_ALIGNED(dwLen);
                }
            }
        }
    }

    return bRet;
}

BOOL CEvent::AddBYTE()
{
    BYTE cData = va_arg(m_valist, BYTE);
    BOOL bRet = SetPropValue(m_iCurrentVar, &cData, 1, sizeof(BYTE));

    //m_pStack++;
    
    return bRet;
}

BOOL CEvent::AddWORD()
{
    WORD wData = va_arg(m_valist, WORD);
    BOOL bRet = 
            SetPropValue(m_iCurrentVar, &wData, 1, sizeof(WORD));

    //m_pStack++;
    
    return bRet;
}

BOOL CEvent::AddDWORD()
{
    DWORD dwData = va_arg(m_valist, DWORD);
    BOOL  bRet = SetPropValue(m_iCurrentVar, &dwData, 1, sizeof(DWORD));

    //m_pStack++;

    return bRet;
}

BOOL CEvent::AddFloat()
{
    // The compiler pushes 64-bit doubles when passing floats, so we'll have
    // to first convert it to a 32-bit float.
    //float fValue = (float) *(double*) m_pStack;
    float fValue = va_arg(m_valist, double);
    BOOL  bRet = SetPropValue(m_iCurrentVar, &fValue, 1, sizeof(float));

    // Account for the 64-bits passed on the stack.
    //m_pStack += 2;

    return bRet;
}

BOOL CEvent::AddDWORD64()
{
    DWORD64 dwData = va_arg(m_valist, DWORD64);
    BOOL    bRet = SetPropValue(m_iCurrentVar, &dwData, 1, sizeof(DWORD64));

    // To get past both DWORDs.
    //m_pStack += 2;

    return bRet;
}

BOOL CEvent::SendEvent()
{
    BOOL bRet = FALSE;

    if (IsEnabled())
    {
        CCondInCritSec cs(&m_cs, IsLockable());

        if (!m_bLayoutSent)
        {
            DWORD dwLayoutSize = m_bufferEventLayout.GetUsedSize();

            // Embed the layout size in the message.
            ((DWORD*) m_bufferEventLayout.m_pBuffer)[1] = dwLayoutSize;

            m_bLayoutSent = 
                m_pSink->GetConnection()->SendData(
                    m_bufferEventLayout.m_pBuffer,
                    dwLayoutSize);
        }

#ifdef USE_SD
        if (!m_bSDSent)
        {
            m_bSDSent = 
                m_pSink->GetConnection()->SendData(
                    m_bufferSD.m_pBuffer,
                    m_bufferSD.GetUsedSize());
        }

        if (m_bLayoutSent && m_bSDSent)
#else
        if (m_bLayoutSent)
#endif
        {
            DWORD dwDataSize = GetUsedSize();

            // Embed the data buffer size in the message.
            ((DWORD*) m_pBuffer)[1] = dwDataSize;

            bRet = m_pSink->GetConnection()->SendData(m_pBuffer, dwDataSize);
        }
    }
    
    return bRet;        
}

void CEvent::GetLayoutBuffer(
    LPBYTE *ppBuffer, 
    DWORD *pdwSize,
    BOOL bIncludeHeader)
{
    DWORD dwHeaderSize = bIncludeHeader ? 0 : sizeof(DWORD) * 4;

    // Get past the header stuff.
    *ppBuffer = m_bufferEventLayout.m_pBuffer + dwHeaderSize;

    // Subtract off the header stuff.
    *pdwSize = m_bufferEventLayout.GetUsedSize() - dwHeaderSize;
}

void CEvent::GetDataBuffer(
    LPBYTE *ppBuffer, 
    DWORD *pdwSize,
    BOOL bIncludeHeader)
{
    DWORD dwHeaderSize = bIncludeHeader ? 0 : sizeof(DWORD) * 3;

    // Get past the header stuff.
    *ppBuffer = m_pBuffer + dwHeaderSize;

    // Subtract off the header stuff.
    *pdwSize = GetUsedSize() - dwHeaderSize;
}

BOOL CEvent::SetLayoutAndDataBuffers(
    LPBYTE pLayoutBuffer,
    DWORD dwLayoutBufferSize,
    LPBYTE pDataBuffer,
    DWORD dwDataBufferSize)
{
    DWORD dwEventIndex = InterlockedExchangeAdd((long*) &g_dwEventIndex, 1);
    int   nProps;

    CCondInCritSec cs(&m_cs, IsLockable());

    // Setup the event layout buffer.
    m_bufferEventLayout.Reset();
    
    // Set the layout buffer.
    m_bufferEventLayout.Write(pLayoutBuffer, dwLayoutBufferSize);
    
    // Add the new index we just created.
    *(((DWORD*) m_bufferEventLayout.m_pBuffer) + 1) = dwEventIndex;
    
    // Get the number of props from the layout buffer.
    nProps = GetPropertyCount();

    // Setup the main event buffer    
    Reset();
    Write(pDataBuffer, dwDataBufferSize);

    // Add the new index we just created.
    *(((DWORD*) m_pBuffer) + 1) = dwEventIndex;

    m_pProps.Init(nProps);
    m_pProps.SetCount(nProps);

    // Setup our data tables.
    RecalcTables();

    LPBYTE pLayoutCurrent = 
            // Get past the header and property count.
            (m_bufferEventLayout.m_pBuffer + sizeof(DWORD) * 5);

    // Get past the event name.
    pLayoutCurrent += sizeof(DWORD) + DWORD_ALIGNED(*(DWORD*) pLayoutCurrent);

    // For each non-null pointer property, figure out the property's size.
    for (DWORD i = 0; i < nProps; i++)
    {
        CPropInfo &info = m_pProps[i];
        CIMTYPE   dwType = *(DWORD*) pLayoutCurrent;

        info.Init(dwType);
        
        // Get past the type, the length of the property name, and the property
        // name itself.
        pLayoutCurrent += 
            sizeof(DWORD) * 2 + 
            DWORD_ALIGNED(*(DWORD*) (pLayoutCurrent + sizeof(DWORD)));

        if (!IsPropNull(i) && info.IsPointer())
        {
            LPBYTE pData = GetPropData(i);

            info.InitCurrentSize(pData);
        }
    }

    return TRUE;
}

#define DEF_HEAP_EXTRA  256

void CEvent::RecalcTables()
{
    DWORD nProps = GetPropertyCount(),
          dwNullSize;

    m_pdwNullTable = (DWORD*) (m_pBuffer + sizeof(DWORD) * 3);
    dwNullSize = (nProps + 31) / 32;
    if (!dwNullSize)
        dwNullSize = 1;

    m_pdwPropTable = m_pdwNullTable + dwNullSize;

    m_pdwHeapData = m_pdwPropTable + nProps;

    DWORD dwSize = (LPBYTE) m_pdwHeapData - m_pCurrent;

    if ((LPBYTE) m_pdwHeapData - m_pBuffer > m_dwSize)
        Resize((LPBYTE) m_pdwHeapData - m_pBuffer + DEF_HEAP_EXTRA);

    dwSize = m_pCurrent - (LPBYTE) m_pdwHeapData;
}

#ifdef USE_SD
BOOL CEvent::SetSD(SECURITY_DESCRIPTOR *pSD)
{
    SECURITY_DESCRIPTOR *pSDRelative;
    BOOL                bRet,
                        bFree;

    if (pSD)
    {
        if (GetRelativeSD(pSD, &pSDRelative, &bFree))
        {
            DWORD dwLen = GetSecurityDescriptorLength(pSDRelative);

            {
                CCondInCritSec cs(&m_cs, IsLockable());

                m_bufferSD.Reset(dwLen + sizeof(DWORD) * 3);

                m_bufferSD.Write((DWORD) NC_SRVMSG_SET_EVENT_SD);
                m_bufferSD.Write(dwLen + sizeof(DWORD) * 3);
                m_bufferSD.Write(GetEventIndex());
                m_bufferSD.Write(pSDRelative, dwLen);
                m_bSDSent = FALSE;
            }

            bRet = TRUE;

            if (bFree)
                delete pSDRelative;
        
            m_bSDSent = FALSE;
        }
        else
            bRet = FALSE;
    }
    else
    {
        CCondInCritSec cs(&m_cs, IsLockable());

        m_bufferSD.Reset(sizeof(DWORD) * 3);
        
        m_bufferSD.Write((DWORD) NC_SRVMSG_SET_EVENT_SD);
        m_bufferSD.Write((DWORD) (sizeof(DWORD) * 3));
        m_bufferSD.Write(GetEventIndex());

        m_bSDSent = FALSE;

        bRet = TRUE;
    }

    return bRet;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncobjapi\eventtrace.cpp ===
// EventTrace.cpp

#include "precomp.h"

// So GUID_WMI_NONCOM_EVENT_TRACE will get included into this file.
#include <initguid.h>
#include "NCEvent.h"

#include "EventTrace.h"
#include "P2PDefs.h"
#include "dutils.h"

// Event tracing stuff.
#include <wmistr.h>
#include <evntrace.h>


CEventTraceClient::CEventTraceClient() :
    m_hTrace(NULL),
    m_hLogger(NULL)
{
}

CEventTraceClient::~CEventTraceClient()
{
    Deinit();
}

ULONG WINAPI CEventTraceClient::ControlCallback(
    IN WMIDPREQUESTCODE requestCode,
    IN PVOID pContext,
    IN OUT ULONG *pdwInOutBufferSize,
    IN OUT PVOID pBuffer)
{
    CEventTraceClient 
            *pThis = (CEventTraceClient*) pContext;
    DWORD   status = ERROR_SUCCESS,
            dwRetSize;

    switch (requestCode)
    {
        case WMI_ENABLE_EVENTS:
            dwRetSize = 0;
            pThis->m_hLogger = GetTraceLoggerHandle(pBuffer);
            pThis->m_pConnection->IncEnabledCount();
            //dwEnableLevel = GetTraceEnableLevel(hLogger);
            //dwEnableFlags = GetTraceEnableFlags(hLogger);
            //_tprintf(_T("Logging enabled to 0x%016I64x(%d,%d,%d)\n"),
            //        hLogger, requestCode, dwEnableLevel, dwEnableFlags);
            break;

        case WMI_DISABLE_EVENTS:
            dwRetSize = 0;
            pThis->m_hLogger = NULL;
            pThis->m_pConnection->ResetEventBufferLayoutSent(TRANS_EVENT_TRACE);
            pThis->m_pConnection->DecEnabledCount();
            break;

        default:
            dwRetSize = 0;
            status = ERROR_INVALID_PARAMETER;
            break;
    }

    *pdwInOutBufferSize = dwRetSize;

    return status;
}

CEventTraceClient::IsReady()
{
    return m_hLogger != NULL;
}

#define MS_SLEEP 10

BOOL CEventTraceClient::SendData(LPBYTE pBuffer, DWORD dwSize)
{
    DWORD dwRet;

    m_event.mofData.DataPtr = (ULONGLONG) pBuffer;
    m_event.mofData.Length  = dwSize;

    do
    {
        dwRet = 
            TraceEvent(
                m_hLogger,
                (PEVENT_TRACE_HEADER) &m_event);

        if (dwRet == 0)
        {
            //printf("Packet sent = %d bytes\n", dwSize);
            break;
        }

        if (dwRet == ERROR_NOT_ENOUGH_MEMORY)
            Sleep(MS_SLEEP);

    } while (dwRet != ERROR_NOT_ENOUGH_MEMORY);

    return dwRet == 0;
}

void CEventTraceClient::Deinit()
{
    if (m_hTrace)
    {
        UnregisterTraceGuids(m_hTrace);

        m_hTrace = NULL;
        m_hLogger = NULL;
    }
}

// TODO: Find out what in the world this is used for!
#define RES_NAME _T("MofResource")

BOOL CEventTraceClient::Init(GUID *pguidEventTraceProvider)
{
    TRACE_GUID_REGISTRATION regTrace[] =
            { { &GUID_WMI_NONCOM_EVENTTRACE_EVENT, NULL } };
    DWORD dwRet;
    TCHAR szImagePath[MAX_PATH] = _T("");

    GetModuleFileName(NULL, szImagePath, sizeof(szImagePath));
    
    // Prepare our event buffer for later use.
    ZeroMemory(&m_event, sizeof(m_event));

    m_event.header.Size  = sizeof(USER_EVENT);
    m_event.header.Flags = WNODE_FLAG_TRACED_GUID | WNODE_FLAG_USE_MOF_PTR;
    m_event.header.Guid  = GUID_WMI_NONCOM_EVENTTRACE_EVENT;

    dwRet = 
        RegisterTraceGuids(
            ControlCallback,
            this,          // RequestContext
            pguidEventTraceProvider,
            1,
            regTrace,
            szImagePath,
            RES_NAME,
            &m_hTrace);

    return dwRet == 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncobjapi\event.h ===
// Event.h
// These classes represent the hEvent returned by the CreateEvent functions.

#pragma once

// Forward declarations
class CConnection;
class CEvent;

#include "array.h"
#include "NCObjApi.h"

/////////////////////////////////////////////////////////////////////////////
// CPropInfo

typedef BOOL (CEvent::*PROP_FUNC)();

typedef CArray<int, int> CIntArray;

class CPropInfo
{
public:
    DWORD     m_dwCurrentSize;
    DWORD     m_dwElementSize;
    PROP_FUNC m_pFunc;

    BOOL Init(CIMTYPE type);
    BOOL CountPrefixed() { return m_bCountPrefixNeeded; }

    BOOL IsPointer()
    {
        return m_bPointer;
    }

    void InitCurrentSize(LPBYTE pData);

protected:
    BOOL      m_bCountPrefixNeeded;
    BOOL      m_bPointer;
};

/////////////////////////////////////////////////////////////////////////////
// CEventWrap

typedef CArray<CPropInfo, CPropInfo&> CPropInfoArray;

class CEventWrap
{
public:
    CEventWrap(CSink *pSink, DWORD dwFlags);
    CEventWrap(CEvent *pEvent, int nIndexes, DWORD *pdwIndexes);
    ~CEventWrap();

    BOOL IsSubset() { return !m_bFreeEvent; }
    CEvent *GetEvent() { return m_pEvent; }
    CIntArray *GetIndexArray() { return !IsSubset() ? NULL : &m_pIndexes; }

    int SubIndexToEventIndex(int iIndex)
    {
        if (!IsSubset())
            return iIndex;
        else
        {
            if(iIndex < 0 || iIndex >= m_pIndexes.GetSize())
            {
                _ASSERT(FALSE);
                return -1;
            }

            return m_pIndexes[iIndex];
        }
    }

protected:
    CEvent    *m_pEvent;
    CIntArray m_pIndexes;
    BOOL      m_bFreeEvent;
};


/////////////////////////////////////////////////////////////////////////////
// CEvent

// LenStr:
// DWORD         nBytes - Bytes in the string.
// WCHAR[nBytes] String data.
// BYTE[0-3]     Padding to make the string DWORD aligned.

// Event Layout Buffer:
// DWORD         NC_SRVMSG_EVENT_LAYOUT (msg type)
// DWORD         dwMsgBytes - The total number of bytes in the buffer.
// DWORD         dwEventIndex
// DWORD         dwSinkIndex
// DWORD         nProperties
// LenStr        szEventClassName
// The next two properties are repeated for each property.
// DWORD         dwPropType (Uses CIMTYPE values)
// LenStr        szPropertyName

// Event Data Buffer:
// DWORD         NC_SRVMSG_PREPPED_EVENT (msg type)
// DWORD         dwMsgBytes - The total number of bytes in the buffer.
// DWORD         dwEventIndex
// DWORD[n]      cNullMask (0 bit == null)
//               n = # of props divided by 32.  If no props, n == 1.
// DWORD[nProps] dwDataInfo
//               This contains actual data for scalar values for types that
//               fit into 32-bits and offsets the to data for everything else.
//               Offsets are relative from the start of the buffer.
// BYTE[???]     The data pointed to by dwDataInfo (if necessary).

// Event SD:
// DWORD         NC_SRVMSG_SET_EVENT_SD
// DWORD         dwMsgBytes - The total number of bytes in the buffer.
// DWORD         dwEventIndex
// BYTE[]        SD data

// Data encoding (total length is always DWORD aligned):
// Strings:
// All strings, both alone and in arrays, are encoded as LenStr's.

//
// Arrays:
// DWORD          dwItems - Number of elements in the array.
// Type[dwItems]  array data
// BYTE[0-3]      Padding to make the data end on a DWORD boundary.
//
// Objects:
// DWORD          dwBytes - Number of bytes of object data.
// BYTE[dwBytes]  Layout Buffer + Data Buffer
// BYTE[0-3]      Padding to make the data end on a DWORD boundary.
//

// Blob Event Layout:
// DWORD          NC_SRVMSG_BLOB_EVENT
// DWORD          dwMsgBytes - The total number of bytes in the buffer.
// DWORD          dwSinkIndex
// LenStr         szEventName
// DWORD          dwSize - Size of blob.
// BYTE[dwSize]   pBlob

class CEvent : public CBuffer
{
public:
    CRITICAL_SECTION m_cs;
    CSink            *m_pSink;

    CEvent(CSink *pSink, DWORD dwFlags);
    ~CEvent();

    void ResetEvent();
    
    // Prepared event functions
    BOOL PrepareEvent(
        LPCWSTR szEventName,
        DWORD nPropertyCount,
        LPCWSTR *pszPropertyNames,
        CIMTYPE *pPropertyTypes);
    BOOL FindProp(LPCWSTR szName, CIMTYPE* ptype, DWORD* pdwIndex);
    BOOL AddProp(LPCWSTR szName, CIMTYPE type, DWORD *pdwIndex);
    BOOL SetPropValues(CIntArray *pArr, va_list list);
    BOOL SetSinglePropValue(DWORD dwIndex, va_list list);
    BOOL SetPropValue(DWORD dwPropIndex, LPVOID pData, DWORD dwElements, 
        DWORD dwSize);
    BOOL GetPropValue(DWORD dwPropIndex, LPVOID pData, DWORD dwBufferSize,
        DWORD *pdwBytesRead);
    BOOL SetPropNull(DWORD dwPropIndex);

    void ResetLayoutSent() { m_bLayoutSent = FALSE; }

#ifdef USE_SD
    void ResetSDSent() 
    { 
        if (m_bufferSD.m_dwSize)
            m_bSDSent = FALSE; 
        else
            m_bSDSent = TRUE; 
    }
#endif

    CBuffer *GetLayout() { return &m_bufferEventLayout; }
    CPropInfo *GetProp(DWORD dwIndex) { return &m_pProps[dwIndex]; }

    BOOL SendEvent();

    friend CPropInfo; // For CPropInfo::Init.
    friend CEventWrap;

    LPCWSTR GetClassName() 
    { 
        return (LPCWSTR) (m_bufferEventLayout.m_pBuffer + sizeof(DWORD) * 6);
    }

    BOOL IsEnabled() 
    { 
        BOOL bEnabled;

        bEnabled =
            m_bEnabled ||
            (m_pSink->GetConnection() && 
                m_pSink->GetConnection()->WaitingForWMIInit());

        return bEnabled;
    }
    void SetEnabled(BOOL bEnabled) { m_bEnabled = bEnabled; }

    void GetLayoutBuffer(
        LPBYTE *ppBuffer, 
        DWORD *pdwSize, 
        BOOL bIncludeHeader);
    void GetDataBuffer(
        LPBYTE *ppBuffer, 
        DWORD *pdwSize,
        BOOL bIncludeHeader);
    
    BOOL SetLayoutAndDataBuffers(
        LPBYTE pLayoutBuffer,
        DWORD dwLayoutBufferSize,
        LPBYTE pDataBuffer,
        DWORD dwDataBufferSize);

    void Lock()
    {
        if (IsLockable())
            EnterCriticalSection(&m_cs);
    }

    void Unlock()
    {
        if (IsLockable())
            LeaveCriticalSection(&m_cs);
    }

    BOOL IsPropNull(DWORD dwIndex)
    {
        LPDWORD pTable = GetNullTable();

        return !(pTable[dwIndex / 32] & (1 << (dwIndex % 32)));
    }

    void SetPropNull(DWORD dwIndex, BOOL bNull)
    {
        LPDWORD pTable = GetNullTable();

        if (bNull)
            pTable[dwIndex / 32] &= ~(1 << (dwIndex % 32));
        else
            pTable[dwIndex / 32] |= 1 << (dwIndex % 32);
    }

#ifdef USE_SD
    BOOL SetSD(SECURITY_DESCRIPTOR *pSD);
#endif

    BOOL IsLockable()
    {
        return (m_dwFlags & WMI_CREATEOBJ_LOCKABLE) != 0;
    }

protected:
    CPropInfoArray   m_pProps;
    CBuffer          m_bufferEventLayout;
#ifdef USE_SD
    CBuffer          m_bufferSD;
    BOOL             m_bSDSent;
#endif
    BOOL             m_bLayoutSent,
                     m_bEnabled;
    DWORD            m_iCurrentVar,
                     m_dwFlags;
    va_list          m_valist;

    DWORD *m_pdwNullTable;
    DWORD *m_pdwPropTable;
    DWORD *m_pdwHeapData;

    void RecalcTables();

    BOOL AddBYTE();
    BOOL AddWORD();
    BOOL AddDWORD();
    BOOL AddDWORD64();
    BOOL AddFloat();
    BOOL AddStringW();
    BOOL AddObject();
    BOOL AddWmiObject();
    BOOL AddScalarArray();
    BOOL AddStringArray();
    BOOL AddObjectArray();
    BOOL AddWmiObjectArray();

    DWORD GetEventIndex()
    {
        return *(DWORD*) (m_bufferEventLayout.m_pBuffer + sizeof(DWORD) * 2);
    }

    DWORD GetPropertyCount() 
    {
        return *(DWORD*) (m_bufferEventLayout.m_pBuffer + sizeof(DWORD) * 4);
    }

    void SetPropertyCount(DWORD nProps)
    {
        *(DWORD*) (m_bufferEventLayout.m_pBuffer + sizeof(DWORD) * 4) =
            nProps;
    }

    DWORD *GetNullTable() 
    {
        return m_pdwNullTable;
    }

    LPBYTE GetPropData(DWORD dwPropIndex);
    
    // Used by SetLayoutAndDataBuffers to figure out the current data size of
    // a property and set m_dwCurrentSize with it.
    DWORD CalcPropDataSize(CPropInfo *pInfo);

    // Called when our buffer is resized.
    virtual void OnResize()
    {
        RecalcTables();
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncobjapi\eventtrace.h ===
// EventTrace.h

#pragma once

#include "Transport.h"

// Event tracing headers.
#include <wmistr.h>
#include <evntrace.h>


typedef struct _USER_EVENT 
{
    EVENT_TRACE_HEADER header;
    MOF_FIELD          mofData;
} USER_EVENT, *PUSER_EVENT;

class CEventTraceClient : public CTransport
{
public:
    CEventTraceClient();
    virtual ~CEventTraceClient();

    // Overrideables
    virtual IsReady();
    virtual BOOL SendData(LPBYTE pBuffer, DWORD dwSize);
    virtual void Deinit();

    // Init function.
    BOOL Init(GUID *pguidEventTraceProvider);

protected:
    TRACEHANDLE m_hTrace,
                m_hLogger; // Non-null indicates the provider is activated.
    USER_EVENT  m_event; // Used for calling TraceEvent API.


    static ULONG WINAPI ControlCallback(
        IN WMIDPREQUESTCODE requestCode,
        IN PVOID pContext,
        IN OUT ULONG *pdwInOutBufferSize,
        IN OUT PVOID pBuffer);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncobjapi\inproc.cpp ===
// Inproc.cpp

#include "precomp.h"
#include "Inproc.h"
#include "NCDefs.h"
#include "DUtils.h"
#include "Connection.h"

CInprocClient::CInprocClient() :
    m_pSrvBuffer(NULL),
    m_hthreadReady(NULL),
    m_heventProviderReady(NULL),
    m_heventDone(NULL),
    m_bDone(FALSE),
    m_hProv(NULL)
{
}    

CInprocClient::~CInprocClient()
{
    Deinit();
}

CInprocClient::IsReady()
{
    return m_pSrvBuffer != NULL;
}

BOOL CInprocClient::SendData(LPBYTE pBuffer, DWORD dwSize)
{
    BOOL bWritten;

#ifdef NO_SEND
    bWriten = TRUE;
#else
    if (m_pSrvBuffer != NULL)
    {
        HRESULT hr;

        hr = 
            m_pSrvBuffer->PostBuffer(
                pBuffer,
                dwSize);

        if (SUCCEEDED(hr))
            bWritten = TRUE;
        else
        {
            bWritten = FALSE;

            TRACE("Failed to send buffer to server.");
        
            DeinitBuffer();

            // Start watching for our provider to be ready, and get the server 
            // buffer.
            if(!StartReadyThreadProc())
                return FALSE;
        }
    }
    else
        bWritten = FALSE;
#endif

    return bWritten;
}

void CInprocClient::Deinit()
{
    if (m_hthreadReady)
    {
        m_bDone = TRUE;

        SetEvent(m_heventDone);
        WaitForSingleObject(m_hthreadReady, INFINITE);
        CloseHandle(m_hthreadReady);

        m_hthreadReady = NULL;
    }

    DeinitBuffer();

    if (m_heventDone)
    {
        CloseHandle(m_heventDone);
        m_heventDone = NULL;
    }

    Release();
}

// There's nothing to send in the inproc case.
void CInprocClient::SendMsgReply(NC_SRVMSG_REPLY *pReply)
{
}

// Init function.
BOOL CInprocClient::Init(LPCWSTR szBaseNamespace, LPCWSTR szBaseProvider)
{
    WCHAR szReadyEventName[256];
        
    // Get the ready event.
    swprintf(
        szReadyEventName, 
        OBJNAME_EVENT_READY L"%s%s", 
        szBaseNamespace,
        szBaseProvider);

    m_heventProviderReady = 
        CreateEventW(
            NULL,
            TRUE,
            FALSE,
            szReadyEventName);
    if(m_heventProviderReady == NULL)
        return FALSE;


    // Construct the pipe name.
    swprintf(
        m_szPipeName, 
        L"\\\\.\\pipe\\" OBJNAME_NAMED_PIPE L"%s%s", 
        szBaseNamespace,
        szBaseProvider);

    m_heventDone =
        CreateEvent(NULL, TRUE, FALSE, NULL);
    if(m_heventDone == NULL)
        return FALSE;

    // Before we start the thread see if our provider is ready right off 
    // the bat.
    if (WaitForSingleObject(m_heventProviderReady, 1) != WAIT_OBJECT_0 ||
        !GetBuffer())
    {
        if(!StartReadyThreadProc())
            return FALSE;
    }

    return TRUE;
}

BOOL CInprocClient::SignalProviderDisabled()
{
    if (m_pSrvBuffer != NULL)
    {
        m_pConnection->IndicateProvDisabled();

        DeinitBuffer();

        if(!StartReadyThreadProc())
            return FALSE;
    }

    return TRUE;
}

BOOL CInprocClient::StartReadyThreadProc()
{
    DWORD dwID;

    if (m_hthreadReady)
        CloseHandle(m_hthreadReady);

    m_hthreadReady =
        CreateThread(
            NULL,
            0,
            (LPTHREAD_START_ROUTINE) ProviderReadyThreadProc,
            this,
            0,
            &dwID);
    if(m_hthreadReady == NULL)
        return FALSE;

    return TRUE;
}

void CInprocClient::DeinitBuffer()
{
    CInCritSec cs(&m_cs);

    // Close the pipe.
    if (m_pSrvBuffer != NULL)
    {
        m_pSrvBuffer->Release();
        m_pSrvBuffer = NULL;
    }

    if (m_hProv != NULL)
    {
        FreeLibrary(m_hProv);

        m_hProv = NULL;
    }
}

// We don't need to add anything else to the buffer.
BOOL CInprocClient::InitCallback()
{
    return TRUE;
}

#define NC_PROV_NAME    L"NCProv.dll"

typedef BOOL (WINAPI *FPINPROC_CONNECT)(LPCWSTR, IPostBuffer*, IPostBuffer**);

BOOL CInprocClient::GetBuffer()
{
    TRACE("Attempting to get server buffer...");

    CInCritSec cs(&m_cs);

    SetLastError(0);

#define MAX_RETRIES 10

    if (m_pSrvBuffer == NULL)
    {
        // Get the server's buffer.
        HANDLE hProv = GetModuleHandleW(NC_PROV_NAME);

        // Make sure the 'real' event provider has been loaded.
        if (hProv != NULL)
        {
            // Increase the ref count on the library so it doesn't ever get
            // pulled out from under us.
            m_hProv = LoadLibraryW(NC_PROV_NAME);

            if (m_hProv != NULL)
            {
                FPINPROC_CONNECT fpInprocConnect;
                
                fpInprocConnect = 
                    (FPINPROC_CONNECT) GetProcAddress(m_hProv, "InprocConnect");

                if (fpInprocConnect)
                {
                    BOOL bRet;

                    bRet =
                        fpInprocConnect(
                            m_szPipeName,
                            this,
                            &m_pSrvBuffer);
                }
            }
        }
        
        if (m_pSrvBuffer != NULL)
        {
            TRACE("Got the server buffer, calling IncEnabledCount.");

            if(!m_pConnection->IndicateProvEnabled())
                return FALSE;
        }
        else
        {
            TRACE("Failed to get server buffer.");

            DeinitBuffer();
        }
    }
    else
        TRACE("Already have a valid server buffer.");

    return m_pSrvBuffer != NULL;
}

DWORD WINAPI CInprocClient::ProviderReadyThreadProc(CInprocClient *pThis)
{
    HANDLE hwaitReady[2] = { pThis->m_heventDone, pThis->m_heventProviderReady };
    
    TRACE("(Inproc) Waiting for provider ready event.");

    while (WaitForMultipleObjects(2, hwaitReady, FALSE, INFINITE) == 1 &&
        !pThis->GetBuffer())
    {
        Sleep(100);
    }

    return 0;
}

// IPostBuffer
ULONG CInprocClient::AddRef()
{
    return InterlockedIncrement(&m_iRef);
}

ULONG CInprocClient::Release()
{
    LONG lRet = InterlockedDecrement(&m_iRef);

    if (!lRet)
        delete this;

    return lRet;
}

HRESULT CInprocClient::PostBuffer(LPBYTE pData, DWORD dwSize)
{
    HRESULT hr;

    hr = m_pConnection->ProcessMessage(pData, dwSize);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncobjapi\inproc.h ===
// Inproc.h

#pragma once

#include "NCDefs.h"
#include "Transport.h"

class CInprocClient : public CTransport, public IPostBuffer
{
public:
    CInprocClient();

    virtual ~CInprocClient();

    // Overrideables
    virtual IsReady();
    virtual BOOL SendData(LPBYTE pBuffer, DWORD dwSize);
    virtual void Deinit();
    virtual BOOL InitCallback();
    virtual void SendMsgReply(NC_SRVMSG_REPLY *pReply);

    // Init function.
    virtual BOOL Init(LPCWSTR szBasePipeName, LPCWSTR szBaseProviderName);

    BOOL SignalProviderDisabled();

    // IPostBuffer
    virtual ULONG AddRef();
    virtual ULONG Release();
    virtual HRESULT PostBuffer(LPBYTE pData, DWORD dwSize);

protected:
    HANDLE // Objects visible to P2 client but created by the server.
           m_heventProviderReady,
           // Other handles used for implementation
           m_hthreadReady,
           m_heventDone;

    IPostBuffer *m_pSrvBuffer;

    WCHAR     m_szPipeName[MAX_PATH];
    BOOL      m_bDone;
    HINSTANCE m_hProv;

    void DeinitBuffer();
    BOOL GetBuffer();

    BOOL StartReadyThreadProc();
    static DWORD WINAPI ProviderReadyThreadProc(CInprocClient *pThis);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncobjapi\namedpipe.h ===
// NamedPipe.h

#pragma once

#include "Transport.h"

#define CALLBACK_BUFFSIZE   2048

struct READ_DATA
{
    OVERLAPPED       overlap;
    BYTE             cBuffer[CALLBACK_BUFFSIZE];
    class CNamedPipeClient *pThis;
};

class CNamedPipeClient : public CTransport
{
public:
    CNamedPipeClient();
    virtual ~CNamedPipeClient();

    // Overrideables
    virtual IsReady();
    virtual BOOL SendData(LPBYTE pBuffer, DWORD dwSize);
    virtual void Deinit();
    virtual BOOL InitCallback();
    virtual void SendMsgReply(NC_SRVMSG_REPLY *pReply);


    // Init function.
    virtual BOOL Init(LPCWSTR szBasePipeName, LPCWSTR szBaseProviderName);

    BOOL SignalProviderDisabled();

protected:
    HANDLE // Objects visible to P2 client but created by the server.
           m_hPipe,
           m_heventProviderReady,
           // Other handles used for implementation
           m_hthreadReady,
           m_heventDone;

    WCHAR  m_szPipeName[MAX_PATH],
           m_szProviderReadyEvent[MAX_PATH];
    BOOL   m_bDone;

    void DeinitPipe();
    BOOL GetPipe();
    static DWORD WINAPI ProviderReadyThreadProc(CNamedPipeClient *pThis);
    static void WINAPI CompletedReadRoutine(
        DWORD dwErr, 
        DWORD nBytesRead, 
        LPOVERLAPPED pOverlap);

    BOOL StartReadyThreadProc();
    long DealWithBuffer(READ_DATA* pData, DWORD dwOrigBytesRead, 
                        BOOL* pbClosePipe);


    // Callback properties.
    HANDLE m_heventCallbackReady,
           m_hthreadCallbackListen;

    // Callback methods.
    static DWORD WINAPI CallbackListenThreadProc(CNamedPipeClient *pThis);
    BOOL StartCallbackListenThread();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncobjapi\precomp.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__BD36E0C8_A21A_4DB9_BCAB_25D8E49BD767__INCLUDED_)
#define AFX_STDAFX_H__BD36E0C8_A21A_4DB9_BCAB_25D8E49BD767__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// Insert your headers here
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#undef _CRTIMP
#define _CRTIMP
#include <yvals.h>
#undef _CRTIMP
#define _CRTIMP __declspec(dllimport)

#include <windows.h>
#include <tchar.h>
#include <crtdbg.h>
#include <objbase.h>
#include <wbemint.h> // For _IWmiObject
#include <sddl.h>

// This makes WMIAPI == dllexport stuff
#define ISP2PDLL

// Change this to use shared memory or named pipes.
#define NAMED_PIPES

// Because our template names get so long, we have to disable the 'debug name 
// truncated' warning.
#pragma warning ( disable : 4786)

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__BD36E0C8_A21A_4DB9_BCAB_25D8E49BD767__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncobjapi\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	P2Prov.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "precomp.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncobjapi\namedpipe.cpp ===
// NamedPipe.cpp

#include "precomp.h"
#include "NamedPipe.h"
#include "NCDefs.h"
#include "DUtils.h"
#include "Connection.h"

CNamedPipeClient::CNamedPipeClient() :
    m_hPipe(INVALID_HANDLE_VALUE),
    m_hthreadReady(NULL),
    m_heventProviderReady(NULL),
    m_heventDone(NULL),
    m_heventCallbackReady(NULL),
    m_hthreadCallbackListen(NULL),
    m_bDone(FALSE)
{
}    

CNamedPipeClient::~CNamedPipeClient()
{
}

CNamedPipeClient::IsReady()
{
    return m_hPipe != INVALID_HANDLE_VALUE;
}

BOOL CNamedPipeClient::SendData(LPBYTE pBuffer, DWORD dwSize)
{
    BOOL  bWritten;
    DWORD dwWritten;

#ifdef NO_SEND
    bWriten = TRUE;
#else
    bWritten = 
        WriteFile(
            m_hPipe,
            pBuffer,
            dwSize,
            &dwWritten,
            NULL);

    if (!bWritten)
    {
        TRACE("%d: WriteFile failed, err = %d", GetCurrentProcessId(), GetLastError());
        
        DeinitPipe();

        // Start watching for our provider to be ready, and get the pipe.
        StartReadyThreadProc();
    }
#endif

    return bWritten;
}

void CNamedPipeClient::Deinit()
{
    HANDLE hthreadReady,
           hthreadCallbackListen;

    // Protect m_bDone, m_hthreadReady, m_hthreadCallbackListen.
    {
        CInCritSec cs(&m_cs);

        hthreadReady = m_hthreadReady;
        hthreadCallbackListen = m_hthreadCallbackListen;

        m_hthreadReady = NULL;
        m_hthreadCallbackListen = NULL;

        m_bDone = TRUE;
    }

    // Tells both the ready and the callback listen threads to go away.
    SetEvent(m_heventDone);

    if (hthreadReady)
    {
        WaitForSingleObject(hthreadReady, INFINITE);
        CloseHandle(hthreadReady);
    }

    if (hthreadCallbackListen)
    {
        WaitForSingleObject(hthreadCallbackListen, INFINITE);
        CloseHandle(hthreadCallbackListen);
    }

    DeinitPipe();

    CloseHandle(m_heventDone);

    delete this;
}

// Init function.
BOOL CNamedPipeClient::Init(LPCWSTR szBaseNamespace, LPCWSTR szBaseProvider)
{
    //HANDLE heventProviderReady;

    // Get the ready event.
    swprintf(
        m_szProviderReadyEvent, 
        OBJNAME_EVENT_READY L"%s%s", 
        szBaseNamespace,
        szBaseProvider);

    // Construct the pipe name.
    swprintf(
        m_szPipeName, 
        L"\\\\.\\pipe\\" OBJNAME_NAMED_PIPE L"%s%s", 
        szBaseNamespace,
        szBaseProvider);

    m_heventDone =
        CreateEvent(NULL, TRUE, FALSE, NULL);
    if(m_heventDone == NULL)
        return FALSE;

    // Before we start the thread see if our provider is ready right off 
    // the bat.
    if (!GetPipe())
        return StartReadyThreadProc();

    return TRUE;
}

BOOL CNamedPipeClient::SignalProviderDisabled()
{
    if (m_hPipe != INVALID_HANDLE_VALUE)
    {
        m_pConnection->IndicateProvDisabled();

        DeinitPipe();

        if(!StartReadyThreadProc())
            return FALSE;
    }
    return TRUE;
}

BOOL CNamedPipeClient::StartReadyThreadProc()
{
    DWORD dwID;

    // Protect m_bDone and m_hthreadReady.
    CInCritSec cs(&m_cs);

    // No need if we're already cleaning up.
    if (m_bDone)
        return TRUE;

    if (m_hthreadReady)
        CloseHandle(m_hthreadReady);

    m_hthreadReady =
        CreateThread(
            NULL,
            0,
            (LPTHREAD_START_ROUTINE) ProviderReadyThreadProc,
            this,
            0,
            &dwID);

    if(m_hthreadReady == NULL)
        return FALSE;

    return TRUE;
}

void CNamedPipeClient::DeinitPipe()
{
    CInCritSec cs(&m_cs);

    // Close the pipe.
    if (m_hPipe != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_hPipe);
        m_hPipe = INVALID_HANDLE_VALUE;
    }
}

BOOL CNamedPipeClient::GetPipe()
{
    // This block must be protected to keep other threads
    // from also trying to get the pipe.

    TRACE("Attempting to get event pipe...");

    CInCritSec cs(&m_cs);

    SetLastError(0);

#define MAX_RETRIES 10

    if (m_hPipe == INVALID_HANDLE_VALUE)
    {
        // Get the pipe
        for (int i = 0; i < MAX_RETRIES; i++)
        {
            m_hPipe =
                CreateFileW(
                    m_szPipeName, 
                    GENERIC_READ | GENERIC_WRITE, 
                    0, 
                    NULL, 
                    OPEN_EXISTING, 
                    FILE_FLAG_OVERLAPPED | SECURITY_IDENTIFICATION | 
                    SECURITY_SQOS_PRESENT,
                    NULL);

            if ( m_hPipe != INVALID_HANDLE_VALUE )
            {
                //
                // we want to handle Reads using message mode.
                //
 
                DWORD dwMode = PIPE_READMODE_MESSAGE;
                
                if ( SetNamedPipeHandleState( m_hPipe, &dwMode, NULL, NULL ) )
                {
                    break;
                }
                else
                {
                    TRACE("SetNamedPipeHandleState() Failed.");
                }
            }
            else if (GetLastError() == ERROR_PIPE_BUSY)
            {
                TRACE("Pipe is busy, we'll try again.");

                // Try again to get a pipe instance if the pipe is currently busy.
                Sleep(100);

                continue;
            }
        } 

        if (m_hPipe != INVALID_HANDLE_VALUE)
        {
            TRACE("Got the pipe, calling IncEnabledCount.");

            if(!m_pConnection->IndicateProvEnabled())
                return FALSE;
        }
        else
            TRACE("Failed to get send pipe.");
    }
    else
        TRACE("Already have a valid pipe.");

    return m_hPipe != INVALID_HANDLE_VALUE;
}

DWORD WINAPI CNamedPipeClient::ProviderReadyThreadProc(CNamedPipeClient *pThis)
{
    HANDLE hwaitReady[2];

    hwaitReady[0] = pThis->m_heventDone;
    
    // Create the provider ready event.
    hwaitReady[1] =
        OpenEventW(
            SYNCHRONIZE,
            FALSE,
            pThis->m_szProviderReadyEvent);

    if (!hwaitReady[1])
    {
        PSECURITY_DESCRIPTOR pSD = NULL;
        DWORD                dwSize;

        ConvertStringSecurityDescriptorToSecurityDescriptorW(
            ESS_EVENT_SDDL,  // security descriptor string
            SDDL_REVISION_1, // revision level
            &pSD,            // SD
            &dwSize);

        SECURITY_ATTRIBUTES sa = { sizeof(sa), pSD, FALSE };

        hwaitReady[1] =
            CreateEventW(
                &sa,
                TRUE,
                FALSE,
                pThis->m_szProviderReadyEvent);

        DWORD dwErr = GetLastError();

        if (pSD)
            LocalFree((HLOCAL) pSD);

        if (!hwaitReady[1])
        {
            TRACE("Couldn't create provider ready event: %d", dwErr);

            return 0;
        }
    }

    TRACE("(Pipe) Waiting for provider ready event.");

    while (WaitForMultipleObjects(2, hwaitReady, FALSE, INFINITE) == 1 &&
        !pThis->GetPipe())
    {
        // TODO: Should we close the ready event and then reopen it after we 
        // sleep?
        Sleep(100);
    }

    // Close the provider ready event.
    CloseHandle(hwaitReady[1]);

    return 0;
}

BOOL CNamedPipeClient::InitCallback()
{
    if (!m_heventCallbackReady)
    {
        m_heventCallbackReady = CreateEvent(NULL, FALSE, FALSE, NULL);
        if(m_heventCallbackReady == NULL)
            return FALSE;
    }

    if(!StartCallbackListenThread())
        return FALSE;

    return TRUE;
}

#define PIPE_SIZE   64000
#define CONNECTING_STATE 0 
#define READING_STATE    1 
#define WRITING_STATE    2 


void CNamedPipeClient::SendMsgReply(NC_SRVMSG_REPLY *pReply)
{
    if (pReply)
        SendData((LPBYTE) pReply, sizeof(*pReply));    
}


DWORD WINAPI CNamedPipeClient::CallbackListenThreadProc(CNamedPipeClient *pThis)
{
    READ_DATA dataRead;
    HANDLE    heventPipeDied = CreateEvent(NULL, TRUE, FALSE, NULL),
              hWait[2] = { pThis->m_heventDone, heventPipeDied };

    ZeroMemory(&dataRead.overlap, sizeof(dataRead.overlap));
    
    // Since ReadFileEx doesn't use the hEvent, we'll use it to signal this proc
    // that something went wrong with the pipe and should try to reconnect.
    dataRead.overlap.hEvent = heventPipeDied;
    dataRead.pThis = pThis;

    // Our callback is ready, so indicate that it's so.
    SetEvent(pThis->m_heventCallbackReady);

    BOOL bRet;

    bRet =
        ReadFileEx(
            pThis->m_hPipe,
            dataRead.cBuffer,
            sizeof(dataRead.cBuffer),
            (OVERLAPPED*) &dataRead,
            (LPOVERLAPPED_COMPLETION_ROUTINE) CompletedReadRoutine);

    if (bRet)
    {
        DWORD dwRet;

        while ((dwRet = WaitForMultipleObjectsEx(2, hWait, FALSE, INFINITE, TRUE))
            == WAIT_IO_COMPLETION)
        {
        }

        CloseHandle(heventPipeDied);

        // Note: If dwRet == 0, our done event fired and it's time to get out.

        // If we got the event that says our pipe went bad, tell our provider that
        // it's now disabled.
        if (dwRet == 1)
            pThis->SignalProviderDisabled();
    }
    else
        pThis->SignalProviderDisabled();

    return 0;
}

void WINAPI CNamedPipeClient::CompletedReadRoutine(
    DWORD dwErr, 
    DWORD nBytesRead, 
    LPOVERLAPPED pOverlap) 
{ 
    READ_DATA        *pData = (READ_DATA*) pOverlap;
    CNamedPipeClient *pThis = pData->pThis;
 
    BOOL bClosePipe = FALSE;

    if(dwErr == 0)
    {
        if (nBytesRead)
        {
            pThis->DealWithBuffer(pData, nBytesRead, &bClosePipe);
        }
    
        if(!bClosePipe)
        {
            bClosePipe = !ReadFileEx( 
                pThis->m_hPipe, 
                pData->cBuffer, 
                sizeof(pData->cBuffer), 
                (OVERLAPPED*) pData, 
                (LPOVERLAPPED_COMPLETION_ROUTINE) CompletedReadRoutine); 
        }
    }
    else
    {
        bClosePipe = TRUE;
    }

    if(bClosePipe)
    {
        // Close the event to tell our read loop to go away.
        SetEvent(pData->overlap.hEvent);
    }
} 

long CNamedPipeClient::DealWithBuffer(READ_DATA* pData, DWORD dwOrigBytesRead, 
                                        BOOL* pbClosePipe)
{
    //
    // Check if the actual message is longer that the buffer
    //

    DWORD dwMessageLength = *(DWORD*)pData->cBuffer;
    *pbClosePipe = FALSE;
    BOOL bDeleteBuffer = FALSE;

    if(dwMessageLength != dwOrigBytesRead)
    {
        //
        // Have to read the rest of it --- the message was larger than the
        // buffer
        //

        BYTE* pNewBuffer = new BYTE[dwMessageLength - sizeof(DWORD)];
        if(pNewBuffer == NULL)
            return ERROR_OUTOFMEMORY;

        memcpy(pNewBuffer, pData->cBuffer + sizeof(DWORD), 
                    dwOrigBytesRead - sizeof(DWORD));

        OVERLAPPED ov;
        memset(&ov, 0, sizeof ov);
        ov.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if(ov.hEvent == NULL)
        {
            delete [] pNewBuffer;
            return GetLastError();
        }

        DWORD dwExtraBytesRead = 0;
        BOOL bSuccess = ReadFile(m_hPipe, 
                                pNewBuffer + dwOrigBytesRead - sizeof(DWORD), 
                                dwMessageLength - dwOrigBytesRead,
                                &dwExtraBytesRead,
                                &ov);
        CloseHandle(ov.hEvent);
        if(!bSuccess)
        {
            long lRes = GetLastError();
            if(lRes == ERROR_IO_PENDING)
            {
                //
                // Fine, I can wait, I got nowhere else to go
                //

                if(!GetOverlappedResult(m_hPipe,
                        &ov, &dwExtraBytesRead, TRUE))
                {
                    *pbClosePipe = TRUE;
                    delete [] pNewBuffer;
                    return GetLastError();
                }
            }
            else
            {
                *pbClosePipe = TRUE;
                delete [] pNewBuffer;
                return lRes;
            }
        }

        if(dwExtraBytesRead != dwMessageLength - dwOrigBytesRead)
        {
            *pbClosePipe = TRUE;
            delete [] pNewBuffer;
            return ERROR_OUTOFMEMORY;
        }

        //
        // Process it
        //

        try
        {
            m_pConnection->ProcessMessage(pNewBuffer, 
                                        dwMessageLength - sizeof(DWORD));
        }
        catch(...)
        {
            *pbClosePipe = FALSE;
            delete [] pNewBuffer;
            return ERROR_OUTOFMEMORY;
        }

        delete [] pNewBuffer;
    }
    else
    {
        //
        // All here --- just process it
        //
                
        try
        {
            m_pConnection->ProcessMessage(pData->cBuffer + sizeof(DWORD), 
                                        dwMessageLength - sizeof(DWORD));
        }
        catch(...)
        {
            *pbClosePipe = FALSE;
            return ERROR_OUTOFMEMORY;
        }
    }

    return ERROR_SUCCESS;
}

BOOL CNamedPipeClient::StartCallbackListenThread()
{
    DWORD dwID;

    // Protect m_bDone and m_hthreadCallbackListen.
    {
        CInCritSec cs(&m_cs);

        if (m_bDone)
            return TRUE;

        m_hthreadCallbackListen =
            CreateThread(
                NULL,
                0,
                (LPTHREAD_START_ROUTINE) CallbackListenThreadProc,
                this,
                0,
                &dwID);
        if(m_hthreadCallbackListen == NULL)
            return FALSE;
    }

    // We have to make sure our callback pipe has been created before we can
    // continue.
    WaitForSingleObject(m_heventCallbackReady, INFINITE);
    CloseHandle(m_heventCallbackReady);
    m_heventCallbackReady = NULL;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncobjapi\ncobjapi.cpp ===
// P2Prov.cpp : Defines the entry point for the DLL application.
//

#include "precomp.h"
#include <crtdbg.h>
#include "buffer.h"
#include "NCDefs.h"
#include "NCObjApi.h"
#include "dutils.h"

#include "Connection.h"
#include "Event.h"

#include "Transport.h"
#include "NamedPipe.h"
#include "EventTrace.h"

#include <stdio.h>

#define DWORD_ALIGNED(x)    ((DWORD)((((x) * 8) + 31) & (~31)) / 8)

/////////////////////////////////////////////////////////////////////////////
// DllMain

BOOL APIENTRY DllMain(
    HANDLE hModule, 
    DWORD  dwReason, 
    LPVOID lpReserved)
{
    return TRUE;
}


void SetOutOfMemory()
{
    SetLastError(ERROR_OUTOFMEMORY);
}

/////////////////////////////////////////////////////
// Functions exposed in DLL

// Register to send events
HANDLE WMIAPI WmiEventSourceConnect(
    LPCWSTR szNamespace,
    LPCWSTR szProviderName,
    BOOL bBatchSend,
    DWORD dwBatchBufferSize,
    DWORD dwMaxSendLatency,
    LPVOID pUserData,
    LPEVENT_SOURCE_CALLBACK pCallback)
{
    if(szNamespace == NULL)
    {
        _ASSERT(FALSE);
        return NULL;
    }

    if(szProviderName == NULL)
    {
        _ASSERT(FALSE);
        return NULL;
    }

    CConnection *pConnection = NULL;
    CSink       *pSink = NULL;

    if (!szNamespace || !szProviderName)
        return NULL;

    try
    {
        pConnection = 
            new CConnection(bBatchSend, dwBatchBufferSize, dwMaxSendLatency);

        if (pConnection)
        {
            if (pConnection->Init(
                szNamespace, 
                szProviderName,
                pUserData,
                pCallback))
            {
                pSink = pConnection->GetMainSink();
            }
            else
            {
                delete pConnection;
                pConnection = NULL;

                SetOutOfMemory();
            }
        }
        else
            SetOutOfMemory();
    }
    catch(...)
    {
        SetOutOfMemory();
    }

    return (HANDLE) pSink;
}

void WMIAPI WmiEventSourceDisconnect(HANDLE hSource)
{
    if (!hSource)
    {
        _ASSERT(FALSE);
        return;
    }

    try
    {
        CSink *pSink = (CSink*) hSource;

        // Is this the primary sink?
        if (pSink->GetSinkID() == 0)
            delete pSink->GetConnection();
        else
        {
            pSink->GetConnection()->RemoveSink(pSink);

            delete pSink;
        }
    }
    catch(...)
    {
    }
}

// For adding properties one at a time.
HANDLE WMIAPI WmiCreateObject(
    HANDLE hSource,
    LPCWSTR szEventName,
    DWORD dwFlags)
{
    if (!hSource)
        return NULL;

    return 
        WmiCreateObjectWithProps(
            hSource,
            szEventName,
            dwFlags,
            0,
            NULL,
            NULL);
}

BOOL WMIAPI WmiResetObject(
    HANDLE hObject)
{
    if (!hObject)
        return FALSE;

    try
    {
        CEvent *pBuffer = ((CEventWrap *) hObject)->GetEvent();

        pBuffer->ResetEvent();
    }
    catch(...)
    {
    }

    return TRUE;
}

DWORD dwSet = 0;

BOOL WMIAPI WmiCommitObject(
    HANDLE hObject)
{
    BOOL bRet = FALSE;

    if (!hObject)
        return FALSE;

    try
    {
        CEvent *pBuffer = ((CEventWrap*) hObject)->GetEvent();

        bRet = pBuffer->SendEvent();
    }
    catch(...)
    {
    }

    return bRet;
}

BOOL WMIAPI WmiDestroyObject(
    HANDLE hObject)
{

    if (!hObject)
    {
        _ASSERT(FALSE);
        return FALSE;
    }

    try
    {
        delete (CEventWrap *) hObject;
    }
    catch(...)
    {
    }

    return TRUE;
}


HANDLE WMIAPI WmiCreateObjectWithProps(
    HANDLE hSource,
    LPCWSTR szEventName,
    DWORD dwFlags,
    DWORD nPropertyCount,
    LPCWSTR *pszPropertyNames,
    CIMTYPE *pPropertyTypes)
{
    CSink      *pSink = NULL;
    CEventWrap *pWrap = NULL;

    if (!hSource || !szEventName)
        return NULL;

    if((dwFlags & ~WMI_CREATEOBJ_LOCKABLE) != 0)
        return NULL;

    try
    {
        pSink = (CSink*) hSource;
        pWrap = new CEventWrap(pSink, dwFlags);

        if (pWrap)
        {
            CEvent *pEvent = pWrap->GetEvent();

            if (pWrap->GetEvent()->PrepareEvent(
                szEventName,
                nPropertyCount,
                pszPropertyNames,
                pPropertyTypes))
            {
                // Figure out if this event should be enabled (ready to be fired) 
                // or not.
                pSink->EnableEventUsingList(pEvent);
            }
            else
            {
                delete pWrap;
                pWrap = NULL;
            }
        }
        else
            SetOutOfMemory();
    }
    catch(...)
    {
    }
    
    return (HANDLE) pWrap;
}

HANDLE WMIAPI WmiCreateObjectPropSubset(
    HANDLE hObject,
    DWORD dwFlags,
    DWORD nPropertyCount,
    DWORD *pdwPropIndexes)
{
    CEventWrap *pWrap = (CEventWrap *) hObject;
    CEventWrap *pSubset = NULL;

    if (!pWrap)
        return NULL;

    if((dwFlags & ~WMI_CREATEOBJ_LOCKABLE) != 0)
        return NULL;

    try
    {
        pSubset = new CEventWrap(pWrap->GetEvent(), nPropertyCount, 
                                pdwPropIndexes);

        if (!pSubset)
            SetOutOfMemory();
    }
    catch(...)
    {
    }

    return (HANDLE) pSubset;
}

BOOL WMIAPI WmiAddObjectProp(
    HANDLE hObject,
    LPCWSTR szPropertyName,
    CIMTYPE type,
    DWORD *pdwPropIndex)
{
    BOOL bRet;

    if (!hObject || !szPropertyName)
        return FALSE;

    try
    {
        CEvent *pBuffer = ((CEventWrap *) hObject)->GetEvent();

        bRet = pBuffer->AddProp(szPropertyName, type, pdwPropIndex);
    }
    catch(...)
    {
        bRet = FALSE;
    }

    return bRet;
}

BOOL WMIAPI WmiSetObjectProp(
    HANDLE hObject,
    DWORD dwPropIndex,
    ...)
{
    BOOL bRet;

    if (!hObject)
        return FALSE;

    try
    {
        CEventWrap *pWrap = (CEventWrap *) hObject;

        va_list list;

        va_start(list, dwPropIndex);

        bRet =
            pWrap->GetEvent()->SetSinglePropValue(
                pWrap->SubIndexToEventIndex(dwPropIndex), 
                list);
                //((LPBYTE) &dwPropIndex) + sizeof(dwPropIndex));
    }
    catch(...)
    {
        bRet = FALSE;
    }

    return bRet;
}

BOOL WMIAPI WmiGetObjectProp(
    HANDLE hObject,
    DWORD dwPropIndex,
    LPVOID pData,
    DWORD dwBufferSize,
    DWORD *pdwBytesRead)
{
    BOOL bRet;

    if (!hObject)
        return FALSE;

    try
    {
        CEventWrap *pWrap = (CEventWrap *) hObject;

        bRet = 
            pWrap->GetEvent()->GetPropValue(
                pWrap->SubIndexToEventIndex(dwPropIndex), 
                pData, 
                dwBufferSize, 
                pdwBytesRead);
    }
    catch(...)
    {
        bRet = FALSE;
    }

    return bRet;
}

BOOL WMIAPI WmiSetObjectPropNull(
    HANDLE hObject,
    DWORD dwPropIndex)
{
    BOOL bRet;

    if (!hObject)
        return FALSE;

    try
    {
        CEventWrap *pWrap = (CEventWrap *) hObject;

        bRet = 
            pWrap->GetEvent()->SetPropNull(
                pWrap->SubIndexToEventIndex(dwPropIndex));
    }
    catch(...)
    {
        bRet = FALSE;
    }

    return bRet;
}

BOOL WMIAPI WmiSetObjectProps(
    HANDLE hObject,
    ...)
{
    BOOL bRet;
    
    if (!hObject)
        return FALSE;

    try
    {
        CEventWrap *pWrap = (CEventWrap *) hObject;
        va_list    list;

        va_start(list, hObject);

        bRet = 
            pWrap->GetEvent()->SetPropValues(
                pWrap->GetIndexArray(),
                list);

                //((LPBYTE) &hObject) + sizeof(HANDLE));

    }
    catch(...)
    {
        bRet = FALSE;
    }

    return bRet;
}

BOOL WMIAPI WmiSetAndCommitObject(
    HANDLE hObject,
    DWORD dwFlags,
    ...)
{
    BOOL bRet;
    
    if (!hObject)
        return FALSE;

    if((dwFlags & ~WMI_SENDCOMMIT_SET_NOT_REQUIRED & ~WMI_USE_VA_LIST) != 0)
        return FALSE;

    try
    {
        CEventWrap *pWrap = (CEventWrap *) hObject;
        CEvent     *pEvent = pWrap->GetEvent();
        BOOL       bEnabled = pEvent->IsEnabled();

        // If the data to be set isn't important and if the event isn't
        // enabled, just return TRUE.
        if ((dwFlags & WMI_SENDCOMMIT_SET_NOT_REQUIRED) && !bEnabled)
        {
            bRet = TRUE;
        }
        else
        {
            va_list *pList;
            va_list list;

            va_start(list, dwFlags); 
            
            if (!(dwFlags & WMI_USE_VA_LIST))
                pList = &list;
            else
                pList = va_arg(list, va_list*);

            // Make sure we have the event locked until we commit the values
            // we set.
            CCondInCritSec cs(&pEvent->m_cs, pEvent->IsLockable());

            bRet = 
                pEvent->SetPropValues(
                    pWrap->GetIndexArray(),
                    *pList);

            if (bEnabled && bRet)
                WmiCommitObject(hObject);
        }
    }
    catch(...)
    {
        bRet = FALSE;
    }

    return bRet;
}


BOOL WMIAPI WmiReportEvent(
    HANDLE hSource,
    LPCWSTR szClassName,
    LPCWSTR szFormat,
    ...)
{
    CSink  *pSink = (CSink*) hSource;
    HANDLE hEvent;
    BOOL   bRet = FALSE;

    if (!pSink || !szClassName || !szFormat)
        return FALSE;

    try
    {
        hEvent = 
            pSink->m_mapReportEvents.GetEvent(
                hSource, szClassName, szFormat);

        if (hEvent != NULL)
        {
            CEventWrap *pWrap = (CEventWrap *) hEvent;
            CEvent     *pEvent = pWrap->GetEvent();
    
            if (pEvent->IsEnabled())
            {
                va_list list;

                va_start(list, szFormat);

                bRet = 
                    pWrap->GetEvent()->SetPropValues(
                        pWrap->GetIndexArray(),
                        list);

                if (bRet)
                    WmiCommitObject(hEvent);
            }
        }
    }
    catch(...)
    {
        bRet = FALSE;
    }

    return bRet;
}

#define MAX_STACK_BUFFER    4096

BOOL WMIAPI WmiReportEventBlob(
    HANDLE hConnection,
    LPCWSTR szClassName,
    LPVOID pData,
    DWORD dwSize)
{
    CSink *pSink = (CSink*) hConnection;
    BOOL  bRet = FALSE;

    if (!pSink || !szClassName)
        return FALSE;

    try
    {
        //if (pConn->IsReady() && pConn->IsEventClassEnabled(szClassName))
        if (pSink->IsEventClassEnabled(szClassName))
        {
            BYTE*  cBuffer = new BYTE[MAX_STACK_BUFFER];
			if (cBuffer == NULL)
				bRet = FALSE;
			else
			{

				DWORD dwSizeNeeded;

				dwSizeNeeded = 
					sizeof(DWORD) * 2 +
					sizeof(DWORD) + (wcslen(szClassName) + 1) * sizeof(WCHAR) +
					sizeof(DWORD) + dwSize;

				dwSizeNeeded = DWORD_ALIGNED(dwSizeNeeded);

				// This will use the stack buffer if we have enough room.  Otherwise
				// it will allocate the buffer.
				CBuffer buffer(dwSizeNeeded <= MAX_STACK_BUFFER ? cBuffer : NULL, 
							dwSizeNeeded, CBuffer::ALIGN_DWORD);

				buffer.Write((DWORD) NC_SRVMSG_BLOB_EVENT);
				buffer.Write(dwSizeNeeded);
				buffer.Write(pSink->GetSinkID());
				buffer.WriteAlignedLenString(szClassName);
				buffer.Write(dwSize);
				buffer.Write(pData, dwSize);

				bRet = 
					pSink->GetConnection()->
						SendData(buffer.m_pBuffer, buffer.GetUsedSize());

				delete cBuffer;
			}
        }
    }
    catch(...)
    {
        bRet = FALSE;
    }

    return bRet;
}

BOOL WMIAPI WmiGetObjectBuffer(
    HANDLE hObject,
    LPVOID *ppLayoutBuffer,
    DWORD *pdwLayoutSize,
    LPVOID *ppDataBuffer,
    DWORD *pdwDataSize)
{
    BOOL bRet;
                   
    if (!hObject)
        return FALSE;

    try
    {
        CEvent *pEvent = ((CEventWrap*) hObject)->GetEvent();

        if (ppLayoutBuffer)
            pEvent->GetLayoutBuffer(
                (LPBYTE*) ppLayoutBuffer, 
                pdwLayoutSize,
                TRUE); 

        if (ppDataBuffer)
            pEvent->GetDataBuffer(
                (LPBYTE*) ppDataBuffer, 
                pdwDataSize,
                TRUE); 

        bRet = TRUE;
    }
    catch(...)
    {
        bRet = FALSE;
    }

    return bRet;
}

HANDLE WMIAPI WmiCreateObjectFromBuffer(
    HANDLE hSource,
    DWORD dwFlags,
    LPVOID pLayoutBuffer,
    DWORD dwLayoutSize,
    LPVOID pDataBuffer,
    DWORD dwDataSize)
{
    CEventWrap *pWrap;

    if (!hSource || !pLayoutBuffer || !pDataBuffer)
        return NULL;

    if((dwFlags & ~WMI_CREATEOBJ_LOCKABLE) != 0)
        return NULL;

    try
    {
        pWrap = new CEventWrap((CSink*) hSource, dwFlags);

        if (pWrap)
        {
            BOOL bRet;

            bRet =
                pWrap->GetEvent()->SetLayoutAndDataBuffers(
                    (LPBYTE) pLayoutBuffer,
                    dwLayoutSize,
                    (LPBYTE) pDataBuffer,
                    dwDataSize);

            if (!bRet)
            {
                delete pWrap;
        
                pWrap = NULL;
            }
        }
        else
            SetOutOfMemory();
    }
    catch(...)
    {
        pWrap = NULL;
    }

    return (HANDLE) pWrap;
}

void WMIAPI WmiLockObject(HANDLE hObject)
{
    try
    {
        CEvent *pEvent = ((CEventWrap*) hObject)->GetEvent();

        pEvent->Lock();
    }
    catch(...)
    {
    }
}

void WMIAPI WmiUnlockObject(HANDLE hObject)
{
    if (!hObject)
        return;

    try
    {
        CEvent *pEvent = ((CEventWrap*) hObject)->GetEvent();

        pEvent->Unlock();
    }
    catch(...)
    {
    }
}

HANDLE WMIAPI WmiDuplicateObject(
    HANDLE hOldObject,
    HANDLE hNewSource,
    DWORD dwFlags)
{
    CEventWrap *pWrap = NULL;
    BOOL       bRet,
               bLocked = FALSE;
    LPBYTE     pLayout,
               pData;
    DWORD      dwLayoutSize,
               dwDataSize;

    if (!hOldObject || !hNewSource)
        return NULL;

    if((dwFlags & ~WMI_CREATEOBJ_LOCKABLE) != 0)
        return NULL;

    try
    {
        WmiLockObject(hOldObject);

        bLocked = TRUE;

        if (WmiGetObjectBuffer(
            hOldObject,
            (LPVOID*) &pLayout,
            &dwLayoutSize,
            (LPVOID*) &pData,
            &dwDataSize))
        {
            pWrap = new CEventWrap((CSink*) hNewSource, dwFlags);

            if (pWrap)
            {
                bRet =
                    pWrap->GetEvent()->SetLayoutAndDataBuffers(
                        (LPBYTE) pLayout,
                        dwLayoutSize,
                        (LPBYTE) pData,
                        dwDataSize);

                if (!bRet)
                {
                    delete pWrap;
        
                    pWrap = NULL;
                }
                else
                {
                    // Figure out if this event should be enabled (ready to be 
                    // fired) 
                    // or not.

                    ((CSink*)hNewSource)->EnableEventUsingList(
                                                pWrap->GetEvent());
                }
            }
            else
                SetOutOfMemory();
        }

        WmiUnlockObject(hOldObject);
    }
    catch(...)
    {
        if (bLocked)
            WmiUnlockObject(hOldObject);
    }

    return (HANDLE) pWrap;
}


HANDLE WMIAPI WmiCreateObjectWithFormat(
    HANDLE hSource,
    LPCWSTR szClassName,
    DWORD dwFlags,
    LPCWSTR szFormat)
{
    CSink  *pSink = (CSink*) hSource;
    HANDLE hEvent;
    BOOL   bRet = FALSE;

    if (!pSink || !szClassName || !szFormat)
        return NULL;

    if((dwFlags & ~WMI_CREATEOBJ_LOCKABLE) != 0)
        return NULL;

    try
    {
        hEvent = 
            pSink->m_mapReportEvents.CreateEvent(
                hSource, szClassName, dwFlags, szFormat);
    }
    catch(...)
    {
        hEvent = NULL;
    }

    return hEvent;
}

BOOL WMIAPI WmiIsObjectActive(HANDLE hObject)
{
    BOOL bRet;

    if (!hObject)
        return FALSE;

    try
    {
        CEvent *pEvent = ((CEventWrap*) hObject)->GetEvent();

        bRet = pEvent->IsEnabled();
    }
    catch(...)
    {
        bRet = FALSE;
    }

    return bRet;    
}

BOOL WMIAPI WmiSetConnectionSecurity(
    HANDLE hSource,
    SECURITY_DESCRIPTOR *pSD)
{
#ifdef USE_SD
    CSink *pSink = (CSink*) hSource;
    BOOL  bRet;

    if (!pSink)
        return FALSE;

    try
    {
        bRet = pSink->SetSD(pSD);
    }
    catch(...)
    {
        bRet = FALSE;
    }

    return bRet;
#else
	return FALSE;
#endif
}

BOOL WMIAPI WmiSetObjectSecurity(
    HANDLE hObject,
    SECURITY_DESCRIPTOR *pSD)
{
#ifdef USE_SD
    BOOL bRet;

    if (!hObject)
        return FALSE;

    try
    {
        CEvent *pEvent = ((CEventWrap*) hObject)->GetEvent();

        bRet = pEvent->SetSD(pSD);
    }
    catch(...)
    {
        bRet = FALSE;
    }

    return bRet;
#else
	return FALSE;
#endif
}

HANDLE WMIAPI WmiCreateRestrictedConnection(
    HANDLE hSource,
    DWORD nQueries,
    LPCWSTR *szQueries,
    LPVOID pUserData,
    LPEVENT_SOURCE_CALLBACK pCallback)
{
    CSink *pOldSink = (CSink*) hSource,
          *pNewSink;

    if (!pOldSink)
        return NULL;

    try
    {
        pNewSink = pOldSink->GetConnection()->CreateSink(pUserData, pCallback);

        if (pNewSink)
            pNewSink->AddRestrictions(nQueries, szQueries);

    }
    catch(...)
    {
        pNewSink = NULL;
    }

    return (HANDLE) pNewSink;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncobjapi\reportevent.h ===
// ReportEvent.h
// This module contains helpers for the WMIReportEvent function.

#pragma once

#include "NCObjApi.h"
#include <wstlallc.h>
#include <map>

class CReportParams
{
public:
    CReportParams(LPCWSTR szName, LPCWSTR szFormat)
    {
        m_szName = szName;
        m_szFormat = szFormat;
    }

    bool operator < (const CReportParams& other) const
    { 
        return m_szName < other.m_szName && m_szFormat < other.m_szFormat;
    }

    bool operator == (const CReportParams& other) const
    {
        return m_szName == other.m_szName && m_szFormat == other.m_szFormat;
    }

    bool IsEquivalent(const CReportParams& other) const
    {
        // The format string is case-senstive due to printf format characters.
        return !_wcsicmp(m_szName, other.m_szName) && 
            !wcscmp(m_szFormat, other.m_szFormat);
    }

protected:
    LPCWSTR m_szName;
    LPCWSTR m_szFormat;
};

class CReportItem
{
public:
    CReportItem(LPCWSTR szName, LPCWSTR szFormat, HANDLE hEvent)
    {
        m_szName = _wcsdup(szName);
        m_szFormat = _wcsdup(szFormat);
        m_hEvent = hEvent;
    }

    ~CReportItem()
    {
        if (m_szName)
            free(m_szName);

        if (m_szFormat)
            free(m_szFormat);

        if (m_hEvent)
            WmiDestroyObject(m_hEvent);            
    }
        
    HANDLE GetEvent() { return m_hEvent; }
    
protected:
    LPWSTR m_szName;
    LPWSTR m_szFormat;
    HANDLE m_hEvent;
};

class CReportEventMap : protected std::map< CReportParams, 
                                            CReportItem*, 
                                            std::less< CReportParams >, 
                                            wbem_allocator< CReportItem* > >
{
public:
    ~CReportEventMap();

    HANDLE GetEvent(
        HANDLE hConnection, 
        LPCWSTR szName, 
        LPCWSTR szFormat);

    HANDLE CreateEvent(
        HANDLE hConnection, 
        LPCWSTR szName, 
        DWORD dwFlags,
        LPCWSTR szFormat);

protected:
    typedef CReportEventMap::iterator CReportEventMapIterator;
    static CIMTYPE PrintfTypeToCimType(LPCWSTR szType);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncprov\dutils.h ===
// dutils.h

#pragma once

/*
extern "C" void MBTrace(LPCTSTR szFormat, ...);
extern "C" void FTrace(LPCTSTR szFormat, ...);
extern "C" void Trace(LPCTSTR szFormat, ...);

#ifdef USE_FTRACE
#define TRACE  FTrace
#else

#ifndef _DEBUG
#define TRACE  1 ? (void)0 : ::Trace
#else
#define TRACE  ::Trace
#endif
*/

#ifdef _ASSERT
#undef _ASSERT
#endif

#include <wbemutil.h>

//#endif // #ifdef USE_FTRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncprov\localloc.cpp ===
#include "precomp.h"
#include <arena.h>

static class WbemComnInitializer
{
public:

    WbemComnInitializer()
    {
        CWin32DefaultArena::WbemHeapInitialize( GetProcessHeap() );
    }

} g_WbemComnInitializer;

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncobjapi\reportevent.cpp ===
// ReportEvent.cpp
#include "precomp.h"
#include "ReportEvent.h"

CReportEventMap::~CReportEventMap()
{
    for (CReportEventMapIterator i = begin(); i != end(); i++)
        delete ((*i).second);
}

CIMTYPE CReportEventMap::PrintfTypeToCimType(LPCWSTR szType)
{
    CIMTYPE type = 0;
    LPWSTR  szArray = wcsstr(szType, L"[]");

    // Look to see if this should be an array.
    if (szArray)
    {
        type = CIM_FLAG_ARRAY;
        *szArray = 0;
    }

    // See if the remainder of the string is only a single character.
    if (*szType && !*(szType + 1))
    {
        // Set the type for the single character cases.
        switch(*szType)
        {
            case 'u':
                type |= CIM_UINT32;
                break;

            case 'd':
            case 'i':
                type |= CIM_SINT32;
                break;

            case 'f':
                type |= CIM_REAL32;
                break;

            case 'g':
                type |= CIM_REAL64;
                break;

            case 's':
                type |= CIM_STRING;
                break;

            case 'c':
                type |= CIM_UINT8;
                break;

            case 'w':
                type |= CIM_UINT16;
                break;

            case 'b':
                type |= CIM_BOOLEAN;
                break;
    
            case 'o':
                type |= CIM_OBJECT;
                break;

            case 'O':
                type |= CIM_IUNKNOWN;
                break;

            default:
                type = CIM_EMPTY;
                break;
        }
    }
    // Else check for the more complicated cases.
    else if (!wcscmp(szType, L"I64d") || !wcscmp(szType, L"I64i"))
        type |= CIM_SINT64;
    else if (!wcscmp(szType, L"I64u"))
        type |= CIM_UINT64;
    else
        type = CIM_EMPTY;
        
    return type;
}

HANDLE CReportEventMap::CreateEvent(
    HANDLE hConnection, 
    LPCWSTR szName, 
    DWORD dwFlags,
    LPCWSTR szFormat)
{
    LPWSTR szTempFormat = _wcsdup(szFormat);
    HANDLE hEvent;

    // Out of memory?
    if (!szTempFormat)
        return NULL;

    hEvent =
        WmiCreateObject(
            hConnection,
            szName ? szName : L"MSFT_WMI_GenericNonCOMEvent",
            dwFlags);
        
    if (hEvent == NULL)
    {
        free(szTempFormat);
        return NULL;
    }

    LPWSTR szCurrent = wcstok(szTempFormat, L" ");
    BOOL   bBad = FALSE;

    while (szCurrent && !bBad)
    {
        LPWSTR szType = wcschr(szCurrent, '!'),
               szBang2;

        bBad = TRUE;

        if (szType)
        {
            szBang2 = wcschr(szType + 1, '!');

            if (szBang2)
            {
                *szBang2 = 0;
                *szType = 0;
                szType++;

                CIMTYPE type = PrintfTypeToCimType(szType);

                if (type != CIM_EMPTY)
                {
                    bBad =
                        !WmiAddObjectProp(
                            hEvent,
                            szCurrent,
                            type,
                            NULL);       
                }
            }
        }
            
        szCurrent = wcstok(NULL, L" ");
    }

    if (bBad && hEvent)
    {
        // Something went wrong, so blow away the event and return NULL.
        WmiDestroyObject(hEvent);
        hEvent = NULL;
    }

    free(szTempFormat);
    return hEvent;
}


HANDLE CReportEventMap::GetEvent(
    HANDLE hConnection, 
    LPCWSTR szName, 
    LPCWSTR szFormat)
{
    HANDLE                  hEvent;
    CReportParams           params(szName, szFormat);
    CReportEventMapIterator i;

    // First find a match using the pointers, then verify it's a real match
    // by using string compares.
    if ((i = find(params)) != end())
    {
        // If it's a match, return the event we already have.
        if (params.IsEquivalent((*i).first))
            return (*i).second->GetEvent();
        else
        {
            // Was not a match, so free up the mapping.
            delete ((*i).second);
            erase(i);
        }
    }

    hEvent =
        CreateEvent(
            hConnection,
            szName,
            0,
            szFormat);

    if (hEvent)
    {
        // If everything was OK then we need to store this event in our
        // map.
        CReportItem *pItem = new CReportItem(szName, szFormat, hEvent);

        if (pItem)
            (*this)[params] = pItem;
        else
        {
            WmiDestroyObject(hEvent);
            hEvent = NULL;
        }
    }
        
    return hEvent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncobjapi\transport.h ===
// Transport.h
// This is the base class for event transport classes.

#pragma once

#include "buffer.h"
#include "NCDefs.h"

class CConnection;

class CTransport
{
public:
    CTransport() :
        m_iRef(1)
    {
        InitializeCriticalSection(&m_cs);
    }

    virtual ~CTransport()
    {
        DeleteCriticalSection(&m_cs);    
    }

    void SetConnection(CConnection *pConnection) 
    { 
        m_pConnection = pConnection; 
    }

    // Overrideables
    virtual IsReady()=0;
    virtual BOOL SendData(LPBYTE pBuffer, DWORD dwSize)=0;
    virtual void Deinit()=0;
    virtual BOOL InitCallback()=0;
    virtual BOOL Init(LPCWSTR szBasePipeName, LPCWSTR szBaseProviderName)=0;
    virtual BOOL SignalProviderDisabled()=0;
    virtual void SendMsgReply(NC_SRVMSG_REPLY *pReply)=0;

    // Critical section functions
    void Lock() { EnterCriticalSection(&m_cs); }
    void Unlock() { LeaveCriticalSection(&m_cs); }

protected:
    LONG             m_iRef;
    CRITICAL_SECTION m_cs;
    CConnection      *m_pConnection;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncprov\makefile.inc ===
$(O)\ncprov.mof $(O)\ncprov.mfl: ncprov.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\ncprovTmp.mof -MFL:$(O)\ncprovTmp.mfl ncprov.mof
    copy copyright.mof+$(O)\ncprovTmp.mof+$(O)\ncprovTmp.mfl $(O)\ncprov.mof
    copy copyright.mof+$(O)\ncprovTmp.mfl $(O)\ncprov.mfl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncprov\ncprov.cpp ===
// NCSrv.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f NCSrvps.mk in the project directory.

#include "precomp.h"
#include "resource.h"
#include <initguid.h>
#include "NCProv.h"

#include "NCProv_i.c"
#include "NCProvider.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_NCProvider, CNCProvider)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_NCProvLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncprov\ncprovider.cpp ===
// NCProvider.cpp : Implementation of CNCProvider
#include "precomp.h"
#include "NCProv.h"
#include "NCProvider.h"
#include "NCDefs.h"
#include <list>
#include "Buffer.h"
#include "dutils.h"
#include "NCObjAPI.h"
#include <Winntsec.h>

#define COUNTOF(x)  (sizeof(x)/sizeof(x[0]))

// We'll need this for our inproc clients.
CPipeToProvMap g_mapPipeToProv;

/////////////////////////////////////////////////////////////////////////////
// CNCProvider

CNCProvider::CNCProvider() :
    m_heventDone(NULL),
    m_heventConnect(NULL),
    m_hPipe( NULL ),
    m_hthreadConnect(NULL),
    m_heventNewQuery(NULL),
    m_heventCancelQuery(NULL),
    m_heventAccessCheck(NULL),
    m_hConnection(NULL),
    m_pProv(NULL)
{
    InitializeCriticalSection(&m_cs);
}

CNCProvider::~CNCProvider()
{
    DeleteCriticalSection(&m_cs);
}

void CNCProvider::FinalRelease()
{
    //
    // do potentially time consuming cleanup in this function rather than
    // DTOR.  Reason is that ATL decrements the module ref count before calling
    // the DTOR.  This means that a call to DllCanUnloadNow will return TRUE
    // while there is still a call executing in the module.  The race condition
    // is that the module could be unloaded while it is still being executed.
    // ATL will call FinalRelease() before decrementing the module refcount 
    // making this race condition much smaller. COM addresses this race 
    // condition by waiting for a bit to unload the module after returning 
    // TRUE.  This wait can be controlled by the delay unload param to 
    // CoFreeUnusedLibrariesEx().  This allows the call to the last Release()
    // of the COM object to finish, before being unloaded.  
    // 

    if ( m_hthreadConnect )
    {
        SetEvent(m_heventDone);
        WaitForSingleObject( m_hthreadConnect, INFINITE );
        CloseHandle(m_hthreadConnect);
    }

    if (m_heventDone)
        CloseHandle(m_heventDone);

    if (m_heventNewQuery)
        WmiDestroyObject(m_heventNewQuery);

    if (m_heventCancelQuery)
        WmiDestroyObject(m_heventCancelQuery);

    if (m_heventAccessCheck)
        WmiDestroyObject(m_heventAccessCheck);

    if (m_hConnection)
        WmiEventSourceDisconnect(m_hConnection);

    delete m_pProv;
}

HRESULT STDMETHODCALLTYPE CNCProvider::Initialize( 
    /* [in] */ LPWSTR pszUser,
    /* [in] */ LONG lFlags,
    /* [in] */ LPWSTR pszNamespace,
    /* [in] */ LPWSTR pszLocale,
    /* [in] */ IWbemServices __RPC_FAR *pNamespace,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink)
{
    m_pProv = new CProvInfo;

    if ( m_pProv == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    m_pProv->SetNamespace(pNamespace);

    m_hConnection = WmiEventSourceConnect( L"root\\cimv2",
                                           L"Standard Non-COM Event Provider",
                                           FALSE,
                                           64000,
                                           1000,
                                           NULL,
                                           NULL );
    if ( m_hConnection == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    m_heventNewQuery = WmiCreateObjectWithFormat(
                m_hConnection,
                L"MSFT_NC_NewQuery",
                WMI_CREATEOBJ_LOCKABLE,
                L"Namespace!s! ProviderName!s! Result!d! QueryLanguage!s! "
                L"Query!s! ID!d! ");

    m_heventCancelQuery =
            WmiCreateObjectWithFormat(
                m_hConnection,
                L"MSFT_NC_CancelQuery",
                WMI_CREATEOBJ_LOCKABLE,
                L"Namespace!s! ProviderName!s! Result!d! ID!d!");

    m_heventAccessCheck =
            WmiCreateObjectWithFormat(
                m_hConnection,
                L"MSFT_NC_AccessCheck",
                WMI_CREATEOBJ_LOCKABLE,
                L"Namespace!s! ProviderName!s! Result!d! QueryLanguage!s! "
                    L"Query!s! Sid!c[]!");

    if ( m_heventNewQuery == NULL || 
         m_heventCancelQuery == NULL || 
         m_heventAccessCheck == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    m_heventDone = 
        CreateEvent(
            NULL,
            TRUE,
            FALSE,
            NULL);

    if ( m_heventDone == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    try 
    {
        m_strNamespace = pszNamespace;
    }
    catch( _com_error )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    // Tell Windows Management our initialization status.
    return pInitSink->SetStatus( WBEM_S_INITIALIZED, 0 );
}

HRESULT STDMETHODCALLTYPE CNCProvider::SetRegistrationObject(
    LONG lFlags,
    IWbemClassObject __RPC_FAR *pProvReg)
{
    _variant_t vName;

    if (SUCCEEDED(pProvReg->Get(
        L"Name",
        0,
        &vName,
        NULL,
        NULL)))
    {
        m_strProvider = V_BSTR(&vName);
    }

    return S_OK;
}


HRESULT STDMETHODCALLTYPE CNCProvider::AccessCheck( 
    /* [in] */ WBEM_CWSTR wszQueryLanguage,
    /* [in] */ WBEM_CWSTR wszQuery,
    /* [in] */ long lSidLength,
    /* [unique][size_is][in] */ const BYTE __RPC_FAR *pSid)
{
    HRESULT hr;

    try
    {
        hr = 
            m_pProv->AccessCheck(
                wszQueryLanguage, 
                wszQuery, 
                lSidLength, 
                (LPBYTE) pSid);

        WmiSetAndCommitObject(
            m_heventAccessCheck, 
            WMI_SENDCOMMIT_SET_NOT_REQUIRED,

            // Data follows...
            (LPCWSTR) m_strNamespace,
            (LPCWSTR) m_strProvider,
            hr,
            wszQueryLanguage,
            wszQuery,
            pSid, lSidLength);
    }
    catch(...)
    {
        hr = WBEM_E_FAILED;
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE CNCProvider::NewQuery( 
    /* [in] */ DWORD dwID,
    /* [in] */ WBEM_WSTR wszQueryLanguage,
    /* [in] */ WBEM_WSTR wszQuery)
{
    HRESULT hr;

    try
    {
        hr = m_pProv->NewQuery(dwID, wszQueryLanguage, wszQuery);
    }
    catch(...)
    {
        hr = WBEM_E_FAILED;
    }

#if 1
    WmiSetAndCommitObject(
        m_heventNewQuery, 
        WMI_SENDCOMMIT_SET_NOT_REQUIRED,

        // Data follows...
        (LPCWSTR) m_strNamespace,
        (LPCWSTR) m_strProvider,
        hr,
        wszQueryLanguage,
        wszQuery,
        dwID);
#endif

    return hr;
}
        
HRESULT STDMETHODCALLTYPE CNCProvider::CancelQuery( 
    /* [in] */ DWORD dwID)
{
    try
    {
        // Get rid of the query item(s).
        m_pProv->CancelQuery(dwID);
    }
    catch(...)
    {
    }

    WmiSetAndCommitObject(
        m_heventCancelQuery, 
        WMI_SENDCOMMIT_SET_NOT_REQUIRED,

        // Data follows...
        (LPCWSTR) m_strNamespace,
        (LPCWSTR) m_strProvider,
        S_OK,
        dwID);

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CNCProvider::ProvideEvents( 
    /* [in] */ IWbemObjectSink __RPC_FAR *pSink,
    /* [in] */ long lFlags)
{
    DWORD          dwID;
    IWbemEventSink *pEventSink = NULL;
    HRESULT        hr;

    if (SUCCEEDED(pSink->QueryInterface(
        IID_IWbemEventSink, (LPVOID*) &pEventSink)))
    {
        m_pProv->SetSink(pEventSink);
        pEventSink->Release();

        if (!m_hthreadConnect)
        {
            m_hthreadConnect =
                CreateThread(
                    NULL,
                    0,
                    (LPTHREAD_START_ROUTINE) ConnectThreadProc,
                    this,
                    0,
                    &dwID);
        }

        hr = S_OK;
    }
    else
        hr = WBEM_E_FAILED;

    return hr;
}

DWORD WINAPI CNCProvider::ConnectThreadProc(CNCProvider *pThis)
{
    if (SUCCEEDED(CoInitializeEx(NULL, COINIT_MULTITHREADED)))
    {
        pThis->ConnectLoop();

        CoUninitialize();
    }

    return 0;
}

// ConnectToNewClient(HANDLE, LPOVERLAPPED) 
// This function is called to start an overlapped connect operation. 
// It returns TRUE if an operation is pending or FALSE if the 
// connection has been completed. 
 
BOOL CNCProvider::ConnectToNewClient(HANDLE hPipe, LPOVERLAPPED lpo) 
{ 
    BOOL bConnected, 
         bPendingIO = FALSE; 
 
    // Start an overlapped connection for this pipe instance. 
    bConnected = ConnectNamedPipe(hPipe, lpo); 
 
    // Overlapped ConnectNamedPipe should return zero. 
    if (bConnected) 
        return FALSE;
 
    switch (GetLastError()) 
    { 
        // The overlapped connection in progress. 
        case ERROR_IO_PENDING: 
            bPendingIO = TRUE; 
            break; 
 
        // Client is already connected, so signal an event. 
        case ERROR_PIPE_CONNECTED: 
            SetEvent(lpo->hEvent);
            break; 
 
        // If an error occurs during the connect operation... 
        default: 
            return FALSE;
   } 
 
   return bPendingIO; 
} 

#define PIPE_SIZE   64000


BOOL CNCProvider::CreateAndConnectInstance(LPOVERLAPPED lpoOverlap, BOOL bFirst)
{
    SECURITY_ATTRIBUTES sa;
    
    sa.nLength = sizeof( SECURITY_ATTRIBUTES );
    sa.bInheritHandle = FALSE;
    
    LPWSTR lpwszSD = L"D:"              // DACL
                     L"(A;;GA;;;SY)"    // Allow local system full control
                     L"(A;;GRGW;;;LS)"  // Allow local service Read/Write
                     L"(A;;GRGW;;;NS)"; // Allow network service Read/Write

    if ( ConvertStringSecurityDescriptorToSecurityDescriptor( 
            lpwszSD,
            SDDL_REVISION_1,
            &(sa.lpSecurityDescriptor),
            NULL ) )
    {
        long lFlags = PIPE_ACCESS_DUPLEX | // read/write access 
                    FILE_FLAG_OVERLAPPED;  // overlapped mode 
        if( bFirst )
        {
            lFlags |= FILE_FLAG_FIRST_PIPE_INSTANCE;
        }
        
        m_hPipe = CreateNamedPipe( 
            m_szNamedPipe,             // pipe name 
            lFlags,
            PIPE_TYPE_MESSAGE |        // message-type pipe 
               PIPE_READMODE_MESSAGE | // message read mode 
               PIPE_WAIT,              // blocking mode 
            PIPE_UNLIMITED_INSTANCES,  // unlimited instances 
            PIPE_SIZE,                 // output buffer size 
            PIPE_SIZE,                 // input buffer size 
            0,                         // client time-out 
            &sa );                     // security per above

            if ( INVALID_HANDLE_VALUE == m_hPipe )
            {
                return FALSE;
            }
    }
    else
    {
        return FALSE;
    }

    //
    // Make sure that the pipe is owned by us
    // Call a subroutine to connect to the new client.
    //
 
    return ConnectToNewClient(m_hPipe, lpoOverlap); 
} 


void CNCProvider::ConnectLoop()
{
    // Init our provider info which will tell our comless providers that
    // we're ready.

    try
    {
        m_pProv->Init(m_strNamespace, m_strProvider);
    }
    catch( CX_MemoryException )
    {
        return;
    }

    m_heventConnect =
        CreateEvent( 
            NULL,    // no security attribute
            TRUE,    // manual reset event 
            TRUE,    // initial state = signaled 
            NULL);   // unnamed event object 

    //m_pServerPost = new CPostBuffer(this);

    // TODO: We need to indicate an error here.
    if (!m_heventConnect)
        return;

    swprintf(
        m_szNamedPipe, 
        L"\\\\.\\pipe\\" OBJNAME_NAMED_PIPE L"%s%s", 
        (LPCWSTR) m_pProv->m_strBaseNamespace,
        (LPCWSTR) m_pProv->m_strBaseName);

    OVERLAPPED oConnect;
    BOOL       bSuccess,
               bPendingIO;
    HANDLE     hWait[2] = { m_heventDone, m_heventConnect };
    DWORD      dwRet;

    oConnect.hEvent = m_heventConnect;

    bPendingIO = CreateAndConnectInstance(&oConnect, TRUE); // first instance

    g_mapPipeToProv.AddPipeProv(m_szNamedPipe, this);
        
    while ((dwRet = WaitForMultipleObjectsEx(2, hWait, FALSE, INFINITE, TRUE))
        != WAIT_OBJECT_0)
    {
        if ( dwRet == WAIT_FAILED )
        {
            break;
        }

        switch(dwRet)
        {
            case 1:
            {
                if (bPendingIO)
                {
                    DWORD dwBytes;

                    bSuccess =
                        GetOverlappedResult( 
                            m_hPipe,   // pipe handle 
                            &oConnect, // OVERLAPPED structure 
                            &dwBytes,  // bytes transferred 
                            FALSE);    // does not wait 
                    
                    // TODO: This is an error, but what to do?
                    if (!bSuccess) 
                       break;
                }

                CPipeClient *pInfo = new CPipeClient(this, m_hPipe);        

                if (pInfo)
                {
                    bSuccess = 
                        ReadFileEx( 
                            pInfo->m_hPipe, 
                            pInfo->m_bufferRecv.m_pBuffer, 
                            pInfo->m_bufferRecv.m_dwSize, 
                            &pInfo->m_info.overlap, 
                            (LPOVERLAPPED_COMPLETION_ROUTINE) CompletedReadRoutine); 

                    if (!bSuccess)
                        DisconnectAndClose(pInfo);
                }
 
                bPendingIO = CreateAndConnectInstance(&oConnect, FALSE);
                break;
            }

            case WAIT_IO_COMPLETION:
                break;
        }
    }

    g_mapPipeToProv.RemovePipeProv(m_szNamedPipe);

    CloseHandle(m_hPipe);

    CloseHandle(m_heventConnect);
}

void CNCProvider::DisconnectAndClose(CClientInfo *pInfo) 
{ 
    m_pProv->RemoveClient(pInfo);
} 
 
//#define NO_WINMGMT
//#define NO_INDICATE
//#define NO_DECODE

#ifdef NO_INDICATE
DWORD m_dwEvents = 0;
#endif

void WINAPI CNCProvider::CompletedReadRoutine(
    DWORD dwErr, 
    DWORD nBytesRead, 
    LPOVERLAPPED pOverlap) 
{ 
    CPipeClient *pInfo = ((OLAP_AND_CLIENT*) pOverlap)->pInfo;
    CNCProvider *pThis = pInfo->m_pProvider;
 
#ifndef _DEBUG
    try
#endif
    {
#ifndef NO_DECODE
        if (nBytesRead)
        {
            pInfo->PostBuffer(pInfo->m_bufferRecv.m_pBuffer, nBytesRead);
        }
#endif
    }
#ifndef _DEBUG
    catch(...)
    {
    }
#endif

    // The read operation has finished, so write a response (if no 
    // error occurred). 
    if (dwErr == 0) 
    { 
        BOOL bSuccess;

        bSuccess = 
            ReadFileEx( 
                pInfo->m_hPipe, 
                pInfo->m_bufferRecv.m_pBuffer, 
                pInfo->m_bufferRecv.m_dwSize, 
                pOverlap, 
                (LPOVERLAPPED_COMPLETION_ROUTINE) CompletedReadRoutine); 

        if (!bSuccess)
            pThis->DisconnectAndClose(pInfo);
    }
    else
        pThis->DisconnectAndClose(pInfo);
} 


/////////////////////////////////////////////////////////////////////////////
// Inproc helper stuff

/*
~CPipeToProvMap::CPipeToProvMap()
{
}
*/

void CPipeToProvMap::AddPipeProv(LPCWSTR szPipeName, CNCProvider *pProv)
{
    Lock();

    (*this)[szPipeName] = pProv;

    Unlock();
}

void CPipeToProvMap::RemovePipeProv(LPCWSTR szPipeName)
{
    Lock();

    CBstrToProviderIterator item = g_mapPipeToProv.find(szPipeName);

    if (item != g_mapPipeToProv.end())
    {
        //CNCProvider *pProv = (*item).second;

        //pProv->m_pServerPost->SetProvider(NULL);

        erase(item);
    }

    Unlock();
}

BOOL WINAPI InprocConnect(
    LPCWSTR szPipeName,
    IPostBuffer *pClientPost,
    IPostBuffer **ppServerPost)
{
    BOOL bRet;

    g_mapPipeToProv.Lock();

    CBstrToProviderIterator item = g_mapPipeToProv.find(szPipeName);

    if (item != g_mapPipeToProv.end())
    {
        CNCProvider   *pProv = (*item).second;
        CInprocClient *pInfo = new CInprocClient(pProv, pClientPost);

        //pProv->m_prov.AddClient(pInfo);

        pInfo->AddRef();
        
        *ppServerPost = pInfo;

        bRet = TRUE;
    }
    else
        bRet = FALSE;

    g_mapPipeToProv.Unlock();
    
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncprov\eventinfo.h ===
// EventInfo.h

#pragma once

#include <map>
#include <wstlallc.h>
#include "array.h"
#include "ObjAccess.h"
#include "buffer.h"
#include "ProvInfo.h"
#include "BlobDcdr.h"

#define GENERIC_CLASS_NAME L"MSFT_WMI_GenericNonCOMEvent"

/////////////////////////////////////////////////////////////////////////////
// CEventInfo

_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));
_COM_SMARTPTR_TYPEDEF(_IWmiObject, __uuidof(_IWmiObject));

class CEventInfo;
class CClientInfo;

typedef BOOL (CEventInfo::*PROP_FUNC)();
typedef CArray<PROP_FUNC> CPropFuncArray;

class CEventInfo : public CObjAccess
{
public:
    CEventInfo();
    ~CEventInfo();

    BOOL InitFromBuffer(CClientInfo *pInfo, CBuffer *pBuffer);
    BOOL SetPropsWithBuffer(CBuffer *pBuffer);
    HRESULT Indicate();
    void SetSink(IWbemEventSink *pSink) { m_pSink = pSink; }
#ifdef USE_SD
    void SetSD(LPBYTE pSD, DWORD dwLen);
#endif

protected:
    enum EVENT_TYPE
    {
        TYPE_NORMAL,
        TYPE_GENERIC,
    };

#ifdef USE_SD
    CBuffer m_bufferSD;
#endif
        
    // These are used when we're decoding an object.
    LPBYTE         m_pBitsBase;
    DWORD          *m_pdwPropTable;

    int            m_iCurrentVar;
    CPropFuncArray m_pPropFuncs;  
    EVENT_TYPE     m_type;
    
    // We need this for embedded objects, so they can call InitFromBuffer.
    CClientInfo    *m_pInfo;
    
    // The sink to indicate to.  This keeps us from having to lookup the
    // restricted sink in a map each time an event is received.
    IWbemEventSink *m_pSink;
    
    // Used only for generic events.
    _variant_t     m_vParamValues;
    BSTR           *m_pValues;

    // Used to get a new _IWmiObject when processing an _IWmiObject property.
    _IWmiObjectPtr m_pObjSpawner;

    BOOL IsNormal() { return m_type == TYPE_NORMAL; }
    BOOL IsGeneric() { return m_type == TYPE_GENERIC; }

    PROP_FUNC TypeToPropFunc(DWORD type);
    PROP_FUNC GenTypeToPropFunc(DWORD type);

    BOOL SetBlobPropsWithBuffer(CBuffer *pBuffer);

    LPBYTE GetPropDataPointer(DWORD dwIndex)
    {
        return m_pBitsBase + m_pdwPropTable[dwIndex];
    }

    DWORD GetPropDataValue(DWORD dwIndex)
    {
        return m_pdwPropTable[dwIndex];
    }

    // Prop type functions for non-generic events.
    BOOL ProcessString();
    BOOL ProcessBYTE();
    BOOL ProcessWORD();
    BOOL ProcessDWORD();
    BOOL ProcessDWORD64();
    BOOL ProcessObject();
    BOOL ProcessWmiObject();

    BOOL ProcessArray1();
    BOOL ProcessArray2();
    BOOL ProcessArray4();
    BOOL ProcessArray8();
    BOOL ProcessStringArray();
    BOOL ProcessObjectArray();
    BOOL ProcessWmiObjectArray();

    // Prop type functions for generic events.
    BOOL GenProcessString();    
    BOOL GenProcessStringArray();
    
    BOOL GenProcessSint8();
    BOOL GenProcessSint8Array();
    BOOL GenProcessUint8();
    BOOL GenProcessUint8Array();

    BOOL GenProcessSint16();
    BOOL GenProcessSint16Array();
    BOOL GenProcessUint16();
    BOOL GenProcessUint16Array();

    BOOL GenProcessSint32();
    BOOL GenProcessSint32Array();
    BOOL GenProcessUint32();
    BOOL GenProcessUint32Array();
    
    BOOL GenProcessSint64();
    BOOL GenProcessSint64Array();
    BOOL GenProcessUint64();
    BOOL GenProcessUint64Array();
    
    BOOL GenProcessReal32();
    BOOL GenProcessReal32Array();
    
    BOOL GenProcessReal64();
    BOOL GenProcessReal64Array();

    BOOL GenProcessObject();
    BOOL GenProcessObjectArray();

    BOOL GenProcessBool();
    BOOL GenProcessBoolArray();

    // Helpers
    BOOL ProcessScalarArray(DWORD dwItemSize);
    
    // Digs out an embedded object from the buffer.
    BOOL GetEmbeddedObject(IUnknown **ppObj, LPBYTE pBits);
    BOOL GetWmiObject(_IWmiObject **ppObj, LPBYTE pBits);

    BOOL GenProcessDWORD(DWORD dwValue);
    BOOL GenProcessInt(DWORD dwValue);
    BOOL GenProcessDWORD64(DWORD64 dwValue);
    BOOL GenProcessInt64(DWORD64 dwValue);
    BOOL GenProcessDouble(double fValue);

    BOOL GenProcessArray8(BOOL bSigned);
    BOOL GenProcessArray16(BOOL bSigned);
    BOOL GenProcessArray32(BOOL bSigned);
    BOOL GenProcessArray64(BOOL bSigned);
};

_COM_SMARTPTR_TYPEDEF(IBlobDecoder, __uuidof(IBlobDecoder));

class CBlobEventInfo : public CEventInfo
{
public:
    CBlobEventInfo();

    BOOL InitFromName(CClientInfo *pInfo, LPCWSTR szClassName);

    // I wanted to make this a virtual version of SetPropsWithBuffer, but
    // there seems to be a bug in VC's template code that was screwing up the
    // size on a new call.  Weird stuff, but getting rid of the virtual
    // functions seems to fix it.
    BOOL SetBlobPropsWithBuffer(CBuffer *pBuffer);

protected:
    CArray<_variant_t> m_pPropHandles;
    IBlobDecoderPtr    m_pDecoder;
};

/////////////////////////////////////////////////////////////////////////////
// CEventInfoMap

class CEventInfoMap
{
public:
    ~CEventInfoMap();

    CEventInfo *GetNormalEventInfo(DWORD dwIndex);
    CEventInfo *GetBlobEventInfo(LPCWSTR szClassName);
    
    BOOL AddNormalEventInfo(DWORD dwIndex, CEventInfo *pInfo);
    BOOL AddBlobEventInfo(LPCWSTR szClassName, CEventInfo *pInfo);

protected:
    typedef std::map<DWORD, CEventInfo*, std::less<DWORD>, wbem_allocator<CEventInfo*> > CNormalInfoMap;
    typedef CNormalInfoMap::iterator CNormalInfoMapIterator;

    typedef std::map<_bstr_t, CEventInfo*, std::less<_bstr_t>, wbem_allocator<CEventInfo*> > CBlobInfoMap;
    typedef CBlobInfoMap::iterator CBlobInfoMapIterator;

    CNormalInfoMap m_mapNormalEvents;
    CBlobInfoMap   m_mapBlobEvents;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncprov\eventinfo.cpp ===
// EventInfo.cpp

#include "precomp.h"
#include "ProvInfo.h"
#include "EventInfo.h"
#include "NCProv.h"
#include "NCProvider.h"
#include "BlobDcdr_i.c"

#define COUNTOF(x)  (sizeof(x)/sizeof(x[0]))
#define DWORD_ALIGNED(x)    ((DWORD)((((x) * 8) + 31) & (~31)) / 8)


/////////////////////////////////////////////////////////////////////////////
// CEventInfo

CEventInfo::CEventInfo() :
#ifdef USE_SD
    m_bufferSD(0),
#endif
    m_pPropFuncs(0)
{
}

CEventInfo::~CEventInfo()
{
}

BOOL GetClassQualifier(
    IWbemClassObject *pObj, 
    LPCWSTR szQualifier,
    VARIANT *pVal)
{
    IWbemQualifierSet *pSet = NULL;
    BOOL              bRet = FALSE;

    if (SUCCEEDED(pObj->GetQualifierSet(&pSet)))
    {
        if (SUCCEEDED(pSet->Get(szQualifier, 0, pVal, NULL)))
            bRet = TRUE;

        pSet->Release();
    }

    return bRet;
}

BOOL GetClassPropertyQualifier(
    IWbemClassObject *pObj, 
    LPCWSTR szProperty,
    LPCWSTR szQualifier,
    VARIANT *pVal)
{
    IWbemQualifierSet *pSet = NULL;
    BOOL              bRet = FALSE;

    if (SUCCEEDED(pObj->GetPropertyQualifierSet(szProperty, &pSet)))
    {
        if (SUCCEEDED(pSet->Get(szQualifier, 0, pVal, NULL)))
            bRet = TRUE;

        pSet->Release();
    }

    return bRet;
}

BOOL CEventInfo::InitFromBuffer(CClientInfo *pInfo, CBuffer *pBuffer)
{
    WCHAR *pszEvent;
    DWORD nProps,
          dwStrSize;
    BOOL  bRet = FALSE;

    m_pInfo = pInfo;

    // Get the number of properties for this event layout.
    nProps = pBuffer->ReadDWORD();
    
    pszEvent = pBuffer->ReadAlignedLenString(&dwStrSize);

    // See if this is the generic class.
    m_type = _wcsicmp(pszEvent, GENERIC_CLASS_NAME) ? TYPE_NORMAL : 
                TYPE_GENERIC;

    // Prepare the array of property functions.
    m_pPropFuncs.Init(nProps);

    if (IsNormal())
    {
        LPWSTR *pszProps = new LPWSTR[nProps];

        if (pszProps)
        {
            for (DWORD i = 0; i < nProps; i++)
            {
                DWORD     type = pBuffer->ReadDWORD();
                DWORD     dwSize;
                LPCWSTR   szProp = pBuffer->ReadAlignedLenString(&dwSize);
                PROP_FUNC pFunc = TypeToPropFunc(type);

                m_pPropFuncs.AddVal(TypeToPropFunc(type));
                pszProps[i] = (BSTR) szProp;
            }

            bRet = 
                Init(
                    pInfo->m_pProvider->m_pProv->GetNamespace(),
                    pszEvent,
                    (LPCWSTR*) pszProps,
                    nProps,
                    FAILED_PROP_TRY_ARRAY);

            delete pszProps;
        }
    }
    else
    {
        // This event is using the generic class.  Create the param names.
        _variant_t     vParamNames;
        SAFEARRAYBOUND bound = { nProps, 0 };

        if ((V_ARRAY(&vParamNames) = SafeArrayCreate(VT_BSTR, 1, &bound)) 
            != NULL)
        {
            BSTR *pNames = (BSTR*) vParamNames.parray->pvData;

            vParamNames.vt = VT_BSTR | VT_ARRAY;

            for (DWORD i = 0; i < nProps; i++)
            {
                DWORD   type = pBuffer->ReadDWORD();
                DWORD   dwSize;
                LPCWSTR szProp = pBuffer->ReadAlignedLenString(&dwSize);

                pNames[i] = SysAllocString((BSTR) szProp);

                m_pPropFuncs.AddVal(GenTypeToPropFunc(type));
            }

            bRet =
                Init(
                    pInfo->m_pProvider->m_pProv->GetNamespace(),
                    pszEvent,
                    NULL,
                    0,
                    FAILED_PROP_FAIL);

            // If everything's OK, Put() the param names along with the 
            // provider name.
            if (bRet)
            {
                m_pObj->Put(
                    L"PropertyNames",
                    0,
                    &vParamNames,
                    0);

                _variant_t vProviderName = pInfo->m_pProvider->m_pProv->m_strName;

                m_pObj->Put(
                    L"ProviderName",
                    0,
                    &vProviderName,
                    0);
            }
        }
    }

    return bRet;
}

BOOL CEventInfo::SetPropsWithBuffer(CBuffer *pBuffer)
{
    if (!m_pObj)
        return FALSE;

    DWORD nProps = m_pPropFuncs.GetCount();
    BOOL  bRet = TRUE;
    DWORD *pNullTable = (DWORD*) pBuffer->m_pCurrent;

    //pBuffer->m_pCurrent = pPropTable + nProps * sizeof(DWORD);
    
    // We need this as the offsets are relative from the beginning
    // of the object packet (including the 2 DWORDs of header stuff).
    m_pBitsBase = (LPBYTE) (pNullTable - 3);
    m_pdwPropTable = pNullTable + (nProps / 32 + ((nProps % 32) != 0));

    // If this is a generic event we have some setup to do.
    if (IsGeneric())
    {
        SAFEARRAYBOUND bound = { nProps, 0 };

        // We need to prepare the array of values.
        V_ARRAY(&m_vParamValues) = SafeArrayCreate(VT_BSTR, 1, &bound);

        // Out of memory?
        if (V_ARRAY(&m_vParamValues) == NULL)
            return FALSE;
            
        m_vParamValues.vt = VT_BSTR | VT_ARRAY; 

        // Save off a pointer to the param values as an optimization.
        m_pValues = (BSTR*) m_vParamValues.parray->pvData;
    }


    // Save this off for our processing functions.
    //m_pBuffer = pBuffer;

    for (m_iCurrentVar = 0; 
        m_iCurrentVar < nProps && bRet; 
        m_iCurrentVar++)
    {
        if ((pNullTable[m_iCurrentVar / 32] & (1 << (m_iCurrentVar % 32))))
        {
            PROP_FUNC pFunc = m_pPropFuncs[m_iCurrentVar];

            bRet = (this->*pFunc)();

            _ASSERT(bRet);
        }
#ifdef NO_WINMGMT
        else
            WriteNULL(m_iCurrentVar);
#endif
    }
        
    if (bRet && IsGeneric())
    {
        m_pObj->Put(
            L"PropertyValues",
            0,
            &m_vParamValues,
            0);

        // Free the value strings since we don't need them anymore.
        m_vParamValues.Clear();
    }

    return bRet;
}

PROP_FUNC CEventInfo::TypeToPropFunc(DWORD type)
{
    PROP_FUNC pRet;
    BOOL      bNonArray = (type & CIM_FLAG_ARRAY) == 0;

    switch(type & ~CIM_FLAG_ARRAY)
    {
        case CIM_STRING:
        case CIM_REFERENCE:
        case CIM_DATETIME:
            pRet = bNonArray ? ProcessString : ProcessStringArray;
            break;

        case CIM_UINT32:
        case CIM_SINT32:
        case CIM_REAL32:
            pRet = bNonArray ? ProcessDWORD : ProcessArray4;
            break;

        case CIM_UINT16:
        case CIM_SINT16:
        case CIM_CHAR16:
        case CIM_BOOLEAN:
            pRet = bNonArray ? ProcessWORD : ProcessArray2;
            break;

        case CIM_SINT8:
        case CIM_UINT8:
            pRet = bNonArray ? ProcessBYTE : ProcessArray1;
            break;

        case CIM_SINT64:
        case CIM_UINT64:
        case CIM_REAL64:
            pRet = bNonArray ? ProcessDWORD64 : ProcessArray8;
            break;

        case CIM_OBJECT:
            pRet = bNonArray ? ProcessObject : ProcessObjectArray;
            break;

        // We'll use this for _IWmiObjects.
        case CIM_IUNKNOWN:
            pRet = bNonArray ? ProcessWmiObject : ProcessWmiObjectArray;
            break;

        default:
            // Bad type!
            _ASSERT(FALSE);
            pRet = NULL;
    }

    return pRet;
}

PROP_FUNC CEventInfo::GenTypeToPropFunc(DWORD type)
{
    PROP_FUNC pRet;
    BOOL      bNonArray = (type & CIM_FLAG_ARRAY) == 0;

    switch(type & ~CIM_FLAG_ARRAY)
    {
        case CIM_STRING:
        case CIM_REFERENCE:
        case CIM_DATETIME:
            pRet = bNonArray ? GenProcessString : GenProcessStringArray;
            break;

        case CIM_UINT32:
            pRet = bNonArray ? GenProcessUint32 : GenProcessUint32Array;
            break;

        case CIM_SINT32:
            pRet = bNonArray ? GenProcessSint32 : GenProcessSint32Array;
            break;

        case CIM_CHAR16:
        case CIM_UINT16:
            pRet = bNonArray ? GenProcessUint16 : GenProcessUint16Array;
            break;

        case CIM_SINT16:
            pRet = bNonArray ? GenProcessSint16 : GenProcessSint16Array;
            break;

        case CIM_BOOLEAN:
            pRet = bNonArray ? GenProcessBool : GenProcessBoolArray;
            break;

        case CIM_SINT8:
            pRet = bNonArray ? GenProcessSint8 : GenProcessSint8Array;
            break;

        case CIM_UINT8:
            pRet = bNonArray ? GenProcessUint8 : GenProcessUint8Array;
            break;

        case CIM_SINT64:
            pRet = bNonArray ? GenProcessSint64 : GenProcessSint64Array;
            break;

        case CIM_UINT64:
            pRet = bNonArray ? GenProcessUint64 : GenProcessUint64Array;
            break;

        case CIM_REAL32:
            pRet = bNonArray ? GenProcessReal32 : GenProcessReal32Array;
            break;

        case CIM_REAL64:
            pRet = bNonArray ? GenProcessReal64 : GenProcessReal64Array;
            break;

        case CIM_OBJECT:
            pRet = bNonArray ? GenProcessObject : GenProcessObjectArray;
            break;

        default:
            // Bad type!
            _ASSERT(FALSE);
            pRet = NULL;
    }

    return pRet;
}

BOOL CEventInfo::ProcessString()
{
    LPBYTE pData = GetPropDataPointer(m_iCurrentVar);
    DWORD  dwSize = *(DWORD*) pData;
    BOOL   bRet;

#ifndef NO_WINMGMT
    bRet = WriteData(m_iCurrentVar, pData + sizeof(DWORD), dwSize);
#else
    bRet = TRUE;
#endif

    return bRet;
}

BOOL CEventInfo::ProcessStringArray()
{
    LPBYTE         pData = GetPropDataPointer(m_iCurrentVar);
    DWORD          nStrings = *(DWORD*) pData;
    BOOL           bRet;
	VARIANT        vValue;
    SAFEARRAYBOUND sabound;
    
    sabound.lLbound = 0;
    sabound.cElements = nStrings;

    
    pData += sizeof(DWORD);

    if ((V_ARRAY(&vValue) = SafeArrayCreate(VT_BSTR, 1, &sabound)) != NULL)
    {
        BSTR   *pStrings = (BSTR*) vValue.parray->pvData;
        LPBYTE pCurrent = pData;

        vValue.vt = VT_BSTR | VT_ARRAY;

        for (DWORD i = 0; i < nStrings; i++)
        {
            //pStrings[i] = (BSTR) pCurrent;
            pStrings[i] = SysAllocString((BSTR) (pCurrent + sizeof(DWORD)));

            pCurrent += DWORD_ALIGNED(*(DWORD*) pCurrent) + sizeof(DWORD);
        }

        //m_pBuffer->m_pCurrent = (LPBYTE) pCurrent;

#ifndef NO_WINMGMT
        HRESULT hr;

        hr =
            m_pObj->Put(
                m_pProps[m_iCurrentVar].m_strName,
                0,
                &vValue,
                0);

        bRet = SUCCEEDED(hr);
        
        if (!bRet)
            bRet = TRUE;
#else
        bRet = TRUE;
#endif

        // Cleanup the safe array.
        
        // Do this so SafeArrayDestroy doesn't try to free our BSTRs we got
        // off of the buffer.
        //ZeroMemory(vValue.parray->pvData, sizeof(BSTR) * nStrings);

        SafeArrayDestroy(V_ARRAY(&vValue));
    }
    else
        bRet = FALSE;

    return bRet;
}

BOOL CEventInfo::ProcessDWORD()
{
#ifndef NO_WINMGMT
    return WriteDWORD(m_iCurrentVar, m_pdwPropTable[m_iCurrentVar]);
#else
    
    //m_pBuffer->ReadDWORD();

    return TRUE;
#endif
}

BOOL CEventInfo::ProcessBYTE()
{
    BYTE cData = m_pdwPropTable[m_iCurrentVar];

#ifndef NO_WINMGMT
    return WriteData(m_iCurrentVar, &cData, sizeof(cData));
#else
    return TRUE;
#endif
}

BOOL CEventInfo::ProcessDWORD64()
{
    DWORD64 *pdwData = (DWORD64*) GetPropDataPointer(m_iCurrentVar);

#ifndef NO_WINMGMT
    return WriteData(m_iCurrentVar, pdwData, sizeof(*pdwData));
#else
    return TRUE;
#endif
}

BOOL CEventInfo::ProcessWORD()
{
    WORD wData = m_pdwPropTable[m_iCurrentVar];

#ifndef NO_WINMGMT
    return WriteData(m_iCurrentVar, &wData, sizeof(wData));
#else
    return TRUE;
#endif
}

BOOL CEventInfo::ProcessScalarArray(DWORD dwItemSize)
{
    LPBYTE pBits = GetPropDataPointer(m_iCurrentVar);
//    DWORD  dwItems = (DWORD*) pBits,
//           dwSize = dwItems * dwItemSize;
    BOOL   bRet;

#ifndef NO_WINMGMT
    bRet = WriteArrayData(m_iCurrentVar, pBits, dwItemSize);
#else
    bRet = TRUE;
#endif

    //m_pBuffer->m_pCurrent += dwSize;

    return bRet;
}

BOOL CEventInfo::ProcessArray1()
{
    return ProcessScalarArray(1);
}

BOOL CEventInfo::ProcessArray2()
{
    return ProcessScalarArray(2);
}

BOOL CEventInfo::ProcessArray4()
{
    return ProcessScalarArray(4);
}

BOOL CEventInfo::ProcessArray8()
{
    return ProcessScalarArray(8);
}

// Digs out an embedded object from the current buffer.
BOOL CEventInfo::GetEmbeddedObject(IUnknown **ppObj, LPBYTE pBits)
{
    CEventInfo *pEvent = new CEventInfo;
    BOOL       bRet = FALSE;

    if (pEvent)
    {
        DWORD   dwSize = *(DWORD*) pBits;
        CBuffer bufferObj(pBits + sizeof(DWORD), dwSize, CBuffer::ALIGN_NONE);

        bRet =
            pEvent->InitFromBuffer(m_pInfo, &bufferObj) &&
            pEvent->SetPropsWithBuffer(&bufferObj);

        if (bRet)
        {
            bRet = 
                SUCCEEDED(pEvent->m_pObj->QueryInterface(
                    IID_IUnknown, (LPVOID*) ppObj));
        }

        delete pEvent;
    }

    return bRet;
}

BOOL CEventInfo::ProcessObject()
{
    _variant_t vObj;
    BOOL       bRet = FALSE;
    LPBYTE     pObjBegin = m_pBitsBase + m_pdwPropTable[m_iCurrentVar];

    if (GetEmbeddedObject(&vObj.punkVal, pObjBegin))
    {
        vObj.vt = VT_UNKNOWN;

        bRet =
            SUCCEEDED(m_pObj->Put(
                m_pProps[m_iCurrentVar].m_strName,
                0,
                &vObj,
                0));
    }
    
    return bRet;
}

BOOL CEventInfo::ProcessObjectArray()
{
    LPBYTE         pBits = m_pBitsBase + m_pdwPropTable[m_iCurrentVar];
    DWORD          nObjects = *(DWORD*) pBits;
    BOOL           bRet = FALSE;
	VARIANT        vValue;
    SAFEARRAYBOUND sabound;
    
    sabound.lLbound = 0;
    sabound.cElements = nObjects;

    if ((V_ARRAY(&vValue) = SafeArrayCreate(VT_UNKNOWN, 1, &sabound)) != NULL)
    {
        IUnknown **pUnks = (IUnknown**) vValue.parray->pvData;

        vValue.vt = VT_UNKNOWN | VT_ARRAY;

        bRet = TRUE;

        // Get past the # of elements.
        pBits += sizeof(DWORD);

        for (DWORD i = 0; i < nObjects && bRet; i++)
        {
            DWORD dwSize = *(DWORD*) pBits;
            
            bRet = GetEmbeddedObject(&pUnks[i], pBits);

            pBits += DWORD_ALIGNED(dwSize) + sizeof(DWORD);
        }

        if (bRet)
        {
#ifndef NO_WINMGMT
            bRet =
                SUCCEEDED(m_pObj->Put(
                    m_pProps[m_iCurrentVar].m_strName,
                    0,
                    &vValue,
                    0));
#endif
        }
    }

    return bRet;
}

// Digs out an embedded object from the current buffer.
BOOL CEventInfo::GetWmiObject(_IWmiObject **ppObj, LPBYTE pBits)
{
    if (m_pObjSpawner == NULL)
    {
        HRESULT hr;

        hr =
            m_pInfo->m_pProvider->m_pProv->GetNamespace()->GetObject(
                L"__NAMESPACE",
                0,
                NULL,
                (IWbemClassObject**) (_IWmiObject**) &m_pObjSpawner,
                NULL);

        if (FAILED(hr))
            return FALSE;
    }

    BOOL        bRet = FALSE;
    _IWmiObject *pObjTemp = NULL;

    if (SUCCEEDED(m_pObjSpawner->SpawnInstance(0, (IWbemClassObject**) &pObjTemp)))
    {
        DWORD  dwSize = *(DWORD*) pBits;
        LPVOID pMem = CoTaskMemAlloc(dwSize);

        if (pMem)
        {
            memcpy(pMem, pBits + sizeof(DWORD), dwSize);
            if (SUCCEEDED(pObjTemp->SetObjectMemory(pMem, dwSize)))
            {
                *ppObj = pObjTemp;

                bRet = TRUE;
            }
        }
    }

    return bRet;
}

BOOL CEventInfo::ProcessWmiObject()
{
    BOOL        bRet;
    LPBYTE      pObjBegin = m_pBitsBase + m_pdwPropTable[m_iCurrentVar];
    _IWmiObject *pObj = NULL;

    if (GetWmiObject(&pObj, pObjBegin))
    {
        CProp   &prop = m_pProps[m_iCurrentVar];
        HRESULT hr;

        hr =
            m_pWmiObj->SetPropByHandle(
                prop.m_lHandle,
                0,
                sizeof(_IWmiObject*),
                &pObj);
            
        pObj->Release();

        bRet = SUCCEEDED(hr);
    }
    else
        bRet = FALSE;
    
    return bRet;
}

BOOL CEventInfo::ProcessWmiObjectArray()
{
    return FALSE; // not supported.
/*
    LPBYTE      pBits = m_pBitsBase + m_pdwPropTable[m_iCurrentVar];
    int         nObjects = *(int*) pBits;
    BOOL        bRet = TRUE;
    _IWmiObject **pObjs = new _IWmiObject*[nObjects];

    if (!pObjs)
        return FALSE;

    memset(pObjs, 0, sizeof(_IWmiObject*) * nObjects);

    // Get past the # of elements.
    pBits += sizeof(DWORD);

    for (int i = 0; i < nObjects && bRet; i++)
    {
        DWORD dwSize = *(DWORD*) pBits;
            
        if (dwSize)
            bRet = GetWmiObject(&pObjs[i], pBits);

        pBits += DWORD_ALIGNED(dwSize) + sizeof(DWORD);
    }

    if (bRet)
    {
        bRet =
            WriteNonPackedArrayData(
                m_iCurrentVar,
                pObjs,
                nObjects,
                sizeof(_IWmiObject*) * nObjects);
    }

    for (int j = 0; j < i; j++)
    {
        if (pObjs[j])
            pObjs[j]->Release();
    }

    delete [] pObjs;

    return bRet;
*/
}



BOOL CEventInfo::GenProcessString()
{
    LPBYTE pData = GetPropDataPointer(m_iCurrentVar) + sizeof(DWORD);

    m_pValues[m_iCurrentVar] = SysAllocString((BSTR) pData);

    return TRUE;
}

BOOL CEventInfo::GenProcessStringArray()
{
    LPBYTE  pData = GetPropDataPointer(m_iCurrentVar);
    DWORD   nStrings = *(DWORD*) pData;
    BOOL    bRet = FALSE;
    LPBYTE  pCurrent = pData + sizeof(DWORD);
    DWORD   dwTotalLen = 0;

    // First see how much of a buffer we'll need.
    for (DWORD i = 0; i < nStrings; i++)
    {
        DWORD dwLen = wcslen((LPCWSTR) (pCurrent + sizeof(DWORD)));

        dwTotalLen += dwLen + 2; // 2 for the comma and space.

        pCurrent += sizeof(DWORD) + *(DWORD*) pCurrent;
    }

    BSTR pValue = SysAllocStringByteLen(NULL, dwTotalLen * sizeof(WCHAR));
    
    m_pValues[m_iCurrentVar] = pValue;
        
    if (pValue)
    {
        // Point back to the first string.
        pCurrent = pData + sizeof(DWORD);

        dwTotalLen = 0;

        for (i = 0; i < nStrings; i++)
        {
            DWORD dwLen = wcslen((LPCWSTR) (pCurrent + sizeof(DWORD)));

            // Add a comma and space before the next value.
            if (i != 0)
            {
                memcpy(
                    &pValue[dwTotalLen], 
                    L", ", 
                    sizeof(L", ") - sizeof(WCHAR));

                dwTotalLen += 2;
            }

            // Add the current value.
            memcpy(
                &pValue[dwTotalLen], 
                pCurrent + sizeof(DWORD), 
                dwLen * sizeof(WCHAR));
            
            // Increase our position in the big value.
            dwTotalLen += dwLen; 

            // Move to the next string.
            pCurrent += sizeof(DWORD) + *(DWORD*) pCurrent;
        }

        // Add the final null.
        pValue[dwTotalLen] = 0;

        bRet = TRUE;
    }
    
    return bRet;
}

BOOL CEventInfo::GenProcessSint8()
{
    BYTE cData = GetPropDataValue(m_iCurrentVar);

    return GenProcessInt(cData);    
}

BOOL CEventInfo::GenProcessSint8Array()
{
    return GenProcessArray8(TRUE);
}

BOOL CEventInfo::GenProcessArray8(BOOL bSigned)
{
    LPBYTE  pData = GetPropDataPointer(m_iCurrentVar);
    DWORD   nItems = *(DWORD*) pData;
    BOOL    bRet = FALSE;
    BSTR    pValue = SysAllocStringByteLen(NULL, nItems * 7 * sizeof(WCHAR));
    LPCWSTR szFormat = bSigned ? L"%d" : L"%u";
    
    m_pValues[m_iCurrentVar] = pValue;
    
    pData += sizeof(DWORD);

    if (pValue)
    {
        *pValue = 0;
        
        for (DWORD i = 0; i < nItems; i++)
        {
            WCHAR szItem[5];

            if (i != 0)
                wcscat(pValue, L", ");

            swprintf(szItem, szFormat, pData[i]);
            wcscat(pValue, szItem);
        }

        bRet = TRUE;
    }

    return bRet;
}

BOOL CEventInfo::GenProcessArray16(BOOL bSigned)
{
    LPWORD  pData = (LPWORD) GetPropDataPointer(m_iCurrentVar);
    DWORD   nItems = *(DWORD*) pData;
    BOOL    bRet = FALSE;
    BSTR    pValue = SysAllocStringByteLen(NULL, nItems * 10 * sizeof(WCHAR));
    LPCWSTR szFormat = bSigned ? L"%d" : L"%u";
    
    m_pValues[m_iCurrentVar] = pValue;

    // Get past the first DWORD.
    pData += 2;
    
    if (pValue)
    {
        *pValue = 0;
        
        for (DWORD i = 0; i < nItems; i++)
        {
            WCHAR szItem[10];

            if (i != 0)
                wcscat(pValue, L", ");

            swprintf(szItem, szFormat, pData[i]);
            wcscat(pValue, szItem);
        }

        bRet = TRUE;
    }

    return bRet;
}

BOOL CEventInfo::GenProcessArray32(BOOL bSigned)
{
    LPDWORD pData = (LPDWORD) GetPropDataPointer(m_iCurrentVar);
    DWORD   nItems = *(DWORD*) pData;
    BOOL    bRet = FALSE;
    BSTR    pValue = SysAllocStringByteLen(NULL, nItems * 15 * sizeof(WCHAR));
    LPCWSTR szFormat = bSigned ? L"%d" : L"%u";
    
    m_pValues[m_iCurrentVar] = pValue;
    
    // Get past the number of items.
    pData++;

    if (pValue)
    {
        *pValue = 0;
        
        for (DWORD i = 0; i < nItems; i++)
        {
            WCHAR szItem[15];

            if (i != 0)
                wcscat(pValue, L", ");

            swprintf(szItem, szFormat, pData[i]);
            wcscat(pValue, szItem);
        }

        bRet = TRUE;
    }

    return bRet;
}

BOOL CEventInfo::GenProcessArray64(BOOL bSigned)
{
    LPBYTE  pData = (LPBYTE) GetPropDataPointer(m_iCurrentVar);
    DWORD   nItems = *(DWORD*) pData;
    BOOL    bRet = FALSE;
    BSTR    pValue = SysAllocStringByteLen(NULL, nItems * 30 * sizeof(WCHAR));
    LPCWSTR szFormat = bSigned ? L"%I64d" : L"%I64u";
    
    m_pValues[m_iCurrentVar] = pValue;
    
    if (pValue)
    {
        *pValue = 0;
        
        DWORD64 *pVals = (DWORD64*) (pData + sizeof(DWORD));

        for (DWORD i = 0; i < nItems; i++)
        {
            WCHAR   szItem[30];

            if (i != 0)
                wcscat(pValue, L", ");

            // TODO: We need to find out how to mark pVals as unaligned.
            swprintf(szItem, szFormat, pVals[i]);
            wcscat(pValue, szItem);
        }

        bRet = TRUE;
    }

    return bRet;
}

BOOL CEventInfo::GenProcessUint8()
{
    BYTE cData = GetPropDataValue(m_iCurrentVar);

    return GenProcessDWORD(cData);    
}

BOOL CEventInfo::GenProcessUint8Array()
{
    return GenProcessArray8(FALSE);
}

BOOL CEventInfo::GenProcessSint16()
{
    WORD wData = GetPropDataValue(m_iCurrentVar);

    return GenProcessInt(wData);    
}

BOOL CEventInfo::GenProcessSint16Array()
{
    return GenProcessArray16(TRUE);
}

BOOL CEventInfo::GenProcessUint16()
{
    WORD wData = GetPropDataValue(m_iCurrentVar);

    return GenProcessDWORD(wData);    
}

BOOL CEventInfo::GenProcessUint16Array()
{
    return GenProcessArray16(FALSE);
}

BOOL CEventInfo::GenProcessSint32()
{
    DWORD dwData = GetPropDataValue(m_iCurrentVar);

    return GenProcessInt(dwData);    
}

BOOL CEventInfo::GenProcessSint32Array()
{
    return GenProcessArray32(TRUE);
}

BOOL CEventInfo::GenProcessUint32()
{
    DWORD dwData = GetPropDataValue(m_iCurrentVar);

    return GenProcessDWORD(dwData);    
}

BOOL CEventInfo::GenProcessUint32Array()
{
    return GenProcessArray32(FALSE);
}

BOOL CEventInfo::GenProcessSint64()
{
    DWORD64 *pdwData = (DWORD64*) GetPropDataPointer(m_iCurrentVar);

    return GenProcessInt64(*pdwData);
}

BOOL CEventInfo::GenProcessSint64Array()
{
    return GenProcessArray64(TRUE);
}

BOOL CEventInfo::GenProcessUint64()
{
    DWORD64 *pdwData = (DWORD64*) GetPropDataPointer(m_iCurrentVar);

    return GenProcessDWORD64(*pdwData);
}

BOOL CEventInfo::GenProcessUint64Array()
{
    return GenProcessArray16(FALSE);
}

BOOL CEventInfo::GenProcessReal32()
{
    return GenProcessDouble(*(float*) &m_pdwPropTable[m_iCurrentVar]);
}

BOOL CEventInfo::GenProcessReal32Array()
{
    float   *pData = (float*) GetPropDataPointer(m_iCurrentVar);
    DWORD   nItems = *(DWORD*) pData;
    BOOL    bRet = FALSE;
    BSTR    pValue = SysAllocStringByteLen(NULL, nItems * 30 * sizeof(WCHAR));
    LPCWSTR szFormat = L"%.4f";
    
    m_pValues[m_iCurrentVar] = pValue;
    
    pData++;

    if (pValue)
    {
        *pValue = 0;
        
        for (DWORD i = 0; i < nItems; i++)
        {
            WCHAR szItem[30];

            if (i != 0)
                wcscat(pValue, L", ");

            swprintf(szItem, szFormat, pData[i]);
            wcscat(pValue, szItem);
        }

        bRet = TRUE;
    }

    return bRet;
}
    
BOOL CEventInfo::GenProcessReal64()
{
    double *pfData = (double*) GetPropDataPointer(m_iCurrentVar);

    return GenProcessDouble(*pfData);
}

BOOL CEventInfo::GenProcessReal64Array()
{
    LPBYTE  pData = (LPBYTE) GetPropDataPointer(m_iCurrentVar);
    DWORD   nItems = *(DWORD*) pData;
    BOOL    bRet = FALSE;
    BSTR    pValue = SysAllocStringByteLen(NULL, nItems * 30 * sizeof(WCHAR));
    LPCWSTR szFormat = L"%.4f";
    
    m_pValues[m_iCurrentVar] = pValue;
    
    if (pValue)
    {
        *pValue = 0;
        
        double *pVals = (double*) (pData + sizeof(DWORD));

        for (DWORD i = 0; i < nItems; i++)
        {
            WCHAR szItem[30];

            if (i != 0)
                wcscat(pValue, L", ");

            // TODO: Mark as unaligned.
            swprintf(szItem, szFormat, pVals[i]);
            wcscat(pValue, szItem);
        }

        bRet = TRUE;
    }

    return bRet;
}


BOOL CEventInfo::GenProcessObject()
{
    return FALSE;
}

BOOL CEventInfo::GenProcessObjectArray()
{
    return FALSE;
}


BOOL CEventInfo::GenProcessBool()
{
    DWORD wData = GetPropDataValue(m_iCurrentVar);

    return GenProcessDWORD(wData ? 1 : 0);    
}

BOOL CEventInfo::GenProcessBoolArray()
{
    DWORD  *pData = (DWORD*) GetPropDataPointer(m_iCurrentVar);
    DWORD nItems = *(DWORD*) pData;
    BOOL  bRet = FALSE;
    BSTR  pValue = SysAllocStringByteLen(NULL, nItems * 3 * sizeof(WCHAR));
    
    m_pValues[m_iCurrentVar] = pValue;
    
    if (pValue)
    {
        *pValue = 0;
        
        for (DWORD i = 0; i < nItems; i++)
        {
            if (i != 0)
                wcscat(pValue, L", ");

            wcscat(pValue, pData[i] ? L"1" : L"0");
        }

        bRet = TRUE;
    }

    return bRet;
}


BOOL CEventInfo::GenProcessDWORD(DWORD dwValue)
{
    WCHAR szTemp[100];

    swprintf(szTemp, L"%u", dwValue);

    m_pValues[m_iCurrentVar] = SysAllocString(szTemp);

    return TRUE;
}

BOOL CEventInfo::GenProcessInt(DWORD dwValue)
{
    WCHAR szTemp[100];

    swprintf(szTemp, L"%d", dwValue);

    m_pValues[m_iCurrentVar] = SysAllocString(szTemp);

    return TRUE;
}

BOOL CEventInfo::GenProcessDWORD64(DWORD64 dwValue)
{
    WCHAR szTemp[100];

    swprintf(szTemp, L"%I64u", dwValue);

    m_pValues[m_iCurrentVar] = SysAllocString(szTemp);

    return TRUE;
}

BOOL CEventInfo::GenProcessInt64(DWORD64 dwValue)
{
    WCHAR szTemp[100];

    swprintf(szTemp, L"%I64i", dwValue);

    m_pValues[m_iCurrentVar] = SysAllocString(szTemp);

    return TRUE;
}

BOOL CEventInfo::GenProcessDouble(double fValue)
{
    WCHAR szTemp[100];

    swprintf(szTemp, L"%.4f", fValue);

    m_pValues[m_iCurrentVar] = SysAllocString(szTemp);

    return TRUE;
}

#ifdef USE_SD
void CEventInfo::SetSD(LPBYTE pSD, DWORD dwLen)
{
    m_bufferSD.Reset(dwLen);
    m_bufferSD.Write(pSD, dwLen);
}
#endif

/////////////////////////////////////////////////////////////////////////////
// CBlobEventInfo

CBlobEventInfo::CBlobEventInfo() :
    m_pPropHandles(0)    
{
}

BOOL CBlobEventInfo::InitFromName(CClientInfo *pInfo, LPCWSTR szClassName)
{
    IWbemClassObject *pClass = NULL;
    BOOL             bRet = FALSE;

    m_pInfo = pInfo;

    // Get the class.
    if (SUCCEEDED(pInfo->m_pProvider->m_pProv->GetNamespace()->GetObject(
        _bstr_t(szClassName), 
        0, 
        NULL, 
        &pClass, 
        NULL)))
    {
        SAFEARRAY *pArrNames;

        // Get the property names.
        if (SUCCEEDED(pClass->GetNames(
            NULL,
            WBEM_FLAG_NONSYSTEM_ONLY,
            NULL,
            &pArrNames)))
        {
            DWORD           nItems = pArrNames->rgsabound[0].cElements;
            BSTR            *pNames = (BSTR*) pArrNames->pvData;
            CArray<CIMTYPE> pTypes(nItems);

            
            bRet = 
                // Prepare the array of property functions.
                m_pPropFuncs.Init(nItems) &&

                // We'll use these to talk to the blob decoder.
                m_pPropHandles.Init(nItems);

            for (DWORD i = 0; i < nItems && bRet; i++)
            {
                CIMTYPE type;

                // Get the property type.
                bRet = 
                    SUCCEEDED(pClass->Get(
                        pNames[i],
                        0,
                        NULL,
                        &type,
                        NULL));

                // Save the type for later.
                pTypes[i] = type;
                
                PROP_FUNC pFunc = TypeToPropFunc(type);

                int iSize = sizeof(pFunc);

                // Get the function used to decode this type.
                m_pPropFuncs[i] = pFunc;

                bRet =
                    GetClassPropertyQualifier(
                        pClass, 
                        pNames[i],
                        L"DecodeHandle",
                        &m_pPropHandles[i]);
            }

            // Now init our CObjAccess
            bRet = 
                Init(
                    pInfo->m_pProvider->m_pProv->GetNamespace(),
                    szClassName,
                    (LPCWSTR*) pNames,
                    nItems,
                    FAILED_PROP_TRY_ARRAY);

            // Load the property decoder for this event.
            if (bRet)
            {
                _variant_t vCLSID;
                CLSID      clsidDecoder;

                bRet =
                    GetClassQualifier(
                        pClass,
                        L"DecodeCLSID",
                        &vCLSID);

                if (bRet && 
                    CLSIDFromString(V_BSTR(&vCLSID), &clsidDecoder) == 0)
                {
                    bRet =
                        SUCCEEDED(CoCreateInstance(
                            clsidDecoder,
                            NULL,
                            CLSCTX_ALL,
                            IID_IBlobDecoder,
                            (LPVOID*) &m_pDecoder));
                }
            }
        }
    }

    return bRet;
}

BOOL CBlobEventInfo::SetBlobPropsWithBuffer(CBuffer *pBuffer)
{
    BYTE*  cBuffer = new BYTE[4096];
	if (cBuffer == NULL)
		return FALSE;

    DWORD   dwPropTable = 0; // This is the offset of the data from cBuffer,
                             // which is always 0.
    CBuffer buffer(cBuffer, sizeof(cBuffer), CBuffer::ALIGN_DWORD_PTR);
    int     nProps = m_pPropFuncs.GetSize();
    BOOL    bRet = TRUE;
    DWORD   dwBlobSize = pBuffer->ReadDWORD();
    LPBYTE  pBlob = pBuffer->m_pCurrent;

    // Save this off for our processing functions.
    //m_pBuffer = &buffer;
    m_pBitsBase = cBuffer;
    
    // Always 0 since all the funcs need to always index to the first member
    // of the m_pdwPropTable array to get the data.
    m_iCurrentVar = 0;

    for (m_iCurrentVar = 0;
        m_iCurrentVar < nProps && bRet; 
        m_iCurrentVar++)
    {
        CIMTYPE type;
        DWORD   dwBytesRead = 0;

        if (SUCCEEDED(
            m_pDecoder->DecodeProperty( 
                &m_pPropHandles[m_iCurrentVar],
                &type,
                pBlob,
                dwBlobSize,
                cBuffer,
                sizeof(cBuffer),
                &dwBytesRead)) && dwBytesRead > 0)
        {
            PROP_FUNC pFunc = m_pPropFuncs[m_iCurrentVar];

            // If the number of bytes read is greater than 4, m_pdwPropTable
            // must point at 0 (data is 0 bytes offset from cBuffer).
            // If the number is 4 or less, m_pdwPropTable should point to
            // cBuffer, since that's where the real data is.
            m_pdwPropTable = 
                dwBytesRead > 4 ? (&dwPropTable - m_iCurrentVar) : 
                ((DWORD*) cBuffer) - m_iCurrentVar;

            bRet = (this->*pFunc)();

            _ASSERT(bRet);
        }
        else
            WriteNULL(m_iCurrentVar);
    }
        
	delete[] cBuffer;
	// don't want to leave this pointing at a buffer that no longer exists!
	m_pBitsBase = NULL; 

    return bRet;
}



/////////////////////////////////////////////////////////////////////////////
// CEventInfoMap

CEventInfoMap::~CEventInfoMap()
{
    while (m_mapNormalEvents.size())
    {
        CNormalInfoMapIterator item = m_mapNormalEvents.begin();

        delete (*item).second;
        
        m_mapNormalEvents.erase(item);
    }

    while (m_mapBlobEvents.size())
    {
        CBlobInfoMapIterator item = m_mapBlobEvents.begin();
        CEventInfo           *pEvent = (*item).second;

        delete pEvent;
        
        m_mapBlobEvents.erase(item);
    }
}

CEventInfo *CEventInfoMap::GetNormalEventInfo(DWORD dwIndex)
{
    CEventInfo             *pInfo;
    CNormalInfoMapIterator item = m_mapNormalEvents.find(dwIndex);

    if (item != m_mapNormalEvents.end())
        pInfo = (*item).second;
    else
        pInfo = NULL;

    return pInfo;
}

CEventInfo *CEventInfoMap::GetBlobEventInfo(LPCWSTR szClassName)
{
    CEventInfo           *pInfo;
    CBlobInfoMapIterator item = m_mapBlobEvents.find(szClassName);

    if (item != m_mapBlobEvents.end())
        pInfo = (*item).second;
    else
        pInfo = NULL;

    return pInfo;
}

BOOL CEventInfoMap::AddNormalEventInfo(DWORD dwIndex, CEventInfo *pInfo)
{
    m_mapNormalEvents[dwIndex] = pInfo;

    return TRUE;
}

BOOL CEventInfoMap::AddBlobEventInfo(LPCWSTR szClassName, CEventInfo *pInfo)
{
    m_mapBlobEvents[szClassName] = pInfo;

    return TRUE;
}

long lTemp = 0;

HRESULT CEventInfo::Indicate()
{
    HRESULT hr;
    
#ifndef USE_SD
	hr = m_pSink->Indicate(1, &m_pObj); 
#else
    if (m_bufferSD.m_dwSize == 0)
        hr = m_pSink->Indicate(1, &m_pObj); 
    else
        hr = m_pSink->IndicateWithSD(1, (IUnknown**) &m_pObj, m_bufferSD.m_dwSize, 
                m_bufferSD.m_pBuffer); 
#endif

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncprov\ncprovider.h ===
// NCProvider.h : Declaration of the CNCProvider

#ifndef __NCProvider_H_
#define __NCProvider_H_

#include "resource.h"       // main symbols
#include <map>
#include <list>
#include <wstlallc.h>
#include "NCDefs.h"
#include "buffer.h"
#include "QueryHelp.h" // For CBstrList
#include "ProvInfo.h"
#include "EventInfo.h"

/////////////////////////////////////////////////////////////////////////////
// CNCProvider

//class CPostBuffer;
class CNCProvider;

typedef std::map<_bstr_t, CNCProvider*, std::less<_bstr_t>, wbem_allocator<CNCProvider*> > CBstrToProvider;
typedef CBstrToProvider::iterator CBstrToProviderIterator;

class CPipeToProvMap : public CBstrToProvider
{
public:
    CPipeToProvMap()
    {
        InitializeCriticalSection(&m_cs);
    }

    virtual ~CPipeToProvMap( )
    {
        DeleteCriticalSection( &m_cs );
    }

    void AddPipeProv(LPCWSTR szPipeName, CNCProvider *pProv);
    void RemovePipeProv(LPCWSTR szPipeName);

    void Lock() { EnterCriticalSection(&m_cs); }
    void Unlock() { LeaveCriticalSection(&m_cs); }

protected:
    CRITICAL_SECTION m_cs;
    
};

class ATL_NO_VTABLE CNCProvider : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CNCProvider, &CLSID_NCProvider>,
	public IWbemProviderInit,
    public IWbemProviderIdentity,
    public IWbemEventProviderSecurity,
    public IWbemEventProviderQuerySink,
    public IWbemEventProvider
{
public:
	CNCProvider();
	~CNCProvider();
        void FinalRelease();

DECLARE_REGISTRY_RESOURCEID(IDR_NCPROVIDER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CNCProvider)
	COM_INTERFACE_ENTRY(IWbemProviderInit)
	COM_INTERFACE_ENTRY(IWbemProviderIdentity)
	COM_INTERFACE_ENTRY(IWbemEventProviderSecurity)
	COM_INTERFACE_ENTRY(IWbemEventProviderQuerySink)
	COM_INTERFACE_ENTRY(IWbemEventProvider)
END_COM_MAP()

    // Globals
    HANDLE           m_heventDone,
                     m_heventConnect,
                     m_hthreadConnect;
    _bstr_t          m_strNamespace,
                     m_strProvider;
    TCHAR            m_szNamedPipe[256];
    HANDLE           // Objects visible to P2 clients
                     m_hPipe;
    CProvInfo*       m_pProv;
    CRITICAL_SECTION m_cs;

    static DWORD WINAPI ConnectThreadProc(CNCProvider *pThis);
    void ConnectLoop();

    BOOL ConnectToNewClient(HANDLE hPipe, OVERLAPPED *pOverlap);
    BOOL CreateAndConnectInstance(OVERLAPPED *pOverlap, BOOL bFirst);
    void DisconnectAndClose(CClientInfo *pInfo);

    static void WINAPI CompletedReadRoutine(
        DWORD dwErr, 
        DWORD cbBytesRead, 
        LPOVERLAPPED lpOverLap);

    void Lock() { EnterCriticalSection(&m_cs); }
    void Unlock() { LeaveCriticalSection(&m_cs); }

// IWbemProviderInit
public:
    HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPWSTR pszUser,
            /* [in] */ LONG lFlags,
            /* [in] */ LPWSTR pszNamespace,
            /* [in] */ LPWSTR pszLocale,
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink);


// IWbemProviderIdentity
public:
    HRESULT STDMETHODCALLTYPE SetRegistrationObject(
            LONG lFlags,
            IWbemClassObject __RPC_FAR *pProvReg);


// IWbemEventProviderSecurity
public:
    HRESULT STDMETHODCALLTYPE AccessCheck( 
        /* [in] */ WBEM_CWSTR wszQueryLanguage,
        /* [in] */ WBEM_CWSTR wszQuery,
        /* [in] */ long lSidLength,
        /* [unique][size_is][in] */ const BYTE __RPC_FAR *pSid);


// IWbemEventProviderQuerySink
public:
    HRESULT STDMETHODCALLTYPE NewQuery( 
        /* [in] */ unsigned long dwId,
        /* [in] */ WBEM_WSTR wszQueryLanguage,
        /* [in] */ WBEM_WSTR wszQuery);
        
    HRESULT STDMETHODCALLTYPE CancelQuery( 
        /* [in] */ unsigned long dwId);


// IWbemEventProvider
public:
    HRESULT STDMETHODCALLTYPE ProvideEvents( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink,
            /* [in] */ long lFlags);

protected:
    HANDLE m_hConnection,
           m_heventNewQuery,
           m_heventCancelQuery,
           m_heventAccessCheck;
};

#endif //__NCProvider_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncprov\precomp.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__1AF40294_748A_4BA9_B2AB_52DFF1CF1D4F__INCLUDED_)
#define AFX_STDAFX_H__1AF40294_748A_4BA9_B2AB_52DFF1CF1D4F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#define NAMED_PIPES

#include <comdef.h>

/*
#undef _CRTIMP
#define _CRTIMP
#include <yvals.h>
#undef _CRTIMP
*/

#include <tchar.h>
#include <sddl.h>

//
// Use of COREPROX_POLARITY should not be needed when ESSLIB 
// is no longer dependent on COREPROX.
//
// #define COREPROX_POLARITY __declspec( dllimport )

/*
#include "corepol.h"
#undef _CRTIMP
#define _CRTIMP POLARITY
#include <yvals.h>
#undef _CRTIMP
#define _CRTIMP __declspec(dllimport)

#include <localloc.h>
*/

#ifndef _WIN64
#define DWORD_PTR DWORD
#endif

//#ifdef _ASSERT
//#undef _ASSERT
//#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1AF40294_748A_4BA9_B2AB_52DFF1CF1D4F__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncprov\queryhelp.h ===
// QueryHelp.h

#pragma once

class CTextLexSource;
class QL1_Parser;
struct QL_LEVEL_1_RPN_EXPRESSION;

#include <list>
#include <wstlallc.h>

typedef std::list<_bstr_t, wbem_allocator<_bstr_t> > CBstrList;
typedef CBstrList::iterator CBstrListIterator;

class CQueryParser
{
public:
    CQueryParser();
    ~CQueryParser();

    HRESULT Init(LPCWSTR szQuery);
    HRESULT GetValuesForProp(LPCWSTR szProperty, CBstrList &listValues);
    HRESULT GetClassName(_bstr_t &strClass);

protected:
    CTextLexSource *m_pLexSource;
    QL1_Parser     *m_pParser;
    QL_LEVEL_1_RPN_EXPRESSION         
                   *m_pExpr;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncprov\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by NCProv.rc
//
#define IDS_PROJNAME                    100
#define IDR_NCPROVIDER                  101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncprov\provinfo.cpp ===
// ProvInfo.cpp

#include "precomp.h"
#include "ProvInfo.h"
#include "NCDefs.h"
#include "dutils.h"
#include "NCProv.h"
#include "NCProvider.h"
#include "QueryHelp.h" // For parsing stuff.

#define COUNTOF(x)  (sizeof(x)/sizeof(x[0]))

extern BOOL bIgnore;

CClientInfo::~CClientInfo()
{
    for (CSinkMapIterator i = m_mapSink.begin(); i != m_mapSink.end(); i++)
    {
        delete (*i).second;
    }   
}

CSinkInfo *CClientInfo::GetSinkInfo(DWORD dwID)
{
    if (dwID == 0)
        return m_pProvider->m_pProv;
    else
    {
        CSinkMapIterator i = m_mapSink.find(dwID);
        CSinkInfo        *pInfo;
        
        if (i != m_mapSink.end())
            pInfo = (*i).second;
        else
            pInfo = NULL;

        return pInfo;
    }
}

HRESULT CClientInfo::PostBuffer(LPBYTE pData, DWORD dwDataSize)
{
    CBuffer buffer(pData, dwDataSize);
        
    while (!buffer.IsEOF())
    {
        DWORD dwMsg = buffer.ReadDWORD();
        
        switch(dwMsg)
        {
            case NC_SRVMSG_CLIENT_INFO:
                DEBUGTRACE(
                    (LOG_ESS, 
                    "NCProv: Got NC_SRVMSG_CLIENT_INFO\n"));

                if (ProcessClientInfo(&buffer))
                    m_pProvider->m_pProv->AddClient(this);
                else
                    m_pProvider->DisconnectAndClose(this);

                // Ignore the rest of this client's messages since the client
                // info message can't be accompanied by any other messages.
                buffer.SetEOF();

                break;

            case NC_SRVMSG_EVENT_LAYOUT:
            {
                LPBYTE pTop = buffer.m_pCurrent - sizeof(DWORD);
                DWORD  dwSize = buffer.ReadDWORD(),
                       dwFuncIndex = buffer.ReadDWORD(),
                       dwSinkIndex = buffer.ReadDWORD();
                    
                DEBUGTRACE(
                    (LOG_ESS, 
                    "NCProv: Got event layout: index = %d, sink = %d\n", 
                    dwFuncIndex, dwSinkIndex));

                CEventInfo *pEvent = new CEventInfo;

                if (pEvent)
                {
                    CSinkInfo *pSinkInfo = GetSinkInfo(dwSinkIndex);

                    if (pSinkInfo && pEvent->InitFromBuffer(this, &buffer))
                    {
                        pEvent->SetSink(pSinkInfo->GetSink());

                        m_mapEvents.AddNormalEventInfo(dwFuncIndex, pEvent);
                    }
                    else
                    {
                        delete pEvent;
                            
                        DEBUGTRACE(
                            (LOG_ESS, 
                            "NCProv: Failed to init event layout: index = %d, sink = %d\n",
                            dwFuncIndex, dwSinkIndex));
                    }
                }

                // Move past the current message.
                buffer.m_pCurrent = pTop + dwSize;
                    
                break;
            }

            case NC_SRVMSG_PREPPED_EVENT:
            {
                LPBYTE     pTop = buffer.m_pCurrent - sizeof(DWORD);
                DWORD      dwSize = buffer.ReadDWORD(),
                           dwEventIndex = buffer.ReadDWORD();
                CEventInfo *pEvent;

                pEvent = m_mapEvents.GetNormalEventInfo(dwEventIndex);

                DEBUGTRACE(
                    (LOG_ESS, 
                    "NCProv: NCMSG_PREPPED_EVENT index %d\n", dwEventIndex));

                if (pEvent)
                {
                    if (pEvent->SetPropsWithBuffer(&buffer))
                    {
#ifndef NO_INDICATE
                        pEvent->Indicate();
#else
                        m_dwEvents++;                            
#endif
                    }
                    else
                        ERRORTRACE(
                            (LOG_ESS, 
                            "NCProv: SetPropsWithBuffer failed, index %d", 
                            dwEventIndex));
                }
                else
                    ERRORTRACE(
                        (LOG_ESS, 
                        "NCProv: Didn't find function info for index %d",
                        dwEventIndex));

                // Move past the current message.
                buffer.m_pCurrent = pTop + dwSize;

                break;
            }

            case NC_SRVMSG_BLOB_EVENT:
            {
                LPBYTE         pTop = buffer.m_pCurrent - sizeof(DWORD);
                DWORD          dwSize = buffer.ReadDWORD(),
                               dwEventIndex = buffer.ReadDWORD(),
                               dwSinkIndex = buffer.ReadDWORD(),
                               dwStrSize;
                LPWSTR         szClassName = buffer.ReadAlignedLenString(&dwStrSize);
                CBlobEventInfo *pEvent;
                    
                pEvent = 
                    (CBlobEventInfo*) 
                        m_mapEvents.GetBlobEventInfo(szClassName);
                    
                if (!pEvent)
                {
                    pEvent = new CBlobEventInfo;

                    if (pEvent)
                    {
                        CSinkInfo *pSinkInfo = GetSinkInfo(dwSinkIndex);

                        if (pSinkInfo && pEvent->InitFromName(this, szClassName))
                        {
                            pEvent->SetSink(pSinkInfo->GetSink());
    
                            m_mapEvents.AddBlobEventInfo(szClassName, pEvent);
                        }
                        else
                        {
                            delete pEvent;

                            ERRORTRACE((LOG_ESS, "NCProv: Failed to init blob event"));

                            buffer.SetEOF();

                            break;
                        }
                    }
                }

                if (pEvent)
                {
                    if (pEvent->SetBlobPropsWithBuffer(&buffer))
                    {
#ifndef NO_INDICATE
                        pEvent->Indicate();
#else
                        m_dwEvents++;                            
#endif
                    }
                    else
                        ERRORTRACE(
                            (LOG_ESS, 
                            "NCProv: SetPropsWithBuffer failed."));
                }

                // Move past the current message.
                buffer.m_pCurrent = pTop + dwSize;

                break;
            }

            case NC_SRVMSG_ACCESS_CHECK_REPLY:
            {
                try
                {
                    NC_SRVMSG_REPLY *pReply = (NC_SRVMSG_REPLY*) buffer.m_pBuffer;
                    CPipeClient     *pClient = (CPipeClient*) pReply->dwMsgCookie;

                    pClient->m_hrClientReply = pReply->hrRet;
                    SetEvent(pClient->m_heventMsgReceived);
                }
                catch(...)
                {
                }

                buffer.SetEOF();

                break;
            }

            case NC_SRVMSG_RESTRICTED_SINK:
            {
                DWORD   dwSinkID = buffer.ReadDWORD(),
                        nQueries = buffer.ReadDWORD();
                LPCWSTR *pszQueries = new LPCWSTR[nQueries];
                
                if (pszQueries)
                {
                    LPCWSTR szCurrent = (LPCWSTR) buffer.m_pCurrent;

                    for (DWORD i = 0; i < nQueries && *szCurrent; i++)
                    {
                        pszQueries[i] = szCurrent;
                        szCurrent += wcslen(szCurrent) + 1;
                    }

                    if (i == nQueries)
                    {
                        HRESULT   hr;
						CSinkInfo *pSinkInfo = NULL;
						try
						{
							 pSinkInfo = new CRestrictedSink(dwSinkID, this);
						}
						catch (...)
						{
							; // nothing - pSinkInfo is NULL now & everybody's happy.
						}

                        if (pSinkInfo)
                        {
                            IWbemEventSink *pWbemSink;

                            hr =
                                m_pProvider->m_pProv->GetSink()->GetRestrictedSink(
                                    nQueries,
                                    pszQueries,
                                    (IUnknown*) pSinkInfo,
                                    &pWbemSink);

                            if (SUCCEEDED(hr))
                            {
                                pSinkInfo->SetSink(pWbemSink);
                                pSinkInfo->SetSink(pWbemSink);
                                pWbemSink->Release();

                                m_mapSink[dwSinkID] = pSinkInfo;

                                // Since we got a new sink, we'll have to 
                                // recheck our subscriptions
/*
                                pSinkInfo->GetSink()->
                                    SetStatus(
                                        WBEM_STATUS_REQUIREMENTS, 
                                        WBEM_REQUIREMENTS_RECHECK_SUBSCRIPTIONS, 
                                        NULL, 
                                        NULL);
*/
                            }
                            else
                                delete pSinkInfo;
                        }
                        else
                            ERRORTRACE(
                                (LOG_ESS, 
                                "NCProv: Failed to create a CSinkInfo."));
                    }
                    else
                        ERRORTRACE(
                            (LOG_ESS, 
                            "NCProv: Client sent mismatched # of strings for restricted sink!"));

                    delete [] pszQueries;
                }

                // Ignore the rest of this client's messages since this
                // message can't be accompanied by any other messages.
                buffer.SetEOF();

                break;
            }

#ifdef USE_SD
            case NC_SRVMSG_SET_EVENT_SD:
            {
                LPBYTE     pTop = buffer.m_pCurrent - sizeof(DWORD);
                DWORD      dwSize = buffer.ReadDWORD(),
                           dwEventIndex = buffer.ReadDWORD();
                CEventInfo *pEvent;

                pEvent = m_mapEvents.GetNormalEventInfo(dwEventIndex);

                DEBUGTRACE(
                    (LOG_ESS, 
                    "NCProv: NC_SRVMSG_SET_EVENT_SD index %d\n", dwEventIndex));

                if (pEvent)
                    pEvent->SetSD(buffer.m_pCurrent, dwSize - sizeof(DWORD) * 3);
                else
                    ERRORTRACE(
                        (LOG_ESS, 
                        "NCProv: NC_SRVMSG_SET_EVENT_SD: Didn't find function info for index %d",
                        dwEventIndex));

                // Move past the current message.
                buffer.m_pCurrent = pTop + dwSize;

                break;
            }

            case NC_SRVMSG_SET_SINK_SD:
            {
                DWORD      dwSinkID = buffer.ReadDWORD(),
                           dwSDSize = buffer.ReadDWORD();
                CSinkInfo  *pSinkInfo = GetSinkInfo(dwSinkID);

                if (pSinkInfo)
                {
                    HRESULT hr;

                    if (FAILED(hr = pSinkInfo->GetSink()->
                        SetSinkSecurity(dwSDSize, buffer.m_pCurrent)))
                    {
                        ERRORTRACE(
                            (LOG_ESS, 
                            "SetSinkSecurity failed: 0x%X", hr));
                    }
                }
                else
                    TRACE(
                        (LOG_ESS, 
                        "NC_SRVMSG_SET_SINK_SD: Didn't find sink info for index %d",
                        dwSinkID));

                // Ignore the rest of this client's messages since this
                // message can't be accompanied by any other messages.
                buffer.SetEOF();

                break;
            }
#endif

            default:
                // Unknown message!
                _ASSERT(FALSE, "NCProv: Received unknown message");
                    
                // Ignore the rest of this message.
                buffer.SetEOF();
        }
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CPipeClient

CPipeClient::CPipeClient(CNCProvider *pProvider, HANDLE hPipe) :
    m_hPipe(hPipe),
#ifndef NO_DECODE
    m_bufferRecv(MAX_EVENT_SIZE)
#else
    m_bufferRecv(500000) // We need to make this really big since we won't know
                         // how big to make it.
#endif
{
    m_pProvider = pProvider;
    memset(&m_info.overlap, 0, sizeof(m_info.overlap));
    m_info.pInfo = this;

    // We'll set this to indicate we've received a message from our client.
    m_heventMsgReceived = CreateEvent(NULL, FALSE, FALSE, NULL);
}

CPipeClient::~CPipeClient()
{
    if (m_hPipe)
    {
        DisconnectNamedPipe(m_hPipe);
 
        // Close the handle to the pipe instance. 
        CloseHandle(m_hPipe); 
    }

    if (m_heventMsgReceived)
        CloseHandle(m_heventMsgReceived);
}

BOOL CPipeClient::ProcessClientInfo(CBuffer *pBuffer)
{
    DWORD dwBufferSize;
    BOOL  bRet;

    if (m_pProvider->m_pProv->ValidateClientSecurity(this))
    {
        dwBufferSize = pBuffer->ReadDWORD();

        // Reset our buffer to the size the client told us to use.
        m_bufferRecv.Reset(dwBufferSize);

        bRet = TRUE;
    }
    else
    {
        m_pProvider->DisconnectAndClose(this);

        bRet = FALSE;
    }

    return bRet;
}

/////////////////////////////////////////////////////////////////////////////
// CInprocClient

CInprocClient::CInprocClient(CNCProvider *pProvider, IPostBuffer *pClientPost)
{
    m_pProvider = pProvider;

    m_pClientPost = pClientPost;
    pClientPost->AddRef();
}

CInprocClient::~CInprocClient()
{
    if (m_pClientPost)  
        m_pClientPost->Release();
}

// In the inproc case we don't need any more information.
BOOL CInprocClient::ProcessClientInfo(CBuffer *pBuffer)
{
    return TRUE;
}

HRESULT CInprocClient::PostBuffer(LPBYTE pData, DWORD dwSize)
{
    if (m_iRef > 1)
        return CClientInfo::PostBuffer(pData, dwSize);
    else
        // If the ref count gets down to 1, we know only one side of the 
        // conversation is holding on to the CInproClient.  So, return
        // FALSE to signal the caller to let go.
        return S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CProvInfo

#ifdef _UNICODE
#define USTR_INSERT     _T("%s")
#else
#define USTR_INSERT     _T("%S")
#endif

CProvInfo::CProvInfo() : m_heventProviderReady(NULL), CSinkInfo(0)
{

}

void GetBaseName(LPCWSTR szName, LPWSTR szBase)
{
    // Normalize this by making sure it doesn't start with "\\.\"
    if (wcsstr(szName, L"\\\\.\\") == szName)
        wcscpy(szBase, szName + 4);
    else
        wcscpy(szBase, szName);

    _wcsupr(szBase);

    // Get rid of the '\' chars since we can't use it in OS object names.
    for (WCHAR *szCurrent = szBase; *szCurrent; szCurrent++)
    {
        if (*szCurrent == '\\')
            *szCurrent = '/';
    }
}

// SDDL string description:
// D:        Security Descriptor
// A:        Access allowed
// 0x1f0003: EVENT_ALL_ACCESS
// BA:       Built-in administrators
// 0x100000: SYNCHRONIZE
// WD:       Everyone
#define ESS_EVENT_SDDL L"D:(A;;0x1f0003;;;BA)(A;;0x100000;;;WD)"

BOOL CProvInfo::Init(LPCWSTR szNamespace, LPCWSTR szProvider)
{
    WCHAR szReadyEventName[MAX_PATH * 2],
          szBaseNamespace[MAX_PATH * 2] = L"",
          szBaseProvider[MAX_PATH * 2] = L"";
        
    if (!szNamespace || !szProvider)
        return FALSE;

    DEBUGTRACE(
        (LOG_ESS, 
        "NCProv: CProvInfo::Init: %S, %S\n", szNamespace, szProvider));

    GetBaseName(szNamespace, szBaseNamespace);
    GetBaseName(szProvider, szBaseProvider);

    // Get the ready event.
    swprintf(
        szReadyEventName, 
        OBJNAME_EVENT_READY L"%s%s", 
        szBaseNamespace,
        szBaseProvider);

    _wcsupr(szReadyEventName);

    // Save these for later.
    m_strName = szProvider;
    m_strBaseName = szBaseProvider;
    m_strBaseNamespace = szBaseNamespace;

    // Create the provider ready event.
    m_heventProviderReady =
        OpenEventW(
            EVENT_ALL_ACCESS,
            FALSE,
            szReadyEventName);

    if (!m_heventProviderReady)
    {
        PSECURITY_DESCRIPTOR pSD = NULL;
        DWORD                dwSize;

        ConvertStringSecurityDescriptorToSecurityDescriptorW(
            ESS_EVENT_SDDL,  // security descriptor string
            SDDL_REVISION_1, // revision level
            &pSD,            // SD
            &dwSize);

        SECURITY_ATTRIBUTES sa = { sizeof(sa), pSD, FALSE };

        m_heventProviderReady =
            CreateEventW(
                &sa,
                TRUE,
                FALSE,
                szReadyEventName);

        if (!m_heventProviderReady)
        {
            ERRORTRACE(
                (LOG_ESS, 
                "NCProv: Couldn't init provider event: err = %d", GetLastError()));
        }

        if (pSD)
            LocalFree((HLOCAL) pSD);
    }

    BOOL bRet;

    if (m_heventProviderReady)
    {
        SetEvent(m_heventProviderReady);

        bRet = TRUE;
    }
    else
        bRet = FALSE;

    return bRet;
}

CProvInfo::~CProvInfo()
{
    if (m_heventProviderReady)
    {
        DEBUGTRACE(
            (LOG_ESS, 
            "NCProv: In ~CProvInfo, resetting ready event.\n"));
        ResetEvent(m_heventProviderReady);
        CloseHandle(m_heventProviderReady);
        
        DWORD dwMsg = NC_CLIMSG_PROVIDER_UNLOADING;

        DEBUGTRACE(
            (LOG_ESS, 
            "NCProv: Sending the NC_CLIMSG_PROVIDER_UNLOADING message.\n"));

        // Tell our clients that we're going away.
        SendMessageToClients((LPBYTE) &dwMsg, sizeof(dwMsg), FALSE);
    }

    CClientInfoListIterator info;

    Lock();

    for ( info = m_listClients.begin( ); 
          info != m_listClients.end( );
          ++info )
    {
        (*info)->Release();
    }

    Unlock();
}

DWORD WINAPI TempThreadProc(IWbemEventSink *pSink)
{
    HRESULT hr;
    
    hr = CoInitializeEx( 0, COINIT_MULTITHREADED );

    if ( FAILED(hr) )
    {
        return hr;
    }

    // Since we got a new client, we'll have to recheck our subscriptions
    pSink->SetStatus(
        WBEM_STATUS_REQUIREMENTS, 
        WBEM_REQUIREMENTS_RECHECK_SUBSCRIPTIONS, 
        NULL, 
        NULL);

    pSink->Release();

    CoUninitialize();

    return 0;
}

// Functions called as clients connect/disconnect with pipe.
void CProvInfo::AddClient(CClientInfo *pInfo)
{
    DEBUGTRACE(
        (LOG_ESS, 
        "NCProv: In AddClient...\n"));

    Lock();

    m_listClients.push_back(pInfo);

    Unlock();

    DWORD dwID;

    IWbemEventSink *pSink = pInfo->m_pProvider->m_pProv->GetSink();

    // Will get released by TempThreadProc.
    pSink->AddRef();

    // We have to do this stuff off a thread, because AddClient is 
    // called from the completed read routine (which means the routine
    // isn't free to receive a response to a client AccessCheck query).
    CloseHandle(
        CreateThread(
            NULL,
            0,
            (LPTHREAD_START_ROUTINE) TempThreadProc,
            pSink,
            0,
            &dwID));

}

void CProvInfo::RemoveClient(CClientInfo *pInfo)
{
    DEBUGTRACE(
        (LOG_ESS, 
        "NCProv: Client removed...\n"));

    CClientInfoListIterator info;

    Lock();

    for (info = m_listClients.begin(); 
        info != m_listClients.end();
        info++)
    {
        if (*info == pInfo)
        {
            m_listClients.erase(info);

            //delete pInfo;
            pInfo->Release();

            break;
        }
    }

    Unlock();
}

BOOL CSinkInfo::BuildClassDescendentList(
    LPCWSTR szClass, 
    CBstrList &listClasses)
{
    IEnumWbemClassObject *pClassEnum = NULL;

    // Add the class name itself to the list.
    listClasses.push_front(szClass);

    if (SUCCEEDED(m_pNamespace->CreateClassEnum(
        (const BSTR) szClass,
        WBEM_FLAG_DEEP,
        NULL,
        &pClassEnum)))
    {
        IWbemClassObject *pClass = NULL;
        DWORD            nCount;

        while(SUCCEEDED(pClassEnum->Next(
            WBEM_INFINITE,
            1,
            &pClass,
            &nCount)) && nCount == 1)
        {
            _variant_t vClass;

            if (SUCCEEDED(pClass->Get(
                L"__CLASS",
                0,
                &vClass,
                NULL,
                NULL) && vClass.vt == VT_BSTR))
            {
                // Upper it to simplify our comparisons later.
                _wcsupr(V_BSTR(&vClass));

                listClasses.push_back(V_BSTR(&vClass));
            }

            pClass->Release();
        }

        pClassEnum->Release();
    }

    return TRUE;
}

HRESULT CProvInfo::SendMessageToClients(LPBYTE pData, DWORD dwSize, BOOL bGetReply)
{
    HRESULT hr = S_OK;

    Lock();

    for (CClientInfoListIterator client = m_listClients.begin();
        client != m_listClients.end(); client++)
    {
        hr = (*client)->SendClientMessage(pData, dwSize, bGetReply);

        if (bGetReply && FAILED(hr))
            break;
    }

    Unlock();

    return hr;
}

// Functions called as CNCProvider:: functions are called by WMI.
HRESULT STDMETHODCALLTYPE CSinkInfo::NewQuery(
    DWORD dwID, 
    WBEM_WSTR szLang, 
    WBEM_WSTR szQuery)
{
    CQueryParser parser;
    HRESULT      hr;
    _bstr_t      strClass;

    DEBUGTRACE(
        (LOG_ESS, 
        "NCProv: CSinkInfo::NewQuery: %d, %S, %S\n", dwID, szLang, szQuery));

    if (SUCCEEDED(hr = parser.Init(szQuery)) &&
        SUCCEEDED(hr = parser.GetClassName(strClass)))
    {
        CBstrList listClasses;

        // Make sure this is upper cased (optimizes compares).  
        _wcsupr(strClass);

        BuildClassDescendentList(strClass, listClasses);

        Lock();

        BOOL bAlreadyInMap = m_mapQueries.find(dwID) != m_mapQueries.end();

        // Keep this in our map.
        if (!bAlreadyInMap)
        {
            m_mapQueries[dwID] = listClasses;

            //pList->assign(listClasses.begin(), listClasses.end());
        }

        Unlock();

        if (GetClientCount() != 0)
        {
            char* szBuffer = new  char[4096];
			if (NULL == szBuffer)
				hr = WBEM_E_OUT_OF_MEMORY;
			else
			{
				CBuffer buffer(szBuffer, sizeof(szBuffer), CBuffer::ALIGN_DWORD_PTR);

				// Header stuff
				buffer.Write((DWORD) NC_CLIMSG_NEW_QUERY_REQ);
				buffer.Write(m_dwID); // Write the sink ID.
				buffer.Write((DWORD_PTR) 0); // No cookie needed.
        
				// New Query data
				buffer.Write(dwID);
				buffer.WriteAlignedLenString(szLang);
				buffer.WriteAlignedLenString(szQuery);

				// Write the newly activated classes.
				for (CBstrListIterator i = listClasses.begin();
					i != listClasses.end();
					i++)
				{
					if (!bAlreadyInMap)
						AddClassRef(*i);

					buffer.WriteAlignedLenString((LPCWSTR) *i);
				}

				// Write the final \0.
				buffer.WriteAlignedLenString(L"");

        
				DWORD dwSize = buffer.GetUsedSize();

				SendMessageToClients(buffer.m_pBuffer, dwSize, FALSE);

				delete[] szBuffer;
			}
        }
        else
        {
            // Add a ref to each class if the query wasn't already in our map.
            if (!bAlreadyInMap)
            {
                for (CBstrListIterator i = listClasses.begin();
                    i != listClasses.end();
                    i++)
                {
                    AddClassRef(*i);
                }
            }
        }
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE CSinkInfo::CancelQuery(DWORD dwID)
{
    DEBUGTRACE(
        (LOG_ESS, 
        "NCProv: CSinkInfo::CancelQuery: %d\n", dwID));

    Lock();

    //BOOL      bProvGoingAway;
    CQueryToClassMapIterator query = m_mapQueries.find(dwID);

    // If this isn't in our map, winmgmt is doing something strange.
    if (query == m_mapQueries.end())
    {
        Unlock();
        return S_OK;
    }

    CBstrList &listClasses = (*query).second;

    // Remove this query's ref on its classes, and remove the classes from the 
    // list that still have a positive ref.  The classes left in the list are 
    // the ones that we need to tell our clients to deactivate.
    for (CBstrListIterator i = listClasses.begin();
        i != listClasses.end();
        )
    {
        if (RemoveClassRef(*i) > 0)
        {
            i = listClasses.erase(i);

            if (i == listClasses.end())
                break;
        }
        else
            // We can't have this in the for loop because listClasses.erase 
            // already moves us ahead.
            i++;
    }

    if (GetClientCount() != 0)
    {
        char    szBuffer[4096];
        CBuffer buffer(szBuffer, sizeof(szBuffer), CBuffer::ALIGN_DWORD_PTR);

        // Header stuff
        buffer.Write((DWORD) NC_CLIMSG_CANCEL_QUERY_REQ);
        buffer.Write(m_dwID); // Write the sink ID.
        buffer.Write((DWORD_PTR) 0); // No cookie needed.
        
        // Cancel Query data
        buffer.Write(dwID);

        // Write the newly deactivated classes.
        for (CBstrListIterator i = listClasses.begin();
            i != listClasses.end();
            i++)
        {
            buffer.WriteAlignedLenString((LPCWSTR) *i);
        }

        // Write the final \0.
        buffer.WriteAlignedLenString(L"");


        DWORD dwSize = buffer.GetUsedSize();

        SendMessageToClients(buffer.m_pBuffer, dwSize, FALSE);
    }

    // Erase this query ID from our map.
    m_mapQueries.erase(query);

    Unlock();

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CProvInfo::AccessCheck(
    LPCWSTR szLang, 
    LPCWSTR szQuery, 
    DWORD dwSidLen, 
    LPBYTE pSid)
{
    DEBUGTRACE(
        (LOG_ESS, 
        "NCProv: CProvInfo::AccessCheck: %S, %S\n", szLang, szQuery));

    HRESULT hr;
    char    szBuffer[1024];
    CBuffer buffer(szBuffer, sizeof(szBuffer), CBuffer::ALIGN_DWORD_PTR);

    // Header stuff
    buffer.Write((DWORD) NC_CLIMSG_ACCESS_CHECK_REQ);
    buffer.Write((DWORD) 0); // We only send this to the main sink (for now).
    buffer.Write((DWORD_PTR) 0); // We'll fill this in later with the real cookie.
        
    // Access Check data
    buffer.WriteAlignedLenString(szLang);
    buffer.WriteAlignedLenString(szQuery);
    buffer.Write(dwSidLen);
    buffer.Write(pSid, dwSidLen);

    DWORD dwSize = buffer.GetUsedSize();

    hr = SendMessageToClients(buffer.m_pBuffer, dwSize, TRUE);

    return hr;
}

int CSinkInfo::AddClassRef(LPCWSTR szClass)
{
    CBstrToIntIterator i = m_mapEnabledClasses.find(szClass);
    int                iRet = 1;

    if (i == m_mapEnabledClasses.end())
    {
        iRet = 1;
        m_mapEnabledClasses[szClass] = 1;
    }
    else
        iRet = ++(*i).second;

    return iRet;
}

int CSinkInfo::RemoveClassRef(LPCWSTR szClass)
{
    CBstrToIntIterator i = m_mapEnabledClasses.find(szClass);
    int                iRet = 0;

    if (i != m_mapEnabledClasses.end())
    {
        iRet = --(*i).second;

        if (iRet <= 0)
            m_mapEnabledClasses.erase(i);
    }

    return iRet;
}

_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));


//#define NO_DACL_CHECK

// retrieve the acl from the provider registration
// upon success, *pDacl points to a byte array containing the dacl
// will be NULL if dacl is NULL
// caller's responsibility to delete memory
HRESULT CProvInfo::GetProviderDacl(IWbemServices *pNamespace, BYTE** pDacl)
{
    HRESULT hr = WBEM_E_INVALID_PROVIDER_REGISTRATION;
    
	DEBUGTRACE((LOG_ESS, "NCProv: GetProviderDacl\n"));

#ifdef NO_DACL_CHECK
    hr = WBEM_S_NO_ERROR;
#else

    WCHAR szObjPath[MAX_PATH * 2];

    swprintf(
        szObjPath, 
        L"__Win32Provider.Name=\"%s\"", 
        (LPCWSTR) m_strName);

    IWbemClassObjectPtr pRegistration;
    
    if (SUCCEEDED(hr = 
        pNamespace->GetObject(szObjPath, 0, NULL, &pRegistration, NULL)))
    {
        _variant_t vSD;

        if (SUCCEEDED(hr = pRegistration->Get(L"SecurityDescriptor", 0, &vSD, NULL, NULL)))
        {
            if (vSD.vt == VT_NULL)
            {
                hr = WBEM_S_NO_ERROR;
                *pDacl = NULL;

				DEBUGTRACE((LOG_ESS, "NCProv: GetProviderDacl - NULL SD\n"));

            }
            else
            {
                _ASSERT(vSD.vt == VT_BSTR, "");
				
				PSECURITY_DESCRIPTOR pSD;
				
				if (ConvertStringSecurityDescriptorToSecurityDescriptorW(
					vSD.bstrVal, SDDL_REVISION_1, &pSD,	NULL))
				{
					PACL pAcl;
					BOOL bDaclPresent, bDaclDefaulted;
					
					if (GetSecurityDescriptorDacl(pSD, &bDaclPresent, &pAcl, &bDaclDefaulted))
					{
						if (bDaclPresent)
						{
							ACL_SIZE_INFORMATION sizeInfo;
							GetAclInformation(pAcl, &sizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

							if (*pDacl = new BYTE[sizeInfo.AclBytesInUse + sizeInfo.AclBytesFree])
								memcpy(*pDacl, pAcl, sizeInfo.AclBytesInUse);
							else
								hr = WBEM_E_OUT_OF_MEMORY;
						}
						else
						{
							pDacl = NULL;
							hr = WBEM_S_NO_ERROR;
						}
					}
					else
					{
						ERRORTRACE((LOG_ESS, "NCProv: Failed to retrieve DACL\n"));
						hr = WBEM_E_FAILED;
					}

					LocalFree(pSD);
				}
				else
				{
					ERRORTRACE((LOG_ESS, "NCProv: Failed to convert SecurityDescriptor property\n"));
					hr = WBEM_E_INVALID_PARAMETER;
				}
            }
        }
		else
			ERRORTRACE((LOG_ESS, "NCProv: Failed to retrieve SecurityDescriptor property, 0x%08X\n", hr));
    }

	DEBUGTRACE((LOG_ESS, "NCProv: GetProviderDacl returning 0x%08X\n", hr));


#endif // NO_DACL_CHECK


    return hr;
}

// Borrowed heavliy from the pseudo provider code (SinkHolder.cpp).
HRESULT CProvInfo::ClientAccessCheck(CPipeClient *pInfo, PACL pDacl)
{
    BOOL ian;
    HRESULT hr = WBEM_E_ACCESS_DENIED;

    if (pDacl != NULL)
    {
        // Just in case we're already impersonating
        // CoRevertToSelf();

        // djinn up a descriptor to use
        SECURITY_DESCRIPTOR sd;    
        ian = InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);

        // find our token & sid
        HANDLE hToken;
        SID_AND_ATTRIBUTES* pSidAndAttr;
        DWORD sizeRequired;

        DWORD err;
        ian = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken);
        err = GetLastError();

        // call once & see how much room we need
        ian = GetTokenInformation(hToken, TokenUser, NULL, 0, &sizeRequired);
        err = GetLastError();

        pSidAndAttr = (SID_AND_ATTRIBUTES*) new BYTE[sizeRequired];
        //CDeleteMe<SID_AND_ATTRIBUTES> freeSid(pSidAndAttr);

        if (pSidAndAttr && 
            GetTokenInformation(hToken, TokenUser, (LPVOID)pSidAndAttr, sizeRequired, &sizeRequired))
        {
            // set sd's sids
            PSID pSid = pSidAndAttr->Sid;
            ian = SetSecurityDescriptorOwner(&sd, pSid, TRUE);
            ian = SetSecurityDescriptorGroup(&sd, pSid, TRUE);
            
            // dangle the ding-donged dacl
            ian = SetSecurityDescriptorDacl(&sd, TRUE, pDacl, TRUE);

            // all the goodies accessCheck needs to fly
            GENERIC_MAPPING map;
            map.GenericRead = 0;
            map.GenericWrite = 1;
            map.GenericExecute = 0;
            map.GenericAll = 1;

            PRIVILEGE_SET ps[10];
            DWORD size = 10 * sizeof(PRIVILEGE_SET);

            DWORD dwGranted;
            BOOL bResult;
            DWORD mask = GENERIC_ALL | GENERIC_WRITE;
                        
			/***************
			debugging only, buffer not freed...
			WCHAR* outbuf = NULL;
			ConvertSecurityDescriptorToStringSecurityDescriptorW(&sd, SDDL_REVISION_1, DACL_SECURITY_INFORMATION, &outbuf, NULL);
			****************/

            if (ImpersonateNamedPipeClient(pInfo->m_hPipe))
            {    
                err = GetLastError();

                HANDLE hUserToken;
                if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hUserToken))
				{
	
					/********************
					debugging only, buffer(s) not freed...
					BYTE sidBuf[2048];
					SID_AND_ATTRIBUTES* pSidAndAttr = (SID_AND_ATTRIBUTES*) sidBuf;

					DWORD size = 2048;
					GetTokenInformation(hUserToken, TokenUser, (LPVOID)pSidAndAttr, size, &size);

					WCHAR* pUserSid;
					ConvertSidToStringSid(pSidAndAttr->Sid,  &pUserSid);
					*********************/

					RevertToSelf();					

					ian = ::AccessCheck(&sd, hUserToken, MAXIMUM_ALLOWED, &map, &ps[0], &size, &dwGranted, &bResult);
					err = GetLastError();
					if (ian && (dwGranted & mask))
						hr = WBEM_S_NO_ERROR;
					else
						hr = WBEM_E_ACCESS_DENIED;
				}
            }
        }

        if (pSidAndAttr)
            delete pSidAndAttr;
    }
    else
        // we're on Win9X, no prob - let's do it!
        // same diff if we've got a NULL dacl
        hr = WBEM_S_NO_ERROR;

    return hr;
}

BOOL CProvInfo::ValidateClientSecurity(CPipeClient *pInfo)
{
    BOOL bRet = FALSE;
    BYTE *pDaclBits = NULL;
    
    if (SUCCEEDED(GetProviderDacl(
        pInfo->m_pProvider->m_pProv->GetNamespace(), &pDaclBits)))
    {            
        bRet = SUCCEEDED(ClientAccessCheck(pInfo, (PACL) pDaclBits));

        if (pDaclBits)
            delete pDaclBits;
    }

    return bRet;
}

#define REPLY_WAIT_TIMEOUT 1000

HRESULT CPipeClient::SendClientMessage(LPVOID pData, DWORD dwSize, BOOL bGetReply)
{
    CPipeClient **pCookie = (CPipeClient**) ((LPBYTE) pData + sizeof(DWORD) * 2);
    DWORD       dwWritten;

    if (bGetReply)
        *pCookie = this;

    //
    // Allocate a bigger buffer to put the length in
    //

    BYTE* pBuffer = new BYTE[dwSize + sizeof(DWORD)];
    if(pBuffer == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    *(DWORD*)pBuffer = dwSize + sizeof(DWORD);
    memcpy(pBuffer + sizeof(DWORD), pData, dwSize);

    BOOL bRes = WriteFile(m_hPipe, pBuffer, dwSize + sizeof(DWORD),
                            &dwWritten, NULL);
    delete [] pBuffer;

    if(!bRes)
        return WBEM_E_FAILED;

    if(dwWritten != dwSize + sizeof(DWORD))
        return WBEM_E_FAILED;

    if (bGetReply)
    {
        HRESULT hr;

        if (WaitForSingleObject(m_heventMsgReceived, REPLY_WAIT_TIMEOUT) == 0)
            hr = m_hrClientReply;
        else
            hr = WBEM_E_FAILED;

        return hr;
    }
    else
        return S_OK;
}

HRESULT CInprocClient::SendClientMessage(LPVOID pData, DWORD dwSize, BOOL bGetReply)
{
    HRESULT hr;
    
    if (m_iRef > 1)
        hr = m_pClientPost->PostBuffer((LPBYTE) pData, dwSize);
    else
        hr = S_OK;
    
    return hr;
}

CRestrictedSink::CRestrictedSink(DWORD dwID, CClientInfo *pInfo) :
    CSinkInfo(dwID),
    m_pInfo(pInfo)
{
    SetNamespace(pInfo->m_pProvider->m_pProv->GetNamespace());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncprov\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "precomp.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncprov\queryhelp.cpp ===
// QueryHelp.cpp
#include "precomp.h"

// Becase someone is using _ASSERT in WMI!

#ifdef _ASSERT
#undef _ASSERT
#endif

//#include <analyser.h>

#include <ql.h>
#include "QueryHelp.h"

CQueryParser::CQueryParser() :
    m_pLexSource(NULL),
    m_pParser(NULL),
    m_pExpr(NULL)   
{
}

CQueryParser::~CQueryParser()
{
    if (m_pLexSource)
        delete m_pLexSource;

    if (m_pParser)
        delete m_pParser;

    if (m_pExpr)
        delete m_pExpr;
}

HRESULT CQueryParser::Init(LPCWSTR szQuery)
{
    HRESULT hr = WBEM_E_OUT_OF_MEMORY;

    m_pLexSource = new CTextLexSource(szQuery);

    if (m_pLexSource)
    {
        m_pParser = new QL1_Parser(m_pLexSource);
    
        if (m_pParser)
        {
            if (m_pParser->Parse(&m_pExpr) == 0)
                hr = S_OK;
            else
                hr = WBEM_E_INVALID_QUERY;
        }
    }

    return hr;
}

HRESULT CQueryParser::GetClassName(_bstr_t &strClass)
{
    HRESULT hr;

    if (m_pExpr)
    {
        strClass = m_pExpr->bsClassName;
        hr = S_OK;
    }
    else
        hr = WBEM_E_FAILED;
    
    return S_OK;
}

/*
HRESULT CQueryParser::GetValuesForProp(LPCWSTR szProperty, CBstrList &listValues)
{
    CPropertyName prop;
    
    prop.AddElement(szProperty);

    // Get the necessary query
    QL_LEVEL_1_RPN_EXPRESSION *pPropExpr;
    HRESULT hres = 
                CQueryAnalyser::GetNecessaryQueryForProperty(
                    m_pExpr, 
                    prop, 
                    pPropExpr);
    
    if (FAILED(hres))
        return hres;

    // See if there are any tokens
    if (pPropExpr->nNumTokens > 0)
    {
        // Combine them all
        for (int i = 0; i < pPropExpr->nNumTokens && SUCCEEDED(hres); i++)
        {
            QL_LEVEL_1_TOKEN &token = pPropExpr->pArrayOfTokens[i];
        
            if (token.nTokenType == QL1_NOT)
                hres = WBEMESS_E_REGISTRATION_TOO_BROAD;
            else if (token.nTokenType == QL1_AND || token.nTokenType == QL1_OR)
            {
                // We treat them all as ORs
                // ========================
            }
            else    
            {
                // This is a token
                if (token.nOperator != QL1_OPERATOR_EQUALS)
                    hres = WBEMESS_E_REGISTRATION_TOO_BROAD;
                else if (V_VT(&token.vConstValue) != VT_BSTR)
                    hres = WBEM_E_INVALID_QUERY;
                else
                {
                    // This token is a string equality.
                    listValues.push_back(V_BSTR(&token.vConstValue));
                }
            }
        }
    }
    else
        hres = WBEMESS_E_REGISTRATION_TOO_BROAD;

    delete pPropExpr;

    return hres;

}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\blobdcod\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\blobdcod\blobdcod.cpp ===
// BlobDcod.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f BlobDcodps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "BlobDcod.h"

#include "BlobDcod_i.c"
#include "BlobDecoder.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_TestBlobDecoder, CBlobDecoder)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_BLOBDCODLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\blobdcod\blobdecoder.cpp ===
// BlobDecoder.cpp : Implementation of CBlobDecoder
#include "stdafx.h"
#include "BlobDcod.h"
#include "BlobDecoder.h"

struct TEST_BLOB
{
    WCHAR szName[25];
    DWORD dwIndex;
    BYTE  cData[10];
    WCHAR szStrings[3][25];
};

#define DWORD_ALIGNED(x)    ((DWORD)((((x) * 8) + 31) & (~31)) / 8)

/////////////////////////////////////////////////////////////////////////////
// CBlobDecoder

HRESULT STDMETHODCALLTYPE CBlobDecoder::DecodeProperty( 
    /* [in] */ VARIANT __RPC_FAR *pPropertyHandle,
    /* [unique][in][out] */ CIMTYPE __RPC_FAR *pType,
    /* [in] */ BYTE __RPC_FAR *pBlob,
    /* [in] */ DWORD dwBlobSize,
    /* [unique][in][out] */ BYTE __RPC_FAR *pOutBuffer,
    /* [in] */ DWORD dwOutBufferSize,
    /* [unique][in][out] */ DWORD __RPC_FAR *dwBytesRead)
{
    HRESULT   hr = E_FAIL;
    TEST_BLOB *pTestBlob = (TEST_BLOB*) pBlob;

    // Make sure the size is right and that the property handle is
    // an integer.
    if (dwBlobSize == sizeof(*pTestBlob) && pPropertyHandle->vt == VT_I4)
    {
        switch(pPropertyHandle->iVal)
        {
            // Name
            case 0:
            {
                DWORD dwLength = 
                         (wcslen(pTestBlob->szName) + 1) * sizeof(WCHAR),
                      dwTotal = dwLength + sizeof(DWORD);

                if (pType)
                    *pType = CIM_STRING;

                if (dwTotal <= dwOutBufferSize)
                {
                    memcpy(pOutBuffer + sizeof(DWORD), pTestBlob->szName, 
                        dwLength);
                    
                    *(DWORD*) pOutBuffer = dwLength;
                    *dwBytesRead = dwTotal;

                    hr = S_OK;
                }
                else
                    hr = WBEM_E_BUFFER_TOO_SMALL;

                break;
            }
                
            // Index
            case 1:
            {
                DWORD dwLength = sizeof(DWORD);

                if (pType)
                    *pType = CIM_UINT32;

                if (dwLength <= dwOutBufferSize)
                {
                    *(DWORD*) pOutBuffer = pTestBlob->dwIndex;
                    
                    *dwBytesRead = dwLength;

                    hr = S_OK;
                }
                else
                    hr = WBEM_E_BUFFER_TOO_SMALL;

                break;
            }

            // ByteArray
            case 2:
            {
                DWORD dwLength = sizeof(pTestBlob->cData) + sizeof(DWORD);

                if (pType)
                    *pType = CIM_UINT8 | CIM_FLAG_ARRAY;

                if (dwLength <= dwOutBufferSize)
                {
                    // For arrays the first 4 bytes indicates the number of
                    // elements in the array.
                    *(DWORD*) pOutBuffer = sizeof(pTestBlob->cData);
                    
                    // Copy in the array data.
                    memcpy(
                        pOutBuffer + sizeof(DWORD), 
                        pTestBlob->cData, 
                        sizeof(pTestBlob->cData));
                    
                    *dwBytesRead = dwLength;

                    hr = S_OK;
                }
                else
                    hr = WBEM_E_BUFFER_TOO_SMALL;

                break;
            }

            // StringArray
            case 3:
            {
                DWORD dwLength = 
                        (wcslen(pTestBlob->szStrings[0]) + 1 +
                        wcslen(pTestBlob->szStrings[1]) + 1 +
                        wcslen(pTestBlob->szStrings[2]) + 1) * sizeof(WCHAR) +
                        sizeof(DWORD);

                if (pType)
                    *pType = CIM_STRING | CIM_FLAG_ARRAY;

                if (dwLength <= dwOutBufferSize)
                {
                    LPBYTE pCurrent;

                    // For arrays the first 4 bytes indicates the number of
                    // elements in the array.
                    *(DWORD*) pOutBuffer = 3;
                    
                    // Get past the first 4 bytes.
                    pCurrent = pOutBuffer + sizeof(DWORD);

                    for (int i = 0; i < 3; i++)
                    {
                        DWORD dwStrLen = 
                                (wcslen(pTestBlob->szStrings[i]) + 1) * 
                                    sizeof(WCHAR);

                        *(DWORD*) pCurrent = dwStrLen;
                        memcpy(
                            pCurrent + sizeof(DWORD), 
                            pTestBlob->szStrings[i], 
                            dwStrLen);

                        pCurrent += sizeof(DWORD) + DWORD_ALIGNED(dwStrLen);
                    }

                    *dwBytesRead = dwLength;

                    hr = S_OK;
                }
                else
                    hr = WBEM_E_BUFFER_TOO_SMALL;

                break;
            }
        }
    }

    return hr;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\ncprov\provinfo.h ===
// ProvInfo.h

#pragma once

#include <list>
#include <map>
#include <wstlallc.h>
#include "NCDefs.h" // For IPostBuffer
#include "buffer.h"
#include "EventInfo.h"
#include "QueryHelp.h" // For CBstrList

/////////////////////////////////////////////////////////////////////////////
// CClientInfo

class CNCProvider;
class CProvInfo;
class CEventInfoMap;

_COM_SMARTPTR_TYPEDEF(IWbemEventSink, __uuidof(IWbemEventSink));
_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));

class CSinkInfo;

typedef std::map<DWORD, CSinkInfo*, std::less<DWORD>, wbem_allocator<CSinkInfo*> > CSinkMap;
typedef CSinkMap::iterator CSinkMapIterator;

class CClientInfo : public IPostBuffer
{ 
public:
    CEventInfoMap m_mapEvents;
    CNCProvider   *m_pProvider;
    CSinkMap      m_mapSink;

    CClientInfo() :
        m_iRef(1)
    {
    }

    ULONG AddRef()
    {
        return InterlockedIncrement(&m_iRef);
    }

    ULONG Release()
    {
        LONG lRet = InterlockedDecrement(&m_iRef);

        if (!lRet)
            delete this;

        return lRet;
    }
    
    virtual HRESULT SendClientMessage(LPVOID pData, DWORD dwSize, 
        BOOL bGetReply = FALSE) = 0;

    virtual ~CClientInfo();

    virtual BOOL ProcessClientInfo(CBuffer *pBuffer) = 0;

    virtual HRESULT PostBuffer(LPBYTE pData, DWORD dwSize);

protected:
    LONG m_iRef;

    CSinkInfo *GetSinkInfo(DWORD dwID);
};

class CPipeClient;

struct OLAP_AND_CLIENT
{
    OVERLAPPED  overlap;
    CPipeClient *pInfo;
};

class CPipeClient : public CClientInfo
{
public:
    // We have to do this because the completion routine won't let us pass
    // custom data along with the OVERLAPPED struct.  We can't pass 'this'
    // because this first points to the junk found in CClientInfo.  So, we
    // have to pass m_info, which is OVERLAPPED + this.
    OLAP_AND_CLIENT 
               m_info;
    CBuffer    m_bufferRecv;
    HANDLE     m_hPipe,
               m_heventMsgReceived;
    HRESULT    m_hrClientReply;

    CPipeClient(CNCProvider *pProvider, HANDLE hPipe);
    ~CPipeClient();

    HRESULT SendClientMessage(LPVOID pData, DWORD dwSize, 
        BOOL bGetReply = FALSE);

    BOOL ProcessClientInfo(CBuffer *pBuffer);
};

class CInprocClient : public CClientInfo
{
public:
    IPostBuffer *m_pClientPost;

    CInprocClient(CNCProvider *pProvider, IPostBuffer *pClientPost);
    ~CInprocClient();

    HRESULT SendClientMessage(LPVOID pData, DWORD dwSize, 
        BOOL bGetReply = FALSE);

    BOOL ProcessClientInfo(CBuffer *pBuffer);
    virtual HRESULT PostBuffer(LPBYTE pData, DWORD dwSize);
};

/////////////////////////////////////////////////////////////////////////////
// CProvInfo

typedef std::list<CClientInfo*, wbem_allocator<CClientInfo*> > CClientInfoList;
typedef CClientInfoList::iterator CClientInfoListIterator;

typedef std::map<_bstr_t, int, std::less<_bstr_t>, wbem_allocator<int> > CBstrToInt;
typedef CBstrToInt::iterator CBstrToIntIterator;

typedef std::map<int, int, std::less<int>, wbem_allocator<int> > CIntToIntMap;
typedef CIntToIntMap::iterator CIntToIntMapIterator;

class CSinkInfo : 
    public IWbemEventProviderQuerySink
{
public:
    CSinkInfo(DWORD dwSinkID) :
        m_dwID(dwSinkID),
        m_lRef(1)
    {
        InitializeCriticalSection(&m_cs);
    }

    virtual ~CSinkInfo()
    {
        DeleteCriticalSection(&m_cs);
    }

    void SetNamespace(IWbemServices *pNamespace)
    {
        m_pNamespace = pNamespace;
    }

    IWbemServices *GetNamespace() { return m_pNamespace; }

    void SetSink(IWbemEventSink *pSink)
    {
        m_pSink = pSink;
    }

    IWbemEventSink *GetSink() { return m_pSink; }

// IUnknown
public:
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID refid, PVOID *ppThis)
    {
        if (refid == IID_IUnknown || refid == IID_IWbemEventProviderQuerySink)
        {
            *ppThis = this;
            AddRef();
            
            return S_OK;
        }
        else
            return E_NOINTERFACE;
    }

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return InterlockedIncrement(&m_lRef);
    }

    ULONG STDMETHODCALLTYPE Release()
    {
        LONG lRet = InterlockedDecrement(&m_lRef);

        if (!lRet)
            delete this;

        return lRet;
    }

// IWbemEventProviderQuerySink
public:
    HRESULT STDMETHODCALLTYPE NewQuery( 
        /* [in] */ DWORD dwId,
        /* [in] */ WBEM_WSTR wszQueryLanguage,
        /* [in] */ WBEM_WSTR wszQuery);
        
    HRESULT STDMETHODCALLTYPE CancelQuery( 
        /* [in] */ unsigned long dwId);

// Implementation
protected:
    typedef std::map<DWORD, CBstrList, std::less<DWORD>, wbem_allocator<CBstrList> > CQueryToClassMap;
    typedef CQueryToClassMap::iterator CQueryToClassMapIterator;

    IWbemServicesPtr  m_pNamespace;
    IWbemEventSinkPtr m_pSink;
    CBstrToInt        m_mapEnabledClasses;
    CQueryToClassMap  m_mapQueries;
    DWORD             m_dwID;
    LONG              m_lRef;
    CRITICAL_SECTION  m_cs;

    void Lock() { EnterCriticalSection(&m_cs); }
    void Unlock() { LeaveCriticalSection(&m_cs); }

    int AddClassRef(LPCWSTR szClass);
    int RemoveClassRef(LPCWSTR szClass);

    BOOL BuildClassDescendentList(
        LPCWSTR szClass, 
        CBstrList &listClasses);

    virtual DWORD GetClientCount() = 0;
    virtual HRESULT SendMessageToClients(LPBYTE pData, DWORD dwSize, BOOL bGetReply) = 0;
};

class CRestrictedSink : public CSinkInfo
{
public:
    CRestrictedSink(DWORD dwID, CClientInfo *pInfo);

protected:
    CClientInfo *m_pInfo;

    virtual DWORD GetClientCount() { return 1; }
    virtual HRESULT SendMessageToClients(LPBYTE pData, DWORD dwSize, BOOL bGetReply)
    {
        return m_pInfo->SendClientMessage(pData, dwSize, bGetReply);
    }
};

class CProvInfo : public CSinkInfo
{ 
public:
    _bstr_t m_strName,
            m_strBaseName,
            m_strBaseNamespace;
    HRESULT m_hrClientMsgResult;

    CProvInfo();
    ~CProvInfo();

    // Called when the provider finds out its name.
    BOOL Init(LPCWSTR szNamespace, LPCWSTR szProvider);

    // Functions called as clients connect/disconnect with pipe.
    void AddClient(CClientInfo *pInfo);
    void RemoveClient(CClientInfo *pInfo);

    HRESULT STDMETHODCALLTYPE AccessCheck(
        LPCWSTR szLang, 
        LPCWSTR szQuery, 
        DWORD dwSidLen, 
        LPBYTE pSid);

    BOOL ValidateClientSecurity(CPipeClient *pInfo);

protected:
    CClientInfoList m_listClients;
    HANDLE          m_heventProviderReady;

    HRESULT GetProviderDacl(IWbemServices *pNamespace, BYTE** pDacl);
    HRESULT ClientAccessCheck(CPipeClient *pInfo, PACL pDacl);

    virtual DWORD GetClientCount()
    {
        return m_listClients.size();
    }

    virtual HRESULT SendMessageToClients(LPBYTE pData, DWORD dwSize, BOOL bGetReply);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\ncetest\ncetest.h ===
// NCETest.h : main header file for the NCETEST application
//

#if !defined(AFX_NCETEST_H__30F783E6_0BA3_4E78_8F9F_A23DEBDB2C4C__INCLUDED_)
#define AFX_NCETEST_H__30F783E6_0BA3_4E78_8F9F_A23DEBDB2C4C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CTestApp:
// See NCETest.cpp for the implementation of this class
//

class CTestApp : public CWinApp
{
public:
	CTestApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTestApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CTestApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

extern CTestApp theApp;

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NCETEST_H__30F783E6_0BA3_4E78_8F9F_A23DEBDB2C4C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\ncetest\events.cpp ===
// Events.cpp
#include "stdafx.h"
#include <wbemcli.h>
#include "NCObjApi.h"
#include "Events.h"

#define COUNTOF(x)  (sizeof(x)/sizeof(x[0]))

// Some random data to send.
#define NUM_STRINGS 3
#define NUM_REFS    3
#define NUM_DATES   3

LPCWSTR szStringArray[] = { L"String1", L"String2", L"String3" };
LPCWSTR szRefArray[] = { L"Win32_Bus.DeviceID=\"PCI_BUS_0\"", 
                         L"Win32_Bus.DeviceID=\"PCI_BUS_1\"", 
                         L"Win32_Bus.DeviceID=\"Isa_BUS_0\"" };
LPCWSTR szDateArray[] = { L"199903260900**.**********", 
                          L"199903270900**.**********", 
                          L"199903280900**.**********" };
BYTE    cByteArray[] = { 0, 1, 2 };
WORD    bBoolArray[] = { 0, 1, 0, 1 };
WORD    wWordArray[] = { 3, 4, 5 };
DWORD   dwDwordArray[] = { 6, 7, 8 };
DWORD64 dwDword64Array[] = { 9, 10, 11 };
float   fFloatArray[] = { 0.25, 0.5, 0.75 };
double  dDoubleArray[] = { 1.33, 1.66, 2.0 };

// Our connections.
extern HANDLE g_hConnection;
//extern HANDLE g_hConnectionDWORD;

BOOL CGenericEvent::Init()
{
    m_strName = "Generic Event";
    m_strQuery = 
        "select * from MSFT_WMI_GenericNonCOMEvent "
        "where providername=\"NCETest Event Provider\"";

    return TRUE;
}

DWORD g_dwIndexGeneric = 0;

BOOL CGenericEvent::ReportEvent()
{
    BOOL bRet;

    bRet =
        WmiReportEvent(
            g_hConnection,
            L"MSFT_WMI_GenericNonCOMEvent",
            L"StringParam!s! Sint64Param!I64i! Uint32Param!u! "
                L"Uint8Array!c[]! StringArray!s[]! BoolArray!b[]!",                    
            L"Another string.", // StringParam
            (DWORD64) 1024,     // Sint64Param
            g_dwIndexGeneric++,              // Uint32Param
            cByteArray, COUNTOF(cByteArray), // Uint8Array,
            szStringArray, NUM_STRINGS,      // StringArray
            bBoolArray, COUNTOF(bBoolArray)  // BoolArray
        );

    return bRet;
}

BOOL CBlobEvent::Init()
{
    m_strName = "Blob Event";
    m_strQuery = 
        "select * from MSFT_NCETest_BlobEvent";

    return TRUE;
}

// Used for testing WmiReportEventBlob.
struct TEST_BLOB
{
    WCHAR szName[25];
    DWORD dwIndex;
    BYTE  cData[10];
    WCHAR szStrings[3][25];
};

TEST_BLOB g_blob = 
    { L"My blob", 0, { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }, 
        { L"String1", L"String2", L"String3" } };

BOOL CBlobEvent::ReportEvent()
{
    BOOL bRet;

    // Just to make it interesting.
    g_blob.dwIndex++;

    bRet =
        WmiReportEventBlob(
            g_hConnection,
            L"MSFT_NCETest_BlobEvent",
            &g_blob,
            sizeof(g_blob));

    return bRet;
}

BOOL CDWORDEvent::Init()
{
    LPCWSTR szIndex = L"Index";
    CIMTYPE type = CIM_UINT32;

    m_strName = "DWORD Event";
    m_strQuery = 
        "select * from MSFT_NCETest_DWORDEvent";

    m_hEvent =
        WmiCreateObjectWithProps(
            //g_hConnectionDWORD,
            g_hConnection,
            L"MSFT_NCETest_DWORDEvent",
            WMI_CREATEOBJ_LOCKABLE,
            1,
            &szIndex,
            &type);

    SetPropsWithManyCalls();

    return m_hEvent != NULL;
}

DWORD g_dwIndexDWORD = 0;

BOOL CDWORDEvent::SetAndFire(DWORD dwFlags)
{
    BOOL bRet;
    
    bRet = 
        WmiSetAndCommitObject(
            m_hEvent,
            dwFlags,
            g_dwIndexDWORD++);

    return bRet;
}

BOOL CDWORDEvent::SetPropsWithOneCall()
{
    BOOL bRet;
    
    bRet = 
        WmiSetObjectProps(
            m_hEvent,
            g_dwIndexDWORD++);

    return bRet;
}

BOOL CDWORDEvent::SetPropsWithManyCalls()
{
    BOOL bRet;
    
    bRet = 
        WmiSetObjectProp(
            m_hEvent,
            0,
            g_dwIndexDWORD++);

    return bRet;
}

BOOL CDWORDEvent::ReportEvent()
{
    BOOL bRet;
    
    bRet = 
        WmiReportEvent(
            //g_hConnectionDWORD,
            g_hConnection,
            L"MSFT_NCETest_DWORDEvent",
            L"Index!d!",
            g_dwIndexDWORD++);

    return bRet;
}




BOOL CSmallEvent::Init()
{
    LPCWSTR szNames[3] = { L"Index", L"BoolParam", L"StringParam" };
    CIMTYPE pTypes[3] = { CIM_UINT32, CIM_BOOLEAN, CIM_STRING };

    m_strName = "Small Event";
    m_strQuery = 
        "select * from MSFT_NCETest_3PropEvent";

    m_hEvent =
        WmiCreateObjectWithProps(
            g_hConnection,
            L"MSFT_NCETest_3PropEvent",
            0,
            3,
            szNames,
            pTypes);

    SetPropsWithManyCalls();

    return m_hEvent != NULL;
}

DWORD g_dwIndexSmall = 0;

BOOL CSmallEvent::SetAndFire(DWORD dwFlags)
{
    BOOL bRet;

    bRet =
        WmiSetAndCommitObject(
            m_hEvent,
            dwFlags,
            g_dwIndexSmall++,
            TRUE,
            L"1");

    bRet =
        WmiSetAndCommitObject(
            m_hEvent,
            dwFlags,
            g_dwIndexSmall++,
            TRUE,
            L"WmiSetAndCommitObjectWmiSetAndCommitObjectWmiSetAndCommitObjectWmiSetAndCommitObjectWmiSetAndCommitObjectWmiSetAndCommitObjectWmiSetAndCommitObjectWmiSetAndCommitObjectWmiSetAndCommitObjectWmiSetAndCommitObjectWmiSetAndCommitObjectWmiSetAndCommitObject");

    return bRet;
}

BOOL CSmallEvent::SetPropsWithOneCall()
{
    BOOL bRet;

    bRet =
        WmiSetObjectProps(
            m_hEvent,
            g_dwIndexSmall++,
            TRUE,
            L"WmiSetObjectProps");

    return bRet;
}

BOOL CSmallEvent::ReportEvent()
{
    BOOL bRet;
    
    bRet = 
        WmiReportEvent(
            g_hConnection,
            L"MSFT_NCETest_3PropEvent",
            L"Index!d! BoolParam!b! StringParam!s!",
            g_dwIndexSmall++,
            TRUE,
            L"WmiReportEvent");

    return bRet;
}

BOOL CSmallEvent::SetPropsWithManyCalls()
{
    BOOL bRet;

    bRet =
        WmiSetObjectProp(
            m_hEvent,
            0,
            g_dwIndexSmall++);

    bRet &=
        WmiSetObjectProp(
            m_hEvent,
            1,
            TRUE);

    bRet &=
        WmiSetObjectProp(
            m_hEvent,
            2,
            L"WmiSetObjectProp");

    return bRet;
}

HANDLE hEmbeddedObjs[3];

void InitEmbeddedObjs(HANDLE hSource)
{
    LPCWSTR szProcessorNames[3] = { L"Name", L"CurrentClockSpeed", L"L2CacheSize" },
            szBusNames[3] = { L"Name", L"DeviceID", L"BusNum" },
            szBIOSNames[3] = { L"Name", L"Status", L"PrimaryBIOS" };
    CIMTYPE pProcessorTypes[3] = { CIM_STRING, CIM_UINT32, CIM_UINT32 },
            pBusTypes[3] = { CIM_STRING, CIM_STRING, CIM_UINT32 },
            pBIOSTypes[3] = { CIM_STRING, CIM_STRING, CIM_BOOLEAN };

    hEmbeddedObjs[0] =
        WmiCreateObjectWithProps(
            hSource,
            L"Win32_Processor",
            WMI_CREATEOBJ_LOCKABLE,
            3,
            szProcessorNames,
            pProcessorTypes);

    WmiSetObjectProps(
        hEmbeddedObjs[0],
        L"Intel Pentium III processor",
        800,
        256);


    hEmbeddedObjs[1] =
        WmiCreateObjectWithProps(
            hSource,
            L"Win32_Bus",
            WMI_CREATEOBJ_LOCKABLE,
            3,
            szBusNames,
            pBusTypes);

    WmiSetObjectProps(
        hEmbeddedObjs[1],
        L"Bus",
        L"PCI_BUS_1",
        5);


    hEmbeddedObjs[2] =
        WmiCreateObjectWithProps(
            hSource,
            L"Win32_BIOS",
            WMI_CREATEOBJ_LOCKABLE,
            3,
            szBIOSNames,
            pBIOSTypes);

    WmiSetObjectProps(
        hEmbeddedObjs[2],
        L"Default System BIOS",
        L"OK",
        TRUE);
}


#ifdef USE_NULLS
IWbemClassObject *pWbemClassObjs[5];
#else
IWbemClassObject *pWbemClassObjs[3];
#endif

LPCWSTR szWbemClassNames[3] = { L"Win32_Bus", L"Win32_Processor", L"Win32_BIOS" };

void InitWbemClassObjs()
{
    IWbemLocator *pLocator;
    HRESULT      hr;

    // Only do this once.
    if (pWbemClassObjs[0])
        return;

    CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if ((hr = CoCreateInstance(
        CLSID_WbemLocator,
		NULL,
		CLSCTX_INPROC_SERVER,
		IID_IWbemLocator,
		(LPVOID *) &pLocator)) == S_OK)
    {
        IWbemServices *pNamespace = NULL;

        if ((hr = pLocator->ConnectServer(
            _bstr_t(L"root\\cimv2"),
			NULL,    // username
			NULL,	 // password
			NULL,    // locale
			0L,		 // securityFlags
			NULL,	 // authority (domain for NTLM)
			NULL,	 // context
			&pNamespace)) == S_OK) 
        {	
            pLocator->Release();

            for (int i = 0; i < 3; i++)
            {
                IWbemClassObject *pClass = NULL;

                pNamespace->GetObject(
                    _bstr_t(szWbemClassNames[i]),
                    0,
                    NULL,
                    &pClass,
                    NULL);
            
#ifdef USE_NULLS
                // i + 1 so that the 1st and last ones will be NULL (to make sure 
                // we allow for NULLs in IWbemClassObject arrays).
                pClass->SpawnInstance(0, (IWbemClassObject**) &pWbemClassObjs[i + 1]);
#else
                pClass->SpawnInstance(0, (IWbemClassObject**) &pWbemClassObjs[i]);
#endif

                pClass->Release();
            }

            //pNamespace->Release();
        }
    }

//    CoUninitialize();
}


enum PROP_INDEX
{
    PI_StringParam,
    PI_StringArray,

    PI_Char16Param,
    PI_Char16Array,

    PI_DateParam,
    PI_DateArray,

    PI_RefParam,
    PI_RefArray,

    PI_BoolParam,
    PI_BoolArray,

    PI_ObjParam,
    PI_ObjArray,

    PI_WbemClassObjParam,
    PI_WbemClassObjArray,

    PI_Real32Param,
    PI_Real32Array,

    PI_Real64Param,
    PI_Real64Array,

    PI_Uint8Param,
    PI_Uint8Array,
    PI_Sint8Param,
    PI_Sint8Array,

    PI_Uint16Param,
    PI_Uint16Array,
    PI_Sint16Param,
    PI_Sint16Array,

    PI_Uint32Param,
    PI_Uint32Array,
    PI_Sint32Param,
    PI_Sint32Array,

    PI_Uint64Param,
    PI_Uint64Array,
    PI_Sint64Param,
    PI_Sint64Array,
};

LPCWSTR pszProps[] = 
{ 
    L"StringParam",
    L"StringArray",

    L"Char16Param",
    L"Char16Array",

    L"DateParam",
    L"DateArray",

    L"RefParam",
    L"RefArray",

    L"BoolParam",
    L"BoolArray",

    L"ObjParam",
    L"ObjArray",

    L"WbemClassObjParam",
    L"WbemClassObjArray",

    L"Real32Param",
    L"Real32Array",

    L"Real64Param",
    L"Real64Array",

    L"Uint8Param",
    L"Uint8Array",
    L"Sint8Param",
    L"Sint8Array",

    L"Uint16Param",
    L"Uint16Array",
    L"Sint16Param",
    L"Sint16Array",

    L"Uint32Param",
    L"Uint32Array",
    L"Sint32Param",
    L"Sint32Array",

    L"Uint64Param",
    L"Uint64Array",
    L"Sint64Param",
    L"Sint64Array",
};

long pTypes[] = 
{  
    CIM_STRING,                     //L"StringParam",
    CIM_STRING | CIM_FLAG_ARRAY,    //L"StringArray",

    CIM_CHAR16,                     //L"Char16Param",
    CIM_CHAR16 | CIM_FLAG_ARRAY,    //L"Char16Array",

    CIM_DATETIME,                   //L"DateParam",
    CIM_DATETIME | CIM_FLAG_ARRAY,  //L"DateArray",

    CIM_REFERENCE,                  //L"RefParam",
    CIM_REFERENCE | CIM_FLAG_ARRAY, //L"RefArray",

    CIM_BOOLEAN,                    //L"BoolParam",
    CIM_BOOLEAN | CIM_FLAG_ARRAY,   //L"BoolArray",

    CIM_OBJECT,                     //L"ObjParam",
    CIM_OBJECT | CIM_FLAG_ARRAY,    //L"ObjArray",

    CIM_IUNKNOWN,                   //L"WbemClassObjParam",
    CIM_IUNKNOWN | CIM_FLAG_ARRAY,  //L"WbemClassObjArray",

    CIM_REAL32,                     //L"Real32Param",
    CIM_REAL32 | CIM_FLAG_ARRAY,    //L"Real32Array",

    CIM_REAL64,                     //L"Real64Param",
    CIM_REAL64 | CIM_FLAG_ARRAY,    //L"Real64Array",

    CIM_UINT8,                      //L"Uint8Param",
    CIM_UINT8 | CIM_FLAG_ARRAY,     //L"Uint8Array",
    CIM_SINT8,                      //L"Sint8Param",
    CIM_SINT8 | CIM_FLAG_ARRAY,     //L"Sint8Array",

    CIM_UINT16,                     //L"Uint16Param",
    CIM_UINT16 | CIM_FLAG_ARRAY,    //L"Uint16Array",
    CIM_SINT16,                     //L"Sint16Param",
    CIM_SINT16 | CIM_FLAG_ARRAY,    //L"Sint16Array",

    CIM_UINT32,                     //L"Uint32Param",
    CIM_UINT32 | CIM_FLAG_ARRAY,    //L"Uint32Array",
    CIM_SINT32,                     //L"Sint32Param",
    CIM_SINT32 | CIM_FLAG_ARRAY,    //L"Sint32Array",

    CIM_UINT64,                     //L"Uint64Param",
    CIM_UINT64 | CIM_FLAG_ARRAY,    //L"Uint64Array",
    CIM_SINT64,                     //L"Sint64Param",
    CIM_SINT64 | CIM_FLAG_ARRAY,    //L"Sint64Array",
};

#define NUM_PROPS  (sizeof(pTypes)/sizeof(pTypes[0]))


BOOL CAllPropsTypeEvent::Init()
{
    m_strName = "All prop types Event";
    m_strQuery = 
        "select * from MSFT_NCETest_AllPropTypesEvent";


    InitEmbeddedObjs(g_hConnection);

    m_hEvent = 
        WmiCreateObjectWithProps(
            g_hConnection,
            L"MSFT_NCETest_AllPropTypesEvent",
            0,
            NUM_PROPS,
            pszProps,
            pTypes);

    SetPropsWithManyCalls();

    return m_hEvent != NULL;
}

BOOL CAllPropsTypeEvent::SetAndFire(DWORD dwFlags)
{
    BOOL bRet;

    InitWbemClassObjs();

    bRet = 
        WmiSetAndCommitObject(
            m_hEvent,
            dwFlags,

            L"A string.",               //L"StringParam",
            szStringArray, NUM_STRINGS, //L"StringArray",

            100,                                     //L"Char16Param",
            L"Some chars.", COUNTOF(L"Some chars."), //L"Char16Array",

            L"199903260900**.**********",   //L"DateParam",
            szDateArray, NUM_DATES,         //L"DateArray",

            L"Win32_Processor.DeviceID=\"CPU0\"", //L"RefParam",
            szRefArray, NUM_REFS,                 //L"RefArray",

            FALSE,                           //L"BoolParam",
            bBoolArray, COUNTOF(bBoolArray), //L"BoolArray",

            hEmbeddedObjs[0],                       //L"ObjParam",
            hEmbeddedObjs, COUNTOF(hEmbeddedObjs),  //L"ObjArray",

            pWbemClassObjs[0],                       //L"WbemClassObjParam",
            pWbemClassObjs, COUNTOF(pWbemClassObjs), //L"WbemClassObjArray",

            (float) 42.3,                      //L"Real32Param",
            fFloatArray, COUNTOF(fFloatArray), //L"Real32Array",

            (double) 7.8,                        //L"Real64Param",
            dDoubleArray, COUNTOF(dDoubleArray), //L"Real64Array",

            13,                              //L"Uint8Param",
            cByteArray, COUNTOF(cByteArray), //L"Uint8Array",
        
            14,                              //L"Sint8Param",
            cByteArray, COUNTOF(cByteArray), //L"Sint8Array",

            15,                              //L"Uint16Param",
            wWordArray, COUNTOF(wWordArray), //L"Uint16Array",
    
            16,                              //L"Sint16Param",
            wWordArray, COUNTOF(wWordArray), //L"Sint16Array",

            17,                                  //L"Uint32Param",
            dwDwordArray, COUNTOF(dwDwordArray), //L"Uint32Array",
        
            18,                                  //L"Sint32Param",
            dwDwordArray, COUNTOF(dwDwordArray), //L"Sint32Array",

            (DWORD64) 19,                            //L"Uint64Param",
            dwDword64Array, COUNTOF(dwDword64Array), //L"Uint64Array",
        
            (DWORD64) 20,                            //L"Sint64Param",
            dwDword64Array, COUNTOF(dwDword64Array)  //L"Sint64Array",
        );

    return bRet;
}

BOOL CAllPropsTypeEvent::SetPropsWithOneCall()
{
    BOOL bRet;

    InitWbemClassObjs();

    bRet = 
        WmiSetObjectProps(
            m_hEvent,

            L"A string.",               //L"StringParam",
            szStringArray, NUM_STRINGS, //L"StringArray",

            100,                                     //L"Char16Param",
            L"Some chars.", COUNTOF(L"Some chars."), //L"Char16Array",

            L"199903260900**.**********",   //L"DateParam",
            szDateArray, NUM_DATES,         //L"DateArray",

            L"Win32_Processor.DeviceID=\"CPU0\"", //L"RefParam",
            szRefArray, NUM_REFS,                 //L"RefArray",

            FALSE,                           //L"BoolParam",
            bBoolArray, COUNTOF(bBoolArray), //L"BoolArray",

            hEmbeddedObjs[0],                       //L"ObjParam",
            hEmbeddedObjs, COUNTOF(hEmbeddedObjs),  //L"ObjArray",

            pWbemClassObjs[0],                       //L"WbemClassObjParam",
            pWbemClassObjs, COUNTOF(pWbemClassObjs), //L"WbemClassObjArray",

            (float) 42.3,                      //L"Real32Param",
            fFloatArray, COUNTOF(fFloatArray), //L"Real32Array",

            (double) 7.8,                        //L"Real64Param",
            dDoubleArray, COUNTOF(dDoubleArray), //L"Real64Array",

            13,                              //L"Uint8Param",
            cByteArray, COUNTOF(cByteArray), //L"Uint8Array",
        
            14,                              //L"Sint8Param",
            cByteArray, COUNTOF(cByteArray), //L"Sint8Array",

            15,                              //L"Uint16Param",
            wWordArray, COUNTOF(wWordArray), //L"Uint16Array",
    
            16,                              //L"Sint16Param",
            wWordArray, COUNTOF(wWordArray), //L"Sint16Array",

            17,                                  //L"Uint32Param",
            dwDwordArray, COUNTOF(dwDwordArray), //L"Uint32Array",
        
            18,                                  //L"Sint32Param",
            dwDwordArray, COUNTOF(dwDwordArray), //L"Sint32Array",

            (DWORD64) 19,                            //L"Uint64Param",
            dwDword64Array, COUNTOF(dwDword64Array), //L"Uint64Array",
        
            (DWORD64) 20,                            //L"Sint64Param",
            dwDword64Array, COUNTOF(dwDword64Array)  //L"Sint64Array",
        );

    return bRet;
}

BOOL CAllPropsTypeEvent::ReportEvent()
{
    BOOL bRet;

    InitWbemClassObjs();

    bRet = 
        WmiReportEvent(
            g_hConnection,
            
            // Class name
            L"MSFT_NCETest_AllPropTypesEvent",

            // Property info
            L"StringParam!s! StringArray!s[]! Char16Param!w! Char16Array!w[]! "
            L"DateParam!s! DateArray!s[]! RefParam!s! RefArray!s[]! "
            L"BoolParam!b! BoolArray!b[]! ObjParam!o! ObjArray!o[]! "
            L"WbemClassObjParam!O! WbemClassObjArray!O[]! "
            L"Real32Param!f! Real32Array!f[]! Real64Param!g! Real64Array!g[]! "
            L"Uint8Param!c! Uint8Array!c[]! Sint8Param!c! Sint8Array!c[]! "
            L"Uint16Param!w! Uint16Array!w[]! Sint16Param!w! Sint16Array!w[]! "
            L"Uint32Param!u! Uint32Array!u[]! Sint32Param!u! Sint32Array!u[]! "
            L"Uint64Param!I64u! Uint64Array!I64u[]! Sint64Param!I64u! Sint64Array!I64u[]! ",
                
            // Data
            L"A string.",               //L"StringParam",
            szStringArray, NUM_STRINGS, //L"StringArray",

            100,                                     //L"Char16Param",
            L"Some chars.", COUNTOF(L"Some chars."), //L"Char16Array",

            L"199903260900**.**********",   //L"DateParam",
            szDateArray, NUM_DATES,         //L"DateArray",

            L"Win32_Processor.DeviceID=\"CPU0\"", //L"RefParam",
            szRefArray, NUM_REFS,                 //L"RefArray",

            FALSE,                           //L"BoolParam",
            bBoolArray, COUNTOF(bBoolArray), //L"BoolArray",

            hEmbeddedObjs[0],                       //L"ObjParam",
            hEmbeddedObjs, COUNTOF(hEmbeddedObjs),  //L"ObjArray",

            pWbemClassObjs[0],                       //L"WbemClassObjParam",
            pWbemClassObjs, COUNTOF(pWbemClassObjs), //L"WbemClassObjArray",

            (float) 42.3,                      //L"Real32Param",
            fFloatArray, COUNTOF(fFloatArray), //L"Real32Array",

            (double) 7.8,                        //L"Real64Param",
            dDoubleArray, COUNTOF(dDoubleArray), //L"Real64Array",

            13,                              //L"Uint8Param",
            cByteArray, COUNTOF(cByteArray), //L"Uint8Array",
        
            14,                              //L"Sint8Param",
            cByteArray, COUNTOF(cByteArray), //L"Sint8Array",

            15,                              //L"Uint16Param",
            wWordArray, COUNTOF(wWordArray), //L"Uint16Array",
    
            16,                              //L"Sint16Param",
            wWordArray, COUNTOF(wWordArray), //L"Sint16Array",

            17,                                  //L"Uint32Param",
            dwDwordArray, COUNTOF(dwDwordArray), //L"Uint32Array",
        
            18,                                  //L"Sint32Param",
            dwDwordArray, COUNTOF(dwDwordArray), //L"Sint32Array",

            (DWORD64) 19,                            //L"Uint64Param",
            dwDword64Array, COUNTOF(dwDword64Array), //L"Uint64Array",
        
            (DWORD64) 20,                            //L"Sint64Param",
            dwDword64Array, COUNTOF(dwDword64Array)  //L"Sint64Array",
        );

    return bRet;
}

BOOL CAllPropsTypeEvent::SetPropsWithManyCalls()
{
    BOOL bRet;

    InitWbemClassObjs();

    bRet = 
        WmiSetObjectProp(
            m_hEvent,
            PI_StringParam,
            L"A very very very very long string."               //L"StringParam",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_StringParam,
            L"A short string."               //L"StringParam",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_StringArray,
            szStringArray, NUM_STRINGS  //L"StringArray",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Char16Param,
            100                                      //L"Char16Param",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Char16Array,
            L"Some chars.", COUNTOF(L"Some chars.")  //L"Char16Array",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_DateParam,
            L"199903260900**.**********"    //L"DateParam",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Char16Param,
            100                                     //L"Char16Param",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_DateArray,
            szDateArray, NUM_DATES          //L"DateArray",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_RefParam,
            L"Win32_Processor.DeviceID=\"CPU0\""  //L"RefParam",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_RefArray,
            szRefArray, NUM_REFS                  //L"RefArray",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_BoolParam,
            FALSE                            //L"BoolParam",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_BoolArray,
            bBoolArray, COUNTOF(bBoolArray)  //L"BoolArray",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_ObjParam,
            hEmbeddedObjs[0]                        //L"ObjParam",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_ObjArray,
            hEmbeddedObjs, COUNTOF(hEmbeddedObjs)   //L"ObjArray",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_WbemClassObjParam,
            pWbemClassObjs[0]                        //L"ObjParam",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_WbemClassObjArray,
            pWbemClassObjs, COUNTOF(pWbemClassObjs)   //L"ObjArray",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Real32Param,
            (float) 42.3                       //L"Real32Param",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Real32Array,
            fFloatArray, COUNTOF(fFloatArray)  //L"Real32Array",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Real64Param,
            (double) 7.8                         //L"Real64Param",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Real64Array,
            dDoubleArray, COUNTOF(dDoubleArray)  //L"Real64Array",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Uint8Param,
            13                               //L"Uint8Param",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Uint8Array,
            cByteArray, COUNTOF(cByteArray)  //L"Uint8Array",
        );
        
    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Sint8Param,
            14                               //L"Sint8Param",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Sint8Array,
            cByteArray, COUNTOF(cByteArray)  //L"Sint8Array",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Uint16Param,
            15                               //L"Uint16Param",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Uint16Array,
            wWordArray, COUNTOF(wWordArray)  //L"Uint16Array",
        );
    
    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Sint16Param,
            16                               //L"Sint16Param",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Sint16Array,
            wWordArray, COUNTOF(wWordArray)  //L"Sint16Array",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Uint32Param,
            17                                   //L"Uint32Param",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Uint32Array,
            dwDwordArray, COUNTOF(dwDwordArray)  //L"Uint32Array",
        );
        
    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Sint32Param,
            18                                   //L"Sint32Param",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Sint32Array,
            dwDwordArray, COUNTOF(dwDwordArray)  //L"Sint32Array",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Uint64Param,
            (DWORD64) 19                             //L"Uint64Param",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Uint64Array,
            dwDword64Array, COUNTOF(dwDword64Array)  //L"Uint64Array",
        );
        
    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Sint64Param,
            (DWORD64) 20                             //L"Sint64Param",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Sint64Array,
            dwDword64Array, COUNTOF(dwDword64Array)  //L"Sint64Array",
        );

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\ncetest\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__79A00F00_8E67_47D8_8DBC_3F0A0E5EAED7__INCLUDED_)
#define AFX_STDAFX_H__79A00F00_8E67_47D8_8DBC_3F0A0E5EAED7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <comdef.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__79A00F00_8E67_47D8_8DBC_3F0A0E5EAED7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\ncetest\ncetest.cpp ===
// NCETest.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "NCETest.h"
#include "TestDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTestApp

BEGIN_MESSAGE_MAP(CTestApp, CWinApp)
	//{{AFX_MSG_MAP(CTestApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTestApp construction

CTestApp::CTestApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CTestApp object

CTestApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CTestApp initialization

BOOL CTestApp::InitInstance()
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CTestDlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = (int) dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\ncetest\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	NCETest.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\ncetest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by NCETest.rc
//
#define IDC_CONNECT                     3
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_NCETEST_DIALOG              102
#define IDR_MAINFRAME                   128
#define IDD_SD                          129
#define IDC_COUNT                       1000
#define IDC_EVENT_TYPES                 1002
#define IDC_API                         1003
#define IDC_QUERY                       1005
#define IDC_SEND                        1006
#define IDC_CALLBACK                    1007
#define IDC_CLEAR                       1009
#define IDC_COPY                        1010
#define IDS_TIME                        1011
#define IDS_PER_SECOND                  1012
#define IDC_EVENT_SD                    1014
#define IDC_CONNECTION_SD               1015
#define IDC_ALLOW_NAME                  1015
#define IDC_NULL                        1016

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1017
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\ncetest\events.h ===
// Events.h

class CNCEvent
{
public:
    CString m_strName,
            m_strQuery;

    virtual ~CNCEvent()
    {
    }

    virtual BOOL Init() = 0;
    virtual BOOL ReportEvent() = 0;
};

class CGenericEvent : public CNCEvent
{
public:
    BOOL Init();
    BOOL ReportEvent();
};

class CBlobEvent : public CNCEvent
{
public:
    BOOL Init();
    BOOL ReportEvent();
};

class CPropEvent : public CNCEvent
{
public:
    HANDLE m_hEvent;

    CPropEvent() :
        m_hEvent(NULL)
    {
    }

    BOOL Commit()
    {
        return WmiCommitObject(m_hEvent);
    }

    virtual ~CPropEvent()
    {
        if (m_hEvent)
            WmiDestroyObject(m_hEvent);
    }

    virtual BOOL SetAndFire(DWORD dwFlags)
    {
        return FALSE;
    }

    virtual BOOL SetPropsWithOneCall() = 0;
    virtual BOOL SetPropsWithManyCalls() = 0;
    virtual BOOL ReportEvent()
    {
        return FALSE;
    }
};

class CDWORDEvent : public CPropEvent
{
public:
    BOOL Init();
    BOOL SetAndFire(DWORD dwFlags);
    BOOL SetPropsWithOneCall();
    BOOL SetPropsWithManyCalls();
    BOOL ReportEvent();
};

class CSmallEvent : public CPropEvent
{
public:
    BOOL Init();
    BOOL SetAndFire(DWORD dwFlags);
    BOOL SetPropsWithOneCall();
    BOOL SetPropsWithManyCalls();
    BOOL ReportEvent();
};

class CAllPropsTypeEvent : public CPropEvent
{
public:
    BOOL Init();
    BOOL SetAndFire(DWORD dwFlags);
    BOOL SetPropsWithOneCall();
    BOOL SetPropsWithManyCalls();
    BOOL ReportEvent();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\ncetest\testdlg.cpp ===
// TestDlg.cpp : implementation file
//

#include "stdafx.h"
#include "NCETest.h"
#include "TestDlg.h"
#include "NCObjApi.h"
#include "Events.h"
//#include "SecDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

HANDLE g_hConnection;
//       g_hConnectionDWORD,
//       g_hConnection3Prop,
//       g_hConnectionAllProps;

enum EVENT_TYPE
{
    EVENT_Generic,
    EVENT_Blob,
    EVENT_DWORD,
    EVENT_3Prop,
    EVENT_AllProps
};

enum API_TYPE
{
    API_WmiSetAndCommitObject,
    API_WmiCommitObject,
    API_WmiSetObjectPropWmiCommitObject,
    API_WmiSetObjectPropsWmiCommitObject,
    API_WmiReportEvent,
    API_WmiReportEventBlob,
};

// The first event index that is a real property event.
#define FIRST_PROP_EVENT  EVENT_DWORD

/////////////////////////////////////////////////////////////////////////////
// CTestDlg dialog

CTestDlg::CTestDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CTestDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CTestDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);

    ZeroMemory(m_pEvents, sizeof(m_pEvents));
}

CTestDlg::~CTestDlg()
{
    FreeHandles();
}

#define BUFFER_SIZE  64000
#define SEND_LATENCY 1000

void CTestDlg::Connect()
{
    g_hConnection =
        WmiEventSourceConnect(
            L"root\\cimv2",
            L"NCETest Event Provider",
            TRUE,
            BUFFER_SIZE,
            SEND_LATENCY,
            this,
            EventSourceCallback);

/*
    LPCWSTR szQuery = L"select * from MSFT_NCETest_DWORDEvent";

    g_hConnectionDWORD =
        WmiCreateRestrictedConnection(
            g_hConnection,
            1,
            &szQuery,
            this,
            EventSourceCallback);

    szQuery = L"select * from MSFT_NCETest_3PropEvent";
    g_hConnection3Prop =
        WmiCreateRestrictedConnection(
            g_hConnection,
            1,
            &szQuery,
            this,
            EventSourceCallback);

    szQuery = L"select * from MSFT_NCETest_AllPropTypesEvent";
    g_hConnectionAllProps =
        WmiCreateRestrictedConnection(
            g_hConnection,
            1,
            &szQuery,
            this,
            EventSourceCallback);
*/

    if (g_hConnection != NULL)
    {
        // Setup some events.
        m_pEvents[0] = new CGenericEvent;
        m_pEvents[1] = new CBlobEvent;
        m_pEvents[2] = new CDWORDEvent;
        m_pEvents[3] = new CSmallEvent;
        m_pEvents[4] = new CAllPropsTypeEvent;

        for (int i = 0; i < NUM_EVENT_TYPES; i++)
        {
            if (!m_pEvents[i]->Init())
            {
                CString strMsg;

                strMsg.Format(
                    "Unable to init '%s'",
                    (LPCTSTR) m_pEvents[i]->m_strName);

                AfxMessageBox(strMsg);
            }
        }
    }
    else
    {
        CString strMsg;

        strMsg.Format(
            "WmiEventSourceConnect failed (err = %d)",
            GetLastError());

        AfxMessageBox(strMsg);
    }
    
}

void CTestDlg::FreeHandles()
{
    for (int i = 0; i < NUM_EVENT_TYPES; i++)
    {
        if (m_pEvents[i])
        {
            delete m_pEvents[i];

            m_pEvents[i] = NULL;
        }
    }

    if (g_hConnection)
    {
        WmiEventSourceDisconnect(g_hConnection);

        g_hConnection = NULL;
    }
}

void CTestDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTestDlg)
	DDX_Control(pDX, IDC_CALLBACK, m_ctlCallback);
	DDX_Control(pDX, IDC_API, m_ctlAPI);
	DDX_Control(pDX, IDC_EVENT_TYPES, m_ctlEventTypes);
	//}}AFX_DATA_MAP

    if (!pDX->m_bSaveAndValidate)
    {
        int nEvents;

        nEvents =
            theApp.GetProfileInt("Settings", "Events", 1);

        if (nEvents <= 0)
            nEvents = 1;

        SetDlgItemInt(IDC_COUNT, nEvents);
    }
    else
    {
        theApp.WriteProfileInt("Settings", "Events", GetDlgItemInt(IDC_COUNT));
        theApp.WriteProfileInt("Settings", "API", m_ctlAPI.GetCurSel());
        theApp.WriteProfileInt("Settings", "Type", m_ctlEventTypes.GetCurSel());
    }
}

BEGIN_MESSAGE_MAP(CTestDlg, CDialog)
	//{{AFX_MSG_MAP(CTestDlg)
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_CONNECT, OnConnect)
	ON_CBN_SELCHANGE(IDC_EVENT_TYPES, OnSelchangeEventTypes)
	ON_BN_CLICKED(IDC_SEND, OnSend)
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_COPY, OnCopy)
	ON_BN_CLICKED(IDC_CLEAR, OnClear)
	ON_BN_CLICKED(IDC_CONNECTION_SD, OnConnectionSd)
	ON_BN_CLICKED(IDC_EVENT_SD, OnEventSd)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTestDlg message handlers

BOOL CTestDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
    // Save this off for later.
    m_hwndStatus = ::GetDlgItem(m_hWnd, IDC_CALLBACK);
    
    // Connect to the non-COM API.
    Connect();

	// Setup our combo boxes.
    for (int i = 0; i < NUM_EVENT_TYPES; i++)
        m_ctlEventTypes.AddString(m_pEvents[i]->m_strName);

    m_ctlAPI.AddString("WmiSetAndCommitObject");
    m_ctlAPI.AddString("WmiCommitObject");
    m_ctlAPI.AddString("WmiSetObjectProp*n + WmiCommitObject");
    m_ctlAPI.AddString("WmiSetObjectProps + WmiCommitObject");
    m_ctlAPI.AddString("WmiReportEvent");
    m_ctlAPI.AddString("WmiReportEventBlob");


    int iTemp;
    
    iTemp =
        theApp.GetProfileInt("Settings", "API", API_WmiCommitObject);
    m_ctlAPI.SetCurSel(iTemp);

    iTemp =
        theApp.GetProfileInt("Settings", "Type", EVENT_DWORD);
    m_ctlEventTypes.SetCurSel(iTemp);

    OnSelchangeEventTypes();

    return TRUE;  // return TRUE  unless you set the focus to a control
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CTestDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CTestDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

void CTestDlg::OnConnect() 
{
	FreeHandles();

    Connect();
}

void CTestDlg::OnSelchangeEventTypes() 
{
	EVENT_TYPE type = (EVENT_TYPE) m_ctlEventTypes.GetCurSel();

    SetDlgItemText(IDC_QUERY, m_pEvents[type]->m_strQuery);
    
    // This should only be enabled if we're not using a blob
    // or generic
    if (type == EVENT_Blob)
    {
        m_ctlAPI.SetCurSel(API_WmiReportEventBlob);
        m_ctlAPI.EnableWindow(FALSE);
        
        GetDlgItem(IDC_EVENT_SD)->EnableWindow(FALSE);
    }
    else if (type == EVENT_Generic)
    {
        m_ctlAPI.SetCurSel(API_WmiReportEvent);
        m_ctlAPI.EnableWindow(FALSE);
        
        GetDlgItem(IDC_EVENT_SD)->EnableWindow(FALSE);
    }
    else
    {
        m_ctlAPI.EnableWindow(TRUE);
        
        GetDlgItem(IDC_EVENT_SD)->EnableWindow(TRUE);
    }
}

void CTestDlg::OnSend() 
{
	CWaitCursor wait;
    int         nEvents = GetDlgItemInt(IDC_COUNT);
	EVENT_TYPE  type = (EVENT_TYPE) m_ctlEventTypes.GetCurSel();
    API_TYPE    api = (API_TYPE) m_ctlAPI.GetCurSel();

    if (type != EVENT_Blob && api == API_WmiReportEventBlob)
    {
        AfxMessageBox(
            "The selected event type can't be fired using ReportEventBlob.");

        return;
    }

    DWORD dwBegin;

    // I'm going to repeat the for/loop for every API so I don't have to have
    // a switch statement inside the loop (which would degrade throughput
    // speeds).
    if (api == API_WmiReportEvent || api == API_WmiReportEventBlob)
    {
        CNCEvent *pEvent = m_pEvents[type];

        dwBegin = GetTickCount();

        for (int i = 0; i < nEvents; i++)
            pEvent->ReportEvent();
    }
    else
    {
        CPropEvent *pEvent = (CPropEvent*) m_pEvents[type];

        if (api == API_WmiSetAndCommitObject)
        {
            dwBegin = GetTickCount();

            for (int i = 0; i < nEvents; i++)
                pEvent->SetAndFire(WMI_SENDCOMMIT_SET_NOT_REQUIRED);
        }
        else if (api == API_WmiCommitObject)
        {
            dwBegin = GetTickCount();

            for (int i = 0; i < nEvents; i++)
                pEvent->Commit();
        }
        else if (api == API_WmiSetObjectPropsWmiCommitObject)
        {
            dwBegin = GetTickCount();

            for (int i = 0; i < nEvents; i++)
            {
                pEvent->SetPropsWithOneCall();
                pEvent->Commit();
            }
        }
        else if (api == API_WmiSetObjectPropWmiCommitObject)
        {
            dwBegin = GetTickCount();

            for (int i = 0; i < nEvents; i++)
            {
                pEvent->SetPropsWithManyCalls();
                pEvent->Commit();
            }
        }
    }


    // Now figure out the stats.
    DWORD   dwEnd = GetTickCount();
    CString strTemp;

    // Make sure the difference isn't 0.
    if (dwEnd == dwBegin)
        dwEnd++;

    // Seconds elapsed
    strTemp.Format(_T("%.2f"), (double) (dwEnd - dwBegin) / 1000.0);
    SetDlgItemText(IDS_TIME, strTemp);

    // Events per second
    strTemp.Format(_T("%.2f"), 
        (double) nEvents / ((double) (dwEnd - dwBegin) / 1000.0));
    SetDlgItemText(IDS_PER_SECOND, strTemp);
}

void CTestDlg::AddStatus(LPCTSTR szMsg)
{
    ::SendMessage(m_hwndStatus, EM_SETSEL, -1, -1);
    ::SendMessage(m_hwndStatus, EM_REPLACESEL, FALSE, (LPARAM) szMsg);
}

HRESULT WINAPI CTestDlg::EventSourceCallback(
    HANDLE hSource, 
    EVENT_SOURCE_MSG msg, 
    LPVOID pUser, 
    LPVOID pData)
{
    CTestDlg *pThis = (CTestDlg*) pUser;

    switch(msg)
    {
        case ESM_START_SENDING_EVENTS:
            pThis->AddStatus("ESM_START_SENDING_EVENTS\r\n\r\n");
            break;

        case ESM_STOP_SENDING_EVENTS:
            pThis->AddStatus("ESM_STOP_SENDING_EVENTS\r\n\r\n");
            break;

        case ESM_NEW_QUERY:
        {
            ES_NEW_QUERY *pQuery = (ES_NEW_QUERY*) pData;
            CString      strMsg;

            strMsg.Format(
                "ESM_NEW_QUERY: ID %d, %S:%S\r\n\r\n", 
                pQuery->dwID,
                pQuery->szQueryLanguage,
                pQuery->szQuery);
                
            pThis->AddStatus(strMsg);

            break;
        }

        case ESM_CANCEL_QUERY:
        {
            ES_CANCEL_QUERY *pQuery = (ES_CANCEL_QUERY*) pData;
            CString         strMsg;

            strMsg.Format(
                "ESM_CANCEL_QUERY: ID %d\r\n\r\n", 
                pQuery->dwID);

            pThis->AddStatus(strMsg);

            break;
        }

        case ESM_ACCESS_CHECK:
        {
            ES_ACCESS_CHECK *pCheck = (ES_ACCESS_CHECK*) pData;
            CString         strMsg;

            strMsg.Format(
                "ESM_ACCESS_CHECK: %S:%S, pSID = 0x%X\r\n\r\n", 
                pCheck->szQueryLanguage,
                pCheck->szQuery,
                pCheck->pSid);

            pThis->AddStatus(strMsg);

            break;
        }

        default:
            break;
    }

    return S_OK;
}

void CTestDlg::OnDestroy() 
{
	CDialog::OnDestroy();
	
	UpdateData(TRUE);
}

void CTestDlg::OnCopy() 
{
    // Set the ANSI text data.
    CString strQuery;

    GetDlgItemText(IDC_QUERY, strQuery);

    DWORD   dwSize = strQuery.GetLength() + 1;
    HGLOBAL hglob = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, dwSize);

    memcpy(GlobalLock(hglob), (LPCTSTR) strQuery, dwSize);
    GlobalUnlock(hglob);

    ::OpenClipboard(NULL);

    SetClipboardData(CF_TEXT, hglob);

    CloseClipboard();
}

void CTestDlg::OnClear() 
{
    SetDlgItemText(IDC_CALLBACK, "");
}

void CTestDlg::OnConnectionSd() 
{
/*
    CSecDlg dlg;

    if (dlg.DoModal() == IDOK)
        WmiSetConnectionSecurity(g_hConnection, dlg.m_pSD);    
*/
}

void CTestDlg::OnEventSd() 
{
/*
    CSecDlg dlg;

    if (dlg.DoModal() == IDOK)
    {
    	EVENT_TYPE type = (EVENT_TYPE) m_ctlEventTypes.GetCurSel();
        CPropEvent *pEvent = (CPropEvent*) m_pEvents[type];

        WmiSetObjectSecurity(pEvent->m_hEvent, dlg.m_pSD);
    }
*/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\atlcrack.h ===
// WTL Version 3.0
// Copyright (C) 1997-1999 Microsoft Corporation
// All rights reserved.
//
// This file is a part of Windows Template Library.
// The code and information is provided "as-is" without
// warranty of any kind, either expressed or implied.

#ifndef __ATLCRACK_H__
#define __ATLCRACK_H__

#pragma once


// For ATL 3.0, message map using cracked handlers MUST use BEGIN_MSG_MAP_EX
#if !defined(_ATL_TMP_IMPL1) && !defined(_ATL_TMP_IMPL2)

#define BEGIN_MSG_MAP_EX(theClass) \
public: \
	BOOL m_bATL3MsgHandled; \
	/* "handled" management for cracked handlers */ \
	BOOL IsMsgHandled() const \
	{ \
		return m_bATL3MsgHandled; \
	} \
	void SetMsgHandled(BOOL bHandled) \
	{ \
		m_bATL3MsgHandled = bHandled; \
	} \
	BOOL ProcessWindowMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult, DWORD dwMsgMapID = 0) \
	{ \
		BOOL bATL3OldMsgHandled = m_bATL3MsgHandled; \
		BOOL bRet = _ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult, dwMsgMapID); \
		m_bATL3MsgHandled = bATL3OldMsgHandled; \
		return bRet; \
	} \
	BOOL _ProcessWindowMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult, DWORD dwMsgMapID) \
	{ \
		BOOL bHandled = TRUE; \
		hWnd; \
		uMsg; \
		wParam; \
		lParam; \
		lResult; \
		bHandled; \
		switch(dwMsgMapID) \
		{ \
		case 0:

#endif //!defined(_ATL_TMP_IMPL1) && !defined(_ATL_TMP_IMPL2)


///////////////////////////////////////////////////////////////////////////////
// Standard Windows message macros

#define MSG_WM_CREATE(func) \
	if (uMsg == WM_CREATE) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((LPCREATESTRUCT)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_INITDIALOG(func) \
	if (uMsg == WM_INITDIALOG) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((HWND)wParam, lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_COPYDATA(func) \
	if (uMsg == WM_COPYDATA) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((HWND)wParam, (PCOPYDATASTRUCT)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_DESTROY(func) \
	if (uMsg == WM_DESTROY) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_MOVE(func) \
	if (uMsg == WM_MOVE) \
	{ \
		SetMsgHandled(TRUE); \
		func(CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SIZE(func) \
	if (uMsg == WM_SIZE) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CSize(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_ACTIVATE(func) \
	if (uMsg == WM_ACTIVATE) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)LOWORD(wParam), (BOOL)HIWORD(wParam), (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SETFOCUS(func) \
	if (uMsg == WM_SETFOCUS) \
	{ \
		SetMsgHandled(TRUE); \
		func((HWND)wParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_KILLFOCUS(func) \
	if (uMsg == WM_KILLFOCUS) \
	{ \
		SetMsgHandled(TRUE); \
		func((HWND)wParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_ENABLE(func) \
	if (uMsg == WM_ENABLE) \
	{ \
		SetMsgHandled(TRUE); \
		func((BOOL)wParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_PAINT(func) \
	if (uMsg == WM_PAINT) \
	{ \
		SetMsgHandled(TRUE); \
		func((HDC)wParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_CLOSE(func) \
	if (uMsg == WM_CLOSE) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_QUERYENDSESSION(func) \
	if (uMsg == WM_QUERYENDSESSION) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((UINT)wParam, (UINT)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_QUERYOPEN(func) \
	if (uMsg == WM_QUERYOPEN) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func(); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_ERASEBKGND(func) \
	if (uMsg == WM_ERASEBKGND) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((HDC)wParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SYSCOLORCHANGE(func) \
	if (uMsg == WM_SYSCOLORCHANGE) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_ENDSESSION(func) \
	if (uMsg == WM_ENDSESSION) \
	{ \
		SetMsgHandled(TRUE); \
		func((BOOL)wParam, (UINT)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SHOWWINDOW(func) \
	if (uMsg == WM_SHOWWINDOW) \
	{ \
		SetMsgHandled(TRUE); \
		func((BOOL)wParam, (int)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_CTLCOLOREDIT(func) \
	if (uMsg == WM_CTLCOLOREDIT) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((HDC)wParam, (HWND)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_CTLCOLORLISTBOX(func) \
	if (uMsg == WM_CTLCOLORLISTBOX) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((HDC)wParam, (HWND)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_CTLCOLORBTN(func) \
	if (uMsg == WM_CTLCOLORBTN) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((HDC)wParam, (HWND)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_CTLCOLORDLG(func) \
	if (uMsg == WM_CTLCOLORDLG) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((HDC)wParam, (HWND)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_CTLCOLORSCROLLBAR(func) \
	if (uMsg == WM_CTLCOLORSCROLLBAR) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((HDC)wParam, (HWND)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_CTLCOLORSTATIC(func) \
	if (uMsg == WM_CTLCOLORSTATIC) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((HDC)wParam, (HWND)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SETTINGCHANGE(func) \
	if (uMsg == WM_SETTINGCHANGE) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, (LPCTSTR)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_DEVMODECHANGE(func) \
	if (uMsg == WM_DEVMODECHANGE) \
	{ \
		SetMsgHandled(TRUE); \
		func((LPCTSTR)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_ACTIVATEAPP(func) \
	if (uMsg == WM_ACTIVATEAPP) \
	{ \
		SetMsgHandled(TRUE); \
		func((BOOL)wParam, (DWORD)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_FONTCHANGE(func) \
	if (uMsg == WM_FONTCHANGE) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_TIMECHANGE(func) \
	if (uMsg == WM_TIMECHANGE) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_CANCELMODE(func) \
	if (uMsg == WM_CANCELMODE) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SETCURSOR(func) \
	if (uMsg == WM_SETCURSOR) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((HWND)wParam, (UINT)LOWORD(lParam), (UINT)HIWORD(lParam)); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_MOUSEACTIVATE(func) \
	if (uMsg == WM_MOUSEACTIVATE) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((HWND)wParam, (UINT)LOWORD(lParam), (UINT)HIWORD(lParam)); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_CHILDACTIVATE(func) \
	if (uMsg == WM_CHILDACTIVATE) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_GETMINMAXINFO(func) \
	if (uMsg == WM_GETMINMAXINFO) \
	{ \
		SetMsgHandled(TRUE); \
		func((LPMINMAXINFO)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_ICONERASEBKGND(func) \
	if (uMsg == WM_ICONERASEBKGND) \
	{ \
		SetMsgHandled(TRUE); \
		func((HDC)wParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SPOOLERSTATUS(func) \
	if (uMsg == WM_SPOOLERSTATUS) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, (UINT)LOWORD(lParam)); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_DRAWITEM(func) \
	if (uMsg == WM_DRAWITEM) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, (LPDRAWITEMSTRUCT)lParam); \
		lResult = TRUE; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_MEASUREITEM(func) \
	if (uMsg == WM_MEASUREITEM) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, (LPMEASUREITEMSTRUCT)lParam); \
		lResult = TRUE; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_DELETEITEM(func) \
	if (uMsg == WM_DELETEITEM) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, (LPDELETEITEMSTRUCT)lParam); \
		lResult = TRUE; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_CHARTOITEM(func) \
	if (uMsg == WM_CHARTOITEM) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((UINT)LOWORD(wParam), (UINT)HIWORD(wParam), (HWND)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_VKEYTOITEM(func) \
	if (uMsg == WM_VKEYTOITEM) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((UINT)LOWORD(wParam), (UINT)HIWORD(wParam), (HWND)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_QUERYDRAGICON(func) \
	if (uMsg == WM_QUERYDRAGICON) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func(); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_COMPAREITEM(func) \
	if (uMsg == WM_COMPAREITEM) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((UINT)wParam, (LPCOMPAREITEMSTRUCT)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_COMPACTING(func) \
	if (uMsg == WM_COMPACTING) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NCCREATE(func) \
	if (uMsg == WM_NCCREATE) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((LPCREATESTRUCT)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NCDESTROY(func) \
	if (uMsg == WM_NCDESTROY) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NCCALCSIZE(func) \
	if (uMsg == WM_NCCALCSIZE) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func((BOOL)wParam, lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NCHITTEST(func) \
	if (uMsg == WM_NCHITTEST) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func(CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NCPAINT(func) \
	if (uMsg == WM_NCPAINT) \
	{ \
		SetMsgHandled(TRUE); \
		func((HRGN)wParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NCACTIVATE(func) \
	if (uMsg == WM_NCACTIVATE) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((BOOL)wParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_GETDLGCODE(func) \
	if (uMsg == WM_GETDLGCODE) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((LPMSG)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NCMOUSEMOVE(func) \
	if (uMsg == WM_NCMOUSEMOVE) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NCLBUTTONDOWN(func) \
	if (uMsg == WM_NCLBUTTONDOWN) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NCLBUTTONUP(func) \
	if (uMsg == WM_NCLBUTTONUP) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NCLBUTTONDBLCLK(func) \
	if (uMsg == WM_NCLBUTTONDBLCLK) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NCRBUTTONDOWN(func) \
	if (uMsg == WM_NCRBUTTONDOWN) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NCRBUTTONUP(func) \
	if (uMsg == WM_NCRBUTTONUP) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NCRBUTTONDBLCLK(func) \
	if (uMsg == WM_NCRBUTTONDBLCLK) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NCMBUTTONDOWN(func) \
	if (uMsg == WM_NCMBUTTONDOWN) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NCMBUTTONUP(func) \
	if (uMsg == WM_NCMBUTTONUP) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NCMBUTTONDBLCLK(func) \
	if (uMsg == WM_NCMBUTTONDBLCLK) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_KEYDOWN(func) \
	if (uMsg == WM_KEYDOWN) \
	{ \
		SetMsgHandled(TRUE); \
		func((TCHAR)wParam, (UINT)lParam & 0xFFFF, (UINT)((lParam & 0xFFFF0000) >> 16)); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_KEYUP(func) \
	if (uMsg == WM_KEYUP) \
	{ \
		SetMsgHandled(TRUE); \
		func((TCHAR)wParam, (UINT)lParam & 0xFFFF, (UINT)((lParam & 0xFFFF0000) >> 16)); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_CHAR(func) \
	if (uMsg == WM_CHAR) \
	{ \
		SetMsgHandled(TRUE); \
		func((TCHAR)wParam, (UINT)lParam & 0xFFFF, (UINT)((lParam & 0xFFFF0000) >> 16)); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_DEADCHAR(func) \
	if (uMsg == WM_DEADCHAR) \
	{ \
		SetMsgHandled(TRUE); \
		func((TCHAR)wParam, (UINT)lParam & 0xFFFF, (UINT)((lParam & 0xFFFF0000) >> 16)); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SYSKEYDOWN(func) \
	if (uMsg == WM_SYSKEYDOWN) \
	{ \
		SetMsgHandled(TRUE); \
		func((TCHAR)wParam, (UINT)lParam & 0xFFFF, (UINT)((lParam & 0xFFFF0000) >> 16)); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SYSKEYUP(func) \
	if (uMsg == WM_SYSKEYUP) \
	{ \
		SetMsgHandled(TRUE); \
		func((TCHAR)wParam, (UINT)lParam & 0xFFFF, (UINT)((lParam & 0xFFFF0000) >> 16)); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SYSCHAR(func) \
	if (uMsg == WM_SYSCHAR) \
	{ \
		SetMsgHandled(TRUE); \
		func((TCHAR)wParam, (UINT)lParam & 0xFFFF, (UINT)((lParam & 0xFFFF0000) >> 16)); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SYSDEADCHAR(func) \
	if (uMsg == WM_SYSDEADCHAR) \
	{ \
		SetMsgHandled(TRUE); \
		func((TCHAR)wParam, (UINT)lParam & 0xFFFF, (UINT)((lParam & 0xFFFF0000) >> 16)); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SYSCOMMAND(func) \
	if (uMsg == WM_SYSCOMMAND) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_TCARD(func) \
	if (uMsg == WM_TCARD) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, (DWORD)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_TIMER(func) \
	if (uMsg == WM_TIMER) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, (TIMERPROC*)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_HSCROLL(func) \
	if (uMsg == WM_HSCROLL) \
	{ \
		SetMsgHandled(TRUE); \
		func((int)LOWORD(wParam), (short)HIWORD(wParam), (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_VSCROLL(func) \
	if (uMsg == WM_VSCROLL) \
	{ \
		SetMsgHandled(TRUE); \
		func((int)LOWORD(wParam), (short)HIWORD(wParam), (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_INITMENU(func) \
	if (uMsg == WM_INITMENU) \
	{ \
		SetMsgHandled(TRUE); \
		func((HMENU)wParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_INITMENUPOPUP(func) \
	if (uMsg == WM_INITMENUPOPUP) \
	{ \
		SetMsgHandled(TRUE); \
		func((HMENU)wParam, (UINT)LOWORD(lParam), (BOOL)HIWORD(lParam)); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_MENUSELECT(func) \
	if (uMsg == WM_MENUSELECT) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)LOWORD(wParam), (UINT)HIWORD(wParam), (HMENU)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_MENUCHAR(func) \
	if (uMsg == WM_MENUCHAR) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func((TCHAR)LOWORD(wParam), (UINT)HIWORD(wParam), (HMENU)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NOTIFY(func) \
	if (uMsg == WM_NOTIFY) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func((int)wParam, (LPNMHDR)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_ENTERIDLE(func) \
	if (uMsg == WM_ENTERIDLE) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_MOUSEMOVE(func) \
	if (uMsg == WM_MOUSEMOVE) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_MOUSEWHEEL(func) \
	if (uMsg == WM_MOUSEWHEEL) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((UINT)LOWORD(wParam), (short)HIWORD(wParam), CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_LBUTTONDOWN(func) \
	if (uMsg == WM_LBUTTONDOWN) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_LBUTTONUP(func) \
	if (uMsg == WM_LBUTTONUP) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_LBUTTONDBLCLK(func) \
	if (uMsg == WM_LBUTTONDBLCLK) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_RBUTTONDOWN(func) \
	if (uMsg == WM_RBUTTONDOWN) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_RBUTTONUP(func) \
	if (uMsg == WM_RBUTTONUP) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_RBUTTONDBLCLK(func) \
	if (uMsg == WM_RBUTTONDBLCLK) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_MBUTTONDOWN(func) \
	if (uMsg == WM_MBUTTONDOWN) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_MBUTTONUP(func) \
	if (uMsg == WM_MBUTTONUP) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_MBUTTONDBLCLK(func) \
	if (uMsg == WM_MBUTTONDBLCLK) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_PARENTNOTIFY(func) \
	if (uMsg == WM_PARENTNOTIFY) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)LOWORD(wParam), (UINT)HIWORD(wParam), lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_MDIACTIVATE(func) \
	if (uMsg == WM_MDIACTIVATE) \
	{ \
		SetMsgHandled(TRUE); \
		func((HWND)wParam, (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_RENDERFORMAT(func) \
	if (uMsg == WM_RENDERFORMAT) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_RENDERALLFORMATS(func) \
	if (uMsg == WM_RENDERALLFORMATS) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_DESTROYCLIPBOARD(func) \
	if (uMsg == WM_DESTROYCLIPBOARD) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_DRAWCLIPBOARD(func) \
	if (uMsg == WM_DRAWCLIPBOARD) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_PAINTCLIPBOARD(func) \
	if (uMsg == WM_PAINTCLIPBOARD) \
	{ \
		SetMsgHandled(TRUE); \
		func((HWND)wParam, (const LPPAINTSTRUCT)::GlobalLock((HGLOBAL)lParam)); \
		::GlobalUnlock((HGLOBAL)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_VSCROLLCLIPBOARD(func) \
	if (uMsg == WM_VSCROLLCLIPBOARD) \
	{ \
		SetMsgHandled(TRUE); \
		func((HWND)wParam, (UINT)LOWORD(lParam), (UINT)HIWORD(lParam)); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_CONTEXTMENU(func) \
	if (uMsg == WM_CONTEXTMENU) \
	{ \
		SetMsgHandled(TRUE); \
		func((HWND)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SIZECLIPBOARD(func) \
	if (uMsg == WM_SIZECLIPBOARD) \
	{ \
		SetMsgHandled(TRUE); \
		func((HWND)wParam, (const LPRECT)::GlobalLock((HGLOBAL)lParam)); \
		::GlobalUnlock((HGLOBAL)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_ASKCBFORMATNAME(func) \
	if (uMsg == WM_ASKCBFORMATNAME) \
	{ \
		SetMsgHandled(TRUE); \
		func((DWORD)wParam, (LPTSTR)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_CHANGECBCHAIN(func) \
	if (uMsg == WM_CHANGECBCHAIN) \
	{ \
		SetMsgHandled(TRUE); \
		func((HWND)wParam, (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_HSCROLLCLIPBOARD(func) \
	if (uMsg == WM_HSCROLLCLIPBOARD) \
	{ \
		SetMsgHandled(TRUE); \
		func((HWND)wParam, (UINT)LOWORD(lParam), (UINT)HIWORD(lParam)); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_QUERYNEWPALETTE(func) \
	if (uMsg == WM_QUERYNEWPALETTE) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func(); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_PALETTECHANGED(func) \
	if (uMsg == WM_PALETTECHANGED) \
	{ \
		SetMsgHandled(TRUE); \
		func((HWND)wParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_PALETTEISCHANGING(func) \
	if (uMsg == WM_PALETTEISCHANGING) \
	{ \
		SetMsgHandled(TRUE); \
		func((HWND)wParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_DROPFILES(func) \
	if (uMsg == WM_DROPFILES) \
	{ \
		SetMsgHandled(TRUE); \
		func((HDROP)wParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_WINDOWPOSCHANGING(func) \
	if (uMsg == WM_WINDOWPOSCHANGING) \
	{ \
		SetMsgHandled(TRUE); \
		func((LPWINDOWPOS)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_WINDOWPOSCHANGED(func) \
	if (uMsg == WM_WINDOWPOSCHANGED) \
	{ \
		SetMsgHandled(TRUE); \
		func((LPWINDOWPOS)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_EXITMENULOOP(func) \
	if (uMsg == WM_EXITMENULOOP) \
	{ \
		SetMsgHandled(TRUE); \
		func((BOOL)wParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_ENTERMENULOOP(func) \
	if (uMsg == WM_ENTERMENULOOP) \
	{ \
		SetMsgHandled(TRUE); \
		func((BOOL)wParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_STYLECHANGED(func) \
	if (uMsg == WM_STYLECHANGED) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, (LPSTYLESTRUCT)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_STYLECHANGING(func) \
	if (uMsg == WM_STYLECHANGING) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, (LPSTYLESTRUCT)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SIZING(func) \
	if (uMsg == WM_SIZING) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, (LPRECT)lParam); \
		lResult = TRUE; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_MOVING(func) \
	if (uMsg == WM_MOVING) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, (LPRECT)lParam); \
		lResult = TRUE; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_CAPTURECHANGED(func) \
	if (uMsg == WM_CAPTURECHANGED) \
	{ \
		SetMsgHandled(TRUE); \
		func((HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_DEVICECHANGE(func) \
	if (uMsg == WM_DEVICECHANGE) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((UINT)wParam, (DWORD)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#define MSG_WM_COMMAND(func) \
	if (uMsg == WM_COMMAND) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)HIWORD(wParam), (int)LOWORD(wParam), (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#define MSG_WM_DISPLAYCHANGE(func) \
	if (uMsg == WM_DISPLAYCHANGE) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CSize(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_ENTERSIZEMOVE(func) \
	if (uMsg == WM_ENTERSIZEMOVE) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_EXITSIZEMOVE(func) \
	if (uMsg == WM_EXITSIZEMOVE) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_GETFONT(func) \
	if (uMsg == WM_GETFONT) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func(); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_GETHOTKEY(func) \
	if (uMsg == WM_GETHOTKEY) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func(); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_GETICON(func) \
	if (uMsg == WM_GETICON) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((UINT)wParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_GETTEXT(func) \
	if (uMsg == WM_GETTEXT) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((int)wParam, (LPTSTR)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_GETTEXTLENGTH(func) \
	if (uMsg == WM_GETTEXTLENGTH) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func(); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_HELP(func) \
	if (uMsg == WM_HELP) \
	{ \
		SetMsgHandled(TRUE); \
		func((LPHELPINFO)lParam); \
		lResult = TRUE; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_HOTKEY(func) \
	if (uMsg == WM_HOTKEY) \
	{ \
		SetMsgHandled(TRUE); \
		func((int)wParam, (UINT)LOWORD(lParam), (UINT)HIWORD(lParam)); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_INPUTLANGCHANGE(func) \
	if (uMsg == WM_INPUTLANGCHANGE) \
	{ \
		SetMsgHandled(TRUE); \
		func((DWORD)wParam, (HKL)lParam); \
		lResult = TRUE; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_INPUTLANGCHANGEREQUEST(func) \
	if (uMsg == WM_INPUTLANGCHANGEREQUEST) \
	{ \
		SetMsgHandled(TRUE); \
		func((BOOL)wParam, (HKL)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NEXTDLGCTL(func) \
	if (uMsg == WM_NEXTDLGCTL) \
	{ \
		SetMsgHandled(TRUE); \
		func((BOOL)LOWORD(lParam), wParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NEXTMENU(func) \
	if (uMsg == WM_NEXTMENU) \
	{ \
		SetMsgHandled(TRUE); \
		func((int)wParam, (LPMDINEXTMENU)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NOTIFYFORMAT(func) \
	if (uMsg == WM_NOTIFYFORMAT) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((HWND)wParam, (int)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_POWERBROADCAST(func) \
	if (uMsg == WM_POWERBROADCAST) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((DWORD)wParam, (DWORD)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_PRINT(func) \
	if (uMsg == WM_PRINT) \
	{ \
		SetMsgHandled(TRUE); \
		func((HDC)wParam, (UINT)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_PRINTCLIENT(func) \
	if (uMsg == WM_PRINTCLIENT) \
	{ \
		SetMsgHandled(TRUE); \
		func((HDC)wParam, (UINT)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_RASDIALEVENT(func) \
	if (uMsg == WM_RASDIALEVENT) \
	{ \
		SetMsgHandled(TRUE); \
		func((RASCONNSTATE)wParam, (DWORD)lParam); \
		lResult = TRUE; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SETFONT(func) \
	if (uMsg == WM_SETFONT) \
	{ \
		SetMsgHandled(TRUE); \
		func((HFONT)wParam, (BOOL)LOWORD(lParam)); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SETHOTKEY(func) \
	if (uMsg == WM_SETHOTKEY) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((int)LOBYTE(LOWORD(wParam)), (UINT)HIBYTE(LOWORD(wParam))); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SETICON(func) \
	if (uMsg == WM_SETICON) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((UINT)wParam, (HICON)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SETREDRAW(func) \
	if (uMsg == WM_SETREDRAW) \
	{ \
		SetMsgHandled(TRUE); \
		func((BOOL)wParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SETTEXT(func) \
	if (uMsg == WM_SETTEXT) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((LPCTSTR)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_USERCHANGED(func) \
	if (uMsg == WM_USERCHANGED) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}

///////////////////////////////////////////////////////////////////////////////
// New NT4 & NT5 messages

#if(_WIN32_WINNT >= 0x0400)

#define MSG_WM_MOUSEHOVER(func) \
	if (uMsg == WM_MOUSEHOVER) \
	{ \
		SetMsgHandled(TRUE); \
		func(wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#define MSG_WM_MOUSELEAVE(func) \
	if (uMsg == WM_MOUSELEAVE) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#endif /* _WIN32_WINNT >= 0x0400 */

#if(WINVER >= 0x0500)

#define MSG_WM_MENURBUTTONUP(func) \
	if (uMsg == WM_MENURBUTTONUP) \
	{ \
		SetMsgHandled(TRUE); \
		func(wParam, (HMENU)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#define MSG_WM_MENUDRAG(func) \
	if (uMsg == WM_MENUDRAG) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func(wParam, (HMENU)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#define MSG_WM_MENUGETOBJECT(func) \
	if (uMsg == WM_MENUGETOBJECT) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func((PMENUGETOBJECTINFO)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#define MSG_WM_UNINITMENUPOPUP(func) \
	if (uMsg == WM_UNINITMENUPOPUP) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)HIWORD(lParam), (HMENU)wParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#define MSG_WM_MENUCOMMAND(func) \
	if (uMsg == WM_MENUCOMMAND) \
	{ \
		SetMsgHandled(TRUE); \
		func(wParam, (HMENU)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#endif /* WINVER >= 0x0500 */

///////////////////////////////////////////////////////////////////////////////
// ATL defined messages

#define MSG_WM_FORWARDMSG(func) \
	if (uMsg == WM_FORWARDMSG) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((LPMSG)lParam, (DWORD)wParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}

///////////////////////////////////////////////////////////////////////////////
// Dialog specific messages

#define MSG_DM_GETDEFID(func) \
	if (uMsg == DM_GETDEFID) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func(); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_DM_SETDEFID(func) \
	if (uMsg == DM_SETDEFID) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam); \
		lResult = TRUE; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_DM_REPOSITION(func) \
	if (uMsg == DM_REPOSITION) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}

///////////////////////////////////////////////////////////////////////////////
// Reflected messages

#define MSG_OCM_COMMAND(func) \
	if (uMsg == OCM_COMMAND) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)HIWORD(wParam), (int)LOWORD(wParam), (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_OCM_NOTIFY(func) \
	if (uMsg == OCM_NOTIFY) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func((int)wParam, (LPNMHDR)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_OCM_PARENTNOTIFY(func) \
	if (uMsg == OCM_PARENTNOTIFY) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)LOWORD(wParam), (UINT)HIWORD(wParam), lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_OCM_DRAWITEM(func) \
	if (uMsg == OCM_DRAWITEM) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, (LPDRAWITEMSTRUCT)lParam); \
		lResult = TRUE; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_OCM_MEASUREITEM(func) \
	if (uMsg == OCM_MEASUREITEM) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, (LPMEASUREITEMSTRUCT)lParam); \
		lResult = TRUE; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_OCM_COMPAREITEM(func) \
	if (uMsg == OCM_COMPAREITEM) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((UINT)wParam, (LPCOMPAREITEMSTRUCT)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_OCM_DELETEITEM(func) \
	if (uMsg == OCM_DELETEITEM) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, (LPDELETEITEMSTRUCT)lParam); \
		lResult = TRUE; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_OCM_VKEYTOITEM(func) \
	if (uMsg == OCM_VKEYTOITEM) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((UINT)LOWORD(wParam), (UINT)HIWORD(wParam), (HWND)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_OCM_CHARTOITEM(func) \
	if (uMsg == OCM_CHARTOITEM) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((UINT)LOWORD(wParam), (UINT)HIWORD(wParam), (HWND)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_OCM_HSCROLL(func) \
	if (uMsg == OCM_HSCROLL) \
	{ \
		SetMsgHandled(TRUE); \
		func((int)LOWORD(wParam), (short)HIWORD(wParam), (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_OCM_VSCROLL(func) \
	if (uMsg == OCM_VSCROLL) \
	{ \
		SetMsgHandled(TRUE); \
		func((int)LOWORD(wParam), (short)HIWORD(wParam), (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_OCM_CTLCOLOREDIT(func) \
	if (uMsg == OCM_CTLCOLOREDIT) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((HDC)wParam, (HWND)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_OCM_CTLCOLORLISTBOX(func) \
	if (uMsg == OCM_CTLCOLORLISTBOX) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((HDC)wParam, (HWND)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_OCM_CTLCOLORBTN(func) \
	if (uMsg == OCM_CTLCOLORBTN) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((HDC)wParam, (HWND)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_OCM_CTLCOLORDLG(func) \
	if (uMsg == OCM_CTLCOLORDLG) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((HDC)wParam, (HWND)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_OCM_CTLCOLORSCROLLBAR(func) \
	if (uMsg == OCM_CTLCOLORSCROLLBAR) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((HDC)wParam, (HWND)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_OCM_CTLCOLORSTATIC(func) \
	if (uMsg == OCM_CTLCOLORSTATIC) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((HDC)wParam, (HWND)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}

///////////////////////////////////////////////////////////////////////////////
// Edit specific messages

#define MSG_WM_CLEAR(func) \
	if (uMsg == WM_CLEAR) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_COPY(func) \
	if (uMsg == WM_COPY) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_CUT(func) \
	if (uMsg == WM_CUT) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_PASTE(func) \
	if (uMsg == WM_PASTE) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_UNDO(func) \
	if (uMsg == WM_UNDO) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}

///////////////////////////////////////////////////////////////////////////////
// Generic message handlers

#define MESSAGE_HANDLER_EX(msg, func) \
	if(uMsg == msg) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func(uMsg, wParam, lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#define MESSAGE_RANGE_HANDLER_EX(msgFirst, msgLast, func) \
	if(uMsg >= msgFirst && uMsg <= msgLast) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func(uMsg, wParam, lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}

///////////////////////////////////////////////////////////////////////////////
// Commands and notifications

#define COMMAND_HANDLER_EX(id, code, func) \
	if (uMsg == WM_COMMAND && code == HIWORD(wParam) && id == LOWORD(wParam)) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)HIWORD(wParam), (int)LOWORD(wParam), (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define COMMAND_ID_HANDLER_EX(id, func) \
	if (uMsg == WM_COMMAND && id == LOWORD(wParam)) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)HIWORD(wParam), (int)LOWORD(wParam), (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define COMMAND_CODE_HANDLER_EX(code, func) \
	if (uMsg == WM_COMMAND && code == HIWORD(wParam)) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)HIWORD(wParam), (int)LOWORD(wParam), (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define NOTIFY_HANDLER_EX(id, cd, func) \
	if (uMsg == WM_NOTIFY && cd == ((LPNMHDR)lParam)->code && id == ((LPNMHDR)lParam)->idFrom) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func((LPNMHDR)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define NOTIFY_ID_HANDLER_EX(id, func) \
	if (uMsg == WM_NOTIFY && id == ((LPNMHDR)lParam)->idFrom) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func((LPNMHDR)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define NOTIFY_CODE_HANDLER_EX(cd, func) \
	if (uMsg == WM_NOTIFY && cd == ((LPNMHDR)lParam)->code) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func((LPNMHDR)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#define COMMAND_RANGE_HANDLER_EX(idFirst, idLast, func) \
	if(uMsg == WM_COMMAND && LOWORD(wParam) >= idFirst  && LOWORD(wParam) <= idLast) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)HIWORD(wParam), (int)LOWORD(wParam), (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define COMMAND_RANGE_CODE_HANDLER_EX(idFirst, idLast, code, func) \
	if(uMsg == WM_COMMAND && code == HIWORD(wParam) && LOWORD(wParam) >= idFirst  && LOWORD(wParam) <= idLast) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)HIWORD(wParam), (int)LOWORD(wParam), (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define NOTIFY_RANGE_HANDLER_EX(idFirst, idLast, func) \
	if(uMsg == WM_NOTIFY && ((LPNMHDR)lParam)->idFrom >= idFirst && ((LPNMHDR)lParam)->idFrom <= idLast) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func((LPNMHDR)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define NOTIFY_RANGE_CODE_HANDLER_EX(idFirst, idLast, cd, func) \
	if(uMsg == WM_NOTIFY && cd == ((LPNMHDR)lParam)->code && ((LPNMHDR)lParam)->idFrom >= idFirst && ((LPNMHDR)lParam)->idFrom <= idLast) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func((LPNMHDR)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#define REFLECTED_COMMAND_HANDLER_EX(id, code, func) \
	if (uMsg == OCM_COMMAND && code == HIWORD(wParam) && id == LOWORD(wParam)) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)HIWORD(wParam), (int)LOWORD(wParam), (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define REFLECTED_COMMAND_ID_HANDLER_EX(id, func) \
	if (uMsg == OCM_COMMAND && id == LOWORD(wParam)) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)HIWORD(wParam), (int)LOWORD(wParam), (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define REFLECTED_COMMAND_CODE_HANDLER_EX(code, func) \
	if (uMsg == OCM_COMMAND && code == HIWORD(wParam)) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)HIWORD(wParam), (int)LOWORD(wParam), (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define REFLECTED_NOTIFY_HANDLER_EX(id, cd, func) \
	if (uMsg == OCM_NOTIFY && cd == ((LPNMHDR)lParam)->code && id == ((LPNMHDR)lParam)->idFrom) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func((LPNMHDR)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define REFLECTED_NOTIFY_ID_HANDLER_EX(id, func) \
	if (uMsg == OCM_NOTIFY && id == ((LPNMHDR)lParam)->idFrom) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func((LPNMHDR)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define REFLECTED_NOTIFY_CODE_HANDLER_EX(cd, func) \
	if (uMsg == OCM_NOTIFY && cd == ((LPNMHDR)lParam)->code) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func((LPNMHDR)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#define REFLECTED_COMMAND_RANGE_HANDLER_EX(idFirst, idLast, func) \
	if(uMsg == OCM_COMMAND && LOWORD(wParam) >= idFirst  && LOWORD(wParam) <= idLast) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)HIWORD(wParam), (int)LOWORD(wParam), (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#define REFLECTED_COMMAND_RANGE_CODE_HANDLER_EX(idFirst, idLast, code, func) \
	if(uMsg == OCM_COMMAND && code == HIWORD(wParam) && LOWORD(wParam) >= idFirst  && LOWORD(wParam) <= idLast) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)HIWORD(wParam), (int)LOWORD(wParam), (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define REFLECTED_NOTIFY_RANGE_HANDLER_EX(idFirst, idLast, func) \
	if(uMsg == OCM_NOTIFY && ((LPNMHDR)lParam)->idFrom >= idFirst && ((LPNMHDR)lParam)->idFrom <= idLast) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func((LPNMHDR)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define REFLECTED_NOTIFY_RANGE_CODE_HANDLER_EX(idFirst, idLast, cd, func) \
	if(uMsg == OCM_NOTIFY && cd == ((LPNMHDR)lParam)->code && ((LPNMHDR)lParam)->idFrom >= idFirst && ((LPNMHDR)lParam)->idFrom <= idLast) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func((LPNMHDR)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#endif //__ATLCRACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\atlapp.h ===
// WTL Version 3.0
// Copyright (C) 1997-1999 Microsoft Corporation
// All rights reserved.
//
// This file is a part of Windows Template Library.
// The code and information is provided "as-is" without
// warranty of any kind, either expressed or implied.

#ifndef __ATLAPP_H__
#define __ATLAPP_H__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLBASE_H__
	#error atlapp.h requires atlbase.h to be included first
#endif

#if (WINVER < 0x0400)
	#error WTL requires Windows version 4.0 or higher
#endif


#include <limits.h>
#if !defined(_ATL_MIN_CRT) & defined(_MT)
#include <process.h>	// for _beginthreadex, _endthreadex
#endif

#include <commctrl.h>
#pragma comment(lib, "comctl32.lib")

#include <atlres.h>


// WTL version number
#define _WTL_VER	0x0300


// This is to support using original VC++ 6.0 headers with WTL
#ifndef _ATL_NO_OLD_HEADERS_WIN64
#if !defined(_WIN64) && !defined(_ATL_TMP_IMPL2)

  #ifndef GetWindowLongPtr
    #define GetWindowLongPtrA   GetWindowLongA
    #define GetWindowLongPtrW   GetWindowLongW
    #ifdef UNICODE
      #define GetWindowLongPtr  GetWindowLongPtrW
    #else
      #define GetWindowLongPtr  GetWindowLongPtrA
    #endif // !UNICODE
  #endif // !GetWindowLongPtr

  #ifndef SetWindowLongPtr
    #define SetWindowLongPtrA   SetWindowLongA
    #define SetWindowLongPtrW   SetWindowLongW
    #ifdef UNICODE
      #define SetWindowLongPtr  SetWindowLongPtrW
    #else
      #define SetWindowLongPtr  SetWindowLongPtrA
    #endif // !UNICODE
  #endif // !SetWindowLongPtr

  #ifndef GWLP_WNDPROC
    #define GWLP_WNDPROC        (-4)
  #endif
  #ifndef GWLP_HINSTANCE
    #define GWLP_HINSTANCE      (-6)
  #endif
  #ifndef GWLP_HWNDPARENT
    #define GWLP_HWNDPARENT     (-8)
  #endif
  #ifndef GWLP_USERDATA
    #define GWLP_USERDATA       (-21)
  #endif
  #ifndef GWLP_ID
    #define GWLP_ID             (-12)
  #endif

  typedef long LONG_PTR;
  typedef unsigned long ULONG_PTR;
  typedef ULONG_PTR DWORD_PTR;

  #ifndef HandleToUlong
#define HandleToUlong( h ) ((ULONG)(ULONG_PTR)(h) )
  #endif
  #ifndef HandleToLong
#define HandleToLong( h ) ((LONG)(LONG_PTR) (h) )
  #endif
  #ifndef LongToHandle
#define LongToHandle( h) ((HANDLE)(LONG_PTR) (h))
  #endif
  #ifndef PtrToUlong
#define PtrToUlong( p ) ((ULONG)(ULONG_PTR) (p) )
  #endif
  #ifndef PtrToLong
#define PtrToLong( p ) ((LONG)(LONG_PTR) (p) )
  #endif
  #ifndef PtrToUint
#define PtrToUint( p ) ((UINT)(UINT_PTR) (p) )
  #endif
  #ifndef PtrToInt
#define PtrToInt( p ) ((INT)(INT_PTR) (p) )
  #endif
  #ifndef PtrToUshort
#define PtrToUshort( p ) ((unsigned short)(ULONG_PTR)(p) )
  #endif
  #ifndef PtrToShort
#define PtrToShort( p ) ((short)(LONG_PTR)(p) )
  #endif
  #ifndef IntToPtr
#define IntToPtr( i )    ((VOID *)(INT_PTR)((int)i))
  #endif
  #ifndef UIntToPtr
#define UIntToPtr( ui )  ((VOID *)(UINT_PTR)((unsigned int)ui))
  #endif
  #ifndef LongToPtr
#define LongToPtr( l )   ((VOID *)(LONG_PTR)((long)l))
  #endif
  #ifndef ULongToPtr
#define ULongToPtr( ul )  ((VOID *)(ULONG_PTR)((unsigned long)ul))
  #endif

#endif //!defined(_WIN64) && !defined(_ATL_TMP_IMPL2)
#endif //!_ATL_NO_OLD_HEADERS_WIN64


namespace WTL
{

enum wtlTraceFlags
{
	atlTraceUI = 0x10000000
};

// Windows version helper
inline bool AtlIsOldWindows()
{
	OSVERSIONINFO ovi;
	ovi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	BOOL bRet = ::GetVersionEx(&ovi);
	return (!bRet || !((ovi.dwMajorVersion >= 5) || (ovi.dwMajorVersion == 4 && ovi.dwMinorVersion >= 90)));
}

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

class CMessageFilter;
class CIdleHandler;
class CMessageLoop;
class CAppModule;
class CServerAppModule;

#ifndef _ATL_TMP_IMPL2
class _U_RECT;
class _U_MENUorID;
class _U_STRINGorID;
#endif //!_ATL_TMP_IMPL2


/////////////////////////////////////////////////////////////////////////////
// CMessageFilter - Interface for message filter support

class CMessageFilter
{
public:
	virtual BOOL PreTranslateMessage(MSG* pMsg) = 0;
};


/////////////////////////////////////////////////////////////////////////////
// CIdleHandler - Interface for idle processing

class CIdleHandler
{
public:
	virtual BOOL OnIdle() = 0;
};

#ifndef _ATL_NO_OLD_NAMES
// for compatilibility with old names only
typedef CIdleHandler	CUpdateUIObject;
#define DoUpdate	OnIdle
#endif //!_ATL_NO_OLD_NAMES


/////////////////////////////////////////////////////////////////////////////
// CMessageLoop - message loop implementation

class CMessageLoop
{
public:
	CSimpleArray<CMessageFilter*> m_aMsgFilter;
	CSimpleArray<CIdleHandler*> m_aIdleHandler;
	MSG m_msg;

// Message filter operations
	BOOL AddMessageFilter(CMessageFilter* pMessageFilter)
	{
		return m_aMsgFilter.Add(pMessageFilter);
	}
	BOOL RemoveMessageFilter(CMessageFilter* pMessageFilter)
	{
		return m_aMsgFilter.Remove(pMessageFilter);
	}
// Idle handler operations
	BOOL AddIdleHandler(CIdleHandler* pIdleHandler)
	{
		return m_aIdleHandler.Add(pIdleHandler);
	}
	BOOL RemoveIdleHandler(CIdleHandler* pIdleHandler)
	{
		return m_aIdleHandler.Remove(pIdleHandler);
	}
#ifndef _ATL_NO_OLD_NAMES
	// for compatilibility with old names only
	BOOL AddUpdateUI(CIdleHandler* pIdleHandler)
	{
		ATLTRACE2(atlTraceUI, 0, "CUpdateUIObject and AddUpdateUI are deprecated. Please change your code to use CIdleHandler and OnIdle\n");
		return AddIdleHandler(pIdleHandler);
	}
	BOOL RemoveUpdateUI(CIdleHandler* pIdleHandler)
	{
		ATLTRACE2(atlTraceUI, 0, "CUpdateUIObject and RemoveUpdateUI are deprecated. Please change your code to use CIdleHandler and OnIdle\n");
		return RemoveIdleHandler(pIdleHandler);
	}
#endif //!_ATL_NO_OLD_NAMES
// message loop
	int Run()
	{
		BOOL bDoIdle = TRUE;
		int nIdleCount = 0;
		BOOL bRet;

		for(;;)
		{
			while(!::PeekMessage(&m_msg, NULL, 0, 0, PM_NOREMOVE) && bDoIdle)
			{
				if(!OnIdle(nIdleCount++))
					bDoIdle = FALSE;
			}

			bRet = ::GetMessage(&m_msg, NULL, 0, 0);

			if(bRet == -1)
			{
				ATLTRACE2(atlTraceUI, 0, _T("::GetMessage returned -1 (error)\n"));
				continue;	// error, don't process
			}
			else if(!bRet)
			{
				ATLTRACE2(atlTraceUI, 0, _T("CMessageLoop::Run - exiting\n"));
				break;		// WM_QUIT, exit message loop
			}

			if(!PreTranslateMessage(&m_msg))
			{
				::TranslateMessage(&m_msg);
				::DispatchMessage(&m_msg);
			}

			if(IsIdleMessage(&m_msg))
			{
				bDoIdle = TRUE;
				nIdleCount = 0;
			}
		}

		return (int)m_msg.wParam;
	}

	static BOOL IsIdleMessage(MSG* pMsg)
	{
		// These messages should NOT cause idle processing
		switch(pMsg->message)
		{
		case WM_MOUSEMOVE:
		case WM_NCMOUSEMOVE:
		case WM_PAINT:
		case 0x0118:	// WM_SYSTIMER (caret blink)
			return FALSE;
		}

		return TRUE;
	}

// Overrideables
	// Override to change message filtering
	virtual BOOL PreTranslateMessage(MSG* pMsg)
	{
		// loop backwards
		for(int i = m_aMsgFilter.GetSize() - 1; i >= 0; i--)
		{
			CMessageFilter* pMessageFilter = m_aMsgFilter[i];
			if(pMessageFilter != NULL && pMessageFilter->PreTranslateMessage(pMsg))
				return TRUE;
		}
		return FALSE;	// not translated
	}
	// override to change idle processing
	virtual BOOL OnIdle(int /*nIdleCount*/)
	{
		for(int i = 0; i < m_aIdleHandler.GetSize(); i++)
		{
			CIdleHandler* pIdleHandler = m_aIdleHandler[i];
			if(pIdleHandler != NULL)
				pIdleHandler->OnIdle();
		}
		return FALSE;	// don't continue
	}
};


/////////////////////////////////////////////////////////////////////////////
// CAppModule - module class for an application

class CAppModule : public CComModule
{
public:
	DWORD m_dwMainThreadID;
	CSimpleMap<DWORD, CMessageLoop*>* m_pMsgLoopMap;
	CSimpleArray<HWND>* m_pSettingChangeNotify;

// Overrides of CComModule::Init and Term
	HRESULT Init(_ATL_OBJMAP_ENTRY* pObjMap, HINSTANCE hInstance, const GUID* pLibID = NULL)
	{
		HRESULT hRet = CComModule::Init(pObjMap, hInstance, pLibID);
		if(FAILED(hRet))
			return hRet;

		m_dwMainThreadID = ::GetCurrentThreadId();
		typedef CSimpleMap<DWORD, CMessageLoop*>	mapClass;
		m_pMsgLoopMap = NULL;
		ATLTRY(m_pMsgLoopMap = new mapClass);
		if(m_pMsgLoopMap == NULL)
			return E_OUTOFMEMORY;
		m_pSettingChangeNotify = NULL;

		return hRet;
	}
	void Term()
	{
		if(m_pSettingChangeNotify != NULL && m_pSettingChangeNotify->GetSize() > 0)
		{
			::DestroyWindow((*m_pSettingChangeNotify)[0]);
		}
		delete m_pSettingChangeNotify;
		delete m_pMsgLoopMap;
		CComModule::Term();
	}

// Message loop map methods
	BOOL AddMessageLoop(CMessageLoop* pMsgLoop)
	{
		ATLASSERT(pMsgLoop != NULL);
		ATLASSERT(m_pMsgLoopMap->Lookup(::GetCurrentThreadId()) == NULL);	// not in map yet
		return m_pMsgLoopMap->Add(::GetCurrentThreadId(), pMsgLoop);
	}
	BOOL RemoveMessageLoop()
	{
		return m_pMsgLoopMap->Remove(::GetCurrentThreadId());
	}
	CMessageLoop* GetMessageLoop(DWORD dwThreadID = ::GetCurrentThreadId()) const
	{
		return m_pMsgLoopMap->Lookup(dwThreadID);
	}

// Setting change notify methods
	BOOL AddSettingChangeNotify(HWND hWnd)
	{
		ATLASSERT(::IsWindow(hWnd));
		if(m_pSettingChangeNotify == NULL)
		{
			typedef CSimpleArray<HWND>	notifyClass;
			ATLTRY(m_pSettingChangeNotify = new notifyClass);
			ATLASSERT(m_pSettingChangeNotify != NULL);
			if(m_pSettingChangeNotify == NULL)
				return FALSE;
		}
		if(m_pSettingChangeNotify->GetSize() == 0)
		{
			// init everything
			_ATL_EMPTY_DLGTEMPLATE templ;
			HWND hNtfWnd = ::CreateDialogIndirect(GetModuleInstance(), &templ, NULL, _SettingChangeDlgProc);
			ATLASSERT(::IsWindow(hNtfWnd));
			if(::IsWindow(hNtfWnd))
			{
				::SetWindowLongPtr(hNtfWnd, GWLP_USERDATA, (LONG_PTR)this);
				m_pSettingChangeNotify->Add(hNtfWnd);
			}
		}
		return m_pSettingChangeNotify->Add(hWnd);
	}

	BOOL RemoveSettingChangeNotify(HWND hWnd)
	{
		if(m_pSettingChangeNotify == NULL)
			return FALSE;
		return m_pSettingChangeNotify->Remove(hWnd);
	}

// Implementation - setting change notify dialog template and dialog procedure
	struct _ATL_EMPTY_DLGTEMPLATE : DLGTEMPLATE
	{
		_ATL_EMPTY_DLGTEMPLATE()
		{
			memset(this, 0, sizeof(_ATL_EMPTY_DLGTEMPLATE));
			style = WS_POPUP;
		}
		WORD wMenu, wClass, wTitle;
	};

#ifdef _WIN64
	static INT_PTR CALLBACK _SettingChangeDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
#else
	static BOOL CALLBACK _SettingChangeDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
#endif
	{
		if(uMsg == WM_SETTINGCHANGE)
		{
			CAppModule* pModule = (CAppModule*)::GetWindowLongPtr(hWnd, GWLP_USERDATA);
			ATLASSERT(pModule != NULL);
			ATLASSERT(pModule->m_pSettingChangeNotify != NULL);
			for(int i = 1; i < pModule->m_pSettingChangeNotify->GetSize(); i++)
				::SendMessageTimeout((*pModule->m_pSettingChangeNotify)[i], uMsg, wParam, lParam, SMTO_ABORTIFHUNG, 1500, NULL);
			return TRUE;
		}
		return FALSE;
	}
};


/////////////////////////////////////////////////////////////////////////////
// CServerAppModule - module class for a COM server application

class CServerAppModule : public CAppModule
{
public:
	HANDLE m_hEventShutdown;
	bool m_bActivity;
	DWORD m_dwTimeOut;
	DWORD m_dwPause;

// Override of CAppModule::Init
	HRESULT Init(_ATL_OBJMAP_ENTRY* pObjMap, HINSTANCE hInstance, const GUID* pLibID = NULL)
	{
		m_dwTimeOut = 5000;
		m_dwPause = 1000;
		return CAppModule::Init(pObjMap, hInstance, pLibID);
	}
	void Term()
	{
		if (m_hEventShutdown != NULL)
			CloseHandle(m_hEventShutdown);
		CAppModule::Term();
	}

// COM Server methods
	LONG Unlock()
	{
		LONG lRet = CComModule::Unlock();
		if(lRet == 0)
		{
			m_bActivity = true;
			::SetEvent(m_hEventShutdown); // tell monitor that we transitioned to zero
		}
		return lRet;
	}

	void MonitorShutdown()
	{
		while(1)
		{
			::WaitForSingleObject(m_hEventShutdown, INFINITE);
			DWORD dwWait = 0;
			do
			{
				m_bActivity = false;
				dwWait = ::WaitForSingleObject(m_hEventShutdown, m_dwTimeOut);
			}
			while(dwWait == WAIT_OBJECT_0);
			// timed out
			if(!m_bActivity && m_nLockCnt == 0) // if no activity let's really bail
			{
#if ((_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM)) & defined(_ATL_FREE_THREADED)
				::CoSuspendClassObjects();
				if(!m_bActivity && m_nLockCnt == 0)
#endif
					break;
			}
		}
		::CloseHandle(m_hEventShutdown);
		::PostThreadMessage(m_dwMainThreadID, WM_QUIT, 0, 0);
	}

	bool StartMonitor()
	{
		m_hEventShutdown = ::CreateEvent(NULL, false, false, NULL);
		if(m_hEventShutdown == NULL)
			return false;
		DWORD dwThreadID;
#if !defined(_ATL_MIN_CRT) & defined(_MT)
		HANDLE h = (HANDLE)_beginthreadex(NULL, 0, (UINT (WINAPI*)(void*))MonitorProc, this, 0, (UINT*)&dwThreadID);
#else
		HANDLE h = ::CreateThread(NULL, 0, MonitorProc, this, 0, &dwThreadID);
#endif
		bool b = (h != NULL);
		if (b)
			CloseHandle(h);
		return b;
	}

	static DWORD WINAPI MonitorProc(void* pv)
	{
		CServerAppModule* p = (CServerAppModule*)pv;
		p->MonitorShutdown();
#if !defined(_ATL_MIN_CRT) & defined(_MT)
		_endthreadex(0);
#endif
		return 0;
	}

	// Scan command line and perform registration
	// Return value specifies if server should run

	// Parses the command line and registers/unregisters the rgs file if necessary
	bool ParseCommandLine(LPCTSTR lpCmdLine, UINT nResId, HRESULT* pnRetCode)
	{
		TCHAR szTokens[] = _T("-/");
		*pnRetCode = S_OK;

		LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
		while(lpszToken != NULL)
		{
			if(lstrcmpi(lpszToken, _T("UnregServer"))==0)
			{
				*pnRetCode = UnregisterServer(TRUE);
				ATLASSERT(SUCCEEDED(*pnRetCode));
				if(FAILED(*pnRetCode))
					return false;
				*pnRetCode = UpdateRegistryFromResource(nResId, FALSE);
				return false;
			}

			// Register as Local Server
			if(lstrcmpi(lpszToken, _T("RegServer"))==0)
			{
				*pnRetCode = UpdateRegistryFromResource(nResId, TRUE);
				ATLASSERT(SUCCEEDED(*pnRetCode));
				if(FAILED(*pnRetCode))
					return false;
				*pnRetCode = RegisterServer(TRUE);
				return false;
			}

			lpszToken = FindOneOf(lpszToken, szTokens);
		}
		return true;
	}
	
	// Parses the command line and registers/unregisters the appid if necessary
	bool ParseCommandLine(LPCTSTR lpCmdLine, LPCTSTR pAppId, HRESULT* pnRetCode)
	{
		TCHAR szTokens[] = _T("-/");
		*pnRetCode = S_OK;

		LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
		while(lpszToken != NULL)
		{
			if(lstrcmpi(lpszToken, _T("UnregServer"))==0)
			{
				*pnRetCode = UnregisterAppId(pAppId);
				ATLASSERT(SUCCEEDED(*pnRetCode));
				if(FAILED(*pnRetCode))
					return false;
				*pnRetCode = UnregisterServer(TRUE);
				return false;
			}

			// Register as Local Server
			if(lstrcmpi(lpszToken, _T("RegServer"))==0)
			{
				*pnRetCode = RegisterAppId(pAppId);
				ATLASSERT(SUCCEEDED(*pnRetCode));
				if(FAILED(*pnRetCode))
					return false;
				*pnRetCode = RegisterServer(TRUE);
				return false;
			}

			lpszToken = FindOneOf(lpszToken, szTokens);
		}
		return true;
	}

#if !defined(_ATL_TMP_IMPL1) && !defined(_ATL_TMP_IMPL2)
	// search for an occurence of string p2 in string p1
	static LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
	{
		while(p1 != NULL && *p1 != NULL)
		{
			LPCTSTR p = p2;
			while(p != NULL && *p != NULL)
			{
				if(*p1 == *p)
					return ::CharNext(p1);
				p = ::CharNext(p);
			}
			p1 = ::CharNext(p1);
		}
		return NULL;
	}

	HRESULT RegisterAppId(LPCTSTR pAppId)
	{
		CRegKey keyAppID;
		if(keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_READ) == ERROR_SUCCESS)
		{
			TCHAR szModule1[_MAX_PATH];
			TCHAR szModule2[_MAX_PATH];
			TCHAR* pszFileName;
			::GetModuleFileName(GetModuleInstance(), szModule1, _MAX_PATH);
			::GetFullPathName(szModule1, _MAX_PATH, szModule2, &pszFileName);
			CRegKey keyAppIDEXE;
			if(keyAppIDEXE.Create(keyAppID, pszFileName, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE) == ERROR_SUCCESS)
				keyAppIDEXE.SetValue(pAppId, _T("AppID"));
			if(keyAppIDEXE.Create(keyAppID, pAppId, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE) == ERROR_SUCCESS)
				keyAppIDEXE.SetValue(pszFileName);
		}
		return S_OK;
	}

	HRESULT UnregisterAppId(LPCTSTR pAppId)
	{
		CRegKey keyAppID;
		if(keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_READ) == ERROR_SUCCESS)
		{
			TCHAR szModule1[_MAX_PATH];
			TCHAR szModule2[_MAX_PATH];
			TCHAR* pszFileName;
			::GetModuleFileName(GetModuleInstance(), szModule1, _MAX_PATH);
			::GetFullPathName(szModule1, _MAX_PATH, szModule2, &pszFileName);
			keyAppID.RecurseDeleteKey(pszFileName);
			keyAppID.RecurseDeleteKey(pAppId);
		}
		return S_OK;
	}
#endif //!defined(_ATL_TMP_IMPL1) && !defined(_ATL_TMP_IMPL2)
};


/////////////////////////////////////////////////////////////////////////////
// ATL 3.0 Add-ons

// protect template members from windowsx.h macros
#ifdef _INC_WINDOWSX
#undef SubclassWindow
#endif //_INC_WINDOWSX

// define useful macros from windowsx.h
#ifndef GET_X_LPARAM
#define GET_X_LPARAM(lParam)	((int)(short)LOWORD(lParam))
#endif
#ifndef GET_Y_LPARAM
#define GET_Y_LPARAM(lParam)	((int)(short)HIWORD(lParam))
#endif


/////////////////////////////////////////////////////////////////////////////
// Dual argument helper classes

#ifndef _ATL_TMP_IMPL2

class _U_RECT
{
public:
	_U_RECT(LPRECT lpRect) : m_lpRect(lpRect)
	{ }
	_U_RECT(RECT& rc) : m_lpRect(&rc)
	{ }
	LPRECT m_lpRect;
};

class _U_MENUorID
{
public:
	_U_MENUorID(HMENU hMenu) : m_hMenu(hMenu)
	{ }
	_U_MENUorID(UINT nID) : m_hMenu((HMENU)LongToHandle(nID))
	{ }
	HMENU m_hMenu;
};

class _U_STRINGorID
{
public:
	_U_STRINGorID(LPCTSTR lpString) : m_lpstr(lpString)
	{ }
	_U_STRINGorID(UINT nID) : m_lpstr(MAKEINTRESOURCE(nID))
	{ }
	LPCTSTR m_lpstr;
};

#endif //!_ATL_TMP_IMPL2


/////////////////////////////////////////////////////////////////////////////
// Forward notifications support for message maps

#if !defined(_ATL_TMP_IMPL1) && !defined(_ATL_TMP_IMPL2)

// forward notifications support
#define FORWARD_NOTIFICATIONS() \
	{ \
		bHandled = TRUE; \
		lResult = Atl3ForwardNotifications(m_hWnd, uMsg, wParam, lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

static LRESULT Atl3ForwardNotifications(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	LRESULT lResult = 0;
	switch(uMsg)
	{
	case WM_COMMAND:
	case WM_NOTIFY:
	case WM_PARENTNOTIFY:
	case WM_DRAWITEM:
	case WM_MEASUREITEM:
	case WM_COMPAREITEM:
	case WM_DELETEITEM:
	case WM_VKEYTOITEM:
	case WM_CHARTOITEM:
	case WM_HSCROLL:
	case WM_VSCROLL:
	case WM_CTLCOLORBTN:
	case WM_CTLCOLORDLG:
	case WM_CTLCOLOREDIT:
	case WM_CTLCOLORLISTBOX:
	case WM_CTLCOLORMSGBOX:
	case WM_CTLCOLORSCROLLBAR:
	case WM_CTLCOLORSTATIC:
		lResult = ::SendMessage(::GetParent(hWnd), uMsg, wParam, lParam);
		break;
	default:
		bHandled = FALSE;
		break;
	}
	return lResult;
}


/////////////////////////////////////////////////////////////////////////////
// Reflected message handler macros for message maps

#define REFLECTED_COMMAND_HANDLER(id, code, func) \
	if(uMsg == OCM_COMMAND && id == LOWORD(wParam) && code == HIWORD(wParam)) \
	{ \
		bHandled = TRUE; \
		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECTED_COMMAND_ID_HANDLER(id, func) \
	if(uMsg == OCM_COMMAND && id == LOWORD(wParam)) \
	{ \
		bHandled = TRUE; \
		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECTED_COMMAND_CODE_HANDLER(code, func) \
	if(uMsg == OCM_COMMAND && code == HIWORD(wParam)) \
	{ \
		bHandled = TRUE; \
		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECTED_COMMAND_RANGE_HANDLER(idFirst, idLast, func) \
	if(uMsg == OCM_COMMAND && LOWORD(wParam) >= idFirst  && LOWORD(wParam) <= idLast) \
	{ \
		bHandled = TRUE; \
		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECTED_COMMAND_RANGE_CODE_HANDLER(idFirst, idLast, code, func) \
	if(uMsg == OCM_COMMAND && code == HIWORD(wParam) && LOWORD(wParam) >= idFirst  && LOWORD(wParam) <= idLast) \
	{ \
		bHandled = TRUE; \
		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECTED_NOTIFY_HANDLER(id, cd, func) \
	if(uMsg == OCM_NOTIFY && id == ((LPNMHDR)lParam)->idFrom && cd == ((LPNMHDR)lParam)->code) \
	{ \
		bHandled = TRUE; \
		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECTED_NOTIFY_ID_HANDLER(id, func) \
	if(uMsg == OCM_NOTIFY && id == ((LPNMHDR)lParam)->idFrom) \
	{ \
		bHandled = TRUE; \
		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECTED_NOTIFY_CODE_HANDLER(cd, func) \
	if(uMsg == OCM_NOTIFY && cd == ((LPNMHDR)lParam)->code) \
	{ \
		bHandled = TRUE; \
		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECTED_NOTIFY_RANGE_HANDLER(idFirst, idLast, func) \
	if(uMsg == OCM_NOTIFY && ((LPNMHDR)lParam)->idFrom >= idFirst && ((LPNMHDR)lParam)->idFrom <= idLast) \
	{ \
		bHandled = TRUE; \
		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECTED_NOTIFY_RANGE_CODE_HANDLER(idFirst, idLast, cd, func) \
	if(uMsg == OCM_NOTIFY && cd == ((LPNMHDR)lParam)->code && ((LPNMHDR)lParam)->idFrom >= idFirst && ((LPNMHDR)lParam)->idFrom <= idLast) \
	{ \
		bHandled = TRUE; \
		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#endif //!defined(_ATL_TMP_IMPL1) && !defined(_ATL_TMP_IMPL2)

}; //namespace WTL

// These are always included
#include <atluser.h>
#include <atlgdi.h>

// old names compatibility
#ifdef _ATL_TMP_IMPL1
namespace WTL
{
typedef CFontHandle		CWinFont;
typedef CMenuHandle		CWinMenu;
#define CWinPropertyPageImpl	CPropertyPageImpl
typedef CDCHandle		CWinDC;
}; //namespace WTL
#endif //_ATL_TMP_IMPL1

#ifndef _WTL_NO_AUTOMATIC_NAMESPACE
using namespace WTL;
#endif //!_WTL_NO_AUTOMATIC_NAMESPACE

#endif // __ATLAPP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\atlctrlw.h ===
// WTL Version 3.0
// Copyright (C) 1997-1999 Microsoft Corporation
// All rights reserved.
//
// This file is a part of Windows Template Library.
// The code and information is provided "as-is" without
// warranty of any kind, either expressed or implied.

#ifndef __ATLCTRLW_H__
#define __ATLCTRLW_H__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLAPP_H__
	#error atlctrlw.h requires atlapp.h to be included first
#endif

#ifndef __ATLCTRLS_H__
	#error atlctrlw.h requires atlctrls.h to be included first
#endif

#if (_WIN32_IE < 0x0400)
	#error atlctrlw.h requires _WIN32_IE >= 0x0400
#endif

// Needed for command bar
#ifndef OBM_CHECK
#define OBM_CHECK           32760
#endif

#ifndef HICF_LMOUSE
#define HICF_LMOUSE         0x00000080          // left mouse button selected
#endif


namespace WTL
{

/////////////////////////////////////////////////////////////////////////////
// Command Bars

// Window Styles:
#define CBRWS_TOP		CCS_TOP
#define CBRWS_BOTTOM		CCS_BOTTOM
#define CBRWS_NORESIZE		CCS_NORESIZE
#define CBRWS_NOPARENTALIGN	CCS_NOPARENTALIGN
#define CBRWS_NODIVIDER		CCS_NODIVIDER

// Extended styles
#define CBR_EX_TRANSPARENT	0x00000001L
#define CBR_EX_SHAREMENU	0x00000002L
#define CBR_EX_ALTFOCUSMODE	0x00000004L

// standard command bar styles
#define ATL_SIMPLE_CMDBAR_PANE_STYLE \
	(WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | CBRWS_NODIVIDER | CBRWS_NORESIZE | CBRWS_NOPARENTALIGN)

// Messages - support chevrons for frame windows
#define CBRM_GETCMDBAR			(WM_USER + 301) // return command bar HWND
#define CBRM_GETMENU			(WM_USER + 302)	// returns loaded or attached menu
#define CBRM_TRACKPOPUPMENU		(WM_USER + 303)	// displays a popup menu

typedef struct tagCBRPOPUPMENU
{
	int cbSize;
	HMENU hMenu;		// popup menu do display
	UINT uFlags;		// TPM_* flags for ::TrackPopupMenuEx
	int x;
	int y;
	LPTPMPARAMS lptpm;	// ptr to TPMPARAMS for ::TrackPopupMenuEx
} CBRPOPUPMENU, *LPCBRPOPUPMENU;

// Menu animation flags
#ifndef TPM_VERPOSANIMATION
#define TPM_VERPOSANIMATION 0x1000L
#endif
#ifndef TPM_NOANIMATION
#define TPM_NOANIMATION     0x4000L
#endif

// helper class
template <class T>
class CSimpleStack : public CSimpleArray< T >
{
public:
	BOOL Push(T t)
	{
#ifdef _CMDBAR_EXTRA_TRACE
		ATLTRACE2(atlTraceUI, 0, "CmdBar - STACK-PUSH (%8.8X) size = %i\n", t, GetSize());
#endif
		return Add(t);
	}
	T Pop()
	{
		int nLast = GetSize() - 1;
		if(nLast < 0)
			return NULL;	// must be able to convert to NULL
		T t = m_aT[nLast];
#ifdef _CMDBAR_EXTRA_TRACE
		ATLTRACE2(atlTraceUI, 0, "CmdBar - STACK-POP (%8.8X) size = %i\n", t, GetSize());
#endif
		if(!RemoveAt(nLast))
			return NULL;
		return t;
	}
	T GetCurrent()
	{
		int nLast = GetSize() - 1;
		if(nLast < 0)
			return NULL;	// must be able to convert to NULL
		return m_aT[nLast];
	}
};


/////////////////////////////////////////////////////////////////////////////
// Forward declarations

template <class T, class TBase = CCommandBarCtrlBase, class TWinTraits = CControlWinTraits> class CCommandBarCtrlImpl;
class CCommandBarCtrl;


/////////////////////////////////////////////////////////////////////////////
// CCommandBarCtrlBase - base class for the Command Bar implementation

class CCommandBarCtrlBase : public CToolBarCtrl
{
public:
	struct _MsgHookData
	{
		HHOOK hMsgHook;
		DWORD dwUsage;

		_MsgHookData() : hMsgHook(NULL), dwUsage(0) { }
	};

	typedef CSimpleMap<DWORD, _MsgHookData*>	CMsgHookMap;
	static CMsgHookMap* s_pmapMsgHook;

	static HHOOK s_hCreateHook;
	static bool s_bW2K;  // For animation flag
	static CCommandBarCtrlBase* s_pCurrentBar;
	static bool s_bStaticInit;

	CSimpleStack<HWND> m_stackMenuWnd;
	CSimpleStack<HMENU> m_stackMenuHandle;

	HWND m_hWndHook;
	DWORD m_dwMagic;


	CCommandBarCtrlBase() : m_hWndHook(NULL), m_dwMagic(1314)
	{
		// init static variables
		if(!s_bStaticInit)
		{
			::EnterCriticalSection(&_Module.m_csStaticDataInit);
			if(!s_bStaticInit)
			{
				// Just in case...
				INITCOMMONCONTROLSEX iccx;
				iccx.dwSize = sizeof(iccx);
				iccx.dwICC = ICC_COOL_CLASSES | ICC_BAR_CLASSES;
				::InitCommonControlsEx(&iccx);
				// Animation on Win2000 only
				s_bW2K = !AtlIsOldWindows();
				// done
				s_bStaticInit = true;
			}
			::LeaveCriticalSection(&_Module.m_csStaticDataInit);
		}
	}

	bool IsCommandBarBase() const { return m_dwMagic == 1314; }
};

__declspec(selectany) CCommandBarCtrlBase::CMsgHookMap* CCommandBarCtrlBase::s_pmapMsgHook = NULL;
__declspec(selectany) HHOOK CCommandBarCtrlBase::s_hCreateHook = NULL;
__declspec(selectany) CCommandBarCtrlBase* CCommandBarCtrlBase::s_pCurrentBar = NULL;
__declspec(selectany) bool CCommandBarCtrlBase::s_bW2K = false;
__declspec(selectany) bool CCommandBarCtrlBase::s_bStaticInit = false;


/////////////////////////////////////////////////////////////////////////////
// CCommandBarCtrl - ATL implementation of Command Bars

template <class T, class TBase = CCommandBarCtrlBase, class TWinTraits = CControlWinTraits>
class ATL_NO_VTABLE CCommandBarCtrlImpl : public CWindowImpl< T, TBase, TWinTraits>
{
public:
	DECLARE_WND_SUPERCLASS(NULL, TBase::GetWndClassName())

// Declarations
	struct _MenuItemData	// menu item data
	{
		DWORD dwMagic;
		LPTSTR lpstrText;
		UINT fType;
		UINT fState;
		int iButton;

		_MenuItemData() { dwMagic = 0x1313; }
		bool IsCmdBarMenuItem() { return (dwMagic == 0x1313); }
	};

	struct _ToolBarData	// toolbar resource data
	{
		WORD wVersion;
		WORD wWidth;
		WORD wHeight;
		WORD wItemCount;
		//WORD aItems[wItemCount]

		WORD* items()
			{ return (WORD*)(this+1); }
	};

// Constants
	enum _CmdBarDrawConstants
	{
		s_kcxGap = 1,
		s_kcxTextMargin = 2,
		s_kcxButtonMargin = 3,
		s_kcyButtonMargin = 3
	};

	enum { _nMaxMenuItemTextLength = 100 };

// Data members
	HMENU m_hMenu;
	HIMAGELIST m_hImageList;
	CSimpleValArray<WORD> m_arrCommand;

	CContainedWindow m_wndParent;
	CContainedWindow m_wndMDIClient;

	bool m_bMenuActive;
	bool m_bAttachedMenu;
	bool m_bImagesVisible;
	bool m_bPopupItem;
	bool m_bContextMenu;
	bool m_bEscapePressed;

	int m_nPopBtn;
	int m_nNextPopBtn;

	SIZE m_szBitmap;
	SIZE m_szButton;

	COLORREF m_clrMask;
	CFont m_fontMenu;

	bool m_bSkipMsg;
	UINT m_uSysKey;

	HWND m_hWndFocus;		// Alternate focus mode
	DWORD m_dwExtendedStyle;	// Command Bar specific extended styles

// Constructor/destructor
	CCommandBarCtrlImpl() : 
			m_hMenu(NULL), 
			m_hImageList(NULL), 
			m_wndParent(this, 1), 
			m_bMenuActive(false), 
			m_bAttachedMenu(false), 
			m_nPopBtn(-1), 
			m_nNextPopBtn(-1), 
			m_bPopupItem(false),
			m_bImagesVisible(true),
			m_wndMDIClient(this, 2),
			m_bSkipMsg(false),
			m_uSysKey(0),
			m_hWndFocus(NULL),
			m_bContextMenu(false),
			m_bEscapePressed(false),
			m_clrMask(RGB(192, 192, 192)),
			m_dwExtendedStyle(CBR_EX_TRANSPARENT | CBR_EX_SHAREMENU)
	{
		m_szBitmap.cx = 16;
		m_szBitmap.cy = 15;
		m_szButton.cx = m_szBitmap.cx + s_kcxButtonMargin;
		m_szButton.cy = m_szBitmap.cy + s_kcyButtonMargin;
 	}

	~CCommandBarCtrlImpl()
	{
		if(m_wndParent.IsWindow())
/*scary!*/			m_wndParent.UnsubclassWindow();

		if(m_wndMDIClient.IsWindow())
/*scary!*/			m_wndMDIClient.UnsubclassWindow();

		if(m_hMenu != NULL && (m_dwExtendedStyle & CBR_EX_SHAREMENU) == 0)
			::DestroyMenu(m_hMenu);

		if(m_hImageList != NULL)
			::ImageList_Destroy(m_hImageList);
	}

// Attributes
	DWORD GetCommandBarExtendedStyle() const
	{
		return m_dwExtendedStyle;
	}
	DWORD SetCommandBarExtendedStyle(DWORD dwExtendedStyle)
	{
		DWORD dwPrevStyle = m_dwExtendedStyle;
		m_dwExtendedStyle = dwExtendedStyle;
		return dwPrevStyle;
	}

	CMenuHandle GetMenu() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return m_hMenu;
	}

	COLORREF GetImageMaskColor() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return m_clrMask;
	}
	COLORREF SetImageMaskColor(COLORREF clrMask)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		COLORREF clrOld = m_clrMask;
		m_clrMask = clrMask;
		return clrOld;
	}

	bool GetImagesVisible() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return m_bImagesVisible;
	}
	bool SetImagesVisible(bool bVisible)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		bool bOld = m_bImagesVisible;
		m_bImagesVisible = bVisible;
		return bOld;
	}

	void GetImageSize(SIZE& size) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		size = m_szBitmap;
	}
	bool SetImageSize(SIZE& size)
	{
		ATLASSERT(::IsWindow(m_hWnd));

		if(m_hImageList != NULL)
		{
			if(::ImageList_GetImageCount(m_hImageList) == 0)	// empty
			{
				::ImageList_Destroy(m_hImageList);
				m_hImageList = NULL;
			}
			else
			{
				return false;		// can't set, image list exists
			}
		}

		if(size.cx == 0 || size.cy == 0)
			return false;

		m_szBitmap = size;
		m_szButton.cx = m_szBitmap.cx + s_kcxButtonMargin;
		m_szButton.cy = m_szBitmap.cy + s_kcyButtonMargin;

		return true;
	}

	HWND GetCmdBar() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HWND)::SendMessage(m_hWnd, CBRM_GETCMDBAR, 0, 0L);
	}

// Methods
	BOOL AttachToWindow(HWND hWnd)
	{
		ATLASSERT(m_hWnd == NULL);
		ATLASSERT(::IsWindow(hWnd));
		BOOL bRet = SubclassWindow(hWnd);
		if(bRet)
		{
			m_bAttachedMenu = true;
			GetSystemSettings();
		}
		return bRet;
	}

	BOOL LoadMenu(_U_STRINGorID menu)
	{
		ATLASSERT(::IsWindow(m_hWnd));

		if(m_bAttachedMenu)	// doesn't work in this mode
			return FALSE;
		if(menu.m_lpstr == NULL)
			return FALSE;

		HMENU hMenu = ::LoadMenu(_Module.GetResourceInstance(), menu.m_lpstr);
		if(hMenu == NULL)
			return FALSE;

		return AttachMenu(hMenu);
	}

	BOOL AttachMenu(HMENU hMenu)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(::IsMenu(hMenu));
		if(hMenu != NULL && !::IsMenu(hMenu))
			return FALSE;

		// destroy old menu, if needed, and set new one
		if(m_hMenu != NULL && (m_dwExtendedStyle & CBR_EX_SHAREMENU) == 0)
			::DestroyMenu(m_hMenu);
		m_hMenu = hMenu;

		if(m_bAttachedMenu)	// Nothing else in this mode
			return TRUE;

		// Build buttons according to menu
		SetRedraw(FALSE);

		// Clear all
		BOOL bRet;
		int nCount = GetButtonCount();
		for(int i = 0; i < nCount; i++)
		{
			bRet = DeleteButton(0);
			ATLASSERT(bRet);
		}


		// Add buttons for each menu item
		if(m_hMenu != NULL)
		{
			int nItems = ::GetMenuItemCount(m_hMenu);

			TCHAR szString[_nMaxMenuItemTextLength];
			for(int i = 0; i < nItems; i++)
			{
				CMenuItemInfo mii;
				mii.fMask = MIIM_ID | MIIM_TYPE;
				mii.fType = MFT_STRING;
				mii.dwTypeData = szString;
				mii.cch = _nMaxMenuItemTextLength;
				bRet = ::GetMenuItemInfo(m_hMenu, i, TRUE, &mii);
				ATLASSERT(bRet);
				// If we have more than the buffer, we assume we have bitmaps bits
				if(lstrlen(szString) > _nMaxMenuItemTextLength - 1)
				{
					mii.fType = MFT_BITMAP;
					::SetMenuItemInfo(m_hMenu, i, TRUE, &mii);
					szString[0] = 0;
				}

				// NOTE: Command Bar currently supports only menu items
				//       that are enabled and have a drop-down menu
				TBBUTTON btn;
				btn.iBitmap = 0;
				btn.idCommand = i;
				btn.fsState = TBSTATE_ENABLED;
				btn.fsStyle = TBSTYLE_BUTTON | TBSTYLE_AUTOSIZE | TBSTYLE_DROPDOWN;
				btn.dwData = 0;
				btn.iString = 0;

				bRet = InsertButton(-1, &btn);
				ATLASSERT(bRet);

				TBBUTTONINFO bi;
				memset(&bi, 0, sizeof(bi));
				bi.cbSize = sizeof(TBBUTTONINFO);
				bi.dwMask = TBIF_TEXT;
				bi.pszText = szString;

				bRet = SetButtonInfo(i, &bi);
				ATLASSERT(bRet);
			}
		}

		SetRedraw(TRUE);
		Invalidate();
		UpdateWindow();

		return TRUE;
	}

	BOOL LoadImages(_U_STRINGorID image)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		HINSTANCE hInstance = _Module.GetResourceInstance();

		HRSRC hRsrc = ::FindResource(hInstance, image.m_lpstr, (LPTSTR)RT_TOOLBAR);
		if(hRsrc == NULL)
			return FALSE;

		HGLOBAL hGlobal = ::LoadResource(hInstance, hRsrc);
		if(hGlobal == NULL)
			return FALSE;

		_ToolBarData* pData = (_ToolBarData*)::LockResource(hGlobal);
		if(pData == NULL)
			return FALSE;
		ATLASSERT(pData->wVersion == 1);

		WORD* pItems = pData->items();
		int nItems = pData->wItemCount;

		// Add bitmap to our image list (create it if it doesn't exist)
		if(m_hImageList == NULL)
		{
			m_hImageList = ::ImageList_Create(pData->wWidth, pData->wHeight, ILC_COLOR | ILC_MASK, pData->wItemCount, 1);
			ATLASSERT(m_hImageList != NULL);
			if(m_hImageList == NULL)
				return FALSE;
		}

		CBitmap bmp;
		bmp.LoadBitmap(image.m_lpstr);
		ATLASSERT(bmp.m_hBitmap != NULL);
		if(bmp.m_hBitmap == NULL)
			return FALSE;
		if(::ImageList_AddMasked(m_hImageList, bmp, m_clrMask) == -1)
			return FALSE;

		// Fill the array with command IDs
		for(int i = 0; i < nItems; i++)
		{
			if(pItems[i] != 0)
				m_arrCommand.Add(pItems[i]);
		}

		ATLASSERT(::ImageList_GetImageCount(m_hImageList) == m_arrCommand.GetSize());
		if(::ImageList_GetImageCount(m_hImageList) != m_arrCommand.GetSize())
			return FALSE;

		// Set some internal stuff
		m_szBitmap.cx = pData->wWidth;
		m_szBitmap.cy = pData->wHeight;
		m_szButton.cx = m_szBitmap.cx + 2 * s_kcxButtonMargin;
		m_szButton.cy = m_szBitmap.cy + 2 * s_kcyButtonMargin;

		return TRUE;
	}

	BOOL AddBitmap(_U_STRINGorID bitmap, int nCommandID)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		CBitmap bmp;
		bmp.LoadBitmap(bitmap.m_lpstr);
		if(bmp.m_hBitmap == NULL)
			return FALSE;
		return AddBitmap(bmp, nCommandID);
	}

	BOOL AddBitmap(HBITMAP hBitmap, UINT nCommandID)
	{
		// Create image list if it doesn't exist
		if(m_hImageList == NULL)
		{
			m_hImageList = ::ImageList_Create(m_szBitmap.cx, m_szBitmap.cy, ILC_COLOR | ILC_MASK, 1, 1);
			if(m_hImageList == NULL)
				return FALSE;
		}
		// check bitmap size
		CBitmapHandle bmp = hBitmap;
		SIZE size = { 0, 0 };
		bmp.GetSize(size);
		if(size.cx != m_szBitmap.cx || size.cy != m_szBitmap.cy)
		{
			ATLASSERT(FALSE);	// must match size!
			return FALSE;
		}
		// add bitmap
		int nRet = ::ImageList_AddMasked(m_hImageList, hBitmap, m_clrMask);
		if(nRet == -1)
			return FALSE;
		BOOL bRet = m_arrCommand.Add((WORD)nCommandID);
		ATLASSERT(::ImageList_GetImageCount(m_hImageList) == m_arrCommand.GetSize());
		return bRet;
	}

	BOOL AddIcon(HICON hIcon, UINT nCommandID)
	{
		// create image list if it doesn't exist
		if(m_hImageList == NULL)
		{
			m_hImageList = ::ImageList_Create(m_szBitmap.cx, m_szBitmap.cy, ILC_COLOR | ILC_MASK, 1, 1);
			if(m_hImageList == NULL)
				return FALSE;
		}

		int nRet = ::ImageList_AddIcon(m_hImageList, hIcon);
		if(nRet == -1)
			return FALSE;
		BOOL bRet = m_arrCommand.Add((WORD)nCommandID);
		ATLASSERT(::ImageList_GetImageCount(m_hImageList) == m_arrCommand.GetSize());
		return bRet;
	}

	BOOL ReplaceBitmap(_U_STRINGorID bitmap, int nCommandID)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		CBitmap bmp;
		bmp.LoadBitmap(bitmap.m_lpstr);
		if(bmp.m_hBitmap == NULL)
			return FALSE;
		return ReplaceBitmap(bmp, nCommandID);
	}

	BOOL ReplaceBitmap(HBITMAP hBitmap, UINT nCommandID)
	{
		BOOL bRet = FALSE;
		for(int i = 0; i < m_arrCommand.GetSize(); i++)
		{
			if(m_arrCommand[i] == nCommandID)
			{
				bRet = ::ImageList_Remove(m_hImageList, i);
				if(bRet)
					m_arrCommand.RemoveAt(i);
				break;
			}
		}
		if(bRet)
			bRet = AddBitmap(hBitmap, nCommandID);
		return bRet;
	}

	BOOL ReplaceIcon(HICON hIcon, UINT nCommandID)
	{
		BOOL bRet = FALSE;
		for(int i = 0; i < m_arrCommand.GetSize(); i++)
		{
			if(m_arrCommand[i] == nCommandID)
			{
				bRet = (::ImageList_ReplaceIcon(m_hImageList, i, hIcon) != -1);
				break;
			}
		}
		return bRet;
	}

	BOOL RemoveImage(int nCommandID)
	{
		ATLASSERT(::IsWindow(m_hWnd));

		BOOL bRet = FALSE;
		for(int i = 0; i < m_arrCommand.GetSize(); i++)
		{
			if(m_arrCommand[i] == nCommandID)
			{
				bRet = ::ImageList_Remove(m_hImageList, i);
				if(bRet)
					m_arrCommand.RemoveAt(i);
				break;
			}
		}
		return bRet;
	}

	BOOL RemoveAllImages()
	{
		ATLASSERT(::IsWindow(m_hWnd));

		ATLTRACE2(atlTraceUI, 0, "CmdBar - Removing all images\n");
		BOOL bRet = ::ImageList_RemoveAll(m_hImageList);
		if(bRet)
			m_arrCommand.RemoveAll();
		return bRet;
	}

	BOOL TrackPopupMenu(HMENU hMenu, UINT uFlags, int x, int y, LPTPMPARAMS lpParams = NULL)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(::IsMenu(hMenu));
		if(!::IsMenu(hMenu))
			return FALSE;
		m_bContextMenu = true;
		return DoTrackPopupMenu(hMenu, uFlags, x, y, lpParams);
	}

	// NOTE: Limited support for MDI - no icon or min/max/close buttons
	BOOL SetMDIClient(HWND hWndMDIClient)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(::IsWindow(hWndMDIClient));
		if(!::IsWindow(hWndMDIClient))
			return FALSE;
#ifdef _DEBUG
		LPCTSTR lpszMDIClientClass = _T("MDICLIENT");
		int nNameLen = lstrlen(lpszMDIClientClass) + 1;
		LPTSTR lpstrClassName = (LPTSTR)_alloca(nNameLen * sizeof(TCHAR));
		::GetClassName(hWndMDIClient, lpstrClassName, nNameLen);
		ATLASSERT(lstrcmpi(lpstrClassName, lpszMDIClientClass) == 0);
		if(lstrcmpi(lpstrClassName, lpszMDIClientClass) != 0)
			return FALSE;	// not an "MDIClient" window
#endif //_DEBUG
		if(m_wndMDIClient.IsWindow())
			m_wndMDIClient.UnsubclassWindow();	// scary!

		return m_wndMDIClient.SubclassWindow(hWndMDIClient);
	}

// Message map and handlers
	BEGIN_MSG_MAP(CCommandBarCtrlImpl)
		MESSAGE_HANDLER(WM_CREATE, OnCreate)
		MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
		MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBackground)
		MESSAGE_HANDLER(WM_INITMENU, OnInitMenu)
		MESSAGE_HANDLER(WM_INITMENUPOPUP, OnInitMenuPopup)
		MESSAGE_HANDLER(WM_MENUSELECT, OnMenuSelect)
		MESSAGE_HANDLER(GetAutoPopupMessage(), OnInternalAutoPopup)
		MESSAGE_HANDLER(GetGetBarMessage(), OnInternalGetBar)
		MESSAGE_HANDLER(WM_SETTINGCHANGE, OnSettingChange)
		MESSAGE_HANDLER(WM_MENUCHAR, OnMenuChar)

		MESSAGE_HANDLER(WM_KEYDOWN, OnKeyDown)
		MESSAGE_HANDLER(WM_KEYUP, OnKeyUp)
		MESSAGE_HANDLER(WM_CHAR, OnChar)
		MESSAGE_HANDLER(WM_SYSKEYDOWN, OnSysKeyDown)
		MESSAGE_HANDLER(WM_SYSKEYUP, OnSysKeyUp)
		MESSAGE_HANDLER(WM_SYSCHAR, OnSysChar)
// public API handlers - these stay to support chevrons in atlframe.h
		MESSAGE_HANDLER(CBRM_GETMENU, OnAPIGetMenu)
		MESSAGE_HANDLER(CBRM_TRACKPOPUPMENU, OnAPITrackPopupMenu)
		MESSAGE_HANDLER(CBRM_GETCMDBAR, OnAPIGetCmdBar)

		MESSAGE_HANDLER(WM_DRAWITEM, OnDrawItem)
		MESSAGE_HANDLER(WM_MEASUREITEM, OnMeasureItem)

		MESSAGE_HANDLER(WM_FORWARDMSG, OnForwardMsg)
	ALT_MSG_MAP(1)		// Parent window messages
		NOTIFY_CODE_HANDLER(TBN_HOTITEMCHANGE, OnParentHotItemChange)
		NOTIFY_CODE_HANDLER(TBN_DROPDOWN, OnParentDropDown)
		MESSAGE_HANDLER(WM_INITMENUPOPUP, OnParentInitMenuPopup)
		MESSAGE_HANDLER(WM_SETTINGCHANGE, OnParentSettingChange)
		MESSAGE_HANDLER(GetGetBarMessage(), OnParentInternalGetBar)
		MESSAGE_HANDLER(WM_SYSCOMMAND, OnParentSysCommand)
		MESSAGE_HANDLER(CBRM_GETMENU, OnParentAPIGetMenu)
		MESSAGE_HANDLER(WM_MENUCHAR, OnParentMenuChar)
		MESSAGE_HANDLER(CBRM_TRACKPOPUPMENU, OnParentAPITrackPopupMenu)
		MESSAGE_HANDLER(CBRM_GETCMDBAR, OnParentAPIGetCmdBar)

		MESSAGE_HANDLER(WM_DRAWITEM, OnParentDrawItem)
		MESSAGE_HANDLER(WM_MEASUREITEM, OnParentMeasureItem)
	ALT_MSG_MAP(2)		// MDI client window messages
		MESSAGE_HANDLER(WM_MDISETMENU, OnMDISetMenu)
	ALT_MSG_MAP(3)		// Message hook messages
		MESSAGE_HANDLER(WM_MOUSEMOVE, OnHookMouseMove)
		MESSAGE_HANDLER(WM_SYSKEYDOWN, OnHookSysKeyDown)
		MESSAGE_HANDLER(WM_SYSKEYUP, OnHookSysKeyUp)
		MESSAGE_HANDLER(WM_SYSCHAR, OnHookSysChar)
		MESSAGE_HANDLER(WM_KEYDOWN, OnHookKeyDown)
		MESSAGE_HANDLER(WM_NEXTMENU, OnHookNextMenu)
		MESSAGE_HANDLER(WM_CHAR, OnHookChar)
	END_MSG_MAP()

	LRESULT OnForwardMsg(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& /*bHandled*/)
	{
		LPMSG pMsg = (LPMSG)lParam;
		LRESULT lRet = 0;
		ProcessWindowMessage(pMsg->hwnd, pMsg->message, pMsg->wParam, pMsg->lParam, lRet, 3);
		return lRet;
	}

	LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
	{
		// These styles are required
		ModifyStyle(0, TBSTYLE_LIST | TBSTYLE_FLAT);
		// Let the toolbar initialize itself
		LRESULT lRet = DefWindowProc(uMsg, wParam, lParam);
		// get and use system settings
		GetSystemSettings();
		// Parent init
		CWindow wndParent = GetParent();
		CWindow wndTopLevelParent = wndParent.GetTopLevelParent();
		m_wndParent.SubclassWindow(wndTopLevelParent);
		// Toolbar Init
		SetButtonStructSize();
		SetImageList(NULL);

		// Create message hook if needed
		::EnterCriticalSection(&_Module.m_csWindowCreate);
		if(s_pmapMsgHook == NULL)
		{
			ATLTRY(s_pmapMsgHook = new CMsgHookMap);
			ATLASSERT(s_pmapMsgHook != NULL);
		}

		if(s_pmapMsgHook != NULL)
		{
			DWORD dwThreadID = ::GetCurrentThreadId();
			_MsgHookData* pData = s_pmapMsgHook->Lookup(dwThreadID);
			if(pData == NULL)
			{
				ATLTRY(pData = new _MsgHookData);
				ATLASSERT(pData != NULL);
				HHOOK hMsgHook = ::SetWindowsHookEx(WH_GETMESSAGE, MessageHookProc, _Module.GetModuleInstance(), dwThreadID);
				ATLASSERT(hMsgHook != NULL);
				if(pData != NULL && hMsgHook != NULL)
				{
					pData->hMsgHook = hMsgHook;
					pData->dwUsage = 1;
					BOOL bRet = s_pmapMsgHook->Add(dwThreadID, pData);
					bRet;
					ATLASSERT(bRet);
				}
			}
			else
			{
				(pData->dwUsage)++;
			}
		}
		::LeaveCriticalSection(&_Module.m_csWindowCreate);

		return lRet;
	}

	LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
	{
		LRESULT lRet = DefWindowProc(uMsg, wParam, lParam);
		::EnterCriticalSection(&_Module.m_csWindowCreate);
		ATLASSERT(s_pmapMsgHook != NULL);
		if(s_pmapMsgHook != NULL)
		{
			DWORD dwThreadID = ::GetCurrentThreadId();
			_MsgHookData* pData = s_pmapMsgHook->Lookup(dwThreadID);
			if(pData != NULL)
			{
				BOOL bRet = ::UnhookWindowsHookEx(pData->hMsgHook);
				ATLASSERT(bRet);
				if(bRet)
				{
					(pData->dwUsage)--;
					if(pData->dwUsage == 0)
					{
						bRet = s_pmapMsgHook->Remove(dwThreadID);
						ATLASSERT(bRet);
						if(bRet)
							delete pData;
					}
				}

				if(s_pmapMsgHook->GetSize() == 0)
				{
					delete s_pmapMsgHook;
					s_pmapMsgHook = NULL;
				}
			}
		}
		::LeaveCriticalSection(&_Module.m_csWindowCreate);
		return lRet;
	}

	LRESULT OnKeyDown(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
#ifdef _CMDBAR_EXTRA_TRACE
		ATLTRACE2(atlTraceUI, 0, "CmdBar - OnKeyDown\n");
#endif
		// Simulate Alt+Space for the parent
		if(wParam == VK_SPACE)
		{
			m_wndParent.PostMessage(WM_SYSKEYDOWN, wParam, lParam | (1 << 29));
			bHandled = TRUE;
			return 0;
		}
		bHandled = FALSE;
		return 0;
	}

	LRESULT OnKeyUp(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
#ifdef _CMDBAR_EXTRA_TRACE
		ATLTRACE2(atlTraceUI, 0, "CmdBar - OnKeyUp\n");
#endif
		if(wParam != VK_SPACE)
			bHandled = FALSE;
		return 0;
	}

	LRESULT OnChar(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
#ifdef _CMDBAR_EXTRA_TRACE
		ATLTRACE2(atlTraceUI, 0, "CmdBar - OnChar\n");
#endif
		if(wParam != VK_SPACE)
			bHandled = FALSE;
		else
			return 0;
		// Security
		if(!m_wndParent.IsWindowEnabled() || ::GetFocus() != m_hWnd)
			return 0;

		// Handle mnemonic press when we have focus
		UINT nID = 0;
		if(wParam != VK_RETURN && 0 == SendMessage(TB_MAPACCELERATOR, LOWORD(wParam), (LPARAM)&nID))
			::MessageBeep(0);
		else
		{
			PostMessage(WM_KEYDOWN, VK_DOWN, 0L);
			if(wParam != VK_RETURN)
				SetHotItem(nID);
		}
		return 0;
	}

	LRESULT OnSysKeyDown(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
#ifdef _CMDBAR_EXTRA_TRACE
		ATLTRACE2(atlTraceUI, 0, "CmdBar - OnSysKeyDown\n");
#endif
		bHandled = FALSE;
		return 0;
	}

	LRESULT OnSysKeyUp(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
#ifdef _CMDBAR_EXTRA_TRACE
		ATLTRACE2(atlTraceUI, 0, "CmdBar - OnSysKeyUp\n");
#endif
		bHandled = FALSE;
		return 0;
	}

	LRESULT OnSysChar(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
#ifdef _CMDBAR_EXTRA_TRACE
		ATLTRACE2(atlTraceUI, 0, "CmdBar - OnSysChar\n");
#endif
		bHandled = FALSE;
		return 0;
	}

	LRESULT OnEraseBackground(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
		if(m_bAttachedMenu || (m_dwExtendedStyle & CBR_EX_TRANSPARENT))
		{
			bHandled = FALSE;
			return 0;
		}

		RECT rect;
		GetClientRect(&rect);
		::FillRect((HDC)wParam, &rect, (HBRUSH)LongToPtr(COLOR_MENU + 1));

		return 1;	// don't do the default erase
	}

	LRESULT OnInitMenu(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		int nIndex = GetHotItem();
		SendMessage(WM_MENUSELECT, MAKEWPARAM(nIndex, MF_POPUP|MF_HILITE), (LPARAM)m_hMenu);
		bHandled = FALSE;
		return 1;
	}

	LRESULT OnInitMenuPopup(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		if((BOOL)HIWORD(lParam))	// System menu, do nothing
		{
			bHandled = FALSE;
			return 1;
		}

		if(!(m_bAttachedMenu || m_bMenuActive))		// Not attached or ours, do nothing
		{
			bHandled = FALSE;
			return 1;
		}

		ATLTRACE2(atlTraceUI, 0, "CmdBar - OnInitMenuPopup\n");

		// forward to the parent or subclassed window, so it can handle update UI
		LRESULT lRet = 0;
		if(m_bAttachedMenu)
			lRet = DefWindowProc(uMsg, wParam, (lParam || m_bContextMenu) ? lParam : GetHotItem());
		else
			lRet = m_wndParent.DefWindowProc(uMsg, wParam, (lParam || m_bContextMenu) ? lParam : GetHotItem());

		// Convert menu items to ownerdraw, add our data
		if(m_bImagesVisible)
		{
			CMenuHandle menuPopup = (HMENU)wParam;
			ATLASSERT(menuPopup.m_hMenu != NULL);

			TCHAR szString[_nMaxMenuItemTextLength];
			BOOL bRet;
			for(int i = 0; i < menuPopup.GetMenuItemCount(); i++)
			{
				CMenuItemInfo mii;
				mii.cch = _nMaxMenuItemTextLength;
				mii.fMask = MIIM_CHECKMARKS | MIIM_DATA | MIIM_ID | MIIM_STATE | MIIM_SUBMENU | MIIM_TYPE;
				mii.dwTypeData = szString;
				bRet = menuPopup.GetMenuItemInfo(i, TRUE, &mii);
				ATLASSERT(bRet);

				if(!(mii.fType & MFT_OWNERDRAW))	// Not already an ownerdraw item
				{
					mii.fMask = MIIM_DATA | MIIM_TYPE | MIIM_STATE;
					_MenuItemData* pMI = NULL;
					ATLTRY(pMI = new _MenuItemData);
					ATLASSERT(pMI != NULL);
					if(pMI != NULL)
					{
						pMI->fType = mii.fType;
						pMI->fState = mii.fState;
						mii.fType |= MFT_OWNERDRAW;
						pMI->iButton = -1;
						for(int j = 0; j < m_arrCommand.GetSize(); j++)
						{
							if(m_arrCommand[j] == mii.wID)
							{
								pMI->iButton = j;
								break;
							}
						}
						pMI->lpstrText = NULL;
						ATLTRY(pMI->lpstrText = new TCHAR[lstrlen(szString) + 1]);
						ATLASSERT(pMI->lpstrText != NULL);
						if(pMI->lpstrText != NULL)
							lstrcpy(pMI->lpstrText, szString);
						mii.dwItemData = (ULONG_PTR)pMI;
						bRet = menuPopup.SetMenuItemInfo(i, TRUE, &mii);
						ATLASSERT(bRet);
					}
				}
			}

			// Add it to the list
			m_stackMenuHandle.Push(menuPopup.m_hMenu);
		}

		return lRet;
	}

	LRESULT OnMenuSelect(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		if(!m_bAttachedMenu)	// Not attached, do nothing, forward to parent
		{
			m_bPopupItem = (lParam != NULL) && ((HMENU)lParam != m_hMenu) && (HIWORD(wParam) & MF_POPUP);
			if(m_wndParent.IsWindow())
				m_wndParent.SendMessage(uMsg, wParam, lParam);
			bHandled = FALSE;
			return 1;
		}

		// Check if a menu is closing, do a cleanup
		if(HIWORD(wParam) == 0xFFFF && lParam == NULL)	// Menu closing
		{
#ifdef _CMDBAR_EXTRA_TRACE
			ATLTRACE2(atlTraceUI, 0, "CmdBar - OnMenuSelect - CLOSING!!!!\n");
#endif
			ATLASSERT(m_stackMenuWnd.GetSize() == 0);
			// Restore the menu items to the previous state for all menus that were converted
			if(m_bImagesVisible)
			{
				HMENU hMenu;
				while((hMenu = m_stackMenuHandle.Pop()) != NULL)
				{
					CMenuHandle menuPopup = hMenu;
					ATLASSERT(menuPopup.m_hMenu != NULL);
					// Restore state and delete menu item data
					BOOL bRet;
					for(int i = 0; i < menuPopup.GetMenuItemCount(); i++)
					{
						CMenuItemInfo mii;
						mii.fMask = MIIM_DATA | MIIM_TYPE;
						bRet = menuPopup.GetMenuItemInfo(i, TRUE, &mii);
						ATLASSERT(bRet);

						_MenuItemData* pMI = (_MenuItemData*)mii.dwItemData;
						if(pMI != NULL && pMI->IsCmdBarMenuItem())
						{
							mii.fMask = MIIM_DATA | MIIM_TYPE | MIIM_STATE;
							mii.fType = pMI->fType;
							mii.dwTypeData = pMI->lpstrText;
							mii.cch = lstrlen(pMI->lpstrText);
							mii.dwItemData = NULL;

							bRet = menuPopup.SetMenuItemInfo(i, TRUE, &mii);
							ATLASSERT(bRet);

							delete [] pMI->lpstrText;
							pMI->dwMagic = 0x6666;
							delete pMI;
						}
					}
				}
			}
		}

		bHandled = FALSE;
		return 1;
	}

	LRESULT OnInternalAutoPopup(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		int nIndex = (int)wParam;
		DoPopupMenu(nIndex, false);
		return 0;
	}

	LRESULT OnInternalGetBar(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		// Let's make sure we're not embedded in another process
		if(wParam && !::IsBadWritePtr((LPVOID)wParam, sizeof DWORD))
			*((DWORD*)wParam) = GetCurrentProcessId();
		if(IsWindowVisible())
			return (LRESULT)static_cast<CCommandBarCtrlBase*>(this);
		else
			return NULL;
	}

	LRESULT OnSettingChange(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		GetSystemSettings();
		return 0;
	}

	LRESULT OnWindowPosChanging(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
	{
		LRESULT lRet = DefWindowProc(uMsg, wParam, lParam);

		LPWINDOWPOS lpWP = (LPWINDOWPOS)lParam;
		int cyMin = ::GetSystemMetrics(SM_CYMENU);
		if(lpWP->cy < cyMin)
		lpWP->cy = cyMin;

		return lRet;
	}

	LRESULT OnMenuChar(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
#ifdef _CMDBAR_EXTRA_TRACE
		ATLTRACE2(atlTraceUI, 0, "CmdBar - OnMenuChar\n");
#endif
		bHandled = TRUE;
		LRESULT lRet;

		if(m_bMenuActive && LOWORD(wParam) != 0x0D)
			lRet = 0;
		else
			lRet = MAKELRESULT(1, 1);
		if(m_bMenuActive && HIWORD(wParam) == MF_POPUP)
		{
			// Convert character to lower/uppercase and possibly Unicode, using current keyboard layout
			TCHAR ch = (TCHAR)LOWORD(wParam);
			CMenuHandle menu = (HMENU)lParam;
			int nCount = ::GetMenuItemCount(menu);
			int nRetCode = MNC_EXECUTE;
			BOOL bRet;
			TCHAR szString[_nMaxMenuItemTextLength];
			WORD wMnem = 0;
			bool bFound = false;
			for(int i = 0; i < nCount; i++)
			{
				CMenuItemInfo mii;
				mii.cch = _nMaxMenuItemTextLength;
				mii.fMask = MIIM_CHECKMARKS | MIIM_DATA | MIIM_ID | MIIM_STATE | MIIM_SUBMENU | MIIM_TYPE;
				mii.dwTypeData = szString;
				bRet = menu.GetMenuItemInfo(i, TRUE, &mii);
				if(!bRet || (mii.fType & MFT_SEPARATOR))
					continue;
				_MenuItemData* pmd = (_MenuItemData*)mii.dwItemData;
				if(pmd != NULL && pmd->IsCmdBarMenuItem())
				{
					LPTSTR p = pmd->lpstrText;

					if(p != NULL)
					{
						while(*p && *p != _T('&'))
							p = ::CharNext(p);
						if(p != NULL && *p)
						{
							TCHAR szP[2] = { *(++p), 0 };
							TCHAR szC[2] = { ch, 0 };
							if(p != NULL && ::CharLower(szP) == ::CharLower(szC))
							{
								if(!bFound)
								{
									wMnem = (WORD)i;
									bFound = true;
									PostMessage(TB_SETHOTITEM, (WPARAM)-1, 0L);
									GiveFocusBack();
								}
								else
								{
									nRetCode = MNC_SELECT;
									break;
								}
							}
						}
					}
				}
			}
			if(bFound)
			{
				bHandled = TRUE;
				lRet = MAKELRESULT(wMnem, nRetCode);
			}
		} 
		else if(!m_bMenuActive)
		{
			UINT nID;
			if(0 == SendMessage(TB_MAPACCELERATOR, LOWORD(wParam), (LPARAM)&nID))
			{
				bHandled = FALSE;
				PostMessage(TB_SETHOTITEM, (WPARAM)-1, 0L);
				GiveFocusBack();
			}
			else if(m_wndParent.IsWindowEnabled())
			{
				TakeFocus();
				PostMessage(WM_KEYDOWN, VK_DOWN, 0L);
				SetHotItem(nID);
			}
		}

		return lRet;
	}

	LRESULT OnDrawItem(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
	{
		LPDRAWITEMSTRUCT lpDrawItemStruct = (LPDRAWITEMSTRUCT)lParam;
		_MenuItemData* pmd = (_MenuItemData*)lpDrawItemStruct->itemData;
		if(lpDrawItemStruct->CtlType == ODT_MENU && pmd->IsCmdBarMenuItem())
			DrawItem(lpDrawItemStruct);
		else
			bHandled = FALSE;
		return (LRESULT)TRUE;
	}

	LRESULT OnMeasureItem(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
	{
		LPMEASUREITEMSTRUCT lpMeasureItemStruct = (LPMEASUREITEMSTRUCT)lParam;
		_MenuItemData* pmd = (_MenuItemData*)lpMeasureItemStruct->itemData;
		if(lpMeasureItemStruct->CtlType == ODT_MENU && pmd->IsCmdBarMenuItem())
			MeasureItem(lpMeasureItemStruct);
		else
			bHandled = FALSE;
		return (LRESULT)TRUE;
	}

// API message handlers
	LRESULT OnAPIGetMenu(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		return (LRESULT)m_hMenu;
	}

	LRESULT OnAPITrackPopupMenu(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& /*bHandled*/)
	{
		if(lParam == NULL)
			return FALSE;
		LPCBRPOPUPMENU lpCBRPopupMenu = (LPCBRPOPUPMENU)lParam;
		if(lpCBRPopupMenu->cbSize != sizeof(CBRPOPUPMENU))
			return FALSE;
		if(!::IsMenu(lpCBRPopupMenu->hMenu))
			return FALSE;

		m_bContextMenu = true;
		return DoTrackPopupMenu(lpCBRPopupMenu->hMenu, lpCBRPopupMenu->uFlags, lpCBRPopupMenu->x, lpCBRPopupMenu->y, lpCBRPopupMenu->lptpm);
	}

	LRESULT OnAPIGetCmdBar(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		return (LRESULT)m_hWnd;
	}

// Parent window message handlers
	// Do not hot track if application in background, OK for modeless dialogs
	LRESULT OnParentHotItemChange(int /*idCtrl*/, LPNMHDR pnmh, BOOL& bHandled)
	{
		DWORD dwProcessID;
		::GetWindowThreadProcessId(::GetActiveWindow(), &dwProcessID);

		LPNMTBHOTITEM lpNMHT = (LPNMTBHOTITEM)pnmh;

		// Check if this comes from us
		if(pnmh->hwndFrom != m_hWnd)
		{
			bHandled = FALSE;
			return 0;
		}

		if((!m_wndParent.IsWindowEnabled() || ::GetCurrentProcessId() != dwProcessID) && lpNMHT->dwFlags & HICF_MOUSE)
			return 1;
		else
		{
			bHandled = FALSE;

			// Send WM_MENUSELECT to the app if it needs to display a status text
			if(!(lpNMHT->dwFlags & HICF_MOUSE)	
				&& !(lpNMHT->dwFlags & HICF_ACCELERATOR)
				&& !(lpNMHT->dwFlags & HICF_LMOUSE))
			{
				if(lpNMHT->dwFlags & HICF_ENTERING)
					m_wndParent.SendMessage(WM_MENUSELECT, 0, (LPARAM)m_hMenu);
				if(lpNMHT->dwFlags & HICF_LEAVING)
					m_wndParent.SendMessage(WM_MENUSELECT, MAKEWPARAM(0, 0xFFFF), NULL);
			}

			return 0;
		}
	}

	LRESULT OnParentDropDown(int /*idCtrl*/, LPNMHDR pnmh, BOOL& bHandled)
	{
		// Check if this comes from us
		if(pnmh->hwndFrom != m_hWnd)
		{
			bHandled = FALSE;
			return 1;
		}

		if(::GetFocus() != m_hWnd)
			TakeFocus();
		LPNMTOOLBAR pNMToolBar = (LPNMTOOLBAR)pnmh;
		int nIndex = CommandToIndex(pNMToolBar->iItem);
		m_bContextMenu = false;
		m_bEscapePressed = false;
		DoPopupMenu(nIndex, true);

		return TBDDRET_DEFAULT;
	}

	LRESULT OnParentInitMenuPopup(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		return OnInitMenuPopup(uMsg, wParam, lParam, bHandled);
	}

	LRESULT OnParentSettingChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		return OnSettingChange(uMsg, wParam, lParam, bHandled);
	}

	LRESULT OnParentInternalGetBar(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		return OnInternalGetBar(uMsg, wParam, lParam, bHandled);
	}

	LRESULT OnParentSysCommand(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
		bHandled = FALSE;
		if((m_uSysKey == VK_MENU 
			|| (m_uSysKey == VK_F10 && !(::GetKeyState(VK_SHIFT) & 0x80))
			|| m_uSysKey == VK_SPACE) 
			&& wParam == SC_KEYMENU)
		{
			if(::GetFocus() == m_hWnd)
			{
				GiveFocusBack();		// exit menu "loop"
				PostMessage(TB_SETHOTITEM, (WPARAM)-1, 0L);
			}
			else if(m_uSysKey != VK_SPACE && !m_bSkipMsg)
			{
				TakeFocus();			// enter menu "loop"
				bHandled = TRUE;
			}
			else if(m_uSysKey != VK_SPACE)
			{
				bHandled = TRUE;
			}
		}
		m_bSkipMsg = false;
		return 0;
	}

	LRESULT OnParentAPIGetMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		return OnAPIGetMenu(uMsg, wParam, lParam, bHandled);
	}

	LRESULT OnParentMenuChar(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		return OnMenuChar(uMsg, wParam, lParam, bHandled);
	}

	LRESULT OnParentAPITrackPopupMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		return OnAPITrackPopupMenu(uMsg, wParam, lParam, bHandled);
	}

	LRESULT OnParentAPIGetCmdBar(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		return OnAPIGetCmdBar(uMsg, wParam, lParam, bHandled);
	}

	LRESULT OnParentDrawItem(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		return OnDrawItem(uMsg, wParam, lParam, bHandled);
	}

	LRESULT OnParentMeasureItem(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		return OnMeasureItem(uMsg, wParam, lParam, bHandled);
	}

// MDI client window message handlers
	LRESULT OnMDISetMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
	{
		m_wndMDIClient.DefWindowProc(uMsg, NULL, lParam);
		HMENU hOldMenu = GetMenu();
		BOOL bRet = AttachMenu((HMENU)wParam);
		bRet;
		ATLASSERT(bRet);
		return (LRESULT)hOldMenu;
	}

// Message hook handlers
	LRESULT OnHookMouseMove(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		static POINT s_point = { -1, -1 };
		DWORD dwPoint = ::GetMessagePos();
		POINT point = { GET_X_LPARAM(dwPoint), GET_Y_LPARAM(dwPoint) };

		bHandled = FALSE;
		if(m_bMenuActive)
		{
			if(::WindowFromPoint(point) == m_hWnd)
			{
				ScreenToClient(&point);
				int nHit = HitTest(&point);

				if((point.x != s_point.x || point.y != s_point.y) && nHit >= 0 && nHit < ::GetMenuItemCount(m_hMenu) && nHit != m_nPopBtn && m_nPopBtn != -1)
				{
					m_nNextPopBtn = nHit | 0xFFFF0000;
					HWND hWndMenu = m_stackMenuWnd.GetCurrent();
					ATLASSERT(hWndMenu != NULL);

					// this one is needed to close a menu if mouse button was down
					::PostMessage(hWndMenu, WM_LBUTTONUP, 0, MAKELPARAM(point.x, point.y));
					// this one closes a popup menu
					::PostMessage(hWndMenu, WM_KEYDOWN, VK_ESCAPE, 0L);

					bHandled = TRUE;
				}
			}
		}
		else
		{
			ScreenToClient(&point);
		}

		s_point = point;
		return 0;
	}

	LRESULT OnHookSysKeyDown(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
		bHandled = FALSE;
#ifdef _CMDBAR_EXTRA_TRACE
		ATLTRACE2(atlTraceUI, 0, "CmdBar - Hook WM_SYSKEYDOWN (0x%2.2X)\n", wParam);
#endif

		if(wParam != VK_SPACE && (!m_bMenuActive && ::GetFocus() == m_hWnd) || m_bMenuActive)
		{
			PostMessage(TB_SETHOTITEM, (WPARAM)-1, 0L);
			GiveFocusBack();
			if(!m_bMenuActive)
				m_bSkipMsg = true;
		}
		else
		{
			m_uSysKey = (UINT)wParam;
		}
		return 0;
	}

	LRESULT OnHookSysKeyUp(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
		bHandled = FALSE;
		wParam;
#ifdef _CMDBAR_EXTRA_TRACE
		ATLTRACE2(atlTraceUI, 0, "CmdBar - Hook WM_SYSKEYUP (0x%2.2X)\n", wParam);
#endif
		return 0;
	}

	LRESULT OnHookSysChar(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
		bHandled = FALSE;
#ifdef _CMDBAR_EXTRA_TRACE
		ATLTRACE2(atlTraceUI, 0, "CmdBar - Hook WM_SYSCHAR (0x%2.2X)\n", wParam);
#endif

		if(!m_bMenuActive && m_hWndHook != m_hWnd && wParam != VK_SPACE)
			bHandled = TRUE;
		return 0;
	}

	LRESULT OnHookKeyDown(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
#ifdef _CMDBAR_EXTRA_TRACE
		ATLTRACE2(atlTraceUI, 0, "CmdBar - Hook WM_KEYDOWN (0x%2.2X)\n", wParam);
#endif
		bHandled = FALSE;

		if(wParam == VK_ESCAPE)
		{
			if(m_bMenuActive && !m_bContextMenu)
			{
				int nHot = GetHotItem();
				if(nHot == -1)
					nHot = m_nPopBtn;
				if(nHot == -1)
					nHot = 0;
				SetHotItem(nHot);
				bHandled = TRUE;
				TakeFocus();
				m_bEscapePressed = true; // To keep focus
			}
			else if(::GetFocus() == m_hWnd && m_wndParent.IsWindow())
			{
				SetHotItem(-1);
				GiveFocusBack();
				bHandled = TRUE;
			}
		}
		else if(wParam == VK_RETURN || wParam == VK_UP || wParam == VK_DOWN)
		{
			if(!m_bMenuActive && ::GetFocus() == m_hWnd && m_wndParent.IsWindow())
			{
				int nHot = GetHotItem();
				if(nHot != -1)
				{
					if(wParam != VK_RETURN)
						PostMessage(WM_KEYDOWN, VK_DOWN, 0L);
				}
				else
				{
					ATLTRACE2(atlTraceUI, 0, "CmdBar - Can't find hot button\n");
				}
			}
			if(wParam == VK_RETURN && m_bMenuActive)
			{
				PostMessage(TB_SETHOTITEM, (WPARAM)-1, 0L);
				m_nNextPopBtn = -1;
				GiveFocusBack();
			}
		}
		else if(wParam == VK_LEFT || wParam == VK_RIGHT)
		{
			if(m_bMenuActive && !(wParam == VK_RIGHT && m_bPopupItem))
			{
				bool bAction = false;
				int nCount = ::GetMenuItemCount(m_hMenu);

				if(wParam == VK_LEFT && s_pCurrentBar->m_stackMenuWnd.GetSize() == 1)
				{
					bAction = true;
					m_nNextPopBtn = m_nPopBtn - 1;
					if(m_nNextPopBtn < 0)
						m_nNextPopBtn = nCount - 1;
				}
				else if(wParam == VK_RIGHT)
				{
					bAction = true;
					m_nNextPopBtn = m_nPopBtn + 1;
					if(m_nNextPopBtn >= nCount)
						m_nNextPopBtn = 0;
				}
				HWND hWndMenu = m_stackMenuWnd.GetCurrent();
				ATLASSERT(hWndMenu != NULL);

				// Close the popup menu
				if(bAction)
				{
					::PostMessage(hWndMenu, WM_KEYDOWN, VK_ESCAPE, 0L);
					if(wParam == VK_RIGHT)
					{
						int cItem = m_stackMenuWnd.GetSize() - 1;
						while(cItem >= 0)
						{
							hWndMenu = m_stackMenuWnd[cItem];
							if(hWndMenu)
							{
								::PostMessage(hWndMenu, WM_KEYDOWN, VK_ESCAPE, 0L);
							}
							cItem--;
						}
					}
					bHandled = TRUE;
				}
			}
		}
		return 0;
	}

	LRESULT OnHookNextMenu(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
#ifdef _CMDBAR_EXTRA_TRACE
		ATLTRACE2(atlTraceUI, 0, "CmdBar - Hook WM_NEXTMENU\n");
#endif
		bHandled = FALSE;
		return 1;
	}

 	LRESULT OnHookChar(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
#ifdef _CMDBAR_EXTRA_TRACE
		ATLTRACE2(atlTraceUI, 0, "CmdBar - Hook WM_CHAR (0x%2.2X)\n", wParam);
#endif
		bHandled = (wParam == VK_ESCAPE);
		if(wParam != VK_ESCAPE && wParam != VK_RETURN && m_bMenuActive)
		{
			SetHotItem(-1);
			GiveFocusBack();
		}
		return 0;
	}

// Implementation - ownerdraw overrideables and helpers
	void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
	{
		_MenuItemData* pmd = (_MenuItemData*)lpDrawItemStruct->itemData;
		CDCHandle dc = lpDrawItemStruct->hDC;
		const RECT& rcItem = lpDrawItemStruct->rcItem;

		if(pmd->fType & MFT_SEPARATOR)
		{
			// draw separator
			RECT rc = rcItem;
			rc.top += (rc.bottom - rc.top) / 2;	// vertical center
			dc.DrawEdge(&rc, EDGE_ETCHED, BF_TOP);	// draw separator line
		}
		else		// not a separator
		{
			BOOL bDisabled = lpDrawItemStruct->itemState & ODS_GRAYED;
			BOOL bSelected = lpDrawItemStruct->itemState & ODS_SELECTED;
			BOOL bChecked = lpDrawItemStruct->itemState & ODS_CHECKED;
			BOOL bHasImage = FALSE;

			if(LOWORD(lpDrawItemStruct->itemID) == (WORD)-1)
				bSelected = FALSE;
			RECT rcButn = { rcItem.left, rcItem.top, rcItem.left + m_szButton.cx, rcItem.top + m_szButton.cy };			// button rect
			::OffsetRect(&rcButn, 0, ((rcItem.bottom - rcItem.top) - (rcButn.bottom - rcButn.top)) / 2);	// center vertically

			int iButton = pmd->iButton;
			if(iButton >= 0)
			{
				bHasImage = TRUE;

				// calc drawing point
				SIZE sz = { rcButn.right - rcButn.left - m_szBitmap.cx, rcButn.bottom - rcButn.top - m_szBitmap.cy };
				sz.cx /= 2;
				sz.cy /= 2;
				POINT point = { rcButn.left + sz.cx, rcButn.top + sz.cy };

				// draw disabled or normal
				if(!bDisabled)
				{
					// normal - fill background depending on state
					if(!bChecked || bSelected)
						dc.FillRect(&rcButn, (HBRUSH)LongToPtr((bChecked && !bSelected) ? (COLOR_3DLIGHT + 1) : (COLOR_MENU + 1)));
					else
					{
						COLORREF crTxt = dc.SetTextColor(::GetSysColor(COLOR_BTNFACE));
						COLORREF crBk = dc.SetBkColor(::GetSysColor(COLOR_BTNHILIGHT));
						CBrush hbr(CDCHandle::GetHalftoneBrush());
						dc.SetBrushOrg(rcButn.left, rcButn.top);
						dc.FillRect(&rcButn, hbr);
						
						dc.SetTextColor(crTxt);
						dc.SetBkColor(crBk);
					}

					// draw pushed-in or popped-out edge
					if(bSelected || bChecked)
					{
						RECT rc2 = rcButn;
						dc.DrawEdge(&rc2, bChecked ? BDR_SUNKENOUTER : BDR_RAISEDINNER, BF_RECT);
					}
					// draw the image
					::ImageList_Draw(m_hImageList, iButton, dc, point.x, point.y, ILD_TRANSPARENT);
				}
				else
				{
					DrawBitmapDisabled(dc, iButton, point);
				}
			}
			else
			{
				// no image - look for custom checked/unchecked bitmaps
				CMenuItemInfo info;
				info.fMask = MIIM_CHECKMARKS;
				::GetMenuItemInfo((HMENU)lpDrawItemStruct->hwndItem, lpDrawItemStruct->itemID, MF_BYCOMMAND, &info);
				if(bChecked || info.hbmpUnchecked)
					bHasImage = Draw3DCheckmark(dc, rcButn, bSelected, bChecked ? info.hbmpChecked : info.hbmpUnchecked);
			}

			// draw item text
			int cxButn = m_szButton.cx;
			COLORREF colorBG = ::GetSysColor(bSelected ? COLOR_HIGHLIGHT : COLOR_MENU);
			if(bSelected || lpDrawItemStruct->itemAction == ODA_SELECT)
			{
				RECT rcBG = rcItem;
				if(bHasImage)
					rcBG.left += cxButn + s_kcxGap;
				dc.FillRect(&rcBG, (HBRUSH)LongToPtr(bSelected ? (COLOR_HIGHLIGHT + 1) : (COLOR_MENU + 1)));
			}

			// calc text rectangle and colors
			RECT rcText = rcItem;
			rcText.left += cxButn + s_kcxGap + s_kcxTextMargin;
			rcText.right -= cxButn;
			dc.SetBkMode(TRANSPARENT);
			COLORREF colorText = ::GetSysColor(bDisabled ?  COLOR_GRAYTEXT : (bSelected ? COLOR_HIGHLIGHTTEXT : COLOR_MENUTEXT));

			// font already selected by Windows
			if(bDisabled && (!bSelected || colorText == colorBG))
			{
				// disabled - draw shadow text shifted down and right 1 pixel (unles selected)
				RECT rcDisabled = rcText;
				::OffsetRect(&rcDisabled, 1, 1);
				DrawMenuText(dc, rcDisabled, pmd->lpstrText, GetSysColor(COLOR_3DHILIGHT));
			}
			DrawMenuText(dc, rcText, pmd->lpstrText, colorText); // finally!
		}
	}

	void DrawMenuText(CDCHandle& dc, RECT& rc, LPCTSTR lpstrText, COLORREF color)
	{
		int nTab = -1;
		for(int i = 0; i < lstrlen(lpstrText); i++)
		{
			if(lpstrText[i] == '\t')
			{
				nTab = i;
				break;
			}
		}
		dc.SetTextColor(color);
		dc.DrawText(lpstrText, nTab, &rc, DT_SINGLELINE | DT_LEFT | DT_VCENTER);
		if(nTab != -1)
			dc.DrawText(&lpstrText[nTab + 1], -1, &rc, DT_SINGLELINE | DT_RIGHT | DT_VCENTER);
	}

	void DrawBitmapDisabled(CDCHandle& dc, int nImage, POINT point)
	{
		// create memory DC
		CDC dcMem;
		dcMem.CreateCompatibleDC(dc);
		// create mono or color bitmap
		CBitmap bmp;
		bmp.CreateCompatibleBitmap(dc, m_szBitmap.cx, m_szBitmap.cy);
		ATLASSERT(bmp.m_hBitmap != NULL);
		// draw image into memory DC--fill BG white first
		HBITMAP hBmpOld = dcMem.SelectBitmap(bmp);
		dcMem.PatBlt(0, 0, m_szBitmap.cx, m_szBitmap.cy, WHITENESS);
		// If white is the text color, we can't use the normal painting since
		// it would blend with the WHITENESS, but the mask is OK
		UINT uDrawStyle = (::GetSysColor(COLOR_BTNTEXT) == RGB(255, 255, 255)) ? ILD_MASK : ILD_NORMAL;
		::ImageList_Draw(m_hImageList, nImage, dcMem, 0, 0, uDrawStyle);
		dc.DitherBlt(point.x, point.y, m_szBitmap.cx, m_szBitmap.cy, dcMem, NULL, 0, 0);
		dcMem.SelectBitmap(hBmpOld);		// restore
	}

	BOOL Draw3DCheckmark(CDCHandle& dc, const RECT& rc, BOOL bSelected, HBITMAP hBmpCheck)
	{
		// get checkmark bitmap if none, use Windows standard
		CBitmapHandle bmp = hBmpCheck;
		if(hBmpCheck == NULL)
		{
			bmp.LoadOEMBitmap(OBM_CHECK);
			ATLASSERT(bmp.m_hBitmap != NULL);
		}
		// center bitmap in caller's rectangle
		SIZE size = { 0, 0 };
		bmp.GetSize(size);
		RECT rcDest = rc;
		POINT p = { 0, 0 };
		SIZE szDelta = { (rc.right - rc.left - size.cx) / 2, (rc.bottom - rc.top - size.cy) / 2 };
		if(rc.right - rc.left > size.cx)
		{
			rcDest.left = rc.left + szDelta.cx;
			rcDest.top = rc.top + szDelta.cy;
			rcDest.right = rcDest.left + size.cx;
			rcDest.bottom = rcDest.top + size.cy;
		}
		else
		{
			p.x -= szDelta.cx;
			p.y -= szDelta.cy;
		}
		// select checkmark into memory DC
		CDC dcMem;
		dcMem.CreateCompatibleDC(dc);
		HBITMAP hBmpOld = dcMem.SelectBitmap(bmp);
		if(bSelected)
		{
			dc.FillRect(&rcDest, (HBRUSH)LongToPtr((bSelected ? COLOR_MENU : COLOR_3DLIGHT) + 1));
		}
		else
		{
			COLORREF crTxt = dc.SetTextColor(::GetSysColor(COLOR_BTNFACE));
			COLORREF crBk = dc.SetBkColor(::GetSysColor(COLOR_BTNHILIGHT));
			CBrush hbr(CDCHandle::GetHalftoneBrush());
			dc.SetBrushOrg(rcDest.left, rcDest.top);
			dc.FillRect(&rcDest, hbr);
			dc.SetTextColor(crTxt);
			dc.SetBkColor(crBk);
		}
		// draw the check bitmap transparently
		COLORREF crOldBack = dc.SetBkColor(RGB(255, 255, 255));
		COLORREF crOldText = dc.SetTextColor(RGB(0, 0, 0));
		CDC dcTrans;
		// create two memory dcs for the image and the mask
		dcTrans.CreateCompatibleDC(dc);
		// create the mask bitmap	
		CBitmap bitmapTrans;	
		int nWidth = rcDest.right - rcDest.left;
		int nHeight = rcDest.bottom - rcDest.top;	
		bitmapTrans.CreateBitmap(nWidth, nHeight, 1, 1, NULL);
		// select the mask bitmap into the appropriate dc
		dcTrans.SelectBitmap(bitmapTrans);
		// build mask based on transparent color	
		dcMem.SetBkColor(m_clrMask);
		dcTrans.SetBkColor(RGB(0, 0, 0));
		dcTrans.SetTextColor(RGB(255, 255, 255));
		dcTrans.BitBlt(0, 0, nWidth, nHeight, dcMem, p.x, p.y, SRCCOPY);
		dc.BitBlt(rcDest.left, rcDest.top, nWidth, nHeight, dcMem, p.x, p.y, SRCINVERT);
		dc.BitBlt(rcDest.left, rcDest.top, nWidth, nHeight, dcTrans, 0, 0, SRCAND);
		dc.BitBlt(rcDest.left, rcDest.top, nWidth, nHeight, dcMem, p.x, p.y, SRCINVERT);
		// restore settings	
		dc.SetBkColor(crOldBack);
		dc.SetTextColor(crOldText);			
		dcMem.SelectBitmap(hBmpOld);		// restore
		// draw pushed-in hilight
		if(rc.right - rc.left > size.cx)
			::InflateRect(&rcDest, 1,1);	// inflate checkmark by one pixel all around
		dc.DrawEdge(&rcDest, BDR_SUNKENOUTER, BF_RECT);

		return TRUE;
	}

	void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct)
	{
		_MenuItemData* pmd = (_MenuItemData*)lpMeasureItemStruct->itemData;

		if(pmd->fType & MFT_SEPARATOR)	// separator - use half system height and zero width
		{
			lpMeasureItemStruct->itemHeight = ::GetSystemMetrics(SM_CYMENU) / 2;
			lpMeasureItemStruct->itemWidth  = 0;
		}
		else
		{
			// compute size of text - use DrawText with DT_CALCRECT
			CWindowDC dc(NULL);
			HFONT hOldFont;
			if(pmd->fState & MFS_DEFAULT)
			{
				// need bold version of font
				LOGFONT lf;
				m_fontMenu.GetLogFont(lf);
				lf.lfWeight += 200;
				CFont fontBold;
				fontBold.CreateFontIndirect(&lf);
				ATLASSERT(fontBold.m_hFont != NULL);
				hOldFont = dc.SelectFont(fontBold);
			}
			else
			{
				hOldFont = dc.SelectFont(m_fontMenu);
			}

			RECT rcText = { 0, 0, 0, 0 };
			dc.DrawText(pmd->lpstrText, -1, &rcText, DT_SINGLELINE | DT_LEFT | DT_VCENTER | DT_CALCRECT);
			int cx = rcText.right - rcText.left;
			dc.SelectFont(hOldFont);

			LOGFONT lf;
			m_fontMenu.GetLogFont(lf);
			int cy = lf.lfHeight;
			if(cy < 0)
				cy = -cy;
			cy += 8;

			// height of item is the bigger of these two
			lpMeasureItemStruct->itemHeight = max(cy, m_szButton.cy);

			// width is width of text plus a bunch of stuff
			cx += 2 * s_kcxTextMargin;	// L/R margin for readability
			cx += s_kcxGap;			// space between button and menu text
			cx += 2 * m_szButton.cx;	// button width (L=button; R=empty margin)

			// Windows adds 1 to returned value
			cx -= ::GetSystemMetrics(SM_CXMENUCHECK) - 1;
			lpMeasureItemStruct->itemWidth = cx;		// done deal
		}
	}

// Implementation - Hook procs
	static LRESULT CALLBACK CreateHookProc(int nCode, WPARAM wParam, LPARAM lParam)
	{
		LRESULT lRet = 0;
		TCHAR szClassName[7];

		if(nCode == HCBT_CREATEWND)
		{
			HWND hWndMenu = (HWND)wParam;
#ifdef _CMDBAR_EXTRA_TRACE
			ATLTRACE2(atlTraceUI, 0, "CmdBar - HCBT_CREATEWND (HWND = %8.8X)\n", hWndMenu);
#endif

			::GetClassName(hWndMenu, szClassName, 7);
			if(!lstrcmp(_T("#32768"), szClassName))
				s_pCurrentBar->m_stackMenuWnd.Push(hWndMenu);
		}
		else if(nCode == HCBT_DESTROYWND)
		{
			HWND hWndMenu = (HWND)wParam;
#ifdef _CMDBAR_EXTRA_TRACE
			ATLTRACE2(atlTraceUI, 0, "CmdBar - HCBT_DESTROYWND (HWND = %8.8X)\n", hWndMenu);
#endif

			::GetClassName(hWndMenu, szClassName, 7);
			if(!lstrcmp(_T("#32768"), szClassName))
			{
				ATLASSERT(hWndMenu == s_pCurrentBar->m_stackMenuWnd.GetCurrent());
				s_pCurrentBar->m_stackMenuWnd.Pop();
			}
		}
		else if(nCode < 0)
		{
			lRet = ::CallNextHookEx(s_hCreateHook, nCode, wParam, lParam);
		}
		return lRet;
	}

	static LRESULT CALLBACK MessageHookProc(int nCode, WPARAM wParam, LPARAM lParam)
	{
		LPMSG pMsg = (LPMSG)lParam;

		if(nCode == HC_ACTION && wParam == PM_REMOVE && pMsg->message != GetGetBarMessage() && pMsg->message != WM_FORWARDMSG)
		{
			CCommandBarCtrlBase* pCmdBar = NULL;
			HWND hWnd = pMsg->hwnd;
			DWORD dwPID = 0;
			while(pCmdBar == NULL && hWnd != NULL)
			{
				pCmdBar = (CCommandBarCtrlBase*)::SendMessage(hWnd, GetGetBarMessage(), (WPARAM)&dwPID, 0L);
				hWnd = ::GetParent(hWnd);
			}

			if(pCmdBar != NULL && dwPID == GetCurrentProcessId())
			{
				pCmdBar->m_hWndHook = pMsg->hwnd;
				ATLASSERT(pCmdBar->IsCommandBarBase());

				if(::IsWindow(pCmdBar->m_hWnd))
					pCmdBar->SendMessage(WM_FORWARDMSG, 0, (LPARAM)pMsg);
				else
					ATLTRACE2(atlTraceUI, 0, "CmdBar - Hook skipping message, can't find command bar!\n");
			}
		}

		LRESULT lRet = 0;
		ATLASSERT(s_pmapMsgHook != NULL);
		if(s_pmapMsgHook != NULL)
		{
			DWORD dwThreadID = ::GetCurrentThreadId();
			_MsgHookData* pData = s_pmapMsgHook->Lookup(dwThreadID);
			if(pData != NULL)
			{
				lRet = ::CallNextHookEx(pData->hMsgHook, nCode, wParam, lParam);
			}
		}
		return lRet;
	}

// Implementation
	void DoPopupMenu(int nIndex, bool bAnimate)
	{
#ifdef _CMDBAR_EXTRA_TRACE
		ATLTRACE2(atlTraceUI, 0, "CmdBar - DoPopupMenu, bAnimate = %s\n", bAnimate ? "true" : "false");
#endif

		// get popup menu and it's position
		RECT rect;
		GetItemRect(nIndex, &rect);
		ClientToScreen(&rect);
		TPMPARAMS TPMParams;
		TPMParams.cbSize = sizeof(TPMPARAMS);
		TPMParams.rcExclude = rect;
		HMENU hMenuPopup = ::GetSubMenu(m_hMenu, nIndex);

		// get button ID
		TBBUTTON tbb;
		GetButton(nIndex, &tbb);
		int nCmdID = tbb.idCommand;

		m_nPopBtn = nIndex;	// remember current button's index

		// press button and display popup menu
		PressButton(nCmdID, TRUE);
		SetHotItem(nCmdID);
		DoTrackPopupMenu(hMenuPopup, TPM_LEFTBUTTON | TPM_VERTICAL | TPM_LEFTALIGN | TPM_TOPALIGN |
			(s_bW2K ? (bAnimate ? TPM_VERPOSANIMATION : TPM_NOANIMATION) : 0), rect.left, rect.bottom, &TPMParams);
		PressButton(nCmdID, FALSE);
		if(::GetFocus() != m_hWnd)
			SetHotItem(-1);

		m_nPopBtn = -1;		// restore

		// eat next message if click is on the same button
		MSG msg;
		if(::PeekMessage(&msg, m_hWnd, NULL, NULL, PM_NOREMOVE))
		{
			if(msg.message == WM_LBUTTONDOWN && ::PtInRect(&rect, msg.pt))
				::PeekMessage(&msg, m_hWnd, WM_LBUTTONDOWN, WM_LBUTTONDOWN, PM_REMOVE);
		}

		// check if another popup menu should be displayed
		if(m_nNextPopBtn != -1)
		{
			PostMessage(GetAutoPopupMessage(), m_nNextPopBtn & 0xFFFF);
			if(!(m_nNextPopBtn & 0xFFFF0000) && !m_bPopupItem)
				PostMessage(WM_KEYDOWN, VK_DOWN, 0);
			m_nNextPopBtn = -1;
		}
		else
		{
			m_bContextMenu = false;
			// If user didn't hit escape, give focus back
			if(!m_bEscapePressed)
				GiveFocusBack();
			else
			{
				SetHotItem(nCmdID);
				SendMessage(TB_SETANCHORHIGHLIGHT, TRUE, 0);
			}
		}
	}

	BOOL DoTrackPopupMenu(HMENU hMenu, UINT uFlags, int x, int y, LPTPMPARAMS lpParams = NULL)
	{
		CMenuHandle menuPopup = hMenu;

		::EnterCriticalSection(&_Module.m_csWindowCreate);

		ATLASSERT(s_hCreateHook == NULL);

		s_pCurrentBar = static_cast<CCommandBarCtrlBase*>(this);

		s_hCreateHook = ::SetWindowsHookEx(WH_CBT, CreateHookProc, _Module.GetModuleInstance(), GetCurrentThreadId());
		ATLASSERT(s_hCreateHook != NULL);

		m_bPopupItem = false;
		m_bMenuActive = true;

		BOOL bTrackRet = menuPopup.TrackPopupMenuEx(uFlags, x, y, m_hWnd, lpParams);
		m_bMenuActive = false;

		::UnhookWindowsHookEx(s_hCreateHook);

		s_hCreateHook = NULL;
		s_pCurrentBar = NULL;

		::LeaveCriticalSection(&_Module.m_csWindowCreate);

		// cleanup - convert menus back to original state
#ifdef _CMDBAR_EXTRA_TRACE
		ATLTRACE2(atlTraceUI, 0, "CmdBar - TrackPopupMenu - cleanup\n");
#endif

		ATLASSERT(m_stackMenuWnd.GetSize() == 0);

		UpdateWindow();
		CWindow wndTL = GetTopLevelParent();
		wndTL.UpdateWindow();

		// restore the menu items to the previous state for all menus that were converted
		if(m_bImagesVisible)
		{
			HMENU hMenuSav;
			while((hMenuSav = m_stackMenuHandle.Pop()) != NULL)
			{
				menuPopup = hMenuSav;
				BOOL bRet;
				// restore state and delete menu item data
				for(int i = 0; i < menuPopup.GetMenuItemCount(); i++)
				{
					CMenuItemInfo mii;
					mii.fMask = MIIM_DATA | MIIM_TYPE | MIIM_ID;
					bRet = menuPopup.GetMenuItemInfo(i, TRUE, &mii);
					ATLASSERT(bRet);

					_MenuItemData* pMI = (_MenuItemData*)mii.dwItemData;
					if(pMI != NULL && pMI->IsCmdBarMenuItem())
					{
						mii.fMask = MIIM_DATA | MIIM_TYPE | MIIM_STATE;
						mii.fType = pMI->fType;
						mii.fState = pMI->fState;
						mii.dwTypeData = pMI->lpstrText;
						mii.cch = lstrlen(pMI->lpstrText);
						mii.dwItemData = NULL;

						bRet = menuPopup.SetMenuItemInfo(i, TRUE, &mii);
						// this one triggers WM_MEASUREITEM
						menuPopup.ModifyMenu(i, MF_BYPOSITION | mii.fType | mii.fState, mii.wID, pMI->lpstrText);
						ATLASSERT(bRet);

						delete [] pMI->lpstrText;
						delete pMI;
					}
				}
			}
		}
		return bTrackRet;
	}

	void GetSystemSettings()
	{
		// refresh our font
		NONCLIENTMETRICS info;
		info.cbSize = sizeof(info);
		::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(info), &info, 0);
		LOGFONT logfont;
		memset(&logfont, 0, sizeof(LOGFONT));
		if(m_fontMenu.m_hFont != NULL)
			m_fontMenu.GetLogFont(logfont);
		if(logfont.lfHeight != info.lfMenuFont.lfHeight ||
		   logfont.lfWidth != info.lfMenuFont.lfWidth ||
		   logfont.lfEscapement != info.lfMenuFont.lfEscapement ||
		   logfont.lfOrientation != info.lfMenuFont.lfOrientation ||
		   logfont.lfWeight != info.lfMenuFont.lfWeight ||
		   logfont.lfItalic != info.lfMenuFont.lfItalic ||
		   logfont.lfUnderline != info.lfMenuFont.lfUnderline ||
		   logfont.lfStrikeOut != info.lfMenuFont.lfStrikeOut ||
		   logfont.lfCharSet != info.lfMenuFont.lfCharSet ||
		   logfont.lfOutPrecision != info.lfMenuFont.lfOutPrecision ||
		   logfont.lfClipPrecision != info.lfMenuFont.lfClipPrecision ||
		   logfont.lfQuality != info.lfMenuFont.lfQuality ||
		   logfont.lfPitchAndFamily != info.lfMenuFont.lfPitchAndFamily ||
		   lstrcmp(logfont.lfFaceName, info.lfMenuFont.lfFaceName) != 0)
		{
			HFONT hFontMenu = ::CreateFontIndirect(&info.lfMenuFont);
			ATLASSERT(hFontMenu != NULL);
			if(hFontMenu != NULL)
			{
				if(m_fontMenu.m_hFont != NULL)
					m_fontMenu.DeleteObject();
				m_fontMenu.Attach(hFontMenu);
				SetFont(m_fontMenu);
				AddStrings(_T("NS\0"));	// for proper item height
				AutoSize();
			}
		}
	}

// Implementation - alternate focus mode support
	void TakeFocus()
	{
		if((m_dwExtendedStyle & CBR_EX_ALTFOCUSMODE) && m_hWndFocus == NULL)
			m_hWndFocus = ::GetFocus();
		SetFocus();
	}

	void GiveFocusBack()
	{
		if((m_dwExtendedStyle & CBR_EX_ALTFOCUSMODE) && ::IsWindow(m_hWndFocus))
			::SetFocus(m_hWndFocus);
		else if(!(m_dwExtendedStyle & CBR_EX_ALTFOCUSMODE) && m_wndParent.IsWindow())
			m_wndParent.SetFocus();
		m_hWndFocus = NULL;
		SendMessage(TB_SETANCHORHIGHLIGHT, 0, 0);
	}

// Implementation - internal message helpers
	static UINT GetAutoPopupMessage()
	{
		static UINT uAutoPopupMessage = 0;
		if(uAutoPopupMessage == 0)
		{
			::EnterCriticalSection(&_Module.m_csStaticDataInit);
			if(uAutoPopupMessage == 0)
				uAutoPopupMessage = ::RegisterWindowMessage(_T("WTL_CmdBar_InternalAutoPopupMsg"));
			::LeaveCriticalSection(&_Module.m_csStaticDataInit);
		}
		ATLASSERT(uAutoPopupMessage != 0);
		return uAutoPopupMessage;
	}

	static UINT GetGetBarMessage()
	{
		static UINT uGetBarMessage = 0;
		if(uGetBarMessage == 0)
		{
			::EnterCriticalSection(&_Module.m_csStaticDataInit);
			if(uGetBarMessage == 0)
				uGetBarMessage = ::RegisterWindowMessage(_T("WTL_CmdBar_InternalGetBarMsg"));
			::LeaveCriticalSection(&_Module.m_csStaticDataInit);
		}
		ATLASSERT(uGetBarMessage != 0);
		return uGetBarMessage;
	}
};


class CCommandBarCtrl : public CCommandBarCtrlImpl<CCommandBarCtrl>
{
public:
	DECLARE_WND_SUPERCLASS(_T("WTL_CommandBar"), GetWndClassName())
};

}; //namespace WTL

#endif // __ATLCTRLW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\atlctrls.h ===
// WTL Version 3.0
// Copyright (C) 1997-1999 Microsoft Corporation
// All rights reserved.
//
// This file is a part of Windows Template Library.
// The code and information is provided "as-is" without
// warranty of any kind, either expressed or implied.

#ifndef __ATLCTRLS_H__
#define __ATLCTRLS_H__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLAPP_H__
	#error atlctrls.h requires atlapp.h to be included first
#endif

#ifndef __ATLWIN_H__
	#error atlctrls.h requires atlwin.h to be included first
#endif

#if (_WIN32_IE < 0x0300)
	#error atlctrls.h requires IE Version 3.0 or higher
#endif


#include <richedit.h>
#include <richole.h>

// protect template members from windowsx.h macros
#ifdef _INC_WINDOWSX
#undef GetNextSibling
#undef GetPrevSibling
#endif //_INC_WINDOWSX


namespace WTL
{

// These are wrapper classes for Windows standard and common controls.
// To implement a window based on a control, use following:
// Example: Implementing a window based on a list box
//
// class CMyListBox : CWindowImpl<CMyListBox, CListBox>
// {
// public:
//      BEGIN_MSG_MAP(CMyListBox)
//          // put your message handler entries here
//      END_MSG_MAP()
// };


/////////////////////////////////////////////////////////////////////////////
// Forward declarations

template <class TBase> class CStaticT;
template <class TBase> class CButtonT;
template <class TBase> class CListBoxT;
template <class TBase> class CComboBoxT;
template <class TBase> class CEditT;
template <class T> class CEditCommands;
template <class TBase> class CScrollBarT;
class CImageList;
template <class TBase> class CListViewCtrlT;
template <class TBase> class CTreeViewCtrlT;
class CTreeItem;
template <class TBase> class CTreeViewCtrlExT;
template <class TBase> class CHeaderCtrlT;
template <class TBase> class CToolBarCtrlT;
template <class TBase> class CStatusBarCtrlT;
template <class TBase> class CTabCtrlT;
class CToolInfo;
template <class TBase> class CToolTipCtrlT;
template <class TBase> class CTrackBarCtrlT;
template <class TBase> class CUpDownCtrlT;
template <class TBase> class CProgressBarCtrlT;
template <class TBase> class CHotKeyCtrlT;
template <class TBase> class CAnimateCtrlT;
template <class TBase> class CRichEditCtrlT;
template <class T> class CRichEditCommands;
template <class TBase> class CDragListBoxT;
template <class T> class CDragListNotifyImpl;
template <class TBase> class CReBarCtrlT;
template <class TBase> class CComboBoxExT;
template <class TBase> class CDateTimePickerCtrlT;
template <class TBase> class CMonthCalendarCtrlT;
#if (_WIN32_IE >= 0x0400)
template <class T> class CFlatScrollBarImpl;
template <class TBase> class CFlatScrollBarT;
template <class TBase> class CIPAddressCtrlT;
template <class TBase> class CPagerCtrlT;
#endif //(_WIN32_IE >= 0x0400)
template <class T> class CCustomDraw;



// --- Standard Windows controls ---

/////////////////////////////////////////////////////////////////////////////
// CStatic - client side for a Windows STATIC control

template <class TBase>
class CStaticT : public TBase
{
public:
// Constructors
	CStaticT(HWND hWnd = NULL) : TBase(hWnd) { }

	CStaticT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return _T("STATIC");
	}

	HICON GetIcon() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HICON)::SendMessage(m_hWnd, STM_GETICON, 0, 0L);
	}
	HICON SetIcon(HICON hIcon)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HICON)::SendMessage(m_hWnd, STM_SETICON, (WPARAM)hIcon, 0L);
	}
	HENHMETAFILE GetEnhMetaFile() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HENHMETAFILE)::SendMessage(m_hWnd, STM_GETIMAGE, IMAGE_ENHMETAFILE, 0L);
	}
	HENHMETAFILE SetEnhMetaFile(HENHMETAFILE hMetaFile)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HENHMETAFILE)::SendMessage(m_hWnd, STM_SETIMAGE, IMAGE_ENHMETAFILE, (LPARAM)hMetaFile);
	}
	CBitmapHandle GetBitmap() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CBitmapHandle((HBITMAP)::SendMessage(m_hWnd, STM_GETIMAGE, IMAGE_BITMAP, 0L));
	}
	CBitmapHandle SetBitmap(HBITMAP hBitmap)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CBitmapHandle((HBITMAP)::SendMessage(m_hWnd, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap));
	}
	HCURSOR GetCursor() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HCURSOR)::SendMessage(m_hWnd, STM_GETIMAGE, IMAGE_CURSOR, 0L);
	}
	HCURSOR SetCursor(HCURSOR hCursor)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HCURSOR)::SendMessage(m_hWnd, STM_SETIMAGE, IMAGE_CURSOR, (LPARAM)hCursor);
	}
};

typedef CStaticT<CWindow>	CStatic;


/////////////////////////////////////////////////////////////////////////////
// CButton - client side for a Windows BUTTON control

template <class TBase>
class CButtonT : public TBase
{
public:
// Constructors
	CButtonT(HWND hWnd = NULL) : TBase(hWnd) { }

	CButtonT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return _T("BUTTON");
	}

	UINT GetState() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, BM_GETSTATE, 0, 0L);
	}
	void SetState(BOOL bHighlight)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, BM_SETSTATE, bHighlight, 0L);
	}
	int GetCheck() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, BM_GETCHECK, 0, 0L);
	}
	void SetCheck(int nCheck)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, BM_SETCHECK, nCheck, 0L);
	}
	UINT GetButtonStyle() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::GetWindowLong(m_hWnd, GWL_STYLE) & 0xff;
	}
	void SetButtonStyle(UINT nStyle, BOOL bRedraw = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, BM_SETSTYLE, nStyle, (LPARAM)bRedraw);
	}

	HICON GetIcon() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HICON)::SendMessage(m_hWnd, BM_GETIMAGE, IMAGE_ICON, 0L);
	}
	HICON SetIcon(HICON hIcon)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HICON)::SendMessage(m_hWnd, BM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);
	}
	CBitmapHandle GetBitmap() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CBitmapHandle((HBITMAP)::SendMessage(m_hWnd, BM_GETIMAGE, IMAGE_BITMAP, 0L));
	}
	CBitmapHandle SetBitmap(HBITMAP hBitmap)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CBitmapHandle((HBITMAP)::SendMessage(m_hWnd, BM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap));
	}

// Operations
	void Click()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, BM_CLICK, 0, 0L);
	}
};

typedef CButtonT<CWindow>	CButton;


/////////////////////////////////////////////////////////////////////////////
// CListBox - client side for a Windows LISTBOX control

template <class TBase>
class CListBoxT : public TBase
{
public:
// Constructors
	CListBoxT(HWND hWnd = NULL) : TBase(hWnd) { }

	CListBoxT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return _T("LISTBOX");
	}

	// for entire listbox
	int GetCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_GETCOUNT, 0, 0L);
	}
	int SetCount(int cItems)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(((GetStyle() & LBS_NODATA) != 0) && ((GetStyle() & LBS_HASSTRINGS) == 0));
		return (int)::SendMessage(m_hWnd, LB_SETCOUNT, cItems, 0L);
	}
	int GetHorizontalExtent() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_GETHORIZONTALEXTENT, 0, 0L);
	}
	void SetHorizontalExtent(int cxExtent)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, LB_SETHORIZONTALEXTENT, cxExtent, 0L);
	}
	int GetTopIndex() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_GETTOPINDEX, 0, 0L);
	}
	int SetTopIndex(int nIndex)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_SETTOPINDEX, nIndex, 0L);
	}
	LCID GetLocale() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (LCID)::SendMessage(m_hWnd, LB_GETLOCALE, 0, 0L);
	}
	LCID SetLocale(LCID nNewLocale)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (LCID)::SendMessage(m_hWnd, LB_SETLOCALE, (WPARAM)nNewLocale, 0L);
	}

	// for single-selection listboxes
	int GetCurSel() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & (LBS_MULTIPLESEL | LBS_EXTENDEDSEL)) == 0);
		return (int)::SendMessage(m_hWnd, LB_GETCURSEL, 0, 0L);
	}
	int SetCurSel(int nSelect)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & (LBS_MULTIPLESEL | LBS_EXTENDEDSEL)) == 0);
		return (int)::SendMessage(m_hWnd, LB_SETCURSEL, nSelect, 0L);
	}

	// for multiple-selection listboxes
	int GetSel(int nIndex) const           // also works for single-selection
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_GETSEL, nIndex, 0L);
	}
	int SetSel(int nIndex, BOOL bSelect = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & (LBS_MULTIPLESEL | LBS_EXTENDEDSEL)) != 0);
		return (int)::SendMessage(m_hWnd, LB_SETSEL, bSelect, nIndex);
	}
	int GetSelCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & (LBS_MULTIPLESEL | LBS_EXTENDEDSEL)) != 0);
		return (int)::SendMessage(m_hWnd, LB_GETSELCOUNT, 0, 0L);
	}
	int GetSelItems(int nMaxItems, LPINT rgIndex) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & (LBS_MULTIPLESEL | LBS_EXTENDEDSEL)) != 0);
		return (int)::SendMessage(m_hWnd, LB_GETSELITEMS, nMaxItems, (LPARAM)rgIndex);
	}
	int GetAnchorIndex() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & (LBS_MULTIPLESEL | LBS_EXTENDEDSEL)) != 0);
		return (int)::SendMessage(m_hWnd, LB_GETANCHORINDEX, 0, 0L);
	}
	void SetAnchorIndex(int nIndex)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & (LBS_MULTIPLESEL | LBS_EXTENDEDSEL)) != 0);
		::SendMessage(m_hWnd, LB_SETANCHORINDEX, nIndex, 0L);
	}
	int GetCaretIndex() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_GETCARETINDEX, 0, 0);
	}
	int SetCaretIndex(int nIndex, BOOL bScroll = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_SETCARETINDEX, nIndex, MAKELONG(bScroll, 0));
	}

	// for listbox items
	DWORD_PTR GetItemData(int nIndex) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD_PTR)::SendMessage(m_hWnd, LB_GETITEMDATA, nIndex, 0L);
	}
	int SetItemData(int nIndex, DWORD_PTR dwItemData)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_SETITEMDATA, nIndex, (LPARAM)dwItemData);
	}
	void* GetItemDataPtr(int nIndex) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (void*)::SendMessage(m_hWnd, LB_GETITEMDATA, nIndex, 0L);
	}
	int SetItemDataPtr(int nIndex, void* pData)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return SetItemData(nIndex, (DWORD_PTR)pData);
	}
	int GetItemRect(int nIndex, LPRECT lpRect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_GETITEMRECT, nIndex, (LPARAM)lpRect);
	}
	int GetText(int nIndex, LPTSTR lpszBuffer) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_GETTEXT, nIndex, (LPARAM)lpszBuffer);
	}
#ifndef _ATL_NO_COM
#ifdef _OLEAUTO_H_
	BOOL GetTextBSTR(int nIndex, BSTR& bstrText) const
	{
		USES_CONVERSION;
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(bstrText == NULL);

		int nLen = GetTextLen(nIndex);
		if(nLen == LB_ERR)
			return FALSE;

		LPTSTR lpszText = (LPTSTR)_alloca((nLen + 1) * sizeof(TCHAR));

		if(GetText(nIndex, lpszText) == LB_ERR)
			return FALSE;

		bstrText = ::SysAllocString(T2OLE(lpszText));
		return (bstrText != NULL) ? TRUE : FALSE;
	}
#endif // _OLEAUTO_H_
#endif //!_ATL_NO_COM
#ifdef __ATLSTR_H__
	int GetText(int nIndex, CString& strText) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		int nRet = GetText(nIndex, strText.GetBufferSetLength(GetTextLen(nIndex)));
		strText.ReleaseBuffer();
		return nRet;
	}
#endif //__ATLSTR_H__
	int GetTextLen(int nIndex) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_GETTEXTLEN, nIndex, 0L);
	}
	int GetItemHeight(int nIndex) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_GETITEMHEIGHT, nIndex, 0L);
	}
	int SetItemHeight(int nIndex, UINT cyItemHeight)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_SETITEMHEIGHT, nIndex, MAKELONG(cyItemHeight, 0));
	}

	// Settable only attributes
	void SetColumnWidth(int cxWidth)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, LB_SETCOLUMNWIDTH, cxWidth, 0L);
	}
	BOOL SetTabStops(int nTabStops, LPINT rgTabStops)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & LBS_USETABSTOPS) != 0);
		return (BOOL)::SendMessage(m_hWnd, LB_SETTABSTOPS, nTabStops, (LPARAM)rgTabStops);
	}
	BOOL SetTabStops()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & LBS_USETABSTOPS) != 0);
		return (BOOL)::SendMessage(m_hWnd, LB_SETTABSTOPS, 0, 0L);
	}
	BOOL SetTabStops(const int& cxEachStop)    // takes an 'int'
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & LBS_USETABSTOPS) != 0);
		return (BOOL)::SendMessage(m_hWnd, LB_SETTABSTOPS, 1, (LPARAM)(LPINT)&cxEachStop);
	}

// Operations
	int InitStorage(int nItems, UINT nBytes)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_INITSTORAGE, (WPARAM)nItems, nBytes);
	}
	void ResetContent()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, LB_RESETCONTENT, 0, 0L);
	}
	UINT ItemFromPoint(POINT pt, BOOL& bOutside) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		DWORD dw = (DWORD)::SendMessage(m_hWnd, LB_ITEMFROMPOINT, 0, MAKELPARAM(pt.x, pt.y));
		bOutside = (BOOL)HIWORD(dw);
		return (UINT)LOWORD(dw);
	}

	// manipulating listbox items
	int AddString(LPCTSTR lpszItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_ADDSTRING, 0, (LPARAM)lpszItem);
	}
	int DeleteString(UINT nIndex)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_DELETESTRING, nIndex, 0L);
	}
	int InsertString(int nIndex, LPCTSTR lpszItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_INSERTSTRING, nIndex, (LPARAM)lpszItem);
	}
	int Dir(UINT attr, LPCTSTR lpszWildCard)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_DIR, attr, (LPARAM)lpszWildCard);
	}
	int AddFile(LPCTSTR lpstrFileName)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_ADDFILE, 0, (LPARAM)lpstrFileName);
	}

	// selection helpers
	int FindString(int nStartAfter, LPCTSTR lpszItem) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_FINDSTRING, nStartAfter, (LPARAM)lpszItem);
	}
	int FindStringExact(int nIndexStart, LPCTSTR lpszFind) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_FINDSTRINGEXACT, nIndexStart, (LPARAM)lpszFind);
	}
	int SelectString(int nStartAfter, LPCTSTR lpszItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_SELECTSTRING, nStartAfter, (LPARAM)lpszItem);
	}
	int SelItemRange(BOOL bSelect, int nFirstItem, int nLastItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & (LBS_MULTIPLESEL | LBS_EXTENDEDSEL)) != 0);
		ATLASSERT(nFirstItem <= nLastItem);
		return bSelect ? (int)::SendMessage(m_hWnd, LB_SELITEMRANGEEX, nFirstItem, nLastItem) : (int)::SendMessage(m_hWnd, LB_SELITEMRANGEEX, nLastItem, nFirstItem);
	}
};

typedef CListBoxT<CWindow>	CListBox;


/////////////////////////////////////////////////////////////////////////////
// CComboBox - client side for a Windows COMBOBOX control

template <class TBase>
class CComboBoxT : public TBase
{
public:
// Constructors
	CComboBoxT(HWND hWnd = NULL) : TBase(hWnd) { }

	CComboBoxT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return _T("COMBOBOX");
	}

	// for entire combo box
	int GetCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_GETCOUNT, 0, 0L);
	}
	int GetCurSel() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_GETCURSEL, 0, 0L);
	}
	int SetCurSel(int nSelect)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_SETCURSEL, nSelect, 0L);
	}
	LCID GetLocale() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (LCID)::SendMessage(m_hWnd, CB_GETLOCALE, 0, 0L);
	}
	LCID SetLocale(LCID nNewLocale)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (LCID)::SendMessage(m_hWnd, CB_SETLOCALE, (WPARAM)nNewLocale, 0L);
	}
	int GetTopIndex() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_GETTOPINDEX, 0, 0L);
	}
	int SetTopIndex(int nIndex)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_SETTOPINDEX, nIndex, 0L);
	}
	UINT GetHorizontalExtent() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, CB_GETHORIZONTALEXTENT, 0, 0L);
	}
	void SetHorizontalExtent(UINT nExtent)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, CB_SETHORIZONTALEXTENT, nExtent, 0L);
	}
	int GetDroppedWidth() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_GETDROPPEDWIDTH, 0, 0L);
	}
	int SetDroppedWidth(UINT nWidth)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_SETDROPPEDWIDTH, nWidth, 0L);
	}

	// for edit control
	DWORD GetEditSel() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, CB_GETEDITSEL, 0, 0L);
	}
	BOOL SetEditSel(int nStartChar, int nEndChar)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, CB_SETEDITSEL, 0, MAKELONG(nStartChar, nEndChar));
	}

	// for combobox item
	DWORD_PTR GetItemData(int nIndex) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD_PTR)::SendMessage(m_hWnd, CB_GETITEMDATA, nIndex, 0L);
	}
	int SetItemData(int nIndex, DWORD_PTR dwItemData)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_SETITEMDATA, nIndex, (LPARAM)dwItemData);
	}
	void* GetItemDataPtr(int nIndex) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (void*)GetItemData(nIndex);
	}
	int SetItemDataPtr(int nIndex, void* pData)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return SetItemData(nIndex, (DWORD_PTR)pData);
	}
	int GetLBText(int nIndex, LPTSTR lpszText) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_GETLBTEXT, nIndex, (LPARAM)lpszText);
	}
#ifndef _ATL_NO_COM
	BOOL GetLBTextBSTR(int nIndex, BSTR& bstrText) const
	{
		USES_CONVERSION;
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(bstrText == NULL);

		int nLen = GetLBTextLen(nIndex);
		if(nLen == CB_ERR)
			return FALSE;

		LPTSTR lpszText = (LPTSTR)_alloca((nLen + 1) * sizeof(TCHAR));

		if(GetLBText(nIndex, lpszText) == CB_ERR)
			return FALSE;

		bstrText = ::SysAllocString(T2OLE(lpszText));
		return (bstrText != NULL) ? TRUE : FALSE;
	}
#endif //!_ATL_NO_COM
#ifdef __ATLSTR_H__
	int GetLBText(int nIndex, CString& strText) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		int nRet = GetLBText(nIndex, strText.GetBufferSetLength(GetLBTextLen(nIndex)));
		strText.ReleaseBuffer();
		return nRet;
	}
#endif //__ATLSTR_H__
	int GetLBTextLen(int nIndex) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_GETLBTEXTLEN, nIndex, 0L);
	}

	int GetItemHeight(int nIndex) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_GETITEMHEIGHT, nIndex, 0L);
	}
	int SetItemHeight(int nIndex, UINT cyItemHeight)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_SETITEMHEIGHT, nIndex, MAKELONG(cyItemHeight, 0));
	}
	BOOL GetExtendedUI() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, CB_GETEXTENDEDUI, 0, 0L);
	}
	int SetExtendedUI(BOOL bExtended = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_SETEXTENDEDUI, bExtended, 0L);
	}
	void GetDroppedControlRect(LPRECT lprect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, CB_GETDROPPEDCONTROLRECT, 0, (LPARAM)lprect);
	}
	BOOL GetDroppedState() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, CB_GETDROPPEDSTATE, 0, 0L);
	}

// Operations
	int InitStorage(int nItems, UINT nBytes)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_INITSTORAGE, (WPARAM)nItems, nBytes);
	}
	void ResetContent()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, CB_RESETCONTENT, 0, 0L);
	}

	// for edit control
	BOOL LimitText(int nMaxChars)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, CB_LIMITTEXT, nMaxChars, 0L);
	}

	// for drop-down combo boxes
	void ShowDropDown(BOOL bShowIt = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, CB_SHOWDROPDOWN, bShowIt, 0L);
	}

	// manipulating listbox items
	int AddString(LPCTSTR lpszString)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_ADDSTRING, 0, (LPARAM)lpszString);
	}
	int DeleteString(UINT nIndex)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_DELETESTRING, nIndex, 0L);
	}
	int InsertString(int nIndex, LPCTSTR lpszString)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_INSERTSTRING, nIndex, (LPARAM)lpszString);
	}
	int Dir(UINT attr, LPCTSTR lpszWildCard)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_DIR, attr, (LPARAM)lpszWildCard);
	}

	// selection helpers
	int FindString(int nStartAfter, LPCTSTR lpszString) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_FINDSTRING, nStartAfter, (LPARAM)lpszString);
	}
	int FindStringExact(int nIndexStart, LPCTSTR lpszFind) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_FINDSTRINGEXACT, nIndexStart, (LPARAM)lpszFind);
	}
	int SelectString(int nStartAfter, LPCTSTR lpszString)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_SELECTSTRING, nStartAfter, (LPARAM)lpszString);
	}

	// Clipboard operations
	void Clear()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_CLEAR, 0, 0L);
	}
	void Copy()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_COPY, 0, 0L);
	}
	void Cut()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_CUT, 0, 0L);
	}
	void Paste()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_PASTE, 0, 0L);
	}
};

typedef CComboBoxT<CWindow>	CComboBox;


/////////////////////////////////////////////////////////////////////////////
// CEdit - client side for a Windows EDIT control

template <class TBase>
class CEditT : public TBase
{
public:
// Constructors
	CEditT(HWND hWnd = NULL) : TBase(hWnd) { }

	CEditT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return _T("EDIT");
	}

	BOOL CanUndo() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_CANUNDO, 0, 0L);
	}
	int GetLineCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_GETLINECOUNT, 0, 0L);
	}
	BOOL GetModify() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_GETMODIFY, 0, 0L);
	}
	void SetModify(BOOL bModified = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_SETMODIFY, bModified, 0L);
	}
	void GetRect(LPRECT lpRect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_GETRECT, 0, (LPARAM)lpRect);
	}
	DWORD GetSel() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, EM_GETSEL, 0, 0L);
	}
	void GetSel(int& nStartChar, int& nEndChar) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_GETSEL, (WPARAM)&nStartChar, (LPARAM)&nEndChar);
	}
	HLOCAL GetHandle() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HLOCAL)::SendMessage(m_hWnd, EM_GETHANDLE, 0, 0L);
	}
	void SetHandle(HLOCAL hBuffer)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_SETHANDLE, (WPARAM)hBuffer, 0L);
	}
	DWORD GetMargins() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, EM_GETMARGINS, 0, 0L);
	}
	void SetMargins(UINT nLeft, UINT nRight)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_SETMARGINS, EC_LEFTMARGIN|EC_RIGHTMARGIN, MAKELONG(nLeft, nRight));
	}
	UINT GetLimitText() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, EM_GETLIMITTEXT, 0, 0L);
	}
	void SetLimitText(UINT nMax)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_SETLIMITTEXT, nMax, 0L);
	}
	POINT PosFromChar(UINT nChar) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, EM_POSFROMCHAR, nChar, 0);
		POINT point = { GET_X_LPARAM(dwRet), GET_Y_LPARAM(dwRet) };
		return point;
	}
	int CharFromPos(POINT pt, int* pLine = NULL) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, EM_CHARFROMPOS, 0, MAKELPARAM(pt.x, pt.y));
		if(pLine != NULL)
			*pLine = (int)(short)HIWORD(dwRet);
		return (int)(short)LOWORD(dwRet);
	}

	// NOTE: first word in lpszBuffer must contain the size of the buffer!
	int GetLine(int nIndex, LPTSTR lpszBuffer) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_GETLINE, nIndex, (LPARAM)lpszBuffer);
	}
	int GetLine(int nIndex, LPTSTR lpszBuffer, int nMaxLength) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		*(LPWORD)lpszBuffer = (WORD)nMaxLength;
		return (int)::SendMessage(m_hWnd, EM_GETLINE, nIndex, (LPARAM)lpszBuffer);
	}

	TCHAR GetPasswordChar() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (TCHAR)::SendMessage(m_hWnd, EM_GETPASSWORDCHAR, 0, 0L);
	}
	void SetPasswordChar(TCHAR ch)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_SETPASSWORDCHAR, ch, 0L);
	}
	EDITWORDBREAKPROC GetWordBreakProc() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (EDITWORDBREAKPROC)::SendMessage(m_hWnd, EM_GETWORDBREAKPROC, 0, 0L);
	}
	void SetWordBreakProc(EDITWORDBREAKPROC ewbprc)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_SETWORDBREAKPROC, 0, (LPARAM)ewbprc);
	}
	int GetFirstVisibleLine() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_GETFIRSTVISIBLELINE, 0, 0L);
	}
	int GetThumb() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & ES_MULTILINE) != 0);
		return (int)::SendMessage(m_hWnd, EM_GETTHUMB, 0, 0L);
	}
	BOOL SetReadOnly(BOOL bReadOnly = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_SETREADONLY, bReadOnly, 0L);
	}

#if (WINVER >= 0x0500)
	UINT GetImeStatus(UINT uStatus) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, EM_GETIMESTATUS, uStatus, 0L);
	}
	UINT SetImeStatus(UINT uStatus, UINT uData)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, EM_SETIMESTATUS, uStatus, uData);
	}
#endif //(WINVER >= 0x0500)

// Operations
	void EmptyUndoBuffer()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_EMPTYUNDOBUFFER, 0, 0L);
	}
	BOOL FmtLines(BOOL bAddEOL)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_FMTLINES, bAddEOL, 0L);
	}
	void LimitText(int nChars = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_LIMITTEXT, nChars, 0L);
	}
	int LineFromChar(int nIndex = -1) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_LINEFROMCHAR, nIndex, 0L);
	}
	int LineIndex(int nLine = -1) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_LINEINDEX, nLine, 0L);
	}
	int LineLength(int nLine = -1) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_LINELENGTH, nLine, 0L);
	}
	void LineScroll(int nLines, int nChars = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_LINESCROLL, nChars, nLines);
	}
	void ReplaceSel(LPCTSTR lpszNewText, BOOL bCanUndo = FALSE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_REPLACESEL, (WPARAM) bCanUndo, (LPARAM)lpszNewText);
	}
	void SetRect(LPCRECT lpRect)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_SETRECT, 0, (LPARAM)lpRect);
	}
	void SetRectNP(LPCRECT lpRect)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_SETRECTNP, 0, (LPARAM)lpRect);
	}
	void SetSel(DWORD dwSelection, BOOL bNoScroll = FALSE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_SETSEL, LOWORD(dwSelection), HIWORD(dwSelection));
		if(!bNoScroll)
			::SendMessage(m_hWnd, EM_SCROLLCARET, 0, 0L);
	}
	void SetSel(int nStartChar, int nEndChar, BOOL bNoScroll = FALSE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_SETSEL, nStartChar, nEndChar);
		if(!bNoScroll)
			::SendMessage(m_hWnd, EM_SCROLLCARET, 0, 0L);
	}
	void SetSelAll(BOOL bNoScroll = FALSE)
	{
		SetSel(-1, 0, bNoScroll);
	}
	void SetSelNone(BOOL bNoScroll = FALSE)
	{
		SetSel(0, -1, bNoScroll);
	}
	BOOL SetTabStops(int nTabStops, LPINT rgTabStops)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_SETTABSTOPS, nTabStops, (LPARAM)rgTabStops);
	}
	BOOL SetTabStops()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_SETTABSTOPS, 0, 0L);
	}
	BOOL SetTabStops(const int& cxEachStop)    // takes an 'int'
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_SETTABSTOPS, 1, (LPARAM)(LPINT)&cxEachStop);
	}
	void ScrollCaret()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_SCROLLCARET, 0, 0L);
	}
	int Scroll(int nScrollAction)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & ES_MULTILINE) != 0);
		LRESULT lRet = ::SendMessage(m_hWnd, EM_SCROLL, nScrollAction, 0L);
		if(!(BOOL)HIWORD(lRet))
			return -1;	// failed
		return (int)(short)LOWORD(lRet);
		
	}

	void InsertText(int nInsertAfterChar, LPCTSTR lpstrText, BOOL bNoScroll = FALSE, BOOL bCanUndo = FALSE)
	{
		SetSel(nInsertAfterChar, nInsertAfterChar, bNoScroll);
		ReplaceSel(lpstrText, bCanUndo);
	}
	void AppendText(LPCTSTR lpstrText, BOOL bNoScroll = FALSE, BOOL bCanUndo = FALSE)
	{
		InsertText(GetWindowTextLength(), lpstrText, bNoScroll, bCanUndo);
	}

	// Clipboard operations
	BOOL Undo()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_UNDO, 0, 0L);
	}
	void Clear()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_CLEAR, 0, 0L);
	}
	void Copy()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_COPY, 0, 0L);
	}
	void Cut()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_CUT, 0, 0L);
	}
	void Paste()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_PASTE, 0, 0L);
	}
};

typedef CEditT<CWindow>		CEdit;


/////////////////////////////////////////////////////////////////////////////
// CEditCommands - message handlers for standard EDIT commands

// Chain to CEditCommands message map. Your class must also derive from CEdit.
// Example:
// class CMyEdit : public CWindowImpl<CMyEdit, CEdit>,
//                 public CEditCommands<CMyEdit>
// {
// public:
//      BEGIN_MSG_MAP(CMyEdit)
//              // your handlers...
//              CHAIN_MSG_MAP_ALT(CEditCommands<CMyEdit>, 1)
//      END_MSG_MAP()
//      // other stuff...
// };

template <class T>
class CEditCommands
{
public:
	BEGIN_MSG_MAP(CEditCommands< T >)
	ALT_MSG_MAP(1)
		COMMAND_ID_HANDLER(ID_EDIT_CLEAR, OnEditClear)
		COMMAND_ID_HANDLER(ID_EDIT_CLEAR_ALL, OnEditClearAll)
		COMMAND_ID_HANDLER(ID_EDIT_COPY, OnEditCopy)
		COMMAND_ID_HANDLER(ID_EDIT_CUT, OnEditCut)
		COMMAND_ID_HANDLER(ID_EDIT_PASTE, OnEditPaste)
		COMMAND_ID_HANDLER(ID_EDIT_SELECT_ALL, OnEditSelectAll)
		COMMAND_ID_HANDLER(ID_EDIT_UNDO, OnEditUndo)
	END_MSG_MAP()

	LRESULT OnEditClear(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		pT->Clear();
		return 0;
	}
	LRESULT OnEditClearAll(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		pT->SetSel(0, -1);
		pT->Clear();
		return 0;
	}
	LRESULT OnEditCopy(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		pT->Copy();
		return 0;
	}
	LRESULT OnEditCut(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		pT->Cut();
		return 0;
	}
	LRESULT OnEditPaste(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		pT->Paste();
		return 0;
	}
	LRESULT OnEditSelectAll(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		pT->SetSel(0, -1);
		return 0;
	}
	LRESULT OnEditUndo(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		pT->Undo();
		return 0;
	}

// State (update UI) helpers
	BOOL CanCut() const
	{ return HasSelection(); }
	BOOL CanCopy() const
	{ return HasSelection(); }
	BOOL CanClear() const
	{ return HasSelection(); }
	BOOL CanSelectAll() const
	{ return HasText(); }
	BOOL CanFind() const
	{ return HasText(); }
	BOOL CanRepeat() const
	{ return HasText(); }
	BOOL CanReplace() const
	{ return HasText(); }
	BOOL CanClearAll() const
	{ return HasText(); }

// Implementation
	BOOL HasSelection() const
	{
		const T* pT = static_cast<const T*>(this);
		int nMin, nMax;
		::SendMessage(pT->m_hWnd, EM_GETSEL, (WPARAM)&nMin, (LPARAM)&nMax);
		return (nMin != nMax);
	}
	BOOL HasText() const
	{
		const T* pT = static_cast<const T*>(this);
		return (pT->GetWindowTextLength() > 0);
	}
};


/////////////////////////////////////////////////////////////////////////////
// CScrollBar - client side for a Windows SCROLLBAR control

template <class TBase>
class CScrollBarT : public TBase
{
public:
// Constructors
	CScrollBarT(HWND hWnd = NULL) : TBase(hWnd) { }

	CScrollBarT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return _T("SCROLLBAR");
	}

	int GetScrollPos() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetScrollPos(m_hWnd, SB_CTL);
	}
	int SetScrollPos(int nPos, BOOL bRedraw = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetScrollPos(m_hWnd, SB_CTL, nPos, bRedraw);
	}
	void GetScrollRange(LPINT lpMinPos, LPINT lpMaxPos) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::GetScrollRange(m_hWnd, SB_CTL, lpMinPos, lpMaxPos);
	}
	void SetScrollRange(int nMinPos, int nMaxPos, BOOL bRedraw = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SetScrollRange(m_hWnd, SB_CTL, nMinPos, nMaxPos, bRedraw);
	}
	BOOL GetScrollInfo(LPSCROLLINFO lpScrollInfo) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetScrollInfo(m_hWnd, SB_CTL, lpScrollInfo);
	}
	int SetScrollInfo(LPSCROLLINFO lpScrollInfo, BOOL bRedraw = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetScrollInfo(m_hWnd, SB_CTL, lpScrollInfo, bRedraw);
	}
	int GetScrollLimit() const
	{
		int nMin, nMax;
		::GetScrollRange(m_hWnd, SB_CTL, &nMin, &nMax);
		SCROLLINFO info;
		info.cbSize = sizeof(SCROLLINFO);
		info.fMask = SIF_PAGE;
		if(::GetScrollInfo(m_hWnd, SB_CTL, &info))
			nMax -= ((info.nPage-1) > 0) ? (info.nPage-1) : 0;

		return nMax;
	}

// Operations
	void ShowScrollBar(BOOL bShow = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::ShowScrollBar(m_hWnd, SB_CTL, bShow);
	}

	BOOL EnableScrollBar(UINT nArrowFlags = ESB_ENABLE_BOTH)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::EnableScrollBar(m_hWnd, SB_CTL, nArrowFlags);
	}

};

typedef CScrollBarT<CWindow>	CScrollBar;


// --- Windows Common Controls ---

/////////////////////////////////////////////////////////////////////////////
// CImageList

class CImageList
{
public:
	HIMAGELIST m_hImageList;

// Constructor
	CImageList(HIMAGELIST hImageList = NULL) : m_hImageList(hImageList)
	{ }

// Operators, etc.
	CImageList& operator=(HIMAGELIST hImageList)
	{
		m_hImageList = hImageList;
		return *this;
	}

	operator HIMAGELIST() const { return m_hImageList; }

	void Attach(HIMAGELIST hImageList)
	{
		ATLASSERT(m_hImageList == NULL);
		ATLASSERT(hImageList != NULL);
		m_hImageList = hImageList;
	}
	HIMAGELIST Detach()
	{
		HIMAGELIST hImageList = m_hImageList;
		m_hImageList = NULL;
		return hImageList;
	}

	bool IsNull() const { return (m_hImageList == NULL); }

// Attributes
	int GetImageCount() const
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_GetImageCount(m_hImageList);
	}
	COLORREF GetBkColor() const
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_GetBkColor(m_hImageList);
	}
	COLORREF SetBkColor(COLORREF cr)
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_SetBkColor(m_hImageList, cr);
	}
	BOOL GetImageInfo(int nImage, IMAGEINFO* pImageInfo) const
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_GetImageInfo(m_hImageList, nImage, pImageInfo);
	}

	HICON GetIcon(int nIndex, UINT uFlags = ILD_NORMAL) const
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_GetIcon(m_hImageList, nIndex, uFlags);
	}
	BOOL GetIconSize(int& cx, int& cy) const
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_GetIconSize(m_hImageList, &cx, &cy);
	}
	BOOL GetIconSize(SIZE& size) const
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_GetIconSize(m_hImageList, (int*)&size.cx, (int*)&size.cy);
	}
	BOOL SetIconSize(int cx, int cy)
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_SetIconSize(m_hImageList, cx, cy);
	}
	BOOL SetIconSize(SIZE size)
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_SetIconSize(m_hImageList, size.cx, size.cy);
	}
	BOOL SetImageCount(UINT uNewCount)
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_SetImageCount(m_hImageList, uNewCount);
	}
	BOOL SetOverlayImage(int nImage, int nOverlay)
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_SetOverlayImage(m_hImageList, nImage, nOverlay);
	}

// Operations
	BOOL Create(int cx, int cy, UINT nFlags, int nInitial, int nGrow)
	{
		ATLASSERT(m_hImageList == NULL);
		m_hImageList = ImageList_Create(cx, cy, nFlags, nInitial, nGrow);
		return (m_hImageList != NULL) ? TRUE : FALSE;
	}
	BOOL Create(_U_STRINGorID bitmap, int cx, int nGrow, COLORREF crMask)
	{
		ATLASSERT(m_hImageList == NULL);
		m_hImageList = ImageList_LoadBitmap(_Module.GetResourceInstance(), bitmap.m_lpstr, cx, nGrow, crMask);
		return (m_hImageList != NULL) ? TRUE : FALSE;
	}
	BOOL CreateFromImage(_U_STRINGorID image, int cx, int nGrow, COLORREF crMask, UINT uType, UINT uFlags = LR_DEFAULTCOLOR | LR_DEFAULTSIZE)
	{
		ATLASSERT(m_hImageList == NULL);
		m_hImageList = ImageList_LoadImage(_Module.GetResourceInstance(), image.m_lpstr, cx, nGrow, crMask, uType, uFlags);
		return (m_hImageList != NULL) ? TRUE : FALSE;
	}
	BOOL Merge(HIMAGELIST hImageList1, int nImage1, HIMAGELIST hImageList2, int nImage2, int dx, int dy)
	{
		ATLASSERT(m_hImageList == NULL);
		m_hImageList = ImageList_Merge(hImageList1, nImage1, hImageList2, nImage2, dx, dy);
		return (m_hImageList != NULL) ? TRUE : FALSE;
	}

	BOOL Destroy()
	{
		if (m_hImageList == NULL)
			return FALSE;
		BOOL bRet = ImageList_Destroy(Detach());
		if(bRet)
			m_hImageList = NULL;
		return bRet;
	}

	int Add(HBITMAP hBitmap, HBITMAP hBitmapMask = NULL)
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_Add(m_hImageList, hBitmap, hBitmapMask);
	}
	int Add(HBITMAP hBitmap, COLORREF crMask)
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_AddMasked(m_hImageList, hBitmap, crMask);
	}
	BOOL Remove(int nImage)
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_Remove(m_hImageList, nImage);
	}
	BOOL RemoveAll()
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_RemoveAll(m_hImageList);
	}
	BOOL Replace(int nImage, HBITMAP hBitmap, HBITMAP hBitmapMask)
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_Replace(m_hImageList, nImage, hBitmap, hBitmapMask);
	}
	int AddIcon(HICON hIcon)
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_AddIcon(m_hImageList, hIcon);
	}
	int ReplaceIcon(int nImage, HICON hIcon)
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_ReplaceIcon(m_hImageList, nImage, hIcon);
	}
	HICON ExtractIcon(int nImage)
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_ExtractIcon(NULL, m_hImageList, nImage);
	}
	BOOL Draw(HDC hDC, int nImage, int x, int y, UINT nStyle)
	{
		ATLASSERT(m_hImageList != NULL);
		ATLASSERT(hDC != NULL);
		return ImageList_Draw(m_hImageList, nImage, hDC, x, y, nStyle);
	}
	BOOL Draw(HDC hDC, int nImage, POINT pt, UINT nStyle)
	{
		ATLASSERT(m_hImageList != NULL);
		ATLASSERT(hDC != NULL);
		return ImageList_Draw(m_hImageList, nImage, hDC, pt.x, pt.y, nStyle);
	}
	BOOL DrawEx(int nImage, HDC hDC, int x, int y, int dx, int dy, COLORREF rgbBk, COLORREF rgbFg, UINT fStyle)
	{
		ATLASSERT(m_hImageList != NULL);
		ATLASSERT(hDC != NULL);
		return ImageList_DrawEx(m_hImageList, nImage, hDC, x, y, dx, dy, rgbBk, rgbFg, fStyle);
	}
	BOOL DrawEx(int nImage, HDC hDC, RECT& rect, COLORREF rgbBk, COLORREF rgbFg, UINT fStyle)
	{
		ATLASSERT(m_hImageList != NULL);
		ATLASSERT(hDC != NULL);
		return ImageList_DrawEx(m_hImageList, nImage, hDC, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, rgbBk, rgbFg, fStyle);
	}
	static BOOL DrawIndirect(IMAGELISTDRAWPARAMS* pimldp)
	{
		return ImageList_DrawIndirect(pimldp);
	}
	BOOL Copy(int nSrc, int nDst, UINT uFlags = ILCF_MOVE)
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_Copy(m_hImageList, nDst, m_hImageList, nSrc, uFlags);
	}
	HIMAGELIST Read(LPSTREAM lpStream)
	{
		ATLASSERT(m_hImageList == NULL);
		return ImageList_Read(lpStream);
	}
	BOOL Write(LPSTREAM lpStream)
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_Write(m_hImageList, lpStream);
	}

	// Drag operations
	BOOL BeginDrag(int nImage, POINT ptHotSpot)
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_BeginDrag(m_hImageList, nImage, ptHotSpot.x, ptHotSpot.y);
	}
	BOOL BeginDrag(int nImage, int xHotSpot, int yHotSpot)
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_BeginDrag(m_hImageList, nImage, xHotSpot, yHotSpot);
	}
	static void EndDrag()
	{
		ImageList_EndDrag();
	}
	static BOOL DragMove(POINT pt)
	{
		return ImageList_DragMove(pt.x, pt.y);
	}
	static BOOL DragMove(int x, int y)
	{
		return ImageList_DragMove(x, y);
	}
	BOOL SetDragCursorImage(int nDrag, POINT ptHotSpot)
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_SetDragCursorImage(m_hImageList, nDrag, ptHotSpot.x, ptHotSpot.y);
	}
	BOOL SetDragCursorImage(int nDrag, int xHotSpot, int yHotSpot)
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_SetDragCursorImage(m_hImageList, nDrag, xHotSpot, yHotSpot);
	}
	static BOOL DragShowNolock(BOOL bShow = TRUE)
	{
		return ImageList_DragShowNolock(bShow);
	}
	static CImageList GetDragImage(LPPOINT lpPoint, LPPOINT lpPointHotSpot)
	{
		return CImageList(ImageList_GetDragImage(lpPoint, lpPointHotSpot));
	}
	static BOOL DragEnter(HWND hWnd, POINT point)
	{
		return ImageList_DragEnter(hWnd, point.x, point.y);
	}
	static BOOL DragEnter(HWND hWnd, int x, int y)
	{
		return ImageList_DragEnter(hWnd, x, y);
	}
	static BOOL DragLeave(HWND hWnd)
	{
		return ImageList_DragLeave(hWnd);
	}

#if (_WIN32_IE >= 0x0400)
	CImageList Duplicate()
	{
		ATLASSERT(m_hImageList != NULL);
		return CImageList(ImageList_Duplicate(m_hImageList));
	}
	static CImageList Duplicate(HIMAGELIST hImageList)
	{
		ATLASSERT(hImageList != NULL);
		return CImageList(ImageList_Duplicate(hImageList));
	}
#endif //(_WIN32_IE >= 0x0400)
};


/////////////////////////////////////////////////////////////////////////////
// CToolTipCtrl

class CToolInfo : public TOOLINFO
{
public:
	CToolInfo(UINT nFlags, HWND hWnd, UINT nIDTool = 0, LPRECT lpRect = NULL, LPTSTR lpstrText = LPSTR_TEXTCALLBACK, LPARAM lUserParam = NULL)
	{
		Init(nFlags, hWnd, nIDTool, lpRect, lpstrText, lUserParam);
	}

	operator LPTOOLINFO() { return this; }
	operator LPARAM() { return (LPARAM)this; }

	void Init(UINT nFlags, HWND hWnd, UINT nIDTool = 0, LPRECT lpRect = NULL, LPTSTR lpstrText = LPSTR_TEXTCALLBACK, LPARAM lUserParam = NULL)
	{
		ATLASSERT(::IsWindow(hWnd));
		memset(this, 0, sizeof(TOOLINFO));
		cbSize = sizeof(TOOLINFO);
		uFlags = nFlags;
		if(nIDTool == 0)
		{
			hwnd = ::GetParent(hWnd);
			uFlags |= TTF_IDISHWND;
			uId = (UINT_PTR)hWnd;
		}
		else
		{
			hwnd = hWnd;
			uId = nIDTool;
		}
		if(lpRect != NULL)
			rect = *lpRect;
		hinst = _Module.GetResourceInstance();
		lpszText = lpstrText;
		lParam = lUserParam;
	}
};

template <class TBase>
class CToolTipCtrlT : public TBase
{
public:
// Constructors
	CToolTipCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }

	CToolTipCtrlT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return TOOLTIPS_CLASS;
	}

	void GetText(LPTOOLINFO lpToolInfo) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TTM_GETTEXT, 0, (LPARAM)&lpToolInfo);
	}
	void GetText(LPTSTR lpstrText, HWND hWnd, UINT nIDTool = 0) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(hWnd != NULL);
		CToolInfo ti(0, hWnd, nIDTool, NULL, lpstrText);
		::SendMessage(m_hWnd, TTM_GETTEXT, 0, ti);
	}
	BOOL GetToolInfo(LPTOOLINFO lpToolInfo) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TTM_GETTOOLINFO, 0, (LPARAM)lpToolInfo);
	}
	BOOL GetToolInfo(HWND hWnd, UINT nIDTool, UINT* puFlags, LPRECT lpRect, LPTSTR lpstrText) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(hWnd != NULL);
		CToolInfo ti(0, hWnd, nIDTool, NULL, lpstrText);
		BOOL bRet = (BOOL)::SendMessage(m_hWnd, TTM_GETTOOLINFO, 0, ti);
		if(bRet)
		{
			*puFlags = ti.uFlags;
			memcpy(lpRect, &(ti.rect), sizeof(RECT));
		}
		return bRet;
	}
	void SetToolInfo(LPTOOLINFO lpToolInfo)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TTM_SETTOOLINFO, 0, (LPARAM)lpToolInfo);
	}
	void SetToolRect(LPTOOLINFO lpToolInfo)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TTM_NEWTOOLRECT, 0, (LPARAM)lpToolInfo);
	}
	void SetToolRect(HWND hWnd, UINT nIDTool, LPCRECT lpRect)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(hWnd != NULL);
		ATLASSERT(nIDTool != 0);

		CToolInfo ti(0, hWnd, nIDTool, (LPRECT)lpRect, NULL);
		::SendMessage(m_hWnd, TTM_NEWTOOLRECT, 0, ti);
	}
	int GetToolCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TTM_GETTOOLCOUNT, 0, 0L);
	}
	int GetDelayTime(DWORD dwType) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TTM_GETDELAYTIME, dwType, 0L);
	}
	void SetDelayTime(DWORD dwType, int nTime)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TTM_SETDELAYTIME, dwType, MAKELPARAM(nTime, 0));
	}
	void GetMargin(LPRECT lpRect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TTM_GETMARGIN, 0, (LPARAM)lpRect);
	}
	void SetMargin(LPRECT lpRect)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TTM_SETMARGIN, 0, (LPARAM)lpRect);
	}
	int GetMaxTipWidth() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TTM_GETMAXTIPWIDTH, 0, 0L);
	}
	int SetMaxTipWidth(int nWidth)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TTM_SETMAXTIPWIDTH, 0, nWidth);
	}
	COLORREF GetTipBkColor() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, TTM_GETTIPBKCOLOR, 0, 0L);
	}
	void SetTipBkColor(COLORREF clr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TTM_SETTIPBKCOLOR, (WPARAM)clr, 0L);
	}
	COLORREF GetTipTextColor() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, TTM_GETTIPTEXTCOLOR, 0, 0L);
	}
	void SetTipTextColor(COLORREF clr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TTM_SETTIPTEXTCOLOR, (WPARAM)clr, 0L);
	}
	BOOL GetCurrentTool(LPTOOLINFO lpToolInfo) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TTM_GETCURRENTTOOL, 0, (LPARAM)lpToolInfo);
	}

#if (_WIN32_IE >= 0x0500)
	SIZE GetBubbleSize(LPTOOLINFO lpToolInfo) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, TTM_GETBUBBLESIZE, 0, (LPARAM)lpToolInfo);
		SIZE size = { GET_X_LPARAM(dwRet), GET_Y_LPARAM(dwRet) };
		return size;
	}
	BOOL SetTitle(UINT uIcon, LPCTSTR lpstrTitle)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TTM_SETTITLE, uIcon, (LPARAM)lpstrTitle);
	}
#endif //(_WIN32_IE >= 0x0500)

// Operations
	void Activate(BOOL bActivate)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TTM_ACTIVATE, bActivate, 0L);
	}
	BOOL AddTool(LPTOOLINFO lpToolInfo)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TTM_ADDTOOL, 0, (LPARAM)lpToolInfo);
	}
	BOOL AddTool(HWND hWnd, _U_STRINGorID text = LPSTR_TEXTCALLBACK, LPCRECT lpRectTool = NULL, UINT nIDTool = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(hWnd != NULL);
		// the toolrect and toolid must both be zero or both valid
		ATLASSERT((lpRectTool != NULL && nIDTool != 0) || (lpRectTool == NULL && nIDTool == 0));

		CToolInfo ti(0, hWnd, nIDTool, (LPRECT)lpRectTool, (LPTSTR)text.m_lpstr);
		return (BOOL)::SendMessage(m_hWnd, TTM_ADDTOOL, 0, ti);
	}
	void DelTool(LPTOOLINFO lpToolInfo)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TTM_DELTOOL, 0, (LPARAM)lpToolInfo);
	}
	void DelTool(HWND hWnd, UINT nIDTool = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(hWnd != NULL);

		CToolInfo ti(0, hWnd, nIDTool, NULL, NULL);
		::SendMessage(m_hWnd, TTM_DELTOOL, 0, ti);
	}
	BOOL HitTest(LPTTHITTESTINFO lpHitTestInfo) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TTM_HITTEST, 0, (LPARAM)lpHitTestInfo);
	}
	BOOL HitTest(HWND hWnd, POINT pt, LPTOOLINFO lpToolInfo) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(hWnd != NULL);
		ATLASSERT(lpToolInfo != NULL);

		TTHITTESTINFO hti;
		memset(&hti, 0, sizeof(hti));
		hti.ti.cbSize = sizeof(TOOLINFO);
		hti.hwnd = hWnd;
		hti.pt.x = pt.x;
		hti.pt.y = pt.y;
		if((BOOL)::SendMessage(m_hWnd, TTM_HITTEST, 0, (LPARAM)&hti))
		{
			memcpy(lpToolInfo, &hti.ti, sizeof(TOOLINFO));
			return TRUE;
		}
		return FALSE;
	}
	void RelayEvent(LPMSG lpMsg)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TTM_RELAYEVENT, 0, (LPARAM)lpMsg);
	}
	void UpdateTipText(LPTOOLINFO lpToolInfo)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TTM_UPDATETIPTEXT, 0, (LPARAM)lpToolInfo);
	}
	void UpdateTipText(_U_STRINGorID text, HWND hWnd, UINT nIDTool = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(hWnd != NULL);

		CToolInfo ti(0, hWnd, nIDTool, NULL, (LPTSTR)text.m_lpstr);
		::SendMessage(m_hWnd, TTM_UPDATETIPTEXT, 0, ti);
	}

	BOOL EnumTools(UINT nTool, LPTOOLINFO lpToolInfo) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TTM_ENUMTOOLS, nTool, (LPARAM)lpToolInfo);
	}
	void Pop()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TTM_POP, 0, 0L);
	}
	void TrackActivate(LPTOOLINFO lpToolInfo, BOOL bActivate)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TTM_TRACKACTIVATE, bActivate, (LPARAM)lpToolInfo);
	}
	void TrackPosition(int xPos, int yPos)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TTM_TRACKPOSITION, 0, MAKELPARAM(xPos, yPos));
	}

#if (_WIN32_IE >= 0x0400)
	void Update()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TTM_UPDATE, 0, 0L);
	}
#endif //(_WIN32_IE >= 0x0400)

#if (_WIN32_IE >= 0x0500)
	BOOL AdjustRect(LPRECT lpRect, BOOL bLarger /*= TRUE*/)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TTM_ADJUSTRECT, bLarger, (LPARAM)lpRect);
	}
#endif //(_WIN32_IE >= 0x0500)
};

typedef CToolTipCtrlT<CWindow>		CToolTipCtrl;


/////////////////////////////////////////////////////////////////////////////
// CHeaderCtrl

template <class TBase>
class CHeaderCtrlT : public TBase
{
public:
// Constructors
	CHeaderCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }

	CHeaderCtrlT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return WC_HEADER;
	}

	int GetItemCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, HDM_GETITEMCOUNT, 0, 0L);
	}
	BOOL GetItem(int nIndex, LPHDITEM pHeaderItem) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, HDM_GETITEM, nIndex, (LPARAM)pHeaderItem);
	}
	BOOL SetItem(int nIndex, LPHDITEM pHeaderItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, HDM_SETITEM, nIndex, (LPARAM)pHeaderItem);
	}
	CImageList GetImageList() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, HDM_GETIMAGELIST, 0, 0L));
	}
	CImageList SetImageList(HIMAGELIST hImageList)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, HDM_SETIMAGELIST, 0, (LPARAM)hImageList));
	}
	BOOL GetOrderArray(int nSize, int* lpnArray) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, HDM_GETORDERARRAY, nSize, (LPARAM)lpnArray);
	}
	BOOL SetOrderArray(int nSize, int* lpnArray)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, HDM_SETORDERARRAY, nSize, (LPARAM)lpnArray);
	}
	BOOL GetItemRect(int nIndex, LPRECT lpItemRect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, HDM_GETITEMRECT, nIndex, (LPARAM)lpItemRect);
	}
	int SetHotDivider(BOOL bPos, DWORD dwInputValue)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, HDM_SETHOTDIVIDER, bPos, dwInputValue);
	}

#if (_WIN32_IE >= 0x0400)
	BOOL GetUnicodeFormat() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, HDM_GETUNICODEFORMAT, 0, 0L);
	}
	BOOL SetUnicodeFormat(BOOL bUnicode = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, HDM_SETUNICODEFORMAT, bUnicode, 0L);
	}
#endif //(_WIN32_IE >= 0x0400)

#if (_WIN32_IE >= 0x0500)
	int GetBitmapMargin() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, HDM_GETBITMAPMARGIN, 0, 0L);
	}
	int SetBitmapMargin(int nWidth)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, HDM_SETBITMAPMARGIN, nWidth, 0L);
	}
	int SetFilterChangeTimeout(DWORD dwTimeOut)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, HDM_SETFILTERCHANGETIMEOUT, 0, dwTimeOut);
	}
#endif //(_WIN32_IE >= 0x0500)

// Operations
	int InsertItem(int nIndex, LPHDITEM phdi)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, HDM_INSERTITEM, nIndex, (LPARAM)phdi);
	}
	BOOL DeleteItem(int nIndex)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, HDM_DELETEITEM, nIndex, 0L);
	}
	BOOL Layout(HD_LAYOUT* pHeaderLayout)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, HDM_LAYOUT, 0, (LPARAM)pHeaderLayout);
	}
	int HitTest(LPHDHITTESTINFO lpHitTestInfo) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, HDM_HITTEST, 0, (LPARAM)lpHitTestInfo);
	}
	int OrderToIndex(int nOrder)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, HDM_ORDERTOINDEX, nOrder, 0L);
	}
	CImageList CreateDragImage(int nIndex)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, HDM_CREATEDRAGIMAGE, nIndex, 0L));
	}

#if (_WIN32_IE >= 0x0500)
	int EditFilter(int nColumn, BOOL bDiscardChanges)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, HDM_EDITFILTER, nColumn, MAKELPARAM(bDiscardChanges, 0));
	}
	int ClearFilter(int nColumn)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, HDM_CLEARFILTER, nColumn, 0L);
	}
	int ClearAllFilters()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, HDM_CLEARFILTER, (WPARAM)-1, 0L);
	}
#endif //(_WIN32_IE >= 0x0500)
};

typedef CHeaderCtrlT<CWindow>		CHeaderCtrl;


/////////////////////////////////////////////////////////////////////////////
// CListViewCtrl

template <class TBase>
class CListViewCtrlT : public TBase
{
public:
// Constructors
	CListViewCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }

	CListViewCtrlT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return WC_LISTVIEW;
	}

	COLORREF GetBkColor() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, LVM_GETBKCOLOR, 0, 0L);
	}
	BOOL SetBkColor(COLORREF cr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_SETBKCOLOR, 0, cr);
	}
	CImageList GetImageList(int nImageListType) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, LVM_GETIMAGELIST, nImageListType, 0L));
	}
	CImageList SetImageList(HIMAGELIST hImageList, int nImageList)
	{
		ATLASSERT(::IsWindow(m_hWnd)); 
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, LVM_SETIMAGELIST, nImageList, (LPARAM)hImageList));
	}
	int GetItemCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LVM_GETITEMCOUNT, 0, 0L);
	}
	void SetItemCount(int nItems)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, LVM_SETITEMCOUNT, nItems, 0L);
	}
	BOOL GetItem(LPLVITEM pItem) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_GETITEM, 0, (LPARAM)pItem);
	}
	BOOL SetItem(const LVITEM* pItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_SETITEM, 0, (LPARAM)pItem);
	}
	BOOL SetItem(int nItem, int nSubItem, UINT nMask, LPCTSTR lpszItem,
		int nImage, UINT nState, UINT nStateMask, LPARAM lParam)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		LVITEM lvi;
		lvi.mask = nMask;
		lvi.iItem = nItem;
		lvi.iSubItem = nSubItem;
		lvi.stateMask = nStateMask;
		lvi.state = nState;
		lvi.pszText = (LPTSTR) lpszItem;
		lvi.iImage = nImage;
		lvi.lParam = lParam;
		return (BOOL)::SendMessage(m_hWnd, LVM_SETITEM, 0, (LPARAM)&lvi);
	}
	UINT GetItemState(int nItem, UINT nMask) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, LVM_GETITEMSTATE, nItem, nMask);
	}
	BOOL SetItemState(int nItem, UINT nState, UINT nStateMask)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return SetItem(nItem, 0, LVIF_STATE, NULL, 0, nState, nStateMask, 0);
	}
	BOOL SetItemState(int nItem, LPLVITEM pItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_SETITEMSTATE, nItem, (LPARAM)pItem);
	}

#ifndef _ATL_NO_COM
	BOOL GetItemText(int nItem, int nSubItem, BSTR& bstrText) const
	{
		USES_CONVERSION;
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(bstrText == NULL);
		LVITEM lvi;
		memset(&lvi, 0, sizeof(LVITEM));
		lvi.iSubItem = nSubItem;

		LPTSTR lpstrText = NULL;
		int nRes = 0;
		for(int nLen = 256; ; nLen *= 2)
		{
			ATLTRY(lpstrText = new TCHAR[nLen]);
			if(lpstrText == NULL)
				break;
			lpstrText[0] = NULL;
			lvi.cchTextMax = nLen;
			lvi.pszText = lpstrText;
			nRes  = (int)::SendMessage(m_hWnd, LVM_GETITEMTEXT, (WPARAM)nItem, (LPARAM)&lvi);
			if(nRes < nLen - 1)
				break;
			delete [] lpstrText;
			lpstrText = NULL;
		}

		if(lpstrText != NULL)
		{
			if(nRes != 0)
				bstrText = ::SysAllocString(T2OLE(lpstrText));
			delete [] lpstrText;
		}

		return (bstrText != NULL) ? TRUE : FALSE;
	}
#endif //!_ATL_NO_COM

#ifdef __ATLSTR_H__
	int GetItemText(int nItem, int nSubItem, CString& strText) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		LVITEM lvi;
		memset(&lvi, 0, sizeof(LVITEM));
		lvi.iSubItem = nSubItem;

		strText.Empty();
		int nRes = 0;
		for(int nLen = 256; ; nLen *= 2)
		{
			lvi.cchTextMax = nLen;
			lvi.pszText = strText.GetBufferSetLength(nLen);
			nRes  = (int)::SendMessage(m_hWnd, LVM_GETITEMTEXT, (WPARAM)nItem, (LPARAM)&lvi);
			if(nRes < nLen - 1)
				break;
		}
		strText.ReleaseBuffer();
		return nRes;
	}
#endif //__ATLSTR_H__

	int GetItemText(int nItem, int nSubItem, LPTSTR lpszText, int nLen) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		LVITEM lvi;
		memset(&lvi, 0, sizeof(LVITEM));
		lvi.iSubItem = nSubItem;
		lvi.cchTextMax = nLen;
		lvi.pszText = lpszText;
		return (int)::SendMessage(m_hWnd, LVM_GETITEMTEXT, (WPARAM)nItem, (LPARAM)&lvi);
	}
	BOOL SetItemText(int nItem, int nSubItem, LPCTSTR lpszText)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return SetItem(nItem, nSubItem, LVIF_TEXT, lpszText, 0, 0, 0, 0);
	}
	DWORD_PTR GetItemData(int nItem) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		LVITEM lvi;
		memset(&lvi, 0, sizeof(LVITEM));
		lvi.iItem = nItem;
		lvi.mask = LVIF_PARAM;
		::SendMessage(m_hWnd, LVM_GETITEM, 0, (LPARAM)&lvi);
		return (DWORD_PTR)lvi.lParam;
	}
	BOOL SetItemData(int nItem, DWORD_PTR dwData)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return SetItem(nItem, 0, LVIF_PARAM, NULL, 0, 0, 0, (LPARAM)dwData);
	}
	UINT GetCallbackMask() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, LVM_GETCALLBACKMASK, 0, 0L);
	}
	BOOL SetCallbackMask(UINT nMask)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_SETCALLBACKMASK, nMask, 0L);
	}
	BOOL GetItemPosition(int nItem, LPPOINT lpPoint) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_GETITEMPOSITION, nItem, (LPARAM)lpPoint);
	}
	BOOL SetItemPosition(int nItem, POINT pt)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(((GetStyle() & LVS_TYPEMASK) == LVS_ICON) || ((GetStyle() & LVS_TYPEMASK) == LVS_SMALLICON));
		return (BOOL)::SendMessage(m_hWnd, LVM_SETITEMPOSITION32, nItem, (LPARAM)&pt);
	}
	BOOL SetItemPosition(int nItem, int x, int y)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(((GetStyle() & LVS_TYPEMASK) == LVS_ICON) || ((GetStyle() & LVS_TYPEMASK) == LVS_SMALLICON));
		POINT pt = { x, y };
		return (BOOL)::SendMessage(m_hWnd, LVM_SETITEMPOSITION32, nItem, (LPARAM)&pt);
	}
	int GetStringWidth(LPCTSTR lpsz) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LVM_GETSTRINGWIDTH, 0, (LPARAM)lpsz);
	}
	CEdit GetEditControl() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CEdit((HWND)::SendMessage(m_hWnd, LVM_GETEDITCONTROL, 0, 0L));
	}
	BOOL GetColumn(int nCol, LV_COLUMN* pColumn) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_GETCOLUMN, nCol, (LPARAM)pColumn);
	}
	BOOL SetColumn(int nCol, const LV_COLUMN* pColumn)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_SETCOLUMN, nCol, (LPARAM)pColumn);
	}
	int GetColumnWidth(int nCol) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LVM_GETCOLUMNWIDTH, nCol, 0L);
	}
	BOOL SetColumnWidth(int nCol, int cx)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_SETCOLUMNWIDTH, nCol, MAKELPARAM(cx, 0));
	}
	BOOL GetViewRect(LPRECT lpRect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_GETVIEWRECT, 0, (LPARAM)lpRect);
	}
	COLORREF GetTextColor() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, LVM_GETTEXTCOLOR, 0, 0L);
	}
	BOOL SetTextColor(COLORREF cr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_SETTEXTCOLOR, 0, cr);
	}
	COLORREF GetTextBkColor() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, LVM_GETTEXTBKCOLOR, 0, 0L);
	}
	BOOL SetTextBkColor(COLORREF cr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_SETTEXTBKCOLOR, 0, cr);
	}
	int GetTopIndex() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LVM_GETTOPINDEX, 0, 0L);
	}
	int GetCountPerPage() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LVM_GETCOUNTPERPAGE, 0, 0L);
	}
	BOOL GetOrigin(LPPOINT lpPoint) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_GETORIGIN, 0, (LPARAM)lpPoint);
	}
	UINT GetSelectedCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, LVM_GETSELECTEDCOUNT, 0, 0L);
	}

	BOOL GetItemRect(int nItem, LPRECT lpRect, UINT nCode) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		lpRect->left = nCode;
		return (BOOL)::SendMessage(m_hWnd, LVM_GETITEMRECT, (WPARAM)nItem, (LPARAM)lpRect);
	}

	HCURSOR GetHotCursor() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HCURSOR)::SendMessage(m_hWnd, LVM_GETHOTCURSOR, 0, 0L);
	}
	HCURSOR SetHotCursor(HCURSOR hHotCursor)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HCURSOR)::SendMessage(m_hWnd, LVM_SETHOTCURSOR, 0, (LPARAM)hHotCursor);
	}
	int GetHotItem() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LVM_GETHOTITEM, 0, 0L);
	}
	int SetHotItem(int nIndex)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LVM_SETHOTITEM, nIndex, 0L);
	}
	BOOL GetColumnOrderArray(int nCount, int* lpnArray) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_GETCOLUMNORDERARRAY, nCount, (LPARAM)lpnArray);
	}
	BOOL SetColumnOrderArray(int nCount, int* lpnArray)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_SETCOLUMNORDERARRAY, nCount, (LPARAM)lpnArray);
	}
	CHeaderCtrl GetHeader() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CHeaderCtrl((HWND)::SendMessage(m_hWnd, LVM_GETHEADER, 0, 0L));
	}
	BOOL GetSubItemRect(int nItem, int nSubItem, int nFlag, LPRECT lpRect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & LVS_TYPEMASK) == LVS_REPORT);
		ATLASSERT(lpRect != NULL);
		lpRect->top = nSubItem;
		lpRect->left = nFlag;
		return (BOOL)::SendMessage(m_hWnd, LVM_GETSUBITEMRECT, nItem, (LPARAM)lpRect);
	}
	DWORD SetIconSpacing(int cx, int cy)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & LVS_TYPEMASK) == LVS_ICON);
		return (DWORD)::SendMessage(m_hWnd, LVM_SETICONSPACING, 0, MAKELPARAM(cx, cy));
	}
	int GetISearchString(LPTSTR lpstr) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LVM_GETISEARCHSTRING, 0, (LPARAM)lpstr);
	}
	void GetItemSpacing(SIZE& sizeSpacing, BOOL bSmallIconView = FALSE) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, LVM_GETITEMSPACING, bSmallIconView, 0L);
		sizeSpacing.cx = GET_X_LPARAM(dwRet);
		sizeSpacing.cy = GET_Y_LPARAM(dwRet);
	}

	// single-selection only
	int GetSelectedIndex() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & LVS_SINGLESEL) != 0);
		return (int)::SendMessage(m_hWnd, LVM_GETNEXTITEM, (WPARAM)-1, MAKELPARAM(LVNI_ALL | LVNI_SELECTED, 0));
	}
	BOOL GetSelectedItem(LPLVITEM pItem) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & LVS_SINGLESEL) != 0);
		ATLASSERT(pItem != NULL);
		pItem->iItem = (int)::SendMessage(m_hWnd, LVM_GETNEXTITEM, (WPARAM)-1, MAKELPARAM(LVNI_ALL | LVNI_SELECTED, 0));
		if(pItem->iItem == -1)
			return FALSE;
		return (BOOL)::SendMessage(m_hWnd, LVM_GETITEM, 0, (LPARAM)pItem);
	}

	// extended list view styles
	DWORD GetExtendedListViewStyle() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0L);
	}
	// dwExMask = 0 means all styles
	DWORD SetExtendedListViewStyle(DWORD dwExStyle, DWORD dwExMask = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, LVM_SETEXTENDEDLISTVIEWSTYLE, dwExMask, dwExStyle);
	}

	// checkboxes only
	BOOL GetCheckState(int nIndex) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetExtendedListViewStyle() & LVS_EX_CHECKBOXES) != 0);
		UINT uRet = GetItemState(nIndex, LVIS_STATEIMAGEMASK);
		return (uRet >> 12) - 1;
	}
	BOOL SetCheckState(int nItem, BOOL bCheck)
	{
		int nCheck = bCheck ? 2 : 1;	// one based index
		return SetItemState(nItem, INDEXTOSTATEIMAGEMASK(nCheck), LVIS_STATEIMAGEMASK);
	}

	// view type
	DWORD GetViewType() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (GetStyle() & LVS_TYPEMASK);
	}

	DWORD SetViewType(DWORD dwType)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(dwType == LVS_ICON || dwType == LVS_SMALLICON || dwType == LVS_LIST || dwType == LVS_REPORT);
		DWORD dwOldType = GetViewType();
		if(dwType != dwOldType)
			ModifyStyle(LVS_TYPEMASK, (dwType & LVS_TYPEMASK));
		return dwOldType;
	}

#if (_WIN32_IE >= 0x0400)
	BOOL GetBkImage(LPLVBKIMAGE plvbki) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_GETBKIMAGE, 0, (LPARAM)plvbki);
	}
	BOOL SetBkImage(LPLVBKIMAGE plvbki)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_SETBKIMAGE, 0, (LPARAM)plvbki);
	}
	int GetSelectionMark() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LVM_GETSELECTIONMARK, 0, 0L);
	}
	int SetSelectionMark(int nIndex)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LVM_SETSELECTIONMARK, 0, nIndex);
	}
	BOOL GetWorkAreas(int nWorkAreas, LPRECT lpRect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_GETWORKAREAS, nWorkAreas, (LPARAM)lpRect);
	}
	BOOL SetWorkAreas(int nWorkAreas, LPRECT lpRect)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_SETWORKAREAS, nWorkAreas, (LPARAM)lpRect);
	}
	DWORD GetHoverTime() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetExtendedListViewStyle() & (LVS_EX_TRACKSELECT | LVS_EX_ONECLICKACTIVATE | LVS_EX_TWOCLICKACTIVATE)) != 0);
		return (DWORD)::SendMessage(m_hWnd, LVM_GETHOVERTIME, 0, 0L);
	}
	DWORD SetHoverTime(DWORD dwHoverTime)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetExtendedListViewStyle() & (LVS_EX_TRACKSELECT | LVS_EX_ONECLICKACTIVATE | LVS_EX_TWOCLICKACTIVATE)) != 0);
		return (DWORD)::SendMessage(m_hWnd, LVM_SETHOVERTIME, 0, dwHoverTime);
	}
	BOOL GetNumberOfWorkAreas(int* pnWorkAreas) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_GETNUMBEROFWORKAREAS, 0, (LPARAM)pnWorkAreas);
	}
	void SetItemCountEx(int nItems, DWORD dwFlags)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(((GetStyle() & LVS_OWNERDATA) != 0) && (((GetStyle() & LVS_TYPEMASK) == LVS_REPORT) || ((GetStyle() & LVS_TYPEMASK) == LVS_LIST)));
		::SendMessage(m_hWnd, LVM_SETITEMCOUNT, nItems, dwFlags);
	}
	CToolTipCtrl GetToolTips() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CToolTipCtrl((HWND)::SendMessage(m_hWnd, LVM_GETTOOLTIPS, 0, 0L));
	}
	CToolTipCtrl SetToolTips(HWND hWndTT)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CToolTipCtrl((HWND)::SendMessage(m_hWnd, LVM_SETTOOLTIPS, (WPARAM)hWndTT, 0L));
	}
	BOOL GetUnicodeFormat() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_GETUNICODEFORMAT, 0, 0L);
	}
	BOOL SetUnicodeFormat(BOOL bUnicode = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_SETUNICODEFORMAT, bUnicode, 0L);
	}
#endif //(_WIN32_IE >= 0x0400)

// Operations
	int InsertColumn(int nCol, const LV_COLUMN* pColumn)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LVM_INSERTCOLUMN, nCol, (LPARAM)pColumn);
	}
	int InsertColumn(int nCol, LPCTSTR lpszColumnHeading, int nFormat, int nWidth, int nSubItem)
	{
		LV_COLUMN column;
		column.mask = LVCF_TEXT|LVCF_FMT;
		column.pszText = (LPTSTR)lpszColumnHeading;
		column.fmt = nFormat;
		if (nWidth != -1)
		{
			column.mask |= LVCF_WIDTH;
			column.cx = nWidth;
		}
		if (nSubItem != -1)
		{
			column.mask |= LVCF_SUBITEM;
			column.iSubItem = nSubItem;
		}
		return InsertColumn(nCol, &column);
	}
	BOOL DeleteColumn(int nCol)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_DELETECOLUMN, nCol, 0L);
	}
	int InsertItem(UINT nMask, int nItem, LPCTSTR lpszItem, UINT nState, UINT nStateMask, int nImage, LPARAM lParam)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		LVITEM item;
		item.mask = nMask;
		item.iItem = nItem;
		item.iSubItem = 0;
		item.pszText = (LPTSTR)lpszItem;
		item.state = nState;
		item.stateMask = nStateMask;
		item.iImage = nImage;
		item.lParam = lParam;
		return InsertItem(&item);
	}
	int InsertItem(const LVITEM* pItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LVM_INSERTITEM, 0, (LPARAM)pItem);
	}
	int InsertItem(int nItem, LPCTSTR lpszItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return InsertItem(LVIF_TEXT, nItem, lpszItem, 0, 0, 0, 0);
	}
	int InsertItem(int nItem, LPCTSTR lpszItem, int nImage)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return InsertItem(LVIF_TEXT|LVIF_IMAGE, nItem, lpszItem, 0, 0, nImage, 0);
	}
	int GetNextItem(int nItem, int nFlags) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LVM_GETNEXTITEM, nItem, MAKELPARAM(nFlags, 0));
	}
	BOOL DeleteItem(int nItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_DELETEITEM, nItem, 0L);
	}
	BOOL DeleteAllItems()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_DELETEALLITEMS, 0, 0L);
	}
	int FindItem(LV_FINDINFO* pFindInfo, int nStart) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LVM_FINDITEM, nStart, (LPARAM)pFindInfo);
	}
	int HitTest(LV_HITTESTINFO* pHitTestInfo) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LVM_HITTEST, 0, (LPARAM)pHitTestInfo);
	}
	int HitTest(POINT pt, UINT* pFlags) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		LV_HITTESTINFO hti;
		hti.pt = pt;
		int nRes = (int)::SendMessage(m_hWnd, LVM_HITTEST, 0, (LPARAM)&hti);
		if (pFlags != NULL)
			*pFlags = hti.flags;
		return nRes;
	}
	BOOL EnsureVisible(int nItem, BOOL bPartialOK)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_ENSUREVISIBLE, nItem, MAKELPARAM(bPartialOK, 0));
	}
	BOOL Scroll(SIZE size)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_SCROLL, size.cx, size.cy);
	}
	BOOL RedrawItems(int nFirst, int nLast)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_REDRAWITEMS, nFirst, nLast);
	}
	BOOL Arrange(UINT nCode)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_ARRANGE, nCode, 0L);
	}
	CEdit EditLabel(int nItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CEdit((HWND)::SendMessage(m_hWnd, LVM_EDITLABEL, nItem, 0L));
	}
	BOOL Update(int nItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_UPDATE, nItem, 0L);
	}
	BOOL SortItems(PFNLVCOMPARE pfnCompare, DWORD dwData)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_SORTITEMS, dwData, (LPARAM)pfnCompare);
	}
	CImageList RemoveImageList(int nImageList)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, LVM_SETIMAGELIST, (WPARAM)nImageList, NULL));
	}

	CImageList CreateDragImage(int nItem, LPPOINT lpPoint)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, LVM_CREATEDRAGIMAGE, nItem, (LPARAM)lpPoint));
	}
	DWORD ApproximateViewRect(int cx = -1, int cy = -1, int nCount = -1)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, LVM_APPROXIMATEVIEWRECT, nCount, MAKELPARAM(cx, cy));
	}
	int SubItemHitTest(LPLVHITTESTINFO lpInfo)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LVM_SUBITEMHITTEST, 0, (LPARAM)lpInfo);
	}

	int AddColumn(LPCTSTR strItem, int nItem, int nSubItem = -1,
			int nMask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM,
			int nFmt = LVCFMT_LEFT)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		LV_COLUMN lvc;
		lvc.mask = nMask;
		lvc.fmt = nFmt;
		lvc.pszText = (LPTSTR)strItem;
		lvc.cx = GetStringWidth(lvc.pszText) + 15;
		if(nMask & LVCF_SUBITEM)
			lvc.iSubItem = (nSubItem != -1) ? nSubItem : nItem;
		return InsertColumn(nItem, &lvc);
	}
	int AddItem(int nItem, int nSubItem, LPCTSTR strItem, int nImageIndex = -1)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		LVITEM lvItem;
		lvItem.mask = LVIF_TEXT;
		lvItem.iItem = nItem;
		lvItem.iSubItem = nSubItem;
		lvItem.pszText = (LPTSTR)strItem;
		if(nImageIndex != -1)
		{
			lvItem.mask |= LVIF_IMAGE;
			lvItem.iImage = nImageIndex;
		}
		if(nSubItem == 0)
			return InsertItem(&lvItem);
		return SetItem(&lvItem) ? nItem : -1;
	}

	// single-selection only
	BOOL SelectItem(int nIndex)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & LVS_SINGLESEL) != 0);

		BOOL bRet = SetItemState(nIndex, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
		if(bRet)
			bRet = EnsureVisible(nIndex, FALSE);
		return bRet;
	}
};

typedef CListViewCtrlT<CWindow>		CListViewCtrl;


/////////////////////////////////////////////////////////////////////////////
// CTreeViewCtrl

template <class TBase>
class CTreeViewCtrlT : public TBase
{
public:
// Constructors
	CTreeViewCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }

	CTreeViewCtrlT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return WC_TREEVIEW;
	}

	UINT GetCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, TVM_GETCOUNT, 0, 0L);
	}
	UINT GetIndent() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, TVM_GETINDENT, 0, 0L);
	}
	void SetIndent(UINT nIndent)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TVM_SETINDENT, nIndent, 0L);
	}
	CImageList GetImageList(UINT nImageList) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TVM_GETIMAGELIST, (UINT)nImageList, 0L));
	}
	CImageList SetImageList(HIMAGELIST hImageList, int nImageListType)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TVM_SETIMAGELIST, (UINT)nImageListType, (LPARAM)hImageList));
	}
	BOOL GetItem(LPTVITEM pItem) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)pItem);
	}
	BOOL SetItem(LPTVITEM pItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TVM_SETITEM, 0, (LPARAM)pItem);
	}
	BOOL SetItem(HTREEITEM hItem, UINT nMask, LPCTSTR lpszItem, int nImage,
		int nSelectedImage, UINT nState, UINT nStateMask, LPARAM lParam)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		TVITEM item;
		item.hItem = hItem;
		item.mask = nMask;
		item.pszText = (LPTSTR) lpszItem;
		item.iImage = nImage;
		item.iSelectedImage = nSelectedImage;
		item.state = nState;
		item.stateMask = nStateMask;
		item.lParam = lParam;
		return (BOOL)::SendMessage(m_hWnd, TVM_SETITEM, 0, (LPARAM)&item);
	}
	BOOL GetItemText(HTREEITEM hItem, LPTSTR lpstrText, int nLen) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(lpstrText != NULL);

		TVITEM item;
		item.hItem = hItem;
		item.mask = TVIF_TEXT;
		item.pszText = lpstrText;
		item.cchTextMax = nLen;

		return (BOOL)::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)&item);
	}

#ifndef _ATL_NO_COM
	BOOL GetItemText(HTREEITEM hItem, BSTR& bstrText) const
	{
		USES_CONVERSION;
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(bstrText == NULL);
		TVITEM item;
		item.hItem = hItem;
		item.mask = TVIF_TEXT;

		LPTSTR lpstrText = NULL;
		BOOL bRet = FALSE;
		for(int nLen = 256; ; nLen *= 2)
		{
			ATLTRY(lpstrText = new TCHAR[nLen]);
			if(lpstrText == NULL)
				break;
			lpstrText[0] = NULL;
			item.pszText = lpstrText;
			item.cchTextMax = nLen;
			bRet = (BOOL)::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)&item);
			if(!bRet || (lstrlen(item.pszText) < nLen - 1))
				break;
			delete [] lpstrText;
			lpstrText = NULL;
		}

		if(lpstrText != NULL)
		{
			if(bRet)
				bstrText = ::SysAllocString(T2OLE(lpstrText));
			delete [] lpstrText;
		}

		return (bstrText != NULL) ? TRUE : FALSE;
	}
#endif //!_ATL_NO_COM

#ifdef __ATLSTR_H__
	BOOL GetItemText(HTREEITEM hItem, CString& strText) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		TVITEM item;
		item.hItem = hItem;
		item.mask = TVIF_TEXT;

		strText.Empty();
		BOOL bRet = FALSE;
		for(int nLen = 256; ; nLen *= 2)
		{
			item.pszText = strText.GetBufferSetLength(nLen);
			item.cchTextMax = nLen;
			bRet = (BOOL)::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)&item);
			if(!bRet || (lstrlen(item.pszText) < nLen - 1))
				break;
		}
		strText.ReleaseBuffer();
		return bRet;
	}
#endif //__ATLSTR_H__
	BOOL SetItemText(HTREEITEM hItem, LPCTSTR lpszItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return SetItem(hItem, TVIF_TEXT, lpszItem, 0, 0, 0, 0, NULL);
	}
	BOOL GetItemImage(HTREEITEM hItem, int& nImage, int& nSelectedImage) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		TVITEM item;
		item.hItem = hItem;
		item.mask = TVIF_IMAGE|TVIF_SELECTEDIMAGE;
		BOOL bRes = (BOOL)::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)&item);
		if (bRes)
		{
			nImage = item.iImage;
			nSelectedImage = item.iSelectedImage;
		}
		return bRes;
	}
	BOOL SetItemImage(HTREEITEM hItem, int nImage, int nSelectedImage)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return SetItem(hItem, TVIF_IMAGE|TVIF_SELECTEDIMAGE, NULL, nImage, nSelectedImage, 0, 0, NULL);
	}
	UINT GetItemState(HTREEITEM hItem, UINT nStateMask) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		TVITEM item;
		item.hItem = hItem;
		item.mask = TVIF_STATE;
		item.stateMask = nStateMask;
		item.state = 0;
		::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)&item);
		return item.state;
	}
	BOOL SetItemState(HTREEITEM hItem, UINT nState, UINT nStateMask)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return SetItem(hItem, TVIF_STATE, NULL, 0, 0, nState, nStateMask, NULL);
	}
	DWORD_PTR GetItemData(HTREEITEM hItem) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		TVITEM item;
		item.hItem = hItem;
		item.mask = TVIF_PARAM;
		::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)&item);
		return (DWORD_PTR)item.lParam;
	}
	BOOL SetItemData(HTREEITEM hItem, DWORD_PTR dwData)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return SetItem(hItem, TVIF_PARAM, NULL, 0, 0, 0, 0, (LPARAM)dwData);
	}
	CEdit GetEditControl() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CEdit((HWND)::SendMessage(m_hWnd, TVM_GETEDITCONTROL, 0, 0L));
	}
	UINT GetVisibleCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, TVM_GETVISIBLECOUNT, 0, 0L);
	}
	BOOL GetItemRect(HTREEITEM hItem, LPRECT lpRect, BOOL bTextOnly) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		*(HTREEITEM*)lpRect = hItem;
		return (BOOL)::SendMessage(m_hWnd, TVM_GETITEMRECT, (WPARAM)bTextOnly, (LPARAM)lpRect);
	}
	BOOL ItemHasChildren(HTREEITEM hItem) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		TVITEM item;
		item.hItem = hItem;
		item.mask = TVIF_CHILDREN;
		::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)&item);
		return item.cChildren;
	}
	CToolTipCtrl GetToolTips() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CToolTipCtrl((HWND)::SendMessage(m_hWnd, TVM_GETTOOLTIPS, 0, 0L));
	}
	CToolTipCtrl SetToolTips(HWND hWndTT)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CToolTipCtrl((HWND)::SendMessage(m_hWnd, TVM_SETTOOLTIPS, (WPARAM)hWndTT, 0L));
	}
	int GetISearchString(LPTSTR lpstr) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TVM_GETISEARCHSTRING, 0, (LPARAM)lpstr);
	}

	// checkboxes only
	BOOL GetCheckState(HTREEITEM hItem) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & TVS_CHECKBOXES) != 0);
		UINT uRet = GetItemState(hItem, TVIS_STATEIMAGEMASK);
		return (uRet >> 12) - 1;
	}
	BOOL SetCheckState(HTREEITEM hItem, BOOL bCheck)
	{
		int nCheck = bCheck ? 2 : 1;	// one based index
		return SetItemState(hItem, INDEXTOSTATEIMAGEMASK(nCheck), TVIS_STATEIMAGEMASK);
	}

#if (_WIN32_IE >= 0x0400)
	COLORREF GetBkColor() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, TVM_GETBKCOLOR, 0, 0L);
	}
	COLORREF SetBkColor(COLORREF clr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, TVM_SETBKCOLOR, 0, (LPARAM)clr);
	}
	COLORREF GetInsertMarkColor() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, TVM_GETINSERTMARKCOLOR, 0, 0L);
	}
	COLORREF SetInsertMarkColor(COLORREF clr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, TVM_SETINSERTMARKCOLOR, 0, (LPARAM)clr);
	}
	int GetItemHeight() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TVM_GETITEMHEIGHT, 0, 0L);
	}
	int SetItemHeight(int cyHeight)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TVM_SETITEMHEIGHT, cyHeight, 0L);
	}
	int GetScrollTime() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TVM_GETSCROLLTIME, 0, 0L);
	}
	int SetScrollTime(int nScrollTime)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TVM_SETSCROLLTIME, nScrollTime, 0L);
	}
	COLORREF GetTextColor() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, TVM_GETTEXTCOLOR, 0, 0L);
	}
	COLORREF SetTextColor(COLORREF clr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, TVM_SETTEXTCOLOR, 0, (LPARAM)clr);
	}
	BOOL GetUnicodeFormat() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TVM_GETUNICODEFORMAT, 0, 0L);
	}
	BOOL SetUnicodeFormat(BOOL bUnicode = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TVM_SETUNICODEFORMAT, bUnicode, 0L);
	}
#endif //(_WIN32_IE >= 0x0400)

#if (_WIN32_IE >= 0x0500)
	COLORREF GetLineColor() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, TVM_GETLINECOLOR, 0, 0L);
	}
	COLORREF SetLineColor(COLORREF clrNew /*= CLR_DEFAULT*/)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, TVM_SETLINECOLOR, 0, (LPARAM)clrNew);
	}
#endif //(_WIN32_IE >= 0x0500)

// Operations
	HTREEITEM InsertItem(LPTV_INSERTSTRUCT lpInsertStruct)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HTREEITEM)::SendMessage(m_hWnd, TVM_INSERTITEM, 0, (LPARAM)lpInsertStruct);
	}
	HTREEITEM InsertItem(LPCTSTR lpszItem, int nImage,
		int nSelectedImage, HTREEITEM hParent, HTREEITEM hInsertAfter)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return InsertItem(TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE, lpszItem, nImage, nSelectedImage, 0, 0, 0, hParent, hInsertAfter); 
	}
	HTREEITEM InsertItem(LPCTSTR lpszItem, HTREEITEM hParent, HTREEITEM hInsertAfter)
	{ 
		ATLASSERT(::IsWindow(m_hWnd));
		return InsertItem(TVIF_TEXT, lpszItem, 0, 0, 0, 0, 0, hParent, hInsertAfter);
	}
	HTREEITEM InsertItem(UINT nMask, LPCTSTR lpszItem, int nImage,
		int nSelectedImage, UINT nState, UINT nStateMask, LPARAM lParam,
		HTREEITEM hParent, HTREEITEM hInsertAfter)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		TV_INSERTSTRUCT tvis;
		tvis.hParent = hParent;
		tvis.hInsertAfter = hInsertAfter;
		tvis.item.mask = nMask;
		tvis.item.pszText = (LPTSTR) lpszItem;
		tvis.item.iImage = nImage;
		tvis.item.iSelectedImage = nSelectedImage;
		tvis.item.state = nState;
		tvis.item.stateMask = nStateMask;
		tvis.item.lParam = lParam;
		return (HTREEITEM)::SendMessage(m_hWnd, TVM_INSERTITEM, 0, (LPARAM)&tvis);
	}
	BOOL DeleteItem(HTREEITEM hItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TVM_DELETEITEM, 0, (LPARAM)hItem);
	}
	BOOL DeleteAllItems()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TVM_DELETEITEM, 0, (LPARAM)TVI_ROOT);
	}
	BOOL Expand(HTREEITEM hItem, UINT nCode = TVE_EXPAND)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TVM_EXPAND, nCode, (LPARAM)hItem);
	}
	HTREEITEM GetNextItem(HTREEITEM hItem, UINT nCode) const
	{ 
		ATLASSERT(::IsWindow(m_hWnd)); 
		return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, nCode, (LPARAM)hItem);
	}
	HTREEITEM GetChildItem(HTREEITEM hItem) const
	{
		ATLASSERT(::IsWindow(m_hWnd)); 
		return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_CHILD, (LPARAM)hItem);
	}
	HTREEITEM GetNextSiblingItem(HTREEITEM hItem) const
	{
		ATLASSERT(::IsWindow(m_hWnd)); 
		return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_NEXT, (LPARAM)hItem); 
	}
	HTREEITEM GetPrevSiblingItem(HTREEITEM hItem) const
	{
		ATLASSERT(::IsWindow(m_hWnd)); 
		return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_PREVIOUS, (LPARAM)hItem);
	}
	HTREEITEM GetParentItem(HTREEITEM hItem) const
	{
		ATLASSERT(::IsWindow(m_hWnd)); 
		return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_PARENT, (LPARAM)hItem); 
	}
	HTREEITEM GetFirstVisibleItem() const
	{
		ATLASSERT(::IsWindow(m_hWnd)); 
		return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_FIRSTVISIBLE, 0L);
	}
	HTREEITEM GetNextVisibleItem(HTREEITEM hItem) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_NEXTVISIBLE, (LPARAM)hItem);
	}
	HTREEITEM GetPrevVisibleItem(HTREEITEM hItem) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_PREVIOUSVISIBLE, (LPARAM)hItem);
	}
	HTREEITEM GetSelectedItem() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_CARET, 0L);
	}
	HTREEITEM GetDropHilightItem() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_DROPHILITE, 0L);
	}
	HTREEITEM GetRootItem() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_ROOT, 0L);
	}
	BOOL Select(HTREEITEM hItem, UINT nCode)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TVM_SELECTITEM, nCode, (LPARAM)hItem);
	}
	BOOL SelectItem(HTREEITEM hItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TVM_SELECTITEM, TVGN_CARET, (LPARAM)hItem);
	}
	BOOL SelectDropTarget(HTREEITEM hItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TVM_SELECTITEM, TVGN_DROPHILITE, (LPARAM)hItem);
	}
	BOOL SelectSetFirstVisible(HTREEITEM hItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TVM_SELECTITEM, TVGN_FIRSTVISIBLE, (LPARAM)hItem);
	}
	CEdit EditLabel(HTREEITEM hItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CEdit((HWND)::SendMessage(m_hWnd, TVM_EDITLABEL, 0, (LPARAM)hItem));
	}
	BOOL EndEditLabelNow(BOOL bCancel)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TVM_ENDEDITLABELNOW, bCancel, 0L);
	}
	HTREEITEM HitTest(TV_HITTESTINFO* pHitTestInfo)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HTREEITEM)::SendMessage(m_hWnd, TVM_HITTEST, 0, (LPARAM)pHitTestInfo);
	}
	HTREEITEM HitTest(POINT pt, UINT* pFlags)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		TV_HITTESTINFO hti;
		hti.pt = pt;
		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_HITTEST, 0, (LPARAM)&hti);
		if (pFlags != NULL)
			*pFlags = hti.flags;
		return hTreeItem;
	}
	BOOL SortChildren(HTREEITEM hItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TVM_SORTCHILDREN, 0, (LPARAM)hItem);
	}
	BOOL EnsureVisible(HTREEITEM hItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TVM_ENSUREVISIBLE, 0, (LPARAM)hItem);
	}
	BOOL SortChildrenCB(LPTV_SORTCB pSort)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TVM_SORTCHILDRENCB, 0, (LPARAM)pSort);
	}
	CImageList RemoveImageList(int nImageList)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TVM_SETIMAGELIST, (WPARAM)nImageList, NULL));
	}
	CImageList CreateDragImage(HTREEITEM hItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TVM_CREATEDRAGIMAGE, 0, (LPARAM)hItem));
	}

#if (_WIN32_IE >= 0x0400)
	BOOL SetInsertMark(HTREEITEM hTreeItem, BOOL bAfter)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TVM_SETINSERTMARK, bAfter, (LPARAM)hTreeItem);
	}
	BOOL RemoveInsertMark()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TVM_SETINSERTMARK, 0, 0L);
	}
#endif //(_WIN32_IE >= 0x0400)
};

typedef CTreeViewCtrlT<CWindow>		CTreeViewCtrl;


/////////////////////////////////////////////////////////////////////////////
// CTreeViewCtrlEx

typedef CTreeViewCtrlExT<CWindow> CTreeViewCtrlEx;	// forward declaration

class CTreeItem
{
public:
	HTREEITEM m_hTreeItem;
	CTreeViewCtrlEx* m_pTreeView;

// Construction
	CTreeItem(HTREEITEM hTreeItem = NULL, CTreeViewCtrlEx* pTreeView = NULL) : m_hTreeItem(hTreeItem), m_pTreeView(pTreeView)
	{ }
 
	CTreeItem(const CTreeItem& posSrc)
	{
		*this = posSrc;
	}

	operator HTREEITEM() { return m_hTreeItem; }

	CTreeItem& operator =(const CTreeItem& itemSrc)
	{
		m_hTreeItem = itemSrc.m_hTreeItem;
		m_pTreeView = itemSrc.m_pTreeView;
		return *this;
	}

// Attributes
	CTreeViewCtrlEx* GetTreeView() const { return m_pTreeView; }

	BOOL operator !() const { return m_hTreeItem == NULL; }
	BOOL IsNull() const { return m_hTreeItem == NULL; }
	
	BOOL GetRect(LPRECT lpRect, BOOL bTextOnly) const;
	BOOL GetText(LPTSTR lpstrText, int nLen) const;
#ifndef _ATL_NO_COM
	BOOL GetText(BSTR& bstrText) const;
#endif //!_ATL_NO_COM
#ifdef __ATLSTR_H__
	BOOL GetText(CString& strText) const;
#endif //__ATLSTR_H__
	BOOL SetText(LPCTSTR lpszItem);
	BOOL GetImage(int& nImage, int& nSelectedImage) const;
	BOOL SetImage(int nImage, int nSelectedImage);
	UINT GetState(UINT nStateMask) const;
	BOOL SetState(UINT nState, UINT nStateMask);
	DWORD_PTR GetData() const;
	BOOL SetData(DWORD_PTR dwData);
	BOOL SetItem(UINT nMask, LPCTSTR lpszItem, int nImage, int nSelectedImage, UINT nState, UINT nStateMask, LPARAM lParam);

// Operations
	CTreeItem InsertAfter(LPCTSTR lpstrItem, HTREEITEM hItemAfter, int nImageIndex)
	{
		return _Insert(lpstrItem, nImageIndex, hItemAfter);
	}
	CTreeItem AddHead(LPCTSTR lpstrItem, int nImageIndex)
	{
		return _Insert(lpstrItem, nImageIndex, TVI_FIRST);
	}
	CTreeItem AddTail(LPCTSTR lpstrItem, int nImageIndex)
	{
		return _Insert(lpstrItem, nImageIndex, TVI_LAST);
	}

	CTreeItem GetChild() const;
	CTreeItem GetNext(UINT nCode) const;
	CTreeItem GetNextSibling() const;
	CTreeItem GetPrevSibling() const;
	CTreeItem GetParent() const;
	CTreeItem GetFirstVisible() const;
	CTreeItem GetNextVisible() const;
	CTreeItem GetPrevVisible() const;
	CTreeItem GetSelected() const;
	CTreeItem GetDropHilight() const;
	CTreeItem GetRoot() const;
	BOOL HasChildren() const;
	BOOL Delete();
	BOOL Expand(UINT nCode = TVE_EXPAND);
	BOOL Select(UINT nCode);
	BOOL Select();
	BOOL SelectDropTarget();
	BOOL SelectSetFirstVisible();
	HWND EditLabel();
	HIMAGELIST CreateDragImage();
	BOOL SortChildren();
	BOOL EnsureVisible();

	CTreeItem _Insert(LPCTSTR lpstrItem, int nImageIndex, HTREEITEM hItemAfter);
	int GetImageIndex() const;

#if (_WIN32_IE >= 0x0400)
	BOOL SetInsertMark(BOOL bAfter);
#endif //(_WIN32_IE >= 0x0400)
};


template <class TBase>
class CTreeViewCtrlExT : public CTreeViewCtrlT< TBase >
{
public:
// Constructors
	CTreeViewCtrlExT(HWND hWnd = NULL) : CTreeViewCtrlT< TBase >(hWnd) { }

	CTreeViewCtrlExT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

// Operations (overides that return CTreeItem)
	CTreeItem InsertItem(LPTV_INSERTSTRUCT lpInsertStruct)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_INSERTITEM, 0, (LPARAM)lpInsertStruct);
		return CTreeItem(hTreeItem, this);
	}
	CTreeItem InsertItem(LPCTSTR lpszItem, int nImage,
		int nSelectedImage, HTREEITEM hParent, HTREEITEM hInsertAfter)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return InsertItem(TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE, lpszItem, nImage, nSelectedImage, 0, 0, 0, hParent, hInsertAfter); 
	}
	CTreeItem InsertItem(LPCTSTR lpszItem, HTREEITEM hParent, HTREEITEM hInsertAfter)
	{ 
		ATLASSERT(::IsWindow(m_hWnd));
		return InsertItem(TVIF_TEXT, lpszItem, 0, 0, 0, 0, 0, hParent, hInsertAfter);
	}
	CTreeItem GetNextItem(HTREEITEM hItem, UINT nCode)
	{ 
		ATLASSERT(::IsWindow(m_hWnd)); 
		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, nCode, (LPARAM)hItem);
		return CTreeItem(hTreeItem, this);
	}
	CTreeItem GetChildItem(HTREEITEM hItem)
	{
		ATLASSERT(::IsWindow(m_hWnd)); 
		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_CHILD, (LPARAM)hItem);
		return CTreeItem(hTreeItem, this); 
	}
	CTreeItem GetNextSiblingItem(HTREEITEM hItem)
	{
		ATLASSERT(::IsWindow(m_hWnd)); 
		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_NEXT, (LPARAM)hItem); 
		return CTreeItem(hTreeItem, this);
	}
	CTreeItem GetPrevSiblingItem(HTREEITEM hItem)
	{
		ATLASSERT(::IsWindow(m_hWnd)); 
		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_PREVIOUS, (LPARAM)hItem);
		return CTreeItem(hTreeItem, this);
	}
	CTreeItem GetParentItem(HTREEITEM hItem)
	{
		ATLASSERT(::IsWindow(m_hWnd)); 
		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_PARENT, (LPARAM)hItem); 
		return CTreeItem(hTreeItem, this);
	}
	CTreeItem GetFirstVisibleItem()
	{
		ATLASSERT(::IsWindow(m_hWnd)); 
		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_FIRSTVISIBLE, 0L);
		return CTreeItem(hTreeItem, this);
	}
	CTreeItem GetNextVisibleItem(HTREEITEM hItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_NEXTVISIBLE, (LPARAM)hItem);
		return CTreeItem(hTreeItem, this);
	}
	CTreeItem GetPrevVisibleItem(HTREEITEM hItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_PREVIOUSVISIBLE, (LPARAM)hItem);
		return CTreeItem(hTreeItem, this);
	}
	CTreeItem GetSelectedItem()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_CARET, 0L);
		return CTreeItem(hTreeItem, this);
	}
	CTreeItem GetDropHilightItem()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_DROPHILITE, 0L);
		return CTreeItem(hTreeItem, this);
	}
	CTreeItem GetRootItem()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_ROOT, 0L);
		return CTreeItem(hTreeItem, this);
	}
	CTreeItem HitTest(TV_HITTESTINFO* pHitTestInfo)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_HITTEST, 0, (LPARAM)pHitTestInfo);
		return CTreeItem(hTreeItem, this);
	}

	CTreeItem InsertItem(UINT nMask, LPCTSTR lpszItem, int nImage,
		int nSelectedImage, UINT nState, UINT nStateMask, LPARAM lParam,
		HTREEITEM hParent, HTREEITEM hInsertAfter)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		TV_INSERTSTRUCT tvis;
		tvis.hParent = hParent;
		tvis.hInsertAfter = hInsertAfter;
		tvis.item.mask = nMask;
		tvis.item.pszText = (LPTSTR) lpszItem;
		tvis.item.iImage = nImage;
		tvis.item.iSelectedImage = nSelectedImage;
		tvis.item.state = nState;
		tvis.item.stateMask = nStateMask;
		tvis.item.lParam = lParam;
		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_INSERTITEM, 0, (LPARAM)&tvis);
		return CTreeItem(hTreeItem, this);
	}

	CTreeItem HitTest(POINT pt, UINT* pFlags)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		TV_HITTESTINFO hti;
		hti.pt = pt;
		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_HITTEST, 0, (LPARAM)&hti);
		if (pFlags != NULL)
			*pFlags = hti.flags;
		return CTreeItem(hTreeItem, this);
	}
};


// CTreeItem inline methods
inline BOOL CTreeItem::GetRect(LPRECT lpRect, BOOL bTextOnly) const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->GetItemRect(m_hTreeItem,lpRect,bTextOnly);
}
inline CTreeItem CTreeItem::GetNext(UINT nCode) const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->GetNextItem(m_hTreeItem,nCode);
}
inline CTreeItem CTreeItem::GetChild() const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->GetChildItem(m_hTreeItem);
}
inline CTreeItem CTreeItem::GetNextSibling() const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->GetNextSiblingItem(m_hTreeItem);
}
inline CTreeItem CTreeItem::GetPrevSibling() const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->GetPrevSiblingItem(m_hTreeItem);
}
inline CTreeItem CTreeItem::GetParent() const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->GetParentItem(m_hTreeItem);
}
inline CTreeItem CTreeItem::GetFirstVisible() const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->GetFirstVisibleItem();
}
inline CTreeItem CTreeItem::GetNextVisible() const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->GetNextVisibleItem(m_hTreeItem);
}
inline CTreeItem CTreeItem::GetPrevVisible() const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->GetPrevVisibleItem(m_hTreeItem);
}
inline CTreeItem CTreeItem::GetSelected() const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->GetSelectedItem();
}
inline CTreeItem CTreeItem::GetDropHilight() const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->GetDropHilightItem();
}
inline CTreeItem CTreeItem::GetRoot() const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->GetRootItem();
}
inline BOOL CTreeItem::GetText(LPTSTR lpstrText, int nLen) const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->GetItemText(m_hTreeItem, lpstrText, nLen);
}
#ifndef _ATL_NO_COM
#ifdef _OLEAUTO_H_
inline BOOL CTreeItem::GetText(BSTR& bstrText) const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->GetItemText(m_hTreeItem, bstrText);
}
#endif // _OLEAUTO_H_
#endif //!_ATL_NO_COM
#ifdef __ATLSTR_H__
inline BOOL CTreeItem::GetText(CString& strText) const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->GetItemText(m_hTreeItem, strText);
}
#endif //__ATLSTR_H__
inline BOOL CTreeItem::GetImage(int& nImage, int& nSelectedImage) const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->GetItemImage(m_hTreeItem,nImage,nSelectedImage);
}
inline UINT CTreeItem::GetState(UINT nStateMask) const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->GetItemState(m_hTreeItem,nStateMask);
}
inline DWORD_PTR CTreeItem::GetData() const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->GetItemData(m_hTreeItem);
}
inline BOOL CTreeItem::SetItem(UINT nMask, LPCTSTR lpszItem, int nImage,
		int nSelectedImage, UINT nState, UINT nStateMask, LPARAM lParam)
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->SetItem(m_hTreeItem, nMask, lpszItem, nImage, nSelectedImage, nState, nStateMask, lParam);
}
inline BOOL CTreeItem::SetText(LPCTSTR lpszItem)
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->SetItemText(m_hTreeItem,lpszItem);
}
inline BOOL CTreeItem::SetImage(int nImage, int nSelectedImage)
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->SetItemImage(m_hTreeItem,nImage,nSelectedImage);
}
inline BOOL CTreeItem::SetState(UINT nState, UINT nStateMask)
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->SetItemState(m_hTreeItem,nState,nStateMask);
}
inline BOOL CTreeItem::SetData(DWORD_PTR dwData)
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->SetItemData(m_hTreeItem,dwData);
}
inline BOOL CTreeItem::HasChildren() const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->ItemHasChildren(m_hTreeItem);
}
inline BOOL CTreeItem::Delete()
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->DeleteItem(m_hTreeItem);
}
inline BOOL CTreeItem::Expand(UINT nCode)
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->Expand(m_hTreeItem,nCode);
}
inline BOOL CTreeItem::Select(UINT nCode)
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->Select(m_hTreeItem,nCode);
}
inline BOOL CTreeItem::Select()
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->SelectItem(m_hTreeItem);
}
inline BOOL CTreeItem::SelectDropTarget()
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->SelectDropTarget(m_hTreeItem);
}
inline BOOL CTreeItem::SelectSetFirstVisible()
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->SelectSetFirstVisible(m_hTreeItem);
}
inline HWND CTreeItem::EditLabel()
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->EditLabel(m_hTreeItem);
}
inline HIMAGELIST CTreeItem::CreateDragImage()
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->CreateDragImage(m_hTreeItem);
}
inline BOOL CTreeItem::SortChildren()
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->SortChildren(m_hTreeItem);
}
inline BOOL CTreeItem::EnsureVisible()
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->EnsureVisible(m_hTreeItem);
}

inline CTreeItem CTreeItem::_Insert(LPCTSTR lpstrItem, int nImageIndex, HTREEITEM hItemAfter)
{
	ATLASSERT(m_pTreeView != NULL);
	TV_INSERTSTRUCT ins;
	ins.hParent = m_hTreeItem;
	ins.hInsertAfter = hItemAfter;
	ins.item.mask = TVIF_TEXT;
	ins.item.pszText = (LPTSTR)lpstrItem;
	if(nImageIndex != -1)
	{
		ins.item.mask |= TVIF_IMAGE | TVIF_SELECTEDIMAGE;
		ins.item.iImage = nImageIndex;
		ins.item.iSelectedImage = nImageIndex;
	}
	return CTreeItem(m_pTreeView->InsertItem(&ins), m_pTreeView);
}

inline int CTreeItem::GetImageIndex() const
{
	ATLASSERT(m_pTreeView != NULL);
	TVITEM item;
	item.mask = TVIF_HANDLE | TVIF_IMAGE;
	item.hItem = m_hTreeItem;
	m_pTreeView->GetItem(&item);
	return item.iImage;
}

#if (_WIN32_IE >= 0x0400)
inline BOOL CTreeItem::SetInsertMark(BOOL bAfter)
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->SetInsertMark(m_hTreeItem, bAfter);
}
#endif //(_WIN32_IE >= 0x0400)


/////////////////////////////////////////////////////////////////////////////
// CToolBarCtrl

template <class TBase>
class CToolBarCtrlT : public TBase
{
public:
// Construction
	CToolBarCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }

	CToolBarCtrlT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return TOOLBARCLASSNAME;
	}

	BOOL IsButtonEnabled(int nID) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_ISBUTTONENABLED, nID, 0L);
	}
	BOOL IsButtonChecked(int nID) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_ISBUTTONCHECKED, nID, 0L);
	}
	BOOL IsButtonPressed(int nID) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_ISBUTTONPRESSED, nID, 0L);
	}
	BOOL IsButtonHidden(int nID) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return(BOOL) ::SendMessage(m_hWnd, TB_ISBUTTONHIDDEN, nID, 0L);
	}
	BOOL IsButtonIndeterminate(int nID) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_ISBUTTONINDETERMINATE, nID, 0L);
	}
	int GetState(int nID) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TB_GETSTATE, nID, 0L);
	}
	BOOL SetState(int nID, UINT nState)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_SETSTATE, nID, MAKELPARAM(nState, 0));
	}
	BOOL GetButton(int nIndex, LPTBBUTTON lpButton) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_GETBUTTON, nIndex, (LPARAM)lpButton);
	}
	int GetButtonCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TB_BUTTONCOUNT, 0, 0L);
	}
	BOOL GetItemRect(int nIndex, LPRECT lpRect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_GETITEMRECT, nIndex, (LPARAM)lpRect);
	}
	void SetButtonStructSize(int nSize = sizeof(TBBUTTON))
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TB_BUTTONSTRUCTSIZE, nSize, 0L);
	}
	BOOL SetButtonSize(SIZE size)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_SETBUTTONSIZE, 0, MAKELPARAM(size.cx, size.cy));
	}
	BOOL SetBitmapSize(SIZE size)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_SETBITMAPSIZE, 0, MAKELPARAM(size.cx, size.cy));
	}
	CToolTipCtrl GetToolTips() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CToolTipCtrl((HWND)::SendMessage(m_hWnd, TB_GETTOOLTIPS, 0, 0L));
	}
	void SetToolTips(HWND hWndToolTip)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TB_SETTOOLTIPS, (WPARAM)hWndToolTip, 0L);
	}
	void SetNotifyWnd(HWND hWnd)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TB_SETPARENT, (WPARAM)hWnd, 0L);
	}
	int GetRows() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TB_GETROWS, 0, 0L);
	}
	void SetRows(int nRows, BOOL bLarger, LPRECT lpRect)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TB_SETROWS, MAKELPARAM(nRows, bLarger), (LPARAM)lpRect);
	}
	BOOL SetCmdID(int nIndex, UINT nID)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_SETCMDID, nIndex, nID);
	}
	DWORD GetBitmapFlags() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, TB_GETBITMAPFLAGS, 0, 0L);
	}
	int GetBitmap(int nID) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TB_GETBITMAP, nID, 0L);
	}
	int GetButtonText(int nID, LPTSTR lpstrText) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TB_GETBUTTONTEXT, nID, (LPARAM)lpstrText);
	}

	CImageList GetImageList() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TB_GETIMAGELIST, 0, 0L));
	}
	CImageList SetImageList(HIMAGELIST hImageList)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TB_SETIMAGELIST, 0, (LPARAM)hImageList));
	}
	CImageList GetDisabledImageList() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TB_GETDISABLEDIMAGELIST, 0, 0L));
	}
	CImageList SetDisabledImageList(HIMAGELIST hImageList)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TB_SETDISABLEDIMAGELIST, 0, (LPARAM)hImageList));
	}
	CImageList GetHotImageList() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TB_GETHOTIMAGELIST, 0, 0L));
	}
	CImageList SetHotImageList(HIMAGELIST hImageList)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TB_SETHOTIMAGELIST, 0, (LPARAM)hImageList));
	}
	DWORD GetStyle() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, TB_GETSTYLE, 0, 0L);
	}
	void SetStyle(DWORD dwStyle)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TB_SETSTYLE, 0, dwStyle);
	}
	DWORD GetButtonSize() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, TB_GETBUTTONSIZE, 0, 0L);
	}
	BOOL GetRect(int nID, LPRECT lpRect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_GETRECT, nID, (LPARAM)lpRect);
	}
	int GetTextRows() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TB_GETTEXTROWS, 0, 0L);
	}
	BOOL SetButtonWidth(int cxMin, int cxMax)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_SETBUTTONWIDTH, 0, MAKELPARAM(cxMin, cxMax));
	}
	BOOL SetIndent(int nIndent)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_SETINDENT, nIndent, 0L);
	}
	BOOL SetMaxTextRows(int nMaxTextRows)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_SETMAXTEXTROWS, nMaxTextRows, 0L);
	}

#if (_WIN32_IE >= 0x0400)
	BOOL GetAnchorHighlight() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_GETANCHORHIGHLIGHT, 0, 0L);
	}
	BOOL SetAnchorHighlight(BOOL bEnable = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_SETANCHORHIGHLIGHT, bEnable, 0L);
	}
	BOOL GetButtonInfo(int nID, LPTBBUTTONINFO lptbbi) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_GETBUTTONINFO, nID, (LPARAM)lptbbi);
	}
	BOOL SetButtonInfo(int nID, LPTBBUTTONINFO lptbbi)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_SETBUTTONINFO, nID, (LPARAM)lptbbi);
	}
	int GetHotItem() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TB_GETHOTITEM, 0, 0L);
	}
	int SetHotItem(int nItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TB_SETHOTITEM, nItem, 0L);
	}
	BOOL IsButtonHighlighted(int nButtonID) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_ISBUTTONHIGHLIGHTED, nButtonID, 0L);
	}
	DWORD SetDrawTextFlags(DWORD dwMask, DWORD dwFlags)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, TB_SETDRAWTEXTFLAGS, dwMask, dwFlags);
	}
	BOOL GetColorScheme(LPCOLORSCHEME lpcs) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_GETCOLORSCHEME, 0, (LPARAM)lpcs);
	}
	void SetColorScheme(LPCOLORSCHEME lpcs)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TB_SETCOLORSCHEME, 0, (LPARAM)lpcs);
	}
	DWORD GetExtendedStyle() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, TB_GETEXTENDEDSTYLE, 0, 0L);
	}
	DWORD SetExtendedStyle(DWORD dwStyle)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, TB_SETEXTENDEDSTYLE, 0, dwStyle);
	}
	void GetInsertMark(LPTBINSERTMARK lptbim) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TB_GETINSERTMARK, 0, (LPARAM)lptbim);
	}
	void SetInsertMark(LPTBINSERTMARK lptbim)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TB_SETINSERTMARK, 0, (LPARAM)lptbim);
	}
	COLORREF GetInsertMarkColor() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, TB_GETINSERTMARKCOLOR, 0, 0L);
	}
	COLORREF SetInsertMarkColor(COLORREF clr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, TB_SETINSERTMARKCOLOR, 0, (LPARAM)clr);
	}
	BOOL GetMaxSize(LPSIZE lpSize) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_GETMAXSIZE, 0, (LPARAM)lpSize);
	}
	void GetPadding(LPSIZE lpSizePadding) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(lpSizePadding != NULL);
		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, TB_GETPADDING, 0, 0L);
		lpSizePadding->cx = GET_X_LPARAM(dwRet);
		lpSizePadding->cy = GET_Y_LPARAM(dwRet);
	}
	void SetPadding(int cx, int cy, LPSIZE lpSizePadding = NULL)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, TB_SETPADDING, 0, MAKELPARAM(cx, cy));
		if(lpSizePadding != NULL)
		{
			lpSizePadding->cx = GET_X_LPARAM(dwRet);
			lpSizePadding->cy = GET_Y_LPARAM(dwRet);
		}
	}
	BOOL GetUnicodeFormat() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_GETUNICODEFORMAT, 0, 0L);
	}
	BOOL SetUnicodeFormat(BOOL bUnicode = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_SETUNICODEFORMAT, bUnicode, 0L);
	}
#endif //(_WIN32_IE >= 0x0400)

#if (_WIN32_IE >= 0x0500)
	int GetString(int nString, LPTSTR lpstrString, int cchMaxLen) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TB_GETSTRING, MAKEWPARAM(cchMaxLen, nString), (LPARAM)lpstrString);
	}
	int GetStringBSTR(int nString, BSTR& bstrString) const
	{
		USES_CONVERSION;
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(bstrString == NULL);
		int nLength = (int)(short)LOWORD(::SendMessage(m_hWnd, TB_GETSTRING, MAKEWPARAM(0, nString), NULL));
		if(nLength != -1)
		{
			LPTSTR lpszString = (LPTSTR)_alloca((nLength + 1) * sizeof(TCHAR));
			nLength = ::SendMessage(m_hWnd, TB_GETSTRING, MAKEWPARAM(nLength + 1, nString), (LPARAM)lpszString);
			if(nLength != -1)
				bstrString = ::SysAllocString(T2OLE(lpszString));
		}
		return nLength;
	}
#ifdef __ATLSTR_H__
	int GetString(int nString, CString& str) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		int nLength = (int)(short)LOWORD(::SendMessage(m_hWnd, TB_GETSTRING, MAKEWPARAM(0, nString), NULL));
		if(nLength != -1)
		{
			nLength = ::SendMessage(m_hWnd, TB_GETSTRING, MAKEWPARAM(nLength + 1, nString), (LPARAM)str.GetBufferSetLength(nLength+1));
			str.ReleaseBuffer();
		}
		return nLength;
	}
#endif //__ATLSTR_H__
#endif //(_WIN32_IE >= 0x0500)

// Operations
	BOOL EnableButton(int nID, BOOL bEnable = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_ENABLEBUTTON, nID, MAKELPARAM(bEnable, 0));
	}
	BOOL CheckButton(int nID, BOOL bCheck = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_CHECKBUTTON, nID, MAKELPARAM(bCheck, 0));
	}
	BOOL PressButton(int nID, BOOL bPress = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_PRESSBUTTON, nID, MAKELPARAM(bPress, 0));
	}
	BOOL HideButton(int nID, BOOL bHide = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_HIDEBUTTON, nID, MAKELPARAM(bHide, 0));
	}
	BOOL Indeterminate(int nID, BOOL bIndeterminate = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_INDETERMINATE, nID, MAKELPARAM(bIndeterminate, 0));
	}
	int AddBitmap(int nNumButtons, UINT nBitmapID)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		TBADDBITMAP tbab;
		tbab.hInst = _Module.GetResourceInstance();
		ATLASSERT(tbab.hInst != NULL);
		tbab.nID = nBitmapID;
		return (int)::SendMessage(m_hWnd, TB_ADDBITMAP, (WPARAM)nNumButtons, (LPARAM)&tbab);
	}
	int AddBitmap(int nNumButtons, HBITMAP hBitmap)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		TBADDBITMAP tbab;
		tbab.hInst = NULL;
		tbab.nID = (UINT_PTR)hBitmap;
		return (int)::SendMessage(m_hWnd, TB_ADDBITMAP, (WPARAM)nNumButtons, (LPARAM)&tbab);
	}
	BOOL AddButtons(int nNumButtons, LPTBBUTTON lpButtons)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_ADDBUTTONS, nNumButtons, (LPARAM)lpButtons);
	}
	BOOL InsertButton(int nIndex, LPTBBUTTON lpButton)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_INSERTBUTTON, nIndex, (LPARAM)lpButton);
	}
	BOOL DeleteButton(int nIndex)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_DELETEBUTTON, nIndex, 0L);
	}
	UINT CommandToIndex(UINT nID) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, TB_COMMANDTOINDEX, nID, 0L);
	}
	void SaveState(HKEY hKeyRoot, LPCTSTR lpszSubKey, LPCTSTR lpszValueName)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		TBSAVEPARAMS tbs;
		tbs.hkr = hKeyRoot;
		tbs.pszSubKey = lpszSubKey;
		tbs.pszValueName = lpszValueName;
		::SendMessage(m_hWnd, TB_SAVERESTORE, (WPARAM)TRUE, (LPARAM)&tbs);
	}
	void RestoreState(HKEY hKeyRoot, LPCTSTR lpszSubKey, LPCTSTR lpszValueName)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		TBSAVEPARAMS tbs;
		tbs.hkr = hKeyRoot;
		tbs.pszSubKey = lpszSubKey;
		tbs.pszValueName = lpszValueName;
		::SendMessage(m_hWnd, TB_SAVERESTORE, (WPARAM)FALSE, (LPARAM)&tbs);
	}
	void Customize()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TB_CUSTOMIZE, 0, 0L);
	}
	int AddString(UINT nStringID)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TB_ADDSTRING, (WPARAM)_Module.GetResourceInstance(), (LPARAM)nStringID);
	}
	int AddStrings(LPCTSTR lpszStrings)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TB_ADDSTRING, 0, (LPARAM)lpszStrings);
	}
	void AutoSize()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TB_AUTOSIZE, 0, 0L);
	}

	BOOL ChangeBitmap(int nID, int nBitmap)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_CHANGEBITMAP, nID, MAKELPARAM(nBitmap, 0));
	}
	int LoadImages(int nBitmapID)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TB_LOADIMAGES, nBitmapID, (LPARAM)_Module.GetResourceInstance());
	}
	int LoadStdImages(int nBitmapID)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TB_LOADIMAGES, nBitmapID, (LPARAM)HINST_COMMCTRL);
	}
	BOOL ReplaceBitmap(LPTBREPLACEBITMAP ptbrb)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_REPLACEBITMAP, 0, (LPARAM)ptbrb);
	}

#if (_WIN32_IE >= 0x0400)
	int HitTest(LPPOINT lpPoint)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TB_HITTEST, 0, (LPARAM)lpPoint);
	}
	BOOL InsertMarkHitTest(LPPOINT lpPoint, LPTBINSERTMARK lptbim)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_INSERTMARKHITTEST, (WPARAM)lpPoint, (LPARAM)lptbim);
	}
	BOOL InsertMarkHitTest(int x, int y, LPTBINSERTMARK lptbim)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		POINT pt = { x, y };
		return (BOOL)::SendMessage(m_hWnd, TB_INSERTMARKHITTEST, (WPARAM)&pt, (LPARAM)lptbim);
	}
	BOOL MapAccelerator(TCHAR chAccel, int& nID) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_MAPACCELERATOR, (WPARAM)chAccel, (LPARAM)&nID);
	}
	BOOL MarkButton(int nID, BOOL bHighlight = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_MARKBUTTON, nID, MAKELPARAM(bHighlight, 0));
	}
	BOOL MoveButton(int nOldPos, int nNewPos)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_MOVEBUTTON, nOldPos, nNewPos);
	}
	HRESULT GetObject(REFIID iid, LPVOID* ppvObject)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HRESULT)::SendMessage(m_hWnd, TB_GETOBJECT, (WPARAM)&iid, (LPARAM)ppvObject);
	}
#endif //(_WIN32_IE >= 0x0400)
};

typedef CToolBarCtrlT<CWindow>		CToolBarCtrl;


/////////////////////////////////////////////////////////////////////////////
// CStatusBarCtrl

template <class TBase>
class CStatusBarCtrlT : public TBase
{
public:
// Constructors
	CStatusBarCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }

	CStatusBarCtrlT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Methods
	static LPCTSTR GetWndClassName()
	{
		return STATUSCLASSNAME;
	}

	int GetParts(int nParts, int* pParts) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, SB_GETPARTS, nParts, (LPARAM)pParts);
	}
	BOOL SetParts(int nParts, int* pWidths)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, SB_SETPARTS, nParts, (LPARAM)pWidths);
	}
	int GetTextLength(int nPane, int* pType = NULL) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(nPane < 256);
		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, SB_GETTEXTLENGTH, (WPARAM)nPane, 0L);
		if (pType != NULL)
			*pType = (int)(short)HIWORD(dwRet);
		return (int)(short)LOWORD(dwRet);
	}
	int GetText(int nPane, LPTSTR lpszText, int* pType = NULL) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(nPane < 256);
		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, SB_GETTEXT, (WPARAM)nPane, (LPARAM)lpszText);
		if(pType != NULL)
			*pType = (int)(short)HIWORD(dwRet);
		return (int)(short)LOWORD(dwRet);
	}
#ifndef _ATL_NO_COM
	BOOL GetTextBSTR(int nPane, BSTR& bstrText, int* pType = NULL) const
	{
		USES_CONVERSION;
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(nPane < 256);
		ATLASSERT(bstrText == NULL);
		int nLength = (int)(short)LOWORD(::SendMessage(m_hWnd, SB_GETTEXTLENGTH, (WPARAM)nPane, 0L));
		if(nLength == 0)
			return FALSE;

		LPTSTR lpszText = (LPTSTR)_alloca((nLength + 1) * sizeof(TCHAR));
		if(!GetText(nPane, lpszText, pType))
			return FALSE;

		bstrText = ::SysAllocString(T2OLE(lpszText));
		return (bstrText != NULL) ? TRUE : FALSE;
	}
#endif //!_ATL_NO_COM
#ifdef __ATLSTR_H__
	int GetText(int nPane, CString& strText, int* pType = NULL) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(nPane < 256);
		int nLength = (int)(short)LOWORD(::SendMessage(m_hWnd, SB_GETTEXTLENGTH, (WPARAM)nPane, 0L));
		if(nLength == 0)
			return 0;

		return GetText(nPane, strText.GetBufferSetLength(nLength), pType);
	}
#endif //__ATLSTR_H__
	BOOL SetText(int nPane, LPCTSTR lpszText, int nType = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(nPane < 256);
		return (BOOL)::SendMessage(m_hWnd, SB_SETTEXT, (nPane | nType), (LPARAM)lpszText);
	}
	BOOL GetRect(int nPane, LPRECT lpRect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(nPane < 256);
		return (BOOL)::SendMessage(m_hWnd, SB_GETRECT, nPane, (LPARAM)lpRect);
	}
	BOOL GetBorders(int* pBorders) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, SB_GETBORDERS, 0, (LPARAM)pBorders);
	}
	BOOL GetBorders(int& nHorz, int& nVert, int& nSpacing) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		int borders[3];
		BOOL bResult = (BOOL)::SendMessage(m_hWnd, SB_GETBORDERS, 0, (LPARAM)&borders);
		if(bResult)
		{
			nHorz = borders[0];
			nVert = borders[1];
			nSpacing = borders[2];
		}
		return bResult;
	}
	void SetMinHeight(int nMin)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, SB_SETMINHEIGHT, nMin, 0L);
	}
	BOOL SetSimple(BOOL bSimple = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, SB_SIMPLE, bSimple, 0L);
	}
	BOOL IsSimple() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, SB_ISSIMPLE, 0, 0L);
	}

#if (_WIN32_IE >= 0x0400)
	COLORREF SetBkColor(COLORREF clrBk)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, SB_SETBKCOLOR, 0, (LPARAM)clrBk);
	}
	BOOL GetUnicodeFormat() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, SB_GETUNICODEFORMAT, 0, 0L);
	}
	BOOL SetUnicodeFormat(BOOL bUnicode = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, SB_SETUNICODEFORMAT, bUnicode, 0L);
	}
	void GetTipText(int nPane, LPTSTR lpstrText, int nSize) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(nPane < 256);
		::SendMessage(m_hWnd, SB_GETTIPTEXT, MAKEWPARAM(nPane, nSize), (LPARAM)lpstrText);
	}
	void SetTipText(int nPane, LPCTSTR lpstrText)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(nPane < 256);
		::SendMessage(m_hWnd, SB_SETTIPTEXT, nPane, (LPARAM)lpstrText);
	}
	HICON GetIcon(int nPane) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(nPane < 256);
		return (HICON)::SendMessage(m_hWnd, SB_GETICON, nPane, 0L);
	}
	BOOL SetIcon(int nPane, HICON hIcon)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(nPane < 256);
		return (BOOL)::SendMessage(m_hWnd, SB_SETICON, nPane, (LPARAM)hIcon);
	}
#endif //(_WIN32_IE >= 0x0400)
};

typedef CStatusBarCtrlT<CWindow>		CStatusBarCtrl;


/////////////////////////////////////////////////////////////////////////////
// CTabCtrl

template <class TBase>
class CTabCtrlT : public TBase
{
public:
// Constructors
	CTabCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }

	CTabCtrlT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return WC_TABCONTROL;
	}

	CImageList GetImageList() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TCM_GETIMAGELIST, 0, 0L));
	}
	CImageList SetImageList(HIMAGELIST hImageList)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TCM_SETIMAGELIST, 0, (LPARAM)hImageList));
	}
	int GetItemCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TCM_GETITEMCOUNT, 0, 0L);
	}
	BOOL GetItem(int nItem, LPTCITEM pTabCtrlItem) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TCM_GETITEM, nItem, (LPARAM)pTabCtrlItem);
	}
	BOOL SetItem(int nItem, LPTCITEM pTabCtrlItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TCM_SETITEM, nItem, (LPARAM)pTabCtrlItem);
	}
	BOOL GetItemRect(int nItem, LPRECT lpRect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TCM_GETITEMRECT, nItem, (LPARAM)lpRect);
	}
	int GetCurSel() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TCM_GETCURSEL, 0, 0L);
	}
	int SetCurSel(int nItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TCM_SETCURSEL, nItem, 0L);
	}
	SIZE SetItemSize(SIZE size)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		DWORD dwSize = (DWORD)::SendMessage(m_hWnd, TCM_SETITEMSIZE, 0, MAKELPARAM(size.cx, size.cy));
		SIZE sizeRet = { GET_X_LPARAM(dwSize), GET_Y_LPARAM(dwSize) };
		return sizeRet;
	}
	void SetPadding(SIZE size)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TCM_SETPADDING, 0, MAKELPARAM(size.cx, size.cy));
	}
	int GetRowCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TCM_GETROWCOUNT, 0, 0L);
	}
	CToolTipCtrl GetTooltips() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CToolTipCtrl((HWND)::SendMessage(m_hWnd, TCM_GETTOOLTIPS, 0, 0L));
	}
	void SetTooltips(HWND hWndToolTip)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TCM_SETTOOLTIPS, (WPARAM)hWndToolTip, 0L);
	}
	int GetCurFocus() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TCM_GETCURFOCUS, 0, 0L);
	}

	void SetCurFocus(int nItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TCM_SETCURFOCUS, nItem, 0L);
	}
	BOOL SetItemExtra(int cbExtra)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetItemCount() == 0);	// must be empty
		return (BOOL)::SendMessage(m_hWnd, TCM_SETITEMEXTRA, cbExtra, 0L);
	}
	int SetMinTabWidth(int nWidth = -1)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TCM_SETMINTABWIDTH, 0, nWidth);
	}

#if (_WIN32_IE >= 0x0400)
	DWORD GetExtendedStyle() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, TCM_GETEXTENDEDSTYLE, 0, 0L);
	}
	DWORD SetExtendedStyle(DWORD dwExMask, DWORD dwExStyle)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, TCM_SETEXTENDEDSTYLE, dwExMask, dwExStyle);
	}
	BOOL GetUnicodeFormat() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TCM_GETUNICODEFORMAT, 0, 0L);
	}
	BOOL SetUnicodeFormat(BOOL bUnicode = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TCM_SETUNICODEFORMAT, bUnicode, 0L);
	}
#endif //(_WIN32_IE >= 0x0400)

// Operations
	BOOL InsertItem(int nItem, LPTCITEM pTabCtrlItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TCM_INSERTITEM, nItem, (LPARAM)pTabCtrlItem);
	}
	BOOL DeleteItem(int nItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TCM_DELETEITEM, nItem, 0L);
	}
	BOOL DeleteAllItems()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TCM_DELETEALLITEMS, 0, 0L);
	}
	void AdjustRect(BOOL bLarger, LPRECT lpRect)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TCM_ADJUSTRECT, bLarger, (LPARAM)lpRect);
	}
	void RemoveImage(int nImage)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TCM_REMOVEIMAGE, nImage, 0L);
	}
	int HitTest(TC_HITTESTINFO* pHitTestInfo) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TCM_HITTEST, 0, (LPARAM)pHitTestInfo);
	}
	void DeselectAll(BOOL bExcludeFocus = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TCM_DESELECTALL, bExcludeFocus, 0L);
	}

#if (_WIN32_IE >= 0x0400)
	BOOL HighlightItem(int nIndex, BOOL bHighlight = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TCM_HIGHLIGHTITEM, nIndex, MAKELPARAM(bHighlight, 0));
	}
#endif //(_WIN32_IE >= 0x0400)
};

typedef CTabCtrlT<CWindow>	CTabCtrl;


/////////////////////////////////////////////////////////////////////////////
// CTrackBarCtrl

template <class TBase>
class CTrackBarCtrlT : public TBase
{
public:
// Constructors
	CTrackBarCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }

	CTrackBarCtrlT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return TRACKBAR_CLASS;
	}

	int GetLineSize() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TBM_GETLINESIZE, 0, 0L);
	}
	int SetLineSize(int nSize)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TBM_SETLINESIZE, 0, nSize);
	}
	int GetPageSize() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TBM_GETPAGESIZE, 0, 0L);
	}
	int SetPageSize(int nSize)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TBM_SETPAGESIZE, 0, nSize);
	}
	int GetRangeMin() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TBM_GETRANGEMIN, 0, 0L);
	}
	void SetRangeMin(int nMin, BOOL bRedraw = FALSE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TBM_SETRANGEMIN, bRedraw, nMin);
	}
	int GetRangeMax() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TBM_GETRANGEMAX, 0, 0L);
	}
	void SetRangeMax(int nMax, BOOL bRedraw = FALSE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TBM_SETRANGEMAX, bRedraw, nMax);
	}
	void GetRange(int& nMin, int& nMax) const
	{
		nMin = GetRangeMin();
		nMax = GetRangeMax();
	}
	void SetRange(int nMin, int nMax, BOOL bRedraw = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TBM_SETRANGE, bRedraw, MAKELPARAM(nMin, nMax));
	}
	int GetSelStart() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TBM_GETSELSTART, 0, 0L);
	}
	void SetSelStart(int nMin)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TBM_SETSELSTART, 0, (LPARAM)nMin);
	}
	int GetSelEnd() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TBM_GETSELEND, 0, 0L);
	}
	void SetSelEnd(int nMax)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TBM_SETSELEND, 0, (LPARAM)nMax);
	}
	void GetSelection(int& nMin, int& nMax) const
	{
		nMin = GetSelStart();
		nMax = GetSelEnd();
	}
	void SetSelection(int nMin, int nMax)
	{
		SetSelStart(nMin);
		SetSelEnd(nMax);
	}
	void GetChannelRect(LPRECT lprc) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TBM_GETCHANNELRECT, 0, (LPARAM)lprc);
	}
	void GetThumbRect(LPRECT lprc) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TBM_GETTHUMBRECT, 0, (LPARAM)lprc);
	}
	int GetPos() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TBM_GETPOS, 0, 0L);
	}
	void SetPos(int nPos)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TBM_SETPOS, TRUE, nPos);
	}
	UINT GetNumTics() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, TBM_GETNUMTICS, 0, 0L);
	}
	DWORD* GetTicArray() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD*)::SendMessage(m_hWnd, TBM_GETPTICS, 0, 0L);
	}
	int GetTic(int nTic) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TBM_GETTIC, nTic, 0L);
	}
	BOOL SetTic(int nTic)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TBM_SETTIC, 0, nTic);
	}
	int GetTicPos(int nTic) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TBM_GETTICPOS, nTic, 0L);
	}
	void SetTicFreq(int nFreq)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TBM_SETTICFREQ, nFreq, 0L);
	}

	int GetThumbLength() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TBM_GETTHUMBLENGTH, 0, 0L);
	}
	void SetThumbLength(int nLength)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TBM_SETTHUMBLENGTH, nLength, 0L);
	}
	void SetSel(int nStart, int nEnd, BOOL bRedraw = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & TBS_ENABLESELRANGE) != 0);
		::SendMessage(m_hWnd, TBM_SETSEL, bRedraw, MAKELPARAM(nStart, nEnd));
	}
	CWindow GetBuddy(BOOL bLeft = TRUE) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CWindow((HWND)::SendMessage(m_hWnd, TBM_GETBUDDY, bLeft, 0L));
	}
	CWindow SetBuddy(HWND hWndBuddy, BOOL bLeft = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CWindow((HWND)::SendMessage(m_hWnd, TBM_SETBUDDY, bLeft, (LPARAM)hWndBuddy));
	}
	CToolTipCtrl GetToolTips() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CToolTipCtrl((HWND)::SendMessage(m_hWnd, TBM_GETTOOLTIPS, 0, 0L));
	}
	void SetToolTips(HWND hWndTT)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TBM_SETTOOLTIPS, (WPARAM)hWndTT, 0L);
	}
	int SetTipSide(int nSide)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TBM_SETTIPSIDE, nSide, 0L);
	}

#if (_WIN32_IE >= 0x0400)
	BOOL GetUnicodeFormat() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TBM_GETUNICODEFORMAT, 0, 0L);
	}
	BOOL SetUnicodeFormat(BOOL bUnicode = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TBM_SETUNICODEFORMAT, bUnicode, 0L);
	}
#endif //(_WIN32_IE >= 0x0400)

// Operations
	void ClearSel(BOOL bRedraw = FALSE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TBM_CLEARSEL, bRedraw, 0L);
	}
	void VerifyPos()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TBM_SETPOS, FALSE, 0L);
	}
	void ClearTics(BOOL bRedraw = FALSE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TBM_CLEARTICS, bRedraw, 0L);
	}
};

typedef CTrackBarCtrlT<CWindow>		CTrackBarCtrl;


/////////////////////////////////////////////////////////////////////////////
// CUpDownCtrl

template <class TBase>
class CUpDownCtrlT : public TBase
{
public:
// Constructors
	CUpDownCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }

	CUpDownCtrlT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return UPDOWN_CLASS;
	}

	UINT GetAccel(int nAccel, UDACCEL* pAccel) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)LOWORD(::SendMessage(m_hWnd, UDM_GETACCEL, nAccel, (LPARAM)pAccel));
	}
	BOOL SetAccel(int nAccel, UDACCEL* pAccel)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)LOWORD(::SendMessage(m_hWnd, UDM_SETACCEL, nAccel, (LPARAM)pAccel));
	}
	UINT GetBase() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)LOWORD(::SendMessage(m_hWnd, UDM_GETBASE, 0, 0L));
	}
	int SetBase(int nBase)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, UDM_SETBASE, nBase, 0L);
	}
	CWindow GetBuddy() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CWindow((HWND)::SendMessage(m_hWnd, UDM_GETBUDDY, 0, 0L));
	}
	CWindow SetBuddy(HWND hWndBuddy)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CWindow((HWND)::SendMessage(m_hWnd, UDM_SETBUDDY, (WPARAM)hWndBuddy, 0L));
	}
	int GetPos() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, UDM_GETPOS, 0, 0L);
	}
	int SetPos(int nPos)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)(short)LOWORD(::SendMessage(m_hWnd, UDM_SETPOS, 0, MAKELPARAM(nPos, 0)));
	}
	DWORD GetRange() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, UDM_GETRANGE, 0, 0L);
	}
	void GetRange(int& nLower, int& nUpper) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, UDM_GETRANGE, 0, 0L);
		nLower = (int)(short)HIWORD(dwRet);
		nUpper = (int)(short)LOWORD(dwRet);
	}
	void SetRange(int nLower, int nUpper)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, UDM_SETRANGE, 0, MAKELPARAM(nUpper, nLower));
	}

#if (_WIN32_IE >= 0x0400)
	void SetRange32(int nLower, int nUpper)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, UDM_SETRANGE32, nLower, nUpper);
	}
	void GetRange32(int& nLower, int& nUpper) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, UDM_GETRANGE32, (WPARAM)&nLower, (LPARAM)&nUpper);
	}
	BOOL GetUnicodeFormat() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, UDM_GETUNICODEFORMAT, 0, 0L);
	}
	BOOL SetUnicodeFormat(BOOL bUnicode = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, UDM_SETUNICODEFORMAT, bUnicode, 0L);
	}
#endif //(_WIN32_IE >= 0x0400)

#if (_WIN32_IE >= 0x0500)
	int GetPos32(LPBOOL lpbError /*= NULL*/) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, UDM_GETPOS32, 0, (LPARAM)lpbError);
	}
	int SetPos32(int nPos)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, UDM_SETPOS32, 0, (LPARAM)nPos);
	}
#endif //(_WIN32_IE >= 0x0500)
};

typedef CUpDownCtrlT<CWindow>		CUpDownCtrl;


/////////////////////////////////////////////////////////////////////////////
// CProgressBarCtrl

template <class TBase>
class CProgressBarCtrlT : public TBase
{
public:
// Constructors
	CProgressBarCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }

	CProgressBarCtrlT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return PROGRESS_CLASS;
	}

	DWORD SetRange(int nLower, int nUpper)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, PBM_SETRANGE, 0, MAKELPARAM(nLower, nUpper));
	}
	int SetPos(int nPos)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)(short)LOWORD(::SendMessage(m_hWnd, PBM_SETPOS, nPos, 0L));
	}
	int OffsetPos(int nPos)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)(short)LOWORD(::SendMessage(m_hWnd, PBM_DELTAPOS, nPos, 0L));
	}
	int SetStep(int nStep)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)(short)LOWORD(::SendMessage(m_hWnd, PBM_SETSTEP, nStep, 0L));
	}
	UINT GetPos() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, PBM_GETPOS, 0, 0L);
	}
	void GetRange(PPBRANGE pPBRange) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(pPBRange != NULL);
		::SendMessage(m_hWnd, PBM_GETRANGE, TRUE, (LPARAM)pPBRange);
	}
	int GetRangeLimit(BOOL bLimit) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, PBM_GETRANGE, bLimit, (LPARAM)NULL);
	}
	DWORD SetRange32(int nMin, int nMax)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, PBM_SETRANGE32, nMin, nMax);
	}

#if (_WIN32_IE >= 0x0400)
	COLORREF SetBarColor(COLORREF clr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, PBM_SETBARCOLOR, 0, (LPARAM)clr);
	}
	COLORREF SetBkColor(COLORREF clr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, PBM_SETBKCOLOR, 0, (LPARAM)clr);
	}
#endif //(_WIN32_IE >= 0x0400)

// Operations
	int StepIt()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)(short)LOWORD(::SendMessage(m_hWnd, PBM_STEPIT, 0, 0L));
	}
};

typedef CProgressBarCtrlT<CWindow>	CProgressBarCtrl;


/////////////////////////////////////////////////////////////////////////////
// CHotKeyCtrl

template <class TBase>
class CHotKeyCtrlT : public TBase
{
public:
// Constructors
	CHotKeyCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }

	CHotKeyCtrlT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return HOTKEY_CLASS;
	}

	DWORD GetHotKey() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, HKM_GETHOTKEY, 0, 0L);
	}
	void GetHotKey(WORD &wVirtualKeyCode, WORD &wModifiers) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		DWORD dw = (DWORD)::SendMessage(m_hWnd, HKM_GETHOTKEY, 0, 0L);
		wVirtualKeyCode = LOBYTE(LOWORD(dw));
		wModifiers = HIBYTE(LOWORD(dw));
	}
	void SetHotKey(WORD wVirtualKeyCode, WORD wModifiers)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, HKM_SETHOTKEY, MAKEWORD(wVirtualKeyCode, wModifiers), 0L);
	}

	void SetRules(WORD wInvalidComb, WORD wModifiers)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, HKM_SETRULES, wInvalidComb, MAKELPARAM(wModifiers, 0));
	}
};

typedef CHotKeyCtrlT<CWindow>		CHotKeyCtrl;


/////////////////////////////////////////////////////////////////////////////
// CAnimateCtrl

template <class TBase>
class CAnimateCtrlT : public TBase
{
public:
// Constructors
	CAnimateCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }

	CAnimateCtrlT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return ANIMATE_CLASS;
	}

// Operations
	BOOL Open(_U_STRINGorID FileName)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, ACM_OPEN, 0, (LPARAM)FileName.m_lpstr);
	}
	BOOL Play(UINT nFrom, UINT nTo, UINT nRep)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, ACM_PLAY, nRep, MAKELPARAM(nFrom, nTo));
	}
	BOOL Stop()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, ACM_STOP, 0, 0L);
	}
	BOOL Close()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, ACM_OPEN, 0, 0L);
	}
	BOOL Seek(UINT nTo)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, ACM_PLAY, 0, MAKELPARAM(nTo, nTo));
	}
};

typedef CAnimateCtrlT<CWindow>		CAnimateCtrl;


/////////////////////////////////////////////////////////////////////////////
// CRichEditCtrl

#ifdef _UNICODE
#if (_RICHEDIT_VER == 0x0100)
#undef RICHEDIT_CLASS
#define RICHEDIT_CLASS	L"RICHEDIT"
#endif //(_RICHEDIT_VER == 0x0100)
#endif //_UNICODE

template <class TBase>
class CRichEditCtrlT : public TBase
{
public:
// Constructors
	CRichEditCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }

	CRichEditCtrlT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return RICHEDIT_CLASS;
	}

	static LPCTSTR GetLibraryName()
	{
#if (_RICHEDIT_VER >= 0x0200)
		return _T("RICHED20.DLL");
#else
		return _T("RICHED32.DLL");
#endif
	}

	int GetLineCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_GETLINECOUNT, 0, 0L);
	}
	BOOL GetModify() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_GETMODIFY, 0, 0L);
	}
	void SetModify(BOOL bModified = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_SETMODIFY, bModified, 0L);
	}
	void GetRect(LPRECT lpRect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_GETRECT, 0, (LPARAM)lpRect);
	}
	DWORD GetOptions() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, EM_GETOPTIONS, 0, 0L);
	}
	DWORD SetOptions(WORD wOperation, DWORD dwOptions)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, EM_SETOPTIONS, wOperation, dwOptions);
	}

	// NOTE: first word in lpszBuffer must contain the size of the buffer!
	int GetLine(int nIndex, LPTSTR lpszBuffer) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_GETLINE, nIndex, (LPARAM)lpszBuffer);
	}
	int GetLine(int nIndex, LPTSTR lpszBuffer, int nMaxLength) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		*(LPINT)lpszBuffer = nMaxLength;
		return (int)::SendMessage(m_hWnd, EM_GETLINE, nIndex, (LPARAM)lpszBuffer);
	}

	BOOL CanUndo() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_CANUNDO, 0, 0L);
	}
	BOOL CanPaste(UINT nFormat = 0) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_CANPASTE, nFormat, 0L);
	}
	void GetSel(LONG& nStartChar, LONG& nEndChar) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		CHARRANGE cr;
		::SendMessage(m_hWnd, EM_EXGETSEL, 0, (LPARAM)&cr);
		nStartChar = cr.cpMin;
		nEndChar = cr.cpMax;
	}
	void GetSel(CHARRANGE &cr) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_EXGETSEL, 0, (LPARAM)&cr);
	}
	int SetSel(LONG nStartChar, LONG nEndChar)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		CHARRANGE cr = { nStartChar, nEndChar };
		return (int)::SendMessage(m_hWnd, EM_EXSETSEL, 0, (LPARAM)&cr);
	}
	int SetSel(CHARRANGE &cr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_EXSETSEL, 0, (LPARAM)&cr);
	}
	int SetSelAll()
	{
		return SetSel(-1, 0);
	}
	int SetSelNone()
	{
		return SetSel(0, -1);
	}
	DWORD GetDefaultCharFormat(CHARFORMAT& cf) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		cf.cbSize = sizeof(CHARFORMAT);
		return (DWORD)::SendMessage(m_hWnd, EM_GETCHARFORMAT, 0, (LPARAM)&cf);
	}
	DWORD GetSelectionCharFormat(CHARFORMAT& cf) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		cf.cbSize = sizeof(CHARFORMAT);
		return (DWORD)::SendMessage(m_hWnd, EM_GETCHARFORMAT, 1, (LPARAM)&cf);
	}
	DWORD GetEventMask() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, EM_GETEVENTMASK, 0, 0L);
	}
	LONG GetLimitText() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (LONG)::SendMessage(m_hWnd, EM_GETLIMITTEXT, 0, 0L);
	}
	DWORD GetParaFormat(PARAFORMAT& pf) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		pf.cbSize = sizeof(PARAFORMAT);
		return (DWORD)::SendMessage(m_hWnd, EM_GETPARAFORMAT, 0, (LPARAM)&pf);
	}
	// richedit EM_GETSELTEXT is ANSI
	LONG GetSelText(LPSTR lpBuf) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (LONG)::SendMessage(m_hWnd, EM_GETSELTEXT, 0, (LPARAM)lpBuf);
	}
#ifndef _ATL_NO_COM
	BOOL GetSelTextBSTR(BSTR& bstrText) const
	{
		USES_CONVERSION;
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(bstrText == NULL);

		CHARRANGE cr;
		cr.cpMin = cr.cpMax = 0;
		::SendMessage(m_hWnd, EM_EXGETSEL, 0, (LPARAM)&cr);
		LPSTR lpstrText = (char*)_alloca((cr.cpMax - cr.cpMin + 1) * 2);
		lpstrText[0] = 0;
		if(::SendMessage(m_hWnd, EM_GETSELTEXT, 0, (LPARAM)lpstrText) == 0)
			return FALSE;

		bstrText = ::SysAllocString(A2W(lpstrText));
		return (bstrText != NULL) ? TRUE : FALSE;
	}
#endif //!_ATL_NO_COM
#ifdef __ATLSTR_H__
	LONG GetSelText(CString& strText) const
	{
		ATLASSERT(::IsWindow(m_hWnd));

		CHARRANGE cr;
		cr.cpMin = cr.cpMax = 0;
		::SendMessage(m_hWnd, EM_EXGETSEL, 0, (LPARAM)&cr);
		LPSTR lpstrText = (char*)_alloca((cr.cpMax - cr.cpMin + 1) * 2);
		lpstrText[0] = 0;
		LONG lLen = (LONG)::SendMessage(m_hWnd, EM_GETSELTEXT, 0, (LPARAM)lpstrText);
		if(lLen == 0)
			return 0;

		USES_CONVERSION;
		strText = A2T(lpstrText);
		return lLen;
	}
#endif //__ATLSTR_H__
	WORD GetSelectionType() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (WORD)::SendMessage(m_hWnd, EM_SELECTIONTYPE, 0, 0L);
	}
	COLORREF SetBackgroundColor(COLORREF cr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, EM_SETBKGNDCOLOR, 0, cr);
	}
	COLORREF SetBackgroundColor()	// sets to system background
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, EM_SETBKGNDCOLOR, 1, 0);
	}
	BOOL SetDefaultCharFormat(CHARFORMAT& cf)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		cf.cbSize = sizeof(CHARFORMAT);
		return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, 0, (LPARAM)&cf);
	}
	BOOL SetSelectionCharFormat(CHARFORMAT& cf)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		cf.cbSize = sizeof(CHARFORMAT);
		return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);
	}
	BOOL SetWordCharFormat(CHARFORMAT& cf)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		cf.cbSize = sizeof(CHARFORMAT);
		return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, SCF_SELECTION | SCF_WORD, (LPARAM)&cf);
	}
	DWORD SetEventMask(DWORD dwEventMask)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, EM_SETEVENTMASK, 0, dwEventMask);
	}
	BOOL SetParaFormat(PARAFORMAT& pf)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		pf.cbSize = sizeof(PARAFORMAT);
		return (BOOL)::SendMessage(m_hWnd, EM_SETPARAFORMAT, 0, (LPARAM)&pf);
	}
	BOOL SetTargetDevice(HDC hDC, int cxLineWidth)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_SETTARGETDEVICE, (WPARAM)hDC, cxLineWidth);
	}
	int GetTextLength() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, WM_GETTEXTLENGTH, 0, 0L);
	}
	BOOL SetReadOnly(BOOL bReadOnly = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_SETREADONLY, bReadOnly, 0L);
	}
	int GetFirstVisibleLine() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_GETFIRSTVISIBLELINE, 0, 0L);
	}

	int GetTextRange(TEXTRANGE* pTextRange) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_GETTEXTRANGE, 0, (LPARAM)pTextRange);
	}
	int GetTextRange(LONG nStartChar, LONG nEndChar, LPSTR lpstrText) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		TEXTRANGE tr;
		tr.chrg.cpMin = nStartChar;
		tr.chrg.cpMax = nEndChar;
		tr.lpstrText = lpstrText;
		return (int)::SendMessage(m_hWnd, EM_GETTEXTRANGE, 0, (LPARAM)&tr);
	}
	EDITWORDBREAKPROCEX GetWordBreakProcEx() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (EDITWORDBREAKPROCEX)::SendMessage(m_hWnd, EM_GETWORDBREAKPROCEX, 0, 0L);
	}
	EDITWORDBREAKPROCEX SetWordBreakProcEx(EDITWORDBREAKPROCEX pfnEditWordBreakProcEx)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (EDITWORDBREAKPROCEX)::SendMessage(m_hWnd, EM_SETWORDBREAKPROCEX, 0, (LPARAM)pfnEditWordBreakProcEx);
	}

#if (_RICHEDIT_VER >= 0x0200)
	DWORD GetDefaultCharFormat(CHARFORMAT2& cf) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		cf.cbSize = sizeof(CHARFORMAT2);
		return (DWORD)::SendMessage(m_hWnd, EM_GETCHARFORMAT, 0, (LPARAM)&cf);
	}
	BOOL SetDefaultCharFormat(CHARFORMAT2& cf)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		cf.cbSize = sizeof(CHARFORMAT2);
		return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, 0, (LPARAM)&cf);
	}
	DWORD GetSelectionCharFormat(CHARFORMAT2& cf) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		cf.cbSize = sizeof(CHARFORMAT2);
		return (DWORD)::SendMessage(m_hWnd, EM_GETCHARFORMAT, 1, (LPARAM)&cf);
	}
	BOOL SetSelectionCharFormat(CHARFORMAT2& cf)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		cf.cbSize = sizeof(CHARFORMAT2);
		return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);
	}
	BOOL SetWordCharFormat(CHARFORMAT2& cf)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		cf.cbSize = sizeof(CHARFORMAT2);
		return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, SCF_SELECTION | SCF_WORD, (LPARAM)&cf);
	}

	DWORD GetParaFormat(PARAFORMAT2& pf) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		pf.cbSize = sizeof(PARAFORMAT2);
		return (DWORD)::SendMessage(m_hWnd, EM_GETPARAFORMAT, 0, (LPARAM)&pf);
	}
	BOOL SetParaFormat(PARAFORMAT2& pf)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		pf.cbSize = sizeof(PARAFORMAT2);
		return (BOOL)::SendMessage(m_hWnd, EM_SETPARAFORMAT, 0, (LPARAM)&pf);
	}
	TEXTMODE GetTextMode() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (TEXTMODE)::SendMessage(m_hWnd, EM_GETTEXTMODE, 0, 0L);
	}
	BOOL SetTextMode(TEXTMODE enumTextMode)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return !(BOOL)::SendMessage(m_hWnd, EM_SETTEXTMODE, enumTextMode, 0L);
	}
	UNDONAMEID GetUndoName() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UNDONAMEID)::SendMessage(m_hWnd, EM_GETUNDONAME, 0, 0L);
	}
	UNDONAMEID GetRedoName() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UNDONAMEID)::SendMessage(m_hWnd, EM_GETREDONAME, 0, 0L);
	}
	BOOL CanRedo() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_CANREDO, 0, 0L);
	}
	BOOL GetAutoURLDetect() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_GETAUTOURLDETECT, 0, 0L);
	}
	BOOL SetAutoURLDetect(BOOL bAutoDetect = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return !(BOOL)::SendMessage(m_hWnd, EM_AUTOURLDETECT, bAutoDetect, 0L);
	}
	// this method is deprecated, please use SetAutoURLDetect
	BOOL EnableAutoURLDetect(BOOL bEnable = TRUE) { return SetAutoURLDetect(bEnable); }
	UINT SetUndoLimit(UINT uUndoLimit)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, EM_SETUNDOLIMIT, uUndoLimit, 0L);
	}
	void SetPalette(HPALETTE hPalette)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_SETPALETTE, (WPARAM)hPalette, 0L);
	}
	int GetTextEx(GETTEXTEX* pGetTextEx, LPTSTR lpstrText) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_GETTEXTEX, (WPARAM)pGetTextEx, (LPARAM)lpstrText);
	}
	int GetTextEx(LPTSTR lpstrText, int nTextLen, DWORD dwFlags = GT_DEFAULT, UINT uCodePage = CP_ACP, LPCSTR lpDefaultChar = NULL, LPBOOL lpUsedDefChar = NULL) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		GETTEXTEX gte;
		gte.cb = nTextLen * sizeof(TCHAR);
		gte.codepage = uCodePage;
		gte.flags = dwFlags;
		gte.lpDefaultChar = lpDefaultChar;
		gte.lpUsedDefChar = lpUsedDefChar;
		return (int)::SendMessage(m_hWnd, EM_GETTEXTEX, (WPARAM)&gte, (LPARAM)lpstrText);
	}
	int GetTextLengthEx(GETTEXTLENGTHEX* pGetTextLengthEx) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_GETTEXTLENGTHEX, (WPARAM)pGetTextLengthEx, 0L);
	}
	int GetTextLengthEx(DWORD dwFlags = GTL_DEFAULT, UINT uCodePage = CP_ACP) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		GETTEXTLENGTHEX gtle;
		gtle.codepage = uCodePage;
		gtle.flags = dwFlags;
		return (int)::SendMessage(m_hWnd, EM_GETTEXTLENGTHEX, (WPARAM)&gtle, 0L);
	}
#endif //(_RICHEDIT_VER >= 0x0200)

#if (_RICHEDIT_VER >= 0x0300)
	int SetTextEx(SETTEXTEX* pSetTextEx, LPCTSTR lpstrText)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_SETTEXTEX, (WPARAM)pSetTextEx, (LPARAM)lpstrText);
	}
	int SetTextEx(LPCTSTR lpstrText, DWORD dwFlags = ST_DEFAULT, UINT uCodePage = CP_ACP)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		SETTEXTEX ste;
		ste.flags = dwFlags;
		ste.codepage = uCodePage;
		return (int)::SendMessage(m_hWnd, EM_SETTEXTEX, (WPARAM)&ste, (LPARAM)lpstrText);
	}
	int GetEditStyle() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_GETEDITSTYLE, 0, 0L);
	}

	int SetEditStyle(int nStyle, int nMask = -1)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		if(nMask == -1)
			nMask = nStyle;	// set everything specified
		return (int)::SendMessage(m_hWnd, EM_SETEDITSTYLE, nStyle, nMask);
	}
	BOOL SetFontSize(int nFontSizeDelta)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(nFontSizeDelta >= -1637 && nFontSizeDelta <= 1638);
		return (BOOL)::SendMessage(m_hWnd, EM_SETFONTSIZE, nFontSizeDelta, 0L);
	}
	void GetScrollPos(LPPOINT lpPoint) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(lpPoint != NULL);
		::SendMessage(m_hWnd, EM_GETSCROLLPOS, 0, (LPARAM)lpPoint);
	}
	void SetScrollPos(LPPOINT lpPoint)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(lpPoint != NULL);
		::SendMessage(m_hWnd, EM_SETSCROLLPOS, 0, (LPARAM)lpPoint);
	}
	BOOL GetZoom(int& nNum, int& nDen) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_GETZOOM, (WPARAM)&nNum, (LPARAM)&nDen);
	}
	BOOL SetZoom(int nNum, int nDen)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(nNum >= 0 && nNum <= 64);
		ATLASSERT(nDen >= 0 && nDen <= 64);
		return (BOOL)::SendMessage(m_hWnd, EM_SETZOOM, nNum, nDen);
	}
	BOOL SetZoomOff()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_SETZOOM, 0, 0L);
	}
#endif //(_RICHEDIT_VER >= 0x0300)

// Operations
	void LimitText(LONG nChars = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_EXLIMITTEXT, 0, nChars);
	}
	int LineFromChar(LONG nIndex) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_EXLINEFROMCHAR, 0, nIndex);
	}
	POINT PosFromChar(LONG nChar) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		POINT point;
		::SendMessage(m_hWnd, EM_POSFROMCHAR, (WPARAM)&point, nChar);
		return point;
	}
	int CharFromPos(POINT pt) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_CHARFROMPOS, 0, MAKELPARAM(pt.x, pt.y));
	}
	void EmptyUndoBuffer()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_EMPTYUNDOBUFFER, 0, 0L);
	}
	int LineIndex(int nLine = -1) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_LINEINDEX, nLine, 0L);
	}
	int LineLength(int nLine = -1) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_LINELENGTH, nLine, 0L);
	}
	BOOL LineScroll(int nLines, int nChars = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_LINESCROLL, nChars, nLines);
	}
	void ReplaceSel(LPCTSTR lpszNewText, BOOL bCanUndo = FALSE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_REPLACESEL, (WPARAM) bCanUndo, (LPARAM)lpszNewText);
	}
	void SetRect(LPCRECT lpRect)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_SETRECT, 0, (LPARAM)lpRect);
	}

	BOOL DisplayBand(LPRECT pDisplayRect)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_DISPLAYBAND, 0, (LPARAM)pDisplayRect);
	}
	LONG FindText(DWORD dwFlags, FINDTEXT& ft) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
#if (_RICHEDIT_VER >= 0x0200) && defined(_UNICODE)
		return (LONG)::SendMessage(m_hWnd, EM_FINDTEXTW, dwFlags, (LPARAM)&ft);
#else
		return (LONG)::SendMessage(m_hWnd, EM_FINDTEXT, dwFlags, (LPARAM)&ft);
#endif
	}
	LONG FindText(DWORD dwFlags, FINDTEXTEX& ft) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
#if (_RICHEDIT_VER >= 0x0200) && defined(_UNICODE)
		return (LONG)::SendMessage(m_hWnd, EM_FINDTEXTEXW, dwFlags, (LPARAM)&ft);
#else
		return (LONG)::SendMessage(m_hWnd, EM_FINDTEXTEX, dwFlags, (LPARAM)&ft);
#endif
	}
	LONG FormatRange(FORMATRANGE& fr, BOOL bDisplay = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (LONG)::SendMessage(m_hWnd, EM_FORMATRANGE, bDisplay, (LPARAM)&fr);
	}
	void HideSelection(BOOL bHide = TRUE, BOOL bChangeStyle = FALSE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_HIDESELECTION, bHide, bChangeStyle);
	}
	void PasteSpecial(UINT uClipFormat, DWORD dwAspect = 0, HMETAFILE hMF = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		REPASTESPECIAL reps = { dwAspect, (DWORD_PTR)hMF };
		::SendMessage(m_hWnd, EM_PASTESPECIAL, uClipFormat, (LPARAM)&reps);
	}
	void RequestResize()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_REQUESTRESIZE, 0, 0L);
	}
	LONG StreamIn(UINT uFormat, EDITSTREAM& es)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (LONG)::SendMessage(m_hWnd, EM_STREAMIN, uFormat, (LPARAM)&es);
	}
	LONG StreamOut(UINT uFormat, EDITSTREAM& es)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (LONG)::SendMessage(m_hWnd, EM_STREAMOUT, uFormat, (LPARAM)&es);
	}

	DWORD FindWordBreak(int nCode, LONG nStartChar)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, EM_FINDWORDBREAK, nCode, nStartChar);
	}

	// Additional operations
	void ScrollCaret()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_SCROLLCARET, 0, 0L);
	}
	int InsertText(long nInsertAfterChar, LPCTSTR lpstrText, BOOL bCanUndo = FALSE)
	{
		int nRet = SetSel(nInsertAfterChar, nInsertAfterChar);
		ReplaceSel(lpstrText, bCanUndo);
		return nRet;
	}
	int AppendText(LPCTSTR lpstrText, BOOL bCanUndo = FALSE)
	{
		return InsertText(GetWindowTextLength(), lpstrText, bCanUndo);
	}

	// Clipboard operations
	BOOL Undo()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_UNDO, 0, 0L);
	}
	void Clear()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_CLEAR, 0, 0L);
	}
	void Copy()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_COPY, 0, 0L);
	}
	void Cut()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_CUT, 0, 0L);
	}
	void Paste()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_PASTE, 0, 0L);
	}

	// OLE support
	IRichEditOle* GetOleInterface() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		IRichEditOle *pRichEditOle = NULL;
		::SendMessage(m_hWnd, EM_GETOLEINTERFACE, 0, (LPARAM)&pRichEditOle);
		return pRichEditOle;
	}
	BOOL SetOleCallback(IRichEditOleCallback* pCallback)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_SETOLECALLBACK, 0, (LPARAM)pCallback);
	}

#if (_RICHEDIT_VER >= 0x0200)
	BOOL Redo()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_REDO, 0, 0L);
	}
	void StopGroupTyping()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_STOPGROUPTYPING, 0, 0L);
	}
	void ShowScrollBar(int nBarType, BOOL bVisible = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_SHOWSCROLLBAR, nBarType, bVisible);
	}
#endif //(_RICHEDIT_VER >= 0x0200)
};

typedef CRichEditCtrlT<CWindow>		CRichEditCtrl;


/////////////////////////////////////////////////////////////////////////////
// CRichEditCommands - message handlers for standard EDIT commands

// Chain to CRichEditCommands message map. Your class must also derive from CRichEditCtrl.
// Example:
// class CMyRichEdit : public CWindowImpl<CMyRichEdit, CRichEditCtrl>,
//                     public CRichEditCommands<CMyRichEdit>
// {
// public:
//      BEGIN_MSG_MAP(CMyRichEdit)
//              // your handlers...
//              CHAIN_MSG_MAP_ALT(CRichEditCommands<CMyRichEdit>, 1)
//      END_MSG_MAP()
//      // other stuff...
// };

template <class T>
class CRichEditCommands : public CEditCommands< T >
{
public:
	BEGIN_MSG_MAP(CRichEditCommands< T >)
	ALT_MSG_MAP(1)
		COMMAND_ID_HANDLER(ID_EDIT_CLEAR, CEditCommands< T >::OnEditClear)
		COMMAND_ID_HANDLER(ID_EDIT_CLEAR_ALL, CEditCommands< T >::OnEditClearAll)
		COMMAND_ID_HANDLER(ID_EDIT_COPY, CEditCommands< T >::OnEditCopy)
		COMMAND_ID_HANDLER(ID_EDIT_CUT, CEditCommands< T >::OnEditCut)
		COMMAND_ID_HANDLER(ID_EDIT_PASTE, CEditCommands< T >::OnEditPaste)
		COMMAND_ID_HANDLER(ID_EDIT_SELECT_ALL, CEditCommands< T >::OnEditSelectAll)
		COMMAND_ID_HANDLER(ID_EDIT_UNDO, CEditCommands< T >::OnEditUndo)
#if (_RICHEDIT_VER >= 0x0200)
		COMMAND_ID_HANDLER(ID_EDIT_REDO, OnEditRedo)
#endif //(_RICHEDIT_VER >= 0x0200)
	END_MSG_MAP()

#if (_RICHEDIT_VER >= 0x0200)
	LRESULT OnEditRedo(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		pT->Redo();
		return 0;
	}
#endif //(_RICHEDIT_VER >= 0x0200)

// State (update UI) helpers
	BOOL CanCut() const
	{ return HasSelection(); }
	BOOL CanCopy() const
	{ return HasSelection(); }
	BOOL CanClear() const
	{ return HasSelection(); }

// Implementation
	BOOL HasSelection() const
	{
		const T* pT = static_cast<const T*>(this);
		return (pT->GetSelectionType() != SEL_EMPTY);
	}
};


/////////////////////////////////////////////////////////////////////////////
// CDragListBox

template <class TBase>
class CDragListBoxT : public CListBoxT< TBase >
{
public:
// Constructors
	CDragListBoxT(HWND hWnd = NULL) : CListBoxT< TBase >(hWnd) { }

	CDragListBoxT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		HWND hWnd = CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
		if(hWnd != NULL)
			MakeDragList();
		return hWnd;
	}

// Operations
	BOOL MakeDragList()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & (LBS_MULTIPLESEL | LBS_EXTENDEDSEL)) == 0);
		return ::MakeDragList(m_hWnd);
	}

	int LBItemFromPt(POINT pt, BOOL bAutoScroll = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::LBItemFromPt(m_hWnd, pt, bAutoScroll);
	}

	void DrawInsert(int nItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::DrawInsert(GetParent(), m_hWnd, nItem);
	}

	static UINT GetDragListMessage()
	{
		static UINT uDragListMessage = 0;
		if(uDragListMessage == 0)
		{
			::EnterCriticalSection(&_Module.m_csStaticDataInit);
			if(uDragListMessage == 0)
				uDragListMessage = ::RegisterWindowMessage(DRAGLISTMSGSTRING);
			::LeaveCriticalSection(&_Module.m_csStaticDataInit);
		}
		ATLASSERT(uDragListMessage != 0);
		return uDragListMessage;
	}
};

typedef CDragListBoxT<CWindow>	CDragListBox;

template <class T>
class CDragListNotifyImpl
{
public:
	BEGIN_MSG_MAP(CDragListNotifyImpl< T >)
		MESSAGE_HANDLER(CDragListBox::GetDragListMessage(), OnDragListNotify)
	END_MSG_MAP()

	LRESULT OnDragListNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		uMsg;	// avoid level 4 warning
		ATLASSERT(uMsg == CDragListBox::GetDragListMessage());
		T* pT = static_cast<T*>(this);
		LPDRAGLISTINFO lpDragListInfo = (LPDRAGLISTINFO)lParam;
		LRESULT lRet = 0;
		switch(lpDragListInfo->uNotification)
		{
		case DL_BEGINDRAG:
			lRet = (LPARAM)pT->OnBeginDrag((int)wParam, lpDragListInfo->hWnd, lpDragListInfo->ptCursor);
			break;
		case DL_CANCELDRAG:
			pT->OnCancelDrag((int)wParam, lpDragListInfo->hWnd, lpDragListInfo->ptCursor);
			break;
		case DL_DRAGGING:
			lRet = (LPARAM)pT->OnDragging((int)wParam, lpDragListInfo->hWnd, lpDragListInfo->ptCursor);
			break;
		case DL_DROPPED:
			pT->OnDropped((int)wParam, lpDragListInfo->hWnd, lpDragListInfo->ptCursor);
			break;
		default:
			ATLTRACE2(atlTraceUI, 0, _T("Unknown DragListBox notification\n"));
			bHandled = FALSE;	// don't handle it
			break;
		}
		return lRet;
	}

// Overrideables
	BOOL OnBeginDrag(int /*nCtlID*/, HWND /*hWndDragList*/, POINT /*ptCursor*/)
	{
		return TRUE;	// allow dragging
	}
	void OnCancelDrag(int /*nCtlID*/, HWND /*hWndDragList*/, POINT /*ptCursor*/)
	{
		// nothing to do
	}
	int OnDragging(int /*nCtlID*/, HWND /*hWndDragList*/, POINT /*ptCursor*/)
	{
		return 0;	// don't change cursor
	}
	void OnDropped(int /*nCtlID*/, HWND /*hWndDragList*/, POINT /*ptCursor*/)
	{
		// nothing to do
	}
};


/////////////////////////////////////////////////////////////////////////////
// CReBarCtrl

template <class TBase>
class CReBarCtrlT : public TBase
{
public:
// Constructors
	CReBarCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }

	CReBarCtrlT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return REBARCLASSNAME;
	}

	UINT GetBandCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, RB_GETBANDCOUNT, 0, 0L);
	}
	BOOL GetBandInfo(int nBand, LPREBARBANDINFO lprbbi) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, RB_GETBANDINFO, nBand, (LPARAM)lprbbi);
	}
	BOOL SetBandInfo(int nBand, LPREBARBANDINFO lprbbi)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, RB_SETBANDINFO, nBand, (LPARAM)lprbbi);
	}
	BOOL GetBarInfo(LPREBARINFO lprbi) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, RB_GETBARINFO, 0, (LPARAM)lprbi);
	}
	BOOL SetBarInfo(LPREBARINFO lprbi)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, RB_SETBARINFO, 0, (LPARAM)lprbi);
	}
	UINT GetRowCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, RB_GETROWCOUNT, 0, 0L);
	}
	UINT GetRowHeight(int nBand) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, RB_GETROWHEIGHT, nBand, 0L);
	}

#if (_WIN32_IE >= 0x0400)
	COLORREF GetTextColor() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, RB_GETTEXTCOLOR, 0, 0L);
	}
	COLORREF SetTextColor(COLORREF clr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, RB_SETTEXTCOLOR, 0, (LPARAM)clr);
	}
	COLORREF GetBkColor() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, RB_GETBKCOLOR, 0, 0L);
	}
	COLORREF SetBkColor(COLORREF clr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, RB_SETBKCOLOR, 0, (LPARAM)clr);
	}
	UINT GetBarHeight() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, RB_GETBARHEIGHT, 0, 0L);
	}
	BOOL GetRect(int nBand, LPRECT lpRect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, RB_GETRECT, nBand, (LPARAM)lpRect);
	}
	CToolTipCtrl GetToolTips() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CToolTipCtrl((HWND)::SendMessage(m_hWnd, RB_GETTOOLTIPS, 0, 0L));
	}
	void SetToolTips(HWND hwndToolTip)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, RB_SETTOOLTIPS, (WPARAM)hwndToolTip, 0L);
	}
	void GetBandBorders(int nBand, LPRECT lpRect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(lpRect != NULL);
		::SendMessage(m_hWnd, RB_GETBANDBORDERS, nBand, (LPARAM)lpRect);
	}
	BOOL GetColorScheme(LPCOLORSCHEME lpColorScheme) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(lpColorScheme != NULL);
		return (BOOL)::SendMessage(m_hWnd, RB_GETCOLORSCHEME, 0, (LPARAM)lpColorScheme);
	}
	void SetColorScheme(LPCOLORSCHEME lpColorScheme)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(lpColorScheme != NULL);
		::SendMessage(m_hWnd, RB_SETCOLORSCHEME, 0, (LPARAM)lpColorScheme);
	}
	HPALETTE GetPalette() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HPALETTE)::SendMessage(m_hWnd, RB_GETPALETTE, 0, 0L);
	}
	HPALETTE SetPalette(HPALETTE hPalette)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HPALETTE)::SendMessage(m_hWnd, RB_SETPALETTE, 0, (LPARAM)hPalette);
	}
	BOOL GetUnicodeFormat() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, RB_GETUNICODEFORMAT, 0, 0L);
	}
	BOOL SetUnicodeFormat(BOOL bUnicode = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, RB_SETUNICODEFORMAT, bUnicode, 0L);
	}
#endif //(_WIN32_IE >= 0x0400)

// Operations
	BOOL InsertBand(int nBand, LPREBARBANDINFO lprbbi)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		lprbbi->cbSize = sizeof(REBARBANDINFO);
		return (BOOL)::SendMessage(m_hWnd, RB_INSERTBAND, nBand, (LPARAM)lprbbi);
	}
	BOOL DeleteBand(int nBand)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, RB_DELETEBAND, nBand, 0L);
	}
	CWindow SetNotifyWnd(HWND hWnd)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CWindow((HWND)::SendMessage(m_hWnd, RB_SETPARENT, (WPARAM)hWnd, 0L));
	}

#if (_WIN32_IE >= 0x0400)
	void BeginDrag(int nBand, DWORD dwPos)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, RB_BEGINDRAG, nBand, dwPos);
	}
	void BeginDrag(int nBand, int xPos, int yPos)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, RB_BEGINDRAG, nBand, MAKELPARAM(xPos, yPos));
	}
	void EndDrag()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, RB_ENDDRAG, 0, 0L);
	}
	void DragMove(DWORD dwPos)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, RB_DRAGMOVE, 0, dwPos);
	}
	void DragMove(int xPos, int yPos)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, RB_DRAGMOVE, 0, MAKELPARAM(xPos, yPos));
	}
	void GetDropTarget(IDropTarget** ppDropTarget) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, RB_GETDROPTARGET, 0, (LPARAM)ppDropTarget);
	}
	void MaximizeBand(int nBand)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, RB_MAXIMIZEBAND, nBand, 0L);
	}
	void MinimizeBand(int nBand)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, RB_MINIMIZEBAND, nBand, 0L);
	}
	BOOL SizeToRect(LPRECT lpRect)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, RB_SIZETORECT, 0, (LPARAM)lpRect);
	}
	int IdToIndex(UINT uBandID) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, RB_IDTOINDEX, uBandID, 0L);
	}
	int HitTest(LPRBHITTESTINFO lprbht) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, RB_HITTEST, 0, (LPARAM)lprbht);
	}
	BOOL ShowBand(int nBand, BOOL bShow)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, RB_SHOWBAND, nBand, bShow);
	}
	BOOL MoveBand(int nBand, int nNewPos)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(nNewPos >= 0 && nNewPos <= ((int)GetBandCount() - 1));
		return (BOOL)::SendMessage(m_hWnd, RB_MOVEBAND, nBand, nNewPos);
	}
#endif //(_WIN32_IE >= 0x0400)

#if (_WIN32_IE >= 0x0500)
	void PushChevron(int nBand, LPARAM lAppValue)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, RB_PUSHCHEVRON, nBand, lAppValue);
	}
#endif //(_WIN32_IE >= 0x0500)
};

typedef CReBarCtrlT<CWindow>		CReBarCtrl;


/////////////////////////////////////////////////////////////////////////////
// CComboBoxEx

template <class TBase>
class CComboBoxExT : public CComboBoxT< TBase >
{
public:
// Constructors
	CComboBoxExT(HWND hWnd = NULL) : CComboBoxT< TBase >(hWnd) { }

	CComboBoxExT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return WC_COMBOBOXEX;
	}

	CImageList GetImageList() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, CBEM_GETIMAGELIST, 0, 0L));
	}
	CImageList SetImageList(HIMAGELIST hImageList)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, CBEM_SETIMAGELIST, 0, (LPARAM)hImageList));
	}

#if (_WIN32_IE >= 0x0400)
	DWORD GetExtendedStyle() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, CBEM_GETEXTENDEDSTYLE, 0, 0L);
	}
	DWORD SetExtendedStyle(DWORD dwExMask, DWORD dwExStyle)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, CBEM_SETEXTENDEDSTYLE, dwExMask, dwExStyle);
	}
	BOOL GetUnicodeFormat() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, CBEM_GETUNICODEFORMAT, 0, 0L);
	}
	BOOL SetUnicodeFormat(BOOL bUnicode = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, CBEM_SETUNICODEFORMAT, bUnicode, 0L);
	}
#endif //(_WIN32_IE >= 0x0400)

// Operations
	int InsertItem(const COMBOBOXEXITEM FAR* lpcCBItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CBEM_INSERTITEM, 0, (LPARAM)lpcCBItem);
	}
	int DeleteItem(int nIndex)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CBEM_DELETEITEM, nIndex, 0L);
	}
	BOOL GetItem(PCOMBOBOXEXITEM pCBItem) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, CBEM_GETITEM, 0, (LPARAM)pCBItem);
	}
	BOOL SetItem(const COMBOBOXEXITEM FAR* lpcCBItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, CBEM_SETITEM, 0, (LPARAM)lpcCBItem);
	}
	CComboBox GetComboCtrl() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CComboBox((HWND)::SendMessage(m_hWnd, CBEM_GETCOMBOCONTROL, 0, 0L));
	}
	CEdit GetEditCtrl() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CEdit((HWND)::SendMessage(m_hWnd, CBEM_GETEDITCONTROL, 0, 0L));
	}
	BOOL HasEditChanged() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, CBEM_HASEDITCHANGED, 0, 0L);
	}
};

typedef CComboBoxExT<CWindow>		CComboBoxEx;


/////////////////////////////////////////////////////////////////////////////
// CMonthCalendarCtrl

template <class TBase>
class CMonthCalendarCtrlT : public TBase
{
public:
// Constructors
	CMonthCalendarCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }

	CMonthCalendarCtrlT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return MONTHCAL_CLASS;
	}

	COLORREF GetColor(int nColorType) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, MCM_GETCOLOR, nColorType, 0L);
	}
	COLORREF SetColor(int nColorType, COLORREF clr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, MCM_SETCOLOR, nColorType, clr);
	}
	BOOL GetCurSel(LPSYSTEMTIME lpSysTime) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, MCM_GETCURSEL, 0, (LPARAM)lpSysTime);
	}
	BOOL SetCurSel(LPSYSTEMTIME lpSysTime)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, MCM_SETCURSEL, 0, (LPARAM)lpSysTime);
	}
	int GetFirstDayOfWeek(BOOL* pbLocaleVal = NULL) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, MCM_GETFIRSTDAYOFWEEK, 0, 0L);
		if(pbLocaleVal != NULL)
			*pbLocaleVal = (BOOL)HIWORD(dwRet);
		return (int)(short)LOWORD(dwRet);
	}
	int SetFirstDayOfWeek(int nDay, BOOL* pbLocaleVal = NULL)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, MCM_SETFIRSTDAYOFWEEK, 0, nDay);
		if(pbLocaleVal != NULL)
			*pbLocaleVal = (BOOL)HIWORD(dwRet);
		return (int)(short)LOWORD(dwRet);
	}
	int GetMaxSelCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, MCM_GETMAXSELCOUNT, 0, 0L);
	}
	BOOL SetMaxSelCount(int nMax)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, MCM_SETMAXSELCOUNT, nMax, 0L);
	}
	int GetMonthDelta() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, MCM_GETMONTHDELTA, 0, 0L);
	}
	int SetMonthDelta(int nDelta)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, MCM_SETMONTHDELTA, nDelta, 0L);
	}
	DWORD GetRange(LPSYSTEMTIME lprgSysTimeArray) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, MCM_GETRANGE, 0, (LPARAM)lprgSysTimeArray);
	}
	BOOL SetRange(DWORD dwFlags, LPSYSTEMTIME lprgSysTimeArray)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, MCM_SETRANGE, dwFlags, (LPARAM)lprgSysTimeArray);
	}
	BOOL GetSelRange(LPSYSTEMTIME lprgSysTimeArray) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, MCM_GETSELRANGE, 0, (LPARAM)lprgSysTimeArray);
	}
	BOOL SetSelRange(LPSYSTEMTIME lprgSysTimeArray)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, MCM_SETSELRANGE, 0, (LPARAM)lprgSysTimeArray);
	}
	BOOL GetToday(LPSYSTEMTIME lpSysTime) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, MCM_GETTODAY, 0, (LPARAM)lpSysTime);
	}
	void SetToday(LPSYSTEMTIME lpSysTime)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, MCM_SETTODAY, 0, (LPARAM)lpSysTime);
	}
	BOOL GetMinReqRect(LPRECT lpRectInfo) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, MCM_GETMINREQRECT, 0, (LPARAM)lpRectInfo);
	}
	int GetMonthRange() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, MCM_GETMAXTODAYWIDTH, 0, 0L);
	}

#if (_WIN32_IE >= 0x0400)
	BOOL GetUnicodeFormat() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, MCM_GETUNICODEFORMAT, 0, 0L);
	}
	BOOL SetUnicodeFormat(BOOL bUnicode = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, MCM_SETUNICODEFORMAT, bUnicode, 0L);
	}
#endif //(_WIN32_IE >= 0x0400)

// Operations
	int GetMonthRange(DWORD dwFlags, LPSYSTEMTIME lprgSysTimeArray) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, MCM_GETMONTHRANGE, dwFlags, (LPARAM)lprgSysTimeArray);
	}
	BOOL SetDayState(int nMonths, LPMONTHDAYSTATE lpDayStateArray)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, MCM_SETDAYSTATE, nMonths, (LPARAM)lpDayStateArray);
	}
	DWORD HitTest(PMCHITTESTINFO pMCHitTest) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, MCM_HITTEST, 0, (LPARAM)pMCHitTest);
	}
};

typedef CMonthCalendarCtrlT<CWindow>		CMonthCalendarCtrl;


/////////////////////////////////////////////////////////////////////////////
// CDateTimePickerCtrl

template <class TBase>
class CDateTimePickerCtrlT : public TBase
{
public:
// Constructors
	CDateTimePickerCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }

	CDateTimePickerCtrlT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Operations
	static LPCTSTR GetWndClassName()
	{
		return DATETIMEPICK_CLASS;
	}

	BOOL SetFormat(LPTSTR lpszFormat)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, DTM_SETFORMAT, 0, (LPARAM)lpszFormat);
	}
	COLORREF GetMonthCalColor(int nColorType) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, DTM_GETMCCOLOR, nColorType, 0L);
	}
	COLORREF SetMonthCalColor(int nColorType, COLORREF clr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, DTM_SETMCCOLOR, nColorType, clr);
	}
	DWORD GetRange(LPSYSTEMTIME lpSysTimeArray) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, DTM_GETRANGE, 0, (LPARAM)lpSysTimeArray);
	}
	BOOL SetRange(DWORD dwFlags, LPSYSTEMTIME lpSysTimeArray)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, DTM_SETRANGE, dwFlags, (LPARAM)lpSysTimeArray);
	}
	DWORD GetSystemTime(LPSYSTEMTIME lpSysTime) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, DTM_GETSYSTEMTIME, 0, (LPARAM)lpSysTime);
	}
	BOOL SetSystemTime(DWORD dwFlags, LPSYSTEMTIME lpSysTime)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, DTM_SETSYSTEMTIME, dwFlags, (LPARAM)lpSysTime);
	}
	CMonthCalendarCtrl GetMonthCal() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CMonthCalendarCtrl((HWND)::SendMessage(m_hWnd, DTM_GETMONTHCAL, 0, 0L));
	}

#if (_WIN32_IE >= 0x0400)
	CFontHandle GetMonthCalFont() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CFontHandle((HFONT)::SendMessage(m_hWnd, DTM_GETMCFONT, 0, 0L));
	}
	void SetMonthCalFont(HFONT hFont, BOOL bRedraw = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, DTM_SETMCFONT, (WPARAM)hFont, MAKELPARAM(bRedraw, 0));
	}
#endif //(_WIN32_IE >= 0x0400)
};

typedef CDateTimePickerCtrlT<CWindow>		CDateTimePickerCtrl;


/////////////////////////////////////////////////////////////////////////////
// CFlatScrollBarImpl - support for flat scroll bars

#if (_WIN32_IE >= 0x0400)

template <class T>
class CFlatScrollBarImpl
{
public:
// Initialization
	BOOL FlatSB_Initialize()
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		return ::InitializeFlatSB(pT->m_hWnd);
	}
	HRESULT FlatSB_Uninitialize()
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		return ::UninitializeFlatSB(pT->m_hWnd);
	}

// Flat scroll bar properties
	BOOL FlatSB_GetScrollProp(UINT uIndex, LPINT lpnValue) const
	{
		const T* pT = static_cast<const T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		return ::FlatSB_GetScrollProp(pT->m_hWnd, uIndex, lpnValue);
	}
	BOOL FlatSB_SetScrollProp(UINT uIndex, int nValue, BOOL bRedraw = TRUE)
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		return ::FlatSB_SetScrollProp(pT->m_hWnd, uIndex, nValue, bRedraw);
	}

// Attributes
	int FlatSB_GetScrollPos(int nBar) const
	{
		const T* pT = static_cast<const T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		return ::FlatSB_GetScrollPos(pT->m_hWnd, nBar);
	}

	int FlatSB_SetScrollPos(int nBar, int nPos, BOOL bRedraw = TRUE)
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		return ::FlatSB_SetScrollPos(pT->m_hWnd, nBar, nPos, bRedraw);
	}

	BOOL FlatSB_GetScrollRange(int nBar, LPINT lpMinPos, LPINT lpMaxPos) const
	{
		const T* pT = static_cast<const T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		return ::FlatSB_GetScrollRange(pT->m_hWnd, nBar, lpMinPos, lpMaxPos);
	}

	BOOL FlatSB_SetScrollRange(int nBar, int nMinPos, int nMaxPos, BOOL bRedraw = TRUE)
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		return ::FlatSB_SetScrollRange(pT->m_hWnd, nBar, nMinPos, nMaxPos, bRedraw);
	}

	BOOL FlatSB_GetScrollInfo(int nBar, LPSCROLLINFO lpScrollInfo) const
	{
		const T* pT = static_cast<const T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		return ::FlatSB_GetScrollInfo(pT->m_hWnd, nBar, lpScrollInfo);
	}

	int FlatSB_SetScrollInfo(int nBar, LPSCROLLINFO lpScrollInfo, BOOL bRedraw = TRUE)
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		return ::FlatSB_SetScrollInfo(pT->m_hWnd, nBar, lpScrollInfo, bRedraw);
	}

// Operations
	BOOL FlatSB_ShowScrollBar(UINT nBar, BOOL bShow = TRUE)
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		return ::FlatSB_ShowScrollBar(pT->m_hWnd, nBar, bShow);
	}

	BOOL FlatSB_EnableScrollBar(UINT uSBFlags, UINT uArrowFlags = ESB_ENABLE_BOTH)
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		return ::FlatSB_EnableScrollBar(pT->m_hWnd, uSBFlags, uArrowFlags);
	}
};

template <class TBase>
class CFlatScrollBarT : public TBase, public CFlatScrollBarImpl<CFlatScrollBarT< TBase > >
{
public:
	CFlatScrollBarT(HWND hWnd = NULL) : TBase(hWnd) { }

	CFlatScrollBarT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}
};

typedef CFlatScrollBarT<CWindow>		CFlatScrollBar;

#endif //(_WIN32_IE >= 0x0400)


/////////////////////////////////////////////////////////////////////////////
// CIPAddressCtrl

#if (_WIN32_IE >= 0x0400)

template <class TBase>
class CIPAddressCtrlT : public TBase
{
public:
// Constructors
	CIPAddressCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }

	CIPAddressCtrlT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Atteributes
	static LPCTSTR GetWndClassName()
	{
		return WC_IPADDRESS;
	}

	BOOL IsBlank() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, IPM_ISBLANK, 0, 0L);
	}
	int GetAddress(LPDWORD lpdwAddress) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, IPM_GETADDRESS, 0, (LPARAM)lpdwAddress);
	}
	void SetAddress(DWORD dwAddress)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, IPM_SETADDRESS, 0, dwAddress);
	}
	void ClearAddress()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, IPM_CLEARADDRESS, 0, 0L);
	}
	void SetRange(int nField, WORD wRange)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, IPM_SETRANGE, nField, wRange);
	}
	void SetRange(int nField, BYTE nMin, BYTE nMax)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, IPM_SETRANGE, nField, MAKEIPRANGE(nMin, nMax));
	}
	void SetFocus(int nField)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, IPM_SETFOCUS, nField, 0L);
	}
};

typedef CIPAddressCtrlT<CWindow>		CIPAddressCtrl;

#endif //(_WIN32_IE >= 0x0400)


/////////////////////////////////////////////////////////////////////////////
// CPagerCtrl

#if (_WIN32_IE >= 0x0400)

template <class TBase>
class CPagerCtrlT : public TBase
{
public:
// Constructors
	CPagerCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }

	CPagerCtrlT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return WC_PAGESCROLLER;
	}

	int GetButtonSize() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, PGM_GETBUTTONSIZE, 0, 0L);
	}
	int SetButtonSize(int nButtonSize)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, PGM_SETBUTTONSIZE, 0, nButtonSize);
	}
	DWORD GetButtonState(int nButton) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(nButton == PGB_TOPORLEFT || nButton == PGB_BOTTOMORRIGHT);
		return (DWORD)::SendMessage(m_hWnd, PGM_GETBUTTONSTATE, 0, nButton);
	}
	COLORREF GetBkColor() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, PGM_GETBKCOLOR, 0, 0L);
	}
	COLORREF SetBkColor(COLORREF clrBk)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, PGM_SETBKCOLOR, 0, (LPARAM)clrBk);
	}
	int GetBorder() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, PGM_GETBORDER, 0, 0L);
	}
	int SetBorder(int nBorderSize)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, PGM_SETBORDER, 0, nBorderSize);
	}
	int GetPos() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, PGM_GETPOS, 0, 0L);
	}
	int SetPos(int nPos)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, PGM_SETPOS, 0, nPos);
	}

// Operations
	void SetChild(HWND hWndChild)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, PGM_SETCHILD, 0, (LPARAM)hWndChild);
	}
	void ForwardMouse(BOOL bForward = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, PGM_FORWARDMOUSE, bForward, 0L);
	}
	void RecalcSize()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, PGM_RECALCSIZE, 0, 0L);
	}
	void GetDropTarget(IDropTarget** ppDropTarget)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(ppDropTarget != NULL);
		::SendMessage(m_hWnd, PGM_GETDROPTARGET, 0, (LPARAM)ppDropTarget);
	}
};

typedef CPagerCtrlT<CWindow>		CPagerCtrl;

#endif //(_WIN32_IE >= 0x0400)


/////////////////////////////////////////////////////////////////////////////
// CCustomDraw - MI class for custom-draw support

template <class T>
class CCustomDraw
{
public:
#if !defined(_ATL_TMP_IMPL1) && !defined(_ATL_TMP_IMPL2)
	BOOL m_bHandledCD;

	BOOL IsMsgHandled() const
	{
		return m_bHandledCD;
	}
	void SetMsgHandled(BOOL bHandled)
	{
		m_bHandledCD = bHandled;
	}
#endif //!defined(_ATL_TMP_IMPL1) && !defined(_ATL_TMP_IMPL2)

// Message map and handlers
	BEGIN_MSG_MAP(CCustomDraw< T >)
		NOTIFY_CODE_HANDLER(NM_CUSTOMDRAW, OnCustomDraw)
	ALT_MSG_MAP(1)
		REFLECTED_NOTIFY_CODE_HANDLER(NM_CUSTOMDRAW, OnCustomDraw)
	END_MSG_MAP()

// message handler
	LRESULT OnCustomDraw(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
	{
		T* pT = static_cast<T*>(this);
		pT->SetMsgHandled(TRUE);
		LPNMCUSTOMDRAW lpNMCustomDraw = (LPNMCUSTOMDRAW)pnmh;
		DWORD dwRet = 0;
		switch(lpNMCustomDraw->dwDrawStage)
		{
		case CDDS_PREPAINT:
			dwRet = pT->OnPrePaint(idCtrl, lpNMCustomDraw);
			break;
		case CDDS_POSTPAINT:
			dwRet = pT->OnPostPaint(idCtrl, lpNMCustomDraw);
			break;
		case CDDS_PREERASE:
			dwRet = pT->OnPreErase(idCtrl, lpNMCustomDraw);
			break;
		case CDDS_POSTERASE:
			dwRet = pT->OnPostErase(idCtrl, lpNMCustomDraw);
			break;
		case CDDS_ITEMPREPAINT:
			dwRet = pT->OnItemPrePaint(idCtrl, lpNMCustomDraw);
			break;
		case CDDS_ITEMPOSTPAINT:
			dwRet = pT->OnItemPostPaint(idCtrl, lpNMCustomDraw);
			break;
		case CDDS_ITEMPREERASE:
			dwRet = pT->OnItemPreErase(idCtrl, lpNMCustomDraw);
			break;
		case CDDS_ITEMPOSTERASE:
			dwRet = pT->OnItemPostErase(idCtrl, lpNMCustomDraw);
			break;
		default:
			pT->SetMsgHandled(FALSE);
			break;
		}
		bHandled = pT->IsMsgHandled();
		return dwRet;
	}

// Overrideables
	DWORD OnPrePaint(int /*idCtrl*/, LPNMCUSTOMDRAW /*lpNMCustomDraw*/)
	{
		return CDRF_DODEFAULT;
	}
	DWORD OnPostPaint(int /*idCtrl*/, LPNMCUSTOMDRAW /*lpNMCustomDraw*/)
	{
		return CDRF_DODEFAULT;
	}
	DWORD OnPreErase(int /*idCtrl*/, LPNMCUSTOMDRAW /*lpNMCustomDraw*/)
	{
		return CDRF_DODEFAULT;
	}
	DWORD OnPostErase(int /*idCtrl*/, LPNMCUSTOMDRAW /*lpNMCustomDraw*/)
	{
		return CDRF_DODEFAULT;
	}
	DWORD OnItemPrePaint(int /*idCtrl*/, LPNMCUSTOMDRAW /*lpNMCustomDraw*/)
	{
		return CDRF_DODEFAULT;
	}
	DWORD OnItemPostPaint(int /*idCtrl*/, LPNMCUSTOMDRAW /*lpNMCustomDraw*/)
	{
		return CDRF_DODEFAULT;
	}
	DWORD OnItemPreErase(int /*idCtrl*/, LPNMCUSTOMDRAW /*lpNMCustomDraw*/)
	{
		return CDRF_DODEFAULT;
	}
	DWORD OnItemPostErase(int /*idCtrl*/, LPNMCUSTOMDRAW /*lpNMCustomDraw*/)
	{
		return CDRF_DODEFAULT;
	}
};

}; //namespace WTL

#endif // __ATLCTRLS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\ncetest\testdlg.h ===
// TestDlg.h : header file
//

#if !defined(AFX_TESTDLG_H__E33F0CB6_2D5D_4D50_851D_9732F3B78642__INCLUDED_)
#define AFX_TESTDLG_H__E33F0CB6_2D5D_4D50_851D_9732F3B78642__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "NCObjApi.h"

/////////////////////////////////////////////////////////////////////////////
// CTestDlg dialog

#define NUM_EVENT_TYPES 5

class CNCEvent;

class CTestDlg : public CDialog
{
// Construction
public:
	CTestDlg(CWnd* pParent = NULL);	// standard constructor
    ~CTestDlg();

// Dialog Data
	//{{AFX_DATA(CTestDlg)
	enum { IDD = IDD_NCETEST_DIALOG };
	CEdit	m_ctlCallback;
	CComboBox	m_ctlAPI;
	CComboBox	m_ctlEventTypes;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTestDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON    m_hIcon;
    HWND     m_hwndStatus;
    CNCEvent *m_pEvents[NUM_EVENT_TYPES];

	void FreeHandles();
    void Connect();
    void AddStatus(LPCTSTR szMsg);

    static HRESULT WINAPI EventSourceCallback(
        HANDLE hSource, 
        EVENT_SOURCE_MSG msg, 
        LPVOID pUser, 
        LPVOID pData);

    // Generated message map functions
	//{{AFX_MSG(CTestDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnConnect();
	afx_msg void OnSelchangeEventTypes();
	afx_msg void OnSend();
	afx_msg void OnDestroy();
	afx_msg void OnCopy();
	afx_msg void OnClear();
	afx_msg void OnConnectionSd();
	afx_msg void OnEventSd();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TESTDLG_H__E33F0CB6_2D5D_4D50_851D_9732F3B78642__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\atlddx.h ===
// WTL Version 3.0
// Copyright (C) 1997-1999 Microsoft Corporation
// All rights reserved.
//
// This file is a part of Windows Template Library.
// The code and information is provided "as-is" without
// warranty of any kind, either expressed or implied.

#ifndef __ATLDDX_H__
#define __ATLDDX_H__

#pragma once

#if defined(_ATL_USE_DDX_FLOAT) && defined(_ATL_MIN_CRT)
	#error Cannot use floating point DDX with _ATL_MIN_CRT defined
#endif //defined(_ATL_USE_DDX_FLOAT) && defined(_ATL_MIN_CRT)

#ifdef _ATL_USE_DDX_FLOAT
#include <float.h>
#ifndef _DEBUG
#include <stdio.h>
#endif //!_DEBUG
#endif //_ATL_USE_DDX_FLOAT

namespace WTL
{

// Constants
#define DDX_LOAD	FALSE
#define DDX_SAVE	TRUE

// DDX map macros
#define BEGIN_DDX_MAP(thisClass) \
	BOOL DoDataExchange(BOOL bSaveAndValidate = FALSE, UINT nCtlID = (UINT)-1) \
	{ \

#define DDX_TEXT(nID, var) \
		if(nCtlID == (UINT)-1 || nCtlID == nID) \
		{ \
			if(!DDX_Text(nID, var, sizeof(var), bSaveAndValidate)) \
				return FALSE; \
		}

#define DDX_TEXT_LEN(nID, var, len) \
		if(nCtlID == (UINT)-1 || nCtlID == nID) \
		{ \
			if(!DDX_Text(nID, var, sizeof(var), bSaveAndValidate, TRUE, len)) \
				return FALSE; \
		}

#define DDX_INT(nID, var) \
		if(nCtlID == (UINT)-1 || nCtlID == nID) \
		{ \
			if(!DDX_Int(nID, var, TRUE, bSaveAndValidate)) \
				return FALSE; \
		}

#define DDX_INT_RANGE(nID, var, min, max) \
		if(nCtlID == (UINT)-1 || nCtlID == nID) \
		{ \
			if(!DDX_Int(nID, var, TRUE, bSaveAndValidate, TRUE, min, max)) \
				return FALSE; \
		}

#define DDX_UINT(nID, var) \
		if(nCtlID == (UINT)-1 || nCtlID == nID) \
		{ \
			if(!DDX_Int(nID, var, FALSE, bSaveAndValidate)) \
				return FALSE; \
		}

#define DDX_UINT_RANGE(nID, var, min, max) \
		if(nCtlID == (UINT)-1 || nCtlID == nID) \
		{ \
			if(!DDX_Int(nID, var, FALSE, bSaveAndValidate, TRUE, min, max)) \
				return FALSE; \
		}

#ifdef _ATL_USE_DDX_FLOAT
#define DDX_FLOAT(nID, var) \
		if(nCtlID == (UINT)-1 || nCtlID == nID) \
		{ \
			if(!DDX_Float(nID, var, bSaveAndValidate)) \
				return FALSE; \
		}

#define DDX_FLOAT_RANGE(nID, var, min, max) \
		if(nCtlID == (UINT)-1 || nCtlID == nID) \
		{ \
			if(!DDX_Float(nID, var, bSaveAndValidate, TRUE, min, max)) \
				return FALSE; \
		}
#endif //_ATL_USE_DDX_FLOAT

#define DDX_CONTROL(nID, obj) \
		if(nCtlID == (UINT)-1 || nCtlID == nID) \
			DDX_Control(nID, obj, bSaveAndValidate);

#define DDX_CHECK(nID, var) \
		if(nCtlID == (UINT)-1 || nCtlID == nID) \
			DDX_Check(nID, var, bSaveAndValidate);

#define DDX_RADIO(nID, var) \
		if(nCtlID == (UINT)-1 || nCtlID == nID) \
			DDX_Radio(nID, var, bSaveAndValidate);

#define END_DDX_MAP() \
		return TRUE; \
	}


/////////////////////////////////////////////////////////////////////////////
// CWinDataExchange - provides support for DDX

template <class T>
class CWinDataExchange
{
public:
// Data exchange method - override in your derived class
	BOOL DoDataExchange(BOOL /*bSaveAndValidate*/ = FALSE, UINT /*nCtlID*/ = (UINT)-1)
	{
		// this one should never be called, override it in
		// your derived class by implementing DDX map
		ATLASSERT(FALSE);
		return FALSE;
	}

// Helpers for validation error reporting
	enum _XDataType
	{
		ddxDataNull = 0,
		ddxDataText = 1,
		ddxDataInt = 2,
		ddxDataFloat = 3,
		ddxDataDouble = 4
	};

	struct _XTextData
	{
		int nLength;
		int nMaxLength;
	};

	struct _XIntData
	{
		long nVal;
		long nMin;
		long nMax;
	};

	struct _XFloatData
	{
		double nVal;
		double nMin;
		double nMax;
	};

	struct _XData
	{
		_XDataType nDataType;
		union
		{
			_XTextData textData;
			_XIntData intData;
			_XFloatData floatData;
		};
	};

// Text exchange
	BOOL DDX_Text(UINT nID, LPTSTR lpstrText, int nSize, BOOL bSave, BOOL bValidate = FALSE, int nLength = 0)
	{
		T* pT = static_cast<T*>(this);
		BOOL bSuccess = TRUE;

		if(bSave)
		{
			HWND hWndCtrl = pT->GetDlgItem(nID);
			int nRetLen = ::GetWindowText(hWndCtrl, lpstrText, nSize);
			if(nRetLen < ::GetWindowTextLength(hWndCtrl))
				bSuccess = FALSE;
		}
		else
		{
			ATLASSERT(!bValidate || lstrlen(lpstrText) <= nLength);
			bSuccess = pT->SetDlgItemText(nID, lpstrText);
		}

		if(!bSuccess)
		{
			pT->OnDataExchangeError(nID, bSave);
		}
		else if(bSave && bValidate)	// validation
		{
			ATLASSERT(nLength > 0);
			if(lstrlen(lpstrText) > nLength)
			{
				_XData data;
				data.nDataType = ddxDataText;
				data.textData.nLength = lstrlen(lpstrText);
				data.textData.nMaxLength = nLength;
				pT->OnDataValidateError(nID, bSave, data);
				bSuccess = FALSE;
			}
		}
		return bSuccess;
	}

	BOOL DDX_Text(UINT nID, BSTR& bstrText, int /*nSize*/, BOOL bSave, BOOL bValidate = FALSE, int nLength = 0)
	{
		T* pT = static_cast<T*>(this);
		BOOL bSuccess = TRUE;

		if(bSave)
		{
			bSuccess = pT->GetDlgItemText(nID, bstrText);
		}
		else
		{
			USES_CONVERSION;
			LPTSTR lpstrText = OLE2T(bstrText);
			ATLASSERT(!bValidate || lstrlen(lpstrText) <= nLength);
			bSuccess = pT->SetDlgItemText(nID, lpstrText);
		}

		if(!bSuccess)
		{
			pT->OnDataExchangeError(nID, bSave);
		}
		else if(bSave && bValidate)	// validation
		{
			ATLASSERT(nLength > 0);
			if((int)::SysStringLen(bstrText) > nLength)
			{
				_XData data;
				data.nDataType = ddxDataText;
				data.textData.nLength = (int)::SysStringLen(bstrText);
				data.textData.nMaxLength = nLength;
				pT->OnDataValidateError(nID, bSave, data);
				bSuccess = FALSE;
			}
		}
		return bSuccess;
	}

	BOOL DDX_Text(UINT nID, CComBSTR& bstrText, int /*nSize*/, BOOL bSave, BOOL bValidate = FALSE, int nLength = 0)
	{
		T* pT = static_cast<T*>(this);
		BOOL bSuccess = TRUE;

		if(bSave)
		{
			bSuccess = pT->GetDlgItemText(nID, (BSTR&)bstrText);
		}
		else
		{
			USES_CONVERSION;
			LPTSTR lpstrText = OLE2T(bstrText);
			ATLASSERT(!bValidate || lstrlen(lpstrText) <= nLength);
			bSuccess = pT->SetDlgItemText(nID, lpstrText);
		}

		if(!bSuccess)
		{
			pT->OnDataExchangeError(nID, bSave);
		}
		else if(bSave && bValidate)	// validation
		{
			ATLASSERT(nLength > 0);
			if((int)bstrText.Length() > nLength)
			{
				_XData data;
				data.nDataType = ddxDataText;
				data.textData.nLength = (int)bstrText.Length();
				data.textData.nMaxLength = nLength;
				pT->OnDataValidateError(nID, bSave, data);
				bSuccess = FALSE;
			}
		}
		return bSuccess;
	}

#ifdef __ATLSTR_H__
	BOOL DDX_Text(UINT nID, CString& strText, int /*nSize*/, BOOL bSave, BOOL bValidate = FALSE, int nLength = 0)
	{
		T* pT = static_cast<T*>(this);
		BOOL bSuccess = TRUE;

		if(bSave)
		{
			HWND hWndCtrl = pT->GetDlgItem(nID);
			int nLen = ::GetWindowTextLength(hWndCtrl);
			int nRetLen = ::GetWindowText(hWndCtrl, strText.GetBufferSetLength(nLen), nLen + 1);
			if(nRetLen < nLen)
				bSuccess = FALSE;
			strText.ReleaseBuffer();
		}
		else
		{
			bSuccess = pT->SetDlgItemText(nID, strText);
		}

		if(!bSuccess)
		{
			pT->OnDataExchangeError(nID, bSave);
		}
		else if(bSave && bValidate)	// validation
		{
			ATLASSERT(nLength > 0);
			if(strText.GetLength() > nLength)
			{
				_XData data;
				data.nDataType = ddxDataText;
				data.textData.nLength = strText.GetLength();
				data.textData.nMaxLength = nLength;
				pT->OnDataValidateError(nID, bSave, data);
				bSuccess = FALSE;
			}
		}
		return bSuccess;
	}
#endif //__ATLSTR_H__

// Numeric exchange
	template <class Type>
	BOOL DDX_Int(UINT nID, Type& nVal, BOOL bSigned, BOOL bSave, BOOL bValidate = FALSE, Type nMin = 0, Type nMax = 0)
	{
		T* pT = static_cast<T*>(this);
		BOOL bSuccess = TRUE;

		if(bSave)
		{
			nVal = (Type)pT->GetDlgItemInt(nID, &bSuccess, bSigned);
		}
		else
		{
			ATLASSERT(!bValidate || nVal >= nMin && nVal <= nMax);
			bSuccess = pT->SetDlgItemInt(nID, nVal, bSigned);
		}

		if(!bSuccess)
		{
			pT->OnDataExchangeError(nID, bSave);
		}
		else if(bSave && bValidate)	// validation
		{
			ATLASSERT(nMin != nMax);
			if(nVal < nMin || nVal > nMax)
			{
				_XData data;
				data.nDataType = ddxDataInt;
				data.intData.nVal = (long)nVal;
				data.intData.nMin = (long)nMin;
				data.intData.nMax = (long)nMax;
				pT->OnDataValidateError(nID, bSave, data);
				bSuccess = FALSE;
			}
		}
		return bSuccess;
	}

// Float exchange
#ifdef _ATL_USE_DDX_FLOAT
	static BOOL _AtlSimpleFloatParse(LPCTSTR lpszText, double& d)
	{
		ATLASSERT(lpszText != NULL);
		while (*lpszText == ' ' || *lpszText == '\t')
			lpszText++;

		TCHAR chFirst = lpszText[0];
		d = _tcstod(lpszText, (LPTSTR*)&lpszText);
		if (d == 0.0 && chFirst != '0')
			return FALSE;   // could not convert
		while (*lpszText == ' ' || *lpszText == '\t')
			lpszText++;

		if (*lpszText != '\0')
			return FALSE;   // not terminated properly

		return TRUE;
	}

	BOOL DDX_Float(UINT nID, float& nVal, BOOL bSave, BOOL bValidate = FALSE, float nMin = 0.F, float nMax = 0.F)
	{
		T* pT = static_cast<T*>(this);
		BOOL bSuccess = TRUE;
		TCHAR szBuff[32];

		if(bSave)
		{
			pT->GetDlgItemText(nID, szBuff, sizeof(szBuff) / sizeof(TCHAR));
			double d = 0;
			if(_AtlSimpleFloatParse(szBuff, d))
				nVal = (float)d;
			else
				bSuccess = FALSE;
		}
		else
		{
			ATLASSERT(!bValidate || nVal >= nMin && nVal <= nMax);
			_stprintf(szBuff, _T("%.*g"), FLT_DIG, nVal);
			bSuccess = pT->SetDlgItemText(nID, szBuff);
		}

		if(!bSuccess)
		{
			pT->OnDataExchangeError(nID, bSave);
		}
		else if(bSave && bValidate)	// validation
		{
			ATLASSERT(nMin != nMax);
			if(nVal < nMin || nVal > nMax)
			{
				_XData data;
				data.nDataType = ddxDataFloat;
				data.floatData.nVal = (double)nVal;
				data.floatData.nMin = (double)nMin;
				data.floatData.nMax = (double)nMax;
				pT->OnDataValidateError(nID, bSave, data);
				bSuccess = FALSE;
			}
		}
		return bSuccess;
	}

	BOOL DDX_Float(UINT nID, double& nVal, BOOL bSave, BOOL bValidate = FALSE, double nMin = 0., double nMax = 0.)
	{
		T* pT = static_cast<T*>(this);
		BOOL bSuccess = TRUE;
		TCHAR szBuff[32];

		if(bSave)
		{
			pT->GetDlgItemText(nID, szBuff, sizeof(szBuff) / sizeof(TCHAR));
			double d = 0;
			if(_AtlSimpleFloatParse(szBuff, d))
				nVal = d;
			else
				bSuccess = FALSE;
		}
		else
		{
			ATLASSERT(!bValidate || nVal >= nMin && nVal <= nMax);
			_stprintf(szBuff, _T("%.*g"), DBL_DIG, nVal);
			bSuccess = pT->SetDlgItemText(nID, szBuff);
		}

		if(!bSuccess)
		{
			pT->OnDataExchangeError(nID, bSave);
		}
		else if(bSave && bValidate)	// validation
		{
			ATLASSERT(nMin != nMax);
			if(nVal < nMin || nVal > nMax)
			{
				_XData data;
				data.nDataType = ddxDataFloat;
				data.floatData.nVal = nVal;
				data.floatData.nMin = nMin;
				data.floatData.nMax = nMax;
				pT->OnDataValidateError(nID, bSave, data);
				bSuccess = FALSE;
			}
		}
		return bSuccess;
	}
#endif //_ATL_USE_DDX_FLOAT

// Control subclassing
	template <class TControl>
	void DDX_Control(UINT nID, TControl& ctrl, BOOL bSave)
	{
		T* pT = static_cast<T*>(this);
		if(!bSave && ctrl.m_hWnd == NULL)
			ctrl.SubclassWindow(pT->GetDlgItem(nID));
	}

// Control state
	void DDX_Check(UINT nID, int& nValue, BOOL bSave)
	{
		T* pT = static_cast<T*>(this);
		HWND hWndCtrl = pT->GetDlgItem(nID);
		if(bSave)
		{
			nValue = (int)::SendMessage(hWndCtrl, BM_GETCHECK, 0, 0L);
			ATLASSERT(nValue >= 0 && nValue <= 2);
		}
		else
		{
			if(nValue < 0 || nValue > 2)
			{
				ATLTRACE2(atlTraceUI, 0, "ATL: Warning - dialog data checkbox value (%d) out of range.\n", nValue);
				nValue = 0;  // default to off
			}
			::SendMessage(hWndCtrl, BM_SETCHECK, nValue, 0L);
		}
	}

	void DDX_Radio(UINT nID, int& nValue, BOOL bSave)
	{
		T* pT = static_cast<T*>(this);
		HWND hWndCtrl = pT->GetDlgItem(nID);
		ATLASSERT(hWndCtrl != NULL);

		// must be first in a group of auto radio buttons
		ATLASSERT(::GetWindowLong(hWndCtrl, GWL_STYLE) & WS_GROUP);
		ATLASSERT(::SendMessage(hWndCtrl, WM_GETDLGCODE, 0, 0L) & DLGC_RADIOBUTTON);

		if(bSave)
			nValue = -1;     // value if none found

		// walk all children in group
		int nButton = 0;
		do
		{
			if(::SendMessage(hWndCtrl, WM_GETDLGCODE, 0, 0L) & DLGC_RADIOBUTTON)
			{
				// control in group is a radio button
				if(bSave)
				{
					if(::SendMessage(hWndCtrl, BM_GETCHECK, 0, 0L) != 0)
					{
						ATLASSERT(nValue == -1);    // only set once
						nValue = nButton;
					}
				}
				else
				{
					// select button
					::SendMessage(hWndCtrl, BM_SETCHECK, (nButton == nValue), 0L);
				}
				nButton++;
			}
			else
			{
				ATLTRACE2(atlTraceUI, 0, "ATL: Warning - skipping non-radio button in group.\n");
			}
			hWndCtrl = ::GetWindow(hWndCtrl, GW_HWNDNEXT);
		}
		while (hWndCtrl != NULL && !(GetWindowLong(hWndCtrl, GWL_STYLE) & WS_GROUP));
	}

// Overrideables
	void OnDataExchangeError(UINT nCtrlID, BOOL /*bSave*/)
	{
		// Override to display an error message
		::MessageBeep((UINT)-1);
		T* pT = static_cast<T*>(this);
		::SetFocus(pT->GetDlgItem(nCtrlID));
	}

	void OnDataValidateError(UINT nCtrlID, BOOL /*bSave*/, _XData& /*data*/)
	{
		// Override to display an error message
		::MessageBeep((UINT)-1);
		T* pT = static_cast<T*>(this);
		::SetFocus(pT->GetDlgItem(nCtrlID));
	}
};

}; //namespace WTL

#endif //__ATLDDX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\atlctrlx.h ===
// WTL Version 3.0
// Copyright (C) 1997-1999 Microsoft Corporation
// All rights reserved.
//
// This file is a part of Windows Template Library.
// The code and information is provided "as-is" without
// warranty of any kind, either expressed or implied.

#ifndef __ATLCTRLX_H__
#define __ATLCTRLX_H__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLAPP_H__
	#error atlctrlx.h requires atlapp.h to be included first
#endif

#ifndef __ATLCTRLS_H__
	#error atlctrlx.h requires atlctrls.h to be included first
#endif


namespace WTL
{

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

template <class T, class TBase = CButton, class TWinTraits = CControlWinTraits> class CBitmapButtonImpl;
class CBitmapButton;
template <class T, class TBase = CListViewCtrl, class TWinTraits = CCheckListViewCtrlTraits> class CCheckListViewCtrlImpl;
class CCheckListViewCtrl;
template <class T, class TBase = CWindow, class TWinTraits = CControlWinTraits> class CHyperLinkImpl;
class CHyperLink;
class CWaitCursor;
template <class T, class TBase = CStatusBarCtrl> class CMultiPaneStatusBarCtrlImpl;
class CMultiPaneStatusBarCtrl;


/////////////////////////////////////////////////////////////////////////////
// CBitmapButton - bitmap button implementation

// bitmap button extended styles
#define BMPBTN_HOVER		0x00000001
#define BMPBTN_AUTO3D_SINGLE	0x00000002
#define BMPBTN_AUTO3D_DOUBLE	0x00000004
#define BMPBTN_AUTOSIZE		0x00000008
#define BMPBTN_SHAREIMAGELISTS	0x00000010

template <class T, class TBase = CButton, class TWinTraits = CControlWinTraits>
class ATL_NO_VTABLE CBitmapButtonImpl : public CWindowImpl< T, TBase, TWinTraits>
{
public:
	DECLARE_WND_SUPERCLASS(NULL, TBase::GetWndClassName())

	enum
	{
		_nImageNormal = 0,
		_nImagePushed,
		_nImageFocusOrHover,
		_nImageDisabled,

		_nImageCount = 4
	};

	// Bitmap button specific extended styles
	DWORD m_dwExtendedStyle;

	CImageList m_ImageList;
	int m_nImage[_nImageCount];

	CToolTipCtrl m_tip;
	LPTSTR m_lpstrToolTipText;

	// Internal states
	unsigned m_fMouseOver:1;
	unsigned m_fFocus:1;
	unsigned m_fPressed:1;


// Constructor/Destructor
	CBitmapButtonImpl(DWORD dwExtendedStyle = BMPBTN_AUTOSIZE, HIMAGELIST hImageList = NULL) : 
			m_ImageList(hImageList), m_dwExtendedStyle(dwExtendedStyle), m_lpstrToolTipText(NULL),
			m_fMouseOver(0), m_fFocus(0), m_fPressed(0)
	{
		m_nImage[_nImageNormal] = -1;
		m_nImage[_nImagePushed] = -1;
		m_nImage[_nImageFocusOrHover] = -1;
		m_nImage[_nImageDisabled] = -1;
	}

	~CBitmapButtonImpl()
	{
		if((m_dwExtendedStyle & BMPBTN_SHAREIMAGELISTS) == 0)
			m_ImageList.Destroy();
		delete [] m_lpstrToolTipText;
	}

	// overridden to provide proper initialization
	BOOL SubclassWindow(HWND hWnd)
	{
		BOOL bRet = CWindowImpl< T, TBase, TWinTraits>::SubclassWindow(hWnd);
		if(bRet)
			Init();
		return bRet;
	}

// Attributes
	DWORD GetBitmapButtonExtendedStyle() const
	{
		return m_dwExtendedStyle;
	}
	DWORD SetBitmapButtonExtendedStyle(DWORD dwExtendedStyle)
	{
		DWORD dwPrevStyle = m_dwExtendedStyle;
		m_dwExtendedStyle = dwExtendedStyle;
		return dwPrevStyle;
	}
	HIMAGELIST GetImageList() const
	{
		return m_ImageList;
	}
	HIMAGELIST SetImageList(HIMAGELIST hImageList)
	{
		HIMAGELIST hImageListPrev = m_ImageList;
		m_ImageList = hImageList;
		if((m_dwExtendedStyle & BMPBTN_AUTOSIZE) != 0 && ::IsWindow(m_hWnd))
			SizeToImage();
		return hImageListPrev;
	}
	int GetToolTipTextLength() const
	{
		return (m_lpstrToolTipText == NULL) ? -1 : lstrlen(m_lpstrToolTipText);
	}
	bool GetToolTipText(LPTSTR lpstrText, int nLength) const
	{
		ATLASSERT(lpstrText != NULL);
		if(m_lpstrToolTipText == NULL)
			return false;
		return (lstrcpyn(lpstrText, m_lpstrToolTipText, min(nLength, lstrlen(m_lpstrToolTipText) + 1)) != NULL);
	}
	bool SetToolTipText(LPCTSTR lpstrText)
	{
		if(m_lpstrToolTipText != NULL)
		{
			delete [] m_lpstrToolTipText;
			m_lpstrToolTipText = NULL;
		}
		if(lpstrText == NULL)
		{
			if(m_tip.IsWindow())
				m_tip.Activate(FALSE);
			return true;
		}
		ATLTRY(m_lpstrToolTipText = new TCHAR[lstrlen(lpstrText) + 1]);
		if(m_lpstrToolTipText == NULL)
			return false;
		bool bRet = (lstrcpy(m_lpstrToolTipText, lpstrText) != NULL);
		if(bRet && m_tip.IsWindow())
		{
			m_tip.Activate(TRUE);
			m_tip.AddTool(m_hWnd, m_lpstrToolTipText);
		}
		return bRet;
	}

// Operations
	void SetImages(int nNormal, int nPushed = -1, int nFocusOrHover = -1, int nDisabled = -1)
	{
		if(nNormal != -1)
			m_nImage[_nImageNormal] = nNormal;
		if(nPushed != -1)
			m_nImage[_nImagePushed] = nPushed;
		if(nFocusOrHover != -1)
			m_nImage[_nImageFocusOrHover] = nFocusOrHover;
		if(nDisabled != -1)
			m_nImage[_nImageDisabled] = nDisabled;
	}
	BOOL SizeToImage()
	{
		ATLASSERT(::IsWindow(m_hWnd) && m_ImageList.m_hImageList != NULL);
		int cx = 0;
		int cy = 0;
		if(!m_ImageList.GetIconSize(cx, cy))
			return FALSE;
		return ResizeClient(cx, cy);
	}

// Overrideables
	void DoPaint(CDCHandle dc)
	{
		ATLASSERT(m_ImageList.m_hImageList != NULL);	// image list must be set
		ATLASSERT(m_nImage[0] != -1);			// main bitmap must be set

		// set bitmap according to the current button state
		int nImage = -1;
		bool bHover = IsHoverMode();
		if(m_fPressed == 1)
			nImage = m_nImage[_nImagePushed];
		else if((!bHover && m_fFocus == 1) || (bHover && m_fMouseOver == 1))
			nImage = m_nImage[_nImageFocusOrHover];
		else if(!IsWindowEnabled())
			nImage = m_nImage[_nImageDisabled];
		if(nImage == -1)	// not there, use default one
			nImage = m_nImage[_nImageNormal];

		// draw the button image
		int xyPos = 0;
		if((m_fPressed == 1) && (m_dwExtendedStyle & (BMPBTN_AUTO3D_SINGLE | BMPBTN_AUTO3D_DOUBLE) != 0) && (m_nImage[_nImagePushed] == -1))
			xyPos = 1;
		m_ImageList.Draw(dc, nImage, xyPos, xyPos, ILD_NORMAL);

		// draw 3D border if required
		if((m_dwExtendedStyle & (BMPBTN_AUTO3D_SINGLE | BMPBTN_AUTO3D_DOUBLE)) != 0)
		{
			RECT rect;
			GetClientRect(&rect);

			if(m_fPressed == 1)
				dc.DrawEdge(&rect, ((m_dwExtendedStyle & BMPBTN_AUTO3D_SINGLE) != 0) ? BDR_SUNKENOUTER : EDGE_SUNKEN, BF_RECT);
			else if(!bHover || m_fMouseOver == 1)
				dc.DrawEdge(&rect, ((m_dwExtendedStyle & BMPBTN_AUTO3D_SINGLE) != 0) ? BDR_RAISEDINNER : EDGE_RAISED, BF_RECT);

			if(!bHover && m_fFocus == 1)
			{
				::InflateRect(&rect, -2 * ::GetSystemMetrics(SM_CXEDGE), -2 * ::GetSystemMetrics(SM_CYEDGE));
				dc.DrawFocusRect(&rect);
			}
		}
	}

// Message map and handlers
	typedef CBitmapButtonImpl< T, TBase, TWinTraits >	thisClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_CREATE, OnCreate)
		MESSAGE_RANGE_HANDLER(WM_MOUSEFIRST, WM_MOUSELAST, OnMouseMessage)
		MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBackground)
		MESSAGE_HANDLER(WM_PAINT, OnPaint)
		MESSAGE_HANDLER(WM_PRINTCLIENT, OnPaint)
		MESSAGE_HANDLER(WM_SETFOCUS, OnFocus)
		MESSAGE_HANDLER(WM_KILLFOCUS, OnFocus)
		MESSAGE_HANDLER(WM_LBUTTONDOWN, OnLButtonDown)
		MESSAGE_HANDLER(WM_LBUTTONDBLCLK, OnLButtonDblClk)
		MESSAGE_HANDLER(WM_LBUTTONUP, OnLButtonUp)
		MESSAGE_HANDLER(WM_CAPTURECHANGED, OnCaptureChanged)
		MESSAGE_HANDLER(WM_ENABLE, OnEnable)
		MESSAGE_HANDLER(WM_MOUSEMOVE, OnMouseMove)
		MESSAGE_HANDLER(WM_MOUSELEAVE, OnMouseLeave)
		MESSAGE_HANDLER(WM_KEYDOWN, OnKeyDown)
		MESSAGE_HANDLER(WM_KEYUP, OnKeyUp)
	END_MSG_MAP()

	LRESULT OnCreate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		Init();
		bHandled = FALSE;
		return 1;
	}

	LRESULT OnMouseMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		MSG msg = { m_hWnd, uMsg, wParam, lParam };
		if(m_tip.IsWindow())
			m_tip.RelayEvent(&msg);
		bHandled = FALSE;
		return 1;
	}

	LRESULT OnEraseBackground(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		return 1;	// no background needed
	}

	LRESULT OnPaint(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		if(wParam != NULL)
		{
			pT->DoPaint((HDC)wParam);
		}
		else
		{
			CPaintDC dc(m_hWnd);
			pT->DoPaint(dc.m_hDC);
		}
		return 0;
	}

	LRESULT OnFocus(UINT uMsg, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		m_fFocus = (uMsg == WM_SETFOCUS) ? 1 : 0;
		Invalidate();
		UpdateWindow();
		bHandled = FALSE;
		return 1;
	}

	LRESULT OnLButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
	{
		LRESULT lRet = DefWindowProc(uMsg, wParam, lParam);
		if(::GetCapture() == m_hWnd)
		{
			m_fPressed = 1;
			Invalidate();
			UpdateWindow();
		}
		return lRet;
	}

	LRESULT OnLButtonDblClk(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
	{
		LRESULT lRet = DefWindowProc(uMsg, wParam, lParam);
		if(::GetCapture() != m_hWnd)
			SetCapture();
		if(m_fPressed == 0)
		{
			m_fPressed = 1;
			Invalidate();
			UpdateWindow();
		}
		return lRet;
	}

	LRESULT OnLButtonUp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
	{
		LRESULT lRet = DefWindowProc(uMsg, wParam, lParam);
		if(::GetCapture() == m_hWnd)
			::ReleaseCapture();
		return lRet;
	}

	LRESULT OnCaptureChanged(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		if(m_fPressed == 1)
		{
			m_fPressed = 0;
			Invalidate();
			UpdateWindow();
		}
		bHandled = FALSE;
		return 1;
	}

	LRESULT OnEnable(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		Invalidate();
		UpdateWindow();
		bHandled = FALSE;
		return 1;
	}

	LRESULT OnMouseMove(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
	{
		if(::GetCapture() == m_hWnd)
		{
			POINT ptCursor = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
			ClientToScreen(&ptCursor);
			RECT rect;
			GetWindowRect(&rect);
			unsigned int uPressed = ::PtInRect(&rect, ptCursor) ? 1 : 0;
			if(m_fPressed != uPressed)
			{
				m_fPressed = uPressed;
				Invalidate();
				UpdateWindow();
			}
		}
		else if(IsHoverMode() && m_fMouseOver == 0)
		{
			m_fMouseOver = 1;
			Invalidate();
			UpdateWindow();
			StartTrackMouseLeave();
		}
		bHandled = FALSE;
		return 1;
	}

	LRESULT OnMouseLeave(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		if(m_fMouseOver == 1)
		{
			m_fMouseOver = 0;
			Invalidate();
			UpdateWindow();
		}
		return 0;
	}

	LRESULT OnKeyDown(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
		if(wParam == VK_SPACE && IsHoverMode())
			return 0;	// ignore if in hover mode
		if(wParam == VK_SPACE && m_fPressed == 0)
		{
			m_fPressed = 1;
			Invalidate();
			UpdateWindow();
		}
		bHandled = FALSE;
		return 1;
	}

	LRESULT OnKeyUp(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
		if(wParam == VK_SPACE && IsHoverMode())
			return 0;	// ignore if in hover mode
		if(wParam == VK_SPACE && m_fPressed == 1)
		{
			m_fPressed = 0;
			Invalidate();
			UpdateWindow();
		}
		bHandled = FALSE;
		return 1;
	}

// Implementation
	void Init()
	{
		// We need this style to prevent Windows from painting the button
		ModifyStyle(0, BS_OWNERDRAW);

		// create a tool tip
		m_tip.Create(m_hWnd);
		ATLASSERT(m_tip.IsWindow());
		if(m_tip.IsWindow() && m_lpstrToolTipText != NULL)
		{
			m_tip.Activate(TRUE);
			m_tip.AddTool(m_hWnd, m_lpstrToolTipText);
		}

		if(m_ImageList.m_hImageList != NULL && (m_dwExtendedStyle & BMPBTN_AUTOSIZE) != 0)
			SizeToImage();
	}

	BOOL StartTrackMouseLeave()
	{
		TRACKMOUSEEVENT tme;
		tme.cbSize = sizeof(tme);
		tme.dwFlags = TME_LEAVE;
		tme.hwndTrack = m_hWnd;
		return _TrackMouseEvent(&tme);
	}

	bool IsHoverMode() const
	{
		return ((m_dwExtendedStyle & BMPBTN_HOVER) != 0);
	}
};


class CBitmapButton : public CBitmapButtonImpl<CBitmapButton>
{
public:
	DECLARE_WND_SUPERCLASS(_T("WTL_BitmapButton"), GetWndClassName())

	CBitmapButton(DWORD dwExtendedStyle = BMPBTN_AUTOSIZE, HIMAGELIST hImageList = NULL) : 
		CBitmapButtonImpl<CBitmapButton>(dwExtendedStyle, hImageList)
	{ }
};


/////////////////////////////////////////////////////////////////////////////
// CCheckListCtrlView - list view control with check boxes

template <DWORD t_dwStyle, DWORD t_dwExStyle, DWORD t_dwExListViewStyle>
class CCheckListViewCtrlImplTraits
{
public:
	static DWORD GetWndStyle(DWORD dwStyle)
	{
		return dwStyle == 0 ? t_dwStyle : dwStyle;
	}
	static DWORD GetWndExStyle(DWORD dwExStyle)
	{
		return dwExStyle == 0 ? t_dwExStyle : dwExStyle;
	}
	static DWORD GetExtendedLVStyle()
	{
		return t_dwExListViewStyle;
	}
};

typedef CCheckListViewCtrlImplTraits<WS_CHILD | WS_VISIBLE | LVS_REPORT | LVS_SHOWSELALWAYS, WS_EX_CLIENTEDGE, LVS_EX_CHECKBOXES | LVS_EX_FULLROWSELECT>	CCheckListViewCtrlTraits;

template <class T, class TBase = CListViewCtrl, class TWinTraits = CCheckListViewCtrlTraits>
class ATL_NO_VTABLE CCheckListViewCtrlImpl : public CWindowImpl<T, TBase, TWinTraits>
{
public:
	DECLARE_WND_SUPERCLASS(NULL, TBase::GetWndClassName())

// Attributes
	static DWORD GetExtendedLVStyle()
	{
		return TWinTraits::GetExtendedLVStyle();
	}

// Operations
	BOOL SubclassWindow(HWND hWnd)
	{
		BOOL bRet = CWindowImplBaseT< TBase, TWinTraits>::SubclassWindow(hWnd);
		if(bRet)
		{
			T* pT = static_cast<T*>(this);
			pT;
			ATLASSERT((pT->GetExtendedLVStyle() & LVS_EX_CHECKBOXES) != 0);
			SetExtendedListViewStyle(pT->GetExtendedLVStyle());
		}
		return bRet;
	}

	void CheckSelectedItems(int nCurrItem)
	{
		// first check if this item is selected
		LVITEM lvi;
		lvi.iItem = nCurrItem;
		lvi.iSubItem = 0;
		lvi.mask = LVIF_STATE;
		lvi.stateMask = LVIS_SELECTED;
		GetItem(&lvi);
		// if item is not selected, don't do anything
		if(!(lvi.state & LVIS_SELECTED))
			return;
		// new check state will be reverse of the current state,
		BOOL bCheck = !GetCheckState(nCurrItem);
		int nItem = -1;
		int nOldItem = -1;
		while((nItem = GetNextItem(nOldItem, LVNI_SELECTED)) != -1)
		{
			if(nItem != nCurrItem)
				SetCheckState(nItem, bCheck);
			nOldItem = nItem;
		}
	}

// Implementation
	typedef CCheckListViewCtrlImpl< T, TBase, TWinTraits >	thisClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_CREATE, OnCreate)
		MESSAGE_HANDLER(WM_LBUTTONDOWN, OnLButtonDown)
		MESSAGE_HANDLER(WM_LBUTTONDBLCLK, OnLButtonDown)
		MESSAGE_HANDLER(WM_KEYDOWN, OnKeyDown)
	END_MSG_MAP()

	LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
	{
		// first let list view control initialize everything
		LRESULT lRet = DefWindowProc(uMsg, wParam, lParam);
		T* pT = static_cast<T*>(this);
		pT;
		ATLASSERT((pT->GetExtendedLVStyle() & LVS_EX_CHECKBOXES) != 0);
		SetExtendedListViewStyle(pT->GetExtendedLVStyle());
		return lRet;
	}

	LRESULT OnLButtonDown(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
	{
		POINT ptMsg = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
		LVHITTESTINFO lvh;
		lvh.pt = ptMsg;
		if(HitTest(&lvh) != -1 && lvh.flags == LVHT_ONITEMSTATEICON && ::GetKeyState(VK_CONTROL) >= 0)
			CheckSelectedItems(lvh.iItem);
		bHandled = FALSE;
		return 1;
	}

	LRESULT OnKeyDown(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
		if(wParam == VK_SPACE)
		{
			int nCurrItem = GetNextItem(-1, LVNI_FOCUSED);
			if(nCurrItem != -1  && ::GetKeyState(VK_CONTROL) >= 0)
				CheckSelectedItems(nCurrItem);
		}
		bHandled = FALSE;
		return 1;
	}
};

class CCheckListViewCtrl : public CCheckListViewCtrlImpl<CCheckListViewCtrl>
{
public:
	DECLARE_WND_SUPERCLASS(_T("WTL_CheckListView"), GetWndClassName())
};


/////////////////////////////////////////////////////////////////////////////
// CHyperLink - hyper link control implementation

#if (WINVER < 0x0500)
__declspec(selectany) struct
{
	enum { cxWidth = 32, cyHeight = 32 };
	int xHotSpot;
	int yHotSpot;
	unsigned char arrANDPlane[cxWidth * cyHeight / 8];
	unsigned char arrXORPlane[cxWidth * cyHeight / 8];
} _AtlHyperLink_CursorData = 
{
	5, 0, 
	{
		0xF9, 0xFF, 0xFF, 0xFF, 0xF0, 0xFF, 0xFF, 0xFF, 0xF0, 0xFF, 0xFF, 0xFF, 0xF0, 0xFF, 0xFF, 0xFF, 
		0xF0, 0xFF, 0xFF, 0xFF, 0xF0, 0x3F, 0xFF, 0xFF, 0xF0, 0x07, 0xFF, 0xFF, 0xF0, 0x01, 0xFF, 0xFF, 
		0xF0, 0x00, 0xFF, 0xFF, 0x10, 0x00, 0x7F, 0xFF, 0x00, 0x00, 0x7F, 0xFF, 0x00, 0x00, 0x7F, 0xFF, 
		0x80, 0x00, 0x7F, 0xFF, 0xC0, 0x00, 0x7F, 0xFF, 0xC0, 0x00, 0x7F, 0xFF, 0xE0, 0x00, 0x7F, 0xFF, 
		0xE0, 0x00, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xF8, 0x01, 0xFF, 0xFF, 
		0xF8, 0x01, 0xFF, 0xFF, 0xF8, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
	},
	{
		0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
		0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0xC0, 0x00, 0x00, 0x06, 0xD8, 0x00, 0x00, 
		0x06, 0xDA, 0x00, 0x00, 0x06, 0xDB, 0x00, 0x00, 0x67, 0xFB, 0x00, 0x00, 0x77, 0xFF, 0x00, 0x00, 
		0x37, 0xFF, 0x00, 0x00, 0x17, 0xFF, 0x00, 0x00, 0x1F, 0xFF, 0x00, 0x00, 0x0F, 0xFF, 0x00, 0x00, 
		0x0F, 0xFE, 0x00, 0x00, 0x07, 0xFE, 0x00, 0x00, 0x07, 0xFE, 0x00, 0x00, 0x03, 0xFC, 0x00, 0x00, 
		0x03, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	}
};
#endif //(WINVER < 0x0500)


template <class T, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class ATL_NO_VTABLE CHyperLinkImpl : public CWindowImpl< T, TBase, TWinTraits >
{
public:
	LPTSTR m_lpstrLabel;
	LPTSTR m_lpstrHyperLink;
	HCURSOR m_hCursor;
	HFONT m_hFont;
	RECT m_rcLink;
	bool m_bPaintLabel;
	CToolTipCtrl m_tip;

	bool m_bVisited;
	COLORREF m_clrLink;
	COLORREF m_clrVisited;


// Constructor/Destructor
	CHyperLinkImpl() : m_lpstrLabel(NULL), m_lpstrHyperLink(NULL),
			m_hCursor(NULL), m_hFont(NULL), m_bPaintLabel(true), m_bVisited(false),
			m_clrLink(RGB(0, 0, 255)), m_clrVisited(RGB(128, 0, 128))
	{
		::SetRectEmpty(&m_rcLink);
	}

	~CHyperLinkImpl()
	{
		free(m_lpstrLabel);
		free(m_lpstrHyperLink);
		if(m_hFont != NULL)
			::DeleteObject(m_hFont);
#if (WINVER < 0x0500)
		// It was created, not loaded, so we have to destroy it
		if(m_hCursor != NULL)
			::DestroyCursor(m_hCursor);
#endif //(WINVER < 0x0500)
	}

// Attributes
	bool GetLabel(LPTSTR lpstrBuffer, int nLength) const
	{
		if(m_lpstrLabel == NULL)
			return false;
		ATLASSERT(lpstrBuffer != NULL);
		if(nLength > lstrlen(m_lpstrLabel) + 1)
		{
			lstrcpy(lpstrBuffer, m_lpstrLabel);
			return true;
		}
		return false;
	}

	bool SetLabel(LPCTSTR lpstrLabel)
	{
		free(m_lpstrLabel);
		m_lpstrLabel = NULL;
		ATLTRY(m_lpstrLabel = (LPTSTR)malloc((lstrlen(lpstrLabel) + 1) * sizeof(TCHAR)));
		if(m_lpstrLabel == NULL)
			return false;
		lstrcpy(m_lpstrLabel, lpstrLabel);
		CalcLabelRect();
		return true;
	}

	bool GetHyperLink(LPTSTR lpstrBuffer, int nLength) const
	{
		if(m_lpstrHyperLink == NULL)
			return false;
		ATLASSERT(lpstrBuffer != NULL);
		if(nLength > lstrlen(m_lpstrHyperLink) + 1)
		{
			lstrcpy(lpstrBuffer, m_lpstrHyperLink);
			return true;
		}
		return false;
	}

	bool SetHyperLink(LPCTSTR lpstrLink)
	{
		free(m_lpstrHyperLink);
		m_lpstrHyperLink = NULL;
		ATLTRY(m_lpstrHyperLink = (LPTSTR)malloc((lstrlen(lpstrLink) + 1) * sizeof(TCHAR)));
		if(m_lpstrHyperLink == NULL)
			return false;
		lstrcpy(m_lpstrHyperLink, lpstrLink);
		if(m_lpstrLabel == NULL)
			CalcLabelRect();
		return true;
	}

// Operations
	BOOL SubclassWindow(HWND hWnd)
	{
		ATLASSERT(m_hWnd == NULL);
		ATLASSERT(::IsWindow(hWnd));
		BOOL bRet = CWindowImpl< T, TBase, TWinTraits >::SubclassWindow(hWnd);
		if(bRet)
			Init();
		return bRet;
	}

	bool Navigate()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(m_lpstrHyperLink != NULL);
		DWORD_PTR dwRet = (DWORD_PTR)::ShellExecute(0, _T("open"), m_lpstrHyperLink, 0, 0, SW_SHOWNORMAL);
		if(dwRet > 32)
		{
			m_bVisited = true;
			Invalidate();
		}
		return (dwRet > 32);
	}

// Message map and handlers
	BEGIN_MSG_MAP(CHyperLinkImpl)
		MESSAGE_HANDLER(WM_CREATE, OnCreate)
		MESSAGE_RANGE_HANDLER(WM_MOUSEFIRST, WM_MOUSELAST, OnMouseMessage)
		MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBackground)
		MESSAGE_HANDLER(WM_PAINT, OnPaint)
		MESSAGE_HANDLER(WM_PRINTCLIENT, OnPaint)
		MESSAGE_HANDLER(WM_SETFOCUS, OnFocus)
		MESSAGE_HANDLER(WM_KILLFOCUS, OnFocus)
		MESSAGE_HANDLER(WM_MOUSEMOVE, OnMouseMove)
		MESSAGE_HANDLER(WM_LBUTTONDOWN, OnLButtonDown)
		MESSAGE_HANDLER(WM_LBUTTONUP, OnLButtonUp)
		MESSAGE_HANDLER(WM_CHAR, OnChar)
		MESSAGE_HANDLER(WM_GETDLGCODE, OnGetDlgCode)
		MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor)
	END_MSG_MAP()

	LRESULT OnCreate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		Init();
		return 0;
	}

	LRESULT OnEraseBackground(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
		if(m_bPaintLabel)
		{
			HBRUSH hBrush = (HBRUSH)::SendMessage(GetParent(), WM_CTLCOLORSTATIC, wParam, (LPARAM)m_hWnd);
			if(hBrush != NULL)
			{
				CDCHandle dc = (HDC)wParam;
				RECT rect;
				GetClientRect(&rect);
				dc.FillRect(&rect, hBrush);
			}
		}
		else
		{
			bHandled = FALSE;
		}
		return 1;
	}

	LRESULT OnPaint(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
		if(!m_bPaintLabel)
		{
			bHandled = FALSE;
			return 1;
		}

		T* pT = static_cast<T*>(this);
		if(wParam != NULL)
		{
			pT->DoPaint((HDC)wParam);
		}
		else
		{
			CPaintDC dc(m_hWnd);
			pT->DoPaint(dc.m_hDC);
		}

		return 0;
	}

	LRESULT OnFocus(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		if(m_bPaintLabel)
			Invalidate();
		else
			bHandled = FALSE;
		return 0;
	}

	LRESULT OnMouseMove(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
	{
		POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
		if(m_lpstrHyperLink != NULL && ::PtInRect(&m_rcLink, pt))
			::SetCursor(m_hCursor);
		else
			bHandled = FALSE;
		return 0;
	}

	LRESULT OnLButtonDown(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& /*bHandled*/)
	{
		POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
		if(::PtInRect(&m_rcLink, pt))
		{
			SetFocus();
			SetCapture();
		}
		return 0;
	}

	LRESULT OnLButtonUp(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& /*bHandled*/)
	{
		if(GetCapture() == m_hWnd)
		{
			ReleaseCapture();
			POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
			if(::PtInRect(&m_rcLink, pt))
				Navigate();
		}
		return 0;
	}

	LRESULT OnSetCursor(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		POINT pt;
		GetCursorPos(&pt);
		ScreenToClient(&pt);
		if(m_lpstrHyperLink != NULL && ::PtInRect(&m_rcLink, pt))
		{
			return TRUE;
		}
		bHandled = FALSE;
		return FALSE;
	}

	LRESULT OnChar(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		if(wParam == VK_RETURN || wParam == VK_SPACE)
			Navigate();
		return 0;
	}

	LRESULT OnGetDlgCode(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		return DLGC_WANTCHARS;
	}

	LRESULT OnMouseMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		MSG msg = { m_hWnd, uMsg, wParam, lParam };
		if(m_tip.IsWindow())
			m_tip.RelayEvent(&msg);
		bHandled = FALSE;
		return 1;
	}

// Implementation
	void Init()
	{
		ATLASSERT(::IsWindow(m_hWnd));

		// Check if we should paint a label
		TCHAR lpszBuffer[8];
		if(::GetClassName(m_hWnd, lpszBuffer, 8))
		{
			if(lstrcmpi(lpszBuffer, _T("static")) == 0)
			{
				ModifyStyle(0, SS_NOTIFY);	// we need this
				DWORD dwStyle = GetStyle() & 0x000000FF;
				if(dwStyle == SS_ICON || dwStyle == SS_BLACKRECT || dwStyle == SS_GRAYRECT || 
						dwStyle == SS_WHITERECT || dwStyle == SS_BLACKFRAME || dwStyle == SS_GRAYFRAME || 
						dwStyle == SS_WHITEFRAME || dwStyle == SS_OWNERDRAW || 
						dwStyle == SS_BITMAP || dwStyle == SS_ENHMETAFILE)
					m_bPaintLabel = false;
			}
		}

		// create or load a cursor
#if (WINVER >= 0x0500)
		m_hCursor = ::LoadCursor(NULL, IDC_HAND);
#else
		m_hCursor = ::CreateCursor(_Module.GetModuleInstance(), _AtlHyperLink_CursorData.xHotSpot, _AtlHyperLink_CursorData.yHotSpot, _AtlHyperLink_CursorData.cxWidth, _AtlHyperLink_CursorData.cyHeight, _AtlHyperLink_CursorData.arrANDPlane, _AtlHyperLink_CursorData.arrXORPlane);
#endif //!(WINVER >= 0x0500)
		ATLASSERT(m_hCursor != NULL);

		// set font
		if(m_bPaintLabel)
		{
			CWindow wnd = GetParent();
			CFontHandle font = wnd.GetFont();
			if(font.m_hFont != NULL)
			{
				LOGFONT lf;
				font.GetLogFont(&lf);
				lf.lfUnderline = TRUE;
				m_hFont = ::CreateFontIndirect(&lf);
			}
		}

		// set label (defaults to window text)
		if(m_lpstrLabel == NULL)
		{
			int nLen = GetWindowTextLength();
			if(nLen > 0)
			{
				LPTSTR lpszText = (LPTSTR)_alloca((nLen+1)*sizeof(TCHAR));
				if(GetWindowText(lpszText, nLen+1))
					SetLabel(lpszText);
			}
		}

		// set hyperlink (defaults to label)
		if(m_lpstrHyperLink == NULL && m_lpstrLabel != NULL)
			SetHyperLink(m_lpstrLabel);

		CalcLabelRect();

		// create a tool tip
		m_tip.Create(m_hWnd);
		ATLASSERT(m_tip.IsWindow());
		m_tip.Activate(TRUE);
		m_tip.AddTool(m_hWnd, m_lpstrHyperLink);

		// set link colors
		if(m_bPaintLabel)
		{
			CRegKey rk;
			LONG lRet = rk.Open(HKEY_CURRENT_USER, _T("Software\\Microsoft\\Internet Explorer\\Settings"));
			if(lRet == 0)
			{
				TCHAR szBuff[12];
				DWORD dwCount = 12 * sizeof(TCHAR);
				lRet = rk.QueryValue(szBuff, _T("Anchor Color"), &dwCount);
				if(lRet == 0)
				{
					COLORREF clr = _ParseColorString(szBuff);
					ATLASSERT(clr != CLR_INVALID);
					if(clr != CLR_INVALID)
						m_clrLink = clr;
				}

				dwCount = 12 * sizeof(TCHAR);
				lRet = rk.QueryValue(szBuff, _T("Anchor Color Visited"), &dwCount);
				if(lRet == 0)
				{
					COLORREF clr = _ParseColorString(szBuff);
					ATLASSERT(clr != CLR_INVALID);
					if(clr != CLR_INVALID)
						m_clrVisited = clr;
				}
			}
		}
	}

	static COLORREF _ParseColorString(LPTSTR lpstr)
	{
		int c[3] = { -1, -1, -1 };
		LPTSTR p;
		for(int i = 0; i < 2; i++)
		{
			for(p = lpstr; *p != _T('\0'); p = ::CharNext(p))
			{
				if(*p == _T(','))
				{
					*p = _T('\0');
					c[i] = _ttoi(lpstr);
					lpstr = &p[1];
					break;
				}
			}
			if(c[i] == -1)
				return CLR_INVALID;
		}
		if(*lpstr == _T('\0'))
			return CLR_INVALID;
		c[2] = _ttoi(lpstr);

		return RGB(c[0], c[1], c[2]);
	}

	bool CalcLabelRect()
	{
		if(!::IsWindow(m_hWnd))
			return false;
		if(m_lpstrLabel == NULL && m_lpstrHyperLink == NULL)
			return false;

		CClientDC dc(m_hWnd);
		RECT rect;
		GetClientRect(&rect);
		m_rcLink = rect;
		if(m_bPaintLabel)
		{
			HFONT hOldFont = NULL;
			if(m_hFont != NULL)
				hOldFont = dc.SelectFont(m_hFont);
			LPTSTR lpstrText = (m_lpstrLabel != NULL) ? m_lpstrLabel : m_lpstrHyperLink;
			DWORD dwStyle = GetStyle();
			int nDrawStyle = DT_LEFT;
			if (dwStyle & SS_CENTER)
				nDrawStyle = DT_CENTER;
			else if (dwStyle & SS_RIGHT)
				nDrawStyle = DT_RIGHT;
			dc.DrawText(lpstrText, -1, &m_rcLink, nDrawStyle | DT_WORDBREAK | DT_CALCRECT);
			if(m_hFont != NULL)
				dc.SelectFont(hOldFont);
		}

		return true;
	}

	void DoPaint(CDCHandle dc)
	{
		dc.SetBkMode(TRANSPARENT);
		dc.SetTextColor(m_bVisited ? m_clrVisited : m_clrLink);
		if(m_hFont != NULL)
			dc.SelectFont(m_hFont);
		LPTSTR lpstrText = (m_lpstrLabel != NULL) ? m_lpstrLabel : m_lpstrHyperLink;
		DWORD dwStyle = GetStyle();
		int nDrawStyle = DT_LEFT;
		if (dwStyle & SS_CENTER)
			nDrawStyle = DT_CENTER;
		else if (dwStyle & SS_RIGHT)
			nDrawStyle = DT_RIGHT;
		dc.DrawText(lpstrText, -1, &m_rcLink, nDrawStyle | DT_WORDBREAK);
		if(GetFocus() == m_hWnd)
			dc.DrawFocusRect(&m_rcLink);
	}
};


class CHyperLink : public CHyperLinkImpl<CHyperLink>
{
public:
	DECLARE_WND_CLASS(_T("WTL_HyperLink"))
};


/////////////////////////////////////////////////////////////////////////////
// CWaitCursor - displays a wait cursor

class CWaitCursor
{
public:
// Data
	HCURSOR m_hWaitCursor;
	HCURSOR m_hOldCursor;
	bool m_bInUse;

// Constructor/destructor
	CWaitCursor(bool bSet = true, LPCTSTR lpstrCursor = IDC_WAIT, bool bSys = true) : m_hOldCursor(NULL), m_bInUse(false)
	{
		HINSTANCE hInstance = bSys ? NULL : _Module.GetResourceInstance();
		m_hWaitCursor = ::LoadCursor(hInstance, lpstrCursor);
		ATLASSERT(m_hWaitCursor != NULL);

		if(bSet)
			Set();
	}

	~CWaitCursor()
	{
		Restore();
	}

// Methods
	bool Set()
	{
		if(m_bInUse)
			return false;
		m_hOldCursor = ::SetCursor(m_hWaitCursor);
		m_bInUse = true;
		return true;
	}

	bool Restore()
	{
		if(!m_bInUse)
			return false;
		::SetCursor(m_hOldCursor);
		m_bInUse = false;
		return true;
	}
};


/////////////////////////////////////////////////////////////////////////////
// CMultiPaneStatusBarCtrl - Status Bar with multiple panes

#define ID_DEFAULT_PANE		0       // default status bar pane

template <class T, class TBase = CStatusBarCtrl>
class ATL_NO_VTABLE CMultiPaneStatusBarCtrlImpl : public CWindowImpl< T, TBase >
{
public:
	DECLARE_WND_SUPERCLASS(NULL, TBase::GetWndClassName())

// Data
	enum { m_cxPaneMargin = 3 };

	int m_nPanes;
	int* m_pPane;

// Constructor/destructor
	CMultiPaneStatusBarCtrlImpl() : m_nPanes(0), m_pPane(NULL)
	{ }

	~CMultiPaneStatusBarCtrlImpl()
	{
		delete [] m_pPane;
	}

// Methods
	HWND Create(HWND hWndParent, LPCTSTR lpstrText, DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | SBARS_SIZEGRIP, UINT nID = ATL_IDW_STATUS_BAR)
	{
		return CWindowImpl< T, TBase >::Create(hWndParent, rcDefault, lpstrText, dwStyle, 0, nID);
	}

	HWND Create(HWND hWndParent, UINT nTextID = ATL_IDS_IDLEMESSAGE, DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | SBARS_SIZEGRIP, UINT nID = ATL_IDW_STATUS_BAR)
	{
		TCHAR szText[128];	// max text lentgth is 127 for status bars
		szText[0] = 0;
		::LoadString(_Module.GetResourceInstance(), nTextID, szText, 127);
		return Create(hWndParent, szText, dwStyle, nID);
	}

	BOOL SetPanes(int* pPanes, int nPanes, bool bSetText = true)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(nPanes > 0);

		m_nPanes = nPanes;
		delete [] m_pPane;
		m_pPane = NULL;

		ATLTRY(m_pPane = new int[nPanes]);
		ATLASSERT(m_pPane != NULL);
		if(m_pPane == NULL)
			return FALSE;
		memcpy(m_pPane, pPanes, nPanes * sizeof(int));

		int* pPanesPos = NULL;
		ATLTRY(pPanesPos = (int*)_alloca(nPanes * sizeof(int)));
		ATLASSERT(pPanesPos != NULL);

		// get status bar DC and set font
		CClientDC dc(m_hWnd);
		HFONT hOldFont = dc.SelectFont(GetFont());

		// get status bar borders
		int arrBorders[3];
		GetBorders(arrBorders);

		TCHAR szBuff[256];
		SIZE size;
		int cxLeft = arrBorders[0];

		// calculate right edge of each part
		for(int i = 0; i < nPanes; i++)
		{
			if(pPanes[i] == ID_DEFAULT_PANE)
			{
				// will be resized later
				pPanesPos[i] = 100 + cxLeft + arrBorders[2];
			}
			else
			{
				::LoadString(_Module.GetResourceInstance(), pPanes[i], szBuff, sizeof(szBuff) / sizeof(TCHAR));
				dc.GetTextExtent(szBuff, lstrlen(szBuff), &size);
				T* pT = static_cast<T*>(this);
				pT;
				pPanesPos[i] = cxLeft + size.cx + arrBorders[2] + 2 * pT->m_cxPaneMargin;
			}
			cxLeft = pPanesPos[i];
		}

		BOOL bRet = SetParts(nPanes, pPanesPos);

		if(bRet && bSetText)
		{
			for(int i = 0; i < nPanes; i++)
			{
				if(pPanes[i] != ID_DEFAULT_PANE)
				{
					::LoadString(_Module.GetResourceInstance(), pPanes[i], szBuff, sizeof(szBuff) / sizeof(TCHAR));
					SetPaneText(m_pPane[i], szBuff);
				}
			}
		}

		dc.SelectFont(hOldFont);
		return bRet;
	}

	bool GetPaneTextLength(int nPaneID, int* pcchLength = NULL, int* pnType = NULL) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		int nIndex  = GetPaneIndexFromID(nPaneID);
		if(nIndex == -1)
			return false;

		int nLength = GetTextLength(nIndex, pnType);
		if(pcchLength != NULL)
			*pcchLength = nLength;

		return true;
	}

	BOOL GetPaneText(int nPaneID, LPTSTR lpstrText, int* pcchLength = NULL, int* pnType = NULL) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		int nIndex  = GetPaneIndexFromID(nPaneID);
		if(nIndex == -1)
			return FALSE;

		int nLength = GetText(nIndex, lpstrText, pnType);
		if(pcchLength != NULL)
			*pcchLength = nLength;

		return TRUE;
	}

	BOOL SetPaneText(int nPaneID, LPCTSTR lpstrText, int nType = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		int nIndex  = GetPaneIndexFromID(nPaneID);
		if(nIndex == -1)
			return FALSE;

		return SetText(nIndex, lpstrText, nType);
	}

	BOOL GetPaneRect(int nPaneID, LPRECT lpRect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		int nIndex  = GetPaneIndexFromID(nPaneID);
		if(nIndex == -1)
			return FALSE;

		return GetRect(nIndex, lpRect);
	}

	BOOL SetPaneWidth(int nPaneID, int cxWidth)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(nPaneID != ID_DEFAULT_PANE);	// Can't resize this one
		int nIndex  = GetPaneIndexFromID(nPaneID);
		if(nIndex == -1)
			return FALSE;

		// get pane positions
		int* pPanesPos = NULL;
		ATLTRY(pPanesPos = (int*)_alloca(m_nPanes * sizeof(int)));
		GetParts(m_nPanes, pPanesPos);
		// calculate offset
		int cxPaneWidth = pPanesPos[nIndex] - ((nIndex == 0) ? 0 : pPanesPos[nIndex - 1]);
		int cxOff = cxWidth - cxPaneWidth;
		// find variable width pane
		int nDef = m_nPanes;
		for(int i = 0; i < m_nPanes; i++)
		{
			if(m_pPane[i] == ID_DEFAULT_PANE)
			{
				nDef = i;
				break;
			}
		}
		// resize
		if(nIndex < nDef)	// before default pane
		{
			for(int i = nIndex; i < nDef; i++)
				pPanesPos[i] += cxOff;
				
		}
		else			// after default one
		{
			for(int i = nDef; i < nIndex; i++)
				pPanesPos[i] -= cxOff;
		}
		// set pane postions
		return SetParts(m_nPanes, pPanesPos);
	}

#if (_WIN32_IE >= 0x0400)
	BOOL GetPaneTipText(int nPaneID, LPTSTR lpstrText, int nSize) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		int nIndex  = GetPaneIndexFromID(nPaneID);
		if(nIndex == -1)
			return FALSE;

		GetTipText(nPaneID, lpstrText, nSize);
		return TRUE;
	}

	BOOL SetPaneTipText(int nPaneID, LPCTSTR lpstrText)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		int nIndex  = GetPaneIndexFromID(nPaneID);
		if(nIndex == -1)
			return FALSE;

		SetTipText(nIndex, lpstrText);
		return TRUE;
	}

	BOOL GetPaneIcon(int nPaneID, HICON& hIcon) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		int nIndex  = GetPaneIndexFromID(nPaneID);
		if(nIndex == -1)
			return FALSE;

		hIcon = GetIcon(nIndex);
		return TRUE;
	}

	BOOL SetPaneIcon(int nPaneID, HICON hIcon)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		int nIndex  = GetPaneIndexFromID(nPaneID);
		if(nIndex == -1)
			return FALSE;

		return SetIcon(nIndex, hIcon);
	}
#endif //(_WIN32_IE >= 0x0400)

// Message map and handlers
	BEGIN_MSG_MAP(CMultiPaneStatusBarCtrlImpl< T >)
		MESSAGE_HANDLER(WM_SIZE, OnSize)
	END_MSG_MAP()

	LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
	{
		LRESULT lRet = DefWindowProc(uMsg, wParam, lParam);
		if(wParam != SIZE_MINIMIZED && m_nPanes > 0)
		{
			T* pT = static_cast<T*>(this);
			pT->UpdatePanesLayout();
		}
		return lRet;
	}

// Implementation
	BOOL UpdatePanesLayout()
	{
		// get pane positions
		int* pPanesPos = NULL;
		ATLTRY(pPanesPos = (int*)_alloca(m_nPanes * sizeof(int)));
		ATLASSERT(pPanesPos != NULL);
		if(pPanesPos == NULL)
			return FALSE;
		int nRet = GetParts(m_nPanes, pPanesPos);
		ATLASSERT(nRet == m_nPanes);
		if(nRet != m_nPanes)
			return FALSE;
		// calculate offset
		RECT rcClient;
		GetClientRect(&rcClient);
		int cxOff = rcClient.right - (pPanesPos[m_nPanes - 1] + ::GetSystemMetrics(SM_CXVSCROLL) + ::GetSystemMetrics(SM_CXEDGE));
		// find variable width pane
		int i;
		for(i = 0; i < m_nPanes; i++)
		{
			if(m_pPane[i] == ID_DEFAULT_PANE)
				break;
		}
		// resize all panes from the variable one to the right
		if((i < m_nPanes) && (pPanesPos[i] + cxOff) > ((i == 0) ? 0 : pPanesPos[i - 1]))
		{
			for(; i < m_nPanes; i++)
				pPanesPos[i] += cxOff;
		}
		// set pane postions
		return SetParts(m_nPanes, pPanesPos);
	}

	int GetPaneIndexFromID(int nPaneID) const
	{
		for(int i = 0; i < m_nPanes; i++)
		{
			if(m_pPane[i] == nPaneID)
				return i;
		}

		return -1;	// not found
	}
};

class CMultiPaneStatusBarCtrl : public CMultiPaneStatusBarCtrlImpl<CMultiPaneStatusBarCtrl>
{
public:
	DECLARE_WND_SUPERCLASS(_T("WTL_MultiPaneStatusBar"), GetWndClassName())
};

}; //namespace WTL

#endif // __ATLCTRLX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\atldlgs.h ===
// WTL Version 3.0
// Copyright (C) 1997-1999 Microsoft Corporation
// All rights reserved.
//
// This file is a part of Windows Template Library.
// The code and information is provided "as-is" without
// warranty of any kind, either expressed or implied.

#ifndef __ATLDLGS_H__
#define __ATLDLGS_H__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLAPP_H__
	#error atldlgs.h requires atlapp.h to be included first
#endif

#ifndef __ATLWIN_H__
	#error atldlgs.h requires atlwin.h to be included first
#endif

#include <commdlg.h>
#include <shlobj.h>


namespace WTL
{

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

template <class T> class CFileDialogImpl;
class CFileDialog;
template <class T> class CFolderDialogImpl;
class CFolderDialog;
template <class T> class CFontDialogImpl;
class CFontDialog;
#ifdef _RICHEDIT_
template <class T> class CRichEditFontDialogImpl;
class CRichEditFontDialog;
#endif //_RICHEDIT_
template <class T> class CColorDialogImpl;
class CColorDialog;
template <class T> class CPrintDialogImpl;
class CPrintDialog;
template <class T> class CPageSetupDialogImpl;
#if (WINVER >= 0x0500)
template <class T> class CPrintDialogExImpl;
class CPrintDialogEx;
#endif //(WINVER >= 0x0500)
class CPageSetupDialog;
template <class T> class CFindReplaceDialogImpl;
class CFindReplaceDialog;

class CPropertySheetWindow;
template <class T, class TBase = CPropertySheetWindow> class CPropertySheetImpl;
class CPropertySheet;
class CPropertyPageWindow;
template <class T, class TBase = CPropertyPageWindow> class CPropertyPageImpl;
template <WORD t_wDlgTemplateID> class CPropertyPage;

/////////////////////////////////////////////////////////////////////////////
// CFileDialogImpl - used for File Open or File Save As

// compatibility with the old (vc6.0) headers
#if (_WIN32_WINNT >= 0x0500) && !defined(OPENFILENAME_SIZE_VERSION_400)
#ifndef CDSIZEOF_STRUCT
#define CDSIZEOF_STRUCT(structname, member)  (((int)((LPBYTE)(&((structname*)0)->member) - ((LPBYTE)((structname*)0)))) + sizeof(((structname*)0)->member))
#endif
#define OPENFILENAME_SIZE_VERSION_400A  CDSIZEOF_STRUCT(OPENFILENAMEA,lpTemplateName)
#define OPENFILENAME_SIZE_VERSION_400W  CDSIZEOF_STRUCT(OPENFILENAMEW,lpTemplateName)
#ifdef UNICODE
#define OPENFILENAME_SIZE_VERSION_400  OPENFILENAME_SIZE_VERSION_400W
#else
#define OPENFILENAME_SIZE_VERSION_400  OPENFILENAME_SIZE_VERSION_400A
#endif // !UNICODE
#endif // (_WIN32_WINNT >= 0x0500) && !defined(OPENFILENAME_SIZE_VERSION_400)

template <class T>
class ATL_NO_VTABLE CFileDialogImpl : public CDialogImplBase
{
public:
	OPENFILENAME m_ofn;
	BOOL m_bOpenFileDialog;			// TRUE for file open, FALSE for file save
	TCHAR m_szFileTitle[_MAX_FNAME];	// contains file title after return
	TCHAR m_szFileName[_MAX_PATH];		// contains full path name after return

	CFileDialogImpl(BOOL bOpenFileDialog, // TRUE for FileOpen, FALSE for FileSaveAs
			LPCTSTR lpszDefExt = NULL,
			LPCTSTR lpszFileName = NULL,
			DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
			LPCTSTR lpszFilter = NULL,
			HWND hWndParent = NULL)
	{
		memset(&m_ofn, 0, sizeof(m_ofn)); // initialize structure to 0/NULL
		m_szFileName[0] = '\0';
		m_szFileTitle[0] = '\0';

		m_bOpenFileDialog = bOpenFileDialog;

		m_ofn.lStructSize = sizeof(m_ofn);
#if (_WIN32_WINNT >= 0x0500)
		// adjust struct size if running on older version of Windows
		if(AtlIsOldWindows())
		{
			ATLASSERT(sizeof(m_ofn) > OPENFILENAME_SIZE_VERSION_400);	// must be
			m_ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400;
		}
#endif //(_WIN32_WINNT >= 0x0500)
		m_ofn.lpstrFile = m_szFileName;
		m_ofn.nMaxFile = _MAX_PATH;
		m_ofn.lpstrDefExt = lpszDefExt;
		m_ofn.lpstrFileTitle = (LPTSTR)m_szFileTitle;
		m_ofn.nMaxFileTitle = _MAX_FNAME;
		m_ofn.Flags |= dwFlags | OFN_EXPLORER | OFN_ENABLEHOOK | OFN_ENABLESIZING;
		m_ofn.lpstrFilter = lpszFilter;
		m_ofn.hInstance = _Module.GetResourceInstance();
		m_ofn.lpfnHook = (LPOFNHOOKPROC)T::StartDialogProc;
		m_ofn.hwndOwner = hWndParent;

		// setup initial file name
		if(lpszFileName != NULL)
			lstrcpyn(m_szFileName, lpszFileName, _MAX_PATH);
	}

	INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow())
	{
		ATLASSERT(m_ofn.Flags & OFN_ENABLEHOOK);
		ATLASSERT(m_ofn.lpfnHook != NULL);	// can still be a user hook

		ATLASSERT(m_ofn.Flags & OFN_EXPLORER);

		if(m_ofn.hwndOwner == NULL)		// set only if not specified before
			m_ofn.hwndOwner = hWndParent;

		ATLASSERT(m_hWnd == NULL);
		_Module.AddCreateWndData(&m_thunk.cd, (CDialogImplBase*)this);

		BOOL bRet;
		if(m_bOpenFileDialog)
			bRet = ::GetOpenFileName(&m_ofn);
		else
			bRet = ::GetSaveFileName(&m_ofn);

		m_hWnd = NULL;

		return bRet ? IDOK : IDCANCEL;
	}

// Attributes
	CWindow GetFileDialogWindow() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CWindow(GetParent());
	}

	int GetFilePath(LPTSTR lpstrFilePath, int nLength) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(m_ofn.Flags & OFN_EXPLORER);

		return (int)GetFileDialogWindow().SendMessage(CDM_GETFILEPATH, nLength, (LPARAM)lpstrFilePath);
	}

	int GetFolderIDList(LPVOID lpBuff, int nLength) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(m_ofn.Flags & OFN_EXPLORER);

		return (int)GetFileDialogWindow().SendMessage(CDM_GETFOLDERIDLIST, nLength, (LPARAM)lpBuff);
	}

	int GetFolderPath(LPTSTR lpstrFolderPath, int nLength) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(m_ofn.Flags & OFN_EXPLORER);

		return (int)GetFileDialogWindow().SendMessage(CDM_GETFOLDERPATH, nLength, (LPARAM)lpstrFolderPath);
	}

	int GetSpec(LPTSTR lpstrSpec, int nLength) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(m_ofn.Flags & OFN_EXPLORER);

		return (int)GetFileDialogWindow().SendMessage(CDM_GETSPEC, nLength, (LPARAM)lpstrSpec);
	}

	void SetControlText(int nCtrlID, LPCTSTR lpstrText)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(m_ofn.Flags & OFN_EXPLORER);

		GetFileDialogWindow().SendMessage(CDM_SETCONTROLTEXT, nCtrlID, (LPARAM)lpstrText);
	}

	void SetDefExt(LPCTSTR lpstrExt)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(m_ofn.Flags & OFN_EXPLORER);

		GetFileDialogWindow().SendMessage(CDM_SETDEFEXT, 0, (LPARAM)lpstrExt);
	}

	BOOL GetReadOnlyPref() const	// return TRUE if readonly checked
	{
		return m_ofn.Flags & OFN_READONLY ? TRUE : FALSE;
	}

// Operations
	void HideControl(int nCtrlID)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(m_ofn.Flags & OFN_EXPLORER);

		GetFileDialogWindow().SendMessage(CDM_HIDECONTROL, nCtrlID);
	}

// Special override for common dialogs
	BOOL EndDialog(INT_PTR /*nRetCode*/ = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		GetFileDialogWindow().SendMessage(WM_COMMAND, MAKEWPARAM(IDCANCEL, 0));
		return TRUE;
	}

// Message map and handlers
	BEGIN_MSG_MAP(CFileDialogImpl< T >)
		NOTIFY_CODE_HANDLER(CDN_FILEOK, _OnFileOK)
		NOTIFY_CODE_HANDLER(CDN_FOLDERCHANGE, _OnFolderChange)
		NOTIFY_CODE_HANDLER(CDN_HELP, _OnHelp)
		NOTIFY_CODE_HANDLER(CDN_INITDONE, _OnInitDone)
		NOTIFY_CODE_HANDLER(CDN_SELCHANGE, _OnSelChange)
		NOTIFY_CODE_HANDLER(CDN_SHAREVIOLATION, _OnShareViolation)
		NOTIFY_CODE_HANDLER(CDN_TYPECHANGE, _OnTypeChange)
	END_MSG_MAP()

	LRESULT _OnFileOK(int /*idCtrl*/, LPNMHDR pnmh, BOOL& /*bHandled*/)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		T* pT = static_cast<T*>(this);
		return !pT->OnFileOK((LPOFNOTIFY)pnmh);
	}
	LRESULT _OnFolderChange(int /*idCtrl*/, LPNMHDR pnmh, BOOL& /*bHandled*/)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		T* pT = static_cast<T*>(this);
		pT->OnFolderChange((LPOFNOTIFY)pnmh);
		return 0;
	}
	LRESULT _OnHelp(int /*idCtrl*/, LPNMHDR pnmh, BOOL& /*bHandled*/)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		T* pT = static_cast<T*>(this);
		pT->OnHelp((LPOFNOTIFY)pnmh);
		return 0;
	}
	LRESULT _OnInitDone(int /*idCtrl*/, LPNMHDR pnmh, BOOL& /*bHandled*/)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		T* pT = static_cast<T*>(this);
		pT->OnInitDone((LPOFNOTIFY)pnmh);
		return 0;
	}
	LRESULT _OnSelChange(int /*idCtrl*/, LPNMHDR pnmh, BOOL& /*bHandled*/)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		T* pT = static_cast<T*>(this);
		pT->OnSelChange((LPOFNOTIFY)pnmh);
		return 0;
	}
	LRESULT _OnShareViolation(int /*idCtrl*/, LPNMHDR pnmh, BOOL& /*bHandled*/)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		T* pT = static_cast<T*>(this);
		return pT->OnShareViolation((LPOFNOTIFY)pnmh);
	}
	LRESULT _OnTypeChange(int /*idCtrl*/, LPNMHDR pnmh, BOOL& /*bHandled*/)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		T* pT = static_cast<T*>(this);
		pT->OnSelChange((LPOFNOTIFY)pnmh);
		return 0;
	}

// Overrideables
	BOOL OnFileOK(LPOFNOTIFY /*lpon*/)
	{
		return TRUE;
	}
	void OnFolderChange(LPOFNOTIFY /*lpon*/)
	{
	}
	void OnHelp(LPOFNOTIFY /*lpon*/)
	{
	}
	void OnInitDone(LPOFNOTIFY /*lpon*/)
	{
	}
	void OnSelChange(LPOFNOTIFY /*lpon*/)
	{
	}
	int OnShareViolation(LPOFNOTIFY /*lpon*/)
	{
		return 0;
	}
	void OnTypeChange(LPOFNOTIFY /*lpon*/)
	{
	}
};


class CFileDialog : public CFileDialogImpl<CFileDialog>
{
public:
	CFileDialog(BOOL bOpenFileDialog, // TRUE for FileOpen, FALSE for FileSaveAs
		LPCTSTR lpszDefExt = NULL,
		LPCTSTR lpszFileName = NULL,
		DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
		LPCTSTR lpszFilter = NULL,
		HWND hWndParent = NULL)
		: CFileDialogImpl<CFileDialog>(bOpenFileDialog, lpszDefExt, lpszFileName, dwFlags, lpszFilter, hWndParent)
	{ }

	// override base class map and references to handlers
	DECLARE_EMPTY_MSG_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CFolderDialogImpl - used for browsing for a folder

#ifndef BFFM_VALIDATEFAILED

#define BFFM_VALIDATEFAILEDA    3
#define BFFM_VALIDATEFAILEDW    4

#ifdef UNICODE
#define BFFM_VALIDATEFAILED BFFM_VALIDATEFAILEDW
#else
#define BFFM_VALIDATEFAILED BFFM_VALIDATEFAILEDA
#endif

#endif //!BFFM_VALIDATEFAILED

template <class T>
class ATL_NO_VTABLE CFolderDialogImpl
{
public:
	BROWSEINFO m_bi;
	TCHAR m_szFolderDisplayName[MAX_PATH];
	TCHAR m_szFolderPath[MAX_PATH];
	HWND m_hWnd;	// used only in the callback function

// Constructor
	CFolderDialogImpl(HWND hWndParent = NULL, LPCTSTR lpstrTitle = NULL, UINT uFlags = BIF_RETURNONLYFSDIRS)
	{
		memset(&m_bi, 0, sizeof(m_bi)); // initialize structure to 0/NULL

		m_bi.hwndOwner = hWndParent;
		m_bi.pidlRoot = NULL;
		m_bi.pszDisplayName = m_szFolderDisplayName;
		m_bi.lpszTitle = lpstrTitle;
		m_bi.ulFlags = uFlags;
		m_bi.lpfn = BrowseCallbackProc;
		m_bi.lParam = (LPARAM)this;

		m_szFolderPath[0] = 0;
		m_szFolderDisplayName[0] = 0;

		m_hWnd = NULL;
	}

// Operations
	INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow())
	{
		if(m_bi.hwndOwner == NULL)	// set only if not specified before
			m_bi.hwndOwner = hWndParent;

		INT_PTR nRet = -1;
		LPITEMIDLIST pItemIDList = ::SHBrowseForFolder(&m_bi);
		if(pItemIDList != NULL)
		{
			if(::SHGetPathFromIDList(pItemIDList, m_szFolderPath))
			{
				IMalloc* pMalloc = NULL;
				if(SUCCEEDED(::SHGetMalloc(&pMalloc)))
				{
					pMalloc->Free(pItemIDList);
					pMalloc->Release();
				}
				nRet = IDOK;
			}
			else
			{
				nRet = IDCANCEL;
			}
		}
		return nRet;
	}

	// filled after a call to DoModal
	LPCTSTR GetFolderPath() const
	{
		return m_szFolderPath;
	}
	LPCTSTR GetFolderDisplayName() const
	{
		return m_szFolderDisplayName;
	}
	int GetFolderImageIndex() const
	{
		return m_bi.iImage;
	}

// Callback function and overrideables
	static int CALLBACK BrowseCallbackProc(HWND hWnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
	{
		int nRet = 0;
		T* pT = (T*)lpData;
		pT->m_hWnd = hWnd;
		switch(uMsg)
		{
		case BFFM_INITIALIZED:
			pT->OnInitialized();
			break;
		case BFFM_SELCHANGED:
			pT->OnSelChanged((LPITEMIDLIST)lParam);
			break;
		case BFFM_VALIDATEFAILED:
			nRet = pT->OnValidateFailed((LPCTSTR)lParam);
			break;
		default:
			ATLTRACE2(atlTraceUI, 0, _T("Unknown message received in CFolderDialogImpl::BrowseCallbackProc\n"));
			break;
		}
		pT->m_hWnd = NULL;
		return nRet;
	}
	void OnInitialized()
	{
	}
	void OnSelChanged(LPITEMIDLIST /*pItemIDList*/)
	{
	}
	int OnValidateFailed(LPCTSTR /*lpstrFolderPath*/)
	{
		return 1;	// 1=continue, 0=EndDialog
	}

	// Commands - valid to call only from handlers
	void EnableOK(BOOL bEnable)
	{
		ATLASSERT(m_hWnd != NULL);
		::SendMessage(m_hWnd, BFFM_ENABLEOK, bEnable, 0L);
	}
	void SetSelection(LPITEMIDLIST pItemIDList)
	{
		ATLASSERT(m_hWnd != NULL);
		::SendMessage(m_hWnd, BFFM_SETSELECTION, FALSE, (LPARAM)pItemIDList);
	}
	void SetSelection(LPCTSTR lpstrFolderPath)
	{
		ATLASSERT(m_hWnd != NULL);
		::SendMessage(m_hWnd, BFFM_SETSELECTION, TRUE, (LPARAM)lpstrFolderPath);
	}
	void SetStatusText(LPCTSTR lpstrText)
	{
		ATLASSERT(m_hWnd != NULL);
		::SendMessage(m_hWnd, BFFM_SETSTATUSTEXT, 0, (LPARAM)lpstrText);
	}
};

class CFolderDialog : public CFolderDialogImpl<CFolderDialog>
{
public:
	CFolderDialog(HWND hWndParent = NULL, LPCTSTR lpstrTitle = NULL, UINT uFlags = BIF_RETURNONLYFSDIRS)
		: CFolderDialogImpl<CFolderDialog>(hWndParent, lpstrTitle, uFlags)
	{
		m_bi.lpfn = NULL;
	}
};


/////////////////////////////////////////////////////////////////////////////
// CCommonDialogImplBase - base class for common dialog classes

class ATL_NO_VTABLE CCommonDialogImplBase : public CWindowImplBase
{
public:
	static UINT_PTR APIENTRY HookProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		if(uMsg != WM_INITDIALOG)
			return 0;
		CCommonDialogImplBase* pT = (CCommonDialogImplBase*)_Module.ExtractCreateWndData();
		ATLASSERT(pT != NULL);
		ATLASSERT(pT->m_hWnd == NULL);
		ATLASSERT(::IsWindow(hWnd));
		// subclass dialog's window
		if(!pT->SubclassWindow(hWnd))
		{
			ATLTRACE2(atlTraceUI, 0, _T("Subclassing a common dialog failed\n"));
			return 0;
		}
		// check message map for WM_INITDIALOG handler
		LRESULT lRes;
		if(pT->ProcessWindowMessage(pT->m_hWnd, uMsg, wParam, lParam, lRes, 0) == FALSE)
			return 0;
		return lRes;
	}

// Special override for common dialogs
	BOOL EndDialog(INT_PTR /*nRetCode*/ = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		SendMessage(WM_COMMAND, MAKEWPARAM(IDABORT, 0));
		return TRUE;
	}

// Implementation - try to override these, to prevent errors
	HWND Create(HWND, _U_RECT, LPCTSTR, DWORD, DWORD, _U_MENUorID, ATOM, LPVOID)
	{
		ATLASSERT(FALSE);	// should not be called
		return NULL;
	}
	static LRESULT CALLBACK StartWindowProc(HWND /*hWnd*/, UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/)
	{
		ATLASSERT(FALSE);	// should not be called
		return 0;
	}
};


/////////////////////////////////////////////////////////////////////////////
// CFontDialogImpl - font selection dialog

template <class T>
class ATL_NO_VTABLE CFontDialogImpl : public CCommonDialogImplBase
{
public:
	CHOOSEFONT m_cf;
	TCHAR m_szStyleName[64];	// contains style name after return
	LOGFONT m_lf;			// default LOGFONT to store the info

// Constructors
	CFontDialogImpl(LPLOGFONT lplfInitial = NULL,
			DWORD dwFlags = CF_EFFECTS | CF_SCREENFONTS,
			HDC hDCPrinter = NULL,
			HWND hWndParent = NULL)
	{
		memset(&m_cf, 0, sizeof(m_cf));
		memset(&m_lf, 0, sizeof(m_lf));
		memset(&m_szStyleName, 0, sizeof(m_szStyleName));

		m_cf.lStructSize = sizeof(m_cf);
		m_cf.hwndOwner = hWndParent;
		m_cf.rgbColors = RGB(0, 0, 0);
		m_cf.lpszStyle = (LPTSTR)&m_szStyleName;
		m_cf.Flags = dwFlags | CF_ENABLEHOOK;
		m_cf.lpfnHook = (LPCFHOOKPROC)T::HookProc;

		if(lplfInitial != NULL)
		{
			m_cf.lpLogFont = lplfInitial;
			m_cf.Flags |= CF_INITTOLOGFONTSTRUCT;
			memcpy(&m_lf, m_cf.lpLogFont, sizeof(m_lf));
		}
		else
		{
			m_cf.lpLogFont = &m_lf;
		}

		if(hDCPrinter != NULL)
		{
			m_cf.hDC = hDCPrinter;
			m_cf.Flags |= CF_PRINTERFONTS;
		}
	}

// Operations
	INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow())
	{
		ATLASSERT(m_cf.Flags & CF_ENABLEHOOK);
		ATLASSERT(m_cf.lpfnHook != NULL);	// can still be a user hook

		if(m_cf.hwndOwner == NULL)		// set only if not specified before
			m_cf.hwndOwner = hWndParent;

		ATLASSERT(m_hWnd == NULL);
		_Module.AddCreateWndData(&m_thunk.cd, (CCommonDialogImplBase*)this);

		BOOL bRet = ::ChooseFont(&m_cf);

		m_hWnd = NULL;

		if(bRet)	// copy logical font from user's initialization buffer (if needed)
			memcpy(&m_lf, m_cf.lpLogFont, sizeof(m_lf));

		return bRet ? IDOK : IDCANCEL;
	}

	// Get the selected font (works during DoModal displayed or after)
	void GetCurrentFont(LPLOGFONT lplf) const
	{
		ATLASSERT(lplf != NULL);

		if(m_hWnd != NULL)
			::SendMessage(m_hWnd, WM_CHOOSEFONT_GETLOGFONT, 0, (LPARAM)lplf);
		else
			*lplf = m_lf;
	}

	// Helpers for parsing information after successful return
	LPCTSTR GetFaceName() const   // return the face name of the font
	{
		return (LPCTSTR)m_cf.lpLogFont->lfFaceName;
	}
	LPCTSTR GetStyleName() const  // return the style name of the font
	{
		return m_cf.lpszStyle;
	}
	int GetSize() const           // return the pt size of the font
	{
		return m_cf.iPointSize;
	}
	COLORREF GetColor() const     // return the color of the font
	{
		return m_cf.rgbColors;
	}
	int GetWeight() const         // return the chosen font weight
	{
		return (int)m_cf.lpLogFont->lfWeight;
	}
	BOOL IsStrikeOut() const      // return TRUE if strikeout
	{
		return m_cf.lpLogFont->lfStrikeOut ? TRUE : FALSE;
	}
	BOOL IsUnderline() const      // return TRUE if underline
	{
		return m_cf.lpLogFont->lfUnderline ? TRUE : FALSE;
	}
	BOOL IsBold() const           // return TRUE if bold font
	{
		return m_cf.lpLogFont->lfWeight == FW_BOLD ? TRUE : FALSE;
	}
	BOOL IsItalic() const         // return TRUE if italic font
	{
		return m_cf.lpLogFont->lfItalic ? TRUE : FALSE;
	}
};

class CFontDialog : public CFontDialogImpl<CFontDialog>
{
public:
	CFontDialog(LPLOGFONT lplfInitial = NULL,
		DWORD dwFlags = CF_EFFECTS | CF_SCREENFONTS,
		HDC hDCPrinter = NULL,
		HWND hWndParent = NULL)
		: CFontDialogImpl<CFontDialog>(lplfInitial, dwFlags, hDCPrinter, hWndParent)
	{ }

	DECLARE_EMPTY_MSG_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CRichEditFontDialogImpl - font selection for the Rich Edit ctrl

#ifdef _RICHEDIT_

template <class T>
class ATL_NO_VTABLE CRichEditFontDialogImpl : public CFontDialogImpl< T >
{
public:
	CRichEditFontDialogImpl(const CHARFORMAT& charformat,
			DWORD dwFlags = CF_SCREENFONTS,
			HDC hDCPrinter = NULL,
			HWND hWndParent = NULL)
			: CFontDialogImpl< T >(NULL, dwFlags, hDCPrinter, hWndParent)
	{
		m_cf.Flags |= CF_INITTOLOGFONTSTRUCT;
		m_cf.Flags |= FillInLogFont(charformat);
		m_cf.lpLogFont = &m_lf;

		if(charformat.dwMask & CFM_COLOR)
			m_cf.rgbColors = charformat.crTextColor;
	}

	void GetCharFormat(CHARFORMAT& cf) const
	{
		USES_CONVERSION;
		cf.dwEffects = 0;
		cf.dwMask = 0;
		if((m_cf.Flags & CF_NOSTYLESEL) == 0)
		{
			cf.dwMask |= CFM_BOLD | CFM_ITALIC;
			cf.dwEffects |= (IsBold()) ? CFE_BOLD : 0;
			cf.dwEffects |= (IsItalic()) ? CFE_ITALIC : 0;
		}
		if((m_cf.Flags & CF_NOSIZESEL) == 0)
		{
			cf.dwMask |= CFM_SIZE;
			//GetSize() returns in tenths of points so mulitply by 2 to get twips
			cf.yHeight = GetSize() * 2;
		}

		if((m_cf.Flags & CF_NOFACESEL) == 0)
		{
			cf.dwMask |= CFM_FACE;
			cf.bPitchAndFamily = m_cf.lpLogFont->lfPitchAndFamily;
#if (_RICHEDIT_VER >= 0x0200)
			lstrcpy(cf.szFaceName, GetFaceName());
#else
			lstrcpyA(cf.szFaceName, T2A((LPTSTR)(LPCTSTR)GetFaceName()));
#endif //(_RICHEDIT_VER >= 0x0200)
		}

		if(m_cf.Flags & CF_EFFECTS)
		{
			cf.dwMask |= CFM_UNDERLINE | CFM_STRIKEOUT | CFM_COLOR;
			cf.dwEffects |= (IsUnderline()) ? CFE_UNDERLINE : 0;
			cf.dwEffects |= (IsStrikeOut()) ? CFE_STRIKEOUT : 0;
			cf.crTextColor = GetColor();
		}
		if((m_cf.Flags & CF_NOSCRIPTSEL) == 0)
		{
			cf.bCharSet = m_cf.lpLogFont->lfCharSet;
			cf.dwMask |= CFM_CHARSET;
		}
		cf.yOffset = 0;
	}

	DWORD FillInLogFont(const CHARFORMAT& cf)
	{
		USES_CONVERSION;
		DWORD dwFlags = 0;
		if(cf.dwMask & CFM_SIZE)
		{
			HDC hDC = ::CreateDC(_T("DISPLAY"), NULL, NULL, NULL);
			LONG yPerInch = ::GetDeviceCaps(hDC, LOGPIXELSY);
			m_lf.lfHeight = -(int)((cf.yHeight * yPerInch) / 1440);
		}
		else
			m_lf.lfHeight = 0;

		m_lf.lfWidth = 0;
		m_lf.lfEscapement = 0;
		m_lf.lfOrientation = 0;

		if((cf.dwMask & (CFM_ITALIC|CFM_BOLD)) == (CFM_ITALIC|CFM_BOLD))
		{
			m_lf.lfWeight = (cf.dwEffects & CFE_BOLD) ? FW_BOLD : FW_NORMAL;
			m_lf.lfItalic = (BYTE)((cf.dwEffects & CFE_ITALIC) ? TRUE : FALSE);
		}
		else
		{
			dwFlags |= CF_NOSTYLESEL;
			m_lf.lfWeight = FW_DONTCARE;
			m_lf.lfItalic = FALSE;
		}

		if((cf.dwMask & (CFM_UNDERLINE|CFM_STRIKEOUT|CFM_COLOR)) ==
			(CFM_UNDERLINE|CFM_STRIKEOUT|CFM_COLOR))
		{
			dwFlags |= CF_EFFECTS;
			m_lf.lfUnderline = (BYTE)((cf.dwEffects & CFE_UNDERLINE) ? TRUE : FALSE);
			m_lf.lfStrikeOut = (BYTE)((cf.dwEffects & CFE_STRIKEOUT) ? TRUE : FALSE);
		}
		else
		{
			m_lf.lfUnderline = (BYTE)FALSE;
			m_lf.lfStrikeOut = (BYTE)FALSE;
		}

		if(cf.dwMask & CFM_CHARSET)
			m_lf.lfCharSet = cf.bCharSet;
		else
			dwFlags |= CF_NOSCRIPTSEL;
		m_lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
		m_lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
		m_lf.lfQuality = DEFAULT_QUALITY;
		if(cf.dwMask & CFM_FACE)
		{
			m_lf.lfPitchAndFamily = cf.bPitchAndFamily;
#if (_RICHEDIT_VER >= 0x0200)
			lstrcpy(m_lf.lfFaceName, cf.szFaceName);
#else
			lstrcpy(m_lf.lfFaceName, A2T((LPSTR)cf.szFaceName));
#endif //(_RICHEDIT_VER >= 0x0200)
		}
		else
		{
			m_lf.lfPitchAndFamily = DEFAULT_PITCH|FF_DONTCARE;
			m_lf.lfFaceName[0] = (TCHAR)0;
		}
		return dwFlags;
	}
};

class CRichEditFontDialog : public CRichEditFontDialogImpl<CRichEditFontDialog>
{
public:
	CRichEditFontDialog(const CHARFORMAT& charformat,
		DWORD dwFlags = CF_SCREENFONTS,
		HDC hDCPrinter = NULL,
		HWND hWndParent = NULL)
		: CRichEditFontDialogImpl<CRichEditFontDialog>(charformat, dwFlags, hDCPrinter, hWndParent)
	{ }

	DECLARE_EMPTY_MSG_MAP()
};

#endif // _RICHEDIT_

/////////////////////////////////////////////////////////////////////////////
// CColorDialogImpl - color selection

static const UINT _nMsgCOLOROK = ::RegisterWindowMessage(COLOROKSTRING);
const UINT _nMsgSETRGB = ::RegisterWindowMessage(SETRGBSTRING);

template <class T>
class ATL_NO_VTABLE CColorDialogImpl : public CCommonDialogImplBase
{
public:
	CHOOSECOLOR m_cc;

// Constructors
	CColorDialogImpl(COLORREF clrInit = 0, DWORD dwFlags = 0, HWND hWndParent = NULL)
	{
		memset(&m_cc, 0, sizeof(m_cc));

		m_cc.lStructSize = sizeof(m_cc);
		m_cc.lpCustColors = GetCustomColors();
		m_cc.hwndOwner = hWndParent;
		m_cc.Flags = dwFlags | CC_ENABLEHOOK;
		m_cc.lpfnHook = (LPCCHOOKPROC)T::HookProc;

		if(clrInit != 0)
		{
			m_cc.rgbResult = clrInit;
			m_cc.Flags |= CC_RGBINIT;
		}
	}

// Operations
	INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow())
	{
		ATLASSERT(m_cc.Flags & CC_ENABLEHOOK);
		ATLASSERT(m_cc.lpfnHook != NULL);	// can still be a user hook

		if(m_cc.hwndOwner == NULL)		// set only if not specified before
			m_cc.hwndOwner = hWndParent;

		ATLASSERT(m_hWnd == NULL);
		_Module.AddCreateWndData(&m_thunk.cd, (CCommonDialogImplBase*)this);

		BOOL bRet = ::ChooseColor(&m_cc);

		m_hWnd = NULL;

		return bRet ? IDOK : IDCANCEL;
	}

	// Set the current color while dialog is displayed
	void SetCurrentColor(COLORREF clr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		SendMessage(_nMsgSETRGB, 0, (DWORD)clr);
	}

	// Helpers for parsing information after successful return
	COLORREF GetColor() const
	{
		return m_cc.rgbResult;
	}

	static COLORREF* GetCustomColors()
	{
		static COLORREF rgbCustomColors[16] =
		{
			RGB(255, 255, 255), RGB(255, 255, 255), 
			RGB(255, 255, 255), RGB(255, 255, 255), 
			RGB(255, 255, 255), RGB(255, 255, 255), 
			RGB(255, 255, 255), RGB(255, 255, 255), 
			RGB(255, 255, 255), RGB(255, 255, 255), 
			RGB(255, 255, 255), RGB(255, 255, 255), 
			RGB(255, 255, 255), RGB(255, 255, 255), 
			RGB(255, 255, 255), RGB(255, 255, 255), 
		};

		return rgbCustomColors;
	}

// Overridable callbacks
	BEGIN_MSG_MAP(CColorDialogImpl< T >)
		MESSAGE_HANDLER(_nMsgCOLOROK, _OnColorOK)
	END_MSG_MAP()

	LRESULT _OnColorOK(UINT, WPARAM, LPARAM, BOOL&)
	{
		T* pT = static_cast<T*>(this);
		return pT->OnColorOK();
	}

	BOOL OnColorOK()        // validate color
	{
		return FALSE;
	}
};

class CColorDialog : public CColorDialogImpl<CColorDialog>
{
public:
	CColorDialog(COLORREF clrInit = 0, DWORD dwFlags = 0, HWND hWndParent = NULL)
		: CColorDialogImpl<CColorDialog>(clrInit, dwFlags, hWndParent)
	{ }

	// override base class map and references to handlers
	DECLARE_EMPTY_MSG_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CPrintDialogImpl - used for Print... and PrintSetup...

#ifndef psh1
#define psh1	0x0400		// from dlgs.h
#endif //!psh1

// global helper
static HDC _AtlCreateDC(HGLOBAL hDevNames, HGLOBAL hDevMode)
{
	if(hDevNames == NULL)
		return NULL;

	LPDEVNAMES lpDevNames = (LPDEVNAMES)::GlobalLock(hDevNames);
	LPDEVMODE  lpDevMode = (hDevMode != NULL) ? (LPDEVMODE)::GlobalLock(hDevMode) : NULL;

	if(lpDevNames == NULL)
		return NULL;

	HDC hDC = ::CreateDC((LPCTSTR)lpDevNames + lpDevNames->wDriverOffset,
					  (LPCTSTR)lpDevNames + lpDevNames->wDeviceOffset,
					  (LPCTSTR)lpDevNames + lpDevNames->wOutputOffset,
					  lpDevMode);

	::GlobalUnlock(hDevNames);
	if(hDevMode != NULL)
		::GlobalUnlock(hDevMode);
	return hDC;
}

template <class T>
class ATL_NO_VTABLE CPrintDialogImpl : public CCommonDialogImplBase
{
public:
	// print dialog parameter block (note this is a reference)
	PRINTDLG& m_pd;

// Constructors
	CPrintDialogImpl(BOOL bPrintSetupOnly = FALSE,	// TRUE for Print Setup, FALSE for Print Dialog
			DWORD dwFlags = PD_ALLPAGES | PD_USEDEVMODECOPIES | PD_NOPAGENUMS | PD_NOSELECTION,
			HWND hWndParent = NULL)
			: m_pd(m_pdActual)
	{
		memset(&m_pdActual, 0, sizeof(m_pdActual));

		m_pd.lStructSize = sizeof(m_pdActual);
		m_pd.hwndOwner = hWndParent;
		m_pd.Flags = (dwFlags | PD_ENABLEPRINTHOOK | PD_ENABLESETUPHOOK);
		m_pd.lpfnPrintHook = (LPPRINTHOOKPROC)T::HookProc;
		m_pd.lpfnSetupHook = (LPSETUPHOOKPROC)T::HookProc;

		if(bPrintSetupOnly)
			m_pd.Flags |= PD_PRINTSETUP;
		else
			m_pd.Flags |= PD_RETURNDC;

		m_pd.Flags &= ~PD_RETURNIC; // do not support information context
	}

// Operations
	INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow())
	{
		ATLASSERT(m_pd.Flags & PD_ENABLEPRINTHOOK);
		ATLASSERT(m_pd.Flags & PD_ENABLESETUPHOOK);
		ATLASSERT(m_pd.lpfnPrintHook != NULL);	// can still be a user hook
		ATLASSERT(m_pd.lpfnSetupHook != NULL);	// can still be a user hook
		ATLASSERT((m_pd.Flags & PD_RETURNDEFAULT) == 0);	// use GetDefaults for this

		if(m_pd.hwndOwner == NULL)		// set only if not specified before
			m_pd.hwndOwner = hWndParent;

		ATLASSERT(m_hWnd == NULL);
		_Module.AddCreateWndData(&m_thunk.cd, (CCommonDialogImplBase*)this);

		BOOL bRet = ::PrintDlg(&m_pd);

		m_hWnd = NULL;

		return bRet ? IDOK : IDCANCEL;
	}

	// GetDefaults will not display a dialog but will get device defaults
	BOOL GetDefaults()
	{
		m_pd.Flags |= PD_RETURNDEFAULT;
		ATLASSERT(m_pd.hDevMode == NULL);	// must be NULL
		ATLASSERT(m_pd.hDevNames == NULL);	// must be NULL

		return ::PrintDlg(&m_pd);
	}

	// Helpers for parsing information after successful return num. copies requested
	int GetCopies() const
	{
		if(m_pd.Flags & PD_USEDEVMODECOPIES)
		{
			LPDEVMODE lpDevMode = GetDevMode();
			return (lpDevMode != NULL) ? lpDevMode->dmCopies : -1;
		}

		return m_pd.nCopies;
	}
	BOOL PrintCollate() const       // TRUE if collate checked
	{
		return m_pd.Flags & PD_COLLATE ? TRUE : FALSE;
	}
	BOOL PrintSelection() const     // TRUE if printing selection
	{
		return m_pd.Flags & PD_SELECTION ? TRUE : FALSE;
	}
	BOOL PrintAll() const           // TRUE if printing all pages
	{
		return !PrintRange() && !PrintSelection() ? TRUE : FALSE;
	}
	BOOL PrintRange() const         // TRUE if printing page range
	{
		return m_pd.Flags & PD_PAGENUMS ? TRUE : FALSE;
	}
	int GetFromPage() const         // starting page if valid
	{
		return (PrintRange() ? m_pd.nFromPage :-1);
	}
	int GetToPage() const           // starting page if valid
	{
		return (PrintRange() ? m_pd.nToPage :-1);
	}
	LPDEVMODE GetDevMode() const    // return DEVMODE
	{
		if(m_pd.hDevMode == NULL)
			return NULL;

		return (LPDEVMODE)::GlobalLock(m_pd.hDevMode);
	}
	LPCTSTR GetDriverName() const   // return driver name
	{
		if(m_pd.hDevNames == NULL)
			return NULL;

		LPDEVNAMES lpDev = (LPDEVNAMES)::GlobalLock(m_pd.hDevNames);
		if(lpDev == NULL)
			return NULL;

		return (LPCTSTR)lpDev + lpDev->wDriverOffset;
	}
	LPCTSTR GetDeviceName() const   // return device name
	{
		if(m_pd.hDevNames == NULL)
			return NULL;

		LPDEVNAMES lpDev = (LPDEVNAMES)::GlobalLock(m_pd.hDevNames);
		if(lpDev == NULL)
			return NULL;

		return (LPCTSTR)lpDev + lpDev->wDeviceOffset;
	}
	LPCTSTR GetPortName() const     // return output port name
	{
		if(m_pd.hDevNames == NULL)
			return NULL;

		LPDEVNAMES lpDev = (LPDEVNAMES)::GlobalLock(m_pd.hDevNames);
		if(lpDev == NULL)
			return NULL;

		return (LPCTSTR)lpDev + lpDev->wOutputOffset;
	}
	HDC GetPrinterDC() const        // return HDC (caller must delete)
	{
		ATLASSERT(m_pd.Flags & PD_RETURNDC);
		return m_pd.hDC;
	}

	// This helper creates a DC based on the DEVNAMES and DEVMODE structures.
	// This DC is returned, but also stored in m_pd.hDC as though it had been
	// returned by CommDlg.  It is assumed that any previously obtained DC
	// has been/will be deleted by the user.  This may be
	// used without ever invoking the print/print setup dialogs.
	HDC CreatePrinterDC()
	{
		m_pd.hDC = _AtlCreateDC(m_pd.hDevNames, m_pd.hDevMode);
		return m_pd.hDC;
	}

// Implementation
	PRINTDLG m_pdActual; // the Print/Print Setup need to share this

	// The following handle the case of print setup... from the print dialog
	CPrintDialogImpl(PRINTDLG& pdInit) : m_pd(pdInit)
	{ }

	BEGIN_MSG_MAP(CPrintDialogImpl< T >)
		COMMAND_ID_HANDLER(psh1, OnPrintSetup) // print setup button when print is displayed
	END_MSG_MAP()

	LRESULT OnPrintSetup(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& /*bHandled*/)
	{
		CPrintDialogImpl< T >* pDlgSetup = NULL;
		ATLTRY(pDlgSetup = new CPrintDialogImpl< T >(m_pd));
		ATLASSERT(pDlgSetup != NULL);

		_Module.AddCreateWndData(&m_thunk.cd, (CCommonDialogImplBase*)pDlgSetup);
		LRESULT lRet = DefWindowProc(WM_COMMAND, MAKEWPARAM(wID, wNotifyCode), (LPARAM)hWndCtl);

		delete pDlgSetup;
		return lRet;
	}
};

class CPrintDialog : public CPrintDialogImpl<CPrintDialog>
{
public:
	CPrintDialog(BOOL bPrintSetupOnly = FALSE,
		DWORD dwFlags = PD_ALLPAGES | PD_USEDEVMODECOPIES | PD_NOPAGENUMS | PD_NOSELECTION,
		HWND hWndParent = NULL)
		: CPrintDialogImpl<CPrintDialog>(bPrintSetupOnly, dwFlags, hWndParent)
	{ }
	CPrintDialog(PRINTDLG& pdInit) : CPrintDialogImpl<CPrintDialog>(pdInit)
	{ }
};


/////////////////////////////////////////////////////////////////////////////
// CPrintDialogExImpl - new print dialog for Windows 2000

#if (WINVER >= 0x0500)

}; //namespace WTL

#include <atlcom.h>

extern "C" const __declspec(selectany) IID IID_IPrintDialogCallback = {0x5852a2c3, 0x6530, 0x11d1, {0xb6, 0xa3, 0x0, 0x0, 0xf8, 0x75, 0x7b, 0xf9}};
extern "C" const __declspec(selectany) IID IID_IPrintDialogServices = {0x509aaeda, 0x5639, 0x11d1, {0xb6, 0xa1, 0x0, 0x0, 0xf8, 0x75, 0x7b, 0xf9}};

namespace WTL
{

template <class T>
class ATL_NO_VTABLE CPrintDialogExImpl : 
				public CWindow,
				public CMessageMap,
				public IPrintDialogCallback,
				public IObjectWithSiteImpl< T >
{
public:
	PRINTDLGEX m_pdex;

// Constructor
	CPrintDialogExImpl(DWORD dwFlags = PD_ALLPAGES | PD_USEDEVMODECOPIES | PD_NOPAGENUMS | PD_NOSELECTION | PD_NOCURRENTPAGE,
				HWND hWndParent = NULL)
	{
		memset(&m_pdex, 0, sizeof(m_pdex));

		m_pdex.lStructSize = sizeof(PRINTDLGEX);
		m_pdex.hwndOwner = hWndParent;
		m_pdex.Flags = dwFlags;
		m_pdex.nStartPage = START_PAGE_GENERAL;
		// callback object will be set in DoModal

		m_pdex.Flags &= ~PD_RETURNIC; // do not support information context
	}

// Operations
	HRESULT DoModal(HWND hWndParent = ::GetActiveWindow())
	{
		ATLASSERT(m_hWnd == NULL);
		ATLASSERT((m_pdex.Flags & PD_RETURNDEFAULT) == 0);	// use GetDefaults for this

		if(m_pdex.hwndOwner == NULL)		// set only if not specified before
			m_pdex.hwndOwner = hWndParent;

		T* pT = static_cast<T*>(this);
		m_pdex.lpCallback = (IUnknown*)(IPrintDialogCallback*)pT;

		HRESULT hResult = ::PrintDlgEx(&m_pdex);

		m_hWnd = NULL;

		return hResult;
	}

	BOOL EndDialog(INT_PTR /*nRetCode*/ = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		SendMessage(WM_COMMAND, MAKEWPARAM(IDABORT, 0));
		return TRUE;
	}

	// GetDefaults will not display a dialog but will get device defaults
	HRESULT GetDefaults()
	{
		m_pdex.Flags |= PD_RETURNDEFAULT;
		ATLASSERT(m_pdex.hDevMode == NULL);	// must be NULL
		ATLASSERT(m_pdex.hDevNames == NULL);	// must be NULL

		return ::PrintDlgEx(&m_pdex);
	}

	// Helpers for parsing information after successful return num. copies requested
	int GetCopies() const
	{
		if(m_pdex.Flags & PD_USEDEVMODECOPIES)
		{
			LPDEVMODE lpDevMode = GetDevMode();
			return (lpDevMode != NULL) ? lpDevMode->dmCopies : -1;
		}

		return m_pdex.nCopies;
	}
	BOOL PrintCollate() const       // TRUE if collate checked
	{
		return m_pdex.Flags & PD_COLLATE ? TRUE : FALSE;
	}
	BOOL PrintSelection() const     // TRUE if printing selection
	{
		return m_pdex.Flags & PD_SELECTION ? TRUE : FALSE;
	}
	BOOL PrintAll() const           // TRUE if printing all pages
	{
		return !PrintRange() && !PrintSelection() ? TRUE : FALSE;
	}
	BOOL PrintRange() const         // TRUE if printing page range
	{
		return m_pdex.Flags & PD_PAGENUMS ? TRUE : FALSE;
	}
	LPDEVMODE GetDevMode() const    // return DEVMODE
	{
		if(m_pdex.hDevMode == NULL)
			return NULL;

		return (LPDEVMODE)::GlobalLock(m_pdex.hDevMode);
	}
	LPCTSTR GetDriverName() const   // return driver name
	{
		if(m_pdex.hDevNames == NULL)
			return NULL;

		LPDEVNAMES lpDev = (LPDEVNAMES)::GlobalLock(m_pdex.hDevNames);
		if(lpDev == NULL)
			return NULL;

		return (LPCTSTR)lpDev + lpDev->wDriverOffset;
	}
	LPCTSTR GetDeviceName() const   // return device name
	{
		if(m_pdex.hDevNames == NULL)
			return NULL;

		LPDEVNAMES lpDev = (LPDEVNAMES)::GlobalLock(m_pdex.hDevNames);
		if(lpDev == NULL)
			return NULL;

		return (LPCTSTR)lpDev + lpDev->wDeviceOffset;
	}
	LPCTSTR GetPortName() const     // return output port name
	{
		if(m_pdex.hDevNames == NULL)
			return NULL;

		LPDEVNAMES lpDev = (LPDEVNAMES)::GlobalLock(m_pdex.hDevNames);
		if(lpDev == NULL)
			return NULL;

		return (LPCTSTR)lpDev + lpDev->wOutputOffset;
	}
	HDC GetPrinterDC() const        // return HDC (caller must delete)
	{
		ATLASSERT(m_pdex.Flags & PD_RETURNDC);
		return m_pdex.hDC;
	}

	// This helper creates a DC based on the DEVNAMES and DEVMODE structures.
	// This DC is returned, but also stored in m_pdex.hDC as though it had been
	// returned by CommDlg.  It is assumed that any previously obtained DC
	// has been/will be deleted by the user.  This may be
	// used without ever invoking the print/print setup dialogs.
	HDC CreatePrinterDC()
	{
		m_pdex.hDC = _AtlCreateDC(m_pdex.hDevNames, m_pdex.hDevMode);
		return m_pdex.hDC;
	}

// Implementation - interfaces

// IUnknown
	STDMETHOD(QueryInterface)(REFIID riid, void** ppvObject)
	{
		if(ppvObject == NULL)
			return E_POINTER;

		T* pT = static_cast<T*>(this);
		if(IsEqualGUID(riid, IID_IUnknown) || IsEqualGUID(riid, IID_IPrintDialogCallback))
		{
			*ppvObject = (IPrintDialogCallback*)pT;
			// AddRef() not needed
			return S_OK;
		}
		else if(IsEqualGUID(riid, IID_IObjectWithSite))
		{
			*ppvObject = (IObjectWithSite*)pT;
			// AddRef() not needed
			return S_OK;
		}

		return E_NOINTERFACE;
	}
	virtual ULONG STDMETHODCALLTYPE AddRef()
	{
		return 1;
	}
	virtual ULONG STDMETHODCALLTYPE Release()
	{
		return 1;
	}

// IPrintDialogCallback
	STDMETHOD(InitDone)()
	{
		return S_FALSE;
	}
	STDMETHOD(SelectionChange)()
	{
		return S_FALSE;
	}
	STDMETHOD(HandleMessage)(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plResult)
	{
		// set up m_hWnd the first time
		if(m_hWnd == NULL)
			Attach(hWnd);

		// call message map
		HRESULT hRet = ProcessWindowMessage(hWnd, uMsg, wParam, lParam, *plResult, 0) ? S_OK : S_FALSE;
		if(hRet == S_OK && uMsg == WM_NOTIFY)	// return in DWL_MSGRESULT
			::SetWindowLong(GetParent(), DWL_MSGRESULT, (LONG)*plResult);

		if(uMsg == WM_INITDIALOG && hRet == S_OK && (BOOL)*plResult != FALSE)
			hRet = S_FALSE;

		return hRet;
	}
};

class CPrintDialogEx : public CPrintDialogExImpl<CPrintDialogEx>
{
public:
	CPrintDialogEx(
		DWORD dwFlags = PD_ALLPAGES | PD_USEDEVMODECOPIES | PD_NOPAGENUMS | PD_NOSELECTION | PD_NOCURRENTPAGE,
		HWND hWndParent = NULL)
		: CPrintDialogExImpl<CPrintDialogEx>(dwFlags, hWndParent)
	{ }

	DECLARE_EMPTY_MSG_MAP()
};

#endif //(WINVER >= 0x0500)

/////////////////////////////////////////////////////////////////////////////
// CPageSetupDialogImpl - Page Setup dialog

template <class T>
class ATL_NO_VTABLE CPageSetupDialogImpl : public CCommonDialogImplBase
{
public:
	PAGESETUPDLG m_psd;
	CWndProcThunk m_thunkPaint;


// Constructors
	CPageSetupDialogImpl(DWORD dwFlags = PSD_MARGINS | PSD_INWININIINTLMEASURE, HWND hWndParent = NULL)
	{
		memset(&m_psd, 0, sizeof(m_psd));

		m_psd.lStructSize = sizeof(m_psd);
		m_psd.hwndOwner = hWndParent;
		m_psd.Flags = (dwFlags | PSD_ENABLEPAGESETUPHOOK | PSD_ENABLEPAGEPAINTHOOK);
		m_psd.lpfnPageSetupHook = (LPPAGESETUPHOOK)T::HookProc;
		m_thunkPaint.Init((WNDPROC)T::PaintHookProc, this);
		m_psd.lpfnPagePaintHook = (LPPAGEPAINTHOOK)&(m_thunkPaint.thunk);
	}

	DECLARE_EMPTY_MSG_MAP()

// Attributes
	LPDEVMODE GetDevMode() const    // return DEVMODE
	{
		if(m_psd.hDevMode == NULL)
			return NULL;

		return (LPDEVMODE)::GlobalLock(m_psd.hDevMode);
	}
	LPCTSTR GetDriverName() const   // return driver name
	{
		if(m_psd.hDevNames == NULL)
			return NULL;

		LPDEVNAMES lpDev = (LPDEVNAMES)::GlobalLock(m_psd.hDevNames);
		return (LPCTSTR)lpDev + lpDev->wDriverOffset;
	}
	LPCTSTR GetDeviceName() const   // return device name
	{
		if(m_psd.hDevNames == NULL)
			return NULL;

		LPDEVNAMES lpDev = (LPDEVNAMES)::GlobalLock(m_psd.hDevNames);
		return (LPCTSTR)lpDev + lpDev->wDeviceOffset;
	}
	LPCTSTR GetPortName() const     // return output port name
	{
		if(m_psd.hDevNames == NULL)
			return NULL;

		LPDEVNAMES lpDev = (LPDEVNAMES)::GlobalLock(m_psd.hDevNames);
		return (LPCTSTR)lpDev + lpDev->wOutputOffset;
	}
	HDC CreatePrinterDC()
	{
		return _AtlCreateDC(m_psd.hDevNames, m_psd.hDevMode);
	}
	SIZE GetPaperSize() const
	{
		SIZE size;
		size.cx = m_psd.ptPaperSize.x;
		size.cy = m_psd.ptPaperSize.y;
		return size;
	}
	void GetMargins(LPRECT lpRectMargins, LPRECT lpRectMinMargins) const
	{
		if(lpRectMargins != NULL)
			memcpy(lpRectMargins, &m_psd.rtMargin, sizeof(RECT));
		if(lpRectMinMargins != NULL)
			memcpy(lpRectMinMargins, &m_psd.rtMinMargin, sizeof(RECT));
	}

// Operations
	INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow())
	{
		ATLASSERT(m_psd.Flags & PSD_ENABLEPAGESETUPHOOK);
		ATLASSERT(m_psd.Flags & PSD_ENABLEPAGEPAINTHOOK);
		ATLASSERT(m_psd.lpfnPageSetupHook != NULL);	// can still be a user hook
		ATLASSERT(m_psd.lpfnPagePaintHook != NULL);	// can still be a user hook

		if(m_psd.hwndOwner == NULL)		// set only if not specified before
			m_psd.hwndOwner = hWndParent;

		ATLASSERT(m_hWnd == NULL);
		_Module.AddCreateWndData(&m_thunk.cd, (CCommonDialogImplBase*)this);

		BOOL bRet = ::PageSetupDlg(&m_psd);

		m_hWnd = NULL;

		return bRet ? IDOK : IDCANCEL;
	}

// Implementation
	static UINT CALLBACK PaintHookProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		CPageSetupDialogImpl< T >* pDlg = (CPageSetupDialogImpl< T >*)hWnd;
		ATLASSERT(pDlg->m_hWnd == ::GetParent(hWnd));
		UINT uRet = 0;
		switch(uMsg)
		{
		case WM_PSD_PAGESETUPDLG:
			uRet = pDlg->PreDrawPage(LOWORD(wParam), HIWORD(wParam), (LPPAGESETUPDLG)lParam);
			break;
		case WM_PSD_FULLPAGERECT:
		case WM_PSD_MINMARGINRECT:
		case WM_PSD_MARGINRECT:
		case WM_PSD_GREEKTEXTRECT:
		case WM_PSD_ENVSTAMPRECT:
		case WM_PSD_YAFULLPAGERECT:
			uRet = pDlg->OnDrawPage(uMsg, (HDC)wParam, (LPRECT)lParam);
			break;
		default:
			ATLTRACE2(atlTraceUI, 0, _T("CPageSetupDialogImpl::PaintHookProc - unknown message received\n"));
			break;
		}
		return uRet;
	}

// Overridables
	UINT PreDrawPage(WORD /*wPaper*/, WORD /*wFlags*/, LPPAGESETUPDLG /*pPSD*/)
	{
		// return 1 to prevent any more drawing
		return 0;
	}
	UINT OnDrawPage(UINT /*uMsg*/, HDC /*hDC*/, LPRECT /*lpRect*/)
	{
		return 0; // do the default
	}
};

class CPageSetupDialog : public CPageSetupDialogImpl<CPageSetupDialog>
{
public:
	CPageSetupDialog(DWORD dwFlags = PSD_MARGINS | PSD_INWININIINTLMEASURE, HWND hWndParent = NULL)
		: CPageSetupDialogImpl<CPageSetupDialog>(dwFlags, hWndParent)
	{ }

	// override PaintHookProc and references to handlers
	static UINT CALLBACK PaintHookProc(HWND, UINT, WPARAM, LPARAM)
	{
		return 0;
	}
};


/////////////////////////////////////////////////////////////////////////////
// CFindReplaceDialogImpl - Find/FindReplace modeless dialogs

template <class T>
class ATL_NO_VTABLE CFindReplaceDialogImpl : public CCommonDialogImplBase
{
public:
	FINDREPLACE m_fr;
	TCHAR m_szFindWhat[128];
	TCHAR m_szReplaceWith[128];

// Constructors
	CFindReplaceDialogImpl()
	{
		memset(&m_fr, 0, sizeof(m_fr));
		m_szFindWhat[0] = '\0';
		m_szReplaceWith[0] = '\0';

		m_fr.lStructSize = sizeof(m_fr);
		m_fr.Flags = FR_ENABLEHOOK;
		m_fr.lpfnHook = (LPFRHOOKPROC)T::HookProc;
		m_fr.lpstrFindWhat = (LPTSTR)m_szFindWhat;
	}

	// Note: You must allocate the object on the heap.
	//       If you do not, you must override OnFinalMessage()
	virtual void OnFinalMessage(HWND /*hWnd*/)
	{
		delete this;
	}

	HWND Create(BOOL bFindDialogOnly, // TRUE for Find, FALSE for FindReplace
			LPCTSTR lpszFindWhat,
			LPCTSTR lpszReplaceWith = NULL,
			DWORD dwFlags = FR_DOWN,
			HWND hWndParent = NULL)
	{
		ATLASSERT(m_fr.Flags & FR_ENABLEHOOK);
		ATLASSERT(m_fr.lpfnHook != NULL);

		m_fr.wFindWhatLen = sizeof(m_szFindWhat)/sizeof(TCHAR);
		m_fr.lpstrReplaceWith = (LPTSTR)m_szReplaceWith;
		m_fr.wReplaceWithLen = sizeof(m_szReplaceWith)/sizeof(TCHAR);
		m_fr.Flags |= dwFlags;

		if(hWndParent == NULL)
			m_fr.hwndOwner = ::GetActiveWindow();
		else
			m_fr.hwndOwner = hWndParent;
		ATLASSERT(m_fr.hwndOwner != NULL); // must have an owner for modeless dialog

		if(lpszFindWhat != NULL)
			lstrcpyn(m_szFindWhat, lpszFindWhat, sizeof(m_szFindWhat)/sizeof(TCHAR));

		if(lpszReplaceWith != NULL)
			lstrcpyn(m_szReplaceWith, lpszReplaceWith, sizeof(m_szReplaceWith)/sizeof(TCHAR));

		ATLASSERT(m_hWnd == NULL);
		_Module.AddCreateWndData(&m_thunk.cd, (CCommonDialogImplBase*)this);
		HWND hWnd;

		if(bFindDialogOnly)
			hWnd = ::FindText(&m_fr);
		else
			hWnd = ::ReplaceText(&m_fr);

		ATLASSERT(m_hWnd == hWnd);
		return hWnd;
	}

	static const UINT GetFindReplaceMsg()
	{
		static const UINT nMsgFindReplace = ::RegisterWindowMessage(FINDMSGSTRING);
		return nMsgFindReplace;
	}
	// call while handling FINDMSGSTRING registered message
	// to retreive the object
	static T* PASCAL GetNotifier(LPARAM lParam)
	{
		ATLASSERT(lParam != NULL);
		T* pDlg = (T*)(lParam - offsetof(T, m_fr));
		return pDlg;
	}

// Operations
	// Helpers for parsing information after successful return
	LPCTSTR GetFindString() const    // get find string
	{
		return (LPCTSTR)m_fr.lpstrFindWhat;
	}
	LPCTSTR GetReplaceString() const // get replacement string
	{
		return (LPCTSTR)m_fr.lpstrReplaceWith;
	}
	BOOL SearchDown() const          // TRUE if search down, FALSE is up
	{
		return m_fr.Flags & FR_DOWN ? TRUE : FALSE;
	}
	BOOL FindNext() const            // TRUE if command is find next
	{
		return m_fr.Flags & FR_FINDNEXT ? TRUE : FALSE;
	}
	BOOL MatchCase() const           // TRUE if matching case
	{
		return m_fr.Flags & FR_MATCHCASE ? TRUE : FALSE;
	}
	BOOL MatchWholeWord() const      // TRUE if matching whole words only
	{
		return m_fr.Flags & FR_WHOLEWORD ? TRUE : FALSE;
	}
	BOOL ReplaceCurrent() const      // TRUE if replacing current string
	{
		return m_fr. Flags & FR_REPLACE ? TRUE : FALSE;
	}
	BOOL ReplaceAll() const          // TRUE if replacing all occurrences
	{
		return m_fr.Flags & FR_REPLACEALL ? TRUE : FALSE;
	}
	BOOL IsTerminating() const       // TRUE if terminating dialog
	{
		return m_fr.Flags & FR_DIALOGTERM ? TRUE : FALSE ;
	}
};

class CFindReplaceDialog : public CFindReplaceDialogImpl<CFindReplaceDialog>
{
public:
	DECLARE_EMPTY_MSG_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CPropertySheetWindow - client side for a property sheet

class CPropertySheetWindow : public CWindow
{
public:
// Constructors
	CPropertySheetWindow(HWND hWnd = NULL) : CWindow(hWnd) { }

	CPropertySheetWindow& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

// Attributes
	int GetPageCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		HWND hWndTabCtrl = GetTabControl();
		ATLASSERT(hWndTabCtrl != NULL);
		return (int)::SendMessage(hWndTabCtrl, TCM_GETITEMCOUNT, 0, 0L);
	}
	HWND GetActivePage() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HWND)::SendMessage(m_hWnd, PSM_GETCURRENTPAGEHWND, 0, 0L);
	}
	int GetActiveIndex() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		HWND hWndTabCtrl = GetTabControl();
		ATLASSERT(hWndTabCtrl != NULL);
		return (int)::SendMessage(hWndTabCtrl, TCM_GETCURSEL, 0, 0L);
	}
	BOOL SetActivePage(int nPageIndex)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, PSM_SETCURSEL, nPageIndex, 0L);
	}
	BOOL SetActivePage(HPROPSHEETPAGE hPage)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(hPage != NULL);
		return (BOOL)::SendMessage(m_hWnd, PSM_SETCURSEL, 0, (LPARAM)hPage);
	}
	BOOL SetActivePageByID(int nPageID)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, PSM_SETCURSELID, 0, nPageID);
	}
	void SetTitle(LPCTSTR lpszText, UINT nStyle = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((nStyle & ~PSH_PROPTITLE) == 0); // only PSH_PROPTITLE is valid
		ATLASSERT(lpszText != NULL);
		::SendMessage(m_hWnd, PSM_SETTITLE, nStyle, (LPARAM)lpszText);
	}
	HWND GetTabControl() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HWND)::SendMessage(m_hWnd, PSM_GETTABCONTROL, 0, 0L);
	}
	void SetFinishText(LPCTSTR lpszText)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, PSM_SETFINISHTEXT, 0, (LPARAM)lpszText);
	}
	void SetWizardButtons(DWORD dwFlags)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::PostMessage(m_hWnd, PSM_SETWIZBUTTONS, 0, dwFlags);
	}

// Operations
	void AddPage(HPROPSHEETPAGE hPage)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(hPage != NULL);
		::SendMessage(m_hWnd, PSM_ADDPAGE, 0, (LPARAM)hPage);
	}
	BOOL AddPage(LPCPROPSHEETPAGE pPage)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(pPage != NULL);
		HPROPSHEETPAGE hPage = ::CreatePropertySheetPage(pPage);
		if(hPage == NULL)
			return FALSE;
		::SendMessage(m_hWnd, PSM_ADDPAGE, 0, (LPARAM)hPage);
		return TRUE;
	}
	void RemovePage(int nPageIndex)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, PSM_REMOVEPAGE, nPageIndex, 0L);
	}
	void RemovePage(HPROPSHEETPAGE hPage)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(hPage != NULL);
		::SendMessage(m_hWnd, PSM_REMOVEPAGE, 0, (LPARAM)hPage);
	}
	BOOL PressButton(int nButton)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, PSM_PRESSBUTTON, nButton, 0L);
	}
	BOOL Apply()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, PSM_APPLY, 0, 0L);
	}
	void CancelToClose()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, PSM_CANCELTOCLOSE, 0, 0L);
	}
	void SetModified(HWND hWndPage, BOOL bChanged = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(::IsWindow(hWndPage));
		UINT uMsg = bChanged ? PSM_CHANGED : PSM_UNCHANGED;
		::SendMessage(m_hWnd, uMsg, (WPARAM)hWndPage, 0L);
	}
	LRESULT QuerySiblings(WPARAM wParam, LPARAM lParam)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SendMessage(m_hWnd, PSM_QUERYSIBLINGS, wParam, lParam);
	}
	void RebootSystem()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, PSM_REBOOTSYSTEM, 0, 0L);
	}
	void RestartWindows()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, PSM_RESTARTWINDOWS, 0, 0L);
	}
	BOOL IsDialogMessage(LPMSG lpMsg)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, PSM_ISDIALOGMESSAGE, 0, (LPARAM)lpMsg);
	}

// Implementation - override to prevent usage
	HWND Create(LPCTSTR, HWND, _U_RECT = NULL, LPCTSTR = NULL, DWORD = 0, DWORD = 0, _U_MENUorID = 0U, LPVOID = NULL)
	{
		ATLASSERT(FALSE);
		return NULL;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CPropertySheetImpl - implements a property sheet

#if (_MSC_VER >= 1200)
typedef HPROPSHEETPAGE	_HPROPSHEETPAGE_TYPE;
#else
// we use void* here instead of HPROPSHEETPAGE becuase HPROPSHEETPAGE
// is a _PSP*, but _PSP is not defined properly
typedef void*	_HPROPSHEETPAGE_TYPE;
#endif

template <class T, class TBase = CPropertySheetWindow>
class ATL_NO_VTABLE CPropertySheetImpl : public CWindowImplBaseT< TBase >
{
public:
	PROPSHEETHEADER m_psh;
	CSimpleArray<_HPROPSHEETPAGE_TYPE> m_arrPages;

// Construction/Destruction
	CPropertySheetImpl(_U_STRINGorID title = (LPCTSTR)NULL, UINT uStartPage = 0, HWND hWndParent = NULL)
	{
		memset(&m_psh, 0, sizeof(PROPSHEETHEADER));
		m_psh.dwSize = sizeof(PROPSHEETHEADER);
		m_psh.dwFlags = PSH_USECALLBACK;
		m_psh.hInstance = _Module.GetResourceInstance();
		m_psh.phpage = NULL;	// will be set later
		m_psh.nPages = 0;	// will be set later
		m_psh.pszCaption = title.m_lpstr;
		m_psh.nStartPage = uStartPage;
		m_psh.hwndParent = hWndParent;	// if NULL, will be set in DoModal/Create
		m_psh.pfnCallback = T::PropSheetCallback;
	}

	~CPropertySheetImpl()
	{
		if(m_arrPages.GetSize() > 0)	// sheet never created, destroy all pages
		{
			for(int i = 0; i < m_arrPages.GetSize(); i++)
				::DestroyPropertySheetPage((HPROPSHEETPAGE)m_arrPages[i]);
		}
	}

	static int CALLBACK PropSheetCallback(HWND hWnd, UINT uMsg, LPARAM)
	{
		if(uMsg == PSCB_INITIALIZED)
		{
			ATLASSERT(hWnd != NULL);
			CPropertySheetImpl< T, TBase >* pT = (CPropertySheetImpl< T, TBase >*)_Module.ExtractCreateWndData();
			// subclass the sheet window
			pT->SubclassWindow(hWnd);
			// remove page handles array
			pT->m_psh.nPages = 0;
			pT->m_psh.phpage = NULL;
			pT->m_arrPages.RemoveAll();
		}

		return 0;
	}

	HWND Create(HWND hWndParent = NULL)
	{
		ATLASSERT(m_hWnd == NULL);

		m_psh.dwFlags |= PSH_MODELESS;
		if(m_psh.hwndParent == NULL)
			m_psh.hwndParent = hWndParent;
		m_psh.phpage = (HPROPSHEETPAGE*)m_arrPages.GetData();
		m_psh.nPages = m_arrPages.GetSize();

		_Module.AddCreateWndData(&m_thunk.cd, (CPropertySheetImpl< T, TBase >*)this);

		HWND hWnd = (HWND)::PropertySheet(&m_psh);

		ATLASSERT(m_hWnd == hWnd);

		return hWnd;
	}

	INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow())
	{
		ATLASSERT(m_hWnd == NULL);

		m_psh.dwFlags &= ~PSH_MODELESS;
		if(m_psh.hwndParent == NULL)
			m_psh.hwndParent = hWndParent;
		m_psh.phpage = (HPROPSHEETPAGE*)m_arrPages.GetData();
		m_psh.nPages = m_arrPages.GetSize();

		_Module.AddCreateWndData(&m_thunk.cd, (CPropertySheetImpl< T, TBase >*)this);

		return ::PropertySheet(&m_psh);
	}

// Attributes (extended overrides of client class methods)
// These now can be called before the sheet is created
// Note: Calling these after the sheet is created gives unpredictable results
	int GetPageCount() const
	{
		if(m_hWnd == NULL)	// not created yet
			return m_arrPages.GetSize();
		return TBase::GetPageCount();
	}
	int GetActiveIndex() const
	{
		if(m_hWnd == NULL)	// not created yet
			return m_psh.nStartPage;
		return TBase::GetActiveIndex();
	}
	HPROPSHEETPAGE GetPage(int nPageIndex) const
	{
		ATLASSERT(m_hWnd == NULL);	// can't do this after it's created
		return (HPROPSHEETPAGE)m_arrPages[nPageIndex];
	}
	int GetPageIndex(HPROPSHEETPAGE hPage) const
	{
		ATLASSERT(m_hWnd == NULL);	// can't do this after it's created
		return m_arrPages.Find((_HPROPSHEETPAGE_TYPE&)hPage);
	}
	BOOL SetActivePage(int nPageIndex)
	{
		if(m_hWnd == NULL)	// not created yet
		{
			ATLASSERT(nPageIndex >= 0 && nPageIndex < m_arrPages.GetSize());
			m_psh.nStartPage = nPageIndex;
			return TRUE;
		}
		return TBase::SetActivePage(nPageIndex);
	}
	BOOL SetActivePage(HPROPSHEETPAGE hPage)
	{
		ATLASSERT(hPage != NULL);
		if (m_hWnd == NULL)	// not created yet
		{
			int nPageIndex = GetPageIndex(hPage);
			if(nPageIndex == -1)
				return FALSE;

			return SetActivePage(nPageIndex);
		}
		return TBase::SetActivePage(hPage);

	}
	void SetTitle(LPCTSTR lpszText, UINT nStyle = 0)
	{
		ATLASSERT((nStyle & ~PSH_PROPTITLE) == 0); // only PSH_PROPTITLE is valid
		ATLASSERT(lpszText != NULL);

		if(m_hWnd == NULL)
		{
			// set internal state
			m_psh.pszCaption = lpszText;	// must exist until sheet is created
			m_psh.dwFlags &= ~PSH_PROPTITLE;
			m_psh.dwFlags |= nStyle;
		}
		else
		{
			// set external state
			TBase::SetTitle(lpszText, nStyle);
		}
	}
	void SetWizardMode()
	{
		m_psh.dwFlags |= PSH_WIZARD;
	}
	void EnableHelp()
	{
		m_psh.dwFlags |= PSH_HASHELP;
	}

// Operations
	BOOL AddPage(HPROPSHEETPAGE hPage)
	{
		ATLASSERT(hPage != NULL);
		BOOL bRet = TRUE;
		if(m_hWnd != NULL)
			TBase::AddPage(hPage);
		else	// sheet not created yet, use internal data
			bRet = m_arrPages.Add((_HPROPSHEETPAGE_TYPE&)hPage);
		return bRet;
	}
	BOOL AddPage(LPCPROPSHEETPAGE pPage)
	{
		ATLASSERT(pPage != NULL);
		HPROPSHEETPAGE hPage = ::CreatePropertySheetPage(pPage);
		if(hPage == NULL)
			return FALSE;
		BOOL bRet = AddPage(hPage);
		if(!bRet)
			::DestroyPropertySheetPage(hPage);
		return bRet;
	}
	BOOL RemovePage(HPROPSHEETPAGE hPage)
	{
		ATLASSERT(hPage != NULL);
		if (m_hWnd == NULL)		// not created yet
		{
			int nPage = GetPageIndex(hPage);
			if(nPage == -1)
				return FALSE;
			return RemovePage(nPage);
		}
		TBase::RemovePage(hPage);
		return TRUE;

	}
	BOOL RemovePage(int nPageIndex)
	{
		BOOL bRet = TRUE;
		if(m_hWnd != NULL)
			TBase::RemovePage(nPageIndex);
		else	// sheet not created yet, use internal data
			bRet = m_arrPages.RemoveAt(nPageIndex);
		return bRet;
	}

#if (_WIN32_IE >= 0x0400)
	void SetHeader(LPCTSTR szbmHeader)
	{
		ATLASSERT(m_hWnd == NULL);	// can't do this after it's created

		m_psh.dwFlags &= ~PSH_WIZARD;
		m_psh.dwFlags |= (PSH_HEADER | PSH_WIZARD97);
		m_psh.pszbmHeader = szbmHeader;
	}

	void SetHeader(HBITMAP hbmHeader)
	{
		ATLASSERT(m_hWnd == NULL);	// can't do this after it's created

		m_psh.dwFlags &= ~PSH_WIZARD;
		m_psh.dwFlags |= (PSH_HEADER | PSH_USEHBMHEADER | PSH_WIZARD97);
		m_psh.hbmHeader = hbmHeader;
	}

	void SetWatermark(LPCTSTR szbmWatermark, HPALETTE hplWatermark = NULL)
	{
		ATLASSERT(m_hWnd == NULL);	// can't do this after it's created

		m_psh.dwFlags &= ~PSH_WIZARD;
		m_psh.dwFlags |= PSH_WATERMARK | PSH_WIZARD97;
		m_psh.pszbmWatermark = szbmWatermark;

		if (hplWatermark != NULL)
		{
			m_psh.dwFlags |= PSH_USEHPLWATERMARK;
			m_psh.hplWatermark = hplWatermark;
		}
	}

	void SetWatermark(HBITMAP hbmWatermark, HPALETTE hplWatermark = NULL)
	{
		ATLASSERT(m_hWnd == NULL);	// can't do this after it's created

		m_psh.dwFlags &= ~PSH_WIZARD;
		m_psh.dwFlags |= (PSH_WATERMARK | PSH_USEHBMWATERMARK | PSH_WIZARD97);
		m_psh.hbmWatermark = hbmWatermark;

		if (hplWatermark != NULL)
		{
			m_psh.dwFlags |= PSH_USEHPLWATERMARK;
			m_psh.hplWatermark = hplWatermark;
		}
	}

	void StretchWatermark(bool bStretchWatermark)
	{
		ATLASSERT(m_hWnd == NULL);	// can't do this after it's created
		if (bStretchWatermark)
			m_psh.dwFlags |= PSH_STRETCHWATERMARK;
		else
			m_psh.dwFlags &= ~PSH_STRETCHWATERMARK;
	}
#endif

// Message map and handlers handlers
	typedef CPropertySheetImpl< T, TBase >	thisClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_COMMAND, OnCommand)
	END_MSG_MAP()

	LRESULT OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
	{
		LRESULT lRet = DefWindowProc(uMsg, wParam, lParam);
		if(HIWORD(wParam) == BN_CLICKED && (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) &&
		   ((m_psh.dwFlags & PSH_MODELESS) != 0) && (GetActivePage() == NULL))
			DestroyWindow();
		return lRet;
	}
};

// for non-customized sheets
class CPropertySheet : public CPropertySheetImpl<CPropertySheet>
{
public:
	CPropertySheet(_U_STRINGorID title = (LPCTSTR)NULL, UINT uStartPage = 0, HWND hWndParent = NULL)
		: CPropertySheetImpl<CPropertySheet>(title, uStartPage, hWndParent)
	{ }

	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_COMMAND, CPropertySheetImpl<CPropertySheet>::OnCommand)
	END_MSG_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CPropertyPageWindow - client side for a property page

class CPropertyPageWindow : public CWindow
{
public:
// Constructors
	CPropertyPageWindow(HWND hWnd = NULL) : CWindow(hWnd) { }

	CPropertyPageWindow& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

// Attributes
	CPropertySheetWindow GetPropertySheet() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CPropertySheetWindow(GetParent());
	}

// Operations
	BOOL Apply()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);
		return GetPropertySheet().Apply();
	}
	void CancelToClose()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);
		GetPropertySheet().CancelToClose();
	}
	void SetModified(BOOL bChanged = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);
		GetPropertySheet().SetModified(m_hWnd, bChanged);
	}
	LRESULT QuerySiblings(WPARAM wParam, LPARAM lParam)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);
		return GetPropertySheet().QuerySiblings(wParam, lParam);
	}
	void RebootSystem()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);
		GetPropertySheet().RebootSystem();
	}
	void RestartWindows()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);
		GetPropertySheet().RestartWindows();
	}
	void SetWizardButtons(DWORD dwFlags)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);
		GetPropertySheet().SetWizardButtons(dwFlags);
	}

// Implementation - overrides to prevent usage
	HWND Create(LPCTSTR, HWND, _U_RECT = NULL, LPCTSTR = NULL, DWORD = 0, DWORD = 0, _U_MENUorID = 0U, LPVOID = NULL)
	{
		ATLASSERT(FALSE);
		return NULL;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CPropertyPageImpl - implements a property page

template <class T, class TBase = CPropertyPageWindow>
class ATL_NO_VTABLE CPropertyPageImpl : public CDialogImplBaseT< TBase >
{
public:
	PROPSHEETPAGE m_psp;

	operator PROPSHEETPAGE*() { return &m_psp; }

// Construction
	CPropertyPageImpl(_U_STRINGorID title = (LPCTSTR)NULL)
	{
		// initialize PROPSHEETPAGE struct
		memset(&m_psp, 0, sizeof(PROPSHEETPAGE));
		m_psp.dwSize = sizeof(PROPSHEETPAGE);
		m_psp.dwFlags = PSP_USECALLBACK;
		m_psp.hInstance = _Module.GetResourceInstance();
		T* pT = static_cast<T*>(this);
		pT;	// avoid level 4 warning
		m_psp.pszTemplate = MAKEINTRESOURCE(pT->IDD);
		m_psp.pfnDlgProc = (DLGPROC)T::StartDialogProc;
		m_psp.pfnCallback = T::PropPageCallback;
		m_psp.lParam = (LPARAM)this;

		if(title.m_lpstr != NULL)
			SetTitle(title);
	}

	static UINT CALLBACK PropPageCallback(HWND hWnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
	{
		hWnd;	// avoid level 4 warning
		if(uMsg == PSPCB_CREATE)
		{
			ATLASSERT(hWnd == NULL);
			CDialogImplBaseT< TBase >* pPage = (CDialogImplBaseT< TBase >*)ppsp->lParam;
			_Module.AddCreateWndData(&pPage->m_thunk.cd, pPage);
		}

		return 1;
	}

	HPROPSHEETPAGE Create()
	{
		return ::CreatePropertySheetPage(&m_psp);
	}

// Attributes
	void SetTitle(_U_STRINGorID title)
	{
		m_psp.pszTitle = title.m_lpstr;
		m_psp.dwFlags |= PSP_USETITLE;
	}

// Operations
	void EnableHelp()
	{
		m_psp.dwFlags |= PSP_HASHELP;
	}

// Message map and handlers
	typedef CPropertyPageImpl< T, TBase >	thisClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
	END_MSG_MAP()

	LRESULT OnNotify(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		NMHDR* pNMHDR = (NMHDR*)lParam;

		// don't handle messages not from the page/sheet itself
		if(pNMHDR->hwndFrom != m_hWnd && pNMHDR->hwndFrom != ::GetParent(m_hWnd))
		{
			bHandled = FALSE;
			return 1;
		}

		T* pT = static_cast<T*>(this);
		LRESULT lResult = 0;
		switch(pNMHDR->code)
		{
		case PSN_SETACTIVE:
			lResult = pT->OnSetActive() ? 0 : -1;
			break;
		case PSN_KILLACTIVE:
			lResult = !pT->OnKillActive();
			break;
		case PSN_APPLY:
			lResult = pT->OnApply() ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
			break;
		case PSN_RESET:
			pT->OnReset();
			break;
		case PSN_QUERYCANCEL:
			lResult = !pT->OnQueryCancel();
			break;
		case PSN_WIZNEXT:
			lResult = pT->OnWizardNext();
			break;
		case PSN_WIZBACK:
			lResult = pT->OnWizardBack();
			break;
		case PSN_WIZFINISH:
			lResult = !pT->OnWizardFinish();
			break;
		case PSN_HELP:
			pT->OnHelp();
			break;
#if (_WIN32_IE >= 0x0400)
		case PSN_GETOBJECT:
			if(!pT->OnGetObject((LPNMOBJECTNOTIFY)lParam))
				bHandled = FALSE;
			break;
#endif //(_WIN32_IE >= 0x0400)
		default:
			bHandled = FALSE;	// not handled
		}

		return lResult;
	}

// Overridables
	BOOL OnSetActive()
	{
		return TRUE;
	}
	BOOL OnKillActive()
	{
		return TRUE;
	}
	BOOL OnApply()
	{
		return TRUE;
	}
	void OnReset()
	{
	}
	BOOL OnQueryCancel()
	{
		return TRUE;    // ok to cancel
	}
	int OnWizardBack()
	{
		// 0  = goto next page
		// -1 = prevent page change
		// >0 = jump to page by dlg ID
		return 0;
	}
	int OnWizardNext()
	{
		// 0  = goto next page
		// -1 = prevent page change
		// >0 = jump to page by dlg ID
		return 0;
	}
	BOOL OnWizardFinish()
	{
		return TRUE;
	}
	void OnHelp()
	{
	}
#if (_WIN32_IE >= 0x0400)
	BOOL OnGetObject(LPNMOBJECTNOTIFY /*lpObjectNotify*/)
	{
		return FALSE;	// not processed
	}
#endif //(_WIN32_IE >= 0x0400)
};

// for non-customized pages
template <WORD t_wDlgTemplateID>
class CPropertyPage : public CPropertyPageImpl<CPropertyPage<t_wDlgTemplateID> >
{
public:
	enum { IDD = t_wDlgTemplateID };

	CPropertyPage(_U_STRINGorID title = (LPCTSTR)NULL) : CPropertyPageImpl<CPropertyPage>(title)
	{ }

	DECLARE_EMPTY_MSG_MAP()
};

}; //namespace WTL

#endif // __ATLDLGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\atlframe.h ===
// WTL Version 3.0
// Copyright (C) 1997-1999 Microsoft Corporation
// All rights reserved.
//
// This file is a part of Windows Template Library.
// The code and information is provided "as-is" without
// warranty of any kind, either expressed or implied.

#ifndef __ATLFRAME_H__
#define __ATLFRAME_H__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLAPP_H__
	#error atlframe.h requires atlapp.h to be included first
#endif

#ifndef __ATLWIN_H__
	#error atlframe.h requires atlwin.h to be included first
#endif


namespace WTL
{

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

template <class T, class TBase = CWindow, class TWinTraits = CFrameWinTraits> class CFrameWindowImpl;
class CMDIWindow;
template <class T, class TBase = CMDIWindow, class TWinTraits = CFrameWinTraits> class CMDIFrameWindowImpl;
template <class T, class TBase = CMDIWindow, class TWinTraits = CMDIChildWinTraits> class CMDIChildWindowImpl;
template <class T> class COwnerDraw;
class CUpdateUIBase;
template <class T> class CUpdateUI;

/////////////////////////////////////////////////////////////////////////////
// CFrameWndClassInfo - Manages frame window Windows class information

class CFrameWndClassInfo
{
public:
	WNDCLASSEX m_wc;
	LPCTSTR m_lpszOrigName;
	WNDPROC pWndProc;
	LPCTSTR m_lpszCursorID;
	BOOL m_bSystemCursor;
	ATOM m_atom;
	TCHAR m_szAutoName[13];
	UINT m_uCommonResourceID;

	ATOM Register(WNDPROC* pProc)
	{
		if (m_atom == 0)
		{
			::EnterCriticalSection(&_Module.m_csWindowCreate);
			if(m_atom == 0)
			{
				HINSTANCE hInst = _Module.GetModuleInstance();
				if (m_lpszOrigName != NULL)
				{
					ATLASSERT(pProc != NULL);
					LPCTSTR lpsz = m_wc.lpszClassName;
					WNDPROC proc = m_wc.lpfnWndProc;

					WNDCLASSEX wc;
					wc.cbSize = sizeof(WNDCLASSEX);
					if(!::GetClassInfoEx(NULL, m_lpszOrigName, &wc))
					{
						::LeaveCriticalSection(&_Module.m_csWindowCreate);
						return 0;
					}
					memcpy(&m_wc, &wc, sizeof(WNDCLASSEX));
					pWndProc = m_wc.lpfnWndProc;
					m_wc.lpszClassName = lpsz;
					m_wc.lpfnWndProc = proc;
				}
				else
				{
					m_wc.hCursor = ::LoadCursor(m_bSystemCursor ? NULL : hInst,
						m_lpszCursorID);
				}

				m_wc.hInstance = hInst;
				m_wc.style &= ~CS_GLOBALCLASS;	// we don't register global classes
				if (m_wc.lpszClassName == NULL)
				{
#ifdef _WIN64
					wsprintf(m_szAutoName, _T("ATL:%p"), &m_wc);
#else
					wsprintf(m_szAutoName, _T("ATL:%8.8X"), (DWORD)&m_wc);
#endif
					m_wc.lpszClassName = m_szAutoName;
				}
				WNDCLASSEX wcTemp;
				memcpy(&wcTemp, &m_wc, sizeof(WNDCLASSEX));
				m_atom = (ATOM)::GetClassInfoEx(m_wc.hInstance, m_wc.lpszClassName, &wcTemp);

				if (m_atom == 0)
				{
					if(m_uCommonResourceID != 0)	// use it if not zero
					{
						m_wc.hIcon = (HICON)::LoadImage(_Module.GetResourceInstance(), MAKEINTRESOURCE(m_uCommonResourceID), IMAGE_ICON, 32, 32, LR_DEFAULTCOLOR);
						m_wc.hIconSm = (HICON)::LoadImage(_Module.GetResourceInstance(), MAKEINTRESOURCE(m_uCommonResourceID), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
					}
					m_atom = ::RegisterClassEx(&m_wc);
				}
			}
			::LeaveCriticalSection(&_Module.m_csWindowCreate);
		}

		if (m_lpszOrigName != NULL)
		{
			ATLASSERT(pProc != NULL);
			ATLASSERT(pWndProc != NULL);
			*pProc = pWndProc;
		}
		return m_atom;
	}
};

#define DECLARE_FRAME_WND_CLASS(WndClassName, uCommonResourceID) \
static CFrameWndClassInfo& GetWndClassInfo() \
{ \
	static CFrameWndClassInfo wc = \
	{ \
		{ sizeof(WNDCLASSEX), 0, StartWindowProc, \
		  0, 0, NULL, NULL, NULL, (HBRUSH)(COLOR_WINDOW + 1), NULL, WndClassName, NULL }, \
		NULL, NULL, IDC_ARROW, TRUE, 0, _T(""), uCommonResourceID \
	}; \
	return wc; \
}

#define DECLARE_FRAME_WND_CLASS_EX(WndClassName, uCommonResourceID, style, bkgnd) \
static CFrameWndClassInfo& GetWndClassInfo() \
{ \
	static CFrameWndClassInfo wc = \
	{ \
		{ sizeof(WNDCLASSEX), style, StartWindowProc, \
		  0, 0, NULL, NULL, NULL, (HBRUSH)(bkgnd + 1), NULL, WndClassName, NULL }, \
		NULL, NULL, IDC_ARROW, TRUE, 0, _T(""), uCommonResourceID \
	}; \
	return wc; \
}

#define DECLARE_FRAME_WND_SUPERCLASS(WndClassName, OrigWndClassName, uCommonResourceID) \
static CFrameWndClassInfo& GetWndClassInfo() \
{ \
	static CFrameWndClassInfo wc = \
	{ \
		{ sizeof(WNDCLASSEX), 0, StartWindowProc, \
		  0, 0, NULL, NULL, NULL, NULL, NULL, WndClassName, NULL }, \
		OrigWndClassName, NULL, NULL, TRUE, 0, _T(""), uCommonResourceID \
	}; \
	return wc; \
}


// Command Chaining Macros

#define CHAIN_COMMANDS(theChainClass) \
	{ \
		if(uMsg == WM_COMMAND && theChainClass::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) \
			return TRUE; \
	}

#define CHAIN_COMMANDS_MEMBER(theChainMember) \
	{ \
		if(uMsg == WM_COMMAND && theChainMember.ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) \
			return TRUE; \
	}

#define CHAIN_COMMANDS_ALT(theChainClass, msgMapID) \
	{ \
		if(uMsg == WM_COMMAND && theChainClass::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult, msgMapID)) \
			return TRUE; \
	}

#define CHAIN_COMMANDS_ALT_MEMBER(theChainMember, msgMapID) \
	{ \
		if(uMsg == WM_COMMAND && theChainMember.ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult, msgMapID)) \
			return TRUE; \
	}


// Client window command chaining macro
#define CHAIN_CLIENT_COMMANDS() \
	if(uMsg == WM_COMMAND && m_hWndClient != NULL) \
		::SendMessage(m_hWndClient, uMsg, wParam, lParam);

/////////////////////////////////////////////////////////////////////////////
// CFrameWindowImpl

// standard toolbar styles
#define ATL_SIMPLE_TOOLBAR_STYLE \
	(WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | TBSTYLE_TOOLTIPS)
// toolbar in a rebar pane
#define ATL_SIMPLE_TOOLBAR_PANE_STYLE \
	(WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | CCS_NODIVIDER | CCS_NORESIZE | CCS_NOPARENTALIGN | TBSTYLE_TOOLTIPS | TBSTYLE_FLAT)
// standard rebar styles
#if (_WIN32_IE >= 0x0400)
#define ATL_SIMPLE_REBAR_STYLE \
	(WS_CHILD | WS_VISIBLE | WS_BORDER | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | RBS_VARHEIGHT | RBS_BANDBORDERS | RBS_AUTOSIZE)
#else
#define ATL_SIMPLE_REBAR_STYLE \
	(WS_CHILD | WS_VISIBLE | WS_BORDER | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | RBS_VARHEIGHT | RBS_BANDBORDERS)
#endif //!(_WIN32_IE >= 0x0400)
// rebar without borders
#if (_WIN32_IE >= 0x0400)
#define ATL_SIMPLE_REBAR_NOBORDER_STYLE \
	(WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | RBS_VARHEIGHT | RBS_BANDBORDERS | RBS_AUTOSIZE | CCS_NODIVIDER)
#else
#define ATL_SIMPLE_REBAR_NOBORDER_STYLE \
	(WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | RBS_VARHEIGHT | RBS_BANDBORDERS | CCS_NODIVIDER)
#endif //!(_WIN32_IE >= 0x0400)

// command bar support
#ifndef __ATLCTRLW_H__

#define CBRM_GETCMDBAR			(WM_USER + 301) // return command bar HWND
#define CBRM_GETMENU			(WM_USER + 302)	// returns loaded or attached menu
#define CBRM_TRACKPOPUPMENU		(WM_USER + 303)	// displays a popup menu

// Menu animation flags
#ifndef TPM_VERPOSANIMATION
#define TPM_VERPOSANIMATION 0x1000L
#endif

struct _AtlFrameWnd_CmdBarPopupMenu
{
	int cbSize;
	HMENU hMenu;
	UINT uFlags;
	int x;
	int y;
	LPTPMPARAMS lptpm;
};

#define CBRPOPUPMENU _AtlFrameWnd_CmdBarPopupMenu

#endif //!__ATLCTRLW_H__


template <class TBase = CWindow, class TWinTraits = CFrameWinTraits>
class ATL_NO_VTABLE CFrameWindowImplBase : public CWindowImplBaseT< TBase, TWinTraits >
{
public:
	DECLARE_FRAME_WND_CLASS(NULL, 0)

// Data members
	HWND m_hWndToolBar;
	HWND m_hWndStatusBar;
	HWND m_hWndClient;

	HACCEL m_hAccel;

	struct _AtlToolBarData
	{
		WORD wVersion;
		WORD wWidth;
		WORD wHeight;
		WORD wItemCount;
		//WORD aItems[wItemCount]

		WORD* items()
			{ return (WORD*)(this+1); }
	};

#if (_WIN32_IE >= 0x0500)
	struct _ChevronMenuInfo
	{
		HMENU hMenu;
		LPNMREBARCHEVRON lpnm;
		bool bCmdBar;
	};
#endif //(_WIN32_IE >= 0x0500)

// Constructor
	CFrameWindowImplBase() : m_hWndToolBar(NULL), m_hWndStatusBar(NULL), m_hWndClient(NULL), m_hAccel(NULL)
	{ }

// Methods
#ifndef _ATL_TMP_IMPL2
	HWND Create(HWND hWndParent, _U_RECT rect, LPCTSTR szWindowName, DWORD dwStyle, DWORD dwExStyle, _U_MENUorID MenuOrID, ATOM atom, LPVOID lpCreateParam)
	{
		ATLASSERT(m_hWnd == NULL);

		if(atom == 0)
			return NULL;

		_Module.AddCreateWndData(&m_thunk.cd, this);

		if(MenuOrID.m_hMenu == NULL && (dwStyle & WS_CHILD))
			MenuOrID.m_hMenu = (HMENU)(UINT_PTR)this;
		if(rect.m_lpRect == NULL)
			rect.m_lpRect = &TBase::rcDefault;

		HWND hWnd = ::CreateWindowEx(dwExStyle, (LPCTSTR)(LONG_PTR)MAKELONG(atom, 0), szWindowName,
			dwStyle, rect.m_lpRect->left, rect.m_lpRect->top, rect.m_lpRect->right - rect.m_lpRect->left,
			rect.m_lpRect->bottom - rect.m_lpRect->top, hWndParent, MenuOrID.m_hMenu,
			_Module.GetModuleInstance(), lpCreateParam);

		ATLASSERT(m_hWnd == hWnd);

		return hWnd;
	}
#endif //!_ATL_TMP_IMPL2

	static HWND CreateSimpleToolBarCtrl(HWND hWndParent, UINT nResourceID, BOOL bInitialSeparator = FALSE, 
			DWORD dwStyle = ATL_SIMPLE_TOOLBAR_STYLE, UINT nID = ATL_IDW_TOOLBAR)
	{
		HINSTANCE hInst = _Module.GetResourceInstance();
		HRSRC hRsrc = ::FindResource(hInst, MAKEINTRESOURCE(nResourceID), RT_TOOLBAR);
		if (hRsrc == NULL)
			return NULL;

		HGLOBAL hGlobal = ::LoadResource(hInst, hRsrc);
		if (hGlobal == NULL)
			return NULL;

		_AtlToolBarData* pData = (_AtlToolBarData*)::LockResource(hGlobal);
		if (pData == NULL)
			return NULL;
		ATLASSERT(pData->wVersion == 1);

		WORD* pItems = pData->items();
		int nItems = pData->wItemCount + (bInitialSeparator ? 1 : 0);
		TBBUTTON* pTBBtn = (TBBUTTON*)_alloca(nItems * sizeof(TBBUTTON));

		// set initial separator (half width)
		if(bInitialSeparator)
		{
			pTBBtn[0].iBitmap = 4;
			pTBBtn[0].idCommand = 0;
			pTBBtn[0].fsState = 0;
			pTBBtn[0].fsStyle = TBSTYLE_SEP;
			pTBBtn[0].dwData = 0;
			pTBBtn[0].iString = 0;
		}

		int nBmp = 0;
		for(int i = 0, j = bInitialSeparator ? 1 : 0; i < pData->wItemCount; i++, j++)
		{
			if(pItems[i] != 0)
			{
				pTBBtn[j].iBitmap = nBmp++;
				pTBBtn[j].idCommand = pItems[i];
				pTBBtn[j].fsState = TBSTATE_ENABLED;
				pTBBtn[j].fsStyle = TBSTYLE_BUTTON;
				pTBBtn[j].dwData = 0;
				pTBBtn[j].iString = 0;
			}
			else
			{
				pTBBtn[j].iBitmap = 8;
				pTBBtn[j].idCommand = 0;
				pTBBtn[j].fsState = 0;
				pTBBtn[j].fsStyle = TBSTYLE_SEP;
				pTBBtn[j].dwData = 0;
				pTBBtn[j].iString = 0;
			}
		}

		HWND hWnd = ::CreateWindowEx(0, TOOLBARCLASSNAME, NULL, dwStyle, 0,0,100,100,
				hWndParent, (HMENU)LongToHandle(nID), _Module.GetModuleInstance(), NULL);

		::SendMessage(hWnd, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0L);

		TBADDBITMAP tbab;
		tbab.hInst = hInst;
		tbab.nID = nResourceID;
		::SendMessage(hWnd, TB_ADDBITMAP, nBmp, (LPARAM)&tbab);
		::SendMessage(hWnd, TB_ADDBUTTONS, nItems, (LPARAM)pTBBtn);
		::SendMessage(hWnd, TB_SETBITMAPSIZE, 0, MAKELONG(pData->wWidth, pData->wHeight));
		::SendMessage(hWnd, TB_SETBUTTONSIZE, 0, MAKELONG(pData->wWidth + 7, pData->wHeight + 7));

		return hWnd;
	}

	static HWND CreateSimpleReBarCtrl(HWND hWndParent, DWORD dwStyle = ATL_SIMPLE_REBAR_STYLE, UINT nID = ATL_IDW_TOOLBAR)
	{
		// Ensure style combinations for proper rebar painting
		if(dwStyle & CCS_NODIVIDER && dwStyle & WS_BORDER)
			dwStyle &= ~WS_BORDER;
		else if(!(dwStyle & WS_BORDER) && !(dwStyle & CCS_NODIVIDER))
			dwStyle |= CCS_NODIVIDER;

		// Create rebar window
		HWND hWndReBar = ::CreateWindowEx(0, REBARCLASSNAME, NULL, dwStyle, 0, 0, 100, 100, hWndParent, (HMENU)LongToHandle(nID), _Module.GetModuleInstance(), NULL);
		if(hWndReBar == NULL)
		{
			ATLTRACE2(atlTraceUI, 0, _T("Failed to create rebar.\n"));
			return NULL;
		}

		// Initialize and send the REBARINFO structure
		REBARINFO rbi;
		rbi.cbSize = sizeof(REBARINFO);
		rbi.fMask  = 0;
		if(!::SendMessage(hWndReBar, RB_SETBARINFO, 0, (LPARAM)&rbi))
		{
			ATLTRACE2(atlTraceUI, 0, _T("Failed to initialize rebar.\n"));
			::DestroyWindow(hWndReBar);
			return NULL;
		}

		return hWndReBar;
	}

	BOOL CreateSimpleReBar(DWORD dwStyle = ATL_SIMPLE_REBAR_STYLE, UINT nID = ATL_IDW_TOOLBAR)
	{
		ATLASSERT(!::IsWindow(m_hWndToolBar));
		m_hWndToolBar = CreateSimpleReBarCtrl(m_hWnd, dwStyle, nID);
		return (m_hWndToolBar != NULL);
	}

	static BOOL AddSimpleReBarBandCtrl(HWND hWndReBar, HWND hWndBand, int nID = 0, LPTSTR lpstrTitle = NULL, BOOL bNewRow = FALSE, int cxWidth = 0, BOOL bFullWidthAlways = FALSE)
	{
		ATLASSERT(::IsWindow(hWndReBar));	// must be already created
#ifdef _DEBUG
		// block - check if this is really a rebar
		{
			TCHAR lpszClassName[sizeof(REBARCLASSNAME)];
			::GetClassName(hWndReBar, lpszClassName, sizeof(REBARCLASSNAME));
			ATLASSERT(lstrcmp(lpszClassName, REBARCLASSNAME) == 0);
		}
#endif //_DEBUG
		ATLASSERT(::IsWindow(hWndBand));	// must be already created

		// Set band info structure
		REBARBANDINFO rbBand;
		rbBand.cbSize = sizeof(REBARBANDINFO);
#if (_WIN32_IE >= 0x0400)
		rbBand.fMask = RBBIM_CHILD | RBBIM_CHILDSIZE | RBBIM_STYLE | RBBIM_ID | RBBIM_SIZE | RBBIM_IDEALSIZE;
#else
		rbBand.fMask = RBBIM_CHILD | RBBIM_CHILDSIZE | RBBIM_STYLE | RBBIM_ID | RBBIM_SIZE;
#endif //!(_WIN32_IE >= 0x0400)
		if(lpstrTitle != NULL)
			rbBand.fMask |= RBBIM_TEXT;
#if (_WIN32_IE >= 0x0500)
		rbBand.fStyle = RBBS_CHILDEDGE | RBBS_USECHEVRON;
#else
		rbBand.fStyle = RBBS_CHILDEDGE;
#endif //!(_WIN32_IE >= 0x0500)
		if(bNewRow)
			rbBand.fStyle |= RBBS_BREAK;

		rbBand.lpText = lpstrTitle;
		rbBand.hwndChild = hWndBand;
		rbBand.wID = nID;

		// Calculate the size of the band
		BOOL bRet;
		RECT rcTmp;
		int nBtnCount = (int)::SendMessage(hWndBand, TB_BUTTONCOUNT, 0, 0L);
		if(nBtnCount > 0)
		{
			bRet = (BOOL)::SendMessage(hWndBand, TB_GETITEMRECT, nBtnCount - 1, (LPARAM)&rcTmp);
			ATLASSERT(bRet);
			rbBand.cx = (cxWidth != 0) ? cxWidth : rcTmp.right;
			rbBand.cyMinChild = rcTmp.bottom - rcTmp.top;
			if(bFullWidthAlways)
			{
				rbBand.cxMinChild = rbBand.cx;
			}
			else if(lpstrTitle == 0)
			{
				bRet = (BOOL)::SendMessage(hWndBand, TB_GETITEMRECT, 0, (LPARAM)&rcTmp);
				ATLASSERT(bRet);
				rbBand.cxMinChild = rcTmp.right;
			}
			else
			{
				rbBand.cxMinChild = 0;
			}
		}
		else	// no buttons, either not a toolbar or really has no buttons
		{
			bRet = ::GetWindowRect(hWndBand, &rcTmp);
			ATLASSERT(bRet);
			rbBand.cx = (cxWidth != 0) ? cxWidth : (rcTmp.right - rcTmp.left);
			rbBand.cxMinChild = (bFullWidthAlways) ? rbBand.cx : 0;
			rbBand.cyMinChild = rcTmp.bottom - rcTmp.top;
		}

#if (_WIN32_IE >= 0x0400)
		rbBand.cxIdeal = rbBand.cx;
#endif //(_WIN32_IE >= 0x0400)

		// Add the band
		LRESULT lRes = ::SendMessage(hWndReBar, RB_INSERTBAND, (WPARAM)-1, (LPARAM)&rbBand);
		if(lRes == 0)
		{
			ATLTRACE2(atlTraceUI, 0, _T("Failed to add a band to the rebar.\n"));
			return FALSE;
		}

#if (_WIN32_IE >= 0x0501)
		::SendMessage(hWndBand, TB_SETEXTENDEDSTYLE, 0, TBSTYLE_EX_HIDECLIPPEDBUTTONS);
#endif //(_WIN32_IE >= 0x0501)

		return TRUE;
	}

	BOOL AddSimpleReBarBand(HWND hWndBand, LPTSTR lpstrTitle = NULL, BOOL bNewRow = FALSE, int cxWidth = 0, BOOL bFullWidthAlways = FALSE)
	{
		ATLASSERT(::IsWindow(m_hWndToolBar));	// must be an existing rebar
		ATLASSERT(::IsWindow(hWndBand));	// must be created
		static int nID = ATL_IDW_BAND_FIRST;
		return AddSimpleReBarBandCtrl(m_hWndToolBar, hWndBand, nID++, lpstrTitle, bNewRow, cxWidth, bFullWidthAlways);
	}

#if (_WIN32_IE >= 0x0400)
	void SizeSimpleReBarBands()
	{
		ATLASSERT(::IsWindow(m_hWndToolBar));	// must be an existing rebar

		int nCount = (int)::SendMessage(m_hWndToolBar, RB_GETBANDCOUNT, 0, 0L);

		for(int i = 0; i < nCount; i++)
		{
			REBARBANDINFO rbBand;
			rbBand.cbSize = sizeof(REBARBANDINFO);
			rbBand.fMask = RBBIM_SIZE;
			BOOL bRet = (BOOL)::SendMessage(m_hWndToolBar, RB_GETBANDINFO, i, (LPARAM)&rbBand);
			ATLASSERT(bRet);
			RECT rect = { 0, 0, 0, 0 };
			::SendMessage(m_hWndToolBar, RB_GETBANDBORDERS, i, (LPARAM)&rect);
			rbBand.cx += rect.left + rect.right;
			bRet = (BOOL)::SendMessage(m_hWndToolBar, RB_SETBANDINFO, i, (LPARAM)&rbBand);
			ATLASSERT(bRet);
		}
	}
#endif //(_WIN32_IE >= 0x0400)

	BOOL CreateSimpleStatusBar(LPCTSTR lpstrText, DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | SBARS_SIZEGRIP, UINT nID = ATL_IDW_STATUS_BAR)
	{
		ATLASSERT(!::IsWindow(m_hWndStatusBar));
		m_hWndStatusBar = ::CreateStatusWindow(dwStyle, lpstrText, m_hWnd, nID);
		return (m_hWndStatusBar != NULL);
	}

	BOOL CreateSimpleStatusBar(UINT nTextID = ATL_IDS_IDLEMESSAGE, DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | SBARS_SIZEGRIP, UINT nID = ATL_IDW_STATUS_BAR)
	{
		TCHAR szText[128];	// max text lentgth is 127 for status bars
		szText[0] = 0;
		::LoadString(_Module.GetResourceInstance(), nTextID, szText, 128);
		return CreateSimpleStatusBar(szText, dwStyle, nID);
	}

	void UpdateLayout(BOOL bResizeBars = TRUE)
	{
		RECT rect;
		GetClientRect(&rect);

		// position bars and offset their dimensions
		UpdateBarsPosition(rect, bResizeBars);

		// resize client window
		if(m_hWndClient != NULL)
			::SetWindowPos(m_hWndClient, NULL, rect.left, rect.top,
				rect.right - rect.left, rect.bottom - rect.top,
				SWP_NOZORDER | SWP_NOACTIVATE);
	}

	void UpdateBarsPosition(RECT& rect, BOOL bResizeBars = TRUE)
	{
		// resize toolbar
		if(m_hWndToolBar != NULL && ((DWORD)::GetWindowLong(m_hWndToolBar, GWL_STYLE) & WS_VISIBLE))
		{
			if(bResizeBars)
				::SendMessage(m_hWndToolBar, WM_SIZE, 0, 0);
			RECT rectTB;
			::GetWindowRect(m_hWndToolBar, &rectTB);
			rect.top += rectTB.bottom - rectTB.top;
		}

		// resize status bar
		if(m_hWndStatusBar != NULL && ((DWORD)::GetWindowLong(m_hWndStatusBar, GWL_STYLE) & WS_VISIBLE))
		{
			if(bResizeBars)
				::SendMessage(m_hWndStatusBar, WM_SIZE, 0, 0);
			RECT rectSB;
			::GetWindowRect(m_hWndStatusBar, &rectSB);
			rect.bottom -= rectSB.bottom - rectSB.top;
		}
	}

	BOOL PreTranslateMessage(MSG* pMsg)
	{
		if(m_hAccel != NULL && ::TranslateAccelerator(m_hWnd, m_hAccel, pMsg))
			return TRUE;
		return FALSE;
	}

	typedef CFrameWindowImplBase< TBase, TWinTraits >	thisClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBackground)
		MESSAGE_HANDLER(WM_MENUSELECT, OnMenuSelect)
		MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
		MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
		NOTIFY_CODE_HANDLER(TTN_GETDISPINFOA, OnToolTipTextA)
		NOTIFY_CODE_HANDLER(TTN_GETDISPINFOW, OnToolTipTextW)
	END_MSG_MAP()

	LRESULT OnEraseBackground(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		if(m_hWndClient != NULL)	// view will paint itself instead
			return 1;

		bHandled = FALSE;
		return 0;
	}

	LRESULT OnMenuSelect(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		bHandled = FALSE;

		if(m_hWndStatusBar == NULL)
			return 1;

		WORD wFlags = HIWORD(wParam);
		if(wFlags == 0xFFFF && lParam == NULL)	// menu closing
			::SendMessage(m_hWndStatusBar, SB_SIMPLE, FALSE, 0L);
		else
		{
			TCHAR szBuff[256];
			szBuff[0] = 0;
			if(!(wFlags & MF_POPUP))
			{
				WORD wID = LOWORD(wParam);
				// check for special cases
				if(wID >= 0xF000 && wID < 0xF1F0)				// system menu IDs
					wID = (WORD)(((wID - 0xF000) >> 4) + ATL_IDS_SCFIRST);
				else if(wID >= ID_FILE_MRU_FIRST && wID <= ID_FILE_MRU_LAST)	// MRU items
					wID = ATL_IDS_MRU_FILE;
				else if(wID >= ATL_IDM_FIRST_MDICHILD)				// MDI child windows
					wID = ATL_IDS_MDICHILD;

				int nRet = ::LoadString(_Module.GetResourceInstance(), wID, szBuff, 256);
				for(int i = 0; i < nRet; i++)
				{
					if(szBuff[i] == _T('\n'))
					{
						szBuff[i] = 0;
						break;
					}
				}
			}
			::SendMessage(m_hWndStatusBar, SB_SIMPLE, TRUE, 0L);
			::SendMessage(m_hWndStatusBar, SB_SETTEXT, (255 | SBT_NOBORDERS), (LPARAM)szBuff);
		}

		return 1;
	}

	LRESULT OnSetFocus(UINT, WPARAM, LPARAM, BOOL& bHandled)
	{
		if(m_hWndClient != NULL && ::IsWindowVisible(m_hWndClient))
			::SetFocus(m_hWndClient);

		bHandled = FALSE;
		return 1;
	}

	LRESULT OnDestroy(UINT, WPARAM, LPARAM, BOOL& bHandled)
	{
		if((GetStyle() & (WS_CHILD | WS_POPUP)) == 0)
			::PostQuitMessage(1);

		bHandled = FALSE;
		return 1;
	}

	LRESULT OnToolTipTextA(int idCtrl, LPNMHDR pnmh, BOOL& /*bHandled*/)
	{
		LPNMTTDISPINFOA pDispInfo = (LPNMTTDISPINFOA)pnmh;
		pDispInfo->szText[0] = 0;

		if((idCtrl != 0) && !(pDispInfo->uFlags & TTF_IDISHWND))
		{
			char szBuff[256];
			szBuff[0] = 0;
			int nRet = ::LoadStringA(_Module.GetResourceInstance(), idCtrl, szBuff, 256);
			for(int i = 0; i < nRet; i++)
			{
				if(szBuff[i] == '\n')
				{
					lstrcpynA(pDispInfo->szText, &szBuff[i + 1], sizeof(pDispInfo->szText) / sizeof(pDispInfo->szText[0]));
					break;
				}
			}
#if (_WIN32_IE >= 0x0300)
			pDispInfo->uFlags |= TTF_DI_SETITEM;
#endif //(_WIN32_IE >= 0x0300)
		}

		return 0;
	}

	LRESULT OnToolTipTextW(int idCtrl, LPNMHDR pnmh, BOOL& /*bHandled*/)
	{
		LPNMTTDISPINFOW pDispInfo = (LPNMTTDISPINFOW)pnmh;
		pDispInfo->szText[0] = 0;

		if((idCtrl != 0) && !(pDispInfo->uFlags & TTF_IDISHWND))
		{
			wchar_t szBuff[256];
			szBuff[0] = 0;
			int nRet = ::LoadStringW(_Module.GetResourceInstance(), idCtrl, szBuff, 256);
			for(int i = 0; i < nRet; i++)
			{
				if(szBuff[i] == L'\n')
				{
					lstrcpynW(pDispInfo->szText, &szBuff[i + 1], sizeof(pDispInfo->szText) / sizeof(pDispInfo->szText[0]));
					break;
				}
			}
#if (_WIN32_IE >= 0x0300)
			pDispInfo->uFlags |= TTF_DI_SETITEM;
#endif //(_WIN32_IE >= 0x0300)
		}

		return 0;
	}

#if (_WIN32_IE >= 0x0500)
	bool PrepareChevronMenu(_ChevronMenuInfo& cmi)
	{
		// get rebar and toolbar
		REBARBANDINFO rbbi;
		rbbi.cbSize = sizeof(REBARBANDINFO);
		rbbi.fMask = RBBIM_CHILD;
		BOOL bRet = (BOOL)::SendMessage(cmi.lpnm->hdr.hwndFrom, RB_GETBANDINFO, cmi.lpnm->uBand, (LPARAM)&rbbi);
		ATLASSERT(bRet);

		// assume the band is a toolbar
		CWindow wnd = rbbi.hwndChild;
		int nCount = (int)wnd.SendMessage(TB_BUTTONCOUNT);
		if(nCount <= 0)		// probably not a toolbar
			return false;

		// check if it's a command bar
		CMenuHandle menuCmdBar = (HMENU)wnd.SendMessage(CBRM_GETMENU);
		cmi.bCmdBar = (menuCmdBar.m_hMenu != NULL);

		// build a menu from hidden items
		CMenuHandle menu;
		bRet = menu.CreatePopupMenu();
		ATLASSERT(bRet);
		RECT rcClient;
		bRet = wnd.GetClientRect(&rcClient);
		ATLASSERT(bRet);
		for(int i = 0; i < nCount; i++)
		{
			TBBUTTON tbb;
			bRet = (BOOL)wnd.SendMessage(TB_GETBUTTON, i, (LPARAM)&tbb);
			ATLASSERT(bRet);
			RECT rcButton;
			bRet = (BOOL)wnd.SendMessage(TB_GETITEMRECT, i, (LPARAM)&rcButton);
			ATLASSERT(bRet);
			if(rcButton.right > rcClient.right)
			{
				if(tbb.fsStyle & BTNS_SEP)
				{
					if(menu.GetMenuItemCount() > 0)
						menu.AppendMenu(MF_SEPARATOR);
				}
				else if(cmi.bCmdBar)
				{
					TCHAR szBuff[100];
					CMenuItemInfo mii;
					mii.fMask = MIIM_TYPE | MIIM_SUBMENU;
					mii.dwTypeData = szBuff;
					mii.cch = sizeof(szBuff) / sizeof(TCHAR);
					bRet = menuCmdBar.GetMenuItemInfo(i, TRUE, &mii);
					ATLASSERT(bRet);
					// Note: CmdBar currently supports enabled and drop-down only
					ATLASSERT(::IsMenu(mii.hSubMenu));
					bRet = menu.AppendMenu(MF_STRING | MF_POPUP, (UINT)mii.hSubMenu, mii.dwTypeData);
					ATLASSERT(bRet);
				}
				else
				{
					// get button's text
					TCHAR szBuff[100];
					LPTSTR lpstrText = szBuff;
					if(wnd.SendMessage(TB_GETBUTTONTEXT, tbb.idCommand, (LPARAM)szBuff) == -1)
					{
						// no text for this button, try a resource string
						lpstrText = _T("?");
						::LoadString(_Module.GetResourceInstance(), tbb.idCommand, szBuff, sizeof(szBuff) / sizeof(TCHAR));
						for(int n = 0; n < lstrlen(szBuff); n++)
						{
							if(szBuff[n] == _T('\n'))
							{
								lpstrText = &szBuff[n + 1];
								break;
							}
						}
					}
					// Note: no checks for disabled buttons
					bRet = menu.AppendMenu(MF_STRING, tbb.idCommand, lpstrText);
					ATLASSERT(bRet);
				}
			}
		}

		if(menu.GetMenuItemCount() == 0)	// no hidden buttons after all
		{
			menu.DestroyMenu();
			::MessageBeep((UINT)-1);
			return false;
		}

		cmi.hMenu = menu;
		return true;
	}

	void DisplayChevronMenu(_ChevronMenuInfo& cmi)
	{
		// convert chevron rect to screen coordinates
		CWindow wndFrom = cmi.lpnm->hdr.hwndFrom;
		RECT rc = cmi.lpnm->rc;
		wndFrom.ClientToScreen(&rc);
		// set up flags and rect
		UINT uMenuFlags = TPM_LEFTBUTTON | TPM_VERTICAL | TPM_LEFTALIGN | TPM_TOPALIGN | (!AtlIsOldWindows() ? TPM_VERPOSANIMATION : 0);
		TPMPARAMS TPMParams;
		TPMParams.cbSize = sizeof(TPMPARAMS);
		TPMParams.rcExclude = rc;
		// check if this window has a command bar
		HWND hWndCmdBar = (HWND)::SendMessage(m_hWnd, CBRM_GETCMDBAR, 0, 0L);
		if(::IsWindow(hWndCmdBar))
		{
			CBRPOPUPMENU CBRPopupMenu = { sizeof(CBRPOPUPMENU), cmi.hMenu, uMenuFlags, rc.left, rc.bottom, &TPMParams };
			::SendMessage(hWndCmdBar, CBRM_TRACKPOPUPMENU, 0, (LPARAM)&CBRPopupMenu);
		}
		else
		{
			::TrackPopupMenuEx(cmi.hMenu, uMenuFlags, rc.left, rc.bottom, m_hWnd, &TPMParams);
		}
	}

	void CleanupChevronMenu(_ChevronMenuInfo& cmi)
	{
		CMenuHandle menu = cmi.hMenu;
		// if menu is from a command bar, detach submenus so they are not destroyed
		if(cmi.bCmdBar)
		{
			for(int i = menu.GetMenuItemCount() - 1; i >=0; i--)
				menu.RemoveMenu(i, MF_BYPOSITION);
		}
		// destroy menu
		menu.DestroyMenu();
		// convert chevron rect to screen coordinates
		CWindow wndFrom = cmi.lpnm->hdr.hwndFrom;
		RECT rc = cmi.lpnm->rc;
		wndFrom.ClientToScreen(&rc);
		// eat next message if click is on the same button
		MSG msg;
		if(::PeekMessage(&msg, m_hWnd, NULL, NULL, PM_NOREMOVE))
		{
			if(msg.message == WM_LBUTTONDOWN && ::PtInRect(&rc, msg.pt))
				::PeekMessage(&msg, m_hWnd, WM_LBUTTONDOWN, WM_LBUTTONDOWN, PM_REMOVE);
		}
	}
#endif //(_WIN32_IE >= 0x0500)
};


template <class T, class TBase = CWindow, class TWinTraits = CFrameWinTraits>
class ATL_NO_VTABLE CFrameWindowImpl : public CFrameWindowImplBase< TBase, TWinTraits >
{
public:
	HWND Create(HWND hWndParent = NULL, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
	{
		ATOM atom = T::GetWndClassInfo().Register(&m_pfnSuperWindowProc);

		dwStyle = T::GetWndStyle(dwStyle);
		dwExStyle = T::GetWndExStyle(dwExStyle);

		if(rect.m_lpRect == NULL)
			rect.m_lpRect = &TBase::rcDefault;

		return CFrameWindowImplBase< TBase, TWinTraits >::Create(hWndParent, rect, szWindowName, dwStyle, dwExStyle, hMenu, atom, lpCreateParam);
	}

	HWND CreateEx(HWND hWndParent = NULL, _U_RECT rect = NULL, DWORD dwStyle = 0, DWORD dwExStyle = 0, LPVOID lpCreateParam = NULL)
	{
		TCHAR szWindowName[256];
		szWindowName[0] = 0;
		::LoadString(_Module.GetResourceInstance(), T::GetWndClassInfo().m_uCommonResourceID, szWindowName, 256);

		HMENU hMenu = ::LoadMenu(_Module.GetResourceInstance(), MAKEINTRESOURCE(T::GetWndClassInfo().m_uCommonResourceID));

		T* pT = static_cast<T*>(this);
		HWND hWnd = pT->Create(hWndParent, rect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);

		if(hWnd != NULL)
			m_hAccel = ::LoadAccelerators(_Module.GetResourceInstance(), MAKEINTRESOURCE(T::GetWndClassInfo().m_uCommonResourceID));

		return hWnd;
	}

	BOOL CreateSimpleToolBar(UINT nResourceID = 0, DWORD dwStyle = ATL_SIMPLE_TOOLBAR_STYLE, UINT nID = ATL_IDW_TOOLBAR)
	{
		ATLASSERT(!::IsWindow(m_hWndToolBar));
		if(nResourceID == 0)
			nResourceID = T::GetWndClassInfo().m_uCommonResourceID;
		m_hWndToolBar = T::CreateSimpleToolBarCtrl(m_hWnd, nResourceID, TRUE, dwStyle, nID);
		return (m_hWndToolBar != NULL);
	}

// message map and handlers
	typedef CFrameWindowImpl< T, TBase, TWinTraits >	thisClass;
	typedef CFrameWindowImplBase< TBase, TWinTraits >	baseClass;

	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_SIZE, OnSize)
#ifndef _ATL_NO_REBAR_SUPPORT
#if (_WIN32_IE >= 0x0400)
		NOTIFY_CODE_HANDLER(RBN_AUTOSIZE, OnReBarAutoSize)
#endif //(_WIN32_IE >= 0x0400)
#if (_WIN32_IE >= 0x0500)
		NOTIFY_CODE_HANDLER(RBN_CHEVRONPUSHED, OnChevronPushed)
#endif //(_WIN32_IE >= 0x0500)
#endif //!_ATL_NO_REBAR_SUPPORT
		CHAIN_MSG_MAP(baseClass)
	END_MSG_MAP()

	LRESULT OnSize(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
		if(wParam != SIZE_MINIMIZED)
		{
			T* pT = static_cast<T*>(this);
			pT->UpdateLayout();
		}
		bHandled = FALSE;
		return 1;
	}

#ifndef _ATL_NO_REBAR_SUPPORT
#if (_WIN32_IE >= 0x0400)
	LRESULT OnReBarAutoSize(int /*idCtrl*/, LPNMHDR /*pnmh*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		pT->UpdateLayout(FALSE);
		return 0;
	}
#endif //(_WIN32_IE >= 0x0400)

#if (_WIN32_IE >= 0x0500)
	LRESULT OnChevronPushed(int /*idCtrl*/, LPNMHDR pnmh, BOOL& bHandled)
	{
		T* pT = static_cast<T*>(this);
		_ChevronMenuInfo cmi = { NULL, (LPNMREBARCHEVRON)pnmh, false };
		if(!pT->PrepareChevronMenu(cmi))
		{
			bHandled = FALSE;
			return 1;
		}
		// display a popup menu with hidden items
		pT->DisplayChevronMenu(cmi);
		// cleanup
		pT->CleanupChevronMenu(cmi);
		return 0;
	}
#endif //(_WIN32_IE >= 0x0500)
#endif //!_ATL_NO_REBAR_SUPPORT
};


/////////////////////////////////////////////////////////////////////////////
// CMDIWindow

class CMDIWindow : public CWindow
{
public:
// Data members
	HWND m_hWndMDIClient;
	HMENU m_hMenu;

// Constructors
	CMDIWindow(HWND hWnd = NULL) : CWindow(hWnd), m_hWndMDIClient(NULL), m_hMenu(NULL) { }

	CMDIWindow& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

// Operations
	HWND MDIGetActive(BOOL* lpbMaximized = NULL)
	{
		ATLASSERT(::IsWindow(m_hWndMDIClient));
		return (HWND)::SendMessage(m_hWndMDIClient, WM_MDIGETACTIVE, 0, (LPARAM)lpbMaximized);
	}

	void MDIActivate(HWND hWndChildToActivate)
	{
		ATLASSERT(::IsWindow(m_hWndMDIClient));
		ATLASSERT(::IsWindow(hWndChildToActivate));
		::SendMessage(m_hWndMDIClient, WM_MDIACTIVATE, (WPARAM)hWndChildToActivate, 0);
	}

	void MDINext(HWND hWndChild, BOOL bPrevious = FALSE)
	{
		ATLASSERT(::IsWindow(m_hWndMDIClient));
		ATLASSERT(hWndChild == NULL || ::IsWindow(hWndChild));
		::SendMessage(m_hWndMDIClient, WM_MDINEXT, (WPARAM)hWndChild, (LPARAM)bPrevious);
	}

	void MDIMaximize(HWND hWndChildToMaximize)
	{
		ATLASSERT(::IsWindow(m_hWndMDIClient));
		ATLASSERT(::IsWindow(hWndChildToMaximize));
		::SendMessage(m_hWndMDIClient, WM_MDIMAXIMIZE, (WPARAM)hWndChildToMaximize, 0);
	}

	void MDIRestore(HWND hWndChildToRestore)
	{
		ATLASSERT(::IsWindow(m_hWndMDIClient));
		ATLASSERT(::IsWindow(hWndChildToRestore));
		::SendMessage(m_hWndMDIClient, WM_MDIICONARRANGE, (WPARAM)hWndChildToRestore, 0);
	}

	void MDIDestroy(HWND hWndChildToDestroy)
	{
		ATLASSERT(::IsWindow(m_hWndMDIClient));
		ATLASSERT(::IsWindow(hWndChildToDestroy));
		::SendMessage(m_hWndMDIClient, WM_MDIDESTROY, (WPARAM)hWndChildToDestroy, 0);
	}

	BOOL MDICascade(UINT uFlags = 0)
	{
		ATLASSERT(::IsWindow(m_hWndMDIClient));
		return (BOOL)::SendMessage(m_hWndMDIClient, WM_MDICASCADE, (WPARAM)uFlags, 0);
	}

	BOOL MDITile(UINT uFlags = MDITILE_HORIZONTAL)
	{
		ATLASSERT(::IsWindow(m_hWndMDIClient));
		return (BOOL)::SendMessage(m_hWndMDIClient, WM_MDITILE, (WPARAM)uFlags, 0);
	}
	void MDIIconArrange()
	{
		ATLASSERT(::IsWindow(m_hWndMDIClient));
		::SendMessage(m_hWndMDIClient, WM_MDIICONARRANGE, 0, 0);
	}

	HMENU MDISetMenu(HMENU hMenuFrame, HMENU hMenuWindow)
	{
		ATLASSERT(::IsWindow(m_hWndMDIClient));
		return (HMENU)::SendMessage(m_hWndMDIClient, WM_MDISETMENU, (WPARAM)hMenuFrame, (LPARAM)hMenuWindow);
	}

	HMENU MDIRefreshMenu()
	{
		ATLASSERT(::IsWindow(m_hWndMDIClient));
		return (HMENU)::SendMessage(m_hWndMDIClient, WM_MDIREFRESHMENU, 0, 0);
	}

// Additional operations
	static HMENU GetStandardWindowMenu(HMENU hMenu)
	{
		int nCount = ::GetMenuItemCount(hMenu);
		if(nCount == -1)
			return NULL;
		int nLen = ::GetMenuString(hMenu, nCount - 2, NULL, 0, MF_BYPOSITION);
		if(nLen == 0)
			return NULL;
		LPTSTR lpszText = (LPTSTR)_alloca((nLen + 1) * sizeof(TCHAR));
		if(::GetMenuString(hMenu, nCount - 2, lpszText, nLen + 1, MF_BYPOSITION) != nLen)
			return NULL;
		if(lstrcmp(lpszText, _T("&Window")))
			return NULL;
		return ::GetSubMenu(hMenu, nCount - 2);
	}

	void SetMDIFrameMenu()
	{
		HMENU hWindowMenu = GetStandardWindowMenu(m_hMenu);
		MDISetMenu(m_hMenu, hWindowMenu);
		MDIRefreshMenu();
		::DrawMenuBar(GetMDIFrame());
	}

	HWND GetMDIFrame() const
	{
		return ::GetParent(m_hWndMDIClient);
	}
};


/////////////////////////////////////////////////////////////////////////////
// CMDIFrameWindowImpl

// MDI child command chaining macro
#define CHAIN_MDI_CHILD_COMMANDS() \
	if(uMsg == WM_COMMAND) \
	{ \
		HWND hWndChild = MDIGetActive(); \
		if(hWndChild != NULL) \
			::SendMessage(hWndChild, uMsg, wParam, lParam); \
	}


template <class T, class TBase = CMDIWindow, class TWinTraits = CFrameWinTraits>
class ATL_NO_VTABLE CMDIFrameWindowImpl : public CFrameWindowImplBase<TBase, TWinTraits >
{
public:
	HWND Create(HWND hWndParent = NULL, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
	{
		m_hMenu = hMenu;
		ATOM atom = T::GetWndClassInfo().Register(&m_pfnSuperWindowProc);

		dwStyle = T::GetWndStyle(dwStyle);
		dwExStyle = T::GetWndExStyle(dwExStyle);

		if(rect.m_lpRect == NULL)
			rect.m_lpRect = &TBase::rcDefault;

		return CFrameWindowImplBase<TBase, TWinTraits >::Create(hWndParent, rect, szWindowName, dwStyle, dwExStyle, hMenu, atom, lpCreateParam);
	}

	HWND CreateEx(HWND hWndParent = NULL, _U_RECT rect = NULL, DWORD dwStyle = 0, DWORD dwExStyle = 0, LPVOID lpCreateParam = NULL)
	{
		TCHAR szWindowName[256];
		szWindowName[0] = 0;
		::LoadString(_Module.GetResourceInstance(), T::GetWndClassInfo().m_uCommonResourceID, szWindowName, 256);

		HMENU hMenu = ::LoadMenu(_Module.GetResourceInstance(), MAKEINTRESOURCE(T::GetWndClassInfo().m_uCommonResourceID));

		T* pT = static_cast<T*>(this);
		HWND hWnd = pT->Create(hWndParent, rect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);

		if(hWnd != NULL)
			m_hAccel = ::LoadAccelerators(_Module.GetResourceInstance(), MAKEINTRESOURCE(T::GetWndClassInfo().m_uCommonResourceID));

		return hWnd;
	}

	BOOL CreateSimpleToolBar(UINT nResourceID = 0, DWORD dwStyle = ATL_SIMPLE_TOOLBAR_STYLE, UINT nID = ATL_IDW_TOOLBAR)
	{
		ATLASSERT(!::IsWindow(m_hWndToolBar));
		if(nResourceID == 0)
			nResourceID = T::GetWndClassInfo().m_uCommonResourceID;
		m_hWndToolBar = T::CreateSimpleToolBarCtrl(m_hWnd, nResourceID, TRUE, dwStyle, nID);
		return (m_hWndToolBar != NULL);
	}

	virtual WNDPROC GetWindowProc()
	{
		return MDIFrameWindowProc;
	}

	static LRESULT CALLBACK MDIFrameWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		CMDIFrameWindowImpl< T, TBase, TWinTraits >* pThis = (CMDIFrameWindowImpl< T, TBase, TWinTraits >*)hWnd;
		// set a ptr to this message and save the old value
#if defined(_ATL_TMP_IMPL1) || defined(_ATL_TMP_IMPL2)
		_ATL_MSG msg(pThis->m_hWnd, uMsg, wParam, lParam);
		const _ATL_MSG* pOldMsg = pThis->m_pCurrentMsg;
#else
		MSG msg = { pThis->m_hWnd, uMsg, wParam, lParam, 0, { 0, 0 } };
		const MSG* pOldMsg = pThis->m_pCurrentMsg;
#endif
		pThis->m_pCurrentMsg = &msg;
		// pass to the message map to process
		LRESULT lRes;
		BOOL bRet = pThis->ProcessWindowMessage(pThis->m_hWnd, uMsg, wParam, lParam, lRes, 0);
		// restore saved value for the current message
		ATLASSERT(pThis->m_pCurrentMsg == &msg);
		pThis->m_pCurrentMsg = pOldMsg;
		// do the default processing if message was not handled
		if(!bRet)
		{
			if(uMsg != WM_NCDESTROY)
				lRes = pThis->DefWindowProc(uMsg, wParam, lParam);
			else
			{
				// unsubclass, if needed
				LONG_PTR pfnWndProc = ::GetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC);
				lRes = pThis->DefWindowProc(uMsg, wParam, lParam);
				if(pThis->m_pfnSuperWindowProc != ::DefWindowProc && ::GetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC) == pfnWndProc)
					::SetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC, (LONG_PTR)pThis->m_pfnSuperWindowProc);
#ifdef _ATL_TMP_IMPL2
				// mark window as destryed
				pThis->m_dwState |= WINSTATE_DESTROYED;
#else
				// clear out window handle
				HWND hWnd = pThis->m_hWnd;
				pThis->m_hWnd = NULL;
				// clean up after window is destroyed
				pThis->OnFinalMessage(hWnd);
#endif
			}
		}
#ifdef _ATL_TMP_IMPL2
		if(pThis->m_dwState & WINSTATE_DESTROYED && pThis->m_pCurrentMsg == NULL)
		{
			// clear out window handle
			HWND hWnd = pThis->m_hWnd;
			pThis->m_hWnd = NULL;
			pThis->m_dwState &= ~WINSTATE_DESTROYED;
			// clean up after window is destroyed
			pThis->OnFinalMessage(hWnd);
		}
#endif
		return lRes;
	}

	// Overriden to call DefWindowProc which uses DefFrameProc
	LRESULT DefWindowProc()
	{
		const MSG* pMsg = m_pCurrentMsg;
		LRESULT lRes = 0;
		if (pMsg != NULL)
			lRes = DefWindowProc(pMsg->message, pMsg->wParam, pMsg->lParam);
		return lRes;
	}

	LRESULT DefWindowProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		return ::DefFrameProc(m_hWnd, m_hWndMDIClient, uMsg, wParam, lParam);
	}

	BOOL PreTranslateMessage(MSG* pMsg)
	{
		if(CFrameWindowImplBase<TBase, TWinTraits>::PreTranslateMessage(pMsg))
			return TRUE;
		return ::TranslateMDISysAccel(m_hWndMDIClient, pMsg);
	}

	HWND CreateMDIClient(HMENU hWindowMenu = NULL, UINT nID = ATL_IDW_CLIENT, UINT nFirstChildID = ATL_IDM_FIRST_MDICHILD)
	{
		DWORD dwStyle = WS_VISIBLE | WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | MDIS_ALLCHILDSTYLES;
		DWORD dwExStyle = WS_EX_CLIENTEDGE;

		CLIENTCREATESTRUCT ccs;
		ccs.hWindowMenu = hWindowMenu;
		ccs.idFirstChild = nFirstChildID;

		if((GetStyle() & (WS_HSCROLL | WS_VSCROLL)) != 0)
		{
			// parent MDI frame's scroll styles move to the MDICLIENT
			dwStyle |= (GetStyle() & (WS_HSCROLL | WS_VSCROLL));

			// fast way to turn off the scrollbar bits (without a resize)
			ModifyStyle(WS_HSCROLL | WS_VSCROLL, 0, SWP_NOREDRAW | SWP_FRAMECHANGED);
		}

		// Create MDICLIENT window
		m_hWndClient = ::CreateWindowEx(dwExStyle, _T("MDIClient"), NULL,
			dwStyle, 0, 0, 1, 1, m_hWnd, (HMENU)LongToHandle(nID),
			_Module.GetModuleInstance(), (LPVOID)&ccs);
		if (m_hWndClient == NULL)
		{
			ATLTRACE2(atlTraceUI, 0, _T("MDI Frame failed to create MDICLIENT.\n"));
			return NULL;
		}

		// Move it to the top of z-order
		::BringWindowToTop(m_hWndClient);

		// set as MDI client window
		m_hWndMDIClient = m_hWndClient;

		// update to proper size
		T* pT = static_cast<T*>(this);
		pT->UpdateLayout();

		return m_hWndClient;
	}

	typedef CMDIFrameWindowImpl< T, TBase, TWinTraits >	thisClass;
	typedef CFrameWindowImplBase<TBase, TWinTraits >	baseClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_SIZE, OnSize)
		MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
		MESSAGE_HANDLER(WM_MDISETMENU, OnMDISetMenu)
#ifndef _ATL_NO_REBAR_SUPPORT
#if (_WIN32_IE >= 0x0400)
		NOTIFY_CODE_HANDLER(RBN_AUTOSIZE, OnReBarAutoSize)
#endif //(_WIN32_IE >= 0x0400)
#if (_WIN32_IE >= 0x0500)
		NOTIFY_CODE_HANDLER(RBN_CHEVRONPUSHED, OnChevronPushed)
#endif //(_WIN32_IE >= 0x0500)
#endif //!_ATL_NO_REBAR_SUPPORT
		CHAIN_MSG_MAP(baseClass)
	END_MSG_MAP()

	LRESULT OnSize(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		if(wParam != SIZE_MINIMIZED)
		{
			T* pT = static_cast<T*>(this);
			pT->UpdateLayout();
		}
		// message must be handled, otherwise DefFrameProc would resize the client again
		return 0;
	}

	LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
	{
		// don't allow CFrameWindowImplBase to handle this one
		return DefWindowProc(uMsg, wParam, lParam);
	}

	LRESULT OnMDISetMenu(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		SetMDIFrameMenu();
		return 0;
	}

#ifndef _ATL_NO_REBAR_SUPPORT
#if (_WIN32_IE >= 0x0400)
	LRESULT OnReBarAutoSize(int /*idCtrl*/, LPNMHDR /*pnmh*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		pT->UpdateLayout(FALSE);
		return 0;
	}
#endif //(_WIN32_IE >= 0x0400)

#if (_WIN32_IE >= 0x0500)
	LRESULT OnChevronPushed(int /*idCtrl*/, LPNMHDR pnmh, BOOL& bHandled)
	{
		T* pT = static_cast<T*>(this);
		_ChevronMenuInfo cmi = { NULL, (LPNMREBARCHEVRON)pnmh, false };
		if(!pT->PrepareChevronMenu(cmi))
		{
			bHandled = FALSE;
			return 1;
		}
		// display a popup menu with hidden items
		pT->DisplayChevronMenu(cmi);
		// cleanup
		pT->CleanupChevronMenu(cmi);
		return 0;
	}
#endif //(_WIN32_IE >= 0x0500)
#endif //!_ATL_NO_REBAR_SUPPORT
};


/////////////////////////////////////////////////////////////////////////////
// CMDIChildWindowImpl

template <class T, class TBase = CMDIWindow, class TWinTraits = CMDIChildWinTraits>
class ATL_NO_VTABLE CMDIChildWindowImpl : public CFrameWindowImplBase<TBase, TWinTraits >
{
public:
	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			UINT nMenuID = 0, LPVOID lpCreateParam = NULL)
	{
		ATOM atom = T::GetWndClassInfo().Register(&m_pfnSuperWindowProc);

		if(nMenuID != 0)
			m_hMenu = ::LoadMenu(_Module.GetResourceInstance(), MAKEINTRESOURCE(nMenuID));

		dwStyle = T::GetWndStyle(dwStyle);
		dwExStyle = T::GetWndExStyle(dwExStyle);

		dwExStyle |= WS_EX_MDICHILD;	// force this one
		m_pfnSuperWindowProc = ::DefMDIChildProc;
		m_hWndMDIClient = hWndParent;
		ATLASSERT(::IsWindow(m_hWndMDIClient));

		if(rect.m_lpRect == NULL)
			rect.m_lpRect = &TBase::rcDefault;

		HWND hWnd = CFrameWindowImplBase<TBase, TWinTraits >::Create(hWndParent, rect, szWindowName, dwStyle, dwExStyle, (UINT)0U, atom, lpCreateParam);

		if(hWnd != NULL && ::IsWindowVisible(m_hWnd) && !::IsChild(hWnd, ::GetFocus()))
			::SetFocus(hWnd);

		return hWnd;
	}

	HWND CreateEx(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR lpcstrWindowName = NULL, DWORD dwStyle = 0, DWORD dwExStyle = 0, LPVOID lpCreateParam = NULL)
	{
		TCHAR szWindowName[256];
		szWindowName[0] = 0;
		if(lpcstrWindowName == NULL)
		{
			::LoadString(_Module.GetResourceInstance(), T::GetWndClassInfo().m_uCommonResourceID, szWindowName, 256);
			lpcstrWindowName = szWindowName;
		}

		T* pT = static_cast<T*>(this);
		HWND hWnd = pT->Create(hWndParent, rect, lpcstrWindowName, dwStyle, dwExStyle, T::GetWndClassInfo().m_uCommonResourceID, lpCreateParam);

		if(hWnd != NULL)
			m_hAccel = ::LoadAccelerators(_Module.GetResourceInstance(), MAKEINTRESOURCE(T::GetWndClassInfo().m_uCommonResourceID));

		return hWnd;
	}

	BOOL CreateSimpleToolBar(UINT nResourceID = 0, DWORD dwStyle = ATL_SIMPLE_TOOLBAR_STYLE, UINT nID = ATL_IDW_TOOLBAR)
	{
		ATLASSERT(!::IsWindow(m_hWndToolBar));
		if(nResourceID == 0)
			nResourceID = T::GetWndClassInfo().m_uCommonResourceID;
		m_hWndToolBar = T::CreateSimpleToolBarCtrl(m_hWnd, nResourceID, TRUE, dwStyle, nID);
		return (m_hWndToolBar != NULL);
	}

	BOOL UpdateClientEdge(LPRECT lpRect = NULL)
	{
		// only adjust for active MDI child window
		HWND hWndChild = MDIGetActive();
		if(hWndChild != NULL && hWndChild != m_hWnd)
			return FALSE;

		// need to adjust the client edge style as max/restore happens
		DWORD dwStyle = ::GetWindowLong(m_hWndMDIClient, GWL_EXSTYLE);
		DWORD dwNewStyle = dwStyle;
		if(hWndChild != NULL && ((GetExStyle() & WS_EX_CLIENTEDGE) == 0) && ((GetStyle() & WS_MAXIMIZE) != 0))
			dwNewStyle &= ~(WS_EX_CLIENTEDGE);
		else
			dwNewStyle |= WS_EX_CLIENTEDGE;

		if(dwStyle != dwNewStyle)
		{
			// SetWindowPos will not move invalid bits
			::RedrawWindow(m_hWndMDIClient, NULL, NULL,
				RDW_INVALIDATE | RDW_ALLCHILDREN);
			// remove/add WS_EX_CLIENTEDGE to MDI client area
			::SetWindowLong(m_hWndMDIClient, GWL_EXSTYLE, dwNewStyle);
			::SetWindowPos(m_hWndMDIClient, NULL, 0, 0, 0, 0,
				SWP_FRAMECHANGED | SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE |
				SWP_NOZORDER | SWP_NOCOPYBITS);

			// return new client area
			if (lpRect != NULL)
				::GetClientRect(m_hWndMDIClient, lpRect);

			return TRUE;
		}

		return FALSE;
	}

	typedef CMDIChildWindowImpl< T, TBase, TWinTraits >	thisClass;
	typedef CFrameWindowImplBase<TBase, TWinTraits >	baseClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_SIZE, OnSize)
		MESSAGE_HANDLER(WM_WINDOWPOSCHANGING, OnWindowPosChanging)
		MESSAGE_HANDLER(WM_MENUSELECT, OnMenuSelect)
		MESSAGE_HANDLER(WM_MDIACTIVATE, OnMDIActivate)
		MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
#ifndef _ATL_NO_REBAR_SUPPORT
#if (_WIN32_IE >= 0x0400)
		NOTIFY_CODE_HANDLER(RBN_AUTOSIZE, OnReBarAutoSize)
#endif //(_WIN32_IE >= 0x0400)
#if (_WIN32_IE >= 0x0500)
		NOTIFY_CODE_HANDLER(RBN_CHEVRONPUSHED, OnChevronPushed)
#endif //(_WIN32_IE >= 0x0500)
#endif //!_ATL_NO_REBAR_SUPPORT
		CHAIN_MSG_MAP(baseClass)
	END_MSG_MAP()

	LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
	{
		DefWindowProc(uMsg, wParam, lParam);	// needed for MDI children
		if(wParam != SIZE_MINIMIZED)
		{
			T* pT = static_cast<T*>(this);
			pT->UpdateLayout();
		}
		return 0;
	}

	LRESULT OnWindowPosChanging(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
	{
		// update MDI client edge and adjust MDI child rect
		LPWINDOWPOS lpWndPos = (LPWINDOWPOS)lParam;

		if(!(lpWndPos->flags & SWP_NOSIZE))
		{
			CWindow wnd(m_hWndMDIClient);
			RECT rectClient;

			if(UpdateClientEdge(&rectClient) && ((GetStyle() & WS_MAXIMIZE) != 0))
			{
				::AdjustWindowRectEx(&rectClient, GetStyle(), FALSE, GetExStyle());
				lpWndPos->x = rectClient.left;
				lpWndPos->y = rectClient.top;
				lpWndPos->cx = rectClient.right - rectClient.left;
				lpWndPos->cy = rectClient.bottom - rectClient.top;
			}
		}

		bHandled = FALSE;
		return 1;
	}

	LRESULT OnMenuSelect(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
	{
		return ::SendMessage(GetMDIFrame(), uMsg, wParam, lParam);
	}

	LRESULT OnMDIActivate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
	{
		if((HWND)lParam == m_hWnd && m_hMenu != NULL)
			SetMDIFrameMenu();
		else if((HWND)lParam == NULL)
			::SendMessage(GetMDIFrame(), WM_MDISETMENU, 0, 0);

		bHandled = FALSE;
		return 1;
	}

	LRESULT OnDestroy(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		UpdateClientEdge();
		bHandled = FALSE;
		return 1;
	}

#ifndef _ATL_NO_REBAR_SUPPORT
#if (_WIN32_IE >= 0x0400)
	LRESULT OnReBarAutoSize(int /*idCtrl*/, LPNMHDR /*pnmh*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		pT->UpdateLayout(FALSE);
		return 0;
	}
#endif //(_WIN32_IE >= 0x0400)

#if (_WIN32_IE >= 0x0500)
	LRESULT OnChevronPushed(int /*idCtrl*/, LPNMHDR pnmh, BOOL& bHandled)
	{
		T* pT = static_cast<T*>(this);
		_ChevronMenuInfo cmi = { NULL, (LPNMREBARCHEVRON)pnmh, false };
		if(!pT->PrepareChevronMenu(cmi))
		{
			bHandled = FALSE;
			return 1;
		}
		// display a popup menu with hidden items
		pT->DisplayChevronMenu(cmi);
		// cleanup
		pT->CleanupChevronMenu(cmi);
		return 0;
	}
#endif //(_WIN32_IE >= 0x0500)
#endif //!_ATL_NO_REBAR_SUPPORT
};


/////////////////////////////////////////////////////////////////////////////
// COwnerDraw - MI class for owner-draw support

template <class T>
class COwnerDraw
{
public:
#if !defined(_ATL_TMP_IMPL1) && !defined(_ATL_TMP_IMPL2)
	BOOL m_bHandledOD;

	BOOL IsMsgHandled() const
	{
		return m_bHandledOD;
	}
	void SetMsgHandled(BOOL bHandled)
	{
		m_bHandledOD = bHandled;
	}
#endif //!defined(_ATL_TMP_IMPL1) && !defined(_ATL_TMP_IMPL2)

// Message map and handlers
	BEGIN_MSG_MAP(COwnerDraw< T >)
		MESSAGE_HANDLER(WM_DRAWITEM, OnDrawItem)
		MESSAGE_HANDLER(WM_MEASUREITEM, OnMeasureItem)
		MESSAGE_HANDLER(WM_COMPAREITEM, OnCompareItem)
		MESSAGE_HANDLER(WM_DELETEITEM, OnDeleteItem)
	ALT_MSG_MAP(1)
		MESSAGE_HANDLER(OCM_DRAWITEM, OnDrawItem)
		MESSAGE_HANDLER(OCM_MEASUREITEM, OnMeasureItem)
		MESSAGE_HANDLER(OCM_COMPAREITEM, OnCompareItem)
		MESSAGE_HANDLER(OCM_DELETEITEM, OnDeleteItem)
	END_MSG_MAP()

	LRESULT OnDrawItem(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
	{
		T* pT = static_cast<T*>(this);
		pT->SetMsgHandled(TRUE);
		pT->DrawItem((LPDRAWITEMSTRUCT)lParam);
		bHandled = pT->IsMsgHandled();
		return (LRESULT)TRUE;
	}
	LRESULT OnMeasureItem(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
	{
		T* pT = static_cast<T*>(this);
		pT->SetMsgHandled(TRUE);
		pT->MeasureItem((LPMEASUREITEMSTRUCT)lParam);
		bHandled = pT->IsMsgHandled();
		return (LRESULT)TRUE;
	}
	LRESULT OnCompareItem(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
	{
		T* pT = static_cast<T*>(this);
		pT->SetMsgHandled(TRUE);
		bHandled = pT->IsMsgHandled();
		return (LRESULT)pT->CompareItem((LPCOMPAREITEMSTRUCT)lParam);
	}
	LRESULT OnDeleteItem(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
	{
		T* pT = static_cast<T*>(this);
		pT->SetMsgHandled(TRUE);
		pT->DeleteItem((LPDELETEITEMSTRUCT)lParam);
		bHandled = pT->IsMsgHandled();
		return (LRESULT)TRUE;
	}

// Overrideables
	void DrawItem(LPDRAWITEMSTRUCT /*lpDrawItemStruct*/)
	{
		// must be implemented
		ATLASSERT(FALSE);
	}
	void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct)
	{
		if(lpMeasureItemStruct->CtlType != ODT_MENU)
		{
			// return default height for a system font
			T* pT = static_cast<T*>(this);
			HWND hWnd = pT->GetDlgItem(lpMeasureItemStruct->CtlID);
			CClientDC dc(hWnd);
			TEXTMETRIC tm;
			dc.GetTextMetrics(&tm);

			lpMeasureItemStruct->itemHeight = tm.tmHeight;
		}
		else
			lpMeasureItemStruct->itemHeight = ::GetSystemMetrics(SM_CYMENU);
	}
	int CompareItem(LPCOMPAREITEMSTRUCT /*lpCompareItemStruct*/)
	{
		// all items are equal
		return 0;
	}
	void DeleteItem(LPDELETEITEMSTRUCT /*lpDeleteItemStruct*/)
	{
		// default - nothing
	}
};


/////////////////////////////////////////////////////////////////////////////
// Update UI macros

// these build the Update UI map inside a class definition
#define BEGIN_UPDATE_UI_MAP(thisClass) \
	static const _AtlUpdateUIMap* GetUpdateUIMap() \
	{ \
		static const _AtlUpdateUIMap theMap[] = \
		{

#define UPDATE_ELEMENT(nID, wType) \
			{ nID,  wType },

#define END_UPDATE_UI_MAP() \
			{ (WORD)-1, 0 } \
		}; \
		return theMap; \
	}

///////////////////////////////////////////////////////////////////////////////
// CUpdateUI - manages UI elements updating

class CUpdateUIBase
{
public:
	// constants
	enum
	{
		// UI element type
		UPDUI_MENUPOPUP		= 0x0001,
		UPDUI_MENUBAR		= 0x0002,
		UPDUI_CHILDWINDOW	= 0x0004,
		UPDUI_TOOLBAR		= 0x0008,
		UPDUI_STATUSBAR		= 0x0010,
		// state
		UPDUI_ENABLED		= 0x0000,
		UPDUI_DISABLED		= 0x0100,
		UPDUI_CHECKED		= 0x0200,
		UPDUI_CHECKED2		= 0x0400,
		UPDUI_RADIO		= 0x0800,
		UPDUI_DEFAULT		= 0x1000,
		UPDUI_TEXT		= 0x2000,
	};

	// element data
	struct _AtlUpdateUIElement
	{
		HWND m_hWnd;
		WORD m_wType;
		bool operator==(const _AtlUpdateUIElement& e) const
		{ return (m_hWnd == e.m_hWnd && m_wType == e.m_wType); }
	};

	// map data
	struct _AtlUpdateUIMap
	{
		WORD m_nID;
		WORD m_wType;
	};

	// instance data
	struct _AtlUpdateUIData
	{
		WORD m_wState;
		void* m_lpData;
	};

	CSimpleArray<_AtlUpdateUIElement> m_UIElements;	// elements data
	const _AtlUpdateUIMap* m_pUIMap;		// static UI data
	_AtlUpdateUIData* m_pUIData;			// instance UI data
	WORD m_wDirtyType;				// global dirty flag

// Constructor, destructor
	CUpdateUIBase() : m_pUIMap(NULL), m_pUIData(NULL), m_wDirtyType(0)
	{ }

	~CUpdateUIBase()
	{
		if(m_pUIMap != NULL && m_pUIData != NULL)
		{
			const _AtlUpdateUIMap* pUIMap = m_pUIMap;
			_AtlUpdateUIData* pUIData = m_pUIData;
			while(pUIMap->m_nID != (WORD)-1)
			{
				if(pUIData->m_wState & UPDUI_TEXT)
					free(pUIData->m_lpData);
				pUIMap++;
				pUIData++;
			}
			delete [] m_pUIData;
		}
	}

// Add elements
	BOOL UIAddMenuBar(HWND hWnd)			// menu bar (main menu)
	{
		if(hWnd == NULL)
			return FALSE;
		_AtlUpdateUIElement e;
		e.m_hWnd = hWnd;
		e.m_wType = UPDUI_MENUBAR;
		return m_UIElements.Add(e);
	}
	BOOL UIAddToolBar(HWND hWnd)			// toolbar
	{
		if(hWnd == NULL)
			return FALSE;
		_AtlUpdateUIElement e;
		e.m_hWnd = hWnd;
		e.m_wType = UPDUI_TOOLBAR;
		return m_UIElements.Add(e);
	}
	BOOL UIAddStatusBar(HWND hWnd)			// status bar
	{
		if(hWnd == NULL)
			return FALSE;
		_AtlUpdateUIElement e;
		e.m_hWnd = hWnd;
		e.m_wType = UPDUI_STATUSBAR;
		return m_UIElements.Add(e);
	}
	BOOL UIAddChildWindowContainer(HWND hWnd)	// child window
	{
		if(hWnd == NULL)
			return FALSE;
		_AtlUpdateUIElement e;
		e.m_hWnd = hWnd;
		e.m_wType = UPDUI_CHILDWINDOW;
		return m_UIElements.Add(e);
	}

// message map for popup menu updates
	BEGIN_MSG_MAP(CUpdateUIBase)
		MESSAGE_HANDLER(WM_INITMENUPOPUP, OnInitMenuPopup)
	END_MSG_MAP()

	LRESULT OnInitMenuPopup(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
		bHandled = FALSE;
		HMENU hMenu = (HMENU)wParam;
		if(hMenu == NULL)
			return 1;
		_AtlUpdateUIData* pUIData = m_pUIData;
		if(pUIData == NULL)
			return 1;
		const _AtlUpdateUIMap* pMap = m_pUIMap;
		while(pMap->m_nID != (WORD)-1)
		{
			if(pMap->m_wType & UPDUI_MENUPOPUP)
				UIUpdateMenuBarElement(pMap->m_nID, pUIData, hMenu);
			pMap++;
			pUIData++;
		}
		return 0;
	}

// methods for setting UI element state
	BOOL UIEnable(int nID, BOOL bEnable, BOOL bForceUpdate = FALSE)
	{
		const _AtlUpdateUIMap* pMap = m_pUIMap;
		_AtlUpdateUIData* pUIData = m_pUIData;
		if(pUIData == NULL)
			return FALSE;

		for( ; pMap->m_nID != (WORD)-1; pMap++, pUIData++)
		{
			if(nID == (int)pMap->m_nID)
			{
				if(bEnable)
				{
					if(pUIData->m_wState & UPDUI_DISABLED)
					{
						pUIData->m_wState |= pMap->m_wType;
						pUIData->m_wState &= ~UPDUI_DISABLED;
					}
				}
				else
				{
					if(!(pUIData->m_wState & UPDUI_DISABLED))
					{
						pUIData->m_wState |= pMap->m_wType;
						pUIData->m_wState |= UPDUI_DISABLED;
					}
				}

				if(bForceUpdate)
					pUIData->m_wState |= pMap->m_wType;
				if(pUIData->m_wState & pMap->m_wType)
					m_wDirtyType |= pMap->m_wType;
			}
		}

		return TRUE;
	}

	BOOL UISetCheck(int nID, int nCheck, BOOL bForceUpdate = FALSE)
	{
		const _AtlUpdateUIMap* pMap = m_pUIMap;
		_AtlUpdateUIData* pUIData = m_pUIData;
		if(pUIData == NULL)
			return FALSE;

		for( ; pMap->m_nID != (WORD)-1; pMap++, pUIData++)
		{
			if(nID == (int)pMap->m_nID)
			{
				switch(nCheck)
				{
				case 0:
					if((pUIData->m_wState & UPDUI_CHECKED) || (pUIData->m_wState & UPDUI_CHECKED2))
					{
						pUIData->m_wState |= pMap->m_wType;
						pUIData->m_wState &= ~(UPDUI_CHECKED | UPDUI_CHECKED2);
					}
					break;
				case 1:
					if(!(pUIData->m_wState & UPDUI_CHECKED))
					{
						pUIData->m_wState |= pMap->m_wType;
						pUIData->m_wState &= ~UPDUI_CHECKED2;
						pUIData->m_wState |= UPDUI_CHECKED;
					}
					break;
				case 2:
					if(!(pUIData->m_wState & UPDUI_CHECKED2))
					{
						pUIData->m_wState |= pMap->m_wType;
						pUIData->m_wState &= ~UPDUI_CHECKED;
						pUIData->m_wState |= UPDUI_CHECKED2;
					}
					break;
				}

				if(bForceUpdate)
					pUIData->m_wState |= pMap->m_wType;
				if(pUIData->m_wState & pMap->m_wType)
					m_wDirtyType |= pMap->m_wType;
			}
		}

		return TRUE;
	}

	BOOL UISetRadio(int nID, BOOL bRadio, BOOL bForceUpdate = FALSE)
	{
		const _AtlUpdateUIMap* pMap = m_pUIMap;
		_AtlUpdateUIData* pUIData = m_pUIData;
		if(pUIData == NULL)
			return FALSE;

		for( ; pMap->m_nID != (WORD)-1; pMap++, pUIData++)
		{
			if(nID == (int)pMap->m_nID)
			{
				if(bRadio)
				{
					if(!(pUIData->m_wState & UPDUI_RADIO))
					{
						pUIData->m_wState |= pMap->m_wType;
						pUIData->m_wState |= UPDUI_RADIO;
					}
				}
				else
				{
					if(pUIData->m_wState & UPDUI_RADIO)
					{
						pUIData->m_wState |= pMap->m_wType;
						pUIData->m_wState &= ~UPDUI_RADIO;
					}
				}

				if(bForceUpdate)
					pUIData->m_wState |= pMap->m_wType;
				if(pUIData->m_wState & pMap->m_wType)
					m_wDirtyType |= pMap->m_wType;
			}
		}

		return TRUE;
	}

	BOOL UISetText(int nID, LPCTSTR lpstrText, BOOL bForceUpdate = FALSE)
	{
		const _AtlUpdateUIMap* pMap = m_pUIMap;
		_AtlUpdateUIData* pUIData = m_pUIData;
		if(pUIData == NULL)
			return FALSE;
		if(lpstrText == NULL)
			lpstrText = _T("");

		for( ; pMap->m_nID != (WORD)-1; pMap++, pUIData++)
		{
			if(nID == (int)pMap->m_nID)
			{
				if(pUIData->m_lpData == NULL || lstrcmp((LPTSTR)pUIData->m_lpData, lpstrText))
				{
					int nStrLen = lstrlen(lpstrText);
					free(pUIData->m_lpData);
					pUIData->m_lpData = NULL;
					ATLTRY(pUIData->m_lpData = malloc((nStrLen + 1) * sizeof(TCHAR)));
					if(pUIData->m_lpData == NULL)
					{
						ATLTRACE2(atlTraceUI, 0, _T("UISetText - malloc failed\n"));
						break;
					}
					lstrcpy((LPTSTR)pUIData->m_lpData, lpstrText);
					pUIData->m_wState |= (UPDUI_TEXT | pMap->m_wType);
				}

				if(bForceUpdate)
					pUIData->m_wState |= (UPDUI_TEXT | pMap->m_wType);
				if(pUIData->m_wState | pMap->m_wType)
					m_wDirtyType |= pMap->m_wType;
			}
		}

		return TRUE;
	}

// methods for complete state set/get
	BOOL UISetState(int nID, DWORD dwState)
	{
		const _AtlUpdateUIMap* pMap = m_pUIMap;
		_AtlUpdateUIData* pUIData = m_pUIData;
		if(pUIData == NULL)
			return FALSE;
		for( ; pMap->m_nID != (WORD)-1; pMap++, pUIData++)
		{
			if(nID == (int)pMap->m_nID)
			{		
				pUIData->m_wState |= dwState | pMap->m_wType;
				m_wDirtyType |= pMap->m_wType;
			}
		}
		return TRUE;
	}
	DWORD UIGetState(int nID)
	{
		const _AtlUpdateUIMap* pMap = m_pUIMap;
		_AtlUpdateUIData* pUIData = m_pUIData;
		if(pUIData == NULL)
			return 0;
		for( ; pMap->m_nID != (WORD)-1; pMap++, pUIData++)
		{
			if(nID == (int)pMap->m_nID)
				return pUIData->m_wState;
		}
		return 0;
	}

// methods for updating UI
	BOOL UIUpdateMenuBar(BOOL bForceUpdate = FALSE, BOOL bMainMenu = FALSE)
	{
		if(!(m_wDirtyType & UPDUI_MENUBAR) && !bForceUpdate)
			return TRUE;

		const _AtlUpdateUIMap* pMap = m_pUIMap;
		_AtlUpdateUIData* pUIData = m_pUIData;
		if(pUIData == NULL)
			return FALSE;

		while(pMap->m_nID != (WORD)-1)
		{
			for(int i = 0; i < m_UIElements.GetSize(); i++)
			{
				if(m_UIElements[i].m_wType == UPDUI_MENUBAR)
				{
					HMENU hMenu = ::GetMenu(m_UIElements[i].m_hWnd);
					if(hMenu != NULL && (pUIData->m_wState & UPDUI_MENUBAR) && (pMap->m_wType & UPDUI_MENUBAR))
						UIUpdateMenuBarElement(pMap->m_nID, pUIData, hMenu);
				}
				if(bMainMenu)
					::DrawMenuBar(m_UIElements[i].m_hWnd);
			}
			pMap++;
			pUIData->m_wState &= ~UPDUI_MENUBAR;
			if(pUIData->m_wState & UPDUI_TEXT)
			{
				free(pUIData->m_lpData);
				pUIData->m_lpData = NULL;
				pUIData->m_wState &= ~UPDUI_TEXT;
			}
			pUIData++;
		}

		m_wDirtyType &= ~UPDUI_MENUBAR;
		return TRUE;
	}

	BOOL UIUpdateToolBar(BOOL bForceUpdate = FALSE)
	{
		if(!(m_wDirtyType & UPDUI_TOOLBAR) && !bForceUpdate)
			return TRUE;

		const _AtlUpdateUIMap* pMap = m_pUIMap;
		_AtlUpdateUIData* pUIData = m_pUIData;
		if(pUIData == NULL)
			return FALSE;

		while(pMap->m_nID != (WORD)-1)
		{
			for(int i = 0; i < m_UIElements.GetSize(); i++)
			{
				if(m_UIElements[i].m_wType == UPDUI_TOOLBAR)
				{
					if((pUIData->m_wState & UPDUI_TOOLBAR) && (pMap->m_wType & UPDUI_TOOLBAR))
						UIUpdateToolBarElement(pMap->m_nID, pUIData, m_UIElements[i].m_hWnd);
				}
			}
			pMap++;
			pUIData->m_wState &= ~UPDUI_TOOLBAR;
			pUIData++;
		}

		m_wDirtyType &= ~UPDUI_TOOLBAR;
		return TRUE;
	}

	BOOL UIUpdateStatusBar(BOOL bForceUpdate = FALSE)
	{
		if(!(m_wDirtyType & UPDUI_STATUSBAR) && !bForceUpdate)
			return TRUE;

		const _AtlUpdateUIMap* pMap = m_pUIMap;
		_AtlUpdateUIData* pUIData = m_pUIData;
		if(pUIData == NULL)
			return FALSE;

		while(pMap->m_nID != (WORD)-1)
		{
			for(int i = 0; i < m_UIElements.GetSize(); i++)
			{
				if(m_UIElements[i].m_wType == UPDUI_STATUSBAR)
				{
					if((pUIData->m_wState & UPDUI_STATUSBAR) && (pMap->m_wType & UPDUI_STATUSBAR))
						UIUpdateStatusBarElement(pMap->m_nID, pUIData, m_UIElements[i].m_hWnd);
				}
			}
			pMap++;
			pUIData->m_wState &= ~UPDUI_STATUSBAR;
			if(pUIData->m_wState & UPDUI_TEXT)
			{
				free(pUIData->m_lpData);
				pUIData->m_lpData = NULL;
				pUIData->m_wState &= ~UPDUI_TEXT;
			}
			pUIData++;
		}

		m_wDirtyType &= ~UPDUI_STATUSBAR;
		return TRUE;
	}

	BOOL UIUpdateChildWindows(BOOL bForceUpdate = FALSE)
	{
		if(!(m_wDirtyType & UPDUI_CHILDWINDOW) && !bForceUpdate)
			return TRUE;

		const _AtlUpdateUIMap* pMap = m_pUIMap;
		_AtlUpdateUIData* pUIData = m_pUIData;
		if(pUIData == NULL)
			return FALSE;

		while(pMap->m_nID != (WORD)-1)
		{
			for(int i = 0; i < m_UIElements.GetSize(); i++)
			{
				if(m_UIElements[i].m_wType == UPDUI_CHILDWINDOW)
				{
					if((pUIData->m_wState & UPDUI_CHILDWINDOW) && (pMap->m_wType & UPDUI_CHILDWINDOW))
						UIUpdateChildWindow(pMap->m_nID, pUIData, m_UIElements[i].m_hWnd);
				}
			}
			pMap++;
			pUIData->m_wState &= ~UPDUI_CHILDWINDOW;
			if(pUIData->m_wState & UPDUI_TEXT)
			{
				free(pUIData->m_lpData);
				pUIData->m_lpData = NULL;
				pUIData->m_wState &= ~UPDUI_TEXT;
			}
			pUIData++;
		}

		m_wDirtyType &= ~UPDUI_CHILDWINDOW;
		return TRUE;
	}

// internal element specific methods
	static void UIUpdateMenuBarElement(int nID, _AtlUpdateUIData* pUIData, HMENU hMenu)
	{
		MENUITEMINFO mii;
		memset(&mii, 0, sizeof(MENUITEMINFO));
		mii.cbSize = sizeof(MENUITEMINFO);
		mii.fMask = MIIM_STATE;
		mii.wID = nID;

		if(pUIData->m_wState & UPDUI_DISABLED)
			mii.fState |= MFS_DISABLED | MFS_GRAYED;
		else
			mii.fState |= MFS_ENABLED;

		if(pUIData->m_wState & UPDUI_CHECKED)
			mii.fState |= MFS_CHECKED;
		else
			mii.fState |= MFS_UNCHECKED;

		if(pUIData->m_wState & UPDUI_DEFAULT)
			mii.fState |= MFS_DEFAULT;

		if(pUIData->m_wState & UPDUI_TEXT)
		{
			mii.fMask |= MIIM_TYPE;
			mii.fType = MFT_STRING;
			mii.dwTypeData = (LPTSTR)pUIData->m_lpData;
		}

		::SetMenuItemInfo(hMenu, nID, FALSE, &mii);
	}

	static void UIUpdateToolBarElement(int nID, _AtlUpdateUIData* pUIData, HWND hWndToolBar)
	{
		// Note: only handles enabled/disabled, checked state, and radio (press)
		::SendMessage(hWndToolBar, TB_ENABLEBUTTON, nID, (LPARAM)(pUIData->m_wState & UPDUI_DISABLED) ? FALSE : TRUE);
		::SendMessage(hWndToolBar, TB_CHECKBUTTON, nID, (LPARAM)(pUIData->m_wState & UPDUI_CHECKED) ? TRUE : FALSE);
		::SendMessage(hWndToolBar, TB_INDETERMINATE, nID, (LPARAM)(pUIData->m_wState & UPDUI_CHECKED2) ? TRUE : FALSE);
		::SendMessage(hWndToolBar, TB_PRESSBUTTON, nID, (LPARAM)(pUIData->m_wState & UPDUI_RADIO) ? TRUE : FALSE);
	}

	static void UIUpdateStatusBarElement(int nID, _AtlUpdateUIData* pUIData, HWND hWndStatusBar)
	{
		// Note: only handles text
		if(pUIData->m_wState & UPDUI_TEXT)
			::SendMessage(hWndStatusBar, SB_SETTEXT, nID, (LPARAM)pUIData->m_lpData);
	}

	static void UIUpdateChildWindow(int nID, _AtlUpdateUIData* pUIData, HWND hWnd)
	{
		HWND hChild = ::GetDlgItem(hWnd, nID);

		::EnableWindow(hChild, (pUIData->m_wState & UPDUI_DISABLED) ? FALSE : TRUE);
		// for check and radio, assume that window is a button
		int nCheck = BST_UNCHECKED;
		if(pUIData->m_wState & UPDUI_CHECKED || pUIData->m_wState & UPDUI_RADIO)
			nCheck = BST_CHECKED;
		else if(pUIData->m_wState & UPDUI_CHECKED2)
			nCheck = BST_INDETERMINATE;
		::SendMessage(hChild, BM_SETCHECK, nCheck, 0L);
		if(pUIData->m_wState & UPDUI_DEFAULT)
		{
			DWORD dwRet = (DWORD)::SendMessage(hWnd, DM_GETDEFID, 0, 0L);
			if(HIWORD(dwRet) == DC_HASDEFID)
			{
				HWND hOldDef = ::GetDlgItem(hWnd, (int)(short)LOWORD(dwRet));
				// remove BS_DEFPUSHBUTTON
				::SendMessage(hOldDef, BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE, 0));
			}
			::SendMessage(hWnd, DM_SETDEFID, nID, 0L);
		}
		if(pUIData->m_wState & UPDUI_TEXT)
			::SetWindowText(hChild, (LPTSTR)pUIData->m_lpData);
	}
};

template <class T>
class CUpdateUI : public CUpdateUIBase
{
public:
	CUpdateUI()
	{
		T* pT = static_cast<T*>(this);
		pT;
		const _AtlUpdateUIMap* pMap = pT->GetUpdateUIMap();
		m_pUIMap = pMap;
		ATLASSERT(m_pUIMap != NULL);
		int nCount;
		for(nCount = 1; pMap->m_nID != (WORD)-1; nCount++)
			pMap++;

		ATLTRY(m_pUIData = new _AtlUpdateUIData[nCount]);
		ATLASSERT(m_pUIData != NULL);

		if(m_pUIData != NULL)
			memset(m_pUIData, 0, sizeof(_AtlUpdateUIData) * nCount);
	}
};


// command bar support
#ifndef __ATLCTRLW_H__
#undef CBRM_GETMENU
#undef CBRM_TRACKPOPUPMENU
#undef CBRM_GETCMDBAR
#undef CBRPOPUPMENU
#endif //!__ATLCTRLW_H__

}; //namespace WTL

#endif // __ATLFRAME_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\atlgdi.h ===
// WTL Version 3.0
// Copyright (C) 1997-1999 Microsoft Corporation
// All rights reserved.
//
// This file is a part of Windows Template Library.
// The code and information is provided "as-is" without
// warranty of any kind, either expressed or implied.

#ifndef __ATLGDI_H__
#define __ATLGDI_H__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLBASE_H__
	#error atlgdi.h requires atlbase.h to be included first
#endif


// protect template members from windowsx.h macros
#ifdef _INC_WINDOWSX
#undef CopyRgn
#undef CreateBrush
#undef CreatePen
#undef SelectBrush
#undef SelectPen
#undef SelectFont
#undef SelectBitmap
#endif //_INC_WINDOWSX

// required libraries
#ifndef _ATL_NO_MSIMG
#pragma comment(lib, "msimg32.lib")
#endif //!_ATL_NO_MSIMG
#ifndef _ATL_NO_OPENGL
#pragma comment(lib, "opengl32.lib")
#endif //!_ATL_NO_OPENGL


namespace WTL
{

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

template <bool t_bManaged> class CPenT;
template <bool t_bManaged> class CBrushT;
template <bool t_bManaged> class CFontT;
template <bool t_bManaged> class CBitmapT;
template <bool t_bManaged> class CPaletteT;
template <bool t_bManaged> class CRgnT;
template <bool t_bManaged> class CDCT;
class CPaintDC;
class CClientDC;
class CWindowDC;
class CEnhMetaFileInfo;
template <bool t_bManaged> class CEnhMetaFileT;
class CEnhMetaFileDC;


/////////////////////////////////////////////////////////////////////////////
// CPen

typedef CPenT<false>		CPenHandle;
typedef CPenT<true>		CPen;

template <bool t_bManaged>
class CPenT
{
public:
// Data members
	HPEN m_hPen;

// Constructor/destructor/operators
	CPenT(HPEN hPen = NULL) : m_hPen(hPen)
	{ }

	~CPenT()
	{
		if(t_bManaged && m_hPen != NULL)
			DeleteObject();
	}

	CPenT<t_bManaged>& operator=(HPEN hPen)
	{
		m_hPen = hPen;
		return *this;
	}

	void Attach(HPEN hPen)
	{
		m_hPen = hPen;
	}
	HPEN Detach()
	{
		HPEN hPen = m_hPen;
		m_hPen = NULL;
		return hPen;
	}

	operator HPEN() const { return m_hPen; }

	bool IsNull() const { return (m_hPen == NULL); }

// Create methods
	HPEN CreatePen(int nPenStyle, int nWidth, COLORREF crColor)
	{
		ATLASSERT(m_hPen == NULL);
		m_hPen = ::CreatePen(nPenStyle, nWidth, crColor);
		return m_hPen;
	}
	HPEN CreatePen(int nPenStyle, int nWidth, const LOGBRUSH* pLogBrush, int nStyleCount = 0, const DWORD* lpStyle = NULL)
	{
		ATLASSERT(m_hPen == NULL);
		m_hPen = ::ExtCreatePen(nPenStyle, nWidth, pLogBrush, nStyleCount, lpStyle);
		return m_hPen;
	}
	HPEN CreatePenIndirect(LPLOGPEN lpLogPen)
	{
		ATLASSERT(m_hPen == NULL);
		m_hPen = ::CreatePenIndirect(lpLogPen);
		return m_hPen;
	}

	BOOL DeleteObject()
	{
		ATLASSERT(m_hPen != NULL);
		BOOL bRet = ::DeleteObject(m_hPen);
		if(bRet)
			m_hPen = NULL;
		return bRet;
	}

// Attributes
	int GetLogPen(LOGPEN* pLogPen) const
	{
		ATLASSERT(m_hPen != NULL);
		return ::GetObject(m_hPen, sizeof(LOGPEN), pLogPen);
	}
	bool GetLogPen(LOGPEN& LogPen) const
	{
		ATLASSERT(m_hPen != NULL);
		return (::GetObject(m_hPen, sizeof(LOGPEN), &LogPen) == sizeof(LOGPEN));
	}
	int GetExtLogPen(EXTLOGPEN* pLogPen) const
	{
		ATLASSERT(m_hPen != NULL);
		return ::GetObject(m_hPen, sizeof(EXTLOGPEN), pLogPen);
	}
	bool GetExtLogPen(EXTLOGPEN& ExtLogPen) const
	{
		ATLASSERT(m_hPen != NULL);
		return (::GetObject(m_hPen, sizeof(EXTLOGPEN), &ExtLogPen) == sizeof(EXTLOGPEN));
	}
};


/////////////////////////////////////////////////////////////////////////////
// CBrush

typedef CBrushT<false>		CBrushHandle;
typedef CBrushT<true>		CBrush;

template <bool t_bManaged>
class CBrushT
{
public:
// Data members
	HBRUSH m_hBrush;

// Constructor/destructor/operators
	CBrushT(HBRUSH hBrush = NULL) : m_hBrush(hBrush)
	{ }

	~CBrushT()
	{
		if(t_bManaged && m_hBrush != NULL)
			DeleteObject();
	}

	CBrushT<t_bManaged>& operator=(HBRUSH hBrush)
	{
		m_hBrush = hBrush;
		return *this;
	}

	void Attach(HBRUSH hBrush)
	{
		m_hBrush = hBrush;
	}
	HBRUSH Detach()
	{
		HBRUSH hBrush = m_hBrush;
		m_hBrush = NULL;
		return hBrush;
	}

	operator HBRUSH() const { return m_hBrush; }

	bool IsNull() const { return (m_hBrush == NULL); }

// Create methods
	HBRUSH CreateSolidBrush(COLORREF crColor)
	{
		ATLASSERT(m_hBrush == NULL);
		m_hBrush = ::CreateSolidBrush(crColor);
		return m_hBrush;
	}
	HBRUSH CreateHatchBrush(int nIndex, COLORREF crColor)
	{
		ATLASSERT(m_hBrush == NULL);
		m_hBrush = ::CreateHatchBrush(nIndex, crColor);
		return m_hBrush;
	}
	HBRUSH CreateBrushIndirect(const LOGBRUSH* lpLogBrush)
	{
		ATLASSERT(m_hBrush == NULL);
		m_hBrush = ::CreateBrushIndirect(lpLogBrush);
		return m_hBrush;
	}
	HBRUSH CreatePatternBrush(HBITMAP hBitmap)
	{
		ATLASSERT(m_hBrush == NULL);
		m_hBrush = ::CreatePatternBrush(hBitmap);
		return m_hBrush;
	}
	HBRUSH CreateDIBPatternBrush(HGLOBAL hPackedDIB, UINT nUsage)
	{
		ATLASSERT(hPackedDIB != NULL);
		const void* lpPackedDIB = ::GlobalLock(hPackedDIB);
		ATLASSERT(lpPackedDIB != NULL);
		m_hBrush = ::CreateDIBPatternBrushPt(lpPackedDIB, nUsage);
		::GlobalUnlock(hPackedDIB);
		return m_hBrush;
	}
	HBRUSH CreateDIBPatternBrush(const void* lpPackedDIB, UINT nUsage)
	{
		ATLASSERT(m_hBrush == NULL);
		m_hBrush = ::CreateDIBPatternBrushPt(lpPackedDIB, nUsage);
		return m_hBrush;
	}
	HBRUSH CreateSysColorBrush(int nIndex)
	{
		ATLASSERT(m_hBrush == NULL);
		m_hBrush = ::GetSysColorBrush(nIndex);
		return m_hBrush;
	}

	BOOL DeleteObject()
	{
		ATLASSERT(m_hBrush != NULL);
		BOOL bRet = ::DeleteObject(m_hBrush);
		if(bRet)
			m_hBrush = NULL;
		return bRet;
	}

// Attributes
	int GetLogBrush(LOGBRUSH* pLogBrush) const
	{
		ATLASSERT(m_hBrush != NULL);
		return ::GetObject(m_hBrush, sizeof(LOGBRUSH), pLogBrush);
	}
	bool GetLogBrush(LOGBRUSH& LogBrush) const
	{
		ATLASSERT(m_hBrush != NULL);
		return (::GetObject(m_hBrush, sizeof(LOGBRUSH), &LogBrush) == sizeof(LOGBRUSH));
	}
};


/////////////////////////////////////////////////////////////////////////////
// CFont

typedef CFontT<false>		CFontHandle;
typedef CFontT<true>		CFont;

template <bool t_bManaged>
class CFontT
{
public:
// Data members
	HFONT m_hFont;

// Constructor/destructor/operators
	CFontT(HFONT hFont = NULL) : m_hFont(hFont)
	{ }

	~CFontT()
	{
		if(t_bManaged && m_hFont != NULL)
			DeleteObject();
	}

	CFontT<t_bManaged>& operator=(HFONT hFont)
	{
		m_hFont = hFont;
		return *this;
	}

	void Attach(HFONT hFont)
	{
		m_hFont = hFont;
	}
	HFONT Detach()
	{
		HFONT hFont = m_hFont;
		m_hFont = NULL;
		return hFont;
	}

	operator HFONT() const { return m_hFont; }

	bool IsNull() const { return (m_hFont == NULL); }

// Create methods
	HFONT CreateFontIndirect(const LOGFONT* lpLogFont)
	{
		ATLASSERT(m_hFont == NULL);
		m_hFont = ::CreateFontIndirect(lpLogFont);
		return m_hFont;
	}

#if (_WIN32_WINNT >= 0x0500)
	HFONT CreateFontIndirectEx(CONST ENUMLOGFONTEXDV* penumlfex)
	{
		ATLASSERT(m_hFont == NULL);
		m_hFont = ::CreateFontIndirectEx(penumlfex);
		return m_hFont;
	}
#endif //(_WIN32_WINNT >= 0x0500)

	HFONT CreateFont(int nHeight, int nWidth, int nEscapement,
			int nOrientation, int nWeight, BYTE bItalic, BYTE bUnderline,
			BYTE cStrikeOut, BYTE nCharSet, BYTE nOutPrecision,
			BYTE nClipPrecision, BYTE nQuality, BYTE nPitchAndFamily,
			LPCTSTR lpszFacename)
	{
		ATLASSERT(m_hFont == NULL);
		m_hFont = ::CreateFont(nHeight, nWidth, nEscapement,
			nOrientation, nWeight, bItalic, bUnderline, cStrikeOut,
			nCharSet, nOutPrecision, nClipPrecision, nQuality,
			nPitchAndFamily, lpszFacename);
		return m_hFont;
	}
	HFONT CreatePointFont(int nPointSize, LPCTSTR lpszFaceName, HDC hDC = NULL)
	{
		LOGFONT logFont;
		memset(&logFont, 0, sizeof(LOGFONT));
		logFont.lfCharSet = DEFAULT_CHARSET;
		logFont.lfHeight = nPointSize;
		lstrcpyn(logFont.lfFaceName, lpszFaceName, sizeof(logFont.lfFaceName)/sizeof(TCHAR));
		return CreatePointFontIndirect(&logFont, hDC);
	}
	HFONT CreatePointFontIndirect(const LOGFONT* lpLogFont, HDC hDC = NULL)
	{
		HDC hDC1 = (hDC != NULL) ? hDC : (::GetDC(NULL));

		// convert nPointSize to logical units based on hDC
		LOGFONT logFont = *lpLogFont;
		POINT pt;
		pt.y = ::GetDeviceCaps(hDC1, LOGPIXELSY) * logFont.lfHeight;
		pt.y /= 720;    // 72 points/inch, 10 decipoints/point
		::DPtoLP(hDC1, &pt, 1);
		POINT ptOrg = { 0, 0 };
		::DPtoLP(hDC1, &ptOrg, 1);
		logFont.lfHeight = -abs(pt.y - ptOrg.y);

		if(hDC == NULL)
			::ReleaseDC(NULL, hDC1);

		return CreateFontIndirect(&logFont);
	}

	BOOL DeleteObject()
	{
		ATLASSERT(m_hFont != NULL);
		BOOL bRet = ::DeleteObject(m_hFont);
		if(bRet)
			m_hFont = NULL;
		return bRet;
	}

// Attributes
	int GetLogFont(LOGFONT* pLogFont) const
	{
		ATLASSERT(m_hFont != NULL);
		return ::GetObject(m_hFont, sizeof(LOGFONT), pLogFont);
	}
	bool GetLogFont(LOGFONT& LogFont) const
	{
		ATLASSERT(m_hFont != NULL);
		return (::GetObject(m_hFont, sizeof(LOGFONT), &LogFont) == sizeof(LOGFONT));
	}
};


/////////////////////////////////////////////////////////////////////////////
// CBitmap

typedef CBitmapT<false>		CBitmapHandle;
typedef CBitmapT<true>		CBitmap;

template <bool t_bManaged>
class CBitmapT
{
public:
// Data members
	HBITMAP m_hBitmap;

// Constructor/destructor/operators
	CBitmapT(HBITMAP hBitmap = NULL) : m_hBitmap(hBitmap)
	{ }

	~CBitmapT()
	{
		if(t_bManaged && m_hBitmap != NULL)
			DeleteObject();
	}

	CBitmapT<t_bManaged>& operator=(HBITMAP hBitmap)
	{
		m_hBitmap = hBitmap;
		return *this;
	}

	void Attach(HBITMAP hBitmap)
	{
		m_hBitmap = hBitmap;
	}
	HBITMAP Detach()
	{
		HBITMAP hBitmap = m_hBitmap;
		m_hBitmap = NULL;
		return hBitmap;
	}

	operator HBITMAP() const { return m_hBitmap; }

	bool IsNull() const { return (m_hBitmap == NULL); }

// Create and load methods
	HBITMAP LoadBitmap(_U_STRINGorID bitmap)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::LoadBitmap(_Module.GetResourceInstance(), bitmap.m_lpstr);
		return m_hBitmap;
	}
	HBITMAP LoadOEMBitmap(UINT nIDBitmap) // for OBM_/OCR_/OIC_
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::LoadBitmap(NULL, MAKEINTRESOURCE(nIDBitmap));
		return m_hBitmap;
	}
	HBITMAP LoadMappedBitmap(UINT nIDBitmap, UINT nFlags = 0, LPCOLORMAP lpColorMap = NULL, int nMapSize = 0)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::CreateMappedBitmap(_Module.GetResourceInstance(), nIDBitmap, (WORD)nFlags, lpColorMap, nMapSize);
		return m_hBitmap;
	}
	HBITMAP CreateBitmap(int nWidth, int nHeight, UINT nPlanes, UINT nBitcount, const void* lpBits)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::CreateBitmap(nWidth, nHeight, nPlanes, nBitcount, lpBits);
		return m_hBitmap;
	}
	HBITMAP CreateBitmapIndirect(LPBITMAP lpBitmap)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::CreateBitmapIndirect(lpBitmap);
		return m_hBitmap;
	}
	HBITMAP CreateCompatibleBitmap(HDC hDC, int nWidth, int nHeight)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::CreateCompatibleBitmap(hDC, nWidth, nHeight);
		return m_hBitmap;
	}
	HBITMAP CreateDiscardableBitmap(HDC hDC, int nWidth, int nHeight)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::CreateDiscardableBitmap(hDC, nWidth, nHeight);
		return m_hBitmap;
	}

	BOOL DeleteObject()
	{
		ATLASSERT(m_hBitmap != NULL);
		BOOL bRet = ::DeleteObject(m_hBitmap);
		if(bRet)
			m_hBitmap = NULL;
		return bRet;
	}

// Attributes
	int GetBitmap(BITMAP* pBitMap) const
	{
		ATLASSERT(m_hBitmap != NULL);
		return ::GetObject(m_hBitmap, sizeof(BITMAP), pBitMap);
	}
	bool GetBitmap(BITMAP& bm) const
	{
		ATLASSERT(m_hBitmap != NULL);
		return (::GetObject(m_hBitmap, sizeof(BITMAP), &bm) == sizeof(BITMAP));
	}
	bool GetSize(SIZE& size) const
	{
		ATLASSERT(m_hBitmap != NULL);
		BITMAP bm;
		if(!GetBitmap(&bm))
			return false;
		size.cx = bm.bmWidth;
		size.cy = bm.bmHeight;
		return true;
	}

	DWORD GetBitmapBits(DWORD dwCount, LPVOID lpBits) const
	{
		ATLASSERT(m_hBitmap != NULL);
		return ::GetBitmapBits(m_hBitmap, dwCount, lpBits);
	}
	DWORD SetBitmapBits(DWORD dwCount, const void* lpBits)
	{
		ATLASSERT(m_hBitmap != NULL);
		return ::SetBitmapBits(m_hBitmap, dwCount, lpBits);
	}
	BOOL GetBitmapDimension(LPSIZE lpSize) const
	{
		ATLASSERT(m_hBitmap != NULL);
		return ::GetBitmapDimensionEx(m_hBitmap, lpSize);
	}
	BOOL SetBitmapDimension(int nWidth, int nHeight, LPSIZE lpSize = NULL)
	{
		ATLASSERT(m_hBitmap != NULL);
		return ::SetBitmapDimensionEx(m_hBitmap, nWidth, nHeight, lpSize);
	}

// DIB support
	HBITMAP CreateDIBitmap(HDC hDC, CONST BITMAPINFOHEADER* lpbmih, DWORD dwInit, CONST VOID* lpbInit, CONST BITMAPINFO* lpbmi, UINT uColorUse)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::CreateDIBitmap(hDC, lpbmih, dwInit, lpbInit, lpbmi, uColorUse);
		return m_hBitmap;
	}
	HBITMAP CreateDIBSection(HDC hDC, CONST BITMAPINFO* lpbmi, UINT uColorUse, VOID** ppvBits, HANDLE hSection, DWORD dwOffset)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::CreateDIBSection(hDC, lpbmi, uColorUse, ppvBits, hSection, dwOffset);
		return m_hBitmap;
	}
	int GetDIBits(HDC hDC, UINT uStartScan, UINT cScanLines,  LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT uColorUse) const
	{
		ATLASSERT(m_hBitmap != NULL);
		return ::GetDIBits(hDC, m_hBitmap, uStartScan, cScanLines,  lpvBits, lpbmi, uColorUse);
	}
	int SetDIBits(HDC hDC, UINT uStartScan, UINT cScanLines, CONST VOID* lpvBits, CONST BITMAPINFO* lpbmi, UINT uColorUse)
	{
		ATLASSERT(m_hBitmap != NULL);
		return ::SetDIBits(hDC, m_hBitmap, uStartScan, cScanLines, lpvBits, lpbmi, uColorUse);
	}
};


/////////////////////////////////////////////////////////////////////////////
// CPalette

typedef CPaletteT<false>	CPaletteHandle;
typedef CPaletteT<true>		CPalette;

template <bool t_bManaged>
class CPaletteT
{
public:
// Data members
	HPALETTE m_hPalette;

// Constructor/destructor/operators
	CPaletteT(HPALETTE hPalette = NULL) : m_hPalette(hPalette)
	{ }

	~CPaletteT()
	{
		if(t_bManaged && m_hPalette != NULL)
			DeleteObject();
	}

	CPaletteT<t_bManaged>& operator=(HPALETTE hPalette)
	{
		m_hPalette = hPalette;
		return *this;
	}

	void Attach(HPALETTE hPalette)
	{
		m_hPalette = hPalette;
	}
	HPALETTE Detach()
	{
		HPALETTE hPalette = m_hPalette;
		m_hPalette = NULL;
		return hPalette;
	}

	operator HPALETTE() const { return m_hPalette; }

	bool IsNull() const { return (m_hPalette == NULL); }

// Create methods
	HPALETTE CreatePalette(LPLOGPALETTE lpLogPalette)
	{
		ATLASSERT(m_hPalette == NULL);
		m_hPalette = ::CreatePalette(lpLogPalette);
		return m_hPalette;
	}
	HPALETTE CreateHalftonePalette(HDC hDC)
	{
		ATLASSERT(m_hPalette == NULL);
		ATLASSERT(hDC != NULL);
		m_hPalette = ::CreateHalftonePalette(hDC);
		return m_hPalette;
	}

	BOOL DeleteObject()
	{
		ATLASSERT(m_hPalette != NULL);
		BOOL bRet = ::DeleteObject(m_hPalette);
		if(bRet)
			m_hPalette = NULL;
		return bRet;
	}

// Attributes
	int GetEntryCount() const
	{
		ATLASSERT(m_hPalette != NULL);
		WORD nEntries;
		::GetObject(m_hPalette, sizeof(WORD), &nEntries);
		return (int)nEntries;
	}
	UINT GetPaletteEntries(UINT nStartIndex, UINT nNumEntries, LPPALETTEENTRY lpPaletteColors) const
	{
		ATLASSERT(m_hPalette != NULL);
		return ::GetPaletteEntries(m_hPalette, nStartIndex, nNumEntries, lpPaletteColors);
	}
	UINT SetPaletteEntries(UINT nStartIndex, UINT nNumEntries, LPPALETTEENTRY lpPaletteColors)
	{
		ATLASSERT(m_hPalette != NULL);
		return ::SetPaletteEntries(m_hPalette, nStartIndex, nNumEntries, lpPaletteColors);
	}

// Operations
	void AnimatePalette(UINT nStartIndex, UINT nNumEntries, LPPALETTEENTRY lpPaletteColors)
	{
		ATLASSERT(m_hPalette != NULL);
		::AnimatePalette(m_hPalette, nStartIndex, nNumEntries, lpPaletteColors);
	}
	BOOL ResizePalette(UINT nNumEntries)
	{
		ATLASSERT(m_hPalette != NULL);
		return ::ResizePalette(m_hPalette, nNumEntries);
	}
	UINT GetNearestPaletteIndex(COLORREF crColor) const
	{
		ATLASSERT(m_hPalette != NULL);
		return ::GetNearestPaletteIndex(m_hPalette, crColor);
	}
};


/////////////////////////////////////////////////////////////////////////////
// CRgn

typedef CRgnT<false>		CRgnHandle;
typedef CRgnT<true>		CRgn;

template <bool t_bManaged>
class CRgnT
{
public:
// Data members
	HRGN m_hRgn;

// Constructor/destructor/operators
	CRgnT(HRGN hRgn = NULL) : m_hRgn(hRgn)
	{ }

	~CRgnT()
	{
		if(t_bManaged && m_hRgn != NULL)
			DeleteObject();
	}

	CRgnT<t_bManaged>& operator=(HRGN hRgn)
	{
		m_hRgn = hRgn;
		return *this;
	}

	void Attach(HRGN hRgn)
	{
		m_hRgn = hRgn;
	}
	HRGN Detach()
	{
		HRGN hRgn = m_hRgn;
		m_hRgn = NULL;
		return hRgn;
	}

	operator HRGN() const { return m_hRgn; }

	bool IsNull() const { return (m_hRgn == NULL); }

// Create methods
	HRGN CreateRectRgn(int x1, int y1, int x2, int y2)
	{
		ATLASSERT(m_hRgn == NULL);
		m_hRgn = ::CreateRectRgn(x1, y1, x2, y2);
		return m_hRgn;
	}
	HRGN CreateRectRgnIndirect(LPCRECT lpRect)
	{
		ATLASSERT(m_hRgn == NULL);
		m_hRgn = ::CreateRectRgnIndirect(lpRect);
		return m_hRgn;
	}
	HRGN CreateEllipticRgn(int x1, int y1, int x2, int y2)
	{
		ATLASSERT(m_hRgn == NULL);
		m_hRgn = ::CreateEllipticRgn(x1, y1, x2, y2);
		return m_hRgn;
	}
	HRGN CreateEllipticRgnIndirect(LPCRECT lpRect)
	{
		ATLASSERT(m_hRgn == NULL);
		m_hRgn = ::CreateEllipticRgnIndirect(lpRect);
		return m_hRgn;
	}
	HRGN CreatePolygonRgn(LPPOINT lpPoints, int nCount, int nMode)
	{
		ATLASSERT(m_hRgn == NULL);
		m_hRgn = ::CreatePolygonRgn(lpPoints, nCount, nMode);
		return m_hRgn;
	}
	HRGN CreatePolyPolygonRgn(LPPOINT lpPoints, LPINT lpPolyCounts, int nCount, int nPolyFillMode)
	{
		ATLASSERT(m_hRgn == NULL);
		m_hRgn = ::CreatePolyPolygonRgn(lpPoints, lpPolyCounts, nCount, nPolyFillMode);
		return m_hRgn;
	}
	HRGN CreateRoundRectRgn(int x1, int y1, int x2, int y2, int x3, int y3)
	{
		ATLASSERT(m_hRgn == NULL);
		m_hRgn = ::CreateRoundRectRgn(x1, y1, x2, y2, x3, y3);
		return m_hRgn;
	}
	HRGN CreateFromPath(HDC hDC)
	{
		ATLASSERT(m_hRgn == NULL);
		ATLASSERT(hDC != NULL);
		m_hRgn = ::PathToRegion(hDC);
		return m_hRgn;
	}
	HRGN CreateFromData(const XFORM* lpXForm, int nCount, const RGNDATA* pRgnData)
	{
		ATLASSERT(m_hRgn == NULL);
		m_hRgn = ::ExtCreateRegion(lpXForm, nCount, pRgnData);
		return m_hRgn;
	}

	BOOL DeleteObject()
	{
		ATLASSERT(m_hRgn != NULL);
		BOOL bRet = ::DeleteObject(m_hRgn);
		if(bRet)
			m_hRgn = NULL;
		return bRet;
	}

// Operations
	void SetRectRgn(int x1, int y1, int x2, int y2)
	{
		ATLASSERT(m_hRgn != NULL);
		::SetRectRgn(m_hRgn, x1, y1, x2, y2);
	}
	void SetRectRgn(LPCRECT lpRect)
	{
		ATLASSERT(m_hRgn != NULL);
		::SetRectRgn(m_hRgn, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom);
	}
	int CombineRgn(HRGN hRgnSrc1, HRGN hRgnSrc2, int nCombineMode)
	{
		ATLASSERT(m_hRgn != NULL);
		return ::CombineRgn(m_hRgn, hRgnSrc1, hRgnSrc2, nCombineMode);
	}
	int CombineRgn(HRGN hRgnSrc, int nCombineMode)
	{
		ATLASSERT(m_hRgn != NULL);
		return ::CombineRgn(m_hRgn, m_hRgn, hRgnSrc, nCombineMode);
	}
	int CopyRgn(HRGN hRgnSrc)
	{
		ATLASSERT(m_hRgn != NULL);
		return ::CombineRgn(m_hRgn, hRgnSrc, NULL, RGN_COPY);
	}
	BOOL EqualRgn(HRGN hRgn) const
	{
		ATLASSERT(m_hRgn != NULL);
		return ::EqualRgn(m_hRgn, hRgn);
	}
	int OffsetRgn(int x, int y)
	{
		ATLASSERT(m_hRgn != NULL);
		return ::OffsetRgn(m_hRgn, x, y);
	}
	int OffsetRgn(POINT point)
	{
		ATLASSERT(m_hRgn != NULL);
		return ::OffsetRgn(m_hRgn, point.x, point.y);
	}
	int GetRgnBox(LPRECT lpRect) const
	{
		ATLASSERT(m_hRgn != NULL);
		return ::GetRgnBox(m_hRgn, lpRect);
	}
	BOOL PtInRegion(int x, int y) const
	{
		ATLASSERT(m_hRgn != NULL);
		return ::PtInRegion(m_hRgn, x, y);
	}
	BOOL PtInRegion(POINT point) const
	{
		ATLASSERT(m_hRgn != NULL);
		return ::PtInRegion(m_hRgn, point.x, point.y);
	}
	BOOL RectInRegion(LPCRECT lpRect) const
	{
		ATLASSERT(m_hRgn != NULL);
		return ::RectInRegion(m_hRgn, lpRect);
	}
	int GetRegionData(LPRGNDATA lpRgnData, int nDataSize) const
	{
		ATLASSERT(m_hRgn != NULL);
		return (int)::GetRegionData(m_hRgn, nDataSize, lpRgnData);
	}
};


/////////////////////////////////////////////////////////////////////////////
// CDC - The device context class

typedef CDCT<false>		CDCHandle;
typedef CDCT<true>		CDC;

template <bool t_bManaged>
class CDCT
{
public:
// Data members
	HDC m_hDC;

// Constructor/destructor/operators
	CDCT(HDC hDC = NULL) : m_hDC(hDC)
	{
	}

	~CDCT()
	{
		if(t_bManaged && m_hDC != NULL)
			::DeleteDC(Detach());
	}

	CDCT<t_bManaged>& operator=(HDC hDC)
	{
		m_hDC = hDC;
		return *this;
	}

	void Attach(HDC hDC)
	{
		m_hDC = hDC;
	}

	HDC Detach()
	{
		HDC hDC = m_hDC;
		m_hDC = NULL;
		return hDC;
	}

	operator HDC() const { return m_hDC; }

	bool IsNull() const { return (m_hDC == NULL); }

// Operations
	HWND WindowFromDC() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::WindowFromDC(m_hDC);
	}

	CPenHandle GetCurrentPen() const
	{
		ATLASSERT(m_hDC != NULL);
		return CPenHandle((HPEN)::GetCurrentObject(m_hDC, OBJ_PEN));
	}
	CBrushHandle GetCurrentBrush() const
	{
		ATLASSERT(m_hDC != NULL);
		return CBrushHandle((HBRUSH)::GetCurrentObject(m_hDC, OBJ_BRUSH));
	}
	CPaletteHandle GetCurrentPalette() const
	{
		ATLASSERT(m_hDC != NULL);
		return CPaletteHandle((HPALETTE)::GetCurrentObject(m_hDC, OBJ_PAL));
	}
	CFontHandle GetCurrentFont() const
	{
		ATLASSERT(m_hDC != NULL);
		return CFontHandle((HFONT)::GetCurrentObject(m_hDC, OBJ_FONT));
	}
	CBitmapHandle GetCurrentBitmap() const
	{
		ATLASSERT(m_hDC != NULL);
		return CBitmapHandle((HBITMAP)::GetCurrentObject(m_hDC, OBJ_BITMAP));
	}

	HDC CreateDC(LPCTSTR lpszDriverName, LPCTSTR lpszDeviceName, LPCTSTR lpszOutput, const DEVMODE* lpInitData)
	{
		ATLASSERT(m_hDC == NULL);
		m_hDC = ::CreateDC(lpszDriverName, lpszDeviceName, lpszOutput, lpInitData);
		return m_hDC;
	}

	HDC CreateCompatibleDC(HDC hDC = NULL)
	{
		ATLASSERT(m_hDC == NULL);
		m_hDC = ::CreateCompatibleDC(hDC);
		return m_hDC;
	}

	BOOL DeleteDC()
	{
		if(m_hDC == NULL)
			return FALSE;

		return ::DeleteDC(Detach());
	}

// Device-Context Functions
	int SaveDC()
	{
		ATLASSERT(m_hDC != NULL);
		return ::SaveDC(m_hDC);
	}

	BOOL RestoreDC(int nSavedDC)
	{
		ATLASSERT(m_hDC != NULL);
		return ::RestoreDC(m_hDC, nSavedDC);
	}

	int GetDeviceCaps(int nIndex) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetDeviceCaps(m_hDC, nIndex);
	}
	UINT SetBoundsRect(LPCRECT lpRectBounds, UINT flags)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetBoundsRect(m_hDC, lpRectBounds, flags);
	}
	UINT GetBoundsRect(LPRECT lpRectBounds, UINT flags) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetBoundsRect(m_hDC, lpRectBounds, flags);
	}
	BOOL ResetDC(const DEVMODE* lpDevMode)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ResetDC(m_hDC, lpDevMode) != NULL;
	}

// Drawing-Tool Functions
	BOOL GetBrushOrg(LPPOINT lpPoint) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetBrushOrgEx(m_hDC, lpPoint);
	}
	BOOL SetBrushOrg(int x, int y, LPPOINT lpPoint = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetBrushOrgEx(m_hDC, x, y, lpPoint);
	}
	BOOL SetBrushOrg(POINT point, LPPOINT lpPointRet = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetBrushOrgEx(m_hDC, point.x, point.y, lpPointRet);
	}
	int EnumObjects(int nObjectType, int (CALLBACK* lpfn)(LPVOID, LPARAM), LPARAM lpData)
	{
		ATLASSERT(m_hDC != NULL);
#ifdef STRICT
		return ::EnumObjects(m_hDC, nObjectType, (GOBJENUMPROC)lpfn, lpData);
#else
		return ::EnumObjects(m_hDC, nObjectType, (GOBJENUMPROC)lpfn, (LPVOID)lpData);
#endif
	}

// Type-safe selection helpers
	HPEN SelectPen(HPEN hPen)
	{
		ATLASSERT(m_hDC != NULL);
		ATLASSERT(hPen == NULL || ::GetObjectType(hPen) == OBJ_PEN || ::GetObjectType(hPen) == OBJ_EXTPEN);
		return (HPEN)::SelectObject(m_hDC, hPen);
	}
	HBRUSH SelectBrush(HBRUSH hBrush)
	{
		ATLASSERT(m_hDC != NULL);
		ATLASSERT(hBrush == NULL || ::GetObjectType(hBrush) == OBJ_BRUSH);
		return (HBRUSH)::SelectObject(m_hDC, hBrush);
	}
	HFONT SelectFont(HFONT hFont)
	{
		ATLASSERT(m_hDC != NULL);
		ATLASSERT(hFont == NULL || ::GetObjectType(hFont) == OBJ_FONT);
		return (HFONT)::SelectObject(m_hDC, hFont);
	}
	HBITMAP SelectBitmap(HBITMAP hBitmap)
	{
		ATLASSERT(m_hDC != NULL);
		ATLASSERT(hBitmap == NULL || ::GetObjectType(hBitmap) == OBJ_BITMAP);
		return (HBITMAP)::SelectObject(m_hDC, hBitmap);
	}
	int SelectRgn(HRGN hRgn)       // special return for regions
	{
		ATLASSERT(m_hDC != NULL);
		ATLASSERT(hRgn == NULL || ::GetObjectType(hRgn) == OBJ_REGION);
		return PtrToInt(::SelectObject(m_hDC, hRgn));
	}
// Type-safe selection helpers for stock objects
	HPEN SelectStockPen(int nPen)
	{
		ATLASSERT(m_hDC != NULL);
#if (_WIN32_WINNT >= 0x0500)
		ATLASSERT(nPen == WHITE_PEN || nPen == BLACK_PEN || nPen == NULL_PEN || nPen == DC_PEN);
#else
		ATLASSERT(nPen == WHITE_PEN || nPen == BLACK_PEN || nPen == NULL_PEN);
#endif //!(_WIN32_WINNT >= 0x0500)
		return SelectPen((HPEN)::GetStockObject(nPen));
	}
	HBRUSH SelectStockBrush(int nBrush)
	{
#if (_WIN32_WINNT >= 0x0500)
		ATLASSERT((nBrush >= WHITE_BRUSH && nBrush <= HOLLOW_BRUSH) || nBrush == DC_BRUSH);
#else
		ATLASSERT(nBrush >= WHITE_BRUSH && nBrush <= HOLLOW_BRUSH);
#endif //!(_WIN32_WINNT >= 0x0500)
		return SelectBrush((HBRUSH)::GetStockObject(nBrush));
	}
	HFONT SelectStockFont(int nFont)
	{
		ATLASSERT((nFont >= OEM_FIXED_FONT && nFont <= SYSTEM_FIXED_FONT) || nFont == DEFAULT_GUI_FONT);
		return SelectFont((HFONT)::GetStockObject(nFont));
	}
	HPALETTE SelectStockPalette(int nPalette, BOOL bForceBackground)
	{
		ATLASSERT(nPalette == DEFAULT_PALETTE); // the only one supported
		return SelectPalette((HPALETTE)::GetStockObject(nPalette), bForceBackground);
	}

// Color and Color Palette Functions
	COLORREF GetNearestColor(COLORREF crColor) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetNearestColor(m_hDC, crColor);
	}
	HPALETTE SelectPalette(HPALETTE hPalette, BOOL bForceBackground)
	{
		ATLASSERT(m_hDC != NULL);

		return ::SelectPalette(m_hDC, hPalette, bForceBackground);
	}
	UINT RealizePalette()
	{
		ATLASSERT(m_hDC != NULL);
		return ::RealizePalette(m_hDC);
	}
	void UpdateColors()
	{
		ATLASSERT(m_hDC != NULL);
		::UpdateColors(m_hDC);
	}

// Drawing-Attribute Functions
	COLORREF GetBkColor() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetBkColor(m_hDC);
	}
	int GetBkMode() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetBkMode(m_hDC);
	}
	int GetPolyFillMode() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetPolyFillMode(m_hDC);
	}
	int GetROP2() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetROP2(m_hDC);
	}
	int GetStretchBltMode() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetStretchBltMode(m_hDC);
	}
	COLORREF GetTextColor() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetTextColor(m_hDC);
	}

	COLORREF SetBkColor(COLORREF crColor)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetBkColor(m_hDC, crColor);
	}
	int SetBkMode(int nBkMode)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetBkMode(m_hDC, nBkMode);
	}
	int SetPolyFillMode(int nPolyFillMode)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetPolyFillMode(m_hDC, nPolyFillMode);
	}
	int SetROP2(int nDrawMode)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetROP2(m_hDC, nDrawMode);
	}
	int SetStretchBltMode(int nStretchMode)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetStretchBltMode(m_hDC, nStretchMode);
	}
	COLORREF SetTextColor(COLORREF crColor)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetTextColor(m_hDC, crColor);
	}

	BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetColorAdjustment(m_hDC, lpColorAdjust);
	}
	BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetColorAdjustment(m_hDC, lpColorAdjust);
	}

// Mapping Functions
	int GetMapMode() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetMapMode(m_hDC);
	}
	BOOL GetViewportOrg(LPPOINT lpPoint) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetViewportOrgEx(m_hDC, lpPoint);
	}
	int SetMapMode(int nMapMode)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetMapMode(m_hDC, nMapMode);
	}
	// Viewport Origin
	BOOL SetViewportOrg(int x, int y, LPPOINT lpPoint = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetViewportOrgEx(m_hDC, x, y, lpPoint);
	}
	BOOL SetViewportOrg(POINT point, LPPOINT lpPointRet = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return SetViewportOrg(point.x, point.y, lpPointRet);
	}
	BOOL OffsetViewportOrg(int nWidth, int nHeight, LPPOINT lpPoint = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::OffsetViewportOrgEx(m_hDC, nWidth, nHeight, lpPoint);
	}

	// Viewport Extent
	BOOL GetViewportExt(LPSIZE lpSize) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetViewportExtEx(m_hDC, lpSize);
	}
	BOOL SetViewportExt(int x, int y, LPSIZE lpSize = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetViewportExtEx(m_hDC, x, y, lpSize);
	}
	BOOL SetViewportExt(SIZE size, LPSIZE lpSizeRet = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return SetViewportExt(size.cx, size.cy, lpSizeRet);
	}
	BOOL ScaleViewportExt(int xNum, int xDenom, int yNum, int yDenom, LPSIZE lpSize = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ScaleViewportExtEx(m_hDC, xNum, xDenom, yNum, yDenom, lpSize);
	}

	// Window Origin
	BOOL GetWindowOrg(LPPOINT lpPoint) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetWindowOrgEx(m_hDC, lpPoint);
	}
	BOOL SetWindowOrg(int x, int y, LPPOINT lpPoint = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetWindowOrgEx(m_hDC, x, y, lpPoint);
	}
	BOOL SetWindowOrg(POINT point, LPPOINT lpPointRet = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return SetWindowOrg(point.x, point.y, lpPointRet);
	}
	BOOL OffsetWindowOrg(int nWidth, int nHeight, LPPOINT lpPoint = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::OffsetWindowOrgEx(m_hDC, nWidth, nHeight, lpPoint);
	}

	// Window extent
	BOOL GetWindowExt(LPSIZE lpSize) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetWindowExtEx(m_hDC, lpSize);
	}
	BOOL SetWindowExt(int x, int y, LPSIZE lpSize = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetWindowExtEx(m_hDC, x, y, lpSize);
	}
	BOOL SetWindowExt(SIZE size, LPSIZE lpSizeRet)
	{
		ATLASSERT(m_hDC != NULL);
		return SetWindowExt(size.cx, size.cy, lpSizeRet);
	}
	BOOL ScaleWindowExt(int xNum, int xDenom, int yNum, int yDenom, LPSIZE lpSize = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ScaleWindowExtEx(m_hDC, xNum, xDenom, yNum, yDenom, lpSize);
	}

// Coordinate Functions
	BOOL DPtoLP(LPPOINT lpPoints, int nCount = 1) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::DPtoLP(m_hDC, lpPoints, nCount);
	}
	BOOL DPtoLP(LPRECT lpRect) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::DPtoLP(m_hDC, (LPPOINT)lpRect, 2);
	}
	BOOL DPtoLP(LPSIZE lpSize) const
	{
		SIZE sizeWinExt;
		if(!GetWindowExt(&sizeWinExt))
			return FALSE;
		SIZE sizeVpExt;
		if(!GetViewportExt(&sizeVpExt))
			return FALSE;
		lpSize->cx = MulDiv(lpSize->cx, abs(sizeWinExt.cx), abs(sizeVpExt.cx));
		lpSize->cy = MulDiv(lpSize->cy, abs(sizeWinExt.cy), abs(sizeVpExt.cy));
		return TRUE;
	}
	BOOL LPtoDP(LPPOINT lpPoints, int nCount = 1) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::LPtoDP(m_hDC, lpPoints, nCount);
	}
	BOOL LPtoDP(LPRECT lpRect) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::LPtoDP(m_hDC, (LPPOINT)lpRect, 2);
	}
	BOOL LPtoDP(LPSIZE lpSize) const
	{
		SIZE sizeWinExt;
		if(!GetWindowExt(&sizeWinExt))
			return FALSE;
		SIZE sizeVpExt;
		if(!GetViewportExt(&sizeVpExt))
			return FALSE;
		lpSize->cx = ::MulDiv(lpSize->cx, abs(sizeVpExt.cx), abs(sizeWinExt.cx));
		lpSize->cy = ::MulDiv(lpSize->cy, abs(sizeVpExt.cy), abs(sizeWinExt.cy));
		return TRUE;
	}

// Special Coordinate Functions (useful for dealing with metafiles and OLE)
	#define HIMETRIC_INCH   2540    // HIMETRIC units per inch

	void DPtoHIMETRIC(LPSIZE lpSize) const
	{
		ATLASSERT(m_hDC != NULL);
		int nMapMode;
		if((nMapMode = GetMapMode()) < MM_ISOTROPIC && nMapMode != MM_TEXT)
		{
			// when using a constrained map mode, map against physical inch
			((CDCHandle*)this)->SetMapMode(MM_HIMETRIC);
			DPtoLP(lpSize);
			((CDCHandle*)this)->SetMapMode(nMapMode);
		}
		else
		{
			// map against logical inch for non-constrained mapping modes
			int cxPerInch = GetDeviceCaps(LOGPIXELSX);
			int cyPerInch = GetDeviceCaps(LOGPIXELSY);
			ATLASSERT(cxPerInch != 0 && cyPerInch != 0);
			lpSize->cx = MulDiv(lpSize->cx, HIMETRIC_INCH, cxPerInch);
			lpSize->cy = MulDiv(lpSize->cy, HIMETRIC_INCH, cyPerInch);
		}
	}

	void HIMETRICtoDP(LPSIZE lpSize) const
	{
		ATLASSERT(m_hDC != NULL);
		int nMapMode;
		if((nMapMode = GetMapMode()) < MM_ISOTROPIC && nMapMode != MM_TEXT)
		{
			// when using a constrained map mode, map against physical inch
			((CDCHandle*)this)->SetMapMode(MM_HIMETRIC);
			LPtoDP(lpSize);
			((CDCHandle*)this)->SetMapMode(nMapMode);
		}
		else
		{
			// map against logical inch for non-constrained mapping modes
			int cxPerInch = GetDeviceCaps(LOGPIXELSX);
			int cyPerInch = GetDeviceCaps(LOGPIXELSY);
			ATLASSERT(cxPerInch != 0 && cyPerInch != 0);
			lpSize->cx = MulDiv(lpSize->cx, cxPerInch, HIMETRIC_INCH);
			lpSize->cy = MulDiv(lpSize->cy, cyPerInch, HIMETRIC_INCH);
		}
	}

	void LPtoHIMETRIC(LPSIZE lpSize) const
	{
		LPtoDP(lpSize);
		DPtoHIMETRIC(lpSize);
	}

	void HIMETRICtoLP(LPSIZE lpSize) const
	{
		HIMETRICtoDP(lpSize);
		DPtoLP(lpSize);
	}

// Region Functions
	BOOL FillRgn(HRGN hRgn, HBRUSH hBrush)
	{
		ATLASSERT(m_hDC != NULL);
		return ::FillRgn(m_hDC, hRgn, hBrush);
	}
	BOOL FrameRgn(HRGN hRgn, HBRUSH hBrush, int nWidth, int nHeight)
	{
		ATLASSERT(m_hDC != NULL);
		return ::FrameRgn(m_hDC, hRgn, hBrush, nWidth, nHeight);
	}
	BOOL InvertRgn(HRGN hRgn)
	{
		ATLASSERT(m_hDC != NULL);
		return ::InvertRgn(m_hDC, hRgn);
	}
	BOOL PaintRgn(HRGN hRgn)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PaintRgn(m_hDC, hRgn);
	}

// Clipping Functions
	int GetClipBox(LPRECT lpRect) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetClipBox(m_hDC, lpRect);
	}
	BOOL PtVisible(int x, int y) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::PtVisible(m_hDC, x, y);
	}
	BOOL PtVisible(POINT point) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::PtVisible(m_hDC, point.x, point.y);
	}
	BOOL RectVisible(LPCRECT lpRect) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::RectVisible(m_hDC, lpRect);
	}
	int SelectClipRgn(HRGN hRgn)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SelectClipRgn(m_hDC, (HRGN)hRgn);
	}
	int ExcludeClipRect(int x1, int y1, int x2, int y2)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ExcludeClipRect(m_hDC, x1, y1, x2, y2);
	}
	int ExcludeClipRect(LPCRECT lpRect)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ExcludeClipRect(m_hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom);
	}
	int ExcludeUpdateRgn(HWND hWnd)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ExcludeUpdateRgn(m_hDC, hWnd);
	}
	int IntersectClipRect(int x1, int y1, int x2, int y2)
	{
		ATLASSERT(m_hDC != NULL);
		return ::IntersectClipRect(m_hDC, x1, y1, x2, y2);
	}
	int IntersectClipRect(LPCRECT lpRect)
	{
		ATLASSERT(m_hDC != NULL);
		return ::IntersectClipRect(m_hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom);
	}
	int OffsetClipRgn(int x, int y)
	{
		ATLASSERT(m_hDC != NULL);
		return ::OffsetClipRgn(m_hDC, x, y);
	}
	int OffsetClipRgn(SIZE size)
	{
		ATLASSERT(m_hDC != NULL);
		return ::OffsetClipRgn(m_hDC, size.cx, size.cy);
	}
	int SelectClipRgn(HRGN hRgn, int nMode)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ExtSelectClipRgn(m_hDC, hRgn, nMode);
	}

// Line-Output Functions
	BOOL GetCurrentPosition(LPPOINT lpPoint) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetCurrentPositionEx(m_hDC, lpPoint);
	}
	BOOL MoveTo(int x, int y, LPPOINT lpPoint = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::MoveToEx(m_hDC, x, y, lpPoint);
	}
	BOOL MoveTo(POINT point, LPPOINT lpPointRet = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return MoveTo(point.x, point.y, lpPointRet);
	}
	BOOL LineTo(int x, int y)
	{
		ATLASSERT(m_hDC != NULL);
		return ::LineTo(m_hDC, x, y);
	}
	BOOL LineTo(POINT point)
	{
		ATLASSERT(m_hDC != NULL);
		return LineTo(point.x, point.y);
	}
	BOOL Arc(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Arc(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4);
	}
	BOOL Arc(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Arc(m_hDC, lpRect->left, lpRect->top,
			lpRect->right, lpRect->bottom, ptStart.x, ptStart.y,
			ptEnd.x, ptEnd.y);
	}
	BOOL Polyline(LPPOINT lpPoints, int nCount)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Polyline(m_hDC, lpPoints, nCount);
	}

	BOOL AngleArc(int x, int y, int nRadius, float fStartAngle, float fSweepAngle)
	{
		ATLASSERT(m_hDC != NULL);
		return ::AngleArc(m_hDC, x, y, nRadius, fStartAngle, fSweepAngle);
	}
	BOOL ArcTo(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ArcTo(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4);
	}
	BOOL ArcTo(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
	{
		ATLASSERT(m_hDC != NULL);
		return ArcTo(lpRect->left, lpRect->top, lpRect->right,
		lpRect->bottom, ptStart.x, ptStart.y, ptEnd.x, ptEnd.y);
	}
	int GetArcDirection() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetArcDirection(m_hDC);
	}
	int SetArcDirection(int nArcDirection)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetArcDirection(m_hDC, nArcDirection);
	}

	BOOL PolyDraw(const POINT* lpPoints, const BYTE* lpTypes, int nCount)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PolyDraw(m_hDC, lpPoints, lpTypes, nCount);
	}
	BOOL PolylineTo(const POINT* lpPoints, int nCount)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PolylineTo(m_hDC, lpPoints, nCount);
	}
	BOOL PolyPolyline(const POINT* lpPoints,
		const DWORD* lpPolyPoints, int nCount)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PolyPolyline(m_hDC, lpPoints, lpPolyPoints, nCount);
	}

	BOOL PolyBezier(const POINT* lpPoints, int nCount)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PolyBezier(m_hDC, lpPoints, nCount);
	}
	BOOL PolyBezierTo(const POINT* lpPoints, int nCount)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PolyBezierTo(m_hDC, lpPoints, nCount);
	}

// Simple Drawing Functions
	BOOL FillRect(LPCRECT lpRect, HBRUSH hBrush)
	{
		ATLASSERT(m_hDC != NULL);
		return ::FillRect(m_hDC, lpRect, hBrush);
	}
	BOOL FrameRect(LPCRECT lpRect, HBRUSH hBrush)
	{
		ATLASSERT(m_hDC != NULL);
		return ::FrameRect(m_hDC, lpRect, hBrush);
	}
	BOOL InvertRect(LPCRECT lpRect)
	{
		ATLASSERT(m_hDC != NULL);
		return ::InvertRect(m_hDC, lpRect);
	}
	BOOL DrawIcon(int x, int y, HICON hIcon)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawIcon(m_hDC, x, y, hIcon);
	}
	BOOL DrawIcon(POINT point, HICON hIcon)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawIcon(m_hDC, point.x, point.y, hIcon);
	}

	BOOL DrawState(POINT pt, SIZE size, HBITMAP hBitmap, UINT nFlags, HBRUSH hBrush = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawState(m_hDC, hBrush, NULL, (LPARAM)hBitmap, 0, pt.x, pt.y, size.cx, size.cy, nFlags | DST_BITMAP);
	}
	BOOL DrawState(POINT pt, SIZE size, HICON hIcon, UINT nFlags, HBRUSH hBrush = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawState(m_hDC, hBrush, NULL, (LPARAM)hIcon, 0, pt.x, pt.y, size.cx, size.cy, nFlags | DST_ICON);
	}
	BOOL DrawState(POINT pt, SIZE size, LPCTSTR lpszText, UINT nFlags, BOOL bPrefixText = TRUE, int nTextLen = 0, HBRUSH hBrush = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawState(m_hDC, hBrush, NULL, (LPARAM)lpszText, (WPARAM)nTextLen, pt.x, pt.y, size.cx, size.cy, nFlags | (bPrefixText ? DST_PREFIXTEXT : DST_TEXT));
	}
	BOOL DrawState(POINT pt, SIZE size, DRAWSTATEPROC lpDrawProc, LPARAM lData, UINT nFlags, HBRUSH hBrush = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawState(m_hDC, hBrush, lpDrawProc, lData, 0, pt.x, pt.y, size.cx, size.cy, nFlags | DST_COMPLEX);
	}

// Ellipse and Polygon Functions
	BOOL Chord(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Chord(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4);
	}
	BOOL Chord(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Chord(m_hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom, ptStart.x, ptStart.y, ptEnd.x, ptEnd.y);
	}
	void DrawFocusRect(LPCRECT lpRect)
	{
		ATLASSERT(m_hDC != NULL);
		::DrawFocusRect(m_hDC, lpRect);
	}
	BOOL Ellipse(int x1, int y1, int x2, int y2)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Ellipse(m_hDC, x1, y1, x2, y2);
	}
	BOOL Ellipse(LPCRECT lpRect)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Ellipse(m_hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom);
	}
	BOOL Pie(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Pie(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4);
	}
	BOOL Pie(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Pie(m_hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom, ptStart.x, ptStart.y, ptEnd.x, ptEnd.y);
	}
	BOOL Polygon(LPPOINT lpPoints, int nCount)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Polygon(m_hDC, lpPoints, nCount);
	}
	BOOL PolyPolygon(LPPOINT lpPoints, LPINT lpPolyCounts, int nCount)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PolyPolygon(m_hDC, lpPoints, lpPolyCounts, nCount);
	}
	BOOL Rectangle(int x1, int y1, int x2, int y2)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Rectangle(m_hDC, x1, y1, x2, y2);
	}
	BOOL Rectangle(LPCRECT lpRect)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Rectangle(m_hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom);
	}
	BOOL RoundRect(int x1, int y1, int x2, int y2, int x3, int y3)
	{
		ATLASSERT(m_hDC != NULL);
		return ::RoundRect(m_hDC, x1, y1, x2, y2, x3, y3);
	}
	BOOL RoundRect(LPCRECT lpRect, POINT point)
	{
		ATLASSERT(m_hDC != NULL);
		return ::RoundRect(m_hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom, point.x, point.y);
	}

// Bitmap Functions
	BOOL PatBlt(int x, int y, int nWidth, int nHeight, DWORD dwRop)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PatBlt(m_hDC, x, y, nWidth, nHeight, dwRop);
	}
	BOOL BitBlt(int x, int y, int nWidth, int nHeight, HDC hSrcDC,
		int xSrc, int ySrc, DWORD dwRop)
	{
		ATLASSERT(m_hDC != NULL);
		return ::BitBlt(m_hDC, x, y, nWidth, nHeight, hSrcDC, xSrc, ySrc, dwRop);
	}
	BOOL StretchBlt(int x, int y, int nWidth, int nHeight, HDC hSrcDC, int xSrc, int ySrc, int nSrcWidth, int nSrcHeight, DWORD dwRop)
	{
		ATLASSERT(m_hDC != NULL);
		return ::StretchBlt(m_hDC, x, y, nWidth, nHeight, hSrcDC, xSrc, ySrc, nSrcWidth, nSrcHeight, dwRop);
	}
	COLORREF GetPixel(int x, int y) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetPixel(m_hDC, x, y);
	}
	COLORREF GetPixel(POINT point) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetPixel(m_hDC, point.x, point.y);
	}
	COLORREF SetPixel(int x, int y, COLORREF crColor)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetPixel(m_hDC, x, y, crColor);
	}
	COLORREF SetPixel(POINT point, COLORREF crColor)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetPixel(m_hDC, point.x, point.y, crColor);
	}
	BOOL FloodFill(int x, int y, COLORREF crColor)
	{
		ATLASSERT(m_hDC != NULL);
		return ::FloodFill(m_hDC, x, y, crColor);
	}
	BOOL ExtFloodFill(int x, int y, COLORREF crColor, UINT nFillType)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ExtFloodFill(m_hDC, x, y, crColor, nFillType);
	}
	BOOL MaskBlt(int x, int y, int nWidth, int nHeight, HDC hSrcDC, int xSrc, int ySrc, HBITMAP hMaskBitmap, int xMask, int yMask, DWORD dwRop)
	{
		ATLASSERT(m_hDC != NULL);
		return ::MaskBlt(m_hDC, x, y, nWidth, nHeight, hSrcDC, xSrc, ySrc, hMaskBitmap, xMask, yMask, dwRop);
	}
	BOOL PlgBlt(LPPOINT lpPoint, HDC hSrcDC, int xSrc, int ySrc, int nWidth, int nHeight, HBITMAP hMaskBitmap, int xMask, int yMask)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PlgBlt(m_hDC, lpPoint, hSrcDC, xSrc, ySrc, nWidth, nHeight, hMaskBitmap, xMask, yMask);
	}
	BOOL SetPixelV(int x, int y, COLORREF crColor)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetPixelV(m_hDC, x, y, crColor);
	}
	BOOL SetPixelV(POINT point, COLORREF crColor)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetPixelV(m_hDC, point.x, point.y, crColor);
	}

#ifndef _ATL_NO_MSIMG
	BOOL AlphaBlend(int x, int y, int nWidth, int nHeight, HDC hSrcDC, int xSrc, int ySrc, int nSrcWidth, int nSrcHeight, BLENDFUNCTION bf)
	{
		ATLASSERT(m_hDC != NULL);
		return ::AlphaBlend(m_hDC, x, y, nWidth, nHeight, hSrcDC, xSrc, ySrc, nSrcWidth, nSrcHeight, bf);
	}
	BOOL TransparentBlt(int x, int y, int nWidth, int nHeight, HDC hSrcDC, int xSrc, int ySrc, int nSrcWidth, int nSrcHeight, UINT crTransparent)
	{
		ATLASSERT(m_hDC != NULL);
		return ::TransparentBlt(m_hDC, x, y, nWidth, nHeight, hSrcDC, xSrc, ySrc, nSrcWidth, nSrcHeight, crTransparent);
	}
	BOOL GradientFill(const PTRIVERTEX pVertices, DWORD nVertices, void* pMeshElements, DWORD nMeshElements, DWORD dwMode)
	{
		ATLASSERT(m_hDC != NULL);
		return ::GradientFill(m_hDC, pVertices, nVertices, pMeshElements, nMeshElements, dwMode);
	}
#endif //!_ATL_NO_MSIMG

// Extra bitmap functions
	// Helper function for painting a disabled toolbar or menu bitmap
	// This function can take either an HBITMAP (for SS) or a DC with 
	//           the bitmap already painted (for cmdbar)
	BOOL DitherBlt(int x, int y, int nWidth, int nHeight, HDC hSrcDC, HBITMAP hBitmap, int xSrc, int ySrc)
	{
		ATLASSERT(m_hDC != NULL || hBitmap != NULL);
		ATLASSERT(nWidth > 0 && nHeight > 0);
		
		// Create a generic DC for all BitBlts
		CDCHandle dc = (hSrcDC != NULL) ? hSrcDC : ::CreateCompatibleDC(m_hDC);
		ATLASSERT(dc.m_hDC != NULL);
		if(dc.m_hDC == NULL)
			return FALSE;
		
		// Create a DC for the monochrome DIB section
		CDC dcBW = ::CreateCompatibleDC(m_hDC);
		ATLASSERT(dcBW.m_hDC != NULL);
		if(dcBW.m_hDC == NULL)
		{
			if(hSrcDC == NULL)
				::DeleteDC(dc);
			return FALSE;
		}

		// Create the monochrome DIB section with a black and white palette
		struct RGBBWBITMAPINFO
		{
			BITMAPINFOHEADER bmiHeader; 
			RGBQUAD          bmiColors[2]; 
		};

		RGBBWBITMAPINFO rgbBWBitmapInfo = 
		{
			{ sizeof(BITMAPINFOHEADER), nWidth, nHeight, 1, 1, BI_RGB, 0, 0, 0, 0, 0 },
			{ { 0x00, 0x00, 0x00, 0x00 }, { 0xFF, 0xFF, 0xFF, 0x00 } }
		};

		VOID *pbitsBW;
		CBitmap bmpBW = ::CreateDIBSection(dcBW, (LPBITMAPINFO)&rgbBWBitmapInfo, DIB_RGB_COLORS, &pbitsBW, NULL, 0);
		ATLASSERT(bmpBW.m_hBitmap != NULL);
		if(bmpBW.m_hBitmap == NULL)
		{
			if(hSrcDC == NULL)
				::DeleteDC(dc);
			return FALSE;
		}
		
		// Attach the monochrome DIB section and the bitmap to the DCs
		HBITMAP hbmOldBW = dcBW.SelectBitmap(bmpBW);
		HBITMAP hbmOldDC = NULL;
		if(hBitmap != NULL)
			hbmOldDC = dc.SelectBitmap(hBitmap);

		// Block: Dark gray removal: we want (128, 128, 128) pixels to become black and not white
		{
			CDC dcTemp1 = ::CreateCompatibleDC(m_hDC);
			CDC dcTemp2 = ::CreateCompatibleDC(m_hDC);
			CBitmap bmpTemp1;
			bmpTemp1.CreateCompatibleBitmap(dc, nWidth, nHeight);
			CBitmap bmpTemp2;
			bmpTemp2.CreateBitmap(nWidth, nHeight, 1, 1, NULL);
			HBITMAP hOldBmp1 = dcTemp1.SelectBitmap(bmpTemp1);
			HBITMAP hOldBmp2 = dcTemp2.SelectBitmap(bmpTemp2);
			// Let's copy our image, it will be altered
			dcTemp1.BitBlt(0, 0, nWidth, nHeight, dc, xSrc, ySrc, SRCCOPY);

			// All dark gray pixels will become white, the others black
			dcTemp1.SetBkColor(RGB(128, 128, 128));
			dcTemp2.BitBlt(0, 0, nWidth, nHeight, dcTemp1, 0, 0, SRCCOPY);
			// Do an XOR to set to black these white pixels
			dcTemp1.BitBlt(0, 0, nWidth, nHeight, dcTemp2, 0, 0, SRCINVERT);

			// BitBlt the bitmap into the monochrome DIB section
			// The DIB section will do a true monochrome conversion
			// The magenta background being closer to white will become white
			dcBW.BitBlt(0, 0, nWidth, nHeight, dcTemp1, 0, 0, SRCCOPY);

			// Cleanup
			dcTemp1.SelectBitmap(hOldBmp1);
			dcTemp2.SelectBitmap(hOldBmp2);
		}
		
		// Paint the destination rectangle in gray
		RECT rc = { x, y, x + nWidth, y + nHeight };
		FillRect(&rc, ::GetSysColorBrush(COLOR_3DFACE));

		// BitBlt the black bits in the monochrome bitmap into COLOR_3DHILIGHT bits in the destination DC
		// The magic ROP comes from the Charles Petzold's book
		CBrush brushHilight;
		brushHilight.CreateSolidBrush(::GetSysColor(COLOR_3DHILIGHT));
		HBRUSH hOldBrush = SelectBrush(brushHilight);
		BitBlt(x + 1, y + 1, nWidth, nHeight, dcBW, 0, 0, 0xB8074A);

		// BitBlt the black bits in the monochrome bitmap into COLOR_3DSHADOW bits in the destination DC
		CBrush brushShadow;
		brushShadow.CreateSolidBrush(::GetSysColor(COLOR_3DSHADOW));
		SelectBrush(brushShadow);
		BitBlt(x, y, nWidth, nHeight, dcBW, 0, 0, 0xB8074A);

		SelectBrush(hOldBrush);
		dcBW.SelectBitmap(hbmOldBW);
		dc.SelectBitmap(hbmOldDC);

		if(hSrcDC == NULL)
			::DeleteDC(dc);

		return TRUE;
	}

// Text Functions
	BOOL TextOut(int x, int y, LPCTSTR lpszString, int nCount = -1)
	{
		ATLASSERT(m_hDC != NULL);
		if(nCount == -1)
			nCount = lstrlen(lpszString);
		return ::TextOut(m_hDC, x, y, lpszString, nCount);
	}
	BOOL ExtTextOut(int x, int y, UINT nOptions, LPCRECT lpRect, LPCTSTR lpszString, UINT nCount = -1, LPINT lpDxWidths = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		if(nCount == -1)
			nCount = lstrlen(lpszString);
		return ::ExtTextOut(m_hDC, x, y, nOptions, lpRect, lpszString, nCount, lpDxWidths);
	}
	SIZE TabbedTextOut(int x, int y, LPCTSTR lpszString, int nCount = -1, int nTabPositions = 0, LPINT lpnTabStopPositions = NULL, int nTabOrigin = 0)
	{
		ATLASSERT(m_hDC != NULL);
		if(nCount == -1)
			nCount = lstrlen(lpszString);
		LONG lRes = ::TabbedTextOut(m_hDC, x, y, lpszString, nCount, nTabPositions, lpnTabStopPositions, nTabOrigin);
		SIZE size = { GET_X_LPARAM(lRes), GET_Y_LPARAM(lRes) };
		return size;
	}
	int DrawText(LPCTSTR lpszString, int nCount, LPRECT lpRect, UINT nFormat)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawText(m_hDC, lpszString, nCount, lpRect, nFormat);
	}
	BOOL GetTextExtent(LPCTSTR lpszString, int nCount, LPSIZE lpSize) const
	{
		ATLASSERT(m_hDC != NULL);
		if(nCount == -1)
			nCount = lstrlen(lpszString);
		return ::GetTextExtentPoint32(m_hDC, lpszString, nCount, lpSize);
	}
	BOOL GetTabbedTextExtent(LPCTSTR lpszString, int nCount, int nTabPositions, LPINT lpnTabStopPositions) const
	{
		ATLASSERT(m_hDC != NULL);
		if(nCount == -1)
			nCount = lstrlen(lpszString);
		return ::GetTabbedTextExtent(m_hDC, lpszString, nCount, nTabPositions, lpnTabStopPositions);
	}
	BOOL GrayString(HBRUSH hBrush, BOOL (CALLBACK* lpfnOutput)(HDC, LPARAM, int), LPARAM lpData, int nCount, int x, int y, int nWidth, int nHeight)
	{
		ATLASSERT(m_hDC != NULL);
		return ::GrayString(m_hDC, hBrush, (GRAYSTRINGPROC)lpfnOutput, lpData, nCount, x, y, nWidth, nHeight);
	}
	UINT GetTextAlign() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetTextAlign(m_hDC);
	}
	UINT SetTextAlign(UINT nFlags)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetTextAlign(m_hDC, nFlags);
	}
	int GetTextFace(LPTSTR lpszFacename, int nCount) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetTextFace(m_hDC, nCount, lpszFacename);
	}
	int GetTextFaceLen() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetTextFace(m_hDC, 0, NULL);
	}
#ifndef _ATL_NO_COM
#ifdef _OLEAUTO_H_
	BOOL GetTextFace(BSTR& bstrFace) const
	{
		USES_CONVERSION;
		ATLASSERT(m_hDC != NULL);
		ATLASSERT(bstrFace == NULL);

		int nLen = GetTextFaceLen();
		if(nLen == 0)
			return FALSE;

		LPTSTR lpszText = (LPTSTR)_alloca(nLen * sizeof(TCHAR));

		if(!GetTextFace(lpszText, nLen))
			return FALSE;

		bstrFace = ::SysAllocString(T2OLE(lpszText));
		return (bstrFace != NULL) ? TRUE : FALSE;
	}
#endif
#endif //!_ATL_NO_COM
#ifdef __ATLSTR_H__
	int GetTextFace(CString& strFace) const
	{
		ATLASSERT(m_hDC != NULL);

		int nLen = GetTextFaceLen();
		if(nLen == 0)
			return 0;

		int nRet = GetTextFace(strFace.GetBufferSetLength(nLen), nLen))
		strText.ReleaseBuffer();
		return nRet;
	}
#endif //__ATLSTR_H__
	BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetTextMetrics(m_hDC, lpMetrics);
	}
	int SetTextJustification(int nBreakExtra, int nBreakCount)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetTextJustification(m_hDC, nBreakExtra, nBreakCount);
	}
	int GetTextCharacterExtra() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetTextCharacterExtra(m_hDC);
	}
	int SetTextCharacterExtra(int nCharExtra)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetTextCharacterExtra(m_hDC, nCharExtra);
	}

// Advanced Drawing
	BOOL DrawEdge(LPRECT lpRect, UINT nEdge, UINT nFlags)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawEdge(m_hDC, lpRect, nEdge, nFlags);
	}
	BOOL DrawFrameControl(LPRECT lpRect, UINT nType, UINT nState)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawFrameControl(m_hDC, lpRect, nType, nState);
	}

// Scrolling Functions
	BOOL ScrollDC(int dx, int dy, LPCRECT lpRectScroll, LPCRECT lpRectClip, HRGN hRgnUpdate, LPRECT lpRectUpdate)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ScrollDC(m_hDC, dx, dy, lpRectScroll, lpRectClip, hRgnUpdate, lpRectUpdate);
	}

// Font Functions
	BOOL GetCharWidth(UINT nFirstChar, UINT nLastChar, LPINT lpBuffer) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetCharWidth(m_hDC, nFirstChar, nLastChar, lpBuffer);
	}
	DWORD SetMapperFlags(DWORD dwFlag)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetMapperFlags(m_hDC, dwFlag);
	}
	BOOL GetAspectRatioFilter(LPSIZE lpSize) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetAspectRatioFilterEx(m_hDC, lpSize);
	}

	BOOL GetCharABCWidths(UINT nFirstChar, UINT nLastChar, LPABC lpabc) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetCharABCWidths(m_hDC, nFirstChar, nLastChar, lpabc);
	}
	DWORD GetFontData(DWORD dwTable, DWORD dwOffset, LPVOID lpData, DWORD cbData) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetFontData(m_hDC, dwTable, dwOffset, lpData, cbData);
	}
	int GetKerningPairs(int nPairs, LPKERNINGPAIR lpkrnpair) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetKerningPairs(m_hDC, nPairs, lpkrnpair);
	}
	UINT GetOutlineTextMetrics(UINT cbData, LPOUTLINETEXTMETRIC lpotm) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetOutlineTextMetrics(m_hDC, cbData, lpotm);
	}
	DWORD GetGlyphOutline(UINT nChar, UINT nFormat, LPGLYPHMETRICS lpgm, DWORD cbBuffer, LPVOID lpBuffer, const MAT2* lpmat2) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetGlyphOutline(m_hDC, nChar, nFormat, lpgm, cbBuffer, lpBuffer, lpmat2);
	}

	BOOL GetCharABCWidths(UINT nFirstChar, UINT nLastChar, LPABCFLOAT lpABCF) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetCharABCWidthsFloat(m_hDC, nFirstChar, nLastChar, lpABCF);
	}
	BOOL GetCharWidth(UINT nFirstChar, UINT nLastChar, float* lpFloatBuffer) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetCharWidthFloat(m_hDC, nFirstChar, nLastChar, lpFloatBuffer);
	}

// Printer/Device Escape Functions
	int Escape(int nEscape, int nCount, LPCSTR lpszInData, LPVOID lpOutData)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Escape(m_hDC, nEscape, nCount, lpszInData, lpOutData);
	}
	int Escape(int nEscape, int nInputSize, LPCSTR lpszInputData,
		int nOutputSize, LPSTR lpszOutputData)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ExtEscape(m_hDC, nEscape, nInputSize, lpszInputData, nOutputSize, lpszOutputData);
	}
	int DrawEscape(int nEscape, int nInputSize, LPCSTR lpszInputData)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawEscape(m_hDC, nEscape, nInputSize, lpszInputData);
	}

	// Escape helpers
	int StartDoc(LPCTSTR lpszDocName)  // old Win3.0 version
	{
		DOCINFO di;
		memset(&di, 0, sizeof(DOCINFO));
		di.cbSize = sizeof(DOCINFO);
		di.lpszDocName = lpszDocName;
		return StartDoc(&di);
	}

	int StartDoc(LPDOCINFO lpDocInfo)
	{
		ATLASSERT(m_hDC != NULL);
		return ::StartDoc(m_hDC, lpDocInfo);
	}
	int StartPage()
	{
		ATLASSERT(m_hDC != NULL);
		return ::StartPage(m_hDC);
	}
	int EndPage()
	{
		ATLASSERT(m_hDC != NULL);
		return ::EndPage(m_hDC);
	}
	int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int))
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetAbortProc(m_hDC, (ABORTPROC)lpfn);
	}
	int AbortDoc()
	{
		ATLASSERT(m_hDC != NULL);
		return ::AbortDoc(m_hDC);
	}
	int EndDoc()
	{
		ATLASSERT(m_hDC != NULL);
		return ::EndDoc(m_hDC);
	}

// MetaFile Functions
	BOOL PlayMetaFile(HMETAFILE hMF)
	{
		ATLASSERT(m_hDC != NULL);
		if(::GetDeviceCaps(m_hDC, TECHNOLOGY) == DT_METAFILE)
		{
			// playing metafile in metafile, just use core windows API
			return ::PlayMetaFile(m_hDC, hMF);
		}

		// for special playback, lParam == pDC
		return ::EnumMetaFile(m_hDC, hMF, EnumMetaFileProc, (LPARAM)this);
	}
	BOOL PlayMetaFile(HENHMETAFILE hEnhMetaFile, LPCRECT lpBounds)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PlayEnhMetaFile(m_hDC, hEnhMetaFile, lpBounds);
	}
	BOOL AddMetaFileComment(UINT nDataSize, const BYTE* pCommentData) // can be used for enhanced metafiles only
	{
		ATLASSERT(m_hDC != NULL);
		return ::GdiComment(m_hDC, nDataSize, pCommentData);
	}

	// Special handling for metafile playback
	static int CALLBACK EnumMetaFileProc(HDC hDC, HANDLETABLE* pHandleTable, METARECORD* pMetaRec, int nHandles, LPARAM lParam)
	{
		CDCHandle* pDC = (CDCHandle*)lParam;

		switch (pMetaRec->rdFunction)
		{
		case META_SETMAPMODE:
			pDC->SetMapMode((int)(short)pMetaRec->rdParm[0]);
			break;
		case META_SETWINDOWEXT:
			pDC->SetWindowExt((int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
			break;
		case META_SETWINDOWORG:
			pDC->SetWindowOrg((int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
			break;
		case META_SETVIEWPORTEXT:
			pDC->SetViewportExt((int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
			break;
		case META_SETVIEWPORTORG:
			pDC->SetViewportOrg((int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
			break;
		case META_SCALEWINDOWEXT:
			pDC->ScaleWindowExt((int)(short)pMetaRec->rdParm[3], (int)(short)pMetaRec->rdParm[2], 
				(int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
			break;
		case META_SCALEVIEWPORTEXT:
			pDC->ScaleViewportExt((int)(short)pMetaRec->rdParm[3], (int)(short)pMetaRec->rdParm[2],
				(int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
			break;
		case META_OFFSETVIEWPORTORG:
			pDC->OffsetViewportOrg((int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
			break;
		case META_SAVEDC:
			pDC->SaveDC();
			break;
		case META_RESTOREDC:
			pDC->RestoreDC((int)(short)pMetaRec->rdParm[0]);
			break;
		case META_SETBKCOLOR:
			pDC->SetBkColor(*(UNALIGNED COLORREF*)&pMetaRec->rdParm[0]);
			break;
		case META_SETTEXTCOLOR:
			pDC->SetTextColor(*(UNALIGNED COLORREF*)&pMetaRec->rdParm[0]);
			break;

		// need to watch out for SelectObject(HFONT), for custom font mapping
		case META_SELECTOBJECT:
			{
				HGDIOBJ hObject = pHandleTable->objectHandle[pMetaRec->rdParm[0]];
				UINT nObjType = ::GetObjectType(hObject);
				if(nObjType == 0)
				{
					// object type is unknown, determine if it is a font
					HFONT hStockFont = (HFONT)::GetStockObject(SYSTEM_FONT);
					HFONT hFontOld = (HFONT)::SelectObject(pDC->m_hDC, hStockFont);
					HGDIOBJ hObjOld = ::SelectObject(pDC->m_hDC, hObject);
					if(hObjOld == hStockFont)
					{
						// got the stock object back, so must be selecting a font
						pDC->SelectFont((HFONT)hObject);
						break;  // don't play the default record
					}
					else
					{
						// didn't get the stock object back, so restore everything
						::SelectObject(pDC->m_hDC, hFontOld);
						::SelectObject(pDC->m_hDC, hObjOld);
					}
					// and fall through to PlayMetaFileRecord...
				}
				else if(nObjType == OBJ_FONT)
				{
					// play back as CDCHandle::SelectFont(HFONT)
					pDC->SelectFont((HFONT)hObject);
					break;  // don't play the default record
				}
			}
			// fall through...

		default:
			::PlayMetaFileRecord(hDC, pHandleTable, pMetaRec, nHandles);
			break;
		}

		return 1;
	}

// Path Functions
	BOOL AbortPath()
	{
		ATLASSERT(m_hDC != NULL);
		return ::AbortPath(m_hDC);
	}
	BOOL BeginPath()
	{
		ATLASSERT(m_hDC != NULL);
		return ::BeginPath(m_hDC);
	}
	BOOL CloseFigure()
	{
		ATLASSERT(m_hDC != NULL);
		return ::CloseFigure(m_hDC);
	}
	BOOL EndPath()
	{
		ATLASSERT(m_hDC != NULL);
		return ::EndPath(m_hDC);
	}
	BOOL FillPath()
	{
		ATLASSERT(m_hDC != NULL);
		return ::FillPath(m_hDC);
	}
	BOOL FlattenPath()
	{
		ATLASSERT(m_hDC != NULL);
		return ::FlattenPath(m_hDC);
	}
	BOOL StrokeAndFillPath()
	{
		ATLASSERT(m_hDC != NULL);
		return ::StrokeAndFillPath(m_hDC);
	}
	BOOL StrokePath()
	{
		ATLASSERT(m_hDC != NULL);
		return ::StrokePath(m_hDC);
	}
	BOOL WidenPath()
	{
		ATLASSERT(m_hDC != NULL);
		return ::WidenPath(m_hDC);
	}
	BOOL GetMiterLimit(PFLOAT pfMiterLimit) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetMiterLimit(m_hDC, pfMiterLimit);
	}
	BOOL SetMiterLimit(float fMiterLimit)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetMiterLimit(m_hDC, fMiterLimit, NULL);
	}
	int GetPath(LPPOINT lpPoints, LPBYTE lpTypes, int nCount) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetPath(m_hDC, lpPoints, lpTypes, nCount);
	}
	BOOL SelectClipPath(int nMode)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SelectClipPath(m_hDC, nMode);
	}

// Misc Helper Functions
	static CBrushHandle PASCAL GetHalftoneBrush()
	{
		HBRUSH halftoneBrush = NULL;
		WORD grayPattern[8];
		for(int i = 0; i < 8; i++)
			grayPattern[i] = (WORD)(0x5555 << (i & 1));
		HBITMAP grayBitmap = CreateBitmap(8, 8, 1, 1, &grayPattern);
		if(grayBitmap != NULL)
		{
			halftoneBrush = ::CreatePatternBrush(grayBitmap);
			DeleteObject(grayBitmap);
		}
		return CBrushHandle(halftoneBrush);
	}
	void DrawDragRect(LPCRECT lpRect, SIZE size, LPCRECT lpRectLast, SIZE sizeLast, HBRUSH hBrush = NULL, HBRUSH hBrushLast = NULL)
	{
		// first, determine the update region and select it
		HRGN hRgnNew;
		HRGN hRgnOutside, hRgnInside;
		hRgnOutside = ::CreateRectRgnIndirect(lpRect);
		RECT rect = *lpRect;
		::InflateRect(&rect, -size.cx, -size.cy);
		::IntersectRect(&rect, &rect, lpRect);
		hRgnInside = ::CreateRectRgnIndirect(&rect);
		hRgnNew = ::CreateRectRgn(0, 0, 0, 0);
		::CombineRgn(hRgnNew, hRgnOutside, hRgnInside, RGN_XOR);

		HBRUSH hBrushOld = NULL;
		if(hBrush == NULL)
			hBrush = CDCHandle::GetHalftoneBrush();
		if(hBrushLast == NULL)
			hBrushLast = hBrush;

		HRGN hRgnLast = NULL, hRgnUpdate = NULL;
		if(lpRectLast != NULL)
		{
			// find difference between new region and old region
			hRgnLast = ::CreateRectRgn(0, 0, 0, 0);
			::SetRectRgn(hRgnOutside, lpRectLast->left, lpRectLast->top, lpRectLast->right, lpRectLast->bottom);
			rect = *lpRectLast;
			::InflateRect(&rect, -sizeLast.cx, -sizeLast.cy);
			::IntersectRect(&rect, &rect, lpRectLast);
			::SetRectRgn(hRgnInside, rect.left, rect.top, rect.right, rect.bottom);
			::CombineRgn(hRgnLast, hRgnOutside, hRgnInside, RGN_XOR);

			// only diff them if brushes are the same
			if(hBrush == hBrushLast)
			{
				hRgnUpdate = ::CreateRectRgn(0, 0, 0, 0);
				::CombineRgn(hRgnUpdate, hRgnLast, hRgnNew, RGN_XOR);
			}
		}
		if(hBrush != hBrushLast && lpRectLast != NULL)
		{
			// brushes are different -- erase old region first
			SelectClipRgn(hRgnLast);
			GetClipBox(&rect);
			hBrushOld = SelectBrush(hBrushLast);
			PatBlt(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, PATINVERT);
			SelectBrush(hBrushOld);
			hBrushOld = NULL;
		}

		// draw into the update/new region
		SelectClipRgn(hRgnUpdate != NULL ? hRgnUpdate : hRgnNew);
		GetClipBox(&rect);
		hBrushOld = SelectBrush(hBrush);
		PatBlt(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, PATINVERT);

		// cleanup DC
		if(hBrushOld != NULL)
			SelectBrush(hBrushOld);
		SelectClipRgn(NULL);
	}
	void FillSolidRect(LPCRECT lpRect, COLORREF clr)
	{
		ATLASSERT(m_hDC != NULL);

		::SetBkColor(m_hDC, clr);
		::ExtTextOut(m_hDC, 0, 0, ETO_OPAQUE, lpRect, NULL, 0, NULL);
	}
	void FillSolidRect(int x, int y, int cx, int cy, COLORREF clr)
	{
		ATLASSERT(m_hDC != NULL);

		::SetBkColor(m_hDC, clr);
		RECT rect = { x, y, x + cx, y + cy };
		::ExtTextOut(m_hDC, 0, 0, ETO_OPAQUE, &rect, NULL, 0, NULL);
	}
	void Draw3dRect(LPCRECT lpRect, COLORREF clrTopLeft, COLORREF clrBottomRight)
	{
		Draw3dRect(lpRect->left, lpRect->top, lpRect->right - lpRect->left,
			lpRect->bottom - lpRect->top, clrTopLeft, clrBottomRight);
	}
	void Draw3dRect(int x, int y, int cx, int cy, COLORREF clrTopLeft, COLORREF clrBottomRight)
	{
		FillSolidRect(x, y, cx - 1, 1, clrTopLeft);
		FillSolidRect(x, y, 1, cy - 1, clrTopLeft);
		FillSolidRect(x + cx, y, -1, cy, clrBottomRight);
		FillSolidRect(x, y + cy, cx, -1, clrBottomRight);
	}

// DIB support
	int SetDIBitsToDevice(int x, int y, DWORD dwWidth, DWORD dwHeight, int xSrc, int ySrc, UINT uStartScan, UINT cScanLines, CONST VOID* lpvBits, CONST BITMAPINFO* lpbmi, UINT uColorUse)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetDIBitsToDevice(m_hDC, x, y, dwWidth, dwHeight, xSrc, ySrc, uStartScan, cScanLines, lpvBits, lpbmi, uColorUse);
	}
	int StretchDIBits(int x, int y, int nWidth, int nHeight, int xSrc, int ySrc, int nSrcWidth, int nSrcHeight, CONST VOID* lpvBits, CONST BITMAPINFO* lpbmi, UINT uColorUse, DWORD dwRop)
	{
		ATLASSERT(m_hDC != NULL);
		return ::StretchDIBits(m_hDC, x, y, nWidth, nHeight, xSrc, ySrc, nSrcWidth, nSrcHeight, lpvBits, lpbmi, uColorUse, dwRop);
	}
	UINT GetDIBColorTable(UINT uStartIndex, UINT cEntries, RGBQUAD* pColors) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetDIBColorTable(m_hDC, uStartIndex, cEntries, pColors);
	}
	UINT SetDIBColorTable(UINT uStartIndex, UINT cEntries, CONST RGBQUAD* pColors)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetDIBColorTable(m_hDC, uStartIndex, cEntries, pColors);
	}

// OpenGL support
#ifndef _ATL_NO_OPENGL
	int ChoosePixelFormat(CONST PIXELFORMATDESCRIPTOR* ppfd)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ChoosePixelFormat(m_hDC, ppfd);
	}
	int DescribePixelFormat(int iPixelFormat, UINT nBytes, LPPIXELFORMATDESCRIPTOR ppfd)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DescribePixelFormat(m_hDC, iPixelFormat, nBytes, ppfd);
	}
	int GetPixelFormat() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetPixelFormat(m_hDC);
	}
	BOOL SetPixelFormat(int iPixelFormat, CONST PIXELFORMATDESCRIPTOR* ppfd)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetPixelFormat(m_hDC, iPixelFormat, ppfd);
	}
	BOOL SwapBuffers()
	{
		ATLASSERT(m_hDC != NULL);
		return ::SwapBuffers(m_hDC);
	}

	HGLRC wglCreateContext()
	{
		ATLASSERT(m_hDC != NULL);
		return ::wglCreateContext(m_hDC);
	}
	HGLRC wglCreateLayerContext(int iLayerPlane)
	{
		ATLASSERT(m_hDC != NULL);
		return ::wglCreateLayerContext(m_hDC, iLayerPlane);
	}
	BOOL wglMakeCurrent(HGLRC hglrc)
	{
		ATLASSERT(m_hDC != NULL);
		return ::wglMakeCurrent(m_hDC, hglrc);
	}
	BOOL wglUseFontBitmaps(DWORD dwFirst, DWORD dwCount, DWORD listBase)
	{
		ATLASSERT(m_hDC != NULL);
		return ::wglUseFontBitmaps(m_hDC, dwFirst, dwCount, listBase);
	}
	BOOL wglUseFontOutlines(DWORD dwFirst, DWORD dwCount, DWORD listBase, FLOAT deviation, FLOAT extrusion, int format, LPGLYPHMETRICSFLOAT lpgmf)
	{
		ATLASSERT(m_hDC != NULL);
		return ::wglUseFontOutlines(m_hDC, dwFirst, dwCount, listBase, deviation, extrusion, format, lpgmf);
	}
	BOOL wglDescribeLayerPlane(int iPixelFormat, int iLayerPlane, UINT nBytes, LPLAYERPLANEDESCRIPTOR plpd)
	{
		ATLASSERT(m_hDC != NULL);
		return ::wglDescribeLayerPlane(m_hDC, iPixelFormat, iLayerPlane, nBytes, plpd);
	}
	int wglSetLayerPaletteEntries(int iLayerPlane, int iStart, int cEntries, CONST COLORREF* pclr)
	{
		ATLASSERT(m_hDC != NULL);
		return ::wglSetLayerPaletteEntries(m_hDC, iLayerPlane, iStart, cEntries, pclr);
	}
	int wglGetLayerPaletteEntries(int iLayerPlane, int iStart, int cEntries, COLORREF* pclr)
	{
		ATLASSERT(m_hDC != NULL);
		return ::wglGetLayerPaletteEntries(m_hDC, iLayerPlane, iStart, cEntries, pclr);
	}
	BOOL wglRealizeLayerPalette(int iLayerPlane, BOOL bRealize)
	{
		ATLASSERT(m_hDC != NULL);
		return ::wglRealizeLayerPalette(m_hDC, iLayerPlane, bRealize);
	}
	BOOL wglSwapLayerBuffers(UINT uPlanes)
	{
		ATLASSERT(m_hDC != NULL);
		return ::wglSwapLayerBuffers(m_hDC, uPlanes);
	}
#endif //!_ATL_NO_OPENGL

// New for Windows 2000 only
#if (_WIN32_WINNT >= 0x0500)

	COLORREF GetDCPenColor() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetDCPenColor(m_hDC);
	}
	COLORREF SetDCPenColor(COLORREF clr)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetDCPenColor(m_hDC, clr);
	}
	COLORREF GetDCBrushColor() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetDCBrushColor(m_hDC);
	}
	COLORREF SetDCBrushColor(COLORREF clr)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetDCBrushColor(m_hDC, clr);
	}

	DWORD GetFontUnicodeRanges(LPGLYPHSET lpgs) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetFontUnicodeRanges(m_hDC, lpgs);
	}
	DWORD GetGlyphIndices(LPCTSTR lpstr, int cch, LPWORD pgi, DWORD dwFlags) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetGlyphIndices(m_hDC, lpstr, cch, pgi, dwFlags);
	}

	BOOL GetTextExtentPointI(LPWORD pgiIn, int cgi, LPSIZE lpSize) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetTextExtentPointI(m_hDC, pgiIn, cgi, lpSize);
	}
	BOOL GetTextExtentExPointI(LPWORD pgiIn, int cgi, int nMaxExtent, LPINT lpnFit, LPINT alpDx, LPSIZE lpSize) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetTextExtentExPointI(m_hDC, pgiIn, cgi, nMaxExtent, lpnFit, alpDx, lpSize);
	}
	BOOL GetCharWidthI(UINT giFirst, UINT cgi, LPWORD pgi, LPINT lpBuffer) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetCharWidthI(m_hDC, giFirst, cgi, pgi, lpBuffer);
	}
	BOOL GetCharABCWidthsI(UINT giFirst, UINT cgi, LPWORD pgi, LPABC lpabc) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetCharABCWidthsI(m_hDC, giFirst, cgi, pgi, lpabc);
	}

#endif //(_WIN32_WINNT >= 0x0500)

// New for Windows 2000 and Windows 98
#if (WINVER >= 0x0500)

	BOOL ColorCorrectPalette(HPALETTE hPalette, DWORD dwFirstEntry, DWORD dwNumOfEntries)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ColorCorrectPalette(m_hDC, hPalette, dwFirstEntry, dwNumOfEntries);
	}

#endif //(WINVER >= 0x0500)
};


/////////////////////////////////////////////////////////////////////////////
// CDC Helpers

class CPaintDC : public CDC
{
public:
// Data members
	HWND m_hWnd;
	PAINTSTRUCT m_ps;

// Constructor/destructor
	CPaintDC(HWND hWnd)
	{
		ATLASSERT(::IsWindow(hWnd));
		m_hWnd = hWnd;
		m_hDC = ::BeginPaint(hWnd, &m_ps);
	}
	~CPaintDC()
	{
		ATLASSERT(m_hDC != NULL);
		ATLASSERT(::IsWindow(m_hWnd));
		::EndPaint(m_hWnd, &m_ps);
		Detach();
	}
};

class CClientDC : public CDC
{
public:
// Data members
	HWND m_hWnd;

// Constructor/destructor
	CClientDC(HWND hWnd)
	{
		ATLASSERT(hWnd == NULL || ::IsWindow(hWnd));
		m_hWnd = hWnd;
		m_hDC = ::GetDC(hWnd);
	}
	~CClientDC()
	{
		ATLASSERT(m_hDC != NULL);
		::ReleaseDC(m_hWnd, Detach());
	}
};

class CWindowDC : public CDC
{
public:
// Data members
	HWND m_hWnd;

// Constructor/destructor
	CWindowDC(HWND hWnd)
	{
		ATLASSERT(hWnd == NULL || ::IsWindow(hWnd));
		m_hWnd = hWnd;
		m_hDC = ::GetWindowDC(hWnd);
	}
	~CWindowDC()
	{
		ATLASSERT(m_hDC != NULL);
		::ReleaseDC(m_hWnd, Detach());
	}
};


/////////////////////////////////////////////////////////////////////////////
// Enhanced metafile support

class CEnhMetaFileInfo
{
public:
// Data members
	HENHMETAFILE m_hEMF;
	BYTE* m_pBits;
	TCHAR* m_pDesc;
	ENHMETAHEADER m_header;
	PIXELFORMATDESCRIPTOR m_pfd;

// Constructor/destructor
	CEnhMetaFileInfo(HENHMETAFILE hEMF) : m_pBits(NULL), m_pDesc(NULL), m_hEMF(hEMF)
	{ }

	~CEnhMetaFileInfo()
	{
		delete [] m_pBits;
		delete [] m_pDesc;
	}

// Operations
	BYTE* GetEnhMetaFileBits()
	{
		ATLASSERT(m_hEMF != NULL);
		UINT nBytes = ::GetEnhMetaFileBits(m_hEMF, 0, NULL);
		delete [] m_pBits;
		m_pBits = NULL;
		ATLTRY(m_pBits = new BYTE[nBytes]);
		if (m_pBits != NULL)
			::GetEnhMetaFileBits(m_hEMF, nBytes, m_pBits);
		return m_pBits;
	}
	LPTSTR GetEnhMetaFileDescription()
	{
		ATLASSERT(m_hEMF != NULL);
		UINT nLen = ::GetEnhMetaFileDescription(m_hEMF, 0, NULL);
		delete [] m_pDesc;
		m_pDesc = NULL;
		ATLTRY(m_pDesc = new TCHAR[nLen]);
		if (m_pDesc != NULL)
			nLen = ::GetEnhMetaFileDescription(m_hEMF, nLen, m_pDesc);
		return m_pDesc;
	}
	ENHMETAHEADER* GetEnhMetaFileHeader()
	{
		ATLASSERT(m_hEMF != NULL);
		memset(&m_header, 0, sizeof(m_header));
		m_header.iType = EMR_HEADER;
		m_header.nSize = sizeof(ENHMETAHEADER);
		UINT n = ::GetEnhMetaFileHeader(m_hEMF, sizeof(ENHMETAHEADER), &m_header);
		return (n != 0) ? &m_header : NULL;
	}
	PIXELFORMATDESCRIPTOR* GetEnhMetaFilePixelFormat()
	{
		ATLASSERT(m_hEMF != NULL);
		memset(&m_pfd, 0, sizeof(m_pfd));
		UINT n = ::GetEnhMetaFilePixelFormat(m_hEMF, sizeof(m_pfd), &m_pfd);
		return (n != 0) ? &m_pfd : NULL;
	}
};


typedef CEnhMetaFileT<false>	CEnhMetaFileHandle;
typedef CEnhMetaFileT<true>	CEnhMetaFile;

template <bool t_bManaged>
class CEnhMetaFileT
{
public:
// Data members
	HENHMETAFILE m_hEMF;

// Constructor/destructor
	CEnhMetaFileT(HENHMETAFILE hEMF = NULL) : m_hEMF(hEMF)
	{
	}

	~CEnhMetaFileT()
	{
		if(t_bManaged && m_hEMF != NULL)
			DeleteObject();
	}

// Operations
	CEnhMetaFileT<t_bManaged>& operator=(HENHMETAFILE hEMF)
	{
		Attach(hEMF);
		return *this;
	}

	void Attach(HENHMETAFILE hEMF)
	{
		if(t_bManaged && m_hEMF != NULL)
			DeleteObject();
		m_hEMF = hEMF;
	}
	HENHMETAFILE Detach()
	{
		HENHMETAFILE hEMF = m_hEMF;
		m_hEMF = NULL;
		return hEMF;
	}

	operator HENHMETAFILE() const { return m_hEMF; }

	bool IsNull() const { return (m_hEMF == NULL); }

	BOOL DeleteObject()
	{
		ATLASSERT(m_hEMF != NULL);
		BOOL bRet = ::DeleteEnhMetaFile(m_hEMF);
		m_hEMF = NULL;
		return bRet;
	}

	UINT GetEnhMetaFileBits(UINT cbBuffer, LPBYTE lpbBuffer) const
	{
		ATLASSERT(m_hEMF != NULL);
		return ::GetEnhMetaFileBits(m_hEMF, cbBuffer, lpbBuffer);
	}
	UINT GetEnhMetaFileDescription(UINT cchBuffer, LPTSTR lpszDescription) const
	{
		ATLASSERT(m_hEMF != NULL);
		return ::GetEnhMetaFileDescription(m_hEMF, cchBuffer, lpszDescription);
	}
	UINT GetEnhMetaFileHeader(LPENHMETAHEADER lpemh) const
	{
		ATLASSERT(m_hEMF != NULL);
		lpemh->iType = EMR_HEADER;
		lpemh->nSize = sizeof(ENHMETAHEADER);
		return ::GetEnhMetaFileHeader(m_hEMF, sizeof(ENHMETAHEADER), lpemh);
	}
	UINT GetEnhMetaFilePaletteEntries(UINT cEntries, LPPALETTEENTRY lppe) const
	{
		ATLASSERT(m_hEMF != NULL);
		return ::GetEnhMetaFilePaletteEntries(m_hEMF, cEntries, lppe);
	}
	UINT GetEnhMetaFilePixelFormat(DWORD cbBuffer, PIXELFORMATDESCRIPTOR* ppfd) const
	{
		ATLASSERT(m_hEMF != NULL);
		return ::GetEnhMetaFilePixelFormat(m_hEMF, cbBuffer, ppfd);
	}
};


class CEnhMetaFileDC : public CDC
{
public:
// Constructor/destructor
	CEnhMetaFileDC()
	{
	}
	CEnhMetaFileDC(HDC hdc, LPCRECT lpRect)
	{
		Create(hdc, NULL, lpRect, NULL);
		ATLASSERT(m_hDC != NULL);
	}
	CEnhMetaFileDC(HDC hdcRef, LPCTSTR lpFilename, LPCRECT lpRect, LPCTSTR lpDescription)
	{
		Create(hdcRef, lpFilename, lpRect, lpDescription);
		ATLASSERT(m_hDC != NULL);
	}

	~CEnhMetaFileDC()
	{
		HENHMETAFILE hEMF = Close();
		if (hEMF != NULL)
			::DeleteEnhMetaFile(hEMF);
	}

// Operations
	void Create(HDC hdcRef, LPCTSTR lpFilename, LPCRECT lpRect, LPCTSTR lpDescription)
	{
		ATLASSERT(m_hDC == NULL);
		m_hDC = ::CreateEnhMetaFile(hdcRef, lpFilename, lpRect, lpDescription);
	}
	HENHMETAFILE Close()
	{
		HENHMETAFILE hEMF = NULL;
		if (m_hDC != NULL)
		{
			hEMF = ::CloseEnhMetaFile(m_hDC);
			m_hDC = NULL;
		}
		return hEMF;
	}
};

}; //namespace WTL

#endif // __ATLGDI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\atlprint.h ===
// WTL Version 3.0
// Copyright (C) 1997-1999 Microsoft Corporation
// All rights reserved.
//
// This file is a part of Windows Template Library.
// The code and information is provided "as-is" without
// warranty of any kind, either expressed or implied.

#ifndef __ATLPRINT_H__
#define __ATLPRINT_H__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLAPP_H__
	#error atlprint.h requires atlapp.h to be included first
#endif

#ifndef __ATLWIN_H__
	#error atlprint.h requires atlwin.h to be included first
#endif


namespace WTL
{

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

template <unsigned int t_nInfo> class CPrinterInfo;
template <bool t_bManaged> class CPrinterT;
template <bool t_bManaged> class CDevModeT;
class CPrinterDC;
class CPrintJobInfo;
class CPrintJob;
class CPrintPreview;
template <class T, class TBase = CWindow, class TWinTraits = CControlWinTraits> class CPrintPreviewWindowImpl;
class CPrintPreviewWindow;


/////////////////////////////////////////////////////////////////////////////

template <unsigned int t_nInfo>
class _printer_info
{
public:
	typedef void infotype;
};

template <> class _printer_info<1> {public: typedef PRINTER_INFO_1 infotype;};
template <> class _printer_info<2> {public: typedef PRINTER_INFO_2 infotype;};
template <> class _printer_info<3> {public: typedef PRINTER_INFO_3 infotype;};
template <> class _printer_info<4> {public: typedef PRINTER_INFO_4 infotype;};
template <> class _printer_info<5> {public: typedef PRINTER_INFO_5 infotype;};
template <> class _printer_info<6> {public: typedef PRINTER_INFO_6 infotype;};
template <> class _printer_info<7> {public: typedef PRINTER_INFO_7 infotype;};
// these are not in the old (vc6.0) headers
#ifdef _ATL_USE_NEW_PRINTER_INFO
template <> class _printer_info<8> {public: typedef PRINTER_INFO_8 infotype;};
template <> class _printer_info<9> {public: typedef PRINTER_INFO_9 infotype;};
#endif //_ATL_USE_NEW_PRINTER_INFO

//This class wraps all of the PRINTER_INFO_* structures
//and provided by ::GetPrinter.
template <unsigned int t_nInfo>
class CPrinterInfo
{
public:
// Data members
	_printer_info<t_nInfo>::infotype* m_pi;

// Constructor/destructor
	CPrinterInfo() : m_pi(NULL)
	{ }
	CPrinterInfo(HANDLE hPrinter) : m_pi(NULL)
	{
		GetPrinterInfo(hPrinter);
	}
	~CPrinterInfo()
	{
		Cleanup();
	}

// Operations
	bool GetPrinterInfo(HANDLE hPrinter)
	{
		Cleanup();
		return GetPrinterInfoHelper(hPrinter, (BYTE**)&m_pi, t_nInfo);
	}

// Implementation
	void Cleanup()
	{
		delete [] (BYTE*)m_pi;
		m_pi = NULL;
	}
	static bool GetPrinterInfoHelper(HANDLE hPrinter, BYTE** pi, int nIndex)
	{
		ATLASSERT(pi != NULL);
		DWORD dw = 0;
		BYTE* pb = NULL;
		::GetPrinter(hPrinter, nIndex, NULL, 0, &dw);
		if (dw > 0)
		{
			ATLTRY(pb = new BYTE[dw]);
			if (pb != NULL)
			{
				memset(pb, 0, dw);
				DWORD dwNew;
				if (!::GetPrinter(hPrinter, nIndex, pb, dw, &dwNew))
				{
					delete [] pb;
					pb = NULL;
				}
			}
		}
		*pi = pb;
		return (pb != NULL);
	}
};

//Provides a wrapper class for a HANDLE to a printer.
template <bool t_bManaged>
class CPrinterT
{
public:
// Data members
	HANDLE m_hPrinter;

// Constructor/destructor
	CPrinterT(HANDLE hPrinter = NULL) : m_hPrinter(hPrinter)
	{ }

	~CPrinterT()
	{
		ClosePrinter();
	}

// Operations
	CPrinterT& operator=(HANDLE hPrinter)
	{
		if (hPrinter != m_hPrinter)
		{
			ClosePrinter();
			m_hPrinter = hPrinter;
		}
		return *this;
	}

	bool IsNull() const { return (m_hPrinter == NULL); }

	bool OpenPrinter(HANDLE hDevNames, const DEVMODE* pDevMode = NULL)
	{
		bool b = false;
		DEVNAMES* pdn = (DEVNAMES*)::GlobalLock(hDevNames);
		if (pdn != NULL)
		{
			LPTSTR lpszPrinterName = (LPTSTR)pdn + pdn->wDeviceOffset;
			b = OpenPrinter(lpszPrinterName, pDevMode);
			::GlobalUnlock(hDevNames);
		}
		return b;
	}
	bool OpenPrinter(LPCTSTR lpszPrinterName, const DEVMODE* pDevMode = NULL)
	{
		ClosePrinter();
		PRINTER_DEFAULTS pdefs = {NULL, (DEVMODE*)pDevMode, PRINTER_ACCESS_USE};
		::OpenPrinter((LPTSTR) lpszPrinterName, &m_hPrinter, 
			(pDevMode == NULL) ? NULL : &pdefs);

		return (m_hPrinter != NULL);
	}
	bool OpenPrinter(LPCTSTR lpszPrinterName, PRINTER_DEFAULTS* pprintdefs)
	{
		ClosePrinter();
		::OpenPrinter((LPTSTR) lpszPrinterName, &m_hPrinter, pprintdefs);
		return (m_hPrinter != NULL);
	}
	bool OpenDefaultPrinter(const DEVMODE* pDevMode = NULL)
	{
		ClosePrinter();
		TCHAR buffer[512];
		buffer[0] = 0;
		::GetProfileString(_T("windows"), _T("device"), _T(",,,"), buffer, sizeof(buffer));
		int nLen = lstrlen(buffer);
		if (nLen != 0)
		{
			LPTSTR lpsz = buffer;
			while (*lpsz)
			{
				if (*lpsz == ',')
				{
					*lpsz = 0;
					break;
				}
				lpsz = CharNext(lpsz);
			}
			PRINTER_DEFAULTS pdefs = {NULL, (DEVMODE*)pDevMode, PRINTER_ACCESS_USE};
			::OpenPrinter(buffer, &m_hPrinter, (pDevMode == NULL) ? NULL : &pdefs);
		}
		return m_hPrinter != NULL;
	}
	void ClosePrinter()
	{
		if (m_hPrinter != NULL)
		{
			if (t_bManaged)
				::ClosePrinter(m_hPrinter);
			m_hPrinter = NULL;
		}
	}

	bool PrinterProperties(HWND hWnd = NULL)
	{
		if (hWnd == NULL)
			hWnd = ::GetActiveWindow();
		return !!::PrinterProperties(hWnd, m_hPrinter);
	}
	HANDLE CopyToHDEVNAMES() const
	{
		HANDLE h = NULL;
		CPrinterInfo<5> pinfon5;
		CPrinterInfo<2> pinfon2;
		LPTSTR lpszPrinterName = NULL;
		//Some printers fail for PRINTER_INFO_5 in some situations
		if (pinfon5.GetPrinterInfo(m_hPrinter))
			lpszPrinterName = pinfon5.m_pi->pPrinterName;
		else if (pinfon2.GetPrinterInfo(m_hPrinter))
			lpszPrinterName = pinfon2.m_pi->pPrinterName;
		if (lpszPrinterName != NULL)
		{
			int nLen = sizeof(DEVNAMES)+ (lstrlen(lpszPrinterName)+1)*sizeof(TCHAR);
			h = GlobalAlloc(GMEM_MOVEABLE, nLen);
			BYTE* pv = (BYTE*)GlobalLock(h);
			DEVNAMES* pdev = (DEVNAMES*)pv;
			if (pv != NULL)
			{
				memset(pv, 0, nLen);
				pdev->wDeviceOffset = sizeof(DEVNAMES)/sizeof(TCHAR);
				pv = pv + sizeof(DEVNAMES); //now points to end
				lstrcpy((LPTSTR)pv, lpszPrinterName);
				GlobalUnlock(h);
			}
		}
		return h;
	}
	HDC CreatePrinterDC(const DEVMODE* pdm = NULL)
	{
		CPrinterInfo<5> pinfo5;
		CPrinterInfo<2> pinfo2;
		HDC hDC = NULL;
		LPTSTR lpszPrinterName = NULL;
		//Some printers fail for PRINTER_INFO_5 in some situations
		if (pinfo5.GetPrinterInfo(m_hPrinter))
			lpszPrinterName = pinfo5.m_pi->pPrinterName;
		else if (pinfo2.GetPrinterInfo(m_hPrinter))
			lpszPrinterName = pinfo2.m_pi->pPrinterName;
		if (lpszPrinterName != NULL)
			hDC = ::CreateDC(NULL, lpszPrinterName, NULL, pdm);
		return hDC;
	}
	HDC CreatePrinterIC(const DEVMODE* pdm = NULL)
	{
		CPrinterInfo<5> pinfo5;
		CPrinterInfo<2> pinfo2;
		HDC hDC = NULL;
		LPTSTR lpszPrinterName = NULL;
		//Some printers fail for PRINTER_INFO_5 in some situations
		if (pinfo5.GetPrinterInfo(m_hPrinter))
			lpszPrinterName = pinfo5.m_pi->pPrinterName;
		else if (pinfo2.GetPrinterInfo(m_hPrinter))
			lpszPrinterName = pinfo2.m_pi->pPrinterName;
		if (lpszPrinterName != NULL)
			hDC = ::CreateIC(NULL, lpszPrinterName, NULL, pdm);
		return hDC;
	}

	void Attach(HANDLE hPrinter)
	{
		ClosePrinter();
		m_hPrinter = hPrinter;
	}

	HANDLE Detach()
	{
		HANDLE hPrinter = m_hPrinter;
		m_hPrinter = NULL;
		return hPrinter;
	}
	operator HANDLE() const {return m_hPrinter;}
};

typedef CPrinterT<false>	CPrinterHandle;
typedef CPrinterT<true> 	CPrinter;


template <bool t_bManaged>
class CDevModeT
{
public:
// Data members
	HANDLE m_hDevMode;
	DEVMODE* m_pDevMode;

// Constructor/destructor
	CDevModeT(HANDLE hDevMode = NULL) : m_hDevMode(hDevMode)
	{
		m_pDevMode = (m_hDevMode != NULL) ? (DEVMODE*)GlobalLock(m_hDevMode) : NULL;
	}
	~CDevModeT()
	{
		Cleanup();
	}

// Operations
	CDevModeT<t_bManaged>& operator=(HANDLE hDevMode)
	{
		Attach(hDevMode);
		return *this;
	}

	void Attach(HANDLE hDevModeNew)
	{
		Cleanup();
		m_hDevMode = hDevModeNew;
		m_pDevMode = (m_hDevMode != NULL) ? (DEVMODE*)GlobalLock(m_hDevMode) : NULL;
	}

	HANDLE Detach()
	{
		if (m_hDevMode != NULL)
			GlobalUnlock(m_hDevMode);
		HANDLE hDevMode = m_hDevMode;
		m_hDevMode = NULL;
		return hDevMode;
	}

	bool IsNull() const { return (m_hDevMode == NULL); }

	bool CopyFromPrinter(HANDLE hPrinter)
	{
		CPrinterInfo<2> pinfo;
		bool b = pinfo.GetPrinterInfo(hPrinter);
		if (b)
		 b = CopyFromDEVMODE(pinfo.m_pi->pDevMode);
		return b;
	}
	bool CopyFromDEVMODE(const DEVMODE* pdm)
	{
		if (pdm == NULL)
			return false;
		int nSize = pdm->dmSize + pdm->dmDriverExtra;
		HANDLE h = GlobalAlloc(GMEM_MOVEABLE, nSize);
		if (h != NULL)
		{
			void* p = GlobalLock(h);
			memcpy(p, pdm, nSize);
			GlobalUnlock(h);
		}
		Attach(h);
		return (h != NULL);
	}
	bool CopyFromHDEVMODE(HANDLE hdm)
	{
		bool b = false;
		if (hdm != NULL)
		{
			DEVMODE* pdm = (DEVMODE*)GlobalLock(hdm);
			b = CopyFromDEVMODE(pdm);
			GlobalUnlock(hdm);
		}
		return b;
	}
	HANDLE CopyToHDEVMODE()
	{
		if ((m_hDevMode == NULL) || (m_pDevMode == NULL))
			return NULL;
		int nSize = m_pDevMode->dmSize + m_pDevMode->dmDriverExtra;
		HANDLE h = GlobalAlloc(GMEM_MOVEABLE, nSize);
		if (h != NULL)
		{
			void* p = GlobalLock(h);
			memcpy(p, m_pDevMode, nSize);
		}
		return h;
	}
	//If this devmode was for another printer, this will create a new devmode
	//based on the existing devmode, but retargeted at the new printer
	bool UpdateForNewPrinter(HANDLE hPrinter)
	{
		LONG nLen = ::DocumentProperties(NULL, hPrinter, NULL, NULL, NULL, 0);
		DEVMODE* pdm = (DEVMODE*) alloca(nLen);
		memset(pdm, 0, nLen);
		LONG l = ::DocumentProperties(NULL, hPrinter, NULL, pdm, m_pDevMode,
			DM_IN_BUFFER|DM_OUT_BUFFER);
		bool b = false;
		if (l == IDOK)
			b = CopyFromDEVMODE(pdm);
		return b;
	}
	bool DocumentProperties(HANDLE hPrinter, HWND hWnd = NULL)
	{
		CPrinterInfo<1> pi;
		pi.GetPrinterInfo(hPrinter);
		if (hWnd == NULL)
			hWnd = ::GetActiveWindow();

		LONG nLen = ::DocumentProperties(hWnd, hPrinter, pi.m_pi->pName, NULL, NULL, 0);
		DEVMODE* pdm = (DEVMODE*) alloca(nLen);
		memset(pdm, 0, nLen);
		LONG l = ::DocumentProperties(hWnd, hPrinter, pi.m_pi->pName, pdm,
			m_pDevMode, DM_IN_BUFFER|DM_OUT_BUFFER|DM_PROMPT);
		bool b = false;
		if (l == IDOK)
			b = CopyFromDEVMODE(pdm);
		return b;
	}
	operator HANDLE() const {return m_hDevMode;}
	operator DEVMODE*() const {return m_pDevMode;}

// Implementation
	void Cleanup()
	{
		if (m_hDevMode != NULL)
		{
			GlobalUnlock(m_hDevMode);
			if(t_bManaged)
				GlobalFree(m_hDevMode);
			m_hDevMode = NULL;
		}
	}
};

typedef CDevModeT<false>	CDevModeHandle;
typedef CDevModeT<true> 	CDevMode;


class CPrinterDC : public CDC
{
public:
// Constructors/destructor
	CPrinterDC()
	{
		CPrinter printer;
		printer.OpenDefaultPrinter();
		Attach(printer.CreatePrinterDC());
		ATLASSERT(m_hDC != NULL);
	}
	CPrinterDC(HANDLE hPrinter, const DEVMODE* pdm = NULL)
	{
		CPrinterHandle p;
		p.Attach(hPrinter);
		Attach(p.CreatePrinterDC(pdm));
		ATLASSERT(m_hDC != NULL);
	}
	~CPrinterDC()
	{
		DeleteDC();
	}
};


//Defines callbacks used by CPrintJob
//This is not a COM interface
class ATL_NO_VTABLE IPrintJobInfo
{
public:
	virtual void BeginPrintJob(HDC hDC)=0; //allocate handles needed, etc
	virtual void EndPrintJob(HDC hDC, bool bAborted)=0; // free handles, etc
	virtual void PrePrintPage(UINT nPage, HDC hDC)=0;
	virtual bool PrintPage(UINT nPage, HDC hDC)=0;
	virtual void PostPrintPage(UINT nPage, HDC hDC)=0;
	//GetNewDevModeForPage allows only a change to be provided
	virtual DEVMODE* GetNewDevModeForPage(UINT nLastPage, UINT nPage)=0;
	virtual bool IsValidPage(UINT nPage);
};


//Provides a default implementatin for IPrintJobInfo
//Typically, MI'd into a document or view class
class ATL_NO_VTABLE CPrintJobInfo : public IPrintJobInfo
{
public:
	virtual void BeginPrintJob(HDC /*hDC*/) //allocate handles needed, etc
	{
	}
	virtual void EndPrintJob(HDC /*hDC*/, bool /*bAborted*/)	// free handles, etc
	{
	}
	virtual void PrePrintPage(UINT /*nPage*/, HDC hDC)
	{
		m_nPJState = ::SaveDC(hDC);
	}
	virtual bool PrintPage(UINT /*nPage*/, HDC /*hDC*/) = 0;
	virtual void PostPrintPage(UINT /*nPage*/, HDC hDC)
	{
		RestoreDC(hDC, m_nPJState);
	}
	virtual DEVMODE* GetNewDevModeForPage(UINT /*nLastPage*/, UINT /*nPage*/)
	{
		return NULL;
	}
	virtual bool IsValidPage(UINT /*nPage*/)
	{
		return true;
	}
private:
	int m_nPJState;
};


//Wraps a set of tasks for a specific printer (StartDoc/EndDoc)
//Handles aborting, background printing
class CPrintJob
{
public:
	CPrinterHandle m_printer;
	IPrintJobInfo* m_pInfo;
	DEVMODE* m_pDefDevMode;
	DOCINFO m_docinfo;
	DWORD m_dwJobID;
	bool m_bCancel;
	bool m_bComplete;
	bool m_bMultiDevMode;
	unsigned long m_nStartPage;
	unsigned long m_nEndPage;
	CPrintJob()
	{
		m_dwJobID = 0;
		m_bCancel = false;
		m_bComplete = true;
	}
	~CPrintJob()
	{
		ATLASSERT(IsJobComplete()); //premature destruction?
	}
	bool IsJobComplete() const { return m_bComplete; }
	bool StartPrintJob(bool bBackground, HANDLE hPrinter, DEVMODE* pDefaultDevMode,
		IPrintJobInfo* pInfo, LPCTSTR lpszDocName, 
		unsigned long nStartPage, unsigned long nEndPage)
	{
		ATLASSERT(m_bComplete); //previous job not done yet?
		if (pInfo == NULL)
			return false;
		memset(&m_docinfo, 0, sizeof(m_docinfo));
		m_docinfo.cbSize = sizeof(m_docinfo);
		m_docinfo.lpszDocName = lpszDocName;
		m_pInfo = pInfo;
		m_nStartPage = nStartPage;
		m_nEndPage = nEndPage;
		m_printer.Attach(hPrinter);
		m_pDefDevMode = pDefaultDevMode;
		DEVMODE* pdm = m_pInfo->GetNewDevModeForPage(0, 1);
		m_bMultiDevMode = (pdm != NULL);
		m_bComplete = false;
		if (!bBackground)
		{
			m_bComplete = true;
			return StartHelper();
		}

		//Create a thread and return

		DWORD dwThreadID = 0;
		HANDLE hThread = CreateThread(NULL, 0, StartProc, (void*)this, 0, &dwThreadID);
		CloseHandle(hThread);
		return (hThread != NULL);
	}

// Implementation
	static DWORD WINAPI StartProc(void* p)
	{
		CPrintJob* pThis = (CPrintJob*)p;
		pThis->StartHelper();
		pThis->m_bComplete = true;
		return 0;
	}
	bool StartHelper()
	{
		CDC dcPrinter;
		dcPrinter.Attach(m_printer.CreatePrinterDC(m_pDefDevMode));
		if (dcPrinter.IsNull())
			return false;
			
		m_dwJobID = ::StartDoc(dcPrinter, &m_docinfo);
		if (m_dwJobID == 0)
			return false;

		m_pInfo->BeginPrintJob(dcPrinter);

		//print all the pages now
		unsigned long nPage;
		unsigned long nLastPage=0;
		for (nPage = m_nStartPage; nPage <= m_nEndPage; nPage++)
		{
			if (!m_pInfo->IsValidPage(nPage))
				break;
			if (m_bMultiDevMode)
			{
				DEVMODE* pdm = m_pInfo->GetNewDevModeForPage(nLastPage, nPage);
				if (pdm == NULL)
					pdm = m_pDefDevMode;
				dcPrinter.ResetDC(pdm);
			}
			dcPrinter.StartPage();
			m_pInfo->PrePrintPage(nPage, dcPrinter);
			if (!m_pInfo->PrintPage(nPage, dcPrinter))
				m_bCancel = true;
			m_pInfo->PostPrintPage(nPage, dcPrinter);
			dcPrinter.EndPage();
			if (m_bCancel)
				break;
			nLastPage = nPage;
		}

		m_pInfo->EndPrintJob(dcPrinter, m_bCancel);
		if (m_bCancel)
			::AbortDoc(dcPrinter);
		else
			::EndDoc(dcPrinter);
		m_dwJobID = 0;
		return true;
	}
	//Cancels a print job.	Can be called asynchronously.
	bool CancelPrintJob()
	{
		m_bCancel = 1;
	}
};


// Adds print preview support to an existing window
class CPrintPreview
{
public:
// Data members
	IPrintJobInfo* m_pInfo;
	CPrinterHandle m_printer;
	CEnhMetaFile m_meta;
	DEVMODE* m_pDefDevMode;
	DEVMODE* m_pCurDevMode;
	SIZE m_sizeCurPhysOffset;

// Constructor
	CPrintPreview() : m_pInfo(NULL), m_pDefDevMode(NULL), m_pCurDevMode(NULL)
	{
		m_sizeCurPhysOffset.cx = 0;
		m_sizeCurPhysOffset.cy = 0;
	}

// Operations
	void SetPrintPreviewInfo(HANDLE hPrinter, DEVMODE* pDefaultDevMode, IPrintJobInfo* pji)
	{
		m_printer.Attach(hPrinter);
		m_pDefDevMode = pDefaultDevMode;
		m_pInfo = pji;
		m_nCurPage = 0;
		m_pCurDevMode = NULL;
	}
	void SetEnhMetaFile(HENHMETAFILE hEMF)
	{
		m_meta = hEMF;
	}
	void SetPage(int nPage)
	{
		if (!m_pInfo->IsValidPage(nPage))
			return;
		m_nCurPage = nPage;
		m_pCurDevMode = m_pInfo->GetNewDevModeForPage(0, nPage);
		if (m_pCurDevMode == NULL)
			m_pCurDevMode = m_pDefDevMode;
		CDC dcPrinter = m_printer.CreatePrinterDC(m_pCurDevMode);

		int iWidth = dcPrinter.GetDeviceCaps(PHYSICALWIDTH); 
		int iHeight = dcPrinter.GetDeviceCaps(PHYSICALHEIGHT); 
		int nLogx = dcPrinter.GetDeviceCaps(LOGPIXELSX);
		int nLogy = dcPrinter.GetDeviceCaps(LOGPIXELSY);

		RECT rcMM = {0,0, MulDiv(iWidth, 2540, nLogx), MulDiv(iHeight, 2540, nLogy)};

		m_sizeCurPhysOffset.cx = dcPrinter.GetDeviceCaps(PHYSICALOFFSETX);
		m_sizeCurPhysOffset.cy = dcPrinter.GetDeviceCaps(PHYSICALOFFSETY);
		
		CEnhMetaFileDC dcMeta(dcPrinter, &rcMM);
		m_pInfo->PrePrintPage(nPage, dcMeta);
		m_pInfo->PrintPage(nPage, dcMeta);
		m_pInfo->PostPrintPage(nPage, dcMeta);
		m_meta.Attach(dcMeta.Close());
	}
	void GetPageRect(RECT& rc, LPRECT prc)
	{
		int x1 = rc.right-rc.left;
		int y1 = rc.bottom - rc.top;
		if ((x1 < 0) || (y1 < 0))
			return;

		CEnhMetaFileInfo emfinfo(m_meta);
		ENHMETAHEADER* pmh = emfinfo.GetEnhMetaFileHeader();

		//Compute whether we are OK vertically or horizontally
		int x2 = pmh->szlDevice.cx;
		int y2 = pmh->szlDevice.cy;
		int y1p = MulDiv(x1, y2, x2);
		int x1p = MulDiv(y1, x2, y2);
		ATLASSERT( (x1p <= x1) || (y1p <= y1));
		if (x1p <= x1)
		{
			prc->left = rc.left + (x1 - x1p)/2;
			prc->right = prc->left + x1p;
			prc->top = rc.top;
			prc->bottom = rc.bottom;
		}
		else
		{
			prc->left = rc.left;
			prc->right = rc.right;
			prc->top = rc.top + (y1 - y1p)/2;
			prc->bottom = prc->top + y1p;
		}
	}

// Painting helper
	void DoPaint(CDCHandle dc, RECT& rc)
	{
		CEnhMetaFileInfo emfinfo(m_meta);
		ENHMETAHEADER* pmh = emfinfo.GetEnhMetaFileHeader();
		int nOffsetX = MulDiv(m_sizeCurPhysOffset.cx, rc.right-rc.left, pmh->szlDevice.cx);
		int nOffsetY = MulDiv(m_sizeCurPhysOffset.cy, rc.bottom-rc.top, pmh->szlDevice.cy);

		dc.OffsetWindowOrg(-nOffsetX, -nOffsetY);
		dc.PlayMetaFile(m_meta, &rc);
	}

// Implementation - data
	int m_nCurPage;
};

template <class T, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class ATL_NO_VTABLE CPrintPreviewWindowImpl : public CWindowImpl<T, TBase, TWinTraits>, public CPrintPreview
{
public:
	DECLARE_WND_CLASS_EX(NULL, CS_VREDRAW | CS_HREDRAW, -1)

	enum { m_cxOffset = 10, m_cyOffset = 10 };

// Constructor
	CPrintPreviewWindowImpl() : m_nMaxPage(0), m_nMinPage(0)
	{ }

// Operations
	void SetPrintPreviewInfo(HANDLE hPrinter, DEVMODE* pDefaultDevMode, 
		IPrintJobInfo* pji, int nMinPage, int nMaxPage)
	{
		CPrintPreview::SetPrintPreviewInfo(hPrinter, pDefaultDevMode, pji);
		m_nMinPage = nMinPage;
		m_nMaxPage = nMaxPage;
	}
	bool NextPage()
	{
		if (m_nCurPage == m_nMaxPage)
			return false;
		SetPage(m_nCurPage + 1);
		Invalidate();
		return true;
	}
	bool PrevPage()
	{
		if (m_nCurPage == m_nMinPage)
			return false;
		if (m_nCurPage == 0)
			return false;
		SetPage(m_nCurPage - 1);
		Invalidate();
		return true;
	}

// Message map and handlers
	BEGIN_MSG_MAP(CPrintPreviewWindowImpl)
		MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBkgnd)
		MESSAGE_HANDLER(WM_PAINT, OnPaint)
	END_MSG_MAP()

	LRESULT OnEraseBkgnd(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		return 1;	// no need for the background
	}

	LRESULT OnPaint(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		CPaintDC dc(m_hWnd);
		RECT rcClient;
		GetClientRect(&rcClient);
		RECT rcArea = rcClient;
		::InflateRect(&rcArea, -pT->m_cxOffset, -pT->m_cyOffset);
		if (rcArea.left > rcArea.right)
			rcArea.right = rcArea.left;
		if (rcArea.top > rcArea.bottom)
			rcArea.bottom = rcArea.top;
		RECT rc;
		GetPageRect(rcArea, &rc);
		CRgn rgn1, rgn2;
		rgn1.CreateRectRgnIndirect(&rc);
		rgn2.CreateRectRgnIndirect(&rcClient);
		rgn2.CombineRgn(rgn1, RGN_DIFF);
		dc.SelectClipRgn(rgn2);
		dc.FillRect(&rcClient, (HBRUSH)LongToPtr(COLOR_BTNSHADOW+1));
		dc.SelectClipRgn(NULL);
		dc.FillRect(&rc, (HBRUSH)GetStockObject(WHITE_BRUSH));
		pT->DoPaint(dc.m_hDC, rc);
		return 0;
	}

// Implementation - data
	int m_nMinPage;
	int m_nMaxPage;
};


class CPrintPreviewWindow : public CPrintPreviewWindowImpl<CPrintPreviewWindow>
{
public:
	DECLARE_WND_CLASS_EX(_T("WTL_PrintPreview"), CS_VREDRAW | CS_HREDRAW, -1)
};

}; //namespace WTL

#endif // __ATLPRINT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\atlmisc.h ===
// WTL Version 3.0
// Copyright (C) 1997-1999 Microsoft Corporation
// All rights reserved.
//
// This file is a part of Windows Template Library.
// The code and information is provided "as-is" without
// warranty of any kind, either expressed or implied.

#ifndef __ATLMISC_H__
#define __ATLMISC_H__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLAPP_H__
	#error atlmisc.h requires atlapp.h to be included first
#endif


#ifndef _WTL_NO_WTYPES
#define __ATLTYPES_H__
#endif //!_WTL_NO_WTYPES

#ifdef _ATL_TMP_NO_CSTRING
#define _WTL_NO_CSTRING
#endif

#ifndef _WTL_NO_CSTRING
#define __ATLSTR_H__
#endif //!_WTL_NO_CSTRING


namespace WTL
{

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

#ifndef _WTL_NO_WTYPES
class CSize;
class CPoint;
class CRect;
#endif //!_WTL_NO_WTYPES
#ifndef _WTL_NO_CSTRING
class CString;
#endif //!_WTL_NO_CSTRING
class CRecentDocumentList;
class CFindFile;


/////////////////////////////////////////////////////////////////////////////
// CSize - Wrapper for Windows SIZE structure.

#ifndef _WTL_NO_WTYPES

class CSize : public tagSIZE
{
public:
// Constructors
	CSize();
	CSize(int initCX, int initCY);
	CSize(SIZE initSize);
	CSize(POINT initPt);
	CSize(DWORD dwSize);

// Operations
	BOOL operator==(SIZE size) const;
	BOOL operator!=(SIZE size) const;
	void operator+=(SIZE size);
	void operator-=(SIZE size);
	void SetSize(int CX, int CY);

// Operators returning CSize values
	CSize operator+(SIZE size) const;
	CSize operator-(SIZE size) const;
	CSize operator-() const;

// Operators returning CPoint values
	CPoint operator+(POINT point) const;
	CPoint operator-(POINT point) const;

// Operators returning CRect values
	CRect operator+(const RECT* lpRect) const;
	CRect operator-(const RECT* lpRect) const;
};


/////////////////////////////////////////////////////////////////////////////
// CPoint - Wrapper for Windows POINT structure.

class CPoint : public tagPOINT
{
public:
// Constructors
	CPoint();
	CPoint(int initX, int initY);
	CPoint(POINT initPt);
	CPoint(SIZE initSize);
	CPoint(DWORD dwPoint);

// Operations
	void Offset(int xOffset, int yOffset);
	void Offset(POINT point);
	void Offset(SIZE size);
	BOOL operator==(POINT point) const;
	BOOL operator!=(POINT point) const;
	void operator+=(SIZE size);
	void operator-=(SIZE size);
	void operator+=(POINT point);
	void operator-=(POINT point);
	void SetPoint(int X, int Y);

// Operators returning CPoint values
	CPoint operator+(SIZE size) const;
	CPoint operator-(SIZE size) const;
	CPoint operator-() const;
	CPoint operator+(POINT point) const;

// Operators returning CSize values
	CSize operator-(POINT point) const;

// Operators returning CRect values
	CRect operator+(const RECT* lpRect) const;
	CRect operator-(const RECT* lpRect) const;
};


/////////////////////////////////////////////////////////////////////////////
// CRect - Wrapper for Windows RECT structure.

class CRect : public tagRECT
{
public:
// Constructors
	CRect();
	CRect(int l, int t, int r, int b);
	CRect(const RECT& srcRect);
	CRect(LPCRECT lpSrcRect);
	CRect(POINT point, SIZE size);
	CRect(POINT topLeft, POINT bottomRight);

// Attributes (in addition to RECT members)
	int Width() const;
	int Height() const;
	CSize Size() const;
	CPoint& TopLeft();
	CPoint& BottomRight();
	const CPoint& TopLeft() const;
	const CPoint& BottomRight() const;
	CPoint CenterPoint() const;

	// convert between CRect and LPRECT/LPCRECT (no need for &)
	operator LPRECT();
	operator LPCRECT() const;

	BOOL IsRectEmpty() const;
	BOOL IsRectNull() const;
	BOOL PtInRect(POINT point) const;

// Operations
	void SetRect(int x1, int y1, int x2, int y2);
	void SetRect(POINT topLeft, POINT bottomRight);
	void SetRectEmpty();
	void CopyRect(LPCRECT lpSrcRect);
	BOOL EqualRect(LPCRECT lpRect) const;

	void InflateRect(int x, int y);
	void InflateRect(SIZE size);
	void InflateRect(LPCRECT lpRect);
	void InflateRect(int l, int t, int r, int b);
	void DeflateRect(int x, int y);
	void DeflateRect(SIZE size);
	void DeflateRect(LPCRECT lpRect);
	void DeflateRect(int l, int t, int r, int b);

	void OffsetRect(int x, int y);
	void OffsetRect(SIZE size);
	void OffsetRect(POINT point);
	void NormalizeRect();

	// absolute position of rectangle
	void MoveToY(int y);
	void MoveToX(int x);
	void MoveToXY(int x, int y);
	void MoveToXY(POINT point);

	// operations that fill '*this' with result
	BOOL IntersectRect(LPCRECT lpRect1, LPCRECT lpRect2);
	BOOL UnionRect(LPCRECT lpRect1, LPCRECT lpRect2);
	BOOL SubtractRect(LPCRECT lpRectSrc1, LPCRECT lpRectSrc2);

// Additional Operations
	void operator=(const RECT& srcRect);
	BOOL operator==(const RECT& rect) const;
	BOOL operator!=(const RECT& rect) const;
	void operator+=(POINT point);
	void operator+=(SIZE size);
	void operator+=(LPCRECT lpRect);
	void operator-=(POINT point);
	void operator-=(SIZE size);
	void operator-=(LPCRECT lpRect);
	void operator&=(const RECT& rect);
	void operator|=(const RECT& rect);

// Operators returning CRect values
	CRect operator+(POINT point) const;
	CRect operator-(POINT point) const;
	CRect operator+(LPCRECT lpRect) const;
	CRect operator+(SIZE size) const;
	CRect operator-(SIZE size) const;
	CRect operator-(LPCRECT lpRect) const;
	CRect operator&(const RECT& rect2) const;
	CRect operator|(const RECT& rect2) const;
	CRect MulDiv(int nMultiplier, int nDivisor) const;
};


/////////////////////////////////////////////////////////////////////////////
// CSize, CPoint, CRect Implementation

// CSize
inline CSize::CSize()
	{ /* random filled */ }
inline CSize::CSize(int initCX, int initCY)
	{ cx = initCX; cy = initCY; }
inline CSize::CSize(SIZE initSize)
	{ *(SIZE*)this = initSize; }
inline CSize::CSize(POINT initPt)
	{ *(POINT*)this = initPt; }
inline CSize::CSize(DWORD dwSize)
	{
		cx = (short)LOWORD(dwSize);
		cy = (short)HIWORD(dwSize);
	}
inline BOOL CSize::operator==(SIZE size) const
	{ return (cx == size.cx && cy == size.cy); }
inline BOOL CSize::operator!=(SIZE size) const
	{ return (cx != size.cx || cy != size.cy); }
inline void CSize::operator+=(SIZE size)
	{ cx += size.cx; cy += size.cy; }
inline void CSize::operator-=(SIZE size)
	{ cx -= size.cx; cy -= size.cy; }
inline void CSize::SetSize(int CX, int CY)
	{ cx = CX; cy = CY; }	
inline CSize CSize::operator+(SIZE size) const
	{ return CSize(cx + size.cx, cy + size.cy); }
inline CSize CSize::operator-(SIZE size) const
	{ return CSize(cx - size.cx, cy - size.cy); }
inline CSize CSize::operator-() const
	{ return CSize(-cx, -cy); }
inline CPoint CSize::operator+(POINT point) const
	{ return CPoint(cx + point.x, cy + point.y); }
inline CPoint CSize::operator-(POINT point) const
	{ return CPoint(cx - point.x, cy - point.y); }
inline CRect CSize::operator+(const RECT* lpRect) const
	{ return CRect(lpRect) + *this; }
inline CRect CSize::operator-(const RECT* lpRect) const
	{ return CRect(lpRect) - *this; }

// CPoint
inline CPoint::CPoint()
	{ /* random filled */ }
inline CPoint::CPoint(int initX, int initY)
	{ x = initX; y = initY; }
inline CPoint::CPoint(POINT initPt)
	{ *(POINT*)this = initPt; }
inline CPoint::CPoint(SIZE initSize)
	{ *(SIZE*)this = initSize; }
inline CPoint::CPoint(DWORD dwPoint)
	{
		x = (short)LOWORD(dwPoint);
		y = (short)HIWORD(dwPoint);
	}
inline void CPoint::Offset(int xOffset, int yOffset)
	{ x += xOffset; y += yOffset; }
inline void CPoint::Offset(POINT point)
	{ x += point.x; y += point.y; }
inline void CPoint::Offset(SIZE size)
	{ x += size.cx; y += size.cy; }
inline BOOL CPoint::operator==(POINT point) const
	{ return (x == point.x && y == point.y); }
inline BOOL CPoint::operator!=(POINT point) const
	{ return (x != point.x || y != point.y); }
inline void CPoint::operator+=(SIZE size)
	{ x += size.cx; y += size.cy; }
inline void CPoint::operator-=(SIZE size)
	{ x -= size.cx; y -= size.cy; }
inline void CPoint::operator+=(POINT point)
	{ x += point.x; y += point.y; }
inline void CPoint::operator-=(POINT point)
	{ x -= point.x; y -= point.y; }
inline void CPoint::SetPoint(int X, int Y)
	{ x = X; y = Y; }
inline CPoint CPoint::operator+(SIZE size) const
	{ return CPoint(x + size.cx, y + size.cy); }
inline CPoint CPoint::operator-(SIZE size) const
	{ return CPoint(x - size.cx, y - size.cy); }
inline CPoint CPoint::operator-() const
	{ return CPoint(-x, -y); }
inline CPoint CPoint::operator+(POINT point) const
	{ return CPoint(x + point.x, y + point.y); }
inline CSize CPoint::operator-(POINT point) const
	{ return CSize(x - point.x, y - point.y); }
inline CRect CPoint::operator+(const RECT* lpRect) const
	{ return CRect(lpRect) + *this; }
inline CRect CPoint::operator-(const RECT* lpRect) const
	{ return CRect(lpRect) - *this; }

// CRect
inline CRect::CRect()
	{ /* random filled */ }
inline CRect::CRect(int l, int t, int r, int b)
	{ left = l; top = t; right = r; bottom = b; }
inline CRect::CRect(const RECT& srcRect)
	{ ::CopyRect(this, &srcRect); }
inline CRect::CRect(LPCRECT lpSrcRect)
	{ ::CopyRect(this, lpSrcRect); }
inline CRect::CRect(POINT point, SIZE size)
	{ right = (left = point.x) + size.cx; bottom = (top = point.y) + size.cy; }
inline CRect::CRect(POINT topLeft, POINT bottomRight)
	{ left = topLeft.x; top = topLeft.y;
		right = bottomRight.x; bottom = bottomRight.y; }
inline int CRect::Width() const
	{ return right - left; }
inline int CRect::Height() const
	{ return bottom - top; }
inline CSize CRect::Size() const
	{ return CSize(right - left, bottom - top); }
inline CPoint& CRect::TopLeft()
	{ return *((CPoint*)this); }
inline CPoint& CRect::BottomRight()
	{ return *((CPoint*)this+1); }
inline const CPoint& CRect::TopLeft() const
	{ return *((CPoint*)this); }
inline const CPoint& CRect::BottomRight() const
	{ return *((CPoint*)this+1); }
inline CPoint CRect::CenterPoint() const
	{ return CPoint((left+right)/2, (top+bottom)/2); }
inline CRect::operator LPRECT()
	{ return this; }
inline CRect::operator LPCRECT() const
	{ return this; }
inline BOOL CRect::IsRectEmpty() const
	{ return ::IsRectEmpty(this); }
inline BOOL CRect::IsRectNull() const
	{ return (left == 0 && right == 0 && top == 0 && bottom == 0); }
inline BOOL CRect::PtInRect(POINT point) const
	{ return ::PtInRect(this, point); }
inline void CRect::SetRect(int x1, int y1, int x2, int y2)
	{ ::SetRect(this, x1, y1, x2, y2); }
inline void CRect::SetRect(POINT topLeft, POINT bottomRight)
	{ ::SetRect(this, topLeft.x, topLeft.y, bottomRight.x, bottomRight.y); }
inline void CRect::SetRectEmpty()
	{ ::SetRectEmpty(this); }
inline void CRect::CopyRect(LPCRECT lpSrcRect)
	{ ::CopyRect(this, lpSrcRect); }
inline BOOL CRect::EqualRect(LPCRECT lpRect) const
	{ return ::EqualRect(this, lpRect); }
inline void CRect::InflateRect(int x, int y)
	{ ::InflateRect(this, x, y); }
inline void CRect::InflateRect(SIZE size)
	{ ::InflateRect(this, size.cx, size.cy); }
inline void CRect::DeflateRect(int x, int y)
	{ ::InflateRect(this, -x, -y); }
inline void CRect::DeflateRect(SIZE size)
	{ ::InflateRect(this, -size.cx, -size.cy); }
inline void CRect::OffsetRect(int x, int y)
	{ ::OffsetRect(this, x, y); }
inline void CRect::OffsetRect(POINT point)
	{ ::OffsetRect(this, point.x, point.y); }
inline void CRect::OffsetRect(SIZE size)
	{ ::OffsetRect(this, size.cx, size.cy); }
inline BOOL CRect::IntersectRect(LPCRECT lpRect1, LPCRECT lpRect2)
	{ return ::IntersectRect(this, lpRect1, lpRect2);}
inline BOOL CRect::UnionRect(LPCRECT lpRect1, LPCRECT lpRect2)
	{ return ::UnionRect(this, lpRect1, lpRect2); }
inline void CRect::operator=(const RECT& srcRect)
	{ ::CopyRect(this, &srcRect); }
inline BOOL CRect::operator==(const RECT& rect) const
	{ return ::EqualRect(this, &rect); }
inline BOOL CRect::operator!=(const RECT& rect) const
	{ return !::EqualRect(this, &rect); }
inline void CRect::operator+=(POINT point)
	{ ::OffsetRect(this, point.x, point.y); }
inline void CRect::operator+=(SIZE size)
	{ ::OffsetRect(this, size.cx, size.cy); }
inline void CRect::operator+=(LPCRECT lpRect)
	{ InflateRect(lpRect); }
inline void CRect::operator-=(POINT point)
	{ ::OffsetRect(this, -point.x, -point.y); }
inline void CRect::operator-=(SIZE size)
	{ ::OffsetRect(this, -size.cx, -size.cy); }
inline void CRect::operator-=(LPCRECT lpRect)
	{ DeflateRect(lpRect); }
inline void CRect::operator&=(const RECT& rect)
	{ ::IntersectRect(this, this, &rect); }
inline void CRect::operator|=(const RECT& rect)
	{ ::UnionRect(this, this, &rect); }
inline CRect CRect::operator+(POINT pt) const
	{ CRect rect(*this); ::OffsetRect(&rect, pt.x, pt.y); return rect; }
inline CRect CRect::operator-(POINT pt) const
	{ CRect rect(*this); ::OffsetRect(&rect, -pt.x, -pt.y); return rect; }
inline CRect CRect::operator+(SIZE size) const
	{ CRect rect(*this); ::OffsetRect(&rect, size.cx, size.cy); return rect; }
inline CRect CRect::operator-(SIZE size) const
	{ CRect rect(*this); ::OffsetRect(&rect, -size.cx, -size.cy); return rect; }
inline CRect CRect::operator+(LPCRECT lpRect) const
	{ CRect rect(this); rect.InflateRect(lpRect); return rect; }
inline CRect CRect::operator-(LPCRECT lpRect) const
	{ CRect rect(this); rect.DeflateRect(lpRect); return rect; }
inline CRect CRect::operator&(const RECT& rect2) const
	{ CRect rect; ::IntersectRect(&rect, this, &rect2);
		return rect; }
inline CRect CRect::operator|(const RECT& rect2) const
	{ CRect rect; ::UnionRect(&rect, this, &rect2);
		return rect; }
inline BOOL CRect::SubtractRect(LPCRECT lpRectSrc1, LPCRECT lpRectSrc2)
	{ return ::SubtractRect(this, lpRectSrc1, lpRectSrc2); }

inline void CRect::NormalizeRect()
{
	int nTemp;
	if (left > right)
	{
		nTemp = left;
		left = right;
		right = nTemp;
	}
	if (top > bottom)
	{
		nTemp = top;
		top = bottom;
		bottom = nTemp;
	}
}

inline void CRect::MoveToY(int y)
	{ bottom = Height() + y; top = y; }
inline void CRect::MoveToX(int x)
	{ right = Width() + x; left = x; }
inline void CRect::MoveToXY(int x, int y)
	{ MoveToX(x); MoveToY(y); }
inline void CRect::MoveToXY(POINT pt)
	{ MoveToX(pt.x); MoveToY(pt.y); }

inline void CRect::InflateRect(LPCRECT lpRect)
{
	left -= lpRect->left;
	top -= lpRect->top;
	right += lpRect->right;
	bottom += lpRect->bottom;
}

inline void CRect::InflateRect(int l, int t, int r, int b)
{
	left -= l;
	top -= t;
	right += r;
	bottom += b;
}

inline void CRect::DeflateRect(LPCRECT lpRect)
{
	left += lpRect->left;
	top += lpRect->top;
	right -= lpRect->right;
	bottom -= lpRect->bottom;
}

inline void CRect::DeflateRect(int l, int t, int r, int b)
{
	left += l;
	top += t;
	right -= r;
	bottom -= b;
}

inline CRect CRect::MulDiv(int nMultiplier, int nDivisor) const
{
	return CRect(
		::MulDiv(left, nMultiplier, nDivisor),
		::MulDiv(top, nMultiplier, nDivisor),
		::MulDiv(right, nMultiplier, nDivisor),
		::MulDiv(bottom, nMultiplier, nDivisor));
}

#endif //!_WTL_NO_WTYPES


/////////////////////////////////////////////////////////////////////////////
// CString - String class

#ifndef _WTL_NO_CSTRING

struct CStringData
{
	long nRefs;     // reference count
	int nDataLength;
	int nAllocLength;
	// TCHAR data[nAllocLength]

	TCHAR* data()
		{ return (TCHAR*)(this+1); }
};

// Globals

// For an empty string, m_pchData will point here
// (note: avoids special case of checking for NULL m_pchData)
// empty string data (and locked)
_declspec(selectany) int rgInitData[] = { -1, 0, 0, 0 };
_declspec(selectany) CStringData* _atltmpDataNil = (CStringData*)&rgInitData;
_declspec(selectany) LPCTSTR _atltmpPchNil = (LPCTSTR)(((BYTE*)&rgInitData)+sizeof(CStringData));

#define _atltmpFORCE_ANSI      0x10000
#define _atltmpFORCE_UNICODE   0x20000


class CString
{
public:
// Constructors
	CString();
	CString(const CString& stringSrc);
	CString(TCHAR ch, int nRepeat = 1);
	CString(LPCSTR lpsz);
	CString(LPCWSTR lpsz);
	CString(LPCTSTR lpch, int nLength);
	CString(const unsigned char* psz);

// Attributes & Operations
	// as an array of characters
	int GetLength() const;
	BOOL IsEmpty() const;
	void Empty();                       // free up the data

	TCHAR GetAt(int nIndex) const;      // 0 based
	TCHAR operator[](int nIndex) const; // same as GetAt
	void SetAt(int nIndex, TCHAR ch);
	operator LPCTSTR() const;           // as a C string

	// overloaded assignment
	const CString& operator=(const CString& stringSrc);
	const CString& operator=(TCHAR ch);
#ifdef _UNICODE
	const CString& operator=(char ch);
#endif
	const CString& operator=(LPCSTR lpsz);
	const CString& operator=(LPCWSTR lpsz);
	const CString& operator=(const unsigned char* psz);

	// string concatenation
	const CString& operator+=(const CString& string);
	const CString& operator+=(TCHAR ch);
#ifdef _UNICODE
	const CString& operator+=(char ch);
#endif
	const CString& operator+=(LPCTSTR lpsz);

	friend CString __stdcall operator+(const CString& string1, const CString& string2);
	friend CString __stdcall operator+(const CString& string, TCHAR ch);
	friend CString __stdcall operator+(TCHAR ch, const CString& string);
#ifdef _UNICODE
	friend CString __stdcall operator+(const CString& string, char ch);
	friend CString __stdcall operator+(char ch, const CString& string);
#endif
	friend CString __stdcall operator+(const CString& string, LPCTSTR lpsz);
	friend CString __stdcall operator+(LPCTSTR lpsz, const CString& string);

	// string comparison
	int Compare(LPCTSTR lpsz) const;         // straight character
	int CompareNoCase(LPCTSTR lpsz) const;   // ignore case
	int Collate(LPCTSTR lpsz) const;         // NLS aware

	// simple sub-string extraction
	CString Mid(int nFirst, int nCount) const;
	CString Mid(int nFirst) const;
	CString Left(int nCount) const;
	CString Right(int nCount) const;

	CString SpanIncluding(LPCTSTR lpszCharSet) const;
	CString SpanExcluding(LPCTSTR lpszCharSet) const;

	// upper/lower/reverse conversion
	void MakeUpper();
	void MakeLower();
	void MakeReverse();

	// trimming whitespace (either side)
	void TrimRight();
	void TrimLeft();

	// advanced manipulation
	// replace occurrences of chOld with chNew
	int Replace(TCHAR chOld, TCHAR chNew);
	// replace occurrences of substring lpszOld with lpszNew;
	// empty lpszNew removes instances of lpszOld
	int Replace(LPCTSTR lpszOld, LPCTSTR lpszNew);
	// remove occurrences of chRemove
	int Remove(TCHAR chRemove);
	// insert character at zero-based index; concatenates
	// if index is past end of string
	int Insert(int nIndex, TCHAR ch);
	// insert substring at zero-based index; concatenates
	// if index is past end of string
	int Insert(int nIndex, LPCTSTR pstr);
	// delete nCount characters starting at zero-based index
	int Delete(int nIndex, int nCount = 1);

	// searching (return starting index, or -1 if not found)
	// look for a single character match
	int Find(TCHAR ch) const;               // like "C" strchr
	int ReverseFind(TCHAR ch) const;
	int FindOneOf(LPCTSTR lpszCharSet) const;

	// look for a specific sub-string
	int Find(LPCTSTR lpszSub) const;        // like "C" strstr

	// Concatentation for non strings
	const CString& Append(int n)
	{
		TCHAR szBuffer[10];
		wsprintf(szBuffer,_T("%d"),n);
		ConcatInPlace(SafeStrlen(szBuffer), szBuffer);
		return *this;
	}

	// simple formatting
	void __cdecl Format(LPCTSTR lpszFormat, ...);
	void __cdecl Format(UINT nFormatID, ...);

	// formatting for localization (uses FormatMessage API)
	BOOL __cdecl FormatMessage(LPCTSTR lpszFormat, ...);
	BOOL __cdecl FormatMessage(UINT nFormatID, ...);

	// Windows support
	BOOL LoadString(UINT nID);          // load from string resource
										// 255 chars max
#ifndef _UNICODE
	// ANSI <-> OEM support (convert string in place)
	void AnsiToOem();
	void OemToAnsi();
#endif

#ifndef _ATL_NO_COM
	// OLE BSTR support (use for OLE automation)
	BSTR AllocSysString() const;
	BSTR SetSysString(BSTR* pbstr) const;
#endif //!_ATL_NO_COM

	// Access to string implementation buffer as "C" character array
	LPTSTR GetBuffer(int nMinBufLength);
	void ReleaseBuffer(int nNewLength = -1);
	LPTSTR GetBufferSetLength(int nNewLength);
	void FreeExtra();

	// Use LockBuffer/UnlockBuffer to turn refcounting off
	LPTSTR LockBuffer();
	void UnlockBuffer();

// Implementation
public:
	~CString();
	int GetAllocLength() const;

	static BOOL __stdcall _IsValidString(LPCWSTR lpsz, int nLength)
	{
		if(lpsz == NULL)
			return FALSE;
		return !::IsBadStringPtrW(lpsz, nLength);
	}

	static BOOL __stdcall _IsValidString(LPCSTR lpsz, int nLength)
	{
		if(lpsz == NULL)
			return FALSE;
		return !::IsBadStringPtrA(lpsz, nLength);
	}

protected:
	LPTSTR m_pchData;   // pointer to ref counted string data

	// implementation helpers
	CStringData* GetData() const;
	void Init();
	void AllocCopy(CString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
	BOOL AllocBuffer(int nLen);
	void AssignCopy(int nSrcLen, LPCTSTR lpszSrcData);
	void ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data, int nSrc2Len, LPCTSTR lpszSrc2Data);
	void ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData);
	void FormatV(LPCTSTR lpszFormat, va_list argList);
	void CopyBeforeWrite();
	BOOL AllocBeforeWrite(int nLen);
	void Release();
	static void PASCAL Release(CStringData* pData);
	static int PASCAL SafeStrlen(LPCTSTR lpsz);

	typedef TCHAR TCHAR_ARG;
	typedef WCHAR WCHAR_ARG;
	typedef char CHAR_ARG;

	struct _DOUBLE
	{
		BYTE doubleBits[sizeof(double)];
	};

	static int __stdcall _LoadString(UINT nID, LPTSTR lpszBuf, UINT nMaxBuf)
	{
#ifdef _DEBUG
		// LoadString without annoying warning from the Debug kernel if the
		//  segment containing the string is not present
		if (::FindResource(_Module.GetResourceInstance(), MAKEINTRESOURCE((nID>>4)+1), RT_STRING) == NULL)
		{
			lpszBuf[0] = '\0';
			return 0; // not found
		}
#endif //_DEBUG
		int nLen = ::LoadString(_Module.GetResourceInstance(), nID, lpszBuf, nMaxBuf);
		if (nLen == 0)
			lpszBuf[0] = '\0';
		return nLen;
	}

	static const CString& __stdcall _GetEmptyString()
	{
		return *(CString*)&_atltmpPchNil;
	}

// CString conversion helpers
	static int __cdecl _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count)
	{
		if (count == 0 && mbstr != NULL)
			return 0;

		int result = ::WideCharToMultiByte(CP_ACP, 0, wcstr, -1, mbstr, (int)count, NULL, NULL);
		ATLASSERT(mbstr == NULL || result <= (int)count);
		if (result > 0)
			mbstr[result-1] = 0;
		return result;
	}

	static int __cdecl _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count)
	{
		if (count == 0 && wcstr != NULL)
			return 0;

		int result = ::MultiByteToWideChar(CP_ACP, 0, mbstr, -1, wcstr, (int)count);
		ATLASSERT(wcstr == NULL || result <= (int)count);
		if (result > 0)
			wcstr[result-1] = 0;
		return result;
	}

// Helpers to avoid CRT startup code
   	static TCHAR* _cstrchr(const TCHAR* p, TCHAR ch)
	{
		//strchr for '\0' should succeed
		while (*p != 0)
		{
			if (*p == ch)
				break;
			p = CharNext(p);
		}
		return (TCHAR*)((*p == ch) ? p : NULL);
	}
	static TCHAR* _cstrchr_db(const TCHAR* p, TCHAR ch1, TCHAR ch2)
	{
		const TCHAR* lpsz = NULL;
		while (*p != 0)
		{
			if (*p == ch1 && *(p+1) == ch2)
			{
				lpsz = p;
				break;
			}
			p = CharNext(p);
		}
		return (TCHAR*)lpsz;
	}
	static TCHAR* _cstrrchr(const TCHAR* p, TCHAR ch)
	{
		const TCHAR* lpsz = NULL;
		while (*p != 0)
		{
			if (*p == ch)
				lpsz = p;
			p = CharNext(p);
		}
		return (TCHAR*)lpsz;
	}
	static TCHAR* _cstrrev(TCHAR* pStr)
	{
		// Optimize NULL, zero-length, and single-char case.
		if ((pStr == NULL) || (pStr[0] == '\0') || (pStr[1] == '\0'))
			return pStr;

		TCHAR* p = pStr;

		while (p[1] != 0) 
		{
			TCHAR* pNext = CharNext(p);
			if(pNext > p + 1)
			{
				char p1 = *(char*)p;
				*(char*)p = *(char*)(p + 1);
				*(char*)(p + 1) = p1;
			}
			p = pNext;
		}

		TCHAR* q = pStr;

		while (q < p)
		{
			TCHAR t = *q;
			*q = *p;
			*p = t;
			q++;
			p--;
		}
		return (TCHAR*)pStr;
	}
	static TCHAR* _cstrstr(const TCHAR* pStr, const TCHAR* pCharSet)
	{
		int nLen = lstrlen(pCharSet);
		if (nLen == 0)
			return (TCHAR*)pStr;

		const TCHAR* pRet = NULL;
		const TCHAR* pCur = pStr;
		while((pStr = _cstrchr(pCur, *pCharSet)) != NULL)
		{
			if(memcmp(pCur, pCharSet, nLen * sizeof(TCHAR)) == 0)
			{
				pRet = pCur;
				break;
			}
			pCur = CharNext(pCur);
		}
		return (TCHAR*) pRet;
	}
	static int _cstrspn(const TCHAR* pStr, const TCHAR* pCharSet)
	{
		int nRet = 0;
		TCHAR* p = (TCHAR*)pStr;
		while (*p != 0)
		{
			TCHAR* pNext = CharNext(p);
			if(pNext > p + 1)
			{
				if(_cstrchr_db(pCharSet, *p, *(p+1)) == NULL)
					break;
				nRet += 2;
			}
			else
			{
				if(_cstrchr(pCharSet, *p) == NULL)
					break;
				nRet++;
			}
			p = pNext;
		}
		return nRet;
	}
	static int _cstrcspn(const TCHAR* pStr, const TCHAR* pCharSet)
	{
		int nRet = 0;
		TCHAR* p = (TCHAR*)pStr;
		while (*p != 0)
		{
			TCHAR* pNext = CharNext(p);
			if(pNext > p + 1)
			{
				if(_cstrchr_db(pCharSet, *p, *(p+1)) != NULL)
					break;
				nRet += 2;
			}
			else
			{
				if(_cstrchr(pCharSet, *p) != NULL)
					break;
				nRet++;
			}
			p = pNext;
		}
		return nRet;
	}
	static TCHAR* _cstrpbrk(const TCHAR* p, const TCHAR* lpszCharSet)
	{
		while (*p != 0)
		{
			if (_cstrchr(lpszCharSet, *p) != NULL)
			{
				return (TCHAR*)p;
				break;
			}
			p = CharNext(p);
		}
		return NULL;
	}

	static int _cstrisdigit(TCHAR ch)
	{
		WORD type;
		GetStringTypeEx(GetThreadLocale(), CT_CTYPE1, &ch, 1, &type);
		return (type & C1_DIGIT) == C1_DIGIT;
	}

	static int _cstrisspace(TCHAR ch)
	{
		WORD type;
		GetStringTypeEx(GetThreadLocale(), CT_CTYPE1, &ch, 1, &type);
		return (type & C1_SPACE) == C1_SPACE;
	}

	static int _cstrcmp(const TCHAR* pstrOne,
		const TCHAR* pstrOther)
	{
		return lstrcmp(pstrOne, pstrOther);
	}

	static int _cstrcmpi(const TCHAR* pstrOne,
		const TCHAR* pstrOther)
	{
		return lstrcmpi(pstrOne, pstrOther);
	}

	static int _cstrcoll(const TCHAR* pstrOne,
		const TCHAR* pstrOther)
	{
		int nRet = CompareString(GetThreadLocale(), 0, pstrOne, -1, 
			pstrOther, -1);
		ATLASSERT(nRet != 0);
		return nRet-2;  // Convert to strcmp convention.  This really is documented.
	}

	static int _cstrcolli(const TCHAR* pstrOne,
		const TCHAR* pstrOther)
	{
		int nRet = CompareString(GetThreadLocale(), NORM_IGNORECASE, pstrOne, -1, 
			pstrOther, -1);
		ATLASSERT(nRet != 0);
		return nRet-2;  // Convert to strcmp convention.  This really is documented.
	}


};

// Compare helpers
bool __stdcall operator==(const CString& s1, const CString& s2);
bool __stdcall operator==(const CString& s1, LPCTSTR s2);
bool __stdcall operator==(LPCTSTR s1, const CString& s2);
bool __stdcall operator!=(const CString& s1, const CString& s2);
bool __stdcall operator!=(const CString& s1, LPCTSTR s2);
bool __stdcall operator!=(LPCTSTR s1, const CString& s2);
bool __stdcall operator<(const CString& s1, const CString& s2);
bool __stdcall operator<(const CString& s1, LPCTSTR s2);
bool __stdcall operator<(LPCTSTR s1, const CString& s2);
bool __stdcall operator>(const CString& s1, const CString& s2);
bool __stdcall operator>(const CString& s1, LPCTSTR s2);
bool __stdcall operator>(LPCTSTR s1, const CString& s2);
bool __stdcall operator<=(const CString& s1, const CString& s2);
bool __stdcall operator<=(const CString& s1, LPCTSTR s2);
bool __stdcall operator<=(LPCTSTR s1, const CString& s2);
bool __stdcall operator>=(const CString& s1, const CString& s2);
bool __stdcall operator>=(const CString& s1, LPCTSTR s2);
bool __stdcall operator>=(LPCTSTR s1, const CString& s2);


/////////////////////////////////////////////////////////////////////////////
// CString Implementation

inline CStringData* CString::GetData() const
	{ ATLASSERT(m_pchData != NULL); return ((CStringData*)m_pchData)-1; }
inline void CString::Init()
	{ m_pchData = _GetEmptyString().m_pchData; }
inline CString::CString(const unsigned char* lpsz)
	{ Init(); *this = (LPCSTR)lpsz; }
inline const CString& CString::operator=(const unsigned char* lpsz)
	{ *this = (LPCSTR)lpsz; return *this; }
#ifdef _UNICODE
inline const CString& CString::operator+=(char ch)
	{ *this += (TCHAR)ch; return *this; }
inline const CString& CString::operator=(char ch)
	{ *this = (TCHAR)ch; return *this; }
inline CString __stdcall operator+(const CString& string, char ch)
	{ return string + (TCHAR)ch; }
inline CString __stdcall operator+(char ch, const CString& string)
	{ return (TCHAR)ch + string; }
#endif

inline int CString::GetLength() const
	{ return GetData()->nDataLength; }
inline int CString::GetAllocLength() const
	{ return GetData()->nAllocLength; }
inline BOOL CString::IsEmpty() const
	{ return GetData()->nDataLength == 0; }
inline CString::operator LPCTSTR() const
	{ return m_pchData; }
inline int PASCAL CString::SafeStrlen(LPCTSTR lpsz)
	{ return (lpsz == NULL) ? 0 : lstrlen(lpsz); }

// CString support (windows specific)
inline int CString::Compare(LPCTSTR lpsz) const
	{ return _cstrcmp(m_pchData, lpsz); }    // MBCS/Unicode aware
inline int CString::CompareNoCase(LPCTSTR lpsz) const
	{ return _cstrcmpi(m_pchData, lpsz); }   // MBCS/Unicode aware
// CString::Collate is often slower than Compare but is MBSC/Unicode
//  aware as well as locale-sensitive with respect to sort order.
inline int CString::Collate(LPCTSTR lpsz) const
	{ return _cstrcoll(m_pchData, lpsz); }   // locale sensitive

inline TCHAR CString::GetAt(int nIndex) const
{
	ATLASSERT(nIndex >= 0);
	ATLASSERT(nIndex < GetData()->nDataLength);
	return m_pchData[nIndex];
}
inline TCHAR CString::operator[](int nIndex) const
{
	// same as GetAt
	ATLASSERT(nIndex >= 0);
	ATLASSERT(nIndex < GetData()->nDataLength);
	return m_pchData[nIndex];
}
inline bool __stdcall operator==(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) == 0; }
inline bool __stdcall operator==(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) == 0; }
inline bool __stdcall operator==(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) == 0; }
inline bool __stdcall operator!=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) != 0; }
inline bool __stdcall operator!=(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) != 0; }
inline bool __stdcall operator!=(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) != 0; }
inline bool __stdcall operator<(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) < 0; }
inline bool __stdcall operator<(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) < 0; }
inline bool __stdcall operator<(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) > 0; }
inline bool __stdcall operator>(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) > 0; }
inline bool __stdcall operator>(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) > 0; }
inline bool __stdcall operator>(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) < 0; }
inline bool __stdcall operator<=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) <= 0; }
inline bool __stdcall operator<=(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) <= 0; }
inline bool __stdcall operator<=(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) >= 0; }
inline bool __stdcall operator>=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) >= 0; }
inline bool __stdcall operator>=(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) >= 0; }
inline bool __stdcall operator>=(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) <= 0; }

inline CString::CString()
{
	Init();
}

inline CString::CString(const CString& stringSrc)
{
	ATLASSERT(stringSrc.GetData()->nRefs != 0);
	if (stringSrc.GetData()->nRefs >= 0)
	{
		ATLASSERT(stringSrc.GetData() != _atltmpDataNil);
		m_pchData = stringSrc.m_pchData;
		InterlockedIncrement(&GetData()->nRefs);
	}
	else
	{
		Init();
		*this = stringSrc.m_pchData;
	}
}

inline BOOL CString::AllocBuffer(int nLen)
// always allocate one extra character for '\0' termination
// assumes [optimistically] that data length will equal allocation length
{
	ATLASSERT(nLen >= 0);
	ATLASSERT(nLen <= INT_MAX-1);    // max size (enough room for 1 extra)

	if (nLen == 0)
		Init();
	else
	{
		CStringData* pData = NULL;
		ATLTRY(pData = (CStringData*)new BYTE[sizeof(CStringData) + (nLen+1)*sizeof(TCHAR)]);
		if(pData == NULL)
			return FALSE;

		pData->nRefs = 1;
		pData->data()[nLen] = '\0';
		pData->nDataLength = nLen;
		pData->nAllocLength = nLen;
		m_pchData = pData->data();
	}

	return TRUE;
}

inline void CString::Release()
{
	if (GetData() != _atltmpDataNil)
	{
		ATLASSERT(GetData()->nRefs != 0);
		if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			delete[] (BYTE*)GetData();
		Init();
	}
}

inline void PASCAL CString::Release(CStringData* pData)
{
	if (pData != _atltmpDataNil)
	{
		ATLASSERT(pData->nRefs != 0);
		if (InterlockedDecrement(&pData->nRefs) <= 0)
			delete[] (BYTE*)pData;
	}
}

inline void CString::Empty()
{
	if (GetData()->nDataLength == 0)
		return;
	if (GetData()->nRefs >= 0)
		Release();
	else
		*this = _T("");
	ATLASSERT(GetData()->nDataLength == 0);
	ATLASSERT(GetData()->nRefs < 0 || GetData()->nAllocLength == 0);
}

inline void CString::CopyBeforeWrite()
{
	if (GetData()->nRefs > 1)
	{
		CStringData* pData = GetData();
		Release();
		if(AllocBuffer(pData->nDataLength))
			memcpy(m_pchData, pData->data(), (pData->nDataLength+1)*sizeof(TCHAR));
	}
	ATLASSERT(GetData()->nRefs <= 1);
}

inline BOOL CString::AllocBeforeWrite(int nLen)
{
	BOOL bRet = TRUE;
	if (GetData()->nRefs > 1 || nLen > GetData()->nAllocLength)
	{
		Release();
		bRet = AllocBuffer(nLen);
	}
	ATLASSERT(GetData()->nRefs <= 1);
	return bRet;
}

inline CString::~CString()
//  free any attached data
{
	if (GetData() != _atltmpDataNil)
	{
		if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			delete[] (BYTE*)GetData();
	}
}

inline void CString::AllocCopy(CString& dest, int nCopyLen, int nCopyIndex,
	 int nExtraLen) const
{
	// will clone the data attached to this string
	// allocating 'nExtraLen' characters
	// Places results in uninitialized string 'dest'
	// Will copy the part or all of original data to start of new string

	int nNewLen = nCopyLen + nExtraLen;
	if (nNewLen == 0)
	{
		dest.Init();
	}
	else
	{
		if(dest.AllocBuffer(nNewLen))
			memcpy(dest.m_pchData, m_pchData+nCopyIndex, nCopyLen*sizeof(TCHAR));
	}
}

inline CString::CString(LPCTSTR lpsz)
{
	Init();
	if (lpsz != NULL && HIWORD(lpsz) == NULL)
	{
		UINT nID = LOWORD((DWORD_PTR)lpsz);
		if (!LoadString(nID))
			ATLTRACE2(atlTraceUI, 0, _T("Warning: implicit LoadString(%u) in CString failed\n"), nID);
	}
	else
	{
		int nLen = SafeStrlen(lpsz);
		if (nLen != 0)
		{
			if(AllocBuffer(nLen))
				memcpy(m_pchData, lpsz, nLen*sizeof(TCHAR));
		}
	}
}

#ifdef _UNICODE
inline CString::CString(LPCSTR lpsz)
{
	Init();
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	if (nSrcLen != 0)
	{
		if(AllocBuffer(nSrcLen))
		{
			_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
			ReleaseBuffer();
		}
	}
}
#else //_UNICODE
inline CString::CString(LPCWSTR lpsz)
{
	Init();
	int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
	if (nSrcLen != 0)
	{
		if(AllocBuffer(nSrcLen*2))
		{
			_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
			ReleaseBuffer();
		}
	}
}
#endif //!_UNICODE

// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CString&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

inline void CString::AssignCopy(int nSrcLen, LPCTSTR lpszSrcData)
{
	if(AllocBeforeWrite(nSrcLen))
	{
		memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(TCHAR));
		GetData()->nDataLength = nSrcLen;
		m_pchData[nSrcLen] = '\0';
	}
}

inline const CString& CString::operator=(const CString& stringSrc)
{
	if (m_pchData != stringSrc.m_pchData)
	{
		if ((GetData()->nRefs < 0 && GetData() != _atltmpDataNil) ||
			stringSrc.GetData()->nRefs < 0)
		{
			// actual copy necessary since one of the strings is locked
			AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
		}
		else
		{
			// can just copy references around
			Release();
			ATLASSERT(stringSrc.GetData() != _atltmpDataNil);
			m_pchData = stringSrc.m_pchData;
			InterlockedIncrement(&GetData()->nRefs);
		}
	}
	return *this;
}

inline const CString& CString::operator=(LPCTSTR lpsz)
{
	ATLASSERT(lpsz == NULL || _IsValidString(lpsz, FALSE));
	AssignCopy(SafeStrlen(lpsz), lpsz);
	return *this;
}

#ifdef _UNICODE
inline const CString& CString::operator=(LPCSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	if(AllocBeforeWrite(nSrcLen))
	{
		_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
		ReleaseBuffer();
	}
	return *this;
}
#else //!_UNICODE
inline const CString& CString::operator=(LPCWSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
	if(AllocBeforeWrite(nSrcLen*2))
	{
		_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
		ReleaseBuffer();
	}
	return *this;
}
#endif  //!_UNICODE

// Concatenation
// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          CString + CString
// and for ? = TCHAR, LPCTSTR
//          CString + ?
//          ? + CString

inline void CString::ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data,
	int nSrc2Len, LPCTSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new CString object

	int nNewLen = nSrc1Len + nSrc2Len;
	if (nNewLen != 0)
	{
		if(AllocBuffer(nNewLen))
		{
			memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(TCHAR));
			memcpy(m_pchData+nSrc1Len, lpszSrc2Data, nSrc2Len*sizeof(TCHAR));
		}
	}
}

inline CString __stdcall operator+(const CString& string1, const CString& string2)
{
	CString s;
	s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData,
		string2.GetData()->nDataLength, string2.m_pchData);
	return s;
}

inline CString __stdcall operator+(const CString& string, LPCTSTR lpsz)
{
	ATLASSERT(lpsz == NULL || CString::_IsValidString(lpsz, FALSE));
	CString s;
	s.ConcatCopy(string.GetData()->nDataLength, string.m_pchData,
		CString::SafeStrlen(lpsz), lpsz);
	return s;
}

inline CString __stdcall operator+(LPCTSTR lpsz, const CString& string)
{
	ATLASSERT(lpsz == NULL || CString::_IsValidString(lpsz, FALSE));
	CString s;
	s.ConcatCopy(CString::SafeStrlen(lpsz), lpsz, string.GetData()->nDataLength,
		string.m_pchData);
	return s;
}

inline void CString::ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData)
{
	//  -- the main routine for += operators

	// concatenating an empty string is a no-op!
	if (nSrcLen == 0)
		return;

	// if the buffer is too small, or we have a width mis-match, just
	//   allocate a new buffer (slow but sure)
	if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen > GetData()->nAllocLength)
	{
		// we have to grow the buffer, use the ConcatCopy routine
		CStringData* pOldData = GetData();
		ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData);
		ATLASSERT(pOldData != NULL);
		CString::Release(pOldData);
	}
	else
	{
		// fast concatenation when buffer big enough
		memcpy(m_pchData+GetData()->nDataLength, lpszSrcData, nSrcLen*sizeof(TCHAR));
		GetData()->nDataLength += nSrcLen;
		ATLASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
		m_pchData[GetData()->nDataLength] = '\0';
	}
}

inline const CString& CString::operator+=(LPCTSTR lpsz)
{
	ATLASSERT(lpsz == NULL || _IsValidString(lpsz, FALSE));
	ConcatInPlace(SafeStrlen(lpsz), lpsz);
	return *this;
}

inline const CString& CString::operator+=(TCHAR ch)
{
	ConcatInPlace(1, &ch);
	return *this;
}

inline const CString& CString::operator+=(const CString& string)
{
	ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);
	return *this;
}

inline LPTSTR CString::GetBuffer(int nMinBufLength)
{
	ATLASSERT(nMinBufLength >= 0);

	if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
	{
		// we have to grow the buffer
		CStringData* pOldData = GetData();
		int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
		if (nMinBufLength < nOldLen)
			nMinBufLength = nOldLen;
		if(AllocBuffer(nMinBufLength))
		{
			memcpy(m_pchData, pOldData->data(), (nOldLen+1)*sizeof(TCHAR));
			GetData()->nDataLength = nOldLen;
			CString::Release(pOldData);
		}
	}
	ATLASSERT(GetData()->nRefs <= 1);

	// return a pointer to the character storage for this string
	ATLASSERT(m_pchData != NULL);
	return m_pchData;
}

inline void CString::ReleaseBuffer(int nNewLength)
{
	CopyBeforeWrite();  // just in case GetBuffer was not called

	if (nNewLength == -1)
		nNewLength = lstrlen(m_pchData); // zero terminated

	ATLASSERT(nNewLength <= GetData()->nAllocLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
}

inline LPTSTR CString::GetBufferSetLength(int nNewLength)
{
	ATLASSERT(nNewLength >= 0);

	GetBuffer(nNewLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
	return m_pchData;
}

inline void CString::FreeExtra()
{
	ATLASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
	if (GetData()->nDataLength != GetData()->nAllocLength)
	{
		CStringData* pOldData = GetData();
		if(AllocBuffer(GetData()->nDataLength))
		{
			memcpy(m_pchData, pOldData->data(), pOldData->nDataLength*sizeof(TCHAR));
			ATLASSERT(m_pchData[GetData()->nDataLength] == '\0');
			CString::Release(pOldData);
		}
	}
	ATLASSERT(GetData() != NULL);
}

inline LPTSTR CString::LockBuffer()
{
	LPTSTR lpsz = GetBuffer(0);
	GetData()->nRefs = -1;
	return lpsz;
}

inline void CString::UnlockBuffer()
{
	ATLASSERT(GetData()->nRefs == -1);
	if (GetData() != _atltmpDataNil)
		GetData()->nRefs = 1;
}

inline int CString::Find(TCHAR ch) const
{
	// find first single character
	LPTSTR lpsz = _cstrchr(m_pchData, (_TUCHAR)ch);

	// return -1 if not found and index otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

inline int CString::FindOneOf(LPCTSTR lpszCharSet) const
{
	ATLASSERT(_IsValidString(lpszCharSet, FALSE));
	LPTSTR lpsz = _cstrpbrk(m_pchData, lpszCharSet);
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

inline void CString::MakeUpper()
{
	CopyBeforeWrite();
	CharUpper(m_pchData);
}

inline void CString::MakeLower()
{
	CopyBeforeWrite();
	CharLower(m_pchData);
}

inline void CString::MakeReverse()
{
	CopyBeforeWrite();
	_cstrrev(m_pchData);
}

inline void CString::SetAt(int nIndex, TCHAR ch)
{
	ATLASSERT(nIndex >= 0);
	ATLASSERT(nIndex < GetData()->nDataLength);

	CopyBeforeWrite();
	m_pchData[nIndex] = ch;
}

#ifndef _UNICODE
inline void CString::AnsiToOem()
{
	CopyBeforeWrite();
	::AnsiToOem(m_pchData, m_pchData);
}
inline void CString::OemToAnsi()
{
	CopyBeforeWrite();
	::OemToAnsi(m_pchData, m_pchData);
}
#endif

inline CString::CString(TCHAR ch, int nLength)
{
	ATLASSERT(!_istlead(ch));    // can't create a lead byte string
	Init();
	if (nLength >= 1)
	{
		if(AllocBuffer(nLength))
		{
#ifdef _UNICODE
			for (int i = 0; i < nLength; i++)
				m_pchData[i] = ch;
#else
			memset(m_pchData, ch, nLength);
#endif
		}
	}
}

inline CString::CString(LPCTSTR lpch, int nLength)
{
	Init();
	if (nLength != 0)
	{
		if(AllocBuffer(nLength))
			memcpy(m_pchData, lpch, nLength*sizeof(TCHAR));
	}
}

inline const CString& CString::operator=(TCHAR ch)
{
	ATLASSERT(!_istlead(ch));    // can't set single lead byte
	AssignCopy(1, &ch);
	return *this;
}

inline CString __stdcall operator+(const CString& string1, TCHAR ch)
{
	CString s;
	s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData, 1, &ch);
	return s;
}

inline CString __stdcall operator+(TCHAR ch, const CString& string)
{
	CString s;
	s.ConcatCopy(1, &ch, string.GetData()->nDataLength, string.m_pchData);
	return s;
}

inline CString CString::Mid(int nFirst) const
{
	return Mid(nFirst, GetData()->nDataLength - nFirst);
}

inline CString CString::Mid(int nFirst, int nCount) const
{
	// out-of-bounds requests return sensible things
	if (nFirst < 0)
		nFirst = 0;
	if (nCount < 0)
		nCount = 0;

	if (nFirst + nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength - nFirst;
	if (nFirst > GetData()->nDataLength)
		nCount = 0;

	CString dest;
	AllocCopy(dest, nCount, nFirst, 0);
	return dest;
}

inline CString CString::Right(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	else if (nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength;

	CString dest;
	AllocCopy(dest, nCount, GetData()->nDataLength-nCount, 0);
	return dest;
}

inline CString CString::Left(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	else if (nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength;

	CString dest;
	AllocCopy(dest, nCount, 0, 0);
	return dest;
}

// strspn equivalent
inline CString CString::SpanIncluding(LPCTSTR lpszCharSet) const
{
	ATLASSERT(_IsValidString(lpszCharSet, FALSE));
	return Left(_cstrspn(m_pchData, lpszCharSet));
}

// strcspn equivalent
inline CString CString::SpanExcluding(LPCTSTR lpszCharSet) const
{
	ATLASSERT(_IsValidString(lpszCharSet, FALSE));
	return Left(_cstrcspn(m_pchData, lpszCharSet));
}

inline int CString::ReverseFind(TCHAR ch) const
{
	// find last single character
	LPTSTR lpsz = _cstrrchr(m_pchData, (_TUCHAR)ch);

	// return -1 if not found, distance from beginning otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

// find a sub-string (like strstr)
inline int CString::Find(LPCTSTR lpszSub) const
{
	ATLASSERT(_IsValidString(lpszSub, FALSE));

	// find first matching substring
	LPTSTR lpsz = _cstrstr(m_pchData, lpszSub);

	// return -1 for not found, distance from beginning otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

inline void CString::FormatV(LPCTSTR lpszFormat, va_list argList)
{
	ATLASSERT(_IsValidString(lpszFormat, FALSE));

	va_list argListSave = argList;

	// make a guess at the maximum length of the resulting string
	int nMaxLen = 0;
	for (LPCTSTR lpsz = lpszFormat; *lpsz != '\0'; lpsz = CharNext(lpsz))
	{
		// handle '%' character, but watch out for '%%'
		if (*lpsz != '%' || *(lpsz = CharNext(lpsz)) == '%')
		{
			nMaxLen += (int)_tclen(lpsz);
			continue;
		}

		int nItemLen = 0;

		// handle '%' character with format
		int nWidth = 0;
		for (; *lpsz != '\0'; lpsz = CharNext(lpsz))
		{
			// check for valid flags
			if (*lpsz == '#')
				nMaxLen += 2;   // for '0x'
			else if (*lpsz == '*')
				nWidth = va_arg(argList, int);
			else if (*lpsz == '-' || *lpsz == '+' || *lpsz == '0' ||
				*lpsz == ' ')
				;
			else // hit non-flag character
				break;
		}
		// get width and skip it
		if (nWidth == 0)
		{
			// width indicated by
			nWidth = _ttoi(lpsz);
			for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = CharNext(lpsz))
				;
		}
		ATLASSERT(nWidth >= 0);

		int nPrecision = 0;
		if (*lpsz == '.')
		{
			// skip past '.' separator (width.precision)
			lpsz = CharNext(lpsz);

			// get precision and skip it
			if (*lpsz == '*')
			{
				nPrecision = va_arg(argList, int);
				lpsz = CharNext(lpsz);
			}
			else
			{
				nPrecision = _ttoi(lpsz);
				for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = CharNext(lpsz))
					;
			}
			ATLASSERT(nPrecision >= 0);
		}

		// should be on type modifier or specifier
		int nModifier = 0;
		switch (*lpsz)
		{
		// modifiers that affect size
		case 'h':
			nModifier = _atltmpFORCE_ANSI;
			lpsz = CharNext(lpsz);
			break;
		case 'l':
			nModifier = _atltmpFORCE_UNICODE;
			lpsz = CharNext(lpsz);
			break;

		// modifiers that do not affect size
		case 'F':
		case 'N':
		case 'L':
			lpsz = CharNext(lpsz);
			break;
		}

		// now should be on specifier
		switch (*lpsz | nModifier)
		{
		// single characters
		case 'c':
		case 'C':
			nItemLen = 2;
			va_arg(argList, TCHAR_ARG);
			break;
		case 'c'|_atltmpFORCE_ANSI:
		case 'C'|_atltmpFORCE_ANSI:
			nItemLen = 2;
			va_arg(argList, CHAR_ARG);
			break;
		case 'c'|_atltmpFORCE_UNICODE:
		case 'C'|_atltmpFORCE_UNICODE:
			nItemLen = 2;
			va_arg(argList, WCHAR_ARG);
			break;

		// strings
		case 's':
		{
			LPCTSTR pstrNextArg = va_arg(argList, LPCTSTR);
			if (pstrNextArg == NULL)
			   nItemLen = 6;  // "(null)"
			else
			{
			   nItemLen = lstrlen(pstrNextArg);
			   nItemLen = max(1, nItemLen);
			}
			break;
		}

		case 'S':
		{
#ifndef _UNICODE
			LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
			if (pstrNextArg == NULL)
			   nItemLen = 6;  // "(null)"
			else
			{
			   nItemLen = (int)wcslen(pstrNextArg);
			   nItemLen = max(1, nItemLen);
			}
#else
			LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
			if (pstrNextArg == NULL)
			   nItemLen = 6; // "(null)"
			else
			{
			   nItemLen = lstrlenA(pstrNextArg);
			   nItemLen = max(1, nItemLen);
			}
#endif
			break;
		}

		case 's'|_atltmpFORCE_ANSI:
		case 'S'|_atltmpFORCE_ANSI:
		{
			LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
			if (pstrNextArg == NULL)
			   nItemLen = 6; // "(null)"
			else
			{
			   nItemLen = lstrlenA(pstrNextArg);
			   nItemLen = max(1, nItemLen);
			}
			break;
		}

		case 's'|_atltmpFORCE_UNICODE:
		case 'S'|_atltmpFORCE_UNICODE:
		{
			LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
			if (pstrNextArg == NULL)
			   nItemLen = 6; // "(null)"
			else
			{
			   nItemLen = (int)wcslen(pstrNextArg);
			   nItemLen = max(1, nItemLen);
			}
			break;
		}
		}

		// adjust nItemLen for strings
		if (nItemLen != 0)
		{
			nItemLen = max(nItemLen, nWidth);
			if (nPrecision != 0)
				nItemLen = min(nItemLen, nPrecision);
		}
		else
		{
			switch (*lpsz)
			{
			// integers
			case 'd':
			case 'i':
			case 'u':
			case 'x':
			case 'X':
			case 'o':
				va_arg(argList, int);
				nItemLen = 32;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			case 'e':
			case 'f':
			case 'g':
			case 'G':
				ATLASSERT(!"Floating point (%%e, %%f, %%g, and %%G) is not supported by the WTL::CString class.");
#ifndef _DEBUG
				::OutputDebugString(_T("Floating point (%%e, %%f, %%g, and %%G) is not supported by the WTL::CString class."));
				::DebugBreak();
#endif //!_DEBUG
				break;

			case 'p':
				va_arg(argList, void*);
				nItemLen = 32;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			// no output
			case 'n':
				va_arg(argList, int*);
				break;

			default:
				ATLASSERT(FALSE);  // unknown formatting option
			}
		}

		// adjust nMaxLen for output nItemLen
		nMaxLen += nItemLen;
	}

	GetBuffer(nMaxLen);
	int nRet = wvsprintf(m_pchData, lpszFormat, argListSave);
	nRet;	// ref
	ATLASSERT(nRet <= GetAllocLength());
	ReleaseBuffer();

	va_end(argListSave);
}

// formatting (using wsprintf style formatting)
inline void __cdecl CString::Format(LPCTSTR lpszFormat, ...)
{
	ATLASSERT(_IsValidString(lpszFormat, FALSE));

	va_list argList;
	va_start(argList, lpszFormat);
	FormatV(lpszFormat, argList);
	va_end(argList);
}

inline void __cdecl CString::Format(UINT nFormatID, ...)
{
	CString strFormat;
	BOOL bRet = strFormat.LoadString(nFormatID);
	bRet;	// ref
	ATLASSERT(bRet != 0);

	va_list argList;
	va_start(argList, nFormatID);
	FormatV(strFormat, argList);
	va_end(argList);
}

// formatting (using FormatMessage style formatting)
inline BOOL __cdecl CString::FormatMessage(LPCTSTR lpszFormat, ...)
{
	// format message into temporary buffer lpszTemp
	va_list argList;
	va_start(argList, lpszFormat);
	LPTSTR lpszTemp;
	BOOL bRet = TRUE;

	if (::FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER,
		lpszFormat, 0, 0, (LPTSTR)&lpszTemp, 0, &argList) == 0 ||
		lpszTemp == NULL)
		bRet = FALSE;

	// assign lpszTemp into the resulting string and free the temporary
	*this = lpszTemp;
	LocalFree(lpszTemp);
	va_end(argList);
	return bRet;
}

inline BOOL __cdecl CString::FormatMessage(UINT nFormatID, ...)
{
	// get format string from string table
	CString strFormat;
	BOOL bRetTmp = strFormat.LoadString(nFormatID);
	bRetTmp;	// ref
	ATLASSERT(bRetTmp != 0);

	// format message into temporary buffer lpszTemp
	va_list argList;
	va_start(argList, nFormatID);
	LPTSTR lpszTemp;
	BOOL bRet = TRUE;

	if (::FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER,
		strFormat, 0, 0, (LPTSTR)&lpszTemp, 0, &argList) == 0 ||
		lpszTemp == NULL)
		bRet = FALSE;

	// assign lpszTemp into the resulting string and free lpszTemp
	*this = lpszTemp;
	LocalFree(lpszTemp);
	va_end(argList);
	return bRet;
}

inline void CString::TrimRight()
{
	CopyBeforeWrite();

	// find beginning of trailing spaces by starting at beginning (DBCS aware)
	LPTSTR lpsz = m_pchData;
	LPTSTR lpszLast = NULL;
	while (*lpsz != '\0')
	{
		if (_istspace(*lpsz))
		{
			if (lpszLast == NULL)
				lpszLast = lpsz;
		}
		else
			lpszLast = NULL;
		lpsz = CharNext(lpsz);
	}

	if (lpszLast != NULL)
	{
		// truncate at trailing space start
		*lpszLast = '\0';
		GetData()->nDataLength = (int)((DWORD_PTR)lpszLast - (DWORD_PTR)m_pchData);
	}
}

inline void CString::TrimLeft()
{
	CopyBeforeWrite();

	// find first non-space character
	LPCTSTR lpsz = m_pchData;
	while (_istspace(*lpsz))
		lpsz = CharNext(lpsz);

	// fix up data and length
	int nDataLength = GetData()->nDataLength - (int)((DWORD_PTR)lpsz - (DWORD_PTR)m_pchData);
	memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(TCHAR));
	GetData()->nDataLength = nDataLength;
}

inline int CString::Delete(int nIndex, int nCount /* = 1 */)
{
	if (nIndex < 0)
		nIndex = 0;
	int nNewLength = GetData()->nDataLength;
	if (nCount > 0 && nIndex < nNewLength)
	{
		CopyBeforeWrite();
		int nBytesToCopy = nNewLength - (nIndex + nCount) + 1;

		memcpy(m_pchData + nIndex,
			m_pchData + nIndex + nCount, nBytesToCopy * sizeof(TCHAR));
		GetData()->nDataLength = nNewLength - nCount;
	}

	return nNewLength;
}

inline int CString::Insert(int nIndex, TCHAR ch)
{
	CopyBeforeWrite();

	if (nIndex < 0)
		nIndex = 0;

	int nNewLength = GetData()->nDataLength;
	if (nIndex > nNewLength)
		nIndex = nNewLength;
	nNewLength++;

	if (GetData()->nAllocLength < nNewLength)
	{
		CStringData* pOldData = GetData();
		LPTSTR pstr = m_pchData;
		if(!AllocBuffer(nNewLength))
			return -1;
		memcpy(m_pchData, pstr, (pOldData->nDataLength+1)*sizeof(TCHAR));
		CString::Release(pOldData);
	}

	// move existing bytes down
	memcpy(m_pchData + nIndex + 1, m_pchData + nIndex, (nNewLength-nIndex)*sizeof(TCHAR));
	m_pchData[nIndex] = ch;
	GetData()->nDataLength = nNewLength;

	return nNewLength;
}

inline int CString::Insert(int nIndex, LPCTSTR pstr)
{
	if (nIndex < 0)
		nIndex = 0;

	int nInsertLength = SafeStrlen(pstr);
	int nNewLength = GetData()->nDataLength;
	if (nInsertLength > 0)
	{
		CopyBeforeWrite();
		if (nIndex > nNewLength)
			nIndex = nNewLength;
		nNewLength += nInsertLength;

		if (GetData()->nAllocLength < nNewLength)
		{
			CStringData* pOldData = GetData();
			LPTSTR pstr = m_pchData;
			if(!AllocBuffer(nNewLength))
				return -1;
			memcpy(m_pchData, pstr, (pOldData->nDataLength+1)*sizeof(TCHAR));
			CString::Release(pOldData);
		}

		// move existing bytes down
		memcpy(m_pchData + nIndex + nInsertLength, m_pchData + nIndex, (nNewLength-nIndex-nInsertLength+1)*sizeof(TCHAR));
		memcpy(m_pchData + nIndex, pstr, nInsertLength*sizeof(TCHAR));
		GetData()->nDataLength = nNewLength;
	}

	return nNewLength;
}

inline int CString::Replace(TCHAR chOld, TCHAR chNew)
{
	int nCount = 0;

	// short-circuit the nop case
	if (chOld != chNew)
	{
		// otherwise modify each character that matches in the string
		CopyBeforeWrite();
		LPTSTR psz = m_pchData;
		LPTSTR pszEnd = psz + GetData()->nDataLength;
		while (psz < pszEnd)
		{
			// replace instances of the specified character only
			if (*psz == chOld)
			{
				*psz = chNew;
				nCount++;
			}
			psz = ::CharNext(psz);
		}
	}
	return nCount;
}

inline int CString::Replace(LPCTSTR lpszOld, LPCTSTR lpszNew)
{
	// can't have empty or NULL lpszOld

	int nSourceLen = SafeStrlen(lpszOld);
	if (nSourceLen == 0)
		return 0;
	int nReplacementLen = SafeStrlen(lpszNew);

	// loop once to figure out the size of the result string
	int nCount = 0;
	LPTSTR lpszStart = m_pchData;
	LPTSTR lpszEnd = m_pchData + GetData()->nDataLength;
	LPTSTR lpszTarget;
	while (lpszStart < lpszEnd)
	{
		while ((lpszTarget = _cstrstr(lpszStart, lpszOld)) != NULL)
		{
			nCount++;
			lpszStart = lpszTarget + nSourceLen;
		}
		lpszStart += lstrlen(lpszStart) + 1;
	}

	// if any changes were made, make them
	if (nCount > 0)
	{
		CopyBeforeWrite();

		// if the buffer is too small, just
		//   allocate a new buffer (slow but sure)
		int nOldLength = GetData()->nDataLength;
		int nNewLength =  nOldLength + (nReplacementLen-nSourceLen)*nCount;
		if (GetData()->nAllocLength < nNewLength || GetData()->nRefs > 1)
		{
			CStringData* pOldData = GetData();
			LPTSTR pstr = m_pchData;
			if(!AllocBuffer(nNewLength))
				return -1;
			memcpy(m_pchData, pstr, pOldData->nDataLength*sizeof(TCHAR));
			CString::Release(pOldData);
		}
		// else, we just do it in-place
		lpszStart = m_pchData;
		lpszEnd = m_pchData + GetData()->nDataLength;

		// loop again to actually do the work
		while (lpszStart < lpszEnd)
		{
			while ( (lpszTarget = _cstrstr(lpszStart, lpszOld)) != NULL)
			{
				int nBalance = nOldLength - ((int)((DWORD_PTR)lpszTarget - (DWORD_PTR)m_pchData) + nSourceLen);
				memmove(lpszTarget + nReplacementLen, lpszTarget + nSourceLen, nBalance * sizeof(TCHAR));
				memcpy(lpszTarget, lpszNew, nReplacementLen*sizeof(TCHAR));
				lpszStart = lpszTarget + nReplacementLen;
				lpszStart[nBalance] = '\0';
				nOldLength += (nReplacementLen - nSourceLen);
			}
			lpszStart += lstrlen(lpszStart) + 1;
		}
		ATLASSERT(m_pchData[nNewLength] == '\0');
		GetData()->nDataLength = nNewLength;
	}

	return nCount;
}

inline int CString::Remove(TCHAR chRemove)
{
	CopyBeforeWrite();

	LPTSTR pstrSource = m_pchData;
	LPTSTR pstrDest = m_pchData;
	LPTSTR pstrEnd = m_pchData + GetData()->nDataLength;

	while (pstrSource < pstrEnd)
	{
		if (*pstrSource != chRemove)
		{
			*pstrDest = *pstrSource;
			pstrDest = ::CharNext(pstrDest);
		}
		pstrSource = ::CharNext(pstrSource);
	}
	*pstrDest = '\0';
	int nCount = (int)((DWORD_PTR)pstrSource - (DWORD_PTR)pstrDest);
	GetData()->nDataLength -= nCount;

	return nCount;
}

#ifdef _UNICODE
#define CHAR_FUDGE 1    // one TCHAR unused is good enough
#else
#define CHAR_FUDGE 2    // two BYTES unused for case of DBC last char
#endif

inline BOOL CString::LoadString(UINT nID)
{
	// try fixed buffer first (to avoid wasting space in the heap)
	TCHAR szTemp[256];
	int nCount =  sizeof(szTemp) / sizeof(szTemp[0]);
	int nLen = _LoadString(nID, szTemp, nCount);
	if (nCount - nLen > CHAR_FUDGE)
	{
		*this = szTemp;
		return nLen > 0;
	}

	// try buffer size of 512, then larger size until entire string is retrieved
	int nSize = 256;
	do
	{
		nSize += 256;
		nLen = _LoadString(nID, GetBuffer(nSize-1), nSize);
	} while (nSize - nLen <= CHAR_FUDGE);
	ReleaseBuffer();

	return nLen > 0;
}

#ifndef _ATL_NO_COM
inline BSTR CString::AllocSysString() const
{
#if defined(_UNICODE) || defined(OLE2ANSI)
	BSTR bstr = ::SysAllocStringLen(m_pchData, GetData()->nDataLength);
#else
	int nLen = MultiByteToWideChar(CP_ACP, 0, m_pchData,
		GetData()->nDataLength, NULL, NULL);
	BSTR bstr = ::SysAllocStringLen(NULL, nLen);
	if(bstr != NULL)
		MultiByteToWideChar(CP_ACP, 0, m_pchData, GetData()->nDataLength, bstr, nLen);
#endif
	return bstr;
}

inline BSTR CString::SetSysString(BSTR* pbstr) const
{
#if defined(_UNICODE) || defined(OLE2ANSI)
	::SysReAllocStringLen(pbstr, m_pchData, GetData()->nDataLength);
#else
	int nLen = MultiByteToWideChar(CP_ACP, 0, m_pchData,
		GetData()->nDataLength, NULL, NULL);
	if(::SysReAllocStringLen(pbstr, NULL, nLen))
		MultiByteToWideChar(CP_ACP, 0, m_pchData, GetData()->nDataLength, *pbstr, nLen);
#endif
	ATLASSERT(*pbstr != NULL);
	return *pbstr;
}
#endif //!_ATL_NO_COM

#endif //!_WTL_NO_CSTRING


/////////////////////////////////////////////////////////////////////////////
// CRecentDocumentList - MRU List Support

class CRecentDocumentList
{
public:
	struct _DocEntry
	{
		TCHAR szDocName[MAX_PATH];
		bool operator==(const _DocEntry& de) const
		{ return (lstrcmpi(szDocName, de.szDocName) == 0); }
	};

	CSimpleArray<_DocEntry> m_arrDocs;
	int m_nMaxEntries;	// default is 4
	HMENU m_hMenu;

	TCHAR m_szNoEntries[MAX_PATH];

// Constructor
	CRecentDocumentList() : m_hMenu(NULL), m_nMaxEntries(4)
	{ }

// Attributes
	HMENU GetMenuHandle()
	{
		return m_hMenu;
	}
	void SetMenuHandle(HMENU hMenu)
	{
		ATLASSERT(hMenu == NULL || ::IsMenu(hMenu));
		m_hMenu = hMenu;
		if(m_hMenu == NULL || (::GetMenuString(m_hMenu, ID_FILE_MRU_FIRST, m_szNoEntries, MAX_PATH, MF_BYCOMMAND) == 0))
			lstrcpy(m_szNoEntries, _T("(empty)"));
	}
	int GetMaxEntries()
	{
		return m_nMaxEntries;
	}
	void SetMaxEntries(int nMaxEntries)
	{
		ATLASSERT(nMaxEntries > 0 && nMaxEntries < (ID_FILE_MRU_LAST - ID_FILE_MRU_FIRST + 1));
		m_nMaxEntries = nMaxEntries;
	}

// Operations
	BOOL AddToList(LPCTSTR lpstrDocName)
	{
		_DocEntry de;
		if(lstrcpy(de.szDocName, lpstrDocName) == NULL)
			return FALSE;

		for(int i = 0; i < m_arrDocs.GetSize(); i++)
		{
			if(lstrcmpi(m_arrDocs[i].szDocName, lpstrDocName) == 0)
			{
				m_arrDocs.RemoveAt(i);
				break;
			}
		}

		if(m_arrDocs.GetSize() == m_nMaxEntries)
			m_arrDocs.RemoveAt(0);

		BOOL bRet = m_arrDocs.Add(de);
		if(bRet)
			bRet = UpdateMenu();
		return bRet;
	}
	BOOL GetFromList(int nItemID, LPTSTR lpstrDocName)
	{
		int nIndex = m_arrDocs.GetSize() - (nItemID - ID_FILE_MRU_FIRST) - 1;
		if(nIndex < 0 || nIndex >= m_arrDocs.GetSize())
			return FALSE;
		return (lstrcpy(lpstrDocName, m_arrDocs[nIndex].szDocName) != NULL);
	}
	BOOL RemoveFromList(int nItemID)
	{
		int nIndex = m_arrDocs.GetSize() - (nItemID - ID_FILE_MRU_FIRST) - 1;
		BOOL bRet = m_arrDocs.RemoveAt(nIndex);
		if(bRet)
			bRet = UpdateMenu();
		return bRet;
	}
	BOOL MoveToTop(int nItemID)
	{
		int nIndex = m_arrDocs.GetSize() - 1 - (nItemID - ID_FILE_MRU_FIRST);
		if(nIndex < 0 || nIndex >= m_arrDocs.GetSize())
			return FALSE;
		_DocEntry de;
		de = m_arrDocs[nIndex];
		m_arrDocs.RemoveAt(nIndex);
		BOOL bRet = m_arrDocs.Add(de);
		if(bRet)
			bRet = UpdateMenu();
		return bRet;
	}

	BOOL ReadFromRegistry(LPCTSTR lpstrRegKey)
	{
		CRegKey rkParent;
		CRegKey rk;

		LONG lRet = rkParent.Open(HKEY_CURRENT_USER, lpstrRegKey);
		if(lRet != ERROR_SUCCESS)
			return FALSE;
		lRet = rk.Open(rkParent, _T("Recent Document List"));
		if(lRet != ERROR_SUCCESS)
			return FALSE;

		DWORD dwRet;
		lRet = rk.QueryValue(dwRet, _T("DocumentCount"));
		if(lRet == ERROR_SUCCESS || dwRet > 0 && dwRet < (ID_FILE_MRU_LAST - ID_FILE_MRU_FIRST + 1))
			m_nMaxEntries = dwRet;

		m_arrDocs.RemoveAll();

		TCHAR szRetString[MAX_PATH];
		_DocEntry de;

		for(int nItem = m_nMaxEntries; nItem > 0; nItem--)
		{
			TCHAR szBuff[11];
			wsprintf(szBuff, _T("Document%i"), nItem);
			DWORD dwCount = MAX_PATH * sizeof(TCHAR);
			lRet = rk.QueryValue(szRetString, szBuff, &dwCount);
			if(lRet == ERROR_SUCCESS && (lstrcpy(de.szDocName, szRetString) != NULL))
				m_arrDocs.Add(de);
		}

		rk.Close();
		rkParent.Close();

		return UpdateMenu();
	}
	BOOL WriteToRegistry(LPCTSTR lpstrRegKey)
	{
		CRegKey rkParent;
		CRegKey rk;

		LONG lRet = rkParent.Create(HKEY_CURRENT_USER, lpstrRegKey);
		if(lRet != ERROR_SUCCESS)
			return FALSE;
		lRet = rk.Create(rkParent, _T("Recent Document List"));
		if(lRet != ERROR_SUCCESS)
			return FALSE;

		lRet = rk.SetValue(m_nMaxEntries, _T("DocumentCount"));
		ATLASSERT(lRet == ERROR_SUCCESS);

		// set new values
		int nItem;
		for(nItem = m_arrDocs.GetSize(); nItem > 0; nItem--)
		{
			TCHAR szBuff[11];
			wsprintf(szBuff, _T("Document%i"), nItem);
			TCHAR szDocName[MAX_PATH];
			GetFromList(ID_FILE_MRU_FIRST + nItem - 1, szDocName);
			lRet = rk.SetValue(szDocName, szBuff);
			ATLASSERT(lRet == ERROR_SUCCESS);
		}

		// delete unused keys
		for(nItem = m_arrDocs.GetSize() + 1; nItem < (ID_FILE_MRU_LAST - ID_FILE_MRU_FIRST + 1); nItem++)
		{
			TCHAR szBuff[11];
			wsprintf(szBuff, _T("Document%i"), nItem);
			rk.DeleteValue(szBuff);
		}

		rk.Close();
		rkParent.Close();

		return TRUE;
	}

// Implementation
	BOOL UpdateMenu()
	{
		if(m_hMenu == NULL)
			return FALSE;
		ATLASSERT(::IsMenu(m_hMenu));

		int nItems = ::GetMenuItemCount(m_hMenu);
		int nInsertPoint;
		for(nInsertPoint=0; nInsertPoint<nItems; nInsertPoint++)
		{
			MENUITEMINFO mi;
			mi.cbSize = sizeof(MENUITEMINFO);
			mi.fMask = MIIM_ID;
			::GetMenuItemInfo(m_hMenu, nInsertPoint, TRUE, &mi);
			if (mi.wID == ID_FILE_MRU_FIRST)
				break;
		}
		ATLASSERT(nInsertPoint < nItems && "You need a menu item with an ID = ID_FILE_MRU_FIRST");

		int nItem;
		for(nItem = ID_FILE_MRU_FIRST; nItem < ID_FILE_MRU_FIRST + m_nMaxEntries; nItem++)
		{
			// keep the first one as an insertion point
			if (nItem != ID_FILE_MRU_FIRST)
				::DeleteMenu(m_hMenu, nItem, MF_BYCOMMAND);
		}

		TCHAR szItemText[MAX_PATH + 6];		// add space for &, 2 digits, and a space
		int nSize = m_arrDocs.GetSize();
		nItem = 0;
		if(nSize > 0)
		{
			for(nItem = 0; nItem < nSize; nItem++)
			{
				wsprintf(szItemText, _T("&%i %s"), nItem + 1, m_arrDocs[nSize - 1 - nItem].szDocName);
				::InsertMenu(m_hMenu, nInsertPoint + nItem, MF_BYPOSITION | MF_STRING, ID_FILE_MRU_FIRST + nItem, szItemText);
			}
		}
		else	// empty
		{
			::InsertMenu(m_hMenu, nInsertPoint, MF_BYPOSITION | MF_STRING, ID_FILE_MRU_FIRST, m_szNoEntries);
			::EnableMenuItem(m_hMenu, ID_FILE_MRU_FIRST, MF_GRAYED);
		}
		::DeleteMenu(m_hMenu, nInsertPoint + nItem, MF_BYPOSITION);

		return TRUE;
	}
};


/////////////////////////////////////////////////////////////////////////////
// CFindFile - file search helper class

class CFindFile
{
public:
// Data members
	WIN32_FIND_DATA m_fd;
	TCHAR m_lpszRoot[MAX_PATH];
	TCHAR m_chDirSeparator;
	HANDLE m_hFind;
	BOOL m_bFound;

// Constructor/destructor
	CFindFile() : m_hFind(NULL), m_chDirSeparator('\\'), m_bFound(FALSE)
	{ }

	~CFindFile()
	{
		Close();
	}

// Attributes
	ULONGLONG GetFileSize() const
	{
		ATLASSERT(m_hFind != NULL);

		ULARGE_INTEGER nFileSize;

		if(m_bFound)
		{
			nFileSize.LowPart = m_fd.nFileSizeLow;
			nFileSize.HighPart = m_fd.nFileSizeHigh;
		}
		else
		{
			nFileSize.QuadPart = 0;
		}

		return nFileSize.QuadPart;
	}
	BOOL GetFileName(LPTSTR lpstrFileName, int cchLength) const
	{
		ATLASSERT(m_hFind != NULL);
		if(lstrlen(m_fd.cFileName) >= cchLength)
			return FALSE;
		return (m_bFound && (lstrcpy(lpstrFileName, m_fd.cFileName) != NULL));
	}
	BOOL GetFilePath(LPTSTR lpstrFilePath, int cchLength) const
	{
		ATLASSERT(m_hFind != NULL);

		int nLen = lstrlen(m_lpszRoot);
		ATLASSERT(nLen > 0);
		if(nLen == 0)
			return FALSE;
		bool bAddSep = (m_lpszRoot[nLen - 1] != '\\' && m_lpszRoot[nLen - 1] != '/');

		if((lstrlen(m_lpszRoot) + (bAddSep ?  1 : 0)) >= cchLength)
			return FALSE;

		BOOL bRet = (lstrcpy(lpstrFilePath, m_lpszRoot) != NULL);
		if(bRet)
		{
			TCHAR szSeparator[2] = { m_chDirSeparator, 0 };
			bRet = (lstrcat(lpstrFilePath, szSeparator) != NULL);
		}
		return bRet;
	}
	BOOL GetFileTitle(LPTSTR lpstrFileTitle, int cchLength) const
	{
		ATLASSERT(m_hFind != NULL);

		TCHAR szBuff[MAX_PATH];
		if(!GetFileName(szBuff, MAX_PATH))
			return FALSE;
		TCHAR szNameBuff[_MAX_FNAME];
		_tsplitpath(szBuff, NULL, NULL, szNameBuff, NULL);
		if(lstrlen(szNameBuff) >= cchLength)
			return FALSE;
		return (lstrcpy(lpstrFileTitle, szNameBuff) != NULL);
	}
	BOOL GetFileURL(LPTSTR lpstrFileURL, int cchLength) const
	{
		ATLASSERT(m_hFind != NULL);

		TCHAR szBuff[MAX_PATH];
		if(!GetFilePath(szBuff, MAX_PATH))
			return FALSE;
		LPCTSTR lpstrFileURLPrefix = _T("file://");
		if(lstrlen(szBuff) + lstrlen(lpstrFileURLPrefix) >= cchLength)
			return FALSE;
		if(lstrcpy(lpstrFileURL, lpstrFileURLPrefix) == NULL)
			return FALSE;
		return (lstrcat(lpstrFileURL, szBuff) != NULL);
	}
	BOOL GetRoot(LPTSTR lpstrRoot, int cchLength) const
	{
		ATLASSERT(m_hFind != NULL);
		if(lstrlen(m_lpszRoot) >= cchLength)
			return FALSE;
		return (lstrcpy(lpstrRoot, m_lpszRoot) != NULL);
	}
#ifndef _WTL_NO_CSTRING
	CString GetFileName() const
	{
		ATLASSERT(m_hFind != NULL);

		CString ret;

		if(m_bFound)
			ret = m_fd.cFileName;
		return ret;
	}
	CString GetFilePath() const
	{
		ATLASSERT(m_hFind != NULL);

		CString strResult = m_lpszRoot;
		if(strResult[strResult.GetLength() - 1] != '\\' &&
			strResult[strResult.GetLength() - 1] != '/')
			strResult += m_chDirSeparator;
		strResult += GetFileName();
		return strResult;
	}
	CString GetFileTitle() const
	{
		ATLASSERT(m_hFind != NULL);

		CString strFullName = GetFileName();
		CString strResult;

		_tsplitpath(strFullName, NULL, NULL, strResult.GetBuffer(MAX_PATH), NULL);
		strResult.ReleaseBuffer();
		return strResult;
	}
	CString GetFileURL() const
	{
		ATLASSERT(m_hFind != NULL);

		CString strResult("file://");
		strResult += GetFilePath();
		return strResult;
	}
	CString GetRoot() const
	{
		ATLASSERT(m_hFind != NULL);

		CString str = m_lpszRoot;
		return str;
	}
#endif //!_WTL_NO_CSTRING
	BOOL GetLastWriteTime(FILETIME* pTimeStamp) const
	{
		ATLASSERT(m_hFind != NULL);
		ATLASSERT(pTimeStamp != NULL);

		if(m_bFound && pTimeStamp != NULL)
		{
			*pTimeStamp = m_fd.ftLastWriteTime;
			return TRUE;
		}

		return FALSE;
	}
	BOOL GetLastAccessTime(FILETIME* pTimeStamp) const
	{
		ATLASSERT(m_hFind != NULL);
		ATLASSERT(pTimeStamp != NULL);

		if(m_bFound && pTimeStamp != NULL)
		{
			*pTimeStamp = m_fd.ftLastAccessTime;
			return TRUE;
		}

		return FALSE;
	}
	BOOL GetCreationTime(FILETIME* pTimeStamp) const
	{
		ATLASSERT(m_hFind != NULL);

		if(m_bFound && pTimeStamp != NULL)
		{
			*pTimeStamp = m_fd.ftCreationTime;
			return TRUE;
		}

		return FALSE;
	}
	BOOL MatchesMask(DWORD dwMask) const
	{
		ATLASSERT(m_hFind != NULL);

		if(m_bFound)
			return ((m_fd.dwFileAttributes & dwMask) != 0);

		return FALSE;
	}
	BOOL IsDots() const
	{
		ATLASSERT(m_hFind != NULL);

		// return TRUE if the file name is "." or ".." and
		// the file is a directory

		BOOL bResult = FALSE;
		if(m_bFound && IsDirectory())
		{
			if(m_fd.cFileName[0] == '.' && (m_fd.cFileName[1] == '\0' || (m_fd.cFileName[1] == '.' && m_fd.cFileName[2] == '\0')))
				bResult = TRUE;
		}

		return bResult;
	}

	BOOL IsReadOnly() const
	{
		return MatchesMask(FILE_ATTRIBUTE_READONLY);
	}
	BOOL IsDirectory() const
	{
		return MatchesMask(FILE_ATTRIBUTE_DIRECTORY);
	}
	BOOL IsCompressed() const
	{
		return MatchesMask(FILE_ATTRIBUTE_COMPRESSED);
	}
	BOOL IsSystem() const
	{
		return MatchesMask(FILE_ATTRIBUTE_SYSTEM);
	}
	BOOL IsHidden() const
	{
		return MatchesMask(FILE_ATTRIBUTE_HIDDEN);
	}
	BOOL IsTemporary() const
	{
		return MatchesMask(FILE_ATTRIBUTE_TEMPORARY);
	}
	BOOL IsNormal() const
	{
		return MatchesMask(FILE_ATTRIBUTE_NORMAL);
	}
	BOOL IsArchived() const
	{
		return MatchesMask(FILE_ATTRIBUTE_ARCHIVE);
	}

// Operations
	BOOL FindFile(LPCTSTR pstrName = NULL)
	{
		Close();

		if(pstrName == NULL)
			pstrName = _T("*.*");
		lstrcpy(m_fd.cFileName, pstrName);

		m_hFind = ::FindFirstFile(pstrName, &m_fd);

		if(m_hFind == INVALID_HANDLE_VALUE)
			return FALSE;

		LPCTSTR pstr = _tfullpath(m_lpszRoot, pstrName, MAX_PATH);

		// passed name isn't a valid path but was found by the API
		ATLASSERT(pstr != NULL);
		if(pstr == NULL)
		{
			Close();
			::SetLastError(ERROR_INVALID_NAME);
			return FALSE;
		}
		else
		{
			// find the last forward or backward whack
			LPTSTR pstrBack  = _tcsrchr(m_lpszRoot, '\\');
			LPTSTR pstrFront = _tcsrchr(m_lpszRoot, '/');

			if(pstrFront != NULL || pstrBack != NULL)
			{
				if(pstrFront == NULL)
					pstrFront = m_lpszRoot;
				if(pstrBack == NULL)
					pstrBack = m_lpszRoot;

				// from the start to the last whack is the root

				if(pstrFront >= pstrBack)
					*pstrFront = '\0';
				else
					*pstrBack = '\0';
			}
		}

		m_bFound = TRUE;

		return TRUE;
	}

	BOOL FindNextFile()
	{
		ATLASSERT(m_hFind != NULL);

		if(m_hFind == NULL)
			return FALSE;

		if(!m_bFound)
			return FALSE;

		m_bFound = ::FindNextFile(m_hFind, &m_fd);

		return m_bFound;
	}
	void Close()
	{
		m_bFound = FALSE;

		if(m_hFind != NULL && m_hFind != INVALID_HANDLE_VALUE)
		{
			::FindClose(m_hFind);
			m_hFind = NULL;
		}
	}
};


/////////////////////////////////////////////////////////////////////////////
// Global functions for loading resources

inline HACCEL AtlLoadAccelerators(_U_STRINGorID table)
{
	return ::LoadAccelerators(_Module.GetResourceInstance(), table.m_lpstr);
}

inline HMENU AtlLoadMenu(_U_STRINGorID menu)
{
	return ::LoadMenu(_Module.GetResourceInstance(), menu.m_lpstr);
}

inline HBITMAP AtlLoadBitmap(_U_STRINGorID bitmap)
{
	return ::LoadBitmap(_Module.GetResourceInstance(), bitmap.m_lpstr);
}

#ifdef OEMRESOURCE
inline HBITMAP AtlLoadSysBitmap(LPCTSTR lpBitmapName)
{
#ifdef _DEBUG
	WORD wID = (WORD)lpBitmapName;
	ATLASSERT(wID >= 32734 && wID <= 32767);
#endif //_DEBUG
	return ::LoadBitmap(NULL, lpBitmapName);
}
#endif //OEMRESOURCE

inline HCURSOR AtlLoadCursor(_U_STRINGorID cursor)
{
	return ::LoadCursor(_Module.GetResourceInstance(), cursor.m_lpstr);
}

inline HCURSOR AtlLoadSysCursor(LPCTSTR lpCursorName)
{
	ATLASSERT(lpCursorName == IDC_ARROW || lpCursorName == IDC_IBEAM || lpCursorName == IDC_WAIT ||
		lpCursorName == IDC_CROSS || lpCursorName == IDC_UPARROW || lpCursorName == IDC_SIZE ||
		lpCursorName == IDC_ICON || lpCursorName == IDC_SIZENWSE || lpCursorName == IDC_SIZENESW ||
		lpCursorName == IDC_SIZEWE || lpCursorName == IDC_SIZENS || lpCursorName == IDC_SIZEALL ||
		lpCursorName == IDC_NO || lpCursorName == IDC_APPSTARTING || lpCursorName == IDC_HELP);
	return ::LoadCursor(NULL, lpCursorName);
}

inline HICON AtlLoadIcon(_U_STRINGorID icon)
{
	return ::LoadIcon(_Module.GetResourceInstance(), icon.m_lpstr);
}

inline HICON AtlLoadSysIcon(LPCTSTR lpIconName)
{
	ATLASSERT(lpIconName == IDI_APPLICATION ||
		lpIconName == IDI_ASTERISK ||
		lpIconName == IDI_EXCLAMATION ||
		lpIconName == IDI_HAND ||
		lpIconName == IDI_QUESTION ||
		lpIconName == IDI_WINLOGO);
	return ::LoadIcon(NULL, lpIconName);
}

inline HBITMAP AtlLoadBitmapImage(_U_STRINGorID bitmap, UINT fuLoad = LR_DEFAULTCOLOR)
{
	return (HBITMAP)::LoadImage(_Module.GetResourceInstance(), bitmap.m_lpstr, IMAGE_BITMAP, 0, 0, fuLoad);
}

inline HCURSOR AtlLoadCursorImage(_U_STRINGorID cursor, UINT fuLoad = LR_DEFAULTCOLOR | LR_DEFAULTSIZE, int cxDesired = 0, int cyDesired = 0)
{
	return (HCURSOR)::LoadImage(_Module.GetResourceInstance(), cursor.m_lpstr, IMAGE_CURSOR, cxDesired, cyDesired, fuLoad);
}

inline HICON AtlLoadIconImage(_U_STRINGorID icon, UINT fuLoad = LR_DEFAULTCOLOR | LR_DEFAULTSIZE, int cxDesired = 0, int cyDesired = 0)
{
	return (HICON)::LoadImage(_Module.GetResourceInstance(), icon.m_lpstr, IMAGE_ICON, cxDesired, cyDesired, fuLoad);
}

#ifdef OEMRESOURCE
inline HBITMAP AtlLoadSysBitmapImage(WORD wBitmapID, UINT fuLoad = LR_DEFAULTCOLOR)
{
	ATLASSERT(wBitmapID >= 32734 && wBitmapID <= 32767);
	ATLASSERT((fuLoad & LR_LOADFROMFILE) == 0);	// this one doesn't load from a file
	return (HBITMAP)::LoadImage(NULL, MAKEINTRESOURCE(wBitmapID), IMAGE_BITMAP, 0, 0, fuLoad);
}
#endif //OEMRESOURCE

inline HCURSOR AtlLoadSysCursorImage(_U_STRINGorID cursor, UINT fuLoad = LR_DEFAULTCOLOR | LR_DEFAULTSIZE, int cxDesired = 0, int cyDesired = 0)
{
#ifdef _DEBUG
	WORD wID = (WORD)cursor.m_lpstr;
	ATLASSERT((wID >= 32512 && wID <= 32516) || (wID >= 32640 && wID <= 32648) || (wID == 32650) || (wID == 32651));
	ATLASSERT((fuLoad & LR_LOADFROMFILE) == 0);	// this one doesn't load from a file
#endif //_DEBUG
	return (HCURSOR)::LoadImage(NULL, cursor.m_lpstr, IMAGE_CURSOR, cxDesired, cyDesired, fuLoad);
}

inline HICON AtlLoadSysIconImage(_U_STRINGorID icon, UINT fuLoad = LR_DEFAULTCOLOR | LR_DEFAULTSIZE, int cxDesired = 0, int cyDesired = 0)
{
#ifdef _DEBUG
	WORD wID = (WORD)icon.m_lpstr;
	ATLASSERT(wID >= 32512 && wID <= 32517);
	ATLASSERT((fuLoad & LR_LOADFROMFILE) == 0);	// this one doesn't load from a file
#endif //_DEBUG
	return (HICON)::LoadImage(NULL, icon.m_lpstr, IMAGE_ICON, cxDesired, cyDesired, fuLoad);
}

inline int AtlLoadString(UINT uID, LPTSTR lpBuffer, int nBufferMax)
{
	return ::LoadString(_Module.GetResourceInstance(), uID, lpBuffer, nBufferMax);
}

inline bool AtlLoadString(UINT uID, BSTR& bstrText)
{
	USES_CONVERSION;
	ATLASSERT(bstrText == NULL);

	LPTSTR lpstrText = NULL;
	int nRes = 0;
	for(int nLen = 256; ; nLen *= 2)
	{
		ATLTRY(lpstrText = new TCHAR[nLen]);
		if(lpstrText == NULL)
			break;
		nRes = ::LoadString(_Module.GetResourceInstance(), uID, lpstrText, nLen);
		if(nRes < nLen - 1)
			break;
		delete [] lpstrText;
		lpstrText = NULL;
	}

	if(lpstrText != NULL)
	{
		if(nRes != 0)
			bstrText = ::SysAllocString(T2OLE(lpstrText));
		delete [] lpstrText;
	}

	return (bstrText != NULL) ? true : false;
}


/////////////////////////////////////////////////////////////////////////////
// Global functions for stock GDI objects

inline HPEN AtlGetStockPen(int nPen)
{
#if (_WIN32_WINNT >= 0x0500)
	ATLASSERT(nPen == WHITE_PEN || nPen == BLACK_PEN || nPen == NULL_PEN || nPen == DC_PEN);
#else
	ATLASSERT(nPen == WHITE_PEN || nPen == BLACK_PEN || nPen == NULL_PEN);
#endif //!(_WIN32_WINNT >= 0x0500)
	return (HPEN)::GetStockObject(nPen);
}

inline HBRUSH AtlGetStockBrush(int nBrush)
{
#if (_WIN32_WINNT >= 0x0500)
	ATLASSERT((nBrush >= WHITE_BRUSH && nBrush <= HOLLOW_BRUSH) || nBrush == DC_BRUSH);
#else
	ATLASSERT(nBrush >= WHITE_BRUSH && nBrush <= HOLLOW_BRUSH);
#endif //!(_WIN32_WINNT >= 0x0500)
	return (HBRUSH)::GetStockObject(nBrush);
}

inline HFONT AtlGetStockFont(int nFont)
{
	ATLASSERT((nFont >= OEM_FIXED_FONT && nFont <= SYSTEM_FIXED_FONT) || nFont == DEFAULT_GUI_FONT);
	return (HFONT)::GetStockObject(nFont);
}

inline HPALETTE AtlGetStockPalette(int nPalette)
{
	ATLASSERT(nPalette == DEFAULT_PALETTE); // the only one supported
	return (HPALETTE)::GetStockObject(nPalette);
}

}; //namespace WTL

#endif // __ATLMISC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\atlscrl.h ===
// WTL Version 3.0
// Copyright (C) 1997-1999 Microsoft Corporation
// All rights reserved.
//
// This file is a part of Windows Template Library.
// The code and information is provided "as-is" without
// warranty of any kind, either expressed or implied.

#ifndef __ATLSCRL_H__
#define __ATLSCRL_H__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLAPP_H__
	#error atlscrl.h requires atlapp.h to be included first
#endif

#ifndef __ATLWIN_H__
	#error atlscrl.h requires atlwin.h to be included first
#endif

#if !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400))
#include <zmouse.h>

#ifndef SPI_GETWHEELSCROLLLINES
#define SPI_GETWHEELSCROLLLINES   104
#endif //!SPI_GETWHEELSCROLLLINES
#endif //!((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400))


namespace WTL
{

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

template <class T> class CScrollImpl;
template <class T, class TBase = CWindow, class TWinTraits = CControlWinTraits> class CScrollWindowImpl;
template <class T> class CMapScrollImpl;
template <class T, class TBase = CWindow, class TWinTraits = CControlWinTraits> class CMapScrollWindowImpl;
#if defined(__ATLCTRLS_H__) && (_WIN32_IE >= 0x0400)
template <class TBase = CWindow> class CFSBWindowT;
#endif //defined(__ATLCTRLS_H__) && (_WIN32_IE >= 0x0400)


/////////////////////////////////////////////////////////////////////////////
// CScrollImpl - Provides scrolling support to any window

// Scroll extended styles
#define SCRL_SCROLLCHILDREN	0x00000001
#define SCRL_ERASEBACKGROUND	0x00000002
#define SCRL_NOTHUMBTRACKING	0x00000004
#if (WINVER >= 0x0500)
#define SCRL_SMOOTHSCROLL	0x00000008
#endif //(WINVER >= 0x0500)


template <class T>
class CScrollImpl
{
public:
	enum { uSCROLL_FLAGS = SW_INVALIDATE };

	POINT m_ptOffset;
	SIZE m_sizeAll;
	SIZE m_sizeLine;
	SIZE m_sizePage;
	SIZE m_sizeClient;
	int m_zDelta;			// current wheel value
	int m_nWheelLines;		// number of lines to scroll on wheel
#if !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400))
	UINT m_uMsgMouseWheel;		// MSH_MOUSEWHEEL
	// Note that this message must be forwarded from a top level window
#endif //!((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400))
	UINT m_uScrollFlags;
	DWORD m_dwExtendedStyle;	// scroll specific extended styles

// Constructor
	CScrollImpl() : m_zDelta(0), m_nWheelLines(3)
	{
		m_ptOffset.x = 0;
		m_ptOffset.y = 0;
		m_sizeAll.cx = 0;
		m_sizeAll.cy = 0;
		m_sizePage.cx = 0;
		m_sizePage.cy = 0;
		m_sizeLine.cx = 0;
		m_sizeLine.cy = 0;
		m_sizeClient.cx = 0;
		m_sizeClient.cy = 0;

		SetScrollExtendedStyle(SCRL_SCROLLCHILDREN | SCRL_ERASEBACKGROUND);
	}

// Attributes & Operations
	DWORD GetScrollExtendedStyle() const
	{
		return m_dwExtendedStyle;
	}

	DWORD SetScrollExtendedStyle(DWORD dwExtendedStyle)
	{
		DWORD dwPrevStyle = m_dwExtendedStyle;
		m_dwExtendedStyle = dwExtendedStyle;
		// cache scroll flags
		T* pT = static_cast<T*>(this);
		pT;	// avoid level 4 warning
		m_uScrollFlags = pT->uSCROLL_FLAGS | (IsScrollingChildren() ? SW_SCROLLCHILDREN : 0) | (IsErasingBackground() ? SW_ERASE : 0);
#if (WINVER >= 0x0500)
		m_uScrollFlags |= (IsSmoothScroll() ? SW_SMOOTHSCROLL : 0);
#endif //(WINVER >= 0x0500)
		return dwPrevStyle;
	}

	// offset operations
	void SetScrollOffset(int x, int y, BOOL bRedraw = TRUE)
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));

		m_ptOffset.x = x;
		m_ptOffset.y = y;

		SCROLLINFO si;
		si.cbSize = sizeof(si);
		si.fMask = SIF_POS;

		si.nPos = m_ptOffset.x;
		pT->SetScrollInfo(SB_HORZ, &si, bRedraw);

		si.nPos = m_ptOffset.y;
		pT->SetScrollInfo(SB_VERT, &si, bRedraw);

		if(bRedraw)
			pT->Invalidate();
	}
	void SetScrollOffset(POINT ptOffset, BOOL bRedraw = TRUE)
	{
		SetScrollOffset(ptOffset.x, ptOffset.y, bRedraw);
	}
	void GetScrollOffset(POINT& ptOffset) const
	{
		ptOffset = m_ptOffset;
	}

	// size operations
	void SetScrollSize(int cx, int cy, BOOL bRedraw = TRUE)
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));

		m_sizeAll.cx = cx;
		m_sizeAll.cy = cy;

		m_ptOffset.x = 0;
		m_ptOffset.y = 0;

		SCROLLINFO si;
		si.cbSize = sizeof(si);
		si.fMask = SIF_PAGE | SIF_RANGE | SIF_POS;
		si.nMin = 0;

		si.nMax = m_sizeAll.cx - 1;
		si.nPage = m_sizeClient.cx;
		si.nPos = m_ptOffset.x;
		pT->SetScrollInfo(SB_HORZ, &si, bRedraw);

		si.nMax = m_sizeAll.cy - 1;
		si.nPage = m_sizeClient.cy;
		si.nPos = m_ptOffset.y;
		pT->SetScrollInfo(SB_VERT, &si, bRedraw);

		SetScrollLine(0, 0);
		SetScrollPage(0, 0);

		if(bRedraw)
			pT->Invalidate();
	}
	void SetScrollSize(SIZE size, BOOL bRedraw = TRUE)
	{
		SetScrollSize(size.cx, size.cy, bRedraw);
	}
	void GetScrollSize(SIZE& sizeWnd) const
	{
		sizeWnd = m_sizeAll;
	}

	// line operations
	void SetScrollLine(int cxLine, int cyLine)
	{
		ATLASSERT(cxLine >= 0 && cyLine >= 0);
		ATLASSERT(m_sizeAll.cx != 0 && m_sizeAll.cy != 0);

		m_sizeLine.cx = CalcLineOrPage(cxLine, m_sizeAll.cx, 100);
		m_sizeLine.cy = CalcLineOrPage(cyLine, m_sizeAll.cy, 100);
	}
	void SetScrollLine(SIZE sizeLine)
	{
		SetScrollLine(sizeLine.cx, sizeLine.cy);
	}
	void GetScrollLine(SIZE& sizeLine) const
	{
		sizeLine = m_sizeLine;
	}

	// page operations
	void SetScrollPage(int cxPage, int cyPage)
	{
		ATLASSERT(cxPage >= 0 && cyPage >= 0);
		ATLASSERT(m_sizeAll.cx != 0 && m_sizeAll.cy != 0);

		m_sizePage.cx = CalcLineOrPage(cxPage, m_sizeAll.cx, 10);
		m_sizePage.cy = CalcLineOrPage(cyPage, m_sizeAll.cy, 10);
	}
	void SetScrollPage(SIZE sizePage)
	{
		SetScrollPage(sizePage.cx, sizePage.cy);
	}
	void GetScrollPage(SIZE& sizePage) const
	{
		sizePage = m_sizePage;
	}

	// commands
	void ScrollLineDown()
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		pT->DoScroll(SB_VERT, SB_LINEDOWN, (int&)m_ptOffset.y, m_sizeAll.cy, m_sizePage.cy, m_sizeLine.cy);
	}

	void ScrollLineUp()
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		pT->DoScroll(SB_VERT, SB_LINEUP, (int&)m_ptOffset.y, m_sizeAll.cy, m_sizePage.cy, m_sizeLine.cy);
	}

	void ScrollPageDown()
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		pT->DoScroll(SB_VERT, SB_PAGEDOWN, (int&)m_ptOffset.y, m_sizeAll.cy, m_sizePage.cy, m_sizeLine.cy);
	}

	void ScrollPageUp()
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		pT->DoScroll(SB_VERT, SB_PAGEUP, (int&)m_ptOffset.y, m_sizeAll.cy, m_sizePage.cy, m_sizeLine.cy);
	}

	void ScrollTop()
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		pT->DoScroll(SB_VERT, SB_TOP, (int&)m_ptOffset.y, m_sizeAll.cy, m_sizePage.cy, m_sizeLine.cy);
	}

	void ScrollBottom()
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		pT->DoScroll(SB_VERT, SB_BOTTOM, (int&)m_ptOffset.y, m_sizeAll.cy, m_sizePage.cy, m_sizeLine.cy);
	}

	void ScrollLineRight()
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		pT->DoScroll(SB_HORZ, SB_LINEDOWN, (int&)m_ptOffset.x, m_sizeAll.cx, m_sizePage.cx, m_sizeLine.cx);
	}

	void ScrollLineLeft()
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		pT->DoScroll(SB_HORZ, SB_LINEUP, (int&)m_ptOffset.x, m_sizeAll.cx, m_sizePage.cx, m_sizeLine.cx);
	}

	void ScrollPageRight()
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		pT->DoScroll(SB_HORZ, SB_PAGEDOWN, (int&)m_ptOffset.x, m_sizeAll.cx, m_sizePage.cx, m_sizeLine.cx);
	}

	void ScrollPageLeft()
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		pT->DoScroll(SB_HORZ, SB_PAGEUP, (int&)m_ptOffset.x, m_sizeAll.cx, m_sizePage.cx, m_sizeLine.cx);
	}

	void ScrollAllLeft()
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		pT->DoScroll(SB_HORZ, SB_TOP, (int&)m_ptOffset.x, m_sizeAll.cx, m_sizePage.cx, m_sizeLine.cx);
	}

	void ScrollAllRight()
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		pT->DoScroll(SB_HORZ, SB_BOTTOM, (int&)m_ptOffset.x, m_sizeAll.cx, m_sizePage.cx, m_sizeLine.cx);
	}

	BEGIN_MSG_MAP(CScrollImpl< T >)
		MESSAGE_HANDLER(WM_CREATE, OnCreate)
		MESSAGE_HANDLER(WM_VSCROLL, OnVScroll)
		MESSAGE_HANDLER(WM_HSCROLL, OnHScroll)
		MESSAGE_HANDLER(WM_MOUSEWHEEL, OnMouseWheel)
#if !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400))
		MESSAGE_HANDLER(m_uMsgMouseWheel, OnMouseWheel)
#endif //(_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)
		MESSAGE_HANDLER(WM_SETTINGCHANGE, OnSettingChange)
		MESSAGE_HANDLER(WM_SIZE, OnSize)
		MESSAGE_HANDLER(WM_PAINT, OnPaint)
		MESSAGE_HANDLER(WM_PRINTCLIENT, OnPaint)
	// standard scroll commands
	ALT_MSG_MAP(1)
		COMMAND_ID_HANDLER(ID_SCROLL_UP, OnScrollUp)
		COMMAND_ID_HANDLER(ID_SCROLL_DOWN, OnScrollDown)
		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_UP, OnScrollPageUp)
		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_DOWN, OnScrollPageDown)
		COMMAND_ID_HANDLER(ID_SCROLL_TOP, OnScrollTop)
		COMMAND_ID_HANDLER(ID_SCROLL_BOTTOM, OnScrollBottom)
		COMMAND_ID_HANDLER(ID_SCROLL_LEFT, OnScrollLeft)
		COMMAND_ID_HANDLER(ID_SCROLL_RIGHT, OnScrollRight)
		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_LEFT, OnScrollPageLeft)
		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_RIGHT, OnScrollPageRight)
		COMMAND_ID_HANDLER(ID_SCROLL_ALL_LEFT, OnScrollAllLeft)
		COMMAND_ID_HANDLER(ID_SCROLL_ALL_RIGHT, OnScrollAllRight)
	END_MSG_MAP()

	LRESULT OnCreate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		GetSystemSettings();
		bHandled = FALSE;
		return 1;
	}

	LRESULT OnVScroll(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		pT->DoScroll(SB_VERT, (int)(short)LOWORD(wParam), (int&)m_ptOffset.y, m_sizeAll.cy, m_sizePage.cy, m_sizeLine.cy);
		return 0;
	}

	LRESULT OnHScroll(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		pT->DoScroll(SB_HORZ, (int)(short)LOWORD(wParam), (int&)m_ptOffset.x, m_sizeAll.cx, m_sizePage.cx, m_sizeLine.cx);
		return 0;
	}

	LRESULT OnMouseWheel(UINT uMsg, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));

#if (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)
		uMsg;
		int zDelta = (int)(short)HIWORD(wParam);
#else
		int zDelta = (uMsg == WM_MOUSEWHEEL) ? (int)(short)HIWORD(wParam) : (int)wParam;
#endif //!((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400))
		int nScrollCode = (m_nWheelLines == WHEEL_PAGESCROLL) ? ((zDelta > 0) ? SB_PAGEUP : SB_PAGEDOWN) : ((zDelta > 0) ? SB_LINEUP : SB_LINEDOWN);
		m_zDelta += zDelta;		// cumulative
		int zTotal = (m_nWheelLines == WHEEL_PAGESCROLL) ? abs(m_zDelta) : abs(m_zDelta) * m_nWheelLines;
		if((pT->GetStyle() & WS_VSCROLL) != 0)
		{
			for(short i = 0; i < zTotal; i += WHEEL_DELTA)
			{
				pT->DoScroll(SB_VERT, nScrollCode, (int&)m_ptOffset.y, m_sizeAll.cy, m_sizePage.cy, m_sizeLine.cy);
				pT->UpdateWindow();
			}
		}
		else		// can't scroll vertically, scroll horizontally
		{
			for(short i = 0; i < zTotal; i += WHEEL_DELTA)
			{
				pT->DoScroll(SB_HORZ, nScrollCode, (int&)m_ptOffset.x, m_sizeAll.cx, m_sizePage.cx, m_sizeLine.cx);
				pT->UpdateWindow();
			}
		}
		int nSteps = m_zDelta / WHEEL_DELTA;
		m_zDelta -= nSteps * WHEEL_DELTA;

		return 0;
	}

	LRESULT OnSettingChange(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		GetSystemSettings();
		return 0;
	}

	LRESULT OnSize(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));

		m_sizeClient.cx = GET_X_LPARAM(lParam);
		m_sizeClient.cy = GET_Y_LPARAM(lParam);

		SCROLLINFO si;
		si.cbSize = sizeof(si);
		si.fMask = SIF_PAGE | SIF_POS;

		si.nPage = m_sizeClient.cx;
		si.nPos = m_ptOffset.x;
		pT->SetScrollInfo(SB_HORZ, &si, FALSE);

		si.nPage = m_sizeClient.cy;
		si.nPos = m_ptOffset.y;
		pT->SetScrollInfo(SB_VERT, &si, FALSE);

		bool bUpdate = false;
		int cxMax = m_sizeAll.cx - m_sizeClient.cx;
		int cyMax = m_sizeAll.cy - m_sizeClient.cy;
		int x = m_ptOffset.x;
		int y = m_ptOffset.y;
		if(m_ptOffset.x > cxMax)
		{
			bUpdate = true;
			x = (cxMax >= 0) ? cxMax : 0;
		}
		if(m_ptOffset.y > cyMax)
		{
			bUpdate = true;
			y = (cyMax >= 0) ? cyMax : 0;
		}
		if(bUpdate)
			SetScrollOffset(x, y);

		bHandled = FALSE;
		return 1;
	}

	LRESULT OnPaint(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		if(wParam != NULL)
		{
			CDCHandle dc = (HDC)wParam;
			dc.SetViewportOrg(-m_ptOffset.x, -m_ptOffset.y);
			pT->DoPaint(dc);
		}
		else
		{
			CPaintDC dc(pT->m_hWnd);
			dc.SetViewportOrg(-m_ptOffset.x, -m_ptOffset.y);
			pT->DoPaint(dc.m_hDC);
		}
		return 0;
	}

	// scrolling handlers
	LRESULT OnScrollUp(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		ScrollLineUp();
		return 0;
	}
	LRESULT OnScrollDown(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		ScrollLineDown();
		return 0;
	}
	LRESULT OnScrollPageUp(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		ScrollPageUp();
		return 0;
	}
	LRESULT OnScrollPageDown(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		ScrollPageDown();
		return 0;
	}
	LRESULT OnScrollTop(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		ScrollTop();
		return 0;
	}
	LRESULT OnScrollBottom(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		ScrollBottom();
		return 0;
	}
	LRESULT OnScrollLeft(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		ScrollLineLeft();
		return 0;
	}
	LRESULT OnScrollRight(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		ScrollLineRight();
		return 0;
	}
	LRESULT OnScrollPageLeft(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		ScrollPageLeft();
		return 0;
	}
	LRESULT OnScrollPageRight(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		ScrollPageRight();
		return 0;
	}
	LRESULT OnScrollAllLeft(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		ScrollAllLeft();
		return 0;
	}
	LRESULT OnScrollAllRight(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		ScrollAllRight();
		return 0;
	}

// Overrideables
	void DoPaint(CDCHandle /*dc*/)
	{
		// must be implemented in a derived class
		ATLASSERT(FALSE);
	}

// Implementation
	void DoScroll(int nType, int nScrollCode, int& cxyOffset, int cxySizeAll, int cxySizePage, int cxySizeLine)
	{
		T* pT = static_cast<T*>(this);
		RECT rect;
		pT->GetClientRect(&rect);
		int cxyClient = (nType == SB_VERT) ? rect.bottom : rect.right;
		int cxyMax = cxySizeAll - cxyClient;

		if(cxyMax < 0)		// can't scroll, client area is bigger
			return;

		BOOL bUpdate = TRUE;
		int cxyScroll = 0;

		switch(nScrollCode)
		{
		case SB_TOP:		// top or all left
			cxyScroll = cxyOffset;
			cxyOffset = 0;
			break;
		case SB_BOTTOM:		// bottom or all right
			cxyScroll = cxyOffset - cxyMax;
			cxyOffset = cxyMax;
			break;
		case SB_LINEUP:		// line up or line left
			if(cxyOffset >= cxySizeLine)
			{
				cxyScroll = cxySizeLine;
				cxyOffset -= cxySizeLine;
			}
			else
			{
				cxyScroll = cxyOffset;
				cxyOffset = 0;
			}
			break;
		case SB_LINEDOWN:	// line down or line right
			if(cxyOffset < cxyMax - cxySizeLine)
			{
				cxyScroll = -cxySizeLine;
				cxyOffset += cxySizeLine;
			}
			else
			{
				cxyScroll = cxyOffset - cxyMax;
				cxyOffset = cxyMax;
			}
			break;
		case SB_PAGEUP:		// page up or page left
			if(cxyOffset >= cxySizePage)
			{
				cxyScroll = cxySizePage;
				cxyOffset -= cxySizePage;
			}
			else
			{
				cxyScroll = cxyOffset;
				cxyOffset = 0;
			}
			break;
		case SB_PAGEDOWN:	// page down or page right
			if(cxyOffset < cxyMax - cxySizePage)
			{
				cxyScroll = -cxySizePage;
				cxyOffset += cxySizePage;
			}
			else
			{
				cxyScroll = cxyOffset - cxyMax;
				cxyOffset = cxyMax;
			}
			break;
		case SB_THUMBTRACK:
			if(IsNoThumbTracking())
				break;
			// else fall through
		case SB_THUMBPOSITION:
			{
				SCROLLINFO si;
				si.cbSize = sizeof(SCROLLINFO);
				si.fMask = SIF_TRACKPOS;
				if(pT->GetScrollInfo(nType, &si))
				{
					cxyScroll = cxyOffset - si.nTrackPos;
					cxyOffset = si.nTrackPos;
				}
			}
			break;
		case SB_ENDSCROLL:
		default:
			bUpdate = FALSE;
			break;
		}

		if(bUpdate && cxyScroll != 0)
		{
			pT->SetScrollPos(nType, cxyOffset, TRUE);
			if(nType == SB_VERT)
				pT->ScrollWindowEx(0, cxyScroll, m_uScrollFlags);
			else
				pT->ScrollWindowEx(cxyScroll, 0, m_uScrollFlags);
		}
	}
	int CalcLineOrPage(int nVal, int nMax, int nDiv)
	{
		if(nVal == 0)
		{
			nVal = nMax / nDiv;
			if(nVal < 1)
				nVal = 1;
		}
		else if(nVal > nMax)
			nVal = nMax;

		return nVal;
	}
	void GetSystemSettings()
	{
		::SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &m_nWheelLines, 0);

#if !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400))
		if(m_uMsgMouseWheel != 0)
			m_uMsgMouseWheel = ::RegisterWindowMessage(MSH_MOUSEWHEEL);

		HWND hWndWheel = FindWindow(MSH_WHEELMODULE_CLASS, MSH_WHEELMODULE_TITLE);
		if(::IsWindow(hWndWheel))
		{
			UINT uMsgScrollLines = ::RegisterWindowMessage(MSH_SCROLL_LINES);
			if(uMsgScrollLines != 0)
				m_nWheelLines = ::SendMessage(hWndWheel, uMsgScrollLines, 0, 0L);
		}
#endif //!((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400))
	}
	bool IsScrollingChildren() const
	{
		return (m_dwExtendedStyle & SCRL_SCROLLCHILDREN) != 0;
	}
	bool IsErasingBackground() const
	{
		return (m_dwExtendedStyle & SCRL_ERASEBACKGROUND) != 0;
	}
	bool IsNoThumbTracking() const
	{
		return (m_dwExtendedStyle & SCRL_NOTHUMBTRACKING) != 0;
	}
#if (WINVER >= 0x0500)
	bool IsSmoothScroll() const
	{
		return (m_dwExtendedStyle & SCRL_SMOOTHSCROLL) != 0;
	}
#endif //(WINVER >= 0x0500)
};


/////////////////////////////////////////////////////////////////////////////
// CScrollWindowImpl - Implements a scrollable window

template <class T, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class ATL_NO_VTABLE CScrollWindowImpl : public CWindowImpl<T, TBase, TWinTraits>, public CScrollImpl< T >
{
public:
	BEGIN_MSG_MAP(CScrollImpl< T >)
		MESSAGE_HANDLER(WM_VSCROLL, CScrollImpl< T >::OnVScroll)
		MESSAGE_HANDLER(WM_HSCROLL, CScrollImpl< T >::OnHScroll)
		MESSAGE_HANDLER(WM_MOUSEWHEEL, CScrollImpl< T >::OnMouseWheel)
#if !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400))
		MESSAGE_HANDLER(m_uMsgMouseWheel, CScrollImpl< T >::OnMouseWheel)
#endif //(_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)
		MESSAGE_HANDLER(WM_SETTINGCHANGE, CScrollImpl< T >::OnSettingChange)
		MESSAGE_HANDLER(WM_SIZE, CScrollImpl< T >::OnSize)
		MESSAGE_HANDLER(WM_PAINT, CScrollImpl< T >::OnPaint)
		MESSAGE_HANDLER(WM_PRINTCLIENT, CScrollImpl< T >::OnPaint)
	ALT_MSG_MAP(1)
		COMMAND_ID_HANDLER(ID_SCROLL_UP, CScrollImpl< T >::OnScrollUp)
		COMMAND_ID_HANDLER(ID_SCROLL_DOWN, CScrollImpl< T >::OnScrollDown)
		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_UP, CScrollImpl< T >::OnScrollPageUp)
		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_DOWN, CScrollImpl< T >::OnScrollPageDown)
		COMMAND_ID_HANDLER(ID_SCROLL_TOP, CScrollImpl< T >::OnScrollTop)
		COMMAND_ID_HANDLER(ID_SCROLL_BOTTOM, CScrollImpl< T >::OnScrollBottom)
		COMMAND_ID_HANDLER(ID_SCROLL_LEFT, CScrollImpl< T >::OnScrollLeft)
		COMMAND_ID_HANDLER(ID_SCROLL_RIGHT, CScrollImpl< T >::OnScrollRight)
		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_LEFT, CScrollImpl< T >::OnScrollPageLeft)
		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_RIGHT, CScrollImpl< T >::OnScrollPageRight)
		COMMAND_ID_HANDLER(ID_SCROLL_ALL_LEFT, CScrollImpl< T >::OnScrollAllLeft)
		COMMAND_ID_HANDLER(ID_SCROLL_ALL_RIGHT, CScrollImpl< T >::OnScrollAllRight)
	END_MSG_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CMapScrollImpl - Provides mapping and scrolling support to any window

template <class T>
class CMapScrollImpl : public CScrollImpl< T >
{
public:
	int m_nMapMode;
	RECT m_rectLogAll;
	SIZE m_sizeLogLine;
	SIZE m_sizeLogPage;

// Constructor
	CMapScrollImpl() : m_nMapMode(MM_TEXT)
	{
		::SetRectEmpty(&m_rectLogAll);
		m_sizeLogPage.cx = 0;
		m_sizeLogPage.cy = 0;
		m_sizeLogLine.cx = 0;
		m_sizeLogLine.cy = 0;
	}

// Attributes & Operations
	// mapping mode operations
	void SetScrollMapMode(int nMapMode)
	{
		ATLASSERT(nMapMode >= MM_MIN && nMapMode <= MM_MAX_FIXEDSCALE);
		m_nMapMode = nMapMode;
	}
	int GetScrollMapMode() const
	{
		ATLASSERT(m_nMapMode >= MM_MIN && m_nMapMode <= MM_MAX_FIXEDSCALE);
		return m_nMapMode;
	}

	// offset operations
	void SetScrollOffset(int x, int y, BOOL bRedraw = TRUE)
	{
		ATLASSERT(m_nMapMode >= MM_MIN && m_nMapMode <= MM_MAX_FIXEDSCALE);
		POINT ptOff = { x, y };
		// block: convert logical to device units
		{
			CWindowDC dc(NULL);
			dc.SetMapMode(m_nMapMode);
			dc.LPtoDP(&ptOff);
		}
		CScrollImpl< T >::SetScrollOffset(ptOff, bRedraw);
	}
	void SetScrollOffset(POINT ptOffset, BOOL bRedraw = TRUE)
	{
		SetScrollOffset(ptOffset.x, ptOffset.y, bRedraw);
	}
	void GetScrollOffset(POINT& ptOffset) const
	{
		ATLASSERT(m_nMapMode >= MM_MIN && m_nMapMode <= MM_MAX_FIXEDSCALE);
		ptOffset = m_ptOffset;
		// block: convert logical to device units
		{
			CWindowDC dc(NULL);
			dc.SetMapMode(m_nMapMode);
			dc.DPtoLP(&ptOffset);
		}
	}

	// size operations
	void SetScrollSize(int xMin, int yMin, int xMax, int yMax, BOOL bRedraw = TRUE)
	{
		ATLASSERT(xMax > xMin && yMax > yMin);
		ATLASSERT(m_nMapMode >= MM_MIN && m_nMapMode <= MM_MAX_FIXEDSCALE);

		::SetRect(&m_rectLogAll, xMin, yMax, xMax, yMin);

		SIZE sizeAll;
		sizeAll.cx = xMax - xMin + 1;
		sizeAll.cy = yMax - xMin + 1;
		// block: convert logical to device units
		{
			CWindowDC dc(NULL);
			dc.SetMapMode(m_nMapMode);
			dc.LPtoDP(&sizeAll);
		}
		CScrollImpl< T >::SetScrollSize(sizeAll, bRedraw);
		SetScrollLine(0, 0);
		SetScrollPage(0, 0);
	}
	void SetScrollSize(RECT& rcScroll, BOOL bRedraw = TRUE)
	{
		SetScrollSize(rcScroll.left, rcScroll.top, rcScroll.right, rcScroll.bottom, bRedraw);
	}
	void SetScrollSize(int cx, int cy, BOOL bRedraw = TRUE)
	{
		SetScrollSize(0, 0, cx, cy, bRedraw);
	}
	void SetScrollSize(SIZE size, BOOL bRedraw = NULL)
	{
		SetScrollSize(0, 0, size.cx, size.cy, bRedraw);
	}
	void GetScrollSize(RECT& rcScroll) const
	{
		ATLASSERT(m_nMapMode >= MM_MIN && m_nMapMode <= MM_MAX_FIXEDSCALE);
		rcScroll = m_rectLogAll;
	}

	// line operations
	void SetScrollLine(int cxLine, int cyLine)
	{
		ATLASSERT(cxLine >= 0 && cyLine >= 0);
		ATLASSERT(m_nMapMode >= MM_MIN && m_nMapMode <= MM_MAX_FIXEDSCALE);

		m_sizeLogLine.cx = cxLine;
		m_sizeLogLine.cy = cyLine;
		SIZE sizeLine = m_sizeLogLine;
		// block: convert logical to device units
		{
			CWindowDC dc(NULL);
			dc.SetMapMode(m_nMapMode);
			dc.LPtoDP(&sizeLine);
		}
		CScrollImpl< T >::SetScrollLine(sizeLine);
	}
	void SetScrollLine(SIZE sizeLine)
	{
		SetScrollLine(sizeLine.cx, sizeLine.cy);
	}
	void GetScrollLine(SIZE& sizeLine) const
	{
		ATLASSERT(m_nMapMode >= MM_MIN && m_nMapMode <= MM_MAX_FIXEDSCALE);
		sizeLine = m_sizeLogLine;
	}

	// page operations
	void SetScrollPage(int cxPage, int cyPage)
	{
		ATLASSERT(cxPage >= 0 && cyPage >= 0);
		ATLASSERT(m_nMapMode >= MM_MIN && m_nMapMode <= MM_MAX_FIXEDSCALE);

		m_sizeLogPage.cx = cxPage;
		m_sizeLogPage.cy = cyPage;
		SIZE sizePage = m_sizeLogPage;
		// block: convert logical to device units
		{
			CWindowDC dc(NULL);
			dc.SetMapMode(m_nMapMode);
			dc.LPtoDP(&sizePage);
		}
		CScrollImpl< T >::SetScrollPage(sizePage);
	}
	void SetScrollPage(SIZE sizePage)
	{
		SetScrollPage(sizePage.cx, sizePage.cy);
	}
	void GetScrollPage(SIZE& sizePage) const
	{
		ATLASSERT(m_nMapMode >= MM_MIN && m_nMapMode <= MM_MAX_FIXEDSCALE);
		sizePage = m_sizeLogPage;
	}

	BEGIN_MSG_MAP(CMapScrollImpl< T >)
		MESSAGE_HANDLER(WM_VSCROLL, CScrollImpl< T >::OnVScroll)
		MESSAGE_HANDLER(WM_HSCROLL, CScrollImpl< T >::OnHScroll)
		MESSAGE_HANDLER(WM_MOUSEWHEEL, CScrollImpl< T >::OnMouseWheel)
#if !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400))
		MESSAGE_HANDLER(m_uMsgMouseWheel, CScrollImpl< T >::OnMouseWheel)
#endif //(_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)
		MESSAGE_HANDLER(WM_SETTINGCHANGE, CScrollImpl< T >::OnSettingChange)
		MESSAGE_HANDLER(WM_SIZE, CScrollImpl< T >::OnSize)
		MESSAGE_HANDLER(WM_PAINT, OnPaint)
		MESSAGE_HANDLER(WM_PRINTCLIENT, OnPaint)
	ALT_MSG_MAP(1)
		COMMAND_ID_HANDLER(ID_SCROLL_UP, CScrollImpl< T >::OnScrollUp)
		COMMAND_ID_HANDLER(ID_SCROLL_DOWN, CScrollImpl< T >::OnScrollDown)
		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_UP, CScrollImpl< T >::OnScrollPageUp)
		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_DOWN, CScrollImpl< T >::OnScrollPageDown)
		COMMAND_ID_HANDLER(ID_SCROLL_TOP, CScrollImpl< T >::OnScrollTop)
		COMMAND_ID_HANDLER(ID_SCROLL_BOTTOM, CScrollImpl< T >::OnScrollBottom)
		COMMAND_ID_HANDLER(ID_SCROLL_LEFT, CScrollImpl< T >::OnScrollLeft)
		COMMAND_ID_HANDLER(ID_SCROLL_RIGHT, CScrollImpl< T >::OnScrollRight)
		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_LEFT, CScrollImpl< T >::OnScrollPageLeft)
		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_RIGHT, CScrollImpl< T >::OnScrollPageRight)
		COMMAND_ID_HANDLER(ID_SCROLL_ALL_LEFT, CScrollImpl< T >::OnScrollAllLeft)
		COMMAND_ID_HANDLER(ID_SCROLL_ALL_RIGHT, CScrollImpl< T >::OnScrollAllRight)
	END_MSG_MAP()

	LRESULT OnPaint(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		if(wParam != NULL)
		{
			CDCHandle dc = (HDC)wParam;
			dc.SetMapMode(m_nMapMode);
			if(m_nMapMode == MM_TEXT)
				dc.SetViewportOrg(-m_ptOffset.x, -m_ptOffset.y);
			else
				dc.SetViewportOrg(-m_ptOffset.x, -m_ptOffset.y + m_sizeAll.cy);
			dc.SetWindowOrg(m_rectLogAll.left, m_rectLogAll.bottom);
			pT->DoPaint(dc);
		}
		else
		{
			CPaintDC dc(pT->m_hWnd);
			dc.SetMapMode(m_nMapMode);
			if(m_nMapMode == MM_TEXT)
				dc.SetViewportOrg(-m_ptOffset.x, -m_ptOffset.y);
			else
				dc.SetViewportOrg(-m_ptOffset.x, -m_ptOffset.y + m_sizeAll.cy);
			dc.SetWindowOrg(m_rectLogAll.left, m_rectLogAll.bottom);
			pT->DoPaint(dc.m_hDC);
		}
		return 0;
	}
};


/////////////////////////////////////////////////////////////////////////////
// CMapScrollWindowImpl - Implements scrolling window with mapping

template <class T, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class ATL_NO_VTABLE CMapScrollWindowImpl : public CWindowImpl< T, TBase, TWinTraits >, public CMapScrollImpl< T >
{
public:
	BEGIN_MSG_MAP(CMapScrollWindowImpl< T >)
		MESSAGE_HANDLER(WM_VSCROLL, CScrollImpl< T >::OnVScroll)
		MESSAGE_HANDLER(WM_HSCROLL, CScrollImpl< T >::OnHScroll)
		MESSAGE_HANDLER(WM_MOUSEWHEEL, CScrollImpl< T >::OnMouseWheel)
#if !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400))
		MESSAGE_HANDLER(m_uMsgMouseWheel, CScrollImpl< T >::OnMouseWheel)
#endif //(_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)
		MESSAGE_HANDLER(WM_SETTINGCHANGE, CScrollImpl< T >::OnSettingChange)
		MESSAGE_HANDLER(WM_SIZE, CScrollImpl< T >::OnSize)
		MESSAGE_HANDLER(WM_PAINT, CMapScrollImpl< T >::OnPaint)
		MESSAGE_HANDLER(WM_PRINTCLIENT, CMapScrollImpl< T >::OnPaint)
	ALT_MSG_MAP(1)
		COMMAND_ID_HANDLER(ID_SCROLL_UP, CScrollImpl< T >::OnScrollUp)
		COMMAND_ID_HANDLER(ID_SCROLL_DOWN, CScrollImpl< T >::OnScrollDown)
		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_UP, CScrollImpl< T >::OnScrollPageUp)
		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_DOWN, CScrollImpl< T >::OnScrollPageDown)
		COMMAND_ID_HANDLER(ID_SCROLL_TOP, CScrollImpl< T >::OnScrollTop)
		COMMAND_ID_HANDLER(ID_SCROLL_BOTTOM, CScrollImpl< T >::OnScrollBottom)
		COMMAND_ID_HANDLER(ID_SCROLL_LEFT, CScrollImpl< T >::OnScrollLeft)
		COMMAND_ID_HANDLER(ID_SCROLL_RIGHT, CScrollImpl< T >::OnScrollRight)
		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_LEFT, CScrollImpl< T >::OnScrollPageLeft)
		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_RIGHT, CScrollImpl< T >::OnScrollPageRight)
		COMMAND_ID_HANDLER(ID_SCROLL_ALL_LEFT, CScrollImpl< T >::OnScrollAllLeft)
		COMMAND_ID_HANDLER(ID_SCROLL_ALL_RIGHT, CScrollImpl< T >::OnScrollAllRight)
	END_MSG_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CFSBWindow - Use as a base instead of CWindow to get flat scroll bar support

#if defined(__ATLCTRLS_H__) && (_WIN32_IE >= 0x0400)

template <class TBase = CWindow> class CFSBWindowT : public TBase, public CFlatScrollBarImpl<CFSBWindowT< TBase > >
{
public:
// Constructors
	CFSBWindowT(HWND hWnd = NULL) : TBase(hWnd)
	{ }

	CFSBWindowT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

// CWindow overrides that use flat scroll bar API
// (only those methods that are used by scroll window classes)
	int SetScrollPos(int nBar, int nPos, BOOL bRedraw = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return FlatSB_SetScrollPos(nBar, nPos, bRedraw);
	}

	BOOL GetScrollInfo(int nBar, LPSCROLLINFO lpScrollInfo)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return FlatSB_GetScrollInfo(nBar, lpScrollInfo);
	}

	BOOL SetScrollInfo(int nBar, LPSCROLLINFO lpScrollInfo, BOOL bRedraw = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return FlatSB_SetScrollInfo(nBar, lpScrollInfo, bRedraw);
	}
};

typedef CFSBWindowT<CWindow>	CFSBWindow;

#endif //defined(__ATLCTRLS_H__) && (_WIN32_IE >= 0x0400)

}; //namespace WTL

#endif //__ATLSCRL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\atlsplit.h ===
// WTL Version 3.0
// Copyright (C) 1997-1999 Microsoft Corporation
// All rights reserved.
//
// This file is a part of Windows Template Library.
// The code and information is provided "as-is" without
// warranty of any kind, either expressed or implied.

#ifndef __ATLSPLIT_H__
#define __ATLSPLIT_H__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLAPP_H__
	#error atlsplit.h requires atlapp.h to be included first
#endif

#ifndef __ATLWIN_H__
	#error atlsplit.h requires atlwin.h to be included first
#endif


namespace WTL
{

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

template <class T, bool t_bVertical = true> class CSplitterImpl;
template <class T, bool t_bVertical = true, class TBase = CWindow, class TWinTraits = CControlWinTraits> class CSplitterWindowImpl;
template <bool t_bVertical = true> class CSplitterWindowT;


/////////////////////////////////////////////////////////////////////////////
// CSplitterImpl - Provides splitter support to any window

// Splitter panes constants
#define SPLIT_PANE_LEFT			 0
#define SPLIT_PANE_RIGHT		 1
#define SPLIT_PANE_TOP			 SPLIT_PANE_LEFT
#define SPLIT_PANE_BOTTOM		 SPLIT_PANE_RIGHT
#define SPLIT_PANE_NONE			-1

// Splitter extended styles
#define SPLIT_PROPORTIONAL		0x00000001
#define SPLIT_NONINTERACTIVE		0x00000002


template <class T, bool t_bVertical = true>
class CSplitterImpl
{
public:
	enum { m_nPanesCount = 2, m_nPropMax = 10000 };

	HWND m_hWndPane[m_nPanesCount];
	RECT m_rcSplitter;
	int m_xySplitterPos;
	int m_nDefActivePane;
	int m_cxySplitBar;		// splitter bar width/height
	static HCURSOR m_hCursor;
	int m_cxyMin;			// minimum pane size
	int m_cxyBarEdge;		// splitter bar edge
	bool m_bFullDrag;
	int m_cxyDragOffset;
	int m_nProportionalPos;
	DWORD m_dwExtendedStyle;	// splitter specific extended styles

// Constructor
	CSplitterImpl() :
			m_xySplitterPos(-1), m_nDefActivePane(SPLIT_PANE_NONE), 
			m_cxySplitBar(0), m_cxyMin(0), m_cxyBarEdge(0), m_bFullDrag(true), 
			m_cxyDragOffset(0), m_nProportionalPos(0),
			m_dwExtendedStyle(SPLIT_PROPORTIONAL)
	{
		m_hWndPane[SPLIT_PANE_LEFT] = NULL;
		m_hWndPane[SPLIT_PANE_RIGHT] = NULL;

		::SetRectEmpty(&m_rcSplitter);

		if(m_hCursor == NULL)
		{
			::EnterCriticalSection(&_Module.m_csStaticDataInit);
			if(m_hCursor == NULL)
				m_hCursor = ::LoadCursor(NULL, t_bVertical ? IDC_SIZEWE : IDC_SIZENS);
			::LeaveCriticalSection(&_Module.m_csStaticDataInit);
		}
	}

// Attributes
	void SetSplitterRect(LPRECT lpRect = NULL, bool bUpdate = true)
	{
		if(lpRect == NULL)
		{
			T* pT = static_cast<T*>(this);
			pT->GetClientRect(&m_rcSplitter);
		}
		else
		{
			m_rcSplitter = *lpRect;
		}

		if(IsProportional())
			UpdateProportionalPos();

		if(bUpdate)
			UpdateSplitterLayout();
	}

	void GetSplitterRect(LPRECT lpRect) const
	{
		ATLASSERT(lpRect != NULL);
		*lpRect = m_rcSplitter;
	}

	bool SetSplitterPos(int xyPos = -1, bool bUpdate = true)
	{
		if(xyPos == -1)		// -1 == middle
		{
			if(t_bVertical)
				xyPos = (m_rcSplitter.right - m_rcSplitter.left) / 2;
			else
				xyPos = (m_rcSplitter.bottom - m_rcSplitter.top) / 2;
		}

		// Adjust if out of valid range
		int cxyMax = 0;
		if(t_bVertical)
			cxyMax = m_rcSplitter.right - m_rcSplitter.left;
		else
			cxyMax = m_rcSplitter.bottom - m_rcSplitter.top;

		if(xyPos < m_cxyMin + m_cxyBarEdge)
			xyPos = m_cxyMin;
		else if(xyPos > (cxyMax - m_cxySplitBar - m_cxyBarEdge - m_cxyMin))
			xyPos = cxyMax - m_cxySplitBar - m_cxyBarEdge - m_cxyMin;

		// Set new position and update if requested
		bool bRet = (m_xySplitterPos != xyPos);
		m_xySplitterPos = xyPos;

		if(IsProportional())
			StoreProportionalPos();

		if(bUpdate && bRet)
			UpdateSplitterLayout();

		return bRet;
	}

	int GetSplitterPos() const
	{
		return m_xySplitterPos;
	}

	DWORD GetSplitterExtendedStyle() const
	{
		return m_dwExtendedStyle;
	}

	DWORD SetSplitterExtendedStyle(DWORD dwExtendedStyle)
	{
		DWORD dwPrevStyle = m_dwExtendedStyle;
		m_dwExtendedStyle = dwExtendedStyle;
		return dwPrevStyle;
	}

// Splitter operations
	void SetSplitterPanes(HWND hWndLeftTop, HWND hWndRightBottom, bool bUpdate = true)
	{
		m_hWndPane[SPLIT_PANE_LEFT] = hWndLeftTop;
		m_hWndPane[SPLIT_PANE_RIGHT] = hWndRightBottom;
		ATLASSERT(m_hWndPane[SPLIT_PANE_LEFT] == NULL || m_hWndPane[SPLIT_PANE_RIGHT] == NULL || m_hWndPane[SPLIT_PANE_LEFT] != m_hWndPane[SPLIT_PANE_RIGHT]);
		if(bUpdate)
			UpdateSplitterLayout();
	}

	bool SetSplitterPane(int nPane, HWND hWnd, bool bUpdate = true)
	{
		ATLASSERT(nPane == SPLIT_PANE_LEFT || nPane == SPLIT_PANE_RIGHT);

		if(nPane != SPLIT_PANE_LEFT && nPane != SPLIT_PANE_RIGHT)
			return false;
		m_hWndPane[nPane] = hWnd;
		ATLASSERT(m_hWndPane[SPLIT_PANE_LEFT] == NULL || m_hWndPane[SPLIT_PANE_RIGHT] == NULL || m_hWndPane[SPLIT_PANE_LEFT] != m_hWndPane[SPLIT_PANE_RIGHT]);
		if(bUpdate)
			UpdateSplitterLayout();
		return true;
	}

	HWND GetSplitterPane(int nPane) const
	{
		ATLASSERT(nPane == SPLIT_PANE_LEFT || nPane == SPLIT_PANE_RIGHT);

		if(nPane != SPLIT_PANE_LEFT && nPane != SPLIT_PANE_RIGHT)
			return false;
		return m_hWndPane[nPane];
	}

	bool SetActivePane(int nPane)
	{
		ATLASSERT(nPane == SPLIT_PANE_LEFT || nPane == SPLIT_PANE_RIGHT);

		if(nPane != SPLIT_PANE_LEFT && nPane != SPLIT_PANE_RIGHT)
			return false;
		::SetFocus(m_hWndPane[nPane]);
		m_nDefActivePane = nPane;
		return true;
	}

	int GetActivePane() const
	{
		int nRet = SPLIT_PANE_NONE;
		HWND hWndFocus = ::GetFocus();
		if(hWndFocus != NULL)
		{
			for(int nPane = 0; nPane < m_nPanesCount; nPane++)
			{
				if(hWndFocus == m_hWndPane[nPane])
				{
					nRet = nPane;
					break;
				}
			}
		}
		return nRet;
	}

	bool ActivateNextPane(bool bNext = true)
	{
		int nPane = SPLIT_PANE_NONE;
		switch(GetActivePane())
		{
		case SPLIT_PANE_LEFT:
			nPane = SPLIT_PANE_RIGHT;
			break;
		case SPLIT_PANE_RIGHT:
			nPane = SPLIT_PANE_LEFT;
			break;
		default:
			nPane = bNext ? SPLIT_PANE_LEFT : SPLIT_PANE_RIGHT;
			break;
		}
		return SetActivePane(nPane);
	}

	bool SetDefaultActivePane(int nPane)
	{
		ATLASSERT(nPane == SPLIT_PANE_LEFT || nPane == SPLIT_PANE_RIGHT);

		if(nPane != SPLIT_PANE_LEFT && nPane != SPLIT_PANE_RIGHT)
			return false;
		m_nDefActivePane = nPane;
		return true;
	}

	bool SetDefaultActivePane(HWND hWnd)
	{
		for(int nPane = 0; nPane < m_nPanesCount; nPane++)
		{
			if(hWnd == m_hWndPane[nPane])
			{
				m_nDefActivePane = nPane;
				return true;
			}
		}
		return false;	// not found
	}

	int GetDefaultActivePane() const
	{
		return m_nDefActivePane;
	}

	void DrawSplitter(CDCHandle dc)
	{
		ATLASSERT(dc.m_hDC != NULL);
		if(m_xySplitterPos == -1)
			return;

		T* pT = static_cast<T*>(this);
		pT->DrawSplitterBar(dc);

		for(int nPane = 0; nPane < m_nPanesCount; nPane++)
		{
			if(m_hWndPane[nPane] == NULL)
				pT->DrawSplitterPane(dc, nPane);
		}
	}

// Overrideables
	void DrawSplitterBar(CDCHandle dc)
	{
		RECT rect;
		if(GetSplitterBarRect(&rect))
		{
			dc.FillRect(&rect, (HBRUSH)LongToPtr(COLOR_3DFACE + 1));
			if(m_cxyMin == 0)	// draw 3D edge if needed
				dc.DrawEdge(&rect, EDGE_RAISED, (t_bVertical) ? (BF_LEFT | BF_RIGHT) : (BF_TOP | BF_BOTTOM));
		}
	}

	// called only if pane is empty
	void DrawSplitterPane(CDCHandle dc, int nPane)
	{
		RECT rect;
		if(GetSplitterPaneRect(nPane, &rect))
		{
			T* pT = static_cast<T*>(this);
			if((pT->GetExStyle() & WS_EX_CLIENTEDGE) == 0)
				dc.DrawEdge(&rect, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
			dc.FillRect(&rect, (HBRUSH)LongToPtr(COLOR_APPWORKSPACE + 1));
		}
	}

// Message map and handlers
	typedef CSplitterImpl< T, t_bVertical>	thisClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_CREATE, OnCreate)
		MESSAGE_HANDLER(WM_PAINT, OnPaint)
		MESSAGE_HANDLER(WM_PRINTCLIENT, OnPaint)
		if(IsInteractive())
		{
			MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor)
			MESSAGE_HANDLER(WM_MOUSEMOVE, OnMouseMove)
			MESSAGE_HANDLER(WM_LBUTTONDOWN, OnLButtonDown)
			MESSAGE_HANDLER(WM_LBUTTONUP, OnLButtonUp)
			MESSAGE_HANDLER(WM_LBUTTONDBLCLK, OnLButtonDoubleClick)
		}
		MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
		MESSAGE_HANDLER(WM_MOUSEACTIVATE, OnMouseActivate)
		MESSAGE_HANDLER(WM_SETTINGCHANGE, OnSettingChange)
	END_MSG_MAP()

	LRESULT OnCreate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		GetSystemSettings(false);
		bHandled = FALSE;
		return 1;
	}

	LRESULT OnPaint(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		// try setting position if not set
		if(m_xySplitterPos == -1)
			pT->SetSplitterPos();
		// do painting
		CPaintDC dc(pT->m_hWnd);
		pT->DrawSplitter(dc.m_hDC);
		return 0;
	}

	LRESULT OnSetCursor(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		T* pT = static_cast<T*>(this);
		if((HWND)wParam == pT->m_hWnd && LOWORD(lParam) == HTCLIENT)
		{
			DWORD dwPos = ::GetMessagePos();
			POINT ptPos = { GET_X_LPARAM(dwPos), GET_Y_LPARAM(dwPos) };
			pT->ScreenToClient(&ptPos);
			if(IsOverSplitterBar(ptPos.x, ptPos.y))
				return 1;
		}

		bHandled = FALSE;
		return 0;
	}

	LRESULT OnMouseMove(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		T* pT = static_cast<T*>(this);
		int xPos = GET_X_LPARAM(lParam);
		int yPos = GET_Y_LPARAM(lParam);
		if((wParam & MK_LBUTTON) && ::GetCapture() == pT->m_hWnd)
		{
			int xyNewSplitPos = 0;
			if(t_bVertical)
				xyNewSplitPos = xPos - m_rcSplitter.left - m_cxyDragOffset;
			else
				xyNewSplitPos = yPos - m_rcSplitter.top - m_cxyDragOffset;

			if(xyNewSplitPos == -1)	// avoid -1, that means middle
				xyNewSplitPos = -2;

			if(m_xySplitterPos != xyNewSplitPos)
			{
				if(m_bFullDrag)
				{
					if(pT->SetSplitterPos(xyNewSplitPos, true))
						pT->UpdateWindow();
				}
				else
				{
					DrawGhostBar();
					pT->SetSplitterPos(xyNewSplitPos, false);
					DrawGhostBar();
				}
			}
		}
		else		// not dragging, just set cursor
		{
			if(IsOverSplitterBar(xPos, yPos))
				::SetCursor(m_hCursor);
			bHandled = FALSE;
		}

		return 0;
	}

	LRESULT OnLButtonDown(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
	{
		int xPos = GET_X_LPARAM(lParam);
		int yPos = GET_Y_LPARAM(lParam);
		if(IsOverSplitterBar(xPos, yPos))
		{
			T* pT = static_cast<T*>(this);
			pT->SetCapture();
			::SetCursor(m_hCursor);
			if(!m_bFullDrag)
				DrawGhostBar();
			if(t_bVertical)
				m_cxyDragOffset = xPos - m_rcSplitter.left - m_xySplitterPos;
			else
				m_cxyDragOffset = yPos - m_rcSplitter.top - m_xySplitterPos;
		}
		bHandled = FALSE;
		return 1;
	}

	LRESULT OnLButtonUp(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		if(!m_bFullDrag)
		{
			DrawGhostBar();
			T* pT = static_cast<T*>(this);
			UpdateSplitterLayout();
			pT->UpdateWindow();
		}
		::ReleaseCapture();
		bHandled = FALSE;
		return 1;
	}

	LRESULT OnLButtonDoubleClick(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		pT->SetSplitterPos();	// middle
		return 0;
	}

	LRESULT OnSetFocus(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM, BOOL& bHandled)
	{
		if(m_nDefActivePane == SPLIT_PANE_LEFT || m_nDefActivePane == SPLIT_PANE_RIGHT)
			::SetFocus(m_hWndPane[m_nDefActivePane]);
		bHandled = FALSE;
		return 1;
	}

	LRESULT OnMouseActivate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		LRESULT lRet = pT->DefWindowProc(uMsg, wParam, lParam);
		if(lRet == MA_ACTIVATE || lRet == MA_ACTIVATEANDEAT)
		{
			DWORD dwPos = ::GetMessagePos();
			POINT pt = { GET_X_LPARAM(dwPos), GET_Y_LPARAM(dwPos) };
			pT->ScreenToClient(&pt);
			RECT rcPane;
			for(int nPane = 0; nPane < m_nPanesCount; nPane++)
			{
				if(GetSplitterPaneRect(nPane, &rcPane) && ::PtInRect(&rcPane, pt))
				{
					m_nDefActivePane = nPane;
					break;
				}
			}
		}
		return lRet;
	}

	LRESULT OnSettingChange(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		GetSystemSettings(true);
		return 0;
	}

// Implementation - internal helpers
	void UpdateSplitterLayout()
	{
		if(m_xySplitterPos == -1)
			return;

		T* pT = static_cast<T*>(this);
		RECT rect = { 0, 0, 0, 0 };
		if(GetSplitterBarRect(&rect))
			pT->InvalidateRect(&rect);

		for(int nPane = 0; nPane < m_nPanesCount; nPane++)
		{
			if(GetSplitterPaneRect(nPane, &rect))
			{
				if(m_hWndPane[nPane] != NULL)
					::SetWindowPos(m_hWndPane[nPane], NULL, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, SWP_NOZORDER);
				else
					pT->InvalidateRect(&rect);
			}
		}
	}

	bool GetSplitterBarRect(LPRECT lpRect) const
	{
		ATLASSERT(lpRect != NULL);
		if(m_xySplitterPos == -1)
			return false;

		if(t_bVertical)
		{
			lpRect->left = m_rcSplitter.left + m_xySplitterPos;
			lpRect->top = m_rcSplitter.top;
			lpRect->right = m_rcSplitter.left + m_xySplitterPos + m_cxySplitBar + m_cxyBarEdge;
			lpRect->bottom = m_rcSplitter.bottom;
		}
		else
		{
			lpRect->left = m_rcSplitter.left;
			lpRect->top = m_rcSplitter.top + m_xySplitterPos;
			lpRect->right = m_rcSplitter.right;
			lpRect->bottom = m_rcSplitter.top + m_xySplitterPos + m_cxySplitBar + m_cxyBarEdge;
		}

		return true;
	}

	bool GetSplitterPaneRect(int nPane, LPRECT lpRect) const
	{
		ATLASSERT(nPane == SPLIT_PANE_LEFT || nPane == SPLIT_PANE_RIGHT);
		ATLASSERT(lpRect != NULL);
		bool bRet = true;
		if(nPane == SPLIT_PANE_LEFT)
		{
			if(t_bVertical)
			{
				lpRect->left = m_rcSplitter.left;
				lpRect->top = m_rcSplitter.top;
				lpRect->right = m_rcSplitter.left + m_xySplitterPos;
				lpRect->bottom = m_rcSplitter.bottom;
			}
			else
			{
				lpRect->left = m_rcSplitter.left;
				lpRect->top = m_rcSplitter.top;
				lpRect->right = m_rcSplitter.right;
				lpRect->bottom = m_rcSplitter.top + m_xySplitterPos;
			}
		}	
		else if(nPane == SPLIT_PANE_RIGHT)
		{
			if(t_bVertical)
			{
				lpRect->left = m_rcSplitter.left + m_xySplitterPos + m_cxySplitBar + m_cxyBarEdge;
				lpRect->top = m_rcSplitter.top;
				lpRect->right = m_rcSplitter.right;
				lpRect->bottom = m_rcSplitter.bottom;
			}
			else
			{
				lpRect->left = m_rcSplitter.left;
				lpRect->top = m_rcSplitter.top + m_xySplitterPos + m_cxySplitBar + m_cxyBarEdge;
				lpRect->right = m_rcSplitter.right;
				lpRect->bottom = m_rcSplitter.bottom;
			}
		}
		else
		{
			bRet = false;
		}
		return bRet;
	}

	bool IsOverSplitterRect(int x, int y) const
	{
		// -1 == don't check
		return ((x == -1 || (x >= m_rcSplitter.left && x <= m_rcSplitter.right)) &&
			(y == -1 || (y >= m_rcSplitter.top && y <= m_rcSplitter.bottom)));
	}

	bool IsOverSplitterBar(int x, int y) const
	{
		if(m_xySplitterPos == -1 || !IsOverSplitterRect(x, y))
			return false;
		int xy = (t_bVertical) ? x : y;
		int xyOff = (t_bVertical) ? m_rcSplitter.left : m_rcSplitter.top;
		return ((xy >= (xyOff + m_xySplitterPos)) && (xy < xyOff + m_xySplitterPos + m_cxySplitBar + m_cxyBarEdge));
	}

	void DrawGhostBar()
	{
		RECT rect = { 0, 0, 0, 0 };
		if(GetSplitterBarRect(&rect))
		{
			// invert the brush pattern (looks just like frame window sizing)
			T* pT = static_cast<T*>(this);
			CWindowDC dc(pT->m_hWnd);
			CBrush brush = CDCHandle::GetHalftoneBrush();
			if(brush.m_hBrush != NULL)
			{
				CBrushHandle brushOld = dc.SelectBrush(brush);
				dc.PatBlt(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, PATINVERT);
				dc.SelectBrush(brushOld);
			}
		}
	}

	void GetSystemSettings(bool bUpdate)
	{
		m_cxySplitBar = ::GetSystemMetrics(t_bVertical ? SM_CXSIZEFRAME : SM_CYSIZEFRAME);

		T* pT = static_cast<T*>(this);
		if((pT->GetExStyle() & WS_EX_CLIENTEDGE))
		{
			m_cxyBarEdge = 2 * ::GetSystemMetrics(t_bVertical ? SM_CXEDGE : SM_CYEDGE);
			m_cxyMin = 0;
		}
		else
		{
			m_cxyBarEdge = 0;
			m_cxyMin = 2 * ::GetSystemMetrics(t_bVertical ? SM_CXEDGE : SM_CYEDGE);
		}

		::SystemParametersInfo(SPI_GETDRAGFULLWINDOWS, 0, &m_bFullDrag, 0);

		if(bUpdate)
			UpdateSplitterLayout();
	}

	bool IsProportional() const
	{
		return (m_dwExtendedStyle & SPLIT_PROPORTIONAL) != 0;
	}

	void StoreProportionalPos()
	{
		int cxyTotal = t_bVertical ? (m_rcSplitter.right - m_rcSplitter.left) : (m_rcSplitter.bottom - m_rcSplitter.top);
		if(cxyTotal > 0)
			m_nProportionalPos = ::MulDiv(m_xySplitterPos, m_nPropMax, cxyTotal);
		else
			m_nProportionalPos = 0;
	}

	void UpdateProportionalPos()
	{
		int cxyTotal = t_bVertical ? (m_rcSplitter.right - m_rcSplitter.left) : (m_rcSplitter.bottom - m_rcSplitter.top);
		if(cxyTotal > 0)
		{
			int xyNewPos = ::MulDiv(m_nProportionalPos, cxyTotal, m_nPropMax);
			T* pT = static_cast<T*>(this);
			pT->SetSplitterPos(xyNewPos, false);
		}
	}

	bool IsInteractive() const
	{
		return !(m_dwExtendedStyle & SPLIT_NONINTERACTIVE);
	}
};

template <class T, bool t_bVertical> HCURSOR CSplitterImpl< T, t_bVertical>::m_hCursor = NULL;


/////////////////////////////////////////////////////////////////////////////
// CSplitterWindowImpl - Implements a splitter window

template <class T, bool t_bVertical = true, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class ATL_NO_VTABLE CSplitterWindowImpl : public CWindowImpl< T, TBase, TWinTraits >, public CSplitterImpl<CSplitterWindowImpl< T , t_bVertical, TBase, TWinTraits >, t_bVertical>
{
public:
	DECLARE_WND_CLASS_EX(NULL, CS_DBLCLKS, COLOR_WINDOW)

	typedef CSplitterWindowImpl< T , t_bVertical, TBase, TWinTraits >				thisClass;
	typedef CSplitterImpl<CSplitterWindowImpl< T , t_bVertical, TBase, TWinTraits >, t_bVertical>	baseClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBackground)
		MESSAGE_HANDLER(WM_SIZE, OnSize)
		CHAIN_MSG_MAP(baseClass)
		FORWARD_NOTIFICATIONS()
	END_MSG_MAP()

	LRESULT OnEraseBackground(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		// handled, no background painting needed
		return 1;
	}

	LRESULT OnSize(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
		if(wParam != SIZE_MINIMIZED)
			SetSplitterRect();

		bHandled = FALSE;
		return 1;
	}
};


/////////////////////////////////////////////////////////////////////////////
// CSplitterWindow - Implements a splitter window to be used as is

template <bool t_bVertical = true>
class CSplitterWindowT : public CSplitterWindowImpl<CSplitterWindowT<t_bVertical>, t_bVertical>
{
public:
	DECLARE_WND_CLASS_EX(_T("WTL_SplitterWindow"), CS_DBLCLKS, COLOR_WINDOW)
};

typedef CSplitterWindowT<true>	CSplitterWindow;
typedef CSplitterWindowT<false>	CHorSplitterWindow;

}; //namespace WTL

#endif // __ATLSPLIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\atlres.h ===
// WTL Version 3.0
// Copyright (C) 1997-1999 Microsoft Corporation
// All rights reserved.
//
// This file is a part of Windows Template Library.
// The code and information is provided "as-is" without
// warranty of any kind, either expressed or implied.

#ifndef __ATLRES_H__
#define __ATLRES_H__

#pragma once

#ifdef RC_INVOKED
#ifndef _INC_WINDOWS
#define _INC_WINDOWS

#define VS_VERSION_INFO     1

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS // Ignore following symbols
#endif //APSTUDIO_INVOKED

#ifndef WINVER
#define WINVER 0x0400   // default to Windows Version 4.0
#endif //!WINVER

#include <winresrc.h>

// operation messages sent to DLGINIT
#define LB_ADDSTRING    (WM_USER+1)
#define CB_ADDSTRING    (WM_USER+3)

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif //APSTUDIO_INVOKED

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif //IDC_STATIC
#define IDC_STATIC      (-1)

#endif //!_INC_WINDOWS
#endif //RC_INVOKED

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS
#endif //APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// ATL resource types

#ifndef RC_INVOKED
#define RT_DLGINIT  MAKEINTRESOURCE(240)
#define RT_TOOLBAR  MAKEINTRESOURCE(241)
#endif //RC_INVOKED

/////////////////////////////////////////////////////////////////////////////

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif //APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard window components

#define ID_SEPARATOR                    0       // special separator value

#ifndef RC_INVOKED  // code only
// standard control bars (IDW = window ID)
#define ATL_IDW_COMMAND_BAR             0xE800  // Command bar window
#define ATL_IDW_STATUS_BAR              0xE801  // Status bar window
#define ATL_IDW_TOOLBAR                 0xE802  // main Toolbar for window

// parts of a frame window
#define ATL_IDW_CLIENT                  0xE900
#define ATL_IDW_PANE_FIRST              0xE900  // first pane (256 max)
#define ATL_IDW_PANE_LAST               0xE9FF
#define ATL_IDW_HSCROLL_FIRST           0xEA00  // first Horz scrollbar (16 max)
#define ATL_IDW_VSCROLL_FIRST           0xEA10  // first Vert scrollbar (16 max)

#define ATL_IDW_SIZE_BOX                0xEA20  // size box for splitters
#define ATL_IDW_PANE_SAVE               0xEA21  // to shift ATL_IDW_PANE_FIRST

// bands for a rebar
#define ATL_IDW_BAND_FIRST		0xEB00
#define ATL_IDW_BAND_LAST		0xEBFF
#endif //!RC_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard Commands

// File commands
#define ID_FILE_NEW                     0xE100
#define ID_FILE_OPEN                    0xE101
#define ID_FILE_CLOSE                   0xE102
#define ID_FILE_SAVE                    0xE103
#define ID_FILE_SAVE_AS                 0xE104
#define ID_FILE_PAGE_SETUP              0xE105
#define ID_FILE_PRINT_SETUP             0xE106
#define ID_FILE_PRINT                   0xE107
#define ID_FILE_PRINT_DIRECT            0xE108
#define ID_FILE_PRINT_PREVIEW           0xE109
#define ID_FILE_UPDATE                  0xE10A
#define ID_FILE_SAVE_COPY_AS            0xE10B
#define ID_FILE_SEND_MAIL               0xE10C

#define ID_FILE_MRU_FIRST               0xE110
#define ID_FILE_MRU_FILE1               0xE110          // range - 16 max
#define ID_FILE_MRU_FILE2               0xE111
#define ID_FILE_MRU_FILE3               0xE112
#define ID_FILE_MRU_FILE4               0xE113
#define ID_FILE_MRU_FILE5               0xE114
#define ID_FILE_MRU_FILE6               0xE115
#define ID_FILE_MRU_FILE7               0xE116
#define ID_FILE_MRU_FILE8               0xE117
#define ID_FILE_MRU_FILE9               0xE118
#define ID_FILE_MRU_FILE10              0xE119
#define ID_FILE_MRU_FILE11              0xE11A
#define ID_FILE_MRU_FILE12              0xE11B
#define ID_FILE_MRU_FILE13              0xE11C
#define ID_FILE_MRU_FILE14              0xE11D
#define ID_FILE_MRU_FILE15              0xE11E
#define ID_FILE_MRU_FILE16              0xE11F
#define ID_FILE_MRU_LAST                0xE11F

// Edit commands
#define ID_EDIT_CLEAR                   0xE120
#define ID_EDIT_CLEAR_ALL               0xE121
#define ID_EDIT_COPY                    0xE122
#define ID_EDIT_CUT                     0xE123
#define ID_EDIT_FIND                    0xE124
#define ID_EDIT_PASTE                   0xE125
#define ID_EDIT_PASTE_LINK              0xE126
#define ID_EDIT_PASTE_SPECIAL           0xE127
#define ID_EDIT_REPEAT                  0xE128
#define ID_EDIT_REPLACE                 0xE129
#define ID_EDIT_SELECT_ALL              0xE12A
#define ID_EDIT_UNDO                    0xE12B
#define ID_EDIT_REDO                    0xE12C

// Window commands
#define ID_WINDOW_NEW                   0xE130
#define ID_WINDOW_ARRANGE               0xE131
#define ID_WINDOW_CASCADE               0xE132
#define ID_WINDOW_TILE_HORZ             0xE133
#define ID_WINDOW_TILE_VERT             0xE134
#define ID_WINDOW_SPLIT                 0xE135
#ifndef RC_INVOKED      // code only
#define ATL_IDM_WINDOW_FIRST            0xE130
#define ATL_IDM_WINDOW_LAST             0xE13F
#define ATL_IDM_FIRST_MDICHILD          0xFF00  // window list starts here
#endif //!RC_INVOKED

// Help and App commands
#define ID_APP_ABOUT                    0xE140
#define ID_APP_EXIT                     0xE141
#define ID_HELP_INDEX                   0xE142
#define ID_HELP_FINDER                  0xE143
#define ID_HELP_USING                   0xE144
#define ID_CONTEXT_HELP                 0xE145      // shift-F1
// special commands for processing help
#define ID_HELP                         0xE146      // first attempt for F1
#define ID_DEFAULT_HELP                 0xE147      // last attempt

// Misc
#define ID_NEXT_PANE                    0xE150
#define ID_PREV_PANE                    0xE151

// Format
#define ID_FORMAT_FONT                  0xE160

// Scroll
#define ID_SCROLL_UP                    0xE170
#define ID_SCROLL_DOWN                  0xE171
#define ID_SCROLL_PAGE_UP               0xE172
#define ID_SCROLL_PAGE_DOWN             0xE173
#define ID_SCROLL_TOP                   0xE174
#define ID_SCROLL_BOTTOM                0xE175
#define ID_SCROLL_LEFT                  0xE176
#define ID_SCROLL_RIGHT                 0xE177
#define ID_SCROLL_PAGE_LEFT             0xE178
#define ID_SCROLL_PAGE_RIGHT            0xE179
#define ID_SCROLL_ALL_LEFT              0xE17A
#define ID_SCROLL_ALL_RIGHT             0xE17B

// OLE commands
#define ID_OLE_INSERT_NEW               0xE200
#define ID_OLE_EDIT_LINKS               0xE201
#define ID_OLE_EDIT_CONVERT             0xE202
#define ID_OLE_EDIT_CHANGE_ICON         0xE203
#define ID_OLE_EDIT_PROPERTIES          0xE204
#define ID_OLE_VERB_FIRST               0xE210     // range - 16 max
#ifndef RC_INVOKED      // code only
#define ID_OLE_VERB_LAST                0xE21F
#endif //!RC_INVOKED

// View commands (same number used as IDW used for toolbar and status bar)
#define ID_VIEW_TOOLBAR                 0xE801
#define ID_VIEW_STATUS_BAR              0xE802
#define ID_VIEW_REFRESH			0xE803

/////////////////////////////////////////////////////////////////////////////
// Standard control IDs

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif //IDC_STATIC
#define IDC_STATIC              (-1)     // all static controls

/////////////////////////////////////////////////////////////////////////////
// Standard string error/warnings

// idle status bar message
#define ATL_IDS_IDLEMESSAGE             0xE001

#ifndef RC_INVOKED      // code only
#define ATL_IDS_SCFIRST                 0xEF00
#endif //!RC_INVOKED

#define ATL_IDS_SCSIZE                  0xEF00
#define ATL_IDS_SCMOVE                  0xEF01
#define ATL_IDS_SCMINIMIZE              0xEF02
#define ATL_IDS_SCMAXIMIZE              0xEF03
#define ATL_IDS_SCNEXTWINDOW            0xEF04
#define ATL_IDS_SCPREVWINDOW            0xEF05
#define ATL_IDS_SCCLOSE                 0xEF06
#define ATL_IDS_SCRESTORE               0xEF12
#define ATL_IDS_SCTASKLIST              0xEF13

#define ATL_IDS_MDICHILD                0xEF1F
#define ATL_IDS_MRU_FILE                0xEFDA

/////////////////////////////////////////////////////////////////////////////
// Misc. control IDs

// Property Sheet control id's (determined with Spy++)
#define ID_APPLY_NOW                    0x3021
#define ID_WIZBACK                      0x3023
#define ID_WIZNEXT                      0x3024
#define ID_WIZFINISH                    0x3025
#define ATL_IDC_TAB_CONTROL             0x3020


#endif //__ATLRES_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\enumerator.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					Enumerator.h
//
//	Abstract:
//
//					declaration of enumerator module
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__ENUMERATOR_H__
#define	__ENUMERATOR_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// common enumerator stuff
#include "_enum.h"

class CEnumerator
{
	DECLARE_NO_COPY ( CEnumerator );

	// locator
	IWbemLocator*	m_pLocator;
	MyEnum			m_enum;

	public:

	CEnumerator ( IWbemLocator * pLocator )
	{
		if ( pLocator )
		{
			( m_pLocator = pLocator ) -> AddRef () ;
		}
	}

	virtual ~CEnumerator ()
	{
		try
		{
			if ( m_pLocator )
			{
				m_pLocator->Release();
			}
		}
		catch ( ... )
		{
		}

		m_pLocator = NULL;
	}

	HRESULT	Init ( LPWSTR wszNamespace, LPWSTR wszClassName ) ;
	HRESULT	Init ( LPWSTR wszNamespace, LPWSTR wszQueryLang, LPWSTR wszQuery ) ;

	HRESULT	Next (	DWORD* pdwProperties,
					LPWSTR** ppProperties,
					CIMTYPE** ppPropertiesTypes,
					LPWSTR* pPropNeedNot = NULL,
					DWORD dwPropNeedNot = NULL,
					LONG		lFlags = WBEM_FLAG_LOCAL_ONLY | WBEM_FLAG_NONSYSTEM_ONLY
				 ); 

	LPWSTR* Get ( LPWSTR wszName, DWORD* dwSize = NULL );
	LPWSTR* Get ( LPWSTR wszNamespace, LPWSTR wszClassName, LPWSTR wszName, DWORD* dwSize = NULL );
	LPWSTR* Get ( LPWSTR wszNamespace, LPWSTR wszQueryLang, LPWSTR wszQuery, LPWSTR wszName, DWORD* dwSize = NULL );
};

#endif	__ENUMERATOR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\module.h ===
#ifndef	_MODULE_H_
#define	_MODULE_H_

#include "..\NonCOMEvent\resource.h"

class ATL_NO_VTABLE CModuleScalar : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CModuleScalar, &CLSID_ModuleScalar>,
	public ICimModule
{
public:

	CModuleScalar();
	~CModuleScalar();

	DECLARE_REGISTRY_RESOURCEID(IDR_NonCOMEvent_Module)

	BEGIN_COM_MAP(CModuleScalar)
	COM_INTERFACE_ENTRY(ICimModule)
	END_COM_MAP()

	//IDispatch methods not supported
	//===============================
	STDMETHODIMP GetTypeInfoCount(UINT *)
	{return E_NOTIMPL;}
	STDMETHODIMP GetTypeInfo(UINT, LCID, ITypeInfo **)
	{return E_NOTIMPL;}
	STDMETHODIMP GetIDsOfNames(REFIID, LPOLESTR*, UINT, LCID, DISPID*)
	{return E_NOTIMPL;}
	STDMETHODIMP Invoke(DISPID, REFIID, LCID, WORD, DISPPARAMS*, VARIANT *, EXCEPINFO*, UINT*)
	{return E_NOTIMPL;}

	//ICimModule methods
	//==================
	STDMETHODIMP Start(VARIANT* pvarInitOp, IUnknown* pIUnknown);
	STDMETHODIMP Pause(void);
	STDMETHODIMP Terminate(void);
	STDMETHODIMP BonusMethod(void);


	bool m_bShouldExit;
	bool m_bShouldPause;
	ICimNotify *m_pCimNotify;
	BSTR m_bstrParams;

protected:
	void ParseParams(VARIANT *);
};

class ATL_NO_VTABLE CModuleArray : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CModuleArray, &CLSID_ModuleArray>,
	public ICimModule
{
public:

	CModuleArray();
	~CModuleArray();

	DECLARE_REGISTRY_RESOURCEID(IDR_NonCOMEvent_Module)

	BEGIN_COM_MAP(CModuleArray)
	COM_INTERFACE_ENTRY(ICimModule)
	END_COM_MAP()

	//IDispatch methods not supported
	//===============================
	STDMETHODIMP GetTypeInfoCount(UINT *)
	{return E_NOTIMPL;}
	STDMETHODIMP GetTypeInfo(UINT, LCID, ITypeInfo **)
	{return E_NOTIMPL;}
	STDMETHODIMP GetIDsOfNames(REFIID, LPOLESTR*, UINT, LCID, DISPID*)
	{return E_NOTIMPL;}
	STDMETHODIMP Invoke(DISPID, REFIID, LCID, WORD, DISPPARAMS*, VARIANT *, EXCEPINFO*, UINT*)
	{return E_NOTIMPL;}

	//ICimModule methods
	//==================
	STDMETHODIMP Start(VARIANT* pvarInitOp, IUnknown* pIUnknown);
	STDMETHODIMP Pause(void);
	STDMETHODIMP Terminate(void);
	STDMETHODIMP BonusMethod(void);


	bool m_bShouldExit;
	bool m_bShouldPause;
	ICimNotify *m_pCimNotify;
	BSTR m_bstrParams;

protected:
	void ParseParams(VARIANT *);
};

class ATL_NO_VTABLE CModuleGeneric : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CModuleGeneric, &CLSID_ModuleGeneric>,
	public ICimModule
{
public:

	CModuleGeneric();
	~CModuleGeneric();

	DECLARE_REGISTRY_RESOURCEID(IDR_NonCOMEvent_Module)

	BEGIN_COM_MAP(CModuleGeneric)
	COM_INTERFACE_ENTRY(ICimModule)
	END_COM_MAP()

	//IDispatch methods not supported
	//===============================
	STDMETHODIMP GetTypeInfoCount(UINT *)
	{return E_NOTIMPL;}
	STDMETHODIMP GetTypeInfo(UINT, LCID, ITypeInfo **)
	{return E_NOTIMPL;}
	STDMETHODIMP GetIDsOfNames(REFIID, LPOLESTR*, UINT, LCID, DISPID*)
	{return E_NOTIMPL;}
	STDMETHODIMP Invoke(DISPID, REFIID, LCID, WORD, DISPPARAMS*, VARIANT *, EXCEPINFO*, UINT*)
	{return E_NOTIMPL;}

	//ICimModule methods
	//==================
	STDMETHODIMP Start(VARIANT* pvarInitOp, IUnknown* pIUnknown);
	STDMETHODIMP Pause(void);
	STDMETHODIMP Terminate(void);
	STDMETHODIMP BonusMethod(void);


	bool m_bShouldExit;
	bool m_bShouldPause;
	ICimNotify *m_pCimNotify;
	BSTR m_bstrParams;

protected:
	void ParseParams(VARIANT *);
};

#endif	_MODULE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\noncomeventaboutdlg.h ===
// NonCOMEventAboutDlg.h : Declaration of the CNonCOMEventAboutDlg

#ifndef __NONCOMEVENTABOUTDLG_H_
#define __NONCOMEVENTABOUTDLG_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CNonCOMEventAboutDlg
class CNonCOMEventAboutDlg : 

	public CDialogImpl<CNonCOMEventAboutDlg>,
	public CMessageFilter
{
	public:

	CNonCOMEventAboutDlg()
	{
	}

	~CNonCOMEventAboutDlg()
	{
	}

	enum { IDD = IDD_ABOUTBOX };

	virtual BOOL PreTranslateMessage(MSG* pMsg)
	{
		return ::IsDialogMessage(m_hWnd, pMsg);
	}

	BEGIN_MSG_MAP(CNonCOMEventAboutDlg)

		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		COMMAND_ID_HANDLER(IDOK, OnCloseCmd)

	END_MSG_MAP()

	LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		CenterWindow(GetParent());

		// set icons
		HICON hIcon = (HICON)::LoadImage(	_Module.GetResourceInstance(),
											MAKEINTRESOURCE(IDR_MAINFRAME), 
											IMAGE_ICON,
											::GetSystemMetrics(SM_CXICON),
											::GetSystemMetrics(SM_CYICON),
											LR_DEFAULTCOLOR
										);
		SetIcon(hIcon, TRUE);

		HICON hIconSmall = (HICON)::LoadImage(	_Module.GetResourceInstance(),
												MAKEINTRESOURCE(IDR_MAINFRAME), 
												IMAGE_ICON,
												::GetSystemMetrics(SM_CXSMICON),
												::GetSystemMetrics(SM_CYSMICON),
												LR_DEFAULTCOLOR
											 );
		SetIcon(hIconSmall, FALSE);

		return TRUE;
	}

	LRESULT OnCloseCmd(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		EndDialog(wID);
		return 0;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CNonCOMEventCommonListDlg
class CNonCOMEventCommonListDlg : 

	public CDialogImpl<CNonCOMEventCommonListDlg>,
	public CMessageFilter
{

	__WrapperARRAY < LPWSTR > m_results;

	CComBSTR	m_namespace;
	CListBox*	m_plb;

	CComBSTR	m_CurrentSelect;

	public:

	CNonCOMEventCommonListDlg(	IWbemLocator* pLocator,
								LPWSTR wszNamespace,
								LPWSTR wszQueryLang,
								LPWSTR wszQuery,
								LPWSTR wszName
							 );

	CNonCOMEventCommonListDlg(	IWbemLocator* pLocator,
								LPWSTR wszNamespace,
								LPWSTR wszClassName,
								LPWSTR wszName
							 );

	~CNonCOMEventCommonListDlg()
	{
		if ( m_plb )
		{
			delete m_plb;
			m_plb = NULL;
		}
	}

	enum { IDD = IDD_COMMON_LIST };

	LPWSTR GetNamespace ()
	{
		CComBSTR result;

		if ( m_CurrentSelect.Length ( ) != 0 )
		{
			result.AppendBSTR ( m_namespace );
			result.AppendBSTR ( m_CurrentSelect );
		}

		return result;
	}

	LPWSTR GetSelected ()
	{
		return m_CurrentSelect;
	}

	virtual BOOL PreTranslateMessage(MSG* pMsg)
	{
		return ::IsDialogMessage(m_hWnd, pMsg);
	}

	BEGIN_MSG_MAP(CNonCOMEventCommonListDlg)

		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)

		COMMAND_ID_HANDLER(IDOK, OnCloseCmd)
		COMMAND_ID_HANDLER(IDCANCEL, OnCloseCmd)

	END_MSG_MAP()

	LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/);
	LRESULT OnCloseCmd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
};

#endif //__NONCOMEVENTABOUTDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\atluser.h ===
// WTL Version 3.0
// Copyright (C) 1997-1999 Microsoft Corporation
// All rights reserved.
//
// This file is a part of Windows Template Library.
// The code and information is provided "as-is" without
// warranty of any kind, either expressed or implied.

#ifndef __ATLUSER_H__
#define __ATLUSER_H__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLBASE_H__
	#error atluser.h requires atlbase.h to be included first
#endif


namespace WTL
{

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

class CMenuItemInfo;
template <bool t_bManaged> class CMenuT;


/////////////////////////////////////////////////////////////////////////////
// CMenu

class CMenuItemInfo : public MENUITEMINFO
{
public:
	CMenuItemInfo()
	{
		memset(this, 0, sizeof(MENUITEMINFO));
		cbSize = sizeof(MENUITEMINFO);
	}
};

typedef CMenuT<false>		CMenuHandle;
typedef CMenuT<true>		CMenu;

template <bool t_bManaged>
class CMenuT
{
public:
// Data members
	HMENU m_hMenu;

// Constructor/destructor/operators
	CMenuT(HMENU hMenu = NULL) : m_hMenu(hMenu)
	{ }

	~CMenuT()
	{
		if(t_bManaged && m_hMenu != NULL)
			DestroyMenu();
	}

	CMenuT<t_bManaged>& operator=(HMENU hMenu)
	{
		m_hMenu = hMenu;
		return *this;
	}

	void Attach(HMENU hMenuNew)
	{
		ATLASSERT(::IsMenu(hMenuNew));
		m_hMenu = hMenuNew;
	}

	HMENU Detach()
	{
		HMENU hMenu = m_hMenu;
		m_hMenu = NULL;
		return hMenu;
	}

	operator HMENU() const { return m_hMenu; }

// Create and load methods
	BOOL CreateMenu()
	{
		ATLASSERT(m_hMenu == NULL);
		m_hMenu = ::CreateMenu();
		return (m_hMenu != NULL) ? TRUE : FALSE;
	}
	BOOL CreatePopupMenu()
	{
		ATLASSERT(m_hMenu == NULL);
		m_hMenu = ::CreatePopupMenu();
		return (m_hMenu != NULL) ? TRUE : FALSE;
	}
	BOOL LoadMenu(_U_STRINGorID menu)
	{
		ATLASSERT(m_hMenu == NULL);
		m_hMenu = ::LoadMenu(_Module.GetResourceInstance(), menu.m_lpstr);
		return (m_hMenu != NULL) ? TRUE : FALSE;
	}
	BOOL LoadMenuIndirect(const void* lpMenuTemplate)
	{
		ATLASSERT(m_hMenu == NULL);
		m_hMenu = ::LoadMenuIndirect(lpMenuTemplate);
		return (m_hMenu != NULL) ? TRUE : FALSE;
	}
	BOOL DestroyMenu()
	{
		if (m_hMenu == NULL)
			return FALSE;
		return ::DestroyMenu(Detach());
	}

// Menu Operations
	BOOL DeleteMenu(UINT nPosition, UINT nFlags)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::DeleteMenu(m_hMenu, nPosition, nFlags);
	}
	BOOL TrackPopupMenu(UINT nFlags, int x, int y, HWND hWnd, LPCRECT lpRect = NULL)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::TrackPopupMenu(m_hMenu, nFlags, x, y, 0, hWnd, lpRect);
	}
	BOOL TrackPopupMenuEx(UINT uFlags, int x, int y, HWND hWnd, LPTPMPARAMS lptpm = NULL)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::TrackPopupMenuEx(m_hMenu, uFlags, x, y, hWnd, lptpm);
	}

// Menu Item Operations
	BOOL AppendMenu(UINT nFlags, UINT nIDNewItem = 0, LPCTSTR lpszNewItem = NULL)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::AppendMenu(m_hMenu, nFlags, nIDNewItem, lpszNewItem);
	}
	BOOL AppendMenu(UINT nFlags, UINT nIDNewItem, HBITMAP hBmp)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::AppendMenu(m_hMenu, nFlags | MF_BITMAP, nIDNewItem, (LPCTSTR)hBmp);
	}
	UINT CheckMenuItem(UINT nIDCheckItem, UINT nCheck)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return (UINT)::CheckMenuItem(m_hMenu, nIDCheckItem, nCheck);
	}
	UINT EnableMenuItem(UINT nIDEnableItem, UINT nEnable)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::EnableMenuItem(m_hMenu, nIDEnableItem, nEnable);
	}
	int GetMenuItemCount() const
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::GetMenuItemCount(m_hMenu);
	}
	UINT GetMenuItemID(int nPos) const
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::GetMenuItemID(m_hMenu, nPos);
	}
	UINT GetMenuState(UINT nID, UINT nFlags) const
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::GetMenuState(m_hMenu, nID, nFlags);
	}
	int GetMenuString(UINT nIDItem, LPTSTR lpString, int nMaxCount, UINT nFlags) const
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::GetMenuString(m_hMenu, nIDItem, lpString, nMaxCount, nFlags);
	}
	int GetMenuStringLen(UINT nIDItem, UINT nFlags) const
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::GetMenuString(m_hMenu, nIDItem, NULL, 0, nFlags);
	}
#ifndef _ATL_NO_COM
	BOOL GetMenuString(UINT nIDItem, BSTR& bstrText, UINT nFlags) const
	{
		USES_CONVERSION;
		ATLASSERT(::IsMenu(m_hMenu));
		ATLASSERT(bstrText == NULL);

		int nLen = GetMenuStringLen(nIDItem, nFlags);
		if(nLen == 0)
		{
			bstrText = ::SysAllocString(OLESTR(""));
			return (bstrText != NULL) ? TRUE : FALSE;
		}

		LPTSTR lpszText = (LPTSTR)_alloca((nLen + 1) * sizeof(TCHAR));

		if(!GetMenuString(nIDItem, lpszText, nLen, nFlags))
			return FALSE;

		bstrText = ::SysAllocString(T2OLE(lpszText));
		return (bstrText != NULL) ? TRUE : FALSE;
	}
#endif //!_ATL_NO_COM
#ifdef __ATLSTR_H__
	int GetMenuString(UINT nIDItem, CString& strText, UINT nFlags) const
	{
		ATLASSERT(::IsMenu(m_hMenu));

		int nLen = GetMenuStringLen(nIDItem, nFlags);
		if(nLen == 0)
			return 0;

		int nRet = GetMenuString(nIDItem, strText.GetBufferSetLength(nLen), nLen);
		strText.ReleaseBuffer();
		return nRet;
	}
#endif //__ATLSTR_H__
	CMenuHandle GetSubMenu(int nPos) const
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return CMenuHandle(::GetSubMenu(m_hMenu, nPos));
	}
	BOOL InsertMenu(UINT nPosition, UINT nFlags, UINT nIDNewItem = 0, LPCTSTR lpszNewItem = NULL)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::InsertMenu(m_hMenu, nPosition, nFlags, nIDNewItem, lpszNewItem);
	}
	BOOL InsertMenu(UINT nPosition, UINT nFlags, UINT nIDNewItem, HBITMAP hBmp)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::InsertMenu(m_hMenu, nPosition, nFlags | MF_BITMAP, nIDNewItem, (LPCTSTR)hBmp);
	}
	BOOL ModifyMenu(UINT nPosition, UINT nFlags, UINT nIDNewItem = 0, LPCTSTR lpszNewItem = NULL)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::ModifyMenu(m_hMenu, nPosition, nFlags, nIDNewItem, lpszNewItem);
	}
	BOOL ModifyMenu(UINT nPosition, UINT nFlags, UINT nIDNewItem, HBITMAP hBmp)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::ModifyMenu(m_hMenu, nPosition, nFlags | MF_BITMAP, nIDNewItem, (LPCTSTR)hBmp);
	}
	BOOL RemoveMenu(UINT nPosition, UINT nFlags)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::RemoveMenu(m_hMenu, nPosition, nFlags);
	}
	BOOL SetMenuItemBitmaps(UINT nPosition, UINT nFlags, HBITMAP hBmpUnchecked, HBITMAP hBmpChecked)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::SetMenuItemBitmaps(m_hMenu, nPosition, nFlags, hBmpUnchecked, hBmpChecked);
	}
	BOOL CheckMenuRadioItem(UINT nIDFirst, UINT nIDLast, UINT nIDItem, UINT nFlags)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::CheckMenuRadioItem(m_hMenu, nIDFirst, nIDLast, nIDItem, nFlags);
	}

	BOOL GetMenuItemInfo(UINT uItem, BOOL bByPosition, LPMENUITEMINFO lpmii) const
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return (BOOL)::GetMenuItemInfo(m_hMenu, uItem, bByPosition, lpmii);
	}
	BOOL SetMenuItemInfo(UINT uItem, BOOL bByPosition, LPMENUITEMINFO lpmii)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return (BOOL)::SetMenuItemInfo(m_hMenu, uItem, bByPosition, lpmii);
	}
	BOOL InsertMenuItem(UINT uItem, BOOL bByPosition, LPMENUITEMINFO lpmii)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return (BOOL)::InsertMenuItem(m_hMenu, uItem, bByPosition, lpmii);
	}

// Context Help Functions
	BOOL SetMenuContextHelpId(DWORD dwContextHelpId)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::SetMenuContextHelpId(m_hMenu, dwContextHelpId);
	}
	DWORD GetMenuContextHelpId() const
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::GetMenuContextHelpId(m_hMenu);
	}
};

}; //namespace WTL

#endif // __ATLUSER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\noncomeventconnectdlg.h ===
// NonCOMEventConnectDlg.h : Declaration of the CNonCOMEventConnectDlg

#ifndef __NONCOMEVENTCONNECTDLG_H_
#define __NONCOMEVENTCONNECTDLG_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CNonCOMEventConnectDlg
class CNonCOMEventConnectDlg : 

	public CDialogImpl<CNonCOMEventConnectDlg>,
	public CMessageFilter
{
	BOOL						m_bBatch;
	public:

	__WrapperARRAY < LPWSTR > m_Events;

	LPWSTR	m_szNamespace;
	LPWSTR	m_szProvider;

	CNonCOMEventConnectDlg():

		m_bBatch ( TRUE ),

		m_szNamespace ( NULL ),
		m_szProvider ( NULL )

	{
	}

	~CNonCOMEventConnectDlg()
	{

		delete [] m_szNamespace;
		m_szNamespace	= NULL;

		delete [] m_szProvider;
		m_szProvider	= NULL;
	}

	enum { IDD = IDD_NONCOMEVENTCONNECTDLG };

	virtual BOOL PreTranslateMessage(MSG* pMsg)
	{
		return ::IsDialogMessage(m_hWnd, pMsg);
	}

	BEGIN_MSG_MAP(CNonCOMEventConnectDlg)

	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)

	COMMAND_ID_HANDLER(IDOK, OnOK)
	COMMAND_ID_HANDLER(IDCANCEL, OnCancel)

	COMMAND_ID_HANDLER(IDC_BUTTON_NAMESPACE, OnNamespace)
	COMMAND_ID_HANDLER(IDC_BUTTON_PROVIDER, OnProvider)

	COMMAND_RANGE_HANDLER(IDC_BATCH_TRUE, IDC_BATCH_FALSE, OnSelChange)

	END_MSG_MAP()

//	Handler prototypes:
//	LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//	LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//	LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	LRESULT	OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

	LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT	OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	LRESULT OnNamespace(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnProvider(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	LRESULT OnSelChange(WORD wNotifyCode, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		if(wNotifyCode == BN_CLICKED)
		{
			UpdateData();
		}

		return 0L;
	}

	private:

	void UpdateData ( void );

	HRESULT TextSet ( UINT, LPCWSTR );
	HRESULT TextGet ( UINT, LPWSTR * );

	///////////////////////////////////////////////////////////////////////////
	// events helper
	///////////////////////////////////////////////////////////////////////////
	HRESULT EventsInit	( IWbemLocator * pLocator, LPWSTR wszNamespace, LPWSTR wszProvider );

};

#endif //__NONCOMEVENTCONNECTDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\precomp.h ===
#ifndef	__PRECOMP_H__
#define	__PRECOMP_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

#define STRICT

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif	_WIN32_WINNT

#ifndef	WIN32_LEAN_AND_MEAN
#define	WIN32_LEAN_AND_MEAN
#endif	WIN32_LEAN_AND_MEAN

#define _ATL_SINGLE_THREADED

#include <windows.h>
#include <objbase.h>

///////////////////////////////////////////////////////////////////////////////
// macros
///////////////////////////////////////////////////////////////////////////////
#include <__macro_pragma.h>
#include <__macro_nocopy.h>
#include <__macro_loadstring.h>
#include <__macro_assert.h>
#include <__macro_err.h>

///////////////////////////////////////////////////////////////////////////////
// wbem stuff
///////////////////////////////////////////////////////////////////////////////
#ifndef	__WBEMIDL_H_
#include <wbemidl.h>
#endif	__WBEMIDL_H_

#include "NCObjApi.h"

#include "__Common_Convert.h"
#include "__Common_SmartPTR.h"

#include "__SafeArrayWrapper.h"

#include <atlbase.h>

///////////////////////////////////////////////////////////////////////////////
// defines
///////////////////////////////////////////////////////////////////////////////
#define	__SUPPORT_MSGBOX
#define	__SUPPORT_WAIT

#ifdef	_DEBUG
//#define	__DEBUG_STRESS
#endif	_DEBUG

#endif	__PRECOMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\noncomeventpropertydlg.h ===
// NonCOMEventPropertyDlg.h : Declaration of the CNonCOMEventPropertyDlg

#ifndef __NONCOMEVENTPROPERTYDLG_H__
#define __NONCOMEVENTPROPERTYDLG_H__

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CNonCOMEventPropertyDlg
class CNonCOMEventPropertyDlg : 

	public CDialogImpl<CNonCOMEventPropertyDlg>,
	public CMessageFilter
{
	BOOL		m_bBehaviour;
	BOOL		m_bSet;

	CComboBox*	m_pcbIndex;
	CComboBox*	m_pcbType;

	DWORD	m_Index;

	LPWSTR	m_wszValue;
	public:
	LPWSTR m_wszName;
	LPWSTR m_wszType;

	CNonCOMEventPropertyDlg( BOOL bBehaviour = FALSE );
	~CNonCOMEventPropertyDlg()
	{
		if ( m_pcbType )
		{
			delete m_pcbType;
			m_pcbType = NULL;
		}

		if ( m_bBehaviour )
		{
			if ( m_pcbIndex )
			{
				delete m_pcbIndex;
				m_pcbIndex = NULL;
			}
		}

		delete [] m_wszName;
		delete [] m_wszType;

		if ( m_wszValue )
		{
			delete [] m_wszValue;
		}
	}

	enum { IDD = IDD_DIALOG_PROPERTY };

	virtual BOOL PreTranslateMessage(MSG* pMsg)
	{
		return ::IsDialogMessage(m_hWnd, pMsg);
	}

	BEGIN_MSG_MAP(CNonCOMEventPropertyDlg)

		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)

		COMMAND_ID_HANDLER(IDOK, OnCloseCmd)
		COMMAND_ID_HANDLER(IDCANCEL, OnCloseCmd)

		COMMAND_ID_HANDLER(IDC_COMBO_INDEX, OnIndex)

		COMMAND_ID_HANDLER(IDC_CHECK_SET, OnChangeSet)

	END_MSG_MAP()

	LRESULT OnInitDialog( UINT, WPARAM, LPARAM, BOOL& );
	LRESULT OnCloseCmd( WORD, WORD, HWND, BOOL& );

	LRESULT OnIndex		(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnChangeSet	(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	HRESULT PropertySet ( void );

	private:

	// text helper
	HRESULT	TextGet ( UINT nDlgItem, LPWSTR * pstr );
};

#endif	__NONCOMEVENTPROPERTYDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\noncomeventmaindlg.h ===
// NonCOMEventMainDlg.h : Declaration of the CNonCOMEventMainDlg

#ifndef __NONCOMEVENTMAINDLG_H_
#define __NONCOMEVENTMAINDLG_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CNonCOMEventMainDlg
class CNonCOMEventMainDlg : 

	public CDialogImpl<CNonCOMEventMainDlg>,
	public CMessageFilter
{

	// event combo box
	CComboBox*	m_pcbEvents;

	// callback list box
	static	CListBox*	m_plbCallBack;

	public:

	CNonCOMEventMainDlg() :

		m_pcbEvents ( NULL )

	{
	}

	~CNonCOMEventMainDlg()
	{
		if ( m_pcbEvents )
		{
			delete m_pcbEvents;
			m_pcbEvents = NULL;
		}

		if ( m_plbCallBack )
		{
			delete m_plbCallBack;
			m_plbCallBack = NULL;
		}
	}

	enum { IDD = IDD_NONCOMEVENTMAINDLG };

	static HRESULT WINAPI EventSourceCallBack(
												HANDLE hSource, 
												EVENT_SOURCE_MSG msg, 
												LPVOID pUser, 
												LPVOID pData
											 );

	virtual BOOL PreTranslateMessage(MSG* pMsg)
	{
		return ::IsDialogMessage(m_hWnd, pMsg);
	}

	BEGIN_MSG_MAP(CNonCOMEventMainDlg)

	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)

	COMMAND_ID_HANDLER(IDOK, OnOK)

	COMMAND_ID_HANDLER(IDC_CONNECT, OnConnect)
	COMMAND_ID_HANDLER(IDC_DISCONNECT, OnConnect)

	COMMAND_ID_HANDLER(IDC_CALLBACK_CLEAR, OnClearList)
	COMMAND_ID_HANDLER(IDC_COMBO_EVENTS, OnEvents)

	COMMAND_ID_HANDLER(IDC_BUTTON_DESTROY, OnDestroyObject)

	COMMAND_ID_HANDLER(IDC_BUTTON_CREATE, OnCreateObject)
	COMMAND_ID_HANDLER(IDC_BUTTON_CREATE_FORMAT, OnCreateObject)
	COMMAND_ID_HANDLER(IDC_BUTTON_CREATE_PROPS, OnCreateObject)

	COMMAND_ID_HANDLER(IDC_BUTTON_PROPERTY_ADD, OnPropertyAdd)
	COMMAND_ID_HANDLER(IDC_BUTTON_PROPERTIES_ADD, OnPropertyAdd)

	COMMAND_ID_HANDLER(IDC_BUTTON_PROPERTY_SET, OnPropertySet)
	COMMAND_ID_HANDLER(IDC_BUTTON_COMMIT, OnCommit)

	COMMAND_ID_HANDLER(IDC_BUTTON_SELECT, OnCopySelect)

	MESSAGE_HANDLER(WM_SYSCOMMAND, OnSysCommand)

	END_MSG_MAP()

//	Handler prototypes:
//	LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//	LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//	LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	LRESULT OnSysCommand(UINT, WPARAM wParam, LPARAM, BOOL& bHandled)
	{
		UINT uCmdType = (UINT)wParam;

		if((uCmdType & 0xFFF0) == IDM_ABOUTBOX)
		{
			CNonCOMEventAboutDlg dlg;
			dlg.DoModal();
		}
		else
		if((uCmdType & 0xFFF0) == SC_CLOSE)
		{
			EndDialog ( IDOK );
		}

		bHandled = FALSE;
		return 0L;
	}

	LRESULT	OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

	LRESULT OnOK		(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnConnect	(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	LRESULT OnCopySelect	(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	LRESULT OnDestroyObject	(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnCreateObject	(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	LRESULT OnEvents	(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnClearList	(WORD, WORD, HWND, BOOL&)
	{
		ClearList();
		return 0L;
	}

	LRESULT OnPropertyAdd	(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnPropertySet	(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnCommit		(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	private:

	HRESULT TextSet ( UINT, LPCWSTR );
	HRESULT TextGet ( UINT, LPWSTR * );

	// enable / disable all controls
	void Enable ( BOOL bEnable );

	// clear list
	void ClearList ( void )
	{
		if ( m_plbCallBack )
		{
			m_plbCallBack->ResetContent();

			// disable button :))
			::EnableWindow ( GetDlgItem ( IDC_CALLBACK_CLEAR ), FALSE );
		}
	}
};

#endif //__NONCOMEVENTMAINDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\worker.h ===
#ifndef _WORKER_H_
#define _WORKER_H_

class __declspec ( novtable ) CWorker
{
	public:

	CWorker()
	{
	}

	virtual ~CWorker()
	{
	}

	// helper method ( parse arguments )

	static BOOL HasCharacter ( LPCWSTR wsz )
	{
		LPWSTR	sz		= NULL;
		BOOL	bResult	= FALSE;

		try
		{
			if ( ( sz = new WCHAR [ lstrlenW ( wsz ) + 1 ] ) != NULL )
			{
				lstrcpyW ( sz ,wsz );
			}
		}
		catch ( ... )
		{
		}

		while ( sz && *sz )
		{
			if ( *sz >= 30 && *sz <= 39 )
			{
				sz++;
			}
			else
			{
				sz = NULL;
				bResult = TRUE;
			}
		}

		delete [] sz;
		sz = NULL;

		return bResult;
	}
};

class CWorkerScalar : public CWorker
{
public:
	CWorkerScalar::CWorkerScalar(CModuleScalar *pModule):
		m_pNotify(pModule->m_pCimNotify),
		m_pModule(pModule),

		m_bStop(pModule->m_bShouldExit),
		m_bPause(pModule->m_bShouldPause)
	{
		m_wszParams = ::SysAllocStringLen ( pModule->m_bstrParams, ::SysStringLen( pModule->m_bstrParams ) );
		
		if ( m_pNotify )
		{
			m_pNotify->AddRef();
			m_pNotify = NULL;
		}

		m_pModule->AddRef();
	}

	virtual ~CWorkerScalar()
	{
		::SysFreeString ( m_wszParams );

		if ( m_pNotify )
		{
			m_pNotify->Release();
			m_pNotify = NULL;
		}

		m_pModule->Release();
	}

	virtual bool IsStopped()
	{
		return m_bStop==true;
	}

	virtual bool IsPaused()
	{
		return m_bPause==true;
	}

	ICimNotify *m_pNotify;

	BSTR m_wszParams;

private:
	bool &m_bStop;
	bool &m_bPause;

	CModuleScalar *m_pModule;
};

class CMyWorkerScalar : public CWorkerScalar
{
	HANDLE	m_hThread;
public:
	CMyWorkerScalar(CModuleScalar *pModule);
	~CMyWorkerScalar();

private:
	static DWORD WINAPI WorkThread(void *pVoid);
};

class CWorkerArray : public CWorker
{
public:
	CWorkerArray::CWorkerArray(CModuleArray *pModule):
		m_pNotify(pModule->m_pCimNotify),
		m_pModule(pModule),

		m_bStop(pModule->m_bShouldExit),
		m_bPause(pModule->m_bShouldPause)
	{
		m_wszParams = ::SysAllocStringLen ( pModule->m_bstrParams, ::SysStringLen( pModule->m_bstrParams ) );
		
		if ( m_pNotify )
		{
			m_pNotify->AddRef();
			m_pNotify = NULL;
		}

		m_pModule->AddRef();
	}

	virtual ~CWorkerArray()
	{
		::SysFreeString ( m_wszParams );
		
		if ( m_pNotify )
		{
			m_pNotify->Release();
			m_pNotify = NULL;
		}

		m_pModule->Release();
	}

	virtual bool IsStopped()
	{
		return m_bStop==true;
	}

	virtual bool IsPaused()
	{
		return m_bPause==true;
	}

	ICimNotify *m_pNotify;

	BSTR m_wszParams;

private:
	bool &m_bStop;
	bool &m_bPause;

	CModuleArray *m_pModule;
};

class CMyWorkerArray : public CWorkerArray
{
	HANDLE	m_hThread;
public:
	CMyWorkerArray(CModuleArray *pModule);
	~CMyWorkerArray();

private:
	static DWORD WINAPI WorkThread(void *pVoid);
};

class CWorkerGeneric : public CWorker
{
public:
	CWorkerGeneric::CWorkerGeneric(CModuleGeneric *pModule):
		m_pNotify(pModule->m_pCimNotify),
		m_pModule(pModule),

		m_bStop(pModule->m_bShouldExit),
		m_bPause(pModule->m_bShouldPause)
	{
		m_wszParams = ::SysAllocStringLen ( pModule->m_bstrParams, ::SysStringLen( pModule->m_bstrParams ) );

		if ( m_pNotify )
		{
			m_pNotify->AddRef();
			m_pNotify = NULL;
		}

		m_pModule->AddRef();
	}

	virtual ~CWorkerGeneric()
	{
		::SysFreeString ( m_wszParams );
		
		if ( m_pNotify )
		{
			m_pNotify->Release();
			m_pNotify = NULL;
		}

		m_pModule->Release();
	}

	virtual bool IsStopped()
	{
		return m_bStop==true;
	}

	virtual bool IsPaused()
	{
		return m_bPause==true;
	}

	ICimNotify *m_pNotify;

	BSTR m_wszParams;

private:
	bool &m_bStop;
	bool &m_bPause;

	CModuleGeneric *m_pModule;
};

class CMyWorkerGeneric : public CWorkerGeneric
{
	HANDLE	m_hThread;
public:
	CMyWorkerGeneric(CModuleGeneric *pModule);
	~CMyWorkerGeneric();

private:
	static DWORD WINAPI WorkThread(void *pVoid);
};

#endif _WORKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\_connectrestricted.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					_ConnectRestricted.h
//
//	Abstract:
//
//					declaration of connect module
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__CONNECT_RESTRICTED_H__
#define	__CONNECT_RESTRICTED_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

#include "_Connect.h"

///////////////////////////////////////////////////////////////////////////////
//
// ConnectRestricted WRAPPER
//
///////////////////////////////////////////////////////////////////////////////

class MyConnectRestricted
{
	DECLARE_NO_COPY ( MyConnectRestricted );


	MyConnectRestricted ( ) :
		m_hConnect ( NULL )
	{
	}

	static MyConnectRestricted*	m_pConnect;
	HANDLE						m_hConnect;

	public:

	static MyConnectRestricted * GetConnect	(	DWORD dwQueries,
												LPCWSTR* ppQueries
											)
	{
		// locking / unlocking
		__Smart_CRITICAL_SECTION;

		try
		{
			if ( ! m_pConnect )
			{
				if ( ( m_pConnect = new MyConnectRestricted() ) != NULL )
				{
					m_pConnect->m_hConnect = WmiCreateRestrictedConnection	(	MyConnect::GetConnect(),
																				dwQueries,
																				ppQueries,
																				NULL,
																				MyConnect::DefaultCallBack
																			);
				}
			}
		}
		catch ( ... )
		{
		}

		return m_pConnect;
	}

	static MyConnectRestricted * GetConnect	(	DWORD dwQueries,
												LPCWSTR* ppQueries,
												LPVOID pUserData,
												LPEVENT_SOURCE_CALLBACK pCallBack
											)
	{
		// locking / unlocking
		__Smart_CRITICAL_SECTION;

		try
		{
			if ( ! m_pConnect )
			{
				if ( ( m_pConnect = new MyConnectRestricted() ) != NULL )
				{
					m_pConnect->m_hConnect = WmiCreateRestrictedConnection	(	MyConnect::GetConnect(),
																				dwQueries,
																				ppQueries,
																				pUserData,
																				pCallBack
																			);
				}
			}
		}
		catch ( ... )
		{
		}

		return m_pConnect;
	}

	static void ClearConnectRestricted ( void )
	{
		// locking / unlocking
		__Smart_CRITICAL_SECTION;

		if ( m_pConnect )
		{
			delete m_pConnect;
			m_pConnect = NULL;
		}
	}

	virtual ~MyConnectRestricted ( )
	{
		if ( m_hConnect )
		{
			WmiEventSourceDisconnect ( m_hConnect );
			m_hConnect = NULL;
		}

		m_pConnect = NULL;
	}

	// operators :))

	operator HANDLE() const
	{
		return m_hConnect;
	}

	HANDLE GetConnectRestrictedHandle ( ) const
	{
		return (HANDLE)(*this);
	}
};

#endif	__CONNECT_RESTRICTED_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\_classobject.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_object.h
//
//	Abstract:
//
//					declaration of object structure
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__CLASSOBJECT_H__
#define	__CLASSOBJECT_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// wbem
#ifndef	__WBEMIDL_H_
#include <wbemidl.h>
#endif	__WBEMIDL_H_

class MyClassObject
{
	DECLARE_NO_COPY ( MyClassObject );

	IWbemClassObject*	m_pObject;
	IWbemQualifierSet*	m_pObjectQualifierSet;

	public:

	//////////////////////////////////////////////////////////////////////////////////////////
	// construction & destruction
	//////////////////////////////////////////////////////////////////////////////////////////

	MyClassObject ( ) :
	m_pObject ( NULL ),
	m_pObjectQualifierSet ( NULL )
	{
	}

	MyClassObject ( IWbemClassObject * pObject ) :
	m_pObject ( NULL ),
	m_pObjectQualifierSet ( NULL )
	{
		ClassObjectInit ( pObject );
	}

	virtual ~MyClassObject ()
	{
		ClassObjectUninit ();
	}

	HRESULT	ClassObjectInit		( IWbemLocator* pLocator, LPWSTR wszClassName );
	HRESULT	ClassObjectInit		( IWbemClassObject * pObject );
	HRESULT	ClassObjectUninit	( void );

	//////////////////////////////////////////////////////////////////////////////////////////
	// methods
	//////////////////////////////////////////////////////////////////////////////////////////

	HRESULT	GetNames			(	DWORD*		pdwNames,
									LPWSTR**	ppNames,
									CIMTYPE**	ppNamesTypes,
									LPWSTR*		lptszPropNeedNot = NULL,
									DWORD		dwPropNeedNot = NULL,
									LONG		lFlags = WBEM_FLAG_LOCAL_ONLY | WBEM_FLAG_NONSYSTEM_ONLY
								);

	HRESULT	GetPropertyType		( LPCWSTR wszPropName, CIMTYPE* type );
	HRESULT	GetPropertyValue	( LPCWSTR wszPropName, LPWSTR* pwsz );
	HRESULT	GetPropertyValue	( LPCWSTR wszPropName, LPWSTR** pwsz, DWORD* dwsz );

	HRESULT	GetQualifierValue	( LPCWSTR wszPropName, LPCWSTR wszQualifierName, LPWSTR* psz );
	HRESULT	GetQualifierValue	( LPCWSTR wszQualifierName, LPWSTR* psz );

	private:

	//////////////////////////////////////////////////////////////////////////////////////////
	// helpers
	//////////////////////////////////////////////////////////////////////////////////////////

	HRESULT	GetQualifierValue	( IWbemQualifierSet* pSet, LPCWSTR wszQualifierName, LPWSTR* psz );

	HRESULT	IsCorrect (	IWbemQualifierSet* pSet,
						LPWSTR* lptszNeedNot,
						DWORD	dwNeedNot
					  );
};

#endif	__CLASSOBJECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\_connect.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					_Connect.h
//
//	Abstract:
//
//					declaration of connect module
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__CONNECT_H__
#define	__CONNECT_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// defines

#define BUFFER_SIZE		64000
#define SEND_LATENCY	1000

#define	NAMESPACE		L"root\\cimv2"
#define	PROVIDER		L"NonCOMTest Event Provider"

#define BATCH			TRUE

///////////////////////////////////////////////////////////////////////////////
//
// CONNECT WRAPPER
//
///////////////////////////////////////////////////////////////////////////////

class MyConnect
{
	DECLARE_NO_COPY ( MyConnect );


	MyConnect ( ) :
		m_hConnect ( NULL )
	{
		ConnectInit ( );
	}

	static MyConnect*	m_pConnect;
	HANDLE				m_hConnect;

	static HANDLE		m_hEventStop;
	public:
	static HANDLE		m_hEventStart;

	static LONG			m_lCount;

	static MyConnect * ConnectGet ( void )
	{
		// locking / unlocking
		__Smart_CRITICAL_SECTION;

		try
		{
			if ( ! m_pConnect )
			{
				if ( ( m_pConnect = new MyConnect() ) != NULL )
				{
					m_pConnect->m_hConnect = WmiEventSourceConnect	(
																		NAMESPACE,
																		PROVIDER,
																		BATCH,
																		BUFFER_SIZE,
																		SEND_LATENCY,
																		NULL,
																		DefaultCallBack
																	);
				}
			}

			::InterlockedIncrement ( &m_lCount );
		}
		catch ( ... )
		{
		}

		return m_pConnect;
	}

	static MyConnect * ConnectGet	(
										LPWSTR wszName,
										LPWSTR wszNameProv,
										BOOL bBatchSend,
										DWORD dwBufferSize, 
										DWORD dwSendLatency,
										LPVOID pUserData,
										LPEVENT_SOURCE_CALLBACK pCallBack
									)
	{
		// locking / unlocking
		__Smart_CRITICAL_SECTION;

		try
		{
			if ( ! m_pConnect )
			{
				if ( ( m_pConnect = new MyConnect() ) != NULL )
				{
					m_pConnect->m_hConnect = WmiEventSourceConnect	(
																		wszName,
																		wszNameProv,
																		bBatchSend,
																		dwBufferSize,
																		dwSendLatency,
																		pUserData,
																		pCallBack
																	);
				}
			}

			::InterlockedIncrement ( &m_lCount );
		}
		catch ( ... )
		{
		}

		return m_pConnect;
	}

	static void ConnectClear ( void )
	{
		// locking / unlocking
		__Smart_CRITICAL_SECTION;

		if ( ::InterlockedCompareExchange ( &m_lCount, m_lCount-1, 1 ) == 1 )
		{
			if ( m_hEventStop )
			{
				::WaitForSingleObject ( m_hEventStop, 3000 );
			}

			if ( m_pConnect )
			{
				delete m_pConnect;
			}
		}

		m_pConnect = NULL;
	}

	virtual ~MyConnect ( )
	{
		if ( m_hConnect )
		{
			WmiEventSourceDisconnect ( m_hConnect );
			m_hConnect = NULL;
		}

		__Smart_CRITICAL_SECTION;

		if ( m_hEventStart )
		{
			::CloseHandle ( m_hEventStart );
			m_hEventStart = NULL;
		}

		if ( m_hEventStop )
		{
			::CloseHandle ( m_hEventStop );
			m_hEventStop = NULL;
		}
	}

	// default CallBack we want to have
    static HRESULT WINAPI DefaultCallBack (
											HANDLE hSource, 
											EVENT_SOURCE_MSG msg, 
											LPVOID pUser, 
											LPVOID pData
										  );

	// operators :))

	operator HANDLE() const
	{
		return m_hConnect;
	}

	HANDLE ConnectGetHandle ( ) const
	{
		if ( m_pConnect )
		return (HANDLE)(*this);

		return (HANDLE) * ConnectGet();
	}

	private:

	static void ConnectInit ( void );
};

#endif	__CONNECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\_dlgimpl.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					_Dlg.cpp
//
//	Abstract:
//
//					module for dialog
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__DLGIMPL_H__
#define	__DLGIMPL_H__

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

#include "_Module.h"
extern MyModule _Module;

template < typename CLASS >
inline HRESULT	MyDlg < CLASS >::Run ( int nCmdShow )
{
	CMessageLoop		loop;

	_Module.Lock();
	_Module.AddMessageLoop ( &loop );

	HRESULT hRes = S_OK;
	hRes = RunModal ( nCmdShow );

	_Module.RemoveMessageLoop();
	_Module.Unlock();

	return hRes;
}

template < typename CLASS >
inline HRESULT	MyDlg < CLASS >::RunModal ( int )
{
	try
	{
		if ( m_pDlg )
		{
			if ( ( m_pDlg->DoModal() ) != IDOK )
			{
				return E_FAIL;
			}
		}
	}
	catch ( ... )
	{
		return E_UNEXPECTED;
	}

	return S_OK;
}

#endif	__DLGIMPL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\_app.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					_app.h
//
//	Abstract:
//
//					declaration of application module
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__APP_H__
#define	__APP_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

#include "_Dlg.h"
#include "_DlgImpl.h"

#include "_Connect.h"
#include "_EventObject.h"
#include "_EventObjects.h"

///////////////////////////////////////////////////////////////////////////////
//
// APPLICATION WRAPPER
//
///////////////////////////////////////////////////////////////////////////////

class MyApp
{
	DECLARE_NO_COPY ( MyApp );

	// critical section
	CComAutoCriticalSection m_cs;

	// variables

	LPWSTR			m_wszName;		// name of app
	__SmartHANDLE	m_hInstance;	// test for previous instance

	public:

	static LONG m_lCount;

	MyConnect*				m_connect;			// connection to non COM event provider
	MyEventObjectNormal		m_event;			// event object

	__SmartHANDLE	m_hKill;		// kill ( com )
	__SmartHANDLE	m_hUse;			// event in use ?

	///////////////////////////////////////////////////////////////////////////
	// construction & destruction
	///////////////////////////////////////////////////////////////////////////

	MyApp( UINT id );
	MyApp( LPWSTR wszName );

	virtual ~MyApp();

	///////////////////////////////////////////////////////////////////////////
	//	event helpers
	///////////////////////////////////////////////////////////////////////////

	HRESULT	EventInit ( LPWSTR wszName )
	{
		// smart locking/unlocking
		__Smart_CRITICAL_SECTION scs ( const_cast<LPCRITICAL_SECTION> ( &m_cs.m_sec ) );

		return m_event.Init ( wszName );
	}

	HRESULT EventUninit ( )
	{
		// smart locking/unlocking
		__Smart_CRITICAL_SECTION scs ( const_cast<LPCRITICAL_SECTION> ( &m_cs.m_sec ) );

		HRESULT hr = S_OK;
		
		hr = m_event.Uninit();

		return hr;
	}

	///////////////////////////////////////////////////////////////////////////
	//	connection helpers
	///////////////////////////////////////////////////////////////////////////

	BOOL	IsConnected ( void )
	{
		return ( ( ( m_connect->ConnectGetHandle() ) == NULL ) ? FALSE : TRUE );
	}

	HRESULT Disconnect ( void )
	{
		// smart locking/unlocking
		__Smart_CRITICAL_SECTION scs ( const_cast<LPCRITICAL_SECTION> ( &m_cs.m_sec ) );

		////////////////////////////////////////////////////////////////////////
		// destroy connect
		////////////////////////////////////////////////////////////////////////

		if ( m_connect )
		{
			m_connect -> ConnectClear();
			m_connect = NULL;

			return S_OK;
		}

		return S_FALSE;
	}

	HRESULT	Connect	( 
						LPWSTR wszName,
						LPWSTR wszNameProv,
						BOOL bBatchSend,
						DWORD dwBufferSize, 
						DWORD dwSendLatency,
						LPVOID pUserData,
						LPEVENT_SOURCE_CALLBACK pCallBack
					)
	{
		// smart locking/unlocking
		__Smart_CRITICAL_SECTION scs ( const_cast<LPCRITICAL_SECTION> ( &m_cs.m_sec ) );

		if ( m_connect )
		{
			return S_FALSE;
		}

		if ( ( m_connect = MyConnect::ConnectGet (	
													wszName,
													wszNameProv,
													bBatchSend,
													dwBufferSize,
													dwSendLatency,
													pUserData,
													pCallBack
												 ) ) != NULL )
		{
			return S_OK;
		}

		return E_FAIL;
	}

	HRESULT	Connect	( )
	{
		// smart locking/unlocking
		__Smart_CRITICAL_SECTION scs ( const_cast<LPCRITICAL_SECTION> ( &m_cs.m_sec ) );

		if ( m_connect )
		{
			return S_FALSE;
		}

		if ( ( m_connect = MyConnect::ConnectGet (	) ) != NULL )
		{
			return S_OK;
		}

		return E_FAIL;
	}

	///////////////////////////////////////////////////////////////////////////
	// exists instance ?
	///////////////////////////////////////////////////////////////////////////
	BOOL Exists ( void );

	///////////////////////////////////////////////////////////////////////////
	// name of application
	///////////////////////////////////////////////////////////////////////////

	LPWSTR	NameGet() const
	{
		ATLTRACE (	L"*************************************************************\n"
					L"MyApp name get\n"
					L"*************************************************************\n" );

		// smart locking/unlocking
		__Smart_CRITICAL_SECTION scs ( const_cast<LPCRITICAL_SECTION> ( &m_cs.m_sec ) );

		return m_wszName;
	}

	void	NameSet ( const LPWSTR wszName )
	{
		ATLTRACE (	L"*************************************************************\n"
					L"MyApp name set\n"
					L"*************************************************************\n" );

		// smart locking/unlocking
		__Smart_CRITICAL_SECTION scs ( const_cast<LPCRITICAL_SECTION> ( &m_cs.m_sec ) );

		___ASSERT ( m_wszName == NULL );
		m_wszName = wszName ;
	}

	///////////////////////////////////////////////////////////////////////////
	// helper functions
	///////////////////////////////////////////////////////////////////////////
	static LPCWSTR FindOneOf(LPCWSTR p1, LPCWSTR p2)
	{
		while (p1 != NULL && *p1 != NULL)
		{
			LPCWSTR p = p2;
			while (p != NULL && *p != NULL)
			{
				if (*p1 == *p)
					return CharNext(p1);
				p = CharNext(p);
			}
			p1 = CharNext(p1);
		}
		return NULL;
	}

   	static TCHAR* _cstrchr(const TCHAR* p, TCHAR ch)
	{
		//strchr for '\0' should succeed
		while (*p != 0)
		{
			if (*p == ch)
				break;
			p = CharNext(p);
		}
		return (TCHAR*)((*p == ch) ? p : NULL);
	}

	static TCHAR* _cstrstr(const TCHAR* pStr, const TCHAR* pCharSet)
	{
		int nLen = lstrlen(pCharSet);
		if (nLen == 0)
			return (TCHAR*)pStr;

		const TCHAR* pRet = NULL;
		const TCHAR* pCur = pStr;
		while((pStr = _cstrchr(pCur, *pCharSet)) != NULL)
		{
			if(memcmp(pCur, pCharSet, nLen * sizeof(TCHAR)) == 0)
			{
				pRet = pCur;
				break;
			}
			pCur = CharNext(pCur);
		}
		return (TCHAR*) pRet;
	}
};

#endif	__APP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\_dlg.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					_dlg.h
//
//	Abstract:
//
//					declaration of application module
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__DLG_H__
#define	__DLG_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

///////////////////////////////////////////////////////////////////////////////
//
// WAIT OPERATION :))
//
///////////////////////////////////////////////////////////////////////////////

class CHourGlass
{
	protected:
    HCURSOR m_hCursor;

	public:

    CHourGlass()
	{
		m_hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
	}

    ~CHourGlass()
	{
		SetCursor(m_hCursor);
	}

};

///////////////////////////////////////////////////////////////////////////////
//
// DIALOG WRAPPER
//
///////////////////////////////////////////////////////////////////////////////

template < typename CLASS >
class MyDlg
{
	DECLARE_NO_COPY ( MyDlg );

	CLASS * m_pDlg;

	public:

	///////////////////////////////////////////////////////////////////////////
	//	construction & destruction
	///////////////////////////////////////////////////////////////////////////

	MyDlg():

		m_pDlg ( NULL )
	{
	}

	virtual ~MyDlg()
	{
		if ( m_pDlg )
		{
			delete m_pDlg;
			m_pDlg = NULL;
		}

		return;
	}

	//////////////////////////////////////////////////////////////////////////
	//	init dialog
	//////////////////////////////////////////////////////////////////////////
	HRESULT	Init ( void )
	{
		if ( m_pDlg )
		{
			return HRESULT_FROM_WIN32 ( ERROR_ALREADY_EXISTS );
		}

		try
		{
			if ( ( m_pDlg = new CLASS ) == NULL )
			{
				return E_OUTOFMEMORY;
			}
		}
		catch ( ... )
		{
			if ( m_pDlg )
			{
				delete m_pDlg;
				m_pDlg = NULL;
			}

			return E_FAIL;
		}

		return S_OK;
	}

	HRESULT	Init ( BOOL b )
	{
		if ( m_pDlg )
		{
			return HRESULT_FROM_WIN32 ( ERROR_ALREADY_EXISTS );
		}

		try
		{
			if ( ( m_pDlg = new CLASS ( b ) ) == NULL )
			{
				return E_OUTOFMEMORY;
			}
		}
		catch ( ... )
		{
			if ( m_pDlg )
			{
				delete m_pDlg;
				m_pDlg = NULL;
			}

			return E_FAIL;
		}

		return S_OK;
	}

	HRESULT	Init ( 	IWbemLocator* pLocator,
					LPWSTR wszNamespace,
					LPWSTR wszQueryLang,
					LPWSTR wszQuery,
					LPWSTR wszName
				 )
	{
		if ( m_pDlg )
		{
			return HRESULT_FROM_WIN32 ( ERROR_ALREADY_EXISTS );
		}

		try
		{
			if ( ( m_pDlg = new CLASS ( pLocator, wszNamespace, wszQueryLang, wszQuery, wszName ) ) == NULL )
			{
				return E_OUTOFMEMORY;
			}
		}
		catch ( ... )
		{
			if ( m_pDlg )
			{
				delete m_pDlg;
				m_pDlg = NULL;
			}

			return E_FAIL;
		}

		return S_OK;
	}

	HRESULT	Init ( 	IWbemLocator* pLocator,
					LPWSTR wszNamespace,
					LPWSTR wszClassName,
					LPWSTR wszName
				 )
	{
		if ( m_pDlg )
		{
			return HRESULT_FROM_WIN32 ( ERROR_ALREADY_EXISTS );
		}

		try
		{
			if ( ( m_pDlg = new CLASS ( pLocator, wszNamespace, wszClassName, wszName ) ) == NULL )
			{
				return E_OUTOFMEMORY;
			}
		}
		catch ( ... )
		{
			if ( m_pDlg )
			{
				delete m_pDlg;
				m_pDlg = NULL;
			}

			return E_FAIL;
		}

		return S_OK;
	}

	//////////////////////////////////////////////////////////////////////////
	//	run dialog
	//////////////////////////////////////////////////////////////////////////
	HRESULT	Run ( int nCmdShow );
	HRESULT	RunModal ( int nCmdShow );

	//////////////////////////////////////////////////////////////////////////
	//	return dialog
	//////////////////////////////////////////////////////////////////////////

	operator CLASS() const
	{
		return ( * m_pDlg ) ;
	}

	CLASS* GetDlg ( ) const
	{
		return m_pDlg ;
	}

};

#endif	__DLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\_eventobject.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					_EventObject.h
//
//	Abstract:
//
//					declaration of common NonCOM Event Object
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__EVENT_OBJECT_H__
#define	__EVENT_OBJECT_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

class MyEventProperty
{
	DECLARE_NO_COPY ( MyEventProperty );

	LPWSTR	m_wszName;
	CIMTYPE	m_type;
	VARIANT	m_value;

	public:

	MyEventProperty ( LPWSTR wszName, CIMTYPE type );
	MyEventProperty ( LPWSTR wszName, LPWSTR type );

	virtual ~MyEventProperty();

	HRESULT SetValue ( VARIANT value );
	HRESULT	GetValue ( VARIANT* pvalue ) const;

	LPWSTR	GetName			( void ) const;

	LPCWSTR	GetTypeString	( void ) const;
	CIMTYPE	GetType			( void ) const;
};

class MyEventObjectAbstract
{
	DECLARE_NO_COPY ( MyEventObjectAbstract );

	public:

	static LPCWSTR	GetTypeString	( CIMTYPE type );
	static CIMTYPE	GetType			( LPWSTR wszType );

	LPWSTR	wszName;
	LPWSTR	wszNameShow;
	LPWSTR	wszQuery;

	////////////////////////////////////////////////////////////////////////////////
	//	construction & destruction
	////////////////////////////////////////////////////////////////////////////////

	MyEventObjectAbstract();
	virtual ~MyEventObjectAbstract ()
	{
		Uninit();
	}

	////////////////////////////////////////////////////////////////////////////////
	//	functions
	////////////////////////////////////////////////////////////////////////////////

	virtual HRESULT Init			( LPWSTR Name, LPWSTR NameShow = NULL, LPWSTR Query = NULL);
	virtual HRESULT Uninit			( void )
	{
		HRESULT hRes = S_OK;

		try
		{
			if ( wszName )
			{
				delete [] wszName;
			}

			if ( wszNameShow )
			{
				delete [] wszNameShow;
			}

			if ( wszQuery )
			{
				delete [] wszQuery;
			}
		}
		catch ( ... )
		{
			hRes = E_FAIL;
		}

		wszName		= NULL;
		wszNameShow	= NULL;
		wszQuery	= NULL;

		return hRes;
	}

	virtual HRESULT EventReport1	(	HANDLE hConnect,
										signed char			cVar,
										unsigned char		ucVar,
										signed short		sVar,
										unsigned short		usVar,
										signed long			lVar,
										unsigned long		ulVar,
										signed __int64		i64Var,
										unsigned __int64	ui64Var,
										float				fVar,
										double				dVar,
										BOOL 				b,
										LPWSTR				wsz,
										WCHAR				wcVar,
										void*				objVar
									)	= 0;

	virtual HRESULT EventReport2	(	HANDLE hConnect,
										DWORD dwSize,
										signed char*		cVar,
										unsigned char*		ucVar,
										signed short*		sVar,
										unsigned short*		usVar,
										signed long*		lVar,
										unsigned long*		ulVar,
										signed __int64*		i64Var,
										unsigned __int64*	ui64Var,
										float*				fVar,
										double*				dVar,
										BOOL* 				b,
										LPWSTR*				wsz,
										WCHAR*				wcVar,
										void*				objVar
									)	= 0;
};

class MyEventObject : virtual public MyEventObjectAbstract
{
	DECLARE_NO_COPY ( MyEventObject );

	__WrapperARRAY < LPWSTR >			m_pNames;
	__WrapperARRAYSimple < CIMTYPE >	m_pTypes;

	LPWSTR						m_wszNamespace;
	LPWSTR						m_wszProvider;

	public:

	bool						m_bProps;
	CComPtr < IWbemLocator >	m_pLocator;

	__WrapperARRAY < MyEventProperty* > m_properties;

	HANDLE	m_hEventObject;

	////////////////////////////////////////////////////////////////////////////////
	//	construction & destruction
	////////////////////////////////////////////////////////////////////////////////

	MyEventObject ( ) : MyEventObjectAbstract ( ),
		m_hEventObject ( NULL ),

		m_wszNamespace ( NULL ),
		m_wszProvider ( NULL ),

		m_pLocator ( NULL )
	{
	}

	virtual ~MyEventObject ( ) 
	{
		MyEventObjectClear();
	}

	void MyEventObjectClear ( void )
	{
		if ( m_wszNamespace )
		{
			delete [] m_wszNamespace;
			m_wszNamespace = NULL;
		}

		if ( m_wszProvider )
		{
			delete [] m_wszProvider;
			m_wszProvider = NULL;
		}

		DestroyObject ();
	}

	////////////////////////////////////////////////////////////////////////////////
	//	functions
	////////////////////////////////////////////////////////////////////////////////

	virtual HRESULT EventCommit	( BOOL bCheck = TRUE )
	{
		if ( m_hEventObject )
		{
			// test all propertiess

			if ( bCheck )
			{
				for ( DWORD dw = 0; dw < m_properties; dw ++ )
				{
					CComVariant var;

					if SUCCEEDED ( m_properties [ dw ] -> GetValue ( & var ) )
					{
						if ( V_VT ( & var ) == VT_EMPTY ) 
						{
							PropertySet ( dw );
						}
					}
				}
			}

			return ( ( WmiCommitObject ( m_hEventObject ) == TRUE ) ? S_OK : S_FALSE );
		}

		return E_UNEXPECTED;
	}

	virtual HRESULT ObjectLocator	( BOOL b = TRUE );

	virtual HRESULT InitInternal	( void );
	virtual HRESULT InitObject		( LPWSTR Namespace = NULL, LPWSTR Provider = NULL );
	virtual HRESULT Init			( LPWSTR Name, LPWSTR NameShow = NULL, LPWSTR Query = NULL );

	////////////////////////////////////////////////////////////////////////////////
	//	destroy
	////////////////////////////////////////////////////////////////////////////////

	HRESULT	DestroyObject		( void )
	{
		if ( m_hEventObject )
		{
			#ifdef	__SUPPORT_WAIT
			Sleep ( 3000 );
			#endif	__SUPPORT_WAIT

			// destroy object
			WmiDestroyObject ( m_hEventObject );

			m_hEventObject = NULL;

			if ( ! m_properties.IsEmpty () ) 
			{
				m_properties.DestroyARRAY ();
			}

			return S_OK;
		}

		return S_FALSE;
	}

	////////////////////////////////////////////////////////////////////////////////
	//	creation
	////////////////////////////////////////////////////////////////////////////////

	HRESULT	CreateObject		(	HANDLE hConnect,
									DWORD dwFlags = WMI_CREATEOBJ_LOCKABLE
								);
	HRESULT	CreateObjectFormat	(	HANDLE hConnect,
									DWORD dwFlags = WMI_CREATEOBJ_LOCKABLE
								);
	HRESULT	CreateObjectFormat	(	HANDLE hConnect,
									LPCWSTR wszFormat,
									DWORD dwFlags = WMI_CREATEOBJ_LOCKABLE
								);
	HRESULT	CreateObjectProps	(	HANDLE hConnect,
									DWORD dwFlags = WMI_CREATEOBJ_LOCKABLE
								);
	HRESULT	CreateObjectProps	(	HANDLE hConnect,
									DWORD dwProps,
									LPCWSTR* pProps,
									CIMTYPE* pTypes,
									DWORD dwFlags = WMI_CREATEOBJ_LOCKABLE
								);

	////////////////////////////////////////////////////////////////////////////////
	//	properties
	////////////////////////////////////////////////////////////////////////////////

	HRESULT PropertiesAdd	( void );
	HRESULT PropertyAdd		( void );
	HRESULT PropertyAdd		( DWORD dwIndex, DWORD* pdwIndex = NULL );

	HRESULT	PropertyAdd		( LPCWSTR wszPropName, CIMTYPE type, DWORD* pdwIndex = NULL );
	HRESULT	PropertySet		( DWORD dwIndex );

	HRESULT	PropertySetWCHAR		( DWORD dwIndex, WCHAR );
	HRESULT	PropertySetWCHAR		( DWORD dwIndex, DWORD dwSize, WCHAR * );

	HRESULT	PropertySetDATETIME		( DWORD dwIndex, LPCWSTR );
	HRESULT	PropertySetDATETIME		( DWORD dwIndex, DWORD dwSize, LPCWSTR * );

	HRESULT	PropertySetREFERENCE	( DWORD dwIndex, LPCWSTR );
	HRESULT	PropertySetREFERENCE	( DWORD dwIndex, DWORD dwSize, LPCWSTR * );

	HRESULT	PropertySetOBJECT		( DWORD dwIndex, void* );
	HRESULT	PropertySetOBJECT		( DWORD dwIndex, DWORD dwSize, void** );

	HRESULT	PropertySet		( DWORD dwIndex, signed char );
	HRESULT	PropertySet		( DWORD dwIndex, unsigned char );
	HRESULT	PropertySet		( DWORD dwIndex, signed short );
	HRESULT	PropertySet		( DWORD dwIndex, unsigned short );
	HRESULT	PropertySet		( DWORD dwIndex, signed long );
	HRESULT	PropertySet		( DWORD dwIndex, unsigned long );
	HRESULT	PropertySet		( DWORD dwIndex, float );
	HRESULT	PropertySet		( DWORD dwIndex, double );
	HRESULT	PropertySet		( DWORD dwIndex, signed __int64 );
	HRESULT	PropertySet		( DWORD dwIndex, unsigned __int64 );

	HRESULT	PropertySet		( DWORD dwIndex, BOOL );
	HRESULT	PropertySet		( DWORD dwIndex, LPCWSTR );

	HRESULT	PropertySet		( DWORD dwIndex, DWORD dwSize, signed char * );
	HRESULT	PropertySet		( DWORD dwIndex, DWORD dwSize, unsigned char * );
	HRESULT	PropertySet		( DWORD dwIndex, DWORD dwSize, signed short * );
	HRESULT	PropertySet		( DWORD dwIndex, DWORD dwSize, unsigned short * );
	HRESULT	PropertySet		( DWORD dwIndex, DWORD dwSize, signed long * );
	HRESULT	PropertySet		( DWORD dwIndex, DWORD dwSize, unsigned long * );
	HRESULT	PropertySet		( DWORD dwIndex, DWORD dwSize, float * );
	HRESULT	PropertySet		( DWORD dwIndex, DWORD dwSize, double * );
	HRESULT	PropertySet		( DWORD dwIndex, DWORD dwSize, signed __int64 * );
	HRESULT	PropertySet		( DWORD dwIndex, DWORD dwSize, unsigned __int64 * );

	HRESULT	PropertySet		( DWORD dwIndex, DWORD dwSize, BOOL * );
	HRESULT	PropertySet		( DWORD dwIndex, DWORD dwSize, LPCWSTR * );

	HRESULT	PropertiesSet1	(	HANDLE hConnect,
								unsigned char ,
								unsigned short ,
								unsigned long ,
								float ,
								DWORD64 ,
								LPWSTR ,
								BOOL 
							);

	HRESULT	PropertiesSet2	(	HANDLE hConnect,
								DWORD dwSize,
								unsigned char *,
								unsigned short *,
								unsigned long *,
								float *,
								DWORD64 *,
								LPWSTR *,
								BOOL *
							);

	HRESULT	SetCommit		( DWORD dwFlags, ... );

	HRESULT	SetAddCommit	(	DWORD dwFlags,
								DWORD dwProps,
								LPCWSTR* pProps,
								CIMTYPE* pctProps,

								... );
};

#endif	__EVENT_OBJECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\_log.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					_log.h
//
//	Abstract:
//
//					declaration of log module and class
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__MY_LOG_H__
#define	__MY_LOG_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

#include "NonComEvent.h"
#include "NonComEventModule.h"

#define	__SUPPORT_FILE_LOG

class MyLog
{
	DECLARE_NO_COPY ( MyLog );

	// variables
	CComPtr < ICimNotify >	m_pNotify;
	#ifdef	__SUPPORT_FILE_LOG
	HANDLE					m_hFile;
	#endif	__SUPPORT_FILE_LOG

	public:

	MyLog ( IUnknown* pUnk = NULL ) :
	#ifdef	__SUPPORT_FILE_LOG
	m_pNotify ( NULL )
	#else	__SUPPORT_FILE_LOG
	m_pNotify ( NULL ),
	m_hFile	  ( NULL )
	#endif	__SUPPORT_FILE_LOG
	{
		try
		{
			if ( pUnk ) 
			{
				pUnk->QueryInterface ( __uuidof ( ICimNotify ), (void**) &m_pNotify );
			}
			#ifdef	__SUPPORT_FILE_LOG
			else
			{
				m_hFile = ::CreateFileW	(	L"\\LogFile_NonCOMEventTest_TOOL.txt" ,
											GENERIC_WRITE,
											FILE_SHARE_READ | FILE_SHARE_WRITE,
											NULL,
											OPEN_ALWAYS,
											FILE_ATTRIBUTE_NORMAL | SECURITY_ANONYMOUS,
											NULL
										);

				if ( m_hFile != INVALID_HANDLE_VALUE && m_hFile )
				{
					LARGE_INTEGER li;

					li.LowPart = 0L;
					li.HighPart = 0L;

					::SetFilePointerEx ( m_hFile, li, NULL, FILE_END );
				}
				else
				{
					m_hFile = NULL;
				}
			}
			#endif	__SUPPORT_FILE_LOG
		}
		catch ( ... )
		{
		}
	}

	virtual ~MyLog ()
	{
		Uninit();

		#ifdef	__SUPPORT_FILE_LOG
		if ( m_hFile )
		{
			::CloseHandle ( m_hFile );
			m_hFile = NULL;
		}
		#endif	__SUPPORT_FILE_LOG
	}

	HRESULT Uninit ()
	{
		if ( !m_pNotify )
		{
			return S_FALSE;
		}

		m_pNotify.Release();
		return S_OK;
	}

	HRESULT Log ( LPWSTR wszName, HRESULT hrOld, DWORD dwCountStrings = 0L, ... );
};

#endif	__MY_LOG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\_enum.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					_enum.h
//
//	Abstract:
//
//					declaration of enumerator module
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__ENUM_H__
#define	__ENUM_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

class MyEnum
{
	DECLARE_NO_COPY ( MyEnum );

	IWbemServices*			m_pServices;
	IEnumWbemClassObject *	m_pEnum;

	public:

	//////////////////////////////////////////////////////////////////////////////////////////
	// construction & destruction
	//////////////////////////////////////////////////////////////////////////////////////////

	MyEnum (  ) :
		m_pEnum ( NULL ),
		m_pServices ( NULL )
	{
	}

	MyEnum ( IWbemLocator* pLocator, LPWSTR wszNamespace ) :
		m_pEnum ( NULL ),
		m_pServices ( NULL )
	{
		MyEnumInit ( pLocator, wszNamespace );
	}

	virtual ~MyEnum ()
	{
		MyEnumUninit ( );
	}

	//////////////////////////////////////////////////////////////////////////////////////////
	// functions
	//////////////////////////////////////////////////////////////////////////////////////////

	// execute query to get all objects
	HRESULT ExecQuery	(	LPWSTR szQueryLang,
							LPWSTR szQuery,
							LONG lFlag  = WBEM_FLAG_FORWARD_ONLY
						);

	// execute query to get all instancess
	HRESULT ExecInstancesQuery	(	LPWSTR szClassName,
									LONG lFlag  = WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_DEEP
								);

	// return next object from enumerator
	HRESULT	NextObject	( IWbemClassObject** ppObject );

	// return next objects from enumerator
	HRESULT	NextObjects	( ULONG uObjects, ULONG* puObjects, IWbemClassObject** ppObject );

	void MyEnumUninit	( void );
	void MyEnumInit		( IWbemLocator* pLocator, LPWSTR wszNamespace );
};

#endif	__ENUM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\__macro_behaviour.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					__macro_behaviour.h
//
//	Abstract:
//
//					behaviour of application
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////// Behaviour /////////////////////////////////////

#ifndef	__BEHAVIOUR__
#define	__BEHAVIOUR__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

#endif	__BEHAVIOUR__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\_eventobjects.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					_EventObjects.h
//
//	Abstract:
//
//					declaration of common NonCOM Event Generic Object
//					declaration of common NonCOM Event Normal Object
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__EVENT_OBJECT_GENERIC_H__
#define	__EVENT_OBJECT_GENERIC_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// disable warning regarding to virtual inheritance
#pragma warning( disable : 4250 )

#include "_EventObject.h"

class MyEventObjectGeneric : virtual public MyEventObjectAbstract
{
	DECLARE_NO_COPY ( MyEventObjectGeneric );

	public:

	////////////////////////////////////////////////////////////////////////////////
	//	construction & destruction
	////////////////////////////////////////////////////////////////////////////////

	MyEventObjectGeneric() : MyEventObjectAbstract ( )
	{
	}

	virtual ~MyEventObjectGeneric()
	{
	}

	////////////////////////////////////////////////////////////////////////////////
	//	functions
	////////////////////////////////////////////////////////////////////////////////

	virtual	HRESULT	AddProperty	( LPWSTR , CIMTYPE )
	{
		return E_NOTIMPL;
	}

	virtual HRESULT EventReport1	(	HANDLE hConnect,
										signed char			cVar,
										unsigned char		ucVar,
										signed short		sVar,
										unsigned short		usVar,
										signed long			lVar,
										unsigned long		ulVar,
										signed __int64		i64Var,
										unsigned __int64	ui64Var,
										float				fVar,
										double				dVar,
										BOOL 				b,
										LPWSTR				wsz,
										WCHAR				wcVar,
										void*				objVar
									);

	virtual HRESULT EventReport2	(	HANDLE hConnect,
										DWORD dwSize,
										signed char*		cVar,
										unsigned char*		ucVar,
										signed short*		sVar,
										unsigned short*		usVar,
										signed long*		lVar,
										unsigned long*		ulVar,
										signed __int64*		i64Var,
										unsigned __int64*	ui64Var,
										float*				fVar,
										double*				dVar,
										BOOL* 				b,
										LPWSTR*				wsz,
										WCHAR*				wcVar,
										void*				objVar
									);
};

class MyEventObjectNormalNoReport : public MyEventObject
{
	DECLARE_NO_COPY ( MyEventObjectNormalNoReport );

	public:

	MyEventObjectNormalNoReport():MyEventObject()
	{
	}

	virtual HRESULT EventReport1	(	HANDLE,
										signed char			,//cVar,
										unsigned char		,//ucVar,
										signed short		,//sVar,
										unsigned short		,//usVar,
										signed long			,//lVar,
										unsigned long		,//ulVar,
										signed __int64		,//i64Var,
										unsigned __int64	,//ui64Var,
										float				,//fVar,
										double				,//dVar,
										BOOL 				,//b,
										LPWSTR				,//wsz,
										WCHAR				,//wcVar,
										void*				 //objVar
									)
	{
		return E_NOTIMPL;
	}

	virtual HRESULT EventReport2	(	HANDLE,
										DWORD,
										signed char*		,//cVar,
										unsigned char*		,//ucVar,
										signed short*		,//sVar,
										unsigned short*		,//usVar,
										signed long*		,//lVar,
										unsigned long*		,//ulVar,
										signed __int64*		,//i64Var,
										unsigned __int64*	,//ui64Var,
										float*				,//fVar,
										double*				,//dVar,
										BOOL* 				,//b,
										LPWSTR*				,//wsz,
										WCHAR*				,//wcVar,
										void*				 //objVar
									)
	{
		return E_NOTIMPL;
	}
};

class MyEventObjectNormal : public MyEventObject,
							public MyEventObjectGeneric
							
{
	DECLARE_NO_COPY ( MyEventObjectNormal );

	public:

	MyEventObjectNormal():
		MyEventObject(),
		MyEventObjectGeneric()
	{
	}

	virtual HRESULT Init			( LPWSTR Name, LPWSTR NameShow = NULL, LPWSTR Query = NULL)
	{
		return MyEventObject::Init ( Name, NameShow, Query );
	}
};

#endif	__EVENT_OBJECT_GENERIC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\_module.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					_module.h
//
//	Abstract:
//
//					declaration of CComModule extension
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__MODULE_H__
#define	__MODULE_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

#ifndef	__ATLBASE_H__
#include <atlbase.h>
#endif	__ATLBASE_H__

// need wtl
#include <atlapp.h>

class MyModule : public CAppModule
{
	DECLARE_NO_COPY ( MyModule );

	HANDLE	m_hEventShutdown;
	bool	m_bActivity;

	HANDLE	m_hThread;

	public:

	///////////////////////////////////////////////////////////////////////////////////////////////
	// construction & destruction
	///////////////////////////////////////////////////////////////////////////////////////////////

	MyModule() :
		m_bActivity ( false ),
		m_hEventShutdown ( NULL ),
		m_hThread ( NULL )
	{
	}

	virtual ~MyModule();

	///////////////////////////////////////////////////////////////////////////////////////////////
	// functions
	///////////////////////////////////////////////////////////////////////////////////////////////

	LONG Unlock();
	void MonitorShutdown();
	bool MonitorShutdownStart();

	static DWORD WINAPI MonitorShutdownProc ( LPVOID pData );

	void ShutDown ()
	{
		if ( m_hEventShutdown )
		{
			SetEvent(m_hEventShutdown);
		}
	}
};

extern MyModule _Module;

#ifndef	__ATLCOM_H__
#include <atlcom.h>
#endif	__ATLCOM_H__

#include <atlwin.h>
#include <atlctrls.h>

#endif	__MODULE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\_test.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					_test.h
//
//	Abstract:
//
//					declaration of test module and class
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__MY_TEST_H__
#define	__MY_TEST_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

#include "_App.h"
extern MyApp _App;

#include "_Module.h"

// includes

#include "Enumerator.h"

#include "_Connect.h"
#include "_EventObject.h"
#include "_EventObjects.h"

enum Types
{
	_string,
	_datetime,
	_reference,
	_char16,
	_uint16
};

class MyTest
{
	DECLARE_NO_COPY ( MyTest );

	public:

	MyTest()
	{
	}

	virtual ~MyTest()
	{
	}

	static BOOL	Commit		( HANDLE hEvent );
	static BOOL	CommitSet	( HANDLE hEvent, ... );

	BOOL	TestScalarOne ( LPWSTR wszName, signed char );
	BOOL	TestScalarOne ( LPWSTR wszName, unsigned char );
	BOOL	TestScalarOne ( LPWSTR wszName, signed short );
	BOOL	TestScalarOne ( LPWSTR wszName, Types, unsigned short );
	BOOL	TestScalarOne ( LPWSTR wszName, signed long );
	BOOL	TestScalarOne ( LPWSTR wszName, unsigned long );
	BOOL	TestScalarOne ( LPWSTR wszName, float );
	BOOL	TestScalarOne ( LPWSTR wszName, double );
	BOOL	TestScalarOne ( LPWSTR wszName, signed __int64 );
	BOOL	TestScalarOne ( LPWSTR wszName, unsigned __int64 );
	BOOL	TestScalarOne ( LPWSTR wszName, BOOL );
	BOOL	TestScalarOne ( LPWSTR wszName, Types, LPCWSTR );
	BOOL	TestScalarOne ( LPWSTR wszName, void* );

	BOOL	TestScalarTwo ( LPWSTR wszName, signed char );
	BOOL	TestScalarTwo ( LPWSTR wszName, unsigned char );
	BOOL	TestScalarTwo ( LPWSTR wszName, signed short );
	BOOL	TestScalarTwo ( LPWSTR wszName, Types, unsigned short );
	BOOL	TestScalarTwo ( LPWSTR wszName, signed long );
	BOOL	TestScalarTwo ( LPWSTR wszName, unsigned long );
	BOOL	TestScalarTwo ( LPWSTR wszName, float );
	BOOL	TestScalarTwo ( LPWSTR wszName, double );
	BOOL	TestScalarTwo ( LPWSTR wszName, signed __int64 );
	BOOL	TestScalarTwo ( LPWSTR wszName, unsigned __int64 );
	BOOL	TestScalarTwo ( LPWSTR wszName, BOOL );
	BOOL	TestScalarTwo ( LPWSTR wszName, Types, LPCWSTR );
	BOOL	TestScalarTwo ( LPWSTR wszName, void* );

	BOOL	TestScalarThree ( LPWSTR wszName, signed char );
	BOOL	TestScalarThree ( LPWSTR wszName, unsigned char );
	BOOL	TestScalarThree ( LPWSTR wszName, signed short );
	BOOL	TestScalarThree ( LPWSTR wszName, Types, unsigned short );
	BOOL	TestScalarThree ( LPWSTR wszName, signed long );
	BOOL	TestScalarThree ( LPWSTR wszName, unsigned long );
	BOOL	TestScalarThree ( LPWSTR wszName, float );
	BOOL	TestScalarThree ( LPWSTR wszName, double );
	BOOL	TestScalarThree ( LPWSTR wszName, signed __int64 );
	BOOL	TestScalarThree ( LPWSTR wszName, unsigned __int64 );
	BOOL	TestScalarThree ( LPWSTR wszName, BOOL );
	BOOL	TestScalarThree ( LPWSTR wszName, Types, LPCWSTR );
	BOOL	TestScalarThree ( LPWSTR wszName, void* );

	BOOL	TestScalarFour ( LPWSTR wszName, signed char );
	BOOL	TestScalarFour ( LPWSTR wszName, unsigned char );
	BOOL	TestScalarFour ( LPWSTR wszName, signed short );
	BOOL	TestScalarFour ( LPWSTR wszName, Types, unsigned short );
	BOOL	TestScalarFour ( LPWSTR wszName, signed long );
	BOOL	TestScalarFour ( LPWSTR wszName, unsigned long );
	BOOL	TestScalarFour ( LPWSTR wszName, float );
	BOOL	TestScalarFour ( LPWSTR wszName, double );
	BOOL	TestScalarFour ( LPWSTR wszName, signed __int64 );
	BOOL	TestScalarFour ( LPWSTR wszName, unsigned __int64 );
	BOOL	TestScalarFour ( LPWSTR wszName, BOOL );
	BOOL	TestScalarFour ( LPWSTR wszName, Types, LPCWSTR );
	BOOL	TestScalarFour ( LPWSTR wszName, void* );

	BOOL	TestScalarFive ( LPWSTR wszName, signed char );
	BOOL	TestScalarFive ( LPWSTR wszName, unsigned char );
	BOOL	TestScalarFive ( LPWSTR wszName, signed short );
	BOOL	TestScalarFive ( LPWSTR wszName, Types, unsigned short );
	BOOL	TestScalarFive ( LPWSTR wszName, signed long );
	BOOL	TestScalarFive ( LPWSTR wszName, unsigned long );
	BOOL	TestScalarFive ( LPWSTR wszName, float );
	BOOL	TestScalarFive ( LPWSTR wszName, double );
	BOOL	TestScalarFive ( LPWSTR wszName, signed __int64 );
	BOOL	TestScalarFive ( LPWSTR wszName, unsigned __int64 );
	BOOL	TestScalarFive ( LPWSTR wszName, BOOL );
	BOOL	TestScalarFive ( LPWSTR wszName, Types, LPCWSTR );
	BOOL	TestScalarFive ( LPWSTR wszName, void* );

	BOOL	TestScalarSix ( LPWSTR wszName, signed char );
	BOOL	TestScalarSix ( LPWSTR wszName, unsigned char );
	BOOL	TestScalarSix ( LPWSTR wszName, signed short );
	BOOL	TestScalarSix ( LPWSTR wszName, Types, unsigned short );
	BOOL	TestScalarSix ( LPWSTR wszName, signed long );
	BOOL	TestScalarSix ( LPWSTR wszName, unsigned long );
	BOOL	TestScalarSix ( LPWSTR wszName, float );
	BOOL	TestScalarSix ( LPWSTR wszName, double );
	BOOL	TestScalarSix ( LPWSTR wszName, signed __int64 );
	BOOL	TestScalarSix ( LPWSTR wszName, unsigned __int64 );
	BOOL	TestScalarSix ( LPWSTR wszName, BOOL );
	BOOL	TestScalarSix ( LPWSTR wszName, Types, LPCWSTR );
	BOOL	TestScalarSix ( LPWSTR wszName, void* );

	BOOL	TestArrayOne ( LPWSTR wszName, DWORD dwSize, signed char * );
	BOOL	TestArrayOne ( LPWSTR wszName, DWORD dwSize, unsigned char * );
	BOOL	TestArrayOne ( LPWSTR wszName, DWORD dwSize, signed short * );
	BOOL	TestArrayOne ( LPWSTR wszName, Types, DWORD dwSize, unsigned short * );
	BOOL	TestArrayOne ( LPWSTR wszName, DWORD dwSize, signed long * );
	BOOL	TestArrayOne ( LPWSTR wszName, DWORD dwSize, unsigned long * );
	BOOL	TestArrayOne ( LPWSTR wszName, DWORD dwSize, float * );
	BOOL	TestArrayOne ( LPWSTR wszName, DWORD dwSize, double * );
	BOOL	TestArrayOne ( LPWSTR wszName, DWORD dwSize, signed __int64 * );
	BOOL	TestArrayOne ( LPWSTR wszName, DWORD dwSize, unsigned __int64 * );
	BOOL	TestArrayOne ( LPWSTR wszName, DWORD dwSize, BOOL * );
	BOOL	TestArrayOne ( LPWSTR wszName, Types, DWORD dwSize, LPCWSTR * );
	BOOL	TestArrayOne ( LPWSTR wszName, DWORD dwSize, void** );

	BOOL	TestArrayTwo ( LPWSTR wszName, DWORD dwSize, signed char * );
	BOOL	TestArrayTwo ( LPWSTR wszName, DWORD dwSize, unsigned char * );
	BOOL	TestArrayTwo ( LPWSTR wszName, DWORD dwSize, signed short * );
	BOOL	TestArrayTwo ( LPWSTR wszName, Types, DWORD dwSize, unsigned short * );
	BOOL	TestArrayTwo ( LPWSTR wszName, DWORD dwSize, signed long * );
	BOOL	TestArrayTwo ( LPWSTR wszName, DWORD dwSize, unsigned long * );
	BOOL	TestArrayTwo ( LPWSTR wszName, DWORD dwSize, float * );
	BOOL	TestArrayTwo ( LPWSTR wszName, DWORD dwSize, double * );
	BOOL	TestArrayTwo ( LPWSTR wszName, DWORD dwSize, signed __int64 * );
	BOOL	TestArrayTwo ( LPWSTR wszName, DWORD dwSize, unsigned __int64 * );
	BOOL	TestArrayTwo ( LPWSTR wszName, DWORD dwSize, BOOL * );
	BOOL	TestArrayTwo ( LPWSTR wszName, Types, DWORD dwSize, LPCWSTR * );
	BOOL	TestArrayTwo ( LPWSTR wszName, DWORD dwSize, void** );

	BOOL	TestArrayThree ( LPWSTR wszName, DWORD dwSize, signed char * );
	BOOL	TestArrayThree ( LPWSTR wszName, DWORD dwSize, unsigned char * );
	BOOL	TestArrayThree ( LPWSTR wszName, DWORD dwSize, signed short * );
	BOOL	TestArrayThree ( LPWSTR wszName, Types, DWORD dwSize, unsigned short * );
	BOOL	TestArrayThree ( LPWSTR wszName, DWORD dwSize, signed long * );
	BOOL	TestArrayThree ( LPWSTR wszName, DWORD dwSize, unsigned long * );
	BOOL	TestArrayThree ( LPWSTR wszName, DWORD dwSize, float * );
	BOOL	TestArrayThree ( LPWSTR wszName, DWORD dwSize, double * );
	BOOL	TestArrayThree ( LPWSTR wszName, DWORD dwSize, signed __int64 * );
	BOOL	TestArrayThree ( LPWSTR wszName, DWORD dwSize, unsigned __int64 * );
	BOOL	TestArrayThree ( LPWSTR wszName, DWORD dwSize, BOOL * );
	BOOL	TestArrayThree ( LPWSTR wszName, Types, DWORD dwSize, LPCWSTR * );
	BOOL	TestArrayThree ( LPWSTR wszName, DWORD dwSize, void** );

	BOOL	TestArrayFour ( LPWSTR wszName, DWORD dwSize, signed char * );
	BOOL	TestArrayFour ( LPWSTR wszName, DWORD dwSize, unsigned char * );
	BOOL	TestArrayFour ( LPWSTR wszName, DWORD dwSize, signed short * );
	BOOL	TestArrayFour ( LPWSTR wszName, Types, DWORD dwSize, unsigned short * );
	BOOL	TestArrayFour ( LPWSTR wszName, DWORD dwSize, signed long * );
	BOOL	TestArrayFour ( LPWSTR wszName, DWORD dwSize, unsigned long * );
	BOOL	TestArrayFour ( LPWSTR wszName, DWORD dwSize, float * );
	BOOL	TestArrayFour ( LPWSTR wszName, DWORD dwSize, double * );
	BOOL	TestArrayFour ( LPWSTR wszName, DWORD dwSize, signed __int64 * );
	BOOL	TestArrayFour ( LPWSTR wszName, DWORD dwSize, unsigned __int64 * );
	BOOL	TestArrayFour ( LPWSTR wszName, DWORD dwSize, BOOL * );
	BOOL	TestArrayFour ( LPWSTR wszName, Types, DWORD dwSize, LPCWSTR * );
	BOOL	TestArrayFour ( LPWSTR wszName, DWORD dwSize, void** );

	BOOL	TestArrayFive ( LPWSTR wszName, DWORD dwSize, signed char * );
	BOOL	TestArrayFive ( LPWSTR wszName, DWORD dwSize, unsigned char * );
	BOOL	TestArrayFive ( LPWSTR wszName, DWORD dwSize, signed short * );
	BOOL	TestArrayFive ( LPWSTR wszName, Types, DWORD dwSize, unsigned short * );
	BOOL	TestArrayFive ( LPWSTR wszName, DWORD dwSize, signed long * );
	BOOL	TestArrayFive ( LPWSTR wszName, DWORD dwSize, unsigned long * );
	BOOL	TestArrayFive ( LPWSTR wszName, DWORD dwSize, float * );
	BOOL	TestArrayFive ( LPWSTR wszName, DWORD dwSize, double * );
	BOOL	TestArrayFive ( LPWSTR wszName, DWORD dwSize, signed __int64 * );
	BOOL	TestArrayFive ( LPWSTR wszName, DWORD dwSize, unsigned __int64 * );
	BOOL	TestArrayFive ( LPWSTR wszName, DWORD dwSize, BOOL * );
	BOOL	TestArrayFive ( LPWSTR wszName, Types, DWORD dwSize, LPCWSTR * );
	BOOL	TestArrayFive ( LPWSTR wszName, DWORD dwSize, void** );

	BOOL	TestArraySix ( LPWSTR wszName, DWORD dwSize, signed char * );
	BOOL	TestArraySix ( LPWSTR wszName, DWORD dwSize, unsigned char * );
	BOOL	TestArraySix ( LPWSTR wszName, DWORD dwSize, signed short * );
	BOOL	TestArraySix ( LPWSTR wszName, Types, DWORD dwSize, unsigned short * );
	BOOL	TestArraySix ( LPWSTR wszName, DWORD dwSize, signed long * );
	BOOL	TestArraySix ( LPWSTR wszName, DWORD dwSize, unsigned long * );
	BOOL	TestArraySix ( LPWSTR wszName, DWORD dwSize, float * );
	BOOL	TestArraySix ( LPWSTR wszName, DWORD dwSize, double * );
	BOOL	TestArraySix ( LPWSTR wszName, DWORD dwSize, signed __int64 * );
	BOOL	TestArraySix ( LPWSTR wszName, DWORD dwSize, unsigned __int64 * );
	BOOL	TestArraySix ( LPWSTR wszName, DWORD dwSize, BOOL * );
	BOOL	TestArraySix ( LPWSTR wszName, Types, DWORD dwSize, LPCWSTR * );
	BOOL	TestArraySix ( LPWSTR wszName, DWORD dwSize, void** );
};

#endif	__MY_TEST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\__common_log.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					__Common_Log.h
//
//	Abstract:
//
//					logging of events into file
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////// smart pointers ///////////////////////////////////

#ifndef	__LOG__
#define	__LOG__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// need smart
#ifndef	__SMART_POINTERS__
#include "__Common_SmartPTR.h"
#endif	__SMART_POINTERS__

class __Log
{
	__Log ( __Log& )					{};
	__Log& operator= ( const __Log& )	{};

	__SmartHANDLE	m_hFile;

	public:

	__Log ( LPWSTR lpwszName )
	{
		if ( lpwszName )
		{
			m_hFile = ::CreateFileW	(	lpwszName,
										GENERIC_WRITE,
										FILE_SHARE_READ,
										NULL,
										CREATE_ALWAYS,
										FILE_ATTRIBUTE_NORMAL | SECURITY_ANONYMOUS,
										NULL
									);
		}
	}

	virtual ~__Log ()
	{
	}

	DWORD	ReportEvent ( LPWSTR wszEvent )
	{
		// auto lock/unlock
		__Smart_CRITICAL_SECTION cs;

		if ( wszEvent && m_hFile.GetHANDLE() && m_hFile.GetHANDLE() != INVALID_HANDLE_VALUE )
		{
			USES_CONVERSION;

			DWORD written = 0;

			::WriteFile (	m_hFile,
							W2A ( wszEvent ),
							( lstrlenW ( wszEvent ) + 1 ) * sizeof ( char ),
							&written,
							NULL
						);

//			::WriteFile (	m_hFile,
//							wszEvent,
//							( lstrlenW ( wszEvent ) + 1 ) * sizeof ( WCHAR ),
//							&written,
//							NULL
//						);

			return static_cast< DWORD > ( HRESULT_TO_WIN32 ( S_OK ) );
		}

		return static_cast< DWORD > ( HRESULT_TO_WIN32 ( E_UNEXPECTED ) );
	}
};

#endif	__LOG__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\__common_convert.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					__Common_Convert.h
//
//	Abstract:
//
//					convertion routines used anywhere
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////// CommonConvert ///////////////////////////////////

#ifndef	__COMMON_CONVERT__
#define	__COMMON_CONVERT__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

//////////////////////////////////////////////////////////////////////////////////////////////
// class for string operations
//////////////////////////////////////////////////////////////////////////////////////////////

class __String
{
	__String ( __String& )					{}
	__String& operator= ( const __String& )	{}

	public:

	//////////////////////////////////////////////////////////////////////////////////////////
	// construction & destruction
	//////////////////////////////////////////////////////////////////////////////////////////

	__String ()
	{
	}

	virtual ~__String ()
	{
	}

	//////////////////////////////////////////////////////////////////////////////////////////
	// functions
	//////////////////////////////////////////////////////////////////////////////////////////

	static void SetStringCopy ( LPWSTR& wszDest, LPWSTR& wsz )
	{
		___ASSERT( wszDest == NULL );

		if ( wsz )
		{
			try
			{
				if ( ( wszDest = new WCHAR[ (lstrlenW ( wsz ) + 1) ] ) != NULL )
				{
					lstrcpyW ( wszDest, wsz );
				}
			}
			catch ( ... )
			{
				if ( wszDest )
				{
					delete wszDest;
					wszDest = NULL;
				}
			}
		}
	}
};

//////////////////////////////////////////////////////////////////////////////////////////////
// class for string release
//////////////////////////////////////////////////////////////////////////////////////////////

class __Release
{
	__Release ( __Release& )					{}
	__Release& operator= ( const __Release& )	{}

	public:

	//////////////////////////////////////////////////////////////////////////////////////////
	// construction & destruction
	//////////////////////////////////////////////////////////////////////////////////////////

	__Release ()
	{
	}

	virtual ~__Release ()
	{
	}

	//////////////////////////////////////////////////////////////////////////////////////////
	// functions
	//////////////////////////////////////////////////////////////////////////////////////////

	static HRESULT Release ( void** ppsz )
	{
		if ( ppsz && (*ppsz) )
		{
			delete [] (*ppsz);
			(*ppsz) = NULL;

			return S_OK;
		}

		return S_FALSE;
	}

	static HRESULT Release ( void*** ppsz, DWORD* dwsz )
	{
		if ( ppsz && (*ppsz) )
		{
			if ( dwsz )
			{
				for ( DWORD dwIndex = 0; dwIndex < (*dwsz); dwIndex++ )
				{
					delete (*ppsz)[dwIndex];
					(*ppsz)[dwIndex] = NULL;
				}

				(*dwsz) = NULL;
			}

			delete [] (*ppsz);
			(*ppsz) = NULL;

			return S_OK;
		}

		return S_FALSE;
	}

	static HRESULT Release ( SAFEARRAY* psa )
	{
		if ( psa )
		{
			::SafeArrayDestroy ( psa );
			psa = NULL;

			return S_OK;
		}

		return S_FALSE;
	}

};

//////////////////////////////////////////////////////////////////////////////////////////////
// class for string converion handling
//////////////////////////////////////////////////////////////////////////////////////////////

class __StringConvert
{
	__StringConvert ( __StringConvert& )					{}
	__StringConvert& operator= ( const __StringConvert& )	{}

	public:

	//////////////////////////////////////////////////////////////////////////////////////////
	// construction & destruction
	//////////////////////////////////////////////////////////////////////////////////////////

	__StringConvert ()
	{
	}

	virtual ~__StringConvert ()
	{
	}

};

//////////////////////////////////////////////////////////////////////////////////////////////
// macros
//////////////////////////////////////////////////////////////////////////////////////////////

#define	RELEASE_ARRAY( ppwsz )\
__Release::Release( ( void** ) &ppwsz )

#define	RELEASE_DOUBLEARRAY( ppwsz, dwsz )\
__Release::Release( ( void*** ) &ppwsz, &dwsz )

#define	RELEASE_SAFEARRAY( psa )\
__Release::Release( psa )


// HRESULT -> WIN32
#define HRESULT_TO_WIN32(hres) ((HRESULT_FACILITY(hres) == FACILITY_WIN32) ? HRESULT_CODE(hres) : (hres))

#endif	__COMMON_CONVERT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\__macro_eventlog.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					__macro_eventlog.h
//
//	Abstract:
//
//					event log helpers and behaviours
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////// EventLog ////////////////////////////////////////

#ifndef	__EVENT_LOG__
#define	__EVENT_LOG__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000


#endif	__EVENT_LOG__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\__macro_assert.h ===
///////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					__macro_assert.h
//
//	Abstract:
//
//					assertion and verify macros and helpers
//
//	History:
//
//					initial		a-marius
//
///////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////// Assert/Verify Macros ///////////////////////////////////

#ifndef	__ASSERT_VERIFY__
#define	__ASSERT_VERIFY__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// set behaviour of macros
#ifdef	_DEBUG
//#define	__SHOW_MSGBOX
#endif	_DEBUG

///////////////////////////////////////////////////////////////////////////////////////////
// macros
///////////////////////////////////////////////////////////////////////////////////////////

// call DebugBreak if in debug mode
#ifdef	_DEBUG
inline void ForceDebugBreak ( void )
{
	__try
	{ 
		DebugBreak(); 
	}
	__except(UnhandledExceptionFilter(GetExceptionInformation()))
	{
	}
}
#else	_DEBUG
#define ForceDebugBreak()
#endif	_DEBUG

// show error and throw break

#ifdef	__SHOW_MSGBOX
#define ___FAIL(szMSG, szTitle)\
(\
	MessageBoxW(GetActiveWindow(), szMSG, szTitle, MB_OK | MB_ICONERROR),\
	ForceDebugBreak()\
)
#else	__SHOW_MSGBOX
#define ___FAIL(szMSG, szTitle)\
(\
	ForceDebugBreak()\
)
#endif	__SHOW_MSGBOX

// Put up an assertion failure
#define ___ASSERTFAIL(file,line,expr,title)\
{\
	WCHAR sz[256] = { L'\0' };\
	wsprintfW(sz, L"File %hs, line %d : %hs", file, line, expr);\
	___FAIL(sz, title);\
}

// Assert in debug builds, but don't remove the code in retail builds.

#ifdef	_DEBUG
#define ___ASSERT(x) if (!(x)) ___ASSERTFAIL(__FILE__, __LINE__, #x, L"Assert Failed")
#else	_DEBUG
#define ___ASSERT(x)
#endif	_DEBUG

#ifdef	_DEBUG
#define ___ASSERT_DESC(x, desc) if (!(x)) ___ASSERTFAIL(__FILE__, __LINE__, #desc, L"Assert Failed")
#else	_DEBUG
#define ___ASSERT_DESC(x, desc)
#endif	_DEBUG

#ifdef	_DEBUG
#define	___VERIFY(x) ___ASSERT(x)
#else	_DEBUG
#define	___VERIFY(x) (x)
#endif	_DEBUG

#endif	__ASSERT_VERIFY__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\__macro_err.h ===
//////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					__macro_err.h
//
//	Abstract:
//
//					error handling helpers and macros
//
//	History:
//
//					initial		a-marius
//
///////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////// error & trace Macros ///////////////////////////////////

#ifndef	__WMI_PERF_ERR__
#define	__WMI_PERF_ERR__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// need atl wrappers
#ifndef	__ATLBASE_H__
#include <atlbase.h>
#endif	__ATLBASE_H__

// need macros :)))
#ifndef	__ASSERT_VERIFY__
#include <__macro_assert.h>
#endif	__ASSERT_VERIFY__

// trace description
#ifdef	_DEBUG
#define	___TRACE( x )\
(\
	AtlTrace( _TEXT( "\n error ... %hs(%d)" ), __FILE__, __LINE__ ),\
	AtlTrace( _TEXT( "\n DESCRIPTION : %s" ), x ),\
	AtlTrace( _TEXT( "\n" ) )\
)
#else	_DEBUG
#define	___TRACE( x )
#endif	_DEBUG

#ifdef	_DEBUG
#define	___TRACE_ERROR( x,err )\
(\
	AtlTrace( _TEXT( "\n error ... %hs(%d)" ), __FILE__, __LINE__ ),\
	AtlTrace( _TEXT( "\n DESCRIPTION  : %s" ), x ),\
	AtlTrace( _TEXT( "\n ERROR NUMBER : 0x%x" ), err ),\
	AtlTrace( _TEXT( "\n" ) )\
)
#else	_DEBUG
#define	___TRACE_ERROR( x, err )
#endif	_DEBUG

inline LPWSTR	GetErrorMessageSystem ( void );
inline LPWSTR	GetErrorMessageSystem ( DWORD dwError );

inline LPWSTR	GetErrorMessageModule ( DWORD dwError, HMODULE handle = NULL );

// stack allocation
inline LPWSTR	GetErrorMessage ( LPWSTR sz, LPWSTR szSource )
{
	if ( sz && szSource )
	{
		lstrcpyW ( sz, szSource );

		delete ( szSource );
		szSource = NULL;

		return sz;
	}

	return NULL;
}

inline LPWSTR	GetErrorMessage ( LPWSTR sz, DWORD err )
{
	wsprintfW ( sz, L"unspecified error : 0x%x", err );
	return sz;
}

//////////////////////////////////////////////////////////////////////////////////////////////
// macros
//////////////////////////////////////////////////////////////////////////////////////////////
#pragma warning( disable : 4003 )

#ifdef	_DEBUG
#define	ERRORMESSAGE_DEFINITION	LPWSTR szErrorMessage = NULL;
#else	! _DEBUG
#define	ERRORMESSAGE_DEFINITION
#endif	_DEBUG

#ifdef	_DEBUG

// system
#define ERRORMESSAGE(dwError)\
szErrorMessage = GetErrorMessageSystem(dwError),\
(\
	( !szErrorMessage ) ? \
	(\
		___TRACE_ERROR ( L"unresolved error was occured !", dwError ),\
		___FAIL (	GetErrorMessage	(\
										(LPWSTR) alloca ( 32 * sizeof ( WCHAR ) ),\
										dwError\
									),\
					L"Error occured"\
				)\
	)\
	:\
	(\
		___TRACE ( szErrorMessage ),\
		___FAIL (	GetErrorMessage	(\
										(LPWSTR) alloca ( ( lstrlenW ( szErrorMessage ) + 1 ) * sizeof ( WCHAR ) ),\
										szErrorMessage\
									),\
					L"Error occured"\
				)\
	)\
)

// module
#define ERRORMESSAGE1(dwError, handle)\
szErrorMessage = GetErrorMessageModule(dwError, handle),\
(\
	( !szErrorMessage ) ? \
	(\
		___TRACE_ERROR ( L"unresolved error was occured !", dwError ),\
		___FAIL (	GetErrorMessage	(\
										(LPWSTR) alloca ( 32 * sizeof ( WCHAR ) ),\
										dwError\
									),\
					L"Error occured"\
				)\
	)\
	:\
	(\
		___TRACE ( szErrorMessage ),\
		___FAIL (	GetErrorMessage	(\
										(LPWSTR) alloca ( ( lstrlenW ( szErrorMessage ) + 1 ) * sizeof ( WCHAR ) ),\
										szErrorMessage\
									),\
					L"Error occured"\
				)\
	)\
)
#else	!_DEBUG
#define	ERRORMESSAGE(dwError)
#define	ERRORMESSAGE1(dwError, handle)
#endif	_DEBUG

#define	ERRORMESSAGE_RETURN(dwError)\
{\
	ERRORMESSAGE( dwError );\
	return dwError;\
}

#define	ERRORMESSAGE_EXIT(dwError)\
{\
	ERRORMESSAGE( dwError );\
	return;\
}

#define	ERRORMESSAGE1_RETURN(dwError, handle)\
{\
	ERRORMESSAGE1( dwError, handle );\
	return dwError;\
}

#define	ERRORMESSAGE1_EXIT(dwError, handle)\
{\
	ERRORMESSAGE1( dwError, handle );\
	return;\
}

//////////////////////////////////////////////////////////////////////////////////////////////
// class for wrapping error handling
//////////////////////////////////////////////////////////////////////////////////////////////

class __Error
{
	__Error ( __Error& )					{}
	__Error& operator= ( const __Error& )	{}

	public:

	//////////////////////////////////////////////////////////////////////////////////////////
	// construction & destruction
	//////////////////////////////////////////////////////////////////////////////////////////

	__Error ()
	{
	}

	virtual ~__Error ()
	{
	}

	//////////////////////////////////////////////////////////////////////////////////////////
	// functions
	//////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////
	// Function name	: GetMessageFromError
	// Description		: returns resolved error message or NULL
	// Return type		: LPWSTR 
	// Argument			: DWORD
	// Note				: user has to free returned string

	inline static LPWSTR GetMessageFromError( DWORD dwError )
	{
		LPVOID		lpMsgBuf = NULL;
		LPWSTR		szResult = NULL;

		try
		{
			FormatMessageW(	FORMAT_MESSAGE_ALLOCATE_BUFFER | 
							FORMAT_MESSAGE_FROM_SYSTEM |
							FORMAT_MESSAGE_IGNORE_INSERTS,
							NULL,
							dwError,
							MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
							(LPWSTR) &lpMsgBuf,
							0,
							NULL );

			if( lpMsgBuf )
			{
				if ( ( szResult = (LPWSTR) new WCHAR[ lstrlenW ( (LPWSTR)lpMsgBuf ) + 1 ] ) != NULL )
				{
					lstrcpyW( szResult, (LPWSTR)lpMsgBuf );
				}

				LocalFree( lpMsgBuf );
			}
		}
		catch ( ... )
		{
			if ( lpMsgBuf )
			{
				LocalFree( lpMsgBuf );
			}
		}

		return szResult;
	}

	//////////////////////////////////////////////////////////////////////////////////////////
	// Function name	: GetMessageFromModule
	// Description		: returns resolved error message or NULL
	// Return type		: LPWSTR 
	// Argument			: DWORD
	// Note				: user has to free returned string

	inline static LPWSTR GetMessageFromModule( DWORD dwError, HMODULE handle = NULL )
	{
		LPVOID		lpMsgBuf = NULL;
		LPWSTR		szResult = NULL;

		try
		{
			FormatMessageW(	FORMAT_MESSAGE_ALLOCATE_BUFFER | 
							FORMAT_MESSAGE_FROM_HMODULE |
							FORMAT_MESSAGE_IGNORE_INSERTS,
							(LPCVOID)handle,
							dwError,
							MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
							(LPWSTR) &lpMsgBuf,
							0,
							NULL );

			if( lpMsgBuf )
			{
				if ( ( szResult = (LPWSTR) new WCHAR[ lstrlenW ( (LPWSTR)lpMsgBuf ) + 1 ] ) != NULL )
				{
					lstrcpyW( szResult, (LPWSTR)lpMsgBuf );
				}

				LocalFree( lpMsgBuf );
			}
		}
		catch ( ... )
		{
			if ( lpMsgBuf )
			{
				LocalFree( lpMsgBuf );
			}
		}

		return szResult;
	}

	//////////////////////////////////////////////////////////////////////////////////////////
	// Function name	: GetMessageFromErrorInfo
	// Description		: returns resolved error message or NULL
	// Return type		: LPWSTR 
	// Argument			: void
	// Note				: user has to free returned string

	inline static LPWSTR GetMessageFromErrorInfo( void )
	{
		CComPtr< IErrorInfo >	pError;
		LPWSTR					szResult = NULL;

		if ( ( ::GetErrorInfo ( NULL, &pError ) == S_OK ) && pError )
		{
			CComBSTR	bstrSource;
			CComBSTR	bstrDescription;

			pError->GetSource ( &bstrSource );
			pError->GetDescription ( &bstrDescription );

			CComBSTR	bstrResult;

			if ( bstrSource.Length() )
			{
				bstrResult	+= L" ProgID : ";
				bstrResult	+= bstrSource;
			}
			if ( bstrDescription.Length() )
			{
				bstrResult	+= L" Description : ";
				bstrResult	+= bstrDescription;
			}

			if ( bstrResult.Length() )
			{
				if ( ( szResult = (LPWSTR) new WCHAR[ bstrResult.Length() + 1 ] ) != NULL )
				{
					lstrcpyW ( szResult, bstrResult );
				}
			}
		}

		return szResult;
	}
};

//////////////////////////////////////////////////////////////////////////////////////////////
// helpers
//////////////////////////////////////////////////////////////////////////////////////////////

inline LPWSTR	GetErrorMessageModule ( DWORD dwError, HMODULE handle )
{
	return __Error::GetMessageFromModule ( dwError, handle );
}

inline LPWSTR	GetErrorMessageSystem ( DWORD dwError )
{
	return __Error::GetMessageFromError ( dwError );
}

inline LPWSTR	GetErrorMessageSystem ( void )
{
	return __Error::GetMessageFromErrorInfo();
}

#endif	__WMI_PERF_ERR__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\__macro_nocopy.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					__macro_nocopy.h
//
//	Abstract:
//
//					dissallow creation of copy of instantied object
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////


#ifndef	__NO_COPY_H__
#define	__NO_COPY_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

#define DECLARE_NO_COPY( T ) \
private:\
	T(const T&);\
	T& operator=(const T&);

#endif	__NO_COPY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\__macro_error.h ===
//////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					__MACRO_ERROR.H
//
//	Abstract:
//
//					error helpers
//
//	History:
//
//					initial		a-marius
//
//////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////// common error Macros ///////////////////////////////////

#ifndef	__ERROR__
#define	__ERROR__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

///////////////////////////////////////////////////////////////////////////////////////////
// macros
///////////////////////////////////////////////////////////////////////////////////////////

#endif	__ERROR__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\__macro_unicode.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					__macro_unicode.h
//
//	Abstract:
//
//					unicode definitions
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////// Unicode //////////////////////////////////////

#ifndef	__UNICODE__
#define	__UNICODE__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// If we are not compiling for an x86 CPU, we always compile using Unicode.
#ifndef	_X86_
#define UNICODE
#endif	_X86_

// To compile using Unicode on the x86 CPU
#define UNICODE

// When using Unicode Win32 functions, use Unicode C-Runtime functions too.
#ifdef	UNICODE
#define _UNICODE
#endif	UNICODE

#endif	__UNICODE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\__macro_pragma.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					__macro_pragma.h
//
//	Abstract:
//
//					pragma message helper
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////// Pragma //////////////////////////////////////

#ifndef	__PRAGMA__
#define	__PRAGMA__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// When the compiler sees a line like this:
// #pragma ___PRAGMA_MSG(Fix this later)
//
// it outputs a line like this:
// C:\Document\AdvWin\Code\Sysinfo.06\..\CmnHdr.H(296):Fix this later
//
// You can easily jump directly to this line and examine the surrounding code.

#define ___STR(x)			#x
#define ___STRING(x)		___STR(x)
#define ___PRAGMA_MSG(desc)	message(__FILE__ "(" ___STRING(__LINE__) ") : " #desc)

#endif	__PRAGMA__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\__common_smartptr.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					__Common_SmartPTR.h
//
//	Abstract:
//
//					smart pointers, handles, cs, ...
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////// smart pointers ///////////////////////////////////

#ifndef	__SMART_POINTERS__
#define	__SMART_POINTERS__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// need common
#ifndef	__COMMON_CONVERT__
#include "__Common_Convert.h"
#endif	__COMMON_CONVERT__

// need assert macro
#ifndef	__ASSERT_VERIFY__
#include "__macro_assert.h"
#endif	__ASSERT_VERIFY__

//////////////////////////////////////////////////////////////////////////////////////////////
// class for smart CRITICAL SECTION
//////////////////////////////////////////////////////////////////////////////////////////////

class __Smart_CRITICAL_SECTION
{
	__Smart_CRITICAL_SECTION  ( __Smart_CRITICAL_SECTION& )					{};
	__Smart_CRITICAL_SECTION& operator= ( const __Smart_CRITICAL_SECTION& )	{};

	CRITICAL_SECTION*	m_cs;
	BOOL				m_bOwned;

	public:

	// construction
	__Smart_CRITICAL_SECTION() :
	m_cs ( NULL ),
	m_bOwned ( true )
	{
		try
		{
			if ( ( m_cs = new CRITICAL_SECTION () ) != NULL )
			{
				::InitializeCriticalSection ( m_cs );
				::EnterCriticalSection ( m_cs );

				ATLTRACE (	L"\n=============================================================\n"
							L" smart CS entered %x \n"
							L"=============================================================\n",
							::GetCurrentThreadId()
						 );
			}
		}
		catch ( ... )
		{
		}
	}

	// construction
	__Smart_CRITICAL_SECTION( LPCRITICAL_SECTION cs ) :
	m_cs ( NULL ),
	m_bOwned ( false )
	{
		___ASSERT ( cs != NULL );

		m_cs = cs;
		try
		{
			::EnterCriticalSection ( m_cs );

			ATLTRACE (	L"\n=============================================================\n"
						L" smart CS entered %x \n"
						L"=============================================================\n",
						::GetCurrentThreadId()
					 );
		}
		catch ( ... )
		{
		}
	}

	// destruction
	virtual ~__Smart_CRITICAL_SECTION ( )
	{
		try
		{
			::LeaveCriticalSection ( m_cs );

			ATLTRACE (	L"\n=============================================================\n"
						L" smart CS leaved  %x \n"
						L"=============================================================\n",
						::GetCurrentThreadId()
					 );

			if ( m_bOwned && m_cs )
			{
				::DeleteCriticalSection ( m_cs );

				delete m_cs;
				m_cs = NULL;
			}
		}
		catch ( ... )
		{
		}
	}
};

//////////////////////////////////////////////////////////////////////////////////////////////
// class for smart HANDLE
//////////////////////////////////////////////////////////////////////////////////////////////

class __SmartHANDLE;
class __SmartServiceHANDLE;

template < class CLASS >
class __HANDLE
{
	__HANDLE	( __HANDLE& )					{}
	__HANDLE&	operator= ( const __HANDLE& h )
	{
		___ASSERT ( m_handle == NULL );
		m_handle = h.GetHANDLE();

		return (*this);
	}

	friend class __SmartHANDLE;
	friend class __SmartServiceHANDLE;

	CLASS m_handle;

	public:

	__HANDLE() : m_handle ( NULL )
	{
	}

	virtual ~__HANDLE()
	{
		m_handle = NULL;
	}

	// operators

	operator CLASS() const
	{
		return m_handle;
	}

	CLASS& operator = ( const CLASS& handle )
	{
		___ASSERT ( m_handle == NULL );
		m_handle = handle;
	}

	// accessors

	void SetHANDLE ( CLASS handle )
	{
		___ASSERT ( m_handle == NULL );
		m_handle = handle;
	}

	CLASS GetHANDLE ( ) const
	{
		return m_handle;
	}

	// functions
	void CloseHandle ()
	{
		if ( m_handle )
		{
			::CloseHandle ( m_handle );
			m_handle = NULL;
		}
	}

	void Attach ( CLASS handle )
	{
		m_handle = handle;
	}

	CLASS Detach()
	{
		CLASS handle = NULL;

		handle = m_handle;
		m_handle = NULL;

		return handle;
	}
};

class __SmartHANDLE : public __HANDLE < HANDLE >
{
	__SmartHANDLE	( __SmartHANDLE& )					{}
	__SmartHANDLE&	operator= ( const __SmartHANDLE& )	{}

	public:

	__SmartHANDLE ( ) : __HANDLE < HANDLE > ( )
	{
	}

	__SmartHANDLE ( HANDLE handle ) : __HANDLE < HANDLE > ( )
	{
		m_handle = handle;
	}

	virtual ~__SmartHANDLE ()
	{
		if ( m_handle )
		{
			::CloseHandle ( m_handle );
		}
	}

	__SmartHANDLE& operator = ( const HANDLE& handle )
	{
		___ASSERT ( m_handle == NULL );
		m_handle = handle;

		return (*this);
	}
};

class __SmartServiceHANDLE : public __HANDLE < SC_HANDLE >
{
	__SmartServiceHANDLE	( __SmartServiceHANDLE& )					{}
	__SmartServiceHANDLE&	operator= ( const __SmartServiceHANDLE& )	{}

	public:

	__SmartServiceHANDLE ( ) : __HANDLE < SC_HANDLE > ( )
	{
	}

	__SmartServiceHANDLE ( SC_HANDLE handle ) : __HANDLE < SC_HANDLE > ( )
	{
		m_handle = handle;
	}

	virtual ~__SmartServiceHANDLE ()
	{
		if ( m_handle )
		{
			::CloseServiceHandle ( m_handle );
		}
	}

	__SmartServiceHANDLE& operator = ( const SC_HANDLE& handle )
	{
		___ASSERT ( m_handle == NULL );
		m_handle = handle;

		return (*this);
	}
};

//////////////////////////////////////////////////////////////////////////////////////////////
// class for smart pointers
//////////////////////////////////////////////////////////////////////////////////////////////

template< class TYPE >	class __WrapperPtr;
template< class TYPE >	class __WrapperExt;
template< class TYPE >	class __WrapperARRAY;
template< class TYPE >	class __WrapperARRAYSimple;

template < class BASE >
class __Wrapper
{
	__Wrapper	( __Wrapper& )					{}
	__Wrapper&	operator= ( const __Wrapper& )	{}

	// variables

	BASE* m_p;

	friend class __WrapperPtr < BASE >;
	friend class __WrapperExt < BASE >;
	friend class __WrapperARRAY < BASE >;
	friend class __WrapperARRAYSimple < BASE >;

	public:

	// construction & destruction

	__Wrapper ( ) : m_p ( NULL )
	{
	}

	__Wrapper ( BASE* p ) :	m_p ( NULL )
	{
		m_p = p;
	}

	virtual ~ __Wrapper()
	{
		if ( m_p )
		{
			delete m_p;
			m_p = NULL;
		}
	}

	virtual void SetData ( BASE* p)
	{
		___ASSERT ( m_p == NULL );
		m_p = p;
	}

	BOOL IsEmpty ()
	{
		return (m_p == NULL ) ? TRUE : FALSE;
	}

	// operators BOOL
	BOOL operator! () const
	{
		return ( m_p == NULL );
	}

	BOOL operator== (BASE* p) const
	{
		return ( m_p == p );
	}

	// operators CASTING

	operator BASE*() const
	{
		return (BASE*)m_p;
	}
	BASE& operator*() const
	{
		return *m_p;
	}

	BASE** operator&()
	{
		___ASSERT ( m_p == NULL );
		return &m_p;
	}

	// pointer operations
	BASE* Detach()
	{
		BASE* p = m_p;
		m_p = NULL;

		return p;
	}

	void Attach ( BASE* p )
	{
		___ASSERT ( m_p == NULL );
		m_p = p;
	}
};

//////////////////////////////////////////////////////////////////////////////////////////////
// class for exposing -> operator
//////////////////////////////////////////////////////////////////////////////////////////////

template < class BASE >
class __WrapperPtr : public __Wrapper< BASE > 
{
	__WrapperPtr	( __WrapperPtr& )					{}
	__WrapperPtr&	operator= ( const __WrapperPtr& )	{}

	public:

	// construction & destruction

	__WrapperPtr ( )
	{
	}

	__WrapperPtr ( BASE* p ) :	__Wrapper< BASE > ( p )
	{
	}

	BASE* operator->() const
	{
		return m_p;
	}
};

//////////////////////////////////////////////////////////////////////////////////////////////
// class changig inner variable
//////////////////////////////////////////////////////////////////////////////////////////////

template < class BASE >
class __WrapperExt : public __Wrapper< BASE > 
{
	__WrapperExt	( __WrapperExt& )					{}
	__WrapperExt&	operator= ( const __WrapperExt& )	{}

	public:

	// construction & destruction

	__WrapperExt ( )
	{
	}

	__WrapperExt ( BASE* p ) :	__Wrapper< BASE > ( p )
	{
	}

	BASE** operator&()
	{
		return &m_p;
	}
};

//////////////////////////////////////////////////////////////////////////////////////////////
// class for wraping ARRAY
//////////////////////////////////////////////////////////////////////////////////////////////

template < class BASE >
class __WrapperARRAYSimple : public __Wrapper<BASE>
{
	friend class __WrapperARRAY < BASE >;

	DWORD	m_dw;

	__WrapperARRAYSimple  ( __WrapperARRAYSimple & )
	{
	}

	__WrapperARRAYSimple & operator= ( const __WrapperARRAYSimple & )
	{
	}

	public:

	// construction & destruction
	__WrapperARRAYSimple ( ) :
	m_dw ( NULL )
	{
	}

	__WrapperARRAYSimple ( BASE* p, DWORD dw ) : __Wrapper<BASE>( p ) ,
	m_dw ( dw )
	{
	}

	public:

	virtual ~__WrapperARRAYSimple ()
	{
		if ( m_p )
		DestroyARRAY();

		m_p = NULL;
		m_dw= NULL;
	}

	virtual void DestroyARRAY()
	{
		if ( m_p )
		{
			delete [] m_p;
		}

		m_p = NULL;
		m_dw= NULL;

		return;
	}

	// accessors
	void SetAt ( DWORD dwIndex, BASE data = NULL )
	{
		___ASSERT ( m_p );
		m_p[dwIndex] = data;
	}

	BASE&	GetAt ( DWORD dwIndex ) const
	{
		___ASSERT ( m_p );
		return m_p[dwIndex];
	}

	// adding data
	virtual HRESULT DataAdd ( BASE* pAdd, DWORD dwSize )
	{
		BASE* p = NULL;

		try
		{
			if ( ( p = new BASE[m_dw + dwSize] ) == NULL )
			{
				return E_OUTOFMEMORY;
			}

			if ( p )
			{
				if ( m_p )
				{
					for ( DWORD dw = 0; dw < m_dw; dw++ )
					{
						p[dw] = m_p[dw];
					}

					delete [] m_p;
					m_p = NULL;
				}

				for ( DWORD dw = m_dw; dw < m_dw + dwSize; dw++ )
				{
					p[dw] = pAdd [ dw - m_dw ];
				}

				m_p = p;
				m_dw += dwSize;
			}
		}
		catch ( ... )
		{
			if ( p )
			{
				delete [] p;
				p = NULL;
			}

			return E_FAIL;
		}

		return S_OK;
	}

	// adding data
	virtual HRESULT DataAdd ( BASE item )
	{
		BASE* p = NULL;

		try
		{
			if ( ( p = new BASE[m_dw + 1] ) == NULL )
			{
				return E_OUTOFMEMORY;
			}

			if ( p )
			{
				if ( m_p )
				{
					for ( DWORD dw = 0; dw < m_dw; dw++ )
					{
						p[dw] = m_p[dw];
					}

					p[dw] = item;

					delete [] m_p;
					m_p = NULL;
				}
				else
				{
					p[m_dw] = item;
				}

				m_p = p;
				m_dw++;
			}
		}
		catch ( ... )
		{
			if ( p )
			{
				delete [] p;
				p = NULL;
			}

			return E_FAIL;
		}

		return S_OK;
	}

	// delete by index
	virtual HRESULT DataDelete ( DWORD dwIndex )
	{
		if ( dwIndex < m_dw )
		{
			for ( DWORD dw = dwIndex; dw < m_dw - 1; dw++ )
			{
				m_p[dw] = m_p[dw+1];
			}

			m_dw--;
			return S_OK;
		}

		return E_INVALIDARG;
	}

	// delete by value
	virtual HRESULT DataDelete ( BASE data )
	{
		for ( DWORD dw = 0; dw < m_dw; dw++ )
		{
			if ( m_p[dw] == data )
			{
				return DataDelete ( dw );
			}
		}

		return S_FALSE;
	}

	// helpers
	void SetData ( BASE* p, DWORD dw )
	{
		if ( p )
		{
			__Wrapper<BASE>::SetData ( p );
		}

		m_dw = dw;
	}

	// aditional operators

	operator DWORD() const	// for return size of array
	{
		return m_dw;
	}

	operator DWORD*()		// for set size of array
	{
		return &m_dw;
	}

	const BASE& operator[] (DWORD dwIndex) const
	{
		return m_p[dwIndex];
	}
};

//////////////////////////////////////////////////////////////////////////////////////////////
// class for wraping ARRAY
//////////////////////////////////////////////////////////////////////////////////////////////

template < class BASE >
class __WrapperARRAY : public __WrapperARRAYSimple<BASE>
{
	public:

	virtual ~__WrapperARRAY ()
	{
		if ( m_p )
		DestroyARRAY();

		m_p = NULL;
		m_dw= NULL;
	}

	virtual void DestroyARRAY()
	{
		if ( m_p )
		{
			for ( DWORD dwIndex = 0; dwIndex < m_dw; dwIndex++ )
			{
				delete m_p[dwIndex];
				m_p[dwIndex] = NULL;
			}

			delete [] m_p;
		}

		m_p = NULL;
		m_dw= NULL;

		return;
	}

	// delete by index
	virtual HRESULT DataDelete ( DWORD dwIndex )
	{
		if ( dwIndex < m_dw )
		{
			try
			{
				delete m_p[dwIndex];
			}
			catch ( ... )
			{
			}

			for ( DWORD dw = dwIndex; dw < m_dw - 1; dw++ )
			{
				m_p[dw] = m_p[dw+1];
			}

			m_dw--;
			return S_OK;
		}

		return E_INVALIDARG;
	}

	// delete by value
	virtual HRESULT DataDelete ( BASE data )
	{
		if ( data )
		{
			for ( DWORD dw = 0; dw < m_dw; dw++ )
			{
				if ( m_p[dw] == data )
				{
					return DataDelete ( dw );
				}
			}

			return S_OK;
		}

		return S_FALSE;
	}
};

//////////////////////////////////////////////////////////////////////////////////////////////
// class for wraping SAFEARRAY
//////////////////////////////////////////////////////////////////////////////////////////////

class __WrapperSAFEARRAY
{
	__WrapperSAFEARRAY ( __WrapperSAFEARRAY& )
	{
	}

	__WrapperSAFEARRAY& operator= ( const __WrapperSAFEARRAY& )
	{
	}

	SAFEARRAY * m_p;

	public:

	// constructor & destructor
	__WrapperSAFEARRAY( ) : m_p ( NULL )
	{
	}

	__WrapperSAFEARRAY( tagSAFEARRAY* psa ) : m_p ( NULL )
	{
		m_p = psa;
	}

	virtual ~__WrapperSAFEARRAY()
	{
		RELEASE_SAFEARRAY ( m_p );
		m_p = NULL;
	}

	// operators CASTING

	operator SAFEARRAY*() const
	{
		return (SAFEARRAY*)m_p;
	}

	SAFEARRAY** operator&()
	{
		___ASSERT ( m_p == NULL );
		return &m_p;
	}
};

#endif	__SMART_POINTERS__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\noncomevent\common.inc ===
!include Z:\NT\admin\wmi\WBEM\common\makefile.cmn
SOURCES_USED=Z:\NT\admin\wmi\WBEM\common\makefile.cmn

NONCOMEVENT_INC = ..\Include
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\noncomevent\enumerator.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					Enumerator.cpp
//
//	Abstract:
//
//					module for enumerator
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "PreComp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

#include "Enumerator.h"
#include "_ClassObject.h"

HRESULT	CEnumerator::Init ( LPWSTR wszNamespace, LPWSTR wszClassName )
{
	if ( m_pLocator && wszNamespace && wszClassName )
	{
		m_enum.MyEnumInit ( m_pLocator, wszNamespace );
		return m_enum.ExecInstancesQuery ( wszClassName );
	}

	return E_INVALIDARG;
}

HRESULT	CEnumerator::Init ( LPWSTR wszNamespace, LPWSTR wszQueryLang, LPWSTR wszQuery )
{
	if ( m_pLocator && wszNamespace && wszQueryLang && wszQuery )
	{
		m_enum.MyEnumInit ( m_pLocator, wszNamespace );
		return m_enum.ExecQuery ( wszQueryLang, wszQuery );
	}

	return E_INVALIDARG;
}

HRESULT CEnumerator::Next (	DWORD* pdwProperties,
							LPWSTR** ppProperties,
							CIMTYPE** ppPropertiesTypes,
							LPWSTR* pPropNeedNot,
							DWORD dwPropNeedNot,
							LONG lFlags
						  )
{
	MyClassObject		Class;
	HRESULT				hRes	= WBEM_S_NO_ERROR;
	IWbemClassObject *	pObject	= NULL;

	if SUCCEEDED ( hRes = m_enum.NextObject ( &pObject ) )
	{
		if ( pObject )
		{
			Class.ClassObjectInit ( pObject );

			hRes = Class.GetNames (	
									pdwProperties,
									ppProperties,
									ppPropertiesTypes,
									pPropNeedNot,
									dwPropNeedNot,
									lFlags
								  );

			pObject->Release();
		}
		else
		{
			hRes = E_FAIL;
		}
	}

	return hRes;
}

LPWSTR* CEnumerator::Get ( LPWSTR wszName, DWORD* dwSize )
{
	if ( ! wszName )
	{
		return NULL;
	}

	MyClassObject	Class;
	LPWSTR			wsz	= NULL;

	__WrapperARRAY < LPWSTR > result;

	HRESULT hRes =	WBEM_S_NO_ERROR;
	while ( hRes ==	WBEM_S_NO_ERROR )
	{
		ULONG				uObjects			= 0L;
		IWbemClassObject *	pObjects [ 100 ]	= { NULL };

		if SUCCEEDED ( hRes = m_enum.NextObjects ( 100, &uObjects, pObjects ) )
		{
			__WrapperARRAY <LPWSTR> ppStr;

			try
			{
				if ( ppStr.SetData ( (LPWSTR*) new LPWSTR[uObjects], uObjects ), ppStr.IsEmpty() )
				{
					for ( DWORD dwIndex = 0; dwIndex < uObjects; dwIndex++ )
					{
						if ( pObjects [ dwIndex ] )
						{
							pObjects [ dwIndex ] -> Release();
							pObjects [ dwIndex ] = NULL;
						}
					}

					continue;
				}
			}
			catch ( ... )
			{
			}

			for ( DWORD dwIndex = 0, dwRealIndex = 0; dwIndex < uObjects; dwIndex++ )
			{
				wsz = NULL;

				if ( pObjects [ dwIndex ] )
				{
					Class.ClassObjectInit ( pObjects [ dwIndex ] );

					CIMTYPE type = CIM_EMPTY;
					Class.GetPropertyType ( wszName, &type );

					if ( type & CIM_FLAG_ARRAY )
					{
						LPWSTR* pwsz	= NULL;
						DWORD	dwsz	= 0L;

						Class.GetPropertyValue ( wszName, &pwsz, &dwsz );

						for ( DWORD dw = 0; dw < dwsz; dw ++ )
						{
							if ( ! dw )
							{
								ppStr.SetAt ( dwRealIndex, pwsz [ dw ] );
							}
							else
							{
								ppStr.DataAdd ( pwsz [ dw ] );
							}

							dwRealIndex++;
						}

						delete [] pwsz;
					}
					else
					{
						Class.GetPropertyValue ( wszName, &wsz );
						ppStr.SetAt ( dwRealIndex, wsz );
						dwRealIndex++;
					}

					pObjects [ dwIndex ] -> Release();
					pObjects [ dwIndex ] = NULL;
				}
				else
				{
					ppStr.SetAt ( dwRealIndex, wsz );
					dwRealIndex++;
				}
			}

			LPWSTR*	p = ppStr.Detach();
			result.DataAdd ( p, dwRealIndex );

			delete [] p;
		}
	}

	if ( ! result.IsEmpty() )
	{
		if ( dwSize )
		{
			( * dwSize ) = (DWORD) result;
		}

		return result.Detach();
	}

	return NULL;
}

LPWSTR* CEnumerator::Get ( LPWSTR wszNamespace, LPWSTR wszClassName, LPWSTR wszName, DWORD* dwSize )
{
	if ( wszName && SUCCEEDED ( Init( wszNamespace, wszClassName ) ) )
	{
		return Get ( wszName, dwSize );
	}

	return NULL;
}

LPWSTR* CEnumerator::Get ( LPWSTR wszNamespace, LPWSTR wszQueryLang, LPWSTR wszQuery, LPWSTR wszName, DWORD* dwSize )
{
	if ( wszName && SUCCEEDED ( Init( wszNamespace, wszQueryLang, wszQuery ) ) )
	{
		return Get ( wszName, dwSize );
	}

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\noncomevent\noncomevent.cpp ===
// NonCOMEvent.cpp : Implementation of WinMain

#include "PreComp.h"
#include "resource.h"

#include <initguid.h>

#include "NonCOMEvent.h"
#include "..\NonCOMEventPS\NonCOMEvent_i.c"

#include "NonCOMEventModule.h"
#include "..\NonCOMEventPS\NonCOMEventModule_i.c"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// declarations
#include "_Module.h"
#include "_App.h"

// debug behaviour
#ifdef	_DEBUG
#endif	_DEBUG

/////////////////////////////////////////////////////////////////////////////
// VARIABLES
/////////////////////////////////////////////////////////////////////////////

// app
MyApp		_App ( IDS_PROJNAME );

// com module
MyModule	_Module;

/////////////////////////////////////////////////////////////////////////////
// dialogs
/////////////////////////////////////////////////////////////////////////////

#include "_Dlg.h"
#include "_DlgImpl.h"

#include "NonCOMEventAboutDlg.h"
#include "NonCOMEventMainDlg.h"

#include "module.h"

/////////////////////////////////////////////////////////////////////////////
// OBJECT MAP
/////////////////////////////////////////////////////////////////////////////

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_ModuleScalar, CModuleScalar)
OBJECT_ENTRY(CLSID_ModuleArray, CModuleArray)
OBJECT_ENTRY(CLSID_ModuleGeneric, CModuleGeneric)
END_OBJECT_MAP()

////////////////////////////////////////////////////////////////////////////
// ATL stuff
////////////////////////////////////////////////////////////////////////////

// need atl wrappers
#ifndef	__ATLBASE_H__
#include <atlbase.h>
#endif	__ATLBASE_H__

// need registry
#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

/////////////////////////////////////////////////////////////////////////////
//
// WIN MAIN
//
/////////////////////////////////////////////////////////////////////////////

extern "C" HRESULT	WINAPI _tWinRun		( int nCmdShow = SW_SHOWDEFAULT, BOOL bGUI = FALSE );
extern "C" int		WINAPI _tWinMain	( HINSTANCE hInstance, HINSTANCE, LPTSTR, int nCmdShow )
{
	return WinMain ( hInstance, NULL, NULL, nCmdShow );
}

extern "C" int WINAPI   WinMain		( HINSTANCE hInstance, HINSTANCE, LPSTR, int nCmdShow )
{
	HRESULT hRes		= S_OK;

	////////////////////////////////////////////////////////////////////////
	// initialization
	////////////////////////////////////////////////////////////////////////
    _Module.Init	( ObjectMap, hInstance, &LIBID_NONCOMEVENTLib );

	////////////////////////////////////////////////////////////////////////
	// variables
	////////////////////////////////////////////////////////////////////////
    WCHAR	szTokens[]	= L"-/";

	////////////////////////////////////////////////////////////////////////
	// command line
	////////////////////////////////////////////////////////////////////////
    LPWSTR lpCmdLine = GetCommandLine();

	////////////////////////////////////////////////////////////////////////
	// find behaviour
	////////////////////////////////////////////////////////////////////////
	LPCWSTR lpszToken	= MyApp::FindOneOf(lpCmdLine, szTokens);
	LPCWSTR wsz			= NULL;

	try
	{
		while (lpszToken != NULL)
		{
			if (lstrcmpiW(lpszToken, L"UnregServer")==0)
			{
				////////////////////////////////////////////////////////////////
				// unregister local server
				////////////////////////////////////////////////////////////////
				_Module.UpdateRegistryFromResource(IDR_NonCOMEvent, FALSE);

				#ifdef	__SUPPORT_TYPELIB
				hRes = _Module.UnregisterServer(TRUE);
				#else	! __SUPPORT_TYPELIB
				hRes = _Module.UnregisterServer(FALSE);
				#endif	__SUPPORT_TYPELIB

				////////////////////////////////////////////////////////////////
				// termination
				////////////////////////////////////////////////////////////////
				_Module.Term();

				return HRESULT_TO_WIN32 ( hRes );
			}
			if (lstrcmpiW(lpszToken, L"RegServer")==0)
			{
				////////////////////////////////////////////////////////////////
				// register local server
				////////////////////////////////////////////////////////////////
				_Module.UpdateRegistryFromResource(IDR_NonCOMEvent, TRUE);

				#ifdef	__SUPPORT_TYPELIB
				hRes = _Module.RegisterServer(TRUE);
				#else	! __SUPPORT_TYPELIB
				hRes = _Module.RegisterServer(FALSE);
				#endif	__SUPPORT_TYPELIB

				////////////////////////////////////////////////////////////////
				// termination
				////////////////////////////////////////////////////////////////
				_Module.Term();

				return HRESULT_TO_WIN32 ( hRes );
			}

			if (lstrcmpiW(lpszToken, L"GUI")==0)
			{
				////////////////////////////////////////////////////////////////
				// previous instance
				////////////////////////////////////////////////////////////////
				if ( _App.Exists() )
				{
					////////////////////////////////////////////////////////////
					// termination
					////////////////////////////////////////////////////////////
					return ERROR_ALREADY_EXISTS;
				}

				////////////////////////////////////////////////////////////////
				// run instance
				////////////////////////////////////////////////////////////////

				hRes = _tWinRun ( nCmdShow, TRUE );

				////////////////////////////////////////////////////////////////
				// termination
				////////////////////////////////////////////////////////////////
				_Module.Term();

				return HRESULT_TO_WIN32 ( hRes );
			}

			wsz = MyApp::_cstrstr( CharUpperW ( const_cast < LPWSTR > ( lpszToken ) ), L"CMD_SCALAR");
			if (wsz)
			{
				// move string pointer
				wsz = &wsz [ 11 ];

				////////////////////////////////////////////////////////////////
				// previous instance
				////////////////////////////////////////////////////////////////
				if ( _App.Exists() )
				{
					////////////////////////////////////////////////////////////
					// termination
					////////////////////////////////////////////////////////////
					return ERROR_ALREADY_EXISTS;
				}

				hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
				_ASSERTE(SUCCEEDED(hRes));

				////////////////////////////////////////////////////////////////
				// run command line application
				////////////////////////////////////////////////////////////////

				CComObject < CModuleScalar > * pModule = NULL;
				CComObject < CModuleScalar > :: CreateInstance ( &pModule );

				CComPtr < ICimModule > pCimModule;

				if SUCCEEDED ( hRes = pModule->QueryInterface ( __uuidof ( ICimModule ), ( void** ) & pCimModule ) )
				{
					// 1st argument
					CComVariant var ( wsz );

					if SUCCEEDED ( hRes = pCimModule->Start ( &var, NULL ) )
					{
						// wait till test is done
					}
				}

				////////////////////////////////////////////////////////////////
				// termination
				////////////////////////////////////////////////////////////////
				_Module.Term();

				::CoUninitialize ();

				if FAILED ( hRes )
				{
					return HRESULT_TO_WIN32 ( hRes );
				}
			}

			wsz = MyApp::_cstrstr( CharUpperW ( const_cast < LPWSTR > ( lpszToken ) ), L"CMD_ARRAY");
			if (wsz)
			{
				// move string pointer
				wsz = &wsz [ 10 ];

				////////////////////////////////////////////////////////////////
				// previous instance
				////////////////////////////////////////////////////////////////
				if ( _App.Exists() )
				{
					////////////////////////////////////////////////////////////
					// termination
					////////////////////////////////////////////////////////////
					return ERROR_ALREADY_EXISTS;
				}

				hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
				_ASSERTE(SUCCEEDED(hRes));

				////////////////////////////////////////////////////////////////
				// run command line application
				////////////////////////////////////////////////////////////////

				CComObject < CModuleArray > * pModule = NULL;
				CComObject < CModuleArray > :: CreateInstance ( &pModule );

				CComPtr < ICimModule > pCimModule;

				if SUCCEEDED ( hRes = pModule->QueryInterface ( __uuidof ( ICimModule ), ( void** ) & pCimModule ) )
				{
					// 1st argument
					CComVariant var ( wsz );

					if SUCCEEDED ( hRes = pCimModule->Start ( &var, NULL ) )
					{
						// wait till test is done
					}
				}

				////////////////////////////////////////////////////////////////
				// termination
				////////////////////////////////////////////////////////////////
				_Module.Term();

				::CoUninitialize ();

				if FAILED ( hRes )
				{
					return HRESULT_TO_WIN32 ( hRes );
				}
			}

			wsz = MyApp::_cstrstr( CharUpperW ( const_cast < LPWSTR > ( lpszToken ) ), L"CMD_GENERIC");
			if (wsz)
			{
				// move string pointer
				wsz = &wsz [ 12 ];

				////////////////////////////////////////////////////////////////
				// previous instance
				////////////////////////////////////////////////////////////////
				if ( _App.Exists() )
				{
					////////////////////////////////////////////////////////////
					// termination
					////////////////////////////////////////////////////////////
					return ERROR_ALREADY_EXISTS;
				}

				hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
				_ASSERTE(SUCCEEDED(hRes));

				////////////////////////////////////////////////////////////////
				// run command line application
				////////////////////////////////////////////////////////////////

				CComObject < CModuleGeneric > * pModule = NULL;
				CComObject < CModuleGeneric > :: CreateInstance ( &pModule );

				CComPtr < ICimModule > pCimModule;

				if SUCCEEDED ( hRes = pModule->QueryInterface ( __uuidof ( ICimModule ), ( void** ) & pCimModule ) )
				{
					// 1st argument
					CComVariant var ( wsz );

					if SUCCEEDED ( hRes = pCimModule->Start ( &var, NULL ) )
					{
						// wait till test is done
					}
				}

				////////////////////////////////////////////////////////////////
				// termination
				////////////////////////////////////////////////////////////////
				_Module.Term();

				::CoUninitialize ();

				if FAILED ( hRes )
				{
					return HRESULT_TO_WIN32 ( hRes );
				}
			}

			lpszToken = MyApp::FindOneOf(lpszToken, szTokens);
		}
	}
	catch ( ... )
	{
		////////////////////////////////////////////////////////////////////////
		// termination
		////////////////////////////////////////////////////////////////////////
		_Module.Term();

		return HRESULT_TO_WIN32 ( E_FAIL );
	}

	////////////////////////////////////////////////////////////////////////
	// previous instance
	////////////////////////////////////////////////////////////////////////
	if ( _App.Exists() )
	{
		////////////////////////////////////////////////////////////////////
		// termination
		////////////////////////////////////////////////////////////////////
		return ERROR_ALREADY_EXISTS;
	}

	////////////////////////////////////////////////////////////////////////
	// run instance
	////////////////////////////////////////////////////////////////////////

	int nRet = _tWinRun ( nCmdShow );

	////////////////////////////////////////////////////////////////////////
	// termination
	////////////////////////////////////////////////////////////////////////
	_Module.Term();

	return HRESULT_TO_WIN32 ( nRet );
}

/////////////////////////////////////////////////////////////////////////////
//
// RUN :))
//
/////////////////////////////////////////////////////////////////////////////

extern "C" HRESULT WINAPI _tWinRun( int, BOOL bGUI )
{
	////////////////////////////////////////////////////////////////////////
	// INITIALIZATION
	////////////////////////////////////////////////////////////////////////

	HRESULT hRes		= S_OK;

	// kill event
	try
	{
		if ( (	_App.m_hKill =
				::CreateEvent ( NULL,
								TRUE,
								FALSE,
								NULL ) 
			 ) == NULL )
		{
			return HRESULT_FROM_WIN32 ( ::GetLastError() );
		}

		if ( !bGUI && (	_App.m_hUse =
						::CreateSemaphore ( NULL,
											1L,
											100L,
											L"NonCOMEvent_StressSemaphore" ) 
					  ) == NULL )
		{
			return HRESULT_FROM_WIN32 ( ::GetLastError() );
		}
	}
	catch ( ... )
	{
		return ERROR_NOT_READY;
	}

	////////////////////////////////////////////////////////////////////////
	// COM INITIALIZATION
	////////////////////////////////////////////////////////////////////////

	if ( bGUI )
	hRes = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
	else
	hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);

	_ASSERTE(SUCCEEDED(hRes));

	////////////////////////////////////////////////////////////////////////
	// This provides a NULL DACL which will allow access to everyone.
	////////////////////////////////////////////////////////////////////////

	hRes = CoInitializeSecurity(NULL,
								-1,
								NULL,
								NULL,
								RPC_C_AUTHN_LEVEL_NONE,
								RPC_C_IMP_LEVEL_IMPERSONATE,
								NULL,
								EOAC_NONE,
								NULL);
	_ASSERTE(SUCCEEDED(hRes));

	hRes = _Module.RegisterClassObjects( CLSCTX_LOCAL_SERVER, REGCLS_MULTIPLEUSE );
	_ASSERTE(SUCCEEDED(hRes));

	// called from local server ( unlock will be called )
	if ( ! _Module.MonitorShutdownStart() )
	{
		// revoke class object
		hRes = _Module.RevokeClassObjects();
		_ASSERTE(SUCCEEDED(hRes));

		////////////////////////////////////////////////////////////////
		// COM UNINITIALIZATION
		////////////////////////////////////////////////////////////////
		::CoUninitialize();

		return E_FAIL;
	}

//	////////////////////////////////////////////////////////////////////////
//	message queve is forgiven
//	////////////////////////////////////////////////////////////////////////
//
//	MSG msg;
//	while ( GetMessage( &msg, 0, 0, 0 ) )
//	{
//		DispatchMessage( &msg );
//	}

	// init WBEM
	_App.m_event.ObjectLocator ();

	if ( bGUI )
	{
		////////////////////////////////////////////////////////////////////
		// COMMON CONTROLS
		////////////////////////////////////////////////////////////////////

		#if (_WIN32_IE >= 0x0300)
		INITCOMMONCONTROLSEX iccx;
		iccx.dwSize = sizeof(iccx);
		iccx.dwICC = ICC_BAR_CLASSES;	// change to support other controls
		::InitCommonControlsEx(&iccx);
		#else
		::InitCommonControls();
		#endif

		MyDlg < CNonCOMEventMainDlg> dlg;

		if SUCCEEDED ( dlg.Init() )
		{
			dlg.Run ( SW_SHOWDEFAULT );
		}
	}

	::WaitForSingleObject ( _App.m_hKill, INFINITE );

	////////////////////////////////////////////////////////////////////////
	// do real finishing stuff ( synchronize etc )
	////////////////////////////////////////////////////////////////////////

	// uninit WBEM
	_App.m_event.ObjectLocator ( FALSE );

	// revoke class object
	_Module.RevokeClassObjects();

	////////////////////////////////////////////////////////////////////////
	// COM UNINITIALIZATION
	////////////////////////////////////////////////////////////////////////
	::CoUninitialize();

	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\noncomevent\module.cpp ===
// ================================================
// MODULE.CPP
// Module Class implementation; non-module specific
// ================================================

#define _WIN32_DCOM	

#include "PreComp.h"

#include "NonCOMEventModule.h"

#include "_App.h"
#include "_Module.h"

#include "module.h"
#include "worker.h"	

#include <comdef.h>
#include <process.h>

// variables
extern MyApp	_App;
extern MyModule	_Module;

CModuleScalar::CModuleScalar():
	m_pCimNotify(NULL),
	m_bstrParams(NULL),
	m_bShouldExit(false),
	m_bShouldPause(false)
{
	_Module.Lock();

	// addref server
	CoAddRefServerProcess();
}

CModuleScalar::~CModuleScalar()
{
	// release params
	SysFreeString(m_bstrParams);

	// release server
	if ( CoReleaseServerProcess() == 0 )
	{
		_Module.Unlock();
		_Module.ShutDown();

		return;
	}

	_Module.Unlock();
}

STDMETHODIMP CModuleScalar::Start(VARIANT* pvarInitOp, IUnknown* pUnknown)
{
	// The module MUST return immediately from calls to Start()
	// Non-zero error code indicates catastrophic failure! Never return that!
	//=======================================================================
	HRESULT	hr		= S_FALSE;

	// Get the logging interface (ICimNotify)
	//=======================================

	if ( pUnknown )
	{
		hr = pUnknown->QueryInterface(IID_ICimNotify, (LPVOID *)&m_pCimNotify);
	}

	//Grab a copy of the start parameters
	//===================================
	CModuleScalar::ParseParams(pvarInitOp);

	//this module could create a different worker object dependent on the parameters
	//==============================================================================
	CMyWorkerScalar* w = new CMyWorkerScalar( this );
	//WorkerScalar now has control over the lifetime over ICimModule (CModuleScalar) and ICimNotify 
	//=================================================================================

	if ( w ) 
	{
		try
		{
			delete w;
		}
		catch ( ... )
		{
		}

		w = NULL;
	}

	return hr;
}

STDMETHODIMP CModuleScalar::Terminate()
{
	// The module MUST return immediately from calls to Terminate()
	// Failure codes indicates catastrophic failure! Never return that!
	//=======================================================================

	m_bShouldExit=true;
	return S_OK;
}

STDMETHODIMP CModuleScalar::Pause()
{
	// The module MUST return immediately from calls to Pause()
	// Failure codes indicate catastrophic failure! Never return that!
	//=======================================================================

	m_bShouldPause=!m_bShouldPause;
	return S_OK;
}

STDMETHODIMP CModuleScalar::BonusMethod(void)
{
	// The module MUST return immediately from calls to BonusMethod()
	// Module specific (i.e. do whatever you want to here)
	// Failure codes indicate catastrophic failure! Never return that!
	//=======================================================================

	return 0;
}

void CModuleScalar::ParseParams(VARIANT *pVar)
{
	//This just stores the parameter. You could choose to actually parse it here!
	//===========================================================================
	if(VT_BSTR==pVar->vt)
	{
		m_bstrParams=SysAllocStringLen( pVar->bstrVal, ::SysStringLen ( pVar->bstrVal ) );
	}
}

CModuleArray::CModuleArray():
	m_pCimNotify(NULL),
	m_bstrParams(NULL),
	m_bShouldExit(false),
	m_bShouldPause(false)
{
	_Module.Lock();

	// addref server
	CoAddRefServerProcess();
}

CModuleArray::~CModuleArray()
{
	// release params
	SysFreeString(m_bstrParams);

	// release server
	if ( CoReleaseServerProcess() == 0 )
	{
		_Module.Unlock();
		_Module.ShutDown();

		return;
	}

	_Module.Unlock();
}

STDMETHODIMP CModuleArray::Start(VARIANT* pvarInitOp, IUnknown* pUnknown)
{
	// The module MUST return immediately from calls to Start()
	// Non-zero error code indicates catastrophic failure! Never return that!
	//=======================================================================
	HRESULT	hr		= S_FALSE;

	// Get the logging interface (ICimNotify)
	//=======================================

	if ( pUnknown )
	{
		hr = pUnknown->QueryInterface(IID_ICimNotify, (LPVOID *)&m_pCimNotify);
	}

	//Grab a copy of the start parameters
	//===================================
	CModuleArray::ParseParams(pvarInitOp);

	//this module could create a different worker object dependent on the parameters
	//==============================================================================
	CMyWorkerArray* w = new CMyWorkerArray( this );
	//WorkerScalar now has control over the lifetime over ICimModule (CModuleScalar) and ICimNotify 
	//=================================================================================

	if ( w ) 
	{
		try
		{
			delete w;
		}
		catch ( ... )
		{
		}

		w = NULL;
	}

	return hr;
}

STDMETHODIMP CModuleArray::Terminate()
{
	// The module MUST return immediately from calls to Terminate()
	// Failure codes indicates catastrophic failure! Never return that!
	//=======================================================================

	m_bShouldExit=true;
	return S_OK;
}

STDMETHODIMP CModuleArray::Pause()
{
	// The module MUST return immediately from calls to Pause()
	// Failure codes indicate catastrophic failure! Never return that!
	//=======================================================================

	m_bShouldPause=!m_bShouldPause;
	return S_OK;
}

STDMETHODIMP CModuleArray::BonusMethod(void)
{
	// The module MUST return immediately from calls to BonusMethod()
	// Module specific (i.e. do whatever you want to here)
	// Failure codes indicate catastrophic failure! Never return that!
	//=======================================================================

	return 0;
}

void CModuleArray::ParseParams(VARIANT *pVar)
{
	//This just stores the parameter. You could choose to actually parse it here!
	//===========================================================================
	if(VT_BSTR==pVar->vt)
	{
		m_bstrParams=SysAllocStringLen( pVar->bstrVal, ::SysStringLen ( pVar->bstrVal ) );
	}
}

CModuleGeneric::CModuleGeneric():
	m_pCimNotify(NULL),
	m_bstrParams(NULL),
	m_bShouldExit(false),
	m_bShouldPause(false)
{
	_Module.Lock();

	// addref server
	CoAddRefServerProcess();
}

CModuleGeneric::~CModuleGeneric()
{
	// release params
	SysFreeString(m_bstrParams);

	// release server
	if ( CoReleaseServerProcess() == 0 )
	{
		_Module.Unlock();
		_Module.ShutDown();

		return;
	}

	_Module.Unlock();
}

STDMETHODIMP CModuleGeneric::Start(VARIANT* pvarInitOp, IUnknown* pUnknown)
{
	// The module MUST return immediately from calls to Start()
	// Non-zero error code indicates catastrophic failure! Never return that!
	//=======================================================================
	HRESULT	hr		= S_FALSE;

	// Get the logging interface (ICimNotify)
	//=======================================

	if ( pUnknown )
	{
		hr = pUnknown->QueryInterface(IID_ICimNotify, (LPVOID *)&m_pCimNotify);
	}

	//Grab a copy of the start parameters
	//===================================
	CModuleGeneric::ParseParams(pvarInitOp);

	//this module could create a different worker object dependent on the parameters
	//==============================================================================
	CMyWorkerGeneric* w = new CMyWorkerGeneric( this );
	//WorkerScalar now has control over the lifetime over ICimModule (CModuleScalar) and ICimNotify 
	//=================================================================================

	if ( w ) 
	{
		try
		{
			delete w;
		}
		catch ( ... )
		{
		}

		w = NULL;
	}

	return hr;
}

STDMETHODIMP CModuleGeneric::Terminate()
{
	// The module MUST return immediately from calls to Terminate()
	// Failure codes indicates catastrophic failure! Never return that!
	//=======================================================================

	m_bShouldExit=true;
	return S_OK;
}

STDMETHODIMP CModuleGeneric::Pause()
{
	// The module MUST return immediately from calls to Pause()
	// Failure codes indicate catastrophic failure! Never return that!
	//=======================================================================

	m_bShouldPause=!m_bShouldPause;
	return S_OK;
}

STDMETHODIMP CModuleGeneric::BonusMethod(void)
{
	// The module MUST return immediately from calls to BonusMethod()
	// Module specific (i.e. do whatever you want to here)
	// Failure codes indicate catastrophic failure! Never return that!
	//=======================================================================

	return 0;
}

void CModuleGeneric::ParseParams(VARIANT *pVar)
{
	//This just stores the parameter. You could choose to actually parse it here!
	//===========================================================================
	if(VT_BSTR==pVar->vt)
	{
		m_bstrParams=SysAllocStringLen( pVar->bstrVal, ::SysStringLen ( pVar->bstrVal ) );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\noncomevent\noncomeventaboutdlg.cpp ===
// NonCOMEventAboutDlg.cpp : Implementation of CNonCOMEventAboutDlg
#include "precomp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// need atl wrappers
#ifndef	__ATLBASE_H__
#include <atlbase.h>
#endif	__ATLBASE_H__

#include "_Module.h"
extern MyModule _Module;

// enumerator
#include "Enumerator.h"

// dialogs
#include "NonCOMEventAboutDlg.h"

// constructor
CNonCOMEventCommonListDlg::CNonCOMEventCommonListDlg(	IWbemLocator* pLocator,
														LPWSTR wszNamespace,
														LPWSTR wszQueryLang,
														LPWSTR wszQuery,
														LPWSTR wszName
													) :

m_plb ( NULL )

{
	DWORD		dwSize = 0L;
	CEnumerator Enum ( pLocator );

	LPWSTR* p = NULL;
	
	p = Enum.Get	(	wszNamespace,
						wszQueryLang,
						wszQuery,
						wszName,
						&dwSize
					);

	if ( p && !dwSize )
	{
		delete [] p;
	}
	else
	{
		m_namespace = wszNamespace;
		if ( wszNamespace [ lstrlenW ( wszNamespace ) -1 ] != L'\\' )
		{
			m_namespace += L"\\";
		}

		m_results.DataAdd ( p,
							dwSize
						  );
	}
}

CNonCOMEventCommonListDlg::CNonCOMEventCommonListDlg(	IWbemLocator* pLocator,
														LPWSTR wszNamespace,
														LPWSTR wszClassName,
														LPWSTR wszName
													) :

m_plb ( NULL )

{
	DWORD		dwSize = 0L;
	CEnumerator Enum ( pLocator );

	LPWSTR* p = NULL;
	
	p = Enum.Get	(	wszNamespace,
						wszClassName,
						wszName,
						&dwSize
					);

	if ( p && !dwSize )
	{
		delete [] p;
	}
	else
	{
		m_namespace = wszNamespace;
		if ( wszNamespace [ lstrlenW ( wszNamespace ) -1 ] != L'\\' )
		{
			m_namespace += L"\\";
		}

		m_results.DataAdd ( p,
							dwSize
						  );
	}
}

// init of dialog
LRESULT CNonCOMEventCommonListDlg::OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
{
	CenterWindow(GetParent());

	// set icons
	HICON hIcon = (HICON)::LoadImage(	_Module.GetResourceInstance(),
										MAKEINTRESOURCE(IDR_MAINFRAME), 
										IMAGE_ICON,
										::GetSystemMetrics(SM_CXICON),
										::GetSystemMetrics(SM_CYICON),
										LR_DEFAULTCOLOR
									);
	SetIcon(hIcon, TRUE);

	HICON hIconSmall = (HICON)::LoadImage(	_Module.GetResourceInstance(),
											MAKEINTRESOURCE(IDR_MAINFRAME), 
											IMAGE_ICON,
											::GetSystemMetrics(SM_CXSMICON),
											::GetSystemMetrics(SM_CYSMICON),
											LR_DEFAULTCOLOR
										 );
	SetIcon(hIconSmall, FALSE);

	// clear helper
	m_CurrentSelect.Empty();

	// wrap list box
	HWND hlb = NULL;
	hlb = GetDlgItem ( IDC_RESULT );

	if ( hlb )
	{
		try
		{
			if ( ( m_plb = new CListBox ( hlb ) ) != NULL )
			{
			}
		}
		catch ( ... )
		{
		}
	}

	if ( m_plb && ! m_results.IsEmpty() )
	{
		for ( DWORD dw = 0 ; dw < ( DWORD ) m_results; dw ++ )
		{
			try
			{
				m_plb->AddString ( m_results [ dw ] );
			}
			catch ( ... )
			{
			}
		}
	}

	return TRUE;
}

// end of dialog
LRESULT CNonCOMEventCommonListDlg::OnCloseCmd(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
{
	switch ( wID ) 
	{
		case IDOK:
		{
			int		nIndex	= 0;
			BSTR	bstr	= NULL;

			if ( ( nIndex = m_plb->GetCurSel() ) != LB_ERR )
			{
				if ( m_plb->GetTextBSTR ( nIndex, bstr ) )
				{
					m_CurrentSelect.AppendBSTR ( bstr ) ;
					::SysFreeString ( bstr );
				}
			}
		}
		break;

		case IDCANCEL:
		{
		}
		break;
	}

	EndDialog(wID);
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\__safearraywrapper.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					__SafeArrayWrapper.h
//
//	Abstract:
//
//					convertion routines for safe arrays
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////// SafeArray ///////////////////////////////////

#ifndef	__SAFE_ARRAY_WRAPPER__
#define	__SAFE_ARRAY_WRAPPER__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

#ifndef	__COMMON_CONVERT__
#include "__Common_Convert.h"
#endif	__COMMON_CONVERT__

// this is not error at all :-))
#pragma warning ( disable : 4806 )

class __SafeArray
{
	DECLARE_NO_COPY ( __SafeArray );

	public:

	static HRESULT	LPWSTRToVariant ( CIMTYPE type, LPWSTR str, VARIANT* pVar )
	{
		if ( ! pVar )
		{
			return E_POINTER;
		}

		::VariantInit ( pVar );

		if ( !str )
		{
			return E_INVALIDARG;
		}

		DWORD dwCount = 0L;

		switch ( type )
		{
			case CIM_SINT8 | CIM_FLAG_ARRAY :
			{
				LPWSTR wsz = str;

				while ( ( wsz = wcsstr ( wsz, L" | ") ), wsz++ )
				{
					dwCount++;
				}

				signed char* p = NULL;

				try
				{
					if ( ( p = new signed char [ dwCount + 1 ] ) == NULL )
					{
						return E_OUTOFMEMORY;
					}
				}
				catch ( ... )
				{
					if ( p )
					{
						delete [] p;
						p = NULL;
					}

					return E_UNEXPECTED;
				}

				wsz = str;

				DWORD dwIndex = 0;

				do
				{
					LPWSTR wszNew = NULL;
					wszNew = wcsstr ( wsz, L" | " );;

					if ( wszNew )
					{
						LPWSTR sz = NULL;

						try
						{
							if ( ( sz = new WCHAR [ wszNew - wsz + 1 ] ) == NULL )
							{
								delete [] p;
								return E_OUTOFMEMORY;
							}

							memcpy ( sz, wsz, ( wszNew - wsz ) * sizeof ( WCHAR ) );
							sz [ wszNew - wsz ] = L'\0';

							CComVariant var;
							CComVariant v ( sz );

							delete [] sz;
							sz = NULL;

							if SUCCEEDED ( ::VariantChangeType ( &var, &v, VARIANT_NOVALUEPROP, VT_I1 ) )
							{
								p[dwIndex++] = V_I1 ( &var );
							}
							else
							{
								p[dwIndex++] = * V_I1REF ( & v );
							}

							wsz = wszNew+3;
						}
						catch ( ... )
						{
							if ( sz )
							{
								delete [] sz;
								sz = NULL;
							}

							delete [] p;

							return E_UNEXPECTED;
						}
					}
					else
					{
						CComVariant var;
						CComVariant v ( wsz );

						if SUCCEEDED ( ::VariantChangeType ( &var, &v, VARIANT_NOVALUEPROP, VT_I1 ) )
						{
							p[dwIndex++] = V_I1 ( &var );
						}
						else
						{
							p[dwIndex++] = * V_I1REF ( & v );
						}

						wsz = wszNew;
					}
				}
				while ( wsz != NULL );

				HRESULT hRes =  CHARToVariant ( p, dwCount+1, pVar );

				delete [] p;
				return hRes;
			}
			break;

			case CIM_UINT8 | CIM_FLAG_ARRAY :
			{
				LPWSTR wsz = str;

				while ( ( wsz = wcsstr ( wsz, L" | ") ), wsz++ )
				{
					dwCount++;
				}

				unsigned char* p = NULL;

				try
				{
					if ( ( p = new unsigned char [ dwCount + 1 ] ) == NULL )
					{
						return E_OUTOFMEMORY;
					}
				}
				catch ( ... )
				{
					if ( p )
					{
						delete [] p;
						p = NULL;
					}

					return E_UNEXPECTED;
				}

				wsz = str;

				DWORD dwIndex = 0;

				do
				{
					LPWSTR wszNew = NULL;
					wszNew = wcsstr ( wsz, L" | " );;

					if ( wszNew )
					{
						LPWSTR sz = NULL;

						try
						{
							if ( ( sz = new WCHAR [ wszNew - wsz + 1 ] ) == NULL )
							{
								delete [] p;
								return E_OUTOFMEMORY;
							}

							memcpy ( sz, wsz, ( wszNew - wsz ) * sizeof ( WCHAR ) );
							sz [ wszNew - wsz ] = L'\0';

							CComVariant var;
							CComVariant v ( sz );

							delete [] sz;
							sz = NULL;

							if SUCCEEDED ( ::VariantChangeType ( &var, &v, VARIANT_NOVALUEPROP, VT_UI1 ) )
							{
								p[dwIndex++] = V_UI1 ( &var );
							}
							else
							{
								p[dwIndex++] = * V_UI1REF ( & v );
							}

							wsz = wszNew+3;
						}
						catch ( ... )
						{
							if ( sz )
							{
								delete [] sz;
								sz = NULL;
							}

							delete [] p;

							return E_UNEXPECTED;
						}
					}
					else
					{
						CComVariant var;
						CComVariant v ( wsz );

						if SUCCEEDED ( ::VariantChangeType ( &var, &v, VARIANT_NOVALUEPROP, VT_UI1 ) )
						{
							p[dwIndex++] = V_UI1 ( &var );
						}
						else
						{
							p[dwIndex++] = * V_UI1REF ( & v );
						}

						wsz = wszNew;
					}
				}
				while ( wsz != NULL );

				HRESULT hRes =  UCHARToVariant ( p, dwCount+1, pVar );

				delete [] p;
				return hRes;
			}
			break;

			case CIM_SINT16 | CIM_FLAG_ARRAY :
			{
				LPWSTR wsz = str;

				while ( ( wsz = wcsstr ( wsz, L" | ") ), wsz++ )
				{
					dwCount++;
				}

				signed short* p = NULL;

				try
				{
					if ( ( p = new signed short [ dwCount + 1 ] ) == NULL )
					{
						return E_OUTOFMEMORY;
					}
				}
				catch ( ... )
				{
					if ( p )
					{
						delete [] p;
						p = NULL;
					}

					return E_UNEXPECTED;
				}

				wsz = str;

				DWORD dwIndex = 0;

				do
				{
					LPWSTR wszNew = NULL;
					wszNew = wcsstr ( wsz, L" | " );;

					if ( wszNew )
					{
						LPWSTR sz = NULL;

						try
						{
							if ( ( sz = new WCHAR [ wszNew - wsz + 1 ] ) == NULL )
							{
								delete [] p;
								return E_OUTOFMEMORY;
							}

							memcpy ( sz, wsz, ( wszNew - wsz ) * sizeof ( WCHAR ) );
							sz [ wszNew - wsz ] = L'\0';

							CComVariant var;
							CComVariant v ( sz );
							delete [] sz;

							if SUCCEEDED ( ::VariantChangeType ( &var, &v, VARIANT_NOVALUEPROP, VT_I2 ) )
							{
								p[dwIndex++] = V_I2 ( &var );
							}

							wsz = wszNew+3;
						}
						catch ( ... )
						{
							if ( sz )
							{
								delete [] sz;
								sz = NULL;
							}

							delete [] p;

							return E_UNEXPECTED;
						}
					}
					else
					{
						CComVariant var;
						CComVariant v ( wsz );

						if SUCCEEDED ( ::VariantChangeType ( &var, &v, VARIANT_NOVALUEPROP, VT_I2 ) )
						{
							p[dwIndex++] = V_I2 ( &var );
						}

						wsz = wszNew;
					}
				}
				while ( wsz != NULL );

				HRESULT hRes =  SHORTToVariant ( p, dwCount+1, pVar );

				delete [] p;
				return hRes;
			}
			break;

			case CIM_UINT16 | CIM_FLAG_ARRAY :
			{
				LPWSTR wsz = str;

				while ( ( wsz = wcsstr ( wsz, L" | ") ), wsz++ )
				{
					dwCount++;
				}

				unsigned short* p = NULL;

				try
				{
					if ( ( p = new unsigned short [ dwCount + 1 ] ) == NULL )
					{
						return E_OUTOFMEMORY;
					}
				}
				catch ( ... )
				{
					if ( p )
					{
						delete [] p;
						p = NULL;
					}

					return E_UNEXPECTED;
				}

				wsz = str;

				DWORD dwIndex = 0;

				do
				{
					LPWSTR wszNew = NULL;
					wszNew = wcsstr ( wsz, L" | " );;

					if ( wszNew )
					{
						LPWSTR sz = NULL;

						try
						{
							if ( ( sz = new WCHAR [ wszNew - wsz + 1 ] ) == NULL )
							{
								delete [] p;
								return E_OUTOFMEMORY;
							}

							memcpy ( sz, wsz, ( wszNew - wsz ) * sizeof ( WCHAR ) );
							sz [ wszNew - wsz ] = L'\0';

							CComVariant var;
							CComVariant v ( sz );
							delete [] sz;

							if SUCCEEDED ( ::VariantChangeType ( &var, &v, VARIANT_NOVALUEPROP, VT_UI2 ) )
							{
								p[dwIndex++] = V_UI2 ( &var );
							}

							wsz = wszNew+3;
						}
						catch ( ... )
						{
							if ( sz )
							{
								delete [] sz;
								sz = NULL;
							}

							delete [] p;

							return E_UNEXPECTED;
						}
					}
					else
					{
						CComVariant var;
						CComVariant v ( wsz );

						if SUCCEEDED ( ::VariantChangeType ( &var, &v, VARIANT_NOVALUEPROP, VT_UI2 ) )
						{
							p[dwIndex++] = V_UI2 ( &var );
						}

						wsz = wszNew;
					}
				}
				while ( wsz != NULL );

				HRESULT hRes =  USHORTToVariant ( p, dwCount+1, pVar );

				delete [] p;
				return hRes;
			}
			break;

			case CIM_SINT32 | CIM_FLAG_ARRAY :
			{
				LPWSTR wsz = str;

				while ( ( wsz = wcsstr ( wsz, L" | ") ), wsz++ )
				{
					dwCount++;
				}

				signed long* p = NULL;

				try
				{
					if ( ( p = new signed long [ dwCount + 1 ] ) == NULL )
					{
						return E_OUTOFMEMORY;
					}
				}
				catch ( ... )
				{
					if ( p )
					{
						delete [] p;
						p = NULL;
					}

					return E_UNEXPECTED;
				}

				wsz = str;

				DWORD dwIndex = 0;

				do
				{
					LPWSTR wszNew = NULL;
					wszNew = wcsstr ( wsz, L" | " );;

					if ( wszNew )
					{
						LPWSTR sz = NULL;

						try
						{
							if ( ( sz = new WCHAR [ wszNew - wsz + 1 ] ) == NULL )
							{
								delete [] p;
								return E_OUTOFMEMORY;
							}

							memcpy ( sz, wsz, ( wszNew - wsz ) * sizeof ( WCHAR ) );
							sz [ wszNew - wsz ] = L'\0';

							CComVariant var;
							CComVariant v ( sz );
							delete [] sz;

							if SUCCEEDED ( ::VariantChangeType ( &var, &v, VARIANT_NOVALUEPROP, VT_I4 ) )
							{
								p[dwIndex++] = V_I4 ( &var );
							}

							wsz = wszNew+3;
						}
						catch ( ... )
						{
							if ( sz )
							{
								delete [] sz;
								sz = NULL;
							}

							delete [] p;

							return E_UNEXPECTED;
						}
					}
					else
					{
						CComVariant var;
						CComVariant v ( wsz );

						if SUCCEEDED ( ::VariantChangeType ( &var, &v, VARIANT_NOVALUEPROP, VT_I4 ) )
						{
							p[dwIndex++] = V_I4 ( &var );
						}

						wsz = wszNew;
					}
				}
				while ( wsz != NULL );

				HRESULT hRes =  LONGToVariant ( p, dwCount+1, pVar );

				delete [] p;
				return hRes;
			}
			break;

			case CIM_UINT32 | CIM_FLAG_ARRAY :
			{
				LPWSTR wsz = str;

				while ( ( wsz = wcsstr ( wsz, L" | ") ), wsz++ )
				{
					dwCount++;
				}

				unsigned long* p = NULL;

				try
				{
					if ( ( p = new unsigned long [ dwCount + 1 ] ) == NULL )
					{
						return E_OUTOFMEMORY;
					}
				}
				catch ( ... )
				{
					if ( p )
					{
						delete [] p;
						p = NULL;
					}

					return E_UNEXPECTED;
				}

				wsz = str;

				DWORD dwIndex = 0;

				do
				{
					LPWSTR wszNew = NULL;
					wszNew = wcsstr ( wsz, L" | " );;

					if ( wszNew )
					{
						LPWSTR sz = NULL;

						try
						{
							if ( ( sz = new WCHAR [ wszNew - wsz + 1 ] ) == NULL )
							{
								delete [] p;
								return E_OUTOFMEMORY;
							}

							memcpy ( sz, wsz, ( wszNew - wsz ) * sizeof ( WCHAR ) );
							sz [ wszNew - wsz ] = L'\0';

							CComVariant var;
							CComVariant v ( sz );
							delete [] sz;

							if SUCCEEDED ( ::VariantChangeType ( &var, &v, VARIANT_NOVALUEPROP, VT_UI4 ) )
							{
								p[dwIndex++] = V_UI4 ( &var );
							}

							wsz = wszNew+3;
						}
						catch ( ... )
						{
							if ( sz )
							{
								delete [] sz;
								sz = NULL;
							}

							delete [] p;

							return E_UNEXPECTED;
						}
					}
					else
					{
						CComVariant var;
						CComVariant v ( wsz );

						if SUCCEEDED ( ::VariantChangeType ( &var, &v, VARIANT_NOVALUEPROP, VT_UI4 ) )
						{
							p[dwIndex++] = V_UI4 ( &var );
						}

						wsz = wszNew;
					}
				}
				while ( wsz != NULL );

				HRESULT hRes =  ULONGToVariant ( p, dwCount+1, pVar );

				delete [] p;
				return hRes;
			}
			break;

			case CIM_REAL32 | CIM_FLAG_ARRAY :
			{
				LPWSTR wsz = str;

				while ( ( wsz = wcsstr ( wsz, L" | ") ), wsz++ )
				{
					dwCount++;
				}

				float* p = NULL;

				try
				{
					if ( ( p = new float [ dwCount + 1 ] ) == NULL )
					{
						return E_OUTOFMEMORY;
					}
				}
				catch ( ... )
				{
					if ( p )
					{
						delete [] p;
						p = NULL;
					}

					return E_UNEXPECTED;
				}

				wsz = str;

				DWORD dwIndex = 0;

				do
				{
					LPWSTR wszNew = NULL;
					wszNew = wcsstr ( wsz, L" | " );;

					if ( wszNew )
					{
						LPWSTR sz = NULL;

						try
						{
							if ( ( sz = new WCHAR [ wszNew - wsz + 1 ] ) == NULL )
							{
								delete [] p;
								return E_OUTOFMEMORY;
							}

							memcpy ( sz, wsz, ( wszNew - wsz ) * sizeof ( WCHAR ) );
							sz [ wszNew - wsz ] = L'\0';

							CComVariant var;
							CComVariant v ( sz );
							delete [] sz;

							if SUCCEEDED ( ::VariantChangeType ( &var, &v, VARIANT_NOVALUEPROP, VT_R4 ) )
							{
								p[dwIndex++] = V_R4 ( &var );
							}

							wsz = wszNew+3;
						}
						catch ( ... )
						{
							if ( sz )
							{
								delete [] sz;
								sz = NULL;
							}

							delete [] p;

							return E_UNEXPECTED;
						}
					}
					else
					{
						CComVariant var;
						CComVariant v ( wsz );

						if SUCCEEDED ( ::VariantChangeType ( &var, &v, VARIANT_NOVALUEPROP, VT_R4 ) )
						{
							p[dwIndex++] = V_R4 ( &var );
						}

						wsz = wszNew;
					}
				}
				while ( wsz != NULL );

				HRESULT hRes =  FLOATToVariant ( p, dwCount+1, pVar );

				delete [] p;
				return hRes;
			}
			break;

			case CIM_REAL64 | CIM_FLAG_ARRAY :
			{
				LPWSTR wsz = str;

				while ( ( wsz = wcsstr ( wsz, L" | ") ), wsz++ )
				{
					dwCount++;
				}

				double* p = NULL;

				try
				{
					if ( ( p = new double [ dwCount + 1 ] ) == NULL )
					{
						return E_OUTOFMEMORY;
					}
				}
				catch ( ... )
				{
					if ( p )
					{
						delete [] p;
						p = NULL;
					}

					return E_UNEXPECTED;
				}

				wsz = str;

				DWORD dwIndex = 0;

				do
				{
					LPWSTR wszNew = NULL;
					wszNew = wcsstr ( wsz, L" | " );;

					if ( wszNew )
					{
						LPWSTR sz = NULL;

						try
						{
							if ( ( sz = new WCHAR [ wszNew - wsz + 1 ] ) == NULL )
							{
								delete [] p;
								return E_OUTOFMEMORY;
							}

							memcpy ( sz, wsz, ( wszNew - wsz ) * sizeof ( WCHAR ) );
							sz [ wszNew - wsz ] = L'\0';

							CComVariant var;
							CComVariant v ( sz );
							delete [] sz;

							if SUCCEEDED ( ::VariantChangeType ( &var, &v, VARIANT_NOVALUEPROP, VT_R8 ) )
							{
								p[dwIndex++] = V_R8 ( &var );
							}

							wsz = wszNew+3;
						}
						catch ( ... )
						{
							if ( sz )
							{
								delete [] sz;
								sz = NULL;
							}

							delete [] p;

							return E_UNEXPECTED;
						}
					}
					else
					{
						CComVariant var;
						CComVariant v ( wsz );

						if SUCCEEDED ( ::VariantChangeType ( &var, &v, VARIANT_NOVALUEPROP, VT_R8 ) )
						{
							p[dwIndex++] = V_R8 ( &var );
						}

						wsz = wszNew;
					}
				}
				while ( wsz != NULL );

				HRESULT hRes =  DOUBLEToVariant ( p, dwCount+1, pVar );

				delete [] p;
				return hRes;
			}
			break;

			case CIM_BOOLEAN | CIM_FLAG_ARRAY :
			{
				LPWSTR wsz = str;

				while ( ( wsz = wcsstr ( wsz, L" | ") ), wsz++ )
				{
					dwCount++;
				}

				BOOL * p = NULL;

				try
				{
					if ( ( p = new BOOL [ dwCount + 1 ] ) == NULL )
					{
						return E_OUTOFMEMORY;
					}
				}
				catch ( ... )
				{
					if ( p )
					{
						delete [] p;
						p = NULL;
					}

					return E_UNEXPECTED;
				}

				wsz = str;

				DWORD dwIndex = 0;

				do
				{
					LPWSTR wszNew = NULL;
					wszNew = wcsstr ( wsz, L" | " );;

					if ( wszNew )
					{
						LPWSTR sz = NULL;

						try
						{
							if ( ( sz = new WCHAR [ wszNew - wsz + 1 ] ) == NULL )
							{
								delete [] p;
								return E_OUTOFMEMORY;
							}

							memcpy ( sz, wsz, ( wszNew - wsz ) * sizeof ( WCHAR ) );
							sz [ wszNew - wsz ] = L'\0';

							CComVariant var;
							CComVariant v ( sz );
							delete [] sz;

							if SUCCEEDED ( ::VariantChangeType ( &var, &v, VARIANT_NOVALUEPROP, VT_BOOL ) )
							{
								p[dwIndex++] = V_BOOL ( &var );
							}

							wsz = wszNew+3;
						}
						catch ( ... )
						{
							if ( sz )
							{
								delete [] sz;
								sz = NULL;
							}

							delete [] p;

							return E_UNEXPECTED;
						}
					}
					else
					{
						CComVariant var;
						CComVariant v ( wsz );

						if SUCCEEDED ( ::VariantChangeType ( &var, &v, VARIANT_NOVALUEPROP, VT_BOOL ) )
						{
							p[dwIndex++] = V_BOOL ( &var );
						}

						wsz = wszNew;
					}
				}
				while ( wsz != NULL );

				HRESULT hRes =  BOOLToVariant ( p, dwCount+1, pVar );

				delete [] p;
				return hRes;
			}
			break;

			case CIM_SINT64 | CIM_FLAG_ARRAY :
			case CIM_UINT64 | CIM_FLAG_ARRAY :
			case CIM_STRING | CIM_FLAG_ARRAY :
			{
				LPWSTR wsz = str;

				while ( ( wsz = wcsstr ( wsz, L" | ") ), wsz++ )
				{
					dwCount++;
				}

				LPWSTR* p = NULL;

				try
				{
					if ( ( p = new LPWSTR [ dwCount + 1 ] ) == NULL )
					{
						return E_OUTOFMEMORY;
					}
				}
				catch ( ... )
				{
					if ( p )
					{
						delete [] p;
						p = NULL;
					}

					return E_UNEXPECTED;
				}

				wsz = str;

				DWORD dwIndex = 0;

				do
				{
					LPWSTR wszNew = NULL;
					wszNew = wcsstr ( wsz, L" | " );

					if ( wszNew )
					{
						LPWSTR sz = NULL;

						try
						{
							if ( ( sz = new WCHAR [ wszNew - wsz + 1 ] ) == NULL )
							{
								delete [] p;
								return E_OUTOFMEMORY;
							}

							memcpy ( sz, wsz, ( wszNew - wsz ) * sizeof ( WCHAR ) );
							sz [ wszNew - wsz ] = L'\0';

							p[dwIndex++] = sz;

							wsz = wszNew+3;
						}
						catch ( ... )
						{
							if ( sz )
							{
								delete [] sz;
								sz = NULL;
							}

							delete [] p;

							return E_UNEXPECTED;
						}
					}
					else
					{
						LPWSTR sz = NULL;

						try
						{
							if ( ( sz = new WCHAR [ lstrlenW ( wsz ) + 1 ] ) == NULL )
							{
								delete [] p;
								return E_OUTOFMEMORY;
							}

							memcpy ( sz, wsz, lstrlenW( wsz ) * sizeof ( WCHAR ) );
							sz [ lstrlenW ( wsz ) ] = L'\0';

							p[dwIndex++] = sz;

							wsz = wszNew;
						}
						catch ( ... )
						{
							if ( sz )
							{
								delete [] sz;
								sz = NULL;
							}

							delete [] p;

							return E_UNEXPECTED;
						}
					}
				}
				while ( wsz != NULL );

				HRESULT hRes =  LPWSTRToVariant ( p, dwCount+1, pVar );

				for ( DWORD d = 0L; d < dwCount + 1; d++ )
				{
					delete [] p[d];
				}

				delete [] p;

				return hRes;
			}
			break;

		}

		return E_UNEXPECTED;
	}

	static HRESULT	VariantToLPWSTR ( CIMTYPE type, VARIANT * pVar, LPWSTR* pResult )
	{
		if ( ! pResult )
		{
			return E_POINTER;
		}
		( * pResult ) = NULL;

		if ( ! pVar )
		{
			return E_INVALIDARG;
		}

		WCHAR	wsz [ _MAX_PATH ]	= { L'\0' };
		DWORD	dw					= 0L;

		switch ( type )
		{
			case CIM_SINT8 | CIM_FLAG_ARRAY:
			{
				signed char * p = NULL;

				if SUCCEEDED ( VariantToCHAR ( pVar, &p, &dw ) )
				{
					for ( DWORD d = 0L; d < dw; d++ )
					{
						if ( d < dw - 1 )
						{
							if ( wsz[0] != L'\0' )
							{
								wsprintfW ( wsz, L"%ls%d | ", wsz, p[d] );
							}
							else
							{
								wsprintfW ( wsz, L"%d | ", p[d] );
							}
						}
						else
						{
							if ( wsz[0] != L'\0' )
							{
								wsprintfW ( wsz, L"%ls%d", wsz, p[d] );
							}
							else
							{
								wsprintfW ( wsz, L"%d", p[d] );
							}
						}
					}

					delete [] p;
				}
			}
			break;

			case CIM_UINT8 | CIM_FLAG_ARRAY:
			{
				unsigned char * p = NULL;

				if SUCCEEDED ( VariantToUCHAR ( pVar, &p, &dw ) )
				{
					for ( DWORD d = 0L; d < dw; d++ )
					{
						if ( d < dw - 1 )
						{
							if ( wsz[0] != L'\0' )
							{
								wsprintfW ( wsz, L"%ls%d | ", wsz, p[d] );
							}
							else
							{
								wsprintfW ( wsz, L"%d | ", p[d] );
							}
						}
						else
						{
							if ( wsz[0] != L'\0' )
							{
								wsprintfW ( wsz, L"%ls%d", wsz, p[d] );
							}
							else
							{
								wsprintfW ( wsz, L"%d", p[d] );
							}
						}
					}

					delete [] p;
				}
			}
			break;

			case CIM_SINT16 | CIM_FLAG_ARRAY:
			{
				signed short * p = NULL;

				if SUCCEEDED ( VariantToSHORT ( pVar, &p, &dw ) )
				{
					for ( DWORD d = 0L; d < dw; d++ )
					{
						if ( d < dw - 1 )
						{
							if ( wsz[0] != L'\0' )
							{
								wsprintfW ( wsz, L"%ls%hd | ", wsz, p[d] );
							}
							else
							{
								wsprintfW ( wsz, L"%hd | ", p[d] );
							}
						}
						else
						{
							if ( wsz[0] != L'\0' )
							{
								wsprintfW ( wsz, L"%ls%hd", wsz, p[d] );
							}
							else
							{
								wsprintfW ( wsz, L"%hd", p[d] );
							}
						}
					}

					delete [] p;
				}
			}
			break;

			case CIM_UINT16 | CIM_FLAG_ARRAY:
			{
				unsigned short * p = NULL;

				if SUCCEEDED ( VariantToUSHORT ( pVar, &p, &dw ) )
				{
					for ( DWORD d = 0L; d < dw; d++ )
					{
						if ( d < dw - 1 )
						{
							if ( wsz[0] != L'\0' )
							{
								wsprintfW ( wsz, L"%ls%hu | ", wsz, p[d] );
							}
							else
							{
								wsprintfW ( wsz, L"%hu | ", p[d] );
							}
						}
						else
						{
							if ( wsz[0] != L'\0' )
							{
								wsprintfW ( wsz, L"%ls%hu", wsz, p[d] );
							}
							else
							{
								wsprintfW ( wsz, L"%hu", p[d] );
							}
						}
					}

					delete [] p;
				}
			}
			break;

			case CIM_SINT32 | CIM_FLAG_ARRAY:
			{
				signed long * p = NULL;

				if SUCCEEDED ( VariantToLONG ( pVar, &p, &dw ) )
				{
					for ( DWORD d = 0L; d < dw; d++ )
					{
						if ( d < dw - 1 )
						{
							if ( wsz[0] != L'\0' )
							{
								wsprintfW ( wsz, L"%ls%li | ", wsz, p[d] );
							}
							else
							{
								wsprintfW ( wsz, L"%li | ", p[d] );
							}
						}
						else
						{
							if ( wsz[0] != L'\0' )
							{
								wsprintfW ( wsz, L"%ls%li", wsz, p[d] );
							}
							else
							{
								wsprintfW ( wsz, L"%li", p[d] );
							}
						}
					}

					delete [] p;
				}
			}
			break;

			case CIM_UINT32 | CIM_FLAG_ARRAY:
			{
				unsigned long * p = NULL;

				if SUCCEEDED ( VariantToULONG ( pVar, &p, &dw ) )
				{
					for ( DWORD d = 0L; d < dw; d++ )
					{
						if ( d < dw - 1 )
						{
							if ( wsz[0] != L'\0' )
							{
								wsprintfW ( wsz, L"%ls%lu | ", wsz, p[d] );
							}
							else
							{
								wsprintfW ( wsz, L"%lu | ", p[d] );
							}
						}
						else
						{
							if ( wsz[0] != L'\0' )
							{
								wsprintfW ( wsz, L"%ls%lu", wsz, p[d] );
							}
							else
							{
								wsprintfW ( wsz, L"%lu", p[d] );
							}
						}
					}

					delete [] p;
				}
			}
			break;

			case CIM_REAL32 | CIM_FLAG_ARRAY:
			{
				float * p = NULL;

				if SUCCEEDED ( VariantToFLOAT ( pVar, &p, &dw ) )
				{
					for ( DWORD d = 0L; d < dw; d++ )
					{
						CComVariant var ( p[d] );
						CComVariant vardest;

						if SUCCEEDED ( ::VariantChangeType ( &vardest, &var, VARIANT_NOVALUEPROP, VT_BSTR ) )
						{
							if ( d < dw - 1 )
							{
								if ( wsz[0] != L'\0' )
								{
									wsprintfW ( wsz, L"%ls%ls | ", wsz, V_BSTR ( &vardest ) );
								}
								else
								{
									wsprintfW ( wsz, L"%ls | ", V_BSTR ( &vardest ) );
								}
							}
							else
							{
								if ( wsz[0] != L'\0' )
								{
									wsprintfW ( wsz, L"%ls%ls", wsz, V_BSTR ( &vardest ) );
								}
								else
								{
									wsprintfW ( wsz, L"%ls", V_BSTR ( &vardest ) );
								}
							}
						}
					}

					delete [] p;
				}
			}
			break;

			case CIM_REAL64 | CIM_FLAG_ARRAY:
			{
				double * p = NULL;

				if SUCCEEDED ( VariantToDOUBLE ( pVar, &p, &dw ) )
				{
					for ( DWORD d = 0L; d < dw; d++ )
					{
						CComVariant var ( p[d] );
						CComVariant vardest;

						if SUCCEEDED ( ::VariantChangeType ( &vardest, &var, VARIANT_NOVALUEPROP, VT_BSTR ) )
						{
							if ( d < dw - 1 )
							{
								if ( wsz[0] != L'\0' )
								{
									wsprintfW ( wsz, L"%ls%ls | ", wsz, V_BSTR ( &vardest ) );
								}
								else
								{
									wsprintfW ( wsz, L"%ls | ", V_BSTR ( &vardest ) );
								}
							}
							else
							{
								if ( wsz[0] != L'\0' )
								{
									wsprintfW ( wsz, L"%ls%ls", wsz, V_BSTR ( &vardest ) );
								}
								else
								{
									wsprintfW ( wsz, L"%ls", V_BSTR ( &vardest ) );
								}
							}
						}
					}

					delete [] p;
				}
			}
			break;

			case CIM_SINT64 | CIM_FLAG_ARRAY:
			{
				signed __int64 * p = NULL;

				if SUCCEEDED ( VariantToI64 ( pVar, &p, &dw ) )
				{
					for ( DWORD d = 0L; d < dw; d++ )
					{
						WCHAR sz [ _MAX_PATH ] = { L'\0' };
						_i64tow ( p[d], sz, 10 );

						if ( d < dw - 1 )
						{
							if ( wsz[0] != L'\0' )
							{
								wsprintfW ( wsz, L"%ls%ls | ", wsz, sz );
							}
							else
							{
								wsprintfW ( wsz, L"%ls | ", sz );
							}
						}
						else
						{
							if ( wsz[0] != L'\0' )
							{
								wsprintfW ( wsz, L"%ls%ls", wsz, sz );
							}
							else
							{
								wsprintfW ( wsz, L"%ls", sz );
							}
						}
					}

					delete [] p;
				}
			}
			break;

			case CIM_UINT64 | CIM_FLAG_ARRAY:
			{
				unsigned __int64 * p = NULL;

				if SUCCEEDED ( VariantToUI64 ( pVar, &p, &dw ) )
				{
					for ( DWORD d = 0L; d < dw; d++ )
					{
						WCHAR sz [ _MAX_PATH ] = { L'\0' };
						_ui64tow ( p[d], sz, 10 );

						if ( d < dw - 1 )
						{
							if ( wsz[0] != L'\0' )
							{
								wsprintfW ( wsz, L"%ls%ls | ", wsz, sz );
							}
							else
							{
								wsprintfW ( wsz, L"%ls | ", sz );
							}
						}
						else
						{
							if ( wsz[0] != L'\0' )
							{
								wsprintfW ( wsz, L"%ls%ls", wsz, sz );
							}
							else
							{
								wsprintfW ( wsz, L"%ls", sz );
							}
						}
					}

					delete [] p;
				}
			}
			break;

			case CIM_BOOLEAN | CIM_FLAG_ARRAY:
			{
				BOOL * p = NULL;

				if SUCCEEDED ( VariantToBOOL ( pVar, &p, &dw ) )
				{
					for ( DWORD d = 0L; d < dw; d++ )
					{
						if ( d < dw - 1 )
						{
							if ( wsz[0] != L'\0' )
							{
								wsprintfW ( wsz, L"%ls%d | ", wsz, (char) p[d] );
							}
							else
							{
								wsprintfW ( wsz, L"%d | ", (char) p[d] );
							}
						}
						else
						{
							if ( wsz[0] != L'\0' )
							{
								wsprintfW ( wsz, L"%ls%d", wsz, (char) p[d] );
							}
							else
							{
								wsprintfW ( wsz, L"%d", (char) p[d] );
							}
						}
					}

					delete [] p;
				}
			}
			break;

			case CIM_STRING | CIM_FLAG_ARRAY:
			{
				LPWSTR * p = NULL;

				if SUCCEEDED ( VariantToLPWSTR ( pVar, &p, &dw ) )
				{
					for ( DWORD d = 0L; d < dw; d++ )
					{
						if ( d < dw - 1 )
						{
							if (  wsz[0] != L'\0' )
							{
								wsprintfW ( wsz, L"%ls%ls | ", wsz, p[d] );
							}
							else
							{
								wsprintfW ( wsz, L"%ls | ", p[d] );
							}
						}
						else
						{
							if ( wsz[0] != L'\0' )
							{
								wsprintfW ( wsz, L"%ls%ls", wsz, p[d] );
							}
							else
							{
								wsprintfW ( wsz, L"%ls", p[d] );
							}
						}
					}

					for ( d = 0L; d < dw; d++ )
					{
						delete [] p[d];
					}

					delete [] p;
				}
			}
			break;

			default:
			{
				CComVariant var;

				if SUCCEEDED ( ::VariantChangeType ( &var, pVar, VARIANT_NOVALUEPROP, VT_BSTR ) )
				{
					try
					{
						if ( ( ( *pResult ) = new WCHAR [ ::SysStringLen ( V_BSTR ( & var ) ) + 1 ] ) == NULL )
						{
							return E_OUTOFMEMORY;
						}

						lstrcpyW ( ( *pResult ), V_BSTR ( &var ) );

						return S_OK;
					}
					catch ( ... )
					{
						if ( ( *pResult ) )
						{
							delete [] ( * pResult );
							( * pResult ) = NULL;
						}

						return E_UNEXPECTED;
					}
				}
			}
			break;
		}

		if ( wsz [0] != L'\0' )
		{
			try
			{
				if ( ( ( *pResult ) = new WCHAR [ lstrlenW ( wsz ) + 1 ] ) == NULL )
				{
					return E_OUTOFMEMORY;
				}

				lstrcpyW ( ( *pResult ), wsz );

				return S_OK;
			}
			catch ( ... )
			{
				if ( ( *pResult ) )
				{
					delete [] ( * pResult );
					( * pResult ) = NULL;
				}

				return E_UNEXPECTED;
			}
		}

		return E_UNEXPECTED;
	}

	static HRESULT	CHARToVariant ( signed char* pVal, DWORD pValSize, VARIANT* pVar )
	{
		if ( ! pVar ) 
		{
			return E_POINTER;
		}

		SAFEARRAY * psa = NULL;

		if SUCCEEDED ( ConvertCHARArrayToSafeArray ( pVal, pValSize, &psa ) )
		{
			::VariantInit ( pVar );

			V_VT ( pVar ) = VT_I1 | VT_ARRAY;
			V_ARRAY ( pVar ) = psa;

			return S_OK;
		}

		return E_INVALIDARG;
	}

	static HRESULT	UCHARToVariant ( unsigned char* pVal, DWORD pValSize, VARIANT* pVar )
	{
		if ( ! pVar ) 
		{
			return E_POINTER;
		}

		SAFEARRAY * psa = NULL;

		if SUCCEEDED ( ConvertUCHARArrayToSafeArray ( pVal, pValSize, &psa ) )
		{
			::VariantInit ( pVar );

			V_VT ( pVar ) = VT_UI1 | VT_ARRAY;
			V_ARRAY ( pVar ) = psa;

			return S_OK;
		}

		return E_INVALIDARG;
	}

	static HRESULT	SHORTToVariant ( short* pVal, DWORD pValSize, VARIANT* pVar )
	{
		if ( ! pVar ) 
		{
			return E_POINTER;
		}

		SAFEARRAY * psa = NULL;

		if SUCCEEDED ( ConvertSHORTArrayToSafeArray ( pVal, pValSize, &psa ) )
		{
			::VariantInit ( pVar );

			V_VT ( pVar ) = VT_I2 | VT_ARRAY;
			V_ARRAY ( pVar ) = psa;

			return S_OK;
		}

		return E_INVALIDARG;
	}

	static HRESULT	USHORTToVariant ( unsigned short* pVal, DWORD pValSize, VARIANT* pVar )
	{
		if ( ! pVar ) 
		{
			return E_POINTER;
		}

		SAFEARRAY * psa = NULL;

		if SUCCEEDED ( ConvertUSHORTArrayToSafeArray ( pVal, pValSize, &psa ) )
		{
			::VariantInit ( pVar );

			V_VT ( pVar ) = VT_UI2 | VT_ARRAY;
			V_ARRAY ( pVar ) = psa;

			return S_OK;
		}

		return E_INVALIDARG;
	}

	static HRESULT	LONGToVariant ( long* pVal, DWORD pValSize, VARIANT* pVar )
	{
		if ( ! pVar ) 
		{
			return E_POINTER;
		}

		SAFEARRAY * psa = NULL;

		if SUCCEEDED ( ConvertLONGArrayToSafeArray ( pVal, pValSize, &psa ) )
		{
			::VariantInit ( pVar );

			V_VT ( pVar ) = VT_I4 | VT_ARRAY;
			V_ARRAY ( pVar ) = psa;

			return S_OK;
		}

		return E_INVALIDARG;
	}

	static HRESULT	ULONGToVariant ( unsigned long* pVal, DWORD pValSize, VARIANT* pVar )
	{
		if ( ! pVar ) 
		{
			return E_POINTER;
		}

		SAFEARRAY * psa = NULL;

		if SUCCEEDED ( ConvertULONGArrayToSafeArray ( pVal, pValSize, &psa ) )
		{
			::VariantInit ( pVar );

			V_VT ( pVar ) = VT_UI4 | VT_ARRAY;
			V_ARRAY ( pVar ) = psa;

			return S_OK;
		}

		return E_INVALIDARG;
	}

	static HRESULT	FLOATToVariant ( float* pVal, DWORD pValSize, VARIANT* pVar )
	{
		if ( ! pVar ) 
		{
			return E_POINTER;
		}

		SAFEARRAY * psa = NULL;

		if SUCCEEDED ( ConvertFLOATArrayToSafeArray ( pVal, pValSize, &psa ) )
		{
			::VariantInit ( pVar );

			V_VT ( pVar ) = VT_R4 | VT_ARRAY;
			V_ARRAY ( pVar ) = psa;

			return S_OK;
		}

		return E_INVALIDARG;
	}

	static HRESULT	DOUBLEToVariant ( double* pVal, DWORD pValSize, VARIANT* pVar )
	{
		if ( ! pVar ) 
		{
			return E_POINTER;
		}

		SAFEARRAY * psa = NULL;

		if SUCCEEDED ( ConvertDOUBLEArrayToSafeArray ( pVal, pValSize, &psa ) )
		{
			::VariantInit ( pVar );

			V_VT ( pVar ) = VT_R8 | VT_ARRAY;
			V_ARRAY ( pVar ) = psa;

			return S_OK;
		}

		return E_INVALIDARG;
	}

	static HRESULT	BOOLToVariant ( BOOL * pVal, DWORD pValSize, VARIANT* pVar )
	{
		if ( ! pVar ) 
		{
			return E_POINTER;
		}

		SAFEARRAY * psa = NULL;

		if SUCCEEDED ( ConvertBOOLArrayToSafeArray ( pVal, pValSize, &psa ) )
		{
			::VariantInit ( pVar );

			V_VT ( pVar ) = VT_BOOL | VT_ARRAY;
			V_ARRAY ( pVar ) = psa;

			return S_OK;
		}

		return E_INVALIDARG;
	}

	static HRESULT	LPWSTRToVariant ( LPWSTR* pVal, DWORD pValSize, VARIANT* pVar )
	{
		if ( ! pVar ) 
		{
			return E_POINTER;
		}

		SAFEARRAY * psa = NULL;

		if SUCCEEDED ( ConvertLPWSTRArrayToSafeArray ( pVal, pValSize, &psa ) )
		{
			::VariantInit ( pVar );

			V_VT ( pVar ) = VT_BSTR | VT_ARRAY;
			V_ARRAY ( pVar ) = psa;

			return S_OK;
		}

		return E_INVALIDARG;
	}

	static HRESULT	I64ToVariant ( __int64* pVal, DWORD pValSize, VARIANT* pVar )
	{
		if ( ! pVar ) 
		{
			return E_POINTER;
		}

		SAFEARRAY * psa = NULL;

		if SUCCEEDED ( ConvertI64ArrayToSafeArray ( pVal, pValSize, &psa ) )
		{
			::VariantInit ( pVar );

			V_VT ( pVar ) = VT_BSTR | VT_ARRAY;
			V_ARRAY ( pVar ) = psa;

			return S_OK;
		}

		return E_INVALIDARG;
	}

	static HRESULT	UI64ToVariant ( unsigned __int64* pVal, DWORD pValSize, VARIANT* pVar )
	{
		if ( ! pVar ) 
		{
			return E_POINTER;
		}

		SAFEARRAY * psa = NULL;

		if SUCCEEDED ( ConvertUI64ArrayToSafeArray ( pVal, pValSize, &psa ) )
		{
			::VariantInit ( pVar );

			V_VT ( pVar ) = VT_BSTR | VT_ARRAY;
			V_ARRAY ( pVar ) = psa;

			return S_OK;
		}

		return E_INVALIDARG;
	}

	static HRESULT	VariantToCHAR ( VARIANT * pvar, signed char** pVal, DWORD * pValSize )
	{
		if ( V_VT ( pvar ) == VT_I1 | VT_ARRAY )
		{
			return ConvertSafeArrayToCHARArray ( V_ARRAY ( pvar ), pVal, pValSize );
		}

		return E_INVALIDARG;
	}

	static HRESULT	VariantToUCHAR ( VARIANT * pvar, unsigned char** pVal, DWORD * pValSize )
	{
		if ( V_VT ( pvar ) == VT_UI1 | VT_ARRAY )
		{
			return ConvertSafeArrayToUCHARArray ( V_ARRAY ( pvar ), pVal, pValSize );
		}

		return E_INVALIDARG;
	}

	static HRESULT	VariantToSHORT ( VARIANT * pvar, short** pVal, DWORD * pValSize )
	{
		if ( V_VT ( pvar ) == VT_I2 | VT_ARRAY )
		{
			return ConvertSafeArrayToSHORTArray ( V_ARRAY ( pvar ), pVal, pValSize );
		}

		return E_INVALIDARG;
	}

	static HRESULT	VariantToUSHORT ( VARIANT * pvar, unsigned short** pVal, DWORD * pValSize )
	{
		if ( V_VT ( pvar ) == VT_UI2 | VT_ARRAY )
		{
			return ConvertSafeArrayToUSHORTArray ( V_ARRAY ( pvar ), pVal, pValSize );
		}

		return E_INVALIDARG;
	}

	static HRESULT	VariantToLONG ( VARIANT * pvar, long** pVal, DWORD * pValSize )
	{
		if ( V_VT ( pvar ) == VT_I4 | VT_ARRAY )
		{
			return ConvertSafeArrayToLONGArray ( V_ARRAY ( pvar ), pVal, pValSize );
		}

		return E_INVALIDARG;
	}

	static HRESULT	VariantToULONG ( VARIANT * pvar, unsigned long** pVal, DWORD * pValSize )
	{
		if ( V_VT ( pvar ) == VT_UI4 | VT_ARRAY )
		{
			return ConvertSafeArrayToULONGArray ( V_ARRAY ( pvar ), pVal, pValSize );
		}

		return E_INVALIDARG;
	}

	static HRESULT	VariantToFLOAT ( VARIANT * pvar, float** pVal, DWORD * pValSize )
	{
		if ( V_VT ( pvar ) == VT_R4 | VT_ARRAY )
		{
			return ConvertSafeArrayToFLOATArray ( V_ARRAY ( pvar ), pVal, pValSize );
		}

		return E_INVALIDARG;
	}

	static HRESULT	VariantToDOUBLE( VARIANT * pvar, double** pVal, DWORD * pValSize )
	{
		if ( V_VT ( pvar ) == VT_R8 | VT_ARRAY )
		{
			return ConvertSafeArrayToDOUBLEArray ( V_ARRAY ( pvar ), pVal, pValSize );
		}

		return E_INVALIDARG;
	}

	static HRESULT	VariantToBOOL ( VARIANT * pvar, BOOL ** pVal, DWORD * pValSize )
	{
		if ( V_VT ( pvar ) == VT_BOOL | VT_ARRAY )
		{
			return ConvertSafeArrayToBOOLArray ( V_ARRAY ( pvar ), pVal, pValSize );
		}

		return E_INVALIDARG;
	}

	static HRESULT	VariantToLPWSTR ( VARIANT * pvar, LPWSTR** pVal, DWORD * pValSize )
	{
		if ( V_VT ( pvar ) == VT_BSTR | VT_ARRAY )
		{
			return ConvertSafeArrayToLPWSTRArray ( V_ARRAY ( pvar ), pVal, pValSize );
		}

		return E_INVALIDARG;
	}

	static HRESULT	VariantToI64 ( VARIANT * pvar, __int64** pVal, DWORD * pValSize )
	{
		if ( V_VT ( pvar ) == VT_BSTR | VT_ARRAY )
		{
			return ConvertSafeArrayToI64Array ( V_ARRAY ( pvar ), pVal, pValSize );
		}

		return E_INVALIDARG;
	}

	static HRESULT	VariantToUI64 ( VARIANT * pvar, unsigned __int64** pVal, DWORD * pValSize )
	{
		if ( V_VT ( pvar ) == VT_BSTR | VT_ARRAY )
		{
			return ConvertSafeArrayToUI64Array ( V_ARRAY ( pvar ), pVal, pValSize );
		}

		return E_INVALIDARG;
	}

	//////////////////////////////////////////////////////////////////////////////////////////
	// functions
	//////////////////////////////////////////////////////////////////////////////////////////

	// SAFEARRAY (char) -> char*
	static HRESULT ConvertSafeArrayToCHARArray ( SAFEARRAY * psa, signed char** pp, DWORD* pdw )
	{
		HRESULT hr = S_OK;

		if ( ! psa )
		return E_INVALIDARG;

		if ( ! pp || ! pdw )
		return E_POINTER;

		(*pp)	= NULL;
		(*pdw)	= NULL;

		// allocate enough memory
		try
		{
			long u = 0;
			long l = 0;

			hr = ::SafeArrayGetUBound( psa, 1, &u );
			hr = ::SafeArrayGetLBound( psa, 1, &l );

			(*pdw) = u-l + 1;

			if ( (*pdw) )
			{
				if ( ( (*pp) = (signed char*) new signed char[ (*pdw) ] ) == NULL )
				{
					return E_OUTOFMEMORY;
				}

				signed char * pchar;

				if SUCCEEDED( hr = ::SafeArrayAccessData ( psa, (void**) &pchar ) )
				{
					for ( LONG lIndex = 0; lIndex < (LONG) (*pdw); lIndex++ )
					{
						(*pp)[lIndex] = pchar[lIndex];
					}
				}
				else
				return hr;

				::SafeArrayUnaccessData ( psa );
			}
			else
			return E_FAIL;
		}
		catch ( ... )
		{
			__Release::Release ( (void***)pp, pdw );
			return E_UNEXPECTED;
		}

		return S_OK;
	}

	// char* -> SAFEARRAY ( char )
	static HRESULT ConvertCHARArrayToSafeArray ( signed char* pp, DWORD dw ,SAFEARRAY ** ppsa )
	{
		if ( ! pp )
		return E_INVALIDARG;

		if ( ! ppsa )
		return E_POINTER;

		(*ppsa)	= NULL;

		try
		{
			SAFEARRAYBOUND rgsabound[1];
			rgsabound[0].lLbound	= 0;
			rgsabound[0].cElements	= dw;

			if ( ( (*ppsa) = ::SafeArrayCreate ( VT_I1, 1, rgsabound ) ) == NULL )
			{
				return E_OUTOFMEMORY;
			}

			for ( DWORD dwIndex = 0; dwIndex < dw; dwIndex++ )
			{
				::SafeArrayPutElement ( (*ppsa), (LONG*) &dwIndex, & ( pp [ dwIndex ] ) );
			}
		}
		catch ( ... )
		{
			__Release::Release ( (*ppsa) );
			return E_UNEXPECTED;
		}

		return S_OK;
	}

	// SAFEARRAY ( unsigned char) -> unsigned char*
	static HRESULT ConvertSafeArrayToUCHARArray ( SAFEARRAY * psa, unsigned char** pp, DWORD* pdw )
	{
		HRESULT hr = S_OK;

		if ( ! psa )
		return E_INVALIDARG;

		if ( ! pp || ! pdw )
		return E_POINTER;

		(*pp)	= NULL;
		(*pdw)	= NULL;

		// allocate enough memory
		try
		{
			long u = 0;
			long l = 0;

			hr = ::SafeArrayGetUBound( psa, 1, &u );
			hr = ::SafeArrayGetLBound( psa, 1, &l );

			(*pdw) = u-l + 1;

			if ( (*pdw) )
			{
				if ( ( (*pp) = (unsigned char*) new unsigned char[ (*pdw) ] ) == NULL )
				{
					return E_OUTOFMEMORY;
				}

				unsigned char * pchar;

				if SUCCEEDED( hr = ::SafeArrayAccessData ( psa, (void**) &pchar ) )
				{
					for ( LONG lIndex = 0; lIndex < (LONG) (*pdw); lIndex++ )
					{
						(*pp)[lIndex] = pchar[lIndex];
					}
				}
				else
				return hr;

				::SafeArrayUnaccessData ( psa );
			}
			else
			return E_FAIL;
		}
		catch ( ... )
		{
			__Release::Release ( (void***)pp, pdw );
			return E_UNEXPECTED;
		}

		return S_OK;
	}

	// unsigned char* -> SAFEARRAY ( unsigned char )
	static HRESULT ConvertUCHARArrayToSafeArray ( unsigned char* pp, DWORD dw ,SAFEARRAY ** ppsa )
	{
		if ( ! pp )
		return E_INVALIDARG;

		if ( ! ppsa )
		return E_POINTER;

		(*ppsa)	= NULL;

		try
		{
			SAFEARRAYBOUND rgsabound[1];
			rgsabound[0].lLbound	= 0;
			rgsabound[0].cElements	= dw;

			if ( ( (*ppsa) = ::SafeArrayCreate ( VT_UI1, 1, rgsabound ) ) == NULL )
			{
				return E_OUTOFMEMORY;
			}

			for ( DWORD dwIndex = 0; dwIndex < dw; dwIndex++ )
			{
				::SafeArrayPutElement ( (*ppsa), (LONG*) &dwIndex, & ( pp [ dwIndex ] ) );
			}
		}
		catch ( ... )
		{
			__Release::Release ( (*ppsa) );
			return E_UNEXPECTED;
		}

		return S_OK;
	}

	// SAFEARRAY (short) -> short*
	static HRESULT ConvertSafeArrayToSHORTArray ( SAFEARRAY * psa, short** pp, DWORD* pdw )
	{
		HRESULT hr = S_OK;

		if ( ! psa )
		return E_INVALIDARG;

		if ( ! pp || ! pdw )
		return E_POINTER;

		(*pp)	= NULL;
		(*pdw)	= NULL;

		// allocate enough memory
		try
		{
			long u = 0;
			long l = 0;

			hr = ::SafeArrayGetUBound( psa, 1, &u );
			hr = ::SafeArrayGetLBound( psa, 1, &l );

			(*pdw) = u-l + 1;

			if ( (*pdw) )
			{
				if ( ( (*pp) = (short*) new short[ (*pdw) ] ) == NULL )
				{
					return E_OUTOFMEMORY;
				}

				short * pshort;

				if SUCCEEDED( hr = ::SafeArrayAccessData ( psa, (void**) &pshort ) )
				{
					for ( LONG lIndex = 0; lIndex < (LONG) (*pdw); lIndex++ )
					{
						(*pp)[lIndex] = pshort[lIndex];
					}
				}
				else
				return hr;

				::SafeArrayUnaccessData ( psa );
			}
			else
			return E_FAIL;
		}
		catch ( ... )
		{
			__Release::Release ( (void***)pp, pdw );
			return E_UNEXPECTED;
		}

		return S_OK;
	}

	// short* -> SAFEARRAY ( short )
	static HRESULT ConvertSHORTArrayToSafeArray ( short* pp, DWORD dw ,SAFEARRAY ** ppsa )
	{
		if ( ! pp )
		return E_INVALIDARG;

		if ( ! ppsa )
		return E_POINTER;

		(*ppsa)	= NULL;

		try
		{
			SAFEARRAYBOUND rgsabound[1];
			rgsabound[0].lLbound	= 0;
			rgsabound[0].cElements	= dw;

			if ( ( (*ppsa) = ::SafeArrayCreate ( VT_I2, 1, rgsabound ) ) == NULL )
			{
				return E_OUTOFMEMORY;
			}

			for ( DWORD dwIndex = 0; dwIndex < dw; dwIndex++ )
			{
				::SafeArrayPutElement ( (*ppsa), (LONG*) &dwIndex, & ( pp [ dwIndex ] ) );
			}
		}
		catch ( ... )
		{
			__Release::Release ( (*ppsa) );
			return E_UNEXPECTED;
		}

		return S_OK;
	}

	// SAFEARRAY ( unsigned short ) -> unsigned short*
	static HRESULT ConvertSafeArrayToUSHORTArray ( SAFEARRAY * psa, unsigned short** pp, DWORD* pdw )
	{
		HRESULT hr = S_OK;

		if ( ! psa )
		return E_INVALIDARG;

		if ( ! pp || ! pdw )
		return E_POINTER;

		(*pp)	= NULL;
		(*pdw)	= NULL;

		// allocate enough memory
		try
		{
			long u = 0;
			long l = 0;

			hr = ::SafeArrayGetUBound( psa, 1, &u );
			hr = ::SafeArrayGetLBound( psa, 1, &l );

			(*pdw) = u-l + 1;

			if ( (*pdw) )
			{
				if ( ( (*pp) = (unsigned short*) new unsigned short[ (*pdw) ] ) == NULL )
				{
					return E_OUTOFMEMORY;
				}

				unsigned short * pshort;

				if SUCCEEDED( hr = ::SafeArrayAccessData ( psa, (void**) &pshort ) )
				{
					for ( LONG lIndex = 0; lIndex < (LONG) (*pdw); lIndex++ )
					{
						(*pp)[lIndex] = pshort[lIndex];
					}
				}
				else
				return hr;

				::SafeArrayUnaccessData ( psa );
			}
			else
			return E_FAIL;
		}
		catch ( ... )
		{
			__Release::Release ( (void***)pp, pdw );
			return E_UNEXPECTED;
		}

		return S_OK;
	}

	// unsigned short* -> SAFEARRAY ( unsigned short )
	static HRESULT ConvertUSHORTArrayToSafeArray ( unsigned short* pp, DWORD dw ,SAFEARRAY ** ppsa )
	{
		if ( ! pp )
		return E_INVALIDARG;

		if ( ! ppsa )
		return E_POINTER;

		(*ppsa)	= NULL;

		try
		{
			SAFEARRAYBOUND rgsabound[1];
			rgsabound[0].lLbound	= 0;
			rgsabound[0].cElements	= dw;

			if ( ( (*ppsa) = ::SafeArrayCreate ( VT_UI2, 1, rgsabound ) ) == NULL )
			{
				return E_OUTOFMEMORY;
			}

			for ( DWORD dwIndex = 0; dwIndex < dw; dwIndex++ )
			{
				::SafeArrayPutElement ( (*ppsa), (LONG*) &dwIndex, & ( pp [ dwIndex ] ) );
			}
		}
		catch ( ... )
		{
			__Release::Release ( (*ppsa) );
			return E_UNEXPECTED;
		}

		return S_OK;
	}

	// SAFEARRAY (long) -> long*
	static HRESULT ConvertSafeArrayToLONGArray ( SAFEARRAY * psa, long** pp, DWORD* pdw )
	{
		HRESULT hr = S_OK;

		if ( ! psa )
		return E_INVALIDARG;

		if ( ! pp || ! pdw )
		return E_POINTER;

		(*pp)	= NULL;
		(*pdw)	= NULL;

		// allocate enough memory
		try
		{
			long u = 0;
			long l = 0;

			hr = ::SafeArrayGetUBound( psa, 1, &u );
			hr = ::SafeArrayGetLBound( psa, 1, &l );

			(*pdw) = u-l + 1;

			if ( (*pdw) )
			{
				if ( ( (*pp) = (long*) new long[ (*pdw) ] ) == NULL )
				{
					return E_OUTOFMEMORY;
				}

				long * plong;

				if SUCCEEDED( hr = ::SafeArrayAccessData ( psa, (void**) &plong ) )
				{
					for ( LONG lIndex = 0; lIndex < (LONG) (*pdw); lIndex++ )
					{
						(*pp)[lIndex] = plong[lIndex];
					}
				}
				else
				return hr;

				::SafeArrayUnaccessData ( psa );
			}
			else
			return E_FAIL;
		}
		catch ( ... )
		{
			__Release::Release ( (void***)pp, pdw );
			return E_UNEXPECTED;
		}

		return S_OK;
	}

	// long* -> SAFEARRAY ( long )
	static HRESULT ConvertLONGArrayToSafeArray ( long* pp, DWORD dw ,SAFEARRAY ** ppsa )
	{
		if ( ! pp )
		return E_INVALIDARG;

		if ( ! ppsa )
		return E_POINTER;

		(*ppsa)	= NULL;

		try
		{
			SAFEARRAYBOUND rgsabound[1];
			rgsabound[0].lLbound	= 0;
			rgsabound[0].cElements	= dw;

			if ( ( (*ppsa) = ::SafeArrayCreate ( VT_I4, 1, rgsabound ) ) == NULL )
			{
				return E_OUTOFMEMORY;
			}

			for ( DWORD dwIndex = 0; dwIndex < dw; dwIndex++ )
			{
				::SafeArrayPutElement ( (*ppsa), (LONG*) &dwIndex, & ( pp [ dwIndex ] ) );
			}
		}
		catch ( ... )
		{
			__Release::Release ( (*ppsa) );
			return E_UNEXPECTED;
		}

		return S_OK;
	}

	// SAFEARRAY ( unsigned long) -> unsigned long*
	static HRESULT ConvertSafeArrayToULONGArray ( SAFEARRAY * psa, unsigned long** pp, DWORD* pdw )
	{
		HRESULT hr = S_OK;

		if ( ! psa )
		return E_INVALIDARG;

		if ( ! pp || ! pdw )
		return E_POINTER;

		(*pp)	= NULL;
		(*pdw)	= NULL;

		// allocate enough memory
		try
		{
			long u = 0;
			long l = 0;

			hr = ::SafeArrayGetUBound( psa, 1, &u );
			hr = ::SafeArrayGetLBound( psa, 1, &l );

			(*pdw) = u-l + 1;

			if ( (*pdw) )
			{
				if ( ( (*pp) = (unsigned long*) new unsigned long[ (*pdw) ] ) == NULL )
				{
					return E_OUTOFMEMORY;
				}

				unsigned long * plong;

				if SUCCEEDED( hr = ::SafeArrayAccessData ( psa, (void**) &plong ) )
				{
					for ( LONG lIndex = 0; lIndex < (LONG) (*pdw); lIndex++ )
					{
						(*pp)[lIndex] = plong[lIndex];
					}
				}
				else
				return hr;

				::SafeArrayUnaccessData ( psa );
			}
			else
			return E_FAIL;
		}
		catch ( ... )
		{
			__Release::Release ( (void***)pp, pdw );
			return E_UNEXPECTED;
		}

		return S_OK;
	}

	// unsigned long* -> SAFEARRAY ( unsigned long )
	static HRESULT ConvertULONGArrayToSafeArray ( unsigned long* pp, DWORD dw ,SAFEARRAY ** ppsa )
	{
		if ( ! pp )
		return E_INVALIDARG;

		if ( ! ppsa )
		return E_POINTER;

		(*ppsa)	= NULL;

		try
		{
			SAFEARRAYBOUND rgsabound[1];
			rgsabound[0].lLbound	= 0;
			rgsabound[0].cElements	= dw;

			if ( ( (*ppsa) = ::SafeArrayCreate ( VT_UI4, 1, rgsabound ) ) == NULL )
			{
				return E_OUTOFMEMORY;
			}

			for ( DWORD dwIndex = 0; dwIndex < dw; dwIndex++ )
			{
				::SafeArrayPutElement ( (*ppsa), (LONG*) &dwIndex, & ( pp [ dwIndex ] ) );
			}
		}
		catch ( ... )
		{
			__Release::Release ( (*ppsa) );
			return E_UNEXPECTED;
		}

		return S_OK;
	}

	// SAFEARRAY (float) -> float*
	static HRESULT ConvertSafeArrayToFLOATArray ( SAFEARRAY * psa, FLOAT** pp, DWORD* pdw )
	{
		HRESULT hr = S_OK;

		if ( ! psa )
		return E_INVALIDARG;

		if ( ! pp || ! pdw )
		return E_POINTER;

		(*pp)	= NULL;
		(*pdw)	= NULL;

		// allocate enough memory
		try
		{
			long u = 0;
			long l = 0;

			hr = ::SafeArrayGetUBound( psa, 1, &u );
			hr = ::SafeArrayGetLBound( psa, 1, &l );

			(*pdw) = u-l + 1;

			if ( (*pdw) )
			{
				if ( ( (*pp) = (float*) new float[ (*pdw) ] ) == NULL )
				{
					return E_OUTOFMEMORY;
				}

				float * pfloat;

				if SUCCEEDED( hr = ::SafeArrayAccessData ( psa, (void**) &pfloat ) )
				{
					for ( LONG lIndex = 0; lIndex < (LONG) (*pdw); lIndex++ )
					{
						(*pp)[lIndex] = pfloat[lIndex];
					}
				}
				else
				return hr;

				::SafeArrayUnaccessData ( psa );
			}
			else
			return E_FAIL;
		}
		catch ( ... )
		{
			__Release::Release ( (void***)pp, pdw );
			return E_UNEXPECTED;
		}

		return S_OK;
	}

	// float* -> SAFEARRAY ( float )
	static HRESULT ConvertFLOATArrayToSafeArray (  float* pp, DWORD dw ,SAFEARRAY ** ppsa )
	{
		if ( ! pp )
		return E_INVALIDARG;

		if ( ! ppsa )
		return E_POINTER;

		(*ppsa)	= NULL;

		try
		{
			SAFEARRAYBOUND rgsabound[1];
			rgsabound[0].lLbound	= 0;
			rgsabound[0].cElements	= dw;

			if ( ( (*ppsa) = ::SafeArrayCreate ( VT_R4, 1, rgsabound ) ) == NULL )
			{
				return E_OUTOFMEMORY;
			}

			for ( DWORD dwIndex = 0; dwIndex < dw; dwIndex++ )
			{
				::SafeArrayPutElement ( (*ppsa), (LONG*) &dwIndex, & ( pp [ dwIndex ] ) );
			}
		}
		catch ( ... )
		{
			__Release::Release ( (*ppsa) );
			return E_UNEXPECTED;
		}

		return S_OK;
	}

	// SAFEARRAY (double) -> double*
	static HRESULT ConvertSafeArrayToDOUBLEArray ( SAFEARRAY * psa, double** pp, DWORD* pdw )
	{
		HRESULT hr = S_OK;

		if ( ! psa )
		return E_INVALIDARG;

		if ( ! pp || ! pdw )
		return E_POINTER;

		(*pp)	= NULL;
		(*pdw)	= NULL;

		// allocate enough memory
		try
		{
			long u = 0;
			long l = 0;

			hr = ::SafeArrayGetUBound( psa, 1, &u );
			hr = ::SafeArrayGetLBound( psa, 1, &l );

			(*pdw) = u-l + 1;

			if ( (*pdw) )
			{
				if ( ( (*pp) = (double*) new double[ (*pdw) ] ) == NULL )
				{
					return E_OUTOFMEMORY;
				}

				double * pdouble;

				if SUCCEEDED( hr = ::SafeArrayAccessData ( psa, (void**) &pdouble ) )
				{
					for ( LONG lIndex = 0; lIndex < (LONG) (*pdw); lIndex++ )
					{
						(*pp)[lIndex] = pdouble[lIndex];
					}
				}
				else
				return hr;

				::SafeArrayUnaccessData ( psa );
			}
			else
			return E_FAIL;
		}
		catch ( ... )
		{
			__Release::Release ( (void***)pp, pdw );
			return E_UNEXPECTED;
		}

		return S_OK;
	}

	// double* -> SAFEARRAY ( double )
	static HRESULT ConvertDOUBLEArrayToSafeArray (  double* pp, DWORD dw ,SAFEARRAY ** ppsa )
	{
		if ( ! pp )
		return E_INVALIDARG;

		if ( ! ppsa )
		return E_POINTER;

		(*ppsa)	= NULL;

		try
		{
			SAFEARRAYBOUND rgsabound[1];
			rgsabound[0].lLbound	= 0;
			rgsabound[0].cElements	= dw;

			if ( ( (*ppsa) = ::SafeArrayCreate ( VT_R8, 1, rgsabound ) ) == NULL )
			{
				return E_OUTOFMEMORY;
			}

			for ( DWORD dwIndex = 0; dwIndex < dw; dwIndex++ )
			{
				::SafeArrayPutElement ( (*ppsa), (LONG*) &dwIndex, & ( pp [ dwIndex ] ) );
			}
		}
		catch ( ... )
		{
			__Release::Release ( (*ppsa) );
			return E_UNEXPECTED;
		}

		return S_OK;
	}

	// SAFEARRAY (BOOL) -> BOOL*
	static HRESULT ConvertSafeArrayToBOOLArray ( SAFEARRAY * psa, BOOL ** pp, DWORD* pdw )
	{
		HRESULT hr = S_OK;

		if ( ! psa )
		return E_INVALIDARG;

		if ( ! pp || ! pdw )
		return E_POINTER;

		(*pp)	= NULL;
		(*pdw)	= NULL;

		// allocate enough memory
		try
		{
			long u = 0;
			long l = 0;

			hr = ::SafeArrayGetUBound( psa, 1, &u );
			hr = ::SafeArrayGetLBound( psa, 1, &l );

			(*pdw) = u-l + 1;

			if ( (*pdw) )
			{
				if ( ( (*pp) = (BOOL *) new BOOL [ (*pdw) ] ) == NULL )
				{
					return E_OUTOFMEMORY;
				}

				WORD * pbool;

				if SUCCEEDED( hr = ::SafeArrayAccessData ( psa, (void**) &pbool ) )
				{
					for ( LONG lIndex = 0; lIndex < (LONG) (*pdw); lIndex++ )
					{
						(*pp)[lIndex] = pbool[lIndex];
					}
				}
				else
				return hr;

				::SafeArrayUnaccessData ( psa );
			}
			else
			return E_FAIL;
		}
		catch ( ... )
		{
			__Release::Release ( (void***)pp, pdw );
			return E_UNEXPECTED;
		}

		return S_OK;
	}

	// BOOL* -> SAFEARRAY ( BOOL )
	static HRESULT ConvertBOOLArrayToSafeArray (  BOOL * pp, DWORD dw ,SAFEARRAY ** ppsa )
	{
		if ( ! pp )
		return E_INVALIDARG;

		if ( ! ppsa )
		return E_POINTER;

		(*ppsa)	= NULL;

		try
		{
			SAFEARRAYBOUND rgsabound[1];
			rgsabound[0].lLbound	= 0;
			rgsabound[0].cElements	= dw;

			if ( ( (*ppsa) = ::SafeArrayCreate ( VT_BOOL, 1, rgsabound ) ) == NULL )
			{
				return E_OUTOFMEMORY;
			}

			for ( DWORD dwIndex = 0; dwIndex < dw; dwIndex++ )
			{
				::SafeArrayPutElement ( (*ppsa), (LONG*) &dwIndex, & ( pp [ dwIndex ] ) );
			}
		}
		catch ( ... )
		{
			__Release::Release ( (*ppsa) );
			return E_UNEXPECTED;
		}

		return S_OK;
	}

	// SAFEARRAY (BSTR) -> i64*
	static HRESULT ConvertSafeArrayToI64Array ( SAFEARRAY * psa, __int64** pp, DWORD* pdw )
	{
		HRESULT hr = S_OK;

		if ( ! psa )
		return E_INVALIDARG;

		if ( ! pp || ! pdw )
		return E_POINTER;

		(*pp)	= NULL;
		(*pdw)	= NULL;

		// allocate enough memory
		try
		{
			long u = 0;
			long l = 0;

			hr = ::SafeArrayGetUBound( psa, 1, &u );
			hr = ::SafeArrayGetLBound( psa, 1, &l );

			(*pdw) = u-l + 1;

			if ( (*pdw) )
			{
				if ( ( (*pp) = (__int64*) new __int64[ (*pdw) ] ) == NULL )
				{
					return E_OUTOFMEMORY;
				}

				BSTR * pbstr;

				if SUCCEEDED( hr = ::SafeArrayAccessData ( psa, (void**) &pbstr ) )
				{
					for ( LONG lIndex = 0; lIndex < (LONG) (*pdw); lIndex++ )
					{
						(*pp)[lIndex] = _wtoi64 ( pbstr[lIndex] );
					}
				}
				else
				return hr;

				::SafeArrayUnaccessData ( psa );
			}
			else
			return E_FAIL;
		}
		catch ( ... )
		{
			__Release::Release ( (void***)pp, pdw );
			return E_UNEXPECTED;
		}

		return S_OK;
	}

	// i64* -> SAFEARRAY ( BSTR )
	static HRESULT ConvertI64ArrayToSafeArray (  __int64* pp, DWORD dw ,SAFEARRAY ** ppsa )
	{
		if ( ! pp )
		return E_INVALIDARG;

		if ( ! ppsa )
		return E_POINTER;

		(*ppsa)	= NULL;

		try
		{
			SAFEARRAYBOUND rgsabound[1];
			rgsabound[0].lLbound	= 0;
			rgsabound[0].cElements	= dw;

			if ( ( (*ppsa) = ::SafeArrayCreate ( VT_BSTR, 1, rgsabound ) ) == NULL )
			{
				return E_OUTOFMEMORY;
			}

			for ( DWORD dwIndex = 0; dwIndex < dw; dwIndex++ )
			{
				WCHAR sz [ _MAX_PATH ] = { L'\0' };
				_i64tow ( pp [ dwIndex ], sz, 10 );

				BSTR bstr = NULL;
				bstr = ::SysAllocString( sz );

				if ( bstr )
				{
					::SafeArrayPutElement ( (*ppsa), (LONG*) &dwIndex, bstr );
					::SysFreeString ( bstr );
				}
			}
		}
		catch ( ... )
		{
			__Release::Release ( (*ppsa) );
			return E_UNEXPECTED;
		}

		return S_OK;
	}

	// SAFEARRAY (BSTR) -> ui64*
	static HRESULT ConvertSafeArrayToUI64Array ( SAFEARRAY * psa, unsigned __int64** pp, DWORD* pdw )
	{
		HRESULT hr = S_OK;

		if ( ! psa )
		return E_INVALIDARG;

		if ( ! pp || ! pdw )
		return E_POINTER;

		(*pp)	= NULL;
		(*pdw)	= NULL;

		// allocate enough memory
		try
		{
			long u = 0;
			long l = 0;

			hr = ::SafeArrayGetUBound( psa, 1, &u );
			hr = ::SafeArrayGetLBound( psa, 1, &l );

			(*pdw) = u-l + 1;

			if ( (*pdw) )
			{
				if ( ( (*pp) = (unsigned __int64*) new unsigned __int64[ (*pdw) ] ) == NULL )
				{
					return E_OUTOFMEMORY;
				}

				BSTR * pbstr;

				if SUCCEEDED( hr = ::SafeArrayAccessData ( psa, (void**) &pbstr ) )
				{
					for ( LONG lIndex = 0; lIndex < (LONG) (*pdw); lIndex++ )
					{
						(*pp)[lIndex] = ( unsigned __int64 ) _wtoi64 ( pbstr[lIndex] );
					}
				}
				else
				return hr;

				::SafeArrayUnaccessData ( psa );
			}
			else
			return E_FAIL;
		}
		catch ( ... )
		{
			__Release::Release ( (void***)pp, pdw );
			return E_UNEXPECTED;
		}

		return S_OK;
	}

	// ui64* -> SAFEARRAY ( BSTR )
	static HRESULT ConvertUI64ArrayToSafeArray (  unsigned __int64* pp, DWORD dw ,SAFEARRAY ** ppsa )
	{
		if ( ! pp )
		return E_INVALIDARG;

		if ( ! ppsa )
		return E_POINTER;

		(*ppsa)	= NULL;

		try
		{
			SAFEARRAYBOUND rgsabound[1];
			rgsabound[0].lLbound	= 0;
			rgsabound[0].cElements	= dw;

			if ( ( (*ppsa) = ::SafeArrayCreate ( VT_BSTR, 1, rgsabound ) ) == NULL )
			{
				return E_OUTOFMEMORY;
			}

			for ( DWORD dwIndex = 0; dwIndex < dw; dwIndex++ )
			{
				WCHAR sz [ _MAX_PATH ] = { L'\0' };
				_ui64tow ( pp [ dwIndex ], sz, 10 );

				BSTR bstr = NULL;
				bstr = ::SysAllocString( sz );

				if ( bstr )
				{
					::SafeArrayPutElement ( (*ppsa), (LONG*) &dwIndex, bstr );
					::SysFreeString ( bstr );
				}
			}
		}
		catch ( ... )
		{
			__Release::Release ( (*ppsa) );
			return E_UNEXPECTED;
		}

		return S_OK;
	}

	// SAFEARRAY (BSTR) -> LPWSTR*
	static HRESULT ConvertSafeArrayToLPWSTRArray ( SAFEARRAY * psa, LPWSTR** pppsz, DWORD* pdwsz )
	{
		HRESULT hr = S_OK;

		if ( ! psa )
		return E_INVALIDARG;

		if ( ! pppsz || ! pdwsz )
		return E_POINTER;

		(*pppsz)	= NULL;
		(*pdwsz)	= NULL;

		// allocate enough memory
		try
		{
			long u = 0;
			long l = 0;

			hr = ::SafeArrayGetUBound( psa, 1, &u );
			hr = ::SafeArrayGetLBound( psa, 1, &l );

			(*pdwsz) = u-l + 1;

			if ( (*pdwsz) )
			{
				if ( ( (*pppsz) = (LPWSTR*) new LPWSTR[ (*pdwsz) ] ) == NULL )
				{
					return E_OUTOFMEMORY;
				}

				// clear everything
				for ( LONG lIndex = 0; lIndex < (LONG) (*pdwsz); lIndex++ )
				{
					(*pppsz)[lIndex] = NULL;
				}

				BSTR * pbstr;

				if SUCCEEDED( hr = ::SafeArrayAccessData ( psa, (void**) &pbstr ) )
				{
					for ( LONG lIndex = 0; lIndex < (LONG) (*pdwsz); lIndex++ )
					{
						if ( ( (*pppsz)[lIndex] = (LPWSTR) new WCHAR[ (::SysStringLen(pbstr[lIndex]) + 1) ] ) == NULL )
						{
							return E_OUTOFMEMORY;
						}

						lstrcpyW ( (*pppsz)[lIndex], pbstr[lIndex] );
					}
				}
				else
				return hr;

				::SafeArrayUnaccessData ( psa );
			}
			else
			return E_FAIL;
		}
		catch ( ... )
		{
			__Release::Release ( (void***)pppsz, pdwsz );
			return E_UNEXPECTED;
		}

		return S_OK;
	}

	// LPWSTR* -> SAFEARRAY ( BSTR )
	static HRESULT ConvertLPWSTRArrayToSafeArray (  LPWSTR* ppsz, DWORD dwsz ,SAFEARRAY ** ppsa )
	{
		if ( ! ppsz )
		return E_INVALIDARG;

		if ( ! ppsa )
		return E_POINTER;

		(*ppsa)	= NULL;

		try
		{
			SAFEARRAYBOUND rgsabound[1];
			rgsabound[0].lLbound	= 0;
			rgsabound[0].cElements	= dwsz;

			if ( ( (*ppsa) = ::SafeArrayCreate ( VT_BSTR, 1, rgsabound ) ) == NULL )
			{
				return E_OUTOFMEMORY;
			}

			for ( DWORD dwIndex = 0; dwIndex < dwsz; dwIndex++ )
			{
				BSTR bstr = NULL;
				bstr = ::SysAllocString( ppsz[ dwIndex ] );

				if ( bstr )
				{
					::SafeArrayPutElement ( (*ppsa), (LONG*) &dwIndex, bstr );
					::SysFreeString ( bstr );
				}
			}
		}
		catch ( ... )
		{
			__Release::Release ( (*ppsa) );
			return E_UNEXPECTED;
		}

		return S_OK;
	}
};

#define	SAFEARRAY_TO_LPWSTRARRAY( psa, pppsz, pdwsz )\
__SafeArray::ConvertSafeArrayToLPWSTRArray( psa, pppsz, pdwsz )

#define	LPWSTRARRAY_TO_SAFEARRAY( ppsz, dwsz, ppsa )\
__SafeArray::ConvertLPWSTRArrayToSafeArray( ppsz, dwsz, ppsa )

#endif	__SAFE_ARRAY_WRAPPER__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\include\__macro_loadstring.h ===
///////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					__macro_loadstring.h
//
//	Abstract:
//
//					load string from resources helper
//
//	History:
//
//					initial		a-marius
//
///////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////// Resource Strings ///////////////////////////////////

#ifndef	__RESOURCE_STR__
#define	__RESOURCE_STR__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// inline helper
inline LPWSTR LoadStringHelper ( LPWSTR sz, LPWSTR szSource )
{
	if ( sz )
	{
		lstrcpyW ( sz, szSource );
	}

	delete ( szSource );
	return sz;
}

inline LPWSTR LoadStringSystem ( HINSTANCE hInst, UINT nID )
{
	WCHAR sz[512] = { L'\0' };
	DWORD lenght = 0;

	if ( ( lenght = ::LoadStringW ( hInst, nID, sz, 512 * sizeof ( WCHAR ) ) ) != 0 )
	{
		LPWSTR psz = NULL;

		if ( ( psz = reinterpret_cast<LPWSTR>( new WCHAR [ lenght + 1 ] ) ) != NULL )
		{
			lstrcpyW ( psz, sz );
		}

		return psz;
	}

	return NULL;
}

// macro
#ifndef	___LOADSTRING

#define	___LOADSTRINGDATA LPWSTR psz = NULL; DWORD dwSize = NULL;
#define	___LOADSTRING( hInst, nID ) \
( \
	( \
		( ! hInst ) ? NULL : \
		( \
			psz  = LoadStringSystem ( hInst, nID ), \
			size = ( \
						( ( ! psz ) ? NULL : ( ( lstrlenW ( psz ) + 1 ) ) * sizeof ( WCHAR ) ) \
				   ), \
\
			LoadStringHelper ( ( LPWSTR ) alloca ( size ), psz ) \
		) \
	) \
)

#endif	___LOADSTRING

#endif	__RESOURCE_STR__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\noncomevent\precomp.h ===
#ifndef	__PRECOMP_H__
#define	__PRECOMP_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

#define STRICT

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif	_WIN32_WINNT

#ifndef	WIN32_LEAN_AND_MEAN
#define	WIN32_LEAN_AND_MEAN
#endif	WIN32_LEAN_AND_MEAN

#define _ATL_SINGLE_THREADED

#include <windows.h>
#include <objbase.h>

///////////////////////////////////////////////////////////////////////////////
// macros
///////////////////////////////////////////////////////////////////////////////
#include <__macro_pragma.h>
#include <__macro_nocopy.h>
#include <__macro_loadstring.h>
#include <__macro_assert.h>
#include <__macro_err.h>

///////////////////////////////////////////////////////////////////////////////
// wbem stuff
///////////////////////////////////////////////////////////////////////////////
#ifndef	__WBEMIDL_H_
#include <wbemidl.h>
#endif	__WBEMIDL_H_

#include "NCObjApi.h"

#include "__Common_Convert.h"
#include "__Common_SmartPTR.h"

#include "__SafeArrayWrapper.h"

#include <atlbase.h>

///////////////////////////////////////////////////////////////////////////////
// defines
///////////////////////////////////////////////////////////////////////////////
#define	__SUPPORT_MSGBOX
#define	__SUPPORT_WAIT

#ifdef	_DEBUG
//#define	__DEBUG_STRESS
#endif	_DEBUG

#endif	__PRECOMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\noncomevent\noncomeventconnectdlg.cpp ===
// NonCOMEventConnectDlg.cpp : Implementation of CNonCOMEventConnectDlg
#include "precomp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// need atl wrappers
#ifndef	__ATLBASE_H__
#include <atlbase.h>
#endif	__ATLBASE_H__

// application
#include "_App.h"
extern MyApp		_App;

// module
#include "_Module.h"
extern MyModule _Module;

/////////////////////////////////////////////////////////////////////////////
// dialogs
/////////////////////////////////////////////////////////////////////////////

#include "_Dlg.h"
#include "_DlgImpl.h"

#include "NonCOMEventAboutDlg.h"
#include "NonCOMEventConnectDlg.h"
#include "NonCOMEventMainDlg.h"

/////////////////////////////////////////////////////////////////////////////
// variables
/////////////////////////////////////////////////////////////////////////////

extern LPWSTR	g_szQueryLang;
extern LPWSTR	g_szQuery;

extern LPWSTR	g_szQueryEvents;
extern LPWSTR	g_szQueryNamespace;

extern LPWSTR	g_szNamespaceRoot;
extern LPWSTR	g_szProviderName;

// enumerator
#include "Enumerator.h"

/////////////////////////////////////////////////////////////////////////////
// CNonCOMEventConnectDlg

LRESULT CNonCOMEventConnectDlg::OnInitDialog( UINT, WPARAM, LPARAM, BOOL& )
{
	// center the dialog on the screen
	CenterWindow(GetParent());

	// set icons
	HICON hIcon = (HICON)::LoadImage(	_Module.GetResourceInstance(),
										MAKEINTRESOURCE(IDR_MAINFRAME), 
										IMAGE_ICON,
										::GetSystemMetrics(SM_CXICON),
										::GetSystemMetrics(SM_CYICON),
										LR_DEFAULTCOLOR
									);
	SetIcon(hIcon, TRUE);

	HICON hIconSmall = (HICON)::LoadImage(	_Module.GetResourceInstance(),
											MAKEINTRESOURCE(IDR_MAINFRAME), 
											IMAGE_ICON,
											::GetSystemMetrics(SM_CXSMICON),
											::GetSystemMetrics(SM_CYSMICON),
											LR_DEFAULTCOLOR
										 );
	SetIcon(hIconSmall, FALSE);

	TextSet ( IDC_BUFFERSIZE, L"64000" );
	TextSet ( IDC_LATENCY, L"1000" );

	TextSet ( IDC_NAMESPACE, L"root\\cimv2" );
	TextSet ( IDC_PROVIDER, L"NonCOMTest Event Provider" );

	if ( ! _App.m_event.m_pLocator )
	{
		HWND	hNamespace	= NULL;
		HWND	hProvider	= NULL;

		hNamespace = GetDlgItem ( IDC_BUTTON_NAMESPACE );
		hProvider  = GetDlgItem ( IDC_BUTTON_PROVIDER );

		if ( hNamespace )
		{
			::EnableWindow ( hNamespace, FALSE );
		}

		if ( hProvider )
		{
			::EnableWindow ( hProvider, FALSE );
		}
	}

	// radio buttons
	CheckRadioButton ( IDC_BATCH_TRUE, IDC_BATCH_FALSE, IDC_BATCH_TRUE );

	if ( ! m_Events.IsEmpty() )
	{
		m_Events.DestroyARRAY();
	}

	return 1;  // Let the system set the focus
}

LRESULT CNonCOMEventConnectDlg::OnNamespace( WORD, WORD, HWND, BOOL& )
{
	if ( _App.m_event.m_pLocator )
	{
		MyDlg < CNonCOMEventCommonListDlg > dlg;

		if ( m_szNamespace )
		{
			delete [] m_szNamespace;
			m_szNamespace = NULL;
		}

		TextGet ( IDC_NAMESPACE, &m_szNamespace );

		if SUCCEEDED ( dlg.Init(	_App.m_event.m_pLocator,
									( m_szNamespace != NULL ) ? m_szNamespace : g_szNamespaceRoot ,
									g_szQueryLang,
									g_szQueryNamespace,
									L"Name"
								)
					 )
		{
			dlg.RunModal ( SW_SHOWDEFAULT );

			if ( dlg.GetDlg()->GetNamespace () )
			{
				TextSet ( IDC_NAMESPACE, dlg.GetDlg()->GetNamespace () );
			}
		}
	}

	return 0L;
}

LRESULT CNonCOMEventConnectDlg::OnProvider( WORD, WORD, HWND, BOOL& )
{
	if ( _App.m_event.m_pLocator )
	{
		MyDlg < CNonCOMEventCommonListDlg > dlg;

		if ( m_szNamespace )
		{
			delete [] m_szNamespace;
			m_szNamespace = NULL;
		}

		TextGet ( IDC_NAMESPACE, &m_szNamespace );

		if SUCCEEDED ( dlg.Init(	_App.m_event.m_pLocator,
									( m_szNamespace != NULL ) ? m_szNamespace : g_szNamespaceRoot,
									g_szProviderName,
									L"Name"
							   )
					 )
		{
			dlg.RunModal ( SW_SHOWDEFAULT );

			if ( dlg.GetDlg()->GetSelected () )
			{
				TextSet ( IDC_PROVIDER, dlg.GetDlg()->GetSelected () );
			}
		}
	}

	return 0L;
}

LRESULT CNonCOMEventConnectDlg::OnOK( WORD, WORD wID, HWND, BOOL& )
{
	// do connect :))

	DWORD	dwBufferSize	= 64000;
	DWORD	dwSendLatency	= 1000;

	BOOL	bBatchSend		= m_bBatch;

	if ( m_szNamespace )
	{
		delete [] m_szNamespace;
		m_szNamespace = NULL;
	}

	if FAILED ( TextGet ( IDC_NAMESPACE, &m_szNamespace ) )
	{
		wID = IDCANCEL;
	}

	if ( m_szProvider )
	{
		delete [] m_szProvider;
		m_szProvider = NULL;
	}

	if FAILED ( TextGet ( IDC_PROVIDER, &m_szProvider ) )
	{
		wID = IDCANCEL;
	}

	// get buffer size
	{
		LPWSTR wsz = NULL;

		if SUCCEEDED ( TextGet ( IDC_BUFFERSIZE, &wsz ) )
		{
			DWORD	dw =  ( DWORD )_wtoi ( wsz );

			if ( dw )
			{
				dwBufferSize = dw;
			}

			delete [] wsz;
		}
	}

	// get send latency
	{
		LPWSTR wsz = NULL;

		if SUCCEEDED ( TextGet ( IDC_LATENCY, &wsz ) )
		{
			DWORD	dw =  ( DWORD )_wtoi ( wsz );

			if ( dw )
			{
				dwSendLatency = dw;
			}

			delete [] wsz;
		}
	}

	// if everything is OK connect
	if ( wID == IDOK )
	{
		// wait
		CHourGlass hg;

		if ( FAILED ( _App.Connect	(
									m_szNamespace,
									m_szProvider,
									bBatchSend,
									dwBufferSize,
									dwSendLatency,
									GetParent (),
									CNonCOMEventMainDlg::EventSourceCallBack
									)
					)

					||

					! _App.IsConnected()
		   )
		{
			wID = IDCANCEL;
		}
		else
		{
			if FAILED ( EventsInit ( _App.m_event.m_pLocator, m_szNamespace, m_szProvider ) )
			{
				_App.Disconnect();
				wID = IDCANCEL;
			}
		}
	}

	EndDialog(wID);
	return 0;
}

LRESULT CNonCOMEventConnectDlg::OnCancel( WORD, WORD wID, HWND, BOOL& )
{
	EndDialog(wID);
	return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////
// private helpers
/////////////////////////////////////////////////////////////////////////////////////////
void	CNonCOMEventConnectDlg::UpdateData ( void )
{
	m_bBatch	= TRUE;
	m_bBatch	= IsDlgButtonChecked(IDC_BATCH_FALSE) ? FALSE : m_bBatch;
}

HRESULT	CNonCOMEventConnectDlg::TextSet ( UINT nDlgItem, LPCWSTR str )
{
	HRESULT hr = S_OK;

	if ( ! SetDlgItemText ( nDlgItem, str ) )
	{
		hr = HRESULT_FROM_WIN32 ( ::GetLastError() );
	}

	return hr;
}

HRESULT	CNonCOMEventConnectDlg::TextGet ( UINT nDlgItem, LPWSTR * pstr )
{
	if ( ! pstr )
	{
		return E_POINTER;
	}

	HRESULT hr = S_OK;

	WCHAR str [ _MAX_PATH ] = { L'\0' };

	if ( ! GetDlgItemText ( nDlgItem, str, _MAX_PATH * sizeof ( WCHAR ) ) )
	{
		hr = HRESULT_FROM_WIN32 ( ::GetLastError() );
	}
	else
	{
		try
		{
			if ( ( ( * pstr ) = new WCHAR [ lstrlenW ( str ) + 1 ] ) != NULL )
			{
				lstrcpyW ( ( * pstr ), str );
			}
			else
			{
				hr = E_OUTOFMEMORY;
			}
		}
		catch ( ... )
		{
			hr = E_UNEXPECTED;
		}
	}

	return hr;
}

///////////////////////////////////////////////////////////////////////////
// events helper
///////////////////////////////////////////////////////////////////////////

HRESULT	CNonCOMEventConnectDlg::EventsInit ( IWbemLocator * pLocator, LPWSTR wszNamespace, LPWSTR wszProvider )
{
	if ( ! pLocator || ! wszNamespace || ! wszProvider )
	{
		return E_POINTER;
	}

	CComBSTR szQuery = L"\\\\\\\\.\\\\";

	// deal w/ namespace
	DWORD dw = lstrlenW ( wszNamespace );

	if ( wszNamespace [ dw - 1 ] == L'\\' )
	{
		wszNamespace [ dw - 1 ] = L'\0';
	}

	LPWSTR wsz		= NULL;
	LPWSTR wszLast	= NULL;

	wsz		= _App._cstrchr ( wszNamespace, L'\\' );
	wszLast	= wszNamespace;

	while ( wsz )
	{
		LPWSTR w = NULL;

		try
		{
			if ( ( w = new WCHAR [ wsz - wszLast + 1 ] ) != NULL )
			{
				for ( DWORD dwIndex = 0; dwIndex < (DWORD) ( wsz - wszLast ); dwIndex++ )
				{
					w [ dwIndex ] = wszLast [ dwIndex ] ;
				}

				w [ dwIndex ] = L'\0';

				szQuery += w;
				szQuery += L"\\\\";
			}
		}
		catch ( ... )
		{
		}

		delete [] w;

		wszLast	= ++wsz;
		wsz		= _App._cstrchr ( wszLast, L'\\' );
	}

	szQuery += wszLast;

	szQuery += L":";
	szQuery += g_szProviderName;
	szQuery += L".Name=\\\"";
	szQuery += wszProvider;
	szQuery += L"\\\"";

	CComBSTR szWhere = L" where provider = \"";

	szWhere.AppendBSTR	( szQuery );
	szWhere.Append		( L"\"" );

	szQuery.Empty();

	szQuery.Append		( g_szQuery );
	szQuery.Append		( L" __EventProviderRegistration " );
	szQuery.AppendBSTR	( szWhere );

	CEnumerator Enum ( pLocator );

	DWORD	dwSize	= 0L;
	LPWSTR* p		= NULL;

	p = Enum.Get	(	wszNamespace,
						g_szQueryLang,
						szQuery,
						L"EventQueryList",
						&dwSize
					);

	HRESULT hr = S_OK;

	if ( p && dwSize )
	{
		try
		{
			if ( m_Events.SetData ( new LPWSTR [ dwSize ], dwSize ) , m_Events.IsEmpty () )
			{
				hr = E_OUTOFMEMORY;
			}
			else
			{
				for ( DWORD dwIndex = 0; dwIndex < dwSize; dwIndex++ )
				{
					LPWSTR w = NULL;

					try
					{
						LPWSTR wsz = NULL;
						wsz = _App._cstrstr ( p [ dwIndex ] , L"from " );

						if ( wsz )
						{
							wsz = wsz + 5;

							LPWSTR wszEvent = NULL;
							wszEvent = _App._cstrchr ( wsz, L' ' );

							if ( wszEvent )
							{
								if ( ( w = new WCHAR [ wszEvent - wsz + 1 ] ) != NULL )
								{
									for ( DWORD dwInd = 0; dwInd < ( DWORD ) ( wszEvent - wsz ); dwInd ++ )
									{
										w [ dwInd ] = wsz [ dwInd ];
									}

									w [ dwInd ] = L'\0';
								}
							}
							else
							{
								if ( ( w = new WCHAR [ lstrlenW ( wsz ) + 1 ] ) != NULL )
								{
									lstrcpyW ( w, wsz );
								}
							}
						}
					}
					catch ( ... )
					{
					}

					m_Events.SetAt ( dwIndex, w );
				}
			}
		}
		catch ( ... )
		{
			hr = E_FAIL;
		}
	}
	else
	{
		if ( p )
		{
			hr = E_FAIL;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}

	for ( DWORD dwIndex = 0; dwIndex < dwSize; dwIndex++ )
	{
		delete [] p [ dwIndex ];
		p [ dwIndex ] = NULL;
	}

	delete [] p;
	p = NULL;

	if FAILED ( hr )
	{
		m_Events.DestroyARRAY();
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\noncomevent\noncomeventpropertydlg.cpp ===
// NonCOMEventPropertyDlg.cpp : Implementation of CNonCOMEventPropertyDlg
#include "precomp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// need atl wrappers
#ifndef	__ATLBASE_H__
#include <atlbase.h>
#endif	__ATLBASE_H__

#include "_App.h"
extern MyApp _App;

#include "_Module.h"
extern MyModule _Module;

// dialogs
#include "NonCOMEventPropertyDlg.h"

#pragma warning ( disable : 4244 )

LPWSTR wszTypes [] = 
{
	L"CIM_SINT8",
	L"CIM_UINT8",
	L"CIM_SINT16",
	L"CIM_UINT16",
	L"CIM_SINT32",
	L"CIM_UINT32",
	L"CIM_SINT64",
	L"CIM_UINT64",
	L"CIM_REAL32",
	L"CIM_REAL64",
	L"CIM_BOOLEAN",
	L"CIM_STRING",
	L"CIM_DATETIME",
	L"CIM_REFERENCE",
	L"CIM_CHAR16",
	L"CIM_OBJECT",
	L"CIM_SINT8 | CIM_FLAG_ARRAY",
	L"CIM_UINT8 | CIM_FLAG_ARRAY",
	L"CIM_SINT16 | CIM_FLAG_ARRAY",
	L"CIM_UINT16 | CIM_FLAG_ARRAY",
	L"CIM_SINT32 | CIM_FLAG_ARRAY",
	L"CIM_UINT32 | CIM_FLAG_ARRAY",
	L"CIM_SINT64 | CIM_FLAG_ARRAY",
	L"CIM_UINT64 | CIM_FLAG_ARRAY",
	L"CIM_REAL32 | CIM_FLAG_ARRAY",
	L"CIM_REAL64 | CIM_FLAG_ARRAY",
	L"CIM_BOOLEAN | CIM_FLAG_ARRAY",
	L"CIM_STRING | CIM_FLAG_ARRAY",
	L"CIM_DATETIME | CIM_FLAG_ARRAY",
	L"CIM_REFERENCE | CIM_FLAG_ARRAY",
	L"CIM_CHAR16 | CIM_FLAG_ARRAY",
	L"CIM_OBJECT | CIM_FLAG_ARRAY"
};

DWORD dwTypes = 32;

CNonCOMEventPropertyDlg::CNonCOMEventPropertyDlg( BOOL bBehaviour ) :
m_bBehaviour ( bBehaviour ),
m_bSet ( FALSE ),

m_pcbIndex ( NULL ),

m_pcbType ( NULL ),

m_Index ( 0 ),

m_wszName ( NULL ),
m_wszType ( NULL ),
m_wszValue ( NULL )
{
}

LRESULT CNonCOMEventPropertyDlg::OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
{
	CenterWindow(GetParent());

	// set icons
	HICON hIcon = (HICON)::LoadImage(	_Module.GetResourceInstance(),
										MAKEINTRESOURCE(IDR_MAINFRAME), 
										IMAGE_ICON,
										::GetSystemMetrics(SM_CXICON),
										::GetSystemMetrics(SM_CYICON),
										LR_DEFAULTCOLOR
									);
	SetIcon(hIcon, TRUE);

	HICON hIconSmall = (HICON)::LoadImage(	_Module.GetResourceInstance(),
											MAKEINTRESOURCE(IDR_MAINFRAME), 
											IMAGE_ICON,
											::GetSystemMetrics(SM_CXSMICON),
											::GetSystemMetrics(SM_CYSMICON),
											LR_DEFAULTCOLOR
										 );
	SetIcon(hIconSmall, FALSE);

	// wrap combo box
	HWND hEvents = NULL;
	hEvents = GetDlgItem ( IDC_COMBO_TYPE );

	if ( hEvents )
	{
		try
		{
			if ( ! m_pcbType && ( m_pcbType = new CComboBox ( hEvents ) ) != NULL )
			{
				for ( DWORD dw = 0; dw < dwTypes; dw++ )
				{
					m_pcbType->AddString ( wszTypes [ dw ] );
				}

				m_pcbType -> SetCurSel ( 0 ) ;
			}
		}
		catch ( ... )
		{
		}
	}

	::ShowWindow ( GetDlgItem ( IDC_STATIC_ARRAY ), SW_HIDE );

	if ( m_bBehaviour )
	{
		// wrap combo box
		HWND hEvents = NULL;
		hEvents = GetDlgItem ( IDC_COMBO_INDEX );

		if ( hEvents )
		{
			try
			{
				if ( ! m_pcbIndex && ( m_pcbIndex = new CComboBox ( hEvents ) ) != NULL )
				{
					if ( ! _App.m_event.m_properties.IsEmpty () )
					{
						for ( DWORD dw = 0; dw < _App.m_event.m_properties; dw ++ )
						{
							WCHAR wsz [ _MAX_PATH ] = { L'\0' };
							wsprintf ( wsz, L" %d ", dw );

							m_pcbIndex -> AddString ( wsz );
						}

						m_pcbIndex -> SetCurSel ( 0 ) ;
					}
					else
					{
						::ShowWindow ( GetDlgItem ( IDC_STATIC_INDEX ) , SW_HIDE );
						::ShowWindow ( GetDlgItem ( IDC_COMBO_INDEX ) , SW_HIDE );
					}
				}
			}
			catch ( ... )
			{
			}
		}

		if ( m_pcbIndex )
		{
			BOOL bHandled = FALSE;
			OnIndex ( CBN_SELCHANGE, IDC_COMBO_INDEX, NULL, bHandled );
		}

		::EnableWindow ( GetDlgItem ( IDC_EDIT_NAME ) , FALSE );
		::EnableWindow ( GetDlgItem ( IDC_EDIT_TYPE ) , FALSE );

		::ShowWindow ( GetDlgItem ( IDC_COMBO_TYPE ) , SW_HIDE );

		// set focus to value field
		::SetFocus ( GetDlgItem ( IDC_EDIT_VALUE ) );
	}
	else
	{
		::ShowWindow ( GetDlgItem ( IDC_STATIC_VALUE ) , SW_HIDE );
		::ShowWindow ( GetDlgItem ( IDC_EDIT_VALUE ) , SW_HIDE );

		::ShowWindow ( GetDlgItem ( IDC_STATIC_INDEX ) , SW_HIDE );
		::ShowWindow ( GetDlgItem ( IDC_COMBO_INDEX ) , SW_HIDE );

		::ShowWindow ( GetDlgItem ( IDC_EDIT_TYPE ) , SW_HIDE );

		::ShowWindow ( GetDlgItem ( IDC_CHECK_SET ) , SW_HIDE );

		// set focus to name field
		::SetFocus ( GetDlgItem ( IDC_EDIT_NAME ) );
	}

	return TRUE;
}

LRESULT CNonCOMEventPropertyDlg::OnChangeSet	(WORD, WORD, HWND, BOOL&)
{
	m_bSet = !m_bSet;
	return 0L;
}

LRESULT CNonCOMEventPropertyDlg::OnIndex	(WORD wNotifyCode, WORD , HWND , BOOL& )
{
	if ( wNotifyCode == CBN_SELCHANGE )
	{
		// set old data if required
		if ( m_bSet )
		{
			PropertySet ( );

			delete [] m_wszValue;
			m_wszValue = NULL;
		}

		SetDlgItemText ( IDC_EDIT_VALUE, L"" );

		if ( m_pcbIndex && ! _App.m_event.m_properties.IsEmpty () ) 
		{
			try
			{
				if ( ( m_Index = m_pcbIndex->GetCurSel() ) != CB_ERR )
				{
					if ( m_wszName )
					{
						delete [] m_wszName;
						m_wszName = NULL;
					}

					try
					{
						if ( ( m_wszName = new WCHAR [ lstrlenW ( _App.m_event.m_properties.GetAt( m_Index )->GetName() ) + 1 ] ) != NULL )
						{
							lstrcpyW ( m_wszName, _App.m_event.m_properties.GetAt( m_Index )-> GetName() );
							SetDlgItemText ( IDC_EDIT_NAME, m_wszName );
						}
					}
					catch ( ... )
					{
					}

					if ( m_wszType )
					{
						delete [] m_wszType;
						m_wszType = NULL;
					}

					try
					{
						if ( ( m_wszType = new WCHAR [ lstrlenW ( _App.m_event.m_properties.GetAt( m_Index )->GetTypeString() ) + 1 ] ) != NULL )
						{
							lstrcpyW ( m_wszType, _App.m_event.m_properties.GetAt( m_Index )-> GetTypeString() );
							SetDlgItemText ( IDC_EDIT_TYPE, m_wszType );
						}
					}
					catch ( ... )
					{
					}

					CIMTYPE type = CIM_EMPTY;
					type = _App.m_event.m_properties.GetAt ( m_Index ) -> GetType();

					if ( ! ( type & CIM_FLAG_ARRAY ) ) 
					{
						::ShowWindow ( GetDlgItem ( IDC_STATIC_ARRAY ), SW_HIDE );
					}
					else
					{
						::ShowWindow ( GetDlgItem ( IDC_STATIC_ARRAY ), SW_SHOW );
					}

					// refresh
					CComVariant var;
					_App.m_event.m_properties.GetAt ( m_Index ) -> GetValue ( & var );

					if ( V_VT ( & var ) != VT_EMPTY && 
						 V_VT ( & var ) != VT_UNKNOWN &&
						 V_VT ( & var ) != VT_DISPATCH
					   )
					{
						if ( !( V_VT ( & var ) & VT_ARRAY ) )
						{
							switch ( type )
							{
								case CIM_DATETIME:
								case CIM_DATETIME | CIM_FLAG_ARRAY:
								case CIM_REFERENCE:
								case CIM_REFERENCE | CIM_FLAG_ARRAY:
								case CIM_OBJECT:
								case CIM_OBJECT | CIM_FLAG_ARRAY:
								{
								}
								break;

								default:
								{
									CComVariant varDest;

									if SUCCEEDED ( ::VariantChangeType ( &varDest, &var, VARIANT_NOVALUEPROP, VT_BSTR ) )
									{
										SetDlgItemText ( IDC_EDIT_VALUE, V_BSTR ( &varDest ) );
									}
								}
								break;
							}
						}
						else
						{
							switch ( type )
							{
								case CIM_DATETIME:
								case CIM_DATETIME | CIM_FLAG_ARRAY:
								case CIM_REFERENCE:
								case CIM_REFERENCE | CIM_FLAG_ARRAY:
								case CIM_OBJECT:
								case CIM_OBJECT | CIM_FLAG_ARRAY:
								{
								}
								break;

								default:
								{
									LPWSTR wsz = NULL;

									if SUCCEEDED ( __SafeArray::VariantToLPWSTR (	_App.m_event.m_properties.GetAt ( m_Index ) -> GetType(),
																					&var,
																					&wsz
																				)
												 )
									{
										SetDlgItemText ( IDC_EDIT_VALUE, wsz );
									}

									if ( wsz )
									{
										delete [] wsz;
										wsz = NULL;
									}
								}
								break;
							}
						}
					}

					switch ( type )
					{
						case CIM_DATETIME:
						case CIM_DATETIME | CIM_FLAG_ARRAY:
						{
							SYSTEMTIME st;
							GetLocalTime ( &st );

							WCHAR time [ _MAX_PATH ] = { L'\0' };
							wsprintf ( time, L"%04d%02d%02d%02d%02d%02d.**********",
													st.wYear,
													st.wMonth,
													st.wDay,
													st.wHour,
													st.wMinute,
													st.wSecond
									 );

							SetDlgItemText ( IDC_EDIT_VALUE, time );
							::EnableWindow ( GetDlgItem ( IDC_EDIT_VALUE ) , FALSE );

							// set focus to ok button
							::SetFocus ( GetDlgItem ( IDOK ) );
						}
						break;

						case CIM_REFERENCE:
						case CIM_REFERENCE | CIM_FLAG_ARRAY:
						{
							if ( V_VT ( &var ) == VT_EMPTY )
							{
								SetDlgItemText ( IDC_EDIT_VALUE, L"Win32_Processor.DeviceID=\"CPU0\"" );
							}

							::EnableWindow ( GetDlgItem ( IDC_EDIT_VALUE ) , FALSE );

							// set focus to ok button
							::SetFocus ( GetDlgItem ( IDOK ) );
						}
						break;

						case CIM_OBJECT:
						case CIM_OBJECT | CIM_FLAG_ARRAY:
						{
							SetDlgItemText ( IDC_EDIT_VALUE, L" ... this only ... " );
							::EnableWindow ( GetDlgItem ( IDC_EDIT_VALUE ) , FALSE );

							// set focus to ok button
							::SetFocus ( GetDlgItem ( IDOK ) );
						}
						break;

						default:
						{
							::EnableWindow ( GetDlgItem ( IDC_EDIT_VALUE ) , TRUE );
						}
						break;
					}
				}
			}
			catch ( ... )
			{
			}
		}
	}

	return 0L;
}

LRESULT CNonCOMEventPropertyDlg::OnCloseCmd(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
{
	if ( wID == IDOK )
	{
		if ( ! m_bBehaviour )
		{
			if ( m_wszName )
			{
				delete [] m_wszName;
				m_wszName = NULL;
			}
			TextGet ( IDC_EDIT_NAME, &m_wszName );

			if ( m_wszType )
			{
				delete [] m_wszType;
				m_wszType = NULL;
			}

			TextGet ( IDC_COMBO_TYPE, &m_wszType );

			// test return Value
			if ( ! m_wszName || ! m_wszType )
			{
				wID = IDCANCEL;
			}
		}
		else
		{
			if ( m_wszValue )
			{
				delete [] m_wszValue;
				m_wszValue = NULL;
			}
			TextGet ( IDC_EDIT_VALUE, &m_wszValue );

			if ( m_pcbIndex )
			{
				m_Index = m_pcbIndex -> GetCurSel();
			}

			// test return Value
			if ( ! m_wszValue || m_Index == LB_ERR )
			{
				wID = IDCANCEL;
			}
		}
	}

	EndDialog(wID);
	return 0;
}

HRESULT	CNonCOMEventPropertyDlg::TextGet ( UINT nDlgItem, LPWSTR * pstr )
{
	if ( ! pstr )
	{
		return E_POINTER;
	}

	HRESULT hr = S_OK;

	WCHAR str [ _MAX_PATH ] = { L'\0' };

	if ( ! GetDlgItemText ( nDlgItem, str, _MAX_PATH * sizeof ( WCHAR ) ) )
	{
		hr = HRESULT_FROM_WIN32 ( ::GetLastError() );
	}
	else
	{
		try
		{
			if ( ( ( * pstr ) = new WCHAR [ lstrlenW ( str ) + 1 ] ) != NULL )
			{
				lstrcpyW ( ( * pstr ), str );
			}
			else
			{
				hr = E_OUTOFMEMORY;
			}
		}
		catch ( ... )
		{
			hr = E_UNEXPECTED;
		}
	}

	return hr;
}

HRESULT CNonCOMEventPropertyDlg::PropertySet ( void )
{
	HRESULT hRes = S_OK;

	try
	{
		if ( ! m_wszValue )
		{
			TextGet ( IDC_EDIT_VALUE, &m_wszValue );
		}

		CComVariant varDest;
		CComVariant	var ( m_wszValue );

		CIMTYPE type = _App.m_event.m_properties [ m_Index ] -> GetType ();

		switch ( type )
		{
			case CIM_SINT8:
			{
				if SUCCEEDED ( ::VariantChangeType ( & varDest, & var, VARIANT_NOVALUEPROP, type ) )
				{
					_App.m_event.PropertySet ( m_Index, ( signed char ) V_I1 ( & varDest ) );
				}
				else
				{
					_App.m_event.PropertySet ( m_Index, ( unsigned char ) * V_I1REF ( & var ) );
				}
			}
			break;

			case CIM_UINT8:
			{
				if SUCCEEDED ( ::VariantChangeType ( & varDest, & var, VARIANT_NOVALUEPROP, type ) )
				{
					_App.m_event.PropertySet ( m_Index, ( unsigned char ) V_UI1 ( & varDest ) );
				}
				else
				{
					unsigned char uc = ( unsigned char ) _wtoi ( V_BSTR ( & var ) );
					_App.m_event.PropertySet ( m_Index, uc );
				}
			}
			break;

			case CIM_SINT16:
			{
				if SUCCEEDED ( ::VariantChangeType ( & varDest, & var, VARIANT_NOVALUEPROP, type ) )
				{
					_App.m_event.PropertySet ( m_Index, ( signed short ) V_I2 ( & varDest ) );
				}
				else
				{
					hRes = E_INVALIDARG;
				}
			}
			break;

			case CIM_UINT16:
			{
				if SUCCEEDED ( ::VariantChangeType ( & varDest, & var, VARIANT_NOVALUEPROP, type ) )
				{
					_App.m_event.PropertySet ( m_Index, ( unsigned short ) V_UI2 ( & varDest ) );
				}
				else
				{
					unsigned short us = ( unsigned short ) _wtoi ( V_BSTR ( & var ) );
					_App.m_event.PropertySet ( m_Index, us );
				}
			}
			break;

			case CIM_SINT32:
			{
				if SUCCEEDED ( ::VariantChangeType ( & varDest, & var, VARIANT_NOVALUEPROP, type ) )
				{
					_App.m_event.PropertySet ( m_Index, ( signed long ) V_I4 ( & varDest ) );
				}
				else
				{
					hRes = E_INVALIDARG;
				}
			}
			break;

			case CIM_UINT32:
			{
				if SUCCEEDED ( ::VariantChangeType ( & varDest, & var, VARIANT_NOVALUEPROP, type ) )
				{
					_App.m_event.PropertySet ( m_Index, ( unsigned long ) V_UI4 ( & varDest ) );
				}
				else
				{
					unsigned long ul = ( unsigned long ) _wtoi ( V_BSTR ( & var ) );
					_App.m_event.PropertySet ( m_Index, ul );
				}
			}
			break;

			case CIM_REAL32:
			{
				if SUCCEEDED ( ::VariantChangeType ( & varDest, & var, VARIANT_NOVALUEPROP, type ) )
				{
					_App.m_event.PropertySet ( m_Index, ( float ) V_R4 ( & varDest ) );
				}
				else
				{
					hRes = E_INVALIDARG;
				}
			}
			break;

			case CIM_REAL64:
			{
				if SUCCEEDED ( ::VariantChangeType ( & varDest, & var, VARIANT_NOVALUEPROP, type ) )
				{
					_App.m_event.PropertySet ( m_Index, ( double ) V_R8 ( & varDest ) );
				}
				else
				{
					hRes = E_INVALIDARG;
				}
			}
			break;

			case CIM_SINT64:
			{
				_App.m_event.PropertySet ( m_Index, _wtoi64 ( V_BSTR ( & var ) ) );
			}
			break;

			case CIM_UINT64:
			{
				_App.m_event.PropertySet ( m_Index, ( DWORD64 ) _wtoi64 ( V_BSTR ( & var ) ) );
			}
			break;

			case CIM_BOOLEAN:
			{
				if SUCCEEDED ( ::VariantChangeType ( & varDest, & var, VARIANT_NOVALUEPROP, type ) )
				{
					_App.m_event.PropertySet ( m_Index, V_BOOL ( & varDest ) );
				}
				else
				{
					hRes = E_INVALIDARG;
				}
			}
			break;

			case CIM_STRING:
			{
				_App.m_event.PropertySet ( m_Index, ( LPCWSTR ) V_BSTR ( & var ) );
			}
			break;

			case CIM_SINT8 | CIM_FLAG_ARRAY:
			{
				if SUCCEEDED ( __SafeArray::LPWSTRToVariant ( type, V_BSTR ( &var ), &varDest ) )
				{
					signed char*	p	= NULL;
					DWORD			dw	= 0L;

					if SUCCEEDED ( __SafeArray::VariantToCHAR ( &varDest, &p, &dw ) )
					{
						_App.m_event.PropertySet ( m_Index, dw, p );
					}

					if ( p )
					{
						delete [] p;
					}
				}
				else
				{
					hRes = E_INVALIDARG;
				}
			}
			break;

			case CIM_UINT8 | CIM_FLAG_ARRAY:
			{
				if SUCCEEDED ( __SafeArray::LPWSTRToVariant ( type, V_BSTR ( &var ), &varDest ) )
				{
					unsigned char*	p	= NULL;
					DWORD			dw	= 0L;

					if SUCCEEDED ( __SafeArray::VariantToUCHAR ( &varDest, &p, &dw ) )
					{
						_App.m_event.PropertySet ( m_Index, dw, p );
					}

					if ( p )
					{
						delete [] p;
					}
				}
				else
				{
					hRes = E_INVALIDARG;
				}
			}
			break;

			case CIM_SINT16 | CIM_FLAG_ARRAY:
			{
				if SUCCEEDED ( __SafeArray::LPWSTRToVariant ( type, V_BSTR ( &var ), &varDest ) )
				{
					signed short*	p	= NULL;
					DWORD			dw	= 0L;

					if SUCCEEDED ( __SafeArray::VariantToSHORT ( &varDest, &p, &dw ) )
					{
						_App.m_event.PropertySet ( m_Index, dw, p );
					}

					if ( p )
					{
						delete [] p;
					}
				}
				else
				{
					hRes = E_INVALIDARG;
				}
			}
			break;

			case CIM_UINT16 | CIM_FLAG_ARRAY:
			{
				if SUCCEEDED ( __SafeArray::LPWSTRToVariant ( type, V_BSTR ( &var ), &varDest ) )
				{
					unsigned short*	p	= NULL;
					DWORD			dw	= 0L;

					if SUCCEEDED ( __SafeArray::VariantToUSHORT ( &varDest, &p, &dw ) )
					{
						_App.m_event.PropertySet ( m_Index, dw, p );
					}

					if ( p )
					{
						delete [] p;
					}
				}
				else
				{
					hRes = E_INVALIDARG;
				}
			}
			break;

			case CIM_SINT32 | CIM_FLAG_ARRAY:
			{
				if SUCCEEDED ( __SafeArray::LPWSTRToVariant ( type, V_BSTR ( &var ), &varDest ) )
				{
					signed long*	p	= NULL;
					DWORD			dw	= 0L;

					if SUCCEEDED ( __SafeArray::VariantToLONG ( &varDest, &p, &dw ) )
					{
						_App.m_event.PropertySet ( m_Index, dw, p );
					}

					if ( p )
					{
						delete [] p;
					}
				}
				else
				{
					hRes = E_INVALIDARG;
				}
			}
			break;

			case CIM_UINT32 | CIM_FLAG_ARRAY:
			{
				if SUCCEEDED ( __SafeArray::LPWSTRToVariant ( type, V_BSTR ( &var ), &varDest ) )
				{
					unsigned long*	p	= NULL;
					DWORD			dw	= 0L;

					if SUCCEEDED ( __SafeArray::VariantToULONG ( &varDest, &p, &dw ) )
					{
						_App.m_event.PropertySet ( m_Index, dw, p );
					}

					if ( p )
					{
						delete [] p;
					}
				}
				else
				{
					hRes = E_INVALIDARG;
				}
			}
			break;

			case CIM_REAL32 | CIM_FLAG_ARRAY:
			{
				if SUCCEEDED ( __SafeArray::LPWSTRToVariant ( type, V_BSTR ( &var ), &varDest ) )
				{
					float*	p	= NULL;
					DWORD			dw	= 0L;

					if SUCCEEDED ( __SafeArray::VariantToFLOAT ( &varDest, &p, &dw ) )
					{
						_App.m_event.PropertySet ( m_Index, dw, p );
					}

					if ( p )
					{
						delete [] p;
					}
				}
				else
				{
					hRes = E_INVALIDARG;
				}
			}
			break;

			case CIM_REAL64 | CIM_FLAG_ARRAY:
			{
				if SUCCEEDED ( __SafeArray::LPWSTRToVariant ( type, V_BSTR ( &var ), &varDest ) )
				{
					double*	p	= NULL;
					DWORD			dw	= 0L;

					if SUCCEEDED ( __SafeArray::VariantToDOUBLE ( &varDest, &p, &dw ) )
					{
						_App.m_event.PropertySet ( m_Index, dw, p );
					}

					if ( p )
					{
						delete [] p;
					}
				}
				else
				{
					hRes = E_INVALIDARG;
				}
			}
			break;

			case CIM_SINT64 | CIM_FLAG_ARRAY:
			{
				if SUCCEEDED ( __SafeArray::LPWSTRToVariant ( type, V_BSTR ( &var ), &varDest ) )
				{
					signed __int64*	p	= NULL;
					DWORD			dw	= 0L;

					if SUCCEEDED ( __SafeArray::VariantToI64 ( &varDest, &p, &dw ) )
					{
						_App.m_event.PropertySet ( m_Index, dw, p );
					}

					if ( p )
					{
						delete [] p;
					}
				}
				else
				{
					hRes = E_INVALIDARG;
				}
			}
			break;

			case CIM_UINT64 | CIM_FLAG_ARRAY:
			{
				if SUCCEEDED ( __SafeArray::LPWSTRToVariant ( type, V_BSTR ( &var ), &varDest ) )
				{
					unsigned __int64*	p	= NULL;
					DWORD				dw	= 0L;

					if SUCCEEDED ( __SafeArray::VariantToUI64 ( &varDest, &p, &dw ) )
					{
						_App.m_event.PropertySet ( m_Index, dw, p );
					}

					if ( p )
					{
						delete [] p;
					}
				}
				else
				{
					hRes = E_INVALIDARG;
				}
			}
			break;

			case CIM_BOOLEAN | CIM_FLAG_ARRAY:
			{
				if SUCCEEDED ( __SafeArray::LPWSTRToVariant ( type, V_BSTR ( &var ), &varDest ) )
				{
					BOOL*	p	= NULL;
					DWORD	dw	= 0L;

					if SUCCEEDED ( __SafeArray::VariantToBOOL ( &varDest, &p, &dw ) )
					{
						_App.m_event.PropertySet ( m_Index, dw, p );
					}

					if ( p )
					{
						delete [] p;
					}
				}
				else
				{
					hRes = E_INVALIDARG;
				}
			}
			break;

			case CIM_STRING | CIM_FLAG_ARRAY:
			{
				if SUCCEEDED ( __SafeArray::LPWSTRToVariant ( type, V_BSTR ( &var ), &varDest ) )
				{
					LPWSTR*	p	= NULL;
					DWORD			dw	= 0L;

					if SUCCEEDED ( __SafeArray::VariantToLPWSTR ( &varDest, &p, &dw ) )
					{
						_App.m_event.PropertySet ( m_Index, dw, (LPCWSTR*) p );
					}

					if ( p )
					{
						for ( DWORD d = 0; d < dw; d++ )
						{
							delete [] p[d];
						}

						delete [] p;
					}
				}
				else
				{
					hRes = E_INVALIDARG;
				}
			}
			break;

			case CIM_CHAR16:
			{
				_App.m_event.PropertySetWCHAR ( m_Index, ( WCHAR ) * V_BSTR ( & var ) );
			}
			break;

			case CIM_CHAR16 | CIM_FLAG_ARRAY:
			{
				_App.m_event.PropertySetWCHAR ( m_Index, ::SysStringLen ( V_BSTR ( & var ) ), ( WCHAR* ) V_BSTR ( & var ) );
			}
			break;

			case CIM_DATETIME:
			{
				_App.m_event.PropertySetDATETIME ( m_Index, ( LPCWSTR ) ( V_BSTR ( & var ) ) );
			}
			break;

			case CIM_DATETIME | CIM_FLAG_ARRAY:
			{
				LPCWSTR array [1] = { NULL };
				array [0] = ( LPCWSTR )( V_BSTR ( & var ) );

				_App.m_event.PropertySetDATETIME ( m_Index, 1, array );
			}
			break;

			case CIM_REFERENCE:
			{
				_App.m_event.PropertySetREFERENCE ( m_Index, ( LPCWSTR ) ( V_BSTR ( & var ) ) );
			}
			break;

			case CIM_REFERENCE | CIM_FLAG_ARRAY:
			{
				LPCWSTR array [1] = { NULL };
				array [0] = ( LPCWSTR )( V_BSTR ( & var ) );

				_App.m_event.PropertySetREFERENCE ( m_Index, 1, array );
			}
			break;

			case CIM_OBJECT:
			{
				_App.m_event.PropertySetOBJECT ( m_Index, ( _App.m_event.m_hEventObject ) );
			}
			break;

			case CIM_OBJECT | CIM_FLAG_ARRAY:
			{
				void* array [1] = { NULL };
				array [0] = ( _App.m_event.m_hEventObject );

				_App.m_event.PropertySetOBJECT ( m_Index, 1, array );
			}
			break;
		}
	}
	catch ( ... )
	{
		return E_FAIL;
	}

	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\noncomevent\worker.cpp ===
#define _WIN32_DCOM	

#include "Precomp.h"
#include "NonCOMEventModule.h"

#include "_App.h"
#include "_Module.h"

extern MyApp _App;

#include "module.h"
#include "worker.h"

// includes

#include "Enumerator.h"

#include "_Connect.h"
#include "_EventObject.h"
#include "_EventObjects.h"

CMyWorkerScalar::CMyWorkerScalar(CModuleScalar *pMod):
    CWorkerScalar(pMod)
{
	DWORD	dwThread= 0L;

	if ( ( m_hThread=CreateThread( 0, 0, CMyWorkerScalar::WorkThread, this, 0, &dwThread ) ) != NULL )
	{
	}

	return;
}

CMyWorkerScalar::~CMyWorkerScalar()
{
	if ( m_hThread )
	{
		::WaitForSingleObject ( m_hThread, INFINITE );

		CloseHandle( m_hThread );
		m_hThread = NULL;
	}
}

CMyWorkerArray::CMyWorkerArray(CModuleArray *pMod):
    CWorkerArray(pMod)
{
	DWORD	dwThread= 0L;

	if ( ( m_hThread=CreateThread( 0, 0, CMyWorkerArray::WorkThread, this, 0, &dwThread ) ) != NULL )
	{
	}

	return;
}

CMyWorkerArray::~CMyWorkerArray()
{
	if ( m_hThread )
	{
		::WaitForSingleObject ( m_hThread, INFINITE );

		CloseHandle( m_hThread );
		m_hThread = NULL;
	}
}

CMyWorkerGeneric::CMyWorkerGeneric(CModuleGeneric *pMod):
    CWorkerGeneric(pMod)
{
	DWORD	dwThread= 0L;

	if ( ( m_hThread=CreateThread( 0, 0, CMyWorkerGeneric::WorkThread, this, 0, &dwThread ) ) != NULL )
	{
	}

	return;
}

CMyWorkerGeneric::~CMyWorkerGeneric()
{
	if ( m_hThread )
	{
		::WaitForSingleObject ( m_hThread, INFINITE );

		CloseHandle( m_hThread );
		m_hThread = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\noncomevent\workergeneric.cpp ===
#define _WIN32_DCOM	

#include "Precomp.h"
#include "NonCOMEventModule.h"

#include "_App.h"
#include "_Module.h"

extern MyApp _App;

#include "module.h"
#include "worker.h"

// includes

#include "Enumerator.h"

#include "_Connect.h"
#include "_EventObject.h"
#include "_EventObjects.h"

// log
#include "_log.h"

DWORD WINAPI CMyWorkerGeneric::WorkThread(void *pVoid)
{
	::CoInitializeEx ( NULL, COINIT_MULTITHREADED );

	if ( _App.m_hUse.GetHANDLE() != NULL )
	{
		DWORD	dwHandles = 2;
		HANDLE	hHandles [] =
		{
			_App.m_hKill,
			_App.m_hUse
		};

		::InterlockedIncrement ( &MyApp::m_lCount );

		if ( ::WaitForMultipleObjects ( dwHandles, hHandles, FALSE, INFINITE ) != WAIT_OBJECT_0 + 1 )
		{
			return ( DWORD ) HRESULT_TO_WIN32 ( E_FAIL );
		}
	}

	// data

	signed char			_c	= -1;
	signed short		_s	= -2;
	signed long			_l	= -3;
	signed __int64		_i	= -123;
	unsigned char		_uc	= 1;
	unsigned short		_us	= 2;
	unsigned long		_ul	= 3;
	unsigned __int64	_ui	= 123;
	float				_f	= (float) 12.34;
	double				_d	= 12.34;

	BOOL				_b	= FALSE;
	LPWSTR				_sz	= L"string 1";
	WCHAR				_wc = L'a';

	DWORD dwSize = 3;

	signed char			c	[3]	= { -1 , -2 , -3 };
	signed short		s	[3]	= { -1 , -2 , -3 };
	signed long			l	[3]	= { -1 , -2 , -3 };
	signed __int64		i	[3]	= { -1 , -2 , -3 };
	unsigned char		uc	[3]	= { 1 , 2 , 3 };
	unsigned short		us	[3]	= { 1 , 2 , 3 };
	unsigned long		ul	[3]	= { 1 , 2 , 3 };
	unsigned __int64	ui	[3]	= { 1 , 2 , 3 };
	float				f	[3]	= { (float) 12.34 , (float) 34.56 , (float) 56.78 };
	double				d	[3]	= { 12.34 , 34.56 , 56.78 };
	BOOL				b	[3]	= { FALSE, TRUE, FALSE };
	LPWSTR				sz	[3]	= { L"string 1" , L"string 2" , L"string 3" };
	WCHAR				wc	[3]	= { L'a', L'b', L'c' };

	CMyWorkerGeneric *		pThis		= ( CMyWorkerGeneric * ) pVoid;

	MyLog					log ( pThis->m_pNotify );
	MyConnect*				pConnect	= NULL;
	HRESULT hr							= S_OK;

	//one way for a module to work--run until stopped by user 
    //=======================================================

	#ifdef	__DEBUG_STRESS
	DebugBreak();
	#endif	__DEBUG_STRESS

	do
	{
		////////////////////////////////////////////////////////////////////////
		// variables
		////////////////////////////////////////////////////////////////////////
		WCHAR	szTokens[]	= L"-/";

		////////////////////////////////////////////////////////////////////////
		// command line
		////////////////////////////////////////////////////////////////////////
		LPWSTR lpCmdLine = pThis->m_wszParams;

		////////////////////////////////////////////////////////////////////////
		// find behaviour
		////////////////////////////////////////////////////////////////////////
		LPCWSTR lpszToken = MyApp::FindOneOf(lpCmdLine, szTokens);

		try
		{
			while (lpszToken != NULL)
			{
				LPCWSTR newToken = NULL;
				newToken = MyApp::FindOneOf(lpszToken, szTokens);

				DWORD	dwAction	= 0L;
				BOOL	bCharacter	= TRUE;

				if ( newToken )
				{
					LPWSTR helper = NULL;

					try
					{
						if ( ( helper = new WCHAR [ newToken - lpszToken ] ) != NULL )
						{
							memcpy ( helper, lpszToken, sizeof ( WCHAR ) * ( newToken - lpszToken - 1 ) );
							helper [ newToken - lpszToken - 1 ] = L'\0';

							if ( !HasCharacter ( helper ) )
							{
								dwAction = _wtoi ( helper );
								bCharacter = FALSE;
							}

							delete [] helper;
							helper = NULL;
						}
					}
					catch ( ... )
					{
					}

					if ( bCharacter )
					{
						lpszToken	= newToken;
						continue;
					}
				}
				else
				{
					if ( !HasCharacter ( lpszToken ) )
					{
						dwAction = _wtoi ( lpszToken );
						bCharacter = FALSE;
					}

					break;
				}

				// get connect to event object
				pConnect = MyConnect::ConnectGet();

				MyEventObjectGeneric		event;
				event.Init ( L"MSFT_WMI_GenericNonCOMEvent" );

				#ifdef	__SUPPORT_WAIT
				Sleep ( 1000 );
				#endif	__SUPPORT_WAIT

				switch ( dwAction )
				{
					case 1:
					{
						try
						{
							hr = event.EventReport1 ( ( HANDLE ) (* pConnect ), 
														_c	,
														_uc	,
														_s	,
														_us	,
														_l	,
														_ul	,
														_i	,
														_ui	,
														_f	,
														_d	,
														_b	,
														_sz	,
														_wc ,
														NULL
								);

							log.Log (	L"WmiReportEvent Generic SCALAR DATA",
										hr,
										1,
										L"report event "
									);
						}
						catch ( ... )
						{
							hr = E_UNEXPECTED;
						}
					}
					break;

					case 2:
					{
						try
						{
							hr = event.EventReport2 ( ( HANDLE ) (* pConnect ), 
														dwSize,
														c	,
														uc	,
														s	,
														us	,
														l	,
														ul	,
														i	,
														ui	,
														f	,
														d	,
														b	,
														sz	,
														wc	,
														NULL
								);

							log.Log (	L"WmiReportEvent Generic ARRAY DATA",
										hr,
										1,
										L"report event "
									);
						}
						catch ( ... )
						{
							hr = E_UNEXPECTED;
						}
					}
					break;

					default:
					case 3:
					{
						while(!pThis->IsStopped())
						{
							//execute test here
							//=================

							try
							{
								hr = event.EventReport1 ( ( HANDLE ) (* pConnect ), 
															_c	,
															_uc	,
															_s	,
															_us	,
															_l	,
															_ul	,
															_i	,
															_ui	,
															_f	,
															_d	,
															_b	,
															_sz	,
															_wc ,
															NULL
									);

								log.Log (	L"WmiReportEvent Generic SCALAR DATA",
											hr,
											1,
											L"report event "
										);

								hr = event.EventReport2 ( ( HANDLE ) (* pConnect ), 
															dwSize,
															c	,
															uc	,
															s	,
															us	,
															l	,
															ul	,
															i	,
															ui	,
															f	,
															d	,
															b	,
															sz	,
															wc	,
															NULL
									);

								log.Log (	L"WmiReportEvent Generic ARRAY DATA",
											hr,
											1,
											L"report event "
										);
							}
							catch ( ... )
							{
								hr = E_UNEXPECTED;
							}

							Sleep ( 500 );

							//check for pause condition after each test
							//=========================================
							while(pThis->IsPaused() && !pThis->IsStopped())
							{
								Sleep(1000);
							}
						}
					}
					break;
				}

				lpszToken	= newToken;
				hr			= S_OK;
			}
		}
		catch ( ... )
		{
			log.Log (	L"CATASTROPHIC FAILURE ... exception was catched",
						E_UNEXPECTED,
						1,
						L"GENERIC TESTING"
					);
		}

		if ( _App.m_hUse.GetHANDLE() != NULL )
		{
			::ReleaseSemaphore ( _App.m_hUse, 1, NULL );
			::InterlockedDecrement ( &MyApp::m_lCount );
		}
	}
	while ( ::InterlockedCompareExchange ( &MyApp::m_lCount, MyApp::m_lCount, 0 ) != 0 );

	// destroy connect
	pConnect->ConnectClear();

	delete pThis;
	::CoUninitialize ( );

	return HRESULT_TO_WIN32 ( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\noncomevent\workerarray.cpp ===
#define _WIN32_DCOM	

#include "Precomp.h"
#include "NonCOMEventModule.h"

#include "_App.h"
#include "_Module.h"

extern MyApp _App;

#include "module.h"
#include "worker.h"

// includes

#include "Enumerator.h"

#include "_Connect.h"
#include "_EventObject.h"
#include "_EventObjects.h"

// log
#include "_log.h"

// test
#include "_test.h"

DWORD WINAPI CMyWorkerArray::WorkThread(void *pVoid)
{
	::CoInitializeEx ( NULL, COINIT_MULTITHREADED );

	if ( _App.m_hUse.GetHANDLE() != NULL )
	{
		DWORD	dwHandles = 2;
		HANDLE	hHandles [] =
		{
			_App.m_hKill,
			_App.m_hUse
		};

		::InterlockedIncrement ( &MyApp::m_lCount );

		if ( ::WaitForMultipleObjects ( dwHandles, hHandles, FALSE, INFINITE ) != WAIT_OBJECT_0 + 1 )
		{
			return ( DWORD ) HRESULT_TO_WIN32 ( E_FAIL );
		}
	}

	CMyWorkerArray *		pThis		= ( CMyWorkerArray * ) pVoid;

	// data

	DWORD dwSize = 3;

	BOOL				b	[3]	= { FALSE, TRUE, FALSE };
	WCHAR				wc	[3]	= { 'a' , 'b' , 'c' };
	LPWSTR				d	[3]	= { NULL };
	void*				o	[3]	= { NULL };
	float				f	[3]	= { (float) 12.34 , (float) 34.56 , (float) 56.78 };
	double				g	[3]	= { 12.34 , 34.56 , 56.78 };
	LPWSTR				r	[3]	= { NULL };
	signed short		s	[3]	= { -1 , -2 , -3 };
	signed long			l	[3]	= { -1 , -2 , -3 };
	signed __int64		i	[3]	= { -1 , -2 , -3 };
	signed char			c	[3]	= { -1 , -2 , -3 };
	LPWSTR				sz	[3]	= { L"string 1" , L"string 2" , L"string 3" };
	unsigned short		us	[3]	= { 1 , 2 , 3 };
	unsigned long		ul	[3]	= { 1 , 2 , 3 };
	unsigned __int64	ui	[3]	= { 1 , 2 , 3 };
	unsigned char		uc	[3]	= { 1 , 2 , 3 };

	r [0] = L"Win32_Processor.DeviceID=\"CPU0\"";
	r [1] = L"Win32_Processor.DeviceID=\"CPU0\"";
	r [2] = L"Win32_Processor.DeviceID=\"CPU0\"";

	MyLog					log ( pThis->m_pNotify );
	MyConnect*				pConnect	= NULL;
	HRESULT hr							= S_OK;

	//one way for a module to work--run until stopped by user 
    //=======================================================

	#ifdef	__DEBUG_STRESS
	DebugBreak();
	#endif	__DEBUG_STRESS

	do
	{
		////////////////////////////////////////////////////////////////////////
		// variables
		////////////////////////////////////////////////////////////////////////
		WCHAR	szTokens[]	= L"-/";

		////////////////////////////////////////////////////////////////////////
		// command line
		////////////////////////////////////////////////////////////////////////
		LPWSTR lpCmdLine = pThis->m_wszParams;

		////////////////////////////////////////////////////////////////////////
		// find behaviour
		////////////////////////////////////////////////////////////////////////
		LPCWSTR lpszToken = MyApp::FindOneOf(lpCmdLine, szTokens);

		try
		{
			while (lpszToken != NULL)
			{
				LPCWSTR newToken = NULL;
				newToken = MyApp::FindOneOf(lpszToken, szTokens);

				DWORD	dwAction	= 0L;
				BOOL	bCharacter	= TRUE;

				if ( newToken )
				{
					LPWSTR helper = NULL;

					try
					{
						if ( ( helper = new WCHAR [ newToken - lpszToken ] ) != NULL )
						{
							memcpy ( helper, lpszToken, sizeof ( WCHAR ) * ( newToken - lpszToken - 1 ) );
							helper [ newToken - lpszToken - 1 ] = L'\0';

							if ( !HasCharacter ( helper ) )
							{
								dwAction = _wtoi ( helper );
								bCharacter = FALSE;
							}

							delete [] helper;
							helper = NULL;
						}
					}
					catch ( ... )
					{
					}

					if ( bCharacter )
					{
						lpszToken	= newToken;
						continue;
					}
				}
				else
				{
					if ( !HasCharacter ( lpszToken ) )
					{
						dwAction = _wtoi ( lpszToken );
						bCharacter = FALSE;
					}

					break;
				}

				SYSTEMTIME st;
				GetLocalTime ( &st );

				WCHAR time [ _MAX_PATH ] = { L'\0' };
				wsprintf ( time, L"%04d%02d%02d%02d%02d%02d.**********",
										st.wYear,
										st.wMonth,
										st.wDay,
										st.wHour,
										st.wMinute,
										st.wSecond
						 );

				// get connect to event object
				pConnect = MyConnect::ConnectGet();

				MyEventObjectNormal		event;

				// connect to IWbemLocator
				event.ObjectLocator ();

				event.InitObject( L"root\\cimv2", L"NonCOMTest Event Provider" );
				event.Init ( L"MSFT_NonCOMTest_SCALAR_Event" );

				d [0] = time;
				d [1] = time;
				d [2] = time;

				#ifdef	__SUPPORT_WAIT
				Sleep ( 1000 );
				#endif	__SUPPORT_WAIT

				switch ( dwAction )
				{
					default:
					case 0 :
					{
						hr = event.EventReport2 ( ( HANDLE ) (* pConnect ),
													dwSize,
													c	,
													uc	,
													s	,
													us	,
													l	,
													ul	,
													i	,
													ui	,
													f	,
													g	,
													b	,
													sz	,
													wc ,
													event.m_hEventObject
												);

						log.Log (	L"Array type REPORTEVENT",
									hr,
									1,
									L"WmiReportEvent "
								);
					}
					break;

					case 11:
					{
						MyTest test;

						if ( ! test.TestArrayOne ( L"MSFT_NonCOMTest_SINT8_ARRAY_Event", dwSize, c ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type SINT8",
									hr,
									4,
									L"WmiCreateObject ",
									L"WmiCommitObject ",
									L"Property Add ---> Set ",
									L"signed char "
								);
					}
					break;

					case 12:
					{
						MyTest test;

						if ( ! test.TestArrayOne ( L"MSFT_NonCOMTest_UINT8_ARRAY_Event", dwSize, uc ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type UINT8",
									hr,
									4,
									L"WmiCreateObject ",
									L"WmiCommitObject ",
									L"Property Add ---> Set ",
									L"unsigned char "
								);
					}
					break;

					case 13:
					{
						MyTest test;

						if ( ! test.TestArrayOne ( L"MSFT_NonCOMTest_SINT16_ARRAY_Event", dwSize, s ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type  SINT16",
									hr,
									4,
									L"WmiCreateObject ",
									L"WmiCommitObject ",
									L"Property Add ---> Set ",
									L"signed short "
								);
					}
					break;

					case 14:
					{
						MyTest test;

						if ( ! test.TestArrayOne ( L"MSFT_NonCOMTest_UINT16_ARRAY_Event", _uint16, dwSize, us ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type UINT16",
									hr,
									4,
									L"WmiCreateObject ",
									L"WmiCommitObject ",
									L"Property Add ---> Set ",
									L"unsigned short "
								);
					}
					break;

					case 15:
					{
						MyTest test;

						if ( ! test.TestArrayOne ( L"MSFT_NonCOMTest_SINT32_ARRAY_Event", dwSize, l ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type SINT32",
									hr,
									4,
									L"WmiCreateObject ",
									L"WmiCommitObject ",
									L"Property Add ---> Set ",
									L"signed long "
								);
					}
					break;

					case 16:
					{
						MyTest test;

						if ( ! test.TestArrayOne ( L"MSFT_NonCOMTest_UINT32_ARRAY_Event", dwSize, ul ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type UINT32",
									hr,
									4,
									L"WmiCreateObject ",
									L"WmiCommitObject ",
									L"Property Add ---> Set ",
									L"unsigned long "
								);
					}
					break;

					case 17:
					{
						MyTest test;

						if ( ! test.TestArrayOne ( L"MSFT_NonCOMTest_SINT64_ARRAY_Event", dwSize, i ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type SINT64",
									hr,
									4,
									L"WmiCreateObject ",
									L"WmiCommitObject ",
									L"Property Add ---> Set ",
									L"signed __int64 "
								);
					}
					break;

					case 18:
					{
						MyTest test;

						if ( ! test.TestArrayOne ( L"MSFT_NonCOMTest_UINT64_ARRAY_Event", dwSize, ui ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type UINT64",
									hr,
									4,
									L"WmiCreateObject ",
									L"WmiCommitObject ",
									L"Property Add ---> Set ",
									L"unsigned __int64 "
								);
					}
					break;

					case 19:
					{
						MyTest test;

						if ( ! test.TestArrayOne ( L"MSFT_NonCOMTest_REAL32_ARRAY_Event", dwSize, f ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type REAL32",
									hr,
									4,
									L"WmiCreateObject ",
									L"WmiCommitObject ",
									L"Property Add ---> Set ",
									L"float "
								);
					}
					break;

					case 110:
					{
						MyTest test;

						if ( ! test.TestArrayOne ( L"MSFT_NonCOMTest_REAL64_ARRAY_Event", dwSize, g ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type REAL64",
									hr,
									4,
									L"WmiCreateObject ",
									L"WmiCommitObject ",
									L"Property Add ---> Set ",
									L"double "
								);
					}
					break;

					case 111:
					{
						MyTest test;

						if ( ! test.TestArrayOne ( L"MSFT_NonCOMTest_BOOLEAN_ARRAY_Event", dwSize, b ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type BOOLEAN",
									hr,
									4,
									L"WmiCreateObject ",
									L"WmiCommitObject ",
									L"Property Add ---> Set ",
									L"boolean "
								);
					}
					break;

					case 112:
					{
						MyTest test;

						if ( ! test.TestArrayOne ( L"MSFT_NonCOMTest_STRING_ARRAY_Event", _string, dwSize, ( LPCWSTR* ) sz ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type STRING",
									hr,
									4,
									L"WmiCreateObject ",
									L"WmiCommitObject ",
									L"Property Add ---> Set ",
									L"string "
								);
					}
					break;

					case 113:
					{
						MyTest test;

						if ( ! test.TestArrayOne ( L"MSFT_NonCOMTest_DATETIME_ARRAY_Event", _datetime, dwSize, ( LPCWSTR* ) d ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type DATETIME",
									hr,
									4,
									L"WmiCreateObject ",
									L"WmiCommitObject ",
									L"Property Add ---> Set ",
									L"datetime "
								);
					}
					break;

					case 114:
					{
						MyTest test;

						if ( ! test.TestArrayOne ( L"MSFT_NonCOMTest_REFERENCE_ARRAY_Event", _reference, dwSize, ( LPCWSTR* ) r ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type REFERENCE",
									hr,
									4,
									L"WmiCreateObject ",
									L"WmiCommitObject ",
									L"Property Add ---> Set ",
									L"reference "
								);
					}
					break;

					case 115:
					{
						MyTest test;

						event.CreateObject ( ( HANDLE ) ( * pConnect ) );
						o [0]	= event.m_hEventObject;
						o [1]	= event.m_hEventObject;
						o [2]	= event.m_hEventObject;

						if ( ! test.TestArrayOne ( L"MSFT_NonCOMTest_OBJECT_ARRAY_Event", dwSize, (void**) o ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type OBJECT",
									hr,
									4,
									L"WmiCreateObject ",
									L"WmiCommitObject ",
									L"Property Add ---> Set ",
									L"object "
								);
					}
					break;

					case 116:
					{
						MyTest test;

						if ( ! test.TestArrayOne ( L"MSFT_NonCOMTest_CHAR16_ARRAY_Event", _char16, dwSize, wc ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type CHAR16",
									hr,
									4,
									L"WmiCreateObject ",
									L"WmiCommitObject ",
									L"Property Add ---> Set ",
									L"char16 "
								);
					}
					break;

					case 1:
					{
						hr = event.CreateObject ( ( HANDLE ) ( * pConnect ) );

						// wait till data ready
						Sleep ( 1000 );

						o [0]	= event.m_hEventObject;
						o [1]	= event.m_hEventObject;
						o [2]	= event.m_hEventObject;

						if SUCCEEDED ( hr )
						{
							BOOL bSuccess = TRUE;

							for ( DWORD dw = 0; dw < 16; dw++ )
							{
								event.PropertyAdd ( dw );
							}

							hr = event.PropertySet ( 0, dwSize,  b );

							log.Log (	L"Array type BOOLEAN",
										hr,
										4,
										L"WmiCreateObject ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"boolean "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySetWCHAR ( 1, dwSize, wc );

							log.Log (	L"Array type CHAR16",
										hr,
										4,
										L"WmiCreateObject ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"char16 "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySetDATETIME ( 2, dwSize, ( LPCWSTR* ) d );

							log.Log (	L"Array type DATETIME",
										hr,
										4,
										L"WmiCreateObject ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"datetime "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySetOBJECT ( 3, dwSize, ( void** ) o );

							log.Log (	L"Array type OBJECT",
										hr,
										4,
										L"WmiCreateObject ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"object "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 4, dwSize, f );

							log.Log (	L"Array type REAL32",
										hr,
										4,
										L"WmiCreateObject ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"float "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 5, dwSize, g );

							log.Log (	L"Array type REAL64",
										hr,
										4,
										L"WmiCreateObject ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"double "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySetREFERENCE ( 6, dwSize, ( LPCWSTR* ) r );

							log.Log (	L"Array type REFERENCE",
										hr,
										4,
										L"WmiCreateObject ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"reference "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 7, dwSize, s );

							log.Log (	L"Array type SINT16",
										hr,
										4,
										L"WmiCreateObject ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"signed short "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 8, dwSize, l );

							log.Log (	L"Array type SINT32",
										hr,
										4,
										L"WmiCreateObject ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"signed long "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 9, dwSize, i );

							log.Log (	L"Array type SINT64",
										hr,
										4,
										L"WmiCreateObject ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"signed __int64 "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 10, dwSize, c );

							log.Log (	L"Array type SINT8",
										hr,
										4,
										L"WmiCreateObject ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"signed char "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 11, dwSize, ( LPCWSTR* ) sz );

							log.Log (	L"Array type STRING",
										hr,
										4,
										L"WmiCreateObject ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"string "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 12, dwSize, us );

							log.Log (	L"Array type UINT16",
										hr,
										4,
										L"WmiCreateObject ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"unsigned short "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 13, dwSize, ul );

							log.Log (	L"Array type UINT32",
										hr,
										4,
										L"WmiCreateObject ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"unsigned long "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 14, dwSize, ui );

							log.Log (	L"Array type UINT64",
										hr,
										4,
										L"WmiCreateObject ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"unsigned __int64 "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 15, dwSize, uc );

							log.Log (	L"Array type UINT8",
										hr,
										4,
										L"WmiCreateObject ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"unsigned char "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							if ( bSuccess )
							{
								hr = event.EventCommit ();
								hr = event.EventCommit ();

								log.Log (	L"Array type ALL",
											hr,
											2,
											L"WmiCreateObject ",
											L"WmiCommitObject "
										);

								Sleep ( 3000 );
							}
						}
					}
					break;

					case 21:
					{
						MyTest test;

						if ( ! test.TestArrayTwo ( L"MSFT_NonCOMTest_SINT8_ARRAY_Event", dwSize, c ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type SINT8",
									hr,
									3,
									L"WmiCreateObject ",
									L"WmiSetAndCommitObject ",
									L"signed char "
								);
					}
					break;

					case 22:
					{
						MyTest test;

						if ( ! test.TestArrayTwo ( L"MSFT_NonCOMTest_UINT8_ARRAY_Event", dwSize, uc ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type UINT8",
									hr,
									3,
									L"WmiCreateObject ",
									L"WmiSetAndCommitObject ",
									L"unsigned char "
								);
					}
					break;

					case 23:
					{
						MyTest test;

						if ( ! test.TestArrayTwo ( L"MSFT_NonCOMTest_SINT16_ARRAY_Event", dwSize, s ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type SINT16",
									hr,
									3,
									L"WmiCreateObject ",
									L"WmiSetAndCommitObject ",
									L"signed short "
								);
					}
					break;

					case 24:
					{
						MyTest test;

						if ( ! test.TestArrayTwo ( L"MSFT_NonCOMTest_UINT16_ARRAY_Event", _uint16, dwSize, us ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type UINT16",
									hr,
									3,
									L"WmiCreateObject ",
									L"WmiSetAndCommitObject ",
									L"unsigned short "
								);
					}
					break;

					case 25:
					{
						MyTest test;

						if ( ! test.TestArrayTwo ( L"MSFT_NonCOMTest_SINT32_ARRAY_Event", dwSize, l ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type SINT32",
									hr,
									3,
									L"WmiCreateObject ",
									L"WmiSetAndCommitObject ",
									L"signed long "
								);
					}
					break;

					case 26:
					{
						MyTest test;

						if ( ! test.TestArrayTwo ( L"MSFT_NonCOMTest_UINT32_ARRAY_Event", dwSize, ul ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type UINT32",
									hr,
									3,
									L"WmiCreateObject ",
									L"WmiSetAndCommitObject ",
									L"unsigned long "
								);
					}
					break;

					case 27:
					{
						MyTest test;

						if ( ! test.TestArrayTwo ( L"MSFT_NonCOMTest_SINT64_ARRAY_Event", dwSize, i ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type SINT64",
									hr,
									3,
									L"WmiCreateObject ",
									L"WmiSetAndCommitObject ",
									L"signed __int64 "
								);
					}
					break;

					case 28:
					{
						MyTest test;

						if ( ! test.TestArrayTwo ( L"MSFT_NonCOMTest_UINT64_ARRAY_Event", dwSize, ui ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type UINT64",
									hr,
									3,
									L"WmiCreateObject ",
									L"WmiSetAndCommitObject ",
									L"unsigned __int64 "
								);
					}
					break;

					case 29:
					{
						MyTest test;

						if ( ! test.TestArrayTwo ( L"MSFT_NonCOMTest_REAL32_ARRAY_Event", dwSize, f ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type REAL32",
									hr,
									3,
									L"WmiCreateObject ",
									L"WmiSetAndCommitObject ",
									L"float "
								);
					}
					break;

					case 210:
					{
						MyTest test;

						if ( ! test.TestArrayTwo ( L"MSFT_NonCOMTest_REAL64_ARRAY_Event", dwSize, g ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type REAL64",
									hr,
									3,
									L"WmiCreateObject ",
									L"WmiSetAndCommitObject ",
									L"double "
								);
					}
					break;

					case 211:
					{
						MyTest test;

						if ( ! test.TestArrayTwo ( L"MSFT_NonCOMTest_BOOLEAN_ARRAY_Event", dwSize, b ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type BOOLEAN",
									hr,
									3,
									L"WmiCreateObject ",
									L"WmiSetAndCommitObject ",
									L"boolean "
								);
					}
					break;

					case 212:
					{
						MyTest test;

						if ( ! test.TestArrayTwo ( L"MSFT_NonCOMTest_STRING_ARRAY_Event", _string, dwSize, ( LPCWSTR* ) sz ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type STRING",
									hr,
									3,
									L"WmiCreateObject ",
									L"WmiSetAndCommitObject ",
									L"string "
								);
					}
					break;

					case 213:
					{
						MyTest test;

						if ( ! test.TestArrayTwo ( L"MSFT_NonCOMTest_DATETIME_ARRAY_Event", _datetime, dwSize, ( LPCWSTR* ) d ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type DATETIME",
									hr,
									3,
									L"WmiCreateObject ",
									L"WmiSetAndCommitObject ",
									L"datetime "
								);
					}
					break;

					case 214:
					{
						MyTest test;

						if ( ! test.TestArrayTwo ( L"MSFT_NonCOMTest_REFERENCE_ARRAY_Event", _reference, dwSize, ( LPCWSTR* ) r ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type REFERENCE",
									hr,
									3,
									L"WmiCreateObject ",
									L"WmiSetAndCommitObject ",
									L"reference "
								);
					}
					break;

					case 215:
					{
						MyTest test;

						event.CreateObject ( ( HANDLE ) ( * pConnect ) );
						o [0]	= event.m_hEventObject;
						o [1]	= event.m_hEventObject;
						o [2]	= event.m_hEventObject;

						if ( ! test.TestArrayTwo ( L"MSFT_NonCOMTest_OBJECT_ARRAY_Event", dwSize, (void**) o ) )
						{
							hr = E_FAIL;
						}

					{
						log.Log (	L"Array type OBJECT",
									hr,
									3,
									L"WmiCreateObject ",
									L"WmiSetAndCommitObject ",
									L"object "
								);
					}
					}
					break;

					case 216:
					{
						MyTest test;

						if ( ! test.TestArrayTwo ( L"MSFT_NonCOMTest_CHAR16_ARRAY_Event", _char16, dwSize, wc ) )
						{
							hr = E_FAIL;
						}

					{
						log.Log (	L"Array type CHAR16",
									hr,
									3,
									L"WmiCreateObject ",
									L"WmiSetAndCommitObject ",
									L"char16 "
								);
					}
					}
					break;

					case 2:
					{
						hr = event.CreateObject ( ( HANDLE ) ( * pConnect ) );

						// wait till data ready
						Sleep ( 1000 );

						o [0]	= event.m_hEventObject;
						o [1]	= event.m_hEventObject;
						o [2]	= event.m_hEventObject;

						if SUCCEEDED ( hr )
						{
							for ( DWORD dw = 0; dw < 16; dw++ )
							{
								event.PropertyAdd ( dw );
							}

							WORD *	pb		= NULL;

							try
							{
								if ( ( pb = new WORD [dwSize] ) != NULL )
								{
									for ( DWORD dw = 0; dw < dwSize; dw ++ )
									{
										pb [ dw ] = (WORD) b [ dw ] ;
									}

								}
							}
							catch ( ... )
							{
								if ( pb )
								{
									delete [] pb;
									pb = NULL;
								}
							}

							hr = event.SetCommit (	WMI_SENDCOMMIT_SET_NOT_REQUIRED,
													( WORD*	 )				pb,
													( WCHAR* )				wc,
													( LPWSTR* )				d,
													( void** )				o,
													( float* )				f,
													( double* )				g,
													( LPWSTR* )				r,
													( signed short* )		s,
													( signed long* )		l,
													( signed __int64* )		i,
													( signed char* )		c,
													( LPWSTR* )				sz,
													( unsigned short* )		us,
													( unsigned long* )		ul,
													( unsigned __int64* )	ui,
													( unsigned char* )		uc
												);

							if ( pb )
							{
								delete [] pb;
								pb = NULL;
							}

							log.Log (	L"Array type ALL",
										hr,
										2,
										L"WmiCreateObject ",
										L"WmiSetAndCommitObject "
									);

							Sleep ( 3000 );
						}
					}
					break;

					case 31:
					{
						MyTest test;

						if ( ! test.TestArrayThree ( L"MSFT_NonCOMTest_SINT8_ARRAY_Event", dwSize, c ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type SINT8",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiCommitObject ",
									L"signed char "
								);
					}
					break;

					case 32:
					{
						MyTest test;

						if ( ! test.TestArrayThree ( L"MSFT_NonCOMTest_UINT8_ARRAY_Event", dwSize, uc ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type UINT8",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiCommitObject ",
									L"unsigned char "
								);
					}
					break;

					case 33:
					{
						MyTest test;

						if ( ! test.TestArrayThree ( L"MSFT_NonCOMTest_SINT16_ARRAY_Event", dwSize, s ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type SINT16",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiCommitObject ",
									L"signed short "
								);
					}
					break;

					case 34:
					{
						MyTest test;

						if ( ! test.TestArrayThree ( L"MSFT_NonCOMTest_UINT16_ARRAY_Event", _uint16, dwSize, us ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type UINT16",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiCommitObject ",
									L"unsigned short "
								);
					}
					break;

					case 35:
					{
						MyTest test;

						if ( ! test.TestArrayThree ( L"MSFT_NonCOMTest_SINT32_ARRAY_Event", dwSize, l ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type SINT32",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiCommitObject ",
									L"signed long "
								);
					}
					break;

					case 36:
					{
						MyTest test;

						if ( ! test.TestArrayThree ( L"MSFT_NonCOMTest_UINT32_ARRAY_Event", dwSize, ul ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type UINT32",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiCommitObject ",
									L"unsigned long "
								);
					}
					break;

					case 37:
					{
						MyTest test;

						if ( ! test.TestArrayThree ( L"MSFT_NonCOMTest_SINT64_ARRAY_Event", dwSize, i ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type SINT64",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiCommitObject ",
									L"signed __int64 "
								);
					}
					break;

					case 38:
					{
						MyTest test;

						if ( ! test.TestArrayThree ( L"MSFT_NonCOMTest_UINT64_ARRAY_Event", dwSize, ui ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type UINT64",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiCommitObject ",
									L"unsigned __int64 "
								);
					}
					break;

					case 39:
					{
						MyTest test;

						if ( ! test.TestArrayThree ( L"MSFT_NonCOMTest_REAL32_ARRAY_Event", dwSize, f ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type REAL32",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiCommitObject ",
									L"float "
								);
					}
					break;

					case 310:
					{
						MyTest test;

						if ( ! test.TestArrayThree ( L"MSFT_NonCOMTest_REAL64_ARRAY_Event", dwSize, g ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type REAL64",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiCommitObject ",
									L"double "
								);
					}
					break;

					case 311:
					{
						MyTest test;

						if ( ! test.TestArrayThree ( L"MSFT_NonCOMTest_BOOLEAN_ARRAY_Event", dwSize, b ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type BOOLEAN",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiCommitObject ",
									L"boolean "
								);
					}
					break;

					case 312:
					{
						MyTest test;

						if ( ! test.TestArrayThree ( L"MSFT_NonCOMTest_STRING_ARRAY_Event", _string, dwSize, ( LPCWSTR* ) sz ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type STRING",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiCommitObject ",
									L"string "
								);
					}
					break;

					case 313:
					{
						MyTest test;

						if ( ! test.TestArrayThree ( L"MSFT_NonCOMTest_DATETIME_ARRAY_Event", _datetime, dwSize, ( LPCWSTR* ) d ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type DATETIME",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiCommitObject ",
									L"datetime "
								);
					}
					break;

					case 314:
					{
						MyTest test;

						if ( ! test.TestArrayThree ( L"MSFT_NonCOMTest_REFERENCE_ARRAY_Event", _reference, dwSize, ( LPCWSTR* ) r ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type REFERENCE",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiCommitObject ",
									L"reference "
								);
					}
					break;

					case 315:
					{
						MyTest test;

						event.CreateObject ( ( HANDLE ) ( * pConnect ) );
						o [0]	= event.m_hEventObject;
						o [1]	= event.m_hEventObject;
						o [2]	= event.m_hEventObject;

						if ( ! test.TestArrayThree ( L"MSFT_NonCOMTest_OBJECT_ARRAY_Event", dwSize, (void**) o ) )
						{
							hr = E_FAIL;
						}

					{
						log.Log (	L"Array type OBJECT",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiCommitObject ",
									L"object "
								);
					}
					}
					break;

					case 316:
					{
						MyTest test;

						if ( ! test.TestArrayThree ( L"MSFT_NonCOMTest_CHAR16_ARRAY_Event", _char16, dwSize, wc ) )
						{
							hr = E_FAIL;
						}

					{
						log.Log (	L"Array type CHAR16",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiCommitObject ",
									L"char16 "
								);
					}
					}
					break;

					case 3:
					{
						hr = event.CreateObjectFormat ( ( HANDLE ) ( * pConnect ) );

						// wait till data ready
						Sleep ( 1000 );

						o [0]	= event.m_hEventObject;
						o [1]	= event.m_hEventObject;
						o [2]	= event.m_hEventObject;

						if SUCCEEDED ( hr )
						{
							BOOL bSuccess = TRUE;

							hr = event.PropertySet ( 0, dwSize,  b );

							log.Log (	L"Array type BOOLEAN",
										hr,
										4,
										L"WmiCreateObjectFormat ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"boolean "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySetWCHAR ( 1, dwSize, wc );

							log.Log (	L"Array type CHAR16",
										hr,
										4,
										L"WmiCreateObjectFormat ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"char16 "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySetDATETIME ( 2, dwSize, ( LPCWSTR* ) d );

							log.Log (	L"Array type DATETIME",
										hr,
										4,
										L"WmiCreateObjectFormat ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"datetime "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySetOBJECT ( 3, dwSize, ( void** ) o );

							log.Log (	L"Array type OBJECT",
										hr,
										4,
										L"WmiCreateObjectFormat ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"object "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 4, dwSize, f );

							log.Log (	L"Array type REAL32",
										hr,
										4,
										L"WmiCreateObjectFormat ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"float "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 5, dwSize, g );

							log.Log (	L"Array type REAL64",
										hr,
										4,
										L"WmiCreateObjectFormat ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"double "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySetREFERENCE ( 6, dwSize, ( LPCWSTR* ) r );

							log.Log (	L"Array type REFERENCE",
										hr,
										4,
										L"WmiCreateObjectFormat ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"reference "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 7, dwSize, s );

							log.Log (	L"Array type SINT16",
										hr,
										4,
										L"WmiCreateObjectFormat ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"signed short "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 8, dwSize, l );

							log.Log (	L"Array type SINT32",
										hr,
										4,
										L"WmiCreateObjectFormat ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"signed long "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 9, dwSize, i );

							log.Log (	L"Array type SINT64",
										hr,
										4,
										L"WmiCreateObjectFormat ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"signed __int64 "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 10, dwSize, c );

							log.Log (	L"Array type SINT8",
										hr,
										4,
										L"WmiCreateObjectFormat ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"signed char "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 11, dwSize, ( LPCWSTR* ) sz );

							log.Log (	L"Array type STRING",
										hr,
										4,
										L"WmiCreateObjectFormat ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"string "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 12, dwSize, us );

							log.Log (	L"Array type UINT16",
										hr,
										4,
										L"WmiCreateObjectFormat ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"unsigned short "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 13, dwSize, ul );

							log.Log (	L"Array type UINT32",
										hr,
										4,
										L"WmiCreateObjectFormat ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"unsigned long "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 14, dwSize, ui );

							log.Log (	L"Array type UINT64",
										hr,
										4,
										L"WmiCreateObjectFormat ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"unsigned __int64 "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 15, dwSize, uc );

							log.Log (	L"Array type UINT8",
										hr,
										4,
										L"WmiCreateObjectFormat ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"unsigned char "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							if ( bSuccess )
							{
								hr = event.EventCommit ();

								log.Log (	L"Array type ALL",
											hr,
											2,
											L"WmiCreateObjectFormat ",
											L"WmiCommitObject "
										);

								Sleep ( 3000 );
							}
						}
					}
					break;

					case 41:
					{
						MyTest test;

						if ( ! test.TestArrayFour ( L"MSFT_NonCOMTest_SINT8_ARRAY_Event", dwSize, c ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type SINT8",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiSetAndCommitObject ",
									L"signed char "
								);
					}
					break;

					case 42:
					{
						MyTest test;

						if ( ! test.TestArrayFour ( L"MSFT_NonCOMTest_UINT8_ARRAY_Event", dwSize, uc ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type UINT8",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiSetAndCommitObject ",
									L"unsigned char "
								);
					}
					break;

					case 43:
					{
						MyTest test;

						if ( ! test.TestArrayFour ( L"MSFT_NonCOMTest_SINT16_ARRAY_Event", dwSize, s ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type SINT16",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiSetAndCommitObject ",
									L"signed short "
								);
					}
					break;

					case 44:
					{
						MyTest test;

						if ( ! test.TestArrayFour ( L"MSFT_NonCOMTest_UINT16_ARRAY_Event", _uint16, dwSize, us ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type UINT16",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiSetAndCommitObject ",
									L"unsigned short "
								);
					}
					break;

					case 45:
					{
						MyTest test;

						if ( ! test.TestArrayFour ( L"MSFT_NonCOMTest_SINT32_ARRAY_Event", dwSize, l ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type SINT32",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiSetAndCommitObject ",
									L"signed long "
								);
					}
					break;

					case 46:
					{
						MyTest test;

						if ( ! test.TestArrayFour ( L"MSFT_NonCOMTest_UINT32_ARRAY_Event", dwSize, ul ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type UINT32",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiSetAndCommitObject ",
									L"unsigned long "
								);
					}
					break;

					case 47:
					{
						MyTest test;

						if ( ! test.TestArrayFour ( L"MSFT_NonCOMTest_SINT64_ARRAY_Event", dwSize, i ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type SINT64",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiSetAndCommitObject ",
									L"signed __int64 "
								);
					}
					break;

					case 48:
					{
						MyTest test;

						if ( ! test.TestArrayFour ( L"MSFT_NonCOMTest_UINT64_ARRAY_Event", dwSize, ui ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type UINT64",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiSetAndCommitObject ",
									L"unsigned __int64 "
								);
					}
					break;

					case 49:
					{
						MyTest test;

						if ( ! test.TestArrayFour ( L"MSFT_NonCOMTest_REAL32_ARRAY_Event", dwSize, f ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type REAL32",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiSetAndCommitObject ",
									L"float "
								);
					}
					break;

					case 410:
					{
						MyTest test;

						if ( ! test.TestArrayFour ( L"MSFT_NonCOMTest_REAL64_ARRAY_Event", dwSize, g ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type REAL64",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiSetAndCommitObject ",
									L"double "
								);
					}
					break;

					case 411:
					{
						MyTest test;

						if ( ! test.TestArrayFour ( L"MSFT_NonCOMTest_BOOLEAN_ARRAY_Event", dwSize, b ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type BOOLEAN",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiSetAndCommitObject ",
									L"boolean "
								);
					}
					break;

					case 412:
					{
						MyTest test;

						if ( ! test.TestArrayFour ( L"MSFT_NonCOMTest_STRING_ARRAY_Event", _string, dwSize, ( LPCWSTR* ) sz ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type STRING",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiSetAndCommitObject ",
									L"string "
								);
					}
					break;

					case 413:
					{
						MyTest test;

						if ( ! test.TestArrayFour ( L"MSFT_NonCOMTest_DATETIME_ARRAY_Event", _datetime, dwSize, ( LPCWSTR* ) d ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type DATETIME",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiSetAndCommitObject ",
									L"datetime "
								);
					}
					break;

					case 414:
					{
						MyTest test;

						if ( ! test.TestArrayFour ( L"MSFT_NonCOMTest_REFERENCE_ARRAY_Event", _reference, dwSize, ( LPCWSTR* ) r ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type REFERENCE",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiSetAndCommitObject ",
									L"reference "
								);
					}
					break;

					case 415:
					{
						MyTest test;

						event.CreateObject ( ( HANDLE ) ( * pConnect ) );
						o [0]	= event.m_hEventObject;
						o [1]	= event.m_hEventObject;
						o [2]	= event.m_hEventObject;

						if ( ! test.TestArrayFour ( L"MSFT_NonCOMTest_OBJECT_ARRAY_Event", dwSize, (void**) o ) )
						{
							hr = E_FAIL;
						}

					{
						log.Log (	L"Array type OBJECT",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiSetAndCommitObject ",
									L"object "
								);
					}
					}
					break;

					case 416:
					{
						MyTest test;

						if ( ! test.TestArrayFour ( L"MSFT_NonCOMTest_CHAR16_ARRAY_Event", _char16, dwSize, wc ) )
						{
							hr = E_FAIL;
						}

					{
						log.Log (	L"Array type CHAR16",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiSetAndCommitObject ",
									L"char16 "
								);
					}
					}
					break;

					case 4:
					{
						hr = event.CreateObjectFormat ( ( HANDLE ) ( * pConnect ) );

						// wait till data ready
						Sleep ( 1000 );

						o [0]	= event.m_hEventObject;
						o [1]	= event.m_hEventObject;
						o [2]	= event.m_hEventObject;

						if SUCCEEDED ( hr )
						{
							WORD *	pb		= NULL;

							try
							{
								if ( ( pb = new WORD [dwSize] ) != NULL )
								{
									for ( DWORD dw = 0; dw < dwSize; dw ++ )
									{
										pb [ dw ] = (WORD) b [ dw ] ;
									}

								}
							}
							catch ( ... )
							{
								if ( pb )
								{
									delete [] pb;
									pb = NULL;
								}
							}

							hr = event.SetCommit (	WMI_SENDCOMMIT_SET_NOT_REQUIRED,
													( WORD*	 )				pb,
													( WCHAR* )				wc,
													( LPWSTR* )				d,
													( void** )				o,
													( float* )				f,
													( double* )				g,
													( LPWSTR* )				r,
													( signed short* )		s,
													( signed long* )		l,
													( signed __int64* )		i,
													( signed char* )		c,
													( LPWSTR* )				sz,
													( unsigned short* )		us,
													( unsigned long* )		ul,
													( unsigned __int64* )	ui,
													( unsigned char* )		uc
												);

							if ( pb )
							{
								delete [] pb;
								pb = NULL;
							}

							log.Log (	L"Array type ALL",
										hr,
										2,
										L"WmiCreateObjectFormat ",
										L"WmiSetAndCommitObject "
									);

							Sleep ( 3000 );
						}
					}
					break;

					case 51:
					{
						MyTest test;

						if ( ! test.TestArrayFive ( L"MSFT_NonCOMTest_SINT8_ARRAY_Event", dwSize, c ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type SINT8",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiCommitObject ",
									L"signed char "
								);
					}
					break;

					case 52:
					{
						MyTest test;

						if ( ! test.TestArrayFive ( L"MSFT_NonCOMTest_UINT8_ARRAY_Event", dwSize, uc ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type UINT8",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiCommitObject ",
									L"unsigned char "
								);
					}
					break;

					case 53:
					{
						MyTest test;

						if ( ! test.TestArrayFive ( L"MSFT_NonCOMTest_SINT16_ARRAY_Event", dwSize, s ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type SINT16",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiCommitObject ",
									L"signed short "
								);
					}
					break;

					case 54:
					{
						MyTest test;

						if ( ! test.TestArrayFive ( L"MSFT_NonCOMTest_UINT16_ARRAY_Event", _uint16, dwSize, us ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type UINT16",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiCommitObject ",
									L"unsigned short "
								);
					}
					break;

					case 55:
					{
						MyTest test;

						if ( ! test.TestArrayFive ( L"MSFT_NonCOMTest_SINT32_ARRAY_Event", dwSize, l ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type SINT32",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiCommitObject ",
									L"signed long "
								);
					}
					break;

					case 56:
					{
						MyTest test;

						if ( ! test.TestArrayFive ( L"MSFT_NonCOMTest_UINT32_ARRAY_Event", dwSize, ul ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type UINT32",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiCommitObject ",
									L"unsigned long "
								);
					}
					break;

					case 57:
					{
						MyTest test;

						if ( ! test.TestArrayFive ( L"MSFT_NonCOMTest_SINT64_ARRAY_Event", dwSize, i ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type SINT64",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiCommitObject ",
									L"signed __int64 "
								);
					}
					break;

					case 58:
					{
						MyTest test;

						if ( ! test.TestArrayFive ( L"MSFT_NonCOMTest_UINT64_ARRAY_Event", dwSize, ui ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type UINT64",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiCommitObject ",
									L"unsigned __int64 "
								);
					}
					break;

					case 59:
					{
						MyTest test;

						if ( ! test.TestArrayFive ( L"MSFT_NonCOMTest_REAL32_ARRAY_Event", dwSize, f ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type REAL32",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiCommitObject ",
									L"float "
								);
					}
					break;

					case 510:
					{
						MyTest test;

						if ( ! test.TestArrayFive ( L"MSFT_NonCOMTest_REAL64_ARRAY_Event", dwSize, g ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type REAL64",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiCommitObject ",
									L"double "
								);
					}
					break;

					case 511:
					{
						MyTest test;

						if ( ! test.TestArrayFive ( L"MSFT_NonCOMTest_BOOLEAN_ARRAY_Event", dwSize, b ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type BOOLEAN",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiCommitObject ",
									L"boolean "
								);
					}
					break;

					case 512:
					{
						MyTest test;

						if ( ! test.TestArrayFive ( L"MSFT_NonCOMTest_STRING_ARRAY_Event", _string, dwSize, ( LPCWSTR* ) sz ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type STRING",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiCommitObject ",
									L"string "
								);
					}
					break;

					case 513:
					{
						MyTest test;

						if ( ! test.TestArrayFive ( L"MSFT_NonCOMTest_DATETIME_ARRAY_Event", _datetime, dwSize, ( LPCWSTR* ) d ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type DATETIME",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiCommitObject ",
									L"datetime "
								);
					}
					break;

					case 514:
					{
						MyTest test;

						if ( ! test.TestArrayFive ( L"MSFT_NonCOMTest_REFERENCE_ARRAY_Event", _reference, dwSize, ( LPCWSTR* ) r ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type REFERENCE",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiCommitObject ",
									L"reference "
								);
					}
					break;

					case 515:
					{
						MyTest test;

						event.CreateObject ( ( HANDLE ) ( * pConnect ) );
						o [0]	= event.m_hEventObject;
						o [1]	= event.m_hEventObject;
						o [2]	= event.m_hEventObject;

						if ( ! test.TestArrayFive ( L"MSFT_NonCOMTest_OBJECT_ARRAY_Event", dwSize, (void**) o ) )
						{
							hr = E_FAIL;
						}

					{
						log.Log (	L"Array type OBJECT",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiCommitObject ",
									L"object "
								);
					}
					}
					break;

					case 516:
					{
						MyTest test;

						if ( ! test.TestArrayFive ( L"MSFT_NonCOMTest_CHAR16_ARRAY_Event", _char16, dwSize, wc ) )
						{
							hr = E_FAIL;
						}

					{
						log.Log (	L"Array type CHAR16",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiCommitObject ",
									L"char16 "
								);
					}
					}
					break;

					case 5:
					{
						hr = event.CreateObjectProps ( ( HANDLE ) ( * pConnect ) );

						// wait till data ready
						Sleep ( 1000 );

						o [0]	= event.m_hEventObject;
						o [1]	= event.m_hEventObject;
						o [2]	= event.m_hEventObject;

						if SUCCEEDED ( hr )
						{
							BOOL bSuccess = TRUE;

							hr = event.PropertySet ( 0, dwSize,  b );

							log.Log (	L"Array type BOOLEAN",
										hr,
										4,
										L"WmiCreateObjectProps ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"boolean "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySetWCHAR ( 1, dwSize, wc );

							log.Log (	L"Array type CHAR16",
										hr,
										4,
										L"WmiCreateObjectProps ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"char16 "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySetDATETIME ( 2, dwSize, ( LPCWSTR* ) d );

							log.Log (	L"Array type DATETIME",
										hr,
										4,
										L"WmiCreateObjectProps ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"datetime "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySetOBJECT ( 3, dwSize, ( void** ) o );

							log.Log (	L"Array type OBJECT",
										hr,
										4,
										L"WmiCreateObjectProps ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"object "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 4, dwSize, f );

							log.Log (	L"Array type REAL32",
										hr,
										4,
										L"WmiCreateObjectProps ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"float "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 5, dwSize, g );

							log.Log (	L"Array type REAL64",
										hr,
										4,
										L"WmiCreateObjectProps ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"double "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySetREFERENCE ( 6, dwSize, ( LPCWSTR* ) r );

							log.Log (	L"Array type REFERENCE",
										hr,
										4,
										L"WmiCreateObjectProps ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"reference "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 7, dwSize, s );

							log.Log (	L"Array type SINT16",
										hr,
										4,
										L"WmiCreateObjectProps ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"signed short "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 8, dwSize, l );

							log.Log (	L"Array type SINT32",
										hr,
										4,
										L"WmiCreateObjectProps ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"signed long "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 9, dwSize, i );

							log.Log (	L"Array type SINT64",
										hr,
										4,
										L"WmiCreateObjectProps ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"signed __int64 "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 10, dwSize, c );

							log.Log (	L"Array type SINT8",
										hr,
										4,
										L"WmiCreateObjectProps ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"signed char "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 11, dwSize, ( LPCWSTR* ) sz );

							log.Log (	L"Array type STRING",
										hr,
										4,
										L"WmiCreateObjectProps ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"string "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 12, dwSize, us );

							log.Log (	L"Array type UINT16",
										hr,
										4,
										L"WmiCreateObjectProps ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"unsigned short "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 13, dwSize, ul );

							log.Log (	L"Array type UINT32",
										hr,
										4,
										L"WmiCreateObjectProps ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"unsigned long "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 14, dwSize, ui );

							log.Log (	L"Array type UINT64",
										hr,
										4,
										L"WmiCreateObjectProps ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"unsigned __int64 "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 15, dwSize, uc );

							log.Log (	L"Array type UINT8",
										hr,
										4,
										L"WmiCreateObjectProps ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"unsigned char "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							if ( bSuccess )
							{
								hr = event.EventCommit ();

								log.Log (	L"Array type ALL",
											hr,
											2,
											L"WmiCreateObjectProps ",
											L"WmiCommitObject "
										);

								Sleep ( 3000 );
							}
						}
					}
					break;

					case 61:
					{
						MyTest test;

						if ( ! test.TestArraySix ( L"MSFT_NonCOMTest_SINT8_ARRAY_Event", dwSize, c ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type SINT8",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiSetAndCommitObject ",
									L"signed char "
								);
					}
					break;

					case 62:
					{
						MyTest test;

						if ( ! test.TestArraySix ( L"MSFT_NonCOMTest_UINT8_ARRAY_Event", dwSize, uc ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type UINT8",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiSetAndCommitObject ",
									L"unsigned char "
								);
					}
					break;

					case 63:
					{
						MyTest test;

						if ( ! test.TestArraySix ( L"MSFT_NonCOMTest_SINT16_ARRAY_Event", dwSize, s ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type SINT16",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiSetAndCommitObject ",
									L"signed short "
								);
					}
					break;

					case 64:
					{
						MyTest test;

						if ( ! test.TestArraySix ( L"MSFT_NonCOMTest_UINT16_ARRAY_Event", _uint16, dwSize, us ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type UINT16",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiSetAndCommitObject ",
									L"unsigned short "
								);
					}
					break;

					case 65:
					{
						MyTest test;

						if ( ! test.TestArraySix ( L"MSFT_NonCOMTest_SINT32_ARRAY_Event", dwSize, l ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type SINT32",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiSetAndCommitObject ",
									L"signed long "
								);
					}
					break;

					case 66:
					{
						MyTest test;

						if ( ! test.TestArraySix ( L"MSFT_NonCOMTest_UINT32_ARRAY_Event", dwSize, ul ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type UINT32",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiSetAndCommitObject ",
									L"unsigned long "
								);
					}
					break;

					case 67:
					{
						MyTest test;

						if ( ! test.TestArraySix ( L"MSFT_NonCOMTest_SINT64_ARRAY_Event", dwSize, i ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type SINT64",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiSetAndCommitObject ",
									L"signed __int64 "
								);
					}
					break;

					case 68:
					{
						MyTest test;

						if ( ! test.TestArraySix ( L"MSFT_NonCOMTest_UINT64_ARRAY_Event", dwSize, ui ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type UINT64",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiSetAndCommitObject ",
									L"unsigned __int64 "
								);
					}
					break;

					case 69:
					{
						MyTest test;

						if ( ! test.TestArraySix ( L"MSFT_NonCOMTest_REAL32_ARRAY_Event", dwSize, f ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type REAL32",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiSetAndCommitObject ",
									L"float "
								);
					}
					break;

					case 610:
					{
						MyTest test;

						if ( ! test.TestArraySix ( L"MSFT_NonCOMTest_REAL64_ARRAY_Event", dwSize, g ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type REAL64",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiSetAndCommitObject ",
									L"double "
								);
					}
					break;

					case 611:
					{
						MyTest test;

						if ( ! test.TestArraySix ( L"MSFT_NonCOMTest_BOOLEAN_ARRAY_Event", dwSize, b ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type BOOLEAN",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiSetAndCommitObject ",
									L"boolean "
								);
					}
					break;

					case 612:
					{
						MyTest test;

						if ( ! test.TestArraySix ( L"MSFT_NonCOMTest_STRING_ARRAY_Event", _string, dwSize, ( LPCWSTR* ) sz ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type STRING",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiSetAndCommitObject ",
									L"string "
								);
					}
					break;

					case 613:
					{
						MyTest test;

						if ( ! test.TestArraySix ( L"MSFT_NonCOMTest_DATETIME_ARRAY_Event", _datetime, dwSize, ( LPCWSTR* ) d ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type DATETIME",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiSetAndCommitObject ",
									L"datetime "
								);
					}
					break;

					case 614:
					{
						MyTest test;

						if ( ! test.TestArraySix ( L"MSFT_NonCOMTest_REFERENCE_ARRAY_Event", _reference, dwSize, ( LPCWSTR* ) r ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Array type REFERENCE",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiSetAndCommitObject ",
									L"reference "
								);
					}
					break;

					case 615:
					{
						MyTest test;

						event.CreateObject ( ( HANDLE ) ( * pConnect ) );
						o [0]	= event.m_hEventObject;
						o [1]	= event.m_hEventObject;
						o [2]	= event.m_hEventObject;

						if ( ! test.TestArraySix ( L"MSFT_NonCOMTest_OBJECT_ARRAY_Event", dwSize, (void**) o ) )
						{
							hr = E_FAIL;
						}

					{
						log.Log (	L"Array type OBJECT",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiSetAndCommitObject ",
									L"object "
								);
					}
					}
					break;

					case 616:
					{
						MyTest test;

						if ( ! test.TestArraySix ( L"MSFT_NonCOMTest_CHAR16_ARRAY_Event", _char16, dwSize, wc ) )
						{
							hr = E_FAIL;
						}

					{
						log.Log (	L"Array type CHAR16",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiSetAndCommitObject ",
									L"char16 "
								);
					}
					}
					break;

					case 6:
					{
						hr = event.CreateObjectProps ( ( HANDLE ) ( * pConnect ) );

						// wait till data ready
						Sleep ( 1000 );

						o [0]	= event.m_hEventObject;
						o [1]	= event.m_hEventObject;
						o [2]	= event.m_hEventObject;

						if SUCCEEDED ( hr )
						{
							WORD *	pb		= NULL;

							try
							{
								if ( ( pb = new WORD [dwSize] ) != NULL )
								{
									for ( DWORD dw = 0; dw < dwSize; dw ++ )
									{
										pb [ dw ] = (WORD) b [ dw ] ;
									}

								}
							}
							catch ( ... )
							{
								if ( pb )
								{
									delete [] pb;
									pb = NULL;
								}
							}

							hr = event.SetCommit (	WMI_SENDCOMMIT_SET_NOT_REQUIRED,
													( WORD*	 )				pb,
													( WCHAR* )				wc,
													( LPWSTR* )				d,
													( void** )				o,
													( float* )				f,
													( double* )				g,
													( LPWSTR* )				r,
													( signed short* )		s,
													( signed long* )		l,
													( signed __int64* )		i,
													( signed char* )		c,
													( LPWSTR* )				sz,
													( unsigned short* )		us,
													( unsigned long* )		ul,
													( unsigned __int64* )	ui,
													( unsigned char* )		uc
												);

							if ( pb )
							{
								delete [] pb;
								pb = NULL;
							}

							log.Log (	L"Array type ALL",
										hr,
										2,
										L"WmiCreateObjectProps ",
										L"WmiSetAndCommitObject "
									);

							Sleep ( 3000 );
						}
					}
					break;
				}

				// disconnect from IWbemLocator
				event.ObjectLocator (FALSE);

				// destroy connect
				pConnect->ConnectClear();

				// destroy event object
				event.MyEventObjectClear();

				lpszToken	= newToken;
				hr			= S_OK;
			}
		}
		catch ( ... )
		{
			log.Log (	L"CATASTROPHIC FAILURE ... exception was catched",
						E_UNEXPECTED,
						1,
						L"SCALAR TESTING"
					);
		}

//		while(!pThis->IsStopped())
//		{
//			//check for pause condition after each test
//			//=========================================
//			while(pThis->IsPaused() && !pThis->IsStopped())
//			{
//				Sleep(1000);
//			}
//		}

		if ( _App.m_hUse.GetHANDLE() != NULL )
		{
			::ReleaseSemaphore ( _App.m_hUse, 1, NULL );
			::InterlockedDecrement ( &MyApp::m_lCount );
		}
	}
	while ( ::InterlockedCompareExchange ( &MyApp::m_lCount, MyApp::m_lCount, 0 ) != 0 );

	delete pThis;
	::CoUninitialize ( );

	return HRESULT_TO_WIN32 ( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\noncomevent\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by NonCOMEvent.rc
//

#ifndef	__ATLRES_H__
#define IDC_STATIC                      -1
#endif	//__ATLRES_H__

#define IDM_ABOUTBOX                    0x0010

#define IDS_PROJNAME		100
#define IDR_MAINFRAME		100

#define IDR_NonCOMEvent			101
#define IDR_NonCOMEvent_Module	102
#define	IDR_NonCOMEvent_Notify	103

#define IDD_ABOUTBOX		103
#define IDS_ABOUTBOX		104

#define	IDD_NONCOMEVENTMAINDLG		105
#define	IDC_CONNECT					106
#define	IDC_DISCONNECT				107

#define	IDC_STATIC_EVENTS			108
#define	IDC_COMBO_EVENTS			109

#define	IDC_LIST_CALLBACK			110
#define	IDC_CALLBACK_CLEAR			111

#define	IDC_BUTTON_CREATE			119
#define	IDC_BUTTON_CREATE_FORMAT	120
#define	IDC_BUTTON_CREATE_PROPS		121

#define	IDC_BUTTON_DESTROY			122

#define	IDC_BUTTON_PROPERTIES_ADD	123
#define	IDC_BUTTON_PROPERTY_ADD		124
#define	IDC_BUTTON_PROPERTY_SET		125

#define	IDC_BUTTON_COMMIT			126

#define	IDD_COMMON_LIST				300
#define	IDC_RESULT					301

#define	IDD_DIALOG_PROPERTY			400

#define	IDC_EDIT_NAME				401

#define	IDC_COMBO_TYPE				402
#define	IDC_EDIT_TYPE				403

#define	IDC_EDIT_VALUE				404
#define	IDC_STATIC_VALUE			405

#define	IDC_COMBO_INDEX				406
#define	IDC_STATIC_INDEX			407

#define	IDC_STATIC_ARRAY			408

#define	IDC_STATIC_SELECT			409
#define	IDC_BUTTON_SELECT			410

#define	IDC_CHECK_SET				411

#define	IDC_DATAGRID				412

#define	IDD_NONCOMEVENTCONNECTDLG	200
#define	IDC_NAMESPACE				201
#define	IDC_BUTTON_NAMESPACE		202
#define	IDC_PROVIDER				203
#define	IDC_BUTTON_PROVIDER			204
#define	IDC_BATCH_TRUE				205
#define	IDC_BATCH_FALSE				206
#define	IDC_BUFFERSIZE				207
#define	IDC_LATENCY					208

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        200
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         200
#define _APS_NEXT_SYMED_VALUE           107

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\noncomevent\noncomeventmaindlg.cpp ===
// NonCOMEventMainDlg.cpp : Implementation of CNonCOMEventMainDlg
#include "precomp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// need atl wrappers
#ifndef	__ATLBASE_H__
#include <atlbase.h>
#endif	__ATLBASE_H__

// application
#include "_App.h"
extern MyApp		_App;

// module
#include "_Module.h"
extern MyModule _Module;

extern LPWSTR	g_szQuery;

/////////////////////////////////////////////////////////////////////////////
// dialogs
/////////////////////////////////////////////////////////////////////////////

#include "_Dlg.h"
#include "_DlgImpl.h"

#include "NonCOMEventAboutDlg.h"
#include "NonCOMEventPropertyDlg.h"
#include "NonCOMEventConnectDlg.h"
#include "NonCOMEventMainDlg.h"

// static list box
CListBox*	CNonCOMEventMainDlg::m_plbCallBack	= NULL;

// call back function
HRESULT WINAPI CNonCOMEventMainDlg::EventSourceCallBack	(
															HANDLE hSource, 
															EVENT_SOURCE_MSG msg, 
															LPVOID pUser, 
															LPVOID pData
														)
{
	if ( ! ::IsWindowEnabled ( ::GetDlgItem ( (HWND) pUser, IDC_CALLBACK_CLEAR ) ) )
	{
		::EnableWindow ( ::GetDlgItem ( (HWND) pUser, IDC_CALLBACK_CLEAR ), TRUE );
	}

	WCHAR		wsz1 [ _MAX_PATH ] = { L'\0' };

	switch(msg)
	{
		case ESM_START_SENDING_EVENTS:
		{
			if ( m_plbCallBack )
			{
				m_plbCallBack -> AddString ( L"***************************************************" );
				m_plbCallBack -> AddString ( L"ESM_START_SENDING_EVENTS" );
				m_plbCallBack -> AddString ( L"***************************************************" );

				m_plbCallBack -> AddString ( L"" );
			}
		}

		break;

		case ESM_STOP_SENDING_EVENTS:
		{
			if ( m_plbCallBack )
			{
				m_plbCallBack -> AddString ( L"***************************************************" );
				m_plbCallBack -> AddString ( L"ESM_STOP_SENDING_EVENTS" );
				m_plbCallBack -> AddString ( L"***************************************************" );

				m_plbCallBack -> AddString ( L"" );
			}
		}

		break;

		case ESM_NEW_QUERY:
		{
            ES_NEW_QUERY *pQuery = (ES_NEW_QUERY*) pData;

			if ( m_plbCallBack )
			{
				m_plbCallBack -> AddString ( L"***************************************************" );
				m_plbCallBack -> AddString ( L"ES_NEW_QUERY" );
				m_plbCallBack -> AddString ( L"***************************************************" );

				m_plbCallBack -> AddString ( L"" );

				wsprintf ( wsz1,	L" %s ... 0x%08x ... THREAD x%08x",
									pQuery->szQuery,
									pQuery->dwID,
									::GetCurrentThreadId ( )
						 );

				m_plbCallBack -> AddString ( wsz1 );
				m_plbCallBack -> AddString ( L"" );
			}
		}

		break;

		case ESM_CANCEL_QUERY:
		{
            ES_CANCEL_QUERY *pQuery = (ES_CANCEL_QUERY*) pData;

			if ( m_plbCallBack )
			{
				m_plbCallBack -> AddString ( L"***************************************************" );
				m_plbCallBack -> AddString ( L"ES_CANCEL_QUERY" );
				m_plbCallBack -> AddString ( L"***************************************************" );

				m_plbCallBack -> AddString ( L"" );

				wsprintf ( wsz1,	L" 0x%08x ... THREAD x%08x",
									pQuery->dwID,
									::GetCurrentThreadId ( )
						 );

				m_plbCallBack -> AddString ( wsz1 );
				m_plbCallBack -> AddString ( L"" );
			}
		}

		break;

		case ESM_ACCESS_CHECK:
		{
            ES_ACCESS_CHECK *pQuery = (ES_ACCESS_CHECK*) pData;

			if ( m_plbCallBack )
			{
				m_plbCallBack -> AddString ( L"***************************************************" );
				m_plbCallBack -> AddString ( L"ES_ACCESS_CHECK" );
				m_plbCallBack -> AddString ( L"***************************************************" );

				m_plbCallBack -> AddString ( L"" );

				wsprintf ( wsz1,	L" %s ... SID = 0x%08x ... THREAD x%08x",
									pQuery->szQuery,
									pQuery->pSid,
									::GetCurrentThreadId ( )
						 );

				m_plbCallBack -> AddString ( wsz1 );
				m_plbCallBack -> AddString ( L"" );
			}
		}

		break;

		default:
		{
			return E_UNEXPECTED;
		}

		break;
	}

	// default stuff
	return MyConnect::DefaultCallBack ( hSource, msg, pUser, pData );
}

/////////////////////////////////////////////////////////////////////////////////////////
// private helpers
/////////////////////////////////////////////////////////////////////////////////////////

HRESULT	CNonCOMEventMainDlg::TextSet ( UINT nDlgItem, LPCWSTR str )
{
	HRESULT hr = S_OK;

	if ( ! SetDlgItemText ( nDlgItem, str ) )
	{
		hr = HRESULT_FROM_WIN32 ( ::GetLastError() );
	}

	return hr;
}

HRESULT	CNonCOMEventMainDlg::TextGet ( UINT nDlgItem, LPWSTR * pstr )
{
	if ( ! pstr )
	{
		return E_POINTER;
	}

	HRESULT hr = S_OK;

	WCHAR str [ _MAX_PATH ] = { L'\0' };

	if ( ! GetDlgItemText ( nDlgItem, str, _MAX_PATH * sizeof ( WCHAR ) ) )
	{
		hr = HRESULT_FROM_WIN32 ( ::GetLastError() );
	}
	else
	{
		try
		{
			if ( ( ( * pstr ) = new WCHAR [ lstrlenW ( str ) + 1 ] ) != NULL )
			{
				lstrcpyW ( ( * pstr ), str );
			}
			else
			{
				hr = E_OUTOFMEMORY;
			}
		}
		catch ( ... )
		{
			hr = E_UNEXPECTED;
		}
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CNonCOMEventMainDlg

LRESULT CNonCOMEventMainDlg::OnInitDialog( UINT, WPARAM, LPARAM, BOOL& )
{
	if ( ! _App.m_event.m_pLocator )
	{
		#ifdef	__SUPPORT_MSGBOX
		::MessageBox ( NULL, L"Internal error, terminating !", L"ERROR ... ", MB_OK );
		#endif	__SUPPORT_MSGBOX

		EndDialog ( IDCANCEL );
		return 1L;
	}

	// center the dialog on the screen
	CenterWindow();

	// set icons
	HICON hIcon = (HICON)::LoadImage(	_Module.GetResourceInstance(),
										MAKEINTRESOURCE(IDR_MAINFRAME), 
										IMAGE_ICON,
										::GetSystemMetrics(SM_CXICON),
										::GetSystemMetrics(SM_CYICON),
										LR_DEFAULTCOLOR
									);
	SetIcon(hIcon, TRUE);

	HICON hIconSmall = (HICON)::LoadImage(	_Module.GetResourceInstance(),
											MAKEINTRESOURCE(IDR_MAINFRAME), 
											IMAGE_ICON,
											::GetSystemMetrics(SM_CXSMICON),
											::GetSystemMetrics(SM_CYSMICON),
											LR_DEFAULTCOLOR
										 );
	SetIcon(hIconSmall, FALSE);

	// IDM_ABOUTBOX must be in the system command range.
	_ASSERTE((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	_ASSERTE(IDM_ABOUTBOX < 0xF000);

	CMenu SysMenu = GetSystemMenu(FALSE);
	if(::IsMenu(SysMenu))
	{
		TCHAR szAboutMenu[256];
		if(::LoadString(_Module.GetResourceInstance(), IDS_ABOUTBOX, szAboutMenu, 255) > 0)
		{
			SysMenu.AppendMenu(MF_SEPARATOR);
			SysMenu.AppendMenu(MF_STRING, IDM_ABOUTBOX, szAboutMenu);
		}
	}
	SysMenu.Detach();

	// register object for message filtering
	CMessageLoop* pLoop = _Module.GetMessageLoop();
	pLoop->AddMessageFilter(this);

	// enable/disable buttons
	::EnableWindow ( GetDlgItem ( IDC_CONNECT ) , TRUE );
	::EnableWindow ( GetDlgItem ( IDC_DISCONNECT ), FALSE );

	::EnableWindow ( GetDlgItem ( IDC_CALLBACK_CLEAR ), FALSE );

	::ShowWindow ( GetDlgItem ( IDC_BUTTON_PROPERTIES_ADD ), SW_HIDE );

	Enable ( FALSE );

	// wrap combo box
	HWND hEvents = NULL;
	hEvents = GetDlgItem ( IDC_COMBO_EVENTS );

	if ( hEvents )
	{
		try
		{
			if ( ! m_pcbEvents && ( m_pcbEvents = new CComboBox ( hEvents ) ) != NULL )
			{
			}
		}
		catch ( ... )
		{
		}
	}

	// wrap list box
	HWND hCallBack = NULL;
	hCallBack = GetDlgItem ( IDC_LIST_CALLBACK );

	if ( hCallBack )
	{
		try
		{
			if ( ! m_plbCallBack && ( m_plbCallBack = new CListBox ( hCallBack ) ) != NULL )
			{
			}
		}
		catch ( ... )
		{
		}
	}

	return 1;  // Let the system set the focus
}

void	CNonCOMEventMainDlg::Enable ( BOOL bEnable = TRUE )
{
	::EnableWindow ( GetDlgItem ( IDC_STATIC_EVENTS ), bEnable );
	::EnableWindow ( GetDlgItem ( IDC_COMBO_EVENTS ), bEnable );

	::EnableWindow ( GetDlgItem ( IDC_STATIC_SELECT ), bEnable );
	::EnableWindow ( GetDlgItem ( IDC_BUTTON_SELECT ), bEnable );

	::EnableWindow ( GetDlgItem ( IDC_BUTTON_CREATE ), bEnable );
	::EnableWindow ( GetDlgItem ( IDC_BUTTON_CREATE_FORMAT ), bEnable );
	::EnableWindow ( GetDlgItem ( IDC_BUTTON_CREATE_PROPS ), bEnable );
	::EnableWindow ( GetDlgItem ( IDC_BUTTON_DESTROY ), bEnable );

	::EnableWindow ( GetDlgItem ( IDC_BUTTON_PROPERTY_ADD ), bEnable );
	::EnableWindow ( GetDlgItem ( IDC_BUTTON_PROPERTY_SET ), bEnable );
	::EnableWindow ( GetDlgItem ( IDC_BUTTON_COMMIT ), bEnable );

	return;
}

LRESULT CNonCOMEventMainDlg::OnEvents	(WORD wNotifyCode, WORD , HWND , BOOL& )
{
	if ( wNotifyCode == CBN_SELCHANGE )
	{
		int nCurrentSelect = 0;
		
		if ( m_pcbEvents )
		{
			if ( ( nCurrentSelect = m_pcbEvents->GetCurSel() ) != CB_ERR )
			{
				// refresh event object

				BSTR wsz = NULL;
				if SUCCEEDED ( m_pcbEvents->GetLBTextBSTR ( nCurrentSelect, wsz ) )
				{
					CComBSTR szSelect;

					szSelect  = g_szQuery;
					szSelect += wsz;

					_App.EventInit ( wsz );
					::SysFreeString ( wsz );

					::EnableWindow ( GetDlgItem ( IDC_BUTTON_CREATE ), TRUE );

					if ( _App.m_event.m_bProps )
					{
					::EnableWindow ( GetDlgItem ( IDC_BUTTON_CREATE_FORMAT ), TRUE );
					::EnableWindow ( GetDlgItem ( IDC_BUTTON_CREATE_PROPS ), TRUE );
					}
					else
					{
					::ShowWindow ( GetDlgItem ( IDC_BUTTON_PROPERTIES_ADD ), SW_HIDE );

					::EnableWindow ( GetDlgItem ( IDC_BUTTON_CREATE_FORMAT ), FALSE );
					::EnableWindow ( GetDlgItem ( IDC_BUTTON_CREATE_PROPS ), FALSE );
					}

					::EnableWindow ( GetDlgItem ( IDC_BUTTON_DESTROY ), FALSE );

					::EnableWindow ( GetDlgItem ( IDC_BUTTON_PROPERTY_ADD ), FALSE );
					::EnableWindow ( GetDlgItem ( IDC_BUTTON_PROPERTY_SET ), FALSE );
					::EnableWindow ( GetDlgItem ( IDC_BUTTON_COMMIT ), FALSE );

					SetDlgItemText ( IDC_STATIC_SELECT, szSelect );
				}
			}
		}
	}

	return 0L;
}

LRESULT CNonCOMEventMainDlg::OnOK( WORD, WORD wID, HWND, BOOL& )
{
	EndDialog(wID);
	return 0L;
}

LRESULT	CNonCOMEventMainDlg::OnConnect( WORD, WORD wID, HWND, BOOL& )
{
	switch ( wID )
	{
		case IDC_CONNECT:
		{
			MyDlg < CNonCOMEventConnectDlg> dlg;

			if SUCCEEDED ( dlg.Init() )
			{
				if SUCCEEDED ( dlg.RunModal ( SW_SHOWDEFAULT ) )
				{
					// enable/disable buttons
					::EnableWindow ( GetDlgItem ( IDC_CONNECT ), FALSE );
					::EnableWindow ( GetDlgItem ( IDC_DISCONNECT ), TRUE );

					// enable everything
					Enable ( );

					// disable destroy button
					::EnableWindow ( GetDlgItem ( IDC_BUTTON_DESTROY ), FALSE );

					// disable properties button
					::EnableWindow ( GetDlgItem ( IDC_BUTTON_PROPERTY_ADD ), FALSE );
					::EnableWindow ( GetDlgItem ( IDC_BUTTON_PROPERTY_SET ), FALSE );
					::EnableWindow ( GetDlgItem ( IDC_BUTTON_COMMIT ), FALSE );

					// refresh static for events
					TextSet ( IDC_STATIC_EVENTS, dlg.GetDlg()->m_szProvider );

					// refresh combo for events
					for ( DWORD dw = 0; dw < ( DWORD ) dlg.GetDlg()->m_Events; dw ++ )
					{
						if ( m_pcbEvents )
						{
							m_pcbEvents->AddString ( dlg.GetDlg()->m_Events [ dw ] );
						}
					}

					if ( m_pcbEvents )
					{
						// init Application event object
						_App.m_event.InitObject ( dlg.GetDlg()->m_szNamespace, dlg.GetDlg()->m_szProvider );

						m_pcbEvents->SetCurSel ( 0 );

						BOOL bHandle = TRUE;
						OnEvents ( CBN_SELCHANGE, IDC_COMBO_EVENTS, GetDlgItem ( IDC_COMBO_EVENTS ), bHandle );
					}
				}
			}
		}
		break;

		case IDC_DISCONNECT:
		{
			// enable/disable buttons
			::EnableWindow ( GetDlgItem ( IDC_CONNECT ), TRUE );
			::EnableWindow ( GetDlgItem ( IDC_DISCONNECT ), FALSE );

			// refresh combo for events
			if ( m_pcbEvents )
			{
				m_pcbEvents->ResetContent();

				// destroy previous Application event object
				_App.m_event.MyEventObjectClear ();

			}

			// clear text field
			SetDlgItemText ( IDC_STATIC_SELECT, L"" );

			// refresh for events
			TextSet ( IDC_STATIC_EVENTS, NULL );

			// disable all controls
			Enable ( FALSE );

			// repaint everything
			UpdateWindow ( );

			// wait
			CHourGlass hg;

			_App.Disconnect();
		}
		break;

	}
	return 0L;
}

LRESULT CNonCOMEventMainDlg::OnPropertyAdd( WORD, WORD wID, HWND, BOOL& )
{
	switch ( wID )
	{
		case IDC_BUTTON_PROPERTY_ADD:
		{
			MyDlg < CNonCOMEventPropertyDlg> dlg;

			if ( _App.m_event.m_bProps )
			{
				if ( ::IsWindowEnabled ( GetDlgItem ( IDC_BUTTON_PROPERTIES_ADD ) ) )
				{
					::EnableWindow ( GetDlgItem ( IDC_BUTTON_PROPERTIES_ADD ), FALSE );
				}

				if ( _App.m_event.PropertyAdd () == S_FALSE )
				{
					::EnableWindow ( GetDlgItem ( IDC_BUTTON_PROPERTY_ADD ), FALSE );
					::EnableWindow ( GetDlgItem ( IDC_BUTTON_PROPERTY_SET ), TRUE );
				}
			}
			else
			{
				if SUCCEEDED ( dlg.Init() )
				{
					if SUCCEEDED ( dlg.RunModal ( SW_SHOWDEFAULT ) )
					{
						if ( _App.m_event.PropertyAdd (
														dlg.GetDlg()->m_wszName,
														MyEventObjectAbstract::GetType ( dlg.GetDlg()->m_wszType ),
														NULL
													  )
							 == S_OK
						   )
						{
							::EnableWindow ( GetDlgItem ( IDC_BUTTON_PROPERTY_SET ), TRUE );
						}
					}
				}
			}
		}
		break;

		case IDC_BUTTON_PROPERTIES_ADD:
		{
			if ( ::IsWindowEnabled ( GetDlgItem ( IDC_BUTTON_PROPERTY_ADD ) ) )
			{
				::EnableWindow ( GetDlgItem ( IDC_BUTTON_PROPERTY_ADD ), FALSE );
			}

			if SUCCEEDED ( _App.m_event.PropertiesAdd ( ) )
			{
				::EnableWindow ( GetDlgItem ( IDC_BUTTON_PROPERTY_SET ), TRUE );
				::EnableWindow ( GetDlgItem ( IDC_BUTTON_PROPERTIES_ADD ), FALSE );
			}
		}
		break;

	}

	return 0L;
}

LRESULT CNonCOMEventMainDlg::OnPropertySet( WORD, WORD, HWND, BOOL& )
{
	MyDlg < CNonCOMEventPropertyDlg> dlg;

	if SUCCEEDED ( dlg.Init( TRUE ) )
	{
		if SUCCEEDED ( dlg.RunModal ( SW_SHOWDEFAULT ) )
		{
			if SUCCEEDED ( dlg.GetDlg() -> PropertySet ( ) )
			{
				::EnableWindow ( GetDlgItem ( IDC_BUTTON_COMMIT ), TRUE );
			}
		}
	}

	return 0L;
}

LRESULT CNonCOMEventMainDlg::OnCommit( WORD, WORD, HWND, BOOL& )
{
	_App.m_event.EventCommit();
	return 0L;
}

LRESULT CNonCOMEventMainDlg::OnDestroyObject( WORD, WORD, HWND, BOOL& )
{
	// stack hour cursor
	CHourGlass hg;

	if SUCCEEDED ( _App.m_event.DestroyObject () )
	{
		::EnableWindow ( GetDlgItem ( IDC_BUTTON_CREATE ), TRUE );
		::EnableWindow ( GetDlgItem ( IDC_BUTTON_CREATE_FORMAT ), TRUE );
		::EnableWindow ( GetDlgItem ( IDC_BUTTON_CREATE_PROPS ), TRUE );
		::EnableWindow ( GetDlgItem ( IDC_BUTTON_DESTROY ), FALSE );

		::EnableWindow ( GetDlgItem ( IDC_BUTTON_PROPERTY_ADD ), FALSE );
		::EnableWindow ( GetDlgItem ( IDC_BUTTON_PROPERTY_SET ), FALSE );
		::EnableWindow ( GetDlgItem ( IDC_BUTTON_COMMIT ), FALSE );

		if ( _App.m_event.m_bProps )
		{
			::EnableWindow ( GetDlgItem ( IDC_BUTTON_PROPERTIES_ADD ), FALSE );
			::ShowWindow ( GetDlgItem ( IDC_BUTTON_PROPERTIES_ADD ), SW_HIDE );
		}
	}

	return 0L;
};

LRESULT CNonCOMEventMainDlg::OnCreateObject( WORD, WORD wID, HWND, BOOL& )
{
	// stack hour cursor
	CHourGlass hg;

	switch ( wID )
	{
		case IDC_BUTTON_CREATE:
		{
			if SUCCEEDED ( _App.m_event.CreateObject ( (HANDLE) ( * _App.m_connect ) ) )
			{
				::EnableWindow ( GetDlgItem ( IDC_BUTTON_CREATE ), FALSE );
				::EnableWindow ( GetDlgItem ( IDC_BUTTON_CREATE_FORMAT ), FALSE );
				::EnableWindow ( GetDlgItem ( IDC_BUTTON_CREATE_PROPS ), FALSE );
				::EnableWindow ( GetDlgItem ( IDC_BUTTON_DESTROY ), TRUE );

				::EnableWindow ( GetDlgItem ( IDC_BUTTON_PROPERTY_ADD ), TRUE );

				if ( _App.m_event.m_bProps )
				{
					::ShowWindow ( GetDlgItem ( IDC_BUTTON_PROPERTIES_ADD ), SW_SHOW );
					::EnableWindow ( GetDlgItem ( IDC_BUTTON_PROPERTIES_ADD ), TRUE );
				}
			}
		}
		break;

		case IDC_BUTTON_CREATE_FORMAT:
		{
			if SUCCEEDED ( _App.m_event.CreateObjectFormat ( (HANDLE) ( * _App.m_connect ) ) )
			{
				::EnableWindow ( GetDlgItem ( IDC_BUTTON_CREATE ), FALSE );
				::EnableWindow ( GetDlgItem ( IDC_BUTTON_CREATE_FORMAT ), FALSE );
				::EnableWindow ( GetDlgItem ( IDC_BUTTON_CREATE_PROPS ), FALSE );
				::EnableWindow ( GetDlgItem ( IDC_BUTTON_DESTROY ), TRUE );

				::EnableWindow ( GetDlgItem ( IDC_BUTTON_PROPERTY_SET ), TRUE );
			}
		}
		break;

		case IDC_BUTTON_CREATE_PROPS:
		{
			if SUCCEEDED ( _App.m_event.CreateObjectProps ( (HANDLE) ( * _App.m_connect ) ) )
			{
				::EnableWindow ( GetDlgItem ( IDC_BUTTON_CREATE ), FALSE );
				::EnableWindow ( GetDlgItem ( IDC_BUTTON_CREATE_FORMAT ), FALSE );
				::EnableWindow ( GetDlgItem ( IDC_BUTTON_CREATE_PROPS ), FALSE );
				::EnableWindow ( GetDlgItem ( IDC_BUTTON_DESTROY ), TRUE );

				::EnableWindow ( GetDlgItem ( IDC_BUTTON_PROPERTY_SET ), TRUE );
			}
		}
		break;
	}

	return 0L;
}

LRESULT CNonCOMEventMainDlg::OnCopySelect( WORD, WORD, HWND, BOOL& )
{
	LPWSTR szQuery = NULL;

    if SUCCEEDED ( TextGet(IDC_STATIC_SELECT, &szQuery) )
	{
		DWORD   dwSize = lstrlenW ( szQuery ) + 1;
		HGLOBAL hglob = GlobalAlloc( GMEM_MOVEABLE | GMEM_DDESHARE, dwSize * sizeof ( WCHAR ) );

		LPVOID	mglob = GlobalLock ( hglob );
		memcpy(mglob, szQuery, dwSize * sizeof ( WCHAR ) );
		GlobalUnlock(hglob);

		::OpenClipboard(NULL);
		SetClipboardData(CF_UNICODETEXT, hglob);
		CloseClipboard();

		delete [] szQuery;
		szQuery = NULL;
	}

	return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\noncomevent\workerscalar.cpp ===
#define _WIN32_DCOM	

#include "Precomp.h"
#include "NonCOMEventModule.h"

#include "_App.h"
#include "_Module.h"

extern MyApp _App;

#include "module.h"
#include "worker.h"

// includes

#include "Enumerator.h"

#include "_Connect.h"
#include "_EventObject.h"
#include "_EventObjects.h"

// log
#include "_log.h"

// test
#include "_test.h"

DWORD WINAPI CMyWorkerScalar::WorkThread(void *pVoid)
{
	::CoInitializeEx ( NULL, COINIT_MULTITHREADED );

	if ( _App.m_hUse.GetHANDLE() != NULL )
	{
		DWORD	dwHandles = 2;
		HANDLE	hHandles [] =
		{
			_App.m_hKill,
			_App.m_hUse
		};

		::InterlockedIncrement ( &MyApp::m_lCount );

		if ( ::WaitForMultipleObjects ( dwHandles, hHandles, FALSE, INFINITE ) != WAIT_OBJECT_0 + 1 )
		{
			return ( DWORD ) HRESULT_TO_WIN32 ( E_FAIL );
		}
	}

	CMyWorkerScalar *		pThis		= ( CMyWorkerScalar * ) pVoid;

	// data

	BOOL				b	= TRUE;
	WCHAR				wc	= L'c';
	LPWSTR				d	= NULL;
	void*				o	= NULL;
	float				f	= 4.5;
	double				g	= 6.7;
	LPWSTR				r	= L"Win32_Processor.DeviceID=\"CPU0\"";
	signed short		s	= -1;
	signed long			l	= -2;
	signed __int64		i	= -3;
	signed char			c	= 'c';
	LPWSTR				sz	= L"string";
	unsigned short		us	= 1;
	unsigned long		ul	= 2;
	unsigned __int64	ui	= 3;
	unsigned char		uc	= 'c';

	MyLog					log ( pThis->m_pNotify );
	MyConnect*				pConnect	= NULL;
	HRESULT hr							= S_OK;

	//one way for a module to work--run until stopped by user 
    //=======================================================

	#ifdef	__DEBUG_STRESS
	DebugBreak();
	#endif	__DEBUG_STRESS

	do
	{
		////////////////////////////////////////////////////////////////////////
		// variables
		////////////////////////////////////////////////////////////////////////
		WCHAR	szTokens[]	= L"-/";

		////////////////////////////////////////////////////////////////////////
		// command line
		////////////////////////////////////////////////////////////////////////
		LPWSTR lpCmdLine = pThis->m_wszParams;

		////////////////////////////////////////////////////////////////////////
		// find behaviour
		////////////////////////////////////////////////////////////////////////
		LPCWSTR lpszToken = MyApp::FindOneOf(lpCmdLine, szTokens);

		try
		{
			while (lpszToken != NULL)
			{
				LPCWSTR newToken = NULL;
				newToken = MyApp::FindOneOf(lpszToken, szTokens);

				DWORD	dwAction	= 0L;
				BOOL	bCharacter	= TRUE;

				if ( newToken )
				{
					LPWSTR helper = NULL;

					try
					{
						if ( ( helper = new WCHAR [ newToken - lpszToken ] ) != NULL )
						{
							memcpy ( helper, lpszToken, sizeof ( WCHAR ) * ( newToken - lpszToken - 1 ) );
							helper [ newToken - lpszToken - 1 ] = L'\0';

							if ( !HasCharacter ( helper ) )
							{
								dwAction = _wtoi ( helper );
								bCharacter = FALSE;
							}

							delete [] helper;
							helper = NULL;
						}
					}
					catch ( ... )
					{
					}

					if ( bCharacter )
					{
						lpszToken	= newToken;
						continue;
					}
				}
				else
				{
					if ( !HasCharacter ( lpszToken ) )
					{
						dwAction = _wtoi ( lpszToken );
						bCharacter = FALSE;
					}

					break;
				}

				SYSTEMTIME st;
				GetLocalTime ( &st );

				WCHAR time [ _MAX_PATH ] = { L'\0' };
				wsprintf ( time, L"%04d%02d%02d%02d%02d%02d.**********",
										st.wYear,
										st.wMonth,
										st.wDay,
										st.wHour,
										st.wMinute,
										st.wSecond
						 );

				d = time;

				// get connect to event object
				pConnect = MyConnect::ConnectGet();

				MyEventObjectNormal		event;

				// connect to IWbemLocator
				event.ObjectLocator ();

				event.InitObject( L"root\\cimv2", L"NonCOMTest Event Provider" );
				event.Init ( L"MSFT_NonCOMTest_SCALAR_Event" );

				#ifdef	__SUPPORT_WAIT
				Sleep ( 1000 );
				#endif	__SUPPORT_WAIT

				switch ( dwAction )
				{
					default:
					case 0 :
					{
						hr = event.EventReport1 ( ( HANDLE ) (* pConnect ), 
													c	,
													uc	,
													s	,
													us	,
													l	,
													ul	,
													i	,
													ui	,
													f	,
													g	,
													b	,
													sz	,
													wc ,
													event.m_hEventObject
												);

						log.Log (	L"Scalar type REPORTEVENT",
									hr,
									1,
									L"WmiReportEvent "
								);
					}
					break;

					case 11:
					{
						MyTest test;

						if ( ! test.TestScalarOne ( L"MSFT_NonCOMTest_SINT8_Event", c ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type SINT8",
									hr,
									4,
									L"WmiCreateObject ",
									L"WmiCommitObject ",
									L"Property Add ---> Set ",
									L"signed char "
								);
					}
					break;

					case 12:
					{
						MyTest test;

						if ( ! test.TestScalarOne ( L"MSFT_NonCOMTest_UINT8_Event", uc ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type UINT8",
									hr,
									4,
									L"WmiCreateObject ",
									L"WmiCommitObject ",
									L"Property Add ---> Set ",
									L"unsigned char "
								);
					}
					break;

					case 13:
					{
						MyTest test;

						if ( ! test.TestScalarOne ( L"MSFT_NonCOMTest_SINT16_Event", s ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type  SINT16",
									hr,
									4,
									L"WmiCreateObject ",
									L"WmiCommitObject ",
									L"Property Add ---> Set ",
									L"signed short "
								);
					}
					break;

					case 14:
					{
						MyTest test;

						if ( ! test.TestScalarOne ( L"MSFT_NonCOMTest_UINT16_Event", _uint16, us ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type UINT16",
									hr,
									4,
									L"WmiCreateObject ",
									L"WmiCommitObject ",
									L"Property Add ---> Set ",
									L"unsigned short "
								);
					}
					break;

					case 15:
					{
						MyTest test;

						if ( ! test.TestScalarOne ( L"MSFT_NonCOMTest_SINT32_Event", l ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type SINT32",
									hr,
									4,
									L"WmiCreateObject ",
									L"WmiCommitObject ",
									L"Property Add ---> Set ",
									L"signed long "
								);
					}
					break;

					case 16:
					{
						MyTest test;

						if ( ! test.TestScalarOne ( L"MSFT_NonCOMTest_UINT32_Event", ul ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type UINT32",
									hr,
									4,
									L"WmiCreateObject ",
									L"WmiCommitObject ",
									L"Property Add ---> Set ",
									L"unsigned long "
								);
					}
					break;

					case 17:
					{
						MyTest test;

						if ( ! test.TestScalarOne ( L"MSFT_NonCOMTest_SINT64_Event", i ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type SINT64",
									hr,
									4,
									L"WmiCreateObject ",
									L"WmiCommitObject ",
									L"Property Add ---> Set ",
									L"signed __int64 "
								);
					}
					break;

					case 18:
					{
						MyTest test;

						if ( ! test.TestScalarOne ( L"MSFT_NonCOMTest_UINT64_Event", ui ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type UINT64",
									hr,
									4,
									L"WmiCreateObject ",
									L"WmiCommitObject ",
									L"Property Add ---> Set ",
									L"unsigned __int64 "
								);
					}
					break;

					case 19:
					{
						MyTest test;

						if ( ! test.TestScalarOne ( L"MSFT_NonCOMTest_REAL32_Event", f ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type REAL32",
									hr,
									4,
									L"WmiCreateObject ",
									L"WmiCommitObject ",
									L"Property Add ---> Set ",
									L"float "
								);
					}
					break;

					case 110:
					{
						MyTest test;

						if ( ! test.TestScalarOne ( L"MSFT_NonCOMTest_REAL64_Event", g ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type REAL64",
									hr,
									4,
									L"WmiCreateObject ",
									L"WmiCommitObject ",
									L"Property Add ---> Set ",
									L"double "
								);
					}
					break;

					case 111:
					{
						MyTest test;

						if ( ! test.TestScalarOne ( L"MSFT_NonCOMTest_BOOLEAN_Event", b ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type BOOLEAN",
									hr,
									4,
									L"WmiCreateObject ",
									L"WmiCommitObject ",
									L"Property Add ---> Set ",
									L"boolean "
								);
					}
					break;

					case 112:
					{
						MyTest test;

						if ( ! test.TestScalarOne ( L"MSFT_NonCOMTest_STRING_Event", _string, sz ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type STRING",
									hr,
									4,
									L"WmiCreateObject ",
									L"WmiCommitObject ",
									L"Property Add ---> Set ",
									L"string "
								);
					}
					break;

					case 113:
					{
						MyTest test;

						if ( ! test.TestScalarOne ( L"MSFT_NonCOMTest_DATETIME_Event", _datetime, d ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type DATETIME",
									hr,
									4,
									L"WmiCreateObject ",
									L"WmiCommitObject ",
									L"Property Add ---> Set ",
									L"datetime "
								);
					}
					break;

					case 114:
					{
						MyTest test;

						if ( ! test.TestScalarOne ( L"MSFT_NonCOMTest_REFERENCE_Event", _reference, r ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type REFERENCE",
									hr,
									4,
									L"WmiCreateObject ",
									L"WmiCommitObject ",
									L"Property Add ---> Set ",
									L"reference "
								);
					}
					break;

					case 115:
					{
						event.CreateObject ( ( HANDLE ) ( * pConnect ) );
						o = ( void* ) event.m_hEventObject;

						MyTest test;

						if ( ! test.TestScalarOne ( L"MSFT_NonCOMTest_OBJECT_Event", (void*) o ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type OBJECT",
									hr,
									4,
									L"WmiCreateObject ",
									L"WmiCommitObject ",
									L"Property Add ---> Set ",
									L"object "
								);
					}
					break;

					case 116:
					{
						MyTest test;

						if ( ! test.TestScalarOne ( L"MSFT_NonCOMTest_CHAR16_Event", _char16, wc ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type CHAR16",
									hr,
									4,
									L"WmiCreateObject ",
									L"WmiCommitObject ",
									L"Property Add ---> Set ",
									L"char16 "
								);
					}
					break;

					case 1:
					{
						hr = event.CreateObject ( ( HANDLE ) ( * pConnect ) );

						// wait till data ready
						Sleep ( 1000 );

						if SUCCEEDED ( hr )
						{
							BOOL bSuccess = TRUE;

							o = ( void* ) event.m_hEventObject;

							for ( DWORD dw = 0; dw < 16; dw++ )
							{
								event.PropertyAdd ( dw );
							}

							hr = event.PropertySet ( 0, b );

							log.Log (	L"Scalar type BOOLEAN",
										hr,
										4,
										L"WmiCreateObject ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"boolean "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySetWCHAR ( 1, wc );

							log.Log (	L"Scalar type CHAR16",
										hr,
										4,
										L"WmiCreateObject ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"char16 "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySetDATETIME ( 2, d );

							log.Log (	L"Scalar type DATETIME",
										hr,
										4,
										L"WmiCreateObject ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"datetime "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySetOBJECT ( 3, ( void* ) o );

							log.Log (	L"Scalar type OBJECT",
										hr,
										4,
										L"WmiCreateObject ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"object "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 4, f );

							log.Log (	L"Scalar type REAL32",
										hr,
										4,
										L"WmiCreateObject ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"float "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 5, g );

							log.Log (	L"Scalar type REAL64",
										hr,
										4,
										L"WmiCreateObject ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"double "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySetREFERENCE ( 6, r );

							log.Log (	L"Scalar type REFERENCE",
										hr,
										4,
										L"WmiCreateObject ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"reference "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 7, s );

							log.Log (	L"Scalar type SINT16",
										hr,
										4,
										L"WmiCreateObject ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"signed short "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 8, l );

							log.Log (	L"Scalar type SINT32",
										hr,
										4,
										L"WmiCreateObject ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"signed long "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 9, i );

							log.Log (	L"Scalar type SINT64",
										hr,
										4,
										L"WmiCreateObject ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"signed __int64 "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 10, c );

							log.Log (	L"Scalar type SINT8",
										hr,
										4,
										L"WmiCreateObject ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"signed char "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 11, sz );

							log.Log (	L"Scalar type STRING",
										hr,
										4,
										L"WmiCreateObject ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"string "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 12, us );

							log.Log (	L"Scalar type UINT16",
										hr,
										4,
										L"WmiCreateObject ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"unsigned short "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 13, ul );

							log.Log (	L"Scalar type UINT32",
										hr,
										4,
										L"WmiCreateObject ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"unsigned long "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 14, ui );

							log.Log (	L"Scalar type UINT64",
										hr,
										4,
										L"WmiCreateObject ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"unsigned __int64 "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 15, uc );

							log.Log (	L"Scalar type UINT8",
										hr,
										4,
										L"WmiCreateObject ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"unsigned char "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							if ( bSuccess )
							{
								hr = event.EventCommit ();
								hr = event.EventCommit ();

								log.Log (	L"Scalar type ALL",
											hr,
											2,
											L"WmiCreateObject ",
											L"WmiCommitObject "
										);

								Sleep ( 3000 );
							}
						}
					}
					break;

					case 21:
					{
						MyTest test;

						if ( ! test.TestScalarTwo ( L"MSFT_NonCOMTest_SINT8_Event", c ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type SINT8",
									hr,
									3,
									L"WmiCreateObject ",
									L"WmiSetAndCommitObject ",
									L"signed char "
								);
					}
					break;

					case 22:
					{
						MyTest test;

						if ( ! test.TestScalarTwo ( L"MSFT_NonCOMTest_UINT8_Event", uc ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type UINT8",
									hr,
									3,
									L"WmiCreateObject ",
									L"WmiSetAndCommitObject ",
									L"unsigned char "
								);
					}
					break;

					case 23:
					{
						MyTest test;

						if ( ! test.TestScalarTwo ( L"MSFT_NonCOMTest_SINT16_Event", s ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type SINT16",
									hr,
									3,
									L"WmiCreateObject ",
									L"WmiSetAndCommitObject ",
									L"signed short "
								);
					}
					break;

					case 24:
					{
						MyTest test;

						if ( ! test.TestScalarTwo ( L"MSFT_NonCOMTest_UINT16_Event", _uint16, us ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type UINT16",
									hr,
									3,
									L"WmiCreateObject ",
									L"WmiSetAndCommitObject ",
									L"unsigned short "
								);
					}
					break;

					case 25:
					{
						MyTest test;

						if ( ! test.TestScalarTwo ( L"MSFT_NonCOMTest_SINT32_Event", l ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type SINT32",
									hr,
									3,
									L"WmiCreateObject ",
									L"WmiSetAndCommitObject ",
									L"signed long "
								);
					}
					break;

					case 26:
					{
						MyTest test;

						if ( ! test.TestScalarTwo ( L"MSFT_NonCOMTest_UINT32_Event", ul ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type UINT32",
									hr,
									3,
									L"WmiCreateObject ",
									L"WmiSetAndCommitObject ",
									L"unsigned long "
								);
					}
					break;

					case 27:
					{
						MyTest test;

						if ( ! test.TestScalarTwo ( L"MSFT_NonCOMTest_SINT64_Event", i ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type SINT64",
									hr,
									3,
									L"WmiCreateObject ",
									L"WmiSetAndCommitObject ",
									L"signed __int64 "
								);
					}
					break;

					case 28:
					{
						MyTest test;

						if ( ! test.TestScalarTwo ( L"MSFT_NonCOMTest_UINT64_Event", ui ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type UINT64",
									hr,
									3,
									L"WmiCreateObject ",
									L"WmiSetAndCommitObject ",
									L"unsigned __int64 "
								);
					}
					break;

					case 29:
					{
						MyTest test;

						if ( ! test.TestScalarTwo ( L"MSFT_NonCOMTest_REAL32_Event", f ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type REAL32",
									hr,
									3,
									L"WmiCreateObject ",
									L"WmiSetAndCommitObject ",
									L"float "
								);
					}
					break;

					case 210:
					{
						MyTest test;

						if ( ! test.TestScalarTwo ( L"MSFT_NonCOMTest_REAL64_Event", g ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type REAL64",
									hr,
									3,
									L"WmiCreateObject ",
									L"WmiSetAndCommitObject ",
									L"double "
								);
					}
					break;

					case 211:
					{
						MyTest test;

						if ( ! test.TestScalarTwo ( L"MSFT_NonCOMTest_BOOLEAN_Event", b ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type BOOLEAN",
									hr,
									3,
									L"WmiCreateObject ",
									L"WmiSetAndCommitObject ",
									L"boolean "
								);
					}
					break;

					case 212:
					{
						MyTest test;

						if ( ! test.TestScalarTwo ( L"MSFT_NonCOMTest_STRING_Event", _string, sz ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type STRING",
									hr,
									3,
									L"WmiCreateObject ",
									L"WmiSetAndCommitObject ",
									L"string "
								);
					}
					break;

					case 213:
					{
						MyTest test;

						if ( ! test.TestScalarTwo ( L"MSFT_NonCOMTest_DATETIME_Event", _datetime, d ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type DATETIME",
									hr,
									3,
									L"WmiCreateObject ",
									L"WmiSetAndCommitObject ",
									L"datetime "
								);
					}
					break;

					case 214:
					{
						MyTest test;

						if ( ! test.TestScalarTwo ( L"MSFT_NonCOMTest_REFERENCE_Event", _reference, r ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type REFERENCE",
									hr,
									3,
									L"WmiCreateObject ",
									L"WmiSetAndCommitObject ",
									L"reference "
								);
					}
					break;

					case 215:
					{
						event.CreateObject ( ( HANDLE ) ( * pConnect ) );
						o = ( void* ) event.m_hEventObject;

						MyTest test;

						if ( ! test.TestScalarTwo ( L"MSFT_NonCOMTest_OBJECT_Event", (void*) o ) )
						{
							hr = E_FAIL;
						}

					{
						log.Log (	L"Scalar type OBJECT",
									hr,
									3,
									L"WmiCreateObject ",
									L"WmiSetAndCommitObject ",
									L"object "
								);
					}
					}
					break;

					case 216:
					{
						MyTest test;

						if ( ! test.TestScalarTwo ( L"MSFT_NonCOMTest_CHAR16_Event", _char16, wc ) )
						{
							hr = E_FAIL;
						}

					{
						log.Log (	L"Scalar type CHAR16",
									hr,
									3,
									L"WmiCreateObject ",
									L"WmiSetAndCommitObject ",
									L"char16 "
								);
					}
					}
					break;

					case 2:
					{
						hr = event.CreateObject ( ( HANDLE ) ( * pConnect ) );

						// wait till data ready
						Sleep ( 1000 );

						if SUCCEEDED ( hr )
						{
							o = ( void* ) event.m_hEventObject;

							for ( DWORD dw = 0; dw < 16; dw++ )
							{
								event.PropertyAdd ( dw );
							}

							hr = event.SetCommit (	WMI_SENDCOMMIT_SET_NOT_REQUIRED,
													( BOOL )				b,
													( WCHAR )				wc,
													( LPWSTR )				d,
													( void* )				o,
													( float )				f,
													( double )				g,
													( LPWSTR )				r,
													( signed short )		s,
													( signed long )			l,
													( signed __int64 )		i,
													( signed char )			c,
													( LPWSTR )				sz,
													( unsigned short )		us,
													( unsigned long )		ul,
													( unsigned __int64 )	ui,
													( unsigned char )		uc
												);

							log.Log (	L"Scalar type ALL",
										hr,
										2,
										L"WmiCreateObject ",
										L"WmiSetAndCommitObject "
									);

							Sleep ( 3000 );
						}
					}
					break;

					case 31:
					{
						MyTest test;

						if ( ! test.TestScalarThree ( L"MSFT_NonCOMTest_SINT8_Event", c ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type SINT8",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiCommitObject ",
									L"signed char "
								);
					}
					break;

					case 32:
					{
						MyTest test;

						if ( ! test.TestScalarThree ( L"MSFT_NonCOMTest_UINT8_Event", uc ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type UINT8",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiCommitObject ",
									L"unsigned char "
								);
					}
					break;

					case 33:
					{
						MyTest test;

						if ( ! test.TestScalarThree ( L"MSFT_NonCOMTest_SINT16_Event", s ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type SINT16",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiCommitObject ",
									L"signed short "
								);
					}
					break;

					case 34:
					{
						MyTest test;

						if ( ! test.TestScalarThree ( L"MSFT_NonCOMTest_UINT16_Event", _uint16, us ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type UINT16",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiCommitObject ",
									L"unsigned short "
								);
					}
					break;

					case 35:
					{
						MyTest test;

						if ( ! test.TestScalarThree ( L"MSFT_NonCOMTest_SINT32_Event", l ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type SINT32",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiCommitObject ",
									L"signed long "
								);
					}
					break;

					case 36:
					{
						MyTest test;

						if ( ! test.TestScalarThree ( L"MSFT_NonCOMTest_UINT32_Event", ul ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type UINT32",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiCommitObject ",
									L"unsigned long "
								);
					}
					break;

					case 37:
					{
						MyTest test;

						if ( ! test.TestScalarThree ( L"MSFT_NonCOMTest_SINT64_Event", i ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type SINT64",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiCommitObject ",
									L"signed __int64 "
								);
					}
					break;

					case 38:
					{
						MyTest test;

						if ( ! test.TestScalarThree ( L"MSFT_NonCOMTest_UINT64_Event", ui ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type UINT64",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiCommitObject ",
									L"unsigned __int64 "
								);
					}
					break;

					case 39:
					{
						MyTest test;

						if ( ! test.TestScalarThree ( L"MSFT_NonCOMTest_REAL32_Event", f ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type REAL32",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiCommitObject ",
									L"float "
								);
					}
					break;

					case 310:
					{
						MyTest test;

						if ( ! test.TestScalarThree ( L"MSFT_NonCOMTest_REAL64_Event", g ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type REAL64",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiCommitObject ",
									L"double "
								);
					}
					break;

					case 311:
					{
						MyTest test;

						if ( ! test.TestScalarThree ( L"MSFT_NonCOMTest_BOOLEAN_Event", b ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type BOOLEAN",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiCommitObject ",
									L"boolean "
								);
					}
					break;

					case 312:
					{
						MyTest test;

						if ( ! test.TestScalarThree ( L"MSFT_NonCOMTest_STRING_Event", _string, sz ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type STRING",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiCommitObject ",
									L"string "
								);
					}
					break;

					case 313:
					{
						MyTest test;

						if ( ! test.TestScalarThree ( L"MSFT_NonCOMTest_DATETIME_Event", _datetime, d ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type DATETIME",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiCommitObject ",
									L"datetime "
								);
					}
					break;

					case 314:
					{
						MyTest test;

						if ( ! test.TestScalarThree ( L"MSFT_NonCOMTest_REFERENCE_Event", _reference, r ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type REFERENCE",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiCommitObject ",
									L"reference "
								);
					}
					break;

					case 315:
					{
						event.CreateObject ( ( HANDLE ) ( * pConnect ) );
						o = ( void* ) event.m_hEventObject;

						MyTest test;

						if ( ! test.TestScalarThree ( L"MSFT_NonCOMTest_OBJECT_Event", (void*) o ) )
						{
							hr = E_FAIL;
						}

					{
						log.Log (	L"Scalar type OBJECT",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiCommitObject ",
									L"object "
								);
					}
					}
					break;

					case 316:
					{
						MyTest test;

						if ( ! test.TestScalarThree ( L"MSFT_NonCOMTest_CHAR16_Event", _char16, wc ) )
						{
							hr = E_FAIL;
						}

					{
						log.Log (	L"Scalar type CHAR16",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiCommitObject ",
									L"char16 "
								);
					}
					}
					break;

					case 3:
					{
						hr = event.CreateObjectFormat ( ( HANDLE ) ( * pConnect ) );

						// wait till data ready
						Sleep ( 1000 );

						if SUCCEEDED ( hr )
						{
							BOOL bSuccess = TRUE;

							o = ( void* ) event.m_hEventObject;

							hr = event.PropertySet ( 0, b );

							log.Log (	L"Scalar type BOOLEAN",
										hr,
										4,
										L"WmiCreateObjectFormat ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"boolean "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySetWCHAR ( 1, wc );

							log.Log (	L"Scalar type CHAR16",
										hr,
										4,
										L"WmiCreateObjectFormat ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"char16 "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySetDATETIME ( 2, d );

							log.Log (	L"Scalar type DATETIME",
										hr,
										4,
										L"WmiCreateObjectFormat ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"datetime "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySetOBJECT ( 3, ( void* ) o );

							log.Log (	L"Scalar type OBJECT",
										hr,
										4,
										L"WmiCreateObjectFormat ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"object "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 4, f );

							log.Log (	L"Scalar type REAL32",
										hr,
										4,
										L"WmiCreateObjectFormat ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"float "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 5, g );

							log.Log (	L"Scalar type REAL64",
										hr,
										4,
										L"WmiCreateObjectFormat ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"double "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySetREFERENCE ( 6, r );

							log.Log (	L"Scalar type REFERENCE",
										hr,
										4,
										L"WmiCreateObjectFormat ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"reference "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 7, s );

							log.Log (	L"Scalar type SINT16",
										hr,
										4,
										L"WmiCreateObjectFormat ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"signed short "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 8, l );

							log.Log (	L"Scalar type SINT32",
										hr,
										4,
										L"WmiCreateObjectFormat ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"signed long "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 9, i );

							log.Log (	L"Scalar type SINT64",
										hr,
										4,
										L"WmiCreateObjectFormat ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"signed __int64 "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 10, c );

							log.Log (	L"Scalar type SINT8",
										hr,
										4,
										L"WmiCreateObjectFormat ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"signed char "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 11, sz );

							log.Log (	L"Scalar type STRING",
										hr,
										4,
										L"WmiCreateObjectFormat ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"string "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 12, us );

							log.Log (	L"Scalar type UINT16",
										hr,
										4,
										L"WmiCreateObjectFormat ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"unsigned short "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 13, ul );

							log.Log (	L"Scalar type UINT32",
										hr,
										4,
										L"WmiCreateObjectFormat ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"unsigned long "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 14, ui );

							log.Log (	L"Scalar type UINT64",
										hr,
										4,
										L"WmiCreateObjectFormat ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"unsigned __int64 "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 15, uc );

							log.Log (	L"Scalar type UINT8",
										hr,
										4,
										L"WmiCreateObjectFormat ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"unsigned char "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							if ( bSuccess )
							{
								hr = event.EventCommit ();

								log.Log (	L"Scalar type ALL",
											hr,
											2,
											L"WmiCreateObjectFormat ",
											L"WmiCommitObject "
										);

								Sleep ( 3000 );
							}
						}
					}
					break;

					case 41:
					{
						MyTest test;

						if ( ! test.TestScalarFour ( L"MSFT_NonCOMTest_SINT8_Event", c ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type SINT8",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiSetAndCommitObject ",
									L"signed char "
								);
					}
					break;

					case 42:
					{
						MyTest test;

						if ( ! test.TestScalarFour ( L"MSFT_NonCOMTest_UINT8_Event", uc ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type UINT8",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiSetAndCommitObject ",
									L"unsigned char "
								);
					}
					break;

					case 43:
					{
						MyTest test;

						if ( ! test.TestScalarFour ( L"MSFT_NonCOMTest_SINT16_Event", s ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type SINT16",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiSetAndCommitObject ",
									L"signed short "
								);
					}
					break;

					case 44:
					{
						MyTest test;

						if ( ! test.TestScalarFour ( L"MSFT_NonCOMTest_UINT16_Event", _uint16, us ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type UINT16",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiSetAndCommitObject ",
									L"unsigned short "
								);
					}
					break;

					case 45:
					{
						MyTest test;

						if ( ! test.TestScalarFour ( L"MSFT_NonCOMTest_SINT32_Event", l ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type SINT32",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiSetAndCommitObject ",
									L"signed long "
								);
					}
					break;

					case 46:
					{
						MyTest test;

						if ( ! test.TestScalarFour ( L"MSFT_NonCOMTest_UINT32_Event", ul ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type UINT32",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiSetAndCommitObject ",
									L"unsigned long "
								);
					}
					break;

					case 47:
					{
						MyTest test;

						if ( ! test.TestScalarFour ( L"MSFT_NonCOMTest_SINT64_Event", i ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type SINT64",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiSetAndCommitObject ",
									L"signed __int64 "
								);
					}
					break;

					case 48:
					{
						MyTest test;

						if ( ! test.TestScalarFour ( L"MSFT_NonCOMTest_UINT64_Event", ui ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type UINT64",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiSetAndCommitObject ",
									L"unsigned __int64 "
								);
					}
					break;

					case 49:
					{
						MyTest test;

						if ( ! test.TestScalarFour ( L"MSFT_NonCOMTest_REAL32_Event", f ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type REAL32",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiSetAndCommitObject ",
									L"float "
								);
					}
					break;

					case 410:
					{
						MyTest test;

						if ( ! test.TestScalarFour ( L"MSFT_NonCOMTest_REAL64_Event", g ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type REAL64",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiSetAndCommitObject ",
									L"double "
								);
					}
					break;

					case 411:
					{
						MyTest test;

						if ( ! test.TestScalarFour ( L"MSFT_NonCOMTest_BOOLEAN_Event", b ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type BOOLEAN",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiSetAndCommitObject ",
									L"boolean "
								);
					}
					break;

					case 412:
					{
						MyTest test;

						if ( ! test.TestScalarFour ( L"MSFT_NonCOMTest_STRING_Event", _string, sz ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type STRING",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiSetAndCommitObject ",
									L"string "
								);
					}
					break;

					case 413:
					{
						MyTest test;

						if ( ! test.TestScalarFour ( L"MSFT_NonCOMTest_DATETIME_Event", _datetime, d ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type DATETIME",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiSetAndCommitObject ",
									L"datetime "
								);
					}
					break;

					case 414:
					{
						MyTest test;

						if ( ! test.TestScalarFour ( L"MSFT_NonCOMTest_REFERENCE_Event", _reference, r ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type REFERENCE",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiSetAndCommitObject ",
									L"reference "
								);
					}
					break;

					case 415:
					{
						event.CreateObject ( ( HANDLE ) ( * pConnect ) );
						o = ( void* ) event.m_hEventObject;

						MyTest test;

						if ( ! test.TestScalarFour ( L"MSFT_NonCOMTest_OBJECT_Event", (void*) o ) )
						{
							hr = E_FAIL;
						}

					{
						log.Log (	L"Scalar type OBJECT",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiSetAndCommitObject ",
									L"object "
								);
					}
					}
					break;

					case 416:
					{
						MyTest test;

						if ( ! test.TestScalarFour ( L"MSFT_NonCOMTest_CHAR16_Event", _char16, wc ) )
						{
							hr = E_FAIL;
						}

					{
						log.Log (	L"Scalar type CHAR16",
									hr,
									3,
									L"WmiCreateObjectFormat ",
									L"WmiSetAndCommitObject ",
									L"char16 "
								);
					}
					}
					break;

					case 4:
					{
						hr = event.CreateObjectFormat ( ( HANDLE ) ( * pConnect ) );

						// wait till data ready
						Sleep ( 1000 );

						if SUCCEEDED ( hr )
						{
							o = ( void* ) event.m_hEventObject;

							hr = event.SetCommit (	WMI_SENDCOMMIT_SET_NOT_REQUIRED,
													( BOOL )				b,
													( WCHAR )				wc,
													( LPWSTR )				d,
													( void* )				o,
													( float )				f,
													( double )				g,
													( LPWSTR )				r,
													( signed short )		s,
													( signed long )			l,
													( signed __int64 )		i,
													( signed char )			c,
													( LPWSTR )				sz,
													( unsigned short )		us,
													( unsigned long )		ul,
													( unsigned __int64 )	ui,
													( unsigned char )		uc
												);

							log.Log (	L"Scalar type ALL",
										hr,
										2,
										L"WmiCreateObjectFormat ",
										L"WmiSetAndCommitObject "
									);

							Sleep ( 3000 );
						}
					}
					break;

					case 51:
					{
						MyTest test;

						if ( ! test.TestScalarFive ( L"MSFT_NonCOMTest_SINT8_Event", c ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type SINT8",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiCommitObject ",
									L"signed char "
								);
					}
					break;

					case 52:
					{
						MyTest test;

						if ( ! test.TestScalarFive ( L"MSFT_NonCOMTest_UINT8_Event", uc ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type UINT8",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiCommitObject ",
									L"unsigned char "
								);
					}
					break;

					case 53:
					{
						MyTest test;

						if ( ! test.TestScalarFive ( L"MSFT_NonCOMTest_SINT16_Event", s ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type SINT16",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiCommitObject ",
									L"signed short "
								);
					}
					break;

					case 54:
					{
						MyTest test;

						if ( ! test.TestScalarFive ( L"MSFT_NonCOMTest_UINT16_Event", _uint16, us ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type UINT16",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiCommitObject ",
									L"unsigned short "
								);
					}
					break;

					case 55:
					{
						MyTest test;

						if ( ! test.TestScalarFive ( L"MSFT_NonCOMTest_SINT32_Event", l ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type SINT32",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiCommitObject ",
									L"signed long "
								);
					}
					break;

					case 56:
					{
						MyTest test;

						if ( ! test.TestScalarFive ( L"MSFT_NonCOMTest_UINT32_Event", ul ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type UINT32",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiCommitObject ",
									L"unsigned long "
								);
					}
					break;

					case 57:
					{
						MyTest test;

						if ( ! test.TestScalarFive ( L"MSFT_NonCOMTest_SINT64_Event", i ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type SINT64",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiCommitObject ",
									L"signed __int64 "
								);
					}
					break;

					case 58:
					{
						MyTest test;

						if ( ! test.TestScalarFive ( L"MSFT_NonCOMTest_UINT64_Event", ui ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type UINT64",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiCommitObject ",
									L"unsigned __int64 "
								);
					}
					break;

					case 59:
					{
						MyTest test;

						if ( ! test.TestScalarFive ( L"MSFT_NonCOMTest_REAL32_Event", f ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type REAL32",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiCommitObject ",
									L"float "
								);
					}
					break;

					case 510:
					{
						MyTest test;

						if ( ! test.TestScalarFive ( L"MSFT_NonCOMTest_REAL64_Event", g ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type REAL64",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiCommitObject ",
									L"double "
								);
					}
					break;

					case 511:
					{
						MyTest test;

						if ( ! test.TestScalarFive ( L"MSFT_NonCOMTest_BOOLEAN_Event", b ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type BOOLEAN",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiCommitObject ",
									L"boolean "
								);
					}
					break;

					case 512:
					{
						MyTest test;

						if ( ! test.TestScalarFive ( L"MSFT_NonCOMTest_STRING_Event", _string, sz ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type STRING",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiCommitObject ",
									L"string "
								);
					}
					break;

					case 513:
					{
						MyTest test;

						if ( ! test.TestScalarFive ( L"MSFT_NonCOMTest_DATETIME_Event", _datetime, d ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type DATETIME",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiCommitObject ",
									L"datetime "
								);
					}
					break;

					case 514:
					{
						MyTest test;

						if ( ! test.TestScalarFive ( L"MSFT_NonCOMTest_REFERENCE_Event", _reference, r ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type REFERENCE",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiCommitObject ",
									L"reference "
								);
					}
					break;

					case 515:
					{
						event.CreateObject ( ( HANDLE ) ( * pConnect ) );
						o = ( void* ) event.m_hEventObject;

						MyTest test;

						if ( ! test.TestScalarFive ( L"MSFT_NonCOMTest_OBJECT_Event", (void*) o ) )
						{
							hr = E_FAIL;
						}

					{
						log.Log (	L"Scalar type OBJECT",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiCommitObject ",
									L"object "
								);
					}
					}
					break;

					case 516:
					{
						MyTest test;

						if ( ! test.TestScalarFive ( L"MSFT_NonCOMTest_CHAR16_Event", _char16, wc ) )
						{
							hr = E_FAIL;
						}

					{
						log.Log (	L"Scalar type CHAR16",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiCommitObject ",
									L"char16 "
								);
					}
					}
					break;

					case 5:
					{
						hr = event.CreateObjectProps ( ( HANDLE ) ( * pConnect ) );

						// wait till data ready
						Sleep ( 1000 );

						if SUCCEEDED ( hr )
						{
							BOOL bSuccess = TRUE;

							o = ( void* ) event.m_hEventObject;

							hr = event.PropertySet ( 0, b );

							log.Log (	L"Scalar type BOOLEAN",
										hr,
										4,
										L"WmiCreateObjectProps ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"boolean "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySetWCHAR ( 1, wc );

							log.Log (	L"Scalar type CHAR16",
										hr,
										4,
										L"WmiCreateObjectProps ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"char16 "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySetDATETIME ( 2, d );

							log.Log (	L"Scalar type DATETIME",
										hr,
										4,
										L"WmiCreateObjectProps ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"datetime "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySetOBJECT ( 3, ( void* ) o );

							log.Log (	L"Scalar type OBJECT",
										hr,
										4,
										L"WmiCreateObjectProps ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"object "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 4, f );

							log.Log (	L"Scalar type REAL32",
										hr,
										4,
										L"WmiCreateObjectProps ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"float "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 5, g );

							log.Log (	L"Scalar type REAL64",
										hr,
										4,
										L"WmiCreateObjectProps ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"double "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySetREFERENCE ( 6, r );

							log.Log (	L"Scalar type REFERENCE",
										hr,
										4,
										L"WmiCreateObjectProps ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"reference "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 7, s );

							log.Log (	L"Scalar type SINT16",
										hr,
										4,
										L"WmiCreateObjectProps ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"signed short "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 8, l );

							log.Log (	L"Scalar type SINT32",
										hr,
										4,
										L"WmiCreateObjectProps ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"signed long "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 9, i );

							log.Log (	L"Scalar type SINT64",
										hr,
										4,
										L"WmiCreateObjectProps ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"signed __int64 "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 10, c );

							log.Log (	L"Scalar type SINT8",
										hr,
										4,
										L"WmiCreateObjectProps ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"signed char "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 11, sz );

							log.Log (	L"Scalar type STRING",
										hr,
										4,
										L"WmiCreateObjectProps ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"string "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 12, us );

							log.Log (	L"Scalar type UINT16",
										hr,
										4,
										L"WmiCreateObjectProps ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"unsigned short "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 13, ul );

							log.Log (	L"Scalar type UINT32",
										hr,
										4,
										L"WmiCreateObjectProps ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"unsigned long "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 14, ui );

							log.Log (	L"Scalar type UINT64",
										hr,
										4,
										L"WmiCreateObjectProps ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"unsigned __int64 "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							hr = event.PropertySet ( 15, uc );

							log.Log (	L"Scalar type UINT8",
										hr,
										4,
										L"WmiCreateObjectProps ",
										L"WmiCommitObject ",
										L"Property Add ---> Set ",
										L"unsigned char "
									);

							if FAILED ( hr )
							bSuccess = FALSE;

							if ( bSuccess )
							{
								hr = event.EventCommit ();

								log.Log (	L"Scalar type ALL",
											hr,
											2,
											L"WmiCreateObjectProps ",
											L"WmiCommitObject "
										);

								Sleep ( 3000 );
							}
						}
					}
					break;

					case 61:
					{
						MyTest test;

						if ( ! test.TestScalarSix ( L"MSFT_NonCOMTest_SINT8_Event", c ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type SINT8",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiSetAndCommitObject ",
									L"signed char "
								);
					}
					break;

					case 62:
					{
						MyTest test;

						if ( ! test.TestScalarSix ( L"MSFT_NonCOMTest_UINT8_Event", uc ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type UINT8",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiSetAndCommitObject ",
									L"unsigned char "
								);
					}
					break;

					case 63:
					{
						MyTest test;

						if ( ! test.TestScalarSix ( L"MSFT_NonCOMTest_SINT16_Event", s ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type SINT16",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiSetAndCommitObject ",
									L"signed short "
								);
					}
					break;

					case 64:
					{
						MyTest test;

						if ( ! test.TestScalarSix ( L"MSFT_NonCOMTest_UINT16_Event", _uint16, us ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type UINT16",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiSetAndCommitObject ",
									L"unsigned short "
								);
					}
					break;

					case 65:
					{
						MyTest test;

						if ( ! test.TestScalarSix ( L"MSFT_NonCOMTest_SINT32_Event", l ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type SINT32",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiSetAndCommitObject ",
									L"signed long "
								);
					}
					break;

					case 66:
					{
						MyTest test;

						if ( ! test.TestScalarSix ( L"MSFT_NonCOMTest_UINT32_Event", ul ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type UINT32",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiSetAndCommitObject ",
									L"unsigned long "
								);
					}
					break;

					case 67:
					{
						MyTest test;

						if ( ! test.TestScalarSix ( L"MSFT_NonCOMTest_SINT64_Event", i ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type SINT64",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiSetAndCommitObject ",
									L"signed __int64 "
								);
					}
					break;

					case 68:
					{
						MyTest test;

						if ( ! test.TestScalarSix ( L"MSFT_NonCOMTest_UINT64_Event", ui ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type UINT64",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiSetAndCommitObject ",
									L"unsigned __int64 "
								);
					}
					break;

					case 69:
					{
						MyTest test;

						if ( ! test.TestScalarSix ( L"MSFT_NonCOMTest_REAL32_Event", f ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type REAL32",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiSetAndCommitObject ",
									L"float "
								);
					}
					break;

					case 610:
					{
						MyTest test;

						if ( ! test.TestScalarSix ( L"MSFT_NonCOMTest_REAL64_Event", g ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type REAL64",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiSetAndCommitObject ",
									L"double "
								);
					}
					break;

					case 611:
					{
						MyTest test;

						if ( ! test.TestScalarSix ( L"MSFT_NonCOMTest_BOOLEAN_Event", b ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type BOOLEAN",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiSetAndCommitObject ",
									L"boolean "
								);
					}
					break;

					case 612:
					{
						MyTest test;

						if ( ! test.TestScalarSix ( L"MSFT_NonCOMTest_STRING_Event", _string, sz ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type STRING",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiSetAndCommitObject ",
									L"string "
								);
					}
					break;

					case 613:
					{
						MyTest test;

						if ( ! test.TestScalarSix ( L"MSFT_NonCOMTest_DATETIME_Event", _datetime, d ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type DATETIME",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiSetAndCommitObject ",
									L"datetime "
								);
					}
					break;

					case 614:
					{
						MyTest test;

						if ( ! test.TestScalarSix ( L"MSFT_NonCOMTest_REFERENCE_Event", _reference, r ) )
						{
							hr = E_FAIL;
						}

						log.Log (	L"Scalar type REFERENCE",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiSetAndCommitObject ",
									L"reference "
								);
					}
					break;

					case 615:
					{
						event.CreateObject ( ( HANDLE ) ( * pConnect ) );
						o = ( void* ) event.m_hEventObject;

						MyTest test;

						if ( ! test.TestScalarSix ( L"MSFT_NonCOMTest_OBJECT_Event", (void*) o ) )
						{
							hr = E_FAIL;
						}

					{
						log.Log (	L"Scalar type OBJECT",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiSetAndCommitObject ",
									L"object "
								);
					}
					}
					break;

					case 616:
					{
						MyTest test;

						if ( ! test.TestScalarSix ( L"MSFT_NonCOMTest_CHAR16_Event", _char16, wc ) )
						{
							hr = E_FAIL;
						}

					{
						log.Log (	L"Scalar type CHAR16",
									hr,
									3,
									L"WmiCreateObjectProps ",
									L"WmiSetAndCommitObject ",
									L"char16 "
								);
					}
					}
					break;

					case 6:
					{
						hr = event.CreateObjectProps ( ( HANDLE ) ( * pConnect ) );

						// wait till data ready
						Sleep ( 1000 );

						if SUCCEEDED ( hr )
						{
							o = ( void* ) event.m_hEventObject;

							hr = event.SetCommit (	WMI_SENDCOMMIT_SET_NOT_REQUIRED,
													( BOOL )				b,
													( WCHAR )				wc,
													( LPWSTR )				d,
													( void* )				o,
													( float )				f,
													( double )				g,
													( LPWSTR )				r,
													( signed short )		s,
													( signed long )			l,
													( signed __int64 )		i,
													( signed char )			c,
													( LPWSTR )				sz,
													( unsigned short )		us,
													( unsigned long )		ul,
													( unsigned __int64 )	ui,
													( unsigned char )		uc
												);

							log.Log (	L"Scalar type ALL",
										hr,
										2,
										L"WmiCreateObjectProps ",
										L"WmiSetAndCommitObject "
									);

							Sleep ( 3000 );
						}
					}
					break;
				}

				// disconnect from IWbemLocator
				event.ObjectLocator (FALSE);

				// destroy connect
				pConnect->ConnectClear();

				// destroy event object
				event.MyEventObjectClear();

				lpszToken	= newToken;
				hr			= S_OK;
			}
		}
		catch ( ... )
		{
			log.Log (	L"CATASTROPHIC FAILURE ... exception was catched",
						E_UNEXPECTED,
						1,
						L"SCALAR TESTING"
					);
		}

//		while(!pThis->IsStopped())
//		{
//			//check for pause condition after each test
//			//=========================================
//			while(pThis->IsPaused() && !pThis->IsStopped())
//			{
//				Sleep(1000);
//			}
//		}

		if ( _App.m_hUse.GetHANDLE() != NULL )
		{
			::ReleaseSemaphore ( _App.m_hUse, 1, NULL );
			::InterlockedDecrement ( &MyApp::m_lCount );
		}
	}
	while ( ::InterlockedCompareExchange ( &MyApp::m_lCount, MyApp::m_lCount, 0 ) != 0 );

	delete pThis;
	::CoUninitialize ( );

	return HRESULT_TO_WIN32 ( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\noncomevent\_app.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					_App.cpp
//
//	Abstract:
//
//					module for application
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "PreComp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// application
#include "_App.h"
extern MyApp		_App;

// static variables
LONG MyApp::m_lCount = 0L;

///////////////////////////////////////////////////////////////////////////
// construction & destruction
///////////////////////////////////////////////////////////////////////////

MyApp::MyApp( UINT id ):

	m_connect ( NULL ),

	m_wszName ( NULL ),
	m_hKill ( NULL )
{
	ATLTRACE (	L"*************************************************************\n"
				L"MyApp construction\n"
				L"*************************************************************\n" );

	// smart locking/unlocking
	__Smart_CRITICAL_SECTION scs ( const_cast<LPCRITICAL_SECTION> ( &m_cs.m_sec ) );

	////////////////////////////////////////////////////////////////////////
	// create name
	////////////////////////////////////////////////////////////////////////
	if ( ( m_wszName = LoadStringSystem ( NULL, id ) ) == NULL )
	{
		try
		{
			if ( ( m_wszName = new WCHAR [ lstrlenW ( L"MyApp" ) + 1 ] ) != NULL )
			{
				lstrcpyW ( m_wszName, L"MyApp" );
			}
		}
		catch ( ... )
		{
			if ( m_wszName )
			{
				delete m_wszName;
				m_wszName = NULL;
			}
		}
	}
}

MyApp::MyApp( LPWSTR wszName ):
	m_wszName ( NULL ),
	m_hKill ( NULL )
{
	ATLTRACE (	L"*************************************************************\n"
				L"MyApp construction\n"
				L"*************************************************************\n" );

	// smart locking/unlocking
	__Smart_CRITICAL_SECTION scs ( const_cast<LPCRITICAL_SECTION> ( &m_cs.m_sec ) );

	////////////////////////////////////////////////////////////////////////
	// create name
	////////////////////////////////////////////////////////////////////////
	if ( wszName )
	{
		try
		{
			if ( ( m_wszName = new WCHAR [ lstrlenW ( wszName ) + 1 ] ) != NULL )
			{
				lstrcpyW ( m_wszName, wszName );
			}
		}
		catch ( ... )
		{
			if ( m_wszName )
			{
				delete m_wszName;
				m_wszName = NULL;
			}
		}
	}
}

MyApp::~MyApp()
{
	ATLTRACE (	L"*************************************************************\n"
				L"MyApp destruction\n"
				L"*************************************************************\n" );

	// smart locking/unlocking
	__Smart_CRITICAL_SECTION scs ( const_cast<LPCRITICAL_SECTION> ( &m_cs.m_sec ) );

	////////////////////////////////////////////////////////////////////////
	// release mutex ( previous instance checker :)) )
	////////////////////////////////////////////////////////////////////////
	if ( m_hInstance.GetHANDLE() )
	{
		::ReleaseMutex ( m_hInstance );
		m_hInstance.CloseHandle();
	}

	////////////////////////////////////////////////////////////////////////
	// delete app name
	////////////////////////////////////////////////////////////////////////
	if ( m_wszName )
	{
		delete m_wszName;
		m_wszName = NULL;
	}

	Disconnect();

//	#ifdef	_DEBUG
//	_CrtDumpMemoryLeaks();
//	#endif	_DEBUG
}

///////////////////////////////////////////////////////////////////////////
// exists instance ?
///////////////////////////////////////////////////////////////////////////
BOOL MyApp::Exists ( void )
{
	ATLTRACE (	L"*************************************************************\n"
				L"MyApp exists application\n"
				L"*************************************************************\n" );

	////////////////////////////////////////////////////////////////////////
	// smart locking/unlocking
	////////////////////////////////////////////////////////////////////////
	__Smart_CRITICAL_SECTION scs ( const_cast<LPCRITICAL_SECTION> ( &m_cs.m_sec ) );


	// check instance

	if ( m_hInstance.GetHANDLE() == NULL && m_wszName )
	{
		if ( m_hInstance.SetHANDLE ( ::CreateMutexW ( NULL, FALSE, m_wszName ) ), m_hInstance )
		{
			if ( ::GetLastError () == ERROR_ALREADY_EXISTS )
			{
				return TRUE;
			}
		}
		else
		{
			// m_hInstance.GetHANDLE() == NULL
			// something's is very bad return we already exists :))
			return TRUE;
		}
	}

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\noncomevent\_common.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					_Common.cpp
//
//	Abstract:
//
//					module for common constants and so
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

// query language & queries
LPWSTR	g_szQueryLang		= L"WQL";
LPWSTR	g_szQueryClass		= L"select * from meta_class where __this isa ";
LPWSTR	g_szQueryEvents		= L"select * from meta_class where __this isa \"__ExtrinsicEvent\" and __CLASS = ";
LPWSTR	g_szQuery			= L"select * from ";
LPWSTR	g_szQueryNamespace	= L"select * from __Namespace";

LPWSTR	g_szNamespaceRoot = L"root\\";
LPWSTR	g_szProviderName  = L"MSFT_WMI_NonCOMEventProvider";

LONG g_lFlag			= WBEM_FLAG_FORWARD_ONLY;
LONG g_lFlagProperties	= WBEM_FLAG_LOCAL_ONLY | WBEM_FLAG_NONSYSTEM_ONLY;

// don't required qualifier
LPWSTR g_szFulFilNot[] =
{
	L"abstract"
};

DWORD g_dwFulFilNot	= sizeof ( g_szFulFilNot ) / sizeof ( g_szFulFilNot[0] );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\noncomevent\_enum.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					_Enum.cpp
//
//	Abstract:
//
//					module for enumerator
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "PreComp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// enum
#include "_Enum.h"

///////////////////////////////////////////////////////////////////////////////
//	pseudo construction
///////////////////////////////////////////////////////////////////////////////
void MyEnum::MyEnumInit ( IWbemLocator* pLocator, LPWSTR wszNamespace )
{
	if ( pLocator )
	{
		// destroy previous if exists
		MyEnumUninit();

		try
		{
			// connect server from locator
			pLocator -> ConnectServer (	CComBSTR (wszNamespace ),	// NameSpace Name
										NULL,						// UserName
										NULL,						// Password
										NULL,						// Locale
										0L,							// Security Flags
										NULL,						// Authority
										NULL,						// Wbem Context
										&m_pServices				// Namespace
									  );
		}
		catch ( ... )
		{
		}
	}
}

///////////////////////////////////////////////////////////////////////////////
//	pseudo destruction
///////////////////////////////////////////////////////////////////////////////
void MyEnum::MyEnumUninit ( )
{
	try
	{
		if ( m_pEnum )
		{
			m_pEnum->Release();
		}

		if ( m_pServices )
		{
			m_pServices->Release();
		}
	}
	catch ( ... )
	{
	}

	m_pServices	= NULL;
	m_pEnum		= NULL;
}

///////////////////////////////////////////////////////////////////////////////
//	exec query
///////////////////////////////////////////////////////////////////////////////
HRESULT MyEnum::ExecQuery (	LPWSTR wszQueryLang,
							LPWSTR wszQuery,
							LONG lFlags
						  )
{	
	if ( ! m_pServices || m_pEnum )
	{
		return E_UNEXPECTED;
	}

	if ( ( ! wszQueryLang ) || ( ! wszQuery ) )
	{
		return E_INVALIDARG;
	}

	return m_pServices->ExecQuery	(	CComBSTR ( wszQueryLang ),
										CComBSTR ( wszQuery ),
										lFlags,
										NULL,
										&m_pEnum
									);
}

///////////////////////////////////////////////////////////////////////////////
//	exec instances query
///////////////////////////////////////////////////////////////////////////////
HRESULT MyEnum::ExecInstancesQuery (	LPWSTR wszClassName,
										LONG lFlags
								   )
{	
	if ( ! m_pServices || m_pEnum )
	{
		return E_UNEXPECTED;
	}

	if ( ( ! wszClassName ) )
	{
		return E_INVALIDARG;
	}

	return m_pServices->CreateInstanceEnum	(	CComBSTR ( wszClassName ),
												lFlags,
												NULL,
												&m_pEnum
											);
}

///////////////////////////////////////////////////////////////////////////////
//	next object
///////////////////////////////////////////////////////////////////////////////
HRESULT	MyEnum::NextObject ( IWbemClassObject** ppObject )
{
	// test part
	if ( ! m_pEnum )
	{
		return E_UNEXPECTED;
	}

	if ( ! ppObject )
	{
		return E_POINTER;
	}

	ULONG	uObject		= 0L;
			(*ppObject)	= NULL;

	return m_pEnum->Next ( WBEM_INFINITE, 1, &(*ppObject), &uObject );
}

///////////////////////////////////////////////////////////////////////////////
//	next objects
///////////////////////////////////////////////////////////////////////////////
HRESULT	MyEnum::NextObjects ( ULONG uObjects, ULONG* puObjects, IWbemClassObject** ppObject )
{
	// test part
	if ( ! m_pEnum )
	{
		return E_UNEXPECTED;
	}

	if ( ! ppObject || ! puObjects )
	{
		return E_POINTER;
	}

	(*puObjects)	= NULL;

	return m_pEnum->Next ( WBEM_INFINITE, uObjects, ppObject, puObjects );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\noncomevent\_classobject.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					_ClassObject.cpp
//
//	Abstract:
//
//					module for IWbemClassObject
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "PreComp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// class object
#include "_ClassObject.h"

////////////////////////////////////////////////////////////////////////////////////
//	pseudo constructor
////////////////////////////////////////////////////////////////////////////////////
HRESULT MyClassObject::ClassObjectInit ( IWbemClassObject* pObject )
{
	if ( pObject )
	{
		// destrocy previous data
		ClassObjectUninit();

		( m_pObject = pObject ) -> AddRef();

		return S_OK;
	}

	return E_INVALIDARG;
}

////////////////////////////////////////////////////////////////////////////////////
//	pseudo destructor
////////////////////////////////////////////////////////////////////////////////////
HRESULT MyClassObject::ClassObjectUninit ( )
{
	HRESULT hRes = S_OK;

	try
	{
		if ( m_pObject )
		{
			m_pObject -> Release ();
		}

		if ( m_pObjectQualifierSet )
		{
			m_pObjectQualifierSet -> Release ();
		}
	}
	catch ( ... )
	{
		hRes = E_UNEXPECTED;
	}

	m_pObject				= NULL;
	m_pObjectQualifierSet	= NULL;

	return hRes;
}

//////////////////////////////////////////////////////////////////////////////////////////////
// helpers
//////////////////////////////////////////////////////////////////////////////////////////////

HRESULT MyClassObject::IsCorrect (	IWbemQualifierSet* pSet,
									LPWSTR* lptszNeedNot,
									DWORD	dwNeedNot
								 )
{
	HRESULT	hRes	= S_OK;
	DWORD	dwIndex	= 0;

	if ( lptszNeedNot && dwNeedNot )
	{
		for ( dwIndex = 0; dwIndex < dwNeedNot; dwIndex++)
		{
			hRes = pSet->Get( lptszNeedNot[dwIndex], NULL, NULL, NULL );

			// there is found not requested qualifier
			if ( hRes == WBEM_S_NO_ERROR )
			{
				return S_FALSE;
			}

			if ( hRes != WBEM_E_NOT_FOUND )
			{
				#ifdef	__SUPPORT_MSGBOX
				ERRORMESSAGE_DEFINITION;
				ERRORMESSAGE_RETURN ( hRes );
				#else	__SUPPORT_MSGBOX
				___TRACE_ERROR( L"find out if object is correct failed",hRes );
				return hRes;
				#endif	__SUPPORT_MSGBOX
			}

			hRes = WBEM_S_NO_ERROR;
		}
	}

	return hRes;
}

HRESULT	MyClassObject::GetNames	(	DWORD*		pdwNames,
									LPWSTR**	ppNames,
									CIMTYPE**	ppNamesTypes,
									LPWSTR*		lptszPropNeedNot,
									DWORD		dwPropNeedNot,
									LONG		lFlags
								)
{
	HRESULT	hRes = S_OK;

	if ( ! m_pObject )
	{
		return E_UNEXPECTED;
	}

	if ( ! pdwNames || ! ppNames || ! ppNamesTypes )
	{
		return E_POINTER;
	}

	( * pdwNames )		= 0L;
	( * ppNames )		= NULL;
	( *	ppNamesTypes )	= NULL;

	// smart pointer for safearrays
	__WrapperSAFEARRAY saNames;

	if FAILED ( hRes = m_pObject->GetNames ( NULL, lFlags, NULL, &saNames ) )
	{
		#ifdef	__SUPPORT_MSGBOX
		ERRORMESSAGE_DEFINITION;
		ERRORMESSAGE_RETURN ( hRes );
		#else	__SUPPORT_MSGBOX
		___TRACE_ERROR( L"find out names of object's properties failed",hRes );
		return hRes;
		#endif	__SUPPORT_MSGBOX
	}

	__WrapperARRAY < LPWSTR >	help;

	if FAILED ( hRes = SAFEARRAY_TO_LPWSTRARRAY ( saNames, &help, help ) )
	{
		#ifdef	__SUPPORT_MSGBOX
		ERRORMESSAGE_DEFINITION;
		ERRORMESSAGE_RETURN ( hRes );
		#else	__SUPPORT_MSGBOX
		___TRACE_ERROR( L"SAFEARRAT_TO_LPWSTRARRAY failed",hRes );
		return hRes;
		#endif	__SUPPORT_MSGBOX
	}

	if ( lptszPropNeedNot && dwPropNeedNot )
	{
		for ( DWORD dwIndex = 0; dwIndex < help; dwIndex++ )
		{
			// test if it has proper qualifier set
			CComPtr<IWbemQualifierSet> pSet;

			if FAILED ( hRes = m_pObject->GetPropertyQualifierSet ( help[dwIndex], &pSet ) )
			{
				#ifdef	__SUPPORT_MSGBOX
				ERRORMESSAGE_DEFINITION;
				ERRORMESSAGE_RETURN ( hRes );
				#else	__SUPPORT_MSGBOX
				___TRACE_ERROR( L"GetPropertyQualifierSet failed",hRes );
				return hRes;
				#endif	__SUPPORT_MSGBOX
			}

			if FAILED ( hRes = IsCorrect ( pSet, lptszPropNeedNot, dwPropNeedNot ) )
			{
				#ifdef	__SUPPORT_MSGBOX
				ERRORMESSAGE_DEFINITION;
				ERRORMESSAGE_RETURN ( hRes );
				#else	__SUPPORT_MSGBOX
				___TRACE_ERROR( L"IsCorrect failed",hRes );
				return hRes;
				#endif	__SUPPORT_MSGBOX
			}

			// is not correct clear this name
			if ( hRes == S_FALSE )
			{
				try
				{
					delete help.GetAt ( dwIndex );
					help.SetAt ( dwIndex );
				}
				catch ( ... )
				{
				}
			}
		}
	}

	for ( DWORD dwIndex = 0; dwIndex < help; dwIndex++ )
	{
		if ( help[dwIndex] )
		{
			(*pdwNames)++;
		}
	}

	if ( (*pdwNames ) != ( DWORD ) help )
	{
		try
		{
			if ( ( (*ppNames) = (LPWSTR*) new LPWSTR[ (*pdwNames) ] ) == NULL )
			{
				hRes =  E_OUTOFMEMORY;
			}

			if ( ( ( *ppNamesTypes ) = new CIMTYPE[ (*pdwNames) ] ) == NULL )
			{
				hRes =  E_OUTOFMEMORY;
			}
		}
		catch ( ... )
		{
			hRes = E_FAIL;
		}

		if SUCCEEDED ( hRes )
		{
			DWORD dw = 0;

			for ( dwIndex = 0; dwIndex < help && SUCCEEDED ( hRes ); dwIndex++ )
			{
				if ( help[dwIndex] )
				{
					try
					{
						if ( ( (*ppNames)[dw] = (LPWSTR) new WCHAR[ lstrlenW(help[dwIndex]) + 1] ) == NULL )
						{
							RELEASE_DOUBLEARRAY ( (*ppNames), (*pdwNames) );
							delete [] (*ppNamesTypes );

							hRes =  E_OUTOFMEMORY;
						}
						else
						{
							lstrcpyW ( (*ppNames)[dw], help[dwIndex] );

							CIMTYPE type = CIM_EMPTY;

							if FAILED ( hRes = GetPropertyType ( help[dwIndex], &type ) )
							{
								RELEASE_DOUBLEARRAY ( (*ppNames), (*pdwNames) );
								delete [] (*ppNamesTypes );

								hRes =  E_OUTOFMEMORY;
							}
							else
							{
								(*ppNamesTypes)[dw] = type;

								// increment internal index
								dw++;
							}
						}
					}
					catch ( ... )
					{
						hRes = E_FAIL;
					}
				}
			}
		}

		if FAILED ( hRes ) 
		{
			RELEASE_DOUBLEARRAY ( (*ppNames), (*pdwNames) );
			delete [] (*ppNamesTypes );

			return hRes;
		}
	}
	else
	{
		try
		{
			if ( ( ( *ppNamesTypes ) = new CIMTYPE[help] ) == NULL )
			{
				return E_OUTOFMEMORY;
			}
		}
		catch ( ... )
		{
			return E_FAIL;
		}

		for ( dwIndex = 0; dwIndex < help; dwIndex++ )
		{
			CIMTYPE type = CIM_EMPTY;

			if FAILED ( hRes = GetPropertyType ( help[dwIndex], &type ) )
			{
				delete [] ( * ppNamesTypes );
				( * ppNamesTypes ) = NULL;

				return hRes;
			}

			(*ppNamesTypes)[dwIndex] = type;
		}

		( * ppNames )  = help.Detach();
	}

	return hRes;
}

// qualifier type for specified property
HRESULT MyClassObject::GetPropertyType ( LPCWSTR wszPropName, CIMTYPE* type )
{
	HRESULT	hRes	= S_OK;

	if ( ! m_pObject )
	{
		return E_UNEXPECTED;
	}

	if ( ! type )
	{
		return E_POINTER;
	}

	( *type ) = NULL;

	if FAILED ( hRes = m_pObject->Get ( wszPropName, NULL, NULL, type, NULL ) )
	{
		#ifdef	__SUPPORT_MSGBOX
		ERRORMESSAGE_DEFINITION;
		ERRORMESSAGE_RETURN ( hRes );
		#else	__SUPPORT_MSGBOX
		___TRACE_ERROR( L"Get method on object failed",hRes );
		return hRes;
		#endif	__SUPPORT_MSGBOX
	}

	return hRes;
}

// qualifier value for main object
HRESULT MyClassObject::GetQualifierValue ( LPCWSTR wszQualifierName, LPWSTR* psz )
{
	HRESULT	hRes	= S_OK;

	( *psz ) = NULL;

	if ( ! m_pObject )
	{
		return E_UNEXPECTED;
	}

	if ( ! m_pObjectQualifierSet )
	{
		CComPtr<IWbemQualifierSet> pQualifiers;

		if FAILED ( hRes = m_pObject->GetQualifierSet ( &pQualifiers ) )
		{
			#ifdef	__SUPPORT_MSGBOX
			ERRORMESSAGE_DEFINITION;
			ERRORMESSAGE_RETURN ( hRes );
			#else	__SUPPORT_MSGBOX
			___TRACE_ERROR( L"GetQualifierSet on object failed",hRes );
			return hRes;
			#endif	__SUPPORT_MSGBOX
		}

		( m_pObjectQualifierSet = pQualifiers ) -> AddRef ();
	}

	return GetQualifierValue ( m_pObjectQualifierSet, wszQualifierName, psz );
}

// qualifier value for specified property
HRESULT MyClassObject::GetQualifierValue ( LPCWSTR wszPropName, LPCWSTR wszQualifierName, LPWSTR* psz )
{
	HRESULT	hRes	= S_OK;

	( *psz ) = NULL;

	if ( ! m_pObject )
	{
		return E_UNEXPECTED;
	}

	CComPtr<IWbemQualifierSet> pQualifiers;

	if FAILED ( hRes = m_pObject->GetPropertyQualifierSet ( wszPropName, &pQualifiers ) )
	{
		#ifdef	__SUPPORT_MSGBOX
		ERRORMESSAGE_DEFINITION;
		ERRORMESSAGE_RETURN ( hRes );
		#else	__SUPPORT_MSGBOX
		___TRACE_ERROR( L"GetPropertyQualifierSet on object failed",hRes );
		return hRes;
		#endif	__SUPPORT_MSGBOX
	}

	return GetQualifierValue ( pQualifiers, wszQualifierName, psz );
}

// return qualifier value in string representation ( helper )
HRESULT MyClassObject::GetQualifierValue ( IWbemQualifierSet * pSet, LPCWSTR wszQualifierName, LPWSTR * psz )
{
	(*psz) = NULL;

	CComVariant var;
	CComVariant varDest;

	HRESULT hRes = S_OK;

	CComBSTR bstrQualifierName = wszQualifierName;
	if FAILED ( hRes = pSet->Get ( bstrQualifierName, NULL, &var, NULL ) )
	{
		return hRes;
	}

	try
	{
		if SUCCEEDED ( ::VariantChangeType ( &varDest, &var, VARIANT_NOVALUEPROP , VT_BSTR) )
		{
			try
			{
				if ( ( (*psz) = (LPWSTR) new WCHAR[ ( ::SysStringLen( V_BSTR(&varDest) ) + 1 ) ] ) == NULL )
				{
					return E_OUTOFMEMORY;
				}

				lstrcpy ( (*psz), V_BSTR( &varDest ) );
			}
			catch ( ... )
			{
				delete (*psz);
				(*psz) = NULL;

				return E_UNEXPECTED;
			}
		}
	}
	catch ( ... )
	{
		return E_UNEXPECTED;
	}

	return S_OK;
}

HRESULT MyClassObject::GetPropertyValue ( LPCWSTR wszPropertyName, LPWSTR * psz )
{
	if ( ! m_pObject )
	{
		return E_UNEXPECTED;
	}

	(*psz) = NULL;

	CComVariant var;
	CComVariant varDest;

	HRESULT hRes = S_OK;

	if FAILED ( hRes = m_pObject->Get ( wszPropertyName, NULL, &var, NULL, NULL ) )
	{
		#ifdef	__SUPPORT_MSGBOX
		ERRORMESSAGE_DEFINITION;
		ERRORMESSAGE_RETURN ( hRes );
		#else	__SUPPORT_MSGBOX
		___TRACE_ERROR( L"Get method on object failed",hRes );
		return hRes;
		#endif	__SUPPORT_MSGBOX
	}

	try
	{
		if SUCCEEDED ( ::VariantChangeType ( &varDest, &var, VARIANT_NOVALUEPROP , VT_BSTR) )
		{
			try
			{
				if ( ( (*psz) = (LPWSTR) new WCHAR[ ( ::SysStringLen( V_BSTR(&varDest) ) + 1 ) ] ) == NULL )
				{
					return E_OUTOFMEMORY;
				}

				lstrcpy ( (*psz), V_BSTR( &varDest ) );
			}
			catch ( ... )
			{
				delete (*psz);
				(*psz) = NULL;

				return E_UNEXPECTED;
			}
		}
		else
		{
			return E_FAIL;
		}
	}
	catch ( ... )
	{
		return E_UNEXPECTED;
	}

	return S_OK;
}

HRESULT MyClassObject::GetPropertyValue ( LPCWSTR wszPropertyName, LPWSTR ** pwsz, DWORD* dwsz )
{
	if ( ! m_pObject )
	{
		return E_UNEXPECTED;
	}

	(*pwsz) = NULL;
	(*dwsz) = NULL;

	CComVariant var;

	HRESULT hRes = S_OK;

	if FAILED ( hRes = m_pObject->Get ( wszPropertyName, NULL, &var, NULL, NULL ) )
	{
		#ifdef	__SUPPORT_MSGBOX
		ERRORMESSAGE_DEFINITION;
		ERRORMESSAGE_RETURN ( hRes );
		#else	__SUPPORT_MSGBOX
		___TRACE_ERROR( L"Get method on object failed",hRes );
		return hRes;
		#endif	__SUPPORT_MSGBOX
	}

	SAFEARRAY_TO_LPWSTRARRAY ( V_ARRAY ( & var ) , pwsz, dwsz );

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\noncomevent\_eventproperty.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					_EventProperty.cpp
//
//	Abstract:
//
//					module for event property
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "PreComp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// enum
#include "_EventObject.h"

MyEventProperty::MyEventProperty ( LPWSTR wszName, CIMTYPE type ) :

m_wszName ( NULL ),
m_type ( CIM_EMPTY )

{
	if ( wszName )
	{
		try
		{
			if ( ( m_wszName = new WCHAR [ lstrlenW ( wszName ) + 1 ] ) != NULL )
			{
				lstrcpyW ( m_wszName, wszName );
			}
		}
		catch ( ... )
		{
		}
	}

	m_type = type;

	::VariantInit ( & m_value );
}

MyEventProperty::MyEventProperty ( LPWSTR wszName, LPWSTR type ) :

m_wszName ( NULL ),
m_type ( CIM_EMPTY )

{
	if ( wszName )
	{
		try
		{
			if ( ( m_wszName = new WCHAR [ lstrlenW ( wszName ) + 1 ] ) != NULL )
			{
				lstrcpyW ( m_wszName, wszName );
			}
		}
		catch ( ... )
		{
		}
	}

	m_type = MyEventObjectAbstract::GetType ( type );

	::VariantInit ( & m_value );
}

MyEventProperty::~MyEventProperty ()
{
	if ( m_wszName )
	{
		delete [] m_wszName;
		m_wszName = NULL;
	}

	::VariantClear ( &m_value );
}

LPWSTR	MyEventProperty::GetName ( void ) const
{
	return m_wszName;
}

LPCWSTR	MyEventProperty::GetTypeString  ( void ) const
{
	return MyEventObjectAbstract::GetTypeString ( m_type );
}

CIMTYPE	MyEventProperty::GetType ( void ) const
{
	return m_type;
}

HRESULT	MyEventProperty::GetValue ( VARIANT* pValue ) const
{
	if ( pValue )
	{
		return ::VariantCopy ( pValue, const_cast < VARIANT* > ( &m_value ) );
	}

	return E_POINTER;
}

HRESULT	MyEventProperty::SetValue ( VARIANT value )
{
	::VariantClear ( &m_value );
	return ::VariantCopy ( & m_value, & value );
}

LPCWSTR	MyEventObjectAbstract::GetTypeString ( CIMTYPE type )
{
	switch ( type )
	{
		case CIM_SINT8:
		{
			return L"CIM_SINT8";
		}
		break;
		case CIM_UINT8:
		{
			return L"CIM_UINT8";
		}
		break;
		case CIM_SINT16:
		{
			return L"CIM_SINT16";
		}
		break;
		case CIM_UINT16:
		{
			return L"CIM_UINT16";
		}
		break;
		case CIM_SINT32:
		{
			return L"CIM_SINT32";
		}
		break;
		case CIM_UINT32:
		{
			return L"CIM_UINT32";
		}
		break;
		case CIM_SINT64:
		{
			return L"CIM_SINT64";
		}
		break;
		case CIM_UINT64:
		{
			return L"CIM_UINT64";
		}
		break;
		case CIM_REAL32:
		{
			return L"CIM_REAL32";
		}
		break;
		case CIM_REAL64:
		{
			return L"CIM_REAL64";
		}
		break;
		case CIM_BOOLEAN:
		{
			return L"CIM_BOOLEAN";
		}
		break;
		case CIM_STRING:
		{
			return L"CIM_STRING";
		}
		break;
		case CIM_DATETIME:
		{
			return L"CIM_DATETIME";
		}
		break;
		case CIM_REFERENCE:
		{
			return L"CIM_REFERENCE";
		}
		break;
		case CIM_CHAR16:
		{
			return L"CIM_CHAR16";
		}
		break;
		case CIM_OBJECT:
		{
			return L"CIM_OBJECT";
		}
		break;

		case CIM_SINT8 | CIM_FLAG_ARRAY:
		{
			return L"CIM_SINT8 | CIM_FLAG_ARRAY";
		}
		break;
		case CIM_UINT8 | CIM_FLAG_ARRAY:
		{
			return L"CIM_UINT8 | CIM_FLAG_ARRAY";
		}
		break;
		case CIM_SINT16 | CIM_FLAG_ARRAY:
		{
			return L"CIM_SINT16 | CIM_FLAG_ARRAY";
		}
		break;
		case CIM_UINT16 | CIM_FLAG_ARRAY:
		{
			return L"CIM_UINT16 | CIM_FLAG_ARRAY";
		}
		break;
		case CIM_SINT32 | CIM_FLAG_ARRAY:
		{
			return L"CIM_SINT32 | CIM_FLAG_ARRAY";
		}
		break;
		case CIM_UINT32 | CIM_FLAG_ARRAY:
		{
			return L"CIM_UINT32 | CIM_FLAG_ARRAY";
		}
		break;
		case CIM_SINT64 | CIM_FLAG_ARRAY:
		{
			return L"CIM_SINT64 | CIM_FLAG_ARRAY";
		}
		break;
		case CIM_UINT64 | CIM_FLAG_ARRAY:
		{
			return L"CIM_UINT64 | CIM_FLAG_ARRAY";
		}
		break;
		case CIM_REAL32 | CIM_FLAG_ARRAY:
		{
			return L"CIM_REAL32 | CIM_FLAG_ARRAY";
		}
		break;
		case CIM_REAL64 | CIM_FLAG_ARRAY:
		{
			return L"CIM_REAL64 | CIM_FLAG_ARRAY";
		}
		break;
		case CIM_BOOLEAN | CIM_FLAG_ARRAY:
		{
			return L"CIM_BOOLEAN | CIM_FLAG_ARRAY";
		}
		break;
		case CIM_STRING | CIM_FLAG_ARRAY:
		{
			return L"CIM_STRING | CIM_FLAG_ARRAY";
		}
		break;
		case CIM_DATETIME | CIM_FLAG_ARRAY:
		{
			return L"CIM_DATETIME | CIM_FLAG_ARRAY";
		}
		break;
		case CIM_REFERENCE | CIM_FLAG_ARRAY:
		{
			return L"CIM_REFERENCE | CIM_FLAG_ARRAY";
		}
		break;
		case CIM_CHAR16 | CIM_FLAG_ARRAY:
		{
			return L"CIM_CHAR16 | CIM_FLAG_ARRAY";
		}
		break;
		case CIM_OBJECT | CIM_FLAG_ARRAY:
		{
			return L"CIM_OBJECT | CIM_FLAG_ARRAY";
		}
		break;
	}

	return NULL;
}

CIMTYPE	MyEventObjectAbstract::GetType ( LPWSTR type )
{
	if ( lstrcmpiW ( type, L"CIM_SINT8" ) == 0 )
	{
		return CIM_SINT8;
	}
	else
	if ( lstrcmpiW ( type, L"CIM_UINT8" ) == 0 )
	{
		return CIM_UINT8;
	}
	else
	if ( lstrcmpiW ( type, L"CIM_SINT16" ) == 0 )
	{
		return CIM_SINT16;
	}
	else
	if ( lstrcmpiW ( type, L"CIM_UINT16" ) == 0 )
	{
		return CIM_UINT16;
	}
	else
	if ( lstrcmpiW ( type, L"CIM_SINT32" ) == 0 )
	{
		return CIM_SINT32;
	}
	else
	if ( lstrcmpiW ( type, L"CIM_UINT32" ) == 0 )
	{
		return CIM_UINT32;
	}
	else
	if ( lstrcmpiW ( type, L"CIM_SINT64" ) == 0 )
	{
		return CIM_SINT64;
	}
	else
	if ( lstrcmpiW ( type, L"CIM_UINT64" ) == 0 )
	{
		return CIM_UINT64;
	}
	else
	if ( lstrcmpiW ( type, L"CIM_REAL32" ) == 0 )
	{
		return CIM_REAL32;
	}
	else
	if ( lstrcmpiW ( type, L"CIM_REAL64" ) == 0 )
	{
		return CIM_REAL64;
	}
	else
	if ( lstrcmpiW ( type, L"CIM_BOOLEAN" ) == 0 )
	{
		return CIM_BOOLEAN;
	}
	else
	if ( lstrcmpiW ( type, L"CIM_STRING" ) == 0 )
	{
		return CIM_STRING;
	}
	else
	if ( lstrcmpiW ( type, L"CIM_DATETIME" ) == 0 )
	{
		return CIM_DATETIME;
	}
	else
	if ( lstrcmpiW ( type, L"CIM_REFERENCE" ) == 0 )
	{
		return CIM_REFERENCE;
	}
	else
	if ( lstrcmpiW ( type, L"CIM_CHAR16" ) == 0 )
	{
		return CIM_CHAR16;
	}
	else
	if ( lstrcmpiW ( type, L"CIM_OBJECT" ) == 0 )
	{
		return CIM_OBJECT;
	}
	else
	if ( lstrcmpiW ( type, L"CIM_SINT8 | CIM_FLAG_ARRAY" ) == 0 )
	{
		return CIM_SINT8 | CIM_FLAG_ARRAY;
	}
	else
	if ( lstrcmpiW ( type, L"CIM_UINT8 | CIM_FLAG_ARRAY" ) == 0 )
	{
		return CIM_UINT8 | CIM_FLAG_ARRAY;
	}
	else
	if ( lstrcmpiW ( type, L"CIM_SINT16 | CIM_FLAG_ARRAY" ) == 0 )
	{
		return CIM_SINT16 | CIM_FLAG_ARRAY;
	}
	else
	if ( lstrcmpiW ( type, L"CIM_UINT16 | CIM_FLAG_ARRAY" ) == 0 )
	{
		return CIM_UINT16 | CIM_FLAG_ARRAY;
	}
	else
	if ( lstrcmpiW ( type, L"CIM_SINT32 | CIM_FLAG_ARRAY" ) == 0 )
	{
		return CIM_SINT32 | CIM_FLAG_ARRAY;
	}
	else
	if ( lstrcmpiW ( type, L"CIM_UINT32 | CIM_FLAG_ARRAY" ) == 0 )
	{
		return CIM_UINT32 | CIM_FLAG_ARRAY;
	}
	else
	if ( lstrcmpiW ( type, L"CIM_SINT64 | CIM_FLAG_ARRAY" ) == 0 )
	{
		return CIM_SINT64 | CIM_FLAG_ARRAY;
	}
	else
	if ( lstrcmpiW ( type, L"CIM_UINT64 | CIM_FLAG_ARRAY" ) == 0 )
	{
		return CIM_UINT64 | CIM_FLAG_ARRAY;
	}
	else
	if ( lstrcmpiW ( type, L"CIM_REAL32 | CIM_FLAG_ARRAY" ) == 0 )
	{
		return CIM_REAL32 | CIM_FLAG_ARRAY;
	}
	else
	if ( lstrcmpiW ( type, L"CIM_REAL64 | CIM_FLAG_ARRAY" ) == 0 )
	{
		return CIM_REAL64 | CIM_FLAG_ARRAY;
	}
	else
	if ( lstrcmpiW ( type, L"CIM_BOOLEAN | CIM_FLAG_ARRAY" ) == 0 )
	{
		return CIM_BOOLEAN | CIM_FLAG_ARRAY;
	}
	else
	if ( lstrcmpiW ( type, L"CIM_STRING | CIM_FLAG_ARRAY" ) == 0 )
	{
		return CIM_STRING | CIM_FLAG_ARRAY;
	}
	else
	if ( lstrcmpiW ( type, L"CIM_DATETIME | CIM_FLAG_ARRAY" ) == 0 )
	{
		return CIM_DATETIME | CIM_FLAG_ARRAY;
	}
	else
	if ( lstrcmpiW ( type, L"CIM_REFERENCE | CIM_FLAG_ARRAY" ) == 0 )
	{
		return CIM_REFERENCE | CIM_FLAG_ARRAY;
	}
	else
	if ( lstrcmpiW ( type, L"CIM_CHAR16 | CIM_FLAG_ARRAY" ) == 0 )
	{
		return CIM_CHAR16 | CIM_FLAG_ARRAY;
	}
	else
	if ( lstrcmpiW ( type, L"CIM_OBJECT | CIM_FLAG_ARRAY" ) == 0 )
	{
		return CIM_OBJECT | CIM_FLAG_ARRAY;
	}

	return CIM_EMPTY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\noncomevent\_connect.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					_Connect.cpp
//
//	Abstract:
//
//					module for connect
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "PreComp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

#include <atlbase.h>

// connect
#include "_Connect.h"

// variables
MyConnect*	MyConnect::m_pConnect		= NULL;
HANDLE		MyConnect::m_hEventStart	= NULL;
HANDLE		MyConnect::m_hEventStop		= NULL;

LONG		MyConnect::m_lCount = 0L;

///////////////////////////////////////////////////////////////////////////////
//	default call back function
///////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI MyConnect::DefaultCallBack	(
												HANDLE /*hSource*/, 
												EVENT_SOURCE_MSG msg, 
												LPVOID /*pUser*/, 
												LPVOID /*pData*/
											)
{
	switch(msg)
	{
		case ESM_START_SENDING_EVENTS:
		{
			AtlTrace ( "ESM_START_SENDING_EVENTS \t ... \t 0x%08x\n", ::GetCurrentThreadId ( ) );
			break;
		}

		case ESM_STOP_SENDING_EVENTS:
		{
			AtlTrace ( "ESM_STOP_SENDING_EVENTS \t ... \t 0x%08x\n", ::GetCurrentThreadId ( ) );

			if ( m_hEventStart )
			{
				::ResetEvent ( m_hEventStart );
			}

			if ( m_hEventStop )
			{
				::SetEvent ( m_hEventStop );
			}

			break;
		}

		case ESM_NEW_QUERY:
		{
			if ( m_hEventStart )
			{
				::SetEvent ( m_hEventStart );
			}

			if ( m_hEventStop )
			{
				::ResetEvent ( m_hEventStop );
			}

			AtlTrace ( "ESM_NEW_QUERY \t ... \t 0x%08x\n", ::GetCurrentThreadId ( ) );
//			ES_NEW_QUERY *pQuery = (ES_NEW_QUERY*) pData;
			break;
		}

		case ESM_CANCEL_QUERY:
		{
			if ( m_hEventStart )
			{
				::ResetEvent ( m_hEventStart );
			}

			if ( m_hEventStop )
			{
				::SetEvent ( m_hEventStop );
			}

			AtlTrace ( "ESM_CANCEL_QUERY \t ... \t 0x%08x\n", ::GetCurrentThreadId ( ) );
//			ES_CANCEL_QUERY *pQuery = (ES_CANCEL_QUERY*) pData;
			break;
		}

		case ESM_ACCESS_CHECK:
		{
			AtlTrace ( "ESM_ACCESS_CHECK \t ... \t 0x%08x\n", ::GetCurrentThreadId ( ) );
//			ES_ACCESS_CHECK *pCheck = (ES_ACCESS_CHECK*) pData;
			break;
		}

		default:
			break;
	}

	return S_OK;
}

void MyConnect::ConnectInit ( void )
{
	__Smart_CRITICAL_SECTION;

	try
	{
		if ( m_hEventStart == NULL )
		{
			m_hEventStart = ::CreateEventW ( NULL, TRUE, FALSE, L"EventStart" );
		}

		if ( m_hEventStop == NULL )
		{
			m_hEventStop = ::CreateEventW ( NULL, TRUE, FALSE, L"EventStop" );
		}
	}
	catch ( ... )
	{
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\noncomevent\_log.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					_Log.cpp
//
//	Abstract:
//
//					module from CimNotify LOG
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "PreComp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

#include "_log.h"

HRESULT MyLog::Log ( LPWSTR wszName, HRESULT hrOld, DWORD dwCount, ... )
{
	if ( ! wszName )
	{
		return E_INVALIDARG;
	}

	HRESULT	hr		= E_FAIL;
	LPWSTR*	array	= NULL;

	if ( m_pNotify )
	{
		CComVariant varEmpty;
		CComVariant var;

		if ( dwCount )
		{
			va_list		list;
			va_start	( list, dwCount );

			try
			{
				if ( ( array = new LPWSTR [ dwCount ] ) == NULL )
				{
					hr = E_OUTOFMEMORY;
				}
				else
				{
					for ( DWORD dw = 0; dw < dwCount; dw++ )
					{
						LPWSTR wsz = NULL;
						wsz = va_arg ( list, LPWSTR );

						array [dw] = wsz;
					}

					hr = __SafeArray::LPWSTRToVariant ( array, dwCount, &var );
				}
			}
			catch ( ... )
			{
				hr = E_FAIL;
			}

			va_end ( list );
		}

		if SUCCEEDED ( hr )
		{
			hr = m_pNotify->Log ( CComBSTR ( wszName ), hrOld, &var, &varEmpty );
		}
	}
	#ifdef	__SUPPORT_FILE_LOG
	else
	{
		if ( m_hFile )
		{
			hr = S_OK;

			if ( dwCount )
			{
				va_list		list;
				va_start	( list, dwCount );

				try
				{
					if ( ( array = new LPWSTR [ dwCount ] ) == NULL )
					{
						hr = E_OUTOFMEMORY;
					}
					else
					{
						for ( DWORD dw = 0; dw < dwCount; dw++ )
						{
							LPWSTR wsz = NULL;
							wsz = va_arg ( list, LPWSTR );

							array [dw] = wsz;
						}
					}
				}
				catch ( ... )
				{
					hr = E_FAIL;
				}

				va_end ( list );
			}

			if ( SUCCEEDED ( hr ) && array )
			{
				hr = E_OUTOFMEMORY;

				LPSTR	buffer	= NULL;
				DWORD	dwBuffer= 0L;

				dwBuffer = lstrlenW ( wszName );

				if ( array )
				{
					for ( DWORD dw = 0; dw < dwCount; dw++ )
					{
						dwBuffer += 2; // space
						dwBuffer += lstrlenW ( array [ dw ] + 1 );
					}
				}

				dwBuffer += 3; // \r\n

				if ( ( buffer = new char [ dwBuffer ] ) != NULL )
				{
					USES_CONVERSION;

					lstrcpyA ( buffer, W2A ( wszName ) );

					if ( array )
					{
						for ( DWORD dw = 0; dw < dwCount; dw++ )
						{
							lstrcatA ( buffer, " " );
							lstrcatA ( buffer, W2A ( array [ dw ] ) );
						}
					}

					// add new line
					lstrcatA ( buffer, "\r\n" );

					DWORD dwWritten = 0L;

					::WriteFile (	m_hFile,
									buffer,
									dwBuffer,
									&dwWritten,
									NULL
								);

					delete [] buffer;
					buffer = NULL;
				}
			}
		}
	}
	#endif	__SUPPORT_FILE_LOG

	if ( array )
	{
		delete [] array;
		array = NULL;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\noncomevent\_eventobject.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					_EventObject.cpp
//
//	Abstract:
//
//					module for abstract event object
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "PreComp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// extern variables
extern LPWSTR	g_szQueryLang		;
extern LPWSTR	g_szQueryClass		;
extern LPWSTR	g_szQueryEvents		;
extern LPWSTR	g_szQuery			;
extern LPWSTR	g_szQueryNamespace	;

extern LPWSTR	g_szNamespaceRoot	;
extern LPWSTR	g_szProviderName	;

#include "_Connect.h"
#include "_EventObject.h"

#include "Enumerator.h"

MyEventObjectAbstract::MyEventObjectAbstract() :

wszName ( NULL ),
wszNameShow ( NULL ),
wszQuery ( NULL )
{
}

HRESULT MyEventObjectAbstract::Init ( LPWSTR wName, LPWSTR wNameShow, LPWSTR wQuery )
{
	if ( ! wName )
	{
		return E_INVALIDARG;
	}

	// just for case
	Uninit();

	try
	{
		if ( ( wszName = new WCHAR [ lstrlenW ( wName ) + 1 ] ) != NULL )
		{
			lstrcpyW ( wszName, wName );
		}

		if ( wNameShow )
		{
			if ( ( wszNameShow = new WCHAR [ lstrlenW ( wNameShow ) + 1 ] ) != NULL )
			{
				lstrcpyW ( wszNameShow, wNameShow );
			}
		}
		else
		{
			if ( ( wszNameShow = new WCHAR [ lstrlenW ( wName ) + 1 ] ) != NULL )
			{
				lstrcpyW ( wszNameShow, wName );
			}
		}

		if ( ! wQuery )
		{
			CComBSTR	bQuery	 = g_szQuery;
			bQuery				+= wName;

			if ( ( wszQuery = new WCHAR [ bQuery.Length() + 1 ] ) != NULL )
			{
				lstrcpyW ( wszQuery, bQuery );
			}
		}
		else
		{
			if ( ( wszQuery = new WCHAR [ lstrlenW ( wQuery ) + 1 ] ) != NULL )
			{
				lstrcpyW ( wszQuery, wQuery );
			}
		}
	}
	catch ( ... )
	{
		return E_UNEXPECTED;
	}

	return S_OK;
}

HRESULT MyEventObject::Init	( LPWSTR Name, LPWSTR NameShow , LPWSTR Query )
{
	HRESULT hr = S_OK;

	hr = MyEventObjectAbstract::Init ( Name, NameShow, Query );

	if SUCCEEDED ( hr )
	return InitInternal ();

	return hr;
}

HRESULT MyEventObject::InitObject	( LPWSTR Namespace, LPWSTR Provider )
{
	HRESULT hRes = S_OK;

	try
	{
		if ( Namespace )
		{
			if ( ( m_wszNamespace = new WCHAR [ lstrlenW ( Namespace ) + 1 ] ) != NULL )
			{
				lstrcpyW ( m_wszNamespace, Namespace );
			}
			else
			{
				hRes = E_OUTOFMEMORY;
				goto myError;
			}
		}
		else
		{
			if ( ( m_wszNamespace = new WCHAR [ lstrlenW ( g_szNamespaceRoot ) + 1 ] ) != NULL )
			{
				lstrcpyW ( m_wszNamespace, g_szNamespaceRoot );
			}
			else
			{
				hRes = E_OUTOFMEMORY;
				goto myError;
			}
		}

		if ( Provider )
		{
			if ( ( m_wszProvider = new WCHAR [ lstrlenW ( Provider ) + 1 ] ) != NULL )
			{
				lstrcpyW ( m_wszProvider, Provider );
			}
			else
			{
				hRes = E_OUTOFMEMORY;
				goto myError;
			}
		}
		else
		{
			if ( ( m_wszProvider = new WCHAR [ lstrlenW ( g_szProviderName ) + 1 ] ) != NULL )
			{
				lstrcpyW ( m_wszProvider, g_szProviderName );
			}
			else
			{
				hRes = E_OUTOFMEMORY;
				goto myError;
			}
		}
	}
	catch ( ... )
	{
		hRes =  E_UNEXPECTED;
	}

	myError:

	if FAILED ( hRes )
	{
		if ( m_wszNamespace )
		{
			delete [] m_wszNamespace;
			m_wszNamespace = NULL;
		}

		if ( m_wszProvider )
		{
			delete [] m_wszProvider;
			m_wszProvider;
		}
	}

	return hRes;
}

HRESULT MyEventObject::InitInternal	( void )
{
	HRESULT hr = S_OK;

	if ( ! m_properties.IsEmpty () )
	{
		m_properties.DestroyARRAY ();
	}

	m_pNames.DestroyARRAY ();
	m_pTypes.DestroyARRAY ();

	// go across all properties :-))

	if ( lstrcmpiW ( wszName, L"MSFT_WMI_GenericNonCOMEvent" ) == 0 )
	{
		m_bProps = false;
		return S_OK;
	}

	CComBSTR wszQuery = g_szQueryEvents;

	wszQuery += L"\"";
	wszQuery += wszName;
	wszQuery += L"\"";

	CEnumerator Enum ( m_pLocator );
	Enum.Init ( m_wszNamespace, g_szQueryLang, wszQuery );

	DWORD dwSize = 0L;

	try
	{
		if SUCCEEDED ( hr = Enum.Next ( &dwSize, &m_pNames, &m_pTypes ) )
		{
			m_pNames.SetData ( NULL, dwSize );
			m_pTypes.SetData ( NULL, dwSize );

			m_bProps = true;
		}
		else
			m_bProps = false;
	}
	catch ( ... )
	{
		if ( ! m_properties.IsEmpty () )
		{
			m_properties.DestroyARRAY ();
		}

		m_pNames.DestroyARRAY ();
		m_pTypes.DestroyARRAY ();

		m_bProps = false;

		hr = E_FAIL;
	}

	return hr;
}

HRESULT MyEventObject::ObjectLocator	( BOOL b )
{
	if ( b )
	{
		HRESULT hr = S_OK;
		
		hr = ::CoCreateInstance	(	__uuidof ( WbemLocator ),
									NULL,
									CLSCTX_INPROC_SERVER,
									__uuidof ( IWbemLocator ),
									( void** ) &m_pLocator
								);

		#ifdef	_DEBUG
		if FAILED ( hr )
		{
			ERRORMESSAGE_DEFINITION;
			ERRORMESSAGE ( hr );
		}
		#endif	_DEBUG

		return hr;
	}
	else
	{
		if ( m_pLocator )
		{
			m_pLocator.Release();

			return S_OK;
		}

		return S_FALSE;
	}
}

HRESULT	MyEventObject::CreateObject ( HANDLE hConnect, DWORD dwFlags )
{
	if ( ! wszName )
	{
		return E_UNEXPECTED;
	}

	if ( hConnect )
	{
		// clear previous data
		DestroyObject();

		if ( ( m_hEventObject = WmiCreateObject ( hConnect, wszName, dwFlags ) ) == NULL )
		{
			return E_FAIL;
		}

		::WaitForSingleObject ( MyConnect::m_hEventStart, 3000 );

		return S_OK;
	}

	return E_INVALIDARG;
}

HRESULT	MyEventObject::CreateObjectFormat ( HANDLE hConnect, DWORD dwFlags )
{
	if ( ! wszName || ! m_bProps )
	{
		return E_UNEXPECTED;
	}

	if ( hConnect )
	{
		// clear previous data
		DestroyObject();

		// create format from helpers
		CComBSTR wszFormat = NULL;

		for ( DWORD dwIndex = 0; dwIndex < ( DWORD ) m_pNames; dwIndex++ )
		{
			wszFormat += m_pNames [ dwIndex ];
			wszFormat += L"!";

			// add type
			switch ( m_pTypes [ dwIndex ] )
			{
				case CIM_SINT8:
				{
					wszFormat += L"c";
				}
				break;

				case CIM_UINT8:
				{
					wszFormat += L"c";
				}
				break;

				case CIM_SINT16:
				{
					wszFormat += L"w";
				}
				break;

				case CIM_UINT16:
				{
					wszFormat += L"w";
				}
				break;

				case CIM_SINT32:
				{
					wszFormat += L"d";
				}
				break;

				case CIM_UINT32:
				{
					wszFormat += L"u";
				}
				break;

				case CIM_REAL32:
				{
					wszFormat += L"f";
				}
				break;

				case CIM_REAL64:
				{
					wszFormat += L"g";
				}
				break;

				case CIM_SINT64:
				{
					wszFormat += L"I64d";
				}
				break;

				case CIM_UINT64:
				{
					wszFormat += L"I64u";
				}
				break;

				case CIM_BOOLEAN:
				{
					wszFormat += L"b";
				}
				break;

				case CIM_STRING:
				{
					wszFormat += L"s";
				}
				break;

				case CIM_SINT8 | CIM_FLAG_ARRAY:
				{
					wszFormat += L"c[]";
				}
				break;

				case CIM_UINT8 | CIM_FLAG_ARRAY:
				{
					wszFormat += L"c[]";
				}
				break;

				case CIM_SINT16 | CIM_FLAG_ARRAY:
				{
					wszFormat += L"w[]";
				}
				break;

				case CIM_UINT16 | CIM_FLAG_ARRAY:
				{
					wszFormat += L"w[]";
				}
				break;

				case CIM_SINT32 | CIM_FLAG_ARRAY:
				{
					wszFormat += L"d[]";
				}
				break;

				case CIM_UINT32 | CIM_FLAG_ARRAY:
				{
					wszFormat += L"u[]";
				}
				break;

				case CIM_REAL32 | CIM_FLAG_ARRAY:
				{
					wszFormat += L"f[]";
				}
				break;

				case CIM_REAL64 | CIM_FLAG_ARRAY:
				{
					wszFormat += L"g[]";
				}
				break;

				case CIM_SINT64 | CIM_FLAG_ARRAY:
				{
					wszFormat += L"I64d[]";
				}
				break;

				case CIM_UINT64 | CIM_FLAG_ARRAY:
				{
					wszFormat += L"I64u[]";
				}
				break;

				case CIM_BOOLEAN | CIM_FLAG_ARRAY:
				{
					wszFormat += L"b[]";
				}
				break;

				case CIM_STRING | CIM_FLAG_ARRAY:
				{
					wszFormat += L"s[]";
				}
				break;

				case CIM_CHAR16:
				{
					wszFormat += L"w";
				}
				break;

				case CIM_CHAR16 | CIM_FLAG_ARRAY:
				{
					wszFormat += L"w[]";
				}
				break;

				case CIM_DATETIME:
				{
					wszFormat += L"s";
				}
				break;

				case CIM_DATETIME | CIM_FLAG_ARRAY:
				{
					wszFormat += L"s[]";
				}
				break;

				case CIM_REFERENCE:
				{
					wszFormat += L"s";
				}
				break;

				case CIM_REFERENCE | CIM_FLAG_ARRAY:
				{
					wszFormat += L"s[]";
				}
				break;

				case CIM_OBJECT:
				{
					wszFormat += L"o";
				}
				break;

				case CIM_OBJECT | CIM_FLAG_ARRAY:
				{
					wszFormat += L"o[]";
				}
				break;
			}

			wszFormat += L"! ";
		}

		if ( ( m_hEventObject = WmiCreateObjectWithFormat ( hConnect, wszName, dwFlags, wszFormat ) ) == NULL )
		{
			return E_FAIL;
		}

		for ( DWORD dw = 0; dw < ( DWORD ) m_pNames; dw++ )
		{
			MyEventProperty* pProp = NULL;

			try
			{
				if ( ( pProp = new MyEventProperty ( m_pNames [ dw ], m_pTypes [ dw ] ) ) != NULL )
				{
					m_properties.DataAdd ( pProp );
				}
			}
			catch ( ... )
			{
			}
		}

		::WaitForSingleObject ( MyConnect::m_hEventStart, 3000 );

		return S_OK;
	}

	return E_INVALIDARG;
}

HRESULT	MyEventObject::CreateObjectFormat ( HANDLE hConnect, LPCWSTR wszFormat, DWORD dwFlags )
{
	if ( ! wszName )
	{
		return E_UNEXPECTED;
	}

	if ( hConnect )
	{
		// clear previous data
		DestroyObject();

		if ( ( m_hEventObject = WmiCreateObjectWithFormat ( hConnect, wszName, dwFlags, wszFormat ) ) == NULL )
		{
			return E_FAIL;
		}

		::WaitForSingleObject ( MyConnect::m_hEventStart, 3000 );

		return S_OK;
	}

	return E_INVALIDARG;
}

HRESULT	MyEventObject::CreateObjectProps	(	HANDLE hConnect,
												DWORD dwFlags
											)
{
	if ( ! wszName || ! m_bProps )
	{
		return E_UNEXPECTED;
	}

	if ( hConnect )
	{
		// clear previous data
		DestroyObject();

		LPCWSTR* pProps		= const_cast<LPCWSTR*> ( (LPWSTR*) m_pNames );
		CIMTYPE* pctProps	= (CIMTYPE*) m_pTypes;

		if ( ( m_hEventObject = WmiCreateObjectWithProps	(	hConnect,
																wszName,
																dwFlags,
																(DWORD) m_pNames,
																pProps,
																pctProps
															)
			 ) == NULL )
		{
			return E_FAIL;
		}

		for ( DWORD dw = 0; dw < ( DWORD ) m_pNames; dw++ )
		{
			MyEventProperty* pProp = NULL;

			try
			{
				if ( ( pProp = new MyEventProperty ( m_pNames [ dw ], m_pTypes [ dw ] ) ) != NULL )
				{
					m_properties.DataAdd ( pProp );
				}
			}
			catch ( ... )
			{
			}
		}

		::WaitForSingleObject ( MyConnect::m_hEventStart, 3000 );

		return S_OK;
	}

	return E_INVALIDARG;
}

HRESULT	MyEventObject::CreateObjectProps	(	HANDLE hConnect,
												DWORD dwProps,
												LPCWSTR* pProps,
												CIMTYPE* pctProps,
												DWORD dwFlags
											)
{
	if ( ! wszName )
	{
		return E_UNEXPECTED;
	}

	if ( hConnect )
	{
		// clear previous data
		DestroyObject();

		if ( ( m_hEventObject = WmiCreateObjectWithProps	(	hConnect,
																wszName,
																dwFlags,
																dwProps,
																pProps,
																pctProps
															)
			 ) == NULL )
		{
			return E_FAIL;
		}

		for ( DWORD dw = 0; dw < dwProps; dw++ )
		{
			MyEventProperty* pProp = NULL;

			try
			{
				if ( ( pProp = new MyEventProperty ( const_cast < LPWSTR > ( pProps [ dw ] ), pctProps [ dw ] ) ) != NULL )
				{
					m_properties.DataAdd ( pProp );
				}
			}
			catch ( ... )
			{
			}
		}

		::WaitForSingleObject ( MyConnect::m_hEventStart, 3000 );

		return S_OK;
	}

	return E_INVALIDARG;
}

////////////////////////////////////////////////////////////////////////////////////
//	properties
////////////////////////////////////////////////////////////////////////////////////

HRESULT	MyEventObject::PropertiesAdd ( void )
{
	HRESULT hr = S_OK;

	if ( ! m_bProps || ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	for ( DWORD dw = 0; dw < (DWORD) m_pNames; dw++ )
	{
		if FAILED ( hr = PropertyAdd ( dw ) )
		{
			break;
		}
	}

	if FAILED ( hr )
	{
		m_properties.DestroyARRAY ();
	}

	return hr;
}

HRESULT	MyEventObject::PropertyAdd ( void )
{
	static DWORD dw = 0;

	if ( dw < ( DWORD ) m_pNames )
	{
		HRESULT hr = S_OK;
		hr = PropertyAdd ( dw );

		if ( hr == S_OK )
		{
			if ( ++dw == ( DWORD ) m_pNames )
			{
				dw = 0;
				hr = S_FALSE;
			}
		}
		else

		if ( hr == S_FALSE )
		{
			hr = E_FAIL;
		}

		return hr;
	}

	dw = 0;
	return S_FALSE;
}

HRESULT	MyEventObject::PropertyAdd ( DWORD dwIndex, DWORD* pdwIndex )
{
	if ( ! m_bProps || ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	try
	{
		if ( dwIndex < ( DWORD ) m_pNames && dwIndex < ( DWORD ) m_pTypes )
		{
			DWORD	dw		= 0L;
			BOOL	bResult	= FALSE;

			bResult = ( WmiAddObjectProp ( m_hEventObject, m_pNames [ dwIndex ] , m_pTypes [ dwIndex ], &dw ) );

			if ( pdwIndex )
			{
				( * pdwIndex ) = dw;
			}

			if ( bResult )
			{
				MyEventProperty* pProp = NULL;

				try
				{
					if ( ( pProp = new MyEventProperty ( m_pNames [ dwIndex ], m_pTypes [ dwIndex ] ) ) != NULL )
					{
						m_properties.DataAdd ( pProp );
					}
				}
				catch ( ... )
				{
				}
			}

			return ( ( bResult ) ? S_OK : S_FALSE );
		}
	}
	catch ( ... )
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT	MyEventObject::PropertyAdd ( LPCWSTR wszPropName, CIMTYPE type, DWORD* pdwIndex )
{
	if ( ! m_hEventObject )
	{
		return E_FAIL;
	}

	if ( ! wszName || ( type == CIM_ILLEGAL ) || ( type == CIM_EMPTY ) )
	{
		return E_INVALIDARG;
	}

	DWORD	dwIndex = 0L;
	BOOL	bResult	= FALSE;

	bResult = ( WmiAddObjectProp ( m_hEventObject, wszPropName, type, &dwIndex ) );

	if ( pdwIndex )
	{
		( * pdwIndex ) = dwIndex;
	}

	if ( bResult )
	{
		MyEventProperty* pProp = NULL;

		try
		{
			if ( ( pProp = new MyEventProperty ( const_cast < LPWSTR > ( wszPropName ), type ) ) != NULL )
			{
				m_properties.DataAdd ( pProp );
			}
		}
		catch ( ... )
		{
		}
	}

	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::PropertySet	 ( DWORD dwIndex )
{
	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	BOOL	bResult = FALSE;
	bResult = WmiSetObjectPropNull ( m_hEventObject, dwIndex );

	if ( bResult && dwIndex < ( DWORD ) m_properties )
	{
		VARIANT var;
		::VariantInit ( & var );

		switch ( m_properties [ dwIndex ] -> GetType () )
		{
			case CIM_SINT8:
			{
				V_VT ( & var )	= VT_I1;
				V_I1 ( & var )	= 0;
			}
			break;

			case CIM_UINT8:
			{
				V_VT ( & var )	= VT_UI1;
				V_UI1 ( & var )	= 0;
			}
			break;

			case CIM_SINT16:
			{
				V_VT ( & var )	= VT_I2;
				V_I2 ( & var )	= 0;
			}
			break;

			case CIM_UINT16:
			{
				V_VT ( & var )	= VT_UI2;
				V_UI2 ( & var )	= 0;
			}
			break;

			case CIM_SINT32:
			{
				V_VT ( & var )	= VT_I4;
				V_I4 ( & var )	= 0;
			}
			break;

			case CIM_UINT32:
			{
				V_VT ( & var )	= VT_UI4;
				V_UI4 ( & var )	= 0;
			}
			break;

			case CIM_SINT64:
			{
				V_VT ( & var )	= VT_BSTR;
				V_BSTR ( & var )	= 0;
			}
			break;

			case CIM_UINT64:
			{
				V_VT ( & var )	= VT_BSTR;
				V_BSTR ( & var )	= 0;
			}
			break;

			case CIM_REAL32:
			{
				V_VT ( & var )	= VT_R4;
				V_R4 ( & var )	= 0;
			}
			break;

			case CIM_REAL64:
			{
				V_VT ( & var )	= VT_R8;
				V_R8 ( & var )	= 0;
			}
			break;

			case CIM_BOOLEAN:
			{
				V_VT ( & var )	= VT_BOOL;
				V_BOOL ( & var )	= 0;
			}
			break;

			case CIM_STRING:
			{
				V_VT ( & var )	= VT_BSTR;
				V_BSTR ( & var )	= 0;
			}
			break;

			case CIM_SINT8 | CIM_FLAG_ARRAY :
			{
				V_VT	( & var )	= VT_ARRAY | VT_I1;
				V_ARRAY	( & var )	= 0;
			}
			break;

			case CIM_UINT8 | CIM_FLAG_ARRAY :
			{
				V_VT	( & var )	= VT_ARRAY | VT_UI1;
				V_ARRAY	( & var )	= 0;
			}
			break;

			case CIM_SINT16 | CIM_FLAG_ARRAY :
			{
				V_VT	( & var )	= VT_ARRAY | VT_I2;
				V_ARRAY	( & var )	= 0;
			}
			break;

			case CIM_UINT16 | CIM_FLAG_ARRAY :
			{
				V_VT	( & var )	= VT_ARRAY | VT_UI2;
				V_ARRAY	( & var )	= 0;
			}
			break;

			case CIM_SINT32 | CIM_FLAG_ARRAY :
			{
				V_VT	( & var )	= VT_ARRAY | VT_I4;
				V_ARRAY	( & var )	= 0;
			}
			break;

			case CIM_UINT32 | CIM_FLAG_ARRAY :
			{
				V_VT	( & var )	= VT_ARRAY | VT_UI4;
				V_ARRAY	( & var )	= 0;
			}
			break;

			case CIM_SINT64 | CIM_FLAG_ARRAY :
			{
				V_VT	( & var )	= VT_ARRAY | VT_BSTR;
				V_ARRAY	( & var )	= 0;
			}
			break;

			case CIM_UINT64 | CIM_FLAG_ARRAY :
			{
				V_VT	( & var )	= VT_ARRAY | VT_BSTR;
				V_ARRAY	( & var )	= 0;
			}
			break;

			case CIM_REAL32 | CIM_FLAG_ARRAY :
			{
				V_VT	( & var )	= VT_ARRAY | VT_R4;
				V_ARRAY	( & var )	= 0;
			}
			break;

			case CIM_REAL64 | CIM_FLAG_ARRAY :
			{
				V_VT	( & var )	= VT_ARRAY | VT_R8;
				V_ARRAY	( & var )	= 0;
			}
			break;

			case CIM_BOOLEAN | CIM_FLAG_ARRAY :
			{
				V_VT	( & var )	= VT_ARRAY | VT_BOOL;
				V_ARRAY	( & var )	= 0;
			}
			break;

			case CIM_STRING | CIM_FLAG_ARRAY :
			{
				V_VT	( & var )	= VT_ARRAY | VT_BSTR;
				V_ARRAY	( & var )	= 0;
			}
			break;

		}

		m_properties [ dwIndex ] -> SetValue ( var );
		::VariantClear ( & var );
	}

	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::PropertySetWCHAR	 ( DWORD dwIndex, WCHAR Val )
{
	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	BOOL	bResult = FALSE;
	bResult = WmiSetObjectProp ( m_hEventObject, dwIndex, Val );

	if ( bResult && dwIndex < ( DWORD ) m_properties )
	{
		m_properties [ dwIndex ] -> SetValue ( CComVariant ( ( short ) Val ) );
	}

	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::PropertySetWCHAR	 ( DWORD dwIndex, DWORD dwSize, WCHAR* Val )
{
	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	BOOL	bResult = FALSE;
	bResult = WmiSetObjectProp ( m_hEventObject, dwIndex, Val, dwSize );

	if ( bResult && dwIndex < ( DWORD ) m_properties )
	{
		CComVariant var;
		if SUCCEEDED ( __SafeArray::USHORTToVariant ( Val, dwSize, &var ) )
		{
			m_properties [ dwIndex ] -> SetValue ( var );
		}
	}

	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::PropertySetDATETIME	 ( DWORD dwIndex, LPCWSTR Val )
{
	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	BOOL	bResult = FALSE;
	bResult = WmiSetObjectProp ( m_hEventObject, dwIndex, Val );

	if ( bResult && dwIndex < ( DWORD ) m_properties )
	{
		m_properties [ dwIndex ] -> SetValue ( CComVariant ( ( LPCWSTR ) Val ) );
	}

	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::PropertySetDATETIME	 ( DWORD dwIndex, DWORD dwSize, LPCWSTR* Val )
{
	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	BOOL	bResult = FALSE;
	bResult = WmiSetObjectProp ( m_hEventObject, dwIndex, Val, dwSize );

	if ( bResult && dwIndex < ( DWORD ) m_properties )
	{
		CComVariant var;
		if SUCCEEDED ( __SafeArray::LPWSTRToVariant ( const_cast < LPWSTR* > ( Val ), dwSize, &var ) )
		{
			m_properties [ dwIndex ] -> SetValue ( var );
		}
	}

	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::PropertySetREFERENCE	 ( DWORD dwIndex, LPCWSTR Val )
{
	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	BOOL	bResult = FALSE;
	bResult = WmiSetObjectProp ( m_hEventObject, dwIndex, Val );

	if ( bResult && dwIndex < ( DWORD ) m_properties )
	{
		m_properties [ dwIndex ] -> SetValue ( CComVariant ( ( LPCWSTR ) Val ) );
	}

	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::PropertySetREFERENCE	 ( DWORD dwIndex, DWORD dwSize, LPCWSTR* Val )
{
	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	BOOL	bResult = FALSE;
	bResult = WmiSetObjectProp ( m_hEventObject, dwIndex, Val, dwSize );

	if ( bResult && dwIndex < ( DWORD ) m_properties )
	{
		CComVariant var;
		if SUCCEEDED ( __SafeArray::LPWSTRToVariant ( const_cast < LPWSTR* > ( Val ), dwSize, &var ) )
		{
			m_properties [ dwIndex ] -> SetValue ( var );
		}
	}

	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::PropertySetOBJECT	 ( DWORD dwIndex, void* Val )
{
	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	BOOL	bResult = FALSE;
	bResult = WmiSetObjectProp ( m_hEventObject, dwIndex, Val );

	if ( bResult && dwIndex < ( DWORD ) m_properties )
	{
		m_properties [ dwIndex ] -> SetValue ( CComVariant ( L" ... this only ... " ) );
	}

	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::PropertySetOBJECT	 ( DWORD dwIndex, DWORD dwSize, void** Val )
{
	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	BOOL	bResult = FALSE;
	bResult = WmiSetObjectProp ( m_hEventObject, dwIndex, Val, dwSize );

	if ( bResult && dwIndex < ( DWORD ) m_properties )
	{
		m_properties [ dwIndex ] -> SetValue ( CComVariant ( L" ... this only ... " ) );
	}

	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::PropertySet	 ( DWORD dwIndex, signed char Val )
{
	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	BOOL	bResult = FALSE;
	bResult = WmiSetObjectProp ( m_hEventObject, dwIndex, Val );

	if ( bResult && dwIndex < ( DWORD ) m_properties )
	{
		m_properties [ dwIndex ] -> SetValue ( CComVariant ( ( signed char ) Val ) );
	}

	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::PropertySet	 ( DWORD dwIndex, unsigned char Val )
{
	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	BOOL	bResult = FALSE;
	bResult = WmiSetObjectProp ( m_hEventObject, dwIndex, Val );

	if ( bResult && dwIndex < ( DWORD ) m_properties )
	{
		VARIANT v;

		::VariantInit ( & v );

		V_VT ( & v ) = VT_UI1;
		V_UI1( & v ) = Val;

		m_properties [ dwIndex ] -> SetValue ( v );

		::VariantClear ( & v );
	}

	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::PropertySet	 ( DWORD dwIndex, signed short Val )
{
	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	BOOL	bResult = FALSE;
	bResult = WmiSetObjectProp ( m_hEventObject, dwIndex, Val );

	if ( bResult && dwIndex < ( DWORD ) m_properties )
	{
		m_properties [ dwIndex ] -> SetValue ( CComVariant ( ( signed short ) Val ) );
	}

	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::PropertySet	 ( DWORD dwIndex, unsigned short Val )
{
	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	BOOL	bResult = FALSE;
	bResult = WmiSetObjectProp ( m_hEventObject, dwIndex, Val );

	if ( bResult && dwIndex < ( DWORD ) m_properties )
	{
		VARIANT v;

		::VariantInit ( & v );

		V_VT ( & v ) = VT_UI2;
		V_UI2( & v ) = Val;

		m_properties [ dwIndex ] -> SetValue ( v );

		::VariantClear ( & v );
	}

	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::PropertySet	 ( DWORD dwIndex, signed long Val )
{
	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	BOOL	bResult = FALSE;
	bResult = WmiSetObjectProp ( m_hEventObject, dwIndex, Val );

	if ( bResult && dwIndex < ( DWORD ) m_properties )
	{
		m_properties [ dwIndex ] -> SetValue ( CComVariant ( ( signed long ) Val, VT_I4 ) );
	}

	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::PropertySet	 ( DWORD dwIndex, unsigned long Val )
{
	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	BOOL	bResult = FALSE;
	bResult = WmiSetObjectProp ( m_hEventObject, dwIndex, Val );

	if ( bResult && dwIndex < ( DWORD ) m_properties )
	{
		VARIANT v;

		::VariantInit ( & v );

		V_VT ( & v ) = VT_UI4;
		V_UI4( & v ) = Val;

		m_properties [ dwIndex ] -> SetValue ( v );

		::VariantClear ( & v );
	}

	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::PropertySet	 ( DWORD dwIndex, float Val )
{
	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	BOOL	bResult = FALSE;
	bResult = WmiSetObjectProp ( m_hEventObject, dwIndex, Val );

	if ( bResult && dwIndex < ( DWORD ) m_properties )
	{
		m_properties [ dwIndex ] -> SetValue ( CComVariant ( Val ) );
	}

	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::PropertySet	 ( DWORD dwIndex, double Val )
{
	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	BOOL	bResult = FALSE;
	bResult = WmiSetObjectProp ( m_hEventObject, dwIndex, Val );

	if ( bResult && dwIndex < ( DWORD ) m_properties )
	{
		m_properties [ dwIndex ] -> SetValue ( CComVariant ( Val ) );
	}

	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::PropertySet	 ( DWORD dwIndex, signed __int64 Val )
{
	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	BOOL	bResult = FALSE;
	bResult = WmiSetObjectProp ( m_hEventObject, dwIndex, Val );

	if ( bResult && dwIndex < ( DWORD ) m_properties )
	{
		WCHAR wsz [ _MAX_PATH ] = { L'\0' };
		_ui64tow ( Val, wsz, 10 );

		m_properties [ dwIndex ] -> SetValue ( CComVariant ( wsz ) );
	}

	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::PropertySet	 ( DWORD dwIndex, unsigned __int64 Val )
{
	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	BOOL	bResult = FALSE;
	bResult = WmiSetObjectProp ( m_hEventObject, dwIndex, Val );

	if ( bResult && dwIndex < ( DWORD ) m_properties )
	{
		WCHAR wsz [ _MAX_PATH ] = { L'\0' };
		_i64tow ( ( signed __int64 ) Val, wsz, 10 );

		m_properties [ dwIndex ] -> SetValue ( CComVariant ( wsz ) );
	}

	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::PropertySet	 ( DWORD dwIndex, BOOL Val )
{
	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	BOOL	bResult = FALSE;
	bResult = WmiSetObjectProp ( m_hEventObject, dwIndex, (WORD) Val );

	if ( bResult && dwIndex < ( DWORD ) m_properties )
	{
		m_properties [ dwIndex ] -> SetValue ( CComVariant ( Val ) );
	}

	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::PropertySet	 ( DWORD dwIndex, LPCWSTR Val )
{
	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	BOOL	bResult = FALSE;
	bResult = WmiSetObjectProp ( m_hEventObject, dwIndex, Val );

	if ( bResult && dwIndex < ( DWORD ) m_properties )
	{
		m_properties [ dwIndex ] -> SetValue ( CComVariant ( Val ) );
	}

	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::PropertySet	 ( DWORD dwIndex, DWORD dwSize, signed char* Val )
{
	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	BOOL	bResult = FALSE;
	bResult = WmiSetObjectProp ( m_hEventObject, dwIndex, Val, dwSize );

	if ( bResult && dwIndex < ( DWORD ) m_properties )
	{
		CComVariant var;
		if SUCCEEDED ( __SafeArray::CHARToVariant ( Val, dwSize, &var ) )
		{
			m_properties [ dwIndex ] -> SetValue ( var );
		}
	}

	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::PropertySet	 ( DWORD dwIndex, DWORD dwSize, unsigned char* Val )
{
	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	BOOL	bResult = FALSE;
	bResult = WmiSetObjectProp ( m_hEventObject, dwIndex, Val, dwSize );

	if ( bResult && dwIndex < ( DWORD ) m_properties )
	{
		CComVariant var;
		if SUCCEEDED ( __SafeArray::UCHARToVariant ( Val, dwSize, &var ) )
		{
			m_properties [ dwIndex ] -> SetValue ( var );
		}
	}

	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::PropertySet	 ( DWORD dwIndex, DWORD dwSize, signed short * Val )
{
	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	BOOL	bResult = FALSE;
	bResult = WmiSetObjectProp ( m_hEventObject, dwIndex, Val, dwSize );

	if ( bResult && dwIndex < ( DWORD ) m_properties )
	{
		CComVariant var;
		if SUCCEEDED ( __SafeArray::SHORTToVariant ( Val, dwSize, &var ) )
		{
			m_properties [ dwIndex ] -> SetValue ( var );
		}
	}

	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::PropertySet	 ( DWORD dwIndex, DWORD dwSize, unsigned short * Val )
{
	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	BOOL	bResult = FALSE;
	bResult = WmiSetObjectProp ( m_hEventObject, dwIndex, Val, dwSize );

	if ( bResult && dwIndex < ( DWORD ) m_properties )
	{
		CComVariant var;
		if SUCCEEDED ( __SafeArray::USHORTToVariant ( Val, dwSize, &var ) )
		{
			m_properties [ dwIndex ] -> SetValue ( var );
		}
	}

	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::PropertySet	 ( DWORD dwIndex, DWORD dwSize, signed long * Val )
{
	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	BOOL	bResult = FALSE;
	bResult = WmiSetObjectProp ( m_hEventObject, dwIndex, Val, dwSize );

	if ( bResult && dwIndex < ( DWORD ) m_properties )
	{
		CComVariant var;
		if SUCCEEDED ( __SafeArray::LONGToVariant ( Val, dwSize, &var ) )
		{
			m_properties [ dwIndex ] -> SetValue ( var );
		}
	}

	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::PropertySet	 ( DWORD dwIndex, DWORD dwSize, unsigned long * Val )
{
	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	BOOL	bResult = FALSE;
	bResult = WmiSetObjectProp ( m_hEventObject, dwIndex, Val, dwSize );

	if ( bResult && dwIndex < ( DWORD ) m_properties )
	{
		CComVariant var;
		if SUCCEEDED ( __SafeArray::ULONGToVariant ( Val, dwSize, &var ) )
		{
			m_properties [ dwIndex ] -> SetValue ( var );
		}
	}

	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::PropertySet	 ( DWORD dwIndex, DWORD dwSize, float * Val )
{
	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	BOOL	bResult = FALSE;
	bResult = WmiSetObjectProp ( m_hEventObject, dwIndex, Val, dwSize );

	if ( bResult && dwIndex < ( DWORD ) m_properties )
	{
		CComVariant var;
		if SUCCEEDED ( __SafeArray::FLOATToVariant ( Val, dwSize, &var ) )
		{
			m_properties [ dwIndex ] -> SetValue ( var );
		}
	}

	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::PropertySet	 ( DWORD dwIndex, DWORD dwSize, double * Val )
{
	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	BOOL	bResult = FALSE;
	bResult = WmiSetObjectProp ( m_hEventObject, dwIndex, Val, dwSize );

	if ( bResult && dwIndex < ( DWORD ) m_properties )
	{
		CComVariant var;
		if SUCCEEDED ( __SafeArray::DOUBLEToVariant ( Val, dwSize, &var ) )
		{
			m_properties [ dwIndex ] -> SetValue ( var );
		}
	}

	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::PropertySet	 ( DWORD dwIndex, DWORD dwSize, signed __int64 * Val )
{
	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	BOOL	bResult = FALSE;
	bResult = WmiSetObjectProp ( m_hEventObject, dwIndex, Val, dwSize );

	if ( bResult && dwIndex < ( DWORD ) m_properties )
	{
		CComVariant var;
		if SUCCEEDED ( __SafeArray::I64ToVariant ( Val, dwSize, &var ) )
		{
			m_properties [ dwIndex ] -> SetValue ( var );
		}
	}

	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::PropertySet	 ( DWORD dwIndex, DWORD dwSize, unsigned __int64 * Val )
{
	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	BOOL	bResult = FALSE;
	bResult = WmiSetObjectProp ( m_hEventObject, dwIndex, Val, dwSize );

	if ( bResult && dwIndex < ( DWORD ) m_properties )
	{
		CComVariant var;
		if SUCCEEDED ( __SafeArray::UI64ToVariant ( Val, dwSize, &var ) )
		{
			m_properties [ dwIndex ] -> SetValue ( var );
		}
	}

	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::PropertySet	 ( DWORD dwIndex, DWORD dwSize, BOOL * Val )
{
	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	BOOL	bResult = FALSE;
	WORD *	pb		= NULL;

	try
	{
		if ( ( pb = new WORD [dwSize] ) != NULL )
		{
			for ( DWORD dw = 0; dw < dwSize; dw ++ )
			{
				pb [ dw ] = (WORD) Val [ dw ] ;
			}

			bResult = WmiSetObjectProp ( m_hEventObject, dwIndex, pb, dwSize );

			delete [] pb;
			pb = NULL;
		}
	}
	catch ( ... )
	{
		if ( pb )
		{
			delete [] pb;
			pb = NULL;
		}
	}

	if ( bResult && dwIndex < ( DWORD ) m_properties )
	{
		CComVariant var;
		if SUCCEEDED ( __SafeArray::BOOLToVariant ( Val, dwSize, &var ) )
		{
			m_properties [ dwIndex ] -> SetValue ( var );
		}
	}

	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::PropertySet	 ( DWORD dwIndex, DWORD dwSize, LPCWSTR * Val )
{
	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	BOOL	bResult = FALSE;
	bResult = WmiSetObjectProp ( m_hEventObject, dwIndex, Val, dwSize );

	if ( bResult && dwIndex < ( DWORD ) m_properties )
	{
		CComVariant var;
		if SUCCEEDED ( __SafeArray::LPWSTRToVariant ( const_cast < LPWSTR* > ( Val ), dwSize, &var ) )
		{
			m_properties [ dwIndex ] -> SetValue ( var );
		}
	}

	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::SetCommit	 ( DWORD dwFlags, ... )
{
	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	BOOL	bResult = FALSE;

	va_list		list;
	va_start	( list, dwFlags );
	bResult = WmiSetAndCommitObject ( m_hEventObject, dwFlags | WMI_USE_VA_LIST, &list );
	va_end		( list );

	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::SetAddCommit	 (	DWORD dwFlags,
										DWORD dwProps,
										LPCWSTR* pProps,
										CIMTYPE* pctProps,

										... )
{
	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	for ( DWORD dw = 0; dw < dwProps; dw++ )
	{
		PropertyAdd ( pProps [ dw ], pctProps [ dw ] );
	}

	BOOL	bResult = FALSE;

	va_list		list;
	va_start	( list, pctProps );
	bResult = WmiSetAndCommitObject ( m_hEventObject, dwFlags | WMI_USE_VA_LIST, &list );
	va_end		( list );

	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::PropertiesSet1	(	HANDLE hConnect,
											unsigned char cVal,
											unsigned short sVal,
											unsigned long lVal,
											float fVal,
											DWORD64 dVal,
											LPWSTR szVal,
											BOOL bVal
										)
{
	LPWSTR  pProps [] = { L"CIM_SINT8", L"CIM_UINT16", L"CIM_UINT32", L"CIM_REAL32", L"CIM_UINT64", L"CIM_STRING", L"CIM_BOOLEAN" };
	CIMTYPE tProps [] = { CIM_SINT8, CIM_UINT16, CIM_UINT32, CIM_REAL32, CIM_UINT64, CIM_STRING, CIM_BOOLEAN };

	m_bProps = TRUE;

	CreateObjectProps ( hConnect, 7, (LPCWSTR*) pProps, tProps );

	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	BOOL	bResult = FALSE;
	bResult = WmiSetObjectProps ( m_hEventObject, cVal, sVal, lVal, fVal, dVal, szVal, (WORD) bVal );
	return ( ( bResult ) ? S_OK : S_FALSE );
}

HRESULT	MyEventObject::PropertiesSet2	(	HANDLE hConnect,
											DWORD dwSize,
											unsigned char *cVal,
											unsigned short *sVal,
											unsigned long *lVal,
											float *fVal,
											DWORD64 *dVal,
											LPWSTR *szVal,
											BOOL *bVal
										)
{
	LPWSTR  pProps [] = { 
							L"CIM_SINT8 | CIM_FLAG_ARRAY", 
							L"CIM_UINT16 | CIM_FLAG_ARRAY", 
							L"CIM_UINT32 | CIM_FLAG_ARRAY", 
							L"CIM_REAL32 | CIM_FLAG_ARRAY", 
							L"CIM_UINT64 | CIM_FLAG_ARRAY", 
							L"CIM_STRING | CIM_FLAG_ARRAY", 
							L"CIM_BOOLEAN | CIM_FLAG_ARRAY" 
						};

	CIMTYPE tProps [] = { 
							CIM_SINT8 | CIM_FLAG_ARRAY, 
							CIM_UINT16 | CIM_FLAG_ARRAY, 
							CIM_UINT32 | CIM_FLAG_ARRAY, 
							CIM_REAL32 | CIM_FLAG_ARRAY, 
							CIM_UINT64 | CIM_FLAG_ARRAY, 
							CIM_STRING | CIM_FLAG_ARRAY, 
							CIM_BOOLEAN | CIM_FLAG_ARRAY 
						};

	m_bProps = TRUE;

	CreateObjectProps ( hConnect, 7, (LPCWSTR*) pProps, tProps );

	if ( ! m_hEventObject )
	{
		return E_UNEXPECTED;
	}

	BOOL	bResult	= FALSE;
	WORD *	pb		= NULL;

	try
	{
		if ( ( pb = new WORD [ dwSize ] ) != NULL )
		{
			for ( DWORD dw = 0; dw < dwSize; dw++ )
			{
				pb [ dw ] = (WORD) bVal [ dw ];
			}

			bResult = WmiSetObjectProps ( m_hEventObject, 
											cVal, dwSize,
											sVal, dwSize,
											lVal, dwSize,
											fVal, dwSize,
											dVal, dwSize,
											szVal, dwSize,
											pb, dwSize
										);

			delete [] pb;
			pb = NULL;
		}
	}
	catch ( ... )
	{
		if ( pb )
		{
			delete [] pb;
			pb = NULL;
		}
	}

	return ( ( bResult ) ? S_OK : S_FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\noncomevent\_eventobjects.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					_EventObjects.cpp
//
//	Abstract:
//
//					module for generic event object
//					module for normal event object
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "PreComp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// extern variables
extern LPWSTR g_szQueryEvent;

// enum
#include "_EventObjects.h"

HRESULT MyEventObjectGeneric::EventReport1	(	HANDLE hConnect,
												signed char			cVar,
												unsigned char		ucVar,
												signed short		sVar,
												unsigned short		usVar,
												signed long			lVar,
												unsigned long		ulVar,
												signed __int64		i64Var,
												unsigned __int64	ui64Var,
												float				fVar,
												double				dVar,
												BOOL 				b,
												LPWSTR				wsz,
												WCHAR				wcVar,
												void*				objVar
											)
{
	if ( wszName )
	{
		LPWSTR wszFormat =
							L"bVar!b! "
							L"wcVar!w! "
							L"dtVar!s! "
							L"objVar!o! "
							L"fVar!f! "
							L"dVar!g! "
							L"refVar!s! "
							L"sVar!w! "
							L"lVar!d! "
							L"i64Var!I64d! "
							L"cVar!c! "
							L"wszVar!s! "
							L"usVar!w! "
							L"ulVar!u! "
							L"ui64Var!I64u! "
							L"ucVar!c! ";

		LPCWSTR	refVar = L"Win32_Processor.DeviceID=\"CPU0\"";
		LPCWSTR dtVar  = NULL;

		SYSTEMTIME st;
		GetLocalTime ( &st );

		WCHAR time [ _MAX_PATH ] = { L'\0' };
		wsprintf ( time, L"%04d%02d%02d%02d%02d%02d.**********",
								st.wYear,
								st.wMonth,
								st.wDay,
								st.wHour,
								st.wMinute,
								st.wSecond
				 );

		dtVar = &time[0];

		if ( WmiReportEvent ( hConnect, wszName, wszFormat,
			
								( WORD ) b,
								wcVar,
								dtVar,
								objVar,
								fVar,
								dVar,
								refVar,
								sVar,
								lVar,
								i64Var,
								cVar,
								wsz,
								usVar,
								ulVar,
								ui64Var,
								ucVar

							)
		   )
		{
			return S_OK;
		}

		return E_FAIL;
	}

	return E_UNEXPECTED;
}

HRESULT MyEventObjectGeneric::EventReport2	(	HANDLE hConnect,
												DWORD dwSize,
												signed char*		cVar,
												unsigned char*		ucVar,
												signed short*		sVar,
												unsigned short*		usVar,
												signed long*		lVar,
												unsigned long*		ulVar,
												signed __int64*		i64Var,
												unsigned __int64*	ui64Var,
												float*				fVar,
												double*				dVar,
												BOOL* 				bVar,
												LPWSTR*				wszVar,
												WCHAR*				wcVar,
												void*				objVar
											)
{
	if ( wszName )
	{
		SYSTEMTIME st;
		GetLocalTime ( &st );

		WCHAR time [ _MAX_PATH ] = { L'\0' };
		wsprintf ( time, L"%04d%02d%02d%02d%02d%02d.**********",
								st.wYear,
								st.wMonth,
								st.wDay,
								st.wHour,
								st.wMinute,
								st.wSecond
				 );

		LPCWSTR	refVar = L"Win32_Processor.DeviceID=\"CPU0\"";
		LPCWSTR dtVar  = NULL;

		LPWSTR wszFormat =
							L"bVar!b[]! "
							L"wcVar!w[]! "
							L"dtVar!s[]! "
							L"objVar!o[]! "
							L"fVar!f[]! "
							L"dVar!g[]! "
							L"refVar!s[]! "
							L"sVar!w[]! "
							L"lVar!d[]! "
							L"i64Var!I64d[]! "
							L"cVar!c[]! "
							L"wszVar!s[]! "
							L"usVar!w[]! "
							L"ulVar!u[]! "
							L"ui64Var!I64u[]! "
							L"ucVar!c[]! ";

		dtVar = &time[0];

		WORD * pb = NULL;

		try
		{
			if ( ( pb = new WORD [ dwSize ] ) != NULL )
			{
				for ( DWORD dw = 0; dw < dwSize; dw++ )
				{
					pb[dw] = (WORD)bVar [ dw ];
				}
			}
			else
			{
				return E_OUTOFMEMORY;
			}
		}
		catch ( ... )
		{
			if ( pb )
			{
				delete [] pb;
				pb = NULL;
			}

			return E_UNEXPECTED;
		}

		if ( WmiReportEvent ( hConnect, wszName, wszFormat,
			
								pb, dwSize, 
								wcVar, dwSize,  
								dtVar, 1, 
								objVar, 1, 
								fVar, dwSize, 
								dVar, dwSize, 
								refVar, 1, 
								sVar, dwSize, 
								lVar, dwSize, 
								i64Var, dwSize, 
								cVar, dwSize, 
								wszVar, dwSize, 
								usVar, dwSize, 
								ulVar, dwSize, 
								ui64Var, dwSize, 
								ucVar, dwSize

							)
		   )
		{
			delete [] pb;
			return S_OK;
		}

		return E_FAIL;
	}

	return E_UNEXPECTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\noncomevent\_test.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					_test.cpp
//
//	Abstract:
//
//					module from test
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "PreComp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

#include "_test.h"

BOOL	MyTest::Commit ( HANDLE hEvent )
{
	if ( hEvent )
	{
		return WmiCommitObject ( hEvent );
	}

	return FALSE;
}

BOOL	MyTest::CommitSet ( HANDLE hEvent, ... )
{
	if ( hEvent )
	{
		BOOL bResult = FALSE;

		va_list		list;
		va_start	( list, hEvent );

		bResult = WmiSetAndCommitObject ( hEvent, WMI_SENDCOMMIT_SET_NOT_REQUIRED| WMI_USE_VA_LIST, &list );

		va_end		( list );

		return bResult;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\noncomevent\_testarraycreateformat.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					_test.cpp
//
//	Abstract:
//
//					module from test
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "PreComp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

#include "_test.h"

BOOL	MyTest::TestArrayThree ( LPWSTR wszName, DWORD dwSize, signed char* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, dwSize, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayThree ( LPWSTR wszName, DWORD dwSize, unsigned char* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, dwSize, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayThree ( LPWSTR wszName, DWORD dwSize, signed short* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, dwSize, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayThree ( LPWSTR wszName, Types type, DWORD dwSize, unsigned short* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );

			switch ( type )
			{
				case _char16:
				{
					event.PropertySetWCHAR ( 0, dwSize, Val );
				}
				break;

				default:
				{
					event.PropertySet ( 0, dwSize, Val );
				}
				break;
			}

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayThree ( LPWSTR wszName, DWORD dwSize, signed long* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, dwSize, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayThree ( LPWSTR wszName, DWORD dwSize, unsigned long* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, dwSize, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayThree ( LPWSTR wszName, DWORD dwSize, float* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, dwSize, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayThree ( LPWSTR wszName, DWORD dwSize, double* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, dwSize, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayThree ( LPWSTR wszName, DWORD dwSize, signed __int64* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, dwSize, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayThree ( LPWSTR wszName, DWORD dwSize, unsigned __int64* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, dwSize, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayThree ( LPWSTR wszName, DWORD dwSize, BOOL* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, dwSize, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayThree ( LPWSTR wszName, Types type, DWORD dwSize, LPCWSTR* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );

			BOOL bContinue	= TRUE;
			BOOL bResult	= FALSE;

			switch ( type )
			{
				case _string:
				{
					event.PropertySet ( 0, dwSize, Val );
				}
				break;

				case _datetime:
				{
					event.PropertySetDATETIME ( 0, dwSize, Val );
				}
				break;

				case _reference:
				{
					event.PropertySetREFERENCE ( 0, dwSize, Val );
				}
				break;

				default:
				bContinue = FALSE;
				break;
			}

			if ( bContinue )
			{
				bResult = MyTest::Commit ( event.m_hEventObject );
			}

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayThree ( LPWSTR wszName, DWORD dwSize, void** Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );
			event.PropertySetOBJECT ( 0, dwSize, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayFour ( LPWSTR wszName, DWORD dwSize, signed char* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val, dwSize );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayFour ( LPWSTR wszName, DWORD dwSize, unsigned char* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val, dwSize );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayFour ( LPWSTR wszName, DWORD dwSize, signed short* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val, dwSize );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayFour ( LPWSTR wszName, Types type, DWORD dwSize, unsigned short* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );

			switch ( type )
			{
				case _char16:
				{
				}
				break;

				default:
				{
				}
				break;
			}

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val, dwSize );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayFour ( LPWSTR wszName, DWORD dwSize, signed long* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val, dwSize );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayFour ( LPWSTR wszName, DWORD dwSize, unsigned long* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val, dwSize );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayFour ( LPWSTR wszName, DWORD dwSize, float* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val, dwSize );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayFour ( LPWSTR wszName, DWORD dwSize, double* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val, dwSize );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayFour ( LPWSTR wszName, DWORD dwSize, signed __int64 * Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val, dwSize );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayFour ( LPWSTR wszName, DWORD dwSize, unsigned __int64 * Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val, dwSize );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayFour ( LPWSTR wszName, DWORD dwSize, BOOL* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );

			BOOL	bResult	= FALSE;
			WORD *	pb		= NULL;

			try
			{
				if ( ( pb = new WORD [dwSize] ) != NULL )
				{
					for ( DWORD dw = 0; dw < dwSize; dw ++ )
					{
						pb [ dw ] = (WORD) Val [ dw ] ;
					}

					bResult = MyTest::CommitSet ( event.m_hEventObject, pb, dwSize );

					delete [] pb;
					pb = NULL;
				}
			}
			catch ( ... )
			{
				bResult = FALSE;

				if ( pb )
				{
					delete [] pb;
					pb = NULL;
				}
			}

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayFour ( LPWSTR wszName, Types type, DWORD dwSize, LPCWSTR* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );

			BOOL bContinue	= TRUE;
			BOOL bResult	= FALSE;

			switch ( type )
			{
				case _string:
				{
				}
				break;

				case _datetime:
				{
				}
				break;

				case _reference:
				{
				}
				break;

				default:
				bContinue = FALSE;
				break;
			}

			if ( bContinue )
			{
				bResult = MyTest::CommitSet ( event.m_hEventObject, Val, dwSize );
			}

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayFour ( LPWSTR wszName, DWORD dwSize, void** Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val, dwSize );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\noncomevent\_testarraycreate.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					_test.cpp
//
//	Abstract:
//
//					module from test
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "PreComp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

#include "_test.h"

BOOL	MyTest::TestArrayOne ( LPWSTR wszName, DWORD dwSize, signed char* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Sint8_ARRAY_Prop", CIM_SINT8 | CIM_FLAG_ARRAY );
			event.PropertySet ( 0, dwSize, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayOne ( LPWSTR wszName, DWORD dwSize, unsigned char* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Uint8_ARRAY_Prop", CIM_UINT8 | CIM_FLAG_ARRAY );
			event.PropertySet ( 0, dwSize, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayOne ( LPWSTR wszName, DWORD dwSize, signed short* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Sint16_ARRAY_Prop", CIM_SINT16 | CIM_FLAG_ARRAY );
			event.PropertySet ( 0, dwSize, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayOne ( LPWSTR wszName, Types type, DWORD dwSize, unsigned short* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			switch ( type )
			{
				case _char16:
				{
					event.PropertyAdd ( L"Char16_ARRAY_Prop", CIM_CHAR16 | CIM_FLAG_ARRAY );
					event.PropertySetWCHAR ( 0, dwSize, Val );
				}
				break;

				default:
				{
					event.PropertyAdd ( L"Uint16_ARRAY_Prop", CIM_UINT16 | CIM_FLAG_ARRAY );
					event.PropertySet ( 0, dwSize, Val );
				}
				break;
			}

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayOne ( LPWSTR wszName, DWORD dwSize, signed long* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Sint32_ARRAY_Prop", CIM_SINT32 | CIM_FLAG_ARRAY );
			event.PropertySet ( 0, dwSize, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayOne ( LPWSTR wszName, DWORD dwSize, unsigned long* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Uint32_ARRAY_Prop", CIM_UINT32 | CIM_FLAG_ARRAY );
			event.PropertySet ( 0, dwSize, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayOne ( LPWSTR wszName, DWORD dwSize, float* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Real32_ARRAY_Prop", CIM_REAL32 | CIM_FLAG_ARRAY );
			event.PropertySet ( 0, dwSize, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayOne ( LPWSTR wszName, DWORD dwSize, double* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Real64_ARRAY_Prop", CIM_REAL64 | CIM_FLAG_ARRAY );
			event.PropertySet ( 0, dwSize, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayOne ( LPWSTR wszName, DWORD dwSize, signed __int64* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Sint64_ARRAY_Prop", CIM_SINT64 | CIM_FLAG_ARRAY );
			event.PropertySet ( 0, dwSize, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayOne ( LPWSTR wszName, DWORD dwSize, unsigned __int64* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Uint64_ARRAY_Prop", CIM_UINT64 | CIM_FLAG_ARRAY );
			event.PropertySet ( 0, dwSize, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayOne ( LPWSTR wszName, DWORD dwSize, BOOL* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Boolean_ARRAY_Prop", CIM_BOOLEAN | CIM_FLAG_ARRAY );
			event.PropertySet ( 0, dwSize, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayOne ( LPWSTR wszName, Types type, DWORD dwSize, LPCWSTR* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			BOOL bContinue	= TRUE;
			BOOL bResult	= FALSE;

			switch ( type )
			{
				case _string:
				{
					event.PropertyAdd ( L"String_ARRAY_Prop", CIM_STRING | CIM_FLAG_ARRAY );
					event.PropertySet ( 0, dwSize, Val );
				}
				break;

				case _datetime:
				{
					event.PropertyAdd ( L"Datetime_ARRAY_Prop", CIM_DATETIME | CIM_FLAG_ARRAY );
					event.PropertySetDATETIME ( 0, dwSize, Val );
				}
				break;

				case _reference:
				{
					event.PropertyAdd ( L"Reference_ARRAY_Prop", CIM_REFERENCE | CIM_FLAG_ARRAY );
					event.PropertySetREFERENCE ( 0, dwSize, Val );
				}
				break;

				default:
				bContinue = FALSE;
				break;
			}

			if ( bContinue )
			{
				bResult = MyTest::Commit ( event.m_hEventObject );
			}

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayOne ( LPWSTR wszName, DWORD dwSize, void** Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Object_ARRAY_Prop", CIM_OBJECT | CIM_FLAG_ARRAY );
			event.PropertySetOBJECT ( 0, dwSize, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayTwo ( LPWSTR wszName, DWORD dwSize, signed char* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Sint8_ARRAY_Prop", CIM_SINT8 | CIM_FLAG_ARRAY );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val, dwSize );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayTwo ( LPWSTR wszName, DWORD dwSize, unsigned char* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Uint8_ARRAY_Prop", CIM_UINT8 | CIM_FLAG_ARRAY );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val, dwSize );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayTwo ( LPWSTR wszName, DWORD dwSize, signed short* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Sint16_ARRAY_Prop", CIM_SINT16 | CIM_FLAG_ARRAY );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val, dwSize );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayTwo ( LPWSTR wszName, Types type, DWORD dwSize, unsigned short* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			switch ( type )
			{
				case _char16:
				{
					event.PropertyAdd ( L"Char16_ARRAY_Prop", CIM_CHAR16 | CIM_FLAG_ARRAY );
				}
				break;

				default:
				{
					event.PropertyAdd ( L"Uint16_ARRAY_Prop", CIM_UINT16 | CIM_FLAG_ARRAY );
				}
				break;
			}

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val, dwSize );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayTwo ( LPWSTR wszName, DWORD dwSize, signed long* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Sint32_ARRAY_Prop", CIM_SINT32 | CIM_FLAG_ARRAY );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val, dwSize );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayTwo ( LPWSTR wszName, DWORD dwSize, unsigned long* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Uint32_ARRAY_Prop", CIM_UINT32 | CIM_FLAG_ARRAY );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val, dwSize );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayTwo ( LPWSTR wszName, DWORD dwSize, float* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Real32_ARRAY_Prop", CIM_REAL32 | CIM_FLAG_ARRAY );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val, dwSize );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayTwo ( LPWSTR wszName, DWORD dwSize, double* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Real64_ARRAY_Prop", CIM_REAL64 | CIM_FLAG_ARRAY );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val, dwSize );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayTwo ( LPWSTR wszName, DWORD dwSize, signed __int64 * Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Sint64_ARRAY_Prop", CIM_SINT64 | CIM_FLAG_ARRAY );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val, dwSize );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayTwo ( LPWSTR wszName, DWORD dwSize, unsigned __int64 * Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Uint64_ARRAY_Prop", CIM_UINT64 | CIM_FLAG_ARRAY );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val, dwSize );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayTwo ( LPWSTR wszName, DWORD dwSize, BOOL* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Boolean_ARRAY_Prop", CIM_BOOLEAN | CIM_FLAG_ARRAY );

			BOOL	bResult	= FALSE;
			WORD *	pb		= NULL;

			try
			{
				if ( ( pb = new WORD [dwSize] ) != NULL )
				{
					for ( DWORD dw = 0; dw < dwSize; dw ++ )
					{
						pb [ dw ] = (WORD) Val [ dw ] ;
					}

					bResult = MyTest::CommitSet ( event.m_hEventObject, pb, dwSize );

					delete [] pb;
					pb = NULL;
				}
			}
			catch ( ... )
			{
				bResult = FALSE;

				if ( pb )
				{
					delete [] pb;
					pb = NULL;
				}
			}

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayTwo ( LPWSTR wszName, Types type, DWORD dwSize, LPCWSTR* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			BOOL bContinue	= TRUE;
			BOOL bResult	= FALSE;

			switch ( type )
			{
				case _string:
				{
					event.PropertyAdd ( L"String_ARRAY_Prop", CIM_STRING | CIM_FLAG_ARRAY );
				}
				break;

				case _datetime:
				{
					event.PropertyAdd ( L"Datetime_ARRAY_Prop", CIM_DATETIME | CIM_FLAG_ARRAY );
				}
				break;

				case _reference:
				{
					event.PropertyAdd ( L"Reference_ARRAY_Prop", CIM_REFERENCE | CIM_FLAG_ARRAY );
				}
				break;

				default:
				bContinue = FALSE;
				break;
			}

			if ( bContinue )
			{
				bResult = MyTest::CommitSet ( event.m_hEventObject, Val, dwSize );
			}

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayTwo ( LPWSTR wszName, DWORD dwSize, void** Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Object_ARRAY_Prop", CIM_OBJECT | CIM_FLAG_ARRAY );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val, dwSize );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\noncomevent\_module.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					_Module.cpp
//
//	Abstract:
//
//					module from CComModule
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "PreComp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// application
#include "_App.h"
extern MyApp	_App;

// com module
#include "_Module.h"
extern MyModule _Module;

// time for EXE to be idle before shutting down
const DWORD dwTimeOut	= 1000;

// destruction
MyModule::~MyModule()
{
	ATLTRACE (	L"*************************************************************\n"
				L"MyModule destruction\n"
				L"*************************************************************\n" );

	if ( m_hEventShutdown )
	{
		::CloseHandle ( m_hEventShutdown );
		m_hEventShutdown = NULL;
	}

	if ( m_hThread )
	{
		::CloseHandle ( m_hThread );
		m_hThread = NULL;
	}
}

// unlock module
LONG MyModule::Unlock()
{
	__Smart_CRITICAL_SECTION cs;

    LONG l = CComModule::Unlock();
    if (l == 0)
    {
        m_bActivity = true;

		 // tell monitor that we transitioned to zero
		if ( m_hEventShutdown )
		{
			SetEvent(m_hEventShutdown);
		}
		else
		{
			if ( _App.m_hKill )
			{
				// kill application
				::SetEvent	( _App.m_hKill );
			}

//			/////////////////////////////////////////////////////
//			message queve is forgiven
//			/////////////////////////////////////////////////////
//
//			PostThreadMessage(_App.ThreadIDGet(), WM_QUIT, 0, 0);
		}
    }

    return l;
}

// Passed to CreateThread to monitor the shutdown event
DWORD WINAPI MyModule::MonitorShutdownProc( LPVOID pData )
{
    MyModule* p = static_cast<MyModule*>(pData);
    p->MonitorShutdown();
    return S_OK;
}

//Monitors the shutdown event
void MyModule::MonitorShutdown()
{
    while (1)
    {
        WaitForSingleObject(m_hEventShutdown, INFINITE);

        DWORD dwWait=0;
        do
        {
            m_bActivity = false;
            dwWait = WaitForSingleObject(m_hEventShutdown, dwTimeOut);
        }
		while ( dwWait == WAIT_OBJECT_0 );

        // timed out
		if (!m_bActivity && m_nLockCnt == 0) // if no activity let's really bail
		{
			CoSuspendClassObjects();
			break;
		}
	}

	if ( _App.m_hKill )
	{
		::SetEvent	( _App.m_hKill );
	}

//	/////////////////////////////////////////////////////
//	message queve is forgiven
//	/////////////////////////////////////////////////////
//
//	PostThreadMessage(_App.ThreadIDGet(), WM_QUIT, 0, 0);
}

// monitor shutdown function
bool MyModule::MonitorShutdownStart()
{
	__Smart_CRITICAL_SECTION cs;

	if ( ! m_hEventShutdown )
	{
		try
		{
			if ( (	m_hEventShutdown = 
					::CreateEventW( NULL,
									FALSE,
									FALSE,
									NULL )
				 ) == NULL )
			{
				return false;
			}
		}
		catch ( ... )
		{
			return false;
		}

		DWORD dwThread = 0;
		if ( ( m_hThread = CreateThread( NULL, 0, MyModule::MonitorShutdownProc, this, 0, &dwThread ) ) == NULL )
		{
			return false;
		}
	}

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\noncomevent\_testarraycreateprops.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					_test.cpp
//
//	Abstract:
//
//					module from test
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "PreComp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

#include "_test.h"

BOOL	MyTest::TestArrayFive ( LPWSTR wszName, DWORD dwSize, signed char* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, dwSize, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayFive ( LPWSTR wszName, DWORD dwSize, unsigned char* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, dwSize, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayFive ( LPWSTR wszName, DWORD dwSize, signed short* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, dwSize, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayFive ( LPWSTR wszName, Types type, DWORD dwSize, unsigned short* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );

			switch ( type )
			{
				case _char16:
				{
					event.PropertySetWCHAR ( 0, dwSize, Val );
				}
				break;

				default:
				{
					event.PropertySet ( 0, dwSize, Val );
				}
				break;
			}

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayFive ( LPWSTR wszName, DWORD dwSize, signed long* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, dwSize, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayFive ( LPWSTR wszName, DWORD dwSize, unsigned long* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, dwSize, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayFive ( LPWSTR wszName, DWORD dwSize, float* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, dwSize, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayFive ( LPWSTR wszName, DWORD dwSize, double* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, dwSize, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayFive ( LPWSTR wszName, DWORD dwSize, signed __int64* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, dwSize, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayFive ( LPWSTR wszName, DWORD dwSize, unsigned __int64* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, dwSize, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayFive ( LPWSTR wszName, DWORD dwSize, BOOL* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, dwSize, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayFive ( LPWSTR wszName, Types type, DWORD dwSize, LPCWSTR* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );

			BOOL bContinue	= TRUE;
			BOOL bResult	= FALSE;

			switch ( type )
			{
				case _string:
				{
					event.PropertySet ( 0, dwSize, Val );
				}
				break;

				case _datetime:
				{
					event.PropertySetDATETIME ( 0, dwSize, Val );
				}
				break;

				case _reference:
				{
					event.PropertySetREFERENCE ( 0, dwSize, Val );
				}
				break;

				default:
				bContinue = FALSE;
				break;
			}

			if ( bContinue )
			{
				bResult = MyTest::Commit ( event.m_hEventObject );
			}

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArrayFive ( LPWSTR wszName, DWORD dwSize, void** Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );
			event.PropertySetOBJECT ( 0, dwSize, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArraySix ( LPWSTR wszName, DWORD dwSize, signed char* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val, dwSize );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArraySix ( LPWSTR wszName, DWORD dwSize, unsigned char* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val, dwSize );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArraySix ( LPWSTR wszName, DWORD dwSize, signed short* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val, dwSize );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArraySix ( LPWSTR wszName, Types type, DWORD dwSize, unsigned short* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );

			switch ( type )
			{
				case _char16:
				{
				}
				break;

				default:
				{
				}
				break;
			}

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val, dwSize );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArraySix ( LPWSTR wszName, DWORD dwSize, signed long* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val, dwSize );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArraySix ( LPWSTR wszName, DWORD dwSize, unsigned long* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val, dwSize );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArraySix ( LPWSTR wszName, DWORD dwSize, float* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val, dwSize );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArraySix ( LPWSTR wszName, DWORD dwSize, double* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val, dwSize );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArraySix ( LPWSTR wszName, DWORD dwSize, signed __int64 * Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val, dwSize );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArraySix ( LPWSTR wszName, DWORD dwSize, unsigned __int64 * Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val, dwSize );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArraySix ( LPWSTR wszName, DWORD dwSize, BOOL* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );

			BOOL	bResult	= FALSE;
			WORD *	pb		= NULL;

			try
			{
				if ( ( pb = new WORD [dwSize] ) != NULL )
				{
					for ( DWORD dw = 0; dw < dwSize; dw ++ )
					{
						pb [ dw ] = (WORD) Val [ dw ] ;
					}

					bResult = MyTest::CommitSet ( event.m_hEventObject, pb, dwSize );

					delete [] pb;
					pb = NULL;
				}
			}
			catch ( ... )
			{
				bResult = FALSE;

				if ( pb )
				{
					delete [] pb;
					pb = NULL;
				}
			}

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArraySix ( LPWSTR wszName, Types type, DWORD dwSize, LPCWSTR* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );

			BOOL bContinue	= TRUE;
			BOOL bResult	= FALSE;

			switch ( type )
			{
				case _string:
				{
				}
				break;

				case _datetime:
				{
				}
				break;

				case _reference:
				{
				}
				break;

				default:
				bContinue = FALSE;
				break;
			}

			if ( bContinue )
			{
				bResult = MyTest::CommitSet ( event.m_hEventObject, Val, dwSize );
			}

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestArraySix ( LPWSTR wszName, DWORD dwSize, void** Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val, dwSize );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\noncomevent\_testscalarcreateprops.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					_test.cpp
//
//	Abstract:
//
//					module from test
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "PreComp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

#include "_test.h"

BOOL	MyTest::TestScalarFive ( LPWSTR wszName, signed char Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarFive ( LPWSTR wszName, unsigned char Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarFive ( LPWSTR wszName, signed short Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarFive ( LPWSTR wszName, Types type, unsigned short Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			BOOL bResult = FALSE;

			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			switch ( type )
			{
				case _char16:
				{
					event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
					event.Init ( wszName );

					event.CreateObjectProps ( (HANDLE) ( * pConnect ) );
					event.PropertySetWCHAR ( 0, Val );

					bResult = MyTest::Commit ( event.m_hEventObject );
				}
				break;

				default:
				{
					event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
					event.Init ( wszName );

					event.CreateObjectProps ( (HANDLE) ( * pConnect ) );
					event.PropertySet ( 0, Val );

					bResult = MyTest::Commit ( event.m_hEventObject );
				}
				break;
			}

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarFive ( LPWSTR wszName, signed long Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarFive ( LPWSTR wszName, unsigned long Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarFive ( LPWSTR wszName, float Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarFive ( LPWSTR wszName, double Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarFive ( LPWSTR wszName, signed __int64 Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarFive ( LPWSTR wszName, unsigned __int64 Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarFive ( LPWSTR wszName, BOOL Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarFive ( LPWSTR wszName, Types type, LPCWSTR Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );

			BOOL bContinue	= TRUE;
			BOOL bResult	= FALSE;

			switch ( type )
			{
				case _string:
				{
					event.PropertySet ( 0, Val );
				}
				break;

				case _datetime:
				{
					event.PropertySetDATETIME ( 0, Val );
				}
				break;

				case _reference:
				{
					event.PropertySetREFERENCE ( 0, Val );
				}
				break;

				default:
				bContinue = FALSE;
				break;
			}

			if ( bContinue )
			{
				bResult = MyTest::Commit ( event.m_hEventObject );
			}

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarFive ( LPWSTR wszName, void* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );
			event.PropertySetOBJECT ( 0, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarSix ( LPWSTR wszName, signed char Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			BOOL bResult = FALSE;
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );

			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarSix ( LPWSTR wszName, unsigned char Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarSix ( LPWSTR wszName, signed short Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarSix ( LPWSTR wszName, Types type, unsigned short Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			switch ( type )
			{
				case _char16:
				case _uint16:
				default:
				break;
			}

			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarSix ( LPWSTR wszName, signed long Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarSix ( LPWSTR wszName, unsigned long Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarSix ( LPWSTR wszName, float Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarSix ( LPWSTR wszName, double Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarSix ( LPWSTR wszName, signed __int64 Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarSix ( LPWSTR wszName, unsigned __int64 Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarSix ( LPWSTR wszName, BOOL Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarSix ( LPWSTR wszName, Types type, LPCWSTR Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			switch ( type )
			{
				case _string:
				case _datetime:
				case _reference:
				break;
			}

			BOOL bResult = FALSE;
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );

			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarSix ( LPWSTR wszName, void* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectProps ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\noncomevent\_testscalarcreate.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					_test.cpp
//
//	Abstract:
//
//					module from test
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "PreComp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

#include "_test.h"

BOOL	MyTest::TestScalarOne ( LPWSTR wszName, signed char Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Sint8_Prop", CIM_SINT8 );
			event.PropertySet ( 0, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarOne ( LPWSTR wszName, unsigned char Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Uint8_Prop", CIM_UINT8 );
			event.PropertySet ( 0, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarOne ( LPWSTR wszName, signed short Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Sint16_Prop", CIM_SINT16 );
			event.PropertySet ( 0, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarOne ( LPWSTR wszName, Types type, unsigned short Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			switch ( type )
			{
				case _char16:
				{
					event.PropertyAdd ( L"Char16_Prop", CIM_CHAR16 );
					event.PropertySetWCHAR ( 0, Val );
				}
				break;

				default:
				{
					event.PropertyAdd ( L"Uint16_Prop", CIM_UINT16 );
					event.PropertySet ( 0, Val );
				}
				break;
			}

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarOne ( LPWSTR wszName, signed long Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Sint32_Prop", CIM_SINT32 );
			event.PropertySet ( 0, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarOne ( LPWSTR wszName, unsigned long Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Uint32_Prop", CIM_UINT32 );
			event.PropertySet ( 0, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarOne ( LPWSTR wszName, float Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Real32_Prop", CIM_REAL32 );
			event.PropertySet ( 0, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarOne ( LPWSTR wszName, double Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Real64_Prop", CIM_REAL64 );
			event.PropertySet ( 0, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarOne ( LPWSTR wszName, signed __int64 Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Sint64_Prop", CIM_SINT64 );
			event.PropertySet ( 0, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarOne ( LPWSTR wszName, unsigned __int64 Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Uint64_Prop", CIM_UINT64 );
			event.PropertySet ( 0, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarOne ( LPWSTR wszName, BOOL Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Boolean_Prop", CIM_BOOLEAN );
			event.PropertySet ( 0, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarOne ( LPWSTR wszName, Types type, LPCWSTR Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			BOOL bContinue	= TRUE;
			BOOL bResult	= FALSE;

			switch ( type )
			{
				case _string:
				{
					event.PropertyAdd ( L"String_Prop", CIM_STRING );
					event.PropertySet ( 0, Val );
				}
				break;

				case _datetime:
				{
					event.PropertyAdd ( L"Datetime_Prop", CIM_DATETIME );
					event.PropertySetDATETIME ( 0, Val );
				}
				break;

				case _reference:
				{
					event.PropertyAdd ( L"Reference_Prop", CIM_REFERENCE );
					event.PropertySetREFERENCE ( 0, Val );
				}
				break;

				default:
				bContinue = FALSE;
				break;
			}

			if ( bContinue )
			{
				bResult = MyTest::Commit ( event.m_hEventObject );
			}

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarOne ( LPWSTR wszName, void* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Object_Prop", CIM_OBJECT );
			event.PropertySetOBJECT ( 0, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarTwo ( LPWSTR wszName, signed char Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Sint8_Prop", CIM_SINT8 );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarTwo ( LPWSTR wszName, unsigned char Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Uint8_Prop", CIM_UINT8 );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarTwo ( LPWSTR wszName, signed short Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Sint16_Prop", CIM_SINT16 );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarTwo ( LPWSTR wszName, Types type, unsigned short Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			switch ( type )
			{
				case _char16:
				{
					event.PropertyAdd ( L"Char16_Prop", CIM_CHAR16 );
				}
				break;

				default:
				{
					event.PropertyAdd ( L"Uint16_Prop", CIM_UINT16 );
				}
				break;
			}

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarTwo ( LPWSTR wszName, signed long Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Sint32_Prop", CIM_SINT32 );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarTwo ( LPWSTR wszName, unsigned long Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Uint32_Prop", CIM_UINT32 );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarTwo ( LPWSTR wszName, float Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Real32_Prop", CIM_REAL32 );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarTwo ( LPWSTR wszName, double Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Real64_Prop", CIM_REAL64 );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarTwo ( LPWSTR wszName, signed __int64 Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Sint64_Prop", CIM_SINT64 );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarTwo ( LPWSTR wszName, unsigned __int64 Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Uint64_Prop", CIM_UINT64 );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarTwo ( LPWSTR wszName, BOOL Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Boolean_Prop", CIM_BOOLEAN );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarTwo ( LPWSTR wszName, Types type, LPCWSTR Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			BOOL bContinue	= TRUE;
			BOOL bResult	= FALSE;

			switch ( type )
			{
				case _string:
				{
					event.PropertyAdd ( L"String_Prop", CIM_STRING );
				}
				break;

				case _datetime:
				{
					event.PropertyAdd ( L"Datetime_Prop", CIM_DATETIME );
				}
				break;

				case _reference:
				{
					event.PropertyAdd ( L"Reference_Prop", CIM_REFERENCE );
				}
				break;

				default:
				bContinue = FALSE;
				break;
			}

			if ( bContinue )
			{
				bResult = MyTest::CommitSet ( event.m_hEventObject, Val );
			}

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarTwo ( LPWSTR wszName, void* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init			( wszName );

			event.CreateObject ( (HANDLE) ( * pConnect ) );

			event.PropertyAdd ( L"Object_Prop", CIM_OBJECT );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\noncomevent\_testscalarcreateformat.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					_test.cpp
//
//	Abstract:
//
//					module from test
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "PreComp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

#include "_test.h"

BOOL	MyTest::TestScalarThree ( LPWSTR wszName, signed char Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarThree ( LPWSTR wszName, unsigned char Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarThree ( LPWSTR wszName, signed short Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarThree ( LPWSTR wszName, Types type, unsigned short Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			BOOL bResult = FALSE;

			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			switch ( type )
			{
				case _char16:
				{
					event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
					event.Init ( wszName );

					event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );
					event.PropertySetWCHAR ( 0, Val );

					bResult = MyTest::Commit ( event.m_hEventObject );
				}
				break;

				default:
				{
					event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
					event.Init ( wszName );

					event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );
					event.PropertySet ( 0, Val );

					bResult = MyTest::Commit ( event.m_hEventObject );
				}
				break;
			}

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarThree ( LPWSTR wszName, signed long Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarThree ( LPWSTR wszName, unsigned long Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarThree ( LPWSTR wszName, float Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarThree ( LPWSTR wszName, double Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarThree ( LPWSTR wszName, signed __int64 Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarThree ( LPWSTR wszName, unsigned __int64 Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarThree ( LPWSTR wszName, BOOL Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );
			event.PropertySet ( 0, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarThree ( LPWSTR wszName, Types type, LPCWSTR Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );

			BOOL bContinue	= TRUE;
			BOOL bResult	= FALSE;

			switch ( type )
			{
				case _string:
				{
					event.PropertySet ( 0, Val );
				}
				break;

				case _datetime:
				{
					event.PropertySetDATETIME ( 0, Val );
				}
				break;

				case _reference:
				{
					event.PropertySetREFERENCE ( 0, Val );
				}
				break;

				default:
				bContinue = FALSE;
				break;
			}

			if ( bContinue )
			{
				bResult = MyTest::Commit ( event.m_hEventObject );
			}

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarThree ( LPWSTR wszName, void* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );
			event.PropertySetOBJECT ( 0, Val );

			BOOL bResult = FALSE;
			bResult = MyTest::Commit ( event.m_hEventObject );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarFour ( LPWSTR wszName, signed char Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			BOOL bResult = FALSE;
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );

			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarFour ( LPWSTR wszName, unsigned char Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarFour ( LPWSTR wszName, signed short Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarFour ( LPWSTR wszName, Types type, unsigned short Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			switch ( type )
			{
				case _char16:
				case _uint16:
				default:
				break;
			}

			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarFour ( LPWSTR wszName, signed long Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarFour ( LPWSTR wszName, unsigned long Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarFour ( LPWSTR wszName, float Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarFour ( LPWSTR wszName, double Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarFour ( LPWSTR wszName, signed __int64 Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarFour ( LPWSTR wszName, unsigned __int64 Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarFour ( LPWSTR wszName, BOOL Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarFour ( LPWSTR wszName, Types type, LPCWSTR Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			switch ( type )
			{
				case _string:
				case _datetime:
				case _reference:
				break;
			}

			BOOL bResult = FALSE;
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );

			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}

BOOL	MyTest::TestScalarFour ( LPWSTR wszName, void* Val )
{
	if ( wszName )
	{
		MyConnect* pConnect = NULL;
		pConnect = MyConnect::ConnectGet ();

		if ( pConnect )
		{
			MyEventObjectNormal event;

			// connect to IWbemLocator
			event.ObjectLocator ();

			event.InitObject ( L"root\\cimv2", L"NonCOMTest Event Provider" );
			event.Init ( wszName );

			event.CreateObjectFormat ( (HANDLE) ( * pConnect ) );

			BOOL bResult = FALSE;
			bResult = MyTest::CommitSet ( event.m_hEventObject, Val );

			// disconnect from IWbemLocator
			event.ObjectLocator (FALSE);

			// destroy event object
			event.MyEventObjectClear();

			// clear and end
			MyConnect::ConnectClear ( );

			return bResult;
		}
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\noncomeventtest\test.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					test.cpp
//
//	Abstract:
//
//					main module
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "PreComp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// globals
int function_Init ( DWORD dwCoInit = COINIT_APARTMENTTHREADED )
{
	return HRESULT_TO_WIN32 ( ::CoInitializeEx ( NULL, dwCoInit ) );
}

int function_Uninit ( )
{
	::CoUninitialize ();
	return 0L;
}

// includes

#include "Enumerator.h"

#include "_Connect.h"
#include "_EventObject.h"
#include "_EventObjects.h"

// application
class App
{
	DECLARE_NO_COPY ( App );

	public:

	App ( DWORD dwCoInit = COINIT_APARTMENTTHREADED )
	{
		function_Init ( dwCoInit );
	}

	virtual ~App ()
	{
		function_Uninit ();
	}

	HRESULT Event1();
	HRESULT Event2();
	HRESULT Event3();
	HRESULT Event4();

	HRESULT EventGeneric ();
	HRESULT EventReport ();

	HRESULT EventSCALAR ();

	HRESULT	Connect();
};

HRESULT App::Event1()
{
	MyConnect*				pConnect = NULL;
	pConnect = MyConnect::ConnectGet();

	MyEventObjectNormal		event;
	event.Init			( L"MSFT_WMI_GenericNonCOMEvent" );

	event.CreateObject	( (HANDLE) (*pConnect) );

	Sleep ( 3000 );

	event.PropertyAdd ( L"char", CIM_UINT8 );
	event.PropertyAdd ( L"short", CIM_UINT16 );
	event.PropertyAdd ( L"long", CIM_UINT32 );
	event.PropertyAdd ( L"DWORD64", CIM_UINT64 );
	event.PropertyAdd ( L"float", CIM_REAL32 );

	event.PropertyAdd ( L"BOOL", CIM_BOOLEAN );
	event.PropertyAdd ( L"LPWSTR", CIM_STRING );

	event.SetCommit ( WMI_SENDCOMMIT_SET_NOT_REQUIRED,
						( unsigned char )'1',
						( unsigned short )2,
						( unsigned long )3,
						(DWORD64)6,
						( float )4.5,
						TRUE,
						L"ahoj"
					   );

	Sleep ( 3000 );

	pConnect->ConnectClear();
	return S_OK;
}

HRESULT App::Event2()
{
	MyConnect*				pConnect = NULL;
	pConnect = MyConnect::ConnectGet();

	LPWSTR wszFormat = L"char!c! short!w! long!u! DWORD64!I64u! float!f! BOOL!b! LPWSTR!s! ";

	MyEventObjectNormal		event;
	event.Init			( L"MSFT_WMI_GenericNonCOMEvent" );

	Sleep ( 3000 );

	event.CreateObjectFormat( (HANDLE) (*pConnect), wszFormat );
	event.SetCommit ( WMI_SENDCOMMIT_SET_NOT_REQUIRED,
						( unsigned char )'1',
						( unsigned short )2,
						( unsigned long )3,
						(DWORD64)6,
						( float )4.5,
						TRUE,
						L"ahoj"
					   );

	Sleep ( 3000 );

	pConnect->ConnectClear();
	return S_OK;
}

HRESULT App::Event3()
{
	MyConnect*				pConnect = NULL;
	pConnect = MyConnect::ConnectGet();

	LPWSTR  Names[] = { L"char", L"short", L"long", L"DWORD64", L"float", L"BOOL", L"LPWSTR" };
	CIMTYPE Types[]	= { CIM_SINT8, CIM_UINT16, CIM_UINT32, CIM_UINT64, CIM_REAL32, CIM_BOOLEAN, CIM_STRING };
	
	MyEventObjectNormal		event;
	event.Init			( L"MSFT_WMI_GenericNonCOMEvent" );

	Sleep ( 3000 );

	event.CreateObjectProps	( (HANDLE) (*pConnect), 7, (LPCWSTR*)Names, (CIMTYPE*)Types );
	event.SetCommit ( WMI_SENDCOMMIT_SET_NOT_REQUIRED,
						( unsigned char )'1',
						( unsigned short )2,
						( unsigned long )3,
						(DWORD64)6,
						( float )4.5,
						TRUE,
						L"ahoj"
					   );

	Sleep ( 3000 );

	pConnect->ConnectClear();
	return S_OK;
}

HRESULT App::Event4()
{
	MyConnect*				pConnect = NULL;
	pConnect = MyConnect::ConnectGet();

	Sleep ( 3000 );

	MyEventObjectNormal		event;
	event.Init			( L"MSFT_WMI_GenericNonCOMEvent" );

	LPWSTR  p1 [] = { L"CIM_SINT8" };
	CIMTYPE t1 [] = { CIM_SINT8 };

	LPWSTR  p2 [] = { L"CIM_UINT16" };
	CIMTYPE t2 [] = { CIM_UINT16 };

	LPWSTR  p3 [] = { L"CIM_UINT32" };
	CIMTYPE t3 [] = { CIM_UINT32 };

	LPWSTR  p4 [] = { L"CIM_UINT64" };
	CIMTYPE t4 [] = { CIM_UINT64 };

	LPWSTR  p5 [] = { L"CIM_REAL32" };
	CIMTYPE t5 [] = { CIM_REAL32 };

	LPWSTR  p6 [] = { L"CIM_BOOLEAN" };
	CIMTYPE t6 [] = { CIM_BOOLEAN };

	LPWSTR  p7 [] = { L"CIM_STRING" };
	CIMTYPE t7 [] = { CIM_STRING };

	event.CreateObject	( (HANDLE) (*pConnect) );
	event.SetAddCommit ( WMI_SENDCOMMIT_SET_NOT_REQUIRED,
						1,
						(LPCWSTR*)p1,
						t1,
						( unsigned char )'1'
					   );

	event.CreateObject	( (HANDLE) (*pConnect) );
	event.SetAddCommit ( WMI_SENDCOMMIT_SET_NOT_REQUIRED,
						1,
						(LPCWSTR*)p2,
						t2,
						( unsigned short )2
					   );

	event.CreateObject	( (HANDLE) (*pConnect) );
	event.SetAddCommit ( WMI_SENDCOMMIT_SET_NOT_REQUIRED,
						1,
						(LPCWSTR*)p3,
						t3,
						( unsigned long )3
					   );

	event.CreateObject	( (HANDLE) (*pConnect) );
	event.SetAddCommit ( WMI_SENDCOMMIT_SET_NOT_REQUIRED,
						1,
						(LPCWSTR*)p4,
						t4,
						( DWORD64 )6
					   );

	event.CreateObject	( (HANDLE) (*pConnect) );
	event.SetAddCommit ( WMI_SENDCOMMIT_SET_NOT_REQUIRED,
						1,
						(LPCWSTR*)p5,
						t5,
						( float )4.5
					   );

	event.CreateObject	( (HANDLE) (*pConnect) );
	event.SetAddCommit ( WMI_SENDCOMMIT_SET_NOT_REQUIRED,
						1,
						(LPCWSTR*)p6,
						t6,
						TRUE
					   );

	event.CreateObject	( (HANDLE) (*pConnect) );
	event.SetAddCommit ( WMI_SENDCOMMIT_SET_NOT_REQUIRED,
						1,
						(LPCWSTR*)p7,
						t7,
						L"ahoj"
					   );

	LPWSTR  p11 [] = { L"CIM_SINT8 | CIM_FLAG_ARRAY" };
	CIMTYPE t11 [] = { CIM_SINT8 | CIM_FLAG_ARRAY };

	LPWSTR  p12 [] = { L"CIM_UINT16 | CIM_FLAG_ARRAY" };
	CIMTYPE t12 [] = { CIM_UINT16 | CIM_FLAG_ARRAY };

	LPWSTR  p13 [] = { L"CIM_UINT32 | CIM_FLAG_ARRAY" };
	CIMTYPE t13 [] = { CIM_UINT32 | CIM_FLAG_ARRAY };

	LPWSTR  p14 [] = { L"CIM_UINT64 | CIM_FLAG_ARRAY" };
	CIMTYPE t14 [] = { CIM_UINT64 | CIM_FLAG_ARRAY };

	LPWSTR  p15 [] = { L"CIM_REAL32 | CIM_FLAG_ARRAY" };
	CIMTYPE t15 [] = { CIM_REAL32 | CIM_FLAG_ARRAY };

	LPWSTR  p16 [] = { L"CIM_BOOLEAN | CIM_FLAG_ARRAY" };
	CIMTYPE t16 [] = { CIM_BOOLEAN | CIM_FLAG_ARRAY };

	LPWSTR  p17 [] = { L"CIM_STRING | CIM_FLAG_ARRAY" };
	CIMTYPE t17 [] = { CIM_STRING | CIM_FLAG_ARRAY };

	unsigned char Val1 [] = { '1', '2', '3' };
	unsigned short Val2 [] = { 1, 2, 3 };
	unsigned long Val3 [] = { 1, 2, 3 };
	DWORD64 Val4 [] = { 1, 2, 3 };
	float Val5 [] = { (float)1.2, (float)3.4, (float)5.6 };
	BOOL Val6 [] = { TRUE, FALSE, TRUE };
	LPWSTR Val7 [] = { L"ahoj1", L"ahoj2", L"ahoj3" };

	event.CreateObject	( (HANDLE) (*pConnect) );
	event.SetAddCommit ( WMI_SENDCOMMIT_SET_NOT_REQUIRED,
						1,
						(LPCWSTR*)p11,
						t11,
						Val1, 3
					   );

	event.CreateObject	( (HANDLE) (*pConnect) );
	event.SetAddCommit ( WMI_SENDCOMMIT_SET_NOT_REQUIRED,
						1,
						(LPCWSTR*)p12,
						t12,
						Val2, 3
					   );

	event.CreateObject	( (HANDLE) (*pConnect) );
	event.SetAddCommit ( WMI_SENDCOMMIT_SET_NOT_REQUIRED,
						1,
						(LPCWSTR*)p13,
						t13,
						Val3, 3
					   );

	event.CreateObject	( (HANDLE) (*pConnect) );
	event.SetAddCommit ( WMI_SENDCOMMIT_SET_NOT_REQUIRED,
						1,
						(LPCWSTR*)p14,
						t14,
						Val4, 3
					   );

	event.CreateObject	( (HANDLE) (*pConnect) );
	event.SetAddCommit ( WMI_SENDCOMMIT_SET_NOT_REQUIRED,
						1,
						(LPCWSTR*)p15,
						t15,
						Val5, 3
					   );

	event.CreateObject	( (HANDLE) (*pConnect) );
	event.SetAddCommit ( WMI_SENDCOMMIT_SET_NOT_REQUIRED,
						1,
						(LPCWSTR*)p16,
						t16,
						Val6, 3
					   );

	event.CreateObject	( (HANDLE) (*pConnect) );
	event.SetAddCommit ( WMI_SENDCOMMIT_SET_NOT_REQUIRED,
						1,
						(LPCWSTR*)p17,
						t17,
						Val7, 3
					   );

	Sleep ( 3000 );

	pConnect->ConnectClear();
	return S_OK;
}

HRESULT App::EventGeneric()
{
	MyConnect*				pConnect = NULL;
	pConnect = MyConnect::ConnectGet();

	Sleep ( 3000 );

	MyEventObjectGeneric		event;
	event.Init			( L"MSFT_WMI_GenericNonCOMEvent" );

	signed char			_c	= -1;
	signed short		_s	= -2;
	signed long			_l	= -3;
	signed __int64		_i	= -123;
	unsigned char		_uc	= 1;
	unsigned short		_us	= 2;
	unsigned long		_ul	= 3;
	unsigned __int64	_ui	= 123;
	float				_f	= (float) 12.34;
	double				_d	= 12.34;

	BOOL				_b	= FALSE;
	LPWSTR				_sz	= L"string 1";
	WCHAR				_wc = L'a';

	DWORD dwSize = 3;

	signed char			c	[3]	= { -1 , -2 , -3 };
	signed short		s	[3]	= { -1 , -2 , -3 };
	signed long			l	[3]	= { -1 , -2 , -3 };
	signed __int64		i	[3]	= { -1 , -2 , -3 };
	unsigned char		uc	[3]	= { 1 , 2 , 3 };
	unsigned short		us	[3]	= { 1 , 2 , 3 };
	unsigned long		ul	[3]	= { 1 , 2 , 3 };
	unsigned __int64	ui	[3]	= { 1 , 2 , 3 };
	float				f	[3]	= { (float) 12.34 , (float) 34.56 , (float) 56.78 };
	double				d	[3]	= { 12.34 , 34.56 , 56.78 };
	BOOL				b	[3]	= { FALSE, TRUE, FALSE };
	LPWSTR				sz	[3]	= { L"string 1" , L"string 2" , L"string 3" };
	WCHAR				wc	[3]	= { L'a', L'b', L'c' };

	try
	{
		event.EventReport1 ( ( HANDLE ) (* pConnect ), 
								_c	,
								_uc	,
								_s	,
								_us	,
								_l	,
								_ul	,
								_i	,
								_ui	,
								_f	,
								_d	,
								_b	,
								_sz	,
								_wc ,
								NULL
			);

		event.EventReport2 ( ( HANDLE ) (* pConnect ), 
								dwSize,
								c	,
								uc	,
								s	,
								us	,
								l	,
								ul	,
								i	,
								ui	,
								f	,
								d	,
								b	,
								sz	,
								wc	,
								NULL
			);
	}
	catch ( ... )
	{
	}

	Sleep ( 3000 );

	pConnect->ConnectClear();
	return S_OK;
}

HRESULT App::EventReport()
{
	MyConnect*				pConnect = NULL;
	pConnect = MyConnect::ConnectGet();

	Sleep ( 3000 );

	MyEventObjectNormal		event;
	event.Init			( L"MSFT_WMI_GenericNonCOMEvent" );

	signed char			_c	= -1;
	signed short		_s	= -2;
	signed long			_l	= -3;
	signed __int64		_i	= -123;
	unsigned char		_uc	= 1;
	unsigned short		_us	= 2;
	unsigned long		_ul	= 3;
	unsigned __int64	_ui	= 123;
	float				_f	= (float) 12.34;
	double				_d	= 12.34;

	WORD				_b	= (WORD) FALSE;
	LPWSTR				_sz	= L"string 1";
	WCHAR				_wc = L'a';

	DWORD dwSize = 3;

	signed char			c	[3]	= { -1 , -2 , -3 };
	signed short		s	[3]	= { -1 , -2 , -3 };
	signed long			l	[3]	= { -1 , -2 , -3 };
	signed __int64		i	[3]	= { -1 , -2 , -3 };
	unsigned char		uc	[3]	= { 1 , 2 , 3 };
	unsigned short		us	[3]	= { 1 , 2 , 3 };
	unsigned long		ul	[3]	= { 1 , 2 , 3 };
	unsigned __int64	ui	[3]	= { 1 , 2 , 3 };
	float				f	[3]	= { (float) 12.34 , (float) 34.56 , (float) 56.78 };
	double				d	[3]	= { 12.34 , 34.56 , 56.78 };
	WORD				b	[3]	= { (WORD) FALSE, (WORD) TRUE, (WORD) FALSE };
	LPWSTR				sz	[3]	= { L"string 1" , L"string 2" , L"string 3" };
	WCHAR				wc	[3]	= { L'a', L'b', L'c' };

	LPWSTR  wszName   = L"MSFT_WMI_GenericNonCOMEvent";
	LPWSTR	wszFormat = NULL;

	HANDLE hConnect = ( HANDLE ) ( * pConnect );

	try
	{

		wszFormat = L"VARIABLE...c!c! ";
		WmiReportEvent ( hConnect, wszName, wszFormat, _c );

		wszFormat = L"VARIABLE...uc!c! ";
		WmiReportEvent ( hConnect, wszName, wszFormat, _uc );

		wszFormat = L"VARIABLE...s!w! ";
		WmiReportEvent ( hConnect, wszName, wszFormat, _s );

		wszFormat = L"VARIABLE...us!w! ";
		WmiReportEvent ( hConnect, wszName, wszFormat, _us );

		wszFormat = L"VARIABLE...l!d! ";
		WmiReportEvent ( hConnect, wszName, wszFormat, _l );

		wszFormat = L"VARIABLE...ul!u! ";
		WmiReportEvent ( hConnect, wszName, wszFormat, _ul );

		wszFormat = L"VARIABLE...i!I64d! ";
		WmiReportEvent ( hConnect, wszName, wszFormat, _i );

		wszFormat = L"VARIABLE...ui!I64u! ";
		WmiReportEvent ( hConnect, wszName, wszFormat, _ui );

		wszFormat = L"VARIABLE...f!f! ";
		WmiReportEvent ( hConnect, wszName, wszFormat, _f );

		wszFormat = L"VARIABLE...d!g! ";
		WmiReportEvent ( hConnect, wszName, wszFormat, _d );

		wszFormat = L"VARIABLE...b!b! ";
		WmiReportEvent ( hConnect, wszName, wszFormat, _b );

		wszFormat = L"VARIABLE...s!s! ";
		WmiReportEvent ( hConnect, wszName, wszFormat, _sz );

		wszFormat = L"VARIABLE...wc!w! ";
		WmiReportEvent ( hConnect, wszName, wszFormat, _wc );

		wszFormat = L"VARIABLE...c!c[]! ";
		WmiReportEvent ( hConnect, wszName, wszFormat, c, dwSize );

		wszFormat = L"VARIABLE...uc!c[]! ";
		WmiReportEvent ( hConnect, wszName, wszFormat, uc, dwSize );

		wszFormat = L"VARIABLE...s!w[]! ";
		WmiReportEvent ( hConnect, wszName, wszFormat, s, dwSize );

		wszFormat = L"VARIABLE...us!w[]! ";
		WmiReportEvent ( hConnect, wszName, wszFormat, us, dwSize );

//		wszFormat = L"VARIABLE...l!d[]! ";
//		WmiReportEvent ( hConnect, wszName, wszFormat, l, dwSize );

//		wszFormat = L"VARIABLE...ul!u[]! ";
//		WmiReportEvent ( hConnect, wszName, wszFormat, ul, dwSize );

//		wszFormat = L"VARIABLE...i!I64d[]! ";
//		WmiReportEvent ( hConnect, wszName, wszFormat, i, dwSize );

//		wszFormat = L"VARIABLE...ui!I64u[]! ";
//		WmiReportEvent ( hConnect, wszName, wszFormat, ui, dwSize );

//		wszFormat = L"VARIABLE...f!f[]! ";
//		WmiReportEvent ( hConnect, wszName, wszFormat, f, dwSize );

//		wszFormat = L"VARIABLE...d!g[]! ";
//		WmiReportEvent ( hConnect, wszName, wszFormat, d, dwSize );

		wszFormat = L"VARIABLE...b!b[]! ";
		WmiReportEvent ( hConnect, wszName, wszFormat, b, dwSize );

		wszFormat = L"VARIABLE...s!s[]! ";
		WmiReportEvent ( hConnect, wszName, wszFormat, sz, dwSize );

		wszFormat = L"VARIABLE...wc!w[]! ";
		WmiReportEvent ( hConnect, wszName, wszFormat, wc, dwSize );

	}
	catch ( ... )
	{
	}

	Sleep ( 3000 );

	pConnect->ConnectClear();
	return S_OK;
}

HRESULT App::EventSCALAR()
{
	HRESULT hr = S_OK;

	MyConnect*				pConnect = NULL;
	pConnect = MyConnect::ConnectGet();

	MyEventObjectNormal		event;

	event.ObjectLocator ();

	event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
	event.Init			( L"MSFT_NonCOMTest_SCALAR_Event" );

	Sleep ( 3000 );

	event.CreateObjectProps ( ( HANDLE ) ( * pConnect ) );

	signed char			_c	= -1;
	signed short		_s	= -2;
	signed long			_l	= -3;
	signed __int64		_i	= -123;
	unsigned char		_uc	= 1;
	unsigned short		_us	= 2;
	unsigned long		_ul	= 3;
	unsigned __int64	_ui	= 123;
	float				_f	= (float) 12.34;
	double				_d	= 12.34;

	BOOL				_b	= FALSE;
	LPWSTR				_sz	= L"string 1";
	WCHAR				_wc = L'a';

	try
	{
		hr = event.SetCommit (	WMI_SENDCOMMIT_SET_NOT_REQUIRED,
								( WORD )				_b,
								( WCHAR )				_wc,
								NULL,
								NULL,
								( float )				_f,
								( double )				_d,
								NULL,
								( signed short )		_s,
								( signed long )			_l,
								( signed __int64 )		_i,
								( signed char )			_c,
								( LPWSTR )				_sz,
								( unsigned short )		_us,
								( unsigned long )		_ul,
								( unsigned __int64 )	_ui,
								( unsigned char )		_uc
							);
	}	
	catch ( ... )
	{
	}

	Sleep ( 3000 );

	pConnect->ConnectClear();
	event.ObjectLocator ( FALSE );

	return S_OK;
}

HRESULT App::Connect()
{
	HRESULT hr = S_OK;

	MyEventObjectNormal		event;
	MyConnect*				pConnect = NULL;

	pConnect = MyConnect::ConnectGet();


	event.ObjectLocator ();

	event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
	event.Init			( L"MSFT_NonCOMTest_SCALAR_Event" );

	event.CreateObjectProps ( ( HANDLE ) ( * pConnect ) );

	event.ObjectLocator ( FALSE );
	event.MyEventObjectClear();

	pConnect->ConnectClear();

	pConnect = MyConnect::ConnectGet(
										L"\\\\.\\root\\cimv2",
										L"NonCOMTest Event Provider",
										1,
										64000,
										1000,
										NULL,
										MyConnect::DefaultCallBack
									);

	event.ObjectLocator ();

	event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
	event.Init			( L"MSFT_NonCOMTest_SCALAR_Event" );

	event.CreateObjectProps ( ( HANDLE ) ( * pConnect ) );

	event.ObjectLocator ( FALSE );
	event.MyEventObjectClear();

	pConnect->ConnectClear();

	pConnect = MyConnect::ConnectGet(
										L"abc",
										L"NonCOMTest Event Provider",
										1,
										64000,
										1000,
										NULL,
										MyConnect::DefaultCallBack
									);

	event.ObjectLocator ();

	event.InitObject	( L"root\\cimv2", L"NonCOMTest Event Provider" );
	event.Init			( L"MSFT_NonCOMTest_SCALAR_Event" );

	event.CreateObjectProps ( ( HANDLE ) ( * pConnect ) );

	event.ObjectLocator ( FALSE );
	event.MyEventObjectClear();

	pConnect->ConnectClear();

	return hr;
}

int main ( LPTSTR, int )
{
	App app;

//	app.Event1();
//	app.Event2();
//	app.Event3();
//	app.Event4();

//	app.EventGeneric();
	app.EventReport();

//	app.EventSCALAR();

//	app.Connect();

	return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\normal\main.cpp ===
#include <windows.h>
#include <stdio.h>
#include <wbemcomn.h>
#include "NCObjApi.h"

#include "events.h"

HANDLE g_hConnection;

#define NUM_EVENT_TYPES 5
#define BUFFER_SIZE  64000
#define SEND_LATENCY 1000

CNCEvent *m_pEvents[NUM_EVENT_TYPES];

HRESULT WINAPI EventSourceCallback(
    HANDLE hSource, 
    EVENT_SOURCE_MSG msg, 
    LPVOID pUser, 
    LPVOID pData)
{
    switch(msg)
    {
        case ESM_START_SENDING_EVENTS:
            printf("Start\n");
            break;

        case ESM_STOP_SENDING_EVENTS:
            printf("Stop\n");
            break;

        case ESM_NEW_QUERY:
        {
            ES_NEW_QUERY *pQuery = (ES_NEW_QUERY*) pData;
            printf("ESM_NEW_QUERY: ID %d, %S:%S", 
                pQuery->dwID,
                pQuery->szQueryLanguage,
                pQuery->szQuery);
                
            break;
        }

        case ESM_CANCEL_QUERY:
        {
            ES_CANCEL_QUERY *pQuery = (ES_CANCEL_QUERY*) pData;
            printf("ESM_CANCEL_QUERY: ID %d\r\n\r\n", 
                pQuery->dwID);
            break;
        }

        case ESM_ACCESS_CHECK:
        {
            ES_ACCESS_CHECK *pCheck = (ES_ACCESS_CHECK*) pData;

            printf("ESM_ACCESS_CHECK: %S:%S, pSID = 0x%X\r\n\r\n", 
                pCheck->szQueryLanguage,
                pCheck->szQuery,
                pCheck->pSid);

            break;
        }

        default:
            break;
    }

    return S_OK;
}

void Connect()
{
    g_hConnection =
        WmiEventSourceConnect(
            L"root\\cimv2",
            L"NCETest Event Provider",
            TRUE,
            BUFFER_SIZE,
            SEND_LATENCY,
            NULL,
            EventSourceCallback);

    if (g_hConnection != NULL)
    {
        // Setup some events.
        m_pEvents[0] = new CGenericEvent;
        m_pEvents[1] = new CBlobEvent;
        m_pEvents[2] = new CDWORDEvent;
        m_pEvents[3] = new CSmallEvent;
        m_pEvents[4] = new CSmallEvent; //CAllPropsTypeEvent;

        for (int i = 0; i < NUM_EVENT_TYPES; i++)
        {
            if (!m_pEvents[i]->Init())
            {
                printf("Trouble\n");
            }
        }
    }
    else
    {
        printf("Trouble\n");
    }
}

void Try()
{

	HANDLE hdlObject = 0;

	LPCWSTR szNames[3] = { L"Index", L"bParam", L"sParam" };
	CIMTYPE pTypes[3] = { CIM_UINT32, CIM_BOOLEAN, CIM_STRING };

	hdlObject = WmiCreateObjectWithProps(
		g_hConnection,						// Connection to the API
		L"MSFT_MyEvent",						// Name of the event class
		WMI_CREATEOBJ_LOCKABLE,				// Access to the event should be serialized by the API
		3,									// Property count
		szNames,
		pTypes);

	HANDLE hdlSubset = 0;

	DWORD dwIndices[2] = {0, 2};

	hdlSubset = WmiCreateObjectPropSubset(
		hdlObject,							// Object handle
			// Number of properties to include in subset
		WMI_CREATEOBJ_LOCKABLE,	2,			// Access to the event should be serialized by the API
		dwIndices);							// Indices of properties to pull back

	BOOL bResult = WmiSetObjectProps(
		hdlSubset,							// Object handle
		1,
		L"Test");

	bResult = WmiSetObjectPropNull(
		hdlSubset,							// Object handle
		1);									// Property index to set to NULL
}

void Try1()
{
	HANDLE hdlObject = 0;

	LPCWSTR szNames[3] = { L"Index", L"bParam"};
	CIMTYPE pTypes[3] = { CIM_UINT32, CIM_BOOLEAN | CIM_FLAG_ARRAY };

	hdlObject = WmiCreateObjectWithProps(
		g_hConnection,						// Connection to the API
		L"MSFT_MyEvent",						// Name of the event class
		WMI_CREATEOBJ_LOCKABLE,				// Access to the event should be serialized by the API
		2,									// Property count
		szNames,
		pTypes);


    BOOL arr[] = {TRUE, TRUE, TRUE};

	BOOL bResult = WmiSetObjectProps(
		hdlObject,							// Object handle
		1,
		arr,
		3);

	bResult = WmiCommitObject(hdlObject);
}
    
void __cdecl main(int argc, char** argv)
{
    Connect();
	Try1();
    getchar();

    ((CDWORDEvent*)m_pEvents[2])->SetAndFire(0);
	WmiEventSourceDisconnect(g_hConnection);
    //getchar();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\utils\array.h ===
// array.h

#pragma once

/////////////////////////////////////////////////////////////////////////////
// CArray template

#define DEF_SIZE    10
#define DEF_GROW_BY 10

template<class TYPE, class REF = TYPE> class CArray
{
public:
    CArray(int iSize = DEF_SIZE, int iGrowBy = DEF_GROW_BY) :
        m_nSize(0),
        m_nCount(0),
        m_nGrowBy(iGrowBy),
        m_pVals(NULL)
    {
        if (m_nGrowBy <= 0)
            m_nGrowBy = DEF_GROW_BY;

        if (iSize)
            Init(iSize);
    }

    CArray(const CArray& other)
    {
        *this = other;
    }

    const CArray& operator= (const CArray<TYPE, REF>& other)
    {
        Init(other.m_nCount);
        m_nCount = other.m_nCount;
        
        for (int i = 0; i < m_nCount; i++)
            m_pVals[i] = other.m_pVals[i];

        return *this;
    }

    ~CArray()
    {
        if (m_pVals)
            delete [] m_pVals;
    }

    BOOL AddVal(REF val)
    {
        if (m_nCount >= m_nSize)
        {
            TYPE *pTemp = new TYPE[m_nSize + m_nGrowBy];

            if (!pTemp)
                return FALSE;

            m_nSize += m_nGrowBy;

            for (int i = 0; i < m_nCount; i++)
                pTemp[i] = m_pVals[i];

            delete [] m_pVals;

            m_pVals = pTemp;
        }
        
        m_pVals[m_nCount++] = val;

        return TRUE;
    }

    BOOL Init(int iSize)
    {
        //if (iSize < DEF_SIZE)
        //    iSize = DEF_SIZE;

        if (iSize != m_nSize)
        {
            if (m_pVals)
                delete [] m_pVals;

            m_pVals = new TYPE[iSize];
        }

        m_nSize = iSize;
        m_nCount = 0;
        
        return m_pVals != NULL;
    }

    TYPE operator[] (int iIndex) const
    {
        return m_pVals[iIndex];
    }

    TYPE& operator[] (int iIndex)
    {
        return m_pVals[iIndex];
    }

    int GetCount() { return m_nCount; }
    void SetCount(int iCount)
    {
        //_ASSERT(iCount < m_nSize);

        m_nCount = iCount;
    }

    int GetSize() { return m_nSize; }
    void SetGrowBy(int iVal) { m_nGrowBy = iVal; }
    TYPE *GetData() { return m_pVals; }

protected:
    TYPE *m_pVals;
    int  m_nCount,
         m_nSize,
         m_nGrowBy;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\normal\events.cpp ===
// Events.cpp
#include <windows.h>
#include <stdio.h>
#include <wbemcomn.h>
#include "NCObjApi.h"
#include "Events.h"

#define COUNTOF(x)  (sizeof(x)/sizeof(x[0]))

// Some random data to send.
#define NUM_STRINGS 3
#define NUM_REFS    3
#define NUM_DATES   3

LPCWSTR szStringArray[] = { L"String1", L"String2", L"String3" };
LPCWSTR szRefArray[] = { L"Win32_Bus.DeviceID=\"PCI_BUS_0\"", 
                         L"Win32_Bus.DeviceID=\"PCI_BUS_1\"", 
                         L"Win32_Bus.DeviceID=\"Isa_BUS_0\"" };
LPCWSTR szDateArray[] = { L"199903260900**.**********", 
                          L"199903270900**.**********", 
                          L"199903280900**.**********" };
BYTE    cByteArray[] = { 0, 1, 2 };
WORD    bBoolArray[] = { 0, 1, 0, 1 };
WORD    wWordArray[] = { 3, 4, 5 };
DWORD   dwDwordArray[] = { 6, 7, 8 };
DWORD64 dwDword64Array[] = { 9, 10, 11 };
float   fFloatArray[] = { 0.25, 0.5, 0.75 };
double  dDoubleArray[] = { 1.33, 1.66, 2.0 };

// Our connections.
extern HANDLE g_hConnection;
//extern HANDLE g_hConnectionDWORD;

BOOL CGenericEvent::Init()
{
    m_strName = "Generic Event";
    m_strQuery = 
        "select * from MSFT_WMI_GenericNonCOMEvent "
        "where providername=\"NCETest Event Provider\"";

    return TRUE;
}

DWORD g_dwIndexGeneric = 0;

BOOL CGenericEvent::ReportEvent()
{
    BOOL bRet;

    bRet =
        WmiReportEvent(
            g_hConnection,
            L"MSFT_WMI_GenericNonCOMEvent",
            L"StringParam!s! Sint64Param!I64i! Uint32Param!u! "
                L"Uint8Array!c[]! StringArray!s[]! BoolArray!b[]!",                    
            L"Another string.", // StringParam
            (DWORD64) 1024,     // Sint64Param
            g_dwIndexGeneric++,              // Uint32Param
            cByteArray, COUNTOF(cByteArray), // Uint8Array,
            szStringArray, NUM_STRINGS,      // StringArray
            bBoolArray, COUNTOF(bBoolArray)  // BoolArray
        );

    return bRet;
}

BOOL CBlobEvent::Init()
{
    m_strName = "Blob Event";
    m_strQuery = 
        "select * from MSFT_NCETest_BlobEvent";

    return TRUE;
}

// Used for testing WmiReportEventBlob.
struct TEST_BLOB
{
    WCHAR szName[25];
    DWORD dwIndex;
    BYTE  cData[10];
    WCHAR szStrings[3][25];
};

TEST_BLOB g_blob = 
    { L"My blob", 0, { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }, 
        { L"String1", L"String2", L"String3" } };

BOOL CBlobEvent::ReportEvent()
{
    BOOL bRet;

    // Just to make it interesting.
    g_blob.dwIndex++;

    bRet =
        WmiReportEventBlob(
            g_hConnection,
            L"MSFT_NCETest_BlobEvent",
            &g_blob,
            sizeof(g_blob));

    return bRet;
}

BOOL CDWORDEvent::Init()
{
    LPCWSTR szIndex = L"Index";
    CIMTYPE type = CIM_UINT32;

    m_strName = "DWORD Event";
    m_strQuery = 
        "select * from MSFT_NCETest_DWORDEvent";

    m_hEvent =
        WmiCreateObjectWithProps(
            //g_hConnectionDWORD,
            g_hConnection,
            L"MSFT_NCETest_DWORDEvent",
            WMI_CREATEOBJ_LOCKABLE,
            1,
            &szIndex,
            &type);

	DWORD dw;
	WmiAddObjectProp(m_hEvent, szIndex, CIM_UINT32, &dw);

    SetPropsWithManyCalls();

    return m_hEvent != NULL;
}

DWORD g_dwIndexDWORD = 0;

BOOL CDWORDEvent::SetAndFire(DWORD dwFlags)
{
    BOOL bRet;
    
    bRet = 
        WmiSetAndCommitObject(
            m_hEvent,
            dwFlags,
            g_dwIndexDWORD++);

    printf("SetAndCommit returned %d\n", (int)bRet);

    HANDLE h = WmiDuplicateObject(m_hEvent, g_hConnection, 
                                    WMI_CREATEOBJ_LOCKABLE);
    
    bRet = 
        WmiSetAndCommitObject(
            h,
            dwFlags,
            g_dwIndexDWORD++);

    printf("Dup SetAndCommit returned %d\n", (int)bRet);

    WmiDestroyObject(h);


    return bRet;
}

BOOL CDWORDEvent::SetPropsWithOneCall()
{
    BOOL bRet;
    
    bRet = 
        WmiSetObjectProps(
            m_hEvent,
            g_dwIndexDWORD++);

    return bRet;
}

BOOL CDWORDEvent::SetPropsWithManyCalls()
{
    BOOL bRet;
    
    bRet = 
        WmiSetObjectProp(
            m_hEvent,
            0,
            g_dwIndexDWORD++);

    return bRet;
}

BOOL CDWORDEvent::ReportEvent()
{
    BOOL bRet;
    
    bRet = 
        WmiReportEvent(
            //g_hConnectionDWORD,
            g_hConnection,
            L"MSFT_NCETest_DWORDEvent",
            L"Index!d!",
            g_dwIndexDWORD++);

    return bRet;
}




BOOL CSmallEvent::Init()
{
    LPCWSTR szNames[3] = { L"Index", L"BoolParam", L"StringParam" };
    CIMTYPE pTypes[3] = { CIM_UINT32, CIM_BOOLEAN, CIM_STRING };

    m_strName = "Small Event";
    m_strQuery = 
        "select * from MSFT_NCETest_3PropEvent";

    m_hEvent =
        WmiCreateObjectWithProps(
            g_hConnection,
            L"MSFT_NCETest_3PropEvent",
            0,
            3,
            szNames,
            pTypes);

    SetPropsWithManyCalls();

    return m_hEvent != NULL;
}

DWORD g_dwIndexSmall = 0;

BOOL CSmallEvent::SetAndFire(DWORD dwFlags)
{
    BOOL bRet;

    bRet =
        WmiSetAndCommitObject(
            m_hEvent,
            dwFlags,
            g_dwIndexSmall++,
            TRUE,
            L"1");

    bRet =
        WmiSetAndCommitObject(
            m_hEvent,
            dwFlags,
            g_dwIndexSmall++,
            TRUE,
            L"WmiSetAndCommitObjectWmiSetAndCommitObjectWmiSetAndCommitObjectWmiSetAndCommitObjectWmiSetAndCommitObjectWmiSetAndCommitObjectWmiSetAndCommitObjectWmiSetAndCommitObjectWmiSetAndCommitObjectWmiSetAndCommitObjectWmiSetAndCommitObjectWmiSetAndCommitObject");

    return bRet;
}

BOOL CSmallEvent::SetPropsWithOneCall()
{
    BOOL bRet;

    bRet =
        WmiSetObjectProps(
            m_hEvent,
            g_dwIndexSmall++,
            TRUE,
            L"WmiSetObjectProps");

    return bRet;
}

BOOL CSmallEvent::ReportEvent()
{
    BOOL bRet;
    
    bRet = 
        WmiReportEvent(
            g_hConnection,
            L"MSFT_NCETest_3PropEvent",
            L"Index!d! BoolParam!b! StringParam!s!",
            g_dwIndexSmall++,
            TRUE,
            L"WmiReportEvent");

    return bRet;
}

BOOL CSmallEvent::SetPropsWithManyCalls()
{
    BOOL bRet;

    bRet =
        WmiSetObjectProp(
            m_hEvent,
            0,
            g_dwIndexSmall++);

    bRet &=
        WmiSetObjectProp(
            m_hEvent,
            1,
            TRUE);

    bRet &=
        WmiSetObjectProp(
            m_hEvent,
            2,
            L"WmiSetObjectProp");

    return bRet;
}

HANDLE hEmbeddedObjs[3];

void InitEmbeddedObjs(HANDLE hSource)
{
    LPCWSTR szProcessorNames[3] = { L"Name", L"CurrentClockSpeed", L"L2CacheSize" },
            szBusNames[3] = { L"Name", L"DeviceID", L"BusNum" },
            szBIOSNames[3] = { L"Name", L"Status", L"PrimaryBIOS" };
    CIMTYPE pProcessorTypes[3] = { CIM_STRING, CIM_UINT32, CIM_UINT32 },
            pBusTypes[3] = { CIM_STRING, CIM_STRING, CIM_UINT32 },
            pBIOSTypes[3] = { CIM_STRING, CIM_STRING, CIM_BOOLEAN };

    hEmbeddedObjs[0] =
        WmiCreateObjectWithProps(
            hSource,
            L"Win32_Processor",
            WMI_CREATEOBJ_LOCKABLE,
            3,
            szProcessorNames,
            pProcessorTypes);

    WmiSetObjectProps(
        hEmbeddedObjs[0],
        L"Intel Pentium III processor",
        800,
        256);


    hEmbeddedObjs[1] =
        WmiCreateObjectWithProps(
            hSource,
            L"Win32_Bus",
            WMI_CREATEOBJ_LOCKABLE,
            3,
            szBusNames,
            pBusTypes);

    WmiSetObjectProps(
        hEmbeddedObjs[1],
        L"Bus",
        L"PCI_BUS_1",
        5);


    hEmbeddedObjs[2] =
        WmiCreateObjectWithProps(
            hSource,
            L"Win32_BIOS",
            WMI_CREATEOBJ_LOCKABLE,
            3,
            szBIOSNames,
            pBIOSTypes);

    WmiSetObjectProps(
        hEmbeddedObjs[2],
        L"Default System BIOS",
        L"OK",
        TRUE);
}


#ifdef USE_NULLS
IWbemClassObject *pWbemClassObjs[5];
#else
IWbemClassObject *pWbemClassObjs[3];
#endif

LPCWSTR szWbemClassNames[3] = { L"Win32_Bus", L"Win32_Processor", L"Win32_BIOS" };

void InitWbemClassObjs()
{
    IWbemLocator *pLocator;
    HRESULT      hr;

    // Only do this once.
    if (pWbemClassObjs[0])
        return;

    CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if ((hr = CoCreateInstance(
        CLSID_WbemLocator,
		NULL,
		CLSCTX_INPROC_SERVER,
		IID_IWbemLocator,
		(LPVOID *) &pLocator)) == S_OK)
    {
        IWbemServices *pNamespace = NULL;

        BSTR str = SysAllocString(L"root\\cimv2");
        if ((hr = pLocator->ConnectServer(
            str,
			NULL,    // username
			NULL,	 // password
			NULL,    // locale
			0L,		 // securityFlags
			NULL,	 // authority (domain for NTLM)
			NULL,	 // context
			&pNamespace)) == S_OK) 
        {	
            pLocator->Release();

            for (int i = 0; i < 3; i++)
            {
                IWbemClassObject *pClass = NULL;

                BSTR str1 = SysAllocString(szWbemClassNames[i]);
                pNamespace->GetObject(
                    str1,
                    0,
                    NULL,
                    &pClass,
                    NULL);
                SysFreeString(str1);
            
#ifdef USE_NULLS
                // i + 1 so that the 1st and last ones will be NULL (to make sure 
                // we allow for NULLs in IWbemClassObject arrays).
                pClass->SpawnInstance(0, (IWbemClassObject**) &pWbemClassObjs[i + 1]);
#else
                pClass->SpawnInstance(0, (IWbemClassObject**) &pWbemClassObjs[i]);
#endif

                pClass->Release();
            }

            //pNamespace->Release();
        }
        SysFreeString(str);
    }

//    CoUninitialize();
}


enum PROP_INDEX
{
    PI_StringParam,
    PI_StringArray,

    PI_Char16Param,
    PI_Char16Array,

    PI_DateParam,
    PI_DateArray,

    PI_RefParam,
    PI_RefArray,

    PI_BoolParam,
    PI_BoolArray,

    PI_ObjParam,
    PI_ObjArray,

/*
    PI_WbemClassObjParam,
    PI_WbemClassObjArray,
*/

    PI_Real32Param,
    PI_Real32Array,

    PI_Real64Param,
    PI_Real64Array,

    PI_Uint8Param,
    PI_Uint8Array,
    PI_Sint8Param,
    PI_Sint8Array,

    PI_Uint16Param,
    PI_Uint16Array,
    PI_Sint16Param,
    PI_Sint16Array,

    PI_Uint32Param,
    PI_Uint32Array,
    PI_Sint32Param,
    PI_Sint32Array,

    PI_Uint64Param,
    PI_Uint64Array,
    PI_Sint64Param,
    PI_Sint64Array,
};

LPCWSTR pszProps[] = 
{ 
    L"StringParam",
    L"StringArray",

    L"Char16Param",
    L"Char16Array",

    L"DateParam",
    L"DateArray",

    L"RefParam",
    L"RefArray",

    L"BoolParam",
    L"BoolArray",

    L"ObjParam",
    L"ObjArray",

/*
    L"WbemClassObjParam",
    L"WbemClassObjArray",
*/

    L"Real32Param",
    L"Real32Array",

    L"Real64Param",
    L"Real64Array",

    L"Uint8Param",
    L"Uint8Array",
    L"Sint8Param",
    L"Sint8Array",

    L"Uint16Param",
    L"Uint16Array",
    L"Sint16Param",
    L"Sint16Array",

    L"Uint32Param",
    L"Uint32Array",
    L"Sint32Param",
    L"Sint32Array",

    L"Uint64Param",
    L"Uint64Array",
    L"Sint64Param",
    L"Sint64Array",
};

long pTypes[] = 
{  
    CIM_STRING,                     //L"StringParam",
    CIM_STRING | CIM_FLAG_ARRAY,    //L"StringArray",

    CIM_CHAR16,                     //L"Char16Param",
    CIM_CHAR16 | CIM_FLAG_ARRAY,    //L"Char16Array",

    CIM_DATETIME,                   //L"DateParam",
    CIM_DATETIME | CIM_FLAG_ARRAY,  //L"DateArray",

    CIM_REFERENCE,                  //L"RefParam",
    CIM_REFERENCE | CIM_FLAG_ARRAY, //L"RefArray",

    CIM_BOOLEAN,                    //L"BoolParam",
    CIM_BOOLEAN | CIM_FLAG_ARRAY,   //L"BoolArray",

    CIM_OBJECT,                     //L"ObjParam",
    CIM_OBJECT | CIM_FLAG_ARRAY,    //L"ObjArray",

/*
    CIM_IUNKNOWN,                   //L"WbemClassObjParam",
    CIM_IUNKNOWN | CIM_FLAG_ARRAY,  //L"WbemClassObjArray",
*/

    CIM_REAL32,                     //L"Real32Param",
    CIM_REAL32 | CIM_FLAG_ARRAY,    //L"Real32Array",

    CIM_REAL64,                     //L"Real64Param",
    CIM_REAL64 | CIM_FLAG_ARRAY,    //L"Real64Array",

    CIM_UINT8,                      //L"Uint8Param",
    CIM_UINT8 | CIM_FLAG_ARRAY,     //L"Uint8Array",
    CIM_SINT8,                      //L"Sint8Param",
    CIM_SINT8 | CIM_FLAG_ARRAY,     //L"Sint8Array",

    CIM_UINT16,                     //L"Uint16Param",
    CIM_UINT16 | CIM_FLAG_ARRAY,    //L"Uint16Array",
    CIM_SINT16,                     //L"Sint16Param",
    CIM_SINT16 | CIM_FLAG_ARRAY,    //L"Sint16Array",

    CIM_UINT32,                     //L"Uint32Param",
    CIM_UINT32 | CIM_FLAG_ARRAY,    //L"Uint32Array",
    CIM_SINT32,                     //L"Sint32Param",
    CIM_SINT32 | CIM_FLAG_ARRAY,    //L"Sint32Array",

    CIM_UINT64,                     //L"Uint64Param",
    CIM_UINT64 | CIM_FLAG_ARRAY,    //L"Uint64Array",
    CIM_SINT64,                     //L"Sint64Param",
    CIM_SINT64 | CIM_FLAG_ARRAY,    //L"Sint64Array",
};

#define NUM_PROPS  (sizeof(pTypes)/sizeof(pTypes[0]))


BOOL CAllPropsTypeEvent::Init()
{
    m_strName = "All prop types Event";
    m_strQuery = 
        "select * from MSFT_NCETest_AllPropTypesEvent";


    InitEmbeddedObjs(g_hConnection);

    m_hEvent = 
        WmiCreateObjectWithProps(
            g_hConnection,
            L"MSFT_NCETest_AllPropTypesEvent",
            0,
            NUM_PROPS,
            pszProps,
            pTypes);

    SetPropsWithManyCalls();

    return m_hEvent != NULL;
}

BOOL CAllPropsTypeEvent::SetAndFire(DWORD dwFlags)
{
    BOOL bRet;

    InitWbemClassObjs();

    bRet = 
        WmiSetAndCommitObject(
            m_hEvent,
            dwFlags,

            L"A string.",               //L"StringParam",
            szStringArray, NUM_STRINGS, //L"StringArray",

            100,                                     //L"Char16Param",
            L"Some chars.", COUNTOF(L"Some chars."), //L"Char16Array",

            L"199903260900**.**********",   //L"DateParam",
            szDateArray, NUM_DATES,         //L"DateArray",

            L"Win32_Processor.DeviceID=\"CPU0\"", //L"RefParam",
            szRefArray, NUM_REFS,                 //L"RefArray",

            FALSE,                           //L"BoolParam",
            bBoolArray, COUNTOF(bBoolArray), //L"BoolArray",

            hEmbeddedObjs[0],                       //L"ObjParam",
            hEmbeddedObjs, COUNTOF(hEmbeddedObjs),  //L"ObjArray",

/*
            pWbemClassObjs[0],                       //L"WbemClassObjParam",
            pWbemClassObjs, COUNTOF(pWbemClassObjs), //L"WbemClassObjArray",
*/

            (float) 42.3,                      //L"Real32Param",
            fFloatArray, COUNTOF(fFloatArray), //L"Real32Array",

            (double) 7.8,                        //L"Real64Param",
            dDoubleArray, COUNTOF(dDoubleArray), //L"Real64Array",

            13,                              //L"Uint8Param",
            cByteArray, COUNTOF(cByteArray), //L"Uint8Array",
        
            14,                              //L"Sint8Param",
            cByteArray, COUNTOF(cByteArray), //L"Sint8Array",

            15,                              //L"Uint16Param",
            wWordArray, COUNTOF(wWordArray), //L"Uint16Array",
    
            16,                              //L"Sint16Param",
            wWordArray, COUNTOF(wWordArray), //L"Sint16Array",

            17,                                  //L"Uint32Param",
            dwDwordArray, COUNTOF(dwDwordArray), //L"Uint32Array",
        
            18,                                  //L"Sint32Param",
            dwDwordArray, COUNTOF(dwDwordArray), //L"Sint32Array",

            (DWORD64) 19,                            //L"Uint64Param",
            dwDword64Array, COUNTOF(dwDword64Array), //L"Uint64Array",
        
            (DWORD64) 20,                            //L"Sint64Param",
            dwDword64Array, COUNTOF(dwDword64Array)  //L"Sint64Array",
        );

    return bRet;
}

BOOL CAllPropsTypeEvent::SetPropsWithOneCall()
{
    BOOL bRet;

    InitWbemClassObjs();

    bRet = 
        WmiSetObjectProps(
            m_hEvent,

            L"A string.",               //L"StringParam",
            szStringArray, NUM_STRINGS, //L"StringArray",

            100,                                     //L"Char16Param",
            L"Some chars.", COUNTOF(L"Some chars."), //L"Char16Array",

            L"199903260900**.**********",   //L"DateParam",
            szDateArray, NUM_DATES,         //L"DateArray",

            L"Win32_Processor.DeviceID=\"CPU0\"", //L"RefParam",
            szRefArray, NUM_REFS,                 //L"RefArray",

            FALSE,                           //L"BoolParam",
            bBoolArray, COUNTOF(bBoolArray), //L"BoolArray",

            hEmbeddedObjs[0],                       //L"ObjParam",
            hEmbeddedObjs, COUNTOF(hEmbeddedObjs),  //L"ObjArray",

/*
            pWbemClassObjs[0],                       //L"WbemClassObjParam",
            pWbemClassObjs, COUNTOF(pWbemClassObjs), //L"WbemClassObjArray",
*/

            (float) 42.3,                      //L"Real32Param",
            fFloatArray, COUNTOF(fFloatArray), //L"Real32Array",

            (double) 7.8,                        //L"Real64Param",
            dDoubleArray, COUNTOF(dDoubleArray), //L"Real64Array",

            13,                              //L"Uint8Param",
            cByteArray, COUNTOF(cByteArray), //L"Uint8Array",
        
            14,                              //L"Sint8Param",
            cByteArray, COUNTOF(cByteArray), //L"Sint8Array",

            15,                              //L"Uint16Param",
            wWordArray, COUNTOF(wWordArray), //L"Uint16Array",
    
            16,                              //L"Sint16Param",
            wWordArray, COUNTOF(wWordArray), //L"Sint16Array",

            17,                                  //L"Uint32Param",
            dwDwordArray, COUNTOF(dwDwordArray), //L"Uint32Array",
        
            18,                                  //L"Sint32Param",
            dwDwordArray, COUNTOF(dwDwordArray), //L"Sint32Array",

            (DWORD64) 19,                            //L"Uint64Param",
            dwDword64Array, COUNTOF(dwDword64Array), //L"Uint64Array",
        
            (DWORD64) 20,                            //L"Sint64Param",
            dwDword64Array, COUNTOF(dwDword64Array)  //L"Sint64Array",
        );

    return bRet;
}

BOOL CAllPropsTypeEvent::ReportEvent()
{
    BOOL bRet;

    InitWbemClassObjs();

    bRet = 
        WmiReportEvent(
            g_hConnection,
            
            // Class name
            L"MSFT_NCETest_AllPropTypesEvent",

            // Property info
            L"StringParam!s! StringArray!s[]! Char16Param!w! Char16Array!w[]! "
            L"DateParam!s! DateArray!s[]! RefParam!s! RefArray!s[]! "
            L"BoolParam!b! BoolArray!b[]! ObjParam!o! ObjArray!o[]! "
//            L"WbemClassObjParam!O! WbemClassObjArray!O[]! "
            L"Real32Param!f! Real32Array!f[]! Real64Param!g! Real64Array!g[]! "
            L"Uint8Param!c! Uint8Array!c[]! Sint8Param!c! Sint8Array!c[]! "
            L"Uint16Param!w! Uint16Array!w[]! Sint16Param!w! Sint16Array!w[]! "
            L"Uint32Param!u! Uint32Array!u[]! Sint32Param!u! Sint32Array!u[]! "
            L"Uint64Param!I64u! Uint64Array!I64u[]! Sint64Param!I64u! Sint64Array!I64u[]! ",
                
            // Data
            L"A string.",               //L"StringParam",
            szStringArray, NUM_STRINGS, //L"StringArray",

            100,                                     //L"Char16Param",
            L"Some chars.", COUNTOF(L"Some chars."), //L"Char16Array",

            L"199903260900**.**********",   //L"DateParam",
            szDateArray, NUM_DATES,         //L"DateArray",

            L"Win32_Processor.DeviceID=\"CPU0\"", //L"RefParam",
            szRefArray, NUM_REFS,                 //L"RefArray",

            FALSE,                           //L"BoolParam",
            bBoolArray, COUNTOF(bBoolArray), //L"BoolArray",

            hEmbeddedObjs[0],                       //L"ObjParam",
            hEmbeddedObjs, COUNTOF(hEmbeddedObjs),  //L"ObjArray",

/*
            pWbemClassObjs[0],                       //L"WbemClassObjParam",
            pWbemClassObjs, COUNTOF(pWbemClassObjs), //L"WbemClassObjArray",
*/

            (float) 42.3,                      //L"Real32Param",
            fFloatArray, COUNTOF(fFloatArray), //L"Real32Array",

            (double) 7.8,                        //L"Real64Param",
            dDoubleArray, COUNTOF(dDoubleArray), //L"Real64Array",

            13,                              //L"Uint8Param",
            cByteArray, COUNTOF(cByteArray), //L"Uint8Array",
        
            14,                              //L"Sint8Param",
            cByteArray, COUNTOF(cByteArray), //L"Sint8Array",

            15,                              //L"Uint16Param",
            wWordArray, COUNTOF(wWordArray), //L"Uint16Array",
    
            16,                              //L"Sint16Param",
            wWordArray, COUNTOF(wWordArray), //L"Sint16Array",

            17,                                  //L"Uint32Param",
            dwDwordArray, COUNTOF(dwDwordArray), //L"Uint32Array",
        
            18,                                  //L"Sint32Param",
            dwDwordArray, COUNTOF(dwDwordArray), //L"Sint32Array",

            (DWORD64) 19,                            //L"Uint64Param",
            dwDword64Array, COUNTOF(dwDword64Array), //L"Uint64Array",
        
            (DWORD64) 20,                            //L"Sint64Param",
            dwDword64Array, COUNTOF(dwDword64Array)  //L"Sint64Array",
        );

    return bRet;
}

BOOL CAllPropsTypeEvent::SetPropsWithManyCalls()
{
    BOOL bRet;

    InitWbemClassObjs();

    bRet = 
        WmiSetObjectProp(
            m_hEvent,
            PI_StringParam,
            L"A very very very very long string."               //L"StringParam",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_StringParam,
            L"A short string."               //L"StringParam",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_StringArray,
            szStringArray, NUM_STRINGS  //L"StringArray",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Char16Param,
            100                                      //L"Char16Param",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Char16Array,
            L"Some chars.", COUNTOF(L"Some chars.")  //L"Char16Array",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_DateParam,
            L"199903260900**.**********"    //L"DateParam",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Char16Param,
            100                                     //L"Char16Param",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_DateArray,
            szDateArray, NUM_DATES          //L"DateArray",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_RefParam,
            L"Win32_Processor.DeviceID=\"CPU0\""  //L"RefParam",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_RefArray,
            szRefArray, NUM_REFS                  //L"RefArray",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_BoolParam,
            FALSE                            //L"BoolParam",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_BoolArray,
            bBoolArray, COUNTOF(bBoolArray)  //L"BoolArray",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_ObjParam,
            hEmbeddedObjs[0]                        //L"ObjParam",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_ObjArray,
            hEmbeddedObjs, COUNTOF(hEmbeddedObjs)   //L"ObjArray",
        );

/*
    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_WbemClassObjParam,
            pWbemClassObjs[0]                        //L"ObjParam",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_WbemClassObjArray,
            pWbemClassObjs, COUNTOF(pWbemClassObjs)   //L"ObjArray",
        );
*/

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Real32Param,
            (float) 42.3                       //L"Real32Param",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Real32Array,
            fFloatArray, COUNTOF(fFloatArray)  //L"Real32Array",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Real64Param,
            (double) 7.8                         //L"Real64Param",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Real64Array,
            dDoubleArray, COUNTOF(dDoubleArray)  //L"Real64Array",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Uint8Param,
            13                               //L"Uint8Param",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Uint8Array,
            cByteArray, COUNTOF(cByteArray)  //L"Uint8Array",
        );
        
    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Sint8Param,
            14                               //L"Sint8Param",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Sint8Array,
            cByteArray, COUNTOF(cByteArray)  //L"Sint8Array",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Uint16Param,
            15                               //L"Uint16Param",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Uint16Array,
            wWordArray, COUNTOF(wWordArray)  //L"Uint16Array",
        );
    
    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Sint16Param,
            16                               //L"Sint16Param",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Sint16Array,
            wWordArray, COUNTOF(wWordArray)  //L"Sint16Array",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Uint32Param,
            17                                   //L"Uint32Param",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Uint32Array,
            dwDwordArray, COUNTOF(dwDwordArray)  //L"Uint32Array",
        );
        
    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Sint32Param,
            18                                   //L"Sint32Param",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Sint32Array,
            dwDwordArray, COUNTOF(dwDwordArray)  //L"Sint32Array",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Uint64Param,
            (DWORD64) 19                             //L"Uint64Param",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Uint64Array,
            dwDword64Array, COUNTOF(dwDword64Array)  //L"Uint64Array",
        );
        
    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Sint64Param,
            (DWORD64) 20                             //L"Sint64Param",
        );

    bRet &= 
        WmiSetObjectProp(
            m_hEvent,
            PI_Sint64Array,
            dwDword64Array, COUNTOF(dwDword64Array)  //L"Sint64Array",
        );

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\utils\buffer.cpp ===
#include "precomp.h"

#include <pshpack1.h>
#include "buffer.h"
#include <poppack.h>

#define DWORD_ALIGNED(x)    (((x) + 3) & ~3)
#define QWORD_ALIGNED(x)    (((x) + 7) & ~7)

#ifdef _WIN64
#define DEF_ALIGNED         QWORD_ALIGNED
#else
#define DEF_ALIGNED         DWORD_ALIGNED
#endif

#ifdef _ASSERT
#undef _ASSERT
#endif

#ifdef DBG
#define _ASSERT(X) { if (!(X)) { DebugBreak(); } }
#else
#define _ASSERT(X)
#endif

CBuffer::CBuffer(LPCVOID pBuffer, DWORD_PTR dwSize, ALIGN_TYPE type) :
	m_bAllocated(FALSE),
	m_pBuffer(NULL),
    m_pCurrent(NULL)
{
    LPBYTE pRealBuffer;

	// Align the buffer if necessary.
    if (type == ALIGN_NONE)
        pRealBuffer = (LPBYTE) pBuffer;
    else if (type == ALIGN_DWORD)
        pRealBuffer = (LPBYTE) DWORD_ALIGNED((DWORD_PTR) pBuffer);
    else if (type == ALIGN_QWORD)
        pRealBuffer = (LPBYTE) QWORD_ALIGNED((DWORD_PTR) pBuffer);
    else if (type == ALIGN_DWORD_PTR)
        pRealBuffer = (LPBYTE) DEF_ALIGNED((DWORD_PTR) pBuffer);
	else
		// Caller passed an invalid type.
		_ASSERT(FALSE);

    dwSize -= pRealBuffer - (LPBYTE) pBuffer;

	Reset(pRealBuffer, dwSize);
}

CBuffer::CBuffer(DWORD_PTR dwSize) :
	m_bAllocated(FALSE),
	m_pBuffer(NULL)
{
	Reset(NULL, dwSize);
}

CBuffer::CBuffer(const CBuffer &other) :
	m_bAllocated(FALSE),
	m_pBuffer(NULL)
{
	*this = other;
}

void CBuffer::Reset(LPCVOID pBuffer, DWORD_PTR dwSize)
{
	Free();

	if (!pBuffer)
	{
        pBuffer = malloc(dwSize);
		
        if (!pBuffer)
            throw CBufferException(GetLastError());

        m_bAllocated = TRUE;
	}
    else
        m_bAllocated = FALSE;

	m_pCurrent = m_pBuffer = (LPBYTE) pBuffer;
	m_dwSize = dwSize;
}

CBuffer::~CBuffer()
{
    Free();
}

void CBuffer::Free()
{
	if (m_bAllocated && m_pBuffer)
    {
		free(m_pBuffer);

        m_pBuffer = NULL;
    }
}

BOOL CBuffer::Write(LPCSTR szVal)
{
    return Write(szVal, lstrlenA(szVal) + 1);
}

BOOL CBuffer::Write(LPCWSTR szVal)
{
    return Write(szVal, (wcslen(szVal) + 1) * sizeof(WCHAR));
}

/*
BOOL CBuffer::WriteLenStr(LPCSTR szVal)
{
    WORD wLen = szVal ? strlen(szVal) + 1 : 0;
    BOOL bRet;

    bRet = Write(wLen);

    if (bRet && wLen)
        bRet = Write(szVal, wLen); 

    return bRet;
}

BOOL CBuffer::WriteLenStr(LPCWSTR szVal)
{
    WORD wLen = szVal ? (wcslen(szVal) + 1) * sizeof(WCHAR) : 0;
    BOOL bRet;

    bRet = Write(wLen);

    if (bRet && wLen)
        bRet = Write(szVal, wLen); 

    return bRet;
}
*/

BOOL CBuffer::Resize(DWORD_PTR dwNewSize)
{
	if (m_pBuffer)
	{
        DWORD_PTR dwUsedSize = GetUsedSize();

        LPBYTE pNewBuffer;
        
        if (m_bAllocated)
        {
            pNewBuffer = (LPBYTE) realloc(m_pBuffer, dwNewSize);

            if (!pNewBuffer)
            {
                pNewBuffer = (LPBYTE) malloc(dwNewSize);

                if (!pNewBuffer)
                    throw CBufferException(0);

                memcpy(pNewBuffer, m_pBuffer, dwUsedSize);

                free(m_pBuffer);
            }
        }
        else
        {
            pNewBuffer = (LPBYTE) malloc(dwNewSize);
		
            if (!pNewBuffer)
                throw CBufferException(0);

            memcpy(pNewBuffer, m_pBuffer, dwUsedSize);

            m_bAllocated = TRUE;

            // Free not needed because we didn't allocate the original memory.
        }

        m_pBuffer = pNewBuffer;
        m_pCurrent = pNewBuffer + dwUsedSize;
        m_dwSize = dwNewSize;

        // Inform the buffer that we reallocated.
        OnResize();
	}
    else
        Reset(dwNewSize);

    return TRUE;
}

BOOL CBuffer::WriteAlignedLenString(LPCWSTR szVal)
{
    DWORD dwLen = (wcslen(szVal) + 1) * sizeof(WCHAR),
          dwLenAligned = DWORD_ALIGNED(dwLen);
    BOOL  bRet;

    bRet = Write(dwLen);

    if (bRet)
    {
        bRet = Write(szVal, dwLen); 

        if (bRet)
            // Move current to make up for the padding, if needed.
            MoveCurrent(dwLenAligned - dwLen);
    }

    return bRet;
}

#define DEF_GROW_BY 256

void CBuffer::AssureSizeRemains(DWORD_PTR dwSize)
{
    DWORD_PTR dwUnusedSize = GetUnusedSize();

    if (dwSize > dwUnusedSize)
    {
        Grow(max(dwSize - dwUnusedSize, DEF_GROW_BY));
    }
}

BOOL CBuffer::Write(DWORD dwVal)
{
	AssureSizeRemains(sizeof(dwVal));

    *((DWORD *) m_pCurrent) = dwVal;

    m_pCurrent += sizeof(dwVal);

    return TRUE;
}

BOOL CBuffer::Write(DWORD64 dwVal)
{
	AssureSizeRemains(sizeof(dwVal));

    *((DWORD64 *) m_pCurrent) = dwVal;

    m_pCurrent += sizeof(dwVal);

    return TRUE;
}

BOOL CBuffer::Write(BYTE cVal)
{
	AssureSizeRemains(sizeof(cVal));
    
    *((BYTE *) m_pCurrent) = cVal;
	
    m_pCurrent += sizeof(cVal);
    
    return TRUE;
}

BOOL CBuffer::Write(WORD wVal)
{
	AssureSizeRemains(sizeof(wVal));

    *((WORD *) m_pCurrent) = wVal;

    m_pCurrent += sizeof(WORD);  

    return TRUE;
}

LPCTSTR CBuffer::ReadString(LPSTR szValue, DWORD dwSize)
{
	DWORD nSize;
	
	nSize = lstrlenA((LPSTR) m_pCurrent) + 1;

	// Make sure the string didn't overrun the buffer.
	if (m_pCurrent + nSize <= m_pBuffer + m_dwSize)
	{
		memcpy(szValue, m_pCurrent, min(nSize, dwSize));
		
		// Make sure it's null terminated.
		szValue[dwSize - 1] = 0;
	}
	else
		// Something went wrong with the sizes.  Just return 0.
		*szValue = 0;

	m_pCurrent += nSize;

	return (LPCTSTR) szValue;
}

LPCTSTR CBuffer::ReadString(LPWSTR szValue, DWORD dwSize)
{
	DWORD nSize;
	
	nSize = (wcslen((LPWSTR) m_pCurrent) + 1) * sizeof(WCHAR);

	// Make sure the string didn't overrun the buffer.
	if (m_pCurrent + nSize <= m_pBuffer + m_dwSize)
	{
		memcpy(szValue, m_pCurrent, min(nSize, dwSize));
		
		// Make sure it's null terminated.
		szValue[dwSize - 1] = 0;
	}
	else
		// Something went wrong with the sizes.  Just return 0.
		*szValue = 0;

	m_pCurrent += nSize;

	return (LPCTSTR) szValue;
}

DWORD CBuffer::ReadDWORD()
{
#ifndef _WIN32_WCE
	DWORD dwVal = *((DWORD *) m_pCurrent);
#else
    DWORD dwVal;

    memcpy(&dwVal, m_pCurrent, sizeof(DWORD));
#endif
	
	m_pCurrent += sizeof(dwVal);

	return dwVal;
}

BYTE CBuffer::ReadBYTE()
{
	BYTE cVal = *((BYTE *) m_pCurrent);
	
	m_pCurrent += sizeof(cVal);

	return cVal;
}

WORD CBuffer::ReadWORD()
{
#ifndef _WIN32_WCE
	WORD wVal = *((WORD *) m_pCurrent);
#else
    WORD wVal;

    memcpy(&wVal, m_pCurrent, sizeof(WORD));
#endif
	
	m_pCurrent += sizeof(wVal);

	return wVal;
}

BOOL CBuffer::Read(LPVOID pBuffer, DWORD dwToRead)
{
	if (m_pCurrent + dwToRead > m_pBuffer + m_dwSize)
		return FALSE;
		
	memcpy(pBuffer, m_pCurrent, dwToRead);
	m_pCurrent += dwToRead; 

	return TRUE;
}

BOOL CBuffer::Write(LPCVOID pBuffer, DWORD dwSize)
{
    AssureSizeRemains(dwSize);

    memcpy(m_pCurrent, pBuffer, dwSize);
	
    m_pCurrent += dwSize;

	return TRUE;
}

BOOL CBuffer::operator ==(const CBuffer &other)
{
	if (!m_pBuffer && !other.m_pBuffer)
		return TRUE;

	// See if the sizes aren't the same, or if either buffer is NULL,
	// return FALSE.
	if (m_dwSize != other.m_dwSize || !m_pBuffer || !other.m_pBuffer)
		return FALSE;

	// Compare the buffers.
	return !memcmp(m_pBuffer, other.m_pBuffer, m_dwSize);
}

const CBuffer& CBuffer::operator =(const CBuffer &other)
{
	// NULL so we allocate our own buffer.
	Reset(NULL, other.m_dwSize);
	
	// Copy the bits.
	memcpy(m_pBuffer, other.m_pBuffer, other.m_dwSize);

	return *this;
}

BOOL CBuffer::ConsumeStringA()
{
	LPBYTE pEnd = m_pBuffer + m_dwSize;

    while (m_pCurrent < pEnd && *m_pCurrent != 0)
        m_pCurrent++;

    if (*m_pCurrent == 0)
    {
        m_pCurrent++;
        return TRUE;
    }
    else
        return FALSE;
}

BOOL CBuffer::ConsumeStringW()
{
	LPBYTE pEnd = m_pBuffer + m_dwSize;

    while (m_pCurrent < pEnd && *(WCHAR*)m_pCurrent != 0)
        m_pCurrent += sizeof(WCHAR);

    if (*(WCHAR*)m_pCurrent == 0)
    {
        m_pCurrent += sizeof(WCHAR);
        return TRUE;
    }
    else
        return FALSE;
}

LPWSTR CBuffer::ReadAlignedLenString(DWORD *pdwBytes)
{
    LPWSTR szRet = (LPWSTR) (m_pCurrent + sizeof(DWORD));

    *pdwBytes = *(DWORD*) m_pCurrent;

    m_pCurrent += DWORD_ALIGNED(*pdwBytes) + sizeof(DWORD);

    return szRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\utils\buffer.h ===
#ifndef _BUFFER_H
#define _BUFFER_H

// m_iError uses Win32 error codes.
class CBufferException
{
public:
    CBufferException(int iErr)
    {
        m_iError = iErr;
    }

    int m_iError;
};

class CBuffer
{
public:
	LPBYTE    m_pBuffer,
			  m_pCurrent;
	DWORD_PTR m_dwSize;

	enum ALIGN_TYPE
    {
        ALIGN_NONE,
        ALIGN_DWORD,
        ALIGN_QWORD,
        ALIGN_DWORD_PTR
    };

    CBuffer(LPCVOID pBuffer, DWORD_PTR dwSize, ALIGN_TYPE type = ALIGN_NONE);
	CBuffer(DWORD_PTR dwSize = 0);
	CBuffer(const CBuffer &other);
	virtual ~CBuffer();
	BOOL Write(LPCSTR szVal);
	BOOL Write(LPCWSTR szVal);
	BOOL Write(DWORD dwVal);
	BOOL Write(DWORD64 dwVal);
	BOOL Write(BYTE cVal);
	BOOL Write(WORD wVal);
	BOOL Write(LPCVOID pBuffer, DWORD dwSize);

	//BOOL WriteLenStr(LPCSTR szVal);
	//BOOL WriteLenStr(LPCWSTR szVal);
	BOOL WriteAlignedLenString(LPCWSTR szVal);

	LPCTSTR ReadString(LPSTR szValue, DWORD dwSize = 256);
	LPCTSTR ReadString(LPWSTR szValue, DWORD dwSize = 256);
	DWORD ReadDWORD();
	BYTE ReadBYTE();
	WORD ReadWORD();
    LPWSTR ReadAlignedLenString(DWORD *pdwBytes);
	short int ReadShortInt();
	BOOL Read(LPVOID pBuffer, DWORD dwToRead);

	void Reset() {m_pCurrent = m_pBuffer;}
	void Reset(LPCVOID pBuffer, DWORD_PTR dwSize);
	void Reset(DWORD_PTR dwSize) { Reset(NULL, dwSize); }
    BOOL Resize(DWORD_PTR dwNewSize);
    BOOL Grow(DWORD_PTR dwGrowBy)
    {
        return Resize(m_dwSize + dwGrowBy);
    }

	// Will make sure dwSize bytes are available.  If not, it will call
    // Resize.  If that fails, it throws a CBufferException.
    void AssureSizeRemains(DWORD_PTR dwSize);

    BOOL IsEOF() {return m_pCurrent >= m_pBuffer + m_dwSize;}
	DWORD_PTR GetUsedSize() {return m_pCurrent - m_pBuffer;}
	DWORD_PTR GetUnusedSize() {return m_dwSize - (m_pCurrent - m_pBuffer);}
	void SetUsedSize(DWORD_PTR dwSize) {m_pCurrent = m_pBuffer + dwSize;}
    void SetEOF() { m_pCurrent = m_pBuffer + m_dwSize; }
    
    // A safe way to move m_pCurrent.
    void MoveCurrent(int iOffset)
    {
        if (iOffset > 0)
            AssureSizeRemains(iOffset);

        m_pCurrent += iOffset;
    }

	BOOL operator ==(const CBuffer &other);
	const CBuffer& operator =(const CBuffer &other);

    BOOL ConsumeStringA();
    BOOL ConsumeStringW();

    // This gets called when the buffer is realloced.  Override with your own
    // behavior if necessary.
    virtual void OnResize()
    {
    }

protected:
	BOOL m_bAllocated;

	void Free();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\normal\events.h ===
// Events.h

class CNCEvent
{
public:
    WString m_strName,
            m_strQuery;

    virtual ~CNCEvent()
    {
    }

    virtual BOOL Init() = 0;
    virtual BOOL ReportEvent() = 0;
};

class CGenericEvent : public CNCEvent
{
public:
    BOOL Init();
    BOOL ReportEvent();
};

class CBlobEvent : public CNCEvent
{
public:
    BOOL Init();
    BOOL ReportEvent();
};

class CPropEvent : public CNCEvent
{
public:
    HANDLE m_hEvent;

    CPropEvent() :
        m_hEvent(NULL)
    {
    }

    BOOL Commit()
    {
        return WmiCommitObject(m_hEvent);
    }

    virtual ~CPropEvent()
    {
        if (m_hEvent)
            WmiDestroyObject(m_hEvent);
    }

    virtual BOOL SetAndFire(DWORD dwFlags)
    {
        return FALSE;
    }

    virtual BOOL SetPropsWithOneCall() = 0;
    virtual BOOL SetPropsWithManyCalls() = 0;
    virtual BOOL ReportEvent()
    {
        return FALSE;
    }
};

class CDWORDEvent : public CPropEvent
{
public:
    BOOL Init();
    BOOL SetAndFire(DWORD dwFlags);
    BOOL SetPropsWithOneCall();
    BOOL SetPropsWithManyCalls();
    BOOL ReportEvent();
};

class CSmallEvent : public CPropEvent
{
public:
    BOOL Init();
    BOOL SetAndFire(DWORD dwFlags);
    BOOL SetPropsWithOneCall();
    BOOL SetPropsWithManyCalls();
    BOOL ReportEvent();
};

class CAllPropsTypeEvent : public CPropEvent
{
public:
    BOOL Init();
    BOOL SetAndFire(DWORD dwFlags);
    BOOL SetPropsWithOneCall();
    BOOL SetPropsWithManyCalls();
    BOOL ReportEvent();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\utils\objaccess.cpp ===
#include "precomp.h"
#include "ObjAccess.h"

/////////////////////////////////////////////////////////////////////////////
// CProp

BOOL CObjAccess::InitDataForArray(CProp *pProp, DWORD dwItems, DWORD dwItemSize)
{
    BOOL  bRet = FALSE;
    DWORD dwSizeNeeded = dwItems * dwItemSize;

    // Make room for the data if we need to.
	//if (pProp->m_dwSize != dwSizeNeeded)
    {
        _variant_t     vValue;
        SAFEARRAYBOUND sabound;
        VARTYPE        typeBase = (VARTYPE)(pProp->m_type & ~VT_ARRAY);

        sabound.lLbound = 0;
        sabound.cElements = dwItems;

        pProp->m_dwSize = 0;
        
        // Fix up some of these for WinMgmt.
        if (typeBase == CIM_UINT64 || typeBase == CIM_SINT64)
            // Commented out because this function should never be called with
            // these two types.
            //typeBase == CIM_DATETIME || typeBase == CIM_REFERENCE)
            typeBase = VT_BSTR;
        else if (typeBase == VT_UI4)
            typeBase = VT_I4;
        else if (typeBase == VT_UI2)
            typeBase = VT_I2;
        else if (typeBase == VT_I1)
            typeBase = VT_UI1;
        else if (typeBase == CIM_CHAR16)
            typeBase = VT_I2;

        if ((V_ARRAY(&vValue) = SafeArrayCreate(typeBase, 1, &sabound)) != NULL)
        {
            V_VT(&vValue) = typeBase | VT_ARRAY; 

            // This is to make sure we have valid strings when calling Put().
            if (typeBase == VT_BSTR)
            {
                LPCWSTR *pStrings = (LPCWSTR*) vValue.parray->pvData;

                for (DWORD i = 0; i < dwItems; i++)
                    pStrings[i] = L"0";
            }

            HRESULT hr =
                m_pObj->Put(
                    pProp->m_strName,
                    0,
                    &vValue,
                    0);

            bRet = SUCCEEDED(hr);

            _ASSERT(bRet);

            // Clear this out since we didn't use SysAlloc'ed BSTRs.
            if (typeBase == VT_BSTR)
                ZeroMemory(vValue.parray->pvData, sizeof(BSTR) * dwItems);

            if (bRet)
                pProp->m_dwSize = dwSizeNeeded;
            else
                pProp->m_dwSize = 0;
        }
    }

    //if (pProp->m_dwSize == dwSizeNeeded)
    {
        HRESULT hr;
        DWORD   nCount;

        hr =
            m_pWmiObj->GetArrayPropAddrByHandle(
                pProp->m_lHandle,
                0,
                &nCount,
                &pProp->m_pData);
                   
        _ASSERT(nCount == dwItems);

        //pProp->m_pData = m_pWmiObj->GetArrayByHandle(pProp->m_lHandle);

        if (SUCCEEDED(hr))
            bRet = TRUE;
        else
        {
            bRet = FALSE;
            pProp->m_pData = NULL;
            pProp->m_dwSize = 0;
        }
    }

    return bRet;
}

/////////////////////////////////////////////////////////////////////////////
// CObjAccess

//static BOOL bFirst = TRUE;
//FPGET_PROPERTY_HANDLE_EX CObjAccess::m_pGetPropertyHandleEx;
//FPGET_ARRAY_BY_HANDLE CObjAccess::m_pGetArrayByHandle;

CObjAccess::CObjAccess() :
    m_pObj(NULL),
    m_pObjAccess(NULL),
    m_pWmiObj(NULL),
    m_pProps(0)
{
/*
    if (bFirst)
    {
        bFirst = FALSE;

        // I tried doing directly (from GetProcAddress into memember vars) but
        // I couldn't come up with a conversion the compiler would let me do.
        // So, do it the hard way.
        HINSTANCE hWbemComn = GetModuleHandle(_T("wbemcomn.dll"));
        FARPROC   fpGetPropertyHandleEx = 
                    GetProcAddress(
                        hWbemComn, 
                        "?GetPropertyHandleEx@CWbemObject@@UAGJPBGJPAJ1@Z"),
                        //"?GetPropertyHandleEx@CWbemObject@@QAEJPBGPAJ1@Z"),
                  fpGetArrayByHandle =
                    GetProcAddress(
                        hWbemComn, 
                        "?GetArrayByHandle@CWbemObject@@QAEPAVCUntypedArray@@J@Z");

        memcpy(
            &m_pGetPropertyHandleEx, 
            &fpGetPropertyHandleEx, 
            sizeof(fpGetPropertyHandleEx));

        memcpy(
            &m_pGetArrayByHandle, 
            &fpGetArrayByHandle, 
            sizeof(fpGetArrayByHandle));
    }
*/
}

CObjAccess::CObjAccess(const CObjAccess& other) :
    m_pProps(other.m_pProps),
    m_pObj(NULL),
    m_pObjAccess(NULL),
    m_pWmiObj(NULL)
{
    other.m_pObj->Clone(&m_pObj);

    m_pObj->QueryInterface(
        IID_IWbemObjectAccess, 
        (LPVOID*) &m_pObjAccess);
    m_pObj->QueryInterface(
        IID__IWmiObject, 
        (LPVOID*) &m_pWmiObj);
}

CObjAccess::~CObjAccess()
{
    if (m_pObjAccess)
        m_pObjAccess->Release();

    if (m_pObj)
        m_pObj->Release();

    if (m_pWmiObj)
        m_pWmiObj->Release();
}

    
const CObjAccess& CObjAccess::operator=(const CObjAccess& other)
{
    m_pProps = other.m_pProps;

    other.m_pObj->Clone(&m_pObj);

    m_pObj->QueryInterface(
        IID_IWbemObjectAccess, 
        (LPVOID*) &m_pObjAccess);

    m_pObj->QueryInterface(
        IID__IWmiObject, 
        (LPVOID*) &m_pWmiObj);

    return *this;
}

BOOL CObjAccess::Init(
    IWbemServices *pSvc,
    LPCWSTR szClass,
    LPCWSTR *pszPropNames,
    DWORD nProps,
    INIT_FAILED_PROP_TYPE typeFail)
{
    IWbemClassObject *pClass = NULL;
    BOOL             bRet = FALSE;

    if (SUCCEEDED(pSvc->GetObject(
        _bstr_t(szClass), 
        0, 
        NULL, 
        &pClass, 
        NULL)) &&
        SUCCEEDED(pClass->SpawnInstance(0, &m_pObj)))
    {
        // Get out if we don't need the whole IWbemObjectAccess stuff.
        if (nProps == 0)
            return TRUE;

        m_pObj->QueryInterface(IID_IWbemObjectAccess, (LPVOID*) &m_pObjAccess);
        m_pObj->QueryInterface(IID__IWmiObject, (LPVOID*) &m_pWmiObj);

        if (m_pProps.Init(nProps))
        {
            m_pProps.SetCount(nProps);
            
            bRet = TRUE;

            for (DWORD i = 0; i < nProps; i++)
            {
                CProp &prop = m_pProps[i];

                if(m_pWmiObj)
                {
                    if (SUCCEEDED(m_pWmiObj->GetPropertyHandleEx(
                        pszPropNames[i],
                        0,
                        &prop.m_type,
                        &prop.m_lHandle)))
                    {
                        prop.m_strName = pszPropNames[i];
                    }
                }
                else
                {
                    if (SUCCEEDED(m_pObjAccess->GetPropertyHandle(
                        pszPropNames[i],
                        &prop.m_type,
                        &prop.m_lHandle)))
                    {
                        prop.m_strName = pszPropNames[i];
                    }
                }
            }
        }
    }

    if (pClass)
        pClass->Release();
    
    return bRet;    
}

BOOL CObjAccess::WriteData(DWORD dwIndex, LPVOID pData, DWORD dwSize)
{
    CProp &prop = m_pProps[dwIndex];
    BOOL  bRet = FALSE;

    // This function only works for non arrays.
    _ASSERT((prop.m_type & CIM_FLAG_ARRAY) == 0);

    bRet =  
        SUCCEEDED(m_pObjAccess->WritePropertyValue(
            prop.m_lHandle,
            dwSize,
            (LPBYTE) pData));

    return bRet;
}

BOOL CObjAccess::WriteArrayData(DWORD dwIndex, LPVOID pData, DWORD dwItemSize)
{
    if(m_pWmiObj == NULL)
        return TRUE; // pretend we did it

    CProp &prop = m_pProps[dwIndex];

    // This function only works for arrays.
    _ASSERT(prop.m_type & CIM_FLAG_ARRAY);
    
    // The SetArrayPropRangeByHandle is currently broken.  Remove once Sanj
    // gets it fixed.
    //return TRUE;
    
    DWORD   dwItems = *(DWORD*) pData,
            dwSize = dwItems * dwItemSize;

    //if (prop.m_dwMaxSize != dwSize)
    //    InitDataForArray(&prop, dwItems, dwItemSize);
            
    //return TRUE;

#if 1
    //return TRUE;

    HRESULT hr;

    hr =
        m_pWmiObj->SetArrayPropRangeByHandle(
            prop.m_lHandle,
            WMIARRAY_FLAG_ALLELEMENTS, // flags
            0,                         // start index
            dwItems,                   // # items
            dwSize,                    // buffer size
            ((LPBYTE) pData) + sizeof(DWORD)); // data buffer

    return SUCCEEDED(hr);
#else
    BOOL bRet;

    bRet = InitDataForArray(&prop, dwItems, dwItemSize);

    if (bRet)
        memcpy(prop.m_pData, ((LPBYTE) pData) + sizeof(DWORD), dwSize);

    return bRet;
#endif
}

BOOL CObjAccess::WriteNonPackedArrayData(
    DWORD dwIndex, 
    LPVOID pData, 
    DWORD dwItems, 
    DWORD dwTotalSize)
{
    if(m_pWmiObj == NULL)
        return TRUE; // pretend we did it

    CProp   &prop = m_pProps[dwIndex];
    HRESULT hr;

    // This function only works for arrays.
    _ASSERT(prop.m_type & CIM_FLAG_ARRAY);

    hr =
        m_pWmiObj->SetArrayPropRangeByHandle(
            prop.m_lHandle,
            WMIARRAY_FLAG_ALLELEMENTS, // flags
            0,                         // start index
            dwItems,                   // # items
            dwTotalSize,               // buffer size
            pData);                    // data buffer

    return SUCCEEDED(hr);
}


BOOL CObjAccess::WriteString(DWORD dwIndex, LPCWSTR szValue)
{
    return 
        SUCCEEDED(m_pObjAccess->WritePropertyValue(
            m_pProps[dwIndex].m_lHandle, 
            (wcslen(szValue) + 1) * sizeof(WCHAR),
            (LPBYTE) szValue));
}

BOOL CObjAccess::WriteString(DWORD dwIndex, LPCSTR szValue)
{
    return WriteString(dwIndex, (LPCWSTR) _bstr_t(szValue));
}

BOOL CObjAccess::WriteDWORD(DWORD dwIndex, DWORD dwValue)
{
    return
        SUCCEEDED(m_pObjAccess->WriteDWORD(
            m_pProps[dwIndex].m_lHandle, 
            dwValue));
}

BOOL CObjAccess::WriteDWORD64(DWORD dwIndex, DWORD64 dwValue)
{
    return
        SUCCEEDED(m_pObjAccess->WriteQWORD(
            m_pProps[dwIndex].m_lHandle, 
            dwValue));
}

BOOL CObjAccess::WriteNULL(DWORD dwIndex)
{
    return 
        SUCCEEDED(m_pObj->Put(
            m_pProps[dwIndex].m_strName, 
            0,
            NULL,
            0));
}


/////////////////////////////////////////////////////////////////////////////
// CProp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\sample\cons\main.cpp ===
#include <commain.h>
#include <clsfac.h>
#include "console.h"

#include <tchar.h>

const CLSID CLSID_WbemConsoleConsumer = 
    {0x266c72f2,0x62e8,0x11d1,{0xad,0x89,0x00,0xc0,0x4f,0xd8,0xfd,0xff}};

class CMyServer : public CComServer
{
protected:
    HRESULT Initialize()
    {
        AddClassInfo(CLSID_WbemConsoleConsumer, 
            new CClassFactory<CConsoleConsumer>(GetLifeControl()),
            _T("Console Event Consumer Provider"), TRUE);
        return S_OK;
    }
   virtual HRESULT InitializeCom()
   {
        HRESULT hres = CoInitialize(NULL);
        if(FAILED(hres))
            return hres;
      
        return CoInitializeSecurity(NULL, -1, NULL, NULL, 
            RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_ANONYMOUS, NULL, 0, 0);
   }

} g_Server;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\utils\objaccess.h ===
// ObjAccess.h

#ifndef _OBJACCESS_H
#define _OBJACCESS_H

#include <wbemcli.h>
#include <wbemint.h>
#include "array.h"

//typedef CArray<long> CLongArray;
//typedef CArray<_bstr_t, LPCWSTR> CBstrArray;

class CProp
{
public:
    CProp() : 
        m_lHandle(0),
        m_dwSize(0),
        m_pData(NULL)
        //m_bArray(FALSE)
    {
    }

    CIMTYPE m_type;
    long    m_lHandle;
    _bstr_t m_strName;
    
    // Array-only stuff
    //BOOL    m_bArray;
    DWORD   m_dwSize;
    LPVOID  m_pData;
};

typedef CArray<CProp, CProp&> CPropArray;

// Wbemcomn.dll prototypes.
//typedef HRESULT (WINAPI IWbemClassObject::*FPGET_PROPERTY_HANDLE_EX)(LPCWSTR, long, CIMTYPE*, long*);
//typedef LPVOID (IWbemClassObject::*FPGET_ARRAY_BY_HANDLE)(long);

class CObjAccess
{
public:
    CObjAccess();
    CObjAccess(const CObjAccess& other);

    ~CObjAccess();
    
    const CObjAccess& operator=(const CObjAccess& other);

    enum INIT_FAILED_PROP_TYPE
    {
        // Init returns FALSE if a property isn't found.
        FAILED_PROP_FAIL, 
        
        // See if this property is an array.
        FAILED_PROP_TRY_ARRAY,
        
        // If the property isn't found just set the handle to 0 and go on.
        FAILED_PROP_IGNORE
    };

    BOOL Init(
        IWbemServices *pSvc,
        LPCWSTR szClass,
        LPCWSTR *pszPropNames,
        DWORD nProps,
        INIT_FAILED_PROP_TYPE type = FAILED_PROP_FAIL);

    BOOL WriteArrayData(DWORD dwIndex, LPVOID pData, DWORD dwItemSize);
    BOOL WriteNonPackedArrayData(DWORD dwIndex, LPVOID pData, DWORD dwItems, 
        DWORD dwTotalSize);
    BOOL WriteData(DWORD dwIndex, LPVOID pData, DWORD dwSize);
    BOOL WriteString(DWORD dwIndex, LPCWSTR szValue);
    BOOL WriteString(DWORD dwIndex, LPCSTR szValue);
    BOOL WriteDWORD(DWORD dwIndex, DWORD dwValue);
    BOOL WriteDWORD64(DWORD dwIndex, DWORD64 dwValue);
    BOOL WriteNULL(DWORD dwIndex);
    IWbemClassObject **GetObjForIndicate() { return &m_pObj; }
    IWbemClassObject *GetObj() { return m_pObj; }
    _IWmiObject *GetWmiObj() { return m_pWmiObj; }

    HRESULT SetProp(DWORD dwIndex, DWORD dwSize, LPVOID pData)
    {
        return 
            m_pWmiObj->SetPropByHandle(
                m_pProps[dwIndex].m_lHandle,
                0,
                dwSize,
                pData);
    }

protected:
    IWbemObjectAccess *m_pObjAccess;
    IWbemClassObject  *m_pObj;
    _IWmiObject       *m_pWmiObj;
    CPropArray        m_pProps;
    //static FPGET_PROPERTY_HANDLE_EX m_pGetPropertyHandleEx;
    //static FPGET_ARRAY_BY_HANDLE m_pGetArrayByHandle;

    BOOL InitDataForArray(CProp *pProp, DWORD dwItems, DWORD dwItemSize);
    //CLongArray        m_pHandles;
    //CBstrArray        m_pNames;
};
        
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\utils\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	P2Prov.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\utils\precomp.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__BD36E0C8_A21A_4DB9_BCAB_25D8E49BD767__INCLUDED_)
#define AFX_STDAFX_H__BD36E0C8_A21A_4DB9_BCAB_25D8E49BD767__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#include <windows.h>
#include <comdef.h>
#include <crtdbg.h>
#include <tchar.h>

// This makes WMIAPI == dllexport stuff
#define ISP2PDLL

// Change this to use shared memory or named pipes.
#define NAMED_PIPES


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__BD36E0C8_A21A_4DB9_BCAB_25D8E49BD767__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\sample\cons\console.cpp ===
#include "console.h"
#include <stdio.h>
#include <wbemutil.h>

HRESULT STDMETHODCALLTYPE CConsoleConsumer::XProvider::FindConsumer(
                    IWbemClassObject* pLogicalConsumer,
                    IWbemUnboundObjectSink** ppConsumer)
{
    CConsoleSink* pSink = new CConsoleSink(m_pObject->m_pControl);
    HRESULT hres = pSink->Initialize(pLogicalConsumer);
    if(FAILED(hres))
    {
        delete pSink;
        *ppConsumer = NULL;
        return hres;
    }
    else return pSink->QueryInterface(IID_IWbemUnboundObjectSink, 
                                        (void**)ppConsumer);
}


void* CConsoleConsumer::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemEventConsumerProvider)
        return &m_XProvider;
    else return NULL;
}






CConsoleSink::~CConsoleSink()
{
}

HRESULT CConsoleSink::Initialize(IWbemClassObject* pLogicalConsumer)
{
    m_lBatches = m_lCurrent = m_lTotal = 0;
    m_lThreshold = 1000;

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CConsoleSink::XSink::IndicateToConsumer(
            IWbemClassObject* pLogicalConsumer, long lNumObjects, 
            IWbemClassObject** apObjects)
{
    CInCritSec ics(&m_pObject->m_cs);

    m_pObject->m_lCurrent += lNumObjects;
    m_pObject->m_lTotal += lNumObjects;
    m_pObject->m_lBatches++;
    if(m_pObject->m_lCurrent >= m_pObject->m_lThreshold)
    {
        m_pObject->m_lCurrent = m_pObject->m_lCurrent % m_pObject->m_lThreshold;

        printf("%d at %d (%d per batch)\n", m_pObject->m_lTotal, 
            GetTickCount(), m_pObject->m_lTotal / m_pObject->m_lBatches);
    }
    Sleep(0);
    return S_OK;
}
    

    

void* CConsoleSink::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemUnboundObjectSink)
        return &m_XSink;
    else return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\sample\cons\console.h ===
#ifndef __WBEM_CONSOLE_CONSUMER__H_
#define __WBEM_CONSOLE_CONSUMER__H_

#include <unk.h>

#include <wbemidl.h>
#include <stdio.h>
#include <sync.h>

class CConsoleConsumer : public CUnk
{
protected:
    class XProvider : public CImpl<IWbemEventConsumerProvider, CConsoleConsumer>
    {
    public:
        XProvider(CConsoleConsumer* pObj)
            : CImpl<IWbemEventConsumerProvider, CConsoleConsumer>(pObj){}
    
        HRESULT STDMETHODCALLTYPE FindConsumer(
                    IWbemClassObject* pLogicalConsumer,
                    IWbemUnboundObjectSink** ppConsumer);
    } m_XProvider;
    friend XProvider;

public:
    CConsoleConsumer(CLifeControl* pControl = NULL, IUnknown* pOuter = NULL)
        : CUnk(pControl, pOuter), m_XProvider(this)
    {}
    ~CConsoleConsumer(){}
    void* GetInterface(REFIID riid);
};


class CConsoleSink : public CUnk
{
protected:
    class XSink : public CImpl<IWbemUnboundObjectSink, CConsoleSink>
    {
    public:
        XSink(CConsoleSink* pObj) : 
            CImpl<IWbemUnboundObjectSink, CConsoleSink>(pObj){}

        HRESULT STDMETHODCALLTYPE IndicateToConsumer(
            IWbemClassObject* pLogicalConsumer, long lNumObjects, 
            IWbemClassObject** apObjects);
    } m_XSink;
    friend XSink;

protected:
    CCritSec m_cs;
    long m_lTotal;
    long m_lCurrent;
    long m_lThreshold;
    long m_lBatches;

public:
    CConsoleSink(CLifeControl* pControl = NULL) 
        : CUnk(pControl), m_XSink(this)
    {}
    HRESULT Initialize(IWbemClassObject* pLogicalConsumer);
    ~CConsoleSink();

    void* GetInterface(REFIID riid);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\sample\cons\temp\main.cpp ===
#include <windows.h>
#include <stdio.h>
#include <wbemidl.h>

#define MIN_PRINT 10000
#define EVENT_CLASS L"FastEvent"
// #define EVENT_CLASS L"TestEvent1"

//***************************************************************************
//
//***************************************************************************

class CMySink : public IWbemObjectSink
{
    UINT m_cRef;

    long m_lTotal;
    long m_lBatches;
    long m_lLastPrinted;
    long m_lStart;
    long m_lDiff;
    long m_lLastPrintTime;

public:
    CMySink() { m_cRef = 1; m_lTotal = 0; m_lBatches = 0; m_lLastPrinted = 0;
                m_lDiff = 1;
                m_lStart = GetTickCount(); m_lLastPrintTime = m_lStart;}
   ~CMySink() { }

    //
    // IUnknown members
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    virtual /* [id] */ HRESULT STDMETHODCALLTYPE Indicate(
            /* [in] */ long lObjectCount,
            /* [size_is][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObjArray
            );

    virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetStatus(
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject __RPC_FAR *pObjParam
            );

};


//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CMySink::QueryInterface(REFIID riid, LPVOID * ppv)
{
    *ppv = 0;

    if (IID_IUnknown==riid || IID_IWbemObjectSink == riid)
    {
        *ppv = (IWbemObjectSink *) this;
        AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}


//***************************************************************************
//
//***************************************************************************

ULONG CMySink::AddRef()
{
    return ++m_cRef;
}

//***************************************************************************
//
//***************************************************************************

ULONG CMySink::Release()
{
    if (0 != --m_cRef)
        return m_cRef;

    delete this;
    return 0;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CMySink::Indicate(
    long lObjectCount,
    IWbemClassObject __RPC_FAR *__RPC_FAR *ppObjArray
    )
{
    m_lTotal += lObjectCount;
    m_lBatches++;
    if(m_lTotal - m_lLastPrinted >= m_lDiff)
    {
        long lElapsed = GetTickCount() - m_lStart;
        long lThisElapsed = GetTickCount() - m_lLastPrintTime;
        printf("%d events in %d batches in %dms (%d/sec (%d), %d/batch)\r", 
            m_lTotal, m_lBatches, lElapsed, (m_lTotal * 1000) / lElapsed,
            ((m_lTotal-m_lLastPrinted) * 1000) / lThisElapsed,
            m_lTotal / m_lBatches);
        
        if(lThisElapsed < 500)
            m_lDiff *= 2;
        else 
        {
            m_lDiff = m_lDiff * 1000 / lThisElapsed;
        }

        m_lLastPrinted = m_lTotal;
        m_lLastPrintTime = GetTickCount();
    }

/*
    printf("Indicate called with %d object(s)\n", lObjectCount);

    // Get the info from the object.
    // =============================
    
    for (long i = 0; i < lObjectCount; i++)
    {
        IWbemClassObject *pObj = ppObjArray[i];
        
        // If here, we know the object is one of the kind we asked for.
        // ============================================================

        CVARIANT vName;
        pObj->Get(CBSTR(L"Name"), 0, &vName, 0, 0);
        CVARIANT vValue;
        pObj->Get(CBSTR(L"Value"), 0, &vValue, 0, 0);
        
        printf("Event info %S %u\n", vName.GetStr(), vValue.GetLONG());
    }
*/

    return WBEM_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CMySink::SetStatus(
    /* [in] */ long lFlags,
    /* [in] */ HRESULT hResult,
    /* [in] */ BSTR strParam,
    /* [in] */ IWbemClassObject __RPC_FAR *pObjParam
    )
{
    // Not called during event delivery.
        
    printf("Error: 0x%X\n", hResult);
    if(FAILED(hResult))
        ExitProcess(0);
    return WBEM_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************



//***************************************************************************
//
//***************************************************************************

void __cdecl main(int argc, char **argv)
{
    CoInitializeEx(0, COINIT_MULTITHREADED);
    CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_NONE,
        RPC_C_IMP_LEVEL_IDENTIFY, NULL, EOAC_NONE, 0);

    IWbemLocator *pLoc = 0;

    DWORD dwRes = CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
            IID_IWbemLocator, (LPVOID *) &pLoc);

    if (dwRes != S_OK)
    {
        printf("Failed to create IWbemLocator object.\n");
        CoUninitialize();
        return;
    }


    // Connect to CIMOM.
    // =================

    IWbemServices *pSvc = 0;

    BSTR strN = SysAllocString(L"root\\default");
    HRESULT hRes = pLoc->ConnectServer(
            strN,
            NULL,
            NULL,
            0,
            0,
            0,
            0,
            &pSvc
            );

    if (hRes)
    {
        printf("Could not connect. Error code = 0x%X\n", hRes);
        CoUninitialize();
        return;
    }

    // If here, we succeeded.
    // ======================


    printf("Connected to CIMOM.\n");


    // Create a new sink.
    // ===================

    CMySink *pSink = new CMySink;

    BSTR strL = SysAllocString(L"WQL");
    BSTR strQ = SysAllocString(L"select * from "EVENT_CLASS);

    hRes = pSvc->ExecNotificationQueryAsync(
        strL, strQ,
        0,                  // Flags
        0,                  // Context
        pSink
        );


    // Now, we wait until the user hits ENTER to stop.
    // ===============================================

    if (SUCCEEDED(hRes))
    {
        printf("Subsribed\n");
        char buf[8];
        gets(buf);

        pSvc->CancelAsyncCall(pSink);
    }
    else
    {
        printf("Unable to execute the event query %x\n", hRes);

    }

    // Cleanup.
    // ========

    printf("Shutting down\n");

    pSink->Release();
    pSvc->Release();
    pLoc->Release();

    CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\sample\cons\exemain.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    EXEMAIN.CPP

Abstract:

  EXE/COM Helpers

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <tchar.h>
#include "commain.cpp"

static DWORD g_dwMainThreadId = 0xFFFFFFFF;

class CExeLifeControl : public CLifeControl
{
protected:
    long m_lNumObjects;
    BOOL m_bUnloading;
    CMyCritSec m_cs;

protected:
    virtual void Quit()
    {
        PostThreadMessage(g_dwMainThreadId, WM_QUIT, 0, 0);
    }
public:
    CExeLifeControl() : m_lNumObjects(0), m_bUnloading(FALSE){}
    virtual BOOL ObjectCreated(IUnknown* pv)
    {
        CMyInCritSec ics(&m_cs);
        if(m_bUnloading)
            return FALSE;

        m_lNumObjects++;
        return TRUE;
    }
    virtual void ObjectDestroyed(IUnknown* pv)
    {
        EnterCriticalSection(&m_cs);
        long l = --m_lNumObjects;
        if(l == 0)
        {
            m_bUnloading = TRUE;
            LeaveCriticalSection(&m_cs);
            Quit();
        }
        else
        {
            LeaveCriticalSection(&m_cs);
        }
    }

    virtual void AddRef(IUnknown* pv){}
    virtual void Release(IUnknown* pv){}
};

void MessageLoop()
{
    MSG msg;
    while(GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
}


struct ServiceInfo
{
    BOOL m_bUsed;

    LPTSTR m_szServiceName;
    LPTSTR m_szDisplayName;
    BOOL m_bAuto;

    HANDLE m_hEvent;
    SERVICE_STATUS_HANDLE m_hStatus;

    ServiceInfo() : m_bUsed(FALSE){}

} g_ServiceInfo;

void SetServiceInfo(LPTSTR szServiceName, LPTSTR szDisplayName, BOOL bAuto)
{
    g_ServiceInfo.m_bUsed = TRUE;
    g_ServiceInfo.m_szServiceName = szServiceName;
    g_ServiceInfo.m_szDisplayName = szDisplayName;
    g_ServiceInfo.m_bAuto = bAuto;
}

void WINAPI ServiceHandler(DWORD dwControl)
{
    SERVICE_STATUS Status;
    Status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    Status.dwCurrentState = SERVICE_RUNNING;
    Status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    Status.dwWin32ExitCode = NO_ERROR;
    Status.dwCheckPoint = 0;
    Status.dwWaitHint = 0;

    if(!SetServiceStatus(g_ServiceInfo.m_hStatus, &Status))
    {
        long lRes = GetLastError();
        return;
    }
    switch(dwControl)
    {
    case SERVICE_CONTROL_STOP:
        Status.dwCurrentState = SERVICE_STOPPED;
        SetServiceStatus(g_ServiceInfo.m_hStatus, &Status);
        SetEvent(g_ServiceInfo.m_hEvent);
        ExitProcess(0);
        return;
    case SERVICE_CONTROL_PAUSE:
    case SERVICE_CONTROL_CONTINUE:
    case SERVICE_CONTROL_INTERROGATE:
    case SERVICE_CONTROL_SHUTDOWN:
        return;
    };
}

void WINAPI ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv)
{
    g_ServiceInfo.m_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    g_ServiceInfo.m_hStatus = RegisterServiceCtrlHandler(
        g_ServiceInfo.m_szServiceName,
        (LPHANDLER_FUNCTION)&ServiceHandler);
    if(g_ServiceInfo.m_hStatus == NULL)
    {
        long lRes = GetLastError();
        return;
    }

    SERVICE_STATUS Status;
    Status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    Status.dwCurrentState = SERVICE_START_PENDING;
    Status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    Status.dwWin32ExitCode = NO_ERROR;
    Status.dwCheckPoint = 0;
    Status.dwWaitHint = 10000;

    if(!SetServiceStatus(g_ServiceInfo.m_hStatus, &Status))
    {
        long lRes = GetLastError();
        return;
    }

    Status.dwCurrentState = SERVICE_RUNNING;
    if(!SetServiceStatus(g_ServiceInfo.m_hStatus, &Status))
    {
        long lRes = GetLastError();
        return;
    }

    MessageLoop();
}


BOOL StartService()
{
    SERVICE_TABLE_ENTRY aEntries[2];
    aEntries[0].lpServiceName = g_ServiceInfo.m_szServiceName;
    aEntries[0].lpServiceProc = (LPSERVICE_MAIN_FUNCTION)&ServiceMain;
    aEntries[1].lpServiceName = NULL;
    aEntries[1].lpServiceProc = NULL;

    if(!StartServiceCtrlDispatcher(aEntries))
    {
        long lRes = GetLastError();
        return FALSE;
    }

    return TRUE;
}

BOOL InstallService()
{
    SC_HANDLE hManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    TCHAR szFilename[1024];
    GetModuleFileName(NULL, szFilename, 1023);

    SC_HANDLE hService = CreateService(hManager,
        g_ServiceInfo.m_szServiceName,
        g_ServiceInfo.m_szDisplayName,
        SERVICE_ALL_ACCESS,
        SERVICE_WIN32_OWN_PROCESS,
        g_ServiceInfo.m_bAuto?SERVICE_AUTO_START : SERVICE_DEMAND_START,
        SERVICE_ERROR_NORMAL,
        szFilename, NULL, NULL, NULL,
        NULL, //Local System
        NULL // no password
    );

    if(hService == NULL)
    {
        long lRes = GetLastError();
        return FALSE;
    }
/*
    // Create AppId key
    // ================

    GUID AppId = *g_aClassInfos[0].m_pClsid;
    char szAppId[128];
    WCHAR wszAppId[128];
    char szAppIdKey[128];

    StringFromGUID2(*pInfo->m_pClsid, wszAppId, 128);
    wcstombs(szAppId, wszAppId, 128);
    strcpy(szAppIdKey, "SOFTWARE\\Classes\\AppId\\");
    strcat(szAppIdKey, szAppId);

    HKEY hKey1;
    RegCreateKey(HKEY_LOCAL_MACHINE, szAppIdKey, &hKey1);

    RegSetValueEx(hKey1, "LocalService", 0, REG_SZ,
        g_ServiceInfo.m_szServiceName,
        strlen(g_ServiceInfo.m_szServiceName)+1);
*/
    return TRUE;

}

BOOL DeinstallService()
{
    SC_HANDLE hManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    SC_HANDLE hService = OpenService(hManager, g_ServiceInfo.m_szServiceName,
        SERVICE_ALL_ACCESS);
    if(hService == NULL)
    {
        long lRes = GetLastError();
        return FALSE;
    }

    if(!DeleteService(hService))
    {
        long lRes = GetLastError();
        return FALSE;
    }

    return TRUE;
}

CLifeControl* g_pLifeControl = new CExeLifeControl;

void CALLBACK MyTimerProc(HWND hWnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{
    PostQuitMessage(0);
}

void __cdecl main()
{
    LPTSTR szOrigCommandLine = GetCommandLine();
    LPTSTR szCommandLine = new TCHAR[lstrlen(szOrigCommandLine)+1];
    lstrcpy(szCommandLine, szOrigCommandLine);
    TCHAR * pc = szCommandLine;
    while(*pc)
        *(pc++) = (TCHAR)toupper(*pc);

    GlobalInitialize();
    if(_tcsstr(szCommandLine, TEXT("-REGSERVER")) ||
        _tcsstr(szCommandLine, TEXT("/REGSERVER")))
    {
        GlobalRegister();
        for(int i = 0; i < g_pClassInfos->size(); i++)
        {
            CClassInfo* pInfo = (*g_pClassInfos)[i];
            HRESULT hres = RegisterServer(pInfo, TRUE);
            if(FAILED(hres)) return;
        }
        if(g_ServiceInfo.m_bUsed)
        {
            InstallService();
        }
    }
    else if(_tcsstr(szCommandLine, TEXT("-UNREGSERVER")) ||
            _tcsstr(szCommandLine, TEXT("/UNREGSERVER")))
    {
        GlobalUnregister();
        for(int i = 0; i < g_pClassInfos->size(); i++)
        {
            CClassInfo* pInfo = (*g_pClassInfos)[i];
            HRESULT hres = UnregisterServer(pInfo, TRUE);
            if(FAILED(hres)) return;
        }
        if(g_ServiceInfo.m_bUsed)
        {
            DeinstallService();
        }
    }
    else if(_tcsstr(szCommandLine, TEXT("EMBEDDING")) == NULL &&
        !g_ServiceInfo.m_bUsed)
    {
        printf("Cannot run standalone\n");
    }
    else
    {
        int i;
        GlobalInitializeCom();
        for(i = 0; i < g_pClassInfos->size(); i++)
        {
            CClassInfo* pInfo = (*g_pClassInfos)[i];
            HRESULT hres = CoRegisterClassObject(
                *pInfo->m_pClsid, pInfo->m_pFactory, CLSCTX_SERVER,
                REGCLS_MULTIPLEUSE, &pInfo->m_dwCookie);

            if(FAILED(hres)) return;
        }

        if(g_ServiceInfo.m_bUsed)
        {
            StartService();
        }
        else
        {
            g_dwMainThreadId = GetCurrentThreadId();
            MessageLoop();
        }

        for(i = 0; i < g_pClassInfos->size(); i++)
        {
            CClassInfo* pInfo = (*g_pClassInfos)[i];
            HRESULT hres = CoRevokeClassObject(pInfo->m_dwCookie);

            if(FAILED(hres)) return;
        }

        SetTimer(NULL, 0, 1000, (TIMERPROC)MyTimerProc);
        MessageLoop();

        GlobalUninitialize();
    }
}

int WINAPI WinMain(HINSTANCE hInst, HINSTANCE hPrev, LPSTR lpCmdLine,
                   int nCmdShow)
{
    main();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\sample\prov\main.cpp ===
#include <windows.h>
#include <wbemidl.h>
#include <stdio.h>
#include <time.h>
#include <wbemdcpl.h>
#include <wbemcomn.h>
#include <winntsec.h>

#define CHECKERROR(HRES) if(FAILED(hres)) {printf("0x%x\n", hres); return;}

class CCallback : public IWbemEventProviderSecurity, public IWbemEventProvider
{
public:
    CCallback() {}
    ~CCallback(){}

    ULONG STDMETHODCALLTYPE AddRef() {return 1;}
    ULONG STDMETHODCALLTYPE Release() {return 1;}
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv) 
    {
        if(riid == IID_IUnknown || riid == IID_IWbemEventProviderSecurity)
        {
            *ppv = (IWbemEventProviderSecurity*)this;
            return S_OK;
        }
        if(riid == IID_IWbemEventProvider)
        {
            *ppv = (IWbemEventProvider*)this;
            return S_OK;
        }
        return E_NOINTERFACE;
    }

    STDMETHOD(AccessCheck)(LPCWSTR, LPCWSTR, long, const BYTE*)
    {
        printf("AccessCheck!\n");
        return WBEM_S_SUBJECT_TO_SDS;
    }

    STDMETHOD(ProvideEvents)(IWbemObjectSink*, long)
    {
        printf("Provide\n");
        return S_OK;
    }
};
    

    
void __cdecl main()
{
    CoInitializeEx(NULL, COINIT_MULTITHREADED);

    // Construct a security descriptor

    CNtSecurityDescriptor SD;
    CNtSid sidSystem(L"SYSTEM");
    CNtSid sidMe(L"levn");
    CNtSid sidAdmins(L"Administrators");
    CNtSid sidAdmin(L"Administrator");

    SD.SetOwner(&sidSystem);
    SD.SetGroup(&sidAdmins);

    CNtAcl Dacl;
    Dacl.AddAce(&CNtAce(WBEM_RIGHT_SUBSCRIBE, ACCESS_ALLOWED_ACE_TYPE, 
                        0, sidSystem));
    SD.SetDacl(&Dacl);
    PSECURITY_DESCRIPTOR pSD = SD.GetPtr();
    long lSDLength = SD.GetSize();

    // Load provision code

    HRESULT hres;
    IWbemDecoupledEventSink* pConnection = NULL;
    hres = CoCreateInstance(CLSID_PseudoSink, NULL, CLSCTX_SERVER, 
                            IID_IWbemDecoupledEventSink, (void**)&pConnection);
    CHECKERROR(hres);
    printf("CoCreated\n");

    // Connect and announce provider name (as in MOF)

    CCallback Callback;
    hres = pConnection->SetProviderServices((IWbemEventProvider*)&Callback, WBEM_FLAG_CHECK_SECURITY);

    IWbemObjectSink* pSink = NULL;
    IWbemServices* pNamespace = NULL;
    hres = pConnection->Connect(L"root\\default", L"FastEventProv", 
                                0, &pSink, &pNamespace);
    CHECKERROR(hres);
    printf("Connected\n");

    IWbemEventSink* pBetterSink = NULL;
    hres = pSink->QueryInterface(IID_IWbemEventSink, (void**)&pBetterSink);
    CHECKERROR(hres);

    // Get Event Class definition

    IWbemClassObject* pClass = NULL;
    BSTR strClassName = SysAllocString(L"FastEvent");
    hres = pNamespace->GetObject(strClassName, 0, NULL, &pClass, NULL);
    pNamespace->Release();
    SysFreeString(strClassName);
    CHECKERROR(hres);

    // Spawn an instance of the event class to use in firings

    IWbemClassObject* pInstance = NULL;
    pClass->SpawnInstance(0, &pInstance);
    // pClass->Release();

    IWbemObjectAccess* pAccess = NULL;
    pInstance->QueryInterface(IID_IWbemObjectAccess, (void**)&pAccess);

    // Obtain handles to properties for faster access

    long lP1Handle, lP2Handle;
    CIMTYPE ct;

    pAccess->GetPropertyHandle(L"IntProp", &ct, &lP1Handle);
    pAccess->GetPropertyHandle(L"StringProp", &ct, &lP2Handle);

    // Init data

    DWORD dwIndex = 0;
    WCHAR wszHello[] = L"Hello there!";
    long lStringLen = wcslen(wszHello)*2+2;

    // Fire 10000 events

    while(1) //dwIndex < 10000)
    {
        // Set property values

        pAccess->WriteDWORD(lP1Handle, dwIndex);
        // pAccess->WritePropertyValue(lP2Handle, lStringLen, (BYTE*)wszHello);

/*
        VARIANT v;
        V_VT(&v) = VT_UNKNOWN;
        pInstance->Clone((IWbemClassObject**)&V_UNKNOWN(&v));
        pInstance->Put(L"o", 0, &v, 0);
        VariantClear(&v);
*/

        // Fire

        pBetterSink->IndicateWithSD(1, (IUnknown**)&pInstance, 
                                    lSDLength, (BYTE*)pSD);
        // pSink->Indicate(1, &pInstance);
        dwIndex++;


/*
        pInstance->Release();
        pAccess->Release();
        pClass->SpawnInstance(0, &pInstance);
        pInstance->QueryInterface(IID_IWbemObjectAccess, (void**)&pAccess);
*/

    }
        
    // Disconnect and release

    pAccess->Release();
    pInstance->Release();
    pConnection->Disconnect();
    pSink->Release();
    pConnection->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\precomp.h ===
#undef _CRTIMP
#define _CRTIMP
#include <yvals.h>
#undef _CRTIMP
#define _CRTIMP __declspec(dllimport)

#include <winsock2.h>
#include <ole2.h>
#include <windows.h>

#pragma message("Hi there")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\killtimer.h ===
#ifndef __KILL_TIMER_COMPILED__
#define __KILL_TIMER_COMPILED__

#include <wbemidl.h>
#include <wbemutil.h>
#include <cominit.h>
#include <Limits.h>

#include <FlexArry.h>
#include <unk.h>
#include <sync.h>

// used for "forever" or "invalid date"
const FILETIME FILETIME_MAX = {_UI32_MAX, _UI32_MAX};

// something to make FILETIME easier to deal with
// performs casts automagically, allows addition
union WAYCOOL_FILETIME
{
public:
    /* CONSTRUCTION */
    WAYCOOL_FILETIME(UINT64 ui64 = 0)
    { m_ui64 = ui64; }

    WAYCOOL_FILETIME(FILETIME ft)
    { m_ft = ft; }
    

    /* ASSIGNMENT */
    FILETIME& operator= (FILETIME& other)
    { m_ft = other; return m_ft; }

    UINT64& operator= (UINT64& other)
    { m_ui64 = other; return m_ui64; }

    
    /* COMPARISON */    
    bool operator< (WAYCOOL_FILETIME& other)
    { return m_ui64 < other.m_ui64; }
    bool operator<= (WAYCOOL_FILETIME& other)
    { return m_ui64 <= other.m_ui64; }

    bool operator> (WAYCOOL_FILETIME& other)
    { return m_ui64 >  other.m_ui64; }
    bool operator>= (WAYCOOL_FILETIME& other)
    { return m_ui64 >= other.m_ui64; }
    
    bool operator== (WAYCOOL_FILETIME& other)
    { return m_ui64 == other.m_ui64; }
    bool operator!= (WAYCOOL_FILETIME& other)
    { return m_ui64 != other.m_ui64; }

    /* ADDITION & SUBTRACTION */
    // remember: units are hundreds of nanoseconds
    WAYCOOL_FILETIME operator+  (UINT64 other)
    { return WAYCOOL_FILETIME(m_ui64 + other); }
    
    WAYCOOL_FILETIME& operator+= (UINT64 other)
    {
        m_ui64 += other;
        return *this;
    }

    WAYCOOL_FILETIME operator-  (UINT64 other)
    { return WAYCOOL_FILETIME(m_ui64 - other); }

    WAYCOOL_FILETIME& operator-= (UINT64 other)
    {
        m_ui64 -= other;
        return *this;
    }

    // += that takes seconds as a parm
    WAYCOOL_FILETIME& AddSeconds(UINT64 other)
    { return operator+= (SecondsToTicks(other)); }    
                                       
    // -= that takes seconds as a parm
    WAYCOOL_FILETIME& SubtractSeconds(UINT64 other)
    { return operator-= (SecondsToTicks(other)); }


    /* CASTS & CONVERSIONS */
    operator UINT64()
    { return m_ui64; }

    // hey if CString can do it, so can I...
    operator UINT64*()
    { return &m_ui64; }
    
    operator FILETIME()
    { return m_ft; }        



    static UINT64 SecondsToTicks(UINT64 ticks)
    { return (ticks * 10000000ui64); }


    /* GET, SET */
    FILETIME GetFILETIME(void)
    { return m_ft; }

    void SetFILETIME(FILETIME ft)
    { m_ft = ft; }

    UINT64 GetUI64(void)
    { return m_ui64; }

    void SetUI64(UINT64 ui64)
    { m_ui64 = ui64; }


private:
    FILETIME m_ft;
    UINT64   m_ui64;
};


/* VIRTUAL BASE CLASS CKiller DEFINITION */

// base class for things that can be killed
// chlid classes should only need to add constructor
// and overrid Die()
class CKiller
{
public:
    CKiller(FILETIME deathDate, CLifeControl* pControl) :
        m_pControl(pControl), m_deathDate(deathDate)
    {
        if (m_pControl)
            m_pControl->ObjectCreated(NULL);       
    }

    virtual ~CKiller()
    {
        if (m_pControl)
            m_pControl->ObjectDestroyed(NULL);       
    }

    // terminate whatever, 
    virtual void Die() = 0;

    // returns true if now is >= death date
    bool TimeExpired(const FILETIME& now)
        { return (CompareTime(now) < 1); }

    // returns  0 if times identical
    //         -1 if this time is less than now
    //         +1 if this time is greater than now
    int CompareTime(const FILETIME& now)
        { return CompareFileTime(&m_deathDate, &now); }

    FILETIME GetDeathDate()
        { return m_deathDate; }

protected:

private:
    FILETIME m_deathDate;
    CLifeControl* m_pControl;
};

// class to provide an arbitrary life time to a process
// proc is killed after a specified timeout
// intended as a global manager class
class CKillerTimer
{
public:

    /* CONSTRUCTION & INITIALIZATION */
    CKillerTimer();
    ~CKillerTimer();

    HRESULT Initialize(CLifeControl* pControl);

    // force shutdown.
    void UnloadNOW();

    /* VICTIM CONTROL */
    // who to kill & when
    // generic version of ScheduleAssassination.  You can stuff any CKiller derived class in.
    // alternatively, the derived class can hide this & expose their own specialized version
    HRESULT ScheduleAssassination(CKiller* pKiller);

protected:

    // holds CKillers sorted by execution time.
    // earliest date first
    // array is not sorted "natively:" order is enforced at ScheduleAssaination time.
    // TODO: consider use of a container that sorts itself.
    CFlexArray m_killers;

    /* SYNCHRONIZATION */

    // keep us from getting our threads tangled around the array
    CCritSec m_csKillers;

    // protect worker thread startup & shutdown
    CCritSec m_csStartup;

    // event signalled when it's time to go away
    HANDLE m_hShutdown;

    // event signalled when there's a new item in the list
    HANDLE m_hNewVictim;

    /* THREAD CONTOL */

    // called by first thread to notice there isn't a timer thread
    HRESULT StartTimer();

    // shuts down timer thread
    bool KillTimer();

    // main killer thread loop
    static DWORD WINAPI ThreadStartRoutine(LPVOID lpParameter);
    void   RunKillerThread();

    /* KILLER THREAD'S ROUTINES */

    // kill all procs that are older than our expiration date
    // called from killer thread only
    void   KillOffOldGuys(const FILETIME& now);

    // decide when to set the waitable timer again.
    // called from killer thread only
    void   RecalcNextKillingSpree(FILETIME& then);

protected:
    CLifeControl* m_pControl;

private:
    // thread to handle actual waits & kills
    HANDLE m_hTimerThread;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\sample\prov\decouple\main.cpp ===
#include <windows.h>
#include <wbemidl.h>
#include <stdio.h>
#include <time.h>
#include <wbemdcpl.h>
#include <wbemcomn.h>
#include <winntsec.h>

#define CHECKERROR(HRES) if(FAILED(hres)) {printf("0x%x on line %d\n", hres, __LINE__); return;}

class CCallback : public IWbemEventProviderSecurity, public IWbemEventProvider
{
public:
    CCallback() {}
    ~CCallback(){}

    ULONG STDMETHODCALLTYPE AddRef() {return 1;}
    ULONG STDMETHODCALLTYPE Release() {return 1;}
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv) 
    {
        if(riid == IID_IUnknown || riid == IID_IWbemEventProviderSecurity)
        {
            *ppv = (IWbemEventProviderSecurity*)this;
            return S_OK;
        }
        if(riid == IID_IWbemEventProvider)
        {
            *ppv = (IWbemEventProvider*)this;
            return S_OK;
        }
        return E_NOINTERFACE;
    }

    STDMETHOD(AccessCheck)(LPCWSTR, LPCWSTR, long, const BYTE*)
    {
        printf("AccessCheck!\n");
        return WBEM_S_SUBJECT_TO_SDS;
    }

    STDMETHOD(ProvideEvents)(IWbemObjectSink*, long)
    {
        printf("Provide\n");
        return S_OK;
    }
};
    

void PrintUsage()
{
    printf("usage:\n%s [-t <total num>] [-r <per sec>] [-b <max mem>:<max delay>]\n");
}
    
void __cdecl main(int argc, char** argv)
{
    HRESULT hres;

    DWORD nNumEvents = 1;
    DWORD nTotal = 0xFFFFFFFF;
    DWORD nMaxMemory = 0;
    DWORD nMaxDelay = 0;

    for(int i = 1; i < argc; i++)
    {
        switch(argv[i][1])
        {
            case 't': case 'T':
                sscanf(argv[i+1], "%d", &nTotal);
                i++;
                break;
            case 'r': case 'R':
                sscanf(argv[i+1], "%d", &nNumEvents);
                i++;
                break;
            case 'b':
                sscanf(argv[i+1], "%d:%d", &nMaxMemory, &nMaxDelay);
                i++;
                break;
            default:
                PrintUsage();
                return;
        }
    }

    CoInitializeEx(NULL, COINIT_MULTITHREADED);
    CoInitializeSecurity(NULL, -1, NULL, NULL,
            RPC_C_AUTHN_LEVEL_PKT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, 0, 0);

    // Load provision code

    IWbemDecoupledBasicEventProvider* pDEP = NULL;
    hres = CoCreateInstance( CLSID_WbemDecoupledBasicEventProvider,
                           NULL,
                   CLSCTX_INPROC_SERVER,
                   IID_IWbemDecoupledBasicEventProvider,
                   (void**)&pDEP );
    CHECKERROR(hres);

    hres = pDEP->Register( 0,
                         NULL,
                         NULL,
                         NULL,
                         L"root\\default",
                         L"FastEventProv",
                         NULL );
    CHECKERROR(hres);

    //
    // get the service pointer for out namespace
    //

    IWbemServices* pSvc = NULL;
    hres = pDEP->GetService(0, NULL, &pSvc );
    CHECKERROR(hres);

    IWbemClassObject* pClass = NULL;
    BSTR strClass = SysAllocString(L"FastEvent");
    hres = pSvc->GetObject(strClass, 0, NULL, &pClass, NULL);
    SysFreeString(strClass);
    CHECKERROR(hres);

    IWbemClassObject* pInstance = NULL;
    pClass->SpawnInstance(0, &pInstance);
    pClass->Release();
    
    IWbemObjectAccess* pAccess = NULL;
    pInstance->QueryInterface(IID_IWbemObjectAccess, (void**)&pAccess);

    long lP1Handle, lP2Handle;
    CIMTYPE ct;

    pAccess->GetPropertyHandle(L"IntProp", &ct, &lP1Handle);
    pAccess->GetPropertyHandle(L"StringProp", &ct, &lP2Handle);

    //
    // get the decoupled event sink
    //

    IWbemObjectSink* pSink = NULL;
    hres = pDEP->GetSink(0, NULL, &pSink);
    CHECKERROR(hres);

    if(nMaxMemory)
    {
        IWbemEventSink* pBetterSink = NULL;
        hres = pSink->QueryInterface(IID_IWbemEventSink, (void**)&pBetterSink);
        CHECKERROR(hres);
    
        pBetterSink->SetBatchingParameters(WBEM_FLAG_MUST_BATCH, 
                                            nMaxMemory, nMaxDelay);
        pBetterSink->Release();
    }

    // Init data

    WCHAR wszHello[] = L"Hello there!";
    long lStringLen = wcslen(wszHello)*2+2;

    // Fire 10000 events

    while(nTotal)
    {
        DWORD dwStart = GetTickCount();
        DWORD dwIndex = 0;
        bool bSlept = false;

        for(int j = 0; j < 10 && nTotal; j++)
        {
            for(int i = nNumEvents * j / 10; 
                    i < nNumEvents * (j+1) / 10 && nTotal; 
                    i++)
            {
                // Set property values
        
                pAccess->WriteDWORD(lP1Handle, dwIndex);
                //pAccess->WritePropertyValue(lP2Handle, lStringLen, (BYTE*)wszHello);
        
                // Fire
        
                pSink->Indicate(1, &pInstance);
                dwIndex++;
                nTotal--;
            }

            DWORD dwElapsed = GetTickCount() - dwStart;
            DWORD dwExpected = (j+1) * 100;
            if(dwExpected > dwElapsed + 16)
            {
                bSlept = true;
                Sleep(dwExpected - dwElapsed);
            }
        }

        DWORD dwElapsed = GetTickCount() - dwStart;

        if(dwElapsed > 1016 && !bSlept)
            printf("Late (%d)\n", nNumEvents * 1000 / dwElapsed);
    }
        
    // Disconnect and release
    pDEP->UnRegister();
    pDEP->Release();

    pAccess->Release();
    pInstance->Release();
    pSink->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\killtimer.cpp ===
#include "precomp.h"
#include "KillTimer.h"

HRESULT CKillerTimer::Initialize(CLifeControl* pControl)
{
    HRESULT hr = WBEM_E_FAILED;

    // create events
    m_hShutdown  = CreateEvent(NULL, false, false, NULL);
    m_hNewVictim = CreateEvent(NULL, false, false, NULL);

    // get some control into our lives
    m_pControl = pControl;

    if (m_hShutdown && m_hNewVictim && m_pControl)
        hr = WBEM_S_NO_ERROR;

    return hr;
}

CKillerTimer::CKillerTimer()
    : m_hTimerThread(NULL), m_hShutdown(NULL), 
      m_hNewVictim(NULL), m_pControl(NULL)
{
}

// shuts down timer thread
// toggle thread dead event
// wait for thread to exit
bool CKillerTimer::KillTimer()
{
    bool bRet = false;
    
    CInCritSec csStartup(&m_csStartup);
    
    // double check - might have gotten crossed up...
    if (m_hTimerThread != NULL)
    {
        if (SetEvent(m_hShutdown))
        {
            // you've got one minute to vacate...
            bRet = (WAIT_TIMEOUT != WaitForSingleObject(m_hTimerThread, 60000));

            CloseHandle(m_hTimerThread);
            m_hTimerThread = NULL;
        }
    }

    return bRet;
}

// kill all procs that are older than our expiration date
// called from killer thread only
void CKillerTimer::KillOffOldGuys(const FILETIME& now)
{
    CInCritSec csKillers(&m_csKillers);
    CKiller* pKiller;
    int nSize = m_killers.Size();

    for (int i = 0; 
    
        (i < nSize) && 
        (pKiller = ((CKiller*)m_killers[i])) &&    
        pKiller->TimeExpired(now); 
        
        i++)
    {
        
        m_killers[i] = NULL;
        pKiller->Die();
        // all done now
        delete pKiller;
    }

    // remove them NULLs
    m_killers.Compress();
}

// decide when to set the waitable timer again.
// called from killer thread only
void CKillerTimer::RecalcNextKillingSpree(FILETIME& then)
{
    CInCritSec csKillers(&m_csKillers);

    if (m_killers.Size() > 0)
        // since these are assumed sorted, we can just grab the first one
        then = ((CKiller*)m_killers[0])->GetDeathDate();
    else
        then = FILETIME_MAX;
}


HRESULT CKillerTimer::StartTimer() 
{
    CInCritSec csStartup(&m_csStartup);
    HRESULT hr = WBEM_S_NO_ERROR;

    // double check - might have gotten crossed up...
    if (m_hTimerThread == NULL)
    {
        DWORD dwIDLikeIcare;
        m_hTimerThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ThreadStartRoutine, 
                                     (LPVOID)this, 0, &dwIDLikeIcare);
        if (m_hTimerThread == NULL)
            hr = WBEM_E_FAILED;
    }

    return hr;
}

DWORD WINAPI CKillerTimer::ThreadStartRoutine(LPVOID lpParameter)
{
    ((CKillerTimer*)lpParameter)->RunKillerThread();

    return 0;
}

void CKillerTimer::RunKillerThread()
{    
    HRESULT foo = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    HANDLE hTimer = CreateWaitableTimer(NULL, false, NULL);
    HANDLE hAutoShutdownTimer = CreateWaitableTimer(NULL, false, NULL);

    // toggled if while we are inside the startup CS
    // so we know to get out when we leave
    bool bInStartupCS = false;
    
    // those things that are worth waiting for
    enum { FirstEvent       = WAIT_OBJECT_0,
           TimerEvent       = FirstEvent,
           AutoShutdownEvent,
           NewVictimEvent,
           LastHandledEvent = NewVictimEvent,
           ShutDownEvent,
           TrailerEvent
         };

    // order counts.  so does neatness.
    const DWORD nEvents = TrailerEvent -FirstEvent;

    HANDLE events[nEvents];
    events[TimerEvent        -FirstEvent] = hTimer;
    events[AutoShutdownEvent -FirstEvent] = hAutoShutdownTimer;
    events[NewVictimEvent    -FirstEvent] = m_hNewVictim;
    events[ShutDownEvent     -FirstEvent] = m_hShutdown;
    
// silliness about the FirstEvent <= whichEvent being always true
// well it is unless somebody changes one of hte constants
// whihc is *why* I made them constants in the first place...
#pragma warning(disable:4296)

    DWORD whichEvent;
    for (whichEvent = WaitForMultipleObjects(nEvents, (const HANDLE*)&events, FALSE, INFINITE);
        (FirstEvent <= whichEvent) && (whichEvent <= LastHandledEvent);
         whichEvent = WaitForMultipleObjects(nEvents, (const HANDLE*)&events, FALSE, INFINITE))
#pragma warning(default:4296)
    {        
        // cancel auto-shutdown if scheduled;
        CancelWaitableTimer(hAutoShutdownTimer);

        switch (whichEvent)
        {
            case AutoShutdownEvent:
                {
                    m_csStartup.Enter();

                    // double check - might have gotten crossed up...
                    if (m_hTimerThread != NULL)
                    {
                        {
                            // see if there's anything in the queue
                            // if it's enpty - we're gone
                            // if anything slips in, it'll get caught at ScheduleAssassination time
                            // and we'll start a new thread
                            CInCritSec csKillers(&m_csKillers);

                            if (m_killers.Size() == 0)
                            {
                                bInStartupCS = true;

                                CloseHandle(m_hTimerThread);
                                m_hTimerThread = NULL;

                                // and we're outta here...
                                SetEvent(m_hShutdown);
                            }
                        }
                    }
                }
                break;
            case TimerEvent:
            {
                // the *official* "now" so we don't get confused
                // anything that occurs after *official* "now" must wait for next loop
                FILETIME now;
                GetSystemTimeAsFileTime(&now);    
                KillOffOldGuys(now);
                
                // if we killed everybody off
                // schedule our own termination in sixty seconds
                {
                    CInCritSec csKillers(&m_csKillers);

                    if (m_killers.Size() == 0)
                    {
                        WAYCOOL_FILETIME then = WAYCOOL_FILETIME(now) +WAYCOOL_FILETIME::SecondsToTicks(60);
                        SetWaitableTimer(hAutoShutdownTimer, (const union _LARGE_INTEGER *)&then, 0, NULL, NULL, true);
                    }
                }
            }
            // no break; FALLTHROUGH to recalc
            case NewVictimEvent:
            {
                FILETIME then;
                RecalcNextKillingSpree(then);
                if (WAYCOOL_FILETIME(FILETIME_MAX) != WAYCOOL_FILETIME(then))
                    if (!SetWaitableTimer(hTimer, (const union _LARGE_INTEGER *)&then, 0, NULL, NULL, true))
                    {
                        DWORD dwErr = GetLastError();
                    }
            }
            break;
        }
    }
         
    // handle the other handles
    CancelWaitableTimer(hTimer);
    CloseHandle(hTimer);
    
    CancelWaitableTimer(hAutoShutdownTimer);
    CloseHandle(hAutoShutdownTimer);
    
    // last gasp at killing off anyone whose time has come
    FILETIME now;
    GetSystemTimeAsFileTime(&now);            
    KillOffOldGuys(now);

    CoUninitialize();

    if (bInStartupCS)
        m_csStartup.Leave();
}

CKillerTimer::~CKillerTimer()
{
    if (m_hTimerThread)
        if (!KillTimer())
            ERRORTRACE((LOG_ESS, "CKillerTimer: Unable to stop worker thread, continuing shutdown\n"));

    UnloadNOW();
}

// clear out array, does not trigger deaths
void CKillerTimer::UnloadNOW(void)
{
    CInCritSec csKillers(&m_csKillers);
    
    for (int i = 0; i < m_killers.Size(); i++)
    {
        delete (CKiller*)m_killers[i];
        m_killers[i] = NULL;
    }

    m_killers.Empty();
}

// insert pKiller into array where he belongs
HRESULT CKillerTimer::ScheduleAssassination(CKiller* pKiller)
{
    HRESULT hr = WBEM_E_FAILED;
    {
        CInCritSec csKillers(&m_csKillers);

        if (m_killers.Size())
        {            
            // minor optimization: check to see if this time is greater than all known
            // this will ALWAYS be the case if all procs are created with the same timeout.
            if  (((CKiller*)m_killers[m_killers.Size() -1])->CompareTime(pKiller->GetDeathDate()) < 0)
            {
                if (SUCCEEDED(m_killers.Add(pKiller)))
                    hr = WBEM_S_NO_ERROR;
                else
                    hr = WBEM_E_OUT_OF_MEMORY;
            }            
            else
            {
                int nFirstGreater = 0;
                // WARNING: break in middle of loop.
                while (nFirstGreater < m_killers.Size())
                {
                    if (((CKiller*)m_killers[nFirstGreater])->CompareTime(pKiller->GetDeathDate()) >= 0)
                    {
                        if (SUCCEEDED(m_killers.InsertAt(nFirstGreater, (void*)pKiller)))
                        {
							hr = WBEM_S_NO_ERROR;
                            break; // BREAKOUT!
                        }
                        else
                            hr = WBEM_E_OUT_OF_MEMORY;
                    }
                    nFirstGreater++;
                } // endwhile
            } // else
        }
        else
        {
            // array is empty
            if (SUCCEEDED(m_killers.Add(pKiller)))
                hr = WBEM_S_NO_ERROR;
            else
                hr = WBEM_E_OUT_OF_MEMORY;
        }
    }

    // we'll set this last just to make sure, 
    // timer thread may have died along the way
    if (SUCCEEDED(hr))
    {
        hr = StartTimer();
        if (!SetEvent(m_hNewVictim))
            hr = WBEM_E_FAILED;
    }
    else
        // NOTE: this assumes that all failure paths result in 
        //       pKiller *not* being added to list
        delete pKiller;
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\sample\prov\classic\main.cpp ===
#include <windows.h>
#include <wbemidl.h>
#include <eprov.h>
#include <stdio.h>
#include <commain.h>
#include <clsfac.h>
#include <wbemcomn.h>
#include <ql.h>
#include <sync.h>
#include <time.h>

#include <tchar.h>

#define NUM_EVENTS 10
#define LOOP_SIZE 100000

DWORD Random()
{
    return ((DWORD)rand() << 16) + rand();
}

void RandomizeInstance(IWbemClassObject* pInst)
{
    pInst->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY);
    BSTR strName;
    while(pInst->Next(0, &strName, NULL, NULL, NULL) == S_OK)
    {
        VARIANT v;
        V_VT(&v) = VT_I4;
        V_I4(&v) = Random() % 1000000;
        pInst->Put(strName, 0, &v, 0);
        SysFreeString(strName);
    }
    pInst->EndEnumeration();
}
        
class CRecord
{
public:
    CFlexArray m_aIDs;
    WString m_wsClass;
    IWbemClassObject* m_pClass;
    IWbemClassObject* m_pInstance;
    IWbemObjectAccess* m_pAccess;
    long m_lHandle;

public:
    CRecord() : m_pClass(NULL), m_pInstance(NULL) {}
    ~CRecord() {if(m_pClass) m_pClass->Release(); if(m_pInstance) m_pInstance->Release();}
};

class CProvider : public CUnk
{
protected:
    class XProv : public CImpl<IWbemEventProvider, CProvider>
    {
    public:
        XProv(CProvider* pObj) : CImpl<IWbemEventProvider, CProvider>(pObj){}

        STDMETHOD(ProvideEvents)(IWbemObjectSink* pSink, long lFlags);
    } m_XProv;
    friend XProv;

    class XInit : public CImpl<IWbemProviderInit, CProvider>
    {
    public:
        XInit(CProvider* pObj) : CImpl<IWbemProviderInit, CProvider>(pObj){}

        STDMETHOD(Initialize)(LPWSTR wszUser, LONG lFlags, LPWSTR wszNamespace,
                                LPWSTR wszLocale, IWbemServices* pNamespace,
                                IWbemContext* pContext, 
                                IWbemProviderInitSink* pInitSink);
    } m_XInit;
    friend XInit;

    class XQuery : public CImpl<IWbemEventProviderQuerySink, CProvider>
    {
    public:
        XQuery(CProvider* pObj) : CImpl<IWbemEventProviderQuerySink, CProvider>(pObj){}

        STDMETHOD(NewQuery)(DWORD dwId, LPWSTR wszLanguage, LPWSTR wszQuery);
        STDMETHOD(CancelQuery)(DWORD dwId);
    } m_XQuery;
    friend XQuery;

    IWbemClassObject* m_pClass;
    BSTR m_strClassName;
    DWORD m_dwNum;
    DWORD m_dwId;
    HANDLE m_hThread;
    IWbemObjectSink* m_pSink;
    BOOL* m_pbOK;

    IWbemServices* m_pNamespace;
    CUniquePointerArray<CRecord>* m_papQueries;
    CCritSec* m_pcs;

protected:
    static DWORD Worker(void* p);

public:
    CProvider(LPCWSTR wszClassName, DWORD dwNum, CLifeControl* pControl) :
        CUnk(pControl, NULL), m_XProv(this), m_XInit(this), m_XQuery(this),
        m_hThread(NULL), m_pClass(NULL),
        m_strClassName(SysAllocString(wszClassName)), m_dwNum(dwNum),
        m_pbOK(NULL), m_pNamespace(NULL), m_pSink(NULL)
    {}
    ~CProvider()
    {
        if(m_pbOK)
            *m_pbOK = FALSE;
		TerminateThread(m_hThread, 0);
        SysFreeString(m_strClassName);
        if(m_pClass)
            m_pClass->Release();
        if(m_pNamespace)
            m_pNamespace->Release();
        if(m_pSink)
            m_pSink->Release();
    }

    void* GetInterface(REFIID riid);
};

void* CProvider::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemEventProvider)
        return &m_XProv;
    else if(riid == IID_IWbemProviderInit)
        return &m_XInit;
    else if(riid == IID_IWbemEventProviderQuerySink)
        return &m_XQuery;
    return NULL;
}

STDMETHODIMP CProvider::XInit::Initialize(LPWSTR wszUser, LONG lFlags, 
                                LPWSTR wszNamespace,
                                LPWSTR wszLocale, IWbemServices* pNamespace,
                                IWbemContext* pContext, 
                                IWbemProviderInitSink* pInitSink)
{
/*
    IWbemLocator* pLoc;
    HRESULT hres = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_SERVER,
                        IID_IWbemLocator, (void**)&pLoc);
    if(FAILED(hres)) return hres;

    IWbemServices* pS;
    hres = pLoc->ConnectServer(L"root\\default", NULL, NULL, NULL, 0, NULL, 
                    NULL, &pS);
    if(FAILED(hres)) return hres;

    pS->Release();
    pLoc->Release();
*/
    
    HRESULT hres = pNamespace->GetObject(L"__InstanceCreationEvent", 0, NULL, 
                                         &m_pObject->m_pClass, NULL);
    if(FAILED(hres))
    {
        return hres;
    }

    m_pObject->m_pNamespace = pNamespace;
    m_pObject->m_pNamespace->AddRef();

    srand(time(NULL));

    m_pObject->m_pbOK = new BOOL(TRUE);
    m_pObject->m_pcs = new CCritSec;
    m_pObject->m_papQueries = new CUniquePointerArray<CRecord>;

    pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CProvider::XQuery::NewQuery(DWORD dwId, LPWSTR wszLanguage,
                                            LPWSTR wszQuery)
{
    HRESULT hres;
    CInCritSec ics(m_pObject->m_pcs);

    QL_LEVEL_1_RPN_EXPRESSION* pExpr = NULL;
/*
    CTextLexSource Source(wszQuery);
    QL1_Parser Parser(&Source);
    Parser.Parse(&pExpr);
*/
    pExpr = new QL_LEVEL_1_RPN_EXPRESSION;
    pExpr->bsClassName = SysAllocString(L"TestEvent1");

    CDeleteMe<QL_LEVEL_1_RPN_EXPRESSION> dm(pExpr);

    IWbemClassObject* pClass = NULL;

    for(int i = 0; i < m_pObject->m_papQueries->GetSize(); i++)
    {
        CFlexArray& aIDs = m_pObject->m_papQueries->GetAt(i)->m_aIDs;

        for(int j = 0; j < aIDs.Size(); j++)
        {
            if((DWORD)(aIDs[j]) == dwId)
            {
                m_pObject->m_papQueries->GetAt(i)->m_wsClass = 
                    pExpr->bsClassName;
                hres = m_pObject->m_pNamespace->GetObject(pExpr->bsClassName, 0, 
                                                    NULL, &pClass, NULL);
                if(FAILED(hres))
                    return hres;
    
                if(m_pObject->m_papQueries->GetAt(i)->m_pClass)
                    m_pObject->m_papQueries->GetAt(i)->m_pClass->Release();
                m_pObject->m_papQueries->GetAt(i)->m_pClass = pClass;
    
                return S_OK;
            }
        }

        if(m_pObject->m_papQueries->GetAt(i)->m_wsClass.EqualNoCase(
                    pExpr->bsClassName))
        {
            aIDs.Add((void*)dwId);
            return S_OK;
        }    
    }

    hres = m_pObject->m_pNamespace->GetObject(pExpr->bsClassName, 0, NULL, 
                                                &pClass, NULL);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pClass);

    CRecord* pRecord = new CRecord;
    pRecord->m_aIDs.Add((void*)dwId);
    pRecord->m_wsClass = pExpr->bsClassName;
    pRecord->m_pClass = pClass;
    pClass->AddRef();
    pClass->SpawnInstance(0, &pRecord->m_pInstance);

    pRecord->m_pInstance->QueryInterface(IID_IWbemObjectAccess, 
                                            (void**)&pRecord->m_pAccess);
    pRecord->m_pAccess->GetPropertyHandle(L"p1", NULL, &pRecord->m_lHandle);
    
    m_pObject->m_papQueries->Add(pRecord);

    return S_OK;
}
            
STDMETHODIMP CProvider::XQuery::CancelQuery(DWORD dwId)
{
    CInCritSec ics(m_pObject->m_pcs);


    for(int i = 0; i < m_pObject->m_papQueries->GetSize(); i++)
    {
        CFlexArray& aIDs = m_pObject->m_papQueries->GetAt(i)->m_aIDs;

        for(int j = 0; j < aIDs.Size(); j++)
        {
            if((DWORD)(aIDs[j]) == dwId)
            {
                aIDs.RemoveAt(j);
                if(aIDs.Size() == 0)
                    m_pObject->m_papQueries->RemoveAt(i);
                return S_OK;
            }
        }
    }

    FILE* f = fopen("c:\\l.txt", "a");
    fprintf(f, "Cancel nonexistent query %d\n", dwId);
    fclose(f);

    return WBEM_E_NOT_FOUND;
}
    
    
STDMETHODIMP CProvider::XProv::ProvideEvents(IWbemObjectSink* pSink,long lFlags)
{
    if(m_pObject->m_hThread)
        DebugBreak();
        
    m_pObject->m_pSink = pSink;
    pSink->AddRef();

/*
    HRESULT hres;
    IWbemClassObject* pClass = NULL;
    BSTR str = SysAllocString(L"MyTest");
    hres = m_pObject->m_pNamespace->GetObject(str, 0, NULL, &pClass, NULL);
    SysFreeString(str);
    if(FAILED(hres))
        return hres;

    IWbemClassObject* pInst = NULL;
    pClass->SpawnInstance(0, &pInst);
    pClass->Release();
    
    hres = m_pObject->m_pNamespace->PutInstance(pInst, 0, NULL, NULL);
    pInst->Release();
    if(FAILED(hres))
        return hres;

    IWbemClassObject* pInstance;
    m_pObject->m_pClass->SpawnInstance(0, &pInstance);

    m_pObject->m_pSink->Indicate(1, &pInstance);
    pInstance->Release();
*/
    
    m_pObject->m_hThread = CreateThread(NULL, 0, 
                                    (LPTHREAD_START_ROUTINE)&CProvider::Worker, 
                                    m_pObject, 0, &m_pObject->m_dwId);
    return S_OK;
}

DWORD CProvider::Worker(void* p)
{
    CoInitializeEx(NULL, COINIT_MULTITHREADED);

    CProvider* pThis = (CProvider*)p;
    DWORD dwNum = pThis->m_dwNum;

/*
    IWbemClassObject* pClass = pThis->m_pClass;
    pClass->AddRef();
*/

    IWbemObjectSink* pSink = pThis->m_pSink;
    pSink->AddRef();

    BOOL* pbOK = pThis->m_pbOK;
    CCritSec* pcs = pThis->m_pcs;
    CUniquePointerArray<CRecord>* papQueries = pThis->m_papQueries;

    DWORD dwIndex = 0;
    
    while(*pbOK)
    {
/*
        if(papQueries->GetSize() != 0)
        {
            CRecord* pRecord = papQueries->GetAt(0);
            IWbemClassObject* pInstance = pRecord->m_pInstance;
            IWbemObjectAccess* pAccess = pRecord->m_pAccess;
            pInstance->AddRef();
            long lHandle = pRecord->m_lHandle;
            long lStrHandle;
            pAccess->GetPropertyHandle(L"s1", NULL, &lStrHandle);
            while(*pbOK)
            {
                // EnterCriticalSection(pcs);
                // pInstance->AddRef();
                // LeaveCriticalSection(pcs);
        
                pAccess->WriteDWORD(lHandle, dwIndex);
                // pAccess->WritePropertyValue(lStrHandle, 16, (BYTE*)L"abcdefg");
                dwIndex = (dwIndex + 1) % LOOP_SIZE;
                // RandomizeInstance(pInstance);
        
                pSink->Indicate(1, &pInstance);
				Sleep(1000);
                // pInstance->Release();
            }
            pInstance->Release();
        }
        else
            Sleep(1000);
*/
        DWORD dwStart = GetTickCount();

        for(int nCount = 0; nCount < (NUM_EVENTS/10) + 1; nCount++)
        {
            EnterCriticalSection(pcs);
            if(papQueries->GetSize() != 0)
            {
                int nIndex = 0; //Random() % papQueries->GetSize();
                IWbemClassObject* pInstance = 
                    papQueries->GetAt(nIndex)->m_pInstance;
                pInstance->AddRef();

                LeaveCriticalSection(pcs);
        
                // RandomizeInstance(pInstance);

                IWbemClassObject* pICE = NULL;
                pThis->m_pClass->SpawnInstance(0, &pICE);

                VARIANT v;
                V_VT(&v) = VT_I4;
                V_I4(&v) = nCount;
                
                pInstance->Put(L"p1", 0, &v, 0);

                V_VT(&v) = VT_UNKNOWN;
                V_UNKNOWN(&v) = pInstance;
               
                pICE->Put(L"TargetInstance", 0, &v, 0);

                IWbemClassObject* pClone = NULL;
                pInstance->Clone(&pClone);
                pInstance->Release();

                V_UNKNOWN(&v) = pICE;
                pClone->Put(L"Embed", 0, &v, 0);
        
                pSink->Indicate(1, &pClone);
                pClone->Release();
            }
            else
            {
                LeaveCriticalSection(pcs);
                Sleep(1000);
            }
        }
            
        DWORD dwElapsed = GetTickCount() - dwStart;
        if(dwElapsed < 100)
            Sleep(100 - dwElapsed);
    }

    pSink->Release();
//    pClass->Release();
    delete pbOK;
    delete pcs;
    delete papQueries;

    return 0;
}


class CProvider1 : public CProvider
{
public:
    CProvider1(CLifeControl* pControl, IUnknown* pOuter = NULL)
        : CProvider(L"TestEvent1", 10, pControl)
    {}
};

class CProvider2 : public CProvider
{
public:
    CProvider2(CLifeControl* pControl, IUnknown* pOuter = NULL)
        : CProvider(L"TestEvent2", 5, pControl)
    {}
};


class CMyServer : public CComServer
{
public:
    HRESULT Initialize()
    {
        HRESULT hr = AddClassInfo(CLSID_TestEventProvider1, 
            new CClassFactory<CProvider1>(GetLifeControl()), 
            _T("Test Event Provider 1"), TRUE);
        return S_OK;
    }
    HRESULT InitializeCom()
    {
        return CoInitializeEx(NULL, COINIT_MULTITHREADED);
    }
} Server;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\scrcons\classfac.cpp ===
#include "precomp.h"
#include "ClassFac.h"
#include <arrTempl.h>

DWORD WMIScriptClassFactory::m_scriptsStarted = 0;
 
DWORD WMIScriptClassFactory::m_scriptsAllowed = 300;

bool WMIScriptClassFactory::m_bIsScriptsAllowedInitialized = false;
bool WMIScriptClassFactory::m_bWeDeadNow = false;


DWORD WMIScriptClassFactory::m_timerID = 0;

HRESULT WMIScriptClassFactory::CreateInstance(IUnknown* pOuter, REFIID riid, void** ppv)
{
    if (!m_bIsScriptsAllowedInitialized)
        FindScriptsAllowed();
    
    HRESULT hr = CClassFactory<CScriptConsumer>::CreateInstance(pOuter, riid, ppv);

    return hr;
}

// our time has come.  Curl up & die.
void CALLBACK WMIScriptClassFactory::TimeoutProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime) 
{
    CoSuspendClassObjects();
    KillTimer(NULL, m_timerID);
    m_timerID = 0;
    m_bWeDeadNow = true;
}

bool WMIScriptClassFactory::LimitReached(void)
{
    return m_bWeDeadNow;
}

// determine number of scripts we're allowed to run
// from the class registration object
void WMIScriptClassFactory::FindScriptsAllowed(void)
{    
    m_bIsScriptsAllowedInitialized = true;
    HRESULT hr;
    IWbemLocator* pLocator;

    if (SUCCEEDED(hr = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_ALL, 
                                          IID_IWbemLocator, (void**)&pLocator)))
    {
        CReleaseMe releaseLocator(pLocator);

        BSTR bstrNamespace;
        bstrNamespace = SysAllocString(L"root\\CIMv2");
        
        if (bstrNamespace)
        {
            IWbemServices* pNamespace;
            CSysFreeMe freeBstr(bstrNamespace);
            hr = pLocator->ConnectServer(bstrNamespace,  NULL, NULL, NULL, 0, NULL, NULL, &pNamespace);
            if (SUCCEEDED(hr))
            {
                CReleaseMe relNamespace(pNamespace);

                BSTR bstrClassName;
                bstrClassName = SysAllocString(L"ScriptingStandardConsumerSetting=@");
                if (bstrClassName)
                {
                    IWbemClassObject* pRegistration = NULL;
                    CSysFreeMe freeTheClassNames(bstrClassName);               
                    hr = pNamespace->GetObject(bstrClassName, 0, NULL, &pRegistration, NULL);
                    if (SUCCEEDED(hr))
                    {
                        CReleaseMe relRegistration(pRegistration);

                        VARIANT v;
                        VariantInit(&v);

                        if (SUCCEEDED(pRegistration->Get(L"MaximumScripts", 0, &v, NULL, NULL))
                            && ((v.vt == VT_I4) || (v.vt == VT_UI4))
                            && (v.ulVal > 0))
                        {
                            m_scriptsAllowed = (DWORD)v.ulVal;
                            VariantClear(&v);
                        }

                        if (SUCCEEDED(hr = pRegistration->Get(L"Timeout", 0, &v, NULL, NULL))
                            && (v.vt == VT_I4))
                        {
                            // maximum to prevent overflow, doc'd in MOF
                            if ((((DWORD)v.lVal) <= 71000) && ((DWORD)v.lVal > 0))
                            {
                                UINT nMilliseconds = (DWORD)v.lVal * 1000 * 60;
                                m_timerID = SetTimer(NULL, 0, nMilliseconds, TimeoutProc);
                            }
                        }
                    }
                }
            }
        }
    }
}

// after the specified number of scripts have been run
// we suspend the class object
// note that access to m_scriptsStarted is not serialized.
// this should not cause a problem, m_scripts allowed does not change
// after instanciation, and if we blow it, it just means we allow
// an extra script to be run, or call CoSuspend an extra time.
void WMIScriptClassFactory::IncrementScriptsRun(void)
{    
    InterlockedIncrement((long*)&m_scriptsStarted);

    if (m_scriptsStarted >= m_scriptsAllowed)
    {
        CoSuspendClassObjects();
        m_bWeDeadNow = true;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\scrcons\main.cpp ===
#include "precomp.h"
#include <commain.h>
#include <clsfac.h>
#include <TChar.h>
#include "ClassFac.h"
#include "ScriptKiller.h"
#include "script.h"

const CLSID CLSID_WbemActiveScriptConsumer = 
    {0x266c72e7,0x62e8,0x11d1,{0xad,0x89,0x00,0xc0,0x4f,0xd8,0xfd,0xff}};

class CMyServer : public CComServer
{
public:
#ifdef ENABLE_REMOTING
	void RegisterMe(CLSID clsID, WCHAR* name)
	{    
        WCHAR      wcID[128];
        WCHAR      szKeyName[128];
        HKEY       hKey;

        // open/create registry entry under CLSID
        StringFromGUID2(clsID, wcID, 128);
        lstrcpy(szKeyName, TEXT("SOFTWARE\\Classes\\CLSID\\"));
        lstrcat(szKeyName, wcID);
        RegCreateKey(HKEY_LOCAL_MACHINE, szKeyName, &hKey);
        
        // set AppID
        RegSetValueEx(hKey, L"AppID", 0, REG_SZ, (BYTE*)wcID, 2*(wcslen(wcID) +1));
        RegCloseKey(hKey);

        // make appID entry w/ DLLSurrogate value
        lstrcpy(szKeyName, TEXT("SOFTWARE\\Classes\\APPID\\"));
        lstrcat(szKeyName, wcID);
        RegCreateKey(HKEY_LOCAL_MACHINE, szKeyName, &hKey);

        // and a nice name
        RegSetValueEx(hKey, NULL, 0, REG_SZ, (BYTE*)name, 2*(wcslen(name) +1));
        RegCloseKey(hKey);
	}


    virtual void Register()
    {
		RegisterMe(CLSID_WbemActiveScriptConsumer, L"Microsoft WBEM Active Scripting Event Consumer Provider");
	}

	void UnregisterMe(CLSID clsID)
	{
		WCHAR      wcID[128];
        HKEY       hKey;

		if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Classes\\APPID\\"), &hKey))
		{
			if (0 != StringFromGUID2(clsID, wcID, 128))
			{
				RegDeleteKey(hKey, wcID);
			}
			RegCloseKey(hKey);
		}

	}
	
	virtual void Unregister()
	{
        UnregisterMe(CLSID_WbemActiveScriptConsumer);
	}

#endif // ENABLE_REMOTING


protected:
    HRESULT Initialize()
    {
        g_scriptKillerTimer.Initialize(GetLifeControl());

        AddClassInfo(CLSID_WbemActiveScriptConsumer, 
            new WMIScriptClassFactory(GetLifeControl()), 
            _T("Active Scripting Event Consumer Provider"), TRUE);

        return S_OK;
    }
} g_Server;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\scrcons\script.cpp ===
#include "precomp.h"
#include <stdio.h>
#include <wbemutil.h>
#include <ArrTempl.h>
#include <lmaccess.h>
#include <wbemdisp.h>
#include "ScriptKiller.h"
#include "script.h"
#include "ClassFac.h"
#include <GroupsForUser.h> 
#include <GenUtils.h>

#define SCRIPT_PROPNAME_SCRIPT L"ScriptText"
#define SCRIPT_PROPNAME_FILENAME L"ScriptFilename"
#define SCRIPT_PROPNAME_ENGINE L"ScriptingEngine"
#define SCRIPT_PROPNAME_TIMEOUT L"KillTimeout"

#define SCRIPT_EVENTNAME L"TargetEvent"

// uncomment me to remove the WMI script object
// #define NO_DISP_CLASS

#ifdef HOWARDS_DEBUG_CODE
#define NO_DISP_CLASS
#endif // HOWARDS_DEBUG_CODE

HRESULT STDMETHODCALLTYPE CScriptConsumer::XProvider::FindConsumer(
                    IWbemClassObject* pLogicalConsumer,
                    IWbemUnboundObjectSink** ppConsumer)
{
    if (WMIScriptClassFactory::LimitReached())
       return RPC_E_DISCONNECTED;
    
    CScriptSink* pSink = new CScriptSink(m_pObject->m_pControl);
    if (!pSink)
        return WBEM_E_OUT_OF_MEMORY;

    HRESULT hres = pSink->Initialize(pLogicalConsumer);
    if(FAILED(hres))
    {
        delete pSink;
        *ppConsumer = NULL;
        return hres;
    }
    else return pSink->QueryInterface(IID_IWbemUnboundObjectSink, 
                                        (void**)ppConsumer);
}

void* CScriptConsumer::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemEventConsumerProvider)
        return &m_XProvider;
    else return NULL;
}

class CScriptSite : public IActiveScriptSite, public IActiveScriptSiteWindow
{
protected:
    long m_lRef;

    IDispatch* m_pObject;
    CScriptSink* m_pSink;

    HRESULT m_hr;
public:
    CScriptSite(CScriptSink* pSink, IDispatch* pObject);
    ~CScriptSite();

    HRESULT GetScriptHResult()
    { return m_hr; }

    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    
    virtual HRESULT STDMETHODCALLTYPE GetLCID(
        /* [out] */ LCID __RPC_FAR *plcid);

    virtual HRESULT STDMETHODCALLTYPE GetItemInfo(
        /* [in] */ LPCOLESTR pstrName,
        /* [in] */ DWORD dwReturnMask,
        /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppiunkItem,
        /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppti);

    virtual HRESULT STDMETHODCALLTYPE GetDocVersionString(
        /* [out] */ BSTR __RPC_FAR *pbstrVersion);

    virtual HRESULT STDMETHODCALLTYPE OnScriptTerminate(
        /* [in] */ const VARIANT __RPC_FAR *pvarResult,
        /* [in] */ const EXCEPINFO __RPC_FAR *pexcepinfo);

    virtual HRESULT STDMETHODCALLTYPE OnStateChange(
        /* [in] */ SCRIPTSTATE ssScriptState);

    virtual HRESULT STDMETHODCALLTYPE OnScriptError(
        /* [in] */ IActiveScriptError __RPC_FAR *pscripterror);

    virtual HRESULT STDMETHODCALLTYPE OnEnterScript( void);

    virtual HRESULT STDMETHODCALLTYPE OnLeaveScript( void);

    virtual HRESULT STDMETHODCALLTYPE GetWindow(
        /* [out] */ HWND __RPC_FAR *phwnd);

    virtual HRESULT STDMETHODCALLTYPE EnableModeless(
        /* [in] */ BOOL fEnable);

};

CScriptSite::CScriptSite(CScriptSink* pSink, IDispatch* pObject) :
    m_lRef(0), m_hr(0)
{
    m_pSink = pSink;
    m_pSink->AddRef();

    m_pObject = pObject;
    if(m_pObject)
        m_pObject->AddRef();
}

CScriptSite::~CScriptSite()
{
    if(m_pObject)
        m_pObject->Release();
    if(m_pSink)
        m_pSink->Release();
}

HRESULT STDMETHODCALLTYPE CScriptSite::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IActiveScriptSite)
        *ppv = (IActiveScriptSite*)this;
    else if(riid == IID_IActiveScriptSiteWindow)
        *ppv = (IActiveScriptSiteWindow*)this;
    else
        return E_NOINTERFACE;
    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}

ULONG STDMETHODCALLTYPE CScriptSite::AddRef() 
{
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CScriptSite::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}
        


HRESULT STDMETHODCALLTYPE CScriptSite::GetLCID(
        /* [out] */ LCID __RPC_FAR *plcid)
{ 
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CScriptSite::GetItemInfo(
        /* [in] */ LPCOLESTR pstrName,
        /* [in] */ DWORD dwReturnMask,
        /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppiunkItem,
        /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppti)
{ 
    if(_wcsicmp(pstrName, SCRIPT_EVENTNAME))
        return TYPE_E_ELEMENTNOTFOUND;
    if(ppti)
        *ppti = NULL;
    if(ppiunkItem)
        *ppiunkItem = NULL;

    if(dwReturnMask & SCRIPTINFO_IUNKNOWN)
    {
        if(ppiunkItem == NULL)
            return E_POINTER;
        m_pObject->QueryInterface(IID_IUnknown, (void**)ppiunkItem);
    }
    
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CScriptSite::GetDocVersionString(
        /* [out] */ BSTR __RPC_FAR *pbstrVersion)
{ return E_NOTIMPL;}

HRESULT STDMETHODCALLTYPE CScriptSite::OnScriptTerminate(
        /* [in] */ const VARIANT __RPC_FAR *pvarResult,
        /* [in] */ const EXCEPINFO __RPC_FAR *pexcepinfo)
{ return S_OK;}

HRESULT STDMETHODCALLTYPE CScriptSite::OnStateChange(
        /* [in] */ SCRIPTSTATE ssScriptState)
{ return S_OK;}

HRESULT STDMETHODCALLTYPE CScriptSite::OnScriptError(
        /* [in] */ IActiveScriptError __RPC_FAR *pscripterror)
{ 
    HRESULT hres;
    EXCEPINFO ei;
    hres = pscripterror->GetExceptionInfo(&ei);
    if(SUCCEEDED(hres))
    {
        if (ei.bstrSource)
        {
            m_pSink->m_wsErrorMessage = ei.bstrSource;
            m_pSink->m_wsErrorMessage += L": ";
        }

        if (ei.bstrDescription)
            m_pSink->m_wsErrorMessage += ei.bstrDescription;
        else
            m_pSink->m_wsErrorMessage += L"unknown";

        if ((ei.wCode != 0) && (ei.wCode >= 1000))
            m_hr = WBEM_E_FAILED;
        else 
            m_hr = ei.scode;
    }
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CScriptSite::OnEnterScript( void)
{ return S_OK;}

HRESULT STDMETHODCALLTYPE CScriptSite::OnLeaveScript( void)
{ return S_OK;}

HRESULT STDMETHODCALLTYPE CScriptSite::GetWindow(
    /* [out] */ HWND __RPC_FAR *phwnd)
{
    *phwnd = NULL;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CScriptSite::EnableModeless(
    /* [in] */ BOOL fEnable)
{return S_OK;}






CScriptSink::~CScriptSink()
{
    if(m_pEngineFac)
        m_pEngineFac->Release();
}

HRESULT CScriptSink::Initialize(IWbemClassObject* pLogicalConsumer)
{
    VARIANT v;
    VariantInit(&v);
    
    BSTR propName;
    propName = SysAllocString(L"CreatorSID");
    if (!propName)
        return WBEM_E_OUT_OF_MEMORY;
    CSysFreeMe freeName(propName);

    if (SUCCEEDED(pLogicalConsumer->Get(propName, 0, &v, NULL, NULL)))
    {
        HRESULT hDebug;
        long ubound;
        hDebug = SafeArrayGetUBound(V_ARRAY(&v), 1, &ubound);

        PVOID pVoid;
        hDebug = SafeArrayAccessData(V_ARRAY(&v), &pVoid);

        m_pSidCreator = new BYTE[ubound +1];
        if (m_pSidCreator)
            memcpy(m_pSidCreator, pVoid, ubound + 1);
        else
            return WBEM_E_OUT_OF_MEMORY;

        SafeArrayUnaccessData(V_ARRAY(&v));
    }
    else
        return WBEM_E_FAILED;
    
    
    // Get the information
    // ===================

    HRESULT hres;
    VariantInit(&v);

    hres = pLogicalConsumer->Get(SCRIPT_PROPNAME_ENGINE, 0, &v, NULL, NULL);
    if(FAILED(hres) || V_VT(&v) != VT_BSTR)
        return WBEM_E_INVALID_PARAMETER;
    WString wsEngine = V_BSTR(&v);
    VariantClear(&v);

    hres = pLogicalConsumer->Get(SCRIPT_PROPNAME_TIMEOUT, 0, &v, NULL, NULL);
    if(V_VT(&v) == VT_I4)
        m_dwKillTimeout = V_I4(&v);
    else
        m_dwKillTimeout = 0;
    VariantClear(&v);

    hres = pLogicalConsumer->Get(SCRIPT_PROPNAME_SCRIPT, 0, &v, NULL, NULL);
    if (SUCCEEDED(hres))
    {
        if (V_VT(&v) == VT_BSTR)
        {
            m_wsScript = V_BSTR(&v);
            VariantClear(&v);
        }
        else
        // try the script file name approach
        {
            hres = pLogicalConsumer->Get(SCRIPT_PROPNAME_FILENAME, 0, &v, NULL, NULL);
            if (SUCCEEDED(hres) && (V_VT(&v) == VT_BSTR))
            {
                m_wsScriptFileName = V_BSTR(&v);
                VariantClear(&v);
            }
            else
                return WBEM_E_INVALID_PARAMETER;
        }                                                        
    }
    else 
        return WBEM_E_INVALID_PARAMETER;


    // Get the CLSID
    // =============
    CLSID clsid;
    if (wsEngine.Length() == 0)
        hres = WBEM_E_INVALID_PARAMETER;
    else
        hres = CLSIDFromProgID((LPCWSTR)wsEngine, &clsid);

    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Scripting engine '%S' not found: %X\n",
            (LPCWSTR)wsEngine, hres));
        return hres;
    }

    hres = CoGetClassObject(clsid, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
                NULL, IID_IClassFactory, (void**)&m_pEngineFac);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Unable to create scripting engine %S: %X\n",
            (LPCWSTR)wsEngine, hres));
        return hres;
    }

    return S_OK;
}

// runs the script contained in the script text
HRESULT CScriptSink::RunScriptText(IWbemClassObject *pObj)
{
    HRESULT hres = S_OK;


    WMIScriptClassFactory::IncrementScriptsRun();
    
    IActiveScript* pScript;
    hres = m_pEngineFac->CreateInstance(NULL, IID_IActiveScript,
            (void**)&pScript);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Unable to create a script. Error code %X\n", 
            hres));
        return hres;
    }

    IActiveScriptParse* pParse;
    hres = pScript->QueryInterface(IID_IActiveScriptParse, (void**)&pParse);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Scripting engine does not support "
            "parsing!\n"));
        pScript->Release();
        return hres;
    }

    IDispatch* pDObject;
#ifdef NO_DISP_CLASS
    pDObject = NULL;
#else
	IBindCtx *pbc = NULL;; 
	IMoniker *pMk = NULL;
	ULONG chEaten = 0; 
	
	if(FAILED(hres = CreateBindCtx(0, &pbc)))
	{
        ERRORTRACE((LOG_ESS, "Unable to Create IBindCtx: 0x%X\n", hres));
        pScript->Release();
        return hres;
    }

	if(FAILED(hres = pbc->RegisterObjectParam(L"WmiObject", pObj)))
	{
		ERRORTRACE((LOG_ESS, "Unable to Register IBindCtx: 0x%X\n", hres));
		pScript->Release();
		return hres;
	}

	if(FAILED(hres = MkParseDisplayName(pbc, L"winmgmts:", &chEaten, &pMk)))
	{
		ERRORTRACE((LOG_ESS, "Unable to MkParseDisplayName: 0x%X\n", hres));
		pScript->Release();
		return hres;
	}

	if(FAILED(hres = pMk->BindToObject(pbc, 0, IID_ISWbemObject, (void **)&pDObject)))
	{
		ERRORTRACE((LOG_ESS, "Unable to BindToObject: 0x%X\n", hres));
		pScript->Release();
		return hres;
	}

	pMk->Release();
	pbc->Release();
	
#endif

    CScriptSite* pSite = new CScriptSite(this, pDObject);
    pSite->AddRef();

#ifndef NO_DISP_CLASS
	if(pDObject) pDObject->Release();
#endif

    hres = pScript->SetScriptSite(pSite);

    hres = pParse->InitNew();
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Failed to initialize script(InitNew): %X\n", 
            hres));
        pSite->Release();
        pScript->Release();
        pParse->Release();
        return hres;
    }

#ifndef NO_DISP_CLASS
    hres = pScript->AddNamedItem(SCRIPT_EVENTNAME, 
        SCRIPTITEM_ISVISIBLE | SCRIPTITEM_NOCODE);

    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Failed to add named item: %X\n", hres));
        pSite->Release();
        pScript->Release();
        pParse->Release();
        return hres;
    }
#endif

    EXCEPINFO ei;
    hres = pParse->ParseScriptText(
        (LPCWSTR)m_wsScript,
        NULL, NULL, NULL, 
        0, 0, 0, NULL, &ei);

    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Failed to parse script. Error code %X\n"
            "Scripting engine says: %S\n", hres, 
            (LPCWSTR)m_wsErrorMessage));
        pSite->Release();
        pScript->Release();
        pParse->Release();
        return hres;
    }
    pParse->Release();


    if (m_dwKillTimeout)
    {           
        FILETIME now;
        GetSystemTimeAsFileTime(&now);        
        WAYCOOL_FILETIME expires(now);
        expires.AddSeconds(m_dwKillTimeout);

        SCRIPTTHREADID threadID;
        hres = pScript->GetScriptThreadID(GetCurrentThreadId(), &threadID);
        if (SUCCEEDED(hres))
            g_scriptKillerTimer.ScheduleAssassination(pScript, expires, threadID);

        /************
        Doing it in the stream.  Probably don't need to.
        LPSTREAM pStream;
        if (SUCCEEDED(hres) && 
            SUCCEEDED(CoMarshalInterThreadInterfaceInStream(IID_IActiveScript, pScript, &pStream)))
        {
            g_scriptKillerTimer.ScheduleAssassination(pStream, expires, threadID);
        }
        ***************/
    }
    
    hres = pScript->SetScriptState(SCRIPTSTATE_CONNECTED);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Failed to execute script. Error code 0x%X\n"
            "Scripting engine says: %S\n", hres, 
            (LPCWSTR)m_wsErrorMessage));
    }
    else if (FAILED(pSite->GetScriptHResult()))
    {
        hres = pSite->GetScriptHResult();
        ERRORTRACE((LOG_ESS, "Error in script execution. Error code 0x%X\n"
            "Scripting engine says: %S\n", hres, 
            (LPCWSTR)m_wsErrorMessage));

    }
        
    pScript->Close();

    pScript->Release();
    pSite->Release();

    return hres;
}

HRESULT CScriptSink::RunScriptFile(IWbemClassObject *pObj)
{
    HRESULT hr = WBEM_E_INVALID_PARAMETER;

    if (m_wsScriptFileName.Length())
    {
        HANDLE hFile = CreateFileW((LPWSTR)m_wsScriptFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

        if (hFile != INVALID_HANDLE_VALUE)
        {
            DWORD fSize;
            if (0xFFFFFFFF != (fSize = GetFileSize(hFile, &fSize)))
            {
                char* pBuf = new char[fSize +2];             
                if (!pBuf)
                    hr = WBEM_E_OUT_OF_MEMORY;
                else
                {
                    DWORD dwErr = GetLastError();
                    
                    ZeroMemory(pBuf, fSize+1);
                    DWORD bitsRead;

                    if (ReadFile(hFile, pBuf, fSize, &bitsRead, NULL))
                    {
                        hr = WBEM_S_NO_ERROR;

                        const WCHAR ByteOrderMark = L'\xFEFF';
                        // determine whether this is a unicode file
                        if (((WCHAR*)pBuf)[0] == ByteOrderMark)                        
                            m_wsScript.BindPtr((WCHAR*)pBuf);
                        else
                        {
                            // not unicode, do the conversion
                            WCHAR* pWideBuf = new WCHAR[strlen(pBuf) +1];
                            if (!pWideBuf)
                                hr = WBEM_E_OUT_OF_MEMORY;
                            else
                            {
                                swprintf(pWideBuf, L"%S", pBuf);
                                m_wsScript.BindPtr(pWideBuf);
                            }
                            
                            delete pBuf;
                        }
                        
                        if (SUCCEEDED(hr))
                            hr = RunScriptText(pObj);
                    }                       
                    else
                    {
                        ERRORTRACE((LOG_ESS, "Script: Cannot read %S, 0x%X\n", (LPWSTR)m_wsScriptFileName, GetLastError()));
                        hr = WBEM_E_FAILED;
                    }
                }                                
            }

            CloseHandle(hFile);
        }
        else
            ERRORTRACE((LOG_ESS, "Script: Cannot Open %S, 0x%X\n", (LPWSTR)m_wsScriptFileName, GetLastError()));
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE CScriptSink::XSink::IndicateToConsumer(
            IWbemClassObject* pLogicalConsumer, long lNumObjects, 
            IWbemClassObject** apObjects)
{
    if (IsNT())
    {
        PSID pSidSystem;
        SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;
 
        if  (AllocateAndInitializeSid(&id, 1,
            SECURITY_LOCAL_SYSTEM_RID, 
            0, 0,0,0,0,0,0,&pSidSystem))
        {         
            // guilty until proven innocent
            HRESULT hr = WBEM_E_ACCESS_DENIED;

            // check to see if sid is either Local System or an admin of some sort...
            if ((EqualSid(pSidSystem, m_pObject->m_pSidCreator)) ||
                (S_OK == IsUserAdministrator(m_pObject->m_pSidCreator)))
                hr = WBEM_S_NO_ERROR;
          
            // We're done with this
            FreeSid(pSidSystem);

            if (FAILED(hr))
                return hr;
        }
        else
            return WBEM_E_OUT_OF_MEMORY;
    }

    if (WMIScriptClassFactory::LimitReached())
        return RPC_E_DISCONNECTED;
    
    HRESULT hrOutter = WBEM_S_NO_ERROR;

    for(int i = 0; i < lNumObjects; i++)
    {
        HRESULT hrInner;
        
        if (m_pObject->m_wsScript.Length())
            hrInner = m_pObject->RunScriptText(apObjects[i]);
        else if (m_pObject->m_wsScriptFileName.Length())
            hrInner = m_pObject->RunScriptFile(apObjects[i]);            
		else
			return WBEM_E_INVALID_PARAMETER;

        if (FAILED(hrInner))
        {
            hrOutter = hrInner;
            // m_pObject->RaiseErrorStatus();
        }
    }

    return hrOutter;
}    

void* CScriptSink::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemUnboundObjectSink)
        return &m_XSink;
    else return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\scrcons\scriptkiller.h ===
#ifndef __SCRIPT_KILLER_COMPILED__
#define __SCRIPT_KILLER_COMPILED__

#include <activscp.h>
#include "KillTimer.h"

// only need one of these laying around
class CScriptKillerTimer;
extern CScriptKillerTimer g_scriptKillerTimer;

// specialized to kill scripts
class CScriptKillerTimer : public CKillerTimer
{
public:
    
    // who to kill & when
    HRESULT ScheduleAssassination(IActiveScript* pScript, FILETIME lastMeal, SCRIPTTHREADID threadID);            
    // HRESULT ScheduleAssassination(LPSTREAM pStream, FILETIME lastMeal, SCRIPTTHREADID threadID);            
};

/* CLASS CScriptKiller DEFINITION */

// hold script that needs to be killed
class CScriptKiller : public CKiller
{
public:
    CScriptKiller(IActiveScript* pScript, FILETIME deathDate, SCRIPTTHREADID threadID, CLifeControl* pControl) :
      CKiller(deathDate, pControl), m_pScript(pScript) /*m_pStream(pStream)*/, m_threadID(threadID)
    {
        m_pScript->AddRef();
    }

    virtual ~CScriptKiller()
    {
        m_pScript->Release();
    }

    // terminate process, 
    virtual void Die();

protected:

private:
    IActiveScript* m_pScript;
    // LPSTREAM m_pStream;

    SCRIPTTHREADID m_threadID;
};

#endif //__SCRIPT_KILLER_COMPILED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\scrcons\scriptkiller.cpp ===
#include "precomp.h"
#include "ScriptKiller.h"

// the only one we'll ever need
CScriptKillerTimer g_scriptKillerTimer;

// last meal is the scheduled execution date
HRESULT CScriptKillerTimer::ScheduleAssassination(IActiveScript* pScript, FILETIME lastMeal, SCRIPTTHREADID threadID)
{
    HRESULT hr = WBEM_E_FAILED;

    CScriptKiller* pKiller;

    if (pKiller = new CScriptKiller(pScript, lastMeal, threadID, m_pControl))
        hr = CKillerTimer::ScheduleAssassination(pKiller);
    else
        // allocation failed
        hr = WBEM_E_OUT_OF_MEMORY;

    return hr;
}

// terminate script
void CScriptKiller::Die()
{
    if (m_pScript)
    {
        EXCEPINFO info;    
        ZeroMemory(&info, sizeof(EXCEPINFO));
        HRESULT hr;

        // regardless of what the dox say, KB article Q182946 says to pass NULL for the second parm.  Really.
        // experimentation shows that zero-ing out the info struct works, too.
        //hr = pScript->InterruptScriptThread(m_threadID, &info, 0);
        hr = m_pScript->SetScriptState(SCRIPTSTATE_DISCONNECTED);
        hr = m_pScript->InterruptScriptThread(SCRIPTTHREADID_ALL, &info, 0);
    }

    /***********************
    stream method
    if (m_pStream)
    {
        EXCEPINFO info;    
        ZeroMemory(&info, sizeof(EXCEPINFO));
        
        IActiveScript* pScript;
        HRESULT hr = CoGetInterfaceAndReleaseStream(m_pStream, IID_IActiveScript, (LPVOID *) &pScript);
        m_pStream = NULL;
    
        // regardless of what the dox say, KB article Q182946 says to pass NULL for the second parm.  Really.
        // experimentation shows that zero-ing out the info struct works, too.
        //hr = pScript->InterruptScriptThread(m_threadID, &info, 0);
        hr = pScript->InterruptScriptThread(SCRIPTTHREADID_ALL, &info, 0);
        hr = pScript->SetScriptState(SCRIPTSTATE_DISCONNECTED);
    
        pScript->Release();    
    }
    *****************************/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\scrcons\script.h ===
#ifndef __WBEM_SCRIPT_CONSUMER__H_
#define __WBEM_SCRIPT_CONSUMER__H_

#include <unk.h>

#include <wbemidl.h>

#include "txttempl.h"
#include <stdio.h>
#include <activscp.h>

class CScriptConsumer : public CUnk
{
protected:
    class XProvider : public CImpl<IWbemEventConsumerProvider, CScriptConsumer>
    {
    public:
        XProvider(CScriptConsumer* pObj)
            : CImpl<IWbemEventConsumerProvider, CScriptConsumer>(pObj){}
    
        HRESULT STDMETHODCALLTYPE FindConsumer(
                    IWbemClassObject* pLogicalConsumer,
                    IWbemUnboundObjectSink** ppConsumer);
    } m_XProvider;
    friend XProvider;

public:
    CScriptConsumer(CLifeControl* pControl = NULL, IUnknown* pOuter = NULL)
        : CUnk(pControl, pOuter), m_XProvider(this)
    {}
    ~CScriptConsumer(){}
    void* GetInterface(REFIID riid);
};


class CScriptSink : public CUnk
{
protected:
    class XSink : public CImpl<IWbemUnboundObjectSink, CScriptSink>
    {
    public:
        XSink(CScriptSink* pObj) : 
            CImpl<IWbemUnboundObjectSink, CScriptSink>(pObj){}

        HRESULT STDMETHODCALLTYPE IndicateToConsumer(
            IWbemClassObject* pLogicalConsumer, long lNumObjects, 
            IWbemClassObject** apObjects);
    } m_XSink;
    friend XSink;

protected:
    // do the dirty work of making the script go
    HRESULT RunScriptFile(IWbemClassObject *pObj);
    HRESULT RunScriptText(IWbemClassObject *pObj);

    // logical consumer values
    WString m_wsScript;
    WString m_wsScriptFileName;
    PSID  m_pSidCreator;   
    // delay in seconds before killing script.  
    // If zero, script will not be killed; it must suicide.
    DWORD m_dwKillTimeout;

    IClassFactory* m_pEngineFac;

    // scripting DLL
    HMODULE m_hMod;

    WString m_wsErrorMessage;


    friend class CScriptSite;
public:
    CScriptSink(CLifeControl* pControl = NULL) 
        : CUnk(pControl), m_XSink(this), m_pEngineFac(NULL), m_pSidCreator(NULL)
    {}
    HRESULT Initialize(IWbemClassObject* pLogicalConsumer);
    ~CScriptSink();

    void* GetInterface(REFIID riid);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\smtpcons\main.cpp ===
#include "precomp.h"
#include <commain.h>
#include <clsfac.h>
#include "smtp.h"
#include <TCHAR.h>


// {C7A3A54B-0250-11D3-9CD1-00105A1F4801}
const CLSID CLSID_WbemSMTPConsumer = 
{ 0xc7a3a54b, 0x250, 0x11d3, { 0x9c, 0xd1, 0x0, 0x10, 0x5a, 0x1f, 0x48, 0x1 } };


class CMyServer : public CComServer
{
public:
#ifdef ENABLE_REMOTING
	void RegisterMe(CLSID clsID, WCHAR* name)
	{    
        WCHAR      wcID[128];
        WCHAR      szKeyName[128];
        HKEY       hKey;

        // open/create registry entry under CLSID
        StringFromGUID2(clsID, wcID, 128);
        lstrcpy(szKeyName, TEXT("SOFTWARE\\Classes\\CLSID\\"));
        lstrcat(szKeyName, wcID);
        RegCreateKey(HKEY_LOCAL_MACHINE, szKeyName, &hKey);
        
        // set AppID
        RegSetValueEx(hKey, L"AppID", 0, REG_SZ, (BYTE*)wcID, 2*(wcslen(wcID) +1));
        RegCloseKey(hKey);

        // make appID entry w/ DLLSurrogate value
        lstrcpy(szKeyName, TEXT("SOFTWARE\\Classes\\APPID\\"));
        lstrcat(szKeyName, wcID);
        RegCreateKey(HKEY_LOCAL_MACHINE, szKeyName, &hKey);
        RegSetValueEx(hKey, L"DllSurrogate", 0, REG_SZ, (BYTE*)L"\0", 2);

        // and a nice name
        RegSetValueEx(hKey, NULL, 0, REG_SZ, (BYTE*)name, 2*(wcslen(name) +1));
        RegCloseKey(hKey);
	}

	// provider server specific registration
	virtual void Register()
	{
		RegisterMe(CLSID_WbemSMTPConsumer, L"Microsoft WBEM SMTP Event Consumer Provider");
	}

	void UnregisterMe(CLSID clsID)
	{
		WCHAR      wcID[128];
        HKEY       hKey;

		if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Classes\\APPID\\"), &hKey))
		{
			if (0 != StringFromGUID2(clsID, wcID, 128))
			{
				RegDeleteKey(hKey, wcID);
			}
			RegCloseKey(hKey);
		}

	}
	
	virtual void Unregister()
	{
		UnregisterMe(CLSID_WbemSMTPConsumer);
	}
#endif

protected:
    HRESULT Initialize()
    {
        AddClassInfo(CLSID_WbemSMTPConsumer,
            new CClassFactory<CSMTPConsumer>(GetLifeControl()), 
            _T("SMTP Event Consumer Provider"), TRUE);

        return S_OK;
    }
} g_Server;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\smtpcons\smtp.h ===
#ifndef __WBEM_SMTP_CONSUMER__H_
#define __WBEM_SMTP_CONSUMER__H_

#include <unk.h>


#include <wbemidl.h>

#include "txttempl.h"

class CSMTPConsumer : public CUnk
{
protected:
    class XProvider : public CImpl<IWbemEventConsumerProvider, CSMTPConsumer>
    {
    public:
        XProvider(CSMTPConsumer* pObj)
            : CImpl<IWbemEventConsumerProvider, CSMTPConsumer>(pObj){}
    
        HRESULT STDMETHODCALLTYPE FindConsumer(
                    IWbemClassObject* pLogicalConsumer,
                    IWbemUnboundObjectSink** ppConsumer);
    } m_XProvider;
    friend XProvider;

public:
    CSMTPConsumer(CLifeControl* pControl = NULL, IUnknown* pOuter = NULL);
    ~CSMTPConsumer();
    void* GetInterface(REFIID riid);
};


class CSMTPSink : public CUnk
{
protected:
    class XSink : public CImpl<IWbemUnboundObjectSink, CSMTPSink>
    {
    public:
        XSink(CSMTPSink* pObj) : 
            CImpl<IWbemUnboundObjectSink, CSMTPSink>(pObj){}

        HRESULT STDMETHODCALLTYPE IndicateToConsumer(
            IWbemClassObject* pLogicalConsumer, long lNumObjects, 
            IWbemClassObject** apObjects);
    } m_XSink;
    friend XSink;

	char* PreProcessLine(WCHAR* line, bool bStripWhitespace, bool bHammerSemiColons);

protected:
    CTextTemplate m_SubjectTemplate;
    CTextTemplate m_MessageTemplate;

    CTextTemplate  m_To;
    CTextTemplate  m_Cc;
    CTextTemplate  m_Bcc;

    CTextTemplate  m_From;
    CTextTemplate  m_ReplyTo;
    WString m_wsServer;
    WString m_wsHeaders;

    bool m_bSMTPInitialized;
    bool m_bFakeFromLine; // true if the from line was generated from the computer name.

public:
    CSMTPSink(CLifeControl* pControl = NULL);
    ~CSMTPSink();

    HRESULT Initialize(IWbemClassObject* pLogicalConsumer);

    void* GetInterface(REFIID riid);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\scrcons\classfac.h ===
#ifndef _WMISCRIPT_CLASSFAC_HEADER_
#define _WMISCRIPT_CLASSFAC_HEADER_

#include <clsfac.h>
#include <Script.h>

class WMIScriptClassFactory : public CClassFactory<CScriptConsumer>
{
public:
    WMIScriptClassFactory(CLifeControl* pControl = NULL) : 
        CClassFactory<CScriptConsumer>(pControl)
        {}

    HRESULT CreateInstance(IUnknown* pOuter, REFIID riid, void** ppv);

    static void FindScriptsAllowed(void);
    static void IncrementScriptsRun(void);
    static bool LimitReached(void);

    static void CALLBACK TimeoutProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);

protected:
    // statics to control how many scripts we're allowed to run
    // note that we don't bother wrapping these in critical sections
    // The worst that can happen is that we initialize m_scriptsAllowed twice
    // or that we run one too many scripts.  I can live with that.

    // number of scripts we've been asked to run
    static DWORD m_scriptsStarted;

    // number of scripts we've been configured to run
    static DWORD m_scriptsAllowed;

    // whether we've gone & looked at how many we need
    static bool m_bIsScriptsAllowedInitialized;

    // id for the timer, only valid if we've been asked to time out
    static DWORD m_timerID;

    // toggled when we reach our timeout limit or max # scripts
    static bool m_bWeDeadNow;
};

#endif // _WMISCRIPT_CLASSFAC_HEADER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\smtpcons\smtp.cpp ===
#include "precomp.h"
#include <stdio.h>
#include <initguid.h>
#include "smtp.h"
#include <wbemutil.h>
#include <cominit.h>
#include <ArrTempl.h>

#define SMTP_PROPNAME_TO       L"ToLine"
#define SMTP_PROPNAME_CC       L"CcLine"
#define SMTP_PROPNAME_BCC      L"BccLine"
#define SMTP_PROPNAME_SUBJECT  L"Subject"
#define SMTP_PROPNAME_MESSAGE  L"Message"
#define SMTP_PROPNAME_SERVER   L"SMTPServer"
#define SMTP_PROPNAME_REPLYTO  L"ReplyToLine"
#define SMTP_PROPNAME_FROM     L"FromLine"
#define SMTP_PROPNAME_HEADERS  L"HeaderFields"

DWORD SMTPSend(char* szServer, char* szTo, char* szCc, char* szBcc, char* szFrom,  char* szReplyTo,
			   char* szSubject, char* szHeaders, char *szText);

CSMTPConsumer::CSMTPConsumer(CLifeControl* pControl, IUnknown* pOuter)
        : CUnk(pControl, pOuter), m_XProvider(this)
{
}

CSMTPConsumer::~CSMTPConsumer()
{
}

// copies gazinta inta gazotta, excluding white space
// no checking - better be good little pointers
void StripWhitespace(const WCHAR* pGazinta, WCHAR* pGazotta)
{
    WCHAR* pSource = (WCHAR*)pGazinta;
    WCHAR* pDest   = pGazotta;

    do 
        if (!iswspace(*pSource))
            *pDest++ = *pSource;    
    while (*pSource++);
}

HRESULT STDMETHODCALLTYPE CSMTPConsumer::XProvider::FindConsumer(
                    IWbemClassObject* pLogicalConsumer,
                    IWbemUnboundObjectSink** ppConsumer)
{
    CSMTPSink* pSink = new CSMTPSink(m_pObject->m_pControl);
    if (!pSink)
        return WBEM_E_OUT_OF_MEMORY;

    HRESULT hres = pSink->Initialize(pLogicalConsumer);
    if(FAILED(hres))
    {
        delete pSink;
        return hres;
    }
    return pSink->QueryInterface(IID_IWbemUnboundObjectSink, 
                                    (void**)ppConsumer);
}

void* CSMTPConsumer::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemEventConsumerProvider)
        return &m_XProvider;
    else
        return NULL;
}




CSMTPSink::CSMTPSink(CLifeControl* pControl)
    : CUnk(pControl), m_XSink(this), m_bSMTPInitialized(false), m_bFakeFromLine(false)
{
}

HRESULT CSMTPSink::Initialize(IWbemClassObject* pLogicalConsumer)
{
    HRESULT hres;

    WSADATA            WsaData; 
    int error = WSAStartup (0x101, &WsaData); 
    if (error)
    {
        ERRORTRACE((LOG_ESS, "Unable to initialize WinSock dll: %X\n", error));
        return WBEM_E_FAILED;
    }
    else
        m_bSMTPInitialized = true;

    // Retrieve information from the logical consumer instance
    // =======================================================

    VARIANT v;
    VariantInit(&v);

    // Get subject
    // ===========

    hres = pLogicalConsumer->Get(SMTP_PROPNAME_SUBJECT, 0, &v, NULL, NULL);
    if(V_VT(&v) == VT_BSTR)
        m_SubjectTemplate.SetTemplate(V_BSTR(&v));
    else
        m_SubjectTemplate.SetTemplate(L"");
    VariantClear(&v);

    // Get message
    // ===========

    hres = pLogicalConsumer->Get(SMTP_PROPNAME_MESSAGE, 0, &v, NULL, NULL);

    if(V_VT(&v) == VT_BSTR)
        m_MessageTemplate.SetTemplate(V_BSTR(&v));
    else
        m_MessageTemplate.SetTemplate(L"");
    VariantClear(&v);

    // flag for 'do we have any recipients at all?'
    bool bOneAddressee = false;

    // Get the To line
    // ===============
    hres = pLogicalConsumer->Get(SMTP_PROPNAME_TO, 0, &v, NULL, NULL);
    if(V_VT(&v) == VT_BSTR)
    {
		m_To.SetTemplate(V_BSTR(&v));
        if (wcslen(V_BSTR(&v)) > 0)
            bOneAddressee = true;
    }
    else
        m_To.SetTemplate(L"");
	VariantClear(&v);

    // Get the From line
    // =================
    hres = pLogicalConsumer->Get(SMTP_PROPNAME_FROM, 0, &v, NULL, NULL);
    if (SUCCEEDED(hres) && (V_VT(&v) == VT_BSTR))
		m_From.SetTemplate(V_BSTR(&v));
    else
    {
		VariantClear(&v);

        // Create From
        // ===========
            
        WString wsFrom;

        wsFrom = L"WinMgmt@";
        pLogicalConsumer->Get(L"__SERVER", 0, &v, NULL, NULL);
        wsFrom += V_BSTR(&v);

        m_From.SetTemplate(wsFrom);

        m_bFakeFromLine = true;
    }
    VariantClear(&v);

    // Get the ReplyTo line
    // =====================
    hres = pLogicalConsumer->Get(SMTP_PROPNAME_REPLYTO, 0, &v, NULL, NULL);
    if(V_VT(&v) == VT_BSTR)
		m_ReplyTo.SetTemplate(V_BSTR(&v));
    else
        m_ReplyTo.SetTemplate(L"");

    VariantClear(&v);

    // Get the CC line
    // ===============
    hres = pLogicalConsumer->Get(SMTP_PROPNAME_CC, 0, &v, NULL, NULL);
    if(V_VT(&v) == VT_BSTR)
    {
        m_Cc.SetTemplate( V_BSTR(&v));
        if (wcslen(V_BSTR(&v)) > 0)
            bOneAddressee = true;
    }
	else
		m_Cc.SetTemplate(L"");

    VariantClear(&v);

    // Get the BCC line
    // ===============

    hres = pLogicalConsumer->Get(SMTP_PROPNAME_BCC, 0, &v, NULL, NULL);
    if(V_VT(&v) == VT_BSTR)
    {
        m_Bcc.SetTemplate(V_BSTR(&v));
	    if (wcslen(V_BSTR(&v)) > 0)
            bOneAddressee = true;
    }
    else
		m_Bcc.SetTemplate(L"");
    VariantClear(&v);

    // okay, at least ONE should be filled in...
    if (!bOneAddressee)
    {
        ERRORTRACE((LOG_ESS, "SMTP: No addressees found, no mail delivered\n"));
        return WBEM_E_INVALID_PARAMETER;
    }

    // Get the server
    // ===============

    hres = pLogicalConsumer->Get(SMTP_PROPNAME_SERVER, 0, &v, NULL, NULL);
    if(V_VT(&v) == VT_BSTR)
        m_wsServer = V_BSTR(&v);
    VariantClear(&v);


    // and any extra header fields
    hres = pLogicalConsumer->Get(SMTP_PROPNAME_HEADERS, 0, &v, NULL, NULL);
    if ((V_VT(&v) & VT_BSTR) && (V_VT(&v) & VT_ARRAY))
    {
        long lBound;

        SafeArrayGetUBound(v.parray, 1, &lBound);
        for (long i = 0; i <= lBound; i++)
        {
            WCHAR* pStr;
            SafeArrayGetElement(v.parray, &i, &pStr);
            m_wsHeaders += pStr;
            if (i != lBound)
                m_wsHeaders += L"\r\n";
        }
    }
	VariantClear(&v);


    return WBEM_S_NO_ERROR;
}


CSMTPSink::~CSMTPSink()
{
    if (m_bSMTPInitialized)
	{		
		if (SOCKET_ERROR == WSACleanup())
			ERRORTRACE((LOG_ESS, "WSACleanup failed, 0x%X\n", WSAGetLastError()));
	}
}

// allocates buffer, strips whitespace if asked
// scrunches wide string down to MBCS
// callers responsibility to delete	return pointer
// returns NULL on allocation failure
// if bHammerSemiColons, the semi colons shall be replaced by commas
char* CSMTPSink::PreProcessLine(WCHAR* line, bool bStripWhitespace, bool bHammerSemiColons)
{
	char *pNewLine = NULL;
	WCHAR *pSource = NULL;
	WCHAR *pStripBuf = NULL;

	if (bStripWhitespace && (pStripBuf = new WCHAR[wcslen(line) +1]))
	{
		StripWhitespace(line, pStripBuf);
		pSource = pStripBuf;
	}
	else
		pSource = line;
							 
	if (pSource && (pNewLine = new char[2*wcslen(pSource) +1]))
	{
		sprintf(pNewLine, "%S", pSource);		
		if (bHammerSemiColons)
		{
			char* pSemiColon;
			while (pSemiColon = strchr(pNewLine, ';'))
				*pSemiColon = ',';
		}
	}

	if (pStripBuf)
		delete[] pStripBuf;


	return pNewLine;
}

HRESULT STDMETHODCALLTYPE CSMTPSink::XSink::IndicateToConsumer(
            IWbemClassObject* pLogicalConsumer, long lNumObjects, 
            IWbemClassObject** apObjects)
{
	// HRESULT hres;
    for(long i = 0; i < lNumObjects; i++)
    {

		// TODO: Lots of duplicated code, here - fix.
        // VARIANT v;

        BSTR str;

        // Obtain customized versions of the subject and the message
        // stripping white space as we go...
        // =========================================================

		// TO
		str = m_pObject->m_To.Apply(apObjects[i]);
		if (!str)
			return WBEM_E_OUT_OF_MEMORY;
	    char* szTo;
		szTo = m_pObject->PreProcessLine(str, true, true);
        SysFreeString(str);
		if (!szTo)
			return WBEM_E_OUT_OF_MEMORY;
		CDeleteMe<char> delTo(szTo);
        
		// CC
		char* szCc;
		str = m_pObject->m_Cc.Apply(apObjects[i]);        
		if (!str)
			return WBEM_E_OUT_OF_MEMORY;
		szCc = m_pObject->PreProcessLine(str, true, true);
		SysFreeString(str);
		if (!szCc)
			return WBEM_E_OUT_OF_MEMORY;	
		CDeleteMe<char> delCc(szCc);

		// BCC
		char* szBcc;
		str = m_pObject->m_Bcc.Apply(apObjects[i]);  
		if (!str)
			return WBEM_E_OUT_OF_MEMORY;
		szBcc = m_pObject->PreProcessLine(str, true, true);
        SysFreeString(str);
		if (!szBcc)
			return WBEM_E_OUT_OF_MEMORY;		
		CDeleteMe<char> delBcc(szBcc);

		// FROM
        char* szFrom;
        str = m_pObject->m_From.Apply(apObjects[i]);
		if (!str)
			return WBEM_E_OUT_OF_MEMORY;
		szFrom = m_pObject->PreProcessLine(str, false, false);
        SysFreeString(str);
		if (!szFrom)
			return WBEM_E_OUT_OF_MEMORY;
        CDeleteMe<char> delFrom(szFrom);

        // Reply To
        char* szReplyTo;
        str = m_pObject->m_ReplyTo.Apply(apObjects[i]);
		if (!str)
			return WBEM_E_OUT_OF_MEMORY;
		szReplyTo = m_pObject->PreProcessLine(str, true, true);
        SysFreeString(str);
		if (!szReplyTo)
			return WBEM_E_OUT_OF_MEMORY;
        CDeleteMe<char> delReplyTo(szReplyTo);
        
        // SERVER
		char* szServer;
        szServer = m_pObject->PreProcessLine(m_pObject->m_wsServer, false, false);
        if (!szServer)
			return WBEM_E_OUT_OF_MEMORY;
		CDeleteMe<char> delServer(szServer);

		// SUBJECT
        str = m_pObject->m_SubjectTemplate.Apply(apObjects[i]);
        char* szSubject;
		szSubject = m_pObject->PreProcessLine(str, false, false);
		SysFreeString(str);
        if (!szSubject)
			return WBEM_E_OUT_OF_MEMORY;
		CDeleteMe<char> delSubject(szSubject);

		// MESSAGE TEXT
        str = m_pObject->m_MessageTemplate.Apply(apObjects[i]);
        char* szText;
		szText = m_pObject->PreProcessLine(str, false, false);
        SysFreeString(str);
		if (!szText)
			return WBEM_E_OUT_OF_MEMORY;
		CDeleteMe<char> delText(szText);

        // extra added header entries
        char* szHeaders;
        szHeaders = m_pObject->PreProcessLine(m_pObject->m_wsHeaders, false, false);
        if (!szHeaders)
            return WBEM_E_OUT_OF_MEMORY;
        CDeleteMe<char> delHeaders(szHeaders);

		// djinn up a reply-to line
        // if we haven't been given one explicitly AND we haven't faked one up, 
        // we'll use the from line.
        char* szReplyToReally;
        if ((strlen(szReplyTo) == 0) && !m_pObject->m_bFakeFromLine)
            szReplyToReally = szFrom;
        else
            szReplyToReally = szReplyTo;

        // DO IT TO IT        
        DWORD dwRes = SMTPSend(szServer, szTo, szCc, szBcc, szFrom, szReplyToReally, szSubject, szHeaders, szText);
        if(dwRes)
        {
            ERRORTRACE((LOG_ESS, "Unable to send message: 0x%X\n", dwRes));
            return WBEM_E_FAILED;
        }
    }

    return WBEM_S_NO_ERROR;
}

void* CSMTPSink::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemUnboundObjectSink)
        return &m_XSink;
    else
        return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\wbemcons\cmdline.h ===
#ifndef __WBEM_CMDLINE_CONSUMER__H_
#define __WBEM_CMDLINE_CONSUMER__H_

#include <unk.h>

#include <wbemidl.h>

#include "txttempl.h"
#include <stdio.h>

class CCommandLineConsumer : public CUnk
{
protected:
    class XProvider : public CImpl<IWbemEventConsumerProvider, 
                                        CCommandLineConsumer>
    {
    public:
        XProvider(CCommandLineConsumer* pObj)
            : CImpl<IWbemEventConsumerProvider, CCommandLineConsumer>(pObj){}
    
        HRESULT STDMETHODCALLTYPE FindConsumer(
                    IWbemClassObject* pLogicalConsumer,
                    IWbemUnboundObjectSink** ppConsumer);
    } m_XProvider;
    friend XProvider;

public:
    CCommandLineConsumer(CLifeControl* pControl = NULL, IUnknown* pOuter = NULL)
        : CUnk(pControl, pOuter), m_XProvider(this)
    {}
    ~CCommandLineConsumer(){}
    void* GetInterface(REFIID riid);
};


class CCommandLineSink : public CUnk
{
protected:
    class XSink : public CImpl<IWbemUnboundObjectSink, CCommandLineSink>
    {
    public:
        XSink(CCommandLineSink* pObj) : 
            CImpl<IWbemUnboundObjectSink, CCommandLineSink>(pObj){}

        HRESULT STDMETHODCALLTYPE CreateProcessNT(WCHAR* wsCommandLine, WCHAR* wsTitle, PROCESS_INFORMATION& pi, FILETIME& now);

        HRESULT STDMETHODCALLTYPE CreateProcess9X(char* pCommandLine, char* pTitle, PROCESS_INFORMATION& pi, FILETIME& now);


        HRESULT STDMETHODCALLTYPE IndicateToConsumer(
            IWbemClassObject* pLogicalConsumer, long lNumObjects, 
            IWbemClassObject** apObjects);
    } m_XSink;
    friend XSink;

protected:
    WString m_wsExecutable;
    CTextTemplate m_CommandLine;
    CTextTemplate m_title;
    DWORD m_dwCreationFlags;
    WString m_wsWorkingDirectory;
    WString m_wsDesktop;
    // WString m_wsTitle;
    DWORD m_dwX;
    DWORD m_dwY;
    DWORD m_dwXSize;
    DWORD m_dwYSize;
    DWORD m_dwXNumCharacters;
    DWORD m_dwYNumCharacters;
    DWORD m_dwFillAttribute;
    DWORD m_dwStartFlags;
    DWORD m_dwShowWindow;
    BOOL  m_bInteractive;
    DWORD m_dwKillTimeout; // how long to wait before killing process, zero is infinite
    PSID  m_pSidCreator;   


    HRESULT FindInteractiveInfo();
public:
    WString m_wsWindowStation;

public:

    CCommandLineSink(CLifeControl* pControl = NULL) 
        : CUnk(pControl), m_XSink(this), m_pSidCreator(NULL)
    {}
    HRESULT Initialize(IWbemClassObject* pLogicalConsumer);

    ~CCommandLineSink()
    { delete m_pSidCreator; }

    void* GetInterface(REFIID riid);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\wbemcons\email.cpp ===
#include <windows.h>
#include <initguid.h>
#include "email.h"
#include <wbemutil.h>
#include <cominit.h>

#define EMAIL_PROPNAME_TO L"ToLine"
#define EMAIL_PROPNAME_CC L"CcLine"
#define EMAIL_PROPNAME_BCC L"BccLine"
#define EMAIL_PROPNAME_IMPORTANCE L"Importance"
#define EMAIL_PROPNAME_ISHTML L"IsHTML"
#define EMAIL_PROPNAME_SUBJECT L"Subject"
#define EMAIL_PROPNAME_MESSAGE L"Message"


CEmailConsumer::CEmailConsumer(CLifeControl* pControl, IUnknown* pOuter)
        : CUnk(pControl, pOuter), m_XProvider(this)
{
}

CEmailConsumer::~CEmailConsumer()
{
}

HRESULT STDMETHODCALLTYPE CEmailConsumer::XProvider::FindConsumer(
                    IWbemClassObject* pLogicalConsumer,
                    IWbemUnboundObjectSink** ppConsumer)
{
    CEmailSink* pSink = new CEmailSink(m_pObject->m_pControl);
    HRESULT hres = pSink->Initialize(pLogicalConsumer);
    if(FAILED(hres))
    {
        delete pSink;
        return hres;
    }
    return pSink->QueryInterface(IID_IWbemUnboundObjectSink, 
                                    (void**)ppConsumer);
}

void* CEmailConsumer::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemEventConsumerProvider)
        return &m_XProvider;
    else
        return NULL;
}




CEmailSink::CEmailSink(CLifeControl* pControl)
    : CUnk(pControl), m_XSink(this), m_pNewMail(NULL)
{
}

HRESULT CEmailSink::Initialize(IWbemClassObject* pLogicalConsumer)
{
    HRESULT hres;

    // Retrieve information from the logical consumer instance
    // =======================================================

    VARIANT v;
    VariantInit(&v);

    // Get subject
    // ===========

    hres = pLogicalConsumer->Get(EMAIL_PROPNAME_SUBJECT, 0, &v, NULL, NULL);
    if(V_VT(&v) == VT_BSTR)
        m_SubjectTemplate.SetTemplate(V_BSTR(&v));
    else
        m_SubjectTemplate.SetTemplate(L"");
    VariantClear(&v);

    // Get message
    // ===========

    hres = pLogicalConsumer->Get(EMAIL_PROPNAME_MESSAGE, 0, &v, NULL, NULL);

    if(V_VT(&v) == VT_BSTR)
        m_MessageTemplate.SetTemplate(V_BSTR(&v));
    else
        m_MessageTemplate.SetTemplate(L"");
    VariantClear(&v);

    // Get the To line
    // ===============

    hres = pLogicalConsumer->Get(EMAIL_PROPNAME_TO, 0, &v, NULL, NULL);
    if(V_VT(&v) != VT_BSTR)
        return WBEM_E_INVALID_PARAMETER;

    m_wsTo= V_BSTR(&v);
    VariantClear(&v);

    // Get the CC line
    // ===============

    hres = pLogicalConsumer->Get(EMAIL_PROPNAME_CC, 0, &v, NULL, NULL);
    if(V_VT(&v) == VT_BSTR)
        m_wsCc = V_BSTR(&v);
    VariantClear(&v);

    // Get the BCC line
    // ===============

    hres = pLogicalConsumer->Get(EMAIL_PROPNAME_BCC, 0, &v, NULL, NULL);
    if(V_VT(&v) == VT_BSTR)
        m_wsBcc = V_BSTR(&v);
    VariantClear(&v);

    // Get HTML designation
    // ====================

    hres = pLogicalConsumer->Get(EMAIL_PROPNAME_ISHTML, 0, &v, NULL, NULL);
    if(V_VT(&v) != VT_BOOL || V_BOOL(&v) == VARIANT_FALSE)
        m_bIsHTML = FALSE;
    else
        m_bIsHTML = TRUE;
    VariantClear(&v);

    // Get importance
    // ==============

    hres = pLogicalConsumer->Get(EMAIL_PROPNAME_IMPORTANCE, 0, &v, NULL, NULL);
    if(V_VT(&v) != VT_I4)
        m_lImportance = 1;
    else
        m_lImportance = V_I4(&v);
    VariantClear(&v);

    // Create From
    // ===========

    m_wsFrom = L"WinMgmt@";
    pLogicalConsumer->Get(L"__SERVER", 0, &v, NULL, NULL);
    m_wsFrom += V_BSTR(&v);
    VariantClear(&v);

    return WBEM_S_NO_ERROR;
}


CEmailSink::~CEmailSink()
{
}


HRESULT STDMETHODCALLTYPE CEmailSink::XSink::IndicateToConsumer(
            IWbemClassObject* pLogicalConsumer, long lNumObjects, 
            IWbemClassObject** apObjects)
{
    HRESULT hres;
    for(long i = 0; i < lNumObjects; i++)
    {
        VARIANT v;

        // Obtain customized versions of the subject and the message
        // =========================================================

        INewMail* pNewMail;
        hres = CoCreateInstance(CLSID_NewMail, NULL, CLSCTX_INPROC_SERVER,
                IID_INewMail, (void**)&pNewMail);
        if(FAILED(hres))
            return hres;

        BSTR str;

        str = SysAllocString(m_pObject->m_wsTo);
        pNewMail->put_To(str);
        SysFreeString(str);

        str = SysAllocString(m_pObject->m_wsCc);
        pNewMail->put_Cc(str);
        SysFreeString(str);

        str = SysAllocString(m_pObject->m_wsBcc);
        pNewMail->put_Bcc(str);
        SysFreeString(str);

        str = SysAllocString(m_pObject->m_wsFrom);
        pNewMail->put_From(str);
        SysFreeString(str);

        str = m_pObject->m_SubjectTemplate.Apply(apObjects[0]);
        pNewMail->put_Subject(str);
        SysFreeString(str);

        pNewMail->put_Importance(m_pObject->m_lImportance);
        pNewMail->put_BodyFormat(m_pObject->m_bIsHTML ? 
                                    CdoBodyFormatHTML : CdoBodyFormatText);


        V_VT(&v) = VT_BSTR;
        V_BSTR(&v) = m_pObject->m_MessageTemplate.Apply(apObjects[0]);
        pNewMail->put_Body(v);
        VariantClear(&v);

        V_VT(&v) = VT_ERROR;

        hres = pNewMail->Send(v, v, v, v, v);
        pNewMail->Release();

        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Unable to send message: 0x%X\n", hres));
            return hres;
        }
    }

    return WBEM_S_NO_ERROR;
}

void* CEmailSink::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemUnboundObjectSink)
        return &m_XSink;
    else
        return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\wbemcons\cmdline.cpp ===
#include "precomp.h"
#include "cmdline.h"
#include <stdio.h>
#include <wbemutil.h>
#include <GroupsForUser.h>
#include "ProcKiller.h"
#include <GenUtils.h>
#include <ArrTempl.h>
#include <sddl.h>
#include <Wtsapi32.h>
#include <winntsec.h>
  

#include <malloc.h>

#define CMDLINE_PROPNAME_EXECUTABLE L"ExecutablePath"
#define CMDLINE_PROPNAME_COMMANDLINE L"CommandLineTemplate"
#define CMDLINE_PROPNAME_USEDEFAULTERRORMODE L"UseDefaultErrorMode"
#define CMDLINE_PROPNAME_CREATENEWCONSOLE L"CreateNewConsole"
#define CMDLINE_PROPNAME_CREATENEWPROCESSGROUP L"CreateNewProcessGroup"
#define CMDLINE_PROPNAME_CREATESEPARATEWOWVDM L"CreateSeparateWowVdm"
#define CMDLINE_PROPNAME_CREATESHAREDWOWVDM L"CreateSharedWowVdm"
#define CMDLINE_PROPNAME_PRIORITY L"Priority"
#define CMDLINE_PROPNAME_WORKINGDIRECTORY L"WorkingDirectory"
#define CMDLINE_PROPNAME_DESKTOP L"DesktopName"
#define CMDLINE_PROPNAME_TITLE L"WindowTitle"
#define CMDLINE_PROPNAME_X L"XCoordinate"
#define CMDLINE_PROPNAME_Y L"YCoordinate"
#define CMDLINE_PROPNAME_XSIZE L"XSize"
#define CMDLINE_PROPNAME_YSIZE L"YSize"
#define CMDLINE_PROPNAME_XCOUNTCHARS L"XNumCharacters"
#define CMDLINE_PROPNAME_YCOUNTCHARS L"YNumCharacters"
#define CMDLINE_PROPNAME_FILLATTRIBUTE L"FillAttribute"
#define CMDLINE_PROPNAME_SHOWWINDOW L"ShowWindowCommand"
#define CMDLINE_PROPNAME_FORCEON L"ForceOnFeedback"
#define CMDLINE_PROPNAME_FORCEOFF L"ForceOffFeedback"
#define CMDLINE_PROPNAME_INTERACTIVE L"RunInteractively"
#define CMDLINE_PROPNAME_KILLTIMEOUT L"KillTimeout"
#define CMDLINE_PROPNAME_CREATORSID L"CreatorSid"

HRESULT STDMETHODCALLTYPE CCommandLineConsumer::XProvider::FindConsumer(
                    IWbemClassObject* pLogicalConsumer,
                    IWbemUnboundObjectSink** ppConsumer)
{
    CCommandLineSink* pSink = new CCommandLineSink(m_pObject->m_pControl);

	if (!pSink)
		return WBEM_E_OUT_OF_MEMORY;
    
	HRESULT hres = pSink->Initialize(pLogicalConsumer);
    if(FAILED(hres))
    {
        delete pSink;
        *ppConsumer = NULL;
        return hres;
    }
    else return pSink->QueryInterface(IID_IWbemUnboundObjectSink, 
                                        (void**)ppConsumer);
}


void* CCommandLineConsumer::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemEventConsumerProvider)
        return &m_XProvider;
    else return NULL;
}

HRESULT CCommandLineSink::Initialize(IWbemClassObject* pLogicalConsumer)
{
    // Get the information
    // ===================

    HRESULT hres;
    VARIANT v;
    VariantInit(&v);

    // only one of the pair Executable & commandLine may be null
    // this var counts...
    int nNulls = 0;

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_EXECUTABLE, 0, &v, 
            NULL, NULL);
    if(FAILED(hres) || V_VT(&v) != VT_BSTR)
    {
        m_wsExecutable = L"";
        nNulls++;
    }
    else
        m_wsExecutable = V_BSTR(&v);
    VariantClear(&v);

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_COMMANDLINE, 0, &v, 
            NULL, NULL);
    if(FAILED(hres) || V_VT(&v) != VT_BSTR)
    {
        m_CommandLine.SetTemplate(L"");
        nNulls++;
    }
    else
        m_CommandLine.SetTemplate(V_BSTR(&v));
    VariantClear(&v);

    if (nNulls > 1)
        return WBEM_E_INVALID_PARAMETER;

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_WORKINGDIRECTORY, 0, &v, 
            NULL, NULL);
    if(SUCCEEDED(hres) && V_VT(&v) == VT_BSTR)
        m_wsWorkingDirectory  = V_BSTR(&v);
    VariantClear(&v);

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_DESKTOP, 0, &v, 
            NULL, NULL);
    if(SUCCEEDED(hres) && V_VT(&v) == VT_BSTR)
        m_wsDesktop  = V_BSTR(&v);
    VariantClear(&v);

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_TITLE, 0, &v, 
            NULL, NULL);
    if(FAILED(hres) || V_VT(&v) != VT_BSTR)
        m_title.SetTemplate(L"");
    else
        m_title.SetTemplate(V_BSTR(&v));
    VariantClear(&v);

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_INTERACTIVE, 0, &v, 
            NULL, NULL);
    if(V_VT(&v) == VT_BOOL && V_BOOL(&v) != VARIANT_FALSE)
        m_bInteractive = TRUE;
    else
        m_bInteractive = FALSE;

    m_dwCreationFlags = 0;
    
    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_USEDEFAULTERRORMODE, 0, &v, 
            NULL, NULL);
    if(V_VT(&v) == VT_BOOL && V_BOOL(&v) != VARIANT_FALSE)
        m_dwCreationFlags |= CREATE_DEFAULT_ERROR_MODE;

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_CREATENEWCONSOLE, 0, &v, 
            NULL, NULL);
    if(V_VT(&v) == VT_BOOL && V_BOOL(&v) != VARIANT_FALSE)
        m_dwCreationFlags |= CREATE_NEW_CONSOLE;

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_CREATENEWPROCESSGROUP, 0, &v, 
            NULL, NULL);
    if(V_VT(&v) == VT_BOOL && V_BOOL(&v) != VARIANT_FALSE)
        m_dwCreationFlags |= CREATE_NEW_PROCESS_GROUP;

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_CREATESEPARATEWOWVDM, 0, &v, 
            NULL, NULL);
    if(V_VT(&v) == VT_BOOL && V_BOOL(&v) != VARIANT_FALSE)
        m_dwCreationFlags |= CREATE_SEPARATE_WOW_VDM;

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_CREATESHAREDWOWVDM, 0, &v, 
            NULL, NULL);
    if(V_VT(&v) == VT_BOOL && V_BOOL(&v) != VARIANT_FALSE)
        m_dwCreationFlags |= CREATE_SHARED_WOW_VDM;

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_PRIORITY, 0, &v, 
            NULL, NULL);
    if(V_VT(&v) == VT_I4)
    {
        if(V_I4(&v) == HIGH_PRIORITY_CLASS || 
            V_I4(&v) == IDLE_PRIORITY_CLASS || 
            V_I4(&v) == NORMAL_PRIORITY_CLASS || 
            V_I4(&v) == REALTIME_PRIORITY_CLASS)
        {
            m_dwCreationFlags |= V_I4(&v);
        }
        else
            return WBEM_E_INVALID_PARAMETER;
    }

    m_dwStartFlags = 0;

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_X, 0, &v, 
            NULL, NULL);
    if(V_VT(&v) == VT_I4)
    {
        m_dwX = V_I4(&v);
        m_dwStartFlags |= STARTF_USEPOSITION;
    }

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_Y, 0, &v, 
            NULL, NULL);
    if(V_VT(&v) == VT_I4)
    {
        m_dwY = V_I4(&v);
        m_dwStartFlags |= STARTF_USEPOSITION;
    }

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_XSIZE, 0, &v, 
            NULL, NULL);
    if(V_VT(&v) == VT_I4)
    {
        m_dwXSize = V_I4(&v);
        m_dwStartFlags |= STARTF_USESIZE;
    }

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_YSIZE, 0, &v, 
            NULL, NULL);
    if(V_VT(&v) == VT_I4)
    {
        m_dwYSize = V_I4(&v);
        m_dwStartFlags |= STARTF_USESIZE;
    }

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_XCOUNTCHARS, 0, &v, 
            NULL, NULL);
    if(V_VT(&v) == VT_I4)
    {
        m_dwXNumCharacters = V_I4(&v);
        m_dwStartFlags |= STARTF_USECOUNTCHARS;
    }

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_YCOUNTCHARS, 0, &v, 
            NULL, NULL);
    if(V_VT(&v) == VT_I4)
    {
        m_dwYNumCharacters = V_I4(&v);
        m_dwStartFlags |= STARTF_USECOUNTCHARS;
    }

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_FILLATTRIBUTE, 0, &v, 
            NULL, NULL);
    if(V_VT(&v) == VT_I4)
    {
        m_dwFillAttribute = V_I4(&v);
        m_dwStartFlags |= STARTF_USEFILLATTRIBUTE;
    }

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_SHOWWINDOW, 0, &v, 
            NULL, NULL);
    if(V_VT(&v) == VT_I4)
    {
        m_dwShowWindow = V_I4(&v);
        m_dwStartFlags |= STARTF_USESHOWWINDOW;
    }

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_FORCEON, 0, &v, 
            NULL, NULL);
    if(V_VT(&v) == VT_BOOL && V_BOOL(&v) != VARIANT_FALSE)
        m_dwStartFlags |= STARTF_FORCEONFEEDBACK;

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_FORCEOFF, 0, &v, 
            NULL, NULL);
    if(V_VT(&v) == VT_BOOL && V_BOOL(&v) != VARIANT_FALSE)
        m_dwStartFlags |= STARTF_FORCEOFFFEEDBACK;

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_KILLTIMEOUT, 0, &v,
            NULL, NULL);
    if(V_VT(&v) == VT_I4)
        m_dwKillTimeout = V_I4(&v);
    else
        m_dwKillTimeout = 0;

    VariantClear(&v);

    hres = pLogicalConsumer->Get(CMDLINE_PROPNAME_CREATORSID, 0, &v,
            NULL, NULL);
    if (SUCCEEDED(hres))
    {
        HRESULT hDebug;
        
        long ubound;
        hDebug = SafeArrayGetUBound(V_ARRAY(&v), 1, &ubound);

        PVOID pVoid;
        hDebug = SafeArrayAccessData(V_ARRAY(&v), &pVoid);

        m_pSidCreator = new BYTE[ubound +1];
        if (m_pSidCreator)
            memcpy(m_pSidCreator, pVoid, ubound + 1);
        else
            return WBEM_E_OUT_OF_MEMORY;

        SafeArrayUnaccessData(V_ARRAY(&v));
    }
    else
    {
        ERRORTRACE((LOG_ESS, "Command Line Consumer could not retrieve creator sid (0x%08X)\n",hres));
        return hres;
    }
    
    return hres;
}

BOOL IsInteractive(HWINSTA hWinsta)
{
    USEROBJECTFLAGS uof;
    DWORD dwLen;
    BOOL bRes = GetUserObjectInformation(hWinsta, UOI_FLAGS, 
        (void*)&uof, sizeof(uof), &dwLen);
    if(!bRes)
        return FALSE;
    return ((uof.dwFlags & WSF_VISIBLE) != 0);
}
BOOL WinstaEnumProc(LPTSTR szWindowStation, LPARAM lParam)
{
    WString* pws = (WString*)lParam;

    HWINSTA hWinsta = OpenWindowStation(szWindowStation, FALSE, 
        WINSTA_ENUMERATE | WINSTA_ENUMDESKTOPS | WINSTA_READATTRIBUTES);
    if(hWinsta == NULL)
        return TRUE;

    if(IsInteractive(hWinsta))
    {
        *pws = szWindowStation;
    }
    CloseWindowStation(hWinsta);

    return TRUE;
}
            
    
BOOL GetInteractiveWinstation(WString& wsName)
{
    wsName.Empty();

    BOOL bRes = EnumWindowStations(WinstaEnumProc, 
        (LPARAM)&wsName);
    return bRes;
}


HRESULT CCommandLineSink::FindInteractiveInfo()
{
    BOOL bRes = GetInteractiveWinstation(m_wsWindowStation);
    if(!bRes)
	{
        return WBEM_E_FAILED;
	}
    if(m_wsWindowStation.Length() == 0)
        return WBEM_E_NOT_FOUND;

    return WBEM_S_NO_ERROR;
}

HRESULT GetSidUse(PSID pSid, SID_NAME_USE& use)
{
    DWORD  dwNameLen = 0;
    DWORD  dwDomainLen = 0;
    LPWSTR pUser = 0;
    LPWSTR pDomain = 0;
    use = SidTypeInvalid;

    // Do the first lookup to get the buffer sizes required.
    // =====================================================

    BOOL bRes = LookupAccountSidW(
        NULL,
        pSid,
        pUser,
        &dwNameLen,
        pDomain,
        &dwDomainLen,
        &use
        );

    DWORD dwLastErr = GetLastError();

    if (dwLastErr != ERROR_INSUFFICIENT_BUFFER)
    {
        return WBEM_E_FAILED;
    }

    // Allocate the required buffers and look them up again.
    // =====================================================

    pUser = new wchar_t[dwNameLen + 1];
    if (!pUser)
        return WBEM_E_OUT_OF_MEMORY;

    pDomain = new wchar_t[dwDomainLen + 1];
    if (!pDomain)
    {
        delete pUser;
        return WBEM_E_OUT_OF_MEMORY;
    }

    bRes = LookupAccountSidW(
        NULL,
        pSid,
        pUser,
        &dwNameLen,
        pDomain,
        &dwDomainLen,
        &use
        );
     
    delete [] pUser;
    delete [] pDomain;

    if (bRes)
        return WBEM_S_NO_ERROR;
    else
        return WBEM_E_FAILED;
}


bool GetLoggedOnUserViaTS(
    CNtSid& sidLoggedOnUser)
{
    bool fRet = false;
    bool fCont = true;
    PWTS_SESSION_INFO psesinfo = NULL;
    DWORD dwSessions = 0;
    LPWSTR wstrUserName = NULL;
    LPWSTR wstrDomainName = NULL;
    LPWSTR wstrWinstaName = NULL;
    DWORD dwSize = 0L;
 
    try
    {
        if(!(::WTSEnumerateSessions(
           WTS_CURRENT_SERVER_HANDLE,
           0,
           1,
           &psesinfo,
           &dwSessions) && psesinfo))
        {
            fCont = false;
        }
 
        if(fCont)
        {
            for(int j = 0; j < dwSessions && !fRet; j++, fCont = true)
            {
                if(psesinfo[j].State != WTSActive)
                {
                    fCont = false;
                }
 
                if(fCont)
                {
                    if(!(::WTSQuerySessionInformation(
                        WTS_CURRENT_SERVER_HANDLE,
                        psesinfo[j].SessionId,
                        WTSUserName,
                        &wstrUserName,
                        &dwSize) && wstrUserName))
                    {
                        fCont = false;
                    }
                }
                
                if(fCont)
                {
                    if(!(::WTSQuerySessionInformation(
                        WTS_CURRENT_SERVER_HANDLE,
                        psesinfo[j].SessionId,
                        WTSDomainName,
                        &wstrDomainName,
                        &dwSize) && wstrDomainName))
                    {
                        fCont = false;
                    }
                }
                    
                if(fCont)
                {            
                    if(!(::WTSQuerySessionInformation(
                        WTS_CURRENT_SERVER_HANDLE,
                        psesinfo[j].SessionId,
                        WTSWinStationName,
                        &wstrWinstaName,
                        &dwSize) && wstrWinstaName))   
                    {
                        fCont = false;
                    }
                }
 
                if(fCont)
                {
                    if(_wcsicmp(wstrWinstaName, L"Console") != 0)
                    {
                        fCont = false;
                    }
                }
 
                if(fCont)
                {
                    // That establishes that this user
                    // is associated with the interactive
                    // desktop.
                    CNtSid sidInteractive(wstrUserName, wstrDomainName);
    
                    if(sidInteractive.GetStatus() == CNtSid::NoError)
                    {
                        sidLoggedOnUser = sidInteractive;
                        fRet = true;
                    }
                }
 
                if(wstrUserName)
                {
                    WTSFreeMemory(wstrUserName);
     wstrUserName = NULL;
                }
                if(wstrDomainName)
                {
                    WTSFreeMemory(wstrDomainName);
     wstrDomainName = NULL;
                }
                if(wstrWinstaName)
                {
                    WTSFreeMemory(wstrWinstaName);
     wstrWinstaName = NULL;
                }
            }
            if (psesinfo)
                WTSFreeMemory(psesinfo);
        }
    }
    catch(...)
    {
        if(wstrUserName)
        {
            WTSFreeMemory(wstrUserName);
   wstrUserName = NULL;
        }
        if(wstrDomainName)
        {
            WTSFreeMemory(wstrDomainName);
   wstrDomainName = NULL;
        }
        if(wstrWinstaName)
        {
            WTSFreeMemory(wstrWinstaName);
                 wstrWinstaName = NULL;
        }

        if (psesinfo)
             WTSFreeMemory(psesinfo);

        fRet = false;
    }
 
    return fRet;
}


HRESULT STDMETHODCALLTYPE CCommandLineSink::XSink::CreateProcessNT(WCHAR* pCommandLine, WCHAR* pTitle, PROCESS_INFORMATION& pi, FILETIME& now)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    WCHAR*  pDesktop = NULL;
    
    WString wsDesktop;               
    
    if(m_pObject->m_bInteractive)
    {
        if(FAILED(m_pObject->FindInteractiveInfo()))
        {
            ERRORTRACE((LOG_ESS, "No interactive window station found!\n"));
            return WBEM_E_FAILED;
        }
        wsDesktop = m_pObject->m_wsWindowStation;
        wsDesktop += L"\\Default";
        pDesktop = (wchar_t*)wsDesktop;
        
        CNtSid user;

        if (!GetLoggedOnUserViaTS(user))
        {
            ERRORTRACE((LOG_ESS, "Could not determine logged on user\n"));
            return WBEM_E_FAILED;
        }


        SID_NAME_USE use;
        if (FAILED(hr =GetSidUse(m_pObject->m_pSidCreator, use)))
            return hr;

        if (use == SidTypeUser)
        {
            if (!EqualSid(m_pObject->m_pSidCreator, user.GetPtr()))
            {
                ERRORTRACE((LOG_ESS, "Command line event consumer will only run interactively\non a workstation that the creator is logged into.\n"));
                return WBEM_E_ACCESS_DENIED;
            }
            // else we're fine continue.
            DEBUGTRACE((LOG_ESS, "User and creator are one in the same\n"));
        }
        else 
        {
            if (0 != IsUserInGroup(user.GetPtr(), m_pObject->m_pSidCreator))
            {
                ERRORTRACE((LOG_ESS, "Command line event consumer will only run interactively\non a workstation that the creator is logged into.\n"));
                return WBEM_E_ACCESS_DENIED;
            }
            else
            {
                DEBUGTRACE((LOG_ESS, "User is in the group!\n"));
            }
        }
    }

 

    WCHAR* szApplicationName =  (m_pObject->m_wsExecutable.Length() == 0) ? NULL : ((wchar_t*)m_pObject->m_wsExecutable);
    WCHAR* szWorkingDirectory = (m_pObject->m_wsWorkingDirectory.Length() == 0) ? NULL : ((wchar_t*)m_pObject->m_wsWorkingDirectory);

    struct _STARTUPINFOW si;
    si.cb = sizeof(si);
    si.lpReserved = NULL;
    si.cbReserved2 = 0;
    si.lpReserved2 = NULL;
    si.lpDesktop = pDesktop;
    si.lpTitle = pTitle;
    si.dwX = m_pObject->m_dwX;
    si.dwY = m_pObject->m_dwY;
    si.dwXSize = m_pObject->m_dwXSize;
    si.dwYSize = m_pObject->m_dwYSize;
    si.dwXCountChars = m_pObject->m_dwXNumCharacters;
    si.dwYCountChars = m_pObject->m_dwYNumCharacters;
    si.dwFillAttribute = m_pObject->m_dwFillAttribute;
    si.dwFlags = m_pObject->m_dwStartFlags;
    si.wShowWindow = (WORD)m_pObject->m_dwShowWindow;

#ifdef HHANCE_DEBUG_CODE
	DEBUGTRACE((LOG_ESS, "Calling Create process\n"));
#endif
    
    BOOL bRes = CreateProcessW(szApplicationName, pCommandLine,
        NULL, NULL, FALSE, m_pObject->m_dwCreationFlags,
        NULL, szWorkingDirectory, &si, &pi);

	if (!bRes)
		ERRORTRACE((LOG_ESS, "CreateProcess failed, 0x%08X\n", GetLastError()));
#ifdef HHANCE_DEBUG_CODE
	else
		DEBUGTRACE((LOG_ESS, "Create Process succeeded\n"));
#endif


    // get current time for shutdown info
    GetSystemTimeAsFileTime(&now);        

    if (!bRes)
        hr = WBEM_E_FAILED;

    return hr;
}

HRESULT STDMETHODCALLTYPE CCommandLineSink::XSink::CreateProcess9X(char* szCommandLine, char* szTitle, PROCESS_INFORMATION& pi, FILETIME& now)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    LPSTR szDesktop = 
        ((m_pObject->m_wsDesktop.Length() == 0) ? 
            NULL : m_pObject->m_wsDesktop.GetLPSTR());


    if(szDesktop == NULL && m_pObject->m_bInteractive)
    {
        if(FAILED(m_pObject->FindInteractiveInfo()))
        {
            ERRORTRACE((LOG_ESS, "No interactive window station found!\n"));
            return WBEM_E_FAILED;
        }
        WString wsDesktop = m_pObject->m_wsWindowStation;
        wsDesktop += L"\\Default";

        szDesktop = wsDesktop.GetLPSTR();

    }

    LPSTR szApplicationName = 

        ((m_pObject->m_wsExecutable.Length() == 0) ? 
            NULL : m_pObject->m_wsExecutable.GetLPSTR());



    LPSTR szWorkingDirectory;


    if (m_pObject->m_wsWorkingDirectory.Length() == 0)
        szWorkingDirectory = NULL;
    else
        szWorkingDirectory = m_pObject->m_wsWorkingDirectory.GetLPSTR();


    STARTUPINFOA si;
    si.cb = sizeof(si);
    si.lpReserved = NULL;
    si.cbReserved2 = 0;
    si.lpReserved2 = NULL;
    si.lpDesktop = szDesktop;
    si.lpTitle = szTitle;
    si.dwX = m_pObject->m_dwX;
    si.dwY = m_pObject->m_dwY;
    si.dwXSize = m_pObject->m_dwXSize;
    si.dwYSize = m_pObject->m_dwYSize;
    si.dwXCountChars = m_pObject->m_dwXNumCharacters;
    si.dwYCountChars = m_pObject->m_dwYNumCharacters;
    si.dwFillAttribute = m_pObject->m_dwFillAttribute;
    si.dwFlags = m_pObject->m_dwStartFlags;
    si.wShowWindow = (WORD)m_pObject->m_dwShowWindow;

    
    BOOL bRes = CreateProcessA(szApplicationName, szCommandLine,
        NULL, NULL, FALSE, m_pObject->m_dwCreationFlags,
        NULL, szWorkingDirectory, &si, &pi);

    // get current time for shutdown info
    GetSystemTimeAsFileTime(&now);        

    if (!bRes)
        hr = WBEM_E_FAILED;

    delete [] szApplicationName;
    delete [] szDesktop;
    delete [] szWorkingDirectory;

    return hr;
}



HRESULT STDMETHODCALLTYPE CCommandLineSink::XSink::IndicateToConsumer(
            IWbemClassObject* pLogicalConsumer, long lNumObjects, 
            IWbemClassObject** apObjects)
{
    HRESULT hr = S_OK;

    if (IsNT())
    {
        PSID pSidSystem;
        SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;
 
        if  (AllocateAndInitializeSid(&id, 1,
            SECURITY_LOCAL_SYSTEM_RID, 
            0, 0,0,0,0,0,0,&pSidSystem))
        {         
            // guilty until proven innocent
            hr = WBEM_E_ACCESS_DENIED;

            // check to see if sid is either Local System or an admin of some sort...
            if ((EqualSid(pSidSystem, m_pObject->m_pSidCreator)) ||
                (S_OK == IsUserAdministrator(m_pObject->m_pSidCreator)))
                hr = WBEM_S_NO_ERROR;
          
            // We're done with this
            FreeSid(pSidSystem);

            if (FAILED(hr))
            {
                if (hr == WBEM_E_ACCESS_DENIED)
                    ERRORTRACE((LOG_ESS, "Command line event consumer may only be used by an administrator\n"));
                return hr;
            }
        }
        else
            return WBEM_E_OUT_OF_MEMORY;
    }
    
    for(int i = 0; i < lNumObjects; i++)
    {
        BSTR strCommandLine = m_pObject->m_CommandLine.Apply(apObjects[i]);
        if(strCommandLine == NULL)
        {
            ERRORTRACE((LOG_ESS, "Invalid command line!\n"));
            return WBEM_E_INVALID_PARAMETER;
        }

        WString wsCommandLine = strCommandLine;
        SysFreeString(strCommandLine);

        BSTR bstrTitle = m_pObject->m_title.Apply(apObjects[i]);
        WString wsTitle = bstrTitle;        
        if (bstrTitle)
            SysFreeString(bstrTitle);

        FILETIME now;
        PROCESS_INFORMATION pi; 

        if (IsNT())
        {
            WCHAR* pCommandLine = ((wsCommandLine.Length() == 0) ? NULL : (wchar_t *)wsCommandLine);;
            WCHAR* pTitle =       ((wsTitle.Length() == 0) ? NULL : (wchar_t *)wsTitle);           
            
            hr = CreateProcessNT(pCommandLine, pTitle, pi, now);
        }
        else
        {    
            char*  pCommandLine = ((wsCommandLine.Length() == 0) ? NULL : wsCommandLine.GetLPSTR());
            char*  pTitle =       ((wsTitle.Length() == 0) ? NULL : wsTitle.GetLPSTR());
;
            hr = CreateProcess9X(pCommandLine, pTitle, pi, now);

            delete pTitle;
            delete pCommandLine;
        }

        if (FAILED(hr))
        {
            ERRORTRACE((LOG_ESS, "Failed to CreateProcess %S. Error 0x%X\n", (LPCWSTR)wsCommandLine, hr));
            return hr;                 
        }
        else
        {
            if (m_pObject->m_dwKillTimeout)
            {

                WAYCOOL_FILETIME then(now);
                then.AddSeconds(m_pObject->m_dwKillTimeout);                

                hr = g_procKillerTimer.ScheduleAssassination(pi.hProcess, (FILETIME)then);

				if (FAILED(hr))
					DEBUGTRACE((LOG_ESS, "Could not schedule process termination\n"));
            }

            CloseHandle(pi.hProcess);
            CloseHandle(pi.hThread);
        }
    }
    return hr;
}
    

    

void* CCommandLineSink::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemUnboundObjectSink)
        return &m_XSink;
    else return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\wbemcons\cdonts.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Sun Nov 02 08:48:51 1997
 */
/* Compiler settings for P:\stacks\src\mail\actmsg\actmsg.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __cdonts_h__
#define __cdonts_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __INewMail_FWD_DEFINED__
#define __INewMail_FWD_DEFINED__
typedef interface INewMail INewMail;
#endif 	/* __INewMail_FWD_DEFINED__ */


#ifndef __ISession_FWD_DEFINED__
#define __ISession_FWD_DEFINED__
typedef interface ISession ISession;
#endif 	/* __ISession_FWD_DEFINED__ */


#ifndef __Folder_FWD_DEFINED__
#define __Folder_FWD_DEFINED__
typedef interface Folder Folder;
#endif 	/* __Folder_FWD_DEFINED__ */


#ifndef __Messages_FWD_DEFINED__
#define __Messages_FWD_DEFINED__
typedef interface Messages Messages;
#endif 	/* __Messages_FWD_DEFINED__ */


#ifndef __Message_FWD_DEFINED__
#define __Message_FWD_DEFINED__
typedef interface Message Message;
#endif 	/* __Message_FWD_DEFINED__ */


#ifndef __Recipients_FWD_DEFINED__
#define __Recipients_FWD_DEFINED__
typedef interface Recipients Recipients;
#endif 	/* __Recipients_FWD_DEFINED__ */


#ifndef __Recipient_FWD_DEFINED__
#define __Recipient_FWD_DEFINED__
typedef interface Recipient Recipient;
#endif 	/* __Recipient_FWD_DEFINED__ */


#ifndef __Attachments_FWD_DEFINED__
#define __Attachments_FWD_DEFINED__
typedef interface Attachments Attachments;
#endif 	/* __Attachments_FWD_DEFINED__ */


#ifndef __Attachment_FWD_DEFINED__
#define __Attachment_FWD_DEFINED__
typedef interface Attachment Attachment;
#endif 	/* __Attachment_FWD_DEFINED__ */


#ifndef __AddressEntry_FWD_DEFINED__
#define __AddressEntry_FWD_DEFINED__
typedef interface AddressEntry AddressEntry;
#endif 	/* __AddressEntry_FWD_DEFINED__ */


#ifndef __NewMail_FWD_DEFINED__
#define __NewMail_FWD_DEFINED__

#ifdef __cplusplus
typedef class NewMail NewMail;
#else
typedef struct NewMail NewMail;
#endif /* __cplusplus */

#endif 	/* __NewMail_FWD_DEFINED__ */


#ifndef __Session_FWD_DEFINED__
#define __Session_FWD_DEFINED__

#ifdef __cplusplus
typedef class Session Session;
#else
typedef struct Session Session;
#endif /* __cplusplus */

#endif 	/* __Session_FWD_DEFINED__ */


#ifndef __AddressEntry_FWD_DEFINED__
#define __AddressEntry_FWD_DEFINED__
typedef interface AddressEntry AddressEntry;
#endif 	/* __AddressEntry_FWD_DEFINED__ */


#ifndef __Attachment_FWD_DEFINED__
#define __Attachment_FWD_DEFINED__
typedef interface Attachment Attachment;
#endif 	/* __Attachment_FWD_DEFINED__ */


#ifndef __Attachments_FWD_DEFINED__
#define __Attachments_FWD_DEFINED__
typedef interface Attachments Attachments;
#endif 	/* __Attachments_FWD_DEFINED__ */


#ifndef __Folder_FWD_DEFINED__
#define __Folder_FWD_DEFINED__
typedef interface Folder Folder;
#endif 	/* __Folder_FWD_DEFINED__ */


#ifndef __Messages_FWD_DEFINED__
#define __Messages_FWD_DEFINED__
typedef interface Messages Messages;
#endif 	/* __Messages_FWD_DEFINED__ */


#ifndef __Message_FWD_DEFINED__
#define __Message_FWD_DEFINED__
typedef interface Message Message;
#endif 	/* __Message_FWD_DEFINED__ */


#ifndef __Recipient_FWD_DEFINED__
#define __Recipient_FWD_DEFINED__
typedef interface Recipient Recipient;
#endif 	/* __Recipient_FWD_DEFINED__ */


#ifndef __Recipients_FWD_DEFINED__
#define __Recipients_FWD_DEFINED__
typedef interface Recipients Recipients;
#endif 	/* __Recipients_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_actmsg_0000
 * at Sun Nov 02 08:48:51 1997
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


typedef /* [helpstring] */ 
enum CdoErrorType
    {	CdoE_CALL_FAILED	= 0x80004005,
	CdoE_NOT_ENOUGH_MEMORY	= 0x8007000e,
	CdoE_INVALID_PARAMETER	= 0x80070057,
	CdoE_INTERFACE_NOT_SUPPORTED	= 0x80004002,
	CdoE_NO_ACCESS	= 0x80070005,
	CdoE_NO_SUPPORT	= 0x80040102,
	CdoE_BAD_CHARWIDTH	= 0x80040103,
	CdoE_STRING_TOO_LONG	= 0x80040105,
	CdoE_UNKNOWN_FLAGS	= 0x80040106,
	CdoE_INVALID_ENTRYID	= 0x80040107,
	CdoE_INVALID_OBJECT	= 0x80040108,
	CdoE_OBJECT_CHANGED	= 0x80040109,
	CdoE_OBJECT_DELETED	= 0x8004010a,
	CdoE_BUSY	= 0x8004010b,
	CdoE_NOT_ENOUGH_DISK	= 0x8004010d,
	CdoE_NOT_ENOUGH_RESOURCES	= 0x8004010e,
	CdoE_NOT_FOUND	= 0x8004010f,
	CdoE_VERSION	= 0x80040110,
	CdoE_LOGON_FAILED	= 0x80040111,
	CdoE_SESSION_LIMIT	= 0x80040112,
	CdoE_USER_CANCEL	= 0x80040113,
	CdoE_UNABLE_TO_ABORT	= 0x80040114,
	CdoE_NETWORK_ERROR	= 0x80040115,
	CdoE_DISK_ERROR	= 0x80040116,
	CdoE_TOO_COMPLEX	= 0x80040117,
	CdoE_BAD_COLUMN	= 0x80040118,
	CdoE_EXTENDED_ERROR	= 0x80040119,
	CdoE_COMPUTED	= 0x8004011a,
	CdoE_CORRUPT_DATA	= 0x8004011b,
	CdoE_UNCONFIGURED	= 0x8004011c,
	CdoE_FAILONEPROVIDER	= 0x8004011d,
	CdoE_UNKNOWN_CPID	= 0x8004011e,
	CdoE_UNKNOWN_LCID	= 0x8004011f,
	CdoE_PASSWORD_CHANGE_REQUIRED	= 0x80040120,
	CdoE_PASSWORD_EXPIRED	= 0x80040121,
	CdoE_INVALID_WORKSTATION_ACCOUNT	= 0x80040122,
	CdoE_INVALID_ACCESS_TIME	= 0x80040123,
	CdoE_ACCOUNT_DISABLED	= 0x80040124,
	CdoE_END_OF_SESSION	= 0x80040200,
	CdoE_UNKNOWN_ENTRYID	= 0x80040201,
	CdoE_MISSING_REQUIRED_COLUMN	= 0x80040202,
	CdoW_NO_SERVICE	= 0x40203,
	CdoE_BAD_VALUE	= 0x80040301,
	CdoE_INVALID_TYPE	= 0x80040302,
	CdoE_TYPE_NO_SUPPORT	= 0x80040303,
	CdoE_UNEXPECTED_TYPE	= 0x80040304,
	CdoE_TOO_BIG	= 0x80040305,
	CdoE_DECLINE_COPY	= 0x80040306,
	CdoE_UNEXPECTED_ID	= 0x80040307,
	CdoW_ERRORS_RETURNED	= 0x40380,
	CdoE_UNABLE_TO_COMPLETE	= 0x80040400,
	CdoE_TIMEOUT	= 0x80040401,
	CdoE_TABLE_EMPTY	= 0x80040402,
	CdoE_TABLE_TOO_BIG	= 0x80040403,
	CdoE_INVALID_BOOKMARK	= 0x80040405,
	CdoW_POSITION_CHANGED	= 0x40481,
	CdoW_APPROX_COUNT	= 0x40482,
	CdoE_WAIT	= 0x80040500,
	CdoE_CANCEL	= 0x80040501,
	CdoE_NOT_ME	= 0x80040502,
	CdoW_CANCEL_MESSAGE	= 0x40580,
	CdoE_CORRUPT_STORE	= 0x80040600,
	CdoE_NOT_IN_QUEUE	= 0x80040601,
	CdoE_NO_SUPPRESS	= 0x80040602,
	CdoE_COLLISION	= 0x80040604,
	CdoE_NOT_INITIALIZED	= 0x80040605,
	CdoE_NON_STANDARD	= 0x80040606,
	CdoE_NO_RECIPIENTS	= 0x80040607,
	CdoE_SUBMITTED	= 0x80040608,
	CdoE_HAS_FOLDERS	= 0x80040609,
	CdoE_HAS_MESSAGES	= 0x8004060a,
	CdoE_FOLDER_CYCLE	= 0x8004060b,
	CdoW_PARTIAL_COMPLETION	= 0x40680,
	CdoE_AMBIGUOUS_RECIP	= 0x80040700
    }	CdoErrorType;

//--------------------------------------------------------------------------------
// CDONTS.H
//--------------------------------------------------------------------------------
// (C) Copyright 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//--------------------------------------------------------------------------------

#pragma comment(lib,"uuid.lib")

// --------------------------------------------------------------------------------
// GUIDS
// --------------------------------------------------------------------------------
DEFINE_GUID(LIBID_CDONTS, 0x0E064ADD,0x9D99,0x11D0,0xAB,0xE5,0x00,0xAA,0x00,0x64,0xD4,0x70);

DEFINE_GUID(CLSID_NewMail, 0xAF0EB60E,0x0775,0x11D1,0xA7,0x7D,0x00,0xC0,0x4F,0xC2,0xF5,0xB3);

DEFINE_GUID(CLSID_Session, 0x0E064AEC,0x9D99,0x11D0,0xAB,0xE5,0x00,0xAA,0x00,0x64,0xD4,0x70);

DEFINE_GUID(IID_INewMail, 0xAF0EB60D,0x0775,0x11D1,0xA7,0x7D,0x00,0xC0,0x4F,0xC2,0xF5,0xB3);

DEFINE_GUID(IID_ISession, 0x0E064AEB,0x9D99,0x11D0,0xAB,0xE5,0x00,0xAA,0x00,0x64,0xD4,0x70);

DEFINE_GUID(IID_Folder, 0x0E064A01,0x9D99,0x11D0,0xAB,0xE5,0x00,0xAA,0x00,0x64,0xD4,0x70);

DEFINE_GUID(IID_Messages, 0x0E064A02,0x9D99,0x11D0,0xAB,0xE5,0x00,0xAA,0x00,0x64,0xD4,0x70);

DEFINE_GUID(IID_Message, 0x0E064A03,0x9D99,0x11D0,0xAB,0xE5,0x00,0xAA,0x00,0x64,0xD4,0x70);

DEFINE_GUID(IID_Recipients, 0x0E064A04,0x9D99,0x11D0,0xAB,0xE5,0x00,0xAA,0x00,0x64,0xD4,0x70);

DEFINE_GUID(IID_Recipient, 0x0E064A05,0x9D99,0x11D0,0xAB,0xE5,0x00,0xAA,0x00,0x64,0xD4,0x70);

DEFINE_GUID(IID_Attachments, 0x0E064A06,0x9D99,0x11D0,0xAB,0xE5,0x00,0xAA,0x00,0x64,0xD4,0x70);

DEFINE_GUID(IID_Attachment, 0x0E064A07,0x9D99,0x11D0,0xAB,0xE5,0x00,0xAA,0x00,0x64,0xD4,0x70);

DEFINE_GUID(IID_AddressEntry, 0x0E064A08,0x9D99,0x11D0,0xAB,0xE5,0x00,0xAA,0x00,0x64,0xD4,0x70);



extern RPC_IF_HANDLE __MIDL_itf_actmsg_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_actmsg_0000_v0_0_s_ifspec;

#ifndef __INewMail_INTERFACE_DEFINED__
#define __INewMail_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: INewMail
 * at Sun Nov 02 08:48:51 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_INewMail;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("AF0EB60D-0775-11D1-A77D-00C04FC2F5B3")
    INewMail : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Value( 
            BSTR bstrHeader,
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_To( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Cc( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Bcc( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Body( 
            /* [in] */ VARIANT newVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Importance( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BodyFormat( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MailFormat( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Subject( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_From( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Send( 
            /* [optional][in] */ VARIANT From,
            /* [optional][in] */ VARIANT To,
            /* [optional][in] */ VARIANT Subject,
            /* [optional][in] */ VARIANT Body,
            /* [optional][in] */ VARIANT Importance) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AttachFile( 
            /* [in] */ VARIANT Source,
            /* [optional][in] */ VARIANT FileName,
            /* [optional][in] */ VARIANT EncodingMethod) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AttachURL( 
            /* [in] */ VARIANT Source,
            /* [in] */ VARIANT ContentLocation,
            /* [optional][in] */ VARIANT ContentBase,
            /* [optional][in] */ VARIANT EncodingMethod) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetLocaleIDs( 
            /* [in] */ long CodePageID) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ContentLocation( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ContentBase( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Version( 
            /* [retval][out] */ BSTR __RPC_FAR *Version) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INewMailVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INewMail __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INewMail __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INewMail __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            INewMail __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            INewMail __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            INewMail __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            INewMail __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Value )( 
            INewMail __RPC_FAR * This,
            BSTR bstrHeader,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_To )( 
            INewMail __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Cc )( 
            INewMail __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Bcc )( 
            INewMail __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Body )( 
            INewMail __RPC_FAR * This,
            /* [in] */ VARIANT newVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Importance )( 
            INewMail __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BodyFormat )( 
            INewMail __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MailFormat )( 
            INewMail __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Subject )( 
            INewMail __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_From )( 
            INewMail __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Send )( 
            INewMail __RPC_FAR * This,
            /* [optional][in] */ VARIANT From,
            /* [optional][in] */ VARIANT To,
            /* [optional][in] */ VARIANT Subject,
            /* [optional][in] */ VARIANT Body,
            /* [optional][in] */ VARIANT Importance);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AttachFile )( 
            INewMail __RPC_FAR * This,
            /* [in] */ VARIANT Source,
            /* [optional][in] */ VARIANT FileName,
            /* [optional][in] */ VARIANT EncodingMethod);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AttachURL )( 
            INewMail __RPC_FAR * This,
            /* [in] */ VARIANT Source,
            /* [in] */ VARIANT ContentLocation,
            /* [optional][in] */ VARIANT ContentBase,
            /* [optional][in] */ VARIANT EncodingMethod);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLocaleIDs )( 
            INewMail __RPC_FAR * This,
            /* [in] */ long CodePageID);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ContentLocation )( 
            INewMail __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ContentBase )( 
            INewMail __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Version )( 
            INewMail __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Version);
        
        END_INTERFACE
    } INewMailVtbl;

    interface INewMail
    {
        CONST_VTBL struct INewMailVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INewMail_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INewMail_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INewMail_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INewMail_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define INewMail_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define INewMail_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define INewMail_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define INewMail_put_Value(This,bstrHeader,newVal)	\
    (This)->lpVtbl -> put_Value(This,bstrHeader,newVal)

#define INewMail_put_To(This,newVal)	\
    (This)->lpVtbl -> put_To(This,newVal)

#define INewMail_put_Cc(This,newVal)	\
    (This)->lpVtbl -> put_Cc(This,newVal)

#define INewMail_put_Bcc(This,newVal)	\
    (This)->lpVtbl -> put_Bcc(This,newVal)

#define INewMail_put_Body(This,newVal)	\
    (This)->lpVtbl -> put_Body(This,newVal)

#define INewMail_put_Importance(This,newVal)	\
    (This)->lpVtbl -> put_Importance(This,newVal)

#define INewMail_put_BodyFormat(This,newVal)	\
    (This)->lpVtbl -> put_BodyFormat(This,newVal)

#define INewMail_put_MailFormat(This,newVal)	\
    (This)->lpVtbl -> put_MailFormat(This,newVal)

#define INewMail_put_Subject(This,newVal)	\
    (This)->lpVtbl -> put_Subject(This,newVal)

#define INewMail_put_From(This,newVal)	\
    (This)->lpVtbl -> put_From(This,newVal)

#define INewMail_Send(This,From,To,Subject,Body,Importance)	\
    (This)->lpVtbl -> Send(This,From,To,Subject,Body,Importance)

#define INewMail_AttachFile(This,Source,FileName,EncodingMethod)	\
    (This)->lpVtbl -> AttachFile(This,Source,FileName,EncodingMethod)

#define INewMail_AttachURL(This,Source,ContentLocation,ContentBase,EncodingMethod)	\
    (This)->lpVtbl -> AttachURL(This,Source,ContentLocation,ContentBase,EncodingMethod)

#define INewMail_SetLocaleIDs(This,CodePageID)	\
    (This)->lpVtbl -> SetLocaleIDs(This,CodePageID)

#define INewMail_put_ContentLocation(This,newVal)	\
    (This)->lpVtbl -> put_ContentLocation(This,newVal)

#define INewMail_put_ContentBase(This,newVal)	\
    (This)->lpVtbl -> put_ContentBase(This,newVal)

#define INewMail_get_Version(This,Version)	\
    (This)->lpVtbl -> get_Version(This,Version)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE INewMail_put_Value_Proxy( 
    INewMail __RPC_FAR * This,
    BSTR bstrHeader,
    /* [in] */ BSTR newVal);


void __RPC_STUB INewMail_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE INewMail_put_To_Proxy( 
    INewMail __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB INewMail_put_To_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE INewMail_put_Cc_Proxy( 
    INewMail __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB INewMail_put_Cc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE INewMail_put_Bcc_Proxy( 
    INewMail __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB INewMail_put_Bcc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE INewMail_put_Body_Proxy( 
    INewMail __RPC_FAR * This,
    /* [in] */ VARIANT newVal);


void __RPC_STUB INewMail_put_Body_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE INewMail_put_Importance_Proxy( 
    INewMail __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB INewMail_put_Importance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE INewMail_put_BodyFormat_Proxy( 
    INewMail __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB INewMail_put_BodyFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE INewMail_put_MailFormat_Proxy( 
    INewMail __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB INewMail_put_MailFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE INewMail_put_Subject_Proxy( 
    INewMail __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB INewMail_put_Subject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE INewMail_put_From_Proxy( 
    INewMail __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB INewMail_put_From_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE INewMail_Send_Proxy( 
    INewMail __RPC_FAR * This,
    /* [optional][in] */ VARIANT From,
    /* [optional][in] */ VARIANT To,
    /* [optional][in] */ VARIANT Subject,
    /* [optional][in] */ VARIANT Body,
    /* [optional][in] */ VARIANT Importance);


void __RPC_STUB INewMail_Send_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE INewMail_AttachFile_Proxy( 
    INewMail __RPC_FAR * This,
    /* [in] */ VARIANT Source,
    /* [optional][in] */ VARIANT FileName,
    /* [optional][in] */ VARIANT EncodingMethod);


void __RPC_STUB INewMail_AttachFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE INewMail_AttachURL_Proxy( 
    INewMail __RPC_FAR * This,
    /* [in] */ VARIANT Source,
    /* [in] */ VARIANT ContentLocation,
    /* [optional][in] */ VARIANT ContentBase,
    /* [optional][in] */ VARIANT EncodingMethod);


void __RPC_STUB INewMail_AttachURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE INewMail_SetLocaleIDs_Proxy( 
    INewMail __RPC_FAR * This,
    /* [in] */ long CodePageID);


void __RPC_STUB INewMail_SetLocaleIDs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE INewMail_put_ContentLocation_Proxy( 
    INewMail __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB INewMail_put_ContentLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE INewMail_put_ContentBase_Proxy( 
    INewMail __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB INewMail_put_ContentBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE INewMail_get_Version_Proxy( 
    INewMail __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *Version);


void __RPC_STUB INewMail_get_Version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INewMail_INTERFACE_DEFINED__ */


#ifndef __ISession_INTERFACE_DEFINED__
#define __ISession_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISession
 * at Sun Nov 02 08:48:51 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ISession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0E064AEB-9D99-11D0-ABE5-00AA0064D470")
    ISession : public IDispatch
    {
    public:
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ VARIANT __RPC_FAR *varApplication) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ VARIANT __RPC_FAR *varParent) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Session( 
            /* [retval][out] */ VARIANT __RPC_FAR *varSession) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Class( 
            /* [retval][out] */ long __RPC_FAR *varClass) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Version( 
            /* [retval][out] */ BSTR __RPC_FAR *varVersion) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *varName) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Inbox( 
            /* [retval][out] */ VARIANT __RPC_FAR *varInbox) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Outbox( 
            /* [retval][out] */ VARIANT __RPC_FAR *varOutbox) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MessageFormat( 
            /* [retval][out] */ long __RPC_FAR *pMessageFormat) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MessageFormat( 
            /* [in] */ long varMessageFormat) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LogonSMTP( 
            /* [in] */ VARIANT DisplayName,
            /* [in] */ VARIANT Address) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Logoff( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDefaultFolder( 
            /* [in] */ VARIANT Type,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarResult) = 0;
        
        virtual /* [hidden][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMessage( 
            /* [in] */ VARIANT MessageID,
            /* [optional][in] */ VARIANT StoreID,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetLocaleIDs( 
            /* [in] */ long CodePageID) = 0;
        
        virtual /* [hidden][helpstring][id] */ HRESULT STDMETHODCALLTYPE SetReserved( 
            /* [in] */ VARIANT var1,
            /* [in] */ VARIANT var2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISession __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISession __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISession __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISession __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISession __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISession __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISession __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            ISession __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varApplication);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            ISession __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varParent);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Session )( 
            ISession __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varSession);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            ISession __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *varClass);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Version )( 
            ISession __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varVersion);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            ISession __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varName);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Inbox )( 
            ISession __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varInbox);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Outbox )( 
            ISession __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varOutbox);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MessageFormat )( 
            ISession __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pMessageFormat);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MessageFormat )( 
            ISession __RPC_FAR * This,
            /* [in] */ long varMessageFormat);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LogonSMTP )( 
            ISession __RPC_FAR * This,
            /* [in] */ VARIANT DisplayName,
            /* [in] */ VARIANT Address);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Logoff )( 
            ISession __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultFolder )( 
            ISession __RPC_FAR * This,
            /* [in] */ VARIANT Type,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);
        
        /* [hidden][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMessage )( 
            ISession __RPC_FAR * This,
            /* [in] */ VARIANT MessageID,
            /* [optional][in] */ VARIANT StoreID,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLocaleIDs )( 
            ISession __RPC_FAR * This,
            /* [in] */ long CodePageID);
        
        /* [hidden][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetReserved )( 
            ISession __RPC_FAR * This,
            /* [in] */ VARIANT var1,
            /* [in] */ VARIANT var2);
        
        END_INTERFACE
    } ISessionVtbl;

    interface ISession
    {
        CONST_VTBL struct ISessionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISession_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISession_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISession_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISession_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISession_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISession_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISession_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISession_get_Application(This,varApplication)	\
    (This)->lpVtbl -> get_Application(This,varApplication)

#define ISession_get_Parent(This,varParent)	\
    (This)->lpVtbl -> get_Parent(This,varParent)

#define ISession_get_Session(This,varSession)	\
    (This)->lpVtbl -> get_Session(This,varSession)

#define ISession_get_Class(This,varClass)	\
    (This)->lpVtbl -> get_Class(This,varClass)

#define ISession_get_Version(This,varVersion)	\
    (This)->lpVtbl -> get_Version(This,varVersion)

#define ISession_get_Name(This,varName)	\
    (This)->lpVtbl -> get_Name(This,varName)

#define ISession_get_Inbox(This,varInbox)	\
    (This)->lpVtbl -> get_Inbox(This,varInbox)

#define ISession_get_Outbox(This,varOutbox)	\
    (This)->lpVtbl -> get_Outbox(This,varOutbox)

#define ISession_get_MessageFormat(This,pMessageFormat)	\
    (This)->lpVtbl -> get_MessageFormat(This,pMessageFormat)

#define ISession_put_MessageFormat(This,varMessageFormat)	\
    (This)->lpVtbl -> put_MessageFormat(This,varMessageFormat)

#define ISession_LogonSMTP(This,DisplayName,Address)	\
    (This)->lpVtbl -> LogonSMTP(This,DisplayName,Address)

#define ISession_Logoff(This)	\
    (This)->lpVtbl -> Logoff(This)

#define ISession_GetDefaultFolder(This,Type,pvarResult)	\
    (This)->lpVtbl -> GetDefaultFolder(This,Type,pvarResult)

#define ISession_GetMessage(This,MessageID,StoreID,pvarResult)	\
    (This)->lpVtbl -> GetMessage(This,MessageID,StoreID,pvarResult)

#define ISession_SetLocaleIDs(This,CodePageID)	\
    (This)->lpVtbl -> SetLocaleIDs(This,CodePageID)

#define ISession_SetReserved(This,var1,var2)	\
    (This)->lpVtbl -> SetReserved(This,var1,var2)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISession_get_Application_Proxy( 
    ISession __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varApplication);


void __RPC_STUB ISession_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISession_get_Parent_Proxy( 
    ISession __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varParent);


void __RPC_STUB ISession_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISession_get_Session_Proxy( 
    ISession __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varSession);


void __RPC_STUB ISession_get_Session_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISession_get_Class_Proxy( 
    ISession __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *varClass);


void __RPC_STUB ISession_get_Class_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISession_get_Version_Proxy( 
    ISession __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varVersion);


void __RPC_STUB ISession_get_Version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISession_get_Name_Proxy( 
    ISession __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varName);


void __RPC_STUB ISession_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISession_get_Inbox_Proxy( 
    ISession __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varInbox);


void __RPC_STUB ISession_get_Inbox_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISession_get_Outbox_Proxy( 
    ISession __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varOutbox);


void __RPC_STUB ISession_get_Outbox_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISession_get_MessageFormat_Proxy( 
    ISession __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pMessageFormat);


void __RPC_STUB ISession_get_MessageFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ISession_put_MessageFormat_Proxy( 
    ISession __RPC_FAR * This,
    /* [in] */ long varMessageFormat);


void __RPC_STUB ISession_put_MessageFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISession_LogonSMTP_Proxy( 
    ISession __RPC_FAR * This,
    /* [in] */ VARIANT DisplayName,
    /* [in] */ VARIANT Address);


void __RPC_STUB ISession_LogonSMTP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISession_Logoff_Proxy( 
    ISession __RPC_FAR * This);


void __RPC_STUB ISession_Logoff_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISession_GetDefaultFolder_Proxy( 
    ISession __RPC_FAR * This,
    /* [in] */ VARIANT Type,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);


void __RPC_STUB ISession_GetDefaultFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstring][id] */ HRESULT STDMETHODCALLTYPE ISession_GetMessage_Proxy( 
    ISession __RPC_FAR * This,
    /* [in] */ VARIANT MessageID,
    /* [optional][in] */ VARIANT StoreID,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);


void __RPC_STUB ISession_GetMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISession_SetLocaleIDs_Proxy( 
    ISession __RPC_FAR * This,
    /* [in] */ long CodePageID);


void __RPC_STUB ISession_SetLocaleIDs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstring][id] */ HRESULT STDMETHODCALLTYPE ISession_SetReserved_Proxy( 
    ISession __RPC_FAR * This,
    /* [in] */ VARIANT var1,
    /* [in] */ VARIANT var2);


void __RPC_STUB ISession_SetReserved_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISession_INTERFACE_DEFINED__ */


#ifndef __Folder_INTERFACE_DEFINED__
#define __Folder_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: Folder
 * at Sun Nov 02 08:48:51 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_Folder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0E064A01-9D99-11D0-ABE5-00AA0064D470")
    Folder : public IDispatch
    {
    public:
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ VARIANT __RPC_FAR *varApplication) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ VARIANT __RPC_FAR *varParent) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Session( 
            /* [retval][out] */ VARIANT __RPC_FAR *varSession) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Class( 
            /* [retval][out] */ long __RPC_FAR *varClass) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *varName) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Messages( 
            /* [retval][out] */ VARIANT __RPC_FAR *varMessages) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct FolderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            Folder __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            Folder __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            Folder __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            Folder __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            Folder __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            Folder __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            Folder __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            Folder __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varApplication);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            Folder __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varParent);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Session )( 
            Folder __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varSession);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            Folder __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *varClass);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            Folder __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varName);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Messages )( 
            Folder __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varMessages);
        
        END_INTERFACE
    } FolderVtbl;

    interface Folder
    {
        CONST_VTBL struct FolderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Folder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Folder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Folder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Folder_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Folder_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Folder_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Folder_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Folder_get_Application(This,varApplication)	\
    (This)->lpVtbl -> get_Application(This,varApplication)

#define Folder_get_Parent(This,varParent)	\
    (This)->lpVtbl -> get_Parent(This,varParent)

#define Folder_get_Session(This,varSession)	\
    (This)->lpVtbl -> get_Session(This,varSession)

#define Folder_get_Class(This,varClass)	\
    (This)->lpVtbl -> get_Class(This,varClass)

#define Folder_get_Name(This,varName)	\
    (This)->lpVtbl -> get_Name(This,varName)

#define Folder_get_Messages(This,varMessages)	\
    (This)->lpVtbl -> get_Messages(This,varMessages)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Folder_get_Application_Proxy( 
    Folder __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varApplication);


void __RPC_STUB Folder_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Folder_get_Parent_Proxy( 
    Folder __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varParent);


void __RPC_STUB Folder_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Folder_get_Session_Proxy( 
    Folder __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varSession);


void __RPC_STUB Folder_get_Session_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Folder_get_Class_Proxy( 
    Folder __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *varClass);


void __RPC_STUB Folder_get_Class_Stub(
    IRpc