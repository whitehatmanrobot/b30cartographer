
        (CURSOR_DIB_BITS_SIZE((pCursorShape)->hdr.cx, (pCursorShape)->hdr.cy, \
        (pCursorShape)->hdr.cBitsPerPel))
        


#define CURSORSHAPE_SIZE(pCursorShape) \
    sizeof(CM_CURSORSHAPEHDR) +               \
    CURSOR_AND_MASK_SIZE(pCursorShape) +     \
    CURSOR_XOR_BITMAP_SIZE(pCursorShape)


/****************************************************************************/
/* Null cursor indications                                                  */
/****************************************************************************/
#define CM_CURSOR_IS_NULL(pCursor) ((((pCursor)->hdr.cPlanes==(BYTE)0xFF) && \
                                    (pCursor)->hdr.cBitsPerPel == (BYTE)0xFF))

#define CM_SET_NULL_CURSOR(pCursor) (pCursor)->hdr.cPlanes = 0xFF;          \
                                    (pCursor)->hdr.cBitsPerPel = 0xFF;

/****************************************************************************/
/* Windows CURSORSHAPE definitions                                          */
/****************************************************************************/
typedef struct _CM_CURSORSHAPEHDR
{
    POINT ptHotSpot;
    WORD  cx;
    WORD  cy;
    WORD  cbMaskRowWidth;
    unsigned cbColorRowWidth;
    BYTE  cPlanes;
    BYTE  cBitsPerPel;
} CM_CURSORSHAPEHDR, *PCM_CURSORSHAPEHDR;

typedef struct _CM_CURSORSHAPE
{
    CM_CURSORSHAPEHDR hdr;
    BYTE Masks[1]; /* 1bpp AND mask, followed by n bpp XOR mask */
} CM_CURSORSHAPE, *PCM_CURSORSHAPE;

typedef struct tagCM_CURSOR_SHAPE_DATA
{
    CM_CURSORSHAPEHDR hdr;
    BYTE              data[CM_MAX_CURSOR_DATA_SIZE];
} CM_CURSOR_SHAPE_DATA, *PCM_CURSOR_SHAPE_DATA;


/****************************************************************************/
/* Structure: CM_SHARED_DATA                                                */
/*                                                                          */
/* Description: Shared memory data - cursor description and usage flag      */
/*                                                                          */
/*   cmCursorStamp     - Cursor identifier: an integer written by the       */
/*                       display driver                                     */
/*   cmCacheSize       - number of entries required in cursor cache         */
/*   cmCacheHit        - cursor was found in the cache                      */
/*   cmBitsWaiting     - there are bits waiting to be sent - set by the DD  */
/*                       and cleared by the WD                              */
/*   cmCacheEntry      - cache entry to send                                */
/*   cmCursorShapeData - Cursor definition (AND, XOR masks, etc)            */
/*   cmCursorPos       - Pointer coords                                     */
/*   cmCursorMoved     - Flag indicating that cursor moved                  */
/*   cmHidden          - Set if cursor hidden                               */
/*   cmNativeColor     - Flag indicating that can use native cursor color   */
/*                       depth                                              */
#ifdef DC_HICOLOR
/*   cmSendAnyColor    - Flag indicating that cursors may be sent at any    */
/*                       color depth, ie including 15/16bpp                 */
#endif
/*                                                                          */
/****************************************************************************/
typedef struct tagCM_SHARED_DATA
{
    UINT32  cmCursorStamp;
    UINT32  cmCacheSize;
    BOOLEAN cmCacheHit;
    BOOLEAN cmBitsWaiting;
    BOOLEAN cmCursorMoved;
    BOOLEAN cmHidden;
    BOOLEAN cmNativeColor;
#ifdef DC_HICOLOR
    BOOLEAN cmSendAnyColor;
#endif
    UINT32  cmCacheEntry;
    POINTL  cmCursorPos;
    CM_CURSOR_SHAPE_DATA cmCursorShapeData;  // Needs to be last for memset in CM_InitShm()
} CM_SHARED_DATA, *PCM_SHARED_DATA;



#endif   /* #ifndef _H_ACMAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\adcg.h ===
/****************************************************************************/
// adcg.h
//
// RDP definitions
//
// Copyright (C) 1996-2000 Microsoft Corporation
/****************************************************************************/
#ifndef _H_ADCG
#define _H_ADCG

#include <at128.h>

#include <stdio.h>
#include <string.h>


// No headers when compiling rdpkdx.
#ifndef DC_NO_SYSTEM_HEADERS

/****************************************************************************/
/* winsta.h defines BYTE as unsigned char; later, windef.h typedefs it.     */
/* This ends up as 'typedef unsigned char unsigned char' which doesn't      */
/* compile too well...                                                      */
/*                                                                          */
/* This is my attempt to avoid it                                           */
/****************************************************************************/
#ifdef BYTE
#undef BYTE
#endif

#define BYTE BYTE

/****************************************************************************/
/* Windows NT DDK include files (used to replace standard windows.h)        */
/*                                                                          */
/* The display driver runs in the Kernel space and so MUST NOT access any   */
/* Win32 functions or data.  Instead we can only use the Win32k functions   */
/* as described in the DDK.                                                 */
/****************************************************************************/
#include <stdarg.h>
#include <windef.h>
#include <wingdi.h>
#include <winddi.h>

#ifndef _FILETIME_
typedef struct  _FILETIME       /* from wtypes.h */
{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME;
#endif

#endif  // !defined(DC_NO_SYSTEM_HEADERS)


/****************************************************************************/
// Set up defines for C or C++ compilation
/****************************************************************************/
#ifdef __cplusplus

// The forward reference to the class.
class ShareClass;
#define SHCLASS ShareClass::

#else /* !__cplusplus */

#define SHCLASS

#endif /* __cplusplus */


/****************************************************************************/
// Added types on top of ANSI C and Win32/Win64 types.
/****************************************************************************/
#define RDPCALL __stdcall

typedef unsigned short UNALIGNED *PUINT16_UA;

// These are defined by NT5's headers, but not on Terminal Server 4.0.
typedef __int32 UNALIGNED *PINT32_UA;
typedef unsigned __int32 UNALIGNED *PUINT32_UA;

typedef void **PPVOID;

typedef unsigned LOCALPERSONID;
typedef LOCALPERSONID *PLOCALPERSONID;

typedef unsigned NETPERSONID;


/****************************************************************************/
/* FIELDSIZE and FIELDOFFSET macros.                                        */
/****************************************************************************/
#define FIELDSIZE(type, field)   (sizeof(((type *)1)->field))
#define FIELDOFFSET(type, field) ((UINT_PTR)(&((type *)0)->field))


/****************************************************************************/
/* Common function macros used throughout the product.                      */
/****************************************************************************/
#define DC_QUIT           goto DC_EXIT_POINT
#define DC_BEGIN_FN(str)  TRC_FN(str); TRC_ENTRY;
#define DC_END_FN()       TRC_EXIT;
#define DC_QUIT_ON_FAIL(hr)     if (FAILED(hr)) DC_QUIT;

/****************************************************************************/
/* Macro to round up a number to the nearest multiple of four.              */
/****************************************************************************/
#define DC_ROUND_UP_4(x)  (((UINT_PTR)(x) + (UINT_PTR)3) & ~((UINT_PTR)0x03))


/****************************************************************************/
/* Other common macros.                                                     */
/****************************************************************************/
#define COM_SIZEOF_RECT(r)                                                  \
    (UINT32)((UINT32)((r).right - (r).left)*                           \
             (UINT32)((r).bottom - (r).top))


/****************************************************************************/
/* Macro to remove the "Unreferenced parameter" warning.                    */
/****************************************************************************/
#define DC_IGNORE_PARAMETER(PARAMETER)   \
                            PARAMETER;


/****************************************************************************/
// Registry key names
/****************************************************************************/
#define WINSTATION_INI_SECTION_NAME L""
#define DCS_INI_SECTION_NAME        L"Share"
#define WINLOGON_KEY \
        L"\\Registry\\Machine\\software\\Microsoft\\Windows Nt\\" \
        L"CurrentVersion\\Winlogon"
        
// This is the new key that is used by winlogon starting with W2K
#define W2K_GROUP_POLICY_WINLOGON_KEY \
        L"\\Registry\\Machine\\Software\\Microsoft\\Windows\\" \
        L"CurrentVersion\\Policies\\System"
/****************************************************************************/
/* Tags for memory allocation.                                              */
/****************************************************************************/
#define WD_ALLOC_TAG 'dwST'
#define DD_ALLOC_TAG 'ddST'


/****************************************************************************/
/* DCRGB                                                                    */
/****************************************************************************/
typedef struct tagDCRGB
{
    BYTE red;
    BYTE green;
    BYTE blue;
} DCRGB, *PDCRGB;


/****************************************************************************/
/* DCCOLOR                                                                  */
/*                                                                          */
/* Union of DCRGB and an index into a color table                           */
/****************************************************************************/
typedef struct tagDCCOLOR
{
    union
    {
        DCRGB rgb;
        BYTE  index;
    } u;
} DCCOLOR, *PDCCOLOR;


/****************************************************************************/
// Max party name kept by the share core.
/****************************************************************************/
#define MAX_NAME_LEN 48


/****************************************************************************/
/* Structure used to package multiple PDUs of differing types into one      */
/* large data packet                                                        */
/****************************************************************************/
typedef struct _tagPDU_PACKAGE_INFO
{
    unsigned cbLen;      /* length of buffer                            */
    unsigned cbInUse;    /* length of buffer in use                     */
    PBYTE    pBuffer;    /* pointer to the actual or compression buffer */
    PVOID    pOutBuf;    /* pointer to an OutBuf                        */
} PDU_PACKAGE_INFO, *PPDU_PACKAGE_INFO;



#endif /* _H_ADCG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\adcsafn.h ===
/****************************************************************************/
/* adcsafn.h                                                                */
/*                                                                          */
/* Function prototypes for DCS API functions                                */
/*                                                                          */
/* Copyright(c) Microsoft 1996-1999                                         */
/****************************************************************************/

BOOL RDPCALL DCS_Init(PTSHARE_WD pTSWd, PVOID pSMHandle);

void RDPCALL DCS_Term();

/****************************************************************************/
// DCS_Disconnect
//
// Disconnects DCS from the Display Driver.
/****************************************************************************/
void RDPCALL DCS_Disconnect()
{
    // Nothing to do.
}

BOOL RDPCALL DCS_Reconnect(void);

NTSTATUS RDPCALL DCS_TimeToDoStuff(PTSHARE_DD_OUTPUT_IN  pOutputIn,
                                PUINT32             pSchCurrentMode,
                                PINT32              pNextTimer);

void RDPCALL DCS_DiscardAllOutput();

void RDPCALL DCS_ReceivedShutdownRequestPDU(
        PTS_SHAREDATAHEADER pDataPDU,
        unsigned            DataLength,
        NETPERSONID         personID);

BOOL RDPCALL DCS_UpdateAutoReconnectCookie();
BOOL RDPCALL DCS_FlushAutoReconnectCookie();

void RDPCALL DCS_UserLoggedOn(PLOGONINFO);

void RDPCALL DCS_WDWKeyboardSetIndicators(void);

void RDPCALL DCS_WDWKeyboardSetImeStatus(void);

void RDPCALL DCS_TriggerUpdateShmCallback(void);

void RDPCALL DCS_UpdateShm(void);

void RDPCALL DCS_TriggerCBDataReady(void);

void RDPCALL DCS_SendErrorInfo(TSUINT32 errInfo);

void RDPCALL DCS_SendAutoReconnectStatus(TSUINT32 arcStatus);

BOOL RDPCALL DCS_SendAutoReconnectCookie(
        PARC_SC_PRIVATE_PACKET pArcSCPkt);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\adcsapi.h ===
/****************************************************************************/
// adcsapi.h
//
// RDP main component API header file.
//
// Copyright(c) Microsoft, PictureTel 1992-1997
// (C) 1997-1999 Microsoft Corp.
/****************************************************************************/
#ifndef _H_ADCSAPI
#define _H_ADCSAPI

#include <ascapi.h>


/****************************************************************************/
/* Frequency for miscellaneous periodic processing, in units of 100ns       */
/****************************************************************************/
#define DCS_MISC_PERIOD         200 * 10000


#define DCS_ARC_UPDATE_INTERVAL     L"AutoReconnect Update Interval"
//
// One hour update interval (units are in seconds)
//
#define DCS_ARC_UPDATE_INTERVAL_DFLT   60 * 60

//
// Time intervals are handled in units of 100ns so 10,000,000
// are needed to make up one second
//
#define DCS_TIME_ONE_SECOND            10000000


#endif   /* #ifndef _H_ADCSAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\aimafn.h ===
/****************************************************************************/
// aimafn.h
//
// IM prototypes
//
// Copyright (C) 1996-1999 Microsoft Corp.
/****************************************************************************/

void RDPCALL IM_Init(void);

void __fastcall IM_PlaybackEvents(PTS_INPUT_PDU, unsigned);

void RDPCALL IM_DecodeFastPathInput(BYTE *, unsigned, unsigned);

void RDPCALL IM_ConvertFastPathToShadow(BYTE *, unsigned, unsigned);

void RDPCALL IM_CheckUpdateCursor(PPDU_PACKAGE_INFO, UINT32 currentTime);

BOOL RDPCALL IM_PartyJoiningShare(LOCALPERSONID, unsigned);

void RDPCALL IM_PartyLeftShare(LOCALPERSONID, unsigned);

NTSTATUS RDPCALL IMCheckForShadowHotkey(KEYBOARD_INPUT_DATA *,
        unsigned);

NTSTATUS RDPCALL IMDoSync(unsigned);

void RDPCALL IMResetKeyStateArray();

BOOL __fastcall IMConvertMousePacketToEvent(TS_POINTER_EVENT UNALIGNED *,
        MOUSE_INPUT_DATA *, BOOL);

BOOL __fastcall IMConvertFastPathKeyboardToEvent(BYTE *,
        KEYBOARD_INPUT_DATA *);


// Inline functions.

#ifdef __cplusplus

/****************************************************************************/
// IM_Term
//
// IM cleanup at WD destruction.
/****************************************************************************/
void RDPCALL IM_Term(void)
{
}


#endif  // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\aoaapi.h ===
/****************************************************************************/
// aoaapi.h
//
// RDP Order Accumulation API functions
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/
#ifndef _H_AOAAPI
#define _H_AOAAPI


#define OA_ORDER_HEAP_SIZE (64 * 1024)


/****************************************************************************/
// Structure used to store orders in the shared memory
//
// TotalOrderBytes - Total bytes used by order data
// nextOrder       - Offset for start of next new order
// orderListHead   - Order list head
// orderHeap       - Order heap
/****************************************************************************/
typedef struct
{
    unsigned   TotalOrderBytes;
    unsigned   nextOrder;
    LIST_ENTRY orderListHead;
    BYTE       orderHeap[OA_ORDER_HEAP_SIZE];
} OA_SHARED_DATA, *POA_SHARED_DATA;


/****************************************************************************/
// INT_ORDER
//
// Info for each order in the order heap.
//
// OrderLength: Length of following order data (not including header or
// extra bytes needed for DWORD-aligned padding).
/****************************************************************************/
typedef struct
{
    LIST_ENTRY list;
    unsigned OrderLength;
#if DC_DEBUG
    unsigned CheckSum;
#endif
    BYTE OrderData[1];
} INT_ORDER, *PINT_ORDER;



#endif /* ndef _H_AOAAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\anmint.h ===
/****************************************************************************/
// anmint.h
//
// RDP Network Manager internal header
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/
#ifndef _H_ANMINT
#define _H_ANMINT

#include <anmapi.h>
#include <mcsioctl.h>
#include <nwdwapi.h>


/****************************************************************************/
/* Values for connectStatus field in NM Handle (note these are flags, hence */
/* discrete bits not contiguous values)                                     */
/****************************************************************************/
#define NM_CONNECT_NONE             0
#define NM_CONNECT_ATTACH           0x01
#define NM_CONNECT_JOIN_USER        0x02
#define NM_CONNECT_JOIN_BROADCAST   0x04


typedef struct tagNM_HANDLE_DATA
{
    /************************************************************************/
    /* pSMHandle MUST be first here to allow SM_MCSSendDataCallback() to    */
    /* get its context pointer through double-indirection.                  */
    /************************************************************************/
    PVOID         pSMHandle;

    PTSHARE_WD    pWDHandle;
    PSDCONTEXT    pContext;
    UserHandle    hUser;
    ChannelID     channelID;
    ChannelHandle hChannel;
    DomainHandle  hDomain;
    UINT32        connectStatus;
    UINT32        userID;
    UINT32        maxPDUSize;
    BOOL          dead;

    /************************************************************************/
    /* Virtual channel information                                          */
    /* - channelCount - number of channels in this session                  */
    /* - channelArrayCount - number of entries in the array                 */
    /* - channelData - information held for each channel                    */
    /*                                                                      */
    /* Channel 7 is used by RDPDD.  I want to use the virtual channel ID as */
    /* an index into channelData, hence entry 7 is left blank.  If there are */
    /* more than 7 channels, channelArrayCount will be channelCount + 1.    */
    /************************************************************************/
    UINT channelCount;
    UINT channelArrayCount;
    NM_CHANNEL_DATA channelData[VIRTUAL_MAXIMUM];

} NM_HANDLE_DATA, *PNM_HANDLE_DATA;


/****************************************************************************/
/* Functions                                                                */
/****************************************************************************/
BOOL RDPCALL NMDetachUserReq(PNM_HANDLE_DATA);

void RDPCALL NMAbortConnect(PNM_HANDLE_DATA);

void RDPCALL NMDetachUserInd(PNM_HANDLE_DATA, MCSReason, UserID);


#endif /* _H_ANMINT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\anmapi.h ===
/****************************************************************************/
// anmapi.h
//
// RDP Network Manager
//
// Copyright (C) 1997-1999 Microsoft Corporation
/****************************************************************************/
#ifndef _H_ANMAPI
#define _H_ANMAPI

#include <nwdwapi.h>


/****************************************************************************/
/* Connection reason codes                                                  */
/****************************************************************************/
#define NM_CB_CONN_OK           0       /* Connected successfully           */
#define NM_CB_CONN_ERR          1       /* Failed to connect                */


/****************************************************************************/
/* Disconnection reason codes                                               */
/****************************************************************************/
#define NM_CB_DISC_SERVER       1       /* Server-initiated disconnection   */
#define NM_CB_DISC_LOGOFF       2       /* Logoff                           */
#define NM_CB_DISC_CLIENT       3       /* Client-initiated disconnection   */
#define NM_CB_DISC_NETWORK      4       /* Network error                    */


/****************************************************************************/
// NM_SendData fast-path output flags. Used in conjunction with some
// TS flags in different bits.
/****************************************************************************/
#define NM_SEND_FASTPATH_OUTPUT 0x01
#define NM_NO_SECURITY_HEADER   0x02


/****************************************************************************/
/* Structure: NM_CHANNEL_DATA                                               */
/*                                                                          */
/* Description: Data held for each virtual channel                          */
/****************************************************************************/
typedef struct tagNM_CHANNEL_DATA
{
    char     name[CHANNEL_NAME_LEN + 1];
    UINT16   MCSChannelID;
    ULONG    flags;
    PBYTE    pData;
    PBYTE    pNext;
    unsigned dataLength;
    unsigned lengthSoFar;
} NM_CHANNEL_DATA, *PNM_CHANNEL_DATA, **PPNM_CHANNEL_DATA;


/****************************************************************************/
/* FUNCTIONS                                                                */
/****************************************************************************/

unsigned RDPCALL NM_GetDataSize(void);

BOOL RDPCALL NM_Init(PVOID      pNMHandle,
                     PVOID      pSMHandle,
                     PTSHARE_WD   pWDHandle,
                     DomainHandle hDomainKernel);

void RDPCALL NM_Term(PVOID pNMHandle);

BOOL RDPCALL NM_Connect(PVOID pNMHandle, PRNS_UD_CS_NET pUserData);

BOOL RDPCALL NM_Disconnect(PVOID pNMHandle);

NTSTATUS __fastcall NM_AllocBuffer(PVOID  pNMHandle,
                               PPVOID ppBuffer,
                               UINT32 bufferSize,
                               BOOLEAN fWait);

void __fastcall NM_FreeBuffer(PVOID pNMHandle, PVOID pBuffer);

BOOL __fastcall NM_SendData(PVOID, PBYTE, UINT32, UINT32, UINT32, UINT32);

void __stdcall NM_MCSUserCallback(UserHandle hUser,
                                  unsigned   Message,
                                  void       *Params,
                                  void       *UserDefined);

void RDPCALL NM_Dead(PVOID pNMHandle, BOOL dead);

NTSTATUS RDPCALL NM_VirtualQueryBindings(PVOID, PSD_VCBIND, ULONG, PULONG);

VIRTUALCHANNELCLASS RDPCALL NM_MCSChannelToVirtual(PVOID, UINT16,
        PPNM_CHANNEL_DATA);

INT16 RDPCALL NM_VirtualChannelToMCS(PVOID, VIRTUALCHANNELCLASS,
        PPNM_CHANNEL_DATA);

NTSTATUS RDPCALL NM_QueryChannels(PVOID, PVOID, unsigned, PULONG);


#endif /* _H_ANMAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\aoacom.c ===
/****************************************************************************/
// aoacom.c
//
// Functions common to OA in WD and DD
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/


#ifdef DLL_DISP
#define _pShm pddShm
#else
#define _pShm m_pShm
#endif


/****************************************************************************/
// OA_ResetOrderList
//
// Frees all Orders and Additional Order Data in the Order List.
// Frees up the Order Heap memory.
/****************************************************************************/
__inline void SHCLASS OA_ResetOrderList()
{        
    // Simply clear the list head, the heap contents become useless.
    _pShm->oa.TotalOrderBytes = 0;
    _pShm->oa.nextOrder = 0;
    InitializeListHead(&_pShm->oa.orderListHead);
}


/****************************************************************************/
// OA_RemoveListOrder
//
// Removes the specified order from the Order List by marking it as spoilt.
// Returns a pointer to the order following the removed order.
/****************************************************************************/
PINT_ORDER SHCLASS OA_RemoveListOrder(PINT_ORDER pCondemnedOrder)
{
    PINT_ORDER pNextOrder;

    DC_BEGIN_FN("OA_RemoveListOrder");

    TRC_DBG((TB, "Remove list order (%p)", pCondemnedOrder));

    // Store a ptr to the next order. If we are at the end of the list
    // we return NULL.
    if (pCondemnedOrder->list.Flink != &_pShm->oa.orderListHead)
        pNextOrder = CONTAINING_RECORD(pCondemnedOrder->list.Flink,
                INT_ORDER, list);
    else
        pNextOrder = NULL;

    // Remove the order.
    RemoveEntryList(&pCondemnedOrder->list);

    TRC_ASSERT((_pShm->oa.TotalOrderBytes >= pCondemnedOrder->OrderLength),
            (TB,"We're removing too many bytes from the order heap - "
            "TotalOrderBytes=%u, ord size to remove=%u",
            _pShm->oa.TotalOrderBytes, pCondemnedOrder->OrderLength));
    _pShm->oa.TotalOrderBytes -= pCondemnedOrder->OrderLength;

    // Check that the list is still consistent with the total number of
    // order bytes.
    if (_pShm->oa.TotalOrderBytes == 0 &&
            !IsListEmpty(&_pShm->oa.orderListHead)) {
        TRC_ERR((TB, "List not empty when total ord bytes==0"));
        InitializeListHead(&_pShm->oa.orderListHead);
    }

    DC_END_FN();
    return pNextOrder;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\aimapi.h ===
/****************************************************************************/
// aimapi.h
//
// Input manager API include file
//
// Copyright(c) Microsoft, PictureTel 1993-1997
// Copyright (c) 1997-1999 Microsoft Corporation
/****************************************************************************/
#ifndef _H_AIMAPI
#define _H_AIMAPI


/****************************************************************************/
/* The maximum amount of time that we expect an injected event to take to   */
/* pass through USER, in units of 100ns                                     */
/****************************************************************************/
#define IM_EVENT_PERCOLATE_TIME   300 * 10000


/****************************************************************************/
/* For managing our key state arrays.                                       */
/*                                                                          */
/* Note that the key state array only needs to have 256 elements for the    */
/* actual keys, but since we're using scan codes we lose the virtual keys   */
/* for the mouse button and the Toggles.  Instead we put these states       */
/*  at the end of the array using our own invented scan codes               */
/****************************************************************************/
#define IM_KEY_STATE_SIZE 266

#define IM_SC_LBUTTON     256
#define IM_SC_RBUTTON     257
#define IM_SC_MBUTTON     258

#define IM_SC_CAPITAL     259
#define IM_SC_NUMLOCK     260
#define IM_SC_SCROLL      261

#define IM_SC_RCONTROL    262
#define IM_SC_RALT        263

#define IM_SC_XBUTTON1    264
#define IM_SC_XBUTTON2    265

/****************************************************************************/
/* These are the real scan codes for Control and ALT.                       */
/****************************************************************************/
#define IM_SC_LCONTROL     29
#define IM_SC_LALT         56


/****************************************************************************/
/* Macro to convert from logical mouse co-ordinates to the full 16-bit      */
/* range co-ordinates expected from us.                                     */
/*                                                                          */
/* The macro below IS right!  Consider a VGA screen.  There are 640         */
/* possible horizontal mouse positions, which we can look at as cells with  */
/* the mouse being at the centre of each, ie at co-ords 0.5, 1.5, ...       */
/* 638.5, 639.5.                                                            */
/*                                                                          */
/* We want to scale this to the range 0 - 65535, so we need 640 cells,      */
/* 65536/640 wide (which is 1024).  This gives the range of mouse positions */
/* as 512, 1536, ...  65024.                                                */
/*                                                                          */
/* Hence we do the conversion by scaling the postion by 65536/640 and       */
/* adding on half the width of a cell                                       */
/*                                                                          */
/****************************************************************************/
#define IM_MOUSEPOS_LOG_TO_OS_ABS(coord, size)                              \
        (((65536L * (UINT32)coord) + 32768L) / (UINT32)size)


/****************************************************************************/
/* Used to set and check values in key state arrays.                        */
/****************************************************************************/
#define IM_KEY_STATE_IS_UP(A) (!(A))
#define IM_KEY_STATE_IS_DOWN(A) (A)

#define IM_SET_KEY_DOWN(A) (A) = TRUE
#define IM_SET_KEY_UP(A)   (A) = FALSE



#endif /* _H_AIMAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\aoaafn.h ===
/****************************************************************************/
// aoaafn.h
//
// Function prototypes for OA API functions
//
// Copyright (C) 1996-2000 Microsoft Corporation
/****************************************************************************/

void RDPCALL OA_Init(void);

void RDPCALL OA_UpdateShm(void);

void RDPCALL OA_SyncUpdatesNow(void);


#ifdef __cplusplus

/****************************************************************************/
/* OA_Term                                                                  */
/****************************************************************************/
void RDPCALL SHCLASS OA_Term(void)
{
}


/****************************************************************************/
// OA_GetFirstListOrder()
//
// Returns pointer to the first order in the Order List.
// PINT_ORDER RDPCALL OA_GetFirstListOrder(void);
/****************************************************************************/
#define OA_GetFirstListOrder() (!IsListEmpty(&_pShm->oa.orderListHead) ? \
        CONTAINING_RECORD(_pShm->oa.orderListHead.Flink, INT_ORDER, list) : \
        NULL);


/****************************************************************************/
/* OA_GetTotalOrderListBytes(..)                                            */
/*                                                                          */
/* Returns:  The total number of bytes in the orders currently stored in    */
/*           the Order List.                                                */
/****************************************************************************/
UINT32 RDPCALL OA_GetTotalOrderListBytes(void)
{
    return m_pShm->oa.TotalOrderBytes;
}


#endif  // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\aoacom.h ===
/****************************************************************************/
// aoacom.h
//
// Header for common (WD/DD) OA functions
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

PINT_ORDER RDPCALL OA_RemoveListOrder(PINT_ORDER);

void RDPCALL OA_ResetOrderList(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\aoeafn.h ===
/****************************************************************************/
// aoeafn.h
//
// Function prototypes for OE API functions
//
// COPYRIGHT (c) Microsoft 1996-1999
/****************************************************************************/

void RDPCALL OE_Init(void);

void RDPCALL OE_PartyLeftShare(LOCALPERSONID localID,
                               unsigned          newShareSize);

BOOL RDPCALL OE_PartyJoiningShare(LOCALPERSONID  localID,
                                  unsigned           oldShareSize);

void RDPCALL OE_UpdateShm(void);

BOOL RDPCALL OEDetermineOrderSupport(void);

void RDPCALL OEEnumOrdersCaps(LOCALPERSONID, UINT_PTR, PTS_CAPABILITYHEADER);


#ifdef __cplusplus

/****************************************************************************/
/* OE_Term                                                                  */
/****************************************************************************/
void RDPCALL OE_Term(void)
{
}


#endif  // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\apmafn.h ===
/****************************************************************************/
// apmafn.h
//
// Function prototypes for PM API functions
//
// Copyright (c) Microsoft 1996 - 1999
/****************************************************************************/

void RDPCALL PM_Init(void);

void RDPCALL PM_SyncNow(void);

BOOL RDPCALL PM_MaybeSendPalettePacket(PPDU_PACKAGE_INFO pPkgInfo);

#ifdef NotUsed
void CALLBACK PMEnumPMCaps(
        LOCALPERSONID        locPersonID,
        PTS_CAPABILITYHEADER pCapabilities);
#endif


#ifdef __cplusplus

/****************************************************************************/
/* PM_Term()                                                                */
/* Terminates the Palette Manager.                                          */
/****************************************************************************/
void RDPCALL SHCLASS PM_Term(void)
{
}


/****************************************************************************/
/* PM_PartyJoiningShare()                                                   */
/*                                                                          */
/* Called when a new party is joining the share.                            */
/*                                                                          */
/* PARAMETERS:                                                              */
/*                                                                          */
/* locPersonID - local person ID of remote person joining the share.        */
/*                                                                          */
/* oldShareSize - the number of the parties which were in the share (ie     */
/* excludes the joining party).                                             */
/*                                                                          */
/* RETURNS: TRUE if the party can join the share.                           */
/*          FALSE if the party can NOT join the share.                      */
/****************************************************************************/
BOOL RDPCALL PM_PartyJoiningShare(
        LOCALPERSONID locPersonID,
        unsigned      oldShareSize)
{
//    if (locPersonID != SC_LOCAL_PERSON_ID) {
        // Renegotiate capabilities (including protocol level and cache size).
        // NOTE: No action taken at this time.
//    }

    return TRUE;
}


/****************************************************************************/
/* PM_PartyLeftShare()                                                      */
/*                                                                          */
/* Cursor Manager function called when a party has left the share.          */
/*                                                                          */
/* PARAMETERS:                                                              */
/*                                                                          */
/* locPersonID - local person ID of remote person leaving the share.        */
/*                                                                          */
/* newShareSize - the number of the parties now in the share (ie excludes   */
/* the leaving party).                                                      */
/****************************************************************************/
void RDPCALL PM_PartyLeftShare(
        LOCALPERSONID locPersonID,
        unsigned      newShareSize)
{
}


#endif  // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\aordprot.h ===
/****************************************************************************/
// aordprot.h
//
// Generic order transmission protocol structures
//
// Copyright(c) Microsoft, PictureTel 1993-1996
// Copyright(c) Microsoft 1997-1999
/****************************************************************************/
#ifndef _H_AORDPROT
#define _H_AORDPROT


/****************************************************************************/
/* All rectangles are inclusive of start and end points.                    */
/*                                                                          */
/* All points are in screen coordinates, with (0,0) at top left.            */
/*                                                                          */
/* Interpretation of individual field values is as in Windows               */
/*      in particular pens, brushes and font are as defined for Windows 3.1 */
/****************************************************************************/

/****************************************************************************/
// NUM_XXX_FIELDS is a constant used to determine the number of bytes used
// for field flags. Must not exceed (TS_MAX_ENC_FIELDS - 1) -- one is added
// to the constant before dividing by 8 for historical reasons.
//
// MAX_XXX_FIELD_SIZE is a constant used to estimate order-heap-to-
// network-buffer translation size. It is the maximum size of all the fields
// of the order as defined in its translation table in oe2data.c.
/****************************************************************************/

#define ORD_LEVEL_1_ORDERS 1


/****************************************************************************/
// Maximum-sized intermediate order representation.
/****************************************************************************/
#define MAX_ORDER_INTFMT_SIZE  sizeof(MULTI_PATBLT_ORDER)

/****************************************************************************/
/*                                                                          */
/* Support for Multiple Clipping Rectangles in one Order                    */
/*                                                                          */
/****************************************************************************/
/* The maximum number of clipping rectangles we encode.                     */
/****************************************************************************/
#define ORD_MAX_ENCODED_CLIP_RECTS      45

/****************************************************************************/
/* Max # of bytes needed to encode the max # of points, which is            */
/* - 2 bytes per co-ord                                                     */
/* - 4 coords per rectangle                                                 */
/****************************************************************************/
#define ORD_MAX_CLIP_RECTS_CODEDDELTAS_LEN \
         (ORD_MAX_ENCODED_CLIP_RECTS * 2 * 4)

/****************************************************************************/
/* Max # of bytes used to encode zero flags for the number of entries       */
/* above.  In caclulating this number we allow for                          */
/* - one bit for each coordinate to signal that the corresponding entry is  */
/*   absent and zero                                                        */
/* - four coordinates per rectangle                                         */
/* - rounding up to a whole number of bytes                                 */
/****************************************************************************/
#define ORD_MAX_CLIP_RECTS_ZERO_FLAGS_BYTES \
        (((ORD_MAX_ENCODED_CLIP_RECTS * 4) + 7) / 8)

// Maximum size of wire-format encoding for a delta list. Includes the
// 2-byte length count and max size of max number of rects and zero flags.
#define MAX_CLIPRECTS_FIELD_SIZE (sizeof(UINT16) + \
        ORD_MAX_CLIP_RECTS_CODEDDELTAS_LEN + \
        ORD_MAX_CLIP_RECTS_ZERO_FLAGS_BYTES)

// Flags used in encode/decode.
#define ORD_CLIP_RECTS_LONG_DELTA   0x80

#define ORD_CLIP_RECTS_XLDELTA_ZERO 0x80
#define ORD_CLIP_RECTS_YTDELTA_ZERO 0x40
#define ORD_CLIP_RECTS_XRDELTA_ZERO 0x20
#define ORD_CLIP_RECTS_YBDELTA_ZERO 0x10

typedef struct _CLIP_RECT_VARIABLE_CODEDDELTALIST
{
    UINT32 len;  // Byte count of encoded deltas.

    /************************************************************************/
    /* Leave enough space for the encoded points and the associated         */
    /* zero-flags.                                                          */
    /************************************************************************/
    BYTE Deltas[ORD_MAX_CLIP_RECTS_CODEDDELTAS_LEN +
                    ORD_MAX_CLIP_RECTS_ZERO_FLAGS_BYTES];

} CLIP_RECT_VARIABLE_CODEDDELTALIST, *PCLIP_RECT_VARIABLE_CODEDDELTALIST;


/****************************************************************************/
/* DstBlt (Destination only Screen Blt)                                     */
/****************************************************************************/
#define NUM_DSTBLT_FIELDS 5
#define MAX_DSTBLT_FIELD_SIZE 9
typedef struct _DSTBLT_ORDER
{
    INT32  nLeftRect;      /* x upper left */
    INT32  nTopRect;       /* y upper left */
    INT32  nWidth;         /* dest width   */
    INT32  nHeight;        /* dest height  */

    BYTE   bRop;           /* ROP */
    char   pad2[3];
} DSTBLT_ORDER, * LPDSTBLT_ORDER;


/****************************************************************************/
/* MultiDstBlt (DstBlt with multiple clipping rectangles)                   */
/****************************************************************************/
#define NUM_MULTI_DSTBLT_FIELDS 7
#define MAX_MULTI_DSTBLT_FIELD_SIZE (MAX_DSTBLT_FIELD_SIZE + 1 + \
        MAX_CLIPRECTS_FIELD_SIZE)
#define MAX_MULTI_DSTBLT_FIELD_SIZE_NCLIP(_NumClipRects) \
        (MAX_DSTBLT_FIELD_SIZE + 1 + (((_NumClipRects) + 1) / 2) + \
        (8 * (_NumClipRects)))
typedef struct _MULTI_DSTBLT_ORDER
{
    INT32  nLeftRect;      /* x upper left */
    INT32  nTopRect;       /* y upper left */
    INT32  nWidth;         /* dest width   */
    INT32  nHeight;        /* dest height  */

    BYTE   bRop;           /* ROP */
    char   pad2[3];

    UINT32 nDeltaEntries;  /* Sized to contain max num of entries */
    CLIP_RECT_VARIABLE_CODEDDELTALIST
        codedDeltaList; /* Contains encoded points */
} MULTI_DSTBLT_ORDER, * LPMULTI_DSTBLT_ORDER;


/****************************************************************************/
/* PatBlt (Pattern to Screen Blt)                                           */
/****************************************************************************/
#define NUM_PATBLT_FIELDS 12
#define MAX_PATBLT_FIELD_SIZE 26
typedef struct _PATBLT_ORDER
{
    INT32   nLeftRect;      /* x upper left */
    INT32   nTopRect;       /* y upper left */
    INT32   nWidth;         /* dest width   */
    INT32   nHeight;        /* dest height  */

    UINT32  bRop;           /* ROP */

    DCCOLOR BackColor;
    char    pad2;
    DCCOLOR ForeColor;
    char    pad3;

    INT32   BrushOrgX;
    INT32   BrushOrgY;
    UINT32  BrushStyle;
    UINT32  BrushHatch;
    BYTE    BrushExtra[7];
    char    pad4;
} PATBLT_ORDER, *LPPATBLT_ORDER;


/****************************************************************************/
/* MultiPatBlt (Pattern to Screen Blt with multiple clipping rectangles)    */
/****************************************************************************/
#define NUM_MULTI_PATBLT_FIELDS 14
#define MAX_MULTI_PATBLT_FIELD_SIZE (MAX_PATBLT_FIELD_SIZE + 1 + \
        MAX_CLIPRECTS_FIELD_SIZE)
#define MAX_MULTI_PATBLT_FIELD_SIZE_NCLIP(_NumClipRects) \
        (MAX_PATBLT_FIELD_SIZE + 1 + (((_NumClipRects) + 1) / 2) + \
        (8 * (_NumClipRects)))
typedef struct _MULTI_PATBLT_ORDER
{
    INT32   nLeftRect;      /* x upper left */
    INT32   nTopRect;       /* y upper left */
    INT32   nWidth;         /* dest width   */
    INT32   nHeight;        /* dest height  */

    UINT32  bRop;           /* ROP */

    DCCOLOR BackColor;
    char    pad2;
    DCCOLOR ForeColor;
    char    pad3;

    INT32   BrushOrgX;
    INT32   BrushOrgY;
    UINT32  BrushStyle;
    UINT32  BrushHatch;
    BYTE    BrushExtra[7];
    char    pad4;

    UINT32  nDeltaEntries;  /* Sized to contain max num of entries */
    CLIP_RECT_VARIABLE_CODEDDELTALIST
            codedDeltaList; /* Contains encoded points */
} MULTI_PATBLT_ORDER, * LPMULTI_PATBLT_ORDER;


/****************************************************************************/
/* ScrBlt (Screen to Screen Blt)                                            */
/****************************************************************************/
#define NUM_SCRBLT_FIELDS 7
#define MAX_SCRBLT_FIELD_SIZE 13
typedef struct _SCRBLT_ORDER
{
    INT32  nLeftRect;      /* x upper left */
    INT32  nTopRect;       /* y upper left */
    INT32  nWidth;         /* dest width   */
    INT32  nHeight;        /* dest height  */

    UINT32 bRop;           /* ROP */

    INT32  nXSrc;
    INT32  nYSrc;
} SCRBLT_ORDER, *LPSCRBLT_ORDER;


/****************************************************************************/
/* MultiScrBlt (Screen to Screen Blt with multiple clipping rectangles)     */
/****************************************************************************/
#define NUM_MULTI_SCRBLT_FIELDS 9
#define MAX_MULTI_SCRBLT_FIELD_SIZE (MAX_SCRBLT_FIELD_SIZE + 1 + \
        MAX_CLIPRECTS_FIELD_SIZE)
#define MAX_MULTI_SCRBLT_FIELD_SIZE_NCLIP(_NumClipRects) \
        (MAX_SCRBLT_FIELD_SIZE + 1 + (((_NumClipRects) + 1) / 2) + \
        (8 * (_NumClipRects)))
typedef struct _MULTI_SCRBLT_ORDER
{
    INT32  nLeftRect;      /* x upper left */
    INT32  nTopRect;       /* y upper left */
    INT32  nWidth;         /* dest width   */
    INT32  nHeight;        /* dest height  */

    UINT32 bRop;           /* ROP */

    INT32  nXSrc;
    INT32  nYSrc;

    UINT32 nDeltaEntries;  /* Sized to contain max num of entries */
    CLIP_RECT_VARIABLE_CODEDDELTALIST
            codedDeltaList; /* Contains encoded points */
} MULTI_SCRBLT_ORDER, * LPMULTI_SCRBLT_ORDER;


/****************************************************************************/
/* LineTo                                                                   */
/****************************************************************************/
#define NUM_LINETO_FIELDS 10
#define MAX_LINETO_FIELD_SIZE 19
typedef struct _LINETO_ORDER
{
    INT32   BackMode;       /* background mix mode                   */

    INT32   nXStart;        /* x line start                          */
    INT32   nYStart;        /* y line start                          */
    INT32   nXEnd;          /* x line end                            */
    INT32   nYEnd;          /* y line end                            */

    DCCOLOR BackColor;      /* background color                      */
    char    pad2;

    UINT32  ROP2;           /* drawing mode                          */

    UINT32  PenStyle;
    UINT32  PenWidth;       /* always 1 - field retained for         */
                                /* backwards compatibility               */
    DCCOLOR PenColor;
    char    pad3;
} LINETO_ORDER, *LPLINETO_ORDER;


/****************************************************************************/
/* OpaqueRect                                                               */
/****************************************************************************/
#define NUM_OPAQUERECT_FIELDS 7
#define MAX_OPAQUERECT_FIELD_SIZE 11
typedef struct _OPAQUE_RECT
{
    INT32   nLeftRect;      /* x upper left                          */
    INT32   nTopRect;       /* y upper left                          */
    INT32   nWidth;         /* dest width                            */
    INT32   nHeight;        /* dest height                           */

    DCCOLOR Color;          /* opaque color                          */
    char    pad2;
} OPAQUERECT_ORDER, * LPOPAQUERECT_ORDER;


/****************************************************************************/
// MultiOpaqueRect (OpaqueRect with multiple clipping rectangles).
/****************************************************************************/
#define NUM_MULTI_OPAQUERECT_FIELDS 9
#define MAX_MULTI_OPAQUERECT_FIELD_SIZE (MAX_OPAQUERECT_FIELD_SIZE + 1 + \
        MAX_CLIPRECTS_FIELD_SIZE)
#define MAX_MULTI_OPAQUERECT_FIELD_SIZE_NCLIP(_NumClipRects) \
        (MAX_OPAQUERECT_FIELD_SIZE + 1 + (((_NumClipRects) + 1) / 2) + \
        (8 * (_NumClipRects)))
typedef struct _MULTI_OPAQUE_RECT
{
    INT32   nLeftRect;      /* x upper left                          */
    INT32   nTopRect;       /* y upper left                          */
    INT32   nWidth;         /* dest width                            */
    INT32   nHeight;        /* dest height                           */

    DCCOLOR Color;          /* opaque color                          */
    char    pad2;

    UINT32  nDeltaEntries;  /* Sized to contain max num of entries */
    CLIP_RECT_VARIABLE_CODEDDELTALIST
                codedDeltaList; /* Contains encoded points */
} MULTI_OPAQUERECT_ORDER, * LPMULTI_OPAQUERECT_ORDER;


/****************************************************************************/
/* SaveBitmap (incorporating RestoreBitmap)                                 */
/****************************************************************************/
#define SV_SAVEBITS      0
#define SV_RESTOREBITS   1

#define NUM_SAVEBITMAP_FIELDS 6
#define MAX_SAVEBITMAP_FIELD_SIZE 13
typedef struct _SAVEBITMAP_ORDER
{
    UINT32 SavedBitmapPosition;

    INT32  nLeftRect;      /* x left   */
    INT32  nTopRect;       /* y top    */
    INT32  nRightRect;     /* x right  */
    INT32  nBottomRect;    /* y bottom */

    UINT32 Operation;      /* SV_xxxxxxxx                              */
} SAVEBITMAP_ORDER, * LPSAVEBITMAP_ORDER;


/****************************************************************************/
/* Common fields for MEMBLT and MEM3BLT (R2 only - R1 is unused).           */
/****************************************************************************/
typedef struct _MEMBLT_COMMON
{
    UINT16 cacheId;
    UINT16 cacheIndex;

    INT32  nLeftRect;      /* x upper left */
    INT32  nTopRect;       /* y upper left */
    INT32  nWidth;         /* dest width   */
    INT32  nHeight;        /* dest height  */

    UINT32 bRop;           /* ROP */

    INT32  nXSrc;
    INT32  nYSrc;
} MEMBLT_COMMON, *PMEMBLT_COMMON;


/****************************************************************************/
/* MemBlt (Memory to Screen Blt). "R2" is historical, the rev 1 version was */
/* from an old DCL product, never used in RDP.                              */
/****************************************************************************/
#define NUM_MEMBLT_FIELDS 9
#define MAX_MEMBLT_FIELD_SIZE 17
typedef struct _MEMBLT_R2_ORDER
{
    // This structure needs to be at the same offset as in Mem3Blt_R2.
    MEMBLT_COMMON Common;
} MEMBLT_R2_ORDER, *PMEMBLT_R2_ORDER;


/****************************************************************************/
/* Mem3Blt (Memory to Screen Blt with ROP3). "R2" is historical, the rev 1  */
/* version was from an old DCL product, never used in RDP.                  */
/****************************************************************************/
#define NUM_MEM3BLT_FIELDS 16
#define MAX_MEM3BLT_FIELD_SIZE (MAX_MEMBLT_FIELD_SIZE + 19)
typedef struct _MEM3BLT_R2_ORDER
{
    // This structure needs to be at the same offset as in MemBlt_R2.
    MEMBLT_COMMON Common;

    DCCOLOR BackColor;
    char    pad1;
    DCCOLOR ForeColor;
    char    pad2;

    INT32   BrushOrgX;
    INT32   BrushOrgY;
    UINT32  BrushStyle;
    UINT32  BrushHatch;
    BYTE    BrushExtra[7];
    char    pad3;
} MEM3BLT_R2_ORDER, *PMEM3BLT_R2_ORDER;


/****************************************************************************/
// PolyLine - designed to handle sets of connected width-1 cosmetic lines.
/****************************************************************************/

// The maximum number of delta points we encode.
#define ORD_MAX_POLYLINE_ENCODED_POINTS 32

// Max # of bytes needed to encode the max # of points, which is 4 bytes
// each.
#define ORD_MAX_POLYLINE_CODEDDELTAS_LEN (ORD_MAX_POLYLINE_ENCODED_POINTS * 4)

// Max # of bytes used to encode zero flags for the number of entries
// above. Each new point has two bits -- one for each coordinate -- to
// signal that the corresponding entry is absent and zero. Note we must
// round up if max points is not a multiple of 4.
#define ORD_MAX_POLYLINE_ZERO_FLAGS_BYTES \
        ((ORD_MAX_POLYLINE_ENCODED_POINTS + 3) / 4)

// This is the equivent set of macros as polyline above, the only difference
// is that we can encode 56 points instead of 32.
#define ORD_MAX_POLYGON_ENCODED_POINTS 56

#define ORD_MAX_POLYGON_CODEDDELTAS_LEN (ORD_MAX_POLYGON_ENCODED_POINTS * 4)

#define ORD_MAX_POLYGON_ZERO_FLAGS_BYTES \
        ((ORD_MAX_POLYGON_ENCODED_POINTS + 3) / 4)

// Flags used in encode/decode.
#define ORD_POLYLINE_LONG_DELTA  0x80
#define ORD_POLYLINE_XDELTA_ZERO 0x80
#define ORD_POLYLINE_YDELTA_ZERO 0x40

typedef struct _VARIABLE_CODEDDELTALIST
{
    UINT32 len;  // Byte count of encoded deltas.

    // Leave enough space for the encoded points and the associated
    // zero-flags.
    BYTE Deltas[ORD_MAX_POLYLINE_CODEDDELTAS_LEN +
                ORD_MAX_POLYLINE_ZERO_FLAGS_BYTES];
} VARIABLE_CODEDDELTALIST, *PVARIABLE_CODEDDELTALIST;

#define NUM_POLYLINE_FIELDS 7
#define MAX_POLYLINE_BASE_FIELDS_SIZE 11
#define MAX_POLYLINE_FIELD_SIZE (11 + 1 + ORD_MAX_POLYLINE_CODEDDELTAS_LEN + \
        ORD_MAX_POLYLINE_ZERO_FLAGS_BYTES)

typedef struct _POLYLINE_ORDER
{
    INT32   XStart;         /* x line start                          */
    INT32   YStart;         /* y line start                          */

    UINT32  ROP2;           /* drawing mode                          */

    UINT32  BrushCacheEntry;
    DCCOLOR PenColor;
    char    pad2;

    UINT32 NumDeltaEntries;  // Sized to contain max num of entries.
    VARIABLE_CODEDDELTALIST CodedDeltaList;  // Filled in with encoded points.
} POLYLINE_ORDER, *PPOLYLINE_ORDER;

// 
// PolyGon Orders
//
typedef struct _POLYGON_CODEDDELTALIST
{
    UINT32 len;  // Byte count of encoded deltas.

    // Leave enough space for the encoded points and the associated
    // zero-flags.
    BYTE Deltas[ORD_MAX_POLYGON_CODEDDELTAS_LEN +
                ORD_MAX_POLYGON_ZERO_FLAGS_BYTES];
} POLYGON_CODEDDELTALIST, *PPOLYGON_CODEDDELTALIST;

#define NUM_POLYGON_CB_FIELDS 13
#define MAX_POLYGON_CB_FIELD_SIZE (24 + 1 + ORD_MAX_POLYGON_CODEDDELTAS_LEN + \
        ORD_MAX_POLYGON_ZERO_FLAGS_BYTES)
#define MAX_POLYGON_CB_BASE_FIELDS_SIZE 24

// polygon order with solid color brush
typedef struct _POLYGON_CB_ORDER
{
    INT32   XStart;         /* x start point                          */
    INT32   YStart;         /* y start point                          */

    UINT32  ROP2;           /* drawing mode                           */

    UINT32  FillMode;       /* either winding mode or alternate mode  */

    DCCOLOR BackColor;
    char    pad2;
    DCCOLOR ForeColor;
    char    pad3;

    INT32   BrushOrgX;
    INT32   BrushOrgY;
    UINT32  BrushStyle;
    UINT32  BrushHatch;
    BYTE    BrushExtra[7];
    char    pad4;

    UINT32 NumDeltaEntries;  // Sized to contain max num of entries.
    POLYGON_CODEDDELTALIST CodedDeltaList;  // Filled in with encoded points.
} POLYGON_CB_ORDER, *PPOLYGON_CB_ORDER;


#define NUM_POLYGON_SC_FIELDS 7
#define MAX_POLYGON_SC_FIELD_SIZE (10 + 1 + ORD_MAX_POLYGON_CODEDDELTAS_LEN + \
        ORD_MAX_POLYGON_ZERO_FLAGS_BYTES)
#define MAX_POLYGON_SC_BASE_FIELDS_SIZE 10

// polygon order with color pattern brush
typedef struct _POLYGON_SC_ORDER
{
    INT32   XStart;         /* x start point                          */
    INT32   YStart;         /* y start point                          */

    UINT32  ROP2;           /* drawing mode                           */

    UINT32  FillMode;       /* either winding mode or alternate  mode */

    DCCOLOR BrushColor;
    char    pad2;

    UINT32 NumDeltaEntries;  // Sized to contain max num of entries.
    POLYGON_CODEDDELTALIST CodedDeltaList;  // Filled in with encoded points.
} POLYGON_SC_ORDER, *PPOLYGON_SC_ORDER;

//
// Ellipse orders
//
#define NUM_ELLIPSE_SC_FIELDS 7
#define MAX_ELLIPSE_SC_FIELD_SIZE 13

// ellipse order with solid color brush or pen
typedef struct _ELLIPSE_SC_ORDER
{
   INT32   LeftRect;        // bounding rect
   INT32   TopRect;
   INT32   RightRect;
   INT32   BottomRect;

   UINT32  ROP2;            // drawing mode
   UINT32  FillMode;

   DCCOLOR Color;           // pen or brush color
   char    pad1;
} ELLIPSE_SC_ORDER, *PELLIPSE_SC_ORDER;

#define NUM_ELLIPSE_CB_FIELDS 13
#define MAX_ELLIPSE_CB_FIELD_SIZE 27

// ellipse order with color pattern brush
typedef struct _ELLIPSE_CB_ORDER
{
   INT32   LeftRect;        // bounding rect
   INT32   TopRect;
   INT32   RightRect;
   INT32   BottomRect;

   UINT32  ROP2;            // drawing mode
   UINT32  FillMode;

   DCCOLOR BackColor;       // pattern brush
   char    pad2;
   DCCOLOR ForeColor;
   char    pad3;

   INT32   BrushOrgX;
   INT32   BrushOrgY;
   UINT32  BrushStyle;
   UINT32  BrushHatch;
   BYTE    BrushExtra[7];
   char    pad4;
} ELLIPSE_CB_ORDER, *PELLIPSE_CB_ORDER;


/****************************************************************************/
// Glyph index.
/****************************************************************************/

// Index order fragment add/use encoding values.
#define ORD_INDEX_FRAGMENT_ADD      0xff
#define ORD_INDEX_FRAGMENT_USE      0xfe

// Variable length array used by Glyph indexes.
typedef struct tagVARIABLE_INDEXREC
{
    BYTE     byte;
} VARIABLE_INDEXREC, * LPVARIABLE_INDEXREC;

// Variable length array used by Glyph indexes.
typedef struct tagVARIABLE_INDEXBYTES
{
    UINT32 len;          /* array count */
    VARIABLE_INDEXREC arecs[255];
} VARIABLE_INDEXBYTES, * LPVARIABLE_INDEXBYTES;


#define NUM_INDEX_FIELDS 22
#define MAX_INDEX_FIELD_SIZE (41 + 1 + 255)
#define MAX_INDEX_FIELD_SIZE_DATASIZE(_DataSize) (41 + 1 + (_DataSize))
typedef struct _INDEX_ORDER
{
    BYTE    cacheId;
    char    pad1;
    BYTE    flAccel;
    BYTE    ulCharInc;


    DCCOLOR BackColor;
    char    pad2;
    DCCOLOR ForeColor;
    char    pad3;

    INT32   BkLeft;
    INT32   BkTop;
    INT32   BkRight;
    INT32   BkBottom;

    INT32   OpLeft;
    INT32   OpTop;
    INT32   OpRight;
    INT32   OpBottom;

    INT32   x;
    INT32   y;

    INT32   BrushOrgX;
    INT32   BrushOrgY;
    UINT32  BrushStyle;
    UINT32  BrushHatch;
    BYTE    BrushExtra[7];
    BYTE    fOpRedundant;

    VARIABLE_INDEXBYTES variableBytes;
} INDEX_ORDER, *LPINDEX_ORDER;

#define NUM_FAST_INDEX_FIELDS 15
#define MAX_FAST_INDEX_FIELD_SIZE (29 + 1 + 255)
#define MAX_FAST_INDEX_FIELD_SIZE_DATASIZE(_DataSize) (29 + 1 + (_DataSize))
typedef struct _FAST_INDEX_ORDER
{
    BYTE    cacheId;
    char    pad1;
    UINT16  fDrawing;

    DCCOLOR BackColor;
    char    pad2;
    DCCOLOR ForeColor;
    char    pad3;

    INT32   BkLeft;
    INT32   BkTop;
    INT32   BkRight;
    INT32   BkBottom;

    INT32   OpLeft;
    INT32   OpTop;
    INT32   OpRight;
    INT32   OpBottom;

    INT32   x;
    INT32   y;

    VARIABLE_INDEXBYTES variableBytes;
} FAST_INDEX_ORDER, *LPFAST_INDEX_ORDER;

// Variable length array used by Glyph data.
typedef struct tagVARIABLE_GLYPHBYTES
{
    UINT32 len;          /* array count */
    BYTE   glyphData[255];
} VARIABLE_GLYPHBYTES, * LPVARIABLE_GLYPHBYTES;


#define NUM_FAST_GLYPH_FIELDS 15
#define MAX_FAST_GLYPH_FIELD_SIZE (29 + 1 + 255)
#define MAX_FAST_GLYPH_FIELD_SIZE_DATASIZE(_DataSize) (29 + 1 + (_DataSize))
typedef struct _FAST_GLYPH_ORDER
{
    BYTE    cacheId;
    char    pad1;
    UINT16  fDrawing;

    DCCOLOR BackColor;
    char    pad2;
    DCCOLOR ForeColor;
    char    pad3;

    INT32   BkLeft;
    INT32   BkTop;
    INT32   BkRight;
    INT32   BkBottom;

    INT32   OpLeft;
    INT32   OpTop;
    INT32   OpRight;
    INT32   OpBottom;

    INT32   x;
    INT32   y;

    VARIABLE_GLYPHBYTES variableBytes;
} FAST_GLYPH_ORDER, *LPFAST_GLYPH_ORDER;

#ifdef DRAW_NINEGRID
/****************************************************************************/
// DrawNineGrid
/****************************************************************************/

#define NUM_DRAWNINEGRID_FIELDS 5
#define MAX_DRAWNINEGRID_FIELD_SIZE 10
typedef struct _DRAWNINEGRID
{
    INT32   srcLeft;     
    INT32   srcTop;      
    INT32   srcRight;    
    INT32   srcBottom;  
    
    UINT16  bitmapId;
    UINT16  pad1;

} DRAWNINEGRID_ORDER, * LPDRAWNINEGRID_ORDER;

/****************************************************************************/
// MultiDrawNineGrid (DrawNineGrid with multiple clipping rectangles).
/****************************************************************************/
#define NUM_MULTI_DRAWNINEGRID_FIELDS 7
#define MAX_MULTI_DRAWNINEGRID_FIELD_SIZE (MAX_DRAWNINEGRID_FIELD_SIZE + 1 + \
        MAX_CLIPRECTS_FIELD_SIZE)
#define MAX_MULTI_DRAWNINEGRID_FIELD_SIZE_NCLIP(_NumClipRects) \
        (MAX_DRAWNINEGRID_FIELD_SIZE + 1 + (((_NumClipRects) + 1) / 2) + \
        (8 * (_NumClipRects)))
typedef struct _MULTI_DRAWNINEGRID_RECT
{
    INT32   srcLeft;     
    INT32   srcTop;      
    INT32   srcRight;    
    INT32   srcBottom;  
    
    UINT16  bitmapId;
    UINT16  pad1;

    UINT32  nDeltaEntries;  /* Sized to contain max num of entries */
    CLIP_RECT_VARIABLE_CODEDDELTALIST
                codedDeltaList; /* Contains encoded points */
} MULTI_DRAWNINEGRID_ORDER, * LPMULTI_DRAWNINEGRID_ORDER;
#endif

#endif /* _H_AORDPROT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\aprot.h ===
/****************************************************************************/
/* aprot.h                                                                  */
/*                                                                          */
/* RDP network packet protocol header file.                                 */
/*                                                                          */
/* Copyright(c) Microsoft, PictureTel 1992-1996                             */
/* (C) 1997-1999 Microsoft Corp.                                            */
/****************************************************************************/
#ifndef _H_APROT
#define _H_APROT


/****************************************************************************/
/* The priorities used by RDP                                               */
/****************************************************************************/
#define PROT_PRIO_UPDATES                1
#define PROT_PRIO_INPUT                  2
#define PROT_PRIO_MISC                   2
#define PROT_PRIO_HIGH                   3

#define PROT_PRIO_COUNT                  3



#endif /* _H_APROT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\aoeapi.h ===
/****************************************************************************/
// aoeapi.h
//
// RDP Order Encoder API functions.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/
#ifndef _H_AOEAPI
#define _H_AOEAPI


/****************************************************************************/
// OE_SHARED_DATA
//
// Transfer structure for values from WD to DD.
/****************************************************************************/
typedef struct tagOE_SHARED_DATA
{
    // Set if the following members have valid data.
    BOOLEAN newCapsData;

    // TRUE if only solid and pattern brushes supported,
    BOOLEAN sendSolidPatternBrushOnly;

    // Send colors as indices not RGB.
    BOOLEAN colorIndices;

    // Array of order support flags.
    BYTE *orderSupported;
} OE_SHARED_DATA, *POE_SHARED_DATA;



#endif /* ndef _H_AOEAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\apmapi.h ===
/****************************************************************************/
/* apmapi.h                                                                 */
/*                                                                          */
/* RDP Palette Manager API Header File.                                     */
/*                                                                          */
/* Copyright(c) Microsoft, PictureTel 1992-1996                             */
/* (C) 1997-1999 Microsoft Corp.                                            */
/****************************************************************************/
#ifndef _H_APMAPI
#define _H_APMAPI


#define PM_NUM_8BPP_PAL_ENTRIES         256


/****************************************************************************/
/* Structure:   PM_SHARED_DATA                                              */
/*                                                                          */
/* Description: Palette Manager data shared between display driver and WD.  */
/****************************************************************************/
typedef struct tagPM_SHARED_DATA
{
    RGBQUAD palette[PM_NUM_8BPP_PAL_ENTRIES];
    BOOL    paletteChanged;
} PM_SHARED_DATA, *PPM_SHARED_DATA;



#endif   /* #ifndef _H_APMAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\asbcafn.h ===
/****************************************************************************/
// asbcafn.h
//
// Function prototypes for SBC functions
//
// Copyright (C) 1996-2000 Microsoft Corporation
/****************************************************************************/

void RDPCALL SBC_Init(void);

void RDPCALL SBC_Term(void);

BOOLEAN RDPCALL SBC_PartyJoiningShare(LOCALPERSONID, unsigned);

void RDPCALL SBC_PartyLeftShare(LOCALPERSONID, unsigned);

void RDPCALL SBC_SyncUpdatesNow(void);

void RDPCALL SBC_UpdateShm(void);

void RDPCALL SBC_HandlePersistentCacheList(TS_BITMAPCACHE_PERSISTENT_LIST *,
        unsigned, LOCALPERSONID);

void RDPCALL SBC_HandleBitmapCacheErrorPDU(TS_BITMAPCACHE_ERROR_PDU *,
        unsigned, LOCALPERSONID);

void RDPCALL SBC_HandleOffscrCacheErrorPDU(TS_OFFSCRCACHE_ERROR_PDU *,
        unsigned, LOCALPERSONID);

#ifdef DRAW_NINEGRID
void RDPCALL SBC_HandleDrawNineGridErrorPDU(TS_DRAWNINEGRID_ERROR_PDU *,
        unsigned, LOCALPERSONID);
#endif

#ifdef DRAW_GDIPLUS
void RDPCALL SBC_HandleDrawGdiplusErrorPDU(TS_DRAWGDIPLUS_ERROR_PDU *,
        unsigned, LOCALPERSONID);
#endif

void RDPCALL SBC_DumpBitmapKeyDatabase(BOOLEAN);

void RDPCALL SBC_DumpMRUList(CHCACHEHANDLE, void *);

BOOLEAN RDPCALL SBCRedetermineBitmapCacheSize(void);

BOOLEAN RDPCALL SBCRedetermineGlyphCacheSize(void);

BOOLEAN RDPCALL SBCRedetermineBrushSupport(void);

BOOLEAN RDPCALL SBCRedetermineOffscreenSupport(void);

#ifdef DRAW_NINEGRID
BOOLEAN RDPCALL SBCRedetermineDrawNineGridSupport(void);
#endif

#ifdef DRAW_GDIPLUS
BOOLEAN RDPCALL SBCRedetermineDrawGdiplusSupport(void);
#endif

void RDPCALL SBCEnumBitmapCacheCaps(LOCALPERSONID, UINT_PTR,
        PTS_CAPABILITYHEADER);

void CALLBACK SBCEnumGlyphCacheCaps(LOCALPERSONID, UINT_PTR,
        PTS_CAPABILITYHEADER);

void RDPCALL SBCCapabilitiesChanged(void);

void RDPCALL SBCEnumBrushCaps(LOCALPERSONID, UINT_PTR,
        PTS_CAPABILITYHEADER);

void RDPCALL SBCEnumOffscreenCaps(LOCALPERSONID, UINT_PTR,
        PTS_CAPABILITYHEADER);

#ifdef DRAW_NINEGRID
void RDPCALL SBCEnumDrawNineGridCaps(LOCALPERSONID, UINT_PTR,
        PTS_CAPABILITYHEADER);
#endif

#ifdef DRAW_GDIPLUS
void RDPCALL SBCEnumDrawGdiplusCaps(LOCALPERSONID, UINT_PTR,
        PTS_CAPABILITYHEADER);
#endif

void RDPCALL SBC_GetBitmapKeyDatabase(unsigned* keyDBSize, BYTE* pKeyDB);

void RDPCALL SBC_FreeBitmapKeyDatabase();

#ifdef __cplusplus

#endif  // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\asbcapi.h ===
/****************************************************************************/
// asbcapi.h
//
// Send Bitmap Cache API header.
//
// Copyright(c) Microsoft, PictureTel 1992-1996
// (C) 1997-2000 Microsoft Corp.
/****************************************************************************/
#ifndef _H_ASBCAPI
#define _H_ASBCAPI

#include <aoaapi.h>
#include <achapi.h>


/****************************************************************************/
/* sbcEnabled flags                                                         */
/****************************************************************************/
#define SBC_NO_CACHE_ENABLED     (0 << 0)

#define SBC_BITMAP_CACHE_ENABLED (1 << 0)
#define SBC_GLYPH_CACHE_ENABLED  (1 << 1)
#define SBC_BRUSH_CACHE_ENABLED  (1 << 2)
#define SBC_OFFSCREEN_CACHE_ENABLED (1 << 3)
#ifdef DRAW_NINEGRID
#define SBC_DRAWNINEGRID_CACHE_ENABLED (1 << 4)
#endif
#ifdef DRAW_GDIPLUS
#define SBC_DRAWGDIPLUS_CACHE_ENABLED (1 << 5)
#endif

/****************************************************************************/
/* Bitmap cache                                                             */
/****************************************************************************/
#define SBC_PROTOCOL_BPP            8
#define SBC_NUM_8BPP_COLORS         256
#define SBC_CACHE_0_DIMENSION       16
#define SBC_CACHE_0_DIMENSION_SHIFT 4

// Cache IDs have a protocol-implicit cell size, starting from 256 and
// increasing in factors of 4.
#ifdef DC_HICOLOR
#define SBC_CellSizeFromCacheID(_id)                   \
        ((TS_BITMAPCACHE_0_CELL_SIZE << (2 * (_id)))   \
           * ((sbcClientBitsPerPel + 7) / 8))
#else
#define SBC_CellSizeFromCacheID(_id) \
        (TS_BITMAPCACHE_0_CELL_SIZE << (2 * (_id)))
#endif



/****************************************************************************/
/* Glyph cache                                                              */
/****************************************************************************/
#define SBC_NUM_GLYPH_CACHES       10
#define CAPS_GLYPH_SUPPORT_NONE    0
#define CAPS_GLYPH_SUPPORT_PARTIAL 1
#define CAPS_GLYPH_SUPPORT_FULL    2
#define CAPS_GLYPH_SUPPORT_ENCODE  3

// Color table cache entries. Note the size of this cache is by consensus with
// the client -- we do not currently actually negotiate the color cache
// capabilities in TS_COLORTABLECACHE_CAPABILITYSET.
#define SBC_NUM_COLOR_TABLE_CACHE_ENTRIES 6


/****************************************************************************/
/* Define the maximum server cache sizes.                                   */
/*                                                                          */
/* These values are negotiated down with the client to determine the actual */
/* cache sizes used.                                                        */
/****************************************************************************/
#define SBC_GL_CACHE1_MAX_CELL_SIZE         2048
#define SBC_GL_CACHE2_MAX_CELL_SIZE         2048
#define SBC_GL_CACHE3_MAX_CELL_SIZE         2048
#define SBC_GL_CACHE4_MAX_CELL_SIZE         2048
#define SBC_GL_CACHE5_MAX_CELL_SIZE         2048
#define SBC_GL_CACHE6_MAX_CELL_SIZE         2048
#define SBC_GL_CACHE7_MAX_CELL_SIZE         2048
#define SBC_GL_CACHE8_MAX_CELL_SIZE         2048
#define SBC_GL_CACHE9_MAX_CELL_SIZE         2048
#define SBC_GL_CACHE10_MAX_CELL_SIZE        2048

#define SBC_GL_MAX_CACHE_ENTRIES            254


/****************************************************************************/
/* Fragment cache                                                           */
/****************************************************************************/
#define SBC_NUM_FRAG_CACHES 1


/****************************************************************************/
/* Define the maximum server cache sizes.                                   */
/*                                                                          */
/* These values are negotiated down with the client to determine the actual */
/* cache sizes used.                                                        */
/****************************************************************************/
#define SBC_FG_CACHE_MAX_CELL_SIZE          256
#define SBC_FG_CACHE_MAX_ENTRIES            256


/****************************************************************************/
// Reg keys and flags for disabling caches.
/****************************************************************************/
#define SBC_INI_CACHING_DISABLED  L"Caching Disabled"
#define SBC_DEFAULT_CACHING_DISABLED 0
#define SBC_DISABLE_BITMAP_CACHE 0x01
#define SBC_DISABLE_BRUSH_CACHE  0x02
#define SBC_DISABLE_GLYPH_CACHE  0x04
#define SBC_DISABLE_OFFSCREEN_CACHE 0x08
#ifdef DRAW_NINEGRID
#define SBC_DISABLE_DRAWNINEGRID_CACHE 0x10
#endif
#ifdef DRAW_GDIPLUS
#define SBC_DISABLE_DRAWGDIPLUS_CACHE 0x20
#endif

/****************************************************************************/
// Structure: SBC_BITMAP_CACHE_INFO
//
// Description: Information stored for each bitmap cache.
/****************************************************************************/
typedef struct tagSBC_BITMAP_CACHE_INFO
{
    CHCACHEHANDLE cacheHandle;

    CHCACHEHANDLE waitingListHandle;

    // flag indicates if the cache needs to be cleared
    unsigned fClearCache;

    TS_BITMAPCACHE_CELL_CACHE_INFO Info;

    // Work tile bitmap information - surface handle, pointer to the bitmap
    // bits.
    HSURF hWorkBitmap;
    BYTE  *pWorkBitmapBits;

#ifdef DC_DEBUG
    // Pointer to extra info array for each entry. Used to detect key
    // generation algorithm collisions.
    BYTE *pExtraEntryInfo;
#endif

} SBC_BITMAP_CACHE_INFO, *PSBC_BITMAP_CACHE_INFO;


/****************************************************************************/
/* Structure: SBC_GLYPH_CACHE_INFO                                          */
/*                                                                          */
/* Description: Information stored for each glyph cache.                    */
/****************************************************************************/
typedef struct tagSBC_GLYPH_CACHE_INFO
{
    CHCACHEHANDLE cacheHandle;
    unsigned      cbCellSize;
    unsigned      cbUseCount;
} SBC_GLYPH_CACHE_INFO, *PSBC_GLYPH_CACHE_INFO;


/****************************************************************************/
/* Structure: SBC_FRAG_CACHE_INFO                                           */
/*                                                                          */
/* Description: Information stored for each frag cache.                     */
/****************************************************************************/
typedef struct tagSBC_FRAG_CACHE_INFO
{
    CHCACHEHANDLE cacheHandle;
    unsigned      cbCellSize;
} SBC_FRAG_CACHE_INFO, *PSBC_FRAG_CACHE_INFO;


/****************************************************************************/
/* Structure: SBC_BRUSH_CACHE_INFO                                          */
/*                                                                          */
/* Description: Information stored for each brush cache.                    */
/****************************************************************************/
typedef struct tagSBC_BRUSH_CACHE_INFO
{
    CHCACHEHANDLE     cacheHandle;

} SBC_BRUSH_CACHE_INFO, *PSBC_BRUSH_CACHE_INFO;

/****************************************************************************/
// SBC_OFFSCREEN_BITMAP_CACHE_INFO
//
// Description: Information stored for the offscreen bitmap cache
/****************************************************************************/
typedef struct tagSBC_OFFSCREEN_BITMAP_CACHE_INFO
{
    unsigned supportLevel;
    unsigned cacheSize;
    unsigned cacheEntries;
} SBC_OFFSCREEN_BITMAP_CACHE_INFO, *PSBC_OFFSCREEN_BITMAP_CACHE_INFO;

#ifdef DRAW_NINEGRID
/****************************************************************************/
// SBC_DRAWNINEGRID_BITMAP_CACHE_INFO
//
// Description: Information stored for the drawninegrid bitmap cache
/****************************************************************************/
typedef struct tagSBC_DRAWNINEGRID_BITMAP_CACHE_INFO
{
    unsigned supportLevel;
    unsigned cacheSize;
    unsigned cacheEntries;
} SBC_DRAWNINEGRID_BITMAP_CACHE_INFO, *PSBC_DRAWNINEGRID_BITMAP_CACHE_INFO;
#endif

#ifdef DRAW_GDIPLUS
/****************************************************************************/
// SBC_DRAWGDIPLUS_INFO
//
// Description: Information stored for the drawgdiplus
/****************************************************************************/
typedef struct tagSBC_DRAWGDIPLUS_INFO
{
    unsigned supportLevel;
    unsigned GdipVersion;
    unsigned GdipCacheLevel;
    TS_GDIPLUS_CACHE_ENTRIES GdipCacheEntries;
    TS_GDIPLUS_CACHE_CHUNK_SIZE GdipCacheChunkSize;
    TS_GDIPLUS_IMAGE_CACHE_PROPERTIES GdipImageCacheProperties;
} SBC_DRAWGDIPLUS_INFO, *PSBC_DRAWGDIPLUS_INFO;
#endif


/****************************************************************************/
/* Structure: SBC_CACHE_SIZE                                                */
/*                                                                          */
/* Description:                                                             */
/****************************************************************************/
typedef struct tagSBC_CACHE_SIZE
{
    unsigned cEntries;
    unsigned cbCellSize;
} SBC_CACHE_SIZE, *PSBC_CACHE_SIZE;


/****************************************************************************/
// Structure: SBC_NEGOTIATED_CAPABILITIES
//
// Description:
/****************************************************************************/
typedef struct tagSBC_NEGOTIATED_CAPABILITIES
{
    SBC_CACHE_SIZE glyphCacheSize[SBC_NUM_GLYPH_CACHES];
    SBC_CACHE_SIZE fragCacheSize[SBC_NUM_FRAG_CACHES];
    UINT16 GlyphSupportLevel;
    UINT32 brushSupportLevel;
} SBC_NEGOTIATED_CAPABILITIES, *PSBC_NEGOTIATED_CAPABILITIES;


/****************************************************************************/
// SBC_BITMAP_CACHE_KEY_INFO
//
// Cache information required to hold either persistent bitmap cache keys
// sent from the client or to transition from a disconnect of a temporary
// login display driver instance to a reconnect to an existing display driver
// session.
/****************************************************************************/
typedef struct
{
    UINT32 Key1, Key2;
    unsigned CacheIndex;
} SBC_MRU_KEY, *PSBC_MRU_KEY;

typedef struct
{
    unsigned TotalKeys;
    unsigned NumKeys[TS_BITMAPCACHE_MAX_CELL_CACHES];
    unsigned KeyStart[TS_BITMAPCACHE_MAX_CELL_CACHES];
    unsigned pad;
    SBC_MRU_KEY Keys[1];
} SBC_BITMAP_CACHE_KEY_INFO, *PSBC_BITMAP_CACHE_KEY_INFO;


/****************************************************************************/
// Structure:   SBC_SHARED_DATA
//
// Description: SBC data shared between DD and WD.
/****************************************************************************/
typedef struct tagSBC_SHARED_DATA
{
    unsigned bUseRev2CacheBitmapOrder : 1;
    unsigned fCachingEnabled : 1;
    unsigned fClearCache : 1;
    unsigned newCapsData : 1;
    unsigned syncRequired : 1;
    unsigned fDisableOffscreen : 1;
#ifdef DRAW_NINEGRID
    unsigned fDisableDrawNineGrid : 1;
#endif
    unsigned fAllowCacheWaitingList : 1;
    unsigned NumBitmapCaches;
#ifdef DRAW_GDIPLUS
    unsigned fDisableDrawGdiplus: 1;
#endif
    CHCACHEHANDLE hFastPathCache;
    SBC_BITMAP_CACHE_INFO bitmapCacheInfo[TS_BITMAPCACHE_MAX_CELL_CACHES];

    SBC_GLYPH_CACHE_INFO        glyphCacheInfo[SBC_NUM_GLYPH_CACHES];
    SBC_FRAG_CACHE_INFO         fragCacheInfo[SBC_NUM_FRAG_CACHES];
    SBC_OFFSCREEN_BITMAP_CACHE_INFO offscreenCacheInfo;
#ifdef DRAW_NINEGRID
    SBC_DRAWNINEGRID_BITMAP_CACHE_INFO drawNineGridCacheInfo;
#endif
#ifdef DRAW_GDIPLUS
    SBC_DRAWGDIPLUS_INFO drawGdiplusInfo;
#endif
    SBC_NEGOTIATED_CAPABILITIES caps;
#ifdef DC_HICOLOR
    unsigned clientBitsPerPel;
#endif
} SBC_SHARED_DATA, *PSBC_SHARED_DATA;


#ifdef DC_DEBUG
/****************************************************************************/
// SBC_BITMAP_CACHE_EXTRA_INFO
//
// Information stored parallel to CH cache nodes for SBC bitmap caches.
/****************************************************************************/
typedef struct
{
     unsigned DataSize;
} SBC_BITMAP_CACHE_EXTRA_INFO;
#endif



#endif /* _H_ASBCAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\ascapi.h ===
/****************************************************************************/
/* ascapi.h                                                                 */
/*                                                                          */
/* Share Controller API Header File.                                        */
/*                                                                          */
/* Copyright(c) Microsoft, PictureTel 1992-1996                             */
/* (C) 1997-1999 Microsoft Corp.                                            */
/****************************************************************************/
#ifndef _H_ASCAPI
#define _H_ASCAPI

// Hardcoded max users in share, and PersonID values corresponding to them.
#define SC_DEF_MAX_PARTIES  3

#define SC_LOCAL_PERSON_ID  0
#define SC_REMOTE_PERSON_ID 1
#define SC_SHADOW_PERSON_ID 2


// Size of sample for MPPC compression statistics.
#define SC_SAMPLE_SIZE 65535



#endif   /* #ifndef _H_ASCAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\ascafn.h ===
/****************************************************************************/
// ascafn.h
//
// Function prototypes for SC functions
//
// Copyright (C) 1996-2000 Microsoft Corporation
/****************************************************************************/

BOOL RDPCALL SC_Init(PVOID);

void RDPCALL SC_Update();

void RDPCALL SC_Term(void);

BOOL RDPCALL SC_CreateShare(void);

#ifdef DC_HICOLOR
BOOL RDPCALL SC_ShadowSyncShares(PTS_COMBINED_CAPABILITIES pCaps,
                                 ULONG capsLen);
#else
BOOL RDPCALL SC_ShadowSyncShares(void);
#endif

void RDPCALL SC_EndShare(BOOLEAN);

void RDPCALL SC_OnDisconnected(UINT32);

void RDPCALL SC_OnDataReceived(PBYTE, NETPERSONID, unsigned, UINT32);

void RDPCALL SC_OnShadowDataReceived(PBYTE, NETPERSONID, unsigned, UINT32);

BOOL RDPCALL SC_SendData(PTS_SHAREDATAHEADER, UINT32, UINT32, UINT32,
        NETPERSONID);

NTSTATUS __fastcall SC_AllocBuffer(PPVOID, UINT32);

void __fastcall SC_FreeBuffer(PVOID);

NETPERSONID RDPCALL SC_GetMyNetworkPersonID(void);

NETPERSONID RDPCALL SC_LocalIDToNetworkID(LOCALPERSONID);

BOOL RDPCALL SC_IsLocalPersonID(LOCALPERSONID);

BOOL RDPCALL SC_IsNetworkPersonID(NETPERSONID);

void RDPCALL SC_SetCapabilities(void);

void RDPCALL SC_UpdateShm(void);

BOOL RDPCALL SC_IsAutoReconnectEnabled();

BOOL RDPCALL SC_IsSecureChecksum();

void RDPCALL SC_SetCombinedCapabilities(UINT, PTS_COMBINED_CAPABILITIES);

void RDPCALL SC_GetCombinedCapabilities(LOCALPERSONID, UINT *, 
        PTS_COMBINED_CAPABILITIES *);

NTSTATUS RDPCALL SC_AddPartyToShare(NETPERSONID, PTS_COMBINED_CAPABILITIES,
        unsigned);

NTSTATUS RDPCALL SC_RemovePartyFromShare(NETPERSONID);

LOCALPERSONID __fastcall SC_NetworkIDToLocalID(NETPERSONID);

BOOL RDPCALL SC_ValidateNetworkID(NETPERSONID, PLOCALPERSONID);

NTSTATUS __fastcall SC_FlushAndAllocPackage(PPDU_PACKAGE_INFO);

PBYTE __fastcall SC_GetSpaceInPackage(PPDU_PACKAGE_INFO, unsigned);

void RDPCALL SC_AddToPackage(PPDU_PACKAGE_INFO, unsigned, BOOL);

BOOL RDPCALL SC_KeepAlive(void);

void RDPCALL SC_RedrawScreen(void);

// Used for shadowing
NTSTATUS RDPCALL SC_SendServerCert(PSHADOWCERT, ULONG);

BOOL RDPCALL SC_SaveServerCert(PTS_SERVER_CERTIFICATE_PDU, ULONG);

NTSTATUS RDPCALL SC_SendClientRandom(PBYTE, ULONG);

BOOL RDPCALL SC_SaveClientRandom(PTS_CLIENT_RANDOM_PDU, ULONG);

NTSTATUS RDPCALL SC_GetSecurityData(PSD_IOCTL);

void RDPCALL SCParseGeneralCaps();

void RDPCALL SC_FlushPackage(PPDU_PACKAGE_INFO);


#ifdef __cplusplus

/****************************************************************************/
/* API FUNCTION: SC_InShare                                                 */
/*                                                                          */
/* Returns whether the SC is in a share or call.                            */
/*                                                                          */
/* RETURNS:                                                                 */
/*                                                                          */
/*  TRUE  = SC is in a share or call.                                       */
/*  FALSE = SC is not in a share or call.                                   */
/****************************************************************************/
BOOL RDPCALL SC_InShare(void)
{
    /************************************************************************/
    /* We do not check the state for this call - it can usefully be made    */
    /* even when SC has not been initialized (or after it has been          */
    /* terminated).                                                         */
    /************************************************************************/
    return (scState == SCS_IN_SHARE);
}


#endif  // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\aschafn.h ===
/****************************************************************************/
// aschafn.h
//
// Function prototypes for Scheduler API functions
//
// Copyright (C) 1996-2000 Microsoft Corporation
/****************************************************************************/

void RDPCALL SCH_Init(void);

void RDPCALL SCH_UpdateShm(void);

void RDPCALL SCH_ContinueScheduling(unsigned);


/****************************************************************************/
// SCH_Term
/****************************************************************************/
void RDPCALL SCH_Term(void)
{
}


/****************************************************************************/
// SCH_ShouldWeDoStuff
//
// Allow SCH to determine if TimeToDoStuff should pass on this IOCTL.
/****************************************************************************/
BOOL RDPCALL SCH_ShouldWeDoStuff(BOOL mustSend)
{
    BOOL rc;

    schInTTDS = TRUE;

    if ((schCurrentMode == SCH_MODE_ASLEEP) && !mustSend) {
        // We've been called because of the first piece of output; don't do
        // any work this time round, but start accumulating.
        SCH_ContinueScheduling(SCH_MODE_NORMAL);
        rc = FALSE;
    }
    else {
        // If we're in normal mode, then set ourselves asleep: we'll only
        // stay awake if someone calls ContinueScheduling during this pass
        // of TimeToDoStuff.
        if (schCurrentMode == SCH_MODE_NORMAL)
            schCurrentMode = SCH_MODE_ASLEEP;

        rc = TRUE;
    }

    return rc;
}


/****************************************************************************/
// SCH_EndOfDoingStuff
//
// Calculate the timer period to set; update the scheduling mode if required.
// Returns time period in milliseconds to set desktop timer.
/****************************************************************************/
INT32 RDPCALL SHCLASS SCH_EndOfDoingStuff(PUINT32 pSchCurrentMode)
{
    UINT32 currentTime;

    // Check for exiting TURBO mode.
    if (schCurrentMode == SCH_MODE_TURBO || schInputKickMode) {
        COM_GETTICKCOUNT(currentTime);

        if ((schCurrentMode == SCH_MODE_TURBO) &&
        	((currentTime - schLastTurboModeSwitch) > schTurboModeDuration))
        {
            schCurrentMode = SCH_MODE_NORMAL;
        }

        // InputKick Mode is set to TRUE when we get client keyboard or mouse
        // input, and set to FALSE here when a constant time-period since the
        // input has passed.
        if ((currentTime - schLastTurboModeSwitch) > SCH_INPUTKICK_DURATION) {
            schInputKickMode = FALSE;
        }
    }

    schInTTDS = FALSE;
    *pSchCurrentMode = schCurrentMode;
    return schPeriods[schCurrentMode];
}


/****************************************************************************/
// SCH_UpdateBACompressionEst
/****************************************************************************/
void RDPCALL SCH_UpdateBACompressionEst(unsigned estimate)
{
    m_pShm->sch.baCompressionEst = estimate;
}


/****************************************************************************/
// SCH_GetBACompressionEst
/****************************************************************************/
unsigned RDPCALL SCH_GetBACompressionEst(void)
{
    return m_pShm->sch.baCompressionEst;
}


/****************************************************************************/
// SCH_GetCurrentMode
/****************************************************************************/
unsigned SCH_GetCurrentMode()
{
    return schCurrentMode;
}


/****************************************************************************/
// SCH_GetInputKickMode
/****************************************************************************/
BOOL SCH_GetInputKickMode()
{
    return schInputKickMode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\asdgafn.h ===
/****************************************************************************/
// asdgafn.h
//
// Function prototypes for SDG API functions
//
// Copyright (C) 1996-2000 Microsoft Corporation
/****************************************************************************/

void RDPCALL SDG_Init(void);

void RDPCALL SDG_SendScreenDataArea(BYTE *, UINT32, PPDU_PACKAGE_INFO);

BOOL RDPCALL SDGSendSDARect(BYTE *, unsigned, PRECTL, BOOL, PPDU_PACKAGE_INFO,
        SDG_ENCODE_CONTEXT *);

void RDPCALL SDGPrepareData(BYTE **, int, int, unsigned, unsigned);


/****************************************************************************/
// SDG_Term
/****************************************************************************/
void RDPCALL SDG_Term(void)
{
}


/****************************************************************************/
/* FUNCTION: SDG_ScreenDataIsWaiting                                        */
/*                                                                          */
/* Returns whether there is some Screen Data ready to be sent.              */
/* RETURNS: TRUE if there is accumulated screen data ready to send.         */
/****************************************************************************/
__inline BOOL RDPCALL SDG_ScreenDataIsWaiting()
{
    return BA_BoundsAreWaiting();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\ascifn.h ===
/****************************************************************************/
// ascifn.h
//
// Function prototypes for SC internal functions
//
// COPYRIGHT (c) Microsoft 1996-1999
/****************************************************************************/

BOOL RDPCALL SCPartyJoiningShare(LOCALPERSONID locPersonID,
                                 unsigned          oldShareSize);

void RDPCALL SCPartyLeftShare(LOCALPERSONID locPersonID,
                              unsigned          newShareSize);

void RDPCALL SCEnumGeneralCaps(LOCALPERSONID, UINT_PTR, PTS_CAPABILITYHEADER);

BOOL RDPCALL SCCallPartyJoiningShare(LOCALPERSONID locPersonID,
                                          unsigned          sizeOfCaps,
                                          PVOID         pCaps,
                                          PBOOL         pAccepted,
                                          unsigned          oldShareSize);

void RDPCALL SCCallPartyLeftShare(LOCALPERSONID locPersonID,
                                       PBOOL         pAccepted,
                                       unsigned          newShareSize );

void RDPCALL SCInitiateSync(BOOLEAN);

void RDPCALL SCConfirmActive(PTS_CONFIRM_ACTIVE_PDU, unsigned, NETPERSONID);

void RDPCALL SCDeactivateOther(NETPERSONID netPersonID);

void RDPCALL SCSynchronizePDU(NETPERSONID       netPersonID,
                                   UINT32            priority,
                                   PTS_SYNCHRONIZE_PDU pPkt);

void RDPCALL SCReceivedControlPacket(
        NETPERSONID netPersonID,
        UINT32      priority,
        void        *pPkt,
        unsigned    DataLength);

void RDPCALL SCFlowTestPDU(LOCALPERSONID, PTS_FLOW_PDU, UINT32);

void RDPCALL SCEndShare(void);

void RDPCALL SCUpdateVCCaps();

#define SCFlowInit()
#define SCFlowFree(a, b)
#define SCFlowAlloc(a, b) TRUE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\ascint.h ===
/****************************************************************************/
// ascint.h
//
// Share Controller Internal Header File.
//
// Copyright (C) Microsoft, PictureTel 1992-1996
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/
#ifndef _H_ASCINT
#define _H_ASCINT


/****************************************************************************/
/* Constants for calling PartyJoiningShare and PartyLeftShare functions.    */
/****************************************************************************/
#define SC_CPC   0
#define SC_IM    1
#define SC_CA    2
#define SC_CM    3
#define SC_OE    4
#define SC_SBC   5
#define SC_SSI   6
#define SC_USR   7
#define SC_DCS   8
#define SC_SC    9
#define SC_UP   10
#define SC_PM   11
#define SC_NUM_PARTY_JOINING_FCTS 12


/****************************************************************************/
/* Events for the SC state table.                                           */
/****************************************************************************/
/****************************************************************************/
/* Real events                                                              */
/****************************************************************************/
#define SCE_INIT                    0
#define SCE_TERM                    1
#define SCE_CREATE_SHARE            2
#define SCE_END_SHARE               3
#define SCE_CONFIRM_ACTIVE          4
#define SCE_DETACH_USER             5


/****************************************************************************/
/* Dummy events to allow state checking on function calls                   */
/****************************************************************************/
#define SCE_INITIATESYNC            6
#define SCE_CONTROLPACKET           7
#define SCE_DATAPACKET              8
#define SCE_GETMYNETWORKPERSONID    9
#define SCE_GETREMOTEPERSONDETAILS  10
#define SCE_GETLOCALPERSONDETAILS   11
#define SCE_PERIODIC                12
#define SCE_LOCALIDTONETWORKID      13
#define SCE_NETWORKIDTOLOCALID      14
#define SCE_ISLOCALPERSONID         15
#define SCE_ISNETWORKPERSONID       16
#define SC_NUM_EVENTS               17


/****************************************************************************/
/* States for the SC state table.                                           */
/****************************************************************************/
#define SCS_STARTED                 0
#define SCS_INITED                  1
#define SCS_SHARE_STARTING          2
#define SCS_IN_SHARE                3
#define SC_NUM_STATES               4


/****************************************************************************/
/* Values in the state table                                                */
/****************************************************************************/
#define SC_TABLE_OK                 0
#define SC_TABLE_WARN               1
#define SC_TABLE_ERROR              2


/****************************************************************************/
/* SC_SET_STATE - set the SLCstate                                          */
/****************************************************************************/
#define SC_SET_STATE(newstate)                                              \
{                                                                           \
    TRC_NRM((TB, "Set state from %s to %s",                                 \
            scStateName[scState], scStateName[newstate]));                  \
    scState = newstate;                                                     \
}


/****************************************************************************/
/* SC_CHECK_STATE checks whether we have violated the SC state table.       */
/****************************************************************************/
#ifdef DC_DEBUG
#define SC_CHECK_STATE(event)                                               \
{                                                                           \
    if (scStateTable[event][scState] != SC_TABLE_OK)                        \
    {                                                                       \
        if (scStateTable[event][scState] == SC_TABLE_WARN)                  \
        {                                                                   \
            TRC_ALT((TB, "Unusual event %s in state %s",                    \
                      scEventName[event], scStateName[scState]));           \
        }                                                                   \
        else                                                                \
        {                                                                   \
            TRC_ABORT((TB, "Invalid event %s in state %s",                  \
                      scEventName[event], scStateName[scState]));           \
        }                                                                   \
        DC_QUIT;                                                            \
    }                                                                       \
}
#else /* DC_DEBUG */
#define SC_CHECK_STATE(event)                                               \
{                                                                           \
    if (scStateTable[event][scState] != SC_TABLE_OK)                        \
    {                                                                       \
        DC_QUIT;                                                            \
    }                                                                       \
}
#endif /* DC_DEBUG */



/****************************************************************************/
/* Information kept for each person in the share.                           */
/****************************************************************************/
typedef struct tagSC_PARTY_INFO
{
    NETPERSONID netPersonID;           /* Is non-zero when in a share.    */
    char        name[MAX_NAME_LEN];    /* Party's name.                   */
    BOOLEAN     sync[PROT_PRIO_COUNT]; /* Is priority synchronized?       */
} SC_PARTY_INFO, *PSC_PARTY_INFO;



#endif /* _H_ASCINT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\aschapi.h ===
/****************************************************************************/
// aschapi.h
//
// Scheduler header.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/
#ifndef _H_ASCHAPI
#define _H_ASCHAPI


// Scheduling mode constants.
#define SCH_MODE_ASLEEP  0
#define SCH_MODE_NORMAL  1
#define SCH_MODE_TURBO   2


/****************************************************************************/
/* Turbo mode duration in units of 100ns                                    */
/****************************************************************************/
#define SCH_TURBO_MODE_FAST_LINK_DURATION 150 * 10000
#define SCH_TURBO_MODE_SLOW_LINK_DURATION 30 * 10000

/****************************************************************************/
/* Turbo mode delay for a slow link (in ms).  Fast link delay is read from  */
/* the registry.                                                            */
/****************************************************************************/
#define SCH_TURBO_PERIOD_SLOW_LINK_DELAY     10

#define SCH_NO_TIMER (-1L)

/****************************************************************************/
/* InputKick mode duration in units of 100ns                                */
/****************************************************************************/
#define SCH_INPUTKICK_DURATION          (1000 * 10000)



/****************************************************************************/
/* Preferred output PDU sizes.  Note that these must be < 16384             */
/*                                                                          */
/* HACKHACK:                                                                */
/* We try to stay within the buffer allocation sizes allowed by TermDD's    */
/* buffer pools. The max is 8192 total bytes, which includes all WD         */
/* overhead (PKT_HEADER_SIZE + security header + NM pOutBuf + MCS prefix    */
/* and suffix) as well as TermDD overhead (estimated to 400 bytes). Until   */
/* we can redesign the WD to keep a variable with the real overhead, we'll  */
/* set the maximum sizes to an approximate amount.                          */
/****************************************************************************/

// The max OUTBUF, X.224, MCS, NM pointer, and encryption overhead sizes.
#define OUTBUF_OVERHEAD 400
#define MCS_ALLOC_OVERHEAD SendDataReqPrefixBytes
#define MAX_X224_MCS_WIRE_OVERHEAD 15
#define NM_OVERHEAD (sizeof(UINT_PTR))
#define MAX_ENCRYPT_OVERHEAD (sizeof(RNS_SECURITY_HEADER1))

// The on-the-wire overhead of the lower layers.
#define NETWORK_WIRE_OVERHEAD \
        (MAX_X224_MCS_WIRE_OVERHEAD + MAX_ENCRYPT_OVERHEAD)

// The OutBuf allocation overhead of the lower layers.
#define NETWORK_ALLOC_OVERHEAD \
        (MCS_ALLOC_OVERHEAD + NM_OVERHEAD + MAX_ENCRYPT_OVERHEAD)

#define OUTBUF_8K_ALLOC_SIZE 8192
#define OUTBUF_HEADER_OVERHEAD 60
#define OUTBUF_16K_ALLOC_SIZE 16384

#ifdef DC_HICOLOR
// Maximum size the order packer can request from the allocator and still
// get a 16K OutBuf, taking into account the overhead of the lower layers.
#define MAX_16K_OUTBUF_ALLOC_SIZE \
        (16384 - OUTBUF_OVERHEAD - NETWORK_ALLOC_OVERHEAD)
#endif


/****************************************************************************/
// Packing sizes - different sizes for different connection speeds.
// The client must fully reconstruct the contents of an OUTBUF before it can
// act on the data contained within. For slow links, we must try not to
// send large OUTBUFs else the output looks bursty as large numbers of
// orders get unpacked at once. On LAN we have a bit more leeway, but still
// want to limit ourselves a bit. And, we always want to try to
// send payloads whose total wire size is as close to a multiple of 1460
// (the LAN and RAS TCP/IP packet payload size) as possible to reduce the
// number of frames we send.
//
// Note that here we specify small and large packing limits. This is
// because some entire orders have trouble fitting into the smaller size
// (e.g. a cache-bitmap secondary order with 4K of bitmap data attached).
// The second size must be at least 4K, plus network overhead, plus the
// the maximum size of a cache-bitmap order header in wire format, times
// 8/7 (the inverse of the ratio used for compressed UP packing).
// It must also be smaller than sc8KOutBufUsableSpace, since the package
// allocator in SC will be allocating that size for the order packer.
/****************************************************************************/

// LAN small and large packing limits.
#define SMALL_LAN_PAYLOAD_SIZE (1460 * 2 - NETWORK_WIRE_OVERHEAD)
#define LARGE_LAN_PAYLOAD_SIZE (1460 * 5 - NETWORK_WIRE_OVERHEAD)

// Slow link small and large packing limits.
#define SMALL_SLOWLINK_PAYLOAD_SIZE (1460 * 1 - NETWORK_WIRE_OVERHEAD)
#define LARGE_SLOWLINK_PAYLOAD_SIZE (1460 * 4 - NETWORK_WIRE_OVERHEAD)

// For filling in order PDUs, we'd like to have a minimum size available in
// the package beyond the update orders PDU header, to allow at least a
// few small orders to be packed into a packet and amortize the cost of
// the share headers.
#define SCH_MIN_ORDER_BUFFER_SPACE 50

// Minimum screen data space for packing network buffers.
#define SCH_MIN_SDA_BUFFER_SPACE 128


/****************************************************************************/
/* Compression scaling factor.                                              */
/****************************************************************************/
#define SCH_UNCOMP_BYTES 1024


/****************************************************************************/
/* Initial estimates for compression (these are tuned on the basis of real  */
/* data once we're running).  The values are "bytes of compressed data per  */
/* SCH_UNCOMP_BYTES bytes of raw data"                                      */
/*                                                                          */
/* The initial values are typical values seen in normal usage.              */
/****************************************************************************/
#define SCH_BA_INIT_EST  100
#define SCH_MPPC_INIT_EST 512


/****************************************************************************/
/* Limit value to prevent odd behaviour                                     */
/****************************************************************************/
#define SCH_COMP_LIMIT 25


/****************************************************************************/
/* Structure: SCH_SHARED_DATA                                               */
/*                                                                          */
/* Description:  Data shared between WD and DD parts of SCH.                */
/****************************************************************************/
typedef struct tagSCH_SHARED_DATA
{
    /************************************************************************/
    /* The next fields are used by SCH to decide when there is enough       */
    /* output to make a schedule worth-while.  The values are passed by     */
    /* OE2 and BA to the WD side of SCH.                                    */
    /*                                                                      */
    /* The value is the number of bytes that 1024 bytes of PDU payload      */
    /* would on average compress to.                                        */
    /************************************************************************/
    unsigned baCompressionEst;   // Amount of BA compression expected.
    unsigned MPPCCompressionEst;  // Compression ratio of MPPC bulk compressor.

    BOOL schSlowLink;

    // OUTBUF packing sizes, based on the link speed.
    unsigned SmallPackingSize;
    unsigned LargePackingSize;
} SCH_SHARED_DATA, *PSCH_SHARED_DATA;



#endif   /* #ifndef _H_ASCHAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\asmapi.h ===
/****************************************************************************/
// asmapi.h
//
// Security Manager API
//
// Copyright (C) 1997-1999 Microsoft Corporation
/****************************************************************************/
#ifndef _H_ASMAPI
#define _H_ASMAPI

#include <anmapi.h>
#include "license.h"
#include <tssec.h>
#include <at120ex.h>

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


void RDPCALL SM_OnConnected(PVOID, UINT32, UINT32, PRNS_UD_SC_NET, UINT32);

void RDPCALL SM_OnDisconnected(PVOID, UINT32, UINT32);

unsigned RDPCALL SM_GetDataSize(void);

NTSTATUS RDPCALL SM_Init(PVOID      pSMHandle,
                         PTSHARE_WD pWDHandle,
                         BOOLEAN    bOldShadow);
BOOL RDPCALL SM_Register(PVOID   pSMHandle,
                         PUINT32 pMaxPDUSize,
                         PUINT32 pUserID);

void RDPCALL SM_Term(PVOID pSMHandle);

NTSTATUS RDPCALL SM_Connect(PVOID          pSMHandle,
                            PRNS_UD_CS_SEC pUserDataIn,
                            PRNS_UD_CS_NET pNetUserData,
                            BOOLEAN        bOldShadow);

BOOL RDPCALL SM_Disconnect(PVOID pSMHandle);

NTSTATUS __fastcall SM_AllocBuffer(PVOID  pSMHandle,
                               PPVOID ppBuffer,
                               UINT32 bufferLen,
                               BOOLEAN fWait,
                               BOOLEAN fForceEncypt);

void __fastcall SM_FreeBuffer(PVOID pSMHandle, PVOID pBuffer, BOOLEAN fForceEncrypt);

BOOL __fastcall SM_SendData(PVOID, PVOID, UINT32, UINT32, UINT32, BOOL, UINT16, BOOLEAN);

void RDPCALL SM_Dead(PVOID pSMHandle, BOOL dead);

NTSTATUS RDPCALL SM_GetSecurityData(PVOID pSMHandle, PSD_IOCTL pSdIoctl);

NTSTATUS RDPCALL SM_SetSecurityData(PVOID pSMHandle, PSECINFO pSecInfo);

void RDPCALL SM_LicenseOK(PVOID pSMHandle);

void RDPCALL SM_DecodeFastPathInput(void *, BYTE *, unsigned, BOOL, unsigned, BOOL);

BOOLEAN __fastcall SM_MCSSendDataCallback(BYTE          *pData,
                                          unsigned      DataLength,
                                          void          *UserDefined,
                                          UserHandle    hUser,
                                          BOOLEAN       bUniform,
                                          ChannelHandle hChannel,
                                          MCSPriority   Priority,
                                          UserID        SenderID,
                                          Segmentation  Segmentation);

BOOL RDPCALL SM_IsSecurityExchangeCompleted(PVOID, CERT_TYPE *);

// Used for shadowing
VOID RDPCALL SM_GetEncryptionMethods(PVOID pSMHandle, PRNS_UD_CS_SEC pSecurityData);

NTSTATUS RDPCALL SM_GetDefaultSecuritySettings(PRNS_UD_CS_SEC pClientSecurityData);

NTSTATUS RDPCALL SM_SetEncryptionParams(PVOID pSMHandle, ULONG ulLevel,
                                        ULONG ulMethod);

NTSTATUS RDPCALL SM_SetSafeChecksumMethod(
        PVOID pSMHandle,
        BOOLEAN fSafeChecksumMethod
        );


#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif // _H_ASMAPI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\asdgapi.h ===
/****************************************************************************/
/* asdgapi.h                                                                */
/*                                                                          */
/* RDP Screen Data Grabber API functions                                    */
/*                                                                          */
/* Copyright(c) Microsoft, PictureTel 1993-1996                             */
/* (C) 1997-1999 Microsoft Corp.                                            */
/****************************************************************************/
#ifndef _H_ASDGAPI
#define _H_ASDGAPI


// Size of sample for compression statistics.
#define SDG_SAMPLE_SIZE 50000


// SDA PDU creation context used during multi-pass rectangle PDU creation.
typedef struct _SDG_ENCODE_CONTEXT
{
    unsigned BitmapPDUSize;  // Size of the current PDU.
    BYTE *pPackageSpace;  // Real start of the package space.
    TS_UPDATE_BITMAP_PDU_DATA UNALIGNED *pBitmapPDU; // PDU data within the update header.
    TS_BITMAP_DATA UNALIGNED *pSDARect;  // Ptr to current rectangle to be added.
} SDG_ENCODE_CONTEXT;



#endif /* ndef _H_ASDGAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\assiapi.h ===
/****************************************************************************/
/* assiapi.h                                                                */
/*                                                                          */
/* SaveScreenBits Interceptor API functions.                                */
/*                                                                          */
/* Copyright(c) Microsoft, PictureTel 1992-1996                             */
/* Copyright(c) Data Connection 1996                                        */
/* (C) 1997-1998 Microsoft Corp.                                            */
/****************************************************************************/
#ifndef _H_ASSIAPI
#define _H_ASSIAPI

/****************************************************************************/
/* Define the values that can be passed in the flags field of               */
/* SaveScreenBits.                                                          */
/*                                                                          */
/* These should be defined in a Windows header - but they are not. In any   */
/* case they are referred to in generic code, so need to be defined here.   */
/****************************************************************************/
#define SSB_SAVEBITS     0
#define SSB_RESTOREBITS  1
#define SSB_DISCARDSAVE  2


/****************************************************************************/
/* Structure:    SSI_SHARED_DATA                                            */
/*                                                                          */
/* Description:  Data shared between WD, DD in SSI                          */
/****************************************************************************/
typedef struct tagSSI_SHARED_DATA
{
    /************************************************************************/
    /* Control flags that tell the DD what to do.                           */
    /************************************************************************/
    BOOLEAN resetInterceptor;
    BOOLEAN saveBitmapSizeChanged;

    /************************************************************************/
    /* Current and new (evaluated but as yet unimplemented) value of the    */
    /* save bitmap size.                                                    */
    /************************************************************************/
    UINT32 sendSaveBitmapSize;
    UINT32 newSaveBitmapSize;
} SSI_SHARED_DATA, *PSSI_SHARED_DATA;



#endif /* _H_ASSIAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\assiafn.h ===
/****************************************************************************/
// assiafn.h
//
// Function prototypes for SSI API functions
//
// COPYRIGHT (c) Microsoft 1996-1999
/****************************************************************************/

void RDPCALL SSI_Init(void);

BOOL RDPCALL SSI_PartyJoiningShare(LOCALPERSONID, unsigned);

void RDPCALL SSI_PartyLeftShare(LOCALPERSONID, unsigned);

void RDPCALL SSI_SyncUpdatesNow(void);

void RDPCALL SSI_UpdateShm(void);


void RDPCALL SSIRedetermineSaveBitmapSize(void);

void RDPCALL SSIEnumBitmapCacheCaps(LOCALPERSONID, UINT_PTR,
        PTS_CAPABILITYHEADER);

void RDPCALL SSIResetInterceptor(void);

void RDPCALL SSICapabilitiesChanged(void);


#ifdef __cplusplus

/****************************************************************************/
/* SSI_Term()                                                               */
/*                                                                          */
/* SSI termination function.                                                */
/****************************************************************************/
void RDPCALL SSI_Term(void)
{
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\asmint.h ===
/****************************************************************************/
/* asmint.h                                                                 */
/*                                                                          */
/* Security Manager Internal Functions                                      */
/*                                                                          */
/* Copyright (C) 1997-1999 Microsoft Corp.                                  */
/****************************************************************************/

#ifndef _H_ASMINT
#define _H_ASMINT

/****************************************************************************/
/* Include required system headers                                          */
/* And some prototypes for which I can't use the system header because it   */
/* also has icky user mode stuff                                            */
/****************************************************************************/
#include <ntnls.h>
#include <fipsapi.h>

NTSYSAPI
VOID
NTAPI
RtlGetDefaultCodePage(
    OUT PUSHORT AnsiCodePage,
    OUT PUSHORT OemCodePage
    );
NTSYSAPI
NTSTATUS
NTAPI
RtlMultiByteToUnicodeN(
    PWSTR UnicodeString,
    ULONG MaxBytesInUnicodeString,
    PULONG BytesInUnicodeString,
    PCHAR MultiByteString,
    ULONG BytesInMultiByteString
    );
NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeToMultiByteN(
    PCHAR MultiByteString,
    ULONG MaxBytesInMultiByteString,
    PULONG BytesInMultiByteString,
    PWSTR UnicodeString,
    ULONG BytesInUnicodeString
    );
NTSYSAPI
VOID
NTAPI
RtlInitCodePageTable(
    IN PUSHORT TableBase,
    OUT PCPTABLEINFO CodePageTable
    );
NTSYSAPI
NTSTATUS
NTAPI
RtlCustomCPToUnicodeN(
    IN PCPTABLEINFO CustomCP,
    OUT PWCH UnicodeString,
    IN ULONG MaxBytesInUnicodeString,
    OUT PULONG BytesInUnicodeString OPTIONAL,
    IN PCH CustomCPString,
    IN ULONG BytesInCustomCPString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeToCustomCPN(
    IN PCPTABLEINFO CustomCP,
    OUT PCH CustomCPString,
    IN ULONG MaxBytesInCustomCPString,
    OUT PULONG BytesInCustomCPString OPTIONAL,
    IN PWCH UnicodeString,
    IN ULONG BytesInUnicodeString
    );


/****************************************************************************/
/* Include T.120 headers                                                    */
/****************************************************************************/
#include <at128.h>
#include "license.h"
#include <tssec.h>
#include <at120ex.h>

/****************************************************************************/
/* Include SM API                                                           */
/****************************************************************************/
#include <asmapi.h>

/****************************************************************************/
/* Include other Share APIs                                                 */
/****************************************************************************/
#include <nwdwapi.h>


/****************************************************************************/
/* Constants                                                                */
/****************************************************************************/
#define WIN_DONTDISPLAYLASTUSERNAME_DFLT    0


/****************************************************************************/
/* Security config defaults                                                 */
/****************************************************************************/
#define WIN_MINENCRYPTIONLEVEL_DFLT     1
#define WIN_DISABLEENCRYPTION_DFLT      FALSE


/****************************************************************************/
/* SM States                                                                */
/****************************************************************************/
#define SM_STATE_STARTED            0
#define SM_STATE_INITIALIZED        1
#define SM_STATE_NM_CONNECTING      2
#define SM_STATE_SM_CONNECTING      3
#define SM_STATE_LICENSING          4
#define SM_STATE_CONNECTED          5
#define SM_STATE_SC_REGISTERED      6
#define SM_STATE_DISCONNECTING      7
#define SM_NUM_STATES               8


/****************************************************************************/
/* SM Events                                                                */
/****************************************************************************/
#define SM_EVT_INIT                 0
#define SM_EVT_TERM                 1
#define SM_EVT_REGISTER             2
#define SM_EVT_CONNECT              3
#define SM_EVT_DISCONNECT           4
#define SM_EVT_CONNECTED            5
#define SM_EVT_DISCONNECTED         6
#define SM_EVT_DATA_PACKET          7

// Note that Alloc & Send have the same event ID, as the conditions
// under which these may be called are identical.
#define SM_EVT_ALLOCBUFFER          8
#define SM_EVT_SENDDATA             8

#define SM_EVT_SEC_PACKET           9
#define SM_EVT_LIC_PACKET           10
#define SM_EVT_ALIVE                11
#define SM_NUM_EVENTS               12


/****************************************************************************/
/* Values in the state table                                                */
/****************************************************************************/
#define SM_TABLE_OK                 0
#define SM_TABLE_WARN               1
#define SM_TABLE_ERROR              2


/****************************************************************************/
/* SM_CHECK_STATE checks whether we have violated the SM state table.       */
/*                                                                          */
/* smStateTable is filled in in ASMDATA.C.                                  */
/*                                                                          */
/* Possible values of STATE are defined in ASMINT.H.                        */
/* Possible events are defined in ASMINT.H                                  */
/****************************************************************************/
#define SM_CHECK_STATE(event)                                               \
{                                                                           \
    if (smStateTable[event][pRealSMHandle->state] != SM_TABLE_OK)           \
    {                                                                       \
        if (smStateTable[event][pRealSMHandle->state] == SM_TABLE_WARN)     \
        {                                                                   \
            TRC_ALT((TB, "Unusual event %s in state %s",                    \
                    smEventName[event], smStateName[pRealSMHandle->state]));\
        }                                                                   \
        else                                                                \
        {                                                                   \
            TRC_ABORT((TB, "Invalid event %s in state %s",                  \
                    smEventName[event], smStateName[pRealSMHandle->state]));\
        }                                                                   \
        DC_QUIT;                                                            \
    }                                                                       \
}

// Query version which supports properly predicting branches.
// Assumes that the "else" case will be the end of the function.
#ifdef DC_DEBUG
#define SM_CHECK_STATE_Q(event) SMCheckState(pRealSMHandle, event)
#else
#define SM_CHECK_STATE_Q(event) \
    (smStateTable[event][pRealSMHandle->state] == SM_TABLE_OK)
#endif


/****************************************************************************/
/* SM_SET_STATE - set the SLCstate                                          */
/****************************************************************************/
#define SM_SET_STATE(newstate)                                              \
{                                                                           \
    TRC_NRM((TB, "Set state from %s to %s",                                 \
            smStateName[pRealSMHandle->state], smStateName[newstate]));     \
    pRealSMHandle->state = newstate;                                        \
}

typedef struct tagSM_CONSOLE_BUFFER
{
    LIST_ENTRY links;
    PVOID   buffer;
    UINT32  length;
} SM_CONSOLE_BUFFER, *PSM_CONSOLE_BUFFER;

//
// Instrumentation enabled to track discarded packets
// (to help track VC decompression break).
//
#define INSTRUM_TRACK_DISCARDED 1


typedef struct _SM_FIPS_Data {
    BYTE                    bEncKey[MAX_FIPS_SESSION_KEY_SIZE];
    BYTE                    bDecKey[MAX_FIPS_SESSION_KEY_SIZE];
    DES3TABLE               EncTable;
    DES3TABLE               DecTable;
    BYTE                    bEncIv[FIPS_BLOCK_LEN];
    BYTE                    bDecIv[FIPS_BLOCK_LEN];
    BYTE                    bSignKey[MAX_SIGNKEY_SIZE];
    PDEVICE_OBJECT          pDeviceObject;
    PFILE_OBJECT            pFileObject;
    FIPS_FUNCTION_TABLE     FipsFunctionTable;
} SM_FIPS_Data, FAR * PSM_FIPS_Data;

/****************************************************************************/
/* Structure: SM_HANDLE_DATA                                                */
/*                                                                          */
/* Description: Structure of context-specific data maintained by SM         */
/****************************************************************************/
typedef struct tagSM_HANDLE_DATA
{
    /************************************************************************/
    /* winstation encryption level.                                         */
    /************************************************************************/
    UINT32  encryptionLevel;
    UINT32  encryptionMethodsSupported;
    UINT32  encryptionMethodSelected;
    BOOLEAN frenchClient;
    BOOLEAN encryptAfterLogon;

    /************************************************************************/
    /* Are we encrypting?                                                   */
    /************************************************************************/
    BOOLEAN encrypting;  // Whether the client is encrypting input.
    BOOLEAN encryptDisplayData;  // Whether server is encrypting output.
    BOOLEAN encryptingLicToClient; // Whether S->C license data is encrypted
    //
    // whether server should send data using safe checksum style
    //
    BOOLEAN useSafeChecksumMethod;
                                        
    /************************************************************************/
    /* State information                                                    */
    /************************************************************************/

    BOOLEAN bDisconnectWorkerSent;
    BOOLEAN dead;
    UINT32  state;

#ifdef INSTRUM_TRACK_DISCARDED
    //
    // Debug information
    //
    UINT32  nDiscardVCDataWhenDead;
    UINT32  nDiscardPDUBadState;
    UINT32  nDiscardNonVCPDUWhenDead;
#endif


    /************************************************************************/
    /* User data to pass back to Client                                     */
    /************************************************************************/
    PRNS_UD_SC_SEC pUserData;

    /************************************************************************/
    /* WDW handle, passed back on WDW_SMCallback calls                      */
    /************************************************************************/
    PTSHARE_WD pWDHandle;

#ifdef USE_LICENSE
    /************************************************************************/
    /* License Manager handle                                               */
    /************************************************************************/
    PVOID pLicenseHandle;
#endif

    /************************************************************************/
    /* MCS User and Channel IDs                                             */
    /************************************************************************/
    UINT32 userID;
    UINT16 channelID;

    /************************************************************************/
    /* Max size of a PDU reported by NM                                     */
    /************************************************************************/
    UINT32 maxPDUSize;

    /************************************************************************/
    /* The type of certificate that is used in the security key exchange.   */
    /************************************************************************/
    CERT_TYPE CertType;

    /************************************************************************/
    /* Client and server random keys that make the client/server session    */
    /* keys.                                                                */
    /************************************************************************/
    PBYTE   pEncClientRandom;
    UINT32  encClientRandomLen;
    BOOLEAN recvdClientRandom;

    // state of whether share class is ready for data forwarding or not
    BOOLEAN bForwardDataToSC;

    /************************************************************************/
    /* encrypt/decrypt session keys. key length is 8 for 40 bit encryption  */
    /* and 16 for 128 encryption.                                           */
    /************************************************************************/
    BOOLEAN              bSessionKeysMade;
    UINT32               keyLength;

    UINT32               encryptCount;
    UINT32               totalEncryptCount;
    UINT32               encryptHeaderLen;
    // Used if encryptDisplayData is FALSE, but we want to encrypt this particular S->C packet
    UINT32               encryptHeaderLenIfForceEncrypt;
    BYTE                 startEncryptKey[MAX_SESSION_KEY_SIZE];
    BYTE                 currentEncryptKey[MAX_SESSION_KEY_SIZE];
    struct RC4_KEYSTRUCT rc4EncryptKey;

    UINT32               decryptCount;
    UINT32               totalDecryptCount;
    BYTE                 startDecryptKey[MAX_SESSION_KEY_SIZE];
    BYTE                 currentDecryptKey[MAX_SESSION_KEY_SIZE];
    struct RC4_KEYSTRUCT rc4DecryptKey;

    BYTE                 macSaltKey[MAX_SESSION_KEY_SIZE];

    LIST_ENTRY           consoleBufferList;
    UINT32               consoleBufferCount;

    SM_FIPS_Data         FIPSData;

} SM_HANDLE_DATA, * PSM_HANDLE_DATA;


/****************************************************************************/
/* Functions                                                                */
/****************************************************************************/
BOOL RDPCALL SMDecryptPacket(PSM_HANDLE_DATA pRealSMHandle,
                             PVOID         pData,
                             unsigned          dataLen,
                             BOOL fUseSafeChecksum);

BOOLEAN RDPCALL SMContinueSecurityExchange(PSM_HANDLE_DATA pRealSMHandle,
                                           PVOID           pData,
                                           UINT32          dataLen);

BOOLEAN RDPCALL SMSecurityExchangeInfo(PSM_HANDLE_DATA pRealSMHandle,
                                       PVOID           pData,
                                       UINT32          dataLen);

BOOLEAN RDPCALL SMSecurityExchangeKey(PSM_HANDLE_DATA pRealSMHandle,
                                      PVOID           pData,
                                      UINT32          dataLen);

void RDPCALL SMFreeInitResources(PSM_HANDLE_DATA pRealSMHandle);

void RDPCALL SMFreeConnectResources(PSM_HANDLE_DATA pRealSMHandle);

INT ConvertToAndFromWideChar(PSM_HANDLE_DATA pRealSMHandle,
        UINT CodePage, LPWSTR WideCharString,
        INT BytesInWideCharString, LPSTR MultiByteString,
        INT BytesInMultiByteString, BOOL ConvertToWideChar);

BOOL RDPCALL SMCheckState(PSM_HANDLE_DATA, unsigned);

BOOL TSFIPS_Init(PSM_FIPS_Data pFipsData);

void TSFIPS_Term(PSM_FIPS_Data pFipsData);

UINT32 TSFIPS_AdjustDataLen(UINT32 dataLen);
BOOL TSFIPS_MakeSessionKeys(PSM_FIPS_Data pFipsData, LPRANDOM_KEYS_PAIR pRandomKey, CryptMethod *pEnumMethod, BOOL bPassThroughStack);

BOOL TSFIPS_EncryptData(
            PSM_FIPS_Data pFipsData,
            LPBYTE pbData,
            DWORD dwDataLen,
            DWORD dwPadLen,
            LPBYTE pbSignature,
            DWORD  dwEncryptionCount);

BOOL TSFIPS_DecryptData(
            PSM_FIPS_Data pFipsData,
            LPBYTE pbData,
            DWORD dwDataLen,
            DWORD dwPadLen,
            LPBYTE pbSignature,
            DWORD  dwDecryptionCount);



// Win16 code page driver-global caching data.
extern FAST_MUTEX fmCodePage;
extern ULONG LastCodePageTranslated;
extern PVOID LastNlsTableBuffer;
extern CPTABLEINFO LastCPTableInfo;
extern UINT NlsTableUseCount;



#endif /* _H_ASMINT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\aupafn.h ===
/****************************************************************************/
// aupafn.h
//
// Function prototypes for UP API functions
//
// Copyright (C) 1996-2000 Microsoft Corporation
/****************************************************************************/

void RDPCALL UP_Init(void);

void RDPCALL SHCLASS UP_ReceivedPacket(
        PTS_SUPPRESS_OUTPUT_PDU pSupOutPDU,
        unsigned                DataLength,
        LOCALPERSONID           locPersonID);

NTSTATUS RDPCALL UP_SendUpdates(BYTE *pFrameBuf,
                            UINT32 frameBufWidth,
                            PPDU_PACKAGE_INFO pPkgInfo);

void RDPCALL UP_SyncNow(BOOLEAN);

BOOL RDPCALL UP_SendBeep(UINT32 duration, UINT32 frequency);

BOOL RDPCALL UP_PartyJoiningShare(LOCALPERSONID locPersonID,
                                  unsigned      oldShareSize);

void RDPCALL UP_PartyLeftShare(LOCALPERSONID personID,
                             unsigned      newShareSize);

BOOL RDPCALL UPSendSyncToken(PPDU_PACKAGE_INFO);

NTSTATUS RDPCALL UPSendOrders(PPDU_PACKAGE_INFO pPkgInfo);

unsigned RDPCALL UPFetchOrdersIntoBuffer(PBYTE, unsigned *, PUINT);

void CALLBACK UPEnumSoundCaps(LOCALPERSONID, UINT_PTR,
        PTS_CAPABILITYHEADER);


/****************************************************************************/
/* UP_Term                                                                  */
/****************************************************************************/
void RDPCALL UP_Term(void)
{
    upfSyncTokenRequired = FALSE;
}


/****************************************************************************/
// UP_UpdateHeaderSize
//
// Called in UP and SC when the fast-path output state changes to recalculate
// orders header size.
/****************************************************************************/
__inline void RDPCALL UP_UpdateHeaderSize()
{
    // Precalculate the header space needed for update-orders PDUs.
    if (scUseFastPathOutput)
        upUpdateHdrSize = scUpdatePDUHeaderSpace + 2;
    else
        upUpdateHdrSize = scUpdatePDUHeaderSpace +
                FIELDOFFSET(TS_UPDATE_ORDERS_PDU_DATA, orderList);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\aupapi.h ===
/****************************************************************************/
/* aupapi.h                                                                 */
/*                                                                          */
/* RDP Update Packager API functions                                        */
/*                                                                          */
/* Copyright(c) Microsoft, PictureTel 1993-1996                             */
/* (C) 1997-1999 Microsoft Corp.                                            */
/****************************************************************************/

#ifndef _H_AUPAPI
#define _H_AUPAPI


// Size of sample for OE2 compression statistics.
#define UP_SAMPLE_SIZE 32768



#endif /* ndef _H_AUPAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\atrcapi.h ===
/****************************************************************************/
// atrcapi.h
//
// Kernel mode trace header
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/
#ifndef _H_ATRCAPI
#define _H_ATRCAPI


#define TRC_BUFFER_SIZE 255


#ifdef DLL_DISP
/****************************************************************************/
// In RDPDD, TT_APIx are not defined - define them here
/****************************************************************************/
#define TT_API1         0x00000001          /* API level 1                  */
#define TT_API2         0x00000002          /* API level 2                  */
#define TT_API3         0x00000004          /* API level 3                  */
#define TT_API4         0x00000008          /* API level 4                  */
#define TT_ERROR        0xffffffff          /* error condition              */

/****************************************************************************/
// No profile tracing in RDPDD
/****************************************************************************/
#ifdef TRC_COMPILE_PRF
#undef TRC_COMPILE_PRF
#endif

#endif /* DLL_DISP */


/****************************************************************************/
/* Before including this file the TRC_FILE macro should be defined.  This   */
/* is much more efficient than relying on __FILE__ to give the correct      */
/* filename since it includes unnecessary path info (and extension info).   */
/* In addition each use of __FILE__ causes a new constant string to be      */
/* placed in the data segment.                                              */
/****************************************************************************/
#ifdef TRC_FILE
#define _file_name_ (char *)__filename
static const char __filename[] = TRC_FILE;
#endif /* TRC_FILE */


/****************************************************************************/
/* Define the trace level.                                                  */
/*                                                                          */
/* TRC_LEVEL_DBG         : All tracing is enabled                           */
/* TRC_LEVEL_NRM         : Debug level tracing is disabled                  */
/* TRC_LEVEL_ALT         : Normal and debug level tracing is disabled       */
/* TRC_LEVEL_ERR         : Alert, normal and debug level tracing is         */
/*                         disabled                                         */
/* TRC_LEVEL_ASSERT      : Error, alert, normal and debug level tracing     */
/*                         is disabled                                      */
/* TRC_LEVEL_DIS         : All tracing is disabled.                         */
/****************************************************************************/
#define TRC_LEVEL_DBG       0
#define TRC_LEVEL_NRM       1
#define TRC_LEVEL_ALT       2
#define TRC_LEVEL_ERR       3
#define TRC_LEVEL_ASSERT    4
#define TRC_LEVEL_DIS       5


/****************************************************************************/
/* Tracing can be switched off at compile time to allow for 'debug' and     */
/* 'retail' versions of the product.  The following macros disable specific */
/* trace processing.                                                        */
/*                                                                          */
/* TRC_ENABLE_DBG    - Enable debug tracing                                 */
/* TRC_ENABLE_NRM    - Enable normal tracing                                */
/* TRC_ENABLE_ALT    - Enable alert tracing                                 */
/* TRC_ENABLE_ERR    - Enable error tracing                                 */
/* TRC_ENABLE_ASSERT - Enable assert tracing                                */
/* TRC_ENABLE_PRF    - Enable function profile tracing                      */
/****************************************************************************/
#if (TRC_COMPILE_LEVEL == TRC_LEVEL_DBG)
#define TRC_ENABLE_DBG
#define TRC_ENABLE_NRM
#define TRC_ENABLE_ALT
#define TRC_ENABLE_ERR
#define TRC_ENABLE_ASSERT
#endif

#if (TRC_COMPILE_LEVEL == TRC_LEVEL_NRM)
#define TRC_ENABLE_NRM
#define TRC_ENABLE_ALT
#define TRC_ENABLE_ERR
#define TRC_ENABLE_ASSERT
#endif

#if (TRC_COMPILE_LEVEL == TRC_LEVEL_ALT)
#define TRC_ENABLE_ALT
#define TRC_ENABLE_ERR
#define TRC_ENABLE_ASSERT
#endif

#if (TRC_COMPILE_LEVEL == TRC_LEVEL_ERR)
#define TRC_ENABLE_ERR
#define TRC_ENABLE_ASSERT
#endif

#if (TRC_COMPILE_LEVEL == TRC_LEVEL_ASSERT)
#define TRC_ENABLE_ASSERT
#endif

#ifdef TRC_COMPILE_PRF
#define TRC_ENABLE_PRF
#endif


/****************************************************************************/
/* Prefix constants                                                         */
/*                                                                          */
/* TRC_MAX_PREFIX       : number of prefixes supported                      */
/* TRC_PREFIX_NAME_LEN  : length of a prefix name                           */
/****************************************************************************/
#define TRC_MAX_PREFIX                  20
#define TRC_PREFIX_NAME_LEN             8


/****************************************************************************/
/* Structure: TRC_PREFIX_DATA                                               */
/*                                                                          */
/* Description: Trace prefixes                                              */
/****************************************************************************/
typedef struct tagTRC_PREFIX_DATA
{
    char name[TRC_PREFIX_NAME_LEN];
    UINT32 start;
    UINT32 end;
} TRC_PREFIX_DATA, *PTRC_PREFIX_DATA;


/****************************************************************************/
// TRC_SHARED_DATA
//
// TS stack trace info for the DD shared memory.
/****************************************************************************/
typedef struct tagTRC_SHARED_DATA
{
    BOOL   init;
    UINT32 TraceClass;
    UINT32 TraceEnable;
    TRC_PREFIX_DATA prefix[TRC_MAX_PREFIX];
} TRC_SHARED_DATA, *PTRC_SHARED_DATA;


/****************************************************************************/
/* Various trace helper definitions                                         */
/****************************************************************************/

#ifdef DLL_DISP
#define TB                  ddTraceString, sizeof(ddTraceString)
#else
#define TB                  pTRCWd->traceString, sizeof(pTRCWd->traceString)
#endif

#ifdef DLL_DISP
#define TraceBuffer         ddTraceString
#else
#define TraceBuffer         pTRCWd->traceString
#endif


#define TRC_FUNC_FMT        "%-*.*s"
#define TRC_LINE_FMT        "%04d"
#define TRC_FUNCNAME_LEN    12

#define TRC_SEP_DBG         ' '
#define TRC_SEP_NRM         ' '
#define TRC_SEP_ALT         '+'
#define TRC_SEP_ERR         '*'
#define TRC_SEP_ASSERT      '!'
#define TRC_SEP_PROF        ' '

#if (TRC_COMPILE_LEVEL < TRC_LEVEL_DIS)
#define TRC_FN(A)   static const char __fnname[] = A;                  \
                    char *trc_fn = (char *)__fnname;                   \
                    char *trc_file = _file_name_;
#else
#define TRC_FN(A)
#endif


/****************************************************************************/
/* Standard trace macros                                                    */
/****************************************************************************/
#ifdef TRC_ENABLE_DBG
#define TRC_DBG(string)     TRCX(TT_API1, TRC_SEP_DBG, string)
#else
#define TRC_DBG(string)
#endif

#ifdef TRC_ENABLE_NRM
#define TRC_NRM(string)     TRCX(TT_API2, TRC_SEP_NRM, string)
#else
#define TRC_NRM(string)
#endif

#ifdef TRC_ENABLE_ALT
#define TRC_ALT(string)     TRCX(TT_API3, TRC_SEP_ALT, string)
#else
#define TRC_ALT(string)
#endif

#ifdef TRC_ENABLE_ERR
#define TRC_ERR(string)     TRCX(TT_API4, TRC_SEP_ERR, string)
#else
#define TRC_ERR(string)
#endif


#ifdef TRC_ENABLE_ASSERT
#ifdef DLL_DISP
/****************************************************************************/
// TRC_ASSERT & TRC_ABORT for RDPDD
/****************************************************************************/
#define TRC_ASSERT(condition, string)                                        \
    {                                                                        \
        if (!(condition))                                                    \
        {                                                                    \
            TRCX(TT_ERROR, TRC_SEP_ASSERT, string);                          \
            EngDebugBreak();                                                 \
        }                                                                    \
    }

#define TRC_ABORT(string)                                                    \
    {                                                                        \
        TRCX(TT_ERROR, TRC_SEP_ASSERT, string);                              \
        EngDebugBreak();                                                     \
    }

#else /* DLL_DISP */
/****************************************************************************/
// TRC_ASSERT & TRC_ABORT for RDPWD
/****************************************************************************/
#define TRC_ASSERT(condition, string)                                        \
    {                                                                        \
        if (!(condition))                                                    \
        {                                                                    \
            TRCX(TT_ERROR, TRC_SEP_ASSERT, string);                          \
            DbgBreakPoint();                                                 \
        }                                                                    \
    }

#define TRC_ABORT(string)                                                    \
    {                                                                        \
        TRCX(TT_ERROR, TRC_SEP_ASSERT, string);                              \
        DbgBreakPoint();                                                     \
    }
#endif /* DLL_DISP */

#else /* TRC_ENABLE_ASSERT */
/****************************************************************************/
// TRC_ASSERT & TRC_ABORT for retail builds (same for RDPWD & RDPDD)
/****************************************************************************/
#define TRC_ASSERT(condition, string)
#define TRC_ABORT(string)
#endif /* TRC_ENABLE_ASSERT */


#ifdef TRC_ENABLE_TST
#define TRC_TST  TRC_DBG
#else
#define TRC_TST(x)
#endif /* TRC_ENABLE_TST */

#ifdef DLL_DISP
/****************************************************************************/
// TRCX for RDPDD
/****************************************************************************/
#define TRCX(type, separator, traceString)                                   \
    {                                                                        \
        if (TRC_WillTrace(type, TC_DISPLAY, trc_file, __LINE__))             \
        {                                                                    \
            _snprintf traceString;                                           \
            TRC_TraceLine(NULL,                                              \
                          TC_DISPLAY,                                        \
                          type,                                              \
                          TraceBuffer,                                       \
                          separator,                                         \
                          (int)__LINE__,                                     \
                          trc_fn,                                            \
                          trc_file);                                         \
        }                                                                    \
    }

#else /* DLL_DISP */
/****************************************************************************/
// TRCX for RDPWD
/****************************************************************************/
#define TRCX(type, separator, traceString)                                   \
    {                                                                        \
        if (TRC_WillTrace(pTRCWd, type, TC_WD, trc_file, __LINE__))          \
        {                                                                    \
            _snprintf traceString;                                           \
            TRC_TraceLine(pTRCWd,                                            \
                          TC_WD,                                             \
                          type,                                              \
                          TraceBuffer,                                       \
                          separator,                                         \
                          (int)__LINE__,                                     \
                          trc_fn,                                            \
                          trc_file);                                         \
        }                                                                    \
    }
#endif /* DLL_DISP */

/****************************************************************************/
/* Function profile trace macros                                            */
/****************************************************************************/

#define TRC_ENTRY TRC_PRF((TB, "Enter {"));
#define TRC_EXIT  TRC_PRF((TB, "Exit  }"));

#ifdef TRC_ENABLE_PRF
#define TRC_PRF(string)   TRCP(string)
#else
#define TRC_PRF(string)
#endif

#define TRCP(traceString)                                                    \
    {                                                                        \
        if (TRC_WillTrace(pTRCWd, type, TC_WD, trc_file, __LINE__))          \
        {                                                                    \
            _snprintf traceString;                                           \
            TRC_TraceLine(pTRCWd,                                            \
                          TC_WD,                                             \
                          TT_API1,                                           \
                          TraceBuffer,                                       \
                          TRC_SEP_PROF,                                      \
                          (int)__LINE__,                                     \
                          trc_fn,                                            \
                          trc_file);                                         \
        }                                                                    \
    }


/****************************************************************************/
/* Data dump trace macros                                                   */
/****************************************************************************/

#ifdef DLL_DISP
/****************************************************************************/
// @@@MF No data tracing in RDPDD (yet?)
/****************************************************************************/
#define TRC_DATA_DBG(a, b, c)
#define TRC_DATA_NRM(a, b, c)
#define TRC_DATA_ALT(a, b, c)
#define TRC_DATA_ERR(a, b, c)

#else /* DLL_DISP */
/****************************************************************************/
// TRC_DATA macros for RDPWD
/****************************************************************************/

#ifdef TRC_ENABLE_DBG
#define TRC_DATA_DBG(string, buffer, length)                                 \
          TRCX_DATA(TT_OUT1, TRC_SEP_DBG, string, buffer, length)
#else
#define TRC_DATA_DBG(string, buffer, length)
#endif

#ifdef TRC_ENABLE_NRM
#define TRC_DATA_NRM(string, buffer, length)                                 \
          TRCX_DATA(TT_OUT2, TRC_SEP_NRM, string, buffer, length)
#else
#define TRC_DATA_NRM(string, buffer, length)
#endif

#ifdef TRC_ENABLE_ALT
#define TRC_DATA_ALT(string, buffer, length)                                 \
          TRCX_DATA(TT_OUT3, TRC_SEP_ALT, string, buffer, length)
#else
#define TRC_DATA_ALT(string, buffer, length)
#endif

#ifdef TRC_ENABLE_ERR
#define TRC_DATA_ERR(string, buffer, length)                                 \
          TRCX_DATA(TT_OUT4, TRC_SEP_ERR, string, buffer, length)
#else
#define TRC_DATA_ERR(string, buffer, length)
#endif

#ifdef TRC_ENABLE_NRM
#define TRC_DATA_NET(string, buffer, length)                                 \
          TRCX_DATA(TT_OUT2, TRC_SEP_NRM, string, buffer, length)
#else
#define TRC_DATA_NET(string, buffer, length)
#endif

#define TRCX_DATA(type, separator, string, buffer, length)                   \
    {                                                                        \
        if (TRC_WillTrace(pTRCWd, type, TC_WD, trc_file, __LINE__))          \
        {                                                                    \
            TRC_TraceLine(pTRCWd,                                            \
                          TC_WD,                                             \
                          type,                                              \
                          string,                                            \
                          separator,                                         \
                          (int)__LINE__,                                     \
                          trc_fn,                                            \
                          trc_file);                                         \
                                                                             \
            /*************************************************************/  \
            /* Use direct function call here, since macro TRACESTACKBUF  */  \
            /* is #defined to _IcaStackTraceBuffer, which takes the      */  \
            /* wrong sort of first param.                                */  \
            /*************************************************************/  \
            IcaStackTraceBuffer(pTRCWd->pContext,                            \
                                TC_WD,                                       \
                                type,                                        \
                                buffer,                                      \
                                length);                                     \
        }                                                                    \
    }

#endif /* DLL_DISP */


/****************************************************************************/
// TRC_TraceLine - function used by RDPDD and RDPWD
/****************************************************************************/
void TRC_TraceLine(PVOID, UINT32, UINT32, char *, char, unsigned, char *,
        char *);

/****************************************************************************/
// Functions used by RDPWD only
/****************************************************************************/
#ifndef DLL_DISP
void TRC_UpdateConfig(PVOID, PSD_IOCTL);
void TRC_MaybeCopyConfig(PVOID, PTRC_SHARED_DATA);
#endif

/****************************************************************************/
/* TRC_WillTrace                                                            */
/****************************************************************************/
#ifdef DLL_DISP
BOOL TRC_WillTrace(UINT32, UINT32, char *, UINT32);
#else
BOOL TRC_WillTrace(PVOID, UINT32, UINT32, char *, UINT32);
#endif



#endif /* _H_ATRCAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\ausrapi.h ===
/****************************************************************************/
// ausrapi.h
//
// RDP Update Sender/Receiver API header
//
// Copyright(c) Microsoft, PictureTel 1992-1997
// (C) 1997-1998 Microsoft Corp.
/****************************************************************************/
#ifndef _H_AUSRAPI
#define _H_AUSRAPI


/****************************************************************************/
/* Define the size of the bitmap used for the SaveBitmap order.             */
/* These dimensions must be multiples of the granularity values below.      */
/* Use a large size - the client will send a smaller size in the Order      */
/* Capability Set.                                                          */
/****************************************************************************/
#define SAVE_BITMAP_WIDTH   1000
#define SAVE_BITMAP_HEIGHT  1000

/****************************************************************************/
/* Define the granularity of the SaveBitmap order.                          */
/****************************************************************************/
#define SAVE_BITMAP_X_GRANULARITY   1
#define SAVE_BITMAP_Y_GRANULARITY  20


/****************************************************************************/
/*                                                                          */
/* PROTOTYPES                                                               */
/*                                                                          */
/****************************************************************************/
#ifdef DC_INCL_PROTOTYPES
#include <ausrafn.h>
#endif



#endif /* _H_AUSRAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\cbchash.c ===
/* (C) 1997-1998 Microsoft Corp.
 *
 * CBC64 - 64-bit hashing algorithm
 *
 * CBC64 is part of a Microsoft Research project to create a fast encryption
 * algorithm for the NT5 NTFS-EFS encrypted disk subsystem. Though
 * originally intended for encryption use, CBC64 makes a fast hash
 * and checksum function with known probabilities for failure and known
 * good variability based on input.
 *
 * CBC64 takes as input four seed values a, b, c, and d. The bits of a and
 * c MUST correspond to the coefficients of an irreducible polynomial.
 * Associated code (RandomIrreduciblePolynomial(), which is included in this
 * file but ifdef-ed out) will take a random number as seed value and
 * converge to a usable value (or zero if the seed cannot be converged,
 * in which case a new random seed must be tried).
 *
 * In an encryption context, a, b, c, and d would correspond to "secrets"
 * held by the encrypter and decrypter. For our purposes -- use as a hash
 * function -- we can simply hardcode all four -- a and c with values from
 * RandomIrreduciblePolynomial() on two random numbers, b and d with
 * simple random numbers.
 *
 * For a set of N inputs (e.g. bitmaps) the probability of duplicate hash
 * value creation has been proven to be (N^2)/(2^64).
 *
 * Original algorithm notes:
 *   From "Chain& Sum primitive and its applications to
 *   Stream Ciphers and MACs"
 *          Ramarathnam Venkatesan (Microsoft Research)
 *          Mariusz Jackubowski (Princeton/MS Research)
 *
 *   To Appear in Advances in Cryptology EuroCrypt 98, Springer Verlag.
 *   Patent rights being applied for by Microsoft.
 *
 *   Extracted from the algorithm for simulating CBC-Encryption and its
 *   message integrity properties using much faster stream ciphers. Its
 *   analysis appears in the above paper.
 *
 *   Algorithm is a MAC with input preprocessing by ((Alpha)x + (Beta))
 *   mod 2^32, followed by forward (ax + b) and (cx + d) in field GF(2^32).
 */

#include "cbchash.h"


#define CBC_a 0xBB40E665
#define CBC_b 0x544B2FBA
#define CBC_c 0xDC3F08DD
#define CBC_d 0x39D589AE
#define CBC_bXORa (CBC_b ^ CBC_a)
#define CBC_dXORc (CBC_d ^ CBC_c)


// For removal of branches in main loop -- over twice as fast as the code
//   with branches.
const UINT32 CBC_AB[2] = { CBC_b, CBC_bXORa };
const UINT32 CBC_CD[2] = { CBC_d, CBC_dXORc };


void __fastcall SHCLASS NextCBC64(
        CBC64Context *pContext,
        UINT32 *pData,
        unsigned NumDWORDBlocks)
{
    while (NumDWORDBlocks--) {
        // Checksum is used to overcome known collision characteristics of
        // CBC64. It is a low-tech solution that simply decreases the
        // probability of collision where used.
        pContext->Checksum += *pData;

        pContext->Datum = CBC_RandomOddAlpha * (*pData + pContext->Datum) +
                CBC_RandomBeta;
        pContext->Key1 ^= pContext->Datum;
        pContext->Key1 = (pContext->Key1 << 1) ^
                (CBC_CD[(pContext->Key1 & 0x80000000) >> 31]);
        pContext->Key2 ^= pContext->Datum;
        pContext->Key2 = (pContext->Key2 << 1) ^
                (CBC_AB[(pContext->Key2 & 0x80000000) >> 31]);
        pData++;
    }
}



/*
 *
 * Support functions for determining irreducible a and c.
 *
 */

#if 0


// Original CBC64 from which the First()-Next() algorithm was derived.
// Returns the first part of the key value; second key part is last param.
UINT32 __fastcall SHCLASS CBC64(
        UINT32 *Data,
        unsigned NumDWORDBlocks,
        UINT32 *pKey2)
{
    int i;
    UINT32 abMAC, cdMAC, Datum;

    // For removal of branches in main loops -- over twice as fast as the code
    //   with branches.
    const UINT32 AB[2] = { CBC_b, CBC_bXORa };
    const UINT32 CD[2] = { CBC_d, CBC_dXORc };

    // Block 0.
    abMAC = cdMAC = Datum = *Data * CBC_RandomOddAlpha + CBC_RandomBeta;
    abMAC = (abMAC << 1) ^ (AB[(cdMAC & 0x80000000) >> 31]);
    cdMAC = (cdMAC << 1) ^ (CD[(cdMAC & 0x80000000) >> 31]);

    // Blocks 1 through nblocks - 2
    i = NumDWORDBlocks - 1;
    while (--i) {
        Data++;
        Datum = CBC_RandomOddAlpha * (*Data + Datum) + CBC_RandomBeta;
        cdMAC ^= Datum;
        cdMAC = (cdMAC << 1) ^ (CD[(cdMAC & 0x80000000) >> 31]);
        abMAC ^= Datum;
        abMAC = (abMAC << 1) ^ (AB[(abMAC & 0x80000000) >> 31]);
    }

    // Last block (nblocks - 1)
    Data++;
    Datum = CBC_RandomOddAlpha * (*Data + Datum) + CBC_RandomBeta;
    cdMAC ^= Datum;
    cdMAC = (cdMAC << 1) ^ (CD[(cdMAC & 0x80000000) >> 31]);
    abMAC ^= Datum;
    *pKey2 = (abMAC << 1) ^ (AB[(abMAC & 0x80000000) >> 31]);

    return cdMAC;
}




#include <stdio.h>
#include <string.h>
#include <time.h>
#include <windows.h>


// multiply y by x mod x^32+p
__inline UINT32 Multiply(UINT32 y, UINT32 p)
{
    return (y & 0x80000000) ? (y<<1)^p : y<<1;
}



// divide y by x mod x^32+p
__inline UINT32 Divide(UINT32 y, UINT32 p)
{
    return (y & 1) ? 0x80000000^((y^p)>>1) : y>>1;
}



// compute (x^32+p) mod qq[i]
__inline UINT32 PolyMod(UINT32 p, UINT32 i)
{
    static const UINT32 qq[2]={18<<2, 127};

    static const UINT32 rt[2][256] = {
        0,32,8,40,16,48,24,56,32,0,40,8,48,16,56,24,8,40,0,32,
        24,56,16,48,40,8,32,0,56,24,48,16,16,48,24,56,0,32,8,40,
        48,16,56,24,32,0,40,8,24,56,16,48,8,40,0,32,56,24,48,16,
        40,8,32,0,32,0,40,8,48,16,56,24,0,32,8,40,16,48,24,56,
        40,8,32,0,56,24,48,16,8,40,0,32,24,56,16,48,48,16,56,24,
        32,0,40,8,16,48,24,56,0,32,8,40,56,24,48,16,40,8,32,0,
        24,56,16,48,8,40,0,32,8,40,0,32,24,56,16,48,40,8,32,0,
        56,24,48,16,0,32,8,40,16,48,24,56,32,0,40,8,48,16,56,24,
        24,56,16,48,8,40,0,32,56,24,48,16,40,8,32,0,16,48,24,56,
        0,32,8,40,48,16,56,24,32,0,40,8,40,8,32,0,56,24,48,16,
        8,40,0,32,24,56,16,48,32,0,40,8,48,16,56,24,0,32,8,40,
        16,48,24,56,56,24,48,16,40,8,32,0,24,56,16,48,8,40,0,32,
        48,16,56,24,32,0,40,8,16,48,24,56,0,32,8,40,
        0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,
        40,42,44,46,48,50,52,54,56,58,60,62,63,61,59,57,55,53,51,49,
        47,45,43,41,39,37,35,33,31,29,27,25,23,21,19,17,15,13,11,9,
        7,5,3,1,1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,
        33,35,37,39,41,43,45,47,49,51,53,55,57,59,61,63,62,60,58,56,
        54,52,50,48,46,44,42,40,38,36,34,32,30,28,26,24,22,20,18,16,
        14,12,10,8,6,4,2,0,2,0,6,4,10,8,14,12,18,16,22,20,
        26,24,30,28,34,32,38,36,42,40,46,44,50,48,54,52,58,56,62,60,
        61,63,57,59,53,55,49,51,45,47,41,43,37,39,33,35,29,31,25,27,
        21,23,17,19,13,15,9,11,5,7,1,3,3,1,7,5,11,9,15,13,
        19,17,23,21,27,25,31,29,35,33,39,37,43,41,47,45,51,49,55,53,
        59,57,63,61,60,62,56,58,52,54,48,50,44,46,40,42,36,38,32,34,
        28,30,24,26,20,22,16,18,12,14,8,10,4,6,0,2};

    p ^= qq[i]<<(32-6);

    p ^= rt[i][p>>24]<<16;
    p ^= rt[i][(p>>16)&0xff]<<8;
    p ^= rt[i][(p>>8)&0xff];

    if (p&(1<<7))
        p ^= qq[i]<<1;
    if (p&(1<<6))
        p ^= qq[i];

    return p % (1<<6);
}



// do an analogue of Fermat test on x^32+p
BOOL Irreducible(UINT32 p)
{
    static const UINT32 expand[256] = {
        0x0, 0x1, 0x4, 0x5, 0x10, 0x11, 0x14, 0x15,
        0x40, 0x41, 0x44, 0x45, 0x50, 0x51, 0x54, 0x55,
        0x100, 0x101, 0x104, 0x105, 0x110, 0x111, 0x114, 0x115,
        0x140, 0x141, 0x144, 0x145, 0x150, 0x151, 0x154, 0x155,
        0x400, 0x401, 0x404, 0x405, 0x410, 0x411, 0x414, 0x415,
        0x440, 0x441, 0x444, 0x445, 0x450, 0x451, 0x454, 0x455,
        0x500, 0x501, 0x504, 0x505, 0x510, 0x511, 0x514, 0x515,
        0x540, 0x541, 0x544, 0x545, 0x550, 0x551, 0x554, 0x555,
        0x1000, 0x1001, 0x1004, 0x1005, 0x1010, 0x1011, 0x1014, 0x1015,
        0x1040, 0x1041, 0x1044, 0x1045, 0x1050, 0x1051, 0x1054, 0x1055,
        0x1100, 0x1101, 0x1104, 0x1105, 0x1110, 0x1111, 0x1114, 0x1115,
        0x1140, 0x1141, 0x1144, 0x1145, 0x1150, 0x1151, 0x1154, 0x1155,
        0x1400, 0x1401, 0x1404, 0x1405, 0x1410, 0x1411, 0x1414, 0x1415,
        0x1440, 0x1441, 0x1444, 0x1445, 0x1450, 0x1451, 0x1454, 0x1455,
        0x1500, 0x1501, 0x1504, 0x1505, 0x1510, 0x1511, 0x1514, 0x1515,
        0x1540, 0x1541, 0x1544, 0x1545, 0x1550, 0x1551, 0x1554, 0x1555,
        0x4000, 0x4001, 0x4004, 0x4005, 0x4010, 0x4011, 0x4014, 0x4015,
        0x4040, 0x4041, 0x4044, 0x4045, 0x4050, 0x4051, 0x4054, 0x4055,
        0x4100, 0x4101, 0x4104, 0x4105, 0x4110, 0x4111, 0x4114, 0x4115,
        0x4140, 0x4141, 0x4144, 0x4145, 0x4150, 0x4151, 0x4154, 0x4155,
        0x4400, 0x4401, 0x4404, 0x4405, 0x4410, 0x4411, 0x4414, 0x4415,
        0x4440, 0x4441, 0x4444, 0x4445, 0x4450, 0x4451, 0x4454, 0x4455,
        0x4500, 0x4501, 0x4504, 0x4505, 0x4510, 0x4511, 0x4514, 0x4515,
        0x4540, 0x4541, 0x4544, 0x4545, 0x4550, 0x4551, 0x4554, 0x4555,
        0x5000, 0x5001, 0x5004, 0x5005, 0x5010, 0x5011, 0x5014, 0x5015,
        0x5040, 0x5041, 0x5044, 0x5045, 0x5050, 0x5051, 0x5054, 0x5055,
        0x5100, 0x5101, 0x5104, 0x5105, 0x5110, 0x5111, 0x5114, 0x5115,
        0x5140, 0x5141, 0x5144, 0x5145, 0x5150, 0x5151, 0x5154, 0x5155,
        0x5400, 0x5401, 0x5404, 0x5405, 0x5410, 0x5411, 0x5414, 0x5415,
        0x5440, 0x5441, 0x5444, 0x5445, 0x5450, 0x5451, 0x5454, 0x5455,
        0x5500, 0x5501, 0x5504, 0x5505, 0x5510, 0x5511, 0x5514, 0x5515,
        0x5540, 0x5541, 0x5544, 0x5545, 0x5550, 0x5551, 0x5554, 0x5555};

    // tables used for fast squaring
    UINT32 pp[4], ph[16], pl[4][16];
    UINT32 g, v;
    int i;

    pp[0] = 0;
    pp[1] = p;

    if (p&0x80000000)
    {
        pp[2] = p ^ (p<<1);
        pp[3] = p<<1;
    }
    else
    {
        pp[2] = p<<1;
        pp[3] = p ^ (p<<1);
    }

    v = 0x40000000;
    for (i=0; i<16; i++)
        ph[i] = v = (v<<2) ^ pp[v >> 30];

    for (i=0; i<4; i++)
    {
        pl[i][0] = 0;
        pl[i][1] = ph[4*i+0];
        pl[i][2] = ph[4*i+1];
        pl[i][3] = ph[4*i+0] ^ ph[4*i+1];
        pl[i][4] = ph[4*i+2];
        pl[i][5] = ph[4*i+2] ^ ph[4*i+0];
        pl[i][6] = ph[4*i+2] ^ ph[4*i+1];
        pl[i][7] = pl[i][5] ^ ph[4*i+1];

        pl[i][8] = ph[4*i+3];
        pl[i][9] = ph[4*i+3] ^ ph[4*i+0];
        pl[i][10] = ph[4*i+3] ^ ph[4*i+1];
        pl[i][11] = pl[i][9] ^ ph[4*i+1];
        pl[i][12] = ph[4*i+3] ^ ph[4*i+2];
        pl[i][13] = pl[i][12] ^ ph[4*i+0];
        pl[i][14] = pl[i][10] ^ ph[4*i+2];
        pl[i][15] = pl[i][14] ^ ph[4*i+0];
    }

    // compute x^(2^16) mod x^32+p

    // x^32 mod x^32+p = p
    g = p;

    // square g
    g = expand[g&0xff] ^ (expand[(g>>8)&0xff]<<16) ^
        pl[0][(g>>16)&0xf] ^ pl[1][(g>>20)&0xf] ^ pl[2][(g>>24)&0xf] ^ pl[3][(g>>28)&0xf];

    // square g 10 more times to get x^(2^16)
    for (i=0; i<2; i++)
    {
        g = expand[g&0xff] ^ (expand[(g>>8)&0xff]<<16) ^
            pl[0][(g>>16)&0xf] ^ pl[1][(g>>20)&0xf] ^ pl[2][(g>>24)&0xf] ^ pl[3][(g>>28)&0xf];
        g = expand[g&0xff] ^ (expand[(g>>8)&0xff]<<16) ^
            pl[0][(g>>16)&0xf] ^ pl[1][(g>>20)&0xf] ^ pl[2][(g>>24)&0xf] ^ pl[3][(g>>28)&0xf];
        g = expand[g&0xff] ^ (expand[(g>>8)&0xff]<<16) ^
            pl[0][(g>>16)&0xf] ^ pl[1][(g>>20)&0xf] ^ pl[2][(g>>24)&0xf] ^ pl[3][(g>>28)&0xf];
        g = expand[g&0xff] ^ (expand[(g>>8)&0xff]<<16) ^
            pl[0][(g>>16)&0xf] ^ pl[1][(g>>20)&0xf] ^ pl[2][(g>>24)&0xf] ^ pl[3][(g>>28)&0xf];
        g = expand[g&0xff] ^ (expand[(g>>8)&0xff]<<16) ^
            pl[0][(g>>16)&0xf] ^ pl[1][(g>>20)&0xf] ^ pl[2][(g>>24)&0xf] ^ pl[3][(g>>28)&0xf];
    }

    // if x^(2^16) mod x^32+p = x then x^32+p has a divisor whose degree is a power of 2
    if (g==2)
        return FALSE;

    // compute x^(2^32) mod x^32+p
    for (i=0; i<4; i++)
    {
        g = expand[g&0xff] ^ (expand[(g>>8)&0xff]<<16) ^
            pl[0][(g>>16)&0xf] ^ pl[1][(g>>20)&0xf] ^ pl[2][(g>>24)&0xf] ^
            pl[3][(g>>28)&0xf];
        g = expand[g&0xff] ^ (expand[(g>>8)&0xff]<<16) ^
            pl[0][(g>>16)&0xf] ^ pl[1][(g>>20)&0xf] ^ pl[2][(g>>24)&0xf] ^
            pl[3][(g>>28)&0xf];
        g = expand[g&0xff] ^ (expand[(g>>8)&0xff]<<16) ^
            pl[0][(g>>16)&0xf] ^ pl[1][(g>>20)&0xf] ^ pl[2][(g>>24)&0xf] ^
            pl[3][(g>>28)&0xf];
        g = expand[g&0xff] ^ (expand[(g>>8)&0xff]<<16) ^
            pl[0][(g>>16)&0xf] ^ pl[1][(g>>20)&0xf] ^ pl[2][(g>>24)&0xf] ^
            pl[3][(g>>28)&0xf];
    }

    // x^32+p is irreducible iff x^(2^16) mod x^32+p != x and
    // x^(2^32) mod x^32+p = x
    return (g == 2);
}



// Take as input a random 32-bit value
// If successful, output is the lowest 32 bits of a degree 32 irreducible
// polynomial otherwise output is 0, in which case try again with a different
// random input.
UINT32 RandomIrreduciblePolynomial(UINT32 p)
{
#define interval (1 << 6)
    BYTE sieve[interval];
    UINT32 r;
    int i;

    memset(sieve, 0, interval);

    p ^= p % interval;

    r = PolyMod(p, 0);
    sieve[r] = 1;
    sieve[r^3] = 1;
    sieve[r^5] = 1;
    sieve[r^15] = 1;
    sieve[r^9] = 1;
    sieve[r^27] = 1;
    sieve[r^29] = 1;
    sieve[r^23] = 1;
    sieve[r^17] = 1;
    sieve[r^51] = 1;
    sieve[r^53] = 1;
    sieve[r^63] = 1;
    sieve[r^57] = 1;
    sieve[r^43] = 1;
    sieve[r^45] = 1;
    sieve[r^39] = 1;
    sieve[r^33] = 1;
    sieve[r^7] = 1;
    sieve[r^21] = 1;
    sieve[r^49] = 1;
    sieve[r^35] = 1;

    r = PolyMod(p, 1);
    sieve[r] = 1;
    sieve[r^11] = 1;
    sieve[r^22] = 1;
    sieve[r^29] = 1;
    sieve[r^44] = 1;
    sieve[r^39] = 1;
    sieve[r^58] = 1;
    sieve[r^49] = 1;
    sieve[r^13] = 1;
    sieve[r^26] = 1;
    sieve[r^23] = 1;
    sieve[r^52] = 1;
    sieve[r^57] = 1;
    sieve[r^46] = 1;
    sieve[r^35] = 1;

    for (i=1; i<interval; i+=2)
        if (sieve[i]==0 && Irreducible(p^i) )
            return p^i;

    return 0;
}



// 16x2 similar bitmaps that come up with same CBC64 (error condition).
DWORD FailData[2][8] =
{
    { 0x00000010, 0x00000010, 0x00000001, 0x00000010,
      0x61AA61AA, 0x61AA61AA, 0x6161AA61, 0xAAAA61AA },
    { 0x00000010, 0x00000010, 0x00000001, 0x00000010,
      0x6AAA61AA, 0x61AA61AA, 0x6161AA61, 0x6AAA61AA }
};



int __cdecl main()
{
    enum { LEN = 512 };
    enum { REPS = 1000 };
    UINT32 X[LEN+1]; 
    UINT32 i;
    UINT32 Key2;
    double start1, end1, speed1;

    for (i=0; i<LEN; X[i++]=i*486248);  //junk data //

    // initialize the variables a,b,c,d
    // This has to be done only once 
//    a = RandomIrreduciblePolynomial(CBC_a);
//    c = RandomIrreduciblePolynomial(CBC_c);
    // Make sure these numbers are not zero; if not
    // Call the routine Random...polynomial() with different seed 
    printf("a = %X, c = %X \n", RandomIrreduciblePolynomial(CBC_a),
            RandomIrreduciblePolynomial(CBC_c));

//    b = CBC_b; //put in some random number
//    d = CBC_d;   // put in some random number

    printf("begin macing\n");
    start1=clock();
    for (i=0; i<REPS; i++)
        CBC64(X, LEN, &Key2);
    end1=clock();
    printf("end macing \n");
    speed1 = 32 * LEN * REPS / ((double) (end1 - start1)/CLOCKS_PER_SEC);
    printf("MAC speed:%4.0lf\n %", speed1);

    printf(" start1= %d end1= %d \n  ", start1, end1);
    scanf ("%d", &Key2); /* just hang so that I can see the output */

    return 0;
}



#endif  // 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\ausrafn.h ===
/****************************************************************************/
// ausrafn.h
//
// Function prototypes for USR API functions
//
// Copyright (C) 1996-2000 Microsoft Corporation
/****************************************************************************/

void RDPCALL USR_Init(void);

void RDPCALL USR_Term(void);

BOOL RDPCALL USR_PartyJoiningShare(LOCALPERSONID, unsigned);

void RDPCALL USR_PartyLeftShare(LOCALPERSONID, unsigned);

BOOL RDPCALL USRDetermineCaps(void);

void CALLBACK USREnumBitmapCaps(LOCALPERSONID, UINT_PTR, PTS_CAPABILITYHEADER);

void RDPCALL USR_ProcessRemoteFonts(PTS_FONT_LIST_PDU, unsigned, LOCALPERSONID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\nbainl.h ===
/****************************************************************************/
// nbainl.h
//
// RDP Bounds Accumulator display driver inline-functions header.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/
#ifndef _H_NBAINL
#define _H_NBAINL

#include <abacom.h>


/****************************************************************************/
// BA_GetTotalBounds
//
// Return the total size in pixels of the accumulated bounds.
/****************************************************************************/
__inline UINT32 BA_GetTotalBounds(void)
{
    return pddShm->ba.totalArea;
}


/****************************************************************************/
/* Name:      BA_QueryBounds                                                */
/*                                                                          */
/* Purpose:   Returns the currently accumlated bounding rectangles.         */
/*            Does NOT reset the list.                                      */
/*                                                                          */
/* Params:    pRects - pointer to buffer that receives the rects            */
/*            pNumRects - pointer to variable that receives number of       */
/*            rects returned.                                               */
/****************************************************************************/
__inline void BA_QueryBounds(PRECTL pRects, unsigned *pNumRects)
{
    BACopyBounds(pRects, pNumRects);
}



#endif  // !defined(_H_NBAINL)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\domain.h ===
/* (C) 1997-1999 Microsoft Corp.
 *
 * file   : domain.h
 * 
 *
 * description: MCS implementation-specific defines and structures.
 */

#ifndef __DOMAIN_H
#define __DOMAIN_H


//#include "MCSKernl.h" 
#include "mcscommn.h"
#include "slist.h"

/*
 * Types
 */

// Primary remote user and local user.
#define NumPreallocUA 2

// One channel for each of remote and local user, plus share, clipboard, and
// printer redir channels.
#define NumPreallocChannel (NumPreallocUA + 3)

struct _Domain;

typedef struct {
    SList UserList;  // hUsers joined. Key=hUser.
    int Type;  // Channel_... defined above.
    BOOLEAN bPreallocated;  // TRUE if we should not free this channel.
    BOOLEAN bInUse;  // For tracking prealloc list usage.
    ChannelID ID;
} MCSChannel;


typedef struct {
    struct _Domain *pDomain;
    BOOLEAN bLocal;  // TRUE if on this machine.
    BOOLEAN bPreallocated;  // TRUE if we should not free this UA.
    BOOLEAN bInUse;  // For tracking prealloc list usage.
    void    *UserDefined;
    UserID  UserID;
    SList   JoinedChannelList;
    MCSUserCallback Callback;
    MCSSendDataCallback SDCallback;
} UserAttachment, *PUserAttachment;


typedef struct _Domain {
    PSDCONTEXT pContext;
    STACKCLASS StackClass;
    BOOLEAN StatusDead;            // This one is consistent with tagTSHARE_WD.dead
    LONG     PseudoRefCount;       // See comment in DisconnectProviderRequestFunc().  This
                                   // is not a full refcount to keep fix simple for RC2,
                                   // another bug is opened for Longhorn for full pDomain fix.
    unsigned StackMode;
    unsigned bChannelBound : 1;   // Indicates T120 channel is registered.
    unsigned bCanSendData : 1;  // ICA stack allows I/O. Diff. from MCS state.
    unsigned bT120StartReceived : 1;  // Whether we can send data to user mode
    unsigned bDPumReceivedNotInput : 1;  // For DPum-before-T120-start timing
    unsigned bEndConnectionPacketReceived : 1;  // DPum or X.224 Disc recvd.
    unsigned bTopProvider : 1;   // TP? Always true on Hydra 4.0.
    unsigned bCurrentPacketFastPath : 1;  // Whether we're in the midst of fast-path input packet.

    // Used for fast-path input decoding.
    void *pSMData;

    // Reassembly info for reassembling TCP-fragmented data packets.
    // Actual default buffer is allocated at end of this struct.
    unsigned ReceiveBufSize;    // TD-allocated size, received on init.
    BYTE *pReassembleData;      // Pointer to PacketBuf or alloc'd buffer.
    unsigned StoredDataLength;  // Current size of held data.
    unsigned PacketDataLength;  // Target packet size. 0xFFFFFFFF for incomplete header.
    unsigned PacketHeaderLength;  // Bytes needed to assemble a header (X.224=4, fastpath=2-3).

    // Statistics counters (used during perf paths).
    PPROTOCOLSTATUS pStat;

    // Perf path MCS information.
    SList ChannelList;           // List of channels in use.

    // X.224 information.
    unsigned MaxX224DataSize;  // Negotiated in X.224 connection.
    unsigned X224SourcePort;

    // MCS domain, channel, user, token information.
    unsigned MaxSendSize;        // The calculated max MCS SendData block size
    SList UserAttachmentList;    // List of local and remote attachments.
    DomainParameters DomParams;  // This domain's negotiated parameters.
    ChannelID NextAvailDynChannel;  // Pseudo-random next-channel indicator.
    int State;                   // Connection state.
    unsigned DelayedDPumReason;

    // Broken connection event.
    PKEVENT pBrokenEvent;

    // Channel to receive shadow data
    ChannelID shadowChannel;

#ifdef DUMP_RAW_INPUT
    BYTE FooBuf[128000];
    unsigned NumPtrs;
    void *Ptrs[1000];
#endif

    // Channel and UserAttachment preallocations for performance and
    // to reduce heap thrashing.
    UserAttachment PreallocUA[NumPreallocUA];
    MCSChannel PreallocChannel[NumPreallocChannel];

    // Beginning of X.224 reconstruction buffer block. Larger size will be
    //   allocated when ReceiveBufSize is known.
    BYTE PacketBuf[1];
} Domain, *PDomain;


#define PDomainAddRef(pDomain) { pDomain->PseudoRefCount++; }
__inline LONG PDomainRelease(PDomain pDomain)
{
    LONG ref;
    ref = --pDomain->PseudoRefCount;
    if (0 == ref)
    {
        ExFreePool(pDomain);
    }
    return ref;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\ndcgdata.h ===
/****************************************************************************/
/* ndcgdata.h                                                               */
/*                                                                          */
/* Common include file for all data.c modules (Windows NT specific)         */
/*                                                                          */
/* Copyright(c) Microsoft 1996-1997.                                        */
/*                                                                          */
/* The macros in this file allow all aspects of data declaration to be kept */
/* together.  The behaviour of this file is controlled by #defines that can */
/* be set prior to inclusion of this.                                       */
/*                                                                          */
/* - DC_INIT_DATA     Set in XX_Init routines to do inline initialisation if*/
/*                    required.                                             */
/* - DC_INCLUDE_DATA  Set where a header file is included in order to get   */
/*                    external declarations.                                */
/* - DC_DEFINE_DATA   Set where a header file is included in order to get   */
/*                    definition without initialisation.                    */
/* - DC_CONSTANT_DATA Set to get global initialisation of const data items  */
/* - (default)        Gets data definition with initialisation.             */
/*                                                                          */
/****************************************************************************/
/*                                                                          */
/* In order to allow for the flexibility required in different environments */
/* (be that different OSs, C vs C++, or whatever) the structure of the file */
/* is as follows.                                                           */
/*                                                                          */
/* First there is an environment-specific mapping from the macros used in   */
/* the code to internal macros.  This mapping also takes the above #defines */
/* into consideration in performing this expansion.                         */
/*                                                                          */
/* Secondly, the low-level macros that actually perform the expansion are   */
/* defined.  These should be platform-independent.                          */
/*                                                                          */
/* The intention of this structure is to avoid the confusions caused by the */
/* old version where, for example, code compiled with DC_INIT_DATA          */
/* explicitly did NOT initialise the data.                                  */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* Clear any previous definitions of the macros.                            */
/****************************************************************************/
#undef DC_DATA
#undef DC_DATA_NULL
#undef DC_DATA_ARRAY
#undef DC_DATA_ARRAY_NULL
#undef DC_DATA_ARRAY_UNINIT
#undef DC_DATA_ARRAY_SET
#undef DC_DATA_2D_ARRAY
#undef DC_CONST_DATA
#undef DC_CONST_DATA_ARRAY
#undef DC_CONST_DATA_2D_ARRAY
#undef DCI_DATA
#undef DCI_DATA_NULL
#undef DCI_DATA_ARRAY
#undef DCI_DATA_ARRAY_NULL
#undef DCI_DATA_ARRAY_UNINIT
#undef DCI_DATA_ARRAY_SET
#undef DCI_DATA_2D_ARRAY
#undef DCI_CONST_DATA
#undef DCI_CONST_DATA_ARRAY
#undef DCI_CONST_DATA_2D_ARRAY

/****************************************************************************/
/* Now define the main (external) macros.                                   */
/****************************************************************************/
#define DC_DATA(A,B,C)                    DCI_DATA(A,B,C)
#define DC_DATA_NULL(A,B,C)               DCI_DATA_NULL(A,B,C)

#define DC_DATA_ARRAY(A,B,C,D)            DCI_DATA_ARRAY(A,B,C,D)
#define DC_DATA_ARRAY_NULL(A,B,C,D)       DCI_DATA_ARRAY_NULL(A,B,C,D)
#define DC_DATA_ARRAY_UNINIT(A,B,C)       DCI_DATA_ARRAY_UNINIT(A,B,C)
#define DC_DATA_ARRAY_SET(A,B,C,D)        DCI_DATA_ARRAY_SET(A,B,C,D)
#define DC_DATA_2D_ARRAY(A,B,C,D,E)       DCI_DATA_2D_ARRAY(A,B,C,D,E)

#define DC_CONST_DATA(A,B,C)              DCI_CONST_DATA(A,B,C)
#define DC_CONST_DATA_ARRAY(A,B,C,D)      DCI_CONST_DATA_ARRAY(A,B,C,D)
#define DC_CONST_DATA_2D_ARRAY(A,B,C,D,E) DCI_CONST_DATA_2D_ARRAY(A,B,C,D,E)

/****************************************************************************/
/****************************************************************************/
/* Now map to the target macros                                             */
/****************************************************************************/
/****************************************************************************/

#if defined(DC_INCLUDE_DATA)
/****************************************************************************/
/* External declarations                                                    */
/****************************************************************************/
#define DCI_DATA(TYPE, Name, VAL)                                        \
                      DCI_EXTERN_DATA(TYPE, Name, VAL)
#define DCI_DATA_NULL(TYPE, Name, VAL)                                   \
                      DCI_EXTERN_DATA_NULL(TYPE, Name, VAL)
#define DCI_DATA_ARRAY(TYPE, Name, Size, VAL)                            \
                      DCI_EXTERN_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_ARRAY_NULL(TYPE, Name, Size, VAL)                       \
                      DCI_EXTERN_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_ARRAY_UNINIT(TYPE, Name, Size)                          \
                      DCI_EXTERN_DATA_ARRAY(TYPE, Name, Size, 0)
#define DCI_DATA_ARRAY_SET(TYPE, Name, Size, VAL)                        \
                      DCI_EXTERN_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)                 \
                      DCI_EXTERN_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)
#define DCI_CONST_DATA(TYPE, Name, VAL)                                  \
                      DCI_EXTERN_CONST_DATA(TYPE, Name, VAL)
#define DCI_CONST_DATA_ARRAY(TYPE, Name, Size, VAL)                      \
                      DCI_EXTERN_CONST_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)           \
                 DCI_EXTERN_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)

#elif defined(DC_INIT_DATA)

/****************************************************************************/
/* Inline initialisation                                                    */
/****************************************************************************/
#if defined(__cplusplus)
#define DCI_DATA(TYPE, Name, VAL)                                        \
                      DCI_ASSIGN_DATA(TYPE, Name, VAL)
#define DCI_DATA_NULL(TYPE, Name, VAL)                                   \
                      DCI_SET_DATA_NULL(TYPE, Name, VAL)
#define DCI_DATA_ARRAY(TYPE, Name, Size, VAL)                            \
                      DCI_ASSIGN_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_ARRAY_NULL(TYPE, Name, Size, VAL)                       \
                      DCI_SET_DATA_ARRAY_NULL(TYPE, Name, Size, VAL)
#define DCI_DATA_ARRAY_UNINIT(TYPE, Name, Size)                          \
                      DCI_NO_DATA_ARRAY(TYPE, Name, Size, 0)
#define DCI_DATA_ARRAY_SET(TYPE, Name, Size, VAL)                        \
                      DCI_SET_DATA_ARRAY_VAL(TYPE, Name, Size, VAL)
#define DCI_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)                 \
                      DCI_ASSIGN_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)
#define DCI_CONST_DATA(TYPE, Name, VAL)                                  \
                      DCI_NO_DATA(TYPE, Name, VAL)
#define DCI_CONST_DATA_ARRAY(TYPE, Name, Size, VAL)                      \
                      DCI_NO_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)           \
                      DCI_NO_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)
#else
#define DCI_DATA(TYPE, Name, VAL)                                        \
                      DCI_NO_DATA(TYPE, Name, VAL)
#define DCI_DATA_NULL(TYPE, Name, VAL)                                   \
                      DCI_NO_DATA_NULL(TYPE, Name, VAL)
#define DCI_DATA_ARRAY(TYPE, Name, Size, VAL)                            \
                      DCI_NO_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_ARRAY_NULL(TYPE, Name, Size, VAL)                       \
                      DCI_NO_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_ARRAY_UNINIT(TYPE, Name, Size)                          \
                      DCI_NO_DATA_ARRAY(TYPE, Name, Size, 0)
#define DCI_DATA_ARRAY_SET(TYPE, Name, Size, VAL)                        \
                      DCI_NO_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)                 \
                      DCI_NO_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)
#define DCI_CONST_DATA(TYPE, Name, VAL)                                  \
                      DCI_NO_DATA(TYPE, Name, VAL)
#define DCI_CONST_DATA_ARRAY(TYPE, Name, Size, VAL)                      \
                      DCI_NO_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)           \
                      DCI_NO_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)

#endif

#elif defined(DC_DEFINE_DATA)

/****************************************************************************/
/* Definition but no initialisation                                         */
/****************************************************************************/
#define DCI_DATA(TYPE, Name, VAL)                                        \
                      DCI_DEFINE_DATA(TYPE, Name, VAL)
#define DCI_DATA_NULL(TYPE, Name, VAL)                                   \
                      DCI_DEFINE_DATA_NULL(TYPE, Name, VAL)
#define DCI_DATA_ARRAY(TYPE, Name, Size, VAL)                            \
                      DCI_DEFINE_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_ARRAY_NULL(TYPE, Name, Size, VAL)                       \
                      DCI_DEFINE_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_ARRAY_UNINIT(TYPE, Name, Size)                          \
                      DCI_DEFINE_DATA_ARRAY(TYPE, Name, Size, NULL)
#define DCI_DATA_ARRAY_SET(TYPE, Name, Size, VAL)                        \
                      DCI_DEFINE_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)                 \
                      DCI_DEFINE_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)
#define DCI_CONST_DATA(TYPE, Name, VAL)                                  \
                      DCI_DEFINE_CONST_DATA(TYPE, Name, VAL)
#define DCI_CONST_DATA_ARRAY(TYPE, Name, Size, VAL)                      \
                      DCI_DEFINE_CONST_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)           \
                DCI_DEFINE_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)

#elif defined(DC_CONSTANT_DATA)

/****************************************************************************/
/* Definition but no initialisation                                         */
/****************************************************************************/
#define DCI_DATA(TYPE, Name, VAL)                                        \
                      DCI_NO_DATA(TYPE, Name, VAL)
#define DCI_DATA_NULL(TYPE, Name, VAL)                                   \
                      DCI_NO_DATA_NULL(TYPE, Name, VAL)
#define DCI_DATA_ARRAY(TYPE, Name, Size, VAL)                            \
                      DCI_NO_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_ARRAY_NULL(TYPE, Name, Size, VAL)                       \
                      DCI_NO_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_ARRAY_UNINIT(TYPE, Name, Size)                          \
                      DCI_NO_DATA_ARRAY(TYPE, Name, Size, NULL)
#define DCI_DATA_ARRAY_SET(TYPE, Name, Size, VAL)                        \
                      DCI_NO_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)                 \
                      DCI_NO_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)
#define DCI_CONST_DATA(TYPE, Name, VAL)                                  \
                      DCI_INIT_CONST_DATA(TYPE, Name, VAL)
#define DCI_CONST_DATA_ARRAY(TYPE, Name, Size, VAL)                      \
                      DCI_INIT_CONST_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)           \
                  DCI_INIT_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)

#else
/****************************************************************************/
/* Data definition and initialisation                                       */
/****************************************************************************/
#define DCI_DATA(TYPE, Name, VAL)                                        \
                      DCI_INIT_DATA(TYPE, Name, VAL)
#define DCI_DATA_NULL(TYPE, Name, VAL)                                   \
                      DCI_INIT_DATA_NULL(TYPE, Name, VAL)
#define DCI_DATA_ARRAY(TYPE, Name, Size, VAL)                            \
                      DCI_INIT_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_ARRAY_NULL(TYPE, Name, Size, VAL)                       \
                      DCI_INIT_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_ARRAY_UNINIT(TYPE, Name, Size)                          \
                      DCI_DEFINE_DATA_ARRAY(TYPE, Name, Size, NULL)
#define DCI_DATA_ARRAY_SET(TYPE, Name, Size, VAL)                        \
                      DCI_INIT_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)                 \
                      DCI_INIT_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)
#define DCI_CONST_DATA(TYPE, Name, VAL)                                  \
                      DCI_INIT_CONST_DATA(TYPE, Name, VAL)
#define DCI_CONST_DATA_ARRAY(TYPE, Name, Size, VAL)                      \
                      DCI_INIT_CONST_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)           \
                  DCI_INIT_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)

#endif

/****************************************************************************/
/****************************************************************************/
/* Finally, the low-level macros required to do the real work.              */
/*                                                                          */
/* Avoid multiple inclusion of these.                                       */
/****************************************************************************/
/****************************************************************************/

#ifndef _H_NDCGDATA
#define _H_NDCGDATA

/****************************************************************************/
/* Some utilities...                                                        */
/****************************************************************************/
#define DC_STRUCT1(a)                                              {a}
#define DC_STRUCT2(a,b)                                          {a,b}
#define DC_STRUCT3(a,b,c)                                      {a,b,c}
#define DC_STRUCT4(a,b,c,d)                                  {a,b,c,d}
#define DC_STRUCT5(a,b,c,d,e)                              {a,b,c,d,e}
#define DC_STRUCT6(a,b,c,d,e,f)                          {a,b,c,d,e,f}
#define DC_STRUCT7(a,b,c,d,e,f,g)                      {a,b,c,d,e,f,g}
#define DC_STRUCT8(a,b,c,d,e,f,g,h)                  {a,b,c,d,e,f,g,h}
#define DC_STRUCT9(a,b,c,d,e,f,g,h,i)              {a,b,c,d,e,f,g,h,i}
#define DC_STRUCT10(a,b,c,d,e,f,g,h,i,j)         {a,b,c,d,e,f,g,h,i,j}
#define DC_STRUCT11(a,b,c,d,e,f,g,h,i,j,k)     {a,b,c,d,e,f,g,h,i,j,k}
#define DC_STRUCT12(a,b,c,d,e,f,g,h,i,j,k,l) {a,b,c,d,e,f,g,h,i,j,k,l}
#define DC_STRUCT13(a,b,c,d,e,f,g,h,i,j,k,l,m)                       \
                                           {a,b,c,d,e,f,g,h,i,j,k,l,m}
#define DC_STRUCT14(a,b,c,d,e,f,g,h,i,j,k,l,m,n)                     \
                                         {a,b,c,d,e,f,g,h,i,j,k,l,m,n}
#define DC_STRUCT15(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)                   \
                                       {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o}
#define DC_STRUCT16(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)                 \
                                     {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p}
#define DC_STRUCT17(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q)               \
                                   {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q}
#define DC_STRUCT18(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r)             \
                                 {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r}
#define DC_STRUCT19(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s)           \
                               {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s}
#define DC_STRUCT20(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t)         \
                             {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t}
#define DC_STRUCT21(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u)       \
                           {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u}
#define DC_STRUCT22(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v)     \
                           {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v}
#define DC_STRUCT23(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w)   \
                           {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w}
#define DC_STRUCT24(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x) \
                           {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x}
#define DC_STRUCT25(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y) \
                           {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y}
#define DC_STRUCT26(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) \
                         {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z}
#define DC_STRUCT27(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,aa) \
                      {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,aa}
#define DC_STRUCT28(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,aa,bb) \
                      {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,aa,bb}
#define DC_STRUCT29(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,aa,bb,cc) \
                      {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,aa,bb,cc}
#define DC_STRUCT30(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z, \
                              aa,bb,cc,dd) \
                      {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z, \
                              aa,bb,cc,dd}
#define DC_STRUCT31(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z, \
                              aa,bb,cc,dd,ee) \
                      {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z, \
                              aa,bb,cc,dd,ee}
#define DC_STRUCT32(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z, \
                              aa,bb,cc,dd,ee,ff)                         \
                      {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z, \
                              aa,bb,cc,dd,ee,ff}
#define DC_STRUCT33(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z, \
                              aa,bb,cc,dd,ee,ff,gg)                      \
                      {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z, \
                              aa,bb,cc,dd,ee,ff,gg}
#define DC_STRUCT34(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z, \
                              aa,bb,cc,dd,ee,ff,gg,hh)                     \
                      {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z, \
                              aa,bb,cc,dd,ee,ff,gg,hh}
#define DC_STRUCT35(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,aa, \
                              bb,cc,dd,ee,ff,gg,hh,ii)                   \
                      {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z, \
                              aa,bb,cc,dd,ee,ff,gg,hh,ii}
#define DC_STRUCT36(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,aa, \
                              bb,cc,dd,ee,ff,gg,hh,ii,jj)                   \
                      {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z, \
                              aa,bb,cc,dd,ee,ff,gg,hh,ii,jj}
#define DC_STRUCT37(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,aa, \
                              bb,cc,dd,ee,ff,gg,hh,ii,jj,kk)                \
                      {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z, \
                              aa,bb,cc,dd,ee,ff,gg,hh,ii,jj,kk}
#define DC_STRUCT38(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,aa, \
                              bb,cc,dd,ee,ff,gg,hh,ii,jj,kk,ll)                \
                      {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z, \
                              aa,bb,cc,dd,ee,ff,gg,hh,ii,jj,kk,ll}
#define DC_STRUCT46(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,aa, \
                  bb,cc,dd,ee,ff,gg,hh,ii,jj,kk,ll,mm,nn,oo,PP,QQ,RR,SS,TT) \
                      {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z, \
                 aa,bb,cc,dd,ee,ff,gg,hh,ii,jj,kk,ll,mm,nn,oo,PP,QQ,RR,SS,TT}
#define DC_STRUCT64(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,aa, \
                              bb,cc,dd,ee,ff,gg,hh,ii,jj,kk,ll,mm,nn,oo,    \
                              pp,qq,rr,ss,tt,uu,vv,ww,xx,yy,zz,ab,ac,ad,ae, \
                              af,ag,ah,ai,aj,ak,al,am)                      \
                      {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z, \
                              aa,bb,cc,dd,ee,ff,gg,hh,ii,jj,kk,ll,mm,nn,oo, \
                              pp,qq,rr,ss,tt,uu,vv,ww,xx,yy,zz,ab,ac,ad,ae, \
                              af,ag,ah,ai,aj,ak,al,am}

/****************************************************************************/
/* The extern declarations macros...                                        */
/****************************************************************************/
#define DCI_EXTERN_DATA(TYPE, Name, VAL)              extern TYPE Name
#define DCI_EXTERN_DATA_NULL(TYPE, Name, VAL)         extern TYPE Name
#define DCI_EXTERN_DATA_ARRAY(TYPE, Name, Size, VAL)  extern TYPE Name[Size]
#define DCI_EXTERN_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)             \
                                                extern TYPE Name[Size1][Size2]
#define DCI_EXTERN_CONST_DATA_ARRAY(TYPE, Name, Size, VAL)                  \
                                                extern const TYPE Name[Size]
#define DCI_EXTERN_CONST_DATA(TYPE, Name, VAL)  extern const TYPE Name
#define DCI_EXTERN_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)       \
                                         extern const TYPE Name[Size1][Size2]

/****************************************************************************/
/* The no-op macros...                                                      */
/****************************************************************************/
#define DCI_NO_DATA(TYPE, Name, VAL)
#define DCI_NO_DATA_NULL(TYPE, Name, VAL)
#define DCI_NO_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_NO_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)

/****************************************************************************/
/* The declaration macros...                                                */
/****************************************************************************/
#define DCI_DEFINE_DATA(TYPE, Name, VAL)              TYPE Name
#define DCI_DEFINE_DATA_NULL(TYPE, Name, VAL)         TYPE Name
#define DCI_DEFINE_DATA_ARRAY(TYPE, Name, Size, VAL)  TYPE Name[Size]
#define DCI_DEFINE_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)            \
                                                       TYPE Name[Size1][Size2]
#define DCI_DEFINE_CONST_DATA(TYPE, Name, VAL)        static const TYPE Name
#define DCI_DEFINE_CONST_DATA_ARRAY(TYPE, Name, Size, VAL)      \
                                                  static const TYPE Name[Size]
#define DCI_DEFINE_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)      \
                                          static const TYPE Name[Size1][Size2]

/****************************************************************************/
/* The define-and-assign macros...                                          */
/****************************************************************************/
#define DCI_INIT_DATA(TYPE, Name, VAL)              TYPE  Name = VAL
#define DCI_INIT_DATA_NULL(TYPE, Name, VAL)         TYPE  Name = VAL
#define DCI_INIT_DATA_ARRAY(TYPE, Name, Size, VAL)  TYPE  Name[Size] = { VAL }
#define DCI_INIT_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL) \
                                            TYPE  Name[Size1][Size2] = { VAL }

/****************************************************************************/
/* The vanilla C version                                                    */
/****************************************************************************/
#define DCI_INIT_CONST_DATA(TYPE, Name, VAL)  const TYPE SHCLASS Name = VAL
#define DCI_INIT_CONST_DATA_ARRAY(TYPE, Name, Size, VAL) \
                                        const TYPE SHCLASS Name[Size] = VAL
#define DCI_INIT_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL) \
                                const TYPE SHCLASS Name[Size1][Size2] = VAL

/****************************************************************************/
/* The procedural code initialisation macros...                             */
/****************************************************************************/
#define DCI_ASSIGN_DATA(TYPE, Name, VAL)     Name = VAL
#define DCI_ASSIGN_DATA_NULL(TYPE, Name, VAL)                   Error!
#define DCI_ASSIGN_DATA_ARRAY_NULL(TYPE, Name, Size, VAL)       Error!
#define DCI_ASSIGN_DATA_ARRAY(TYPE, Name, Size, VAL)            Error!
#define DCI_ASSIGN_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL) Error!

/****************************************************************************/
/* The mem-cpy and -set initialisation macros...                            */
/****************************************************************************/
#define DCI_SET_DATA_NULL(TYPE, Name, VAL)  memset(&Name, 0, sizeof(TYPE))
#define DCI_SET_DATA_ARRAY_NULL(TYPE, Name, Size, VAL)       \
                                     memset(&Name, 0, Size*sizeof(TYPE))
#define DCI_SET_DATA_ARRAY_VAL(TYPE, Name, Size, VAL)        \
                                     memset(&Name, VAL, Size*sizeof(TYPE))

#endif /*H_NDCGDATA*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\cbchash.h ===
/* (C) 1998 Microsoft Corp.
 *
 * cbchash.h
 *
 * Header for CBC64 hash function.
 */
#ifndef __CBCHASH_H
#define __CBCHASH_H


// Alpha must be odd.
#define CBC_RandomOddAlpha 0xF90919A1
#define CBC_RandomBeta     0xF993291A


// Holds state variables for CBC64, to allow FirstCBC64() and NextCBC64()
// behavior using the passed context.
typedef struct {
    // Private variable to maintain state.
    UINT32 Datum;

    // Current key values. These are public for reading by the caller.
    UINT32 Key1, Key2;

    // Current plain checksum value. This is public for reading.
    UINT32 Checksum;
} CBC64Context;


extern const UINT32 CBC_AB[2];
extern const UINT32 CBC_CD[2];


void __fastcall NextCBC64(CBC64Context *, UINT32 *, unsigned);


__inline void __fastcall FirstCBC64(
        CBC64Context *pContext,
        UINT32 *pData,
        unsigned NumDWORDBlocks)
{
    pContext->Key1 = pContext->Key2 = pContext->Datum = CBC_RandomOddAlpha *
            (*pData) + CBC_RandomBeta;
    pContext->Key1 = (pContext->Key1 << 1) ^
            (CBC_CD[(pContext->Key1 & 0x80000000) >> 31]);
    pContext->Key2 = (pContext->Key2 << 1) ^
            (CBC_AB[(pContext->Key2 & 0x80000000) >> 31]);
    pContext->Checksum = 0;
    NextCBC64(pContext, pData + 1, NumDWORDBlocks - 1);
}



#endif  // !defined(__CBCHASH_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\nddapi.h ===
/****************************************************************************/
/* nddapi.h                                                                 */
/*                                                                          */
/* RDP DD functions.                                                        */
/*                                                                          */
/* Copyright(c) Microsoft 1996-2000                                         */
/****************************************************************************/
#ifndef _H_NDDAPI
#define _H_NDDAPI


/****************************************************************************/
/* Structure: DD_PDEV                                                       */
/*                                                                          */
/* Contents of the handle that the GDI always passes to the display driver. */
/* This structure is filled in from DrvEnablePDEV.                          */
/****************************************************************************/
typedef struct  tagDD_PDEV
{
    ULONG       iBitmapFormat;          /* Current colour depth as defined  */
                                        /* by the BMF_xBPP flags.           */

    /************************************************************************/
    /* Rendering extensions colour information.                             */
    /************************************************************************/
    HANDLE      hDriver;                /* Handle to \Device\Screen         */
    HDEV        hdevEng;                /* Engine's handle to PDEV          */
    HSURF       hsurfFrameBuf;          /* Frame Buffer surface (bitmap)    */
    HSURF       hsurfDevice;            /* Device surface (used by engine)  */
    SURFOBJ    *psoFrameBuf;            /* pointer to frame buffer SURFOBJ   */

    LONG        cxScreen;               /* Visible screen width             */
    LONG        cyScreen;               /* Visible screen height            */
    LONG        cClientBitsPerPel;      /* Client display bpp (4,8,15,etc)  */
    LONG        cProtocolBitsPerPel;    /* Protocol bpp (8)                 */
    ULONG       ulMode;                 /* Mode the mini-port driver is in. */

    FLONG       flHooks;                /* What we're hooking from GDI      */

    /************************************************************************/
    /* Pointer to the Frame Buffer                                          */
    /************************************************************************/
    PBYTE       pFrameBuf;

    HANDLE      SectionObject;          /* Section Object for Frame Buffer  */

    /************************************************************************/
    /* Palette stuff.                                                       */
    /************************************************************************/
    HPALETTE    hpalDefault;            /* GDI handle to the default palette*/
    FLONG       flRed;                  /* Red mask for bitmask modes       */
    FLONG       flGreen;                /* Green mask for bitmask modes     */
    FLONG       flBlue;                 /* Blue mask for bitmask modes      */

    // NOTE!! This must be the last entry else the memset(0) code in nddapi.c
    // will get messed up.
    PALETTEENTRY Palette[256];          /* The palette if palette managed   */
} DD_PDEV, * PDD_PDEV;


/****************************************************************************/
// Structure: DD_DSURF
//
// Device surface for the offscreen bitmaps
/****************************************************************************/
typedef struct tagDD_DSURF
{
    ULONG     bitmapId;
    INT       shareId;

    SIZEL     sizl;          // size of the offscreen bitmap
    ULONG     iBitmapFormat; // color depth for the bitmap, 
                             // defined by the BMF_xBPP flags.  

    PDD_PDEV  ppdev;         // Need this for deleting the bitmap
    SURFOBJ   *pso;          // points to the backup GDI surface
    
    ULONG     flags;         
#define DD_NO_OFFSCREEN  0x1 // If this flag is on, it indicates that the bitmap
                             // has been punt off the offscreen list,
                             // or there is a client offscreen error.
                             // Either case, the server has to send the offscreen
                             // bitmap as regular memory cached bitmap.
} DD_DSURF, * PDD_DSURF;   


/****************************************************************************/
/* Number of functions supported by our display driver.                     */
/****************************************************************************/
#ifdef DRAW_GDIPLUS
#ifdef DRAW_NINEGRID
#define DD_NUM_DRIVER_INTERCEPTS   38
#else
#define DD_NUM_DRIVER_INTERCEPTS   37
#endif
#else // DRAW_GDIPLUS
#ifdef DRAW_NINEGRID
#define DD_NUM_DRIVER_INTERCEPTS   37
#else
#define DD_NUM_DRIVER_INTERCEPTS   36
#endif
#endif //DRAWGDIPLUS

#ifdef DRAW_NINEGRID
#define INDEX_DrvNineGrid          91L
#define GCAPS2_REMOTEDRIVER        0x00000400

typedef struct NINEGRID
{
   ULONG        flFlags;
   LONG         ulLeftWidth;
   LONG         ulRightWidth;
   LONG         ulTopHeight;
   LONG         ulBottomHeight;
   COLORREF     crTransparent;
} NINEGRID, *PNINEGRID;

BOOL DrvNineGrid(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    PRECTL      prclDst,
    PRECTL      prclSrc,
    PNINEGRID   png,
    BLENDOBJ   *pBlendObj,
    PVOID       pvReserved
);

BOOL APIENTRY EngNineGrid(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    PRECTL      prclDst,
    PRECTL      prclSrc,
    PNINEGRID   png,
    BLENDOBJ   *pBlendObj,
    PVOID       pvReserved
);

#endif

/****************************************************************************/
/* Name of the display driver as passed back in the DEVMODEW structure.     */
/****************************************************************************/
#define DD_DLL_NAME L"rdpdd"


/****************************************************************************/
/* Prototypes.                                                              */
/****************************************************************************/
#ifdef DC_DEBUG
void DrvDebugPrint(char *, ...);
#endif



#endif /* _H_NDDAPI  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\nddifn.h ===
/****************************************************************************/
// nddifn.h
//
// Function prototypes for DD internal functions
//
// Copyright (C) 1996-2000 Microsoft Corporation
/****************************************************************************/

BOOL RDPCALL DDInit(PDD_PDEV, BOOL, BOOL, PTSHARE_VIRTUAL_MODULE_DATA, UINT32);

void RDPCALL DDTerm(void);

void RDPCALL DDDisconnect(BOOL);

void RDPCALL DDInitializeModeFields(PDD_PDEV, GDIINFO *, GDIINFO *,
        DEVINFO *, DEVMODEW *);

BOOL RDPCALL DDInitializePalette(PDD_PDEV, DEVINFO *);

INT32 RDPCALL DDGetModes(HANDLE, PVIDEO_MODE_INFORMATION *, PINT32);

// DirectDraw Functions
DWORD DdLock(PDD_LOCKDATA  lpLock);

DWORD DdUnlock(PDD_UNLOCKDATA  lpUnlock);

DWORD DdMapMemory(PDD_MAPMEMORYDATA  lpMapMemory);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\noeinl.h ===
/****************************************************************************/
// noeinl.h
//
// Function prototypes for NT OE inline API functions.
//
// Copyright (C) 1996-2000 Microsoft Corporation
/****************************************************************************/
#ifndef _H_NOEINL
#define _H_NOEINL

#define DC_INCLUDE_DATA
#include <noedata.c>
#undef DC_INCLUDE_DATA


/****************************************************************************/
// OE_SendAsOrder
//
// Check the negotiated data to determine if this call can be sent as a
// drawing order.
/****************************************************************************/
__inline BOOL RDPCALL OE_SendAsOrder(unsigned order)
{
    return (BOOL)oeOrderSupported[oeEncToNeg[order]];
}


/****************************************************************************/
// OEGetSurfObjBitmap
//
// This function checks a SURFOBJ pointer, and if it points to a (the) device
// SURFOBJ, returns a pointer to the actual bitmap's SURFOBJ.
// Assumes that pso is non-NULL.
/****************************************************************************/
_inline SURFOBJ * RDPCALL OEGetSurfObjBitmap(SURFOBJ *pso, PDD_DSURF *ppdsurf)
{
    DC_BEGIN_FN("OEGetSurfObjBitmap");

    TRC_ASSERT(((pso) != NULL), (TB, "NULL surfobj"));

    // Primary Device Surface, this is our backup frame buffer for
    // the client desktop screen, the bitmap is saved in dhsurf
    if (pso->iType == STYPE_DEVICE) {
        TRC_ASSERT((pso->dhsurf != NULL),
                   (TB, "NULL dhsurf for pso(%p)", pso));
        *ppdsurf = NULL;
        return(SURFOBJ *)(pso->dhsurf);
    }

    // Offscreen Bitmap Surface, the backup offscreen bitmap
    // is saved in the pso field of dhsurf.
    else if (pso->iType == STYPE_DEVBITMAP) {
        TRC_ASSERT((pso->dhsurf != NULL),
                   (TB, "NULL dhsurf for pso(%p)", pso));
        *ppdsurf = (PDD_DSURF)(pso->dhsurf);
        return ((PDD_DSURF)(pso->dhsurf))->pso;
    }

    // GDI handled DIB surface.
    else {
        *ppdsurf = NULL;
        return pso;
    }

    DC_END_FN();
    return pso;
}



#endif  // !defined(_H_NOEINL)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\nschdisp.h ===
/****************************************************************************/
/* nschdisp.h                                                               */
/*                                                                          */
/* Display Driver Scheduler API Header File.                                */
/*                                                                          */
/* Copyright (C) 1997-1999 Microsoft Corp.                                  */
/****************************************************************************/
#ifndef _H_NSCHDISP
#define _H_NSCHDISP

#include <nddapi.h>


void RDPCALL SCH_InitShm(void);

NTSTATUS RDPCALL SCH_DDOutputAvailable(PDD_PDEV, BOOL);

BOOL RDPCALL SCHEnoughOutputAccumulated(void);



#endif   /* #ifndef _H_NSCHDISP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\nshmapi.h ===
/****************************************************************************/
// nshmapi.h
//
// RDP Display Driver/Share Core shared memory
//
// Copyright (C) 1996-2000 Microsoft Corporation
/****************************************************************************/
#ifndef _H_NSHMAPI
#define _H_NSHMAPI

#include <adcs.h>
#include <aordprot.h>
#include <aoaapi.h>
#include <abaapi.h>
#include <asbcapi.h>
#include <acmapi.h>
#include <apmapi.h>
#include <aschapi.h>
#include <aoeapi.h>
#include <assiapi.h>
#include <abcapi.h>
#include <compress.h>


#define SHM_CHECKVAL  (UINT32)'!mhs'   // "shm!"


// Max size allowed for data to be input to the bulk MPPC compressor.
#ifdef DC_HICOLOR
#define MAX_COMPRESS_INPUT_BUF 16384
#else
#define MAX_COMPRESS_INPUT_BUF 8192
#endif

// Allocation size for a temp buffer used to hold data to be compressed with
// MPPC. This data must fit into an 8K OUTBUF, so we might as well not alloc
// the OUTBUF overhead size we'll never use anyway. See aschapi.h for
// constants used for allocations.
#define MAX_COMPRESSED_BUFFER (MAX_COMPRESS_INPUT_BUF - OUTBUF_OVERHEAD)


/****************************************************************************/
/* Format of the shadow data shared between stacks                          */
/****************************************************************************/
typedef struct tagSHADOW_INFO {
    ULONG messageSize;
#ifdef DC_HICOLOR
    // Note we can't just send a chunk bigger than 16k - we have to introduce
    // an overflow buffer for high color
    ULONG messageSizeEx;
#endif
    ULONG flags;
    ULONG senderID;
    ULONG channelID;
    BYTE  data[1];
} SHADOW_INFO, *PSHADOW_INFO;


/****************************************************************************/
/* Structure:   SHM_SHARED_MEMORY                                           */
/*                                                                          */
/* Description:                                                             */
/* Shared memory as used by the display driver and share core to            */
/* communicate.  It is divided up into sub-structures for each component    */
/* that uses the shared mem, each sub-struct being named after the owning   */
/* component.                                                               */
/****************************************************************************/
typedef struct tagSHM_SHARED_MEMORY
{
    /************************************************************************/
    /* We deliberately compile the guard values into the retail build       */
    /* as well as the debug build so that we can mix-n-match retail and     */
    /* debug wd/dd drivers (the shared memory format must be the same for   */
    /* both).                                                               */
    /************************************************************************/
    UINT32 guardVal1;

    INT32 shareId;

    BOOLEAN fShmUpdate;

    PSHADOW_INFO pShadowInfo; /* used by the primary and shadow        */
                              /* stack(s) for communication.           */

    /************************************************************************/
    // NOTE!!: Each component must make sure to init its Shm component.
    // We do NOT zero the shm on alloc to reduce init-time paging and cache
    // flushing.
    /************************************************************************/
    BA_SHARED_DATA  ba;            /* Accumulated bounds.                   */
    OA_SHARED_DATA  oa;            /* Order heap.                           */
    OE_SHARED_DATA  oe;            /* Transfer buffer for new parameters    */
    CM_SHARED_DATA  cm;            /* Location for DD to put cursor details */
    SCH_SHARED_DATA sch;           /* SCH shared data                       */
    PM_SHARED_DATA  pm;            /* PM shared data                        */
    SSI_SHARED_DATA ssi;           /* SSI shared data                       */
    SBC_SHARED_DATA sbc;           /* SBC shared data                       */
    BC_SHARED_DATA  bc;            // BC work buffers.

    UINT32 guardVal2;

    // Uninitialized work buffer for screen data compression.
    // Better in this case to use session space memory instead of putting
    // this in the ShareClass allocation in system space -- session space
    // PTEs are essentially unlimited.
    BYTE sdgTransferBuffer[MAX_UNCOMPRESSED_DATA_SIZE];

    UINT32 guardVal3;

#ifdef DC_DEBUG
    TRC_SHARED_DATA trc;           /* TRC shared data                       */
#endif

    UINT32 guardVal4;

    UINT32 guardVal5;
} SHM_SHARED_MEMORY, *PSHM_SHARED_MEMORY, **PPSHM_SHARED_MEMORY;


/****************************************************************************/
// Prototypes.
/****************************************************************************/
#ifdef DLL_DISP

#include <nddapi.h>
BOOLEAN RDPCALL SHM_Init(PDD_PDEV pPDev);
void RDPCALL SHM_Term(void);

#endif



#endif  // !defined(_H_NSHMAPI)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\nprcount.h ===
/****************************************************************************/
// nprcount.h
//
// Constants/defines for profiling counters used by Terminal Server code.
//
// Copyright (C) 1998-2000 Microsoft Corporation
/****************************************************************************/
#ifndef _H_NPRCOUNT
#define _H_NPRCOUNT


/****************************************************************************/
/* The Terminal Server TermDD stack maintains a WINSTATIONINFORMATION       */
/* record per Winstation.  One of the fields in this record is a pointer to */
/* a PROTOCOLSTATUS record.  Contained within the protocolstatus record are */
/* statistics fields that the stack can fill in to hold "interesting"       */
/* numbers (e.g.  the number of LineTo orders sent in total).  Some of the  */
/* numbers are maintained by the ICADD common code, but some are protocol   */
/* specific and hence up for grabs by the TShare stack.                     */
/*                                                                          */
/* The available counters are split up as follows                           */
/* - 10 cache statistics (each contains two numbers: #of reads, #of hits)   */
/* - 100 output counters                                                    */
/* - 100 input counters                                                     */
/****************************************************************************/

// We don't need to be doing the work of incrementing counters when
// we are not actively looking at the data. Define DC_COUNTERS to enable
// the counters for analysis.
#ifdef DC_COUNTERS

#ifdef DLL_DISP
#define INC_INCOUNTER(x) pddProtStats->Input.Specific.Reserved[x]++
#define ADD_INCOUNTER(x, y) pddProtStats->Input.Specific.Reserved[x] += y
#define INC_OUTCOUNTER(x) pddProtStats->Output.Specific.Reserved[x]++
#define DEC_OUTCOUNTER(x) pddProtStats->Output.Specific.Reserved[x]--
#define ADD_OUTCOUNTER(x, y) pddProtStats->Output.Specific.Reserved[x] += y
#else
#define INC_INCOUNTER(x) m_pTSWd->pProtocolStatus->Input.Specific.Reserved[x]++
#define ADD_INCOUNTER(x, y) m_pTSWd->pProtocolStatus->Input.Specific.Reserved[x] += y
#define SUB_INCOUNTER(x, y) m_pTSWd->pProtocolStatus->Input.Specific.Reserved[x] -= y
#define SET_INCOUNTER(x, y) m_pTSWd->pProtocolStatus->Input.Specific.Reserved[x] = y
#define INC_OUTCOUNTER(x) m_pTSWd->pProtocolStatus->Output.Specific.Reserved[x]++
#endif

#else  // DC_COUNTERS

#define INC_INCOUNTER(x)
#define ADD_INCOUNTER(x, y)
#define SET_INCOUNTER(x, y)
#define SUB_INCOUNTER(x, y)
#define INC_OUTCOUNTER(x)
#define DEC_OUTCOUNTER(x)
#define ADD_OUTCOUNTER(x, y)

#endif  // DC_COUNTERS


/****************************************************************************/
/* Index values for performance statistics counters                         */
/****************************************************************************/
#define BITMAP 0
#define GLYPH  1
#define BRUSH  2
#define SSI    3
#define FREE_4 4
#define FREE_5 5
#define FREE_6 6
#define FREE_7 7
#define FREE_8 8
#define FREE_9 9

// OUTPUT COUNTERS
#define OUT_BITBLT_ALL                    0 // No. of calls to DrvBitBlt
#define OUT_BITBLT_SDA                    1 // sent as SDA
#define OUT_BITBLT_NOOFFSCR               2 // DrvBitBlt calls failed due to no-offscr flag
#define OUT_BITBLT_SDA_ROP4               3 // SDA: ROP4
#define OUT_BITBLT_SDA_UNSUPPORTED        4 // SDA: order unsupported
#define OUT_BITBLT_SDA_NOROP3             5 // SDA: unsupported ROP3
#define OUT_BITBLT_SDA_COMPLEXCLIP        6 // SDA: complex clipping
#define OUT_BITBLT_SDA_MBUNCACHEABLE      7 // SDA: uncacheable memblt
#define OUT_BITBLT_SDA_NOCOLORTABLE       8 // SDA: color table not queued
#define OUT_BITBLT_SDA_HEAPALLOCFAILED    9 // SDA: failed to alloc heap order
#define OUT_BITBLT_SDA_SBCOMPLEXCLIP     10 // SDA: ScrBlt complex clip
#define OUT_BITBLT_SDA_M3BCOMPLEXBRUSH   11 // SDA: Mem3Blt with complex brush
#define OUT_BITBLT_SDA_WINDOWSAYERING    12 // SDA: Windows layering bitmap

#define OUT_OFFSCREEN_BITMAP_ALL         13 // No. of calls to DrvCreateDeviceBitmap
#define OUT_OFFSCREEN_BITMAP_ORDER       14 // Number of Create Offscreen Bitmap orders sent.
#define OUT_OFFSCREEN_BITMAP_ORDER_BYTES 15 // Total size of Create Offscreen Bitmap orders.

#define OUT_SWITCHSURFACE                16 // Number of switch surface orders sent.
#define OUT_SWITCHSURFACE_BYTES          17 // Bytes of Switch Surface orders.

#define OUT_STRTCHBLT_ALL                18 // No. of calls to DrvStretchBlt
#define OUT_STRTCHBLT_SDA                19 // sent as SDA
#define OUT_STRTCHBLT_BITBLT             20 // passed to DrvBitBlt
#define OUT_STRTCHBLT_SDA_MASK           21 // SDA: mask specified
#define OUT_STRTCHBLT_SDA_COMPLEXCLIP    22 // SDA: complex clipping

#define OUT_COPYBITS_ALL                 23 // No. of calls to DrvCopyBits

#define OUT_TEXTOUT_ALL                  24 // No. of calls to DrvTextOut
#define OUT_TEXTOUT_SDA                  25 // sent as SDA
#define OUT_TEXTOUT_SDA_EXTRARECTS       26 // SDA: extra rects
#define OUT_TEXTOUT_SDA_NOSTRING         27 // SDA: no string
#define OUT_TEXTOUT_SDA_COMPLEXCLIP      28 // SDA: complex clipping
#define OUT_TEXTOUT_SDA_NOFCI            29 // SDA: Failed alloc fontcacheinfo
#define OUT_TEXTOUT_GLYPH_INDEX          30 // Num Index orders
#define OUT_TEXTOUT_FAST_GLYPH           31 // Num FastGlyph orders
#define OUT_TEXTOUT_FAST_INDEX           32 // Num FastIndex orders
#define OUT_CACHEGLYPH                   33 // Num Cache Glyph secondary orders
#define OUT_CACHEGLYPH_BYTES             34 // Bytes of Cache Glyph

#define OUT_CACHEBITMAP                  35 // Number of Cache Bitmap secondary orders
#define OUT_CACHEBITMAP_FAILALLOC        36 // Number of failures during heap alloc
#define OUT_CACHEBITMAP_BYTES            37 // Bytes of CacheBitmap

#define OUT_CACHECOLORTABLE              38 // Number of Cache Color Table secondary orders
#define OUT_CACHECOLORTABLE_BYTES        39 // CacheColorTable bytes

#define OUT_LINETO_ALL                   40 // No. of calls to DrvLineTo
#define OUT_LINETO_ORDR                  41 // sent as orders
#define OUT_LINETO_SDA                   42 // sent as SDA
#define OUT_LINETO_SDA_UNSUPPORTED       43 // SDA: order unsupported
#define OUT_LINETO_SDA_BADBRUSH          44 // SDA: unsupported brush
#define OUT_LINETO_SDA_COMPLEXCLIP       45 // SDA: complex clipping
#define OUT_LINETO_SDA_FAILEDADD         46 // SDA: failed to add order

#define OUT_STROKEPATH_ALL               47 // No. of calls to DrvStrokePath
#define OUT_STROKEPATH_SDA               48 // sent as SDA
#define OUT_STROKEPATH_UNSENT            49 // not sent
#define OUT_STROKEPATH_SDA_NOLINETO      50 // SDA: LineTo unsupported
#define OUT_STROKEPATH_SDA_BADBRUSH      51 // SDA: unsupported brush
#define OUT_STROKEPATH_SDA_COMPLEXCLIP   52 // SDA: complex clipping
#define OUT_STROKEPATH_SDA_FAILEDADD     53 // SDA: failed to add line
#define OUT_STROKEPATH_POLYLINE          54 // PolyLine orders sent
#define OUT_STROKEPATH_ELLIPSE_SC        55 // Hollow ellipses sent.

#define OUT_FILLPATH_ALL                 56 // No. of calls to DrvFillPath
#define OUT_FILLPATH_SDA                 57 // sent as SDA
#define OUT_FILLPATH_UNSENT              58 // not sent
#define OUT_FILLPATH_SDA_NOPOLYGON       59 // SDA: polygon unsupported
#define OUT_FILLPATH_SDA_BADBRUSH        60 // SDA: unsupported brush
#define OUT_FILLPATH_SDA_COMPLEXCLIP     61 // SDA: complex clipping
#define OUT_FILLPATH_SDA_FAILEDADD       62 // SDA: failed to add polygon
#define OUT_FILLPATH_ELLIPSE_SC          63 // Ellipse solid color
#define OUT_FILLPATH_ELLIPSE_CB          64 // Ellipse color brush
#define OUT_FILLPATH_POLYGON_SC          65 // Polygon solid solid color
#define OUT_FILLPATH_POLYGON_CB          66 // Polygon color brush

#define OUT_DSTBLT_ORDER            67 // DstBlt orders
#define OUT_MULTI_DSTBLT_ORDER      68 // MultiDstBlt orders
#define OUT_PATBLT_ORDER            69 // PatBlt orders
#define OUT_MULTI_PATBLT_ORDER      70 // MultiPatBlt orders
#define OUT_OPAQUERECT_ORDER        71 // OpaqueRect orders
#define OUT_MULTI_OPAQUERECT_ORDER  72 // MultiOpaqueRect orders
#define OUT_SCRBLT_ORDER            73 // ScrBlt orders
#define OUT_MULTI_SCRBLT_ORDER      74 // MultiScrBlt orders
#define OUT_MEMBLT_ORDER            75 // MemBlt orders
#define OUT_MEM3BLT_ORDER           76 // Mem3Blt orders

#define OUT_PAINT_ALL               77 // No. of calls to DrvPaint
#define OUT_PAINT_SDA               78 // sent as SDA
#define OUT_PAINT_UNSENT            79 // not sent
#define OUT_PAINT_SDA_COMPLEXCLIP   80 // SDA: complex clipping

#define OUT_BRUSH_ALL               81 // No. of calls to DrvRealizeBrush
#define OUT_BRUSH_STORED            82 // brush gets stored
#define OUT_BRUSH_MONO              83 // brush was mono, not standard
#define OUT_BRUSH_STANDARD          84 // standard brush
#define OUT_BRUSH_REJECTED          85 // cannot be sent over the wire
#define OUT_CACHEBRUSH              86 // CacheBrushPDUs sent.
#define OUT_CACHEBRUSH_BYTES        87 // Bytes of CacheBrushPDU

//free: 88-89

#define OUT_SAVESCREEN_ALL           90 // No. of calls to DrvSaveScreenBits
#define OUT_SAVEBITMAP_ORDERS        91 // sent as orders
#define OUT_SAVESCREEN_UNSUPP        92 // not handled cos order not supported

#define OUT_CHECKBRUSH_NOREALIZATION 93 // CheckBrush failed - not realized
#define OUT_CHECKBRUSH_COMPLEX       94 // CheckBrush failed - complex brush

// free: 95-99


// "Input" counters (not really input-related, just used as more space for
// counters).
#define CORE_IN_COUNT     (m_pTSWd->pProtocolStatus)->Input.Specific.Reserved
#define IN_SCH_SMALL_PAYLOAD  0    // PDU small target size
#define IN_SCH_LARGE_PAYLOAD  1    // PDU large target size
#define IN_SCH_OUT_ALL        2    // Number of calls to SCH_DDOutputAvailable

// Flush reasons:
#define IN_SCH_MUSTSEND       3       // due to timer pop
#define IN_SCH_OUTPUT         4       // Output estimate reached target
#define IN_SCH_OE_NUMBER      5       // due to reached heap limit
#define IN_SCH_NEW_CURSOR     6       // due to new cursor shape
#define IN_SCH_ASLEEP         7       // due to first output while asleep
#define IN_SCH_DO_NOTHING     8       // nowt to do, sum to total.

#define IN_SND_TOTAL_ORDER    9       // total number of orders sent
#define IN_SND_ORDER_BYTES   10       // uncompressed raw update orders
#define IN_SND_NO_BUFFER     11       // failed to allocate an OutBuf

#define IN_MEMBLT_BYTES           12
#define IN_MEM3BLT_BYTES          13
#define IN_DSTBLT_BYTES           14
#define IN_MULTI_DSTBLT_BYTES     15
#define IN_OPAQUERECT_BYTES       16
#define IN_MULTI_OPAQUERECT_BYTES 17
#define IN_PATBLT_BYTES           18
#define IN_MULTI_PATBLT_BYTES     19
#define IN_SCRBLT_BYTES           20
#define IN_MULTI_SCRBLT_BYTES     21
#define IN_LINETO_BYTES           22
#define IN_FASTGLYPH_BYTES        23
#define IN_FASTINDEX_BYTES        24
#define IN_GLYPHINDEX_BYTES       25
#define IN_POLYLINE_BYTES         26
#define IN_ELLIPSE_SC_BYTES       27
#define IN_ELLIPSE_CB_BYTES       28
#define IN_POLYGON_SC_BYTES       29
#define IN_POLYGON_CB_BYTES       30
#define IN_SAVEBITMAP_BYTES       31

#define IN_REPLAY_ORDERS          40
#define IN_REPLAY_BYTES           41

#define IN_SND_SDA_ALL        42      // Number of calls to SDG_SendSDA
#define IN_SND_SDA_AREA       43      // uncompressed bytes of SDA
#define IN_SND_SDA_PDUS       44      // number of SDA packets

#define IN_SDA_BITBLT_ROP4_AREA        45
#define IN_SDA_BITBLT_NOROP3_AREA      46
#define IN_SDA_BITBLT_COMPLEXCLIP_AREA 47
#define IN_SDA_OPAQUERECT_AREA         48
#define IN_SDA_PATBLT_AREA             49
#define IN_SDA_DSTBLT_AREA             50
#define IN_SDA_MEMBLT_AREA             51
#define IN_SDA_MEM3BLT_AREA            52
#define IN_SDA_SCRBLT_AREA             53
#define IN_SDA_SCRSCR_FAILROP_AREA     54
#define IN_SDA_TEXTOUT_AREA            55
#define IN_SDA_LINETO_AREA             56
#define IN_SDA_STROKEPATH_AREA         57
#define IN_SDA_FILLPATH_AREA           58

//free: 59-84

#define IN_PKT_TOTAL_SENT     85      // total number of packets sent
#define IN_PKT_BYTE_SPREAD1   86      // sent pkt of 0  - 200    bytes
#define IN_PKT_BYTE_SPREAD2   87      // sent pkt of 201 - 400   bytes
#define IN_PKT_BYTE_SPREAD3   88      // sent pkt of 401 -  600  bytes
#define IN_PKT_BYTE_SPREAD4   89      // sent pkt of 601  - 800  bytes
#define IN_PKT_BYTE_SPREAD5   90      // sent pkt of 801  - 1000 bytes
#define IN_PKT_BYTE_SPREAD6   91      // sent pkt of 1001 - 1200 bytes
#define IN_PKT_BYTE_SPREAD7   92      // sent pkt of 1201 - 1400 bytes
#define IN_PKT_BYTE_SPREAD8   93      // sent pkt of 1401 - 1600 bytes
#define IN_PKT_BYTE_SPREAD9   94      // sent pkt of 1601 - 2000 bytes
#define IN_PKT_BYTE_SPREAD10  95      // sent pkt of 2001 - 4000 bytes
#define IN_PKT_BYTE_SPREAD11  96      // sent pkt of 4001 - 6000 bytes
#define IN_PKT_BYTE_SPREAD12  97      // sent pkt of 6001 - 8000 bytes
#define IN_PKT_BYTE_SPREAD13  98      // sent pkt of >8000       bytes
#define IN_MAX_PKT_SIZE       99      // biggest single datalen for MCS



#endif /* _H_NPRCOUNT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\nwdwapi.h ===
/****************************************************************************/
// nwdwapi.h
//
// General RDPWD header.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/
#ifndef _H_NWDWAPI
#define _H_NWDWAPI

#include <tsrvexp.h>
#include "license.h"
#include <tssec.h>
#include <at120ex.h>
#include <nshmapi.h>
#include <pchannel.h>

#include <MCSKernl.h>


/****************************************************************************/
/* Constants                                                                */
/****************************************************************************/

/****************************************************************************/
/* @@@MF Need to calculated real values for the following numbers           */
/* Remeber that buffer size needs to allow for 32K of T.128 data ??plus hdr */
/* size.                                                                    */
/****************************************************************************/
#define TSHARE_WD_BUFFER_COUNT 5
#define TSHARE_TD_BUFFER_SIZE  (NET_MAX_SIZE_SEND_PKT + 1000)

/****************************************************************************/
/* Macro for splitting the function from an IOCtl                           */
/****************************************************************************/
#define WDW_IOCTL_FUNCTION(ioctl) (((ioctl) >> 2) & 0xfff)

/****************************************************************************/
/* Max decl def's                                                           */
/****************************************************************************/
#define WD_MAX_DOMAIN_LENGTH        48
#define WD_MAX_USERNAME_LENGTH      48
#define WD_MAX_PASSWORD_LENGTH      48
#define WD_MAX_SHADOW_BUFFER        (8192 * 2)
#define WD_MIN_COMPRESS_INPUT_BUF   50

#define WD_VC_DECOMPR_REASSEMBLY_BUF (CHANNEL_CHUNK_LENGTH*2)


/****************************************************************************/
/* ID of the 'Thinwire' virtual channel                                     */
/****************************************************************************/
#define WD_THINWIRE_CHANNEL     7

typedef struct tagMALLOC_HEADER MALLOC_HEADER, * PMALLOC_HEADER;
typedef struct tagMALLOC_HEADER
{
    PMALLOC_HEADER pNext;
    PMALLOC_HEADER pPrev;
    PVOID          pCaller;
    UINT32         length;
} MALLOC_HEADER, * PMALLOC_HEADER;

typedef struct tagTSHARE_WD {
    /************************************************************************/
    /* Returned from MCS initialization. Needed to attach a user to MCS.    */
    /* NOTE: This MUST be first in struct. MCS will assume so.              */
    /************************************************************************/
    DomainHandle hDomainKernel;

    /************************************************************************/
    /* Pointer back to the SDCONTEXT that is passed in on all calls.        */
    /************************************************************************/
    PSDCONTEXT pContext;

    /************************************************************************/
    /* Is this WD prepared to process data?                                 */
    /************************************************************************/
    BOOLEAN dead;

    /************************************************************************/
    /* Shadow data                                                          */
    /************************************************************************/
    BOOLEAN       bInShadowShare;
    BYTE          HotkeyVk;
    USHORT        HotkeyModifiers;
    PSHADOW_INFO  pShadowInfo;
    PSHADOWCERT   pShadowCert;
    PCLIENTRANDOM pShadowRandom;
    PUSERDATAINFO pUserData;

    UINT32        shadowState;
    #define       SHADOW_NONE   0
    #define       SHADOW_CLIENT 1
    #define       SHADOW_TARGET 2

    /************************************************************************/
    /* Pointer to protocol counters struct                                  */
    /************************************************************************/
    PPROTOCOLSTATUS pProtocolStatus;

    /************************************************************************/
    /* Display characteristics                                              */
    /************************************************************************/
    unsigned desktopHeight;
    unsigned desktopWidth;
    unsigned desktopBpp;
#ifdef DC_HICOLOR
    unsigned supportedBpps; // holds RNS_UD_xxBPP_SUPPORT OR'ed flags
    unsigned maxServerBpp;
#endif

    /************************************************************************/
    /* Timer to kick to talk to the DD                                      */
    /************************************************************************/
    PKTIMER ritTimer;

    /************************************************************************/
    /* Events to sleep on while waiting for                                 */
    /* - the connected indication                                           */
    /* - Share creation to complete.                                        */
    /* - security transaction tp complete.                                  */
    /************************************************************************/
    PKEVENT pConnEvent;
    PKEVENT pCreateEvent;
    PKEVENT pSecEvent;
    PKEVENT pSessKeyEvent;
    PKEVENT pClientDisconnectEvent;

    // Associated error returns.
    NTSTATUS SessKeyCreationStatus;

    /************************************************************************/
    /* Internal handles we need                                             */
    /************************************************************************/
    PVOID dcShare;
    PVOID pSmInfo;
    PVOID pNMInfo;
#ifdef USE_LICENSE
    PVOID pSLicenseHandle;
#endif

    /************************************************************************/
    /* Has the Share Class been initialized?                                */
    /************************************************************************/
    BOOLEAN shareClassInit;

    /************************************************************************/
    /* Has the WD connected successfully to the Client?                     */
    /************************************************************************/
    BOOLEAN connected;

    /************************************************************************/
    /* Was the Share created OK?                                            */
    /************************************************************************/
    BOOLEAN shareCreated;

    /************************************************************************/
    /* Other useful stuff from user data                                    */
    /************************************************************************/
    HANDLE    hDomain;
    UINT16    sas;
    UINT16    clientProductId;
    UINT32    version;
    ULONG     kbdLayout;
    UINT32    clientBuild;
    WCHAR     clientName[RNS_UD_CS_CLIENTNAME_LENGTH + 1];
    ChannelID broadcastChannel;
    ULONG     sessionId;
    ULONG     serialNumber;
    ULONG     clientAddressFamily;
    WCHAR     clientAddress[CLIENTADDRESS_LENGTH + 2];
    WCHAR     clientDir[DIRECTORY_LENGTH];
    RDP_TIME_ZONE_INFORMATION clientTimeZone;
    ULONG     clientSessionId;
    WCHAR       clientDigProductId[CLIENT_PRODUCT_ID_LENGTH]; //shadow loop fix

    //
    // Perf (slow link) disabled feature list (e.g wallpaper, themes)
    // defined in tsperf.h
    //
    ULONG     performanceFlags;

    //
    // Client's active input locale information
    // (i.e. HKL returned from GetKeyboardLayout)
    //
    UINT32    activeInputLocale;

    /************************************************************************/
    /* Temporary storage for an IOCtl.                                      */
    /************************************************************************/
    PSD_IOCTL pSdIoctl;

    /************************************************************************/
    /* Structs needed to support the keyboard IOCtls                        */
    /************************************************************************/
    KEYBOARD_TYPEMATIC_PARAMETERS KeyboardTypematic;
    KEYBOARD_INDICATOR_PARAMETERS KeyboardIndicators;
    PVOID   pgafPhysKeyState;
    PVOID   pKbdLayout;
    PVOID   pKbdTbl;
    PVOID   gpScancodeMap;
    BOOLEAN KeyboardType101;
    KEYBOARD_IME_STATUS KeyboardImeStatus;

    /************************************************************************/
    /* Name information                                                     */
    /************************************************************************/
    DLLNAME        DLLName;
    WINSTATIONNAME WinStationRegName;

    /************************************************************************/
    /* These are used by the COM registry functions to store the handle of  */
    /* an open key and to keep track of calls to COM_OpenRegistry and       */
    /* COM_CloseRegistry.                                                   */
    /************************************************************************/
    HANDLE  regKeyHandle;
    BOOLEAN regAttemptedOpen;

    /************************************************************************/
    /* For determining is a QUERY_VIRTUAL_BINDINGS has already occurred.    */
    /************************************************************************/
    BOOLEAN bVirtualChannelBound;

    /************************************************************************/
    /* StartSessionInfo data                                                */
    /************************************************************************/
    BOOLEAN         fDontDisplayLastUserName;
    RNS_INFO_PACKET *pInfoPkt;

    /************************************************************************/
    /* FE data                                                              */
    /************************************************************************/
    UINT32 keyboardType;
    UINT32 keyboardSubType;
    UINT32 keyboardFunctionKey;
    WCHAR  imeFileName[TS_MAX_IMEFILENAME];

    /************************************************************************/
    /* Transfer variables for scheduler settings.  These correspond to      */
    /* schNormalPeriod and schTurboPeriod respectively.                     */
    /************************************************************************/
    UINT32    outBufDelay;
    UINT32    interactiveDelay;

    /************************************************************************/
    // Connection info
    /************************************************************************/
    STACKCLASS StackClass;

    /*
     * Compression history
     */
    BOOLEAN bCompress;
    BOOLEAN bFlushed;
    BOOLEAN bOutputFlush;
    SendContext *pMPPCContext;
    BYTE *pCompressBuffer;

    /************************************************************************/
    /* Share load count                                                     */
    /************************************************************************/
    INT32     shareId;

    // Client load balancing capabilities.
    UINT32 bClientSupportsRedirection : 1;
    UINT32 bRequestedSessionIDFieldValid : 1;
    UINT32 bUseSmartcardLogon : 1;
    UINT32 RequestedSessionID;
    UINT32 ClientRedirectionVersion;

    // VC compression supported
    BOOLEAN bClientSupportsVCCompression;

    //
    // Recv decompression context
    // (this is 8K as VC's only support 8k compression
    //  from client to server) to limit memory usage and
    //  give better scalability.
    //
    RecvContext1 _DecomprContext1;
    RecvContext2_8K* _pRecvDecomprContext2;
    PUCHAR       _pVcDecomprReassemblyBuf;

    /************************************************************************/
    /* NOTE: Add new elements above here, so that the #ifdef DEBUG stuff    */
    /* below is always at the end.  This allows the KD extensions to work   */
    /* correctly for retail/debug builds.                                   */
    /************************************************************************/
    BOOL        bSupportErrorInfoPDU;
    BOOL        bForceEncryptedCSPDU;

#ifdef DC_DEBUG
    /************************************************************************/
    /* Memory allocation chain anchor point                                 */
    /************************************************************************/
    UINT32      breakOnLeak;
    MALLOC_HEADER memoryHeader;

    /************************************************************************/
    /* Trace config - should always be the last elements in this structure. */
    /************************************************************************/
    BOOL          trcShmNeedsUpdate;
    TRC_SHARED_DATA trc;
    char         traceString[TRC_BUFFER_SIZE];
#endif

    /************************************************************************/
    /* Channel Write Flow Control Sleep Interval                            */
    /************************************************************************/
    UINT32      flowControlSleepInterval;

    BOOL        fPolicyDisablesArc;
    //
    // Autoreconnect token
    //
    BOOL        arcTokenValid;
    UINT32      arcReconnectSessionID;
    BYTE        arcCookie[ARC_SC_SECURITY_TOKEN_LEN];
    

    /************************************************************************/
    /* The SM/NM data is allocated as part of the block of data containing  */
    /* this structure - it follows on at the next 4 byte boundary.          */
    /************************************************************************/

} TSHARE_WD, * PTSHARE_WD;


/****************************************************************************/
/* FUNCTION PROTOTYPES                                                      */
/****************************************************************************/

/****************************************************************************/
/* Firstly, those APIs that are called by ICADD.                            */
/****************************************************************************/
#ifdef __cplusplus      
extern "C" {
#endif

NTSTATUS DriverEntry( PSDCONTEXT, BOOLEAN );
NTSTATUS WD_Open( PTSHARE_WD, PSD_OPEN );
NTSTATUS WD_RawWrite( PTSHARE_WD, PSD_RAWWRITE );
NTSTATUS WD_Close( PTSHARE_WD, PSD_CLOSE );
NTSTATUS WD_ChannelWrite( PTSHARE_WD, PSD_CHANNELWRITE );
NTSTATUS WD_Ioctl( PTSHARE_WD, PSD_IOCTL );
void RDPCALL WDW_LogAndDisconnect(
        PTSHARE_WD pTSWd,
        BOOL       fSendErrorToClient,
        unsigned   errDetailCode,
        PBYTE      pDetailData,
        unsigned   detailDataLen);


/****************************************************************************/
/* Now those APIs that are called by the other components within the WD.    */
/****************************************************************************/
void RDPCALL WDW_OnSMConnecting(PVOID, PRNS_UD_SC_SEC, PRNS_UD_SC_NET);

void RDPCALL WDW_OnSMConnected(PVOID, unsigned);

void WDW_OnSMDisconnected(PVOID);

void WDW_InvalidateRect(
        PTSHARE_WD           pTSWd,
        PTS_REFRESH_RECT_PDU pRRPDU,
        unsigned             DataLength);

void WDW_OnDataReceived(PTSHARE_WD, PVOID, unsigned, UINT16);

PTS_CAPABILITYHEADER WDW_GetCapSet(
        PTSHARE_WD                pTSWd,
        UINT32                    CapSetType,
        PTS_COMBINED_CAPABILITIES pCaps,
        UINT32                    capsLength);

NTSTATUS RDPCALL WDW_WaitForConnectionEvent(PTSHARE_WD, PKEVENT, LONG);


/****************************************************************************/
/* Name:      WDW_ShareCreated                                              */
/*                                                                          */
/* Purpose:   Called by Share Core when Share Create process is complete    */
/*                                                                          */
/* Params:    pTSWd                                                         */
/*            result - TRUE  Share created OK                               */
/*                   - FALSE Share not created                              */
/****************************************************************************/
__inline void RDPCALL WDW_ShareCreated(PTSHARE_WD pTSWd, BOOLEAN result)
{
    /************************************************************************/
    /* Unblock the Connect IOCtl.                                           */
    /************************************************************************/
    pTSWd->shareCreated = result;
    KeSetEvent(pTSWd->pCreateEvent, EVENT_INCREMENT, FALSE);
}


/****************************************************************************/
/* Name:      WDW_Disconnect                                                */
/*                                                                          */
/* Purpose:   Disconnect the session                                        */
/*                                                                          */
/* Params:    pTSWd - pointer to WD structure                               */
/****************************************************************************/
__inline void WDW_Disconnect(PTSHARE_WD pTSWd)
{
    ICA_CHANNEL_COMMAND BrokenConn;

    BrokenConn.Header.Command = ICA_COMMAND_BROKEN_CONNECTION;
    BrokenConn.BrokenConnection.Reason = Broken_Disconnect;
    BrokenConn.BrokenConnection.Source = BrokenSource_User;
    IcaChannelInput(pTSWd->pContext, Channel_Command, 0, NULL,
            (BYTE *)&BrokenConn, sizeof(BrokenConn));
}


/****************************************************************************/
/* Name:      WDW_StartRITTimer                                             */
/*                                                                          */
/* Purpose:   Start the timer that will cause a kick to the WinStation's    */
/*            RIT.                                                          */
/*                                                                          */
/* Params:    IN    pTSWd      - pointer to WD struct                       */
/*            IN    milliSecs  - time period.                               */
/****************************************************************************/
__inline void WDW_StartRITTimer(PTSHARE_WD pTSWd, UINT32 milliSecs)
{
    if (pTSWd->ritTimer != NULL) {
        KeSetTimer(pTSWd->ritTimer, RtlConvertLongToLargeInteger(
                -((INT32)milliSecs * 10000)), NULL);
    }
}

/****************************************************************************/
// Returns the current state of the keyboard indicators.
/****************************************************************************/
__inline NTSTATUS WDW_QueryKeyboardIndicators(
        PTSHARE_WD pTSWd,
        PSD_IOCTL pSdIoctl)
{
    PKEYBOARD_INDICATOR_PARAMETERS pIndicator;

    if ( pSdIoctl->OutputBufferLength >=
            sizeof(KEYBOARD_INDICATOR_PARAMETERS)) {
        pIndicator = (PKEYBOARD_INDICATOR_PARAMETERS)
                pSdIoctl->OutputBuffer;
        *pIndicator = pTSWd->KeyboardIndicators;
        pSdIoctl->BytesReturned = sizeof(KEYBOARD_INDICATOR_PARAMETERS);
        return STATUS_SUCCESS;
    }
    else {
        return STATUS_BUFFER_TOO_SMALL;
    }
}


#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\nsbcinl.h ===
/****************************************************************************/
// nsbcinl.h
//
// SBC inline functions
//
// Copyright(C) Microsoft Corporation 1997-1999
/****************************************************************************/
#ifndef _H_NSBCINL
#define _H_NSBCINL

#include <nsbcdisp.h>

#define DC_INCLUDE_DATA
#include <nsbcddat.c>
#undef DC_INCLUDE_DATA


/****************************************************************************/
/* Name:      SBC_PaletteChanged                                            */
/*                                                                          */
/* Purpose:   Called when the palette changes.                              */
/****************************************************************************/
__inline void RDPCALL SBC_PaletteChanged(void)
{
    sbcPaletteChanged = TRUE;
}


/****************************************************************************/
// SBC_DDIsMemScreenBltCachable
//
// Checks the bitmap format for characteristics that make it uncachable.
// At this point no bitmaps are uncachable since we handle both RLE-encoded
// and regular bitmaps. For RLE bitmaps containing relative-motion deltas
// we have to set up a special flag which is used at the tile level to cause
// us to grab the background screen bits before blt-ing the RLE bitmap over
// them. We also prescan for non-delta RLEs which can be cached normally.
// See MSDN query on "Bitmap Compression" for details on RLE encoding, and
// see comments below.
/****************************************************************************/
__inline BOOLEAN RDPCALL SBC_DDIsMemScreenBltCachable(
        PMEMBLT_ORDER_EXTRA_INFO pMemBltInfo)
{
    BOOLEAN rc = TRUE;
    SURFOBJ *pSourceSurf;
    
    DC_BEGIN_FN("SBC_DDIsMemScreenBltCachable");

    if (sbcEnabled & SBC_BITMAP_CACHE_ENABLED) {
        pSourceSurf = pMemBltInfo->pSource;

        // Tune for the normal case.
        if (pSourceSurf->iBitmapFormat != BMF_4RLE &&
                pSourceSurf->iBitmapFormat != BMF_8RLE) {
            // Reset the RLE flag.
            pMemBltInfo->bDeltaRLE = FALSE;
        }
        else {
            BYTE *pBits = (BYTE *)pSourceSurf->pvBits;
            BYTE *pEnd = (BYTE *)pSourceSurf->pvBits + pSourceSurf->cjBits - 1;
            BYTE RLEDivisor, RLECeilAdjustment;
            int PixelsInLine, LinesInBitmap;

            TRC_ASSERT((((UINT_PTR)pBits & 1) == 0),
                    (TB,"Bitmap source address not word aligned!"));

            TRC_NRM((TB,"RLE%c, sizl=(%u, %u)", (pSourceSurf->iBitmapFormat ==
                    BMF_4RLE ? '4' : '8'), pSourceSurf->sizlBitmap.cx,
                    pSourceSurf->sizlBitmap.cy));

            if (pSourceSurf->iBitmapFormat == BMF_8RLE) {
                RLEDivisor = 1;
                RLECeilAdjustment = 0;
            }
            else {
                RLEDivisor = 2;
                RLECeilAdjustment = 1;
            }

            // Detect offset drawing in bitmap. If offsets are used the bitmap
            // cannot be encoded as a regular bitmap since the offsets require
            // knowing the screen bits behind the bitmap.
            // Note this search is expensive, but since RLE bitmaps are rare
            // this is an unusual case. Also note that pEnd is at one less
            // than the last byte of the bitmap since all RLE codes are in 2
            // byte increments and we scan ahead one byte during loop.
            pMemBltInfo->bDeltaRLE = FALSE;
            PixelsInLine = 0;
            LinesInBitmap = 1;
            while (pBits < pEnd) {
                if (*pBits == 0x00) {
                    // 0x00 is an escape. Check the next byte for the action:
                    //     0x00 means end-of-line
                    //     0x01 means end-of-bitmap
                    //     0x02 means delta movement to draw next bits.
                    //          x,y offsets are in 2 bytes after 0x02 code.
                    //          This is the type of encoding we cannot handle.
                    //     0x03..0xFF means there are this many raw indices
                    //          following. For 4BPP there are 2 indices per
                    //          byte. In both RLE types the run must be padded
                    //          to word alignment relative to the start of the
                    //          bitmap bits.
                    if (*(pBits + 1) == 0x00) {
                        // Check that the entire line was drawn in the bitmap.
                        // Skipping any part of a line means we need to grab
                        // screen data as a backdrop.
                        if (PixelsInLine < pSourceSurf->sizlBitmap.cx) {
                            pMemBltInfo->bDeltaRLE = TRUE;
                            TRC_NRM((TB,"EOL too soon at %p", pBits));
                            break;
                        }

                        PixelsInLine = 0;
                        pBits += 2;
                        LinesInBitmap++;
                    }
                    if (*(pBits + 1) == 0x01) {
                        // Check that the last line was covered (see EOL
                        // above).
                        if (PixelsInLine < pSourceSurf->sizlBitmap.cx) {
                            pMemBltInfo->bDeltaRLE = TRUE;
                            TRC_NRM((TB,"EOL too soon (EOBitmap) at %p",
                                    pBits));
                        }

                        // Check that all lines were covered.
                        if (LinesInBitmap < pSourceSurf->sizlBitmap.cy) {
                            pMemBltInfo->bDeltaRLE = TRUE;
                            TRC_NRM((TB,"EOBitmap too soon not all lines "
                                    "covered at %p", pBits));
                        }
                        
                        break;
                    }
                    if (*(pBits + 1) == 0x02) {
                        TRC_NRM((TB,"Delta at %p\n", pBits));
                        pMemBltInfo->bDeltaRLE = TRUE;
                        break;
                    }
                    else {
                        PixelsInLine += *(pBits + 1);
                        if (PixelsInLine > pSourceSurf->sizlBitmap.cx) {
                            // Implicit wraparound.
                            TRC_NRM((TB,"Implicit wraparound at %p", pBits));
                            LinesInBitmap += PixelsInLine / pSourceSurf->
                                    sizlBitmap.cx;
                            PixelsInLine %= pSourceSurf->sizlBitmap.cx;
                        }

                        // Skip the 2 bytes for 0x00 and the number of entries,
                        // plus #entries bytes for RLE8 (RLEDivisor == 1) or
                        // ceil(#entries / 2) for RLE4 (RLEDivisor == 2).
                        pBits += 2 + (*(pBits + 1) + RLECeilAdjustment) /
                                RLEDivisor;

                        // Adjust the new pBits for word alignment relative to
                        // the start of the bitmap. We assume that the
                        // start addr of the bitmap is word-aligned in memory.
                        pBits += ((UINT_PTR)pBits & 1);
                    }
                }
                else {
                    // Non-escape count byte, skip it and the next byte
                    // containing palette indices.
                    PixelsInLine += *pBits;
                    if (PixelsInLine > pSourceSurf->sizlBitmap.cx) {
                        // Implicit wraparound.
                        TRC_NRM((TB,"Implicit wraparound at %p", pBits));
                        LinesInBitmap += PixelsInLine / pSourceSurf->
                                sizlBitmap.cx;
                        PixelsInLine %= pSourceSurf->sizlBitmap.cx;
                    }

                    pBits += 2;
                }
            }
        }
    }
    else {
        rc = FALSE;
        TRC_DBG((TB, "Caching not enabled"));
    }

    DC_END_FN();
    return rc;
}


/****************************************************************************/
// SBC_DDQueryBitmapTileSize
//
// Returns the tile size to use for a given bitblt on a given bitmap.
/****************************************************************************/
__inline unsigned SBC_DDQueryBitmapTileSize(
        unsigned bmpWidth,
        unsigned bmpHeight,
        PPOINTL pptlSrc,
        unsigned width,
        unsigned height)
{
    unsigned i;
    unsigned TileSize;

    DC_BEGIN_FN("SBC_DDQueryBitmapTileSize");

    // We should have at least one functional cache or this will go badly.
    TRC_ASSERT((pddShm->sbc.NumBitmapCaches > 0),(TB,"No bitmap caches"));

    // Loop through all sizes seeing if the src rect start is a multiple of the
    // tile dimension, the blt size is not bigger than the tile size, and
    // there are an integral number of tiles in the blt. If this matches
    // anywhere we have our tile size. Don't check the last tile size since
    // that's a default anyway.
    for (i = 0; i < pddShm->sbc.NumBitmapCaches; i++) {
        TileSize = SBC_CACHE_0_DIMENSION << i;

        if ((((pptlSrc->x & (TileSize - 1)) == 0) &&
                ((pptlSrc->y & (TileSize - 1)) == 0) &&
                (width <= TileSize) &&
                (height <= TileSize)) ||
                ((((unsigned)pptlSrc->x >> (SBC_CACHE_0_DIMENSION_SHIFT + i)) ==
                    (((unsigned)pptlSrc->x + width - 1) >>
                    (SBC_CACHE_0_DIMENSION_SHIFT + i))) &&
                (((unsigned)pptlSrc->y >> (SBC_CACHE_0_DIMENSION_SHIFT + i)) ==
                    (((unsigned)pptlSrc->y + height - 1) >>
                    (SBC_CACHE_0_DIMENSION_SHIFT + i))))) {
            goto EndFunc;
        }
    }

    // Cycle through the caches, checking for if the bitmap will fit
    // into a tile size in one of its dimensions. Don't check the
    // last size since that's the default if no others work.
    for (i = 0; i < (pddShm->sbc.NumBitmapCaches - 1); i++) {

//TODO: What about using 'or' here -- uses more of smaller tiles when
// one dimension is bad. But could send more data.
        if (bmpWidth <= (unsigned)(SBC_CACHE_0_DIMENSION << i) &&
                bmpHeight <= (unsigned)(SBC_CACHE_0_DIMENSION << i))
            break;
    }

EndFunc:
    TRC_NRM((TB, "Tile(%u x %u, TileID %d) bmpWidth(%u) bmpHeight(%u)"
            "srcLeft(%d) srcTop(%d) width(%d) height(%d)",
            (SBC_CACHE_0_DIMENSION << i), (SBC_CACHE_0_DIMENSION << i),
            i, bmpWidth, bmpHeight, pptlSrc->x, pptlSrc->y, width,
            height));
    DC_END_FN();
    return i;
}



#endif /* _H_NSBCINL  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\nwdwioct.h ===
/****************************************************************************/
// nwdwioct.h
//
// Define formats for IOCtls sent ftom TShareDD to WDTShare
//
// Copyright(C) Microsoft Corporation 1997-1999
/****************************************************************************/

#include <tsrvexp.h>


/****************************************************************************/
/****************************************************************************/
/* IOCtl codes - WDTShare IOCTLs start at 0x510: 0x500-0x50f are reserved   */
/*               for use by PDMCS (see mcsioctl.h)                          */
/****************************************************************************/
/****************************************************************************/

/****************************************************************************/
/* IOCTL_WDTS_DD_CONNECT carries                                            */
/* - TSHARE_DD_CONNECT_IN as input data                                     */
/* - TSHARE_DD_CONNECT_OUT as output data                                   */
/****************************************************************************/
#define IOCTL_WDTS_DD_CONNECT       _ICA_CTL_CODE( 0x510, METHOD_NEITHER )

/****************************************************************************/
/* IOCTL_WDTS_DD_DISCONNECT carries                                         */
/* - TSHARE_DD_DISCONNECT_IN as input data                                  */
/* - NULL output data                                                       */
/****************************************************************************/
#define IOCTL_WDTS_DD_DISCONNECT    _ICA_CTL_CODE( 0x511, METHOD_NEITHER )

/****************************************************************************/
/* IOCTL_WDTS_DD_RECONNECT carries                                          */
/* - TSHARE_DD_CONNECT_IN as input data                                     */
/* - TSHARE_DD_CONNECT_OUT as output data                                   */
/****************************************************************************/
#define IOCTL_WDTS_DD_RECONNECT     _ICA_CTL_CODE( 0x512, METHOD_NEITHER )

/****************************************************************************/
/* IOCTL_WDTS_DD_OUTPUT_AVAILABLE carries                                   */
/* - TSHARE_DD_OUTPUT_IN as input data                                      */
/* - TSHARE_DD_OUTPUT_OUT as output data                                    */
/****************************************************************************/
#define IOCTL_WDTS_DD_OUTPUT_AVAILABLE \
                                      _ICA_CTL_CODE( 0x513, METHOD_NEITHER )

/****************************************************************************/
/* IOCTL_WDTS_DD_TIMER_INFO carries                                         */
/* - TSHARE_DD_TIMER_INFO as input data                                     */
/* - NULL output data                                                       */
/****************************************************************************/
#define IOCTL_WDTS_DD_TIMER_INFO    _ICA_CTL_CODE( 0x514, METHOD_NEITHER )

/****************************************************************************/
/* IOCTL_WDTS_DD_CLIP carries                                               */
/* - CBM_EVENT_DATA as input data                                           */
/* - NULL output data                                                       */
/****************************************************************************/
#define IOCTL_WDTS_DD_CLIP          _ICA_CTL_CODE( 0x515, METHOD_NEITHER )

/****************************************************************************/
/* IOCTL_WDTS_DD_SHADOW_CONNECT                                             */
/* - TSHARE_DD_CONNECT_IN as input data                                     */
/* - TSHARE_DD_CONNECT_OUT as output data                                   */
/****************************************************************************/
#define IOCTL_WDTS_DD_SHADOW_CONNECT _ICA_CTL_CODE( 0x516, METHOD_NEITHER )

/****************************************************************************/
/* IOCTL_WDTS_DD_SHADOW_DISCONNECT                                          */
/* - TSHARE_DD_DISCONNECT_IN as input data                                  */
/* - NULL output data                                                       */
/****************************************************************************/
#define IOCTL_WDTS_DD_SHADOW_DISCONNECT _ICA_CTL_CODE( 0x517, METHOD_NEITHER )

/****************************************************************************/
/* IOCTL_WDTS_DD_SHADOW_SYNCHRONIZE                                         */
/* - TSHARE_DD_SHADOWSYNC_IN - as input data                                */
/* - NULL output data                                                       */
/****************************************************************************/
#define IOCTL_WDTS_DD_SHADOW_SYNCHRONIZE _ICA_CTL_CODE( 0x518, METHOD_NEITHER )

/****************************************************************************/
/* IOCTL_WDTS_DD_REDRAW_SCREEN                                              */
/* - NULL input data                                                        */
/* - NULL output data                                                       */
/****************************************************************************/
#define IOCTL_WDTS_DD_REDRAW_SCREEN _ICA_CTL_CODE( 0x519, METHOD_NEITHER )

#ifdef DC_HICOLOR
/****************************************************************************/
/* IOCTL_WDTS_DD_QUERY_SHADOW_CAPS                                          */
/* - NULL input data                                                        */
/* - Pointer to memory for shadow caps as output data                       */
/****************************************************************************/
#define IOCTL_WDTS_DD_QUERY_SHADOW_CAPS _ICA_CTL_CODE( 0x51A, METHOD_NEITHER )
#endif

/****************************************************************************/
// IOCTL_WDTS_DD_GET_BITMAP_KEYDATABASE
// - NULL input data                                                        
// - Pointer to memory for keydatabase
/****************************************************************************/
#define IOCTL_WDTS_DD_GET_BITMAP_KEYDATABASE _ICA_CTL_CODE( 0x51B, METHOD_NEITHER )

#ifdef DC_DEBUG
/****************************************************************************/
// IOCTL_WDTS_DD_ICABREAKONDEBUGGER
// - NULL input data                                                        
// - NULL output data
/****************************************************************************/
#define IOCTL_WDTS_DD_ICABREAKONDEBUGGER  _ICA_CTL_CODE( 0x51C, METHOD_NEITHER )
#endif

/****************************************************************************/
/****************************************************************************/
/* IOCtl structures                                                         */
/****************************************************************************/
/****************************************************************************/


/****************************************************************************/
/* Structure: TSHARE_VIRTUAL_MODULE_DATA                                    */
/*                                                                          */
/* Description:  Display Driver data for shadowing.  This information is    */
/* passed to the DrvShadowConnect() entry point of the target session.      */
/****************************************************************************/
typedef struct tagTSHARE_VIRTUAL_MODULE_DATA {

    //Combined capabilities for this client/host
    unsigned capsLength;
    TS_COMBINED_CAPABILITIES combinedCapabilities;

} TSHARE_VIRTUAL_MODULE_DATA, *PTSHARE_VIRTUAL_MODULE_DATA;


/****************************************************************************/
/* Structure: TSHARE_DD_CONNECT_IN                                          */
/*                                                                          */
/* Description: Structure sent as input on IOCTL_WDTS_DD_(RE)CONNECT.       */
/* Contains data items, created by DD, that WD needs to get values of.      */
/****************************************************************************/
typedef struct tagTSHARE_DD_CONNECT_IN
{
    UINT32 pad1;                 /* Avoid Citrix bug                      */
    UINT32 pad2;
    UINT32 pad3;
    UINT32 pad4;

    PVOID  pShm;
    unsigned DDShmSize;  // Used for catching mismatched binaries.

    /************************************************************************/
    /* Following fields valid only on a reconnect                           */
    /************************************************************************/
    UINT32 desktopHeight;
    UINT32 desktopWidth;
#ifdef DC_HICOLOR
    UINT32 desktopBpp;
#endif
    PKTIMER  pKickTimer;

    // The following fields are only used during shadow connect processing
    UINT32 virtModuleDataLen;
    PTSHARE_VIRTUAL_MODULE_DATA pVirtModuleData;

} TSHARE_DD_CONNECT_IN, * PTSHARE_DD_CONNECT_IN;


/****************************************************************************/
/* Structure: TSHARE_DD_CONNECT_OUT                                         */
/*                                                                          */
/* Description: Structure returned by WD on IOCTL_WDTS_DD_(RE)CONNECT.      */
/* Contains data items, created by WD, that DD needs to get values of.      */
/****************************************************************************/
typedef struct tagTSHARE_DD_CONNECT_OUT
{
    UINT32 pad1;                 /* Avoid Citrix bug                      */
    UINT32 pad2;
    UINT32 pad3;
    UINT32 pad4;

    // WARNING!  Never ever reference this field.  It is for kernel debugger
    // use only.  Pass any WD fields we need separately to avoid binary mismatch
    // problems.
    PVOID  pTSWd;

    // System space - shared data structures
    PPROTOCOLSTATUS pProtocolStatus;

    /************************************************************************/
    /* Following two fields are meaningful only on reconnect                */
    /************************************************************************/
    UINT32 desktopHeight;
    UINT32 desktopWidth;
#ifdef DC_HICOLOR
    UINT32 desktopBpp;
#endif

    // Individual stack connection status.  The secondary is used to store the
    // status of the shadow stacks (if any).
    NTSTATUS primaryStatus;
    NTSTATUS secondaryStatus;

    // Cache keys for populating the bitmap caches.
    UINT32 bitmapKeyDatabaseSize;

    // This field needs to be qword aligned
    BYTE bitmapKeyDatabase;
} TSHARE_DD_CONNECT_OUT, * PTSHARE_DD_CONNECT_OUT;


/****************************************************************************/
/* Structure: TSHARE_DD_DISCONNECT_IN                                       */
/*                                                                          */
/* Description: Structure sent as input on IOCTL_WDTS_DD_DISCONNECT.        */
/****************************************************************************/
typedef struct tagTSHARE_DD_DISCONNECT_IN
{
    UINT32 pad1;                 /* Avoid Citrix bug                      */
    UINT32 pad2;
    UINT32 pad3;
    UINT32 pad4;

    PVOID  pShm;
    BOOL   bShadowDisconnect;   // TRUE if we are disconnecting to setup a shadow

} TSHARE_DD_DISCONNECT_IN, * PTSHARE_DD_DISCONNECT_IN;


/****************************************************************************/
/* Structure:   TSHARE_DD_OUTPUT_IN                                         */
/*                                                                          */
/* Description: Structure sent by DD as input on IOCTL_WDTS_DD_OUTPUT       */
/****************************************************************************/
typedef struct tagTSHARE_DD_OUTPUT_IN
{
    UINT32 pad1;                    /* Avoid Citrix bug                     */
    UINT32 pad2;
    UINT32 pad3;
    UINT32 pad4;
    PVOID  pShm;
    BOOL   forceSend;               /* True if called due to explicit req.  */
    PBYTE pFrameBuf;                /* address of frame buffer              */
    UINT32 frameBufWidth;
    UINT32 frameBufHeight;
    BOOL   schedOnly;               /* change sched state only - no send    */
} TSHARE_DD_OUTPUT_IN, * PTSHARE_DD_OUTPUT_IN;

/****************************************************************************/
/* Structure: TSHARE_DD_OUTPUT_OUT                                          */
/*                                                                          */
/* Description: Structure returned to DD on IOCTL_WDTS_DD_OUTPUT            */
/****************************************************************************/
typedef struct tagTSHARE_DD_OUTPUT_OUT
{
    UINT32    schCurrentMode;
    BOOL      schInputKickMode;
} TSHARE_DD_OUTPUT_OUT, * PTSHARE_DD_OUTPUT_OUT;


/****************************************************************************/
/* Structure:   TSHARE_DD_TIMER_INFO                                        */
/*                                                                          */
/* Description: Structure sent by DD as input on IOCTL_WDTS_DD_TIMER_INFO.  */
/* Contains info required by WD to be able to start a timer which will pop  */
/* in the RIT of the correct WinStation.                                    */
/****************************************************************************/
typedef struct tagTSHARE_DD_TIMER_INFO
{
    UINT32 pad1;                 /* Avoid Citrix bug                      */
    UINT32 pad2;
    UINT32 pad3;
    UINT32 pad4;
    PKTIMER pKickTimer;
} TSHARE_DD_TIMER_INFO, * PTSHARE_DD_TIMER_INFO;


/****************************************************************************/
/* Structure: TSHARE_DD_SHADOWSYNC_IN                                       */
/*                                                                          */
/* Description: Structure sent as input on IOCTL_WDTS_DD_SHADOW_SYNCHRONIZE */
/* Contains data items, created by DD, that WD needs to get values of.      */
/****************************************************************************/
typedef struct tagTSHARE_DD_SHADOWSYNC_IN
{
    UINT32 pad1;                 /* Avoid Citrix bug                      */
    UINT32 pad2;
    UINT32 pad3;
    UINT32 pad4;

    PVOID  pShm;

#ifdef DC_HICOLOR
    UINT32 capsLen;
    PTS_COMBINED_CAPABILITIES pShadowCaps;
#endif

} TSHARE_DD_SHADOWSYNC_IN, * PTSHARE_DD_SHADOWSYNC_IN;


/****************************************************************************/
// Structure: TSHARE_DD_BITMAP_KEYDATABAE_OUT                                          
//                                                                          
// Description: Structure returned to DD on 
//              IOCTL_WDTS_DD_GET_BITMAP_KEYDATABAE_OUT    
/****************************************************************************/
typedef struct tagTSHARE_DD_BITMAP_KEYDATABASE_OUT
{
    UINT32    bitmapKeyDatabaseSize;
    UINT32    pad;

    // This is QWORD aligned
    BYTE      bitmapKeyDatabase;
} TSHARE_DD_BITMAP_KEYDATABASE_OUT, * PTSHARE_DD_BITMAP_KEYDATABASE_OUT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\nwdwint.h ===
/****************************************************************************/
// nwdwint.h
//
// General RDPWD header.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/
#ifndef _H_NWDWINT
#define _H_NWDWINT

#include <t120.h>
#include <tsrvexp.h>
#include <nshmapi.h>


#define MIN_USERDATAINFO_SIZE (sizeof(USERDATAINFO)     \
                               + sizeof(RNS_UD_CS_SEC)  \
                               + sizeof(CLIENT_H221_KEY))

#ifdef DC_DEBUG
#define WDW_CHECK_SHM(pShm)                                                 \
    TRC_ASSERT((((PSHM_SHARED_MEMORY)pShm)->guardVal1 == SHM_CHECKVAL),     \
           (TB, "Guard value 1 incorrect(%#x) pShm(%p)",                    \
           ((PSHM_SHARED_MEMORY)pShm)->guardVal1, pShm));                   \
                                                                            \
    TRC_ASSERT((((PSHM_SHARED_MEMORY)pShm)->guardVal2 == SHM_CHECKVAL),     \
           (TB, "Guard value 2 incorrect(%#x) pShm(%p)",                    \
           ((PSHM_SHARED_MEMORY)pShm)->guardVal2, pShm));                   \
                                                                            \
    TRC_ASSERT((((PSHM_SHARED_MEMORY)pShm)->guardVal3 == SHM_CHECKVAL),     \
           (TB, "Guard value 3 incorrect(%#x) pShm(%p)",                    \
           ((PSHM_SHARED_MEMORY)pShm)->guardVal3, pShm));                   \
                                                                            \
    TRC_ASSERT((((PSHM_SHARED_MEMORY)pShm)->guardVal4 == SHM_CHECKVAL),     \
           (TB, "Guard value 4 incorrect(%#x) pShm(%p)",                    \
           ((PSHM_SHARED_MEMORY)pShm)->guardVal4, pShm));                   \
                                                                            \
    TRC_ASSERT((((PSHM_SHARED_MEMORY)pShm)->guardVal5 == SHM_CHECKVAL),     \
           (TB, "Guard value 5 incorrect(%#x) pShm(%p)",                    \
           ((PSHM_SHARED_MEMORY)pShm)->guardVal5, pShm));
#else
#define WDW_CHECK_SHM(pShm)
#endif /* DC_DEBUG */

#define WD_BREAK_ON_MEMORY_LEAK         	L"BreakOnMemoryLeak"
#define WD_BREAK_ON_MEMORY_LEAK_DFLT    	0

/****************************************************************************/
/* Interval for sleeping during flow control of channel writes.             */
/****************************************************************************/
#define WD_FLOWCONTROL_SLEEPINTERVAL    	L"FlowControlSleepInterval"
#define WD_FLOWCONTROL_SLEEPINTERVAL_DFLT	(2*1000) // 2 seconds

/****************************************************************************/
/* Function prototypes                                                      */
/****************************************************************************/

NTSTATUS WDWLoad( PSDCONTEXT );
NTSTATUS WDWUnload( PSDCONTEXT );
NTSTATUS WDWGetClientData ( PTSHARE_WD, PSD_IOCTL );
NTSTATUS WDWGetExtendedClientData(RNS_INFO_PACKET *RnsInfoPacket, PSD_IOCTL pSdIoctl);
NTSTATUS WDWGetAutoReconnectInfo(PTSHARE_WD, RNS_INFO_PACKET *RnsInfoPacket, PSD_IOCTL pSdIoctl);
NTSTATUS WDWGetModuleData(PTSHARE_WD, PSD_IOCTL);
NTSTATUS WDWGetDefaultCoreParams(PRNS_UD_CS_CORE pClientCoreData);
NTSTATUS WDWSetConfigData(PTSHARE_WD, PICA_STACK_CONFIG_DATA);

NTSTATUS WDWConfConnect(PTSHARE_WD, PSD_IOCTL);
NTSTATUS WDWConsoleConnect(PTSHARE_WD, PSD_IOCTL);
NTSTATUS WDWShadowConnect(PTSHARE_WD, PSD_IOCTL);
NTSTATUS WDWConnect(PTSHARE_WD, PRNS_UD_CS_CORE, PRNS_UD_CS_SEC,
        PRNS_UD_CS_NET, PTS_UD_CS_CLUSTER, PSD_IOCTL, BOOLEAN);

NTSTATUS WDWDDConnect(PTSHARE_WD, PSD_IOCTL, BOOL);
NTSTATUS WDWDDDisconnect(PTSHARE_WD, PSD_IOCTL, BOOLEAN);
NTSTATUS WDWDDReconnect(PTSHARE_WD, PSD_IOCTL);
NTSTATUS WDWDDShadowConnect(PTSHARE_WD pTSWd, PSD_IOCTL pSdIoctl);
NTSTATUS WDWDDShadowDisconnect(PTSHARE_WD pTSWd, PSD_IOCTL pSdIoctl);
NTSTATUS WDWDDQueryClient(PTSHARE_WD pTSWd, PSD_IOCTL pSdIOCtl);
BOOL     WDWParseUserData(PTSHARE_WD, PUSERDATAINFO, unsigned, PRNS_UD_HEADER,
        ULONG, PPRNS_UD_CS_CORE, PPRNS_UD_CS_SEC, PPRNS_UD_CS_NET,
        PTS_UD_CS_CLUSTER *);


/****************************************************************************/
/* Name:      WDWStopRITTimer (macro since trace lines can't compile here)  */
/*                                                                          */
/* Purpose:   Stop the RIT timer.                                           */
/*                                                                          */
/* Params:    IN    pTSWd        - pointer to WD struct                     */
/*                                                                          */
/* Operation: Time period is determined by the state of SCH.                */
/****************************************************************************/
__inline void RDPCALL WDWStopRITTimer(PTSHARE_WD pTSWd)
{
    if (pTSWd->ritTimer != NULL)
        KeCancelTimer(pTSWd->ritTimer);
} /* WDWStopRITTimer */


#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

NTSTATUS WDWNewShareClass(PTSHARE_WD pTSWd);
void     WDWDeleteShareClass(PTSHARE_WD pTSWd);
void     WDWTermShareClass(PTSHARE_WD pTSWd);
void     WDWDisconnectShareClass(PTSHARE_WD pTSWd, PSHM_SHARED_MEMORY pShm);

void     WDWUserLoggedOn(PTSHARE_WD pTSWd, PSD_IOCTL pSdIoctl);
void     WDWKeyboardSetIndicators(PTSHARE_WD pTSWd);
void     WDWKeyboardSetImeStatus(PTSHARE_WD pTSWd);
void     WDWVCMessage(PTSHARE_WD, UINT32);
UCHAR    WDWCompressToOutbuf(PTSHARE_WD pTSWd, UCHAR* pSrcData, ULONG cbSrcLen,
                             UCHAR* pOutBuf,  ULONG* pcbOutLen);

NTSTATUS WDWSetErrorInfo(PTSHARE_WD pTSWd, PSD_IOCTL pSdIoctl);
NTSTATUS WDWSendArcStatus(PTSHARE_WD pTSWd, PSD_IOCTL pSdIoctl);

NTSTATUS KeyboardQueryAttributes( PTSHARE_WD, PSD_IOCTL  );
NTSTATUS KeyboardQueryTypematic( PTSHARE_WD, PSD_IOCTL  );
NTSTATUS KeyboardSetTypematic( PTSHARE_WD, PSD_IOCTL  );
NTSTATUS KeyboardQueryIndicators( PTSHARE_WD, PSD_IOCTL  );
NTSTATUS KeyboardSetIndicators( PTSHARE_WD, PSD_IOCTL  );
NTSTATUS KeyboardQueryIndicatorTranslation( PTSHARE_WD, PSD_IOCTL  );
NTSTATUS KeyboardSetLayout( PTSHARE_WD, PSD_IOCTL  );
NTSTATUS KeyboardFixupLayout( PVOID, PVOID, ULONG, PVOID, PVOID * );
NTSTATUS KeyboardSetScanMap( PTSHARE_WD, PSD_IOCTL  );
NTSTATUS KeyboardSetType( PTSHARE_WD, PSD_IOCTL  );
NTSTATUS KeyboardSetKeyState( PTSHARE_WD pWd, PVOID *pgafPhysKeyState );
BOOLEAN  KeyboardHotKeyProcedure(BYTE HotkeyVk, USHORT HotkeyModifiers,
                                 PKEYBOARD_INPUT_DATA pkei, PVOID gpScancodeMap,
                                 PVOID pKbdTbl, BOOLEAN KeyboardType101,
                                 PVOID gafPhysKeyState );
NTSTATUS KeyboardSetImeStatus( PTSHARE_WD, PSD_IOCTL  );


NTSTATUS MouseQueryAttributes( PTSHARE_WD, PSD_IOCTL  );

NTSTATUS VirtualCancelInput( PTSHARE_WD, PSD_IOCTL );
NTSTATUS VirtualCancelOutput( PTSHARE_WD, PSD_IOCTL );
NTSTATUS TerminalQueryVirtualBindings( PTSHARE_WD, PSD_IOCTL );
NTSTATUS TerminalGetVirtualModuleData( PTSHARE_WD, PSD_IOCTL );
NTSTATUS TerminalGetModuleData( PTSHARE_WD, PSD_IOCTL );
NTSTATUS TerminalGetBufferInfo( PTSHARE_WD, PSD_IOCTL );

NTSTATUS WDWSendBeep( PTSHARE_WD, PSD_IOCTL );
NTSTATUS WDWClipIoctl(PTSHARE_WD, PSD_IOCTL );

extern LONG WD_ShareId;


#ifdef __cplusplus
}
#endif  /* __cplusplus */


#endif  // !defined(_H_NWDWINT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\slist.h ===
/* (C) 1997-1999 Microsoft Corp.
 *
 * file    : SList.h
 * authors : Christos Tsollis, Erik Mavrinac
 *
 * description: Interface definition to a dynamically-resizing list/queue
 *   data type. The "key" values in the list are unsigned ints of whatever the
 *   default word size is, so the elements of the array will be word-aligned.
 *   These elements can be cast into whatever form is needed. Associated is
 *   a void * for data asssociated with the "key".
 */

#ifndef __SLIST_H
#define __SLIST_H


#define SListDefaultNumEntries 4

/*
 * Types
 */

typedef struct
{
    UINT_PTR Key;
    void     *Value;
} _SListNode;

typedef struct
{
    unsigned NEntries;    // current # of entries in the list
    unsigned MaxEntries;  // max # of entries that the array can hold
    unsigned HeadOffset;  // Offset of the 1st entry in the circular array
    unsigned CurrOffset;  // Iterator value
    _SListNode *Entries;    // Circular array of entries
} _SListHeader;

typedef struct
{
    _SListHeader Hdr;
    _SListNode InitialList[SListDefaultNumEntries];
} SList, *PSList;



/*
 * API prototypes.
 */

BOOLEAN SListAppend(PSList, UINT_PTR, void *);
void SListDestroy(PSList);
BOOLEAN SListGetByKey(PSList, UINT_PTR, void **);
void SListInit(PSList, unsigned);
BOOLEAN SListIterate(PSList, UINT_PTR *, void **);
BOOLEAN SListPrepend(PSList, UINT_PTR, void *);
void SListRemove(PSList, UINT_PTR, void **);
void SListRemoveFirst(PSList, UINT_PTR *, void **);
void SListRemoveLast(PSList, UINT_PTR *, void **);



/*
 * API functions implemented as macros.
 */

// void SListResetIteration(PSList);  // Resets iteration counter.
#define SListResetIteration(pSL) (pSL)->Hdr.CurrOffset = 0xFFFFFFFF

// unsigned SListGetEntries(PSList);  // Ret. # entries in list.
#define SListGetEntries(pSL) ((pSL)->Hdr.NEntries)

// void SListClear(PSList);
#define SListClear(pSL) {  \
    (pSL)->Hdr.NEntries = (pSL)->Hdr.HeadOffset = 0;  \
    (pSL)->Hdr.CurrOffset = 0xFFFFFFFF;  \
}

// BOOLEAN SListIsEmpty(PSList);
#define SListIsEmpty(pSL) ((pSL)->Hdr.NEntries == 0)



#endif  // !defined(__SLIST_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\slicense.h ===
/**INC+**********************************************************************/
/* Header:    SLicense.h                                                    */
/*                                                                          */
/* Purpose:   Server License Manager functions                              */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log$
**/
/**INC-**********************************************************************/
#ifndef _SLICENSE_H
#define _SLICENSE_H


//
// License Handle
//

typedef struct _License_Handle
{
    
    PBYTE       pDataBuf;       // pointer to data buffer
    UINT        cbDataBuf;      // size of data buffer
    PKEVENT     pDataEvent;     // used to wait for data event
    PBYTE       pCacheBuf;      // points to a cache buffer
    UINT        cbCacheBuf;     // size of cache buffer
    NTSTATUS    Status;         // status of the previous operation

    //
    // do we need a spin lock to protect this data structure?
    //
        
} License_Handle, * PLicense_Handle;


/**PROC+*********************************************************************/
/* Name:      SLicenseInit                                                  */
/*                                                                          */
/* Purpose:   Initialize License Manager                                    */
/*                                                                          */
/* Returns:   Handle to be passed to subsequent License Manager functions   */
/*                                                                          */
/* Params:    None                                                          */
/*                                                                          */
/* Operation: LicenseInit is called during Server initialization.  Its      */
/*            purpose is to allow one-time initialization.  It returns a    */
/*            handle which is subsequently passed to all License Manager    */
/*            functions.  A typical use for this handle is as a pointer to  */
/*            memory containing per-instance data.                          */
/*                                                                          */
/**PROC-*********************************************************************/
LPVOID _stdcall SLicenseInit(VOID);


/**PROC+*********************************************************************/
/* Name:      SLicenseData                                                  */
/*                                                                          */
/* Purpose:   Handle license data received from the Client                  */
/*                                                                          */
/* Returns:   None                                                          */
/*                                                                          */
/* Params:    pHandle   - handle returned by LicenseInit                    */
/*            pSMHandle - SM Handle                                         */
/*            pData     - data received from Client                         */
/*            dataLen   - length of data received                           */
/*                                                                          */
/* Operation: This function is passed all license packets received from the */
/*            Client.  It should parse the packet and respond (by calling   */
/*            suitable SM functions - see asmapi.h) as required.  The SM    */
/*            Handle is provided so that SM calls can be made.              */
/*                                                                          */
/*            If license negotiation is complete and successful, the        */
/*            License Manager must call SM_LicenseOK.                       */
/*                                                                          */
/*            If license negotiation is complete but unsuccessful, the      */
/*            License Manager must disconnect the session.                  */
/*                                                                          */
/*            Incoming packets from the Client will continue to be          */
/*            interpreted as license packets until SM_LicenseOK is called,  */
/*            or the session is disconnected.                               */
/*                                                                          */
/**PROC-*********************************************************************/
void _stdcall SLicenseData(LPVOID pHandle,
                           LPVOID pSMHandle,
                           LPVOID pData,
                           UINT   dataLen);


/**PROC+*********************************************************************/
/* Name:      SLicenseTerm                                                  */
/*                                                                          */
/* Purpose:   Terminate Server License Manager                              */
/*                                                                          */
/* Returns:   None                                                          */
/*                                                                          */
/* Params:    pHandle - handle returned from LicenseInit                    */
/*                                                                          */
/* Operation: This function is provided to do one-time termination of the   */
/*            License Manager.  For example, if pHandle points to per-      */
/*            instance memory, this would be a good place to free it.       */
/*                                                                          */
/**PROC-*********************************************************************/
void _stdcall SLicenseTerm(LPVOID pHandle);

#endif /* _SLICENSE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\pdmcs\conpdu.c ===
/* (C) 1997-2000 Microsoft Corp.
 *
 * file   : ConPDU.c
 * author : Erik Mavrinac
 *
 * description: Handles decoding of MCS connect PDUs. Connect PDUs are always
 *   encoded with ASN.1 basic encoding rules (BER). Included in this file are
 *   local functions to BER-decode and -encode various types used in MCS PDUs.
 *
 * History:
 * 11-Aug-1997    jparsons    Fixed BER decode routines.
 */

#include "precomp.h"
#pragma hdrstop

#include <MCSImpl.h>


/*
 * Defines
 */

// Return codes for encode/decode functions.
#define H_OK          0
#define H_TooShort    1
#define H_BadContents 2
#define H_Error       3


/*
 * Prototypes for handler functions.
 */
BOOLEAN __fastcall HandleConnectInitial(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandleConnectResponse(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandleConnectAdditional(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandleConnectResult(PDomain, BYTE *, unsigned, unsigned *);


/*
 * These are listed in the 101-based enumeration order specified in the T.125
 * spec. Decode the initial BER connect PDU 0x7F, then subtract 101 decimal
 * from the next byte value to get an index into this table. E.g. the bytes
 * 0x7F65 at the beginning refer to a connect-initial PDU.
 */
const MCSPDUInfo ConnectPDUTable[] = {
    StrOnDbg("Connect Initial",    HandleConnectInitial),
    StrOnDbg("Connect Response",   NULL  /* HandleConnectResponse */),
    StrOnDbg("Connect Additional", NULL  /* HandleConnectAdditional */),
    StrOnDbg("Connect Result",     NULL  /* HandleConnectResult */),
};


/*
 * Decodes BER strings used by MCS. A BER stream is a set of tags
 *   containing ID-length-contents triplets, using byte values as type and
 *   length indicators unless length escapes are used. For example, a
 *   typical tag:
 *
 *     0x02 0x02 0x04 0x00
 *
 *   Decomposition:
 *     0x02:      Id     = INTEGER_TAG
 *     0x02:      Length = 2 octets
 *     0x04 0x00: Contents = 1024 (0x0400)
 *
 *   Escaped tag:
 *
 *     0x04 0x82 0x04 0x00 0x8a 0x96...
 *
 *   Decomposition:
 *     0x04:         Id = OCTET_STRING_TAG
 *     0x82:         Length stored in TWO bytes
 *     0x04 0x00:    Length = 1024 octets
 *     0x8a 0x96...: Contents = 0x8 0x96... (1022 more octets)
 *
 * Returns FALSE if the frame is too small.
 *
 * History:
 * 11-Aug-97   jparsons    Fixed pointer dereferencing error in calculating length
 *
 */

#define LengthModifier_Indefinite 0x80
#define LengthModifier_1          0x81
#define LengthModifier_2          0x82
#define LengthModifier_3          0x83
#define LengthModifier_4          0x84

#define TagType_Boolean           0x01
#define TagType_Integer           0x02
#define TagType_BitString         0x03
#define TagType_OctetString       0x04
#define TagType_Enumeration       0x0A
#define TagType_Sequence          0x30
#define TagType_SetOf             0x31
#define TagType_ConnectInitial    0x65
#define TagType_ConnectResponse   0x66
#define TagType_ConnectAdditional 0x67
#define TagType_ConnectResult     0x68

int DecodeTagBER(
        PSDCONTEXT pContext,  // For tracing.
        BYTE       *Frame,
        unsigned   *OutBytesLeft,
        int        TagTypeExpected,
        unsigned   *OutDataLength,
        UINT_PTR   *Data,
        BYTE       **newFrame)
{
    int rc = H_OK;
    int TagType;
    unsigned i, BytesLeft, DataLength;

    BytesLeft = *OutBytesLeft;
    DataLength = *OutDataLength;

    if (BytesLeft >= 2) {
        // Get tag type, check it.
        TagType = *Frame;
        Frame++;
        BytesLeft--;
        if (TagType != TagTypeExpected) {
            ErrOut2(pContext, "Unexpected tag type found decoding BER tag, "
                    "recv %d != expect %d", TagType, TagTypeExpected);
            rc = H_BadContents;
            goto ExitFunc;
        }
    }
    else {
        ErrOut(pContext, "BER PDU too short");
        rc = H_TooShort;
        goto ExitFunc;
    }

    // Find tag length indicator, including escapes.
    if (*Frame >= LengthModifier_Indefinite && *Frame <= LengthModifier_4) {
        unsigned NLengthBytes;

        // Check zero size for LengthModifier_Indefinite.
        NLengthBytes = 4 + *Frame - LengthModifier_4;
        if (NLengthBytes == 0)
            NLengthBytes = 1;

        if (BytesLeft >= NLengthBytes) {
            Frame++;  // Now at beginning of length bytes
            BytesLeft--;

            DataLength = 0;
            for (i = 0; i < NLengthBytes; i++) {
                DataLength = (DataLength << 8) + (unsigned)(*Frame);
                Frame++;
            }
            BytesLeft -= NLengthBytes;
        }
        else {
            ErrOut(pContext, "BER PDU too short");
            rc = H_TooShort;
            goto ExitFunc;
        }
    }
    else {
        DataLength = *Frame;
        Frame++;
        BytesLeft--;
    }

    if (BytesLeft >= DataLength) {
        // Frame now points to beginning of contents. Fill out *Data with info
        // based on the tag type.
        switch (TagType) {
            case TagType_Boolean:
            case TagType_Integer:
            case TagType_Enumeration:
                // Fill in *Data with the actual data. Fill out *BytesLeft
                // so that we consume the contents.  Discard if requested.
                if (Data != NULL) {
                   unsigned Sum;

                   Sum = 0;
                   for (i = 0; i < DataLength; i++) {
                       Sum = (Sum << 8) + *Frame;
                       Frame++;
                   }
                   *Data = Sum;
                }
                else
                   Frame += DataLength;
                
                BytesLeft -= DataLength;
                break;

            case TagType_OctetString:
                // Fill in *Data with a pointer into the frame of the
                // beginning of the data.
                if (Data != NULL)
                   *Data = (UINT_PTR)Frame;
                   
                Frame += DataLength;
                BytesLeft -= DataLength;
                break;

            // For these, we really just want to consume the tag and length
            case TagType_ConnectInitial:
            case TagType_Sequence:
                break;
            
            // MCS FUTURE: Add TagType_BitString

            default:
                ErrOut1(pContext, "Unknown TagType in DecodeTagBER (%u)",
                        TagType);
                rc = H_BadContents;
                goto ExitFunc;
        }
    }
    else {
        ErrOut(pContext, "BER PDU too short");
        rc = H_TooShort;
        goto ExitFunc;
    }

ExitFunc:
    *newFrame = Frame;
    *OutBytesLeft = BytesLeft;
    *OutDataLength = DataLength;
    return rc;
}


/*
 * BER-encodes by parameter type. Advances pointer at *Frame past the encoded
 *   bytes to allow for a current-pointer mechanism to be used. Parameter
 *   usage as follows:
 *
 *   Tag type         Params
 *   ---------------------------------------------------------------
 *   bool, int, enum  Data: The value to encode, maximum 0x7FFFFFFF.
 *                    DataLength: Unused.
 *
 *   octet str, seq   DataLength: Length of the sequence/string.
 *                    Data: Pointer to beginning of data to copy.
 *                      (Data can be NULL to prevent copying user data.)
 *
 *   bitstring        Not yet supported
 */
void EncodeTagBER (
        PSDCONTEXT pContext,  // For tracing.
        BYTE       *Frame,
        int        TagType,
        unsigned   DataLength,
        UINT_PTR   Data,
        unsigned   *pNBytesConsumed,
        BYTE       **newFrame)
{
    int i, Length, NBytesConsumed;

    // Encode tag type.
    *Frame = (BYTE)TagType;
    Frame++;
    NBytesConsumed = 1;

    // Encode tag length indicator, including escapes, then encode the actual
    //   tag data, if applicable.
    switch (TagType) {
        case TagType_Boolean:
        case TagType_Integer:
        case TagType_Enumeration:
            // Encode the bool or int size in bytes.
            if (Data < 0x80) Length = 1;
            else if (Data < 0x8000) Length = 2;
            else if (Data < 0x800000) Length = 3;
            else if (Data < 0x80000000) Length = 4;
            else {
                ErrOut(pContext,
                        "Cannot BER-encode the size for an int/bool tag");
                ASSERT(FALSE);
                break;
            }

            *Frame = (BYTE)Length;
            Frame++;
            NBytesConsumed++;

            // Encode the bool/int/enum data.
            for (i = 0; i < Length; i++) {
                *Frame = (BYTE)(Data >> (8 * (Length - 1 - i)));
                Frame++;
            }

            NBytesConsumed += Length;
            break;

        case TagType_OctetString:
        case TagType_Sequence:
            // Determine the length of DataLength. Escape if greater than 1.
            if (DataLength < 0x80) 
                Length = 1;
            else if (DataLength < 0x8000) {
                Length = 2;
                *Frame = LengthModifier_2;
                Frame++;
                NBytesConsumed++;
            }
            else if (DataLength < 0x800000) {
                Length = 3;
                *Frame = LengthModifier_3;
                Frame++;
                NBytesConsumed++;
            }
            else if (DataLength < 0x80000000) {
                Length = 4;
                *Frame = LengthModifier_4;
                Frame++;
                NBytesConsumed++;
            }
            else {
                ErrOut(pContext,
                        "Cannot BER-encode the length for an octet string tag");
                ASSERT(FALSE);
                break;
            }

            for (i = 0; i < Length; i++) {
                *Frame = (BYTE)(DataLength >> (8 * (Length - 1 - i)));
                Frame++;
            }
            NBytesConsumed += Length;

            // Encode the string data.
            if (((BYTE *)Data) != NULL) {
                // This case is never used since we create headers only.
                // If this were to be used we would need to copy memory.
                memcpy(Frame, (BYTE *)Data, DataLength);
                Frame += DataLength;
                NBytesConsumed += DataLength;
            }
            
            break;

        // MCS FUTURE: Add TagType_BitString.
    }

    *newFrame = Frame;
    *pNBytesConsumed = NBytesConsumed;
}


/*
 * BER-encodes the given domain parameters.
 */
void EncodeDomainParameters(
        PSDCONTEXT pContext,  // For tracing.
        BYTE *Frame,
        int  *pNBytesConsumed,
        const DomainParameters *pDomParams,
        BYTE **newFrame)
{
    BYTE *pSeqLength;
    unsigned NBytesConsumed, TotalBytes;

    // Encode the sequence tag type beginning manually. We'll fill in the
    //   length after we're done with the rest of the domain parameters.
    *Frame = TagType_Sequence;
    pSeqLength = Frame + 1;
    Frame += 2;
    TotalBytes = 2;

    // Encode the 8 domain parameters.
    EncodeTagBER(pContext, Frame, TagType_Integer, 0,
            pDomParams->MaxChannels, &NBytesConsumed, newFrame);
    TotalBytes += NBytesConsumed;
    Frame = *newFrame;

    EncodeTagBER(pContext, Frame, TagType_Integer, 0,
            pDomParams->MaxUsers, &NBytesConsumed, newFrame);
    TotalBytes += NBytesConsumed;
    Frame = *newFrame;

    EncodeTagBER(pContext, Frame, TagType_Integer, 0,
            pDomParams->MaxTokens, &NBytesConsumed, newFrame);
    TotalBytes += NBytesConsumed;
    Frame = *newFrame;

    EncodeTagBER(pContext, Frame, TagType_Integer, 0,
            pDomParams->NumPriorities, &NBytesConsumed, newFrame);
    TotalBytes += NBytesConsumed;
    Frame = *newFrame;

    EncodeTagBER(pContext, Frame, TagType_Integer, 0,
            pDomParams->MinThroughput, &NBytesConsumed, newFrame);
    TotalBytes += NBytesConsumed;
    Frame = *newFrame;

    EncodeTagBER(pContext, Frame, TagType_Integer, 0,
            pDomParams->MaxDomainHeight, &NBytesConsumed, newFrame);
    TotalBytes += NBytesConsumed;
    Frame = *newFrame;

    EncodeTagBER(pContext, Frame, TagType_Integer, 0,
            pDomParams->MaxPDUSize, &NBytesConsumed, newFrame);
    TotalBytes += NBytesConsumed;
    Frame = *newFrame;

    EncodeTagBER(pContext, Frame, TagType_Integer, 0,
            pDomParams->ProtocolVersion, &NBytesConsumed, newFrame);
    TotalBytes += NBytesConsumed;
    Frame = *newFrame;

    *pNBytesConsumed = TotalBytes;
    *pSeqLength = TotalBytes - 2;
}


/*
 * BER-decodes domain parameters. Returns one of the H_... codes defined above.
 */
int DecodeDomainParameters(
        PSDCONTEXT pContext,  // For tracing.
        BYTE *Frame,
        unsigned *BytesLeft,
        DomainParameters *pDomParams,
        BYTE **newFrame)
{
    int Result;
    unsigned DataLength = 0;
    UINT_PTR Data = 0;

    // Get sequence indicator and block length.
    Result = DecodeTagBER(pContext, Frame, BytesLeft, TagType_Sequence,
            &DataLength, &Data, newFrame);
    if (Result == H_OK) {
        if (*BytesLeft >= DataLength)
            Frame = *newFrame;
        else
            return H_TooShort;
    }
    else {
        return Result;
    }

    // Get all 8 integer-tag values.
    Result = DecodeTagBER(pContext, Frame, BytesLeft, TagType_Integer,
            &DataLength, &Data, newFrame);
    if (Result == H_OK) {
        Frame = *newFrame;
        pDomParams->MaxChannels = (unsigned)Data;
    }
    else {
        return Result;
    }

    Result = DecodeTagBER(pContext, Frame, BytesLeft, TagType_Integer,
            &DataLength, &Data, newFrame);
    if (Result == H_OK) {
        Frame = *newFrame;
        pDomParams->MaxUsers = (unsigned)Data;
    }
    else {
        return Result;
    }

    Result = DecodeTagBER(pContext, Frame, BytesLeft, TagType_Integer,
            &DataLength, &Data, newFrame);
    if (Result == H_OK) {
        Frame = *newFrame;
        pDomParams->MaxTokens = (unsigned)Data;
    }
    else {
        return Result;
    }

    Result = DecodeTagBER(pContext, Frame, BytesLeft, TagType_Integer,
            &DataLength, &Data, newFrame);
    if (Result == H_OK) {
        Frame = *newFrame;
        pDomParams->NumPriorities = (unsigned)Data;
    }
    else {
        return Result;
    }

    Result = DecodeTagBER(pContext, Frame, BytesLeft, TagType_Integer,
            &DataLength, &Data, newFrame);
    if (Result == H_OK) {
        Frame = *newFrame;
        pDomParams->MinThroughput = (unsigned)Data;
    }
    else {
        return Result;
    }

    Result = DecodeTagBER(pContext, Frame, BytesLeft, TagType_Integer,
            &DataLength, &Data, newFrame);
    if (Result == H_OK) {
        Frame = *newFrame;
        pDomParams->MaxDomainHeight = (unsigned)Data;
    }
    else {
        return Result;
    }

    Result = DecodeTagBER(pContext, Frame, BytesLeft, TagType_Integer,
            &DataLength, &Data, newFrame);
    if (Result == H_OK) {
        Frame = *newFrame;
        pDomParams->MaxPDUSize = (unsigned)Data;
    }
    else {
        return Result;
    }

    Result = DecodeTagBER(pContext, Frame, BytesLeft, TagType_Integer,
            &DataLength, &Data, newFrame);
    if (Result == H_OK) {
        Frame = *newFrame;
        pDomParams->ProtocolVersion = (unsigned)Data;
    }
    else {
        return Result;
    }

    return H_OK;
}


/*
 * PDU 101
 *
 *   Connect-Initial ::= [APPLICATION 101] IMPLICIT SEQUENCE {
 *       callingDomainSelector OCTET STRING,
 *       calledDomainSelector  OCTET STRING,
 *       upwardFlag            BOOLEAN,
 *       targetParameters      DomainParameters,
 *       minimumParameters     DomainParameters,
 *       maximumParameters     DomainParameters,
 *       userData              OCTET STRING
 *   }
 *
 * Returns FALSE if the in parameters are not acceptable.
 */
BOOLEAN NegotiateDomParams(
        PDomain pDomain,
        DomainParameters *pTarget,
        DomainParameters *pMin,
        DomainParameters *pMax,
        DomainParameters *pOut)
{
    // Maximum channels.
    if (pTarget->MaxChannels >= RequiredMinChannels) {
        pOut->MaxChannels = pTarget->MaxChannels;
    }
    else if (pMax->MaxChannels >= RequiredMinChannels) {
        pOut->MaxChannels = RequiredMinChannels;
    }
    else {
        ErrOut(pDomain->pContext, "Could not negotiate max channels");
        return FALSE;
    }

    // Maximum users.
    if (pTarget->MaxUsers >= RequiredMinUsers) {
        pOut->MaxUsers = pTarget->MaxUsers;
    }
    else if (pMax->MaxUsers >= RequiredMinUsers) {
        pOut->MaxUsers = RequiredMinUsers;
    }
    else {
        ErrOut(pDomain->pContext, "Could not negotiate max users");
        return FALSE;
    }

    // Maximum tokens. We don't implement tokens right now, so just take
    // the target number and we'll return an error if they try to use them.
    //MCS FUTURE: This needs to be negotiated if tokens are implemented.
    pOut->MaxTokens = pTarget->MaxTokens;

    // Number of data priorities. We accept only one priority.
    if (pMin->NumPriorities <= RequiredPriorities) {
        pOut->NumPriorities = RequiredPriorities;
    }
    else {
        ErrOut(pDomain->pContext, "Could not negotiate # priorities");
        return FALSE;
    }

    // Minimum throughput. We don't care about this, take whatever.
    pOut->MinThroughput = pTarget->MinThroughput;

    // Maximum domain height. We only allow a height of 1 in this product.
    //MCS FUTURE: This needs to change if we support deeper domains.
    if (pTarget->MaxDomainHeight == RequiredDomainHeight ||
            pMin->MaxDomainHeight <= RequiredDomainHeight) {
        pOut->MaxDomainHeight = RequiredDomainHeight;
    }
    else {
        ErrOut(pDomain->pContext, "Could not negotiate max domain height");
        return FALSE;
    }

    // Max MCS PDU size. Minimum required for headers and lowest X.224
    //   allowable size. Max was negotiated by X.224.
    if (pTarget->MaxPDUSize >= RequiredMinPDUSize) {
        if (pTarget->MaxPDUSize <= pDomain->MaxX224DataSize) {
            pOut->MaxPDUSize = pTarget->MaxPDUSize;
        }
        else if (pMin->MaxPDUSize >= RequiredMinPDUSize &&
                pMin->MaxPDUSize <= pDomain->MaxX224DataSize) {
            // Take maximum possible size as long as we're within range.
            pOut->MaxPDUSize = pDomain->MaxX224DataSize;
        }
        else {
            ErrOut(pDomain->pContext, "Could not negotiate max PDU size, "
                    "sender outside X.224 negotiated limits");
            return FALSE;
        }
    }
    else {
        if (pMax->MaxPDUSize >= RequiredMinPDUSize) {
            pOut->MaxPDUSize = pMax->MaxPDUSize;
        }
        else {
            ErrOut(pDomain->pContext, "Could not negotiate max PDU size, "
                    "sender max too small");
            return FALSE;
        }
    }

    // MCS protocol version. We support only version 2.
    if (pTarget->ProtocolVersion == RequiredProtocolVer ||
            (pMin->ProtocolVersion <= RequiredProtocolVer &&
            pMax->ProtocolVersion >= RequiredProtocolVer)) {
        pOut->ProtocolVersion = RequiredProtocolVer;
    }
    else {
        ErrOut(pDomain->pContext, "Could not negotiate protocol version");
        return FALSE;
    }
    
    return TRUE;
}


BOOLEAN __fastcall HandleConnectInitial(
        PDomain  pDomain,
        BYTE     *Frame,
        unsigned BytesLeft,
        unsigned *pNBytesConsumed)
{
    int Result;
    BYTE *SaveFrame, *pUserData, *pCPinBuf, *newFrame;
    UINT_PTR Data = 0;
    NTSTATUS Status;
    unsigned DataLength = 0;
    unsigned SaveBytesLeft;
    unsigned PDULength = 0;
    DomainParameters TargetParams, MinParams, MaxParams;
    ConnectProviderIndicationIoctl CPin;

    if (pDomain->State == State_X224_Connected) {
        // Save for error handling below.
        SaveBytesLeft = BytesLeft;
        newFrame = SaveFrame = Frame;

        // Get the PDU length, verify it against BytesLeft.
        Result = DecodeTagBER(pDomain->pContext, Frame, &BytesLeft,
                    TagType_ConnectInitial, &PDULength, NULL, &newFrame);
        if (Result == H_OK) {
            if (BytesLeft >= PDULength)
                Frame = newFrame;
            else
                return FALSE;
        }
        else {
            goto BadResult;
        }
    }
    else {
        ErrOut(pDomain->pContext, "Connect-Initial PDU received when not in "
                "state X224_Connected");
        MCSProtocolErrorEvent(pDomain->pContext, pDomain->pStat,
                Log_MCS_UnexpectedConnectInitialPDU,
                Frame, BytesLeft);

        // Consume all the data given to us.
        *pNBytesConsumed = BytesLeft;
        return TRUE;
    }

    // Decode and skip calling domain selector.
    Result = DecodeTagBER(pDomain->pContext, Frame, &BytesLeft,
                TagType_OctetString, &DataLength, NULL, &newFrame);
    if (Result == H_OK)
        Frame = newFrame;
    else
        goto BadResult;

    // Decode and skip called domain selector.
    Result = DecodeTagBER(pDomain->pContext, Frame, &BytesLeft,
                TagType_OctetString, &DataLength, NULL, &newFrame);
    if (Result == H_OK)
        Frame = newFrame;
    else
        goto BadResult;

    // Decode Upward boolean.
    Result = DecodeTagBER(pDomain->pContext, Frame, &BytesLeft,
                TagType_Boolean, &DataLength, &Data, &newFrame);
    if (Result == H_OK) {
        Frame = newFrame;
        CPin.bUpwardConnection = (Data ? TRUE : FALSE);
    }
    else {
        goto BadResult;
    }

    // Decode target, max, min domain parameters. We will handle internal
    //   negotiation for these parameters and pass up to the MUX only
    //   the results, if the negotiation can succeed.
    Result = DecodeDomainParameters(pDomain->pContext, Frame, &BytesLeft,
            &TargetParams, &newFrame);
    if (Result == H_OK)
        Frame = newFrame;
    else
        goto BadResult;

    Result = DecodeDomainParameters(pDomain->pContext, Frame, &BytesLeft,
            &MinParams, &newFrame);
    if (Result == H_OK)
        Frame = newFrame;
    else
        goto BadResult;

    Result = DecodeDomainParameters(pDomain->pContext, Frame, &BytesLeft,
            &MaxParams, &newFrame);
    if (Result == H_OK)
        Frame = newFrame;
    else
        goto BadResult;

    // Get the user data (an octet string). After this Frame should point to
    // the end of the user data.
    Result = DecodeTagBER(pDomain->pContext, Frame, &BytesLeft,
                TagType_OctetString, &CPin.UserDataLength, &Data, &newFrame);
    if (Result == H_OK) {
        Frame = newFrame;
        pUserData = (BYTE *)Data;
        *pNBytesConsumed = SaveBytesLeft - BytesLeft;
    }
    else {
        goto BadResult;
    }
    
    // Check maximum user data size.
    if (CPin.UserDataLength > MaxGCCConnectDataLength) {
        POUTBUF pOutBuf;
        ICA_CHANNEL_COMMAND Command;

        ErrOut(pDomain->pContext, "HandleConnectInitial(): Attached user data "
                "is too large, returning error and failing connection");

        // Alloc OutBuf for sending PDU.
        // This allocation is vital to the session and must succeed.
        do {
            Status = IcaBufferAlloc(pDomain->pContext, FALSE, TRUE,
                    ConnectResponseHeaderSize, NULL, &pOutBuf);
            if (Status != STATUS_SUCCESS)
                ErrOut(pDomain->pContext, "Could not allocate an OutBuf for a "
                        "connect-response PDU, retrying");
        } while (Status != STATUS_SUCCESS);
    
        // Fill in PDU.
        // Encode PDU header. Param 2, the called connect ID, does not need to
        //   be anything special because we do not allow extra sockets to be
        //   opened for other data priorities.
        CreateConnectResponseHeader(pDomain->pContext,
                RESULT_UNSPECIFIED_FAILURE, 0, &pDomain->DomParams, 0, pOutBuf->pBuffer,
                &pOutBuf->ByteCount);

        // Send the PDU.
        Status = SendOutBuf(pDomain, pOutBuf);
        if (!NT_SUCCESS(Status)) {
            ErrOut(pDomain->pContext, "Could not send connect-response PDU "
                    "to TD");
            // Ignore error -- this should only occur if stack is going down.
            return TRUE;
        }

        // Signal that we need to drop the link.
        Command.Header.Command = ICA_COMMAND_BROKEN_CONNECTION;
        Command.BrokenConnection.Reason = Broken_Unexpected;
        Command.BrokenConnection.Source = BrokenSource_Server;
        Status = IcaChannelInput(pDomain->pContext, Channel_Command,
                0, NULL, (BYTE *)&Command, sizeof(Command));
        if (!NT_SUCCESS(Status))
            ErrOut(pDomain->pContext, "HandleConnectInitial(): Could not "
                    "send BROKEN_CONN upward");
        
        return TRUE;
    }
    
    // Domain parameters negotiation.
    if (NegotiateDomParams(pDomain, &TargetParams, &MinParams, &MaxParams,
            &CPin.DomainParams)) {
        pDomain->DomParams = CPin.DomainParams;
    }
    else {
        MCSProtocolErrorEvent(pDomain->pContext, pDomain->pStat,
                Log_MCS_UnnegotiableDomainParams,
                Frame, BytesLeft);

        return TRUE;
    }

    // Calculate the MaxSendSize. This is the maximum PDU size minus the
    //   maximum possible number of bytes for MCS headers and ASN.1
    //   segmentation.
    pDomain->MaxSendSize = CPin.DomainParams.MaxPDUSize - 6 -
            GetTotalLengthDeterminantEncodingSize(
            CPin.DomainParams.MaxPDUSize);

    // Fill in remaining CPin fields and send to MCSMUX
    // MCS FUTURE: hConn should point to a real Connection object.
    CPin.Header.hUser = NULL;  // Signals node controller traffic.
    CPin.Header.Type = MCS_CONNECT_PROVIDER_INDICATION;
    CPin.hConn = (PVOID) 1;  // Non-NULL so we know this is remote connection.
    RtlCopyMemory(CPin.UserData, pUserData, CPin.UserDataLength);

    // Set state for this connection, we are waiting for a reply from NC.
    pDomain->State = State_ConnectProvIndPending;
        
    ASSERT(pDomain->bChannelBound);
    TraceOut(pDomain->pContext, "HandleConnectInitial(): Sending "
            "CONNECT_PROVIDER_IND upward");
    Status = IcaChannelInput(pDomain->pContext, Channel_Virtual,
            Virtual_T120ChannelNum, NULL, (BYTE *)&CPin, sizeof(CPin));
    if (!NT_SUCCESS(Status)) {
        ErrOut(pDomain->pContext, "ChannelInput failed on "
                "connect-provider indication");

        // Ignore errors here. This should only happen if stack is going down.
        return TRUE;
    }

    return TRUE;

BadResult:
    if (Result == H_TooShort)
        return FALSE;
    
    // Must be H_BadContents.
    ErrOut(pDomain->pContext, "HandleConnectInitial(): Could not parse PDU, "
            "returning PDU reject");
    ReturnRejectPDU(pDomain, Diag_InvalidBEREncoding, SaveFrame,
            SaveBytesLeft - BytesLeft);
    MCSProtocolErrorEvent(pDomain->pContext, pDomain->pStat,
            Log_MCS_ConnectPDUBadPEREncoding,
            Frame, BytesLeft);

    // Attempt to skip the entire PDU.
    *pNBytesConsumed = SaveBytesLeft;

    // Return FALSE to force the caller to fail.
    return FALSE;
}


/*
 * PDU 102
 *
 *   Connect-Response ::= [APPLICATION 102] IMPLICIT SEQUENCE {
 *       result           Result,
 *       calledConnectId  INTEGER (0..MAX),
 *       domainParameters DomainParameters,
 *       userData         OCTET STRING
 *   }
 */

// pBuffer is assumed to point to a buffer of at least size given
//   by macro ConnectResponseHeaderSize; X.224 header will start here.
// Actual number of bytes used for the encoding is returned in
//   *pNBytesConsumed.
// We do not encode the user data, but instead just the header, which
//   allows some optimization by allowing the header to be encoded
//   and copied to the beginning of user data.
void CreateConnectResponseHeader(
        PSDCONTEXT pContext,  // For tracing.
        MCSResult  Result,
        int        CalledConnectID,
        DomainParameters *pDomParams,
        unsigned   UserDataLength,
        BYTE       *pBuffer,
        unsigned   *pNBytesConsumed)
{
    BYTE *OutFrame, *newFrame;
    unsigned NBytesConsumed, TotalSize, EncodeLength;

    // Set up for creating the PDU.
    OutFrame = pBuffer + X224_DataHeaderSize;
    NBytesConsumed = 0;

    // Encode the BER prefix, PDU type, and leave space for the PDU length.
    // Note that the length is the number of bytes following this length
    //   indicator.
    // The most-oft-encountered case is where the PDU length is less than 128
    //   bytes. So, special-case larger sizes at the end of the function
    //   when we know the total size.
    OutFrame[0] = MCS_CONNECT_PDU;
    OutFrame[1] = MCS_CONNECT_RESPONSE_ENUM;
    // Skip OutFrame[2] for the default 1-byte (<= 128) size.
    OutFrame += 3;
    TotalSize = 3;

    // Encode Result, CalledConnectID, DomParams. We use OutFrame
    //   as a current pointer.
    EncodeTagBER(pContext, OutFrame, TagType_Enumeration, 0, Result,
            &NBytesConsumed, &newFrame);
    TotalSize += NBytesConsumed;
    OutFrame = newFrame;

    EncodeTagBER(pContext, OutFrame, TagType_Integer, 0, CalledConnectID,
            &NBytesConsumed, &newFrame);
    TotalSize += NBytesConsumed;
    OutFrame = newFrame;

    EncodeDomainParameters(pContext, OutFrame, &NBytesConsumed, pDomParams,
            &newFrame);
    TotalSize += NBytesConsumed;
    OutFrame = newFrame;

    // Encode only the length bytes, not the user data body.
    EncodeTagBER(pContext, OutFrame, TagType_OctetString, UserDataLength,
            (UINT_PTR)NULL, &NBytesConsumed, &newFrame);
    TotalSize += NBytesConsumed;
    OutFrame = newFrame;

    // Encode the final size. Here we special-case a too-large size by
    //   shifting data around. The large size is the exceptional case.
    EncodeLength = TotalSize - 3 + UserDataLength;
    if (EncodeLength < 128) {
        pBuffer[2 + X224_DataHeaderSize] = (BYTE)EncodeLength;
    }
    else {
        unsigned i, Len = 0;

        WarnOut(pContext, "CreateConnRespHeader(): Perf hit from too-large "
                "PDU size");
        
        // Since we can only send up to 64K bytes, the length determinant
        //   cannot be any more than 3 bytes long.
        ASSERT(EncodeLength < 65535);
        if (EncodeLength < 0x8000)
            Len = 2;
        else if (EncodeLength < 0x800000)
            Len = 3;
        else
            ASSERT(FALSE);

        // Size escape comes first.
        pBuffer[2 + X224_DataHeaderSize] = LengthModifier_2 + Len - 2;

        RtlMoveMemory(pBuffer + 3 + X224_DataHeaderSize + Len,
                pBuffer + 3 + X224_DataHeaderSize, EncodeLength - 3);

        for (i = 1; i <= Len; i++) {
            pBuffer[3 + X224_DataHeaderSize + Len - i] = (BYTE)EncodeLength;
            EncodeLength >>= 8;
        }

        // We already included one byte of the length encoding above, but
        // now we need to also skip the length escape and the encoded length.
        TotalSize += Len;
    }
    
    // Set up X224 header based on the final size of the packet.
    CreateX224DataHeader(pBuffer, TotalSize + UserDataLength, TRUE);

    *pNBytesConsumed = X224_DataHeaderSize + TotalSize;
}


#ifdef MCS_Future
BOOLEAN __fastcall HandleConnectResponse(
        PDomain  pDomain,
        BYTE     *Frame,
        unsigned BytesLeft,
        unsigned *pNBytesConsumed)
{
//MCS FUTURE: This will be needed to handle the future case where we initiate
//connections for joins/invites.
    ErrOut(pDomain->pContext, "Connect Response PDU received, "
            "this should never happen");
    MCSProtocolErrorEvent(pDomain->pContext, pDomain->pStat,
            Log_MCS_UnsupportedConnectPDU,
            Frame, BytesLeft);

    // Consume all the data given to us.
    *pNBytesConsumed = BytesLeft;
    return TRUE;
}
#endif  // MCS_Future


/*
 * PDU 103
 *
 *   Connect-Additional ::= [APPLICATION 103] IMPLICIT SEQUENCE {
 *       calledConnectId  INTEGER (0..MAX),
 *       dataPriority     DataPriority
 *   }
 *
 * No Create() funcion, we never expect to initiate these PDUs.
 *
 * We do not handle these PDUs for this Hydra release, since in the Citrix
 *   framework there can be only one connection at a time. Domain parameters
 *   should have been negotiated to only one connection handling all SendData
 *   priorities.
 */

#ifdef MCS_Future
BOOLEAN __fastcall HandleConnectAdditional(
        PDomain  pDomain,
        BYTE     *Frame,
        unsigned BytesLeft,
        unsigned *pNBytesConsumed)
{
    ErrOut(pDomain->pContext, "Connect-additional PDU received, "
            "this should never happen");
    MCSProtocolErrorEvent(pDomain->pContext, pDomain->pStat,
            Log_MCS_UnsupportedConnectPDU,
            Frame, BytesLeft);

    // Consume all the data given to us.
    *pNBytesConsumed = BytesLeft;
    return TRUE;
}
#endif  // MCS_Future



/*
 * PDU 104
 *
 *   Connect-Result ::= [APPLICATION 104] IMPLICIT SEQUENCE {
 *       result Result
 *   }
 *
 * No Create() function, we never expect to initiate these PDUs.
 *
 * We do not handle these PDUs for this Hydra release, since in the Citrix
 *   framework there can be only one connection at a time.
 */

#ifdef MCS_Future
BOOLEAN __fastcall HandleConnectResult(
        PDomain  pDomain,
        BYTE     *Frame,
        unsigned BytesLeft,
        unsigned *pNBytesConsumed)
{
    ErrOut(pDomain->pContext, "Connect-result PDU received, "
            "this should never happen");
    MCSProtocolErrorEvent(pDomain->pContext, pDomain->pStat,
            Log_MCS_UnsupportedConnectPDU,
            Frame, BytesLeft);

    // Consume all the data given to us.
    *pNBytesConsumed = BytesLeft;
    return TRUE;
}
#endif  // MCS_Future
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\pdmcs\decode.c ===
/* (C) 1997-1999 Microsoft Corp.
 *
 * file   : Decode.c
 * author : Erik Mavrinac
 *
 * description: Decoding logic for MCS PDUs, for passing on to handlers
 *   in ConPDU.c for connect PDUs and DomPDU.c and other files for domain
 *   PDUs.
 */

#include "precomp.h"
#pragma hdrstop

#include <mcsimpl.h>
#include <at128.h>


/*
 * Defines
 */

// Leading PDU byte for connect PDUs.
#define CONNECT_PDU 0x7F

// Size of the X.224 RFC1006 header.
#define RFC1006HeaderSize 4

// Constant for an incompletely-received input data header.
#define IncompleteHeader 0xFFFFFFFF

// Sizes for fast-path headers.
#define FastPathBaseHeaderSize 2


/*
 * Prototypes for external functions for which we have no header.
 */
void __stdcall SM_DecodeFastPathInput(void *, BYTE *, unsigned, unsigned,
        unsigned, unsigned);


/*
 * Prototypes for locally-defined functions
 */
BOOLEAN  __fastcall RecognizeMCSFrame(PDomain, BYTE *, int, unsigned *);
MCSError __fastcall DeliverShadowData(PDomain, BYTE *, unsigned, ChannelID);


/*
 * Logs an error to the system event log and drops the connection.
 * ErrDetailCodes are from inc\LogErr.h.
 */

// Defined maximum size for caller-provided data to be sent to system event
//   log. Max data size is 256, IcaLogError() includes a Unicode string
//   "WinStation" which takes up some of the space, as does the unsigned
//   subcode used here.
#define MaxEventDataLen (234 - sizeof(unsigned))

void APIENTRY MCSProtocolErrorEvent(
        PSDCONTEXT      pContext,
        PPROTOCOLSTATUS pStat,
        unsigned        ErrDetailCode,
        BYTE            *pDetailData,
        unsigned        DetailDataLen)
{
    BYTE SpewBuf[256];
    WCHAR *StringParams;
    unsigned DataLen;
    NTSTATUS Status;
    UNICODE_STRING EventLogName;
    ICA_CHANNEL_COMMAND Command;

    // Increment the error counter.
    pStat->Input.Errors++;

    // Set the facility name based on the ErrDetailCode. More will need to be
    //   added here as we get more facilties using this function.
    if (ErrDetailCode == Log_Null_Base)
        StringParams = L"NULL";
    else if (ErrDetailCode >= Log_X224_Base && ErrDetailCode < Log_MCS_Base)
        StringParams = L"X.224";
    else if (ErrDetailCode >= Log_MCS_Base && ErrDetailCode < Log_RDP_Base)
        StringParams = L"MCS";
    else if (ErrDetailCode >= Log_RDP_Base && ErrDetailCode < Log_RDP_ENC_Base)
        StringParams = L"WD";
    else if (ErrDetailCode >= Log_RDP_ENC_Base)  // Add new facility here...
        StringParams = L"\"DATA ENCRYPTION\"";

    // ErrDetailCode is designated as the first unsigned in the extra buffer.
    *((unsigned *)SpewBuf) = ErrDetailCode;

    // Limit data according to max size.
    DataLen = (DetailDataLen < MaxEventDataLen ? DetailDataLen :
            MaxEventDataLen);
    if (pDetailData != NULL)
        memcpy(SpewBuf + sizeof(unsigned), pDetailData, DataLen);
    DataLen += sizeof(unsigned);

    IcaLogError(pContext, STATUS_RDP_PROTOCOL_ERROR, &StringParams, 1,
            SpewBuf, DataLen);

    // Signal that we need to drop the link.
    Command.Header.Command = ICA_COMMAND_BROKEN_CONNECTION;
    Command.BrokenConnection.Reason = Broken_Unexpected;
    Command.BrokenConnection.Source = BrokenSource_Server;

    Status = IcaChannelInput(pContext, Channel_Command, 0, NULL,
            (BYTE *)&Command, sizeof(Command));
    if (!NT_SUCCESS(Status))
        ErrOut(pContext, "MCSProtocolErrorEvent(): Could not send BROKEN_CONN "
                "upward");
}



/*
 * Utility function to send an X.224 connection response. Used by
 *   DecodeWireData() and when a T120_START is sent indicating the
 *   stack is up.
 */
NTSTATUS SendX224Confirm(Domain *pDomain)
{
    POUTBUF pOutBuf;
    NTSTATUS Status;

    pDomain->State = State_X224_Connected;

    // This PDU send is vital to the connection and must succeed.
    // Keep retrying the allocation until it succeeds.
    do {
        // Allow the call to wait for a buffer.
        Status = IcaBufferAlloc(pDomain->pContext, TRUE, FALSE,
                X224_ConnectionConPacketSize, NULL, &pOutBuf);
        if (Status != STATUS_SUCCESS)  // NT_SUCCESS() does not fail STATUS_TIMEOUT
            ErrOut(pDomain->pContext,
                    "Could not alloc X.224 connect-confirm OutBuf, retrying");
    } while (Status != STATUS_SUCCESS);

    // Use a bogus source port number for the confirm. This is
    //   not used by either side.
    CreateX224ConnectionConfirmPacket(pOutBuf->pBuffer,
            pDomain->X224SourcePort, 0x1234);
    pOutBuf->ByteCount = X224_ConnectionConPacketSize;

    Status = SendOutBuf(pDomain, pOutBuf);
    if (!NT_SUCCESS(Status)) {
        ErrOut(pDomain->pContext,
                "Unable to send X.224 connection-confirm");
        return Status;  // Intended receiver receives silence.
    }

    return STATUS_SUCCESS;
}



/*
 * Connect-request-specific bytes:
 *   Byte   Contents
 *   ----   --------
 *    6     MSB of destination (answering) socket/port #,
 *          should be 0
 *    7     LSB of destination socket/port #, should be 0
 *    8     MSB of source (calling) socket/port #
 *    9     LSB of source socket/port #
 *    10    Data class, should be 0x00 for X.224 class 0.
 *
 * Following are an optional TPDU size (incl. RFC1006 header size
 *     of 4 bytes but not incl. X.224 3-byte data header)
 *     negotiation block.
 * If this block is not present, an RFC1006 default is assumed
 *     (65531, minus 3 bytes for the rest of the data packet
 *     header)
 * Only present if LenInd is 2:
 *    11    TPDU type (only TPDU_SIZE (0xC0) supported)
 *    12    Info length (must be 0x01 for TPDU_SIZE)
 *    13    Encoded per X.224 sec 13.3.4(b), as power of 2 in
 *          range 7..11 for TPDU size
 */

NTSTATUS HandleX224ConnectReq(
        Domain   *pDomain,
        BYTE     *pBuffer,
        unsigned PacketLen)
{
    POUTBUF pOutBuf;
    NTSTATUS Status;
    unsigned LenInd;

    if (pDomain->State != State_Unconnected) {
        ErrOut(pDomain->pContext,
                "X.224 ConnectionRequest received unexpectedly");
        MCSProtocolErrorEvent(pDomain->pContext, pDomain->pStat,
                Log_X224_ConnectReceivedAfterConnected,
                pBuffer, PacketLen);
        return STATUS_RDP_PROTOCOL_ERROR;
    }

    // Decode the length indicator in byte 4. Should be equal to the
    //   remaining packet size after the RFC1006 header and LenInd byte.
    LenInd = pBuffer[4];
    if (LenInd != (PacketLen - RFC1006HeaderSize - 1)) {
        ErrOut(pDomain->pContext,
                "X.224 Connect LenInd does not match packet length");
        MCSProtocolErrorEvent(pDomain->pContext, pDomain->pStat,
                Log_X224_ConnectLenIndNotMatchingPacketLen,
                pBuffer, PacketLen);
        return STATUS_RDP_PROTOCOL_ERROR;
    }


    // Check for possible denial-of-service attack or malformed packet.
    if (PacketLen < 11 || LenInd < 6) {
        ErrOut(pDomain->pContext, "HandleX224ConnectReq(): Header length "
                "or LenInd encoded in X.224 header too short");
        MCSProtocolErrorEvent(pDomain->pContext, pDomain->pStat,
                Log_X224_ConnectHeaderLenNotRequiredSize,
                pBuffer, PacketLen);
        return STATUS_RDP_PROTOCOL_ERROR;
    }

    // Verify that dst port is set per standard.
    if (pBuffer[6] != 0x00 || pBuffer[7] != 0x00)
        WarnOut(pDomain->pContext, "HandleX224ConnectReq(): Dest port not "
                "0x0000");

    // Save src port.
    pDomain->X224SourcePort = (pBuffer[8] << 8) + pBuffer[9];

    // Must be class 0 connection per standard.
    if (pBuffer[10] != 0x00) {
        ErrOut(pDomain->pContext, "HandleX224ConnectReq(): Data class not "
                "0x00 (X.224 class 0)");
        MCSProtocolErrorEvent(pDomain->pContext, pDomain->pStat,
                Log_X224_ConnectNotClassZero,
                pBuffer, PacketLen);
        return STATUS_RDP_PROTOCOL_ERROR;
    }

    // Set the default RFC1006 data size.
    pDomain->MaxX224DataSize = X224_DefaultDataSize;

    // Check for optional parameters.
    if (LenInd == 6)
        goto FinishedDecoding;

    // TPDU_SIZE is 3 bytes.
    if (PacketLen < 14 || LenInd < 9) {
        ErrOut(pDomain->pContext, "HandleX224ConnectReq(): Header length(s) "
                "encoded in CR header too short for TPDU_SIZE");
        goto FinishedDecoding;
    }

    //MCS FUTURE: X.224 class 0 defined a couple more codes here;
    // should we handle them in the future?
    if (pBuffer[11] == TPDU_SIZE) {
        if (pBuffer[12] != 0x01) {
            ErrOut(pDomain->pContext, "HandleX224ConnectReq(): Illegal data "
                    "size field in TPDU_SIZE block");
            MCSProtocolErrorEvent(pDomain->pContext, pDomain->pStat,
                    Log_X224_ConnectTPDU_SIZELengthFieldIllegalValue,
                    pBuffer, PacketLen);
            return STATUS_RDP_PROTOCOL_ERROR;
        }

        // Must conform to X.224 class 0 constraints of 7..11.
        if (pBuffer[13] < 7 || pBuffer[13] > 11) {
            ErrOut(pDomain->pContext, "HandleX224ConnectReq(): Illegal data "
                    "size field in TPDU size block");
            MCSProtocolErrorEvent(pDomain->pContext, pDomain->pStat,
                    Log_X224_ConnectTPDU_SIZENotLegalRange,
                    pBuffer, PacketLen);
            return STATUS_RDP_PROTOCOL_ERROR;
        }

        // Size is power of 2 -- 128..2048, minus 3 bytes for X.224
        //   Data TPDU header size.
        pDomain->MaxX224DataSize = (1 << pBuffer[13]) - 3;

        if (PacketLen > 14)
            WarnOut(pDomain->pContext, "HandleX224ConnectReq(): Frame size "
                    "greater than TPDU data bytes (incl. TPDU-SIZE) for "
                    "connection-request");
    }

    if (LenInd > 9)
        WarnOut(pDomain->pContext, "X224Recognize(): Extra optional "
                 "fields present in TPDU, we are not handling!");

FinishedDecoding:
    // If the virtual channels have already been bound, and the
    //   stack has been given permission to send, send the
    //   X.224 response to start the client data flow.
    if (pDomain->bChannelBound && pDomain->bCanSendData) {
        TraceOut(pDomain->pContext,
                "DecodeWireData(): Sending X.224 response");
        Status = SendX224Confirm(pDomain);
        // Ignore errors. Should only occur if the stack is
        //   going down.
    }
    else {
        // Set up for later with indication that X.224 is waiting.
        pDomain->State = State_X224_Requesting;
    }

    return STATUS_SUCCESS;
}



/*
 * Disconnect-request-specific bytes:
 *   Byte   Contents
 *   ----   --------
 *    6     MSB of destination socket/port #
 *    7     LSB of destination socket/port #
 *    8     MSB of source (sending) socket/port #
 *    9     LSB of source socket/port #
 *    10    Reason code:
 *            0 : not specified
 *            1 : congestion at sending machine
 *            2 : no session manager for data at sender
 *            3 : address unknown
 *
 * NOTE: We do not use any of these fields.
 */

NTSTATUS HandleX224Disconnect(
        Domain   *pDomain,
        BYTE     *pBuffer,
        unsigned PacketLen)
{
    unsigned LenInd;

    if (pDomain->State == State_Unconnected) {
        ErrOut(pDomain->pContext, "HandleX224Disconnect(): Disconnect "
                "received when not connected");
        MCSProtocolErrorEvent(pDomain->pContext, pDomain->pStat,
                Log_X224_DisconnectWithoutConnection,
                pBuffer, PacketLen);
        return STATUS_RDP_PROTOCOL_ERROR;
    }

    if (pDomain->State == State_MCS_Connected) {
        // Not a serious error since we just dropped X.224 below MCS
        //   without first dropping MCS.
        WarnOut(pDomain->pContext, "X.224 Disconnect received, "
                "MCS was in connected state");
        SignalBrokenConnection(pDomain);
    }

    pDomain->State = State_Disconnected;
    pDomain->bEndConnectionPacketReceived = TRUE;

    // Decode the length indicator in byte 4. Should be equal to the
    //   remaining packet size after the RFC1006 header and LenInd byte.
    LenInd = pBuffer[4];
    if (LenInd != (PacketLen - RFC1006HeaderSize - 1)) {
        ErrOut(pDomain->pContext,
                "X.224 Disconnect LenInd does not match packet length");
        MCSProtocolErrorEvent(pDomain->pContext, pDomain->pStat,
                Log_X224_DisconnectLenIndNotMatchingPacketLen,
                pBuffer, PacketLen);
        return STATUS_RDP_PROTOCOL_ERROR;
    }

    // Possible denial-of-service attack or malformed packet.
    if (PacketLen != 11 || LenInd != 6) {
        ErrOut(pDomain->pContext, "HandleX224Disconnect(): Overall header "
                "length or LenInd encoded in X.224 Disconnect wrong size");
        MCSProtocolErrorEvent(pDomain->pContext, pDomain->pStat,
                Log_X224_DisconnectHeaderLenNotRequiredSize,
                pBuffer, PacketLen);
        return STATUS_RDP_PROTOCOL_ERROR;
    }

    return STATUS_SUCCESS;
}



/*
 * Main entry point for data arriving from transport via IcaRawInput() path.
 * Decode data passed up from the transport. pBuffer is assumed not to be
 *   usable beyond the return from this function, so that data copying is
 *   done as necessary. It is possible for incomplete frames to be passed
 *   in, so a packet reassembly buffer is maintained.
 * This function is called directly by ICADD with a pointer to the WD data
 *   structure. By convention, we assume that the DomainHandle is first in
 *   that struct so we can simply do a double-indirection to get to our data.
 * Assumes the presence of X.224 framing headers at the start of all
 *   data.
 *
 * General X.224 header is laid out as follows, with specific TPDU bytes
 *     following:
 *   Byte   Contents
 *   ----   --------
 *    0     RFC1006 version number, must be 0x03.
 *    1     RFC1006 Reserved, must be 0x00.
 *    2     RFC1006 MSB of word-sized total-frame length (incl. whole X.224
 *          header).
 *    3     RFC1006 LSB of word-sized total-frame length.
 *    4     Length Indicator, the size of the header bytes following.
 *    5     Packet type indicator. Only 4 most sig. bits are type code, but
 *          X.224 class 0 specifies lower 4 bits to be 0 anyway.
 */

NTSTATUS MCSIcaRawInput(
        void   *pTSWd,
        PINBUF pInBuf,
        BYTE   *pBuf,
        ULONG  BytesLeft)
{
    BYTE *pBuffer;
    Domain *pDomain;
    BOOLEAN bUsingReassemblyBuf, bMCSRecognizedFrame;
    unsigned NBytesConsumed_MCS, Diff, X224TPDUType, PacketLength;

    // We assume we will not use InBufs.
    ASSERT(pInBuf == NULL);
    ASSERT(pBuf != NULL);
    ASSERT(BytesLeft != 0);

    // We actually receive a pointer to WD instance data. The first element in
    // that data is a DomainHandle, i.e. a pointer to a Domain.
    pDomain = *((Domain **)pTSWd);

    // Increment protocol counters.
    pDomain->pStat->Input.WdBytes += BytesLeft;
    pDomain->pStat->Input.WdFrames++;

#ifdef DUMP_RAW_INPUT
    DbgPrint("Received raw input, len=%d\n", BytesLeft);
    if (pDomain->Ptrs[0] == NULL)
        pDomain->Ptrs[0] = pDomain->FooBuf;
    memcpy(pDomain->Ptrs[pDomain->NumPtrs], pBuf, BytesLeft);
    pDomain->NumPtrs++;

    pDomain->Ptrs[pDomain->NumPtrs] = (BYTE *)pDomain->Ptrs[pDomain->NumPtrs - 1] +
            BytesLeft;
#endif

    /*
     * Check for previous data in reassembly buffer. Prepare whole X.224
     *   packet for decode loop.
     */
    if (pDomain->StackClass != Stack_Shadow) {
        if (pDomain->StoredDataLength == 0) {
            // We'll handle setup of this case just inside the decode loop,
            //   triggered by this value being FALSE.
            bUsingReassemblyBuf = FALSE;
        }
        else {
            ASSERT(pDomain->pReassembleData != NULL);
    
            if (pDomain->PacketDataLength == IncompleteHeader) {
                ASSERT(pDomain->pReassembleData == pDomain->PacketBuf);
    
                // We did not have enough of a header last time to
                // determine the packet size. Try to reassemble enough of one
                // to get the size. We only need the first 4 bytes to get
                // the size from the X.224 RFC1006 header, or 2-3 bytes
                // for the fastpath header. We know the packet type based
                // on the first byte, and must have received at least
                // one byte in the last round.
                if ((BytesLeft + pDomain->StoredDataLength) <
                        pDomain->PacketHeaderLength) {
                    // Copy what little we got and return -- we still don't
                    // have a header.
                    memcpy(pDomain->pReassembleData +
                            pDomain->StoredDataLength, pBuf, BytesLeft);
                    pDomain->StoredDataLength += BytesLeft;
                    return STATUS_SUCCESS;
                }
    
                if (pDomain->PacketHeaderLength < pDomain->StoredDataLength) {
                    pBuffer = pDomain->pReassembleData;
                    goto X224BadPktType;
                }
                memcpy(pDomain->pReassembleData +
                        pDomain->StoredDataLength, pBuf,
                        pDomain->PacketHeaderLength -
                        pDomain->StoredDataLength);
                BytesLeft -= (pDomain->PacketHeaderLength -
                        pDomain->StoredDataLength);
                pBuf += (pDomain->PacketHeaderLength -
                        pDomain->StoredDataLength);
                pDomain->StoredDataLength = pDomain->PacketHeaderLength;
    
                // Get the size.
                if (pDomain->bCurrentPacketFastPath) {
                    // Total packet length is in the second and, possibly,
                    // third bytes.of the packet. Format is similar to
                    // ASN.1 PER - high bit of first byte set means length is
                    // contained in the low 7 bits of current byte as the
                    // most significant bits, plus the 8 bits of the
                    // next byte for a total size of 15 bits. Otherwise,
                    // the packet size is contained within the low 7 bits
                    // of the second byte only.
                    if (!(pDomain->pReassembleData[1] & 0x80)) {
                        pDomain->PacketDataLength =
                                pDomain->pReassembleData[1];
                    }
                    else {
                        // We need a third byte. We don't assemble it the
                        // first time around to keep from corrupting the
                        // stream if we received a 1-byte size with no
                        // contents. Most often we will be receiving
                        // a 1-byte size anyway, so this code is little
                        // executed.
                        pDomain->PacketHeaderLength = 3;
                        if (BytesLeft) {
                            pDomain->pReassembleData[2] = *pBuf;
                            pDomain->PacketDataLength =
                                    (pDomain->pReassembleData[1] & 0x7F) << 8 |
                                    *pBuf;
                            BytesLeft--;
                            pBuf++;
                        }
                        else {
                            // No data left, try again later.
                            // IncompleteHeader is already in PacketDataLength.
                            return STATUS_SUCCESS;
                        }
                    }
                }
                else {
                    // X.224 packet, length is in third and fourth bytes.
                    pDomain->PacketDataLength =
                            (pDomain->pReassembleData[2] << 8) +
                            pDomain->pReassembleData[3];
                }

                // Dynamically allocate a buffer if size is too big.
                if (pDomain->PacketDataLength > pDomain->ReceiveBufSize) {
                    TraceOut1(pDomain->pContext, "MCSIcaRawInput(): "
                             "Allocating large [%ld] X.224 reassembly buf (path1)!",
                              pDomain->PacketDataLength);
    
                    pDomain->pReassembleData = ExAllocatePoolWithTag(PagedPool,
                            pDomain->PacketDataLength + INPUT_BUFFER_BIAS, MCS_POOL_TAG);
                    if (pDomain->pReassembleData != NULL) {
                        // Copy the assembled header.
                        memcpy(pDomain->pReassembleData,
                                pDomain->PacketBuf,
                                pDomain->PacketHeaderLength);
                    }
                    else {
                        // We are trying to parse the beginning of a net frame
                        //   and have run out of memory. Set to read from the
                        //   RFC1006 header if we are called again.
                        ErrOut(pDomain->pContext, "MCSIcaRawInput(): "
                                "Failed to alloc large X.224 reassembly buf");
                        pDomain->pReassembleData = pDomain->PacketBuf;
                        return STATUS_NO_MEMORY;
                    }
                }
            }
    
            if ((pDomain->StoredDataLength + BytesLeft) <
                    pDomain->PacketDataLength) {
                // We still don't have enough data. Copy what we have
                //   and return.
                memcpy(pDomain->pReassembleData +
                        pDomain->StoredDataLength, pBuf, BytesLeft);
                pDomain->StoredDataLength += BytesLeft;
                return STATUS_SUCCESS;
            }
    
            // We have at least enough data for this packet. Only copy
            //   up to the end of this particular packet. We'll handle
            //   any later data below.
            if (pDomain->StoredDataLength > pDomain->PacketDataLength) {
                // We received a bad packet. Get out of here.
                pBuffer = pDomain->pReassembleData;
                goto X224BadPktType;
            }

            Diff = pDomain->PacketDataLength - pDomain->StoredDataLength;
            memcpy(pDomain->pReassembleData +
                    pDomain->StoredDataLength, pBuf, Diff);
            pBuf += Diff;
            BytesLeft -= Diff;
            pDomain->StoredDataLength = pDomain->PacketDataLength;
    
            // Set decode data.
            pBuffer = pDomain->pReassembleData;
            PacketLength = pDomain->PacketDataLength;
    
            // This will prevent us from doing the default input-buffer setup
            //   below.
            bUsingReassemblyBuf = TRUE;
        }


        /*
         * Main decode loop.
         * Loops as long as there are complete X.224 packets to decode.
         */
        for (;;) {
            /*
             * Handle the general case of data being used directly from the
             *   inbound data buffer.
             */
            if (!bUsingReassemblyBuf) {
                // We must have at least one byte. Determine the packet type.
                if ((pBuf[0] & TS_INPUT_FASTPATH_ACTION_MASK) ==
                        TS_INPUT_FASTPATH_ACTION_FASTPATH) {
                    // Fast-path packet (low 2 bits = 00). Set up the minimum
                    // header length.
                    pDomain->PacketHeaderLength = 2;
                    pDomain->bCurrentPacketFastPath = TRUE;
                }
                else if ((pBuf[0] & TS_INPUT_FASTPATH_ACTION_MASK) ==
                        TS_INPUT_FASTPATH_ACTION_X224) {
                    // X.224. Use 4-byte fixed header length.
                    pDomain->PacketHeaderLength = RFC1006HeaderSize;
                    pDomain->bCurrentPacketFastPath = FALSE;
                }
                else {
                    // Bad low bits of first byte.
                    pBuffer = pBuf;
                    goto X224BadPktType;
                }

                // Check we have enough for the minimum header.
                if (BytesLeft >= pDomain->PacketHeaderLength) {
                    // Get the size.
                    if (pDomain->bCurrentPacketFastPath) {
                        // Total packet length is in the second and, possibly,
                        // third bytes.of the packet. Format is similar to
                        // ASN.1 PER - high bit of first byte set means length is
                        // contained in the low 7 bits of current byte as the
                        // most significant bits, plus the 8 bits of the
                        // next byte for a total size of 15 bits. Otherwise,
                        // the packet size is contained within the low 7 bits
                        // of the second byte only.
                        if (!(pBuf[1] & 0x80)) {
                            PacketLength = pBuf[1];
                        }
                        else {
                            // We need a third byte. We don't assemble it the
                            // first time around to keep from corrupting the
                            // stream if we received a 1-byte size with no
                            // contents. Most often we will be receiving
                            // a 1-byte size anyway, so this code is little
                            // executed.
                            pDomain->PacketHeaderLength = 3;
                            if (BytesLeft >= 3) {
                                PacketLength = (pBuf[1] & 0x7F) << 8 | pBuf[2];
                            }
                            else {
                                // We don't have enough for the minimum size
                                // header, store the little bit we do have.
                                pDomain->pReassembleData = pDomain->PacketBuf;
                                pDomain->StoredDataLength = BytesLeft;
                                pDomain->PacketDataLength = IncompleteHeader;
                                pDomain->pReassembleData[0] = *pBuf;
                                pDomain->pReassembleData[1] = pBuf[1];
                                break;
                            }
                        }
                    }
                    else {
                        // Get the X.224 size from the third and fourth bytes.
                        PacketLength = (pBuf[2] << 8) + pBuf[3];
                    }
                }
                else {
                    // We don't have enough for the minimum size header, store
                    // the little bit we do have.
                    pDomain->pReassembleData = pDomain->PacketBuf;
                    pDomain->StoredDataLength = BytesLeft;
                    pDomain->PacketDataLength = IncompleteHeader;
                    memcpy(pDomain->pReassembleData, pBuf, BytesLeft);
                    break;
                }
    
                // Make sure we have a whole packet.
                if (PacketLength <= BytesLeft) {
                    // Set decode data.
                    pBuffer = (BYTE *)pBuf;

                    // Skip the bytes we're about to consume.
                    pBuf += PacketLength;
                    BytesLeft -= PacketLength;
                }
                else {
                    // We don't have a whole packet, store what we do have
                    // and return.
                    pDomain->PacketDataLength = PacketLength;
                    pDomain->StoredDataLength = BytesLeft;
    
                    if (PacketLength <= pDomain->ReceiveBufSize) {
                        pDomain->pReassembleData = pDomain->PacketBuf;
                    }
                    else {
                        // Size is too big for the standard buffer, alloc one.
                        TraceOut1(pDomain->pContext, "MCSIcaRawInput(): "
                                 "Allocating large [%ld] X.224 reassembly buf (path2)!",
                                  pDomain->PacketDataLength);
    
                        pDomain->pReassembleData = ExAllocatePoolWithTag(
                                PagedPool, pDomain->PacketDataLength + INPUT_BUFFER_BIAS,
                                MCS_POOL_TAG);

                        if (pDomain->pReassembleData == NULL) {
                            // We failed to allocate, and we're in the middle of
                            //   an X.224 frame. Store no bytes, and return an
                            //   error to the transport.
                            ErrOut(pDomain->pContext, "MCSIcaRawInput(): "
                                    "Failed to alloc large X.224 reassembly buf");
                            pDomain->PacketDataLength = 0;
                            return STATUS_NO_MEMORY;
                        }
                    }
    
                    memcpy(pDomain->pReassembleData, pBuf, BytesLeft);
                    break;
                }
            }
    
            /*
             * Time to decode. Different handling for fast-path vs. X.224.
             */
            if (pDomain->bCurrentPacketFastPath) {
                // Verify that the sent size covers at least the header.
                if (PacketLength > pDomain->PacketHeaderLength) {
                    // Let SM decrypt if need be, and pass to IM.
                    SM_DecodeFastPathInput(pDomain->pSMData,
                            pBuffer + pDomain->PacketHeaderLength,
                            PacketLength - pDomain->PacketHeaderLength,
                            pBuffer[0] & TS_INPUT_FASTPATH_ENCRYPTED,
                            (pBuffer[0] & TS_INPUT_FASTPATH_NUMEVENTS_MASK) >> 2,
                            pBuffer[0] & TS_INPUT_FASTPATH_SECURE_CHECKSUM);
                    goto PostDecode;
                }
                else {
                    goto X224BadPktType;
                }
            }

            // X.224.
            //
            // Verify all TPKT data up through the TPDU type code. This code
            // is performance path, so segregate the error handling code outside
            // the main paths.
            if (pBuffer[0] == 0x03 && pBuffer[1] == 0x00 &&
                    PacketLength > RFC1006HeaderSize) {
                // Decode the X.224 PDU type contained in the 6th byte.
                X224TPDUType = pBuffer[5];
    
                // Most oft-used case is data.
                // Further bytes in data:
                //   Byte   Contents
                //   ----   --------
                //    6     EOT flag -- 0x80 if end of sequence, 0x00 if not
                //    7+    Start of user data bytes
                if (X224TPDUType == X224_Data) {
                    if (pDomain->State != State_Unconnected &&
                            pDomain->State != State_Disconnected &&
                            PacketLength > X224_DataHeaderSize &&
                            pBuffer[4] == 0x02 &&
                            pBuffer[6] == X224_EOT) {
                        bMCSRecognizedFrame = RecognizeMCSFrame(pDomain,
                                pBuffer + X224_DataHeaderSize,
                                PacketLength - X224_DataHeaderSize,
                                &NBytesConsumed_MCS);
    
                        if (bMCSRecognizedFrame &&
                                (NBytesConsumed_MCS >=
                                  (PacketLength - X224_DataHeaderSize))) {
        //                  TraceOut2(pDomain->pContext, "MCS accepted %d "
        //                          "bytes (Domain %X)", NBytesConsumed_MCS,
        //                          pDomain);
    
                        }
                        else {
                            goto MCSRecognizeErr;
                        }
                    }
                    else {
                        goto DataPktProtocolErr;
                    }
                }
                else {
                    // Control-type PDUs, not a perf path.
                    switch (X224TPDUType) {
                        case X224_ConnectionReq:
                            // Noncritical path, throw to another function to handle.
                            if (HandleX224ConnectReq(pDomain, pBuffer,
                                    PacketLength) != STATUS_SUCCESS)
                                goto ReturnErr;
                            break;
    
                        case X224_Disconnect:
                            // Noncritical path, throw to another function to handle.
                            if (HandleX224Disconnect(pDomain, pBuffer,
                                    PacketLength) != STATUS_SUCCESS)
                                goto ReturnErr;
                            break;
    
                        default:
                            ErrOut1(pDomain->pContext,
                                    "Unsupported X.224 TPDU type %d received",
                                    X224TPDUType);
                            goto X224BadPktType;
                    }
                }
            }
            else {
                goto RFC1006ProtocolErr;
            }

PostDecode:
            // Free dynamic reassembly buf if allocated.
            if (bUsingReassemblyBuf &&
                    pDomain->pReassembleData != pDomain->PacketBuf &&
                    NULL != pDomain->pReassembleData) {
                ExFreePool(pDomain->pReassembleData);
                pDomain->pReassembleData = NULL;
            }

            // Force next loop iteration to use the PDU input buffer.
            bUsingReassemblyBuf = FALSE;
            pDomain->StoredDataLength = 0;
    
            // If we consumed exactly what came in on the wire, we're done.
            if (BytesLeft == 0) {
                pDomain->StoredDataLength = 0;
                break;
            }
        }
    }

    // This is shadow stack, so deliver the data the the requested channel
    else {
        MCSError MCSErr;
    
        MCSErr = DeliverShadowData(pDomain, pBuf, BytesLeft, 
                                   pDomain->shadowChannel);
        if (MCSErr == MCS_NO_ERROR)
            return STATUS_SUCCESS;
        else
            return STATUS_RDP_PROTOCOL_ERROR;
    }

    return STATUS_SUCCESS;

    /*
     * Protocol error handling code, segregated for performance.
     */

X224BadPktType:
    MCSProtocolErrorEvent(pDomain->pContext, pDomain->pStat,
            Log_X224_UnknownPacketType,
            pBuffer, 7);
    goto ReturnErr;

MCSRecognizeErr:
    if (!bMCSRecognizedFrame) {
        //pTSWd->hDomainKernel might be cleaned by WD_Close
        if (*((Domain **)pTSWd))
        {
            ErrOut(pDomain->pContext, "MCSIcaRawInput(): X.224 data "
                "packet contains an incomplete MCS PDU!");

            if (pDomain->bCanSendData) {           
                MCSProtocolErrorEvent(pDomain->pContext, pDomain->pStat,
                    Log_X224_DataIncompleteMCSPacketNotSupported,
                    pBuffer, PacketLength);
            }
        }
        else
            goto MCSQuit;
    }

    if (NBytesConsumed_MCS <
            (PacketLength - X224_DataHeaderSize)) {
        ErrOut1(pDomain->pContext, "MCS did not consume %d bytes "
                "in X.224 data TPKT", (PacketLength -
                X224_DataHeaderSize - NBytesConsumed_MCS));
        MCSProtocolErrorEvent(pDomain->pContext, pDomain->pStat,
                Log_X224_DataMultipleMCSPDUsNotSupported,
                pBuffer, PacketLength);
        goto ReturnErr;
        // MCS FUTURE: Implement parsing more than 1 MCS PDU per
        //   X.224 TPKT.
    }

DataPktProtocolErr:
    if (*((Domain **)pTSWd) == NULL) {
        goto MCSQuit;
    }

    if (pDomain->State == State_Unconnected) {
        ErrOut(pDomain->pContext, "X.224 Data received before X.224 "
                "Connect.");
        MCSProtocolErrorEvent(pDomain->pContext, pDomain->pStat,
                Log_X224_ReceivedDataBeforeConnected,
                pBuffer, PacketLength);
        goto ReturnErr;
    }

    if (pDomain->State == State_Disconnected) {
        if (!pDomain->bEndConnectionPacketReceived) {
            TraceOut(pDomain->pContext,
                    "X.224 Data received after X.224 Disconnect or "
                    "DPum");
            goto ReturnErr;
        }
        else {
            TraceOut(pDomain->pContext, "X.224 Data received after "
                    "local disconnect, ignoring");
            goto ReturnErr;
        }
    }
    
    // Possible denial-of-service attack, malformed or null packet.
    if (PacketLength <= X224_DataHeaderSize) {
        ErrOut(pDomain->pContext, "X224Recognize(): Data header len "
                "wrong or null packet");
        MCSProtocolErrorEvent(pDomain->pContext, pDomain->pStat,
                Log_X224_PacketLengthLessThanHeader,
                pBuffer, 4);
        goto ReturnErr;
    }

    // TPDU length indicator should be 2 bytes.
    if (pBuffer[4] != 0x02) {
        ErrOut(pDomain->pContext, "MCSIcaRawInput(): X.224 data "
                "packet contains length indicator not set to 2");
        MCSProtocolErrorEvent(pDomain->pContext, pDomain->pStat,
                Log_X224_DataLenIndNotRequiredSize,
                pBuffer, 5);
        goto ReturnErr;
    }

    // We don't handle fragmented X.224 packets.
    if (pBuffer[6] != X224_EOT) {
        ErrOut(pDomain->pContext, "MCSIcaRawInput(): X.224 data "
                "packet does not have EOT bit set, not supported");
        MCSProtocolErrorEvent(pDomain->pContext, pDomain->pStat,
                Log_X224_DataFalseEOTNotSupported,
                pBuffer, 7);
        goto ReturnErr;
    }


RFC1006ProtocolErr:
    if (pBuffer[0] != 0x03 || pBuffer[1] != 0x00) {
        ErrOut1(pDomain->pContext, "X.224 RFC1006 version not correct, "
                "skipping %d bytes", PacketLength);
        MCSProtocolErrorEvent(pDomain->pContext, pDomain->pStat,
                Log_X224_RFC1006HeaderVersionNotCorrect,
                pBuffer, 2);
        goto ReturnErr;
    }

    // Null TPKTs.
    if (PacketLength <= RFC1006HeaderSize) {
        ErrOut(pDomain->pContext, "X224Recognize(): Header len "
                "given is <= 4 (RFC header only)");
        MCSProtocolErrorEvent(pDomain->pContext, pDomain->pStat,
                Log_X224_PacketLengthLessThanHeader,
                pBuffer, RFC1006HeaderSize);
        goto ReturnErr;
    }

ReturnErr:
    // Void any held packet data. The stream is considered corrupted now.
    pDomain->StoredDataLength = 0;
MCSQuit:
    return STATUS_RDP_PROTOCOL_ERROR;
}



/*
 * Decodes MCS data. Assumes that X.224 headers have already been interpreted
 *   such that pBuffer points to the start of the MCS data. Returns FALSE if
 *   the frame data was too short.
 */

BOOLEAN __fastcall RecognizeMCSFrame(
        PDomain  pDomain,
        BYTE     *pBuffer,
        int      BytesLeft,
        unsigned *pNBytesConsumed)
{
    int Result, PDUType;
    unsigned NBytesConsumed;

    *pNBytesConsumed = 0;

    if (BytesLeft >= 1) {
        if (*pBuffer != CONNECT_PDU) {
            // Domain PDUs include Data PDUs and are a perf path.

            // This must be a domain PDU. Domain PDU enumeration code is
            //   stored in the high 6 bits of the first byte.
            PDUType = *pBuffer >> 2;

            // Special-case the almost-always data case.
            if (PDUType == MCS_SEND_DATA_REQUEST_ENUM) {
                return HandleAllSendDataPDUs(pDomain, pBuffer, BytesLeft,
                        pNBytesConsumed);
            }
            else if (PDUType <= MaxDomainPDU) {
                // Domain PDUs are in the range 0..42, so simply index
                // into table and call handler. Note that we cannot skip
                // any bytes when passing to handler, since the last 2
                // bits of the initial byte can be used as information
                // by ASN.1 PER encoding.
                if (DomainPDUTable[PDUType].HandlePDUFunc != NULL)
                    return DomainPDUTable[PDUType].HandlePDUFunc(pDomain,
                            pBuffer, BytesLeft, pNBytesConsumed);
                else
                    goto DomainPDURangeErr;
            }
            else {
                goto DomainPDURangeErr;
            }
        }
        else {
            // Not a performance path, PDUs on this path are control PDUs
            // used at the beginning of a connection sequence.

            // The first byte on a connect PDU is 0x7F, so that the actual
            //   PDU code is in the second byte.
            if (BytesLeft < 2)
                return FALSE;

            PDUType = pBuffer[1];
            if (PDUType >= MinConnectPDU && PDUType <= MaxConnectPDU) {
                // Connect PDUs are in the range 101..104, so normalize to zero
                // and call from table. Note that we can skip 1st byte because
                // it has been completely claimed. 2nd byte is needed to unpack
                // the PDU size.
                PDUType = pBuffer[1] - MinConnectPDU;
                if (ConnectPDUTable[PDUType].HandlePDUFunc != NULL) {
                    if (ConnectPDUTable[PDUType].HandlePDUFunc(pDomain,
                            pBuffer + 1, BytesLeft - 1, pNBytesConsumed)) {
                        (*pNBytesConsumed)++;  // Add in the CONNECT_PDU byte.
                        return TRUE;
                    }
                    else {
                        return FALSE;
                    }
                }
                else {
                    goto ConnectPDURangeErr;
                }
            }
            else {
                goto ConnectPDURangeErr;
            }
        }

        return TRUE;
    }
    else {
        return FALSE;
    }


    /*
     * Protocol error handling code.
     */

DomainPDURangeErr:
    if (PDUType > MaxDomainPDU) {
        ErrOut1(pDomain->pContext, "RecognizeMCSFrame(): Received bad "
                "domain PDU number %d", PDUType);
        MCSProtocolErrorEvent(pDomain->pContext, pDomain->pStat,
                Log_MCS_BadDomainPDUType,
                pBuffer, BytesLeft);
        goto ReturnErr;
    }

ConnectPDURangeErr:
    if (PDUType < MinConnectPDU || PDUType > MaxConnectPDU) {
        ErrOut1(pDomain->pContext, "RecognizeMCSFrame(): Received bad "
                "connect PDU number %d", PDUType);
        MCSProtocolErrorEvent(pDomain->pContext, pDomain->pStat,
                Log_MCS_BadConnectPDUType,
                pBuffer, BytesLeft);
        goto ReturnErr;
    }

ReturnErr:
    // Skip everything we received.
    *pNBytesConsumed = BytesLeft;
    return TRUE;
}


/*
 * Called by MCSICARawInput during shadow sessions to deliver shadow data to 
 * any registered user attachements.
 */
MCSError __fastcall DeliverShadowData(
        PDomain   pDomain,
        BYTE      *Frame,
        unsigned  DataLength,
        ChannelID shadowChannel)
{
    MCSChannel     *pMCSChannel;
    unsigned       CurUserID;
    UserAttachment *pUA;

    TraceOut(pDomain->pContext, "MCSDeliverShadowData(): entry");

    // Find channel in channel list.
    if (!SListGetByKey(&pDomain->ChannelList, shadowChannel, &pMCSChannel)) {
        // Ignore sends on missing channels. This means that no one
        //   has joined the channel. Give a warning only.
        WarnOut1(pDomain->pContext, "Shadow ChannelID %d PDU does not exist",
                 shadowChannel);

        return MCS_NO_SUCH_CHANNEL;
    }

    // Send indication to all local attachments.
    SListResetIteration(&pMCSChannel->UserList);
    while (SListIterate(&pMCSChannel->UserList, (UINT_PTR *)&CurUserID, &pUA))
        if (pUA->bLocal)
            (pUA->SDCallback)(
                    Frame,  // pData
                    DataLength,
                    pUA->UserDefined,  // UserDefined
                    pUA,  // hUser
                    FALSE, // bUniform
                    pMCSChannel,  // hChannel
                    MCS_TOP_PRIORITY,
                    1004,  // SenderID
                    SEGMENTATION_BEGIN | SEGMENTATION_END); // Segmentation

    return MCS_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\pdmcs\icaiface.c ===
/* (C) 1997-1999 Microsoft Corp.
 *
 * file   : IcaIFace.c
 * author : Erik Mavrinac
 *
 * description: MCS setup/shutdown and direct entry points for use with the
 *   ICA programming model. See also Decode.c for IcaRawInput() handling.
 *
 * History:
 *  10-Aug-1997    jparsons     Revised for new calling model
 *  05-Aug-1998    jparsons     Added shadowing support
 *
 */

#include "precomp.h"
#pragma hdrstop

#include <MCSImpl.h>


// Prototype for WD function used below, so we don't need to include
// lots of extra headers.
void WDW_OnClientDisconnected(void *);


/*
 * Main initialization entry point for kernel-mode MCS.
 * Called by the WD during its processing of WdOpen().
 */
MCSError APIENTRY MCSInitialize(
        PSDCONTEXT   pContext,
        PSD_OPEN     pSdOpen,
        DomainHandle *phDomain,
        void         *pSMData)
{
    Domain *pDomain;
    unsigned i;
    ULONG  ulBufferLen;
    
    TraceOut(pContext, "MCSInitialize(): entry");

    //
    // Alloc the Domain struct. We allocate the basic size plus the typical
    // input buffer size.  The default in the registry today is 2048 which
    // nicely fits the max virtual channel PDU of about 1640.  If we get a
    // message that exceeds this length we will dynamically allocate a buffer
    // just for use in a one time reassembly then delete it.
    //
    if (pSdOpen->StackClass != Stack_Passthru) {
        ulBufferLen = pSdOpen->WdConfig.WdInputBufferLength;
    }
    else {
        ulBufferLen = 1024 * 10;
    }

    pDomain = ExAllocatePoolWithTag(PagedPool, sizeof(Domain) +
                                    ulBufferLen + INPUT_BUFFER_BIAS, MCS_POOL_TAG);
    
    if (pDomain != NULL) {
        memset(pDomain, 0, sizeof(Domain));
    }
    else {
        ErrOut(pContext, "MCSInitialize(kernel): Alloc failure "
                "allocating Domain");
        return MCS_ALLOCATION_FAILURE;
    }

    // Save pContext -- it is needed for future tracing and ICA interaction.
    pDomain->pContext = pContext;

    // Save pSMData - needed for calling fast-path input decoding function.
    pDomain->pSMData = pSMData;

    // Store what we need from SD_OPEN.
    pDomain->pStat = pSdOpen->pStatus;
    pDomain->ReceiveBufSize = ulBufferLen;

    // We have one reference to this pDomain
    pDomain->PseudoRefCount = 1;

    // Indicate that we do not want TermDD managing outbuf headers/trailers
    pSdOpen->SdOutBufHeader = 0;
    pSdOpen->SdOutBufTrailer = 0;

    // Initialize MCS-specific Domain members. We already zeroed mem
    //   so set only nonzero variables.
    SListInit(&pDomain->ChannelList, DefaultNumChannels);
    SListInit(&pDomain->UserAttachmentList, DefaultNumUserAttachments);
    pDomain->bTopProvider = TRUE;
    pDomain->NextAvailDynChannel = MinDynamicChannel;
    pDomain->State = State_Unconnected;
    pDomain->StackClass = pSdOpen->StackClass;
    for (i = 0; i < NumPreallocUA; i++) {
        pDomain->PreallocUA[i].bInUse = FALSE;
        pDomain->PreallocUA[i].bPreallocated = TRUE;
    }
    for (i = 0; i < NumPreallocChannel; i++) {
        pDomain->PreallocChannel[i].bInUse = FALSE;
        pDomain->PreallocChannel[i].bPreallocated = TRUE;
    }

    // Give the Domain to the caller.
    *phDomain = pDomain;

    // If this is a shadow or passthru stack, the default all the info
    // otherwise, all this info gets built when the client connects
    if ((pDomain->StackClass == Stack_Passthru) ||
            (pDomain->StackClass == Stack_Shadow))
        MCSCreateDefaultDomain(pContext, *phDomain);

    return MCS_NO_ERROR;
}


/*
 * Called by WD during shadow connect processing to retrieve the client MCS
 * domain parameters for use by the shadow target stack.
 */
MCSError APIENTRY MCSGetDomainInfo(
                     DomainHandle      hDomain,
                     PDomainParameters pDomParams,
                     unsigned          *MaxSendSize,
                     unsigned          *MaxX224DataSize,
                     unsigned          *X224SourcePort)
{
    Domain *pDomain = hDomain;

    TraceOut(pDomain->pContext, "MCSGetDomainInfo(): entry");

    *pDomParams = pDomain->DomParams;
    *MaxSendSize = pDomain->MaxSendSize;
    *MaxX224DataSize = pDomain->MaxX224DataSize;
    *X224SourcePort = pDomain->X224SourcePort;
    
    return MCS_NO_ERROR;
}


/*
 * Called by WD during shadow connect processing to initialize the MCS
 * domain for the shadow & passthru stacks.
 */
MCSError APIENTRY MCSCreateDefaultDomain(PSDCONTEXT pContext, 
                                         DomainHandle hDomain)
{
    Domain *pDomain = hDomain;
    
    TraceOut(pContext, "MCSCreateDefaultDomain(): entry");

    pDomain->DomParams.MaxChannels = 34;
    pDomain->DomParams.MaxUsers = RequiredMinUsers;
    pDomain->DomParams.MaxTokens = 0;
    pDomain->DomParams.NumPriorities = RequiredPriorities;
    pDomain->DomParams.MinThroughput = 0;
    pDomain->DomParams.MaxDomainHeight = RequiredDomainHeight;
    pDomain->DomParams.MaxPDUSize = X224_DefaultDataSize;
    pDomain->DomParams.ProtocolVersion = RequiredProtocolVer;
    
    pDomain->MaxSendSize = X224_DefaultDataSize - 6 - 
                  GetTotalLengthDeterminantEncodingSize(X224_DefaultDataSize);
    pDomain->MaxX224DataSize = X224_DefaultDataSize;
    pDomain->X224SourcePort = 0x1234;
    pDomain->State = State_MCS_Connected;
    pDomain->bCanSendData = 1;

    return MCS_NO_ERROR;
}


/*
/*
 * Called by WD during shadow connect processing to get the default domain
 * params for the shadow target stack.
 */
MCSError APIENTRY MCSGetDefaultDomain(PSDCONTEXT        pContext,
                                      PDomainParameters pDomParams,
                                      unsigned          *MaxSendSize,
                                      unsigned          *MaxX224DataSize,
                                      unsigned          *X224SourcePort)
{
    TraceOut(pContext, "MCSGetDefaultDomain(): entry");
    
    pDomParams->MaxChannels = 34;
    pDomParams->MaxUsers = RequiredMinUsers;
    pDomParams->MaxTokens = 0;
    pDomParams->NumPriorities = RequiredPriorities;
    pDomParams->MinThroughput = 0;
    pDomParams->MaxDomainHeight = RequiredDomainHeight;
    pDomParams->MaxPDUSize = X224_DefaultDataSize;
    pDomParams->ProtocolVersion = RequiredProtocolVer;
    
    *MaxSendSize = pDomParams->MaxPDUSize - 6 - 
        GetTotalLengthDeterminantEncodingSize(pDomParams->MaxPDUSize);    
    *MaxX224DataSize = X224_DefaultDataSize;
    *X224SourcePort = 0x1234; 

    return MCS_NO_ERROR;
}


/*
 * Called by WD during shadow connect processing to register which channel
 * should receive all shadow data.
 */
MCSError APIENTRY MCSSetShadowChannel(
        DomainHandle hDomain,
        ChannelID    shadowChannel)
{
    Domain *pDomain = hDomain;
    
    TraceOut(pDomain->pContext, "MCSSetShadowChannel: entry");

    pDomain->shadowChannel = shadowChannel;
    return MCS_NO_ERROR;
}


/*
 * Main destruction entry point for kernel-mode MCS.
 * Called by the WD during its processing of WdClose().
 */
MCSError APIENTRY MCSCleanup(DomainHandle *phDomain)
{
    Domain *pDomain;
    UINT_PTR ChannelID;
    MCSChannel *pMCSChannel;
    UserHandle hUser;
    UserAttachment *pUA;

    pDomain = (Domain *)(*phDomain);
    
    TraceOut1(pDomain->pContext, "MCSCleanup(): pDomain=%X", pDomain);

    /*
     * Free any remaining data in the Domain.
     */

    // Deallocate all remaining channels, if present. Note we should take care
    // of channels first since they're usually attached to other objects and
    // need to have their bPreallocated status determined first.
    for (;;) {
        SListRemoveFirst(&pDomain->ChannelList, &ChannelID, &pMCSChannel);
        if (pMCSChannel == NULL)
            break;
        SListDestroy(&pMCSChannel->UserList);
        if (!pMCSChannel->bPreallocated)
            ExFreePool(pMCSChannel);
    }

    // Deallocate all remaining user attachments, if present.
    for (;;) {
        SListRemoveFirst(&pDomain->UserAttachmentList, (UINT_PTR *)&hUser,
                &pUA);
        if (pUA == NULL)
            break;
        SListDestroy(&pUA->JoinedChannelList);
        if (!pUA->bPreallocated)
            ExFreePool(pUA);
    }

    // Kill lists.
    SListDestroy(&pDomain->ChannelList);
    SListDestroy(&pDomain->UserAttachmentList);

    // Free outstanding dynamic input reassembly buffer if present.
    if (pDomain->pReassembleData != NULL &&
            pDomain->pReassembleData != pDomain->PacketBuf)
        ExFreePool(pDomain->pReassembleData);

    // Free the Domain.
    PDomainRelease(pDomain);
    *phDomain = NULL;

    return MCS_NO_ERROR;
}


/*
 * Callout from WD when an IOCTL_ICA_VIRTUAL_QUERY_BINDINGS is received.
 * pVBind is a pointer to an empty SD_VCBIND struct.
 */
NTSTATUS MCSIcaVirtualQueryBindings(
        DomainHandle hDomain,
        PSD_VCBIND   *ppVBind,
        unsigned     *pBytesReturned)
{
    Domain *pDomain;
    NTSTATUS Status;
    PSD_VCBIND pVBind;

    pDomain = (Domain *)hDomain;
    pVBind = *ppVBind;

    // Define the user mode T120 channel.
    if (!pDomain->bChannelBound) {
        RtlCopyMemory(pVBind->VirtualName, Virtual_T120,
                sizeof(Virtual_T120));
        pVBind->VirtualClass = Virtual_T120ChannelNum;
        *pBytesReturned = sizeof(SD_VCBIND);
        pDomain->bChannelBound = TRUE;
        
        // Skip our entry and advance the caller's pointer.
        pVBind++;
        *ppVBind = pVBind;
    }
    else {
        *pBytesReturned = 0;
    }

    Status = STATUS_SUCCESS;

    // This is one of the events which must occur before the data flow can be
    //   sent across the net. If we have gotten an MCS_T120_START indication
    //   already, and an X.224 connect-request, then it is now time to send
    //   the X.224 response and kick off the data flow.
    if (pDomain->bCanSendData && pDomain->State == State_X224_Requesting) {
        TraceOut(pDomain->pContext,
                "IcaQueryVirtBind(): Sending X.224 response");
        Status = SendX224Confirm(pDomain);
    }
    
    return Status;
}


/*
 * Callout from WD upon reception of a IOCTL_T120_REQUEST, i.e. a user-mode
 *   ioctl.
 */
NTSTATUS MCSIcaT120Request(DomainHandle hDomain, PSD_IOCTL pSdIoctl)
{
    Domain *pDomain;
    IoctlHeader *pHeader;
    
    pDomain = (Domain *)hDomain;
    
    // Get the request type.
    ASSERT(pSdIoctl->InputBufferLength >= sizeof(IoctlHeader));
    pHeader = (IoctlHeader *)pSdIoctl->InputBuffer;

    // Make sure request within bounds.
    if (pHeader->Type < MCS_ATTACH_USER_REQUEST ||
            pHeader->Type > MCS_T120_START) {
        ErrOut(pDomain->pContext, "Invalid IOCTL_T120_REQUEST type");
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    // Check that request is supported.
    if (g_T120RequestDispatch[pHeader->Type] == NULL) {
        ErrOut(pDomain->pContext, "IOCTL_T120_REQUEST type unsupported");
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    // Make the call. The entry points are defined in MCSIoctl.c.
    return (g_T120RequestDispatch[pHeader->Type])(pDomain, pSdIoctl);
}


/*
 * Processes channel inputs from TD. For MCS we only need to check for
 *   upward-bound command channel inputs for broken-connection indications;
 *   everything else can be passed up the stack.
 */
 
// Utility function. Used here and in Decode.c for X.224 disconnection.
void SignalBrokenConnection(Domain *pDomain)
{
    NTSTATUS Status;
    DisconnectProviderIndicationIoctl DPin;

    // Check if disconnection already happened.
    if (pDomain->State != State_MCS_Connected)
        return;

    if (!pDomain->bChannelBound) {
        TraceOut(pDomain->pContext, "SignalBrokenConnection(): Cannot "
                "send disconnect-provider indication: user mode link broken");
        return;
    }

    TraceOut(pDomain->pContext, "SignalBrokenConnection(): Sending "
            "disconnect-provider indication to user mode");

    // Begin filling out disconnect-provider indication for the node controller.
    DPin.Header.Type = MCS_DISCONNECT_PROVIDER_INDICATION;
    DPin.Header.hUser = NULL;  // Node controller.
    DPin.hConn = NULL;
    DPin.Reason = REASON_DOMAIN_DISCONNECTED;
    
    TraceOut1(pDomain->pContext, "%s: SignalBrokenConnection!!!",
              pDomain->StackClass == Stack_Primary ? "Primary" :
              (pDomain->StackClass == Stack_Shadow ? "Shadow" :
              "PassThru"));
    
    // Send the DPin to the node controller channel.
    Status = IcaChannelInput(pDomain->pContext, Channel_Virtual,
            Virtual_T120ChannelNum, NULL, (BYTE *)&DPin, sizeof(DPin));
    if (!NT_SUCCESS(Status)) {
        ErrOut(pDomain->pContext, "SignalBrokenConn(): Could not send "
                "disconnect-provider indication: error on ChannelInput()");
        // Ignore errors sending disconnect-provider upward. If the stack is
        //   going down we will no longer have connectivity.
    }
    
    // Transition to state unconnected, detach nonlocal users.
    DisconnectProvider(pDomain, FALSE, REASON_DOMAIN_DISCONNECTED);
}


/*
 * This function is called directly by TermDD with a pointer to the WD data
 *   structure. By convention, we assume that the DomainHandle is first in
 *   that struct so we can simply do a double-indirection to get to our data.
 */
NTSTATUS MCSIcaChannelInput(
        void                *pTSWd,
        CHANNELCLASS        ChannelClass,
        VIRTUALCHANNELCLASS VirtualClass,
        PINBUF              pInBuf,
        BYTE                *pBuffer,
        ULONG               ByteCount)
{
    Domain *pDomain;
    NTSTATUS Status;
    PICA_CHANNEL_COMMAND pCommand;

    pDomain = (Domain *)(*((HANDLE *)pTSWd));
    
    if (ChannelClass != Channel_Command)
        goto SendUpStack;

    if (ByteCount < sizeof(ICA_CHANNEL_COMMAND)) {
        ErrOut(pDomain->pContext, "ChannelInput(): Channel_Command bad "
                "byte count");
        goto SendUpStack;
    }

    pCommand = (PICA_CHANNEL_COMMAND)pBuffer;

    if (pCommand->Header.Command != ICA_COMMAND_BROKEN_CONNECTION)
        goto SendUpStack;
                    
    TraceOut1(pDomain->pContext, "%s: ChannelInput(): broken connection received",
              pDomain->StackClass == Stack_Primary ? "Primary" :
              (pDomain->StackClass == Stack_Shadow ? "Shadow" :
              "PassThru"));
    
    // Block further send attempts from MCS. We will eventually receive an
    //   IOCTL_ICA_STACK_CANCEL_IO which means the same thing, but that is
    //   only done after we issue the ICA_COMMAND_BROKEN_CONNECTION
    //   upward.
    pDomain->bCanSendData = FALSE;

    // Signal that the client closed the connection, both for MCS and
    // directly to the WD to release any session locks waiting on
    // the client to complete a connection protocol sequence.
    if (pDomain->pBrokenEvent)
        KeSetEvent (pDomain->pBrokenEvent, EVENT_INCREMENT, FALSE);
    WDW_OnClientDisconnected(pTSWd);

    // If we have not already received a disconnect-provider request from
    //   user mode, send an indication.
    if (pDomain->State == State_MCS_Connected && pDomain->bChannelBound)
        SignalBrokenConnection(pDomain);

SendUpStack:
    Status = IcaChannelInput(pDomain->pContext, ChannelClass, VirtualClass,
            pInBuf, pBuffer, ByteCount);
    if (!NT_SUCCESS(Status))
        ErrOut(pDomain->pContext, "MCSIcaChannelInput(): Failed to forward "
               "input upward");

    return Status;
}


/*
 * Receives signal from WD that an IOCTL_ICA_STACK_CANCEL_IO was received
 *   which signals that I/O on the stack is no longer allowed. After this
 *   point no further ICA buffer allocation, freeing, or data sends should be
 *   performed.
 */
void MCSIcaStackCancelIo(DomainHandle hDomain)
{
    TraceOut(((Domain *)hDomain)->pContext, "Received STACK_CANCEL_IO");

    ((Domain *)hDomain)->bCanSendData = FALSE;
}


/*
 * Returns number of bytes (octets) consumed finding the size in NBytesConsumed.
 *   Returns length in Result. Sets *pbLarge to nonzero if there are more
 *   encoded blocks following this one.
 * Note that the maximum size encoded is 64K -- 0xC4 indicates
 *   that 4 16K blocks are encoded here. If the block is larger, for instance
 *   in a large MCS Send Data PDU, multiple blocks will be encoded one
 *   after another. If the block is an exact multiple of 16K, a trailing byte
 *   code 0x00 is appended as a placemarker to indicate that the encoding is
 *   complete.
 * Examples of large encodings:
 *
 *   16K: 0xC1, then 16K of data, then 0x00 as the final placeholder.
 *   16K + 1: 0xC1, then 16K of data, then 0x01, and finally the extra byte of data.
 *   64K: 0xC4, then 64K of data, then 0x00 as the final placeholder.
 *   128K + 1: 0xC4 then 64K of data, 0xC4 + 64K of data, 0x01 + 1 byte of data.
 *
 * pStart is assumed to be an octet(BYTE)-aligned address -- this function is
 *   designed for ALIGNED-PER encoding type, which is the type used in MCS.
 * Note that bit references here are in the range 7..0 where 7 is the high bit.
 *   The ASN.1 spec uses 8..1.
 * Returns FALSE if length could not be retrieved.
 */
BOOLEAN __fastcall DecodeLengthDeterminantPER(
        BYTE     *pStart,   // [IN], points to start of encoded bytes.
        unsigned BytesLeft, // [IN], number of bytes remaining in frame.
        BOOLEAN  *pbLarge,  // [OUT] TRUE if there are more encoded blocks following.
        unsigned *Length,   // [OUT] Number of bytes encoded here.
        unsigned *pNBytesConsumed)  // [OUT] Count of bytes consumed in decoding.
{
    if (BytesLeft >= 1) {
        if (*pStart <= 0x7F) {
            *pNBytesConsumed = 1;
            *Length = *pStart;
            *pbLarge = FALSE;
        }
        else {
            // High bit 7 set, check to see if bit 6 is set.
            if (*pStart & 0x40) {
                // Bit 6 is set, the lowest 3 bits encode the number (1..4) of
                // full 16K chunks following.
                *pNBytesConsumed = 1;
                *Length = 16384 * (*pStart & 0x07);
                *pbLarge = TRUE;
            }
            else {
                // Bit 6 is clear, length is encoded in 14 bits of last 6 bits
                //   of *pStart as most significant bits and all of the next
                //   byte as least significant.
                if (BytesLeft >= 2) {
                    *pNBytesConsumed = 2;
                    *Length = ((unsigned)((*pStart & 0x3F) << 8) +
                            (unsigned)(*(pStart + 1)));
                    *pbLarge = FALSE;
                }
                else {
                    return FALSE;
                }
            }
        }

        return TRUE;
    }
    else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\pdmcs\dompdu.c ===
/* (C) 1997-1999 Microsoft Corp.
 *
 * file   : DomPDU.c
 * author : Erik Mavrinac
 *
 * description: Encode/decode functions for MCS domain PDUs. Domain PDUs are
 *   encoded with ASN.1 packed encoding rules (PER). Included in this file
 *   are local functions to PER-decode and -encode various types used in MCS
 *   PDUs. Note that this implementation follows closely the T.122/T.125 LITE
 *   specification published by the IMTC, reducing the number of fully-
 *   implemented code paths and providing default behavior for unimplemented
 *   functions.
 *
 * NOTE: Bit numbers used in comments are decoded as follows:
 *
 *   Byte:   0101 1001 ( = 0x59)
 *   Bit:    7654 3210
 *
 * History:
 * 11-Aug-97   jparsons    Set byte counts for outbufs.
 */

#include "precomp.h"
#pragma hdrstop

#include <MCSImpl.h>
#include "domain.h"

/*
 * Prototypes for unpacking functions, defined across the indicated files.
 */

// Defined below.
BOOLEAN __fastcall HandlePlumbDomainInd(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandleErectDomainReq(PDomain, BYTE *, unsigned, unsigned *);

// Defined in MergePDU.c.
BOOLEAN __fastcall HandleMergeChannelsReq(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandleMergeChannelsCon(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandlePurgeChannelsInd(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandleMergeTokensReq(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandleMergeTokensCon(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandlePurgeTokensInd(PDomain, BYTE *, unsigned, unsigned *);

// Defined below.
BOOLEAN __fastcall HandleDisconnectProviderUlt(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandleRejectMCSPDUUlt(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandleAttachUserReq(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandleAttachUserCon(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandleDetachUserReq(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandleDetachUserInd(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandleChannelJoinReq(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandleChannelJoinCon(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandleChannelLeaveReq(PDomain, BYTE *, unsigned, unsigned *);

// Defined in CnvChPDU.c.
BOOLEAN __fastcall HandleChannelConveneReq(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandleChannelConveneCon(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandleChannelDisbandReq(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandleChannelDisbandInd(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandleChannelAdmitReq(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandleChannelAdmitInd(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandleChannelExpelReq(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandleChannelExpelInd(PDomain, BYTE *, unsigned, unsigned *);

// Defined below (prototype in MCSImpl.h for visibility in Decode.c).
//BOOLEAN __fastcall HandleAllSendDataPDUs(PDomain, BYTE *, unsigned, unsigned *);

// Defined in TokenPDU.c.
BOOLEAN __fastcall HandleTokenGrabReq(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandleTokenGrabCon(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandleTokenInhibitReq(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandleTokenInhibitCon(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandleTokenGiveReq(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandleTokenGiveInd(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandleTokenGiveRes(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandleTokenGiveCon(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandleTokenPleaseReq(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandleTokenPleaseInd(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandleTokenReleaseReq(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandleTokenReleaseCon(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandleTokenTestReq(PDomain, BYTE *, unsigned, unsigned *);
BOOLEAN __fastcall HandleTokenTestCon(PDomain, BYTE *, unsigned, unsigned *);



/*
 * These are listed in the 0-based enumeration order specified in the T.125
 *   spec. Decode the 6-bit PER encoded PDU type enumeration bits and cast to
 *   an index into this table to get the info.
 */

const MCSPDUInfo DomainPDUTable[] =
{
    // 0
    StrOnDbg("Plumb Domain Indication",       NULL  /* HandlePlumbDomainInd */),
    StrOnDbg("Erect Domain Request",          HandleErectDomainReq),
    StrOnDbg("Merge Channels Request",        NULL  /* HandleMergeChannelsReq */),
    StrOnDbg("Merge Channels Confirm",        NULL  /* HandleMergeChannelsCon */),
    StrOnDbg("Purge Channels Indication",     NULL  /* HandlePurgeChannelsInd */),

    // 5
    StrOnDbg("Merge Tokens Request",          NULL  /* HandleMergeTokensReq */),
    StrOnDbg("Merge Tokens Confirm",          NULL  /* HandleMergeTokensCon */),
    StrOnDbg("Purge Tokens Indication",       NULL  /* HandlePurgeTokensInd */),
    StrOnDbg("Disconnect Provider Ultimatum", HandleDisconnectProviderUlt),
    StrOnDbg("Reject MCS PDU Ultimatum",      NULL  /*HandleRejectMCSPDUUlt */),

    // 10
    StrOnDbg("Attach User Request",           HandleAttachUserReq),
    StrOnDbg("Attach User Confirm",           NULL  /* HandleAttachUserCon */),
    StrOnDbg("Detach User Request",           NULL  /* HandleDetachUserReq */),
    StrOnDbg("Detach User Indication",        NULL  /* HandleDetachUserInd */),
    StrOnDbg("Channel Join Request",          HandleChannelJoinReq),

    // 15
    StrOnDbg("Channel Join Confirm",          NULL  /* HandleChannelJoinCon */),
    StrOnDbg("Channel Leave Request",         NULL  /* HandleChannelLeaveReq */),
    StrOnDbg("Channel Convene Request",       NULL  /* HandleChannelConveneReq */),
    StrOnDbg("Channel Convene Confirm",       NULL  /* HandleChannelConveneCon */),
    StrOnDbg("Channel Disband Request",       NULL  /* HandleChannelDisbandReq */),

    // 20
    StrOnDbg("Channel Disband Indication",    NULL  /* HandleChannelDisbandInd */),
    StrOnDbg("Channel Admit Request",         NULL  /* HandleChannelAdmitReq */),
    StrOnDbg("Channel Admit Indication",      NULL  /* HandleChannelAdmitInd */),
    StrOnDbg("Channel Expel Request",         NULL  /* HandleChannelExpelReq */),
    StrOnDbg("Channel Expel Indication",      NULL  /* HandleChannelExpelInd */),

    // 25
    StrOnDbg("Send Data Request",             HandleAllSendDataPDUs),
    StrOnDbg("Send Data Indication",          HandleAllSendDataPDUs),
    StrOnDbg("Uniform Send Data Request",     HandleAllSendDataPDUs),
    StrOnDbg("Uniform Send Data Indication",  HandleAllSendDataPDUs),
    StrOnDbg("Token Grab Request",            NULL  /* HandleTokenGrabReq */),

    // 30
    StrOnDbg("Token Grab Confirm",            NULL  /* HandleTokenGrabCon */),
    StrOnDbg("Token Inhibit Request",         NULL  /* HandleTokenInhibitReq */),
    StrOnDbg("Token Inhibit Confirm",         NULL  /* HandleTokenInhibitCon */),
    StrOnDbg("Token Give Request",            NULL  /* HandleTokenGiveReq */),
    StrOnDbg("Token Give Indication",         NULL  /* HandleTokenGiveInd */),

    // 35
    StrOnDbg("Token Give Response",           NULL  /* HandleTokenGiveRes */),
    StrOnDbg("Token Give Confirm",            NULL  /* HandleTokenGiveCon */),
    StrOnDbg("Token Please Request",          NULL  /* HandleTokenPleaseReq */),
    StrOnDbg("Token Please Indication",       NULL  /* HandleTokenPleaseInd */),
    StrOnDbg("Token Release Request",         NULL  /* HandleTokenReleaseReq */),

    // 40
    StrOnDbg("Token Release Confirm",         NULL  /* HandleTokenReleaseCon */),
    StrOnDbg("Token Test Request",            NULL  /* HandleTokenTestReq */),
    StrOnDbg("Token Test Confirm",            NULL  /* HandleTokenTestCon */)
};



/*
 * Returns the number of bytes total that will be used to encode this length.
 */

int GetTotalLengthDeterminantEncodingSize(int Length) {
    int N16KBlocks;

    if (Length <= 127) return 1;
    if (Length <= 16383) return 2;

    N16KBlocks = Length / 16384;
    if (N16KBlocks > 4) N16KBlocks = 4;
    
    // 1 byte for # 16K blocks up to 4, then remainder encoded separately.
    return 1 + GetTotalLengthDeterminantEncodingSize(Length - N16KBlocks *
            16384);
}


/*
 * Encodes a length determinant.
 * Note that bit references here are in the range 7..0 where 7 is the high bit.
 *   The ASN.1 spec uses 8..1.
 */

void __fastcall EncodeLengthDeterminantPER(
        BYTE     *pBuffer,   // [IN], where to encode.
        unsigned Length,   // [IN], length number to encode.
        unsigned *pLengthEncoded,  // [OUT], number of bytes that were encoded.
        BOOLEAN  *pbLarge,  // [OUT] TRUE if more encoded blocks are needed to encode this length.
        unsigned *pNBytesConsumed)  // [OUT] Count of bytes consumed in encoding.
{
    *pbLarge = FALSE;
    *pLengthEncoded = Length;
    *pNBytesConsumed = 1;

    if (Length <= 0x7F) {
        // <= 127 means encode in lower 7 bits of first byte, so that bit 7
        //   is zero.
        *pBuffer = (BYTE)Length;
    }
    else if (Length <= 16383) {
        // Set bit 7 but not bit 6, encode length in last 6 bits
        //   of 1st byte and entire 2nd byte (14 bits total).
        PutByteswappedShort(pBuffer, (Length | 0x8000));
        *pNBytesConsumed = 2;
    }
    else {
        // Set bits 7 and 6, encode up to four blocks of 16K (16384) into
        //   one byte, pass back that block is large for future coding.
        int N16KBlocks = Length / 16384;

        // We never expect more than 64K of data owing to X.224 limits.
        ASSERT(N16KBlocks <= 4);

        if (N16KBlocks > 4) N16KBlocks = 4;
        *pBuffer = N16KBlocks | 0xC0;
        *pLengthEncoded = N16KBlocks * 16384;
        *pbLarge = TRUE;
    }
}



/*
 * Handler functions
 */



#ifdef MCS_Future
/*
 * PDU 0
 *
 *   PDin ::= [APPLICATION 0] IMPLICIT SEQUENCE {
 *       heightLimit INTEGER (0..MAX)
 *   }
 *
 * This PDU is sent from the top provider downward when a new node is added
 *   to the domain. It is intended to ferret out loops in the domain, as well
 *   as enforce the negotiated maximum domain height.
 */

// pBuffer should point to the place where the X.224 header will start. Total
//   size specified by PDinPDUSize.
void CreatePlumbDomainInd(
        unsigned short HeightLimit,
        BYTE           *pBuffer)
{
    // Set up first byte with the type.
    pBuffer[X224_DataHeaderSize] = MCS_PLUMB_DOMAIN_INDICATION_ENUM << 2;

    // Add HeightLimit.
    PutByteswappedShort(pBuffer + X224_DataHeaderSize + 1, HeightLimit);

    // Set up X224 header based on the final size of the packet.
    CreateX224DataHeader(pBuffer, PDinBaseSize, TRUE);
}



BOOLEAN __fastcall HandlePlumbDomainInd(
        PDomain  pDomain,
        BYTE     *Frame,
        unsigned BytesLeft,
        unsigned *pNBytesConsumed)
{
    if (BytesLeft < PDinBaseSize)
        return FALSE;

#if 0
    // Data unpacking code, not used right now since we should not receive this PDU.
    int HeightLimit;

    // Get HeightLimit.
    HeightLimit = (int)GetByteswappedShort(Frame + 1);
#endif

    if (pDomain->bTopProvider) {
        ErrOut(pDomain->pContext, "Plumb-domain indication PDU received; "
                "we are top provider, this should never happen, rejecting");
        ReturnRejectPDU(pDomain, Diag_ForbiddenPDUUpward, Frame, PDinBaseSize);
    }
    else {
        ErrOut(pDomain->pContext, "Plumb-domain indication PDU received, "
                "not supported");
        ASSERT(FALSE);
        //MCS FUTURE: Unpack, check if height limit is zero. If so, we need
        //   to disconnect all providers lower than us, since this means
        //   we have reached the maximum allowable depth in the domain.
    }

    // Skip the bytes received no matter what.
    *pNBytesConsumed = PDinBaseSize;
    return TRUE;
}
#endif  // MCS_Future



/*
 * PDU 1
 *
 *   EDrq ::= [APPLICATION 1] IMPLICIT SEQUENCE {
 *       subHeight   INTEGER (0..MAX)
 *       subInterval INTEGER (0..MAX)
 *   }
 *
 * This PDU is sent upwards by a lower node to its upward connection when
 *   either its height in the domain changes (which occurs only when
 *   domains are merged) or its requirements for throughput enforcement
 *   change.
 * Though this PDU may be sent by a lower node upon completion of a
 *   domain connection, its information is unneeded for this implementation.
 */

BOOLEAN __fastcall HandleErectDomainReq(
        PDomain  pDomain,
        BYTE     *Frame,
        unsigned BytesLeft,
        unsigned *pNBytesConsumed)
{
    if (BytesLeft < EDrqBaseSize)
        return FALSE;

    if (pDomain->bTopProvider) {
        // We don't unpack the PDU, just ignore for this implementation.
        TraceOut(pDomain->pContext, "Erect-domain request PDU received, ignored");

#if 0
        // PDU unpacking code, unneeded for the current implementation.
        int SubHeight, SubInterval;

        // Get parameters.
        SubHeight = (int)GetByteswappedShort(Frame + 1);
        SubInterval = (int)GetByteswappedShort(Frame + 3);

        // Actions at this point would be to update the internal database
        //   of subordinate nodes with the new information and, possibly,
        //   pass the PDU upward again (though the latter is not well
        //   specified in the T.125 spec).
#endif

    }
    else {
        ErrOut(pDomain->pContext, "Erect-domain request PDU received, "
                "not supported");
        ASSERT(FALSE);
        // MCS FUTURE: Forward PDU to upward connection.
    }

    // Skip the bytes for this PDU no matter what.
    *pNBytesConsumed = EDrqBaseSize;
    return TRUE;
}



/*
 * PDU 8
 *
 *   DPum ::= [APPLICATION 8] IMPLICIT SEQUENCE {
 *       reason Reason
 *   }
 *
 * This PDU is sent upward or downward on a connection when it is about
 *   to be destroyed. There is no reply to this PDU; it simply means a node
 *   is going away, irrevocably.
 */

// pBuffer points to where the X.224 header will start. Total size is given
//   in DPumPDUSize.
void CreateDisconnectProviderUlt(int Reason, BYTE *pBuffer)
{
    // Set up first byte with the type.
    pBuffer[X224_DataHeaderSize] = MCS_DISCONNECT_PROVIDER_ULTIMATUM_ENUM << 2;

    // Add Reason to first and second bytes.
    pBuffer[X224_DataHeaderSize + 1] = 0;
    Put3BitFieldAtBit1(pBuffer + X224_DataHeaderSize, Reason);

    // Set up X224 header based on the final size of the packet.
    CreateX224DataHeader(pBuffer, DPumBaseSize, TRUE);
}



BOOLEAN __fastcall HandleDisconnectProviderUlt(
        PDomain  pDomain,
        BYTE     *Frame,
        unsigned BytesLeft,
        unsigned *pNBytesConsumed)
{
    NTSTATUS Status;
    DisconnectProviderIndicationIoctl DPin;

    if (BytesLeft < DPumBaseSize)
        return FALSE;
    *pNBytesConsumed = DPumBaseSize;

    TraceOut(pDomain->pContext, "Received DPum PDU");

    // If we already received a DPum or X.224 disconnect, do not send the
    // indications upward.
    if (pDomain->State == State_Disconnected) {
        ErrOut(pDomain->pContext, "Received an extra DPum PDU, ignoring");
        return TRUE;
    }

    // We do not check the connection state other than disconnected -- it
    //   is a small client bug that it will send a DPum no matter if
    //   we've connected yet.
    pDomain->State = State_Disconnected;

    // Begin filling out disconnect-provider indication for the node
    //   controller.
    DPin.Header.hUser = NULL;  // Node controller.
    DPin.Header.Type = MCS_DISCONNECT_PROVIDER_INDICATION;
    DPin.hConn = NULL;

    // Reason is a 3-bit field starting at bit 1 of the 1st byte.
    DPin.Reason = (int)Get3BitFieldAtBit1(Frame);

    // Disconnect remote users only.
    DisconnectProvider(pDomain, FALSE, DPin.Reason);
    pDomain->bEndConnectionPacketReceived = TRUE;

    if (!pDomain->bChannelBound || !pDomain->bT120StartReceived) {
        if (!pDomain->bChannelBound)
            TraceOut(pDomain->pContext, "HandleDisconnProvUlt(): Cannot "
                    "send DISCONNECT_PROV_IND to user mode, "
                    "QueryVirtBindings not received or server-side "
                    "disconnect occurred");
        else
            TraceOut(pDomain->pContext, "HandleDisconnProvUlt(): Cannot "
                    "send DISCONN_PROV_IND to user mode, T120_START not "
                    "received");

        pDomain->bDPumReceivedNotInput = TRUE;
        pDomain->DelayedDPumReason = DPin.Reason;
    }
    else {
        //
        // Let TD know that the comming disconnection is expected
        //
        ICA_STACK_BROKENREASON brkReason;
        SD_IOCTL SdIoctl;
        brkReason.BrokenReason = TD_USER_BROKENREASON_TERMINATING;

        //
        // Send an IOCTL down to notify that this is an expected
        // disconnection otherwise the broken reason would
        // eventually make it's way back to termsrv as
        // 'BrokenReason_Unexpected' and this causes problems
        // e.g see whistler bug 17714
        //
        SdIoctl.IoControlCode = IOCTL_ICA_STACK_SET_BROKENREASON;

        SdIoctl.InputBuffer = &brkReason;
        SdIoctl.InputBufferLength = sizeof(brkReason);
        SdIoctl.OutputBuffer = NULL;
        SdIoctl.OutputBufferLength = 0;

        Status = IcaCallNextDriver(pDomain->pContext,
                    SD$IOCTL,
                    &SdIoctl);
        if (!NT_SUCCESS(Status)) {
            WarnOut1(pDomain->pContext, "HandleDisconnProvUlt(): "
                    "Could not send broken reason notifcation to next driver"
                    "status=%X, ignoring error", Status);
        }

        // Send the DPin to the node controller channel.
        TraceOut(pDomain->pContext, "HandleDisconnProvUlt(): Sending "
                "DISCONNECT_PROV_IND upward");
        Status = IcaChannelInput(pDomain->pContext, Channel_Virtual,
                Virtual_T120ChannelNum, NULL, (BYTE *)&DPin, sizeof(DPin));
        if (!NT_SUCCESS(Status)) {
            // We ignore the error -- if the stack is coming down, the link
            //   may have been broken, so this is not a major concern.
            WarnOut1(pDomain->pContext, "HandleDisconnProvUlt(): "
                    "Could not send notification to node controller, "
                    "status=%X, ignoring error", Status);
        }
    }
    
    return TRUE;
}



/*
 * PDU 9
 *
 *   RJum ::= [APPLICATION 9] IMPLICIT SEQUENCE {
 *       diagnostic    Diagnostic,
 *       initialOctets OCTET STRING
 *   }
 */

NTSTATUS ReturnRejectPDU(
        PDomain  pDomain,
        int      Diagnostic,
        BYTE     *BadPDUData,
        unsigned BadPDUSize)
{
    POUTBUF pOutBuf;
    NTSTATUS Status;
    unsigned Size;

    // Determine the largest chunk that will fit in a maximum-sized PDU.
    Size = RJumPDUSize(BadPDUSize);
    if (Size > pDomain->DomParams.MaxPDUSize)
        BadPDUSize = pDomain->DomParams.MaxPDUSize;

    // Alloc buffer for return. Must be constrained by the largest size of
    //   return PDU.
    Status = IcaBufferAlloc(pDomain->pContext, FALSE, TRUE,
            RJumPDUSize(BadPDUSize), NULL, &pOutBuf);
    if (Status != STATUS_SUCCESS) {
        ErrOut(pDomain->pContext, "Could not allocate an OutBuf for an RJum PDU "
                "send, send ignored");
        // No asserts, if we cannot send this PDU it's like the incoming PDU
        //   was ignored.
        return Status;
    }

    CreateRejectMCSPDUUlt(Diagnostic, BadPDUData, BadPDUSize, pOutBuf->pBuffer);
    pOutBuf->ByteCount = RJumPDUSize(BadPDUSize);

    // MCS FUTURE: This would have to change to make sure we send to the
    //   right connection instead of the implicit downward connection.

    Status = SendOutBuf(pDomain, pOutBuf);
    if (!NT_SUCCESS(Status))
        ErrOut(pDomain->pContext, "Could not send a RJum PDU, send ignored");

    return Status;
}



// pBuffer points to the beginning of the space where the X.224 data header
//   will start. Total size is given in macro RJumPDUSize().
void CreateRejectMCSPDUUlt(
        int      Diagnostic,
        BYTE     *BadPDUData,
        unsigned BadPDUSize,
        BYTE     *pBuffer)
{
    BOOLEAN bLarge;
    unsigned NBytesConsumed, EncodedLength;

    // Set up first byte with the type.
    pBuffer[X224_DataHeaderSize] = MCS_REJECT_ULTIMATUM_ENUM << 2;

    // Add Diagnostic to first and second bytes.
    pBuffer[X224_DataHeaderSize + 1] = 0;
    Put4BitFieldAtBit1(pBuffer + X224_DataHeaderSize, Diagnostic);

    // Encode the PDU size.
    EncodeLengthDeterminantPER(
            pBuffer + X224_DataHeaderSize + 2,
            BadPDUSize,
            &EncodedLength,
            &bLarge,
            &NBytesConsumed);

    // We won't handle greater than 16383 bytes of encoded length right now.
    ASSERT(!bLarge);

    // Copy offending data into the output PDU.
    RtlCopyMemory(pBuffer + X224_DataHeaderSize + 2 + NBytesConsumed,
            BadPDUData, BadPDUSize);

    // Set up X224 header based on the final size of the packet.
    CreateX224DataHeader(pBuffer, RJumBaseSize(BadPDUSize), TRUE);
}




BOOLEAN __fastcall HandleRejectMCSPDUUlt(
        PDomain  pDomain,
        BYTE     *Frame,
        unsigned BytesLeft,
        unsigned *pNBytesConsumed)
{
    BOOLEAN bLarge;
    unsigned Diagnostic, DataLength, NBytesConsumed;

    // There must at least be Diagnostic field.
    if (BytesLeft < 2)
        return FALSE;

    // Get Diagnostic code -- 4-bit enumeration bitfield, starting at bit 1 of
    //   byte 1, shifted to make a code starting at 0.
    Diagnostic = Get4BitFieldAtBit1(Frame);

    // Get DataLength. This is a special case requiring handling a length
    //   determinant.
    if (!DecodeLengthDeterminantPER(Frame + 2, BytesLeft - 2, &bLarge,
            &DataLength, &NBytesConsumed))
        return FALSE;

    // We are not handling more than 16383 bytes encoded length right now.
    ASSERT(!bLarge);

    // Raw data is at Frame + 2 + NBytesConsumed.

    if (BytesLeft < (2 + NBytesConsumed + DataLength))
        return FALSE;

    ErrOut1(pDomain->pContext, "Received reject PDU ultimatum, type byte is 0x%X",
            Frame[2 + NBytesConsumed + X224_DataHeaderSize]);

    *pNBytesConsumed = 2 + NBytesConsumed + DataLength;
    return TRUE;
}

/*
 * PDU 10
 *
 *   AUrq ::= [APPLICATION 10] IMPLICIT SEQUENCE {
 *   }
 */

BOOLEAN __fastcall HandleAttachUserReq(
        PDomain  pDomain,
        BYTE     *Frame,
        unsigned BytesLeft,
        unsigned *pNBytesConsumed)
{
    TraceOut(pDomain->pContext, "Received an AttachUserReq PDU");
    
    // We don't need to do any decoding here -- this is a null packet beyond
    //   the initial PDU type byte.
    *pNBytesConsumed = AUrqBaseSize;

    if (pDomain->bTopProvider) {
        POUTBUF pOutBuf;
        BOOLEAN bCompleted;
        unsigned MaxSendSize;
        NTSTATUS Status;
        MCSError MCSErr;
        UserAttachment *pUA;

        // Alloc buffer for largest size of return PDU.
        // This allocation is vital to stack communication and must succeed.
        do {
            Status = IcaBufferAlloc(pDomain->pContext, FALSE, TRUE,
                    AUcfPDUSize(TRUE), NULL, &pOutBuf);
            if (Status != STATUS_SUCCESS)
                ErrOut(pDomain->pContext, "Could not allocate an OutBuf for an "
                        "AUcf PDU send, retrying");
        } while (Status != STATUS_SUCCESS);

        // Call the kernel mode API. We will munge extra info below as needed.
        MCSErr = MCSAttachUserRequest(pDomain, NULL, NULL, NULL, &pUA,
                &MaxSendSize, &bCompleted);
        if (MCSErr == MCS_NO_ERROR) {
            ASSERT(bCompleted);

            CreateAttachUserCon(RESULT_SUCCESSFUL, TRUE, pUA->UserID,
                    pOutBuf->pBuffer);
            pOutBuf->ByteCount = AUcfPDUSize(TRUE);

            // Change the UA to show that user is nonlocal.
            pUA->bLocal = FALSE;
        }
        else {
            CreateAttachUserCon(RESULT_UNSPECIFIED_FAILURE, FALSE,
                    NULL_ChannelID, pOutBuf->pBuffer);
            pOutBuf->ByteCount = AUcfPDUSize(FALSE);
        }

        Status = SendOutBuf(pDomain, pOutBuf);
        if (!NT_SUCCESS(Status)) {
            // This should only occur if the stack is going down; the
            //   requester will not ever receive a reply.
            ErrOut(pDomain->pContext, "Problem sending AUcf PDU to TD");
            // Remove the user from the user list, quietly.
            SListRemove(&pDomain->UserAttachmentList, (UINT_PTR)pUA, &pUA);
            ASSERT(FALSE);
            return TRUE;
        }
    }
    else {
        ErrOut(pDomain->pContext, "Attach-user request PDU received, "
                "not supported");
        ASSERT(FALSE);
        // MCS FUTURE: Forward PDU to upward connection.
    }

    return TRUE;
}



/*
 * PDU 11
 *
 *   AUcf ::= [APPLICATION 11] IMPLICIT SEQUENCE {
 *       result    Result,
 *       initiator UserId OPTIONAL
 *   }
 */

// pBuffer points to beginning of space where X.224 data header will start.
// Total size needed given by macro AUcfPDUSize().
void CreateAttachUserCon(
        int      Result,
        BOOLEAN  bInitiatorPresent,
        UserID   Initiator,
        BYTE     *pBuffer)
{
    // Set up first byte with the type and whether Initiator is present.
    pBuffer[X224_DataHeaderSize] = MCS_ATTACH_USER_CONFIRM_ENUM << 2;
    if (bInitiatorPresent) pBuffer[X224_DataHeaderSize] |= 0x02;

    // Add Result to first and second bytes.
    pBuffer[X224_DataHeaderSize + 1] = 0;
    Put4BitFieldAtBit0(pBuffer + X224_DataHeaderSize, Result);

    // Add Initiator, if present.
    if (bInitiatorPresent)
        PutUserID(pBuffer + X224_DataHeaderSize + 2, Initiator);

    // Set up X224 header based on the final size of the packet.
    CreateX224DataHeader(pBuffer, AUcfBaseSize(bInitiatorPresent), TRUE);
}



#ifdef MCS_Future
BOOLEAN __fastcall HandleAttachUserCon(
        PDomain  pDomain,
        BYTE     *Frame,
        unsigned BytesLeft,
        unsigned *pNBytesConsumed)
{
    BOOLEAN bInitiatorPresent;
    unsigned Size;

    // At least enough bytes to get to bInitiatorPresent bit and Result.
    if (BytesLeft < 2)
        return FALSE;

    // Bit 1 in byte 1 is a flag for whether the initiator UserID is present
    //   (it is OPTIONAL in the ASN.1 source for this PDU).
    bInitiatorPresent = (*Frame & 0x02);

    // We did not receive the whole frame.
    Size = AUcfBaseSize(bInitiatorPresent);
    if (BytesLeft < Size)
        return FALSE;

    if (pDomain->bTopProvider) {
        ErrOut(pDomain->pContext, "Attach-user confirm PDU received; "
                "we are top provider, this should never happen, rejecting");
        ReturnRejectPDU(pDomain, Diag_ForbiddenPDUUpward, Frame, Size);
    }
    else {
        ErrOut(pDomain->pContext, "Attach-user confirm PDU received, "
                "not supported");
        ASSERT(FALSE);

#if 0
        // Decode code not used right now.
        int    Result;
        UserID InitiatorID;

        // Result, starting at bit 0 of the 1st byte.
        Result = Get4BitFieldAtBit0(Frame);

        // Get Initiator.
        if (bUserIDPresent) UserID = GetUserID(Frame + 2);

        //MCS FUTURE: Actions here are to state-transition past a waiting-
        //  for-AU confirm state, check the Result code, store the Initiator
        //  userID as our new UserID.
#endif

    }

    // At least skip the bytes in the PDU.
    *pNBytesConsumed = Size;
    return TRUE;
}
#endif  // MCS_Future



/*
 * PDU 12
 *
 *   DUrq ::= [APPLICATION 12] IMPLICIT SEQUENCE {
 *       reason  Reason,
 *       userIds SET OF UserId
 *   }
 */

BOOLEAN __fastcall HandleDetachUserReq(
        PDomain  pDomain,
        BYTE     *Frame,
        unsigned BytesLeft,
        unsigned *pNBytesConsumed)
{
    UserID CurUserID;
    BOOLEAN bLarge, bFound;
    unsigned i, Reason, NUsers, NBytesConsumed, Size;
    NTSTATUS Status;
    UserHandle hUser;
    UserAttachment *pUA;

    // Must at least have Reason bytes.
    if (BytesLeft < 2)
        return FALSE;

    // Get NUsers. This is a special case requiring handling a length
    //   determinant.
    if (!DecodeLengthDeterminantPER(Frame + 2, BytesLeft - 2, &bLarge,
            &NUsers, &NBytesConsumed))
        return FALSE;

    // We are not handling more than 16383 detach users in a PDU.
    ASSERT(!bLarge);

    Size = DUrqBaseSize(NUsers);
    if (BytesLeft < Size)
        return FALSE;

    if (pDomain->bTopProvider) {
        MCSError MCSErr;
        
        // Get Reason.
        Reason = Get3BitFieldAtBit1(Frame);

        // User IDs are a byteswapped word array starting at Frame + 2 +
        //   NBytesConsumed.

        // Iterate all listed users, find in attachment list, remove.
        for (i = 0; i < NUsers; i++) {
            CurUserID = GetUserID(Frame + 2 + NBytesConsumed +
                    sizeof(short) * i);

            // We do not have a list indexed by UserID, so we have to do the
            //   search here.
            bFound = FALSE;
            SListResetIteration(&pDomain->UserAttachmentList);
            while (SListIterate(&pDomain->UserAttachmentList,
                    (UINT_PTR *)&hUser, &pUA)) {
                if (pUA->UserID == CurUserID) {
                    bFound = TRUE;
                    break;
                }
            }
            if (bFound)
                MCSErr = DetachUser(pDomain, hUser, REASON_USER_REQUESTED,
                        FALSE);
            else
                ErrOut(pDomain->pContext, "A UserID received in a detach-user "
                        "request PDU is not present");
        }
    }
    else {
        ErrOut(pDomain->pContext, "Detach-user request PDU received, "
                "not supported");
        ASSERT(FALSE);
        // MCS FUTURE: Forward PDU to upward connection.
    }

    *pNBytesConsumed = Size;
    return TRUE;
}



/*
 * PDU 13
 *
 *   DUin ::= [APPLICATION 13] IMPLICIT SEQUENCE {
 *       reason  Reason,
 *       userIds SET OF UserId
 *   }
 */

// pBuffer is a pointer to the beginning of where the X.224 data header
//   will be. Required encoding size for the whole PDU is given in
//   macro DUinPDUSize().
void CreateDetachUserInd(
        MCSReason Reason,    // [IN] Reason code.
        int       NUserIDs,  // [IN] # of user IDs to encode.
        UserID    *UserIDs,  // [IN] Array of UserIDs.
        BYTE      *pBuffer)  // [IN] Pointer to buffer in which to encode.
{
    int i, EncodedLength, NBytesConsumed;
    BOOLEAN bLarge;

    // Set up first byte with the type.
    pBuffer[X224_DataHeaderSize] = MCS_DETACH_USER_INDICATION_ENUM << 2;

    // Add Reason to first and second bytes.
    pBuffer[X224_DataHeaderSize + 1] = 0;
    Put3BitFieldAtBit1(pBuffer + X224_DataHeaderSize, Reason);

    // Encode the number of User IDs.
    EncodeLengthDeterminantPER(
            pBuffer + X224_DataHeaderSize + 2,
            NUserIDs,
            &EncodedLength,
            &bLarge,
            &NBytesConsumed);

    // We are not handling more than 16383 UserIDs.
    ASSERT(!bLarge);

    // Encode user ID array.
    for (i = 0; i < NUserIDs; i++)
        PutUserID(pBuffer + X224_DataHeaderSize + 2 + NBytesConsumed
                + sizeof(short) * i, UserIDs[i]);

    // Set up X224 header based on the final size of the packet.
    CreateX224DataHeader(pBuffer, DUinBaseSize(NUserIDs), TRUE);
}



#ifdef MCS_Future
BOOLEAN __fastcall HandleDetachUserInd(
        PDomain  pDomain,
        BYTE     *Frame,
        unsigned BytesLeft,
        unsigned *pNBytesConsumed)
{
    BOOLEAN bLarge;
    unsigned NUsers, NBytesConsumed, Size;

    // Must at least have Reason bytes.
    if (BytesLeft < 2) return FALSE;  // Only cover Reason bytes.

    // Get NUsers. This is a special case requiring handling a length
    //   determinant.
    if (!DecodeLengthDeterminantPER(Frame + 2, BytesLeft - 2, &bLarge,
            &NUsers, &NBytesConsumed))
        return FALSE;

    // We are not handling more than 16383 detached users in a PDU.
    ASSERT(!bLarge);

    Size = DUinBaseSize(NUsers);
    if (BytesLeft < Size)
        return FALSE;

    if (pDomain->bTopProvider) {
        ErrOut(pDomain->pContext, "Detach-user indication PDU received; "
                "we are top provider, this should never happen, rejecting");
        ReturnRejectPDU(pDomain, Diag_ForbiddenPDUUpward, Frame, Size);
    }
    else {
        ErrOut(pDomain->pContext, "Detach-user indication PDU received, "
                "not supported");
        ASSERT(FALSE);

#if 0
        // This is decode code, which is not needed because we should not
        //   receive this PDU.
        int Reason;

        // Get Reason.
        Reason = Get3BitFieldAtBit1(Frame);

        // User IDs are a byteswapped word array starting at Frame + 2 +
        //   NBytesConsumed.
#endif

    }

    *pNBytesConsumed = Size;
    return TRUE;
}
#endif  // MCS_Future



/*
 * PDU 14
 *
 *   CJrq ::= [APPLICATION 14] IMPLICIT SEQUENCE {
 *       initiator UserId,
 *       channelId ChannelId
 *   }
 */

BOOLEAN __fastcall HandleChannelJoinReq(
        PDomain  pDomain,
        BYTE     *Frame,
        unsigned BytesLeft,
        unsigned *pNBytesConsumed)
{   
    TraceOut(pDomain->pContext, "Received a ChannelJoinReq PDU");

    
    if (BytesLeft < CJrqBaseSize)
        return FALSE;

    *pNBytesConsumed = CJrqBaseSize;

    if (pDomain->bTopProvider) {
        UserID Initiator;
        POUTBUF pOutBuf;
        BOOLEAN bFound, bCompleted;
        MCSError MCSErr;
        NTSTATUS Status;
        MCSResult Result;
        ChannelID ChannelID;
        ChannelHandle hChannel;
        UserAttachment *pUA;
        
        Initiator = GetUserID(Frame + 1);
        ChannelID = GetChannelID(Frame + 3);

        // We do not have a list indexed by UserID, so we have to do the
        //   search here.
        bFound = FALSE;
        SListResetIteration(&pDomain->UserAttachmentList);
        while (SListIterate(&pDomain->UserAttachmentList,
                (UINT_PTR *)&pUA, &pUA)) {
            if (pUA->UserID == Initiator) {
                bFound = TRUE;
                break;
            }
        }
        if (bFound) {
            // Call kernel-mode API.
            MCSErr = MCSChannelJoinRequest(pUA, ChannelID, &hChannel,
                    &bCompleted);
            if (MCSErr == MCS_NO_ERROR) {
                ASSERT(bCompleted);
                Result = RESULT_SUCCESSFUL;
            }
            else if (MCSErr == MCS_NO_SUCH_USER) {
                Result = RESULT_NO_SUCH_USER;
            }
            else if (MCSErr == MCS_DUPLICATE_CHANNEL) {
                goto EXIT_POINT;
            }
            else {
                Result = RESULT_UNSPECIFIED_FAILURE;
            }
        }
        else {
            ErrOut(pDomain->pContext, "Initiator UserID received in a "
                    "channel-join request PDU is not in user list");
            Result = RESULT_NO_SUCH_USER;
        }

        // Alloc buffer for largest size of return PDU.
        // This allocation is vital to stack communication and must succeed.
        do {
            Status = IcaBufferAlloc(pDomain->pContext, FALSE, TRUE,
                    CJcfPDUSize(TRUE), NULL, &pOutBuf);
            if (Status != STATUS_SUCCESS)
                ErrOut(pDomain->pContext, "Could not allocate an OutBuf for a "
                        "CJcf PDU send, retrying");
        } while (Status != STATUS_SUCCESS);

        if (Result == RESULT_SUCCESSFUL) {
            CreateChannelJoinCon(Result, Initiator, ChannelID,
                    TRUE, ChannelID, pOutBuf->pBuffer);
            pOutBuf->ByteCount = CJcfPDUSize(TRUE) ;
        }
        else {
            CreateChannelJoinCon(Result, Initiator, ChannelID,
                    FALSE, NULL_ChannelID, pOutBuf->pBuffer);
            pOutBuf->ByteCount = CJcfPDUSize(FALSE) ;
        }

        Status = SendOutBuf(pDomain, pOutBuf);
        
        if (!NT_SUCCESS(Status)) {
            // This should only occur if the stack is going down; the
            //   requester will not ever receive a reply.
            ErrOut(pDomain->pContext, "Problem sending CJcf PDU to TD");
            return TRUE;
        }
    }
    else {
        ErrOut(pDomain->pContext, "Channel-join request received, "
                "not supported");
        ASSERT(FALSE);
        // MCS FUTURE: Forward the PDU to the upward connection.
    }
EXIT_POINT:
    return TRUE;  // We don't have user data to which to skip.
}



/*
 * PDU 15
 *
 *   CJcf ::= [APPLICATION 15] IMPLICIT SEQUENCE {
 *       result    Result,
 *       initiator UserId,
 *       requested ChannelId,
 *       channelId ChannelId OPTIONAL
 *   }
 */

// pBuffer points to the beginning of the space where the X.224 data header
//   will start. Total bytes required given by CJcfPDUSize() macro.
void CreateChannelJoinCon(
        int       Result,
        UserID    Initiator,
        ChannelID RequestedChannelID,
        BOOLEAN   bJoinedChannelIDPresent,
        ChannelID JoinedChannelID,
        BYTE      *pBuffer)
{
    // Set up first byte with the type and whether JoinedChannelID is present.
    pBuffer[X224_DataHeaderSize] = MCS_CHANNEL_JOIN_CONFIRM_ENUM << 2;
    if (bJoinedChannelIDPresent) pBuffer[X224_DataHeaderSize] |= 0x02;

    // Add Result to first and second bytes.
    pBuffer[X224_DataHeaderSize + 1] = 0;
    Put4BitFieldAtBit0(pBuffer + X224_DataHeaderSize, Result);

    // Add Initiator, RequestedChannelID.
    PutUserID(pBuffer + X224_DataHeaderSize + 2, Initiator);
    PutChannelID(pBuffer + X224_DataHeaderSize + 4, RequestedChannelID);

    // Add JoinedChannelID, if present.
    if (bJoinedChannelIDPresent)
        PutChannelID(pBuffer + X224_DataHeaderSize + 6, JoinedChannelID);

    // Set up X224 header based on the final size of the packet.
    CreateX224DataHeader(pBuffer, CJcfBaseSize(bJoinedChannelIDPresent), TRUE);
}



#ifdef MCS_Future
BOOLEAN __fastcall HandleChannelJoinCon(
        PDomain  pDomain,
        BYTE     *Frame,
        unsigned BytesLeft,
        unsigned *pNBytesConsumed)
{
    BOOLEAN bJoinedChannelIDPresent;
    unsigned Size;

    // First byte containing the bJoinedChannelIDPresent bit is guaranteed
    //   to be present since it had to be present to decode the PDU type.

    // Bit 1 in 1st byte is a flag for whether the joined ChannelID is present
    //   (it is OPTIONAL in the ASN.1 source for this PDU).
    bJoinedChannelIDPresent = (*Frame & 0x02);

    Size = CJcfBaseSize(bJoinedChannelIDPresent);
    if (BytesLeft < Size)
        return FALSE;

    if (pDomain->bTopProvider) {
        ErrOut(pDomain->pContext, "Channel-join confirm PDU received;"
                "we are top provider, this should never happen, rejecting");
        ReturnRejectPDU(pDomain, Diag_ForbiddenPDUUpward, Frame, Size);
    }
    else {
        ErrOut(pDomain->pContext, "Channel-join confirm PDU received, "
                "not supported");
        ASSERT(FALSE);
        //MCS FUTURE: Decode and handle

#if 0
        /*
         * This is decode code which is not used for now because we always expect
         *   to be top provider.
         */
        int Result;
        UserID Initiator;
        ChannelID RequestedChannelID, JoinedChannelID;

        if (BytesLeft < (6 + (bJoinedChannelPresent ? 2 : 0))) return FALSE;

        Result = Get4BitFieldAtBit0(Frame);
        Initiator = GetUserID(Frame + 2);
        RequestedChannelID = GetChannelID(Frame + 4);
        if (bJoinedChannelIDPresent) JoinedChannelID = GetChannelID(Frame + 6);
#endif

    }

    *pNBytesConsumed = Size;
    return TRUE;
}
#endif  // MCS_Future



/*
 * PDU 16
 *
 *   CLrq ::= [APPLICATION 16] IMPLICIT SEQUENCE {
 *       channelIds SET OF ChannelId
 *   }
 */

BOOLEAN __fastcall HandleChannelLeaveReq(
        PDomain  pDomain,
        BYTE     *Frame,
        unsigned BytesLeft,
        unsigned *pNBytesConsumed)
{
    BOOLEAN bLarge, bChannelRemoved;
    unsigned i, UserID, NChannels, NBytesConsumed, Size;
    NTSTATUS Status;
    ChannelID ChannelID;
    MCSChannel *pMCSChannel;
    UserAttachment *pUA;

    // Get NChannels. This is a special case requiring handling a length
    //   determinant.
    if (!DecodeLengthDeterminantPER(Frame + 1, BytesLeft - 1, &bLarge,
            &NChannels, &NBytesConsumed))
        return FALSE;

    // We are not handling more than 16383 channels to join.
    ASSERT(!bLarge);

    Size = CLrqBaseSize(NChannels);
    if (BytesLeft < Size)
        return FALSE;

    *pNBytesConsumed = Size;

    if (pDomain->bTopProvider) {
        // MCS FUTURE: Be aware that this PDU does not include user
        //   attachments, so if we move to multiple connections per PD this
        //   will have to be differentiated to make sure only users joined
        //   from the connection this arrived on will be removed from the
        //   channel list.

        MCSError MCSErr;
        
        // For each channel listed, remove all nonlocal users.
        for (i = 0; i < NChannels; i++) {
            ChannelID = GetChannelID(Frame + 1 + NBytesConsumed +
                    sizeof(short) * i);

            if (!SListGetByKey(&pDomain->ChannelList, ChannelID,
                    &pMCSChannel)) {
                ErrOut(pDomain->pContext, "A channel specified in a "
                        "channel-leave request PDU does not exist");
                continue;
            }

            // Iterate user list in the channel, check for nonlocal users.
            SListResetIteration(&pMCSChannel->UserList);
            while (SListIterate(&pMCSChannel->UserList, (UINT_PTR *)&pUA,
                    &pUA)) {
                if (!pUA->bLocal) {
                    // Call central code in MCSCore.c.
                    MCSErr = ChannelLeave(pUA, pMCSChannel, &bChannelRemoved);
                                        
                    if (bChannelRemoved)
                        // The MCSChannel beneath us went away, do not continue
                        //   trying to access list data.
                        break;
                }
            }
        }
    }
    else {
        ErrOut(pDomain->pContext, "Channel-leave request received, "
                "not supported");
        ASSERT(FALSE);
        // MCS FUTURE: Forward the PDU to the upward connection.
    }

    return TRUE;  // We don't have user data to which to skip.
}



/*
 * PDUs 25-28
 *
 *   SDrq/SDin/USrq/USin ::= [APPLICATION 25-28] IMPLICIT SEQUENCE {
 *       initiator UserId,
 *       channelId ChannelId,
 *       dataPriority DataPriority,
 *       segmentation Segmentation,
 *       userData     OCTET STRING
 *   }
 */

/*
 * Create function for all SendData PDUs. Prepends header to beginning of
 *   data specified in MCSSendDataRequestIoctl.pData, returns in
 *   pNewDataStart the new beginning of the data, i.e. the beginning of the
 *   PDU.
 * Assumes that enough space has already been allocated before the
 *   start of the user data.
 */

// Does not return indications that ASN.1 segmentation has occurred --
//   requires caller to understand and encode separately any segment
//   data.
void CreateSendDataPDUHeader(
        int          PDUType,  // MCS_SEND_DATA_INDICATION_ENUM, etc.
        UserID       Initiator,
        ChannelID    ChannelID,
        MCSPriority  Priority,
        Segmentation Segmentation,
        BYTE         **ppData,
        unsigned     *pDataLength)
{
    int NBytesConsumed, EncodedLength, PDULength;
    BYTE *pCurData, *pData;
    BOOLEAN bLarge;
    unsigned DataLength;

    // Save original pData and DataLength.
    pData = *ppData;
    DataLength = *pDataLength;
    
    // First get the length determinant. It is a maximum of 2 bytes, so
    //   encode it at (pData-2) and shift it forward if it is smaller.
    EncodeLengthDeterminantPER(
            pData - 2,
            DataLength,
            &EncodedLength,
            &bLarge,
            &NBytesConsumed);
    // We ignore bLarge, EncodedLength, see above comment.

    if (NBytesConsumed == 1)
        *(pData - 1) = *(pData - 2);

    // Set the beginning of the rest of the data (which is 6 bytes).
    pCurData = pData - NBytesConsumed - 6;

    // Set up first byte with the type.
    *pCurData = PDUType << 2;
    pCurData++;

    // Add Initiator, ChannelID.
    PutUserID(pCurData, Initiator);
    PutChannelID(pCurData + 2, ChannelID);
    pCurData += 4;

    // Add DataPriority (2 bits in bits 7 and 6) and Segmentation (2 bits
    //   into bits 5 and 4) into 6th byte. Note that the Segmentation flags
    //   (SEGMENTATION_BEGIN, SEGMENTATION_END) are assumed to be defined
    //   in their exact bit positions corresponding to the positons required
    //   here for encoding.
    *pCurData = (BYTE)(Priority << 6) + (BYTE)Segmentation;

    // Set up X.224 header based on the final size of the packet.
    PDULength = NBytesConsumed + 6 + DataLength;
    pCurData = pData - NBytesConsumed - 6 - X224_DataHeaderSize;
    CreateX224DataHeader(pCurData, PDULength, TRUE);

    *ppData = pCurData;
    *pDataLength = PDULength + X224_DataHeaderSize;
}



/*
 * Handler function for all SendData PDUs.
 */

BOOLEAN __fastcall HandleAllSendDataPDUs(
        PDomain  pDomain,
        BYTE     *Frame,
        unsigned BytesLeft,
        unsigned *pNBytesConsumed)
{
    BYTE *pBuffer;
    UserID SenderID;
    BOOLEAN bLarge, bFound;
    unsigned NBytesConsumed, Size, PDUNum, DataLength;
    UINT_PTR CurUserID;
    NTSTATUS Status;
    ChannelID ChannelID;
    MCSChannel *pMCSChannel;
    UserHandle hUser;
    MCSPriority Priority;
    Segmentation Segmentation;
    UserAttachment *pUA;

//    TraceOut(pDomain->pContext, "Received a SendData PDU");
    
    // MCS FUTURE: We should forward the data upward here, since below we
    //   will modify the encoded buffer for ASN.1 segmentation.

    // Get the PDU number again since this function handles multiple PDUs.
    PDUNum = (*Frame) >> 2;
    ASSERT(PDUNum >= MCS_SEND_DATA_REQUEST_ENUM &&
            PDUNum <= MCS_UNIFORM_SEND_DATA_INDICATION_ENUM);


#if DBG
    // Enforce hierarchical requirements on PDUs -- indications move only
    //   away from the top provider, requests move only toward it.
    // MCS FUTURE: For indications moving toward TP from any downlevel
    //   connection we should send a reject-MCS-PDU back down the link.
    // MCS FUTURE: If we are not TP and a request is coming from the upward
    //   direction send back up rejected.
    // TODO FUTURE: With cross server shadowing we have two top providers
    //   talking to each other.  Need to decide how this is best represented.
    if (pDomain->StackClass == Stack_Primary) {
        if (pDomain->bTopProvider && (PDUNum == MCS_SEND_DATA_INDICATION_ENUM ||
                PDUNum == MCS_UNIFORM_SEND_DATA_INDICATION_ENUM)) {
            ErrOut(pDomain->pContext, "HandleAllSendDataPDUs(): Received a "
                    "(uniform)send-data indication when we are top provider!");
            // Ignore the error.
        }
    }
#endif


    // At least to DataLength should be present.
    if (BytesLeft < 6)
         return FALSE;

    // Get initiator, ChannelID.
    SenderID = GetUserID(Frame + 1);
    ChannelID = GetChannelID(Frame + 3);

    // Get DataPriority, a 2-bit bitfield stored in bits 7 and 6 of byte 6,
    //   shifted right to get a number in range 0..3.
    Priority = ((*(Frame + 5)) & 0xC0) >> 6;

    // Get Segmentation, a 2-bit bitfield stored in bits 5 and 4 of byte 6.
    // Note that the flag values bits defined for SEGMENTATION_BEGIN and
    //   SEGMENTATION_END correspond to these exact bit positions, no further
    //   shifting is required.
    Segmentation = ((*(Frame + 5)) & 0x30);

    // Get DataLength. This is a special case requiring handling a length
    //   determinant. bLarge (meaning ASN.1 segmentation occurred) will be
    //   handled below.
    if (!DecodeLengthDeterminantPER(Frame + 6, BytesLeft - 6, &bLarge,
            &DataLength, &NBytesConsumed))
        return FALSE;

    Size = 6 + NBytesConsumed + DataLength;
    if (BytesLeft < Size)
        return FALSE;

    if (bLarge) {
        // The packet is ASN.1 segmented. This means that there is a second
        //   length determinant embedded in the data buffer. The header
        //   encoded size contained only a multiple of 16K blocks; we
        //   have to get the remainder length determinant and then shift
        //   the remaining data onto the determinant to make a contiguous
        //   block.

        unsigned Remainder, ExtraBytesConsumed;

        if (!DecodeLengthDeterminantPER(Frame + 6 + NBytesConsumed +
                DataLength, BytesLeft - 6 - NBytesConsumed - DataLength,
                &bLarge, &Remainder, &ExtraBytesConsumed))
            return FALSE;

        ASSERT(!bLarge);

        Size += ExtraBytesConsumed + Remainder;
        if (BytesLeft < Size)
            return FALSE;

        RtlMoveMemory(Frame + 6 + NBytesConsumed + DataLength,
                Frame + 6 + NBytesConsumed + DataLength +
                ExtraBytesConsumed, Remainder);

        DataLength += Remainder;
        // Leave NBytesConsumed alone, it's still the size of the first length
        //   determinant.
    }

    // We have received an entire SendData frame.
    *pNBytesConsumed = Size;

    // MCS FUTURE: We do not handle MCS segmentation at all -- do we want to
    //reconstruct here since we're already doing a memcpy()? If so, need to
    //allocate a buffer for this priority and copy.

    if (pDomain->bTopProvider ||
            (!pDomain->bTopProvider && PDUNum != MCS_UNIFORM_SEND_DATA_REQUEST)) {


#if DBG
        // Verify that Initiator exists. We do not have a list indexed by
        //   UserID, so we have to do the search here.
        bFound = FALSE;
        SListResetIteration(&pDomain->UserAttachmentList);
        while (SListIterate(&pDomain->UserAttachmentList, (UINT_PTR *)&hUser,
                &pUA)) {
            if (pUA->UserID == SenderID) {
                bFound = TRUE;
                break;
            }
        }
        if (!bFound && pDomain->bTopProvider) {
            // Not knowing initiator is bad when coming from downlevel,
            //   but okay coming from upward connection since this node may
            //   not have seen the attach-user request pass by.
            // In this case we will signal an error and ignore the send.
            ErrOut2(pDomain->pContext, "%s: Initiator UserID[%lx] received in a "
                    "send-data PDU is not present, ignoring send",
                    pDomain->StackClass == Stack_Shadow ? "Shadow stack" :
                    (pDomain->StackClass == Stack_Passthru ? "Passthru stack" :
                    "Primary stack"), SenderID);
            return TRUE;
        }
#endif


        // Find channel in channel list.
        if (!SListGetByKey(&pDomain->ChannelList, ChannelID, &pMCSChannel)) {
            // Ignore sends on missing channels. This means that no one
            //   has joined the channel. Give a warning only.
            WarnOut1(pDomain->pContext, "ChannelID %d received in a send-data "
                    "PDU does not exist", ChannelID);
            //MCS FUTURE: If we are not top provider, send to upward
            //   connection.
            return TRUE;
        }

        // Send indication to all local attachments.
        SListResetIteration(&pMCSChannel->UserList);
        while (SListIterate(&pMCSChannel->UserList, &CurUserID, &pUA)) {
            //If SDCallback fails, we need to return FALSE
            if (pUA->bLocal)
                if (!(pUA->SDCallback)(
                        (Frame + 6 + NBytesConsumed),  // pData
                        DataLength,
                        pUA->UserDefined,  // UserDefined
                        pUA,  // hUser
                        (BOOLEAN)(PDUNum == MCS_UNIFORM_SEND_DATA_REQUEST),  // bUniform
                        pMCSChannel,  // hChannel
                        Priority,
                        SenderID,
                        Segmentation))  {
                    return FALSE;
                }
            //  WD_Close can jump in to clean the Channel list and user list 
            //  during the pUA->SDCallback when disconnecting
            //  at this time pDomain->bCanSendData will be set to FALSE
            if (!pDomain->bCanSendData) {
                 return FALSE;
            }
        }        
        // MCS FUTURE: We do not handle indications and requests differently
        //   and enforce standard usage.
        // MCS FUTURE: We need to check if there are any other downlevel attachments
        //   and forward the data down to them.
    }
    else {
        //MCS FUTURE: Forward (Uniform)SendData PDU to upward connection.
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\pdmcs\mcscore.c ===
/* (C) 1997-1999 Microsoft Corp.
 *
 * file   : MCSCore.c
 * author : Erik Mavrinac
 *
 * description: MCS core manipulation code for actions that are common
 *   between inbound PDU handling and API calls from upper components.
 */

#include "PreComp.h"
#pragma hdrstop

#include <MCSImpl.h>


// Gets a new dynamic channel number, but does not add it to channel list.
// Returns 0 if none available.
ChannelID GetNewDynamicChannel(Domain *pDomain)
{
    if (SListGetEntries(&pDomain->ChannelList) >=
            pDomain->DomParams.MaxChannels)
        return 0;

    pDomain->NextAvailDynChannel++;
    ASSERT(pDomain->NextAvailDynChannel <= 65535);
    return (pDomain->NextAvailDynChannel - 1);
}
        


/*
 * Common detach-user request code applicable to both net PDU requests and
 *   local requests.
 * bDisconnect is FALSE if this is a normal detach where local attachments
 *   are notified, nonzero if this a disconnection situation and the
 *   attachment needs to be sent a detach-user indication with its own UserID.
 */

MCSError DetachUser(
        Domain     *pDomain,
        UserHandle hUser,
        MCSReason  Reason,
        BOOLEAN    bDisconnect)
{
    POUTBUF pOutBuf;
    BOOLEAN bChannelRemoved;
    NTSTATUS Status;
    MCSError MCSErr;
    MCSChannel *pMCSChannel;
    UserAttachment *pUA, *pCurUA;
    DetachUserIndication DUin;

    pUA = (UserAttachment *)hUser;

    TraceOut3(pDomain->pContext, "DetachUser() entry, pDomain=%X, hUser=%X, "
            "UserID=%X", pDomain, hUser, pUA->UserID);

    // Remove the user from all joined channels.
    SListResetIteration(&pUA->JoinedChannelList);
    while (SListIterate(&pUA->JoinedChannelList, (UINT_PTR *)&pMCSChannel,
            &pMCSChannel)) {
        MCSErr = ChannelLeave(hUser, pMCSChannel, &bChannelRemoved);
        ASSERT(MCSErr == MCS_NO_ERROR);
    }

    // Remove the requested hUser from the user attachments list.
    TraceOut(pDomain->pContext, "DetachUser(): Removing hUser from main list");
    SListRemove(&pDomain->UserAttachmentList, (UINT_PTR)hUser, &pUA);
    if (pUA != NULL) {
        // Common callback information.
        DUin.UserID = pUA->UserID;
        DUin.Reason = Reason;
    }
    else {
        ErrOut(pDomain->pContext, "DetachUser: hUser is not a valid "
                "user attachment");
        return MCS_NO_SUCH_USER;
    }

    if (bDisconnect) {
        // Send detach-user callback to user with its own ID.
        DUin.bSelf = TRUE;

        (pUA->Callback)(hUser, MCS_DETACH_USER_INDICATION, &DUin,
                pUA->UserDefined);
    }
    else if (!bDisconnect && SListGetEntries(&pDomain->UserAttachmentList)) {
        DUin.bSelf = FALSE;
        
        // Iterate the remaining local attachments and send the indication.
        // It is the caller's responsibility to inform downlevel connections
        //   of the detachment.
        SListResetIteration(&pDomain->UserAttachmentList);
        while (SListIterate(&pDomain->UserAttachmentList, (UINT_PTR *)&hUser,
                &pCurUA)) {
            if (pCurUA->bLocal)
                (pCurUA->Callback)(hUser, MCS_DETACH_USER_INDICATION, &DUin,
                        pCurUA->UserDefined);
        }
        
        // Reset again to keep callers from failing to iterate.
        SListResetIteration(&pDomain->UserAttachmentList);
    }

    // Remove UserID from channel list. It may no longer be there if the
    //   user had joined the channel and the channel was purged above.
    TraceOut(pDomain->pContext, "DetachUser(): Removing UserID from main "
            "channel list");
    SListRemove(&pDomain->ChannelList, pUA->UserID, &pMCSChannel);
    if (pMCSChannel) {
        // Consistency check -- the code above should have caught the channel
        //   and destroyed it if the user had joined. Otherwise the channel
        //   should be empty.
        ASSERT(SListGetEntries(&pMCSChannel->UserList) == 0);
        SListDestroy(&pMCSChannel->UserList);
        if (pMCSChannel->bPreallocated)
            pMCSChannel->bInUse = FALSE;
        else
            ExFreePool(pMCSChannel);
    }

    // Destruct and deallocate pUA.
    SListDestroy(&pUA->JoinedChannelList);
    if (pUA->bPreallocated)
        pUA->bInUse = FALSE;
    else
        ExFreePool(pUA);

    return MCS_NO_ERROR;
}



MCSError ChannelLeave(
        UserHandle    hUser,
        ChannelHandle hChannel,
        BOOLEAN       *pbChannelRemoved)
{
    UserAttachment *pUA, *pUA_Channel;
    MCSChannel *pMCSChannel_UA, *pMCSChannel_Main;

    *pbChannelRemoved = FALSE;

    pUA = (UserAttachment *)hUser;
    pMCSChannel_Main = (MCSChannel *)hChannel;

    if (NULL == pMCSChannel_Main) {
        return MCS_NO_SUCH_CHANNEL;
    }

    // Remove the channel from the UA joined-channel list.
    TraceOut1(pUA->pDomain->pContext, "ChannelLeave(): Removing hChannel %X "
            "from main channel list", hChannel);
    SListRemove(&pUA->JoinedChannelList, (UINT_PTR)pMCSChannel_Main,
            &pMCSChannel_UA);
    ASSERT(pMCSChannel_UA == pMCSChannel_Main);  // Consistency check.

    // Remove the hUser from the channel user list.
    TraceOut1(pUA->pDomain->pContext, "ChannelLeave(): Removing hUser %X "
            "from channel joined user list", hUser);
    SListRemove(&pMCSChannel_Main->UserList, (UINT_PTR)pUA, &pUA_Channel);
    ASSERT(pUA == pUA_Channel);  // Consistency check.

    // Remove the channel from the main list if there are no more users joined.
    if (!SListGetEntries(&pMCSChannel_Main->UserList)) {
        TraceOut(pUA->pDomain->pContext, "ChannelLeave(): Removing channel "
                "from main channel list");
        SListRemove(&pUA->pDomain->ChannelList, pMCSChannel_Main->ID,
                &pMCSChannel_Main);
        ASSERT(pMCSChannel_Main != NULL);
        if (pMCSChannel_Main == NULL) {
            return MCS_NO_SUCH_CHANNEL;
        }
        if (pMCSChannel_Main->bPreallocated)
            pMCSChannel_Main->bInUse = FALSE;
        else
            ExFreePool(pMCSChannel_Main);
        *pbChannelRemoved = TRUE;
    }

    if (!pUA->pDomain->bTopProvider) {
        // MCS FUTURE: Local lists are updated, forward the request to the
        //   top provider. No confirm will be issued.
    }
    
    return MCS_NO_ERROR;
}



/*
 * Disconnect provider. Called on receipt of a disconnect-provider ultimatum
 *   PDU, or when the connection is lost. bLocal is TRUE if this call is
 *   for a local node controller call or lost connection, FALSE if for a
 *   received PDU.
 */

NTSTATUS DisconnectProvider(Domain *pDomain, BOOLEAN bLocal, MCSReason Reason)
{
    NTSTATUS Status;
    UserHandle hUser;
    UserAttachment *pUA;

    pDomain->State = State_Disconnected;

    TraceOut1(pDomain->pContext, "DisconnectProvider(): pDomain=%X", pDomain);

    // Search through the attached users list, launch detach-user indications.
    // For bLocal == FALSE, we do a regular-style detach for each nonlocal user.
    // Otherwise, we send a detach-user indication to each local user
    //   attachment containing the attachment's own user ID, indicating that
    //   it was forced out of the domain.
    // Multiple iterations: DetachUser also iterates UserAttachmentList, but
    //   takes care to reset the iteration again after it is done. Since
    //   removing a list entry resets the iteration, this is exactly what we
    //   want.
    SListResetIteration(&pDomain->UserAttachmentList);
    while (SListIterate(&pDomain->UserAttachmentList, (UINT_PTR *)&hUser,
            &pUA)) {
        if (bLocal && pUA->bLocal)
            Status = DetachUser(pDomain, hUser, Reason, TRUE);
        else if (!bLocal && !pUA->bLocal)
            Status = DetachUser(pDomain, hUser, Reason, FALSE);
    }
    
    // We do not do any notification to either the local node controller or
    //   sending across the net -- the caller is responsible for doing the
    //   right thing.
    return STATUS_SUCCESS;
}



/*
 * Handles sending an OutBuf to the TD, including updating perf counters.
 * NOTE: This code is inlined into the critical MCSSendDataRequest() path
 *   in MCSKAPI.c. Any changes here need to be reflected there.
 */

NTSTATUS SendOutBuf(Domain *pDomain, POUTBUF pOutBuf)
{
    SD_RAWWRITE SdWrite;

    ASSERT(pOutBuf->ByteCount > 0);

    if (!pDomain->bCanSendData) {
        WarnOut1(pDomain->pContext, "%s: SendOutBuf(): Ignoring a send because "
                "ICA stack not connected", 
                 pDomain->StackClass == Stack_Primary ? "Primary" :
                 (pDomain->StackClass == Stack_Shadow ? "Shadow" :
                 "PassThru"));
        IcaBufferFree(pDomain->pContext, pOutBuf);
        return STATUS_SUCCESS;
    }

    // Fill out the raw write data.
    SdWrite.pBuffer = NULL;
    SdWrite.ByteCount = 0;
    SdWrite.pOutBuf = pOutBuf;

    // Increment protocol counters.
    pDomain->pStat->Output.WdFrames++;
    pDomain->pStat->Output.WdBytes += pOutBuf->ByteCount;

    // Send data to next driver in stack.
    return IcaCallNextDriver(pDomain->pContext, SD$RAWWRITE, &SdWrite);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\pdmcs\precomp.h ===
/* (C) 1997 Microsoft Corp.
 *
 * file   : PreComp.h
 * author : Erik Mavrinac
 *
 * description: Precompiled headers file
 */

#include <ntddk.h>

#ifndef _HYDRA_
#include <cxstatus.h>
#endif

#include <winstaw.h>

#ifdef _HYDRA_
#define _DEFCHARINFO_
#endif

#include <icadd.h>
#include <ctxver.h>

#include <sdapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\pdmcs\trace.h ===
/* (C) 1997 Microsoft Corp.
 *
 * file   : Debug.h
 * author : Erik Mavrinac
 *
 * description: MCS debugging defines and prototypes. Requires that
 *   a stack PSDCONTEXT be available anywhere these calls are made.
 */


#if DBG


// These ...Out() macros are graded by the number of extra parameters:
//   Out() is only a string, Out1() is one stack parameter, etc.
// We use non-ICA-defined trace types here to allow clean separation from
//   WDTShare tracing, which uses the ICA TT_API*, TT_OUT*, TT_IN* macros.

#define MCS_TT_Error   TT_ERROR
#define MCS_TT_Warning 0x02000000
#define MCS_TT_Trace   0x04000000
#define MCS_TT_Dump    0x08000000

#define ErrOut(context, str) \
        IcaStackTrace(context, TC_PD, MCS_TT_Error, "MCS: **** ERROR: " str "\n")
#define ErrOut1(context, str, arg1) \
        IcaStackTrace(context, TC_PD, MCS_TT_Error, "MCS: **** ERROR: " str "\n", arg1)
#define ErrOut2(context, str, arg1, arg2) \
        IcaStackTrace(context, TC_PD, MCS_TT_Error, "MCS: **** ERROR: " str "\n", arg1, arg2)

#define WarnOut(context, str) \
        IcaStackTrace(context, TC_PD, MCS_TT_Warning, "MCS: warning: " str "\n")
#define WarnOut1(context, str, arg1) \
        IcaStackTrace(context, TC_PD, MCS_TT_Warning, "MCS: warning: " str "\n", arg1)
#define WarnOut2(context, str, arg1, arg2) \
        IcaStackTrace(context, TC_PD, MCS_TT_Warning, "MCS: warning: " str "\n", arg1, arg2)

#define TraceOut(context, str) \
        IcaStackTrace(context, TC_PD, MCS_TT_Trace, "MCS: " str "\n")
#define TraceOut1(context, str, arg1) \
        IcaStackTrace(context, TC_PD, MCS_TT_Trace, "MCS: " str "\n", arg1)
#define TraceOut2(context, str, arg1, arg2) \
        IcaStackTrace(context, TC_PD, MCS_TT_Trace, "MCS: " str "\n", arg1, arg2)
#define TraceOut3(context, str, arg1, arg2, arg3) \
        IcaStackTrace(context, TC_PD, MCS_TT_Trace, "MCS: " str "\n", arg1, arg2, arg3)

#define DumpOut(context, str, buf, len) \
        { \
            IcaStackTrace(context, TC_PD, MCS_TT_Dump, "MCS: dump: " str "\n"); \
            IcaStackTraceBuffer(context, TC_PD, MCS_TT_Dump, buf, len); \
        }


#else  // DBG


#define ErrOut(context, str) 
#define ErrOut1(context, str, arg1) 
#define ErrOut2(context, str, arg1, arg2) 

#define WarnOut(context, str) 
#define WarnOut1(context, str, arg1) 
#define WarnOut2(context, str, arg1, arg2) 

#define TraceOut(context, str) 
#define TraceOut1(context, str, arg1) 
#define TraceOut2(context, str, arg1, arg2) 
#define TraceOut3(context, str, arg1, arg2, arg3) 

#define DumpOut(context, str, buf, len) 


#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\pdmcs\mcsimpl.h ===
/* (C) 1997-1999 Microsoft Corp.
 *
 * file   : MCSImpl.h
 * author : Erik Mavrinac
 *
 * description: MCS implementation-specific defines and structures.
 */

#ifndef __MCSIMPL_H
#define __MCSIMPL_H


#include "MCSKernl.h"
#include "X224.h"
#include "MCSIOCTL.h"
#include "SList.h"
#include "Trace.h"
#include "rdperr.h"
#include "domain.h"


/*
 * Defines
 */

// Memory defines.
#define MCS_POOL_TAG 'cmST'


// Used with PDU handler function tables to allow a PDU name in debug builds.
#if DBG
#define StrOnDbg(str, func) { str, func }
#else
#define StrOnDbg(str, func) { func }
#endif  // DBG


#define NULL_ChannelID 0
#define NULL_TokenID   0
#define NULL_UserID    0


// Start of the dynamic MCS channel numbering space.
#define MinDynamicChannel 1002


// Types of channels possible in the MCSChannel struct below.
#define Channel_Unused   0
#define Channel_Static   1
#define Channel_UserID   2
#define Channel_Assigned 3
#define Channel_Convened 4


// Default starting sizes for allocation pools. These are provided as hints
//   to data structure management code.
#define DefaultNumChannels 5
#define DefaultNumUserAttachments 2

// DomainParameters required min and max settings.
#define RequiredMinChannels  4
#define RequiredMinUsers     3
#define RequiredDomainHeight 1
#define RequiredMinPDUSize   124
#define RequiredProtocolVer  2
#define RequiredPriorities   1

// Connection states for PD.State below.
// Connection sequence like this:
//   1. Start state: Unconnected
//   2. Client socket created, state: Unconnected
//   3. X.224 Connect TPDU comes in, send accept. State: X224_Connected
//   4. MCS connect-initial comes in, send up to node controller for acceptance,
//      state: ConnectProvIndPending
//   5. Node controller responds with connect-provider response: if accepted
//      (RESULT_SUCCESSFUL) state = MCS_Connected; otherwise state =
//      Disconnected.
//   6. Client sends MCS disconnect-provider ultimatum: state = Disconnected.
//   7. Server calls DisconnectProvider: state = Disconnected.
#define State_Unconnected           0
#define State_X224_Connected        1
#define State_X224_Requesting       2
#define State_ConnectProvIndPending 3
#define State_MCS_Connected         4
#define State_Disconnected          5


// Diagnostic codes - for RejectMCSPDU. Values per T.125 spec.
#define Diag_InconsistentMerge      0
#define Diag_ForbiddenPDUDownward   1
#define Diag_ForbiddenPDUUpward     2
#define Diag_InvalidBEREncoding     3
#define Diag_InvalidPEREncoding     4
#define Diag_MisroutedUser          5
#define Diag_UnrequestedConfirm     6
#define Diag_WrongTransportPriority 7
#define Diag_ChannelIDConflict      8
#define Diag_TokenIDConflict        9
#define Diag_NotUserIDChannel       10
#define Diag_TooManyChannels        11
#define Diag_TooManyTokens          12
#define Diag_TooManyUsers           13



/*
 * PDU types and lengths
 */

#define MCS_CONNECT_PDU 0x7F

// The 101-based enumerated connect PDU type.
#define MCS_CONNECT_INITIAL_ENUM    0x65
#define MCS_CONNECT_RESPONSE_ENUM   0x66
#define MCS_CONNECT_ADDITIONAL_ENUM 0x67
#define MCS_CONNECT_RESULT_ENUM     0x68

#define MinConnectPDU MCS_CONNECT_INITIAL_ENUM
#define MaxConnectPDU MCS_CONNECT_RESULT_ENUM


// The 0-based enumerated domain PDU type, defined for creating labeled-byte
//   tables for Bloodhound.
#define MCS_PLUMB_DOMAIN_INDICATION_ENUM                 0
#define MCS_ERECT_DOMAIN_REQUEST_ENUM                    1
#define MCS_MERGE_CHANNELS_REQUEST_ENUM                  2
#define MCS_MERGE_CHANNELS_CONFIRM_ENUM                  3
#define MCS_PURGE_CHANNEL_INDICATION_ENUM                4
#define MCS_MERGE_TOKENS_REQUEST_ENUM                    5
#define MCS_MERGE_TOKENS_CONFIRM_ENUM                    6
#define MCS_PURGE_TOKEN_INDICATION_ENUM                  7
#define MCS_DISCONNECT_PROVIDER_ULTIMATUM_ENUM           8
#define MCS_REJECT_ULTIMATUM_ENUM                        9
#define MCS_ATTACH_USER_REQUEST_ENUM                     10
#define MCS_ATTACH_USER_CONFIRM_ENUM                     11
#define MCS_DETACH_USER_REQUEST_ENUM                     12
#define MCS_DETACH_USER_INDICATION_ENUM                  13
#define MCS_CHANNEL_JOIN_REQUEST_ENUM                    14
#define MCS_CHANNEL_JOIN_CONFIRM_ENUM                    15
#define MCS_CHANNEL_LEAVE_REQUEST_ENUM                   16
#define MCS_CHANNEL_CONVENE_REQUEST_ENUM                 17
#define MCS_CHANNEL_CONVENE_CONFIRM_ENUM                 18
#define MCS_CHANNEL_DISBAND_REQUEST_ENUM                 19
#define MCS_CHANNEL_DISBAND_INDICATION_ENUM              20
#define MCS_CHANNEL_ADMIT_REQUEST_ENUM                   21
#define MCS_CHANNEL_ADMIT_INDICATION_ENUM                22
#define MCS_CHANNEL_EXPEL_REQUEST_ENUM                   23
#define MCS_CHANNEL_EXPEL_INDICATION_ENUM                24
#define MCS_SEND_DATA_REQUEST_ENUM                       25
#define MCS_SEND_DATA_INDICATION_ENUM                    26
#define MCS_UNIFORM_SEND_DATA_REQUEST_ENUM               27
#define MCS_UNIFORM_SEND_DATA_INDICATION_ENUM            28
#define MCS_TOKEN_GRAB_REQUEST_ENUM                      29
#define MCS_TOKEN_GRAB_CONFIRM_ENUM                      30
#define MCS_TOKEN_INHIBIT_REQUEST_ENUM                   31
#define MCS_TOKEN_INHIBIT_CONFIRM_ENUM                   32
#define MCS_TOKEN_GIVE_REQUEST_ENUM                      33
#define MCS_TOKEN_GIVE_INDICATION_ENUM                   34
#define MCS_TOKEN_GIVE_RESPONSE_ENUM                     35
#define MCS_TOKEN_GIVE_CONFIRM_ENUM                      36
#define MCS_TOKEN_PLEASE_REQUEST_ENUM                    37
#define MCS_TOKEN_PLEASE_INDICATION_ENUM                 38
#define MCS_TOKEN_RELEASE_REQUEST_ENUM                   39
#define MCS_TOKEN_RELEASE_CONFIRM_ENUM                   40
#define MCS_TOKEN_TEST_REQUEST_ENUM                      41
#define MCS_TOKEN_TEST_CONFIRM_ENUM                      42

#define MinDomainPDU MCS_PLUMB_DOMAIN_INDICATION_ENUM
#define MaxDomainPDU MCS_TOKEN_TEST_CONFIRM_ENUM



/*
 * PDU size definitions for use allocating buffers for PDUs/headers.
 */

// Connect PDUs.

// Connect-response - maximum size. Includes:
//   3 bytes for Result
//   5 bytes for CalledConnectID
//   40 bytes for DomParams
//   6 bytes for UserDataSize
//   UserLen bytes for user data
#define ConnectResponseHeaderSize 54
#define ConnectResponseBaseSize(UserLen) (ConnectResponseHeaderSize + UserLen)
#define ConnectResponsePDUSize(UserLen) \
        (X224_DataHeaderSize + ConnectResponseBaseSize(UserLen))


// Domain PDUs.

// Prototype for function defined in DomPDU.c.
int GetTotalLengthDeterminantEncodingSize(int);
#define GetLD(x) GetTotalLengthDeterminantEncodingSize(x)

// Plumb-domain indication
#define PDinBaseSize 3
#define PDinPDUSize (X224_DataHeaderSize + PDinBaseSize)

// Erect-domain request
#define EDrqBaseSize 5
#define EDrqPDUSize (X224_DataHeaderSize + EDrqBaseSize)

// Disconnect-provider ultimatum
#define DPumBaseSize 2
#define DPumPDUSize (X224_DataHeaderSize + DPumBaseSize)

// Reject-MCSPDU ultimatum
#define RJumBaseSize(PDUSize) (2 + GetLD(PDUSize) + (PDUSize))
#define RJumPDUSize(PDUSize) (X224_DataHeaderSize + RJumBaseSize(PDUSize))

// Attach-user request
#define AUrqBaseSize 1
#define AUrqPDUSize (X224_DataHeaderSize + AUrqBaseSize)

// Attach-user confirm
#define AUcfBaseSize(bInit) ((bInit) ? 4 : 2)
#define AUcfPDUSize(bInit) (X224_DataHeaderSize + AUcfBaseSize(bInit))

// Detach-user request
#define DUrqBaseSize(NUsers) (2 + GetLD(NUsers) + sizeof(UserID) * (NUsers))
#define DUrqPDUSize(NUsers) (X224_DataHeaderSize + DUrqBaseSize(NUsers))

// Detach-user indication
#define DUinBaseSize(NUsers) DUrqBaseSize(NUsers)
#define DUinPDUSize(NUsers) DUrqPDUSize(NUsers)

// Channel-join request
#define CJrqBaseSize 5
#define CJrqPDUSize (X224_DataHeaderSize + CJrqBaseSize)

// Channel-join confirm
#define CJcfBaseSize(bJoin) ((bJoin) ? 8 : 6)
#define CJcfPDUSize(bJoin) (X224_DataHeaderSize + CJcfBaseSize(bJoin))

// Channel-leave request
#define CLrqBaseSize(NChn) (1 + GetLD(NChn) + sizeof(ChannelID) * (NChn))
#define CLrqPDUSize(NChn) (X224_DataHeaderSize + CLrqBaseSize(NChn))

// Channel-convene request
#define CCrqBaseSize 3
#define CCrqPDUSize (X224_DataHeaderSize + CCrqBaseSize)

// Channel-convene confirm
#define CCcfBaseSize(bChn) ((bChn) ? 6 : 4)
#define CCcfPDUSize(bChn) (X224_DataHeaderSize + CCcfBaseSize(bChn))

// Channel-disband request
#define CDrqBaseSize 5
#define CDrqPDUSize (X224_DataHeaderSize + CDrqBaseSize)

// Channel-disband indication
#define CDinBaseSize 3
#define CDinPDUSize (X224_DataHeaderSize + CDinBaseSize)

// Channel-admit request
#define CArqBaseSize(NUsers) (5 + sizeof(UserID) * (NUsers))
#define CArqPDUSize(NUsers) (X224_DataHeaderSize + CArqBaseSize(NUsers))

// Channel-admit indication
#define CAinBaseSize(NUsers) CArqBaseSize(NUsers)
#define CAinPDUSize(NUsers) CAinPDUSize(NUsers)

// Channel-expel request
#define CErqBaseSize(NUsers) CArqBaseSize(NUsers)
#define CErqPDUSize(NUsers) CAinPDUSize(NUsers)

// Channel-expel indication
#define CEinBaseSize(NUsers) (3 + sizeof(UserID) * (NUsers))
#define CEinPDUSize(NUsers) (X224_DataHeaderSize + CEinBaseSize(NUsers))

// Send data
#define SDBaseSize(DataSize) (6 + GetLD(DataSize) + (DataSize))
#define SDPDUSize(DataSize) (X224_DataHeaderSize + SDBaseSize(DataSize))

// Token-grab request
#define TGrqBaseSize 5
#define TGrqPDUSize (X224_DataHeaderSize + TGrqBaseSize)

// Token-grab confirm
#define TGcfBaseSize 7
#define TGcfPDUSize (X224_DataHeaderSize + TGcfBaseSize)

// Token-inhibit request
#define TIrqBaseSize 5
#define TIrqPDUSize (X224_DataHeaderSize + TIrqBaseSize)

// Token-inhibit confirm
#define TIcfBaseSize TGcfBaseSize
#define TIcfPDUSize TGcfPDUSize

// Token-give request
#define TVrqBaseSize 7
#define TVrqPDUSize (X224_DataHeaderSize + TVrqBaseSize)

// Token-give indication
#define TVinBaseSize 7
#define TVinPDUSize (X224_DataHeaderSize + TVinBaseSize)

// Token-give response
#define TVrsBaseSize 6
#define TVrsPDUSize (X224_DataHeaderSize + TVrsBaseSize)

// Token-give confirm
#define TVcfBaseSize TGcfBaseSize
#define TVcfPDUSize TGcfPDUSize

// Token-please request
#define TPrqBaseSize 5
#define TPrqPDUSize (X224_DataHeaderSize + TPrqBaseSize)

// Token-please indication
#define TPinBaseSize 5
#define TPinPDUSize (X224_DataHeaderSize + TPinBaseSize)

// Token-release request
#define TRrqBaseSize 5
#define TRrqPDUSize (X224_DataHeaderSize + TRrqBaseSize)

// Token-release confirm
#define TRcfBaseSize TGcfBaseSize
#define TRcfPDUSize TGcfPDUSize

// Token-test request
#define TTrqBaseSize 5
#define TTrqPDUSize (X224_DataHeaderSize + TTrqBaseSize)

// Token-test confirm
#define TTcfBaseSize 6
#define TTcfPDUSize (X224_DataHeaderSize + TTcfBaseSize)



/*
 * Utility macros and prototypes for decoding and encoding domain PDUs.
 */

#define GetByteswappedShort(pStartByte) \
       ((*(pStartByte) << 8) + *((pStartByte) + 1))

#define PutByteswappedShort(pStartByte, Val) \
        { \
            *(pStartByte) = ((Val) & 0xFF00) >> 8; \
            *((pStartByte) + 1) = (Val) & 0x00FF; \
        }


// Regular Channel ID -- 0..65535: 16 bits.
#define GetChannelID(pStartByte) GetByteswappedShort(pStartByte)
#define PutChannelID(pStartByte, ChID) PutByteswappedShort(pStartByte, ChID)


// Dynamic Channel ID -- 1001..65535: 16 bits, advanced to offset 1001.
#define GetDynamicChannelID(pStartByte) \
        ((GetByteswappedShort(pStartByte)) + 1001)

#define PutDynamicChannelID(pStartByte, DChID) \
        PutByteswappedShort(pStartByte, (DChID) - 1001)


// Token ID -- 0..65535: 16 bits.
#define GetTokenID(pStartByte) GetByteswappedShort(pStartByte)
#define PutTokenID(pStartByte, TokID) PutByteswappedShort(pStartByte, TokID)


// User ID -- same as dynamic channel ID.
#define GetUserID(pStartByte) GetDynamicChannelID(pStartByte)
#define PutUserID(pStartByte, UsrID) PutDynamicChannelID(pStartByte, UsrID)


// Private channel ID -- same as dynamic channel ID.
#define GetPrivateChannelID(pStartByte) GetDynamicChannelID(pStartByte)
#define PutPrivateChannelID(pStartByte, PrvChID) \
        PutDynamicChannelID(pStartByte, PrvChID)


// Reason field.
#define Get3BitFieldAtBit1(pStartByte) \
        (((*(pStartByte) & 0x03) << 1) + ((*((pStartByte) + 1) & 0x80) >> 7))

#define Put3BitFieldAtBit1(pStartByte, Val) \
        { \
            *(pStartByte) |= (((Val) & 0x06) >> 1); \
            *((pStartByte) + 1) |= (((Val) & 0x01) << 7); \
        }


// Result and Diagnostic fields in various PDUs.
#define Get4BitFieldAtBit0(pStartByte) \
        (((*(pStartByte) & 0x01) << 3) + ((*((pStartByte) + 1) & 0xE0) >> 5))

#define Put4BitFieldAtBit0(pStartByte, Val) \
        { \
            *(pStartByte) |= (((Val) & 0x08) >> 3); \
            *((pStartByte) + 1) |= (((Val) & 0x07) << 5); \
        }

#define Get4BitFieldAtBit1(pStartByte) \
        (((*(pStartByte) & 0x03) << 2) + ((*((pStartByte) + 1) & 0xC0) >> 6))

#define Put4BitFieldAtBit1(pStartByte, Val) \
        { \
            *(pStartByte) |= (((Val) & 0x0C) >> 2); \
            *((pStartByte) + 1) |= (((Val) & 0x03) << 6); \
        }



//
// Input buffer allocations are biased to be 8 bytes bigger
// than necessary because the decompression code prefetches
// bytes from after the end of the input buffer.
// It's evil, but it avoids a lot of branches in perf critical code.
// NOTE: We could change the decompression code to check for buffer
// end but it is performance critical so we're not touching it.
//
#define INPUT_BUFFER_BIAS 8



// T.120 request dispatch function signature.
typedef NTSTATUS (*PT120RequestFunc)(PDomain, PSD_IOCTL);


// PDU dispatch table entries.
typedef struct {
#if DBG
    char *Name;
#endif

    BOOLEAN (__fastcall *HandlePDUFunc)(Domain *, BYTE *, unsigned, unsigned *);
} MCSPDUInfo;



/*
 * Globals
 */

// Dispatch table defined in MCSCalls.c.
extern const PT120RequestFunc g_T120RequestDispatch[];

// PDU dispatch table defined in ConPDU.c.
extern const MCSPDUInfo ConnectPDUTable[];

// PDU dispatch table defined in DomPDU.c.
extern const MCSPDUInfo DomainPDUTable[];



/*
 * Prototypes.
 */

// Defined in Decode.c.
NTSTATUS SendX224Confirm(Domain *);

// Defined in DomPDU.c.
void __fastcall EncodeLengthDeterminantPER(BYTE *, unsigned, unsigned *,
        BOOLEAN *, unsigned *);
void CreatePlumbDomainInd(unsigned short, BYTE *);
void CreateDisconnectProviderUlt(int, BYTE *);
NTSTATUS ReturnRejectPDU(PDomain, int, BYTE *, unsigned);
void CreateRejectMCSPDUUlt(int, BYTE *, unsigned, BYTE *);
void CreateAttachUserCon(int, BOOLEAN, UserID, BYTE *);
void CreateDetachUserInd(MCSReason, int, UserID *, BYTE *);
void CreateChannelJoinCon(int, UserID, ChannelID, BOOLEAN, ChannelID, BYTE *);
void CreateChannelConveneCon(MCSResult, UserID, BOOLEAN, ChannelID, BYTE *);
void CreateSendDataPDUHeader(int, UserID, ChannelID, MCSPriority,
        Segmentation, BYTE **, unsigned *);
BOOLEAN __fastcall HandleAllSendDataPDUs(PDomain, BYTE *, unsigned, unsigned *);

// Defined in TokenPDU.c.
void CreateTokenCon(int, int, UserID, TokenID, int, BYTE *);
void CreateTokenTestCon(UserID, TokenID, int, BYTE *);

// Defined in MCSCore.c.
ChannelID GetNewDynamicChannel(Domain *);
MCSError DetachUser(Domain *, UserHandle, MCSReason, BOOLEAN);
MCSError ChannelLeave(UserHandle, ChannelHandle, BOOLEAN *);
NTSTATUS DisconnectProvider(PDomain, BOOLEAN, MCSReason);
NTSTATUS SendOutBuf(Domain *, POUTBUF);

// Defined in ConPDU.c.
void CreateConnectResponseHeader(PSDCONTEXT, MCSResult, int,
        DomainParameters *, unsigned, BYTE *, unsigned *);

// Defined in IcaIFace.c.
void SignalBrokenConnection(Domain *);



#endif  // !defined(__MCSIMPL_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\pdmcs\slist.c ===
/* (C) 1997-1999 Microsoft Corp.
 *
 * file    : SList.c
 * authors : Christos Tsollis, Erik Mavrinac
 *
 * description: Implementation of list described in SList.h.
 */

#include "precomp.h"
#pragma hdrstop

#include "mcsimpl.h"


void SListInit(PSList pSL, unsigned NItems)
{
    // Initialize the private member variables. Use preallocated array for
    // initial node array.
    pSL->Hdr.NEntries = 0;
    pSL->Hdr.MaxEntries = SListDefaultNumEntries;
    pSL->Hdr.HeadOffset = 0;
    pSL->Hdr.CurrOffset = 0xFFFFFFFF;
    pSL->Hdr.Entries = pSL->InitialList;
}



void SListDestroy(PSList pSL)
{
    // Only free if we have a pool-allocated array.
    if (pSL->Hdr.Entries != pSL->InitialList) {
        ExFreePool(pSL->Hdr.Entries);
        pSL->Hdr.Entries = pSL->InitialList;
        pSL->Hdr.MaxEntries = SListDefaultNumEntries;
    }
    pSL->Hdr.NEntries = 0;
}



/*
 * Expand
 *   Private function to double the storage of the SList. Returns FALSE on
 *   error.
 */
static BOOLEAN SListExpand(PSList pSL)
{
    unsigned Temp;
    _SListNode *OldEntries;    // Keeps a copy of the old array of values.

    ASSERT(pSL->Hdr.Entries != NULL);

    // The current array of entries is full, so we need to allocate a bigger
    //   one. The new array has twice the size of the old one.
    OldEntries = pSL->Hdr.Entries;
    pSL->Hdr.Entries = ExAllocatePoolWithTag(PagedPool, pSL->Hdr.MaxEntries *
            2 * sizeof(_SListNode), MCS_POOL_TAG);
    if (pSL->Hdr.Entries == NULL) {
        // We failed; we have to return
        pSL->Hdr.Entries = OldEntries;
        return FALSE;
    }

    // Copy the old entries into the new array, starting from the head.
    Temp = pSL->Hdr.MaxEntries - pSL->Hdr.HeadOffset;
    memcpy(pSL->Hdr.Entries, OldEntries + pSL->Hdr.HeadOffset, Temp *
            sizeof(_SListNode));
    memcpy(pSL->Hdr.Entries + Temp, OldEntries, pSL->Hdr.HeadOffset *
            sizeof(_SListNode));

    // Free the old array of entries if not the initial array.
    if (OldEntries != pSL->InitialList)
        ExFreePool(OldEntries);

    // Set the instance variables
    pSL->Hdr.MaxEntries *= 2;
    pSL->Hdr.HeadOffset = 0;
    return TRUE;
}



/*
 * Append
 *   Inserts a value at the end of a list. Returns FALSE on error.
 */
BOOLEAN SListAppend(PSList pSL, UINT_PTR NewKey, void *NewValue)
{
    unsigned Temp;

    if (pSL->Hdr.NEntries < pSL->Hdr.MaxEntries ||
            (pSL->Hdr.NEntries >= pSL->Hdr.MaxEntries && SListExpand(pSL))) {
        Temp = pSL->Hdr.HeadOffset + pSL->Hdr.NEntries;
        if (Temp >= pSL->Hdr.MaxEntries)
            Temp -= pSL->Hdr.MaxEntries;
        pSL->Hdr.Entries[Temp].Key = NewKey;
        pSL->Hdr.Entries[Temp].Value = NewValue;
        pSL->Hdr.NEntries++;

        return TRUE;
    }
    else {
        return FALSE;
    }
}



#ifdef NotUsed
/*
 * Prepend
 *   Inserts a value at the beginning of a list. Returns FALSE on error.
 */
BOOLEAN SListPrepend(PSList pSL, UINT_PTR NewKey, void *NewValue)
{
    if (pSL->Hdr.NEntries >= pSL->Hdr.MaxEntries)
        if (!SListExpand(pSL))
            return FALSE;

    ASSERT(pSL->Hdr.Entries != NULL);
    ASSERT(pSL->Hdr.NEntries < pSL->Hdr.MaxEntries);

    if (pSL->Hdr.HeadOffset == 0)
        pSL->Hdr.HeadOffset = pSL->Hdr.MaxEntries - 1;
    else
        pSL->Hdr.HeadOffset--;
    
    pSL->Hdr.Entries[pSL->Hdr.HeadOffset].Key = NewKey;
    pSL->Hdr.Entries[pSL->Hdr.HeadOffset].Value = NewValue;
    pSL->Hdr.NEntries++;

    // Reset iteration.
    pSL->Hdr.CurrOffset = 0xFFFFFFFF;

    return TRUE;
}
#endif  // NotUsed



/*
 * Remove
 *   Removes a value from the list, returning the value in *pValue. Returns
 *     NULL in *pValue if the key does not exist. pValue can be NULL.
 */
void SListRemove(PSList pSL, UINT_PTR Key, void **pValue)
{
    unsigned i, Temp, CurItem;

    // Find Key in the list.
    CurItem = pSL->Hdr.HeadOffset;
    for (i = 0; i < pSL->Hdr.NEntries; i++) {
        if (Key == pSL->Hdr.Entries[CurItem].Key) {
            // Found it; now move the last value in the list into its place.
            // (Remember we aren't trying to preserve ordering here.)
            if (pValue != NULL)
                *pValue = pSL->Hdr.Entries[CurItem].Value;

            // Move the last item in the list into the open place.
            Temp = pSL->Hdr.HeadOffset + pSL->Hdr.NEntries - 1;
            if (Temp >= pSL->Hdr.MaxEntries)
                Temp -= pSL->Hdr.MaxEntries;
            pSL->Hdr.Entries[CurItem] = pSL->Hdr.Entries[Temp];

            pSL->Hdr.NEntries--;
            pSL->Hdr.CurrOffset = 0xFFFFFFFF;  // Reset iteration.
            return;
        }

        // Advance CurItem, wrapping at end of list.
        CurItem++;
        if (CurItem == pSL->Hdr.MaxEntries)
            CurItem = 0;
    }

    if (pValue != NULL)
        *pValue = NULL;
}



/*
 * RemoveFirst
 *   Reads and removes the 1st item from the list. Returns the value removed,
 *     or zero if the list is empty.
 */
void SListRemoveFirst(PSList pSL, UINT_PTR *pKey, void **pValue)
{
    if (pSL->Hdr.NEntries < 1) {
        *pKey = 0;
        *pValue = NULL;
        return;
    }

    // Reset iteration.
    pSL->Hdr.CurrOffset = 0xFFFFFFFF;
    
    *pKey = (pSL->Hdr.Entries + pSL->Hdr.HeadOffset)->Key;
    *pValue = (pSL->Hdr.Entries + pSL->Hdr.HeadOffset)->Value;
    pSL->Hdr.NEntries--;
    pSL->Hdr.HeadOffset++;
    if (pSL->Hdr.HeadOffset >= pSL->Hdr.MaxEntries)
        pSL->Hdr.HeadOffset = 0;
}



/*
 * GetByKey
 *   Searches the list and returns in *pValue the value corresponding to the
 *     given key. If the key is not present, returns FALSE and NULL in
 *     *pValue. If key is found, reurns nonzero.
 */
BOOLEAN SListGetByKey(PSList pSL, UINT_PTR Key, void **pValue)
{
    unsigned i, Temp;
    _SListNode *pItem;

    // Find Key in the list.
    pItem = pSL->Hdr.Entries + pSL->Hdr.HeadOffset;
    for (i = 0; i < pSL->Hdr.NEntries; i++) {
        if (Key == pItem->Key) {
            // Found it; set *pValue and return.
            *pValue = pItem->Value;
            return TRUE;
        }

        // Advance pItem, wrapping at end of list.
        pItem++;
        if ((unsigned)(pItem - pSL->Hdr.Entries) >= pSL->Hdr.MaxEntries)
            pItem = pSL->Hdr.Entries;
    }

    *pValue = NULL;
    return FALSE;
}



#ifdef NotUsed
/*
 * RemoveLast
 *   Removes the value at the end of the lst and returns it. If the list is
 *   empty, returns zero.
 */
void SListRemoveLast(PSList pSL, UINT_PTR *pKey, void **pValue)
{
    unsigned Temp;

    if (pSL->Hdr.NEntries < 1) {
        *pKey = 0;
        *pValue = NULL;
        return;
    }

    // Reset iteration.
    pSL->Hdr.CurrOffset = 0xFFFFFFFF;
    
    pSL->Hdr.NEntries--;
    Temp = pSL->Hdr.HeadOffset + pSL->Hdr.NEntries - 1;
    if (Temp >= pSL->Hdr.MaxEntries)
        Temp -= pSL->Hdr.MaxEntries;

    *pKey = (pSL->Hdr.Entries + Temp)->Key;
    *pValue = (pSL->Hdr.Entries + Temp)->Value;
}
#endif  // NotUsed



/*
 * Iterate
 *   Iterates through the items of a list. CurrOffset is used as a current
 *   iteration pointer, so this function can be called in a loop. Returns
 *   FALSE if the iteration has completed, nonzero if the iteration continues
 *   (and *pKey is valid).
 */
BOOLEAN SListIterate(PSList pSL, UINT_PTR *pKey, void **pValue)
{
    unsigned Temp;

    if (pSL->Hdr.NEntries >= 1) {
        if (pSL->Hdr.CurrOffset != 0xFFFFFFFF) {
            pSL->Hdr.CurrOffset++;
            if (pSL->Hdr.CurrOffset >= pSL->Hdr.NEntries) {
                // Reset the iterator.
                pSL->Hdr.CurrOffset = 0xFFFFFFFF;
                return FALSE;
            }
        }
        else {
            // Start from the beginning.
            pSL->Hdr.CurrOffset = 0;
        }

        Temp = pSL->Hdr.CurrOffset + pSL->Hdr.HeadOffset;
        if (Temp >= pSL->Hdr.MaxEntries)
            Temp -= pSL->Hdr.MaxEntries;

        *pKey = pSL->Hdr.Entries[Temp].Key;
        *pValue = pSL->Hdr.Entries[Temp].Value;
        
        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\pdmcs\mcsioctl.c ===
/* (C) 1997-2000 Microsoft Corp.
 *
 * file   : MCSIoctl.c
 * author : Erik Mavrinac
 *
 * description: MCS API calls received from MCSMUX through ICA stack IOCTLs
 *   and returned through ICA virtual channel inputs. These entry points
 *   simply provide an IOCTL translation layer for the kernel-mode API.
 *   ONLY MCSMUX should make these calls.
 */

#include "PreComp.h"
#pragma hdrstop

#include <MCSImpl.h>


/*
 * Prototypes for forward references for locally-defined functions.
 */

NTSTATUS AttachUserRequestFunc(PDomain, PSD_IOCTL);
NTSTATUS DetachUserRequestFunc(PDomain, PSD_IOCTL);
NTSTATUS ChannelJoinRequestFunc(PDomain, PSD_IOCTL);
NTSTATUS ChannelLeaveRequestFunc(PDomain, PSD_IOCTL);
NTSTATUS SendDataRequestFunc(PDomain, PSD_IOCTL);
NTSTATUS ConnectProviderResponseFunc(PDomain, PSD_IOCTL);
NTSTATUS DisconnectProviderRequestFunc(PDomain, PSD_IOCTL);
NTSTATUS T120StartFunc(PDomain, PSD_IOCTL);



/*
 * Globals
 */

// Table of function entry points for ChannelWrite() request calls.
// These entry points correspond to request defines in MCSIOCTL.h.
// NULL means unsupported, which will be handled by dispatch code in
//   PdChannelWrite() in PDAPI.c.
const PT120RequestFunc g_T120RequestDispatch[] =
{
    AttachUserRequestFunc,
    DetachUserRequestFunc,
    ChannelJoinRequestFunc,
    ChannelLeaveRequestFunc,
    SendDataRequestFunc,      // Handles both uniform and regular.
    SendDataRequestFunc,      // Handles both uniform and regular.
    NULL,                      // MCS_CHANNEL_CONVENE_REQUEST unsupported.
    NULL,                      // MCS_CHANNEL_DISBAND_REQUEST unsupported.
    NULL,                      // MCS_CHANNEL_ADMIT_REQUEST unsupported.
    NULL,                      // MCS_CHANNEL_EXPEL_REQUEST unsupported.
    NULL,                      // MCS_TOKEN_GRAB_REQUEST unsupported.
    NULL,                      // MCS_TOKEN_INHIBIT_REQUEST unsupported.
    NULL,                      // MCS_TOKEN_GIVE_REQUEST unsupported.
    NULL,                      // MCS_TOKEN_GIVE_RESPONSE unsupported.
    NULL,                      // MCS_TOKEN_PLEASE_REQUEST unsupported.
    NULL,                      // MCS_TOKEN_RELEASE_REQUEST unsupported.
    NULL,                      // MCS_TOKEN_TEST_REQUEST unsupported.
    NULL,                      // MCS_CONNECT_PROVIDER_REQUEST unsupported.
    ConnectProviderResponseFunc,
    DisconnectProviderRequestFunc,
    T120StartFunc,
};



/*
 * Main callback for user attachment indications/confirms from kernel mode API.
 *   Translate and send to user mode.
 */

void __stdcall UserModeUserCallback(
        UserHandle hUser,
        unsigned   Message,
        void       *Params,
        void       *UserDefined)
{
    BYTE *pData;
    unsigned DataLength;
    NTSTATUS Status;
    UserAttachment *pUA;

    pUA = (UserAttachment *)hUser;
    
    //MCS FUTURE: Handle all callbacks. Right now we support only those
    //   we know are going to pass by.
    
    switch (Message) {
        case MCS_DETACH_USER_INDICATION: {
            DetachUserIndication *pDUin;
            DetachUserIndicationIoctl DUinIoctl;

            pDUin = (DetachUserIndication *)Params;

            DUinIoctl.Header.Type = Message;
            DUinIoctl.Header.hUser = hUser;
            DUinIoctl.UserDefined = UserDefined;
            DUinIoctl.DUin = *pDUin;

            pData = (BYTE *)&DUinIoctl;
            DataLength = sizeof(DetachUserIndicationIoctl);
            
            // Send data below.
            break;
        }

        default:
            ErrOut1(pUA->pDomain->pContext, "UserModeUserCallback: "
                    "Unsupported callback %d received", Message);
            return;
    }

    // Send the data to user mode.
    ASSERT(pUA->pDomain->bChannelBound);
    Status = IcaChannelInput(pUA->pDomain->pContext, Channel_Virtual,
           Virtual_T120ChannelNum, NULL, pData, DataLength);
    if (!NT_SUCCESS(Status)) {
        ErrOut2(pUA->pDomain->pContext, "UserModeUserCallback: "
                "Error %X on IcaChannelInput() for callback %d",
                Status, Message);
        // Ignore errors here. This should not happen unless the stack is
        //   going down.
    }
}



/*
 * Handles MCS kernel API callbacks for MCS send-data indications.
 * Translates into user mode call.
 */

BOOLEAN __fastcall UserModeSendDataCallback(
        BYTE          *pData,
        unsigned      DataLength,
        void          *UserDefined,
        UserHandle    hUser,
        BOOLEAN       bUniform,
        ChannelHandle hChannel,
        MCSPriority   Priority,
        UserID        SenderID,
        Segmentation  Segmentation)
{
    BOOLEAN result = TRUE;
    NTSTATUS Status;
    UserAttachment *pUA;
    SendDataIndicationIoctl SDinIoctl;

    pUA = (UserAttachment *)hUser;

    //MCS FUTURE: Need to alloc data and copy or, better yet,
    //  utilize a header at the beginning of the input buffer
    //  to send this upward.

#if 0
    SDinIoctl.Header.Type = bUniform ? MCS_UNIFORM_SEND_DATA_INDICATION :
            MCS_SEND_DATA_INDICATION;
    SDinIoctl.Header.hUser = hUser;
    SDinIoctl.UserDefined = UserDefined;
    SDinIoctl.hChannel = hChannel;
    SDinIoctl.SenderID = SenderID;
    SDinIoctl.Priority = Priority;
    SDinIoctl.Segmentation = Segmentation;
    SDinIoctl.DataLength = DataLength;

    // Send the data to user mode.
    ASSERT(pUA->pDomain->bChannelBound);
    Status = IcaChannelInput(pUA->pDomain->pContext, Channel_Virtual,
           Virtual_T120ChannelNum, NULL, pData, DataLength);
    if (!NT_SUCCESS(Status)) {
        ErrOut2(pUA->pDomain->pContext, "UserModeUserCallback: "
                "Error %X on IcaChannelInput() for callback %d",
                Status, Message);
        // Ignore errors here. This should not happen unless the stack is
        //   going down.
    }
#endif

    ErrOut(pUA->pDomain->pContext, "UserModeUserCallback: "
            "Unsupported send-data indication received, code incomplete");
    ASSERT(FALSE);
    return result;
}



/*
 * Handles an MCS attach-user request from user mode. Translates the ioctl
 *   into a kernel-mode MCS API call.
 */

NTSTATUS AttachUserRequestFunc(Domain *pDomain, PSD_IOCTL pSdIoctl)
{
    AttachUserReturnIoctl *pAUrt;
    AttachUserRequestIoctl *pAUrq;

    ASSERT(pSdIoctl->InputBufferLength == sizeof(AttachUserRequestIoctl));
    ASSERT(pSdIoctl->OutputBufferLength == sizeof(AttachUserReturnIoctl));
    pAUrq = (AttachUserRequestIoctl *) pSdIoctl->InputBuffer;
    pAUrt = (AttachUserReturnIoctl *) pSdIoctl->OutputBuffer;
    ASSERT(pAUrq->Header.Type == MCS_ATTACH_USER_REQUEST);

    // Call kernel-mode API which will handle creating local data and,
    //   if necessary, will forward the request to the top provider.
    // Provide a kernel-mode callback that will package the data and send it
    //   to the appropriate user.
    pAUrt->MCSErr = MCSAttachUserRequest((DomainHandle)pDomain,
            UserModeUserCallback, UserModeSendDataCallback,
            pAUrq->UserDefined, &pAUrt->hUser, &pAUrt->MaxSendSize,
            &pAUrt->bCompleted);
    pAUrt->UserID = ((UserAttachment *)pAUrt->hUser)->UserID;

    pSdIoctl->BytesReturned = sizeof(AttachUserReturnIoctl);
    
    // Return STATUS_SUCCESS even if there was an error code returned --
    //   the MCSError code is returned above too.
    return STATUS_SUCCESS;
}



/*
 * Handles an MCS detach-user request channel write. There is no callback for
 *   this request, the user attachment is considered destroyed upon return.
 */
NTSTATUS DetachUserRequestFunc(PDomain pDomain, PSD_IOCTL pSdIoctl)
{
    MCSError *pMCSErr;
    DetachUserRequestIoctl *pDUrq;

    ASSERT(pSdIoctl->InputBufferLength == sizeof(DetachUserRequestIoctl));
    ASSERT(pSdIoctl->OutputBufferLength == sizeof(MCSError));
    pDUrq = (DetachUserRequestIoctl *)pSdIoctl->InputBuffer;
    pMCSErr = (MCSError *)pSdIoctl->OutputBuffer;
    ASSERT(pDUrq->Header.Type == MCS_DETACH_USER_REQUEST);

    // Call the kernel-mode API.
    *pMCSErr = MCSDetachUserRequest(pDUrq->Header.hUser);
    
    pSdIoctl->BytesReturned = sizeof(MCSError);
    
    // Always return STATUS_SUCCESS.
    return STATUS_SUCCESS;
}



/*
 * Channel join - ChannelWrite() request.
 */
NTSTATUS ChannelJoinRequestFunc(PDomain pDomain, PSD_IOCTL pSdIoctl)
{
    ChannelJoinRequestIoctl *pCJrq;
    ChannelJoinReturnIoctl *pCJrt;

    ASSERT(pSdIoctl->InputBufferLength == sizeof(ChannelJoinRequestIoctl));
    ASSERT(pSdIoctl->OutputBufferLength == sizeof(ChannelJoinReturnIoctl));
    pCJrq = (ChannelJoinRequestIoctl *) pSdIoctl->InputBuffer;
    pCJrt = (ChannelJoinReturnIoctl *) pSdIoctl->OutputBuffer;
    ASSERT(pCJrq->Header.Type == MCS_CHANNEL_JOIN_REQUEST);

    // Make the call to the kernel mode API.
    pCJrt->MCSErr = MCSChannelJoinRequest(pCJrq->Header.hUser,
            pCJrq->ChannelID, &pCJrt->hChannel, &pCJrt->bCompleted);
    pCJrt->ChannelID = ((MCSChannel *)pCJrt->hChannel)->ID;

    pSdIoctl->BytesReturned = sizeof(ChannelJoinReturnIoctl);
    
    // Always return STATUS_SUCCESS.
    return STATUS_SUCCESS;
}



/*
 * Channel leave - ChannelWrite() request.
 */
NTSTATUS ChannelLeaveRequestFunc(PDomain pDomain, PSD_IOCTL pSdIoctl)
{
    MCSError *pMCSErr;
    ChannelLeaveRequestIoctl *pCLrq;

    ASSERT(pSdIoctl->InputBufferLength == sizeof(ChannelLeaveRequestIoctl));
    ASSERT(pSdIoctl->OutputBufferLength == sizeof(MCSError));
    pCLrq = (ChannelLeaveRequestIoctl *)pSdIoctl->InputBuffer;
    pMCSErr = (MCSError *)pSdIoctl->OutputBuffer;
    ASSERT(pCLrq->Header.Type == MCS_CHANNEL_LEAVE_REQUEST);

    *pMCSErr = MCSChannelLeaveRequest(pCLrq->Header.hUser, pCLrq->hChannel);

    pSdIoctl->BytesReturned = sizeof(MCSError);
    
    // Always return STATUS_SUCCESS.
    return STATUS_SUCCESS;
}



/*
 * Send data - handles both uniform and regular sends.
 * Data is packed immediately after the SendDataRequestIoctl struct.
 *   No profixes or suffixes are needed.
 */
NTSTATUS SendDataRequestFunc(PDomain pDomain, PSD_IOCTL pSdIoctl)
{
    POUTBUF pOutBuf;
    MCSError *pMCSErr;
    NTSTATUS Status;
    UserAttachment *pUA;
    SendDataRequestIoctl *pSDrq;

    ASSERT(pSdIoctl->InputBufferLength >= sizeof(SendDataRequestIoctl));
    ASSERT(pSdIoctl->OutputBufferLength == sizeof(MCSError));
    pSDrq = (SendDataRequestIoctl *)pSdIoctl->InputBuffer;
    pMCSErr = (MCSError *)pSdIoctl->OutputBuffer;
    ASSERT(pSDrq->Header.Type == MCS_SEND_DATA_REQUEST ||
            pSDrq->Header.Type == MCS_UNIFORM_SEND_DATA_REQUEST);
    ASSERT(pSdIoctl->InputBufferLength == (sizeof(SendDataRequestIoctl) +
            pSDrq->DataLength));
    
#if DBG    
    // Get pUA for tracing.
    pUA = (UserAttachment *)pSDrq->Header.hUser;
#endif

    // Allocate an OutBuf to emulate a kernel-mode caller.
    Status = IcaBufferAlloc(pDomain->pContext, TRUE, TRUE,
            (SendDataReqPrefixBytes + pSDrq->DataLength +
            SendDataReqSuffixBytes), NULL, &pOutBuf);
    if (Status != STATUS_SUCCESS) {
        ErrOut(pUA->pDomain->pContext, "Could not allocate an OutBuf for a "
                "send-data request sent from user mode");
        return Status;
    }

    // Copy the user-mode memory to the kernel outbuf.
    memcpy(pOutBuf->pBuffer + SendDataReqPrefixBytes,
            &pSdIoctl->InputBuffer + sizeof(SendDataRequestIoctl),
            pSDrq->DataLength);
    
    // Set OutBuf params according to needs of API.
    pOutBuf->ByteCount = pSDrq->DataLength;
    pOutBuf->pBuffer += SendDataReqPrefixBytes;

    // Call the kernel-mode API.
    *pMCSErr = MCSSendDataRequest(pSDrq->Header.hUser, pSDrq->hChannel,
            pSDrq->RequestType, 0, pSDrq->Priority, pSDrq->Segmentation,
            pOutBuf);

    pSdIoctl->BytesReturned = sizeof(MCSError);
    
    // Always return STATUS_SUCCESS.
    return STATUS_SUCCESS;
}



/*
 * Connect provider response - ChannelWrite() request. Requires filler bytes
 *   in MCSConnectProviderResponseIoctl to make sure we use at least 54 bytes
 *   for the struct so we can reuse the OutBuf here. User data must start
 *   at (pSdIoctl->pBuffer + sizeof(MCSConnectProviderResponseIoctl)).
 */

NTSTATUS ConnectProviderResponseFunc(
        PDomain pDomain,
        PSD_IOCTL pSdIoctl)
{
    POUTBUF pOutBuf;
    NTSTATUS Status;
    ConnectProviderResponseIoctl *pCPrs;

    ASSERT(pSdIoctl->InputBufferLength ==
            sizeof(ConnectProviderResponseIoctl));
    pCPrs = (ConnectProviderResponseIoctl *)pSdIoctl->InputBuffer;
    ASSERT(pCPrs->Header.Type == MCS_CONNECT_PROVIDER_RESPONSE);

    // Verify that we are actually waiting for a CP response.
    if (pDomain->State != State_ConnectProvIndPending) {
        ErrOut(pDomain->pContext, "Connect-provider response call received, "
                "we are in wrong state, ignoring");
        return STATUS_INVALID_DOMAIN_STATE;
    }

    // Alloc OutBuf for sending PDU.
    // This allocation is vital to the session and must succeed.
    do {
        Status = IcaBufferAlloc(pDomain->pContext, FALSE, TRUE,
                ConnectResponseHeaderSize + pCPrs->UserDataLength, NULL,
                &pOutBuf);
        if (Status != STATUS_SUCCESS)
            ErrOut(pDomain->pContext, "Could not allocate an OutBuf for a "
                    "connect-response PDU, retrying");
    } while (Status != STATUS_SUCCESS);

    // Encode PDU header. Param 2, the called connect ID, does not need to be
    //   anything special because we do not allow extra sockets to be opened
    //   for other data priorities.
    CreateConnectResponseHeader(pDomain->pContext, pCPrs->Result, 0,
            &pDomain->DomParams, pCPrs->UserDataLength, pOutBuf->pBuffer,
            &pOutBuf->ByteCount);

    // Copy the user data after the header.
    RtlCopyMemory(pOutBuf->pBuffer + pOutBuf->ByteCount, pCPrs->pUserData,
            pCPrs->UserDataLength);
    pOutBuf->ByteCount += pCPrs->UserDataLength;

    // Send the new PDU OutBuf down to the TD for sending out.
    //MCS FUTURE: Needs to change for multiple connections.
    Status = SendOutBuf(pDomain, pOutBuf);
    if (!NT_SUCCESS(Status)) {
        ErrOut(pDomain->pContext, "Could not send connect-response PDU OutBuf "
                "to TD");
        // Ignore errors here -- this should only occur if stack is going down.
        return Status;
    }

    // Transition state depending on Result.
    if (pCPrs->Result == RESULT_SUCCESSFUL) {
        pDomain->State = State_MCS_Connected;
    }
    else {
        TraceOut(pDomain->pContext, "ConnectProviderRespFunc(): Node "
                "controller returned error in response, destroying call "
                "data");
        pDomain->State = State_Disconnected;
        
        // Detach any users that attached during domain setup.
        DisconnectProvider(pDomain, TRUE, REASON_PROVIDER_INITIATED);
    }

    return STATUS_SUCCESS;
}



/*
 * Disconnect provider - ChannelWrite() request.
 * This handles both the case where a disconnect is performed on the local
 *   "connection" (i.e. pDPrq->hConn == NULL), and a specific remote
 *   connection (pDPrq->hConn != NULL)/
 * MCS FUTURE: Change for multiple connections.
 */

NTSTATUS DisconnectProviderRequestFunc(
        PDomain pDomain,
        PSD_IOCTL pSdIoctl)
{
    NTSTATUS Status;
    DisconnectProviderRequestIoctl *pDPrq;
    LONG refs;

    TraceOut1(pDomain->pContext, "DisconnectProviderRequestFunc(): Entry, "
            "pDomain=%X", pDomain);

    ASSERT(pSdIoctl->InputBufferLength ==
            sizeof(DisconnectProviderRequestIoctl));
    pDPrq = (DisconnectProviderRequestIoctl *)pSdIoctl->InputBuffer;
    ASSERT(pDPrq->Header.hUser == NULL);
    ASSERT(pDPrq->Header.Type == MCS_DISCONNECT_PROVIDER_REQUEST);

    // Send DPum PDU if we can still send data.
    if ((pDomain->State == State_MCS_Connected) && pDomain->bCanSendData) {
        POUTBUF pOutBuf;

        // Alloc OutBuf for sending DPum PDU.
        Status = IcaBufferAlloc(pDomain->pContext, FALSE, TRUE, DPumPDUSize,
                NULL, &pOutBuf);
        if (Status != STATUS_SUCCESS) {
            ErrOut(pDomain->pContext, "Could not allocate an OutBuf for a "
                    "DPum PDU, cannot send");
            // We ignore problems sending the DPum PDU since we are going down
            //   anyway.
        }
        else {
            SD_SYNCWRITE SdSyncWrite;

            CreateDisconnectProviderUlt(pDPrq->Reason, pOutBuf->pBuffer);
            pOutBuf->ByteCount = DPumPDUSize;

            TraceOut(pDomain->pContext, "DisconnectProviderRequestFunc(): "
                    "Sending DPum PDU");

            // Send the PDU to the transport.
            // MCS FUTURE: Assuming only one transport and only one
            //   connection.
            Status = SendOutBuf(pDomain, pOutBuf);
            if (!NT_SUCCESS(Status))
                // We ignore problems sending the DPum PDU since we are going
                //   down anyway.
                WarnOut(pDomain->pContext, "Could not send DPum PDU OutBuf "
                        "downward");

            // The call to IcaCallNextDriver unlocks our stack, allowing a WD_Close to
            // go through.  WD_Close can call MCSCleanup which will free pDomain,
            // and NULL out pTSWd->hDomainKernel.  Because pDomain may no longer be valid,
            // it is not good enough to check pDomain->StatusDead here!  To keep this
            // fix localized, we created a pseudo-RefCount to protect the exact cases
            // we saw this bug hit in stress.  A bug will be opened for Longhorn to
            // make this RefCount generic so that ALL calls to IcaWaitForSingleObject (etc)
            // are protected.
            PDomainAddRef(pDomain);

            // Flush the transport driver.  Note that this call can block and 
            // release the stack lock
            Status = IcaCallNextDriver(pDomain->pContext, SD$SYNCWRITE,
                    &SdSyncWrite);

            refs = PDomainRelease(pDomain);
            if (0 == refs)
            {
                // We ignore problems since we are going down anyway.
                Status = STATUS_SUCCESS;
                goto DC_EXIT_POINT;
            }

            if (!NT_SUCCESS(Status))                
                // We ignore problems since we are going down anyway.
                WarnOut(pDomain->pContext, "Could not sync transport after "
                        "DPum");

            // If the client has not already responded with a FIN (while we
            // were blocked on the synchronous write) wait until we see it or time
            // out trying
            if (pDomain->bCanSendData) {
                pDomain->pBrokenEvent = ExAllocatePool(NonPagedPool, sizeof(KEVENT));
                if (pDomain->pBrokenEvent) {
                    KeInitializeEvent(pDomain->pBrokenEvent, NotificationEvent, FALSE);

                    PDomainAddRef(pDomain);
    
                    IcaWaitForSingleObject(pDomain->pContext, 
                                           pDomain->pBrokenEvent,
                                           5000);

                    refs = PDomainRelease(pDomain);
                    if (0 == refs)
                    {
                        // We ignore problems since we are going down anyway.
                        Status = STATUS_SUCCESS;
                        goto DC_EXIT_POINT;
                    }

                    ExFreePool(pDomain->pBrokenEvent);
                    pDomain->pBrokenEvent = NULL;
                }
            }
        }
    }

    // Internal disconnection code.
    DisconnectProvider(pDomain, (BOOLEAN)(pDPrq->hConn == NULL),
            pDPrq->Reason);


    Status = STATUS_SUCCESS;

    // Different behavior for different connections.
    if (pDPrq->hConn == NULL) {
        // This call should only come in when the stack is going away.
        // So, prevent further data sends to transport and further channel
        //   inputs to user mode.
        pDomain->bCanSendData = FALSE;
        pDomain->bChannelBound = FALSE;

        // The domain is considered dead now. Domain struct cleanup will
        //   occur during stack driver cleanup at MCSCleanup().
                
//      Status = IcaChannelInput(pDomain->pContext, Channel_Virtual,
//                               Virtual_T120ChannelNum, NULL, "F", 1);
   }

DC_EXIT_POINT:
    return Status;

}



NTSTATUS T120StartFunc(Domain *pDomain, PSD_IOCTL pSdIoctl)
{
    NTSTATUS Status;
    DisconnectProviderIndicationIoctl DPin;

    pDomain->bT120StartReceived = TRUE;

    // This is to handle a timing window where the stack has just come up
    //   but a DPum from a quickly-disconnected client has already arrived.
    if (pDomain->bDPumReceivedNotInput) {
        // We should have received a QUERY_VIRTUAL_BINDINGS ioctl by this time.
        ASSERT(pDomain->bChannelBound);

        // Fill out disconnect-provider indication for the node controller.
        DPin.Header.hUser = NULL;  // Node controller.
        DPin.Header.Type = MCS_DISCONNECT_PROVIDER_INDICATION;
        DPin.hConn = NULL;

        // Reason is a 3-bit field starting at bit 1 of the 1st byte.
        DPin.Reason = pDomain->DelayedDPumReason;

        // Send the DPin to the node controller channel.
        TraceOut(pDomain->pContext, "HandleDisconnProvUlt(): Sending "
                "DISCONNECT_PROV_IND upward");
        Status = IcaChannelInput(pDomain->pContext, Channel_Virtual,
                Virtual_T120ChannelNum, NULL, (BYTE *)&DPin, sizeof(DPin));
        if (!NT_SUCCESS(Status)) {
            // We ignore the error -- if the stack is coming down, the link
            //   may have been broken, so this is not a major concern.
            WarnOut1(pDomain->pContext, "T120StartFunc(): "
                    "Could not send DISCONN_PROV_IND to user mode, "
                    "status=%X, ignoring error", Status);
        }

        // In this case we have to ignore the fact that we may have a
        //   X.224 connect already pending.
        return STATUS_SUCCESS;
    }

    pDomain->bCanSendData = TRUE;

    // If an X.224 connect has already been processed, and we have bound the
    //   virtual channels, send the X.224 response.
    if (pDomain->bChannelBound && pDomain->State == State_X224_Requesting) {
        TraceOut(pDomain->pContext, "T120StartFunc(): Sending X.224 response");
        Status = SendX224Confirm(pDomain);
        // Ignore errors. Failure to send should occur only when the stack is
        //   going down.
    }
    else {
        WarnOut(pDomain->pContext,
                "T120StartFunc(): Domain state not State_X224_Requesting, "
                "awaiting X.224 connect");
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\pdmcs\mcskapi.c ===
/* (C) 1997-2000 Microsoft Corp.
 *
 * file   : MCSKAPI.c
 * author : Erik Mavrinac
 *
 * description: Implementation of the kernel mode MCS API entry points.
 */

#include "precomp.h"
#pragma hdrstop

#include <MCSImpl.h>


/*
 * Main API entry point for the attach-user request primitive.
 * UserCallback and SDCallback must be non-NULL for external callers,
 *   but there is no error checking or asserting done here to that
 *   HandleAttachUserRequest() in DomPDU.c can call this API internally.
 */
MCSError APIENTRY MCSAttachUserRequest(
        DomainHandle        hDomain,
        MCSUserCallback     UserCallback,
        MCSSendDataCallback SDCallback,
        void                *UserDefined,
        UserHandle          *phUser,
        unsigned            *pMaxSendSize,
        BOOLEAN             *pbCompleted)
{
    NTSTATUS Status;
    MCSError MCSErr = MCS_NO_ERROR;
    Domain *pDomain;
    unsigned i;
    MCSChannel *pMCSChannel;
    UserAttachment *pUA;

    pDomain = (Domain *)hDomain;
    
    TraceOut(pDomain->pContext, "AttachUserRequest() entry");

    // Start with incomplete state.
    *pbCompleted = FALSE;
    
    // Check against domain max users param.
    if (SListGetEntries(&pDomain->UserAttachmentList) ==
            pDomain->DomParams.MaxUsers) {
        ErrOut(pDomain->pContext, "AttachUserReq(): Too many users");
        return MCS_TOO_MANY_USERS;
    }

    // Allocate a UserAttachment. Try the prealloc list first.
    pUA = NULL;
    for (i = 0; i < NumPreallocUA; i++) {
        if (!pDomain->PreallocUA[i].bInUse) {
            pUA = &pDomain->PreallocUA[i];
            pUA->bInUse = TRUE;
        }
    }
    if (pUA == NULL) {
        pUA = ExAllocatePoolWithTag(PagedPool, sizeof(UserAttachment),
                MCS_POOL_TAG);
        if (pUA != NULL)
            pUA->bPreallocated = FALSE;
    }
    if (pUA != NULL) {
        // Store info in UA.
        pUA->UserDefined = UserDefined;
        SListInit(&pUA->JoinedChannelList, DefaultNumChannels);
        pUA->pDomain = pDomain;
        pUA->Callback = UserCallback;
        pUA->SDCallback = SDCallback;
    }
    else {
        ErrOut(pDomain->pContext, "Could not alloc a UserAttachment");
        return MCS_ALLOCATION_FAILURE;
    }

    // If all these are NULL, it must be a remote caller since there is no way
    // to deliver any kind of indication or data
    if (UserDefined == NULL && UserCallback == NULL && SDCallback == NULL)
        pUA->bLocal = FALSE;
    else
        pUA->bLocal = TRUE;

    // Allocate new UserID.
    pUA->UserID = GetNewDynamicChannel(pDomain);
    if (pUA->UserID == 0) {
        ErrOut(pDomain->pContext, "AttachUser: Unable to get new dyn channel");
        MCSErr = MCS_TOO_MANY_CHANNELS;
        goto PostAllocUA;
    }

    // Allocate a Channel. Try the prealloc list first.
    pMCSChannel = NULL;
    for (i = 0; i < NumPreallocChannel; i++) {
        if (!pDomain->PreallocChannel[i].bInUse) {
            pMCSChannel = &pDomain->PreallocChannel[i];
            pMCSChannel->bInUse = TRUE;
        }
    }
    if (pMCSChannel == NULL) {
        pMCSChannel = ExAllocatePoolWithTag(PagedPool, sizeof(MCSChannel),
                MCS_POOL_TAG);
        if (pMCSChannel != NULL)
            pMCSChannel->bPreallocated = FALSE;
    }
    if (pMCSChannel != NULL) {
        pMCSChannel->Type = Channel_UserID;
        pMCSChannel->ID = pUA->UserID;
        SListInit(&pMCSChannel->UserList, DefaultNumChannels);
    }
    else {
        ErrOut(pDomain->pContext, "AttachUser: Unable to alloc channel");
        MCSErr = MCS_ALLOCATION_FAILURE;
        goto PostAllocUA;
    }

    if (SListAppend(&pDomain->ChannelList, pMCSChannel->ID, pMCSChannel)) {
        // Add user attachment to attachment list.
        if (SListAppend(&pDomain->UserAttachmentList, (UINT_PTR)pUA, pUA)) {
            // Return the hUser and MaxSendSize.
            *phUser = pUA;
            *pMaxSendSize = pDomain->MaxSendSize;


        }
        else {
            ErrOut(pDomain->pContext, "Unable to add user attachment to "
                    "attachment list");
            MCSErr = MCS_ALLOCATION_FAILURE;
            goto PostAddChannel;
        }
    }
    else {
        ErrOut(pDomain->pContext, "AttachUser: Could not add channel "
                "to main list");
        MCSErr = MCS_ALLOCATION_FAILURE;
        goto PostAllocChannel;
    }
    
    if (pDomain->bTopProvider) {
        // The action is complete, there is no need for a callback.
        *pbCompleted = TRUE;
    }
    else {
        //MCS FUTURE: We have created the local structures, now forward
        //   the request toward the top provider and return.
        // Note that *pbCompleted is FALSE meaning there is a callback pending.        
    }
    
    return MCS_NO_ERROR;


// Error handling.
PostAddChannel:
    SListRemove(&pDomain->ChannelList, pMCSChannel->ID, NULL);

PostAllocChannel:
    SListDestroy(&pMCSChannel->UserList);
    if (pMCSChannel->bPreallocated)
        pMCSChannel->bInUse = FALSE;
    else
        ExFreePool(pMCSChannel);

PostAllocUA:
    SListDestroy(&pUA->JoinedChannelList);
    if (pUA->bPreallocated)
        pUA->bInUse = FALSE;
    else
        ExFreePool(pUA);

    return MCSErr;
}


/****************************************************************************/
// MCSDetachUserRequest
//
// Detach-user kernel API.
/****************************************************************************/
MCSError APIENTRY MCSDetachUserRequest(UserHandle hUser)
{
    MCSError rc;
    NTSTATUS Status;
    UserAttachment *pUA;
    POUTBUF pOutBuf;

    // hUser is pointer to user obj.
    ASSERT(hUser != NULL);
    pUA = (UserAttachment *)hUser;

    TraceOut1(pUA->pDomain->pContext, "DetachUserRequest() entry, hUser=%X",
            hUser);

    // Allocate an OutBuf for sending a DUin.
    Status = IcaBufferAlloc(pUA->pDomain->pContext, FALSE, TRUE,
            DUinPDUSize(1), NULL, &pOutBuf);
    if (Status == STATUS_SUCCESS) {
        // Send DUin to all downlevel connections.
        // MCS FUTURE: Since there is only one downlevel attachment just send it.
        //   This will need to change to support multiple downlevel nodes.
        CreateDetachUserInd(REASON_USER_REQUESTED, 1, &pUA->UserID,
                pOutBuf->pBuffer);
        pOutBuf->ByteCount = DUinPDUSize(1);

        Status = SendOutBuf(pUA->pDomain, pOutBuf);
        if (NT_SUCCESS(Status)) {
            // Call central code in MCSCore.c.
            rc = DetachUser(pUA->pDomain, hUser, REASON_USER_REQUESTED,
                    FALSE);
        }
        else {
            ErrOut(pUA->pDomain->pContext, "Problem sending DUin PDU to TD");
            rc = MCS_NETWORK_ERROR;
        }
    }
    else {
        ErrOut(pUA->pDomain->pContext, "Could not allocate an OutBuf for a "
                "DetachUser ind to a remote user");
        rc = MCS_ALLOCATION_FAILURE;
    }

    return rc;
}



UserID APIENTRY MCSGetUserIDFromHandle(UserHandle hUser)
{
    ASSERT(hUser != NULL);
    return ((UserAttachment *)hUser)->UserID;
}



MCSError APIENTRY MCSChannelJoinRequest(
        UserHandle    hUser,
        ChannelID     ChID,
        ChannelHandle *phChannel,
        BOOLEAN       *pbCompleted)
{
    ChannelID ChannelIDToJoin;
    MCSChannel *pMCSChannel, *pChannelValue;
    UserAttachment *pUA;

    ASSERT(hUser != NULL);
    pUA = (UserAttachment *)hUser;

    TraceOut1(pUA->pDomain->pContext, "ChannelJoinRequest() entry, hUser=%X\n",
            hUser);

    // Start with request incomplete.
    *pbCompleted = FALSE;
    
    // Look for channel.
    if (SListGetByKey(&pUA->pDomain->ChannelList, ChID, &pMCSChannel)) {
        // The channel exists in the main channel list. Determine actions
        //   by its type.
        
        ASSERT(pMCSChannel->ID == ChID);  // Consistency check.

        switch (pMCSChannel->Type) {
            case Channel_UserID:
                if (pMCSChannel->ID == ChID) {
                    // We will handle joining the user to the channel below.
                    ChannelIDToJoin = ChID;
                }
                else {
                    ErrOut(pUA->pDomain->pContext, "ChannelJoin: User "
                            "attempted to join UserID channel not its own");
                    return MCS_CANT_JOIN_OTHER_USER_CHANNEL;
                }
                
                break;

            case Channel_Static:
                //PASSTHRU
            case Channel_Assigned:
                // Assigned channels are like static channels when they exist.
                // We will handle below joining the user to the channel.
                ChannelIDToJoin = ChID;
                break;

            case Channel_Convened:
                //MCS FUTURE: Handle convened channels, incl. checking for
                //   whether a user is admitted to the channel.
                return MCS_COMMAND_NOT_SUPPORTED;

            default:
                // Shouldn't happen. Includes Channel_Unused.
                ErrOut(pUA->pDomain->pContext, "ChannelJoin: Channel to join "
                        "exists but is unknown type");
                ASSERT(FALSE);
                return MCS_ALLOCATION_FAILURE;
        }
    }
    
    else {
        // Channel did not already exist.
        
        int ChannelType;
        unsigned i;

        if (ChID > 1001) {
            // Not an assigned or static channel request. Error.
            ErrOut(pUA->pDomain->pContext, "ChannelJoin: Requested channel "
                    "is not static or assigned");
            return MCS_NO_SUCH_CHANNEL;
        }
        
        // Check against domain params.
        if (SListGetEntries(&pUA->pDomain->ChannelList) >
                pUA->pDomain->DomParams.MaxChannels) {
            ErrOut(pUA->pDomain->pContext,
                    "ChannelJoin: Too many channels already");
            return MCS_TOO_MANY_CHANNELS;
        }

        // Determine channel ID joined.
        if (ChID == 0) {
            ChannelIDToJoin = GetNewDynamicChannel(pUA->pDomain);
            if (ChannelIDToJoin == 0) {
                ErrOut(pUA->pDomain->pContext, "ChannelJoin: Unable to get "
                        "new dyn channel");
                return MCS_TOO_MANY_CHANNELS;
            }
            ChannelType = Channel_Assigned;
        }
        else {
            ChannelIDToJoin = ChID;  // Assume static.
            ChannelType = Channel_Static;
        }
        
        // Allocate, fill in, and add a new MCS channel with no UserIDs
        //   joined (yet). Try the prealloc list first.
        pMCSChannel = NULL;
        for (i = 0; i < NumPreallocChannel; i++) {
            if (!pUA->pDomain->PreallocChannel[i].bInUse) {
                pMCSChannel = &pUA->pDomain->PreallocChannel[i];
                pMCSChannel->bInUse = TRUE;
            }
        }
        if (pMCSChannel == NULL) {
            pMCSChannel = ExAllocatePoolWithTag(PagedPool, sizeof(MCSChannel),
                    MCS_POOL_TAG);
            if (pMCSChannel != NULL)
                pMCSChannel->bPreallocated = FALSE;
        }
        if (pMCSChannel != NULL) {
            pMCSChannel->ID = ChannelIDToJoin;
            pMCSChannel->Type = ChannelType;
            // pMCSChannel->UserList initialized below.
        }
        else {
            ErrOut(pUA->pDomain->pContext, "ChannelJoin: Could not allocate "
                    "a new channel");
            return MCS_ALLOCATION_FAILURE;
        }

        if (!SListAppend(&pUA->pDomain->ChannelList, (unsigned)ChannelIDToJoin,
                pMCSChannel)) {
            ErrOut(pUA->pDomain->pContext, "ChannelJoin: Could not add "
                    "channel to main list");
            if (pMCSChannel->bPreallocated)
                pMCSChannel->bInUse = FALSE;
            else
                ExFreePool(pMCSChannel);
            return MCS_ALLOCATION_FAILURE;
        }

        // Deferred for error handling above.
        SListInit(&pMCSChannel->UserList, DefaultNumUserAttachments);
    }

    // Check if this channel is already in the list, if already in, then we don't
    // add it to the lists again
    if (!SListGetByKey(&pUA->JoinedChannelList, (UINT_PTR)pMCSChannel, &pChannelValue)) {
        // Put channel into user's joined channel list.
        if (!SListAppend(&pUA->JoinedChannelList, (UINT_PTR)pMCSChannel,
                pMCSChannel)) {
            ErrOut(pUA->pDomain->pContext, "ChannelJoin: Could not add channel "
                    "to user channel list");
            return MCS_ALLOCATION_FAILURE;
        }
    
        // Put user into channel's joined user list.
        if (!SListAppend(&pMCSChannel->UserList, (UINT_PTR)pUA, pUA)) {
            ErrOut(pUA->pDomain->pContext, "ChannelJoin: Could not user to "
                    "channel user list");
            return MCS_ALLOCATION_FAILURE;
        }
    }
    else      {
        ErrOut(pUA->pDomain->pContext, "ChannelJoin: Duplicate channel detected");
        return MCS_DUPLICATE_CHANNEL;
    }

    if (pUA->pDomain->bTopProvider) {
        // The join is complete.
        *pbCompleted = TRUE;
    }
    else {
        //MCS FUTURE: The user is now joined locally and all lists are updated.
        // Send the channel join upward toward the top provider.
        // Remember that *pbCompleted is still FALSE here indicating that
        //   a future callback is to be expected when top provider responds.
    }
    
    *phChannel = pMCSChannel;
    
    return MCS_NO_ERROR;
}


MCSError APIENTRY MCSChannelLeaveRequest(
        UserHandle    hUser,
        ChannelHandle hChannel)
{
    BOOLEAN bChannelRemoved;
    
    ASSERT(hUser != NULL);
    TraceOut1(((UserAttachment *)hUser)->pDomain->pContext,
            "ChannelLeaveRequest() entry, hUser=%X", hUser);
    return ChannelLeave(hUser, hChannel, &bChannelRemoved);
}


ChannelID APIENTRY MCSGetChannelIDFromHandle(ChannelHandle hChannel)
{
    return ((MCSChannel *)hChannel)->ID;
}


// pOutBuf->pBuffer should point to the user data inside the OutBuf allocated
//   area. SendDataReqPrefixBytes must be present before this point, and
//   SendDataReqSuffixBytes must be allocated after the user data.
// pOutBuf->ByteCount should be the length of the user data.
// The OutBuf is not deallocated when an error occurs.
MCSError __fastcall MCSSendDataRequest(
        UserHandle      hUser,
        ChannelHandle   hChannel,
        DataRequestType RequestType,
        ChannelID       ChannelID,
        MCSPriority     Priority,
        Segmentation    Segmentation,
        POUTBUF         pOutBuf)
{
    BOOLEAN bAnyNonlocalSends;
    MCSError MCSErr;
    NTSTATUS Status;
    unsigned SavedIterationState;
    MCSChannel *pMCSChannel;
    SD_RAWWRITE SdWrite;
    UserAttachment *pUA, *pCurUA;

    ASSERT(hUser != NULL);
    pUA = (UserAttachment *)hUser;
    
//    TraceOut1(pUA->pDomain->pContext, "SendDataRequest() entry, hUser=%X",
//            hUser);

    MCSErr = MCS_NO_ERROR;

    if (pUA->pDomain->bCanSendData) {
        if (hChannel != NULL) {
            pMCSChannel = (MCSChannel *)hChannel;
            ChannelID = pMCSChannel->ID;
        }
        else {
            // The user requested a send to a channel that it has not joined.
            // Find the channel by its ID.

            ASSERT(ChannelID >= 1 && ChannelID <= 65535);

            if (!SListGetByKey(&pUA->pDomain->ChannelList, ChannelID,
                    &pMCSChannel)) {
                if (!pUA->pDomain->bTopProvider) {
                    //MCS FUTURE: We did not find the channel, send to upward
                    //  connection since it may be in another part of the
                    //  hierarchy tree.
                }

                WarnOut(pUA->pDomain->pContext, "SendDataReq(): Unjoined "
                        "channel send requested, channel not found, "
                        "ignoring send");
                goto FreeOutBuf;
            }
        }
    }
    else {
        WarnOut1(pUA->pDomain->pContext, "%s: SendOutBuf(): Ignoring a send because "
                "ICA stack not connected", 
                 pUA->pDomain->StackClass == Stack_Primary ? "Primary" :
                 (pUA->pDomain->StackClass == Stack_Shadow ? "Shadow" :
                 "PassThru"));
        goto FreeOutBuf;
    }

#if DBG
    // Check against maximum send size allowed.
    if (pOutBuf->ByteCount > pUA->pDomain->MaxSendSize) {
        ErrOut(pUA->pDomain->pContext, "SendDataReq(): Send size exceeds "
                "negotiated domain maximum");
        MCSErr = MCS_SEND_SIZE_TOO_LARGE;
        goto FreeOutBuf;
    }
#endif
    
#ifdef MCS_Future
    if (!pUA->pDomain->bTopProvider) {
        // MCS FUTURE: We are not the top provider. Send SDrq or USrq to
        // upward connection. We handle nonuniform send-data sending to local
        // and lower attachments below.
        if (RequestType == UNIFORM_SEND_DATA)
            goto FreeOutBuf;
    }
#endif

    // Set up for iterating the users joined to the channel.
    // This includes preserving the iteration state of the domain-wide user
    //   list in case we are being called from within a send-data indication.
    bAnyNonlocalSends = FALSE;
    SavedIterationState = pMCSChannel->UserList.Hdr.CurrOffset;
    
    // First send to local attachments, if any, skipping the sender.
    SListResetIteration(&pMCSChannel->UserList);
    while (SListIterate(&pMCSChannel->UserList, (UINT_PTR *)&pCurUA, &pCurUA)) {
        if (pCurUA != hUser) {
            if (!pCurUA->bLocal) {
                bAnyNonlocalSends = TRUE;
            }
            else {
                // Trigger callback to pCurUA user attachment.
                (pCurUA->SDCallback)(
                        pOutBuf->pBuffer,  // pData
                        pOutBuf->ByteCount,  // DataLength
                        pCurUA->UserDefined,  // UserDefined
                        pCurUA,  // hUser
                        (BOOLEAN)(RequestType == UNIFORM_SEND_DATA),  // bUniform
                        pMCSChannel,  // hChannel
                        Priority,
                        pCurUA->UserID,  // SenderID
                        Segmentation);
            }
        }
    }

    // Next send to lower attachments, if any.
    if (bAnyNonlocalSends) {
        // If we are sending more than 16383 bytes, we have to include ASN.1
        //   segmentation. So, the header contains encoded the number of
        //   16K blocks (up to 3 in the maximum X.224 send size) encoded
        //   first, then the 16K blocks, then another length determinant
        //   for the size of the rest of the data, followed by the rest of the
        //   data.
        // For the maximum X.224 send size, the maximum number of bytes for the
        //   later length determinant is 2 bytes. For this purpose we require
        //   the caller to add SendDataReqSuffixBytes at the end of the OutBuf,
        //   so that we can shift outward the tail end of the data which
        //   will always be the smallest chunk possible to move.

        // Create send-data indication PDU header first. Note that this will
        //   only encode size of up to 3 16K blocks if the send size is
        //   greater than 16383. The remainder we have to deal with.
        // MCS FUTURE: This is a top-provider-only solution, we send as
        //   indication PDUs instead of request PDUs.

        CreateSendDataPDUHeader(RequestType == NORMAL_SEND_DATA ?
                MCS_SEND_DATA_INDICATION_ENUM :
                MCS_UNIFORM_SEND_DATA_INDICATION_ENUM,
                pUA->UserID, ChannelID, Priority, Segmentation,
                &pOutBuf->pBuffer, &pOutBuf->ByteCount);

        // MCS FUTURE: Remove #if if we need to handle send sizes > 16383.
        ASSERT(pOutBuf->ByteCount <= 16383);
#ifdef MCS_Future
        // Check for ASN.1 segmentation requirement.
        if (pOutBuf->ByteCount > 16383) {
            // Now move memory around and create a new length determinant.
            BYTE LengthDet[2], *pLastSegment;
            unsigned Remainder, LengthEncoded, NBytesConsumed;
            BOOLEAN bLarge;

            Remainder = pOutBuf->ByteCount % 16384;

            EncodeLengthDeterminantPER(LengthDet, Remainder, &LengthEncoded,
                    &bLarge, &NBytesConsumed);
            ASSERT(!bLarge);

            // NBytesConsumed now contains how much we have to shift the
            //   last segment of the data.
            pLastSegment = pOutBuf->pBuffer + pOutBuf->ByteCount;
            RtlMoveMemory(pLastSegment + NBytesConsumed, pLastSegment,
                    Remainder);
            pOutBuf->ByteCount += Remainder + NBytesConsumed;

            // Copy in the later length determinant (up to 2 bytes).
            *pLastSegment = LengthDet[0];
            if (NBytesConsumed == 2)
                *(pLastSegment + 1) = LengthDet[1];
        }
#endif  // 0

        // Send downward.
        //MCS FUTURE: Needs to change for multiple connections.
        SdWrite.pBuffer = NULL;
        SdWrite.ByteCount = 0;
        SdWrite.pOutBuf = pOutBuf;

        Status = IcaCallNextDriver(pUA->pDomain->pContext, SD$RAWWRITE,
                &SdWrite);
        if (NT_SUCCESS(Status)) {
            // Increment protocol counters.
            pUA->pDomain->pStat->Output.WdFrames++;
            pUA->pDomain->pStat->Output.WdBytes += pOutBuf->ByteCount;
        }
        else {
            ErrOut1(pUA->pDomain->pContext, "Problem sending SDin or USin "
                    "PDU to TD, status=%X", Status);
            MCSErr = MCS_NETWORK_ERROR;
            // We do not free the OutBuf here, the TD is supposed to do it.
        }
    } else {
        IcaBufferFree(pUA->pDomain->pContext, pOutBuf);
    }

    // Restore the iteration state from before the call.
    pMCSChannel->UserList.Hdr.CurrOffset = SavedIterationState;

    return MCSErr;

FreeOutBuf:
    IcaBufferFree(pUA->pDomain->pContext, pOutBuf);

    return MCSErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\pdmcs\x224.h ===
/* (C) 1997 Microsoft Corp.
 *
 * file   : X224.h
 * author : Erik Mavrinac
 *
 * description: X.224 types and defines for encoding and decoding X.224
 *   packets for MCS.
 */

#ifndef __X224_H
#define __X224_H


/*
 * Defines
 */

#define X224_ConnectionConPacketSize 11
#define X224_DataHeaderSize          7

// TPDU types.
#define X224_None          0
#define X224_ConnectionReq 0xE0
#define X224_ConnectionCon 0xD0
#define X224_Disconnect    0x80
#define X224_Error         0x70
#define X224_Data          0xF0

// X.224 Data EOT field.
#define X224_EOT 0x80

// X.224 Connect Request extra field type.
#define TPDU_SIZE 0xC0

// RFC1006 default of 65531 minus 3 bytes for data TPDU header.
#define X224_DefaultDataSize 65528



/*
 * Prototypes for worker functions referred to by other files.
 */

void CreateX224ConnectionConfirmPacket(BYTE *, unsigned, unsigned);


/*
 * X.224 data header is laid out as follows:
 *   Byte   Contents
 *   ----   --------
 *    0     RFC1006 version number, must be 0x03.
 *    1     RFC1006 Reserved, must be 0x00.
 *    2     RFC1006 MSB of word-sized total-frame length (incl. whole X.224 header).
 *    3     RFC1006 LSB of word-sized total-frame length.
 *    4     Length Indicator, the size of the header bytes following (== 2).
 *    5     Data packet indicator, 0xF0.
 *    6     X224_EOT (0x80) if this is the last packet, 0x00 otherwise.
 *
 * bLastTPDU is nonzero when the data in this TPDU is the final X.224 block
 *   in this data send sequence.
 *
 * Assumes that PayloadDataSize does not exceed the maximum X.224 user data size
 *   negotiated during X.224 connection.
 */

__inline void CreateX224DataHeader(
        BYTE     *pBuffer,
        unsigned PayloadDataSize,
        BOOLEAN  bLastTPDU)
{
    unsigned TotalSize;

    TotalSize = PayloadDataSize + X224_DataHeaderSize;
    
    // RFC1006 header.
    pBuffer[0] = 0x03;
    pBuffer[1] = 0x00;
    pBuffer[2] = (TotalSize & 0x0000FF00) >> 8;
    pBuffer[3] = (TotalSize & 0x000000FF);

    // Data TPDU header.
    pBuffer[4] = 0x02;   // Size of TPDU bytes following.
    pBuffer[5] = X224_Data;
    pBuffer[6] = (PayloadDataSize && bLastTPDU) ? X224_EOT : 0;
}



#endif // !defined(__X224_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpdd\dbg_fncall_hist.h ===
#ifndef _H_DBG_FNCALL_HIST_
#define _H_DBG_FNCALL_HIST_

#ifdef DC_DEBUG

// This defines how many slots are in the function call history
#define DBG_DD_FNCALL_HIST_MAX      50

typedef struct tagDBG_DD_FUNCALL_HISTORY
{
    INT32   fnID;
    DWORD_PTR   param1;
    DWORD_PTR   param2;
    DWORD_PTR   param3;
    DWORD_PTR   param4;
} DBG_DD_FUNCALL_HISTORY, *PDBG_DD_FUNCALL_HISTORY;

// These are the IDs to be used when calling the macro below
enum {
    DBG_DD_FNCALL_DRV_CONNECT,  
    DBG_DD_FNCALL_DRV_DISCONNECT,
    DBG_DD_FNCALL_DRV_RECONNECT,
    DBG_DD_FNCALL_DRV_SHADOWCONNECT,
    DBG_DD_FNCALL_DRV_SHADOWDISCONNECT,
    DBG_DD_FNCALL_DRV_ASSERTMODE,
    DBG_DD_ALLOC_SECTIONOBJ,
    DBG_DD_FREE_SECTIONOBJ_SURFACE,
    DBG_DD_FREE_SECTIONOBJ_DDTERM,
    DBG_DD_FNCALL_DRV_ENABLEDIRECTDRAW,
    DBG_DD_FNCALL_DRV_DISABLEDIRECTDRAW
};

// Use this to add to the history
#define DBG_DD_FNCALL_HIST_ADD( ID, PARAM1, PARAM2, PARAM3, PARAM4 ) \
    DrvDebugPrint( "FNCALL_HIST: FN[%x] 1[%x] 2[%x] 3[%x] 4[%x]\n", \
        (ID), (PARAM1), (PARAM2), (PARAM3), (PARAM4) ); \
    dbg_ddFnCallHistory[ dbg_ddFnCallHistoryIndex ].fnID = (ID); \
    dbg_ddFnCallHistory[ dbg_ddFnCallHistoryIndex ].param1 = (DWORD_PTR)(PARAM1); \
    dbg_ddFnCallHistory[ dbg_ddFnCallHistoryIndex ].param2 = (DWORD_PTR)(PARAM2); \
    dbg_ddFnCallHistory[ dbg_ddFnCallHistoryIndex ].param3 = (DWORD_PTR)(PARAM3); \
    dbg_ddFnCallHistory[ dbg_ddFnCallHistoryIndex ].param4 = (DWORD_PTR)(PARAM4); \
    dbg_ddFnCallHistoryIndex = \
        (dbg_ddFnCallHistoryIndex + 1) % dbg_ddFnCallHistoryIndexMAX;

#endif // DC_DEBUG

#endif // _H_DBG_FNCALL_HIST_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\pdmcs\x224.c ===
/* (C) 1997 Microsoft corp.
 *
 * file   : X224.c
 * author : Erik Mavrinac
 *
 * description: X.224 functions for encoding and decoding X.224 packets for
 *   MCS.
 */

#include "precomp.h"
#pragma hdrstop

#include <MCSImpl.h>


/*
 * X.224 connection-confirm packet is laid out as follows:
 *   Byte   Contents
 *   ----   --------
 *    0     RFC1006 version number, must be 0x03.
 *    1     RFC1006 Reserved, must be 0x00.
 *    2     RFC1006 MSB of word-sized total-frame length (incl. X.224 header).
 *    3     RFC1006 LSB of word-sized total-frame length.
 *    4     Length Indicator, the size of the header bytes following (== 2).
 *    5     Connection confirm indicator, 0xD0.
 *    6     MSB of destination socket/port # on receiving machine.
 *    7     LSB of destination socket/port #.
 *    8     MSB of source socket/port # on sending machine.
 *    9     LSB of source socket/port #.
 *    10    Protocol class. Should be 0x00 (X.224 class 0).
 */

void CreateX224ConnectionConfirmPacket(
        BYTE *pBuffer,
        unsigned DestPort,
        unsigned SrcPort)
{
    // RFC1006 header.
    pBuffer[0] = 0x03;
    pBuffer[1] = 0x00;
    pBuffer[2] = 0x00;
    pBuffer[3] = X224_ConnectionConPacketSize;

    // Connection confirm TPDU header.
    pBuffer[4] = 6;  // # following bytes.
    pBuffer[5] = X224_ConnectionCon;
    pBuffer[6] = (DestPort & 0xFF00) >> 8;
    pBuffer[7] = (DestPort & 0x00FF);
    pBuffer[8] = (SrcPort & 0xFF00) >> 8;
    pBuffer[9] = (SrcPort & 0x00FF);
    pBuffer[10] = 0x00;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpdd\nbadisp.c ===
/****************************************************************************/
// nbadisp.c
//
// RDP Bounds Accumulator display driver code
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <precmpdd.h>
#define hdrstop

#define TRC_FILE "nbadisp"
#include <adcg.h>

#include <atrcapi.h>
#include <abaapi.h>
#include <nbadisp.h>

#define DC_INCLUDE_DATA
#include <ndddata.c>
#undef DC_INCLUDE_DATA

// No data.
//#include <nbaddat.c>

#include <nbainl.h>

// Instantiate common code.
#include <abacom.c>


// Local prototypes.
#ifdef DC_DEBUG
void BAPerformUnitTests();
#endif


/****************************************************************************/
// BA_DDInit
/****************************************************************************/
void RDPCALL BA_DDInit(void)
{
    DC_BEGIN_FN("BA_DDInit");

    // No data to declare, don't waste time opening the file.
//#define DC_INIT_DATA
//#include <nbaddat.c>
//#undef DC_INIT_DATA

#ifdef DC_DEBUG
    // Perform one-time checks on the algorithm.
    BAPerformUnitTests();
#endif

    DC_END_FN();
}


/****************************************************************************/
// BA_InitShm
//
// Init BA block in shared memory just after alloc.
/****************************************************************************/
void RDPCALL BA_InitShm(void)
{
    unsigned i;

    DC_BEGIN_FN("BA_InitShm");

    // Initialize all members - shared memory is not zeroed on alloc.

    // Initialize rectangle array slots as unused, set up free list
    // containing all rects.
    pddShm->ba.firstRect = BA_INVALID_RECT_INDEX;
    pddShm->ba.rectsUsed = 0;
    pddShm->ba.totalArea = 0;
    pddShm->ba.firstFreeRect = 0;
    for (i = 0; i < BA_TOTAL_NUM_RECTS; i++) {
        pddShm->ba.bounds[i].inUse = FALSE;
        pddShm->ba.bounds[i].iNext = i + 1;
    }
    pddShm->ba.bounds[BA_TOTAL_NUM_RECTS - 1].iNext = BA_INVALID_RECT_INDEX;

    DC_END_FN();
}


/****************************************************************************/
// BA_AddScreenData
//
// Adds a specified rectangle to the current Screen Data Area.
/****************************************************************************/
void RDPCALL BA_AddScreenData(PRECTL pRect)
{
    DC_BEGIN_FN("BA_AddScreenData");

    // Check that the caller has passed a valid rectangle.
    // Make sure we add a rectangle with coordinates within the screen area.
    if((pRect->right > pRect->left) && (pRect->bottom > pRect->top) &&
            (pRect->left >= 0) && (pRect->left < ddDesktopWidth) &&
            (pRect->right > 0) && (pRect->right <= ddDesktopWidth) &&
            (pRect->top >= 0) && (pRect->top < ddDesktopHeight) &&
            (pRect->bottom > 0) && (pRect->bottom <= ddDesktopHeight)) {
        BAAddRect(pRect, 0);
    }
    
    DC_END_FN();
}


/****************************************************************************/
// BAOverlap
//
// Detects overlap between two rectangles. Note that all rectangle
// coordinates are exclusive. Returns one of the overlap return codes or
// outcode combinations defined above.
/****************************************************************************/
int RDPCALL BAOverlap(PRECTL pRect1, PRECTL pRect2)
{
    int externalEdges;
    int externalCount;
    int internalEdges;
    int internalCount;
    int rc;

    DC_BEGIN_FN("BAOverlap");

    // We start with special cases of the rects being immediately adjacent
    // or overlapping while lying side-by-side.
    if (pRect1->top == pRect2->top && pRect1->bottom == pRect2->bottom) {
        if (pRect1->left <= pRect2->right &&
                pRect1->left > pRect2->left &&
                pRect1->right > pRect2->right) {
            rc = OL_MERGE_LEFT;
            DC_QUIT;
        }

        if (pRect1->right >= pRect2->left &&
                pRect1->right < pRect2->right &&
                pRect1->left < pRect2->left) {
            rc = OL_MERGE_RIGHT;
            DC_QUIT;
        }
    }
    if (pRect1->left == pRect2->left && pRect1->right == pRect2->right) {
        if (pRect1->top <= pRect2->bottom &&
                pRect1->top > pRect2->top &&
                pRect1->bottom > pRect2->bottom) {
            rc = OL_MERGE_TOP;
            DC_QUIT;
        }

        if (pRect1->bottom >= pRect2->top &&
                pRect1->bottom < pRect2->bottom &&
                pRect1->top < pRect2->top) {
            rc = OL_MERGE_BOTTOM;
            DC_QUIT;
        }
    }

    // Check for no overlapping -- we've exhausted the cases where adjacency
    // can be taken advantage of.
    if (pRect1->left >= pRect2->right ||
            pRect1->top >= pRect2->bottom ||
            pRect1->right <= pRect2->left ||
            pRect1->bottom <= pRect2->top) {
        rc = OL_NONE;
        DC_QUIT;
    }

    // Use outcodes for Internal edge cases.
    // If 3 or more bits are set then rect1 is enclosed either partially or
    // completely within rect2 according to the OL_ENCLOSED and
    // OL_PART_ENCLOSED_XXX definitions. The negative of the outcode value
    // is retruned to ensure that it is distinct from the external edge
    // outcode returns (see below).
    internalCount = 0;
    internalEdges = 0;
    if (pRect1->left >= pRect2->left && pRect1->left < pRect2->right) {
        // Rect1 left is enclosed within rect2.
        internalEdges |= EE_LEFT;
        internalCount++;
    }
    if (pRect1->top >= pRect2->top && pRect1->top < pRect2->bottom) {
        // Rect1 top is enclosed within rect2.
        internalEdges |= EE_TOP;
        internalCount++;
    }
    if (pRect1->right > pRect2->left && pRect1->right <= pRect2->right) {
        // Rect1 right is enclosed within rect2.
        internalEdges |= EE_RIGHT;
        internalCount++;
    }
    if (pRect1->bottom > pRect2->top && pRect1->bottom <= pRect2->bottom) {
        // Rect1 bottom is enclosed within rect2.
        internalEdges |= EE_BOTTOM;
        internalCount++;
    }
    if (internalCount >= 3) {
        rc = -internalEdges;
        DC_QUIT;
    }

    // Use outcodes for External edge cases. These are the classic "line"
    // outcodes. If 2 or more bits are set then rect1 overlaps rect2 per the
    // OL_ENCLOSES_XXX and OL_SPLIT_XXX definitions.
    externalEdges = 0;
    externalCount = 0;
    if (pRect1->left <= pRect2->left) {
        // Rect1 left is left of rect2 left.
        externalEdges |= EE_LEFT;
        externalCount++;
    }
    if (pRect1->top <= pRect2->top) {
        // Rect1 top is above rect2 top.
        externalEdges |= EE_TOP;
        externalCount++;
    }
    if (pRect1->right >= pRect2->right) {
        // Rect1 right is right of rect2 right.
        externalEdges |= EE_RIGHT;
        externalCount++;
    }
    if (pRect1->bottom >= pRect2->bottom) {
        // Rect1 bottom is below rect2 bottom.
        externalEdges |= EE_BOTTOM;
        externalCount++;
    }
    if (externalCount >= 2) {
        rc = externalEdges;
        DC_QUIT;
    }

    // If get here then we failed to detect a valid case.
    TRC_ALT((TB, "Unrecognised Overlap: (%d,%d,%d,%d),(%d,%d,%d,%d)",
            pRect1->left, pRect1->top, pRect1->right, pRect1->bottom,
            pRect2->left, pRect2->top, pRect2->right, pRect2->bottom ));
    rc = OL_NONE;

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}


/****************************************************************************/
// BARemoveRectList
//
// Removes a rectangle from the list.
/****************************************************************************/
__inline void RDPCALL BARemoveRectList(unsigned iRect)
{
    BA_RECT_INFO *pRect;

    DC_BEGIN_FN("BARemoveRectList");

    pRect = &(pddShm->ba.bounds[iRect]);

    // Unlink from used list.
    if (pRect->iPrev != BA_INVALID_RECT_INDEX)
        pddShm->ba.bounds[pRect->iPrev].iNext = pRect->iNext;
    else
        pddShm->ba.firstRect = pRect->iNext;

    if (pRect->iNext != BA_INVALID_RECT_INDEX)
        pddShm->ba.bounds[pRect->iNext].iPrev = pRect->iPrev;

    // Add to beginning of free list.
    pRect->inUse = FALSE;
    pRect->iNext = pddShm->ba.firstFreeRect;
    pddShm->ba.firstFreeRect = iRect;

    // Update bookkeeping variables.
    pddShm->ba.rectsUsed--;
    pddShm->ba.totalArea -= pRect->area;

#ifdef DC_DEBUG
    // Check the list integrity.
    BACheckList();
#endif

    DC_END_FN();
}


/****************************************************************************/
// BARecalcArea
//
// Recalculates a rect area, preserving the totalArea central tally of areas.
/****************************************************************************/
__inline void RDPCALL BARecalcArea(unsigned iRect)
{
    // Reset area to new size and update totalArea.
    pddShm->ba.totalArea -= pddShm->ba.bounds[iRect].area;
    pddShm->ba.bounds[iRect].area =
            COM_SIZEOF_RECT(pddShm->ba.bounds[iRect].coord);
    pddShm->ba.totalArea += pddShm->ba.bounds[iRect].area;
}


/****************************************************************************/
// BAAddRect
//
// Accumulates rectangles. This is a complex routine, with the essential
// algorithm as follows:
//
// - Start with the supplied rect as the candidate rect.
//
// - Compare the candidate against each of the existing accumulated rects.
//
// - If some form of overlap is detected between the candidate and an
//   existing rect, this may result in one of the following (see the cases of
//   the switch for details):
//
//   - adjust the candidate or the existing rect or both
//   - merge the candidate into the existing rect
//   - discard the candidate as it is enclosed by an existing rect.
//
// - If the merge or adjustment results in a changed candidate, restart the
//   comparisons from the beginning of the list with the changed candidate.
//
// - If the adjustment results in a split (giving two candidate rects),
//   invoke this routine recursively with one of the two candidates as its
//   candidate.
//
// - If no overlap is detected against the existing rects, add the candidate
//   to the list of accumulated rectangles.
//
// - If the add results in more than BA_MAX_ACCUMULATED_RECTS accumulated
//   rects, do a forced merge of two of the accumulate rects (which include
//   the newly added candidate) - choosing the two rects where the merged rect
//   results in the smallest increase in area over the two non-merged rects.
//
// - After a forced merge, restart the comparisons from the beginning of the
//   list with the newly merged rectangle as the candidate.
//
// For a particular call, this process will continue until the candidate
// (whether the supplied rect, an adjusted version of that rect, or a merged
// rect):
//
// - does not find an overlap among the rects in the list and does not cause
//   a forced merge
// - is discarded becuase it is enclosed within one of the rects in the list.
//
// Returns TRUE if rectangle was spoiled due to a complete overlap.
/****************************************************************************/
BOOL RDPCALL BAAddRect(PRECTL pCand, int level)
{
    INT32    bestMergeIncrease;
    INT32    mergeIncrease;
    unsigned iBestMerge1;
    unsigned iBestMerge2;
    unsigned iExist;
    unsigned iTmp;
    BOOLEAN  fRectToAdd;
    BOOLEAN  fRectMerged;
    BOOLEAN  fResetRects;
    RECTL    rectNew;
    unsigned iLastMerge;
    int  overlapType;
    BOOL rc = TRUE;

    DC_BEGIN_FN("BAAddRect");

#ifdef DC_DEBUG
    // Check list, esp. the area calculations.
    BACheckList();
#endif

    // Increase the level count in case we recurse.
    level++;

    // Start off by assuming the candidate rectangle will be added to the
    // accumulated list of rectangles, and that no forced merge has
    // occurred.
    fRectToAdd = TRUE;
    fRectMerged = FALSE;

    // Loop until no merges occur.
    do {
        TRC_DBG((TB, "Candidate rect: (%d,%d,%d,%d)",
                pCand->left,pCand->top,pCand->right,pCand->bottom));

        // Compare the current candidate rectangle against the rectangles
        // in the current accumulated list.
        iExist = pddShm->ba.firstRect;

        while (iExist != BA_INVALID_RECT_INDEX) {
            // Assume that the comparisons will run through the whole list.
            fResetRects = FALSE;

            // If the candidate and the existing rectangle are the same
            // then ignore.  This occurs when an existing rectangle is
            // replaced by a candidate and the comparisons are restarted
            // from the front of the list - whereupon at some point the
            // candidate will be compared with itself.
            if (&pddShm->ba.bounds[iExist].coord == pCand) {
                TRC_DBG((TB, "OL_SAME - %d", iExist));
                iExist = pddShm->ba.bounds[iExist].iNext;
                continue;
            }

            // Switch on the overlap type (see Overlap routine).
            overlapType = BAOverlap(&(pddShm->ba.bounds[iExist].coord), pCand);
            switch (overlapType) {
                case OL_NONE:
                    // No overlap.
                    TRC_DBG((TB, "OL_NONE - %d", iExist));
                    break;


                case OL_MERGE_LEFT:
                    // Candidate abuts or overlaps existing rect at existing
                    // rect's left.
                    TRC_DBG((TB, "OL_MERGE_LEFT - %d", iExist));
                    if (fRectToAdd) {
                        // Candidate is the original rect; merge the
                        // candidate into the existing, and make the existing
                        // the new candidate.
                        pddShm->ba.bounds[iExist].coord.left = pCand->left;
                        pCand = &(pddShm->ba.bounds[iExist].coord);
                        fRectToAdd = FALSE;
                        iLastMerge = iExist;
                        BARecalcArea(iExist);
                    }
                    else {
                        // This is a merge of two existing rectangles (ie
                        // the candidate is the result of a merge), merge the
                        // overlapping existing into the candidate (the last
                        // merged) and remove the existing.
                        pCand->right = pddShm->ba.bounds[iExist].coord.right;
                        BARemoveRectList(iExist);
                    }

                    // Start the comparisons again with the new candidate.
                    fResetRects = TRUE;
                    break;


                case OL_MERGE_RIGHT:
                    // Candidate abuts or overlaps existing rect at existing
                    // rect's right.
                    TRC_DBG((TB, "OL_MERGE_RIGHT - %d", iExist));
                    if (fRectToAdd) {
                        // Candidate is the original rect; merge the
                        // candidate into the existing, and make the existing
                        // the new candidate.
                        pddShm->ba.bounds[iExist].coord.right = pCand->right;
                        pCand = &(pddShm->ba.bounds[iExist].coord);
                        fRectToAdd = FALSE;
                        iLastMerge = iExist;
                        BARecalcArea(iExist);
                    }
                    else {
                        // This is a merge of two existing rectangles (ie
                        // the candidate is the result of a merge), merge the
                        // overlapping existing into the candidate (the last
                        // merged) and remove the existing.
                        pCand->left = pddShm->ba.bounds[iExist].coord.left;
                        BARemoveRectList(iExist);
                    }

                    // Start the comparisons again with the new candidate.
                    fResetRects = TRUE;
                    break;


                case OL_MERGE_TOP:
                    // Candidate abuts or overlaps existing rect at existing
                    // rect's top.
                    TRC_DBG((TB, "OL_MERGE_TOP - %d", iExist));
                    if (fRectToAdd) {
                        // Candidate is the original rect; merge the
                        // candidate into the existing, and make the existing
                        // the new candidate.
                        pddShm->ba.bounds[iExist].coord.top = pCand->top;
                        pCand = &(pddShm->ba.bounds[iExist].coord);
                        fRectToAdd = FALSE;
                        iLastMerge = iExist;
                        BARecalcArea(iExist);
                    }
                    else {
                        // This is a merge of two existing rectangles (ie
                        // the candidate is the result of a merge), merge the
                        // overlapping existing into the candidate (the last
                        // merged) and remove the existing.
                        pCand->bottom =
                                pddShm->ba.bounds[iExist].coord.bottom;
                        BARemoveRectList(iExist);
                    }

                    // Start the comparisons again with the new candidate.
                    fResetRects = TRUE;
                    break;


                case OL_MERGE_BOTTOM:
                    // Candidate abuts or overlaps existing rect at existing
                    // rect's bottom.
                    TRC_DBG((TB, "OL_MERGE_BOTTOM - %d", iExist));
                    if (fRectToAdd) {
                        // Candidate is the original rect; merge the
                        // candidate into the existing, and make the existing
                        // the new candidate.
                        pddShm->ba.bounds[iExist].coord.bottom =
                                pCand->bottom;
                        pCand = &(pddShm->ba.bounds[iExist].coord);
                        fRectToAdd = FALSE;
                        iLastMerge = iExist;
                        BARecalcArea(iExist);
                    }
                    else {
                        // This is a merge of two existing rectangles (ie
                        // the candidate is the result of a merge), merge the
                        // overlapping existing into the candidate (the last
                        // merged) and remove the existing.
                        pCand->top = pddShm->ba.bounds[iExist].coord.top;
                        BARemoveRectList(iExist);
                    }

                    // Start the comparisons again with the new candidate.
                    fResetRects = TRUE;
                    break;


                case OL_ENCLOSED:
                    // The existing is enclosed by the candidate.
                    //
                    //      100,100 +----------------------+
                    //              |        Cand          |
                    //              |                      |
                    //              |    130,130           |
                    //              |    +------------+    |
                    //              |    |            |    |
                    //              |    |   Exist    |    |
                    //              |    |            |    |
                    //              |    +------------+    |
                    //              |             170,170  |
                    //              +----------------------+ 200,200
                    TRC_DBG((TB, "OL_ENCLOSED - %d", iExist));
                    if (fRectToAdd) {
                        // Candidate is the original rect; replace the
                        // existing with the candidate and make the new
                        // existing the new candidate.
                        pddShm->ba.bounds[iExist].coord = *pCand;
                        pCand = &(pddShm->ba.bounds[iExist].coord);
                        fRectToAdd = FALSE;
                        iLastMerge = iExist;
                        BARecalcArea(iExist);
                    }
                    else {
                        // Candidate is an existing rect: Remove the other
                        // existing rect.
                        BARemoveRectList(iExist);
                    }

                    // Start the comparisons again with the new candidate.
                    fResetRects = TRUE;
                    break;


                case OL_PART_ENCLOSED_LEFT:
                    // The existing is partially enclosed by the candidate
                    // - but not on the right.
                    //
                    //   100,100 +----------------------+
                    //           |        Cand          |
                    //           | 130,130  +-----------+--------+
                    //           |          |           |        |
                    //           |          |  Exist    |        |
                    //           |          |           |        |
                    //           |          +-----------+--------+
                    //           |                      |     220,170
                    //           +----------------------+
                    //                               200,200
                    //
                    // Adjust the existing rectangle to be the non-
                    // overlapped portion.
                    //
                    //   100,100 +----------------------+
                    //           |                      |200,130
                    //           |                      |+-------+
                    //           |                      ||       |
                    //           |        Cand          || Exist |
                    //           |                      ||       |
                    //           |                      |+-------+
                    //           |                      |     220,170
                    //           +----------------------+
                    //                                200,200
                    //
                    // Note that this does not restart the comparisons.
                    TRC_DBG((TB, "OL_PART_ENCLOSED_LEFT - %d", iExist));
                    pddShm->ba.bounds[iExist].coord.left = pCand->right;
                    BARecalcArea(iExist);
                    break;


                case OL_PART_ENCLOSED_RIGHT:
                    // The existing is partially enclosed by the candidate
                    // - but not on the left. Adjust the existing rect to be
                    // the non-overlapping portion, similar to
                    // OL_PART_ENCLOSED_LEFT above.
                    // Note that this does not restart the comparisons.
                    TRC_DBG((TB, "OL_PART_ENCLOSED_RIGHT - %d", iExist));
                    pddShm->ba.bounds[iExist].coord.right = pCand->left;
                    BARecalcArea(iExist);
                    break;


                case OL_PART_ENCLOSED_TOP:
                    // The existing is partially enclosed by the candidate
                    // - but not on the bottom. Adjust the existing rect to be
                    // the non-overlapping portion, similar to
                    // OL_PART_ENCLOSED_LEFT above.
                    // Note that this does not restart the comparisons.
                    TRC_DBG((TB, "OL_PART_ENCLOSED_TOP - %d", iExist));
                    pddShm->ba.bounds[iExist].coord.top = pCand->bottom;
                    BARecalcArea(iExist);
                    break;


                case OL_PART_ENCLOSED_BOTTOM:
                    // The existing is partially enclosed by the candidate
                    // - but not on the top. Adjust the existing rect to be
                    // the non-overlapping portion, similar to
                    // OL_PART_ENCLOSED_LEFT above.
                    // Note that this does not restart the comparisons.
                    TRC_DBG((TB, "OL_PART_ENCLOSED_BOTTOM - %d", iExist));
                    pddShm->ba.bounds[iExist].coord.bottom = pCand->top;
                    BARecalcArea(iExist);
                    break;


                case OL_ENCLOSES:
                    // The existing encloses the candidate.
                    //
                    //      100,100 +----------------------+
                    //              |        Exist         |
                    //              |                      |
                    //              |    130,130           |
                    //              |    +------------+    |
                    //              |    |            |    |
                    //              |    |   Cand     |    |
                    //              |    |            |    |
                    //              |    +------------+    |
                    //              |             170,170  |
                    //              +----------------------+ 200,200
                    TRC_DBG((TB, "OL_ENCLOSES - %d", iExist));

                    // Return FALSE indicating that the rectangle is
                    // already catered for by the existing bounds.
                    rc = FALSE;
                    DC_QUIT;


                case OL_PART_ENCLOSES_LEFT:
                    // The existing partially encloses the candidate - but
                    // not on the left.
                    //
                    //   100,100 +----------------------+
                    //           |        Exist         |
                    //   70,130  |                      |
                    //     +-----+---------------+      |
                    //     |     |               |      |
                    //     |     |        Cand   |      |
                    //     |     |               |      |
                    //     +-----+---------------+      |
                    //           |           170,170    |
                    //           +----------------------+ 200,200
                    //
                    // Adjust the candidate rectangle to be the non-
                    // overlapped portion.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |                      |
                    //    70,130 |                      |
                    //     +----+|                      |
                    //     |    ||                      |
                    //     |Cand||        Exist         |
                    //     |    ||                      |
                    //     +----+|                      |
                    //    100,170|                      |
                    //           +----------------------+ 200,200
                    TRC_DBG((TB, "OL_PART_ENCLOSES_LEFT - %d", iExist));
                    pCand->right = pddShm->ba.bounds[iExist].coord.left;

                    // The candidate changed. Restart the comparisons to check
                    // for overlaps between the adjusted candidate and other
                    // existing rects.
                    fResetRects = TRUE;
                    BARecalcArea(iExist);
                    break;


                case OL_PART_ENCLOSES_RIGHT:
                    // The existing partially encloses the candidate - but
                    // not on the right. Adjust the candidate rect to be
                    // the non-overlapping portion, similar to
                    // OL_PART_ENCLOSES_LEFT above.
                    TRC_DBG((TB, "OL_PART_ENCLOSES_RIGHT - %d", iExist));
                    pCand->left = pddShm->ba.bounds[iExist].coord.right;

                    // The candidate changed. Restart the comparisons to check
                    // for overlaps between the adjusted candidate and other
                    // existing rects.
                    fResetRects = TRUE;
                    BARecalcArea(iExist);
                    break;


                case OL_PART_ENCLOSES_TOP:
                    // The existing partially encloses the candidate - but
                    // not on the top. Adjust the candidate rect to be
                    // the non-overlapping portion, similar to
                    // OL_PART_ENCLOSES_LEFT above.
                    TRC_DBG((TB, "OL_PART_ENCLOSES_TOP - %d", iExist));
                    pCand->bottom = pddShm->ba.bounds[iExist].coord.top;

                    // The candidate changed. Restart the comparisons to check
                    // for overlaps between the adjusted candidate and other
                    // existing rects.
                    fResetRects = TRUE;
                    BARecalcArea(iExist);
                    break;


                case OL_PART_ENCLOSES_BOTTOM:
                    // The existing partially encloses the candidate - but
                    // not on the bottom. Adjust the candidate rect to be
                    // the non-overlapping portion, similar to
                    // OL_PART_ENCLOSES_LEFT above.
                    TRC_DBG((TB, "OL_PART_ENCLOSES_BOTTOM - %d", iExist));
                    pCand->top = pddShm->ba.bounds[iExist].coord.bottom;

                    // The candidate changed. Restart the comparisons to check
                    // for overlaps between the adjusted candidate and other
                    // existing rects.
                    fResetRects = TRUE;
                    BARecalcArea(iExist);
                    break;


                case OL_SPLIT_HORIZ:
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //         100,100 +--------+
                    //        70,130   |  Exist |
                    //           +-----+--------+------+
                    //           |     |        |      |
                    //           | Cand|        |      |
                    //           |     |        |      |
                    //           +-----+--------+------+180,160
                    //                 |        |
                    //                 +--------+150,200
                    //
                    // Need to split candidate into left and right halves.
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the left and a new rectangle on
                    // the right. Call this routine recursively to handle
                    // the new rectangle.
                    //
                    //         100,100 +--------+
                    //        70,130   |        |150,130
                    //           +----+|        |+-----+
                    //           |    ||        ||     |
                    //           |Cand|| Exist  || New |
                    //           |    ||        ||     |
                    //           +----+|        |+-----+
                    //          100,160|        |     180,160
                    //                 +--------+150,200
                    TRC_DBG((TB, "OL_SPLIT_HORIZ - %d", iExist));

                    if (pddShm->ba.rectsUsed < BA_MAX_ACCUMULATED_RECTS &&
                            level < ADDR_RECURSE_LIMIT) {
                        if (((pCand->bottom - pCand->top) *
                                (pddShm->ba.bounds[iExist].coord.right -
                                pddShm->ba.bounds[iExist].coord.left)) >
                                MIN_OVERLAP_BYTES) {
                            rectNew.left =
                                    pddShm->ba.bounds[iExist].coord.right;
                            rectNew.right = pCand->right;
                            rectNew.top = pCand->top;
                            rectNew.bottom = pCand->bottom;
                            pCand->right =
                                     pddShm->ba.bounds[iExist].coord.left;

                            TRC_DBG((TB, "*** RECURSION ***"));
                            BAAddRect(&rectNew, level);
                            TRC_DBG((TB, "*** RETURN    ***"));

                            if (!fRectToAdd &&
                                    !pddShm->ba.bounds[iLastMerge].inUse) {
                                TRC_DBG((TB, "FINISHED - %d", iLastMerge));
                                DC_QUIT;
                            }

                            // After the recursion, because the candidate has
                            // changed, restart the comparisons to check for
                            // overlaps between the adjusted candidate and
                            // other existing rectangles.
                            fResetRects = TRUE;
                        }
                    }
                    break;


                case OL_SPLIT_VERT:
                    // The existing overlaps the candidate, but neither can
                    // be merged or adjusted. Split candidate into top and
                    // bottom similar to OL_SPLIT_HORIZ above.
                    TRC_DBG((TB, "OL_SPLIT_VERT - %d", iExist));
                    if (pddShm->ba.rectsUsed < BA_MAX_ACCUMULATED_RECTS &&
                            level < ADDR_RECURSE_LIMIT) {
                        if (((pCand->right - pCand->left) *
                                (pddShm->ba.bounds[iExist].coord.bottom -
                                pddShm->ba.bounds[iExist].coord.top)) >
                                MIN_OVERLAP_BYTES) {
                            rectNew.left = pCand->left;
                            rectNew.right = pCand->right;
                            rectNew.top =
                                    pddShm->ba.bounds[iExist].coord.bottom;
                            rectNew.bottom = pCand->bottom;
                            pCand->bottom =
                                    pddShm->ba.bounds[iExist].coord.top;

                            TRC_DBG((TB, "*** RECURSION ***"));
                            BAAddRect(&rectNew, level);
                            TRC_DBG((TB, "*** RETURN    ***"));

                            if (!fRectToAdd &&
                                    !pddShm->ba.bounds[iLastMerge].inUse) {
                                TRC_DBG((TB, "FINISHED - %d", iLastMerge));
                                DC_QUIT;
                            }

                            // After the recursion, because the candidate has
                            // changed, restart the comparisons to check for
                            // overlaps between the adjusted candidate and
                            // other existing rectangles.
                            fResetRects = TRUE;
                        }
                    }
                    break;


                case OL_SPLIT_LEFT_TOP:
                    // The existing overlaps the candicate at the existing
                    // rect's top left, but neither can be merged or adjusted.
                    //
                    //      100,100 +---------------+
                    //              |   Cand        |
                    //              |               |
                    //              |    150,150    |
                    //              |       +-------+-----+
                    //              |       |       |     |
                    //              |       |       |     |
                    //              +-------+-------+     |
                    //                      |    200,200  |
                    //                      |             |
                    //                      |    Exist    |
                    //                      +-------------+ 250, 250
                    //
                    // Need to split candidate into top and left pieces.
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the left and a new rectangle on
                    // the top. Call this routine recursively to handle
                    // the new rectangle.
                    //
                    //                   151,100
                    //      100,100 +-------+-------+
                    //              |       |       |
                    //              |       |  New  |
                    //              |       |       |200,149
                    //              |       +-------+-----+
                    //              | Cand  |150,150      |
                    //              |       |             |
                    //              +-------+    Exist    |
                    //               150,200|             |
                    //                      |             |
                    //                      |             |
                    //                      +-------------+ 250,250
                    TRC_DBG((TB, "OL_SPLIT_LEFT_TOP - %d", iExist));
                    if (pddShm->ba.rectsUsed < BA_MAX_ACCUMULATED_RECTS &&
                         level < ADDR_RECURSE_LIMIT) {
                        if (((pCand->right -
                                pddShm->ba.bounds[iExist].coord.left) *
                                (pCand->bottom -
                                pddShm->ba.bounds[iExist].coord.top)) >
                                MIN_OVERLAP_BYTES) {
                            rectNew.left =
                                    pddShm->ba.bounds[iExist].coord.left;
                            rectNew.right = pCand->right;
                            rectNew.top = pCand->top;
                            rectNew.bottom =
                                    pddShm->ba.bounds[iExist].coord.top;
                            pCand->right =
                                    pddShm->ba.bounds[iExist].coord.left;

                            TRC_DBG((TB, "*** RECURSION ***"));
                            BAAddRect(&rectNew, level);
                            TRC_DBG((TB, "*** RETURN    ***"));

                            if (!fRectToAdd &&
                                    !pddShm->ba.bounds[iLastMerge].inUse) {
                                TRC_DBG((TB, "FINISHED - %d", iLastMerge));
                                DC_QUIT;
                            }

                            // After the recursion, because the candidate has
                            // changed, restart the comparisons to check for
                            // overlaps between the adjusted candidate and
                            // other existing rectangles.
                            fResetRects = TRUE;
                        }
                    }
                    break;


                case OL_SPLIT_RIGHT_TOP:
                    // The existing overlaps the candidate, but neither can
                    // be merged or adjusted. Split into top and right
                    // pieces if there is room in the list, similar to
                    // OL_SPLIT_LEFT_TOP above.
                    TRC_DBG((TB, "OL_SPLIT_RIGHT_TOP - %d", iExist));
                    if (pddShm->ba.rectsUsed < BA_MAX_ACCUMULATED_RECTS &&
                            level < ADDR_RECURSE_LIMIT) {
                        if (((pddShm->ba.bounds[iExist].coord.right -
                                pCand->left) * (pCand->bottom -
                                pddShm->ba.bounds[iExist].coord.top)) >
                                MIN_OVERLAP_BYTES) {
                            rectNew.left = pCand->left;
                            rectNew.right =
                                    pddShm->ba.bounds[iExist].coord.right;
                            rectNew.top = pCand->top;
                            rectNew.bottom =
                                    pddShm->ba.bounds[iExist].coord.top;
                            pCand->left =
                                    pddShm->ba.bounds[iExist].coord.right;

                            TRC_DBG((TB, "*** RECURSION ***"));
                            BAAddRect(&rectNew, level);
                            TRC_DBG((TB, "*** RETURN    ***"));

                            if (!fRectToAdd &&
                                    !pddShm->ba.bounds[iLastMerge].inUse) {
                                TRC_DBG((TB, "FINISHED - %d", iLastMerge));
                                DC_QUIT;
                            }

                            // After the recursion, because the candidate has
                            // changed, restart the comparisons to check for
                            // overlaps between the adjusted candidate and
                            // other existing rectangles.
                            fResetRects = TRUE;
                        }
                    }
                    break;


                case OL_SPLIT_LEFT_BOTTOM:
                    // The existing overlaps the candidate, but neither can
                    // be merged or adjusted. Split into left and bottom
                    // pieces if there is room in the list, similar to
                    // OL_SPLIT_LEFT_TOP above.
                    TRC_DBG((TB, "OL_SPLIT_LEFT_BOTTOM - %d", iExist));
                    if (pddShm->ba.rectsUsed < BA_MAX_ACCUMULATED_RECTS &&
                            level < ADDR_RECURSE_LIMIT) {
                        if (((pCand->right -
                                pddShm->ba.bounds[iExist].coord.left) *
                                (pddShm->ba.bounds[iExist].coord.bottom -
                                pCand->top)) > MIN_OVERLAP_BYTES) {
                            rectNew.left =
                                    pddShm->ba.bounds[iExist].coord.left;
                            rectNew.right = pCand->right;
                            rectNew.top =
                                    pddShm->ba.bounds[iExist].coord.bottom;
                            rectNew.bottom = pCand->bottom;
                            pCand->right =
                                    pddShm->ba.bounds[iExist].coord.left;

                            TRC_DBG((TB, "*** RECURSION ***"));
                            BAAddRect(&rectNew, level);
                            TRC_DBG((TB, "*** RETURN    ***"));

                            if (!fRectToAdd &&
                                    !pddShm->ba.bounds[iLastMerge].inUse) {
                                TRC_DBG((TB, "FINISHED - %d", iLastMerge));
                                DC_QUIT;
                            }

                            // After the recursion, because the candidate has
                            // changed, restart the comparisons to check for
                            // overlaps between the adjusted candidate and
                            // other existing rectangles.
                            fResetRects = TRUE;
                        }
                    }
                    break;


                case OL_SPLIT_RIGHT_BOTTOM:
                    // The existing overlaps the candidate, but neither can
                    // be merged or adjusted. Split into right and bottom
                    // pieces if there is room in the list, similar to
                    // OL_SPLIT_LEFT_TOP above.
                    TRC_DBG((TB, "OL_SPLIT_RIGHT_BOTTOM - %d", iExist));
                    if (pddShm->ba.rectsUsed < BA_MAX_ACCUMULATED_RECTS &&
                            level < ADDR_RECURSE_LIMIT) {
                        if (((pddShm->ba.bounds[iExist].coord.right -
                               pCand->left) *
                               (pddShm->ba.bounds[iExist].coord.bottom -
                               pCand->top)) > MIN_OVERLAP_BYTES) {
                            rectNew.left = pCand->left;
                            rectNew.right =
                                    pddShm->ba.bounds[iExist].coord.right;
                            rectNew.top =
                                    pddShm->ba.bounds[iExist].coord.bottom;
                            rectNew.bottom = pCand->bottom;
                            pCand->left =
                                    pddShm->ba.bounds[iExist].coord.right;

                            TRC_DBG((TB, "*** RECURSION ***"));
                            BAAddRect(&rectNew, level);
                            TRC_DBG((TB, "*** RETURN    ***"));

                            if (!fRectToAdd &&
                                    !pddShm->ba.bounds[iLastMerge].inUse) {
                                TRC_DBG((TB, "FINISHED - %d", iLastMerge));
                                DC_QUIT;
                            }

                            // After the recursion, because the candidate has
                            // changed, restart the comparisons to check for
                            // overlaps between the adjusted candidate and
                            // other existing rectangles.
                            fResetRects = TRUE;
                        }
                    }
                    break;

                default:
                    TRC_ERR((TB, "Unrecognised overlap case-%d",
                            overlapType));
                    break;
            }

            iExist = (!fResetRects) ? pddShm->ba.bounds[iExist].iNext :
                    pddShm->ba.firstRect;
        }

        // Arriving here means that no overlap was found between the
        // candidate and the existing rectangles.
        // - If the candidate is the original rectangle, add it to the list.
        // - If the candidate is an existing rectangle, it is already in
        //   the list.
        if (fRectToAdd)
            BAAddRectList(pCand);

        // The compare and add processing above is allowed to add a
        // rectangle to the list when there are already BA_MAX_NUM_RECTS
        // (eg. when doing a split or when there is no overlap at all with
        // the existing rectangles) - there is an extra slot for that purpose.
        // If we now have more than BA_MAX_NUM_RECTS rectangles, do a
        // forced merge, so that the next call to this routine has a spare
        // slot.
        fRectMerged = (pddShm->ba.rectsUsed > BA_MAX_ACCUMULATED_RECTS);
        if (fRectMerged) {
            // Start looking for merged rectangles. For each rectangle in the
            // list, compare it with the others, and Determine cost of
            // merging. We want to merge the two rectangles with the minimum
            // area difference, ie that will produce a merged rectangle that
            // covers the least superfluous screen area.
            bestMergeIncrease = 0x7FFFFFFF;

            // Recalculate the real areas of the current rectangles. We
            // cannot rely upon the current area value since the rect
            // edges may have changed during a merge and the area not
            // recalculated.
            for (iExist = pddShm->ba.firstRect;
                    iExist != BA_INVALID_RECT_INDEX;
                    iExist = pddShm->ba.bounds[iExist].iNext)
                BARecalcArea(iExist);

            for (iExist = pddShm->ba.firstRect;
                    iExist != BA_INVALID_RECT_INDEX;
                    iExist = pddShm->ba.bounds[iExist].iNext) {
                for (iTmp = pddShm->ba.bounds[iExist].iNext;
                        iTmp != BA_INVALID_RECT_INDEX;
                        iTmp = pddShm->ba.bounds[iTmp].iNext) {
                    rectNew.left = min(pddShm->ba.bounds[iExist].coord.left,
                            pddShm->ba.bounds[iTmp].coord.left );
                    rectNew.top = min(pddShm->ba.bounds[iExist].coord.top,
                            pddShm->ba.bounds[iTmp].coord.top );
                    rectNew.right = max(pddShm->ba.bounds[iExist].coord.right,
                            pddShm->ba.bounds[iTmp].coord.right );
                    rectNew.bottom = max(pddShm->ba.bounds[iExist].coord.bottom,
                            pddShm->ba.bounds[iTmp].coord.bottom );

                    mergeIncrease = COM_SIZEOF_RECT(rectNew) -
                            pddShm->ba.bounds[iExist].area -
                            pddShm->ba.bounds[iTmp].area;

                    if (bestMergeIncrease > mergeIncrease) {
                        iBestMerge1 = iExist;
                        iBestMerge2 = iTmp;
                        bestMergeIncrease = mergeIncrease;
                    }
                }
            }

            // Now do the merge.
            // We recalculate the size of the merged rectangle here -
            // alternatively we could remember the size of the best so far
            // in the loop above.  The trade off is between calculating
            // twice or copying at least once but probably more than once
            // as we find successively better merges.
            TRC_DBG((TB, "Merge ix %d, (%d,%d,%d,%d)", iBestMerge1,
                    pddShm->ba.bounds[iBestMerge1].coord.left,
                    pddShm->ba.bounds[iBestMerge1].coord.top,
                    pddShm->ba.bounds[iBestMerge1].coord.right,
                    pddShm->ba.bounds[iBestMerge1].coord.bottom ));

            TRC_DBG((TB, "Merge ix %d, (%d,%d,%d,%d)", iBestMerge2,
                    pddShm->ba.bounds[iBestMerge2].coord.left,
                    pddShm->ba.bounds[iBestMerge2].coord.top,
                    pddShm->ba.bounds[iBestMerge2].coord.right,
                    pddShm->ba.bounds[iBestMerge2].coord.bottom ));

            pddShm->ba.bounds[iBestMerge1].coord.left =
                    min(pddShm->ba.bounds[iBestMerge1].coord.left,
                    pddShm->ba.bounds[iBestMerge2].coord.left);
            pddShm->ba.bounds[iBestMerge1].coord.top =
                    min(pddShm->ba.bounds[iBestMerge1].coord.top,
                    pddShm->ba.bounds[iBestMerge2].coord.top );
            pddShm->ba.bounds[iBestMerge1].coord.right =
                    max(pddShm->ba.bounds[iBestMerge1].coord.right,
                    pddShm->ba.bounds[iBestMerge2].coord.right);
            pddShm->ba.bounds[iBestMerge1].coord.bottom =
                    max(pddShm->ba.bounds[iBestMerge1].coord.bottom,
                    pddShm->ba.bounds[iBestMerge2].coord.bottom);

            // Remove the second best merge.
            BARemoveRectList(iBestMerge2);

            // The best merged rectangle becomes the candidate, and we fall
            // back to the head of the comparison loop to start again.
            pCand = &(pddShm->ba.bounds[iBestMerge1].coord);
            iLastMerge = iBestMerge1;
            fRectToAdd = FALSE;
        }
    } while (fRectMerged);


DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}


#ifdef DC_DEBUG
/****************************************************************************/
// BAPerformUnitTests
//
// Verifies some basic assumptions of the BA algorithms, in case it breaks
// while being changed. Performed only on init.
/****************************************************************************/

// Test data. Note that these tests are designed for BA using exclusive rects.

typedef struct
{
    const char *TestName;
    const RECTL *MustBePresent;
    unsigned NumPresent;
} Validation;

// Start with a rect out in the middle area.
const RECTL Test1StartAdd = { 10, 10, 20, 20 };
const Validation Test1StartVerify = { "Test1Start", &Test1StartAdd, 1 };

// Add a rect of the same height 2 pixels off the right edge of rect1.
// Should not merge with rect1.
const RECTL Test1Step1Add = { 21, 10, 31, 20 };
const RECTL Test1Step1Ver[2] = { { 10, 10, 20, 20 }, { 21, 10, 31, 20 } };
const Validation Test1Step1Verify = { "Test1Step1", Test1Step1Ver, 2 };

// Add a rect of the same width immediately left of but not intersecting
// with rect1. Should be merged into one large rect.
const RECTL Test1Step2Add = { 0, 10, 10, 20 };
const RECTL Test1Step2Ver[2] = { { 0, 10, 20, 20 }, { 21, 10, 31, 20 } };
const Validation Test1Step2Verify = { "Test1Step2", Test1Step2Ver, 2 };

// Add a rect of the same width intersecting rect2 at its top.
// Should be merged into one large rect.
const RECTL Test1Step3Add = { 21, 5, 31, 15 };
const RECTL Test1Step3Ver[2] = { { 0, 10, 20, 20 }, { 21, 5, 31, 20 } };
const Validation Test1Step3Verify = { "Test1Step3", Test1Step3Ver, 2 };

// Add a rect that intersects rect1 at its bottom but is smaller in
// width and partially enclosed within rect1. Rect should be split,
// the top half absorbed into rect1, the bottom a new rect.
const RECTL Test1Step4Add = { 5, 15, 10, 25 };
const RECTL Test1Step4Ver[3] = {
    { 0, 10, 20, 20 }, { 21, 5, 31, 20 }, { 5, 20, 10, 25 }
};
const Validation Test1Step4Verify = { "Test1Step4", Test1Step4Ver, 3 };


// Worker func to verify the contents of the rects. Returns FALSE if
// the 
void AddAndValidateRects(const RECTL *pAdd, const Validation *pVal)
{
    BOOL rc = TRUE;
    RECTL Rects[BA_MAX_ACCUMULATED_RECTS];
    unsigned i, j;
    unsigned NumRects;
    BYTE RectFound[BA_MAX_ACCUMULATED_RECTS] = { 0 };
    RECTL Add;

    DC_BEGIN_FN("AddAndValidateRects");

    // Make a copy of *pAdd since BAAddRect can modify it.
    Add = *pAdd;
    BAAddRect(&Add, 0);
    BACopyBounds(Rects, &NumRects);
    TRC_ASSERT((NumRects == pVal->NumPresent),
            (TB,"%s failure: NumRects=%u, should be %u", pVal->TestName,
            NumRects, pVal->NumPresent));

    for (i = 0; i < NumRects; i++) {
        for (j = 0; j < NumRects; j++) {
            if (!memcmp(&Rects[i], &pVal->MustBePresent[j], sizeof(RECTL)))
                RectFound[j] = TRUE;
        }
    }

    for (i = 0; i < NumRects; i++) {
        if (!RectFound[i]) {
            TRC_ERR((TB,"BA validation error, rects:"));
            for (j = 0; j < NumRects; j++)
                TRC_ERR((TB,"    %u: (%u,%u,%u,%u)", j, Rects[j].left,
                        Rects[j].top, Rects[j].right, Rects[j].bottom));
            TRC_ASSERT((RectFound[i]),(TB,"%s failure: MustBePresent rect %u "
                    "was not present", pVal->TestName, i));
        }
    }

    DC_END_FN();
}


// The real function.
void BAPerformUnitTests()
{
    RECTL Rect1, Rect2;
    
    DC_BEGIN_FN("BAPerformUnitTests");

    // Test1.
    AddAndValidateRects(&Test1StartAdd, &Test1StartVerify);
    AddAndValidateRects(&Test1Step1Add, &Test1Step1Verify);
    AddAndValidateRects(&Test1Step2Add, &Test1Step2Verify);
    AddAndValidateRects(&Test1Step3Add, &Test1Step3Verify);
    AddAndValidateRects(&Test1Step4Add, &Test1Step4Verify);

}
#endif  // DC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpdd\color.c ===
/******************************Module*Header*******************************\
* Module Name: color.c
*
* This algorithm for color dithering is patent pending and its use is
* restricted to Microsoft products and drivers for Microsoft products.
* Use in non-Microsoft products or in drivers for non-Microsoft product is
* prohibited without written permission from Microsoft.
*
* The patent application is the primary reference for the operation of the
* color dithering code.
*
* Note that in the comments and variable names, "vertex" means "vertex of
* either the inner (half intensity) or outer (full intensity) color cube."
* Vertices map to colors 0-6 and 248-255 of the Windows standard (required)
* 256-color palette, where vertices 0-6 and 248 are the vertices of the inner
* color cube, and 0 plus 249-255 are the vertices of the full color cube.
* Vertex 7 is 75% gray; this could be used in the dither, but that would break
* apps that depend on the exact Windows 3.1 dithering. This code is Window 3.1
* compatible.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

#include <precmpdd.h>
#define hdrstop
#include <nddapi.h>

/**************************************************************************\
* This function takes a value from 0 - 255 and uses it to create an
* 8x8 pile of bits in the form of a 1BPP bitmap.  It can also take an
* RGB value and make an 8x8 bitmap.  These can then be used as brushes
* to simulate color unavaible on the device.
*
* For monochrome the basic algorithm is equivalent to turning on bits
* in the 8x8 array according to the following order:
*
*  00 32 08 40 02 34 10 42
*  48 16 56 24 50 18 58 26
*  12 44 04 36 14 46 06 38
*  60 28 52 20 62 30 54 22
*  03 35 11 43 01 33 09 41
*  51 19 59 27 49 17 57 25
*  15 47 07 39 13 45 05 37
*  63 31 55 23 61 29 53 21
*
* Reference: A Survey of Techniques for the Display of Continous
*            Tone Pictures on Bilevel Displays,;
*            Jarvis, Judice, & Ninke;
*            COMPUTER GRAPHICS AND IMAGE PROCESSING 5, pp 13-40, (1976)
\**************************************************************************/

#define SWAP_RB 0x00000004
#define SWAP_GB 0x00000002
#define SWAP_RG 0x00000001

#define SWAPTHEM(a,b) (ulTemp = a, a = b, b = ulTemp)

// PATTERNSIZE is the number of pixels in a dither pattern.
#define PATTERNSIZE 64

typedef union _PAL_ULONG {
    PALETTEENTRY pal;
    ULONG ul;
} PAL_ULONG;

typedef struct _VERTEX_DATA {
    ULONG ulCount;  // # of pixels in this vertex
    ULONG ulVertex; // vertex #
} VERTEX_DATA;

// Tells which row to turn a pel on in when dithering for monochrome bitmaps.
const BYTE ajByte[] = {
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7,
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7
};

// The array of monochrome bits used for monc
const BYTE ajBits[] = {
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80
};

// Translates vertices back to the original subspace. Each row is a subspace,
// as encoded in ulSymmetry, and each column is a vertex between 0 and 15.
const BYTE jSwapSubSpace[8*16] = {
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    0, 2, 1, 3, 4, 6, 5, 7, 8, 10, 9, 11, 12, 14, 13, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 4, 2, 6, 1, 5, 3, 7, 8, 12, 10, 14, 9, 13, 11, 15,
    0, 2, 4, 6, 1, 3, 5, 7, 8, 10, 12, 14, 9, 11, 13, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
};

// Converts a nibble value in the range 0-15 to a dword value containing the
// nibble value packed 8 times.
const ULONG ulNibbleToDwordWithConvert[16] = {
    0x00000000,
    0x01010101,
    0x02020202,
    0x03030303,
    0x04040404,
    0x05050505,
    0x06060606,
    0xF8F8F8F8,
    0x07070707,
    0xF9F9F9F9,
    0xFAFAFAFA,
    0xFBFBFBFB,
    0xFCFCFCFC,
    0xFDFDFDFD,
    0xFEFEFEFE,
    0xFFFFFFFF
};

// Specifies where in the dither pattern colors should be placed in order
// of increasing intensity.
const ULONG aulDitherOrder[] = {
  0, 36,  4, 32, 18, 54, 22, 50,
  2, 38,  6, 34, 16, 52, 20, 48,
  9, 45, 13, 41, 27, 63, 31, 59,
 11, 47, 15, 43, 25, 61, 29, 57,
  1, 37,  5, 33, 19, 55, 23, 51,
  3, 39,  7, 35, 17, 53, 21, 49,
  8, 44, 12, 40, 26, 62, 30, 58,
 10, 46, 14, 42, 24, 60, 28, 56,
};

// Array to convert to 256 color from 16 color. Maps from index that represents
// a 16-color vertex (color) to value that specifies the color index in the
// 256-color palette.

const BYTE ajConvert[] =
{
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    248,
    7,
    249,
    250,
    251,
    252,
    253,
    254,
    255
};

/******************************Public*Routine******************************\
* DrvDitherColor
*
* Dithers an RGB color to an 8X8 approximation using the reserved VGA colors
*
\**************************************************************************/

ULONG DrvDitherColor(
IN  DHPDEV dhpdev,
IN  ULONG  iMode,
IN  ULONG  rgb,
OUT ULONG *pul)
{
    ULONG   ulGrey, ulRed, ulGre, ulBlu, ulSymmetry;
    ULONG   ulRedTemp, ulGreenTemp, ulBlueTemp, ulTemp;
    VERTEX_DATA vVertexData[4];
    VERTEX_DATA *pvVertexData;
    VERTEX_DATA *pvVertexDataEnd;
    ULONG  *pulDitherOrder;
    ULONG   ulNumPixels;
    BYTE    jColor;
    ULONG   ulColor;
    VERTEX_DATA *pvMaxVertex;
    ULONG   ulVertex0Temp, ulVertex1Temp, ulVertex2Temp, ulVertex3Temp;
    BYTE   *pjDither = (BYTE *)pul;
    BYTE   *savePul;
    BYTE    Dither8x8[64];

    // If the target is a 4bpp brush, create the 8bpp brush in a temporary
    // work buffer and copy it to the target later.
    if (((PDD_PDEV)dhpdev)->iBitmapFormat == BMF_4BPP) {
        savePul = (BYTE *)pul;
        pul = (ULONG *)Dither8x8;
        pjDither = Dither8x8;
    }

    // Figure out if we need a full color dither or only a monochrome dither
    if (iMode != DM_MONOCHROME) {

        // Full color dither

        // Split the color into red, green, and blue components
        ulRedTemp   = ((PAL_ULONG *)&rgb)->pal.peRed;
        ulGreenTemp   = ((PAL_ULONG *)&rgb)->pal.peGreen;
        ulBlueTemp   = ((PAL_ULONG *)&rgb)->pal.peBlue;

        // Sort the RGB so that the point is transformed into subspace 0, and
        // keep track of the swaps in ulSymmetry so we can unravel it again
        // later.  We want r >= g >= b (subspace 0).
        ulSymmetry = 0;
        if (ulBlueTemp > ulRedTemp) {
            SWAPTHEM(ulBlueTemp,ulRedTemp);
            ulSymmetry = SWAP_RB;
        }

        if (ulBlueTemp > ulGreenTemp) {
            SWAPTHEM(ulBlueTemp,ulGreenTemp);
            ulSymmetry |= SWAP_GB;
        }

        if (ulGreenTemp > ulRedTemp) {
            SWAPTHEM(ulGreenTemp,ulRedTemp);
            ulSymmetry |= SWAP_RG;
        }

        ulSymmetry <<= 4;   // for lookup purposes

        // Scale the values from 0-255 to 0-64. Note that the scaling is not
        // symmetric at the ends; this is done to match Windows 3.1 dithering
        ulRed = (ulRedTemp + 1) >> 2;
        ulGre = (ulGreenTemp + 1) >> 2;
        ulBlu = (ulBlueTemp + 1) >> 2;

        // Compute the subsubspace within subspace 0 in which the point lies,
        // then calculate the # of pixels to dither in the colors that are the
        // four vertexes of the tetrahedron bounding the color we're emulating.
        // Only vertices with more than zero pixels are stored, and the
        // vertices are stored in order of increasing intensity, saving us the
        // need to sort them later
        if ((ulRedTemp + ulGreenTemp) > 256) {
            // Subsubspace 2 or 3
            if ((ulRedTemp + ulBlueTemp) > 256) {
                // Subsubspace 3
                // Calculate the number of pixels per vertex, still in
                // subsubspace 3, then convert to original subspace. The pixel
                // counts and vertex numbers are matching pairs, stored in
                // ascending intensity order, skipping vertices with zero
                // pixels. The vertex intensity order for subsubspace 3 is:
                // 7, 9, 0x0B, 0x0F
                pvVertexData = vVertexData;
                if ((ulVertex0Temp = (64 - ulRed) << 1) != 0) {
                    pvVertexData->ulCount = ulVertex0Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
                }
                ulVertex2Temp = ulGre - ulBlu;
                ulVertex3Temp = (ulRed - 64) + ulBlu;
                if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                        ulVertex2Temp) - ulVertex3Temp) != 0) {
                    pvVertexData->ulCount = ulVertex1Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
                }
                if (ulVertex2Temp != 0) {
                    pvVertexData->ulCount = ulVertex2Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
                }
                if (ulVertex3Temp != 0) {
                    pvVertexData->ulCount = ulVertex3Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0F];
                }
            } else {
                // Subsubspace 2
                // Calculate the number of pixels per vertex, still in
                // subsubspace 2, then convert to original subspace. The pixel
                // counts and vertex numbers are matching pairs, stored in
                // ascending intensity order, skipping vertices with zero
                // pixels. The vertex intensity order for subsubspace 2 is:
                // 3, 7, 9, 0x0B
                pvVertexData = vVertexData;
                ulVertex1Temp = ulBlu << 1;
                ulVertex2Temp = ulRed - ulGre;
                ulVertex3Temp = (ulRed - 32) + (ulGre - 32);
                if ((ulVertex0Temp = ((PATTERNSIZE - ulVertex1Temp) -
                            ulVertex2Temp) - ulVertex3Temp) != 0) {
                    pvVertexData->ulCount = ulVertex0Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
                }
                if (ulVertex1Temp != 0) {
                    pvVertexData->ulCount = ulVertex1Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
                }
                if (ulVertex2Temp != 0) {
                    pvVertexData->ulCount = ulVertex2Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
                }
                if (ulVertex3Temp != 0) {
                    pvVertexData->ulCount = ulVertex3Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
                }
            }
        } else {
            // Subsubspace 0 or 1
            if (ulRedTemp > 128) {
                // Subsubspace 1
                // Calculate the number of pixels per vertex, still in
                // subsubspace 1, then convert to original subspace. The pixel
                // counts and vertex numbers are matching pairs, stored in
                // ascending intensity order, skipping vertices with zero
                // pixels. The vertex intensity order for subsubspace 1 is:
                // 1, 3, 7, 9
                pvVertexData = vVertexData;
                if ((ulVertex0Temp = ((32 - ulGre) + (32 - ulRed)) << 1) != 0) {
                    pvVertexData->ulCount = ulVertex0Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
                }
                ulVertex2Temp = ulBlu << 1;
                ulVertex3Temp = (ulRed - 32) << 1;
                if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                        ulVertex2Temp) - ulVertex3Temp) != 0) {
                    pvVertexData->ulCount = ulVertex1Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
                }
                if (ulVertex2Temp != 0) {
                    pvVertexData->ulCount = ulVertex2Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
                }
                if (ulVertex3Temp != 0) {
                    pvVertexData->ulCount = ulVertex3Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
                }
            } else {
                // Subsubspace 0
                // Calculate the number of pixels per vertex, still in
                // subsubspace 0, then convert to original subspace. The pixel
                // counts and vertex numbers are matching pairs, stored in
                // ascending intensity order, skipping vertices with zero
                // pixels. The vertex intensity order for subsubspace 0 is:
                // 0, 1, 3, 7
                pvVertexData = vVertexData;
                if ((ulVertex0Temp = (32 - ulRed) << 1) != 0) {
                    pvVertexData->ulCount = ulVertex0Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x00];
                }
                if ((ulVertex1Temp = (ulRed - ulGre) << 1) != 0) {
                    pvVertexData->ulCount = ulVertex1Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
                }
                ulVertex3Temp = ulBlu << 1;
                if ((ulVertex2Temp = ((PATTERNSIZE - ulVertex0Temp) -
                        ulVertex1Temp) - ulVertex3Temp) != 0) {
                    pvVertexData->ulCount = ulVertex2Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
                }
                if (ulVertex3Temp != 0) {
                    pvVertexData->ulCount = ulVertex3Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
                }
            }
        }

        // Now that we have found the bounding vertices and the number of
        // pixels to dither for each vertex, we can create the dither pattern

        // Handle 1, 2, and 3 & 4 vertices per dither separately
        ulTemp = (ULONG)(UINT_PTR)(pvVertexData - vVertexData); // # of vertices with more than
                                                // zero pixels
        if (ulTemp > 2) {

            // There are 3 or 4 vertices in this dither

            if (ulTemp == 3) {

                // There are 3 vertices in this dither

                // Find the vertex with the most pixels, and fill the whole
                // destination bitmap with that vertex's color, which is faster
                // than dithering it
                if (vVertexData[1].ulCount >= vVertexData[2].ulCount) {
                    pvMaxVertex = &vVertexData[1];
                    ulTemp = vVertexData[1].ulCount;
                } else {
                    pvMaxVertex = &vVertexData[2];
                    ulTemp = vVertexData[2].ulCount;
                }

            } else {

                // There are 4 vertices in this dither

                // Find the vertex with the most pixels, and fill the whole
                // destination bitmap with that vertex's color, which is faster
                // than dithering it
                if (vVertexData[2].ulCount >= vVertexData[3].ulCount) {
                    pvMaxVertex = &vVertexData[2];
                    ulTemp = vVertexData[2].ulCount;
                } else {
                    pvMaxVertex = &vVertexData[3];
                    ulTemp = vVertexData[3].ulCount;
                }
            }

            if (vVertexData[1].ulCount > ulTemp) {
                pvMaxVertex = &vVertexData[1];
                ulTemp = vVertexData[1].ulCount;
            }
            if (vVertexData[0].ulCount > ulTemp) {
                pvMaxVertex = &vVertexData[0];
            }

            pvVertexDataEnd = pvVertexData;

            // Prepare a dword version of the most common vertex number (color)
            ulColor = ulNibbleToDwordWithConvert[pvMaxVertex->ulVertex];

            // Mark that the vertex we're about to do doesn't need to be done
            // later
            pvMaxVertex->ulVertex = 0xFF;

            // Block fill the dither pattern with the more common vertex
            *pul = ulColor;
            *(pul+1) = ulColor;
            *(pul+2) = ulColor;
            *(pul+3) = ulColor;
            *(pul+4) = ulColor;
            *(pul+5) = ulColor;
            *(pul+6) = ulColor;
            *(pul+7) = ulColor;
            *(pul+8) = ulColor;
            *(pul+9) = ulColor;
            *(pul+10) = ulColor;
            *(pul+11) = ulColor;
            *(pul+12) = ulColor;
            *(pul+13) = ulColor;
            *(pul+14) = ulColor;
            *(pul+15) = ulColor;

            // Now dither all the remaining vertices in order 0->2 or 0->3
            // (in order of increasing intensity)
            pulDitherOrder = (ULONG *)aulDitherOrder;
            pvVertexData = vVertexData;
            do {
                if (pvVertexData->ulVertex == 0xFF) {
                    // This is the max vertex, which we already did, but we
                    // have to account for it in the dither order
                    pulDitherOrder += pvVertexData->ulCount;
                } else {
                    jColor = ajConvert[pvVertexData->ulVertex];
                    ulNumPixels = pvVertexData->ulCount;
                    switch (ulNumPixels & 3) {
                        case 3:
                            pjDither[*(pulDitherOrder+2)] = jColor;
                        case 2:
                            pjDither[*(pulDitherOrder+1)] = jColor;
                        case 1:
                            pjDither[*(pulDitherOrder+0)] = jColor;
                            pulDitherOrder += ulNumPixels & 3;
                        case 0:
                            break;
                    }
                    if ((ulNumPixels >>= 2) != 0) {
                        do {
                            pjDither[*pulDitherOrder] = jColor;
                            pjDither[*(pulDitherOrder+1)] = jColor;
                            pjDither[*(pulDitherOrder+2)] = jColor;
                            pjDither[*(pulDitherOrder+3)] = jColor;
                            pulDitherOrder += 4;
                        } while (--ulNumPixels);
                    }
                }
            } while (++pvVertexData < pvVertexDataEnd);

        } else if (ulTemp == 2) {

            // There are exactly two vertices with more than zero pixels; fill
            // in the dither array as follows: block fill with vertex with more
            // points first, then dither in the other vertex
            if (vVertexData[0].ulCount >= vVertexData[1].ulCount) {
                // There are no more vertex 1 than vertex 0 pixels, so do
                // the block fill with vertex 0
                ulColor = ulNibbleToDwordWithConvert[vVertexData[0].ulVertex];
                // Do the dither with vertex 1
                jColor = ajConvert[vVertexData[1].ulVertex];
                ulNumPixels = vVertexData[1].ulCount;
                // Set where to start dithering with vertex 1 (vertex 0 is
                // lower intensity, so its pixels come first in the dither
                // order)
                pulDitherOrder = (ULONG *)aulDitherOrder + vVertexData[0].ulCount;
            } else {
                // There are more vertex 1 pixels, so do the block fill
                // with vertex 1
                ulColor = ulNibbleToDwordWithConvert[vVertexData[1].ulVertex];
                // Do the dither with vertex 0
                jColor = ajConvert[vVertexData[0].ulVertex];
                ulNumPixels = vVertexData[0].ulCount;
                // Set where to start dithering with vertex 0 (vertex 0 is
                // lower intensity, so its pixels come first in the dither
                // order)
                pulDitherOrder = (ULONG *)aulDitherOrder;
            }

            // Block fill the dither pattern with the more common vertex
            *pul = ulColor;
            *(pul+1) = ulColor;
            *(pul+2) = ulColor;
            *(pul+3) = ulColor;
            *(pul+4) = ulColor;
            *(pul+5) = ulColor;
            *(pul+6) = ulColor;
            *(pul+7) = ulColor;
            *(pul+8) = ulColor;
            *(pul+9) = ulColor;
            *(pul+10) = ulColor;
            *(pul+11) = ulColor;
            *(pul+12) = ulColor;
            *(pul+13) = ulColor;
            *(pul+14) = ulColor;
            *(pul+15) = ulColor;

            // Dither in the less common vertex
            switch (ulNumPixels & 3) {
                case 3:
                    pjDither[*(pulDitherOrder+2)] = jColor;
                case 2:
                    pjDither[*(pulDitherOrder+1)] = jColor;
                case 1:
                    pjDither[*(pulDitherOrder+0)] = jColor;
                    pulDitherOrder += ulNumPixels & 3;
                case 0:
                    break;
            }
            if ((ulNumPixels >>= 2) != 0) {
                do {
                    pjDither[*pulDitherOrder] = jColor;
                    pjDither[*(pulDitherOrder+1)] = jColor;
                    pjDither[*(pulDitherOrder+2)] = jColor;
                    pjDither[*(pulDitherOrder+3)] = jColor;
                    pulDitherOrder += 4;
                } while (--ulNumPixels);
            }

        } else {

            // There is only one vertex in this dither

            // No sorting or dithering is needed for just one color; we can
            // just generate the final DIB directly
            ulColor = ulNibbleToDwordWithConvert[vVertexData[0].ulVertex];
            *pul = ulColor;
            *(pul+1) = ulColor;
            *(pul+2) = ulColor;
            *(pul+3) = ulColor;
            *(pul+4) = ulColor;
            *(pul+5) = ulColor;
            *(pul+6) = ulColor;
            *(pul+7) = ulColor;
            *(pul+8) = ulColor;
            *(pul+9) = ulColor;
            *(pul+10) = ulColor;
            *(pul+11) = ulColor;
            *(pul+12) = ulColor;
            *(pul+13) = ulColor;
            *(pul+14) = ulColor;
            *(pul+15) = ulColor;
        }

    } else {

        // For monochrome we will only use the Intensity (grey level)
        RtlFillMemory((PVOID) pul, PATTERNSIZE/2, 0);  // zero the dither bits

        ulRed   = (ULONG) ((PALETTEENTRY *) &rgb)->peRed;
        ulGre = (ULONG) ((PALETTEENTRY *) &rgb)->peGreen;
        ulBlu  = (ULONG) ((PALETTEENTRY *) &rgb)->peBlue;

        // I = .30R + .59G + .11B
        // For convience the following ratios are used:
        //
        //  77/256 = 30.08%
        // 151/256 = 58.98%
        //  28/256 = 10.94%

        ulGrey  = (((ulRed * 77) + (ulGre * 151) + (ulBlu * 28)) >> 8) & 255;

        // Convert the RGBI from 0-255 to 0-64 notation.

        ulGrey = (ulGrey + 1) >> 2;

        while(ulGrey) {
            ulGrey--;
            pul[ajByte[ulGrey]] |= ((ULONG) ajBits[ulGrey]);
        }
    }

    // If the target is a 4bpp brush, copy the just-created 8bpp brush from
    // the temporary buffer into the target
    if (((PDD_PDEV)dhpdev)->iBitmapFormat == BMF_4BPP) {
        BYTE *pSrc;
        BYTE *pDst;
        BYTE *pEnd;

        for (pSrc = Dither8x8, pDst = savePul, pEnd = &(Dither8x8[63]);
            pSrc <= pEnd; pSrc += 2, pDst++) {
            *pDst = (*pSrc << 4) + (*(pSrc + 1) & 0xf);
        }
    }

    return(DCR_DRIVER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpdd\nbaddat.c ===
/****************************************************************************/
// nbaddat.c
//
// RDP bounds accumulator DD data.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

//#include <ndcgdata.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpdd\nbcdisp.c ===
/****************************************************************************/
/* nbcdisp.c                                                                */
/*                                                                          */
/* RDP Bitmap Compressor display driver code                                */
/*                                                                          */
/* Copyright(c) Microsoft 1997-1999                                         */
/****************************************************************************/

#include <precmpdd.h>
#define hdrstop

#define TRC_FILE "nbcdisp"

#define DC_INCLUDE_DATA
#include <ndddata.c>
#undef DC_INCLUDE_DATA

#include <abcapi.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpdd\nbadisp.h ===
/****************************************************************************/
// nbadisp.h
//
// RDP Bounds Accumulator display driver header.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/
#ifndef _H_NBADISP
#define _H_NBADISP


// Maximum recursion level for splitting rectangles, after which merges are
// done.
#define ADDR_RECURSE_LIMIT 20

#define MIN_OVERLAP_BYTES 100


// The following constants are used to determine overlaps.
// - OL_NONE through OL_MERGE_BOTTOM are return codes - which need to be
//   distinct from all possible outcode combinations - allowing for the
//   minus outcodes for enclosed cases.
// - EE_XMIN through EE_YMAX are outcodes - which need to be uniquely
//   ORable binary constants within a single nibble.
// - OL_ENCLOSED through OL_SPLIT_XMAX_YMAX are outcode combinations for
//   internal and external edge overlap cases.
#define OL_NONE               -1
#define OL_MERGE_LEFT         -2
#define OL_MERGE_TOP          -3
#define OL_MERGE_RIGHT        -4
#define OL_MERGE_BOTTOM       -5

#define EE_LEFT   0x0001
#define EE_TOP    0x0002
#define EE_RIGHT  0x0004
#define EE_BOTTOM 0x0008

#define OL_ENCLOSED             -(EE_LEFT | EE_TOP | EE_RIGHT | EE_BOTTOM)
#define OL_PART_ENCLOSED_LEFT   -(EE_LEFT | EE_TOP | EE_BOTTOM)
#define OL_PART_ENCLOSED_TOP    -(EE_LEFT | EE_TOP | EE_RIGHT)
#define OL_PART_ENCLOSED_RIGHT  -(EE_TOP  | EE_RIGHT | EE_BOTTOM)
#define OL_PART_ENCLOSED_BOTTOM -(EE_LEFT | EE_RIGHT | EE_BOTTOM)

#define OL_ENCLOSES             (EE_LEFT | EE_RIGHT | EE_TOP | EE_BOTTOM)
#define OL_PART_ENCLOSES_LEFT   (EE_RIGHT | EE_TOP | EE_BOTTOM)
#define OL_PART_ENCLOSES_RIGHT  (EE_LEFT | EE_TOP | EE_BOTTOM)
#define OL_PART_ENCLOSES_TOP    (EE_LEFT | EE_RIGHT | EE_BOTTOM)
#define OL_PART_ENCLOSES_BOTTOM (EE_LEFT | EE_RIGHT | EE_TOP)
#define OL_SPLIT_HORIZ          (EE_TOP | EE_BOTTOM)
#define OL_SPLIT_VERT           (EE_LEFT | EE_RIGHT)
#define OL_SPLIT_LEFT_TOP       (EE_RIGHT | EE_BOTTOM)
#define OL_SPLIT_RIGHT_TOP      (EE_LEFT | EE_BOTTOM)
#define OL_SPLIT_LEFT_BOTTOM    (EE_RIGHT | EE_TOP)
#define OL_SPLIT_RIGHT_BOTTOM   (EE_LEFT | EE_TOP)


/****************************************************************************/
// Prototypes and inlines
/****************************************************************************/
void RDPCALL BA_DDInit(void);

void RDPCALL BA_InitShm(void);

void RDPCALL BA_AddScreenData(PRECTL);

int  RDPCALL BAOverlap(PRECTL, PRECTL);

void RDPCALL BARemoveRectList(unsigned);

BOOL RDPCALL BAAddRect(PRECTL, int);



#endif /* _H_NBADISP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpdd\nchdisp.c ===
/****************************************************************************/
// (C) 1997-2000 Microsoft Corp.
//
// chdisp.c
//
// Cache Handler - display driver portion.
//
// The Cache Handler is a data structure manager that holds hash keys
// generated from original data. CH deals with individual caches. There can
// be multiple caches in the system, e.g. the memblt caches in SBC and the
// cursor cache in CM. Each cache can be searched (CH_SearchCache),
// added to (CH_CacheKey), and removed from (CH_RemoveCacheEntry).
//
// Each cache has associated with it the concept of an MRU/LRU list, where
// incoming cached items to a full cache cause other items to be evicted
// based on recent usage. The cache owner is notified of evicted items via
// a callback.
/****************************************************************************/

#include <precmpdd.h>
#define hdrstop

#define TRC_FILE "nchdisp"
#include <adcg.h>

#include <adcs.h>

#include <nchdisp.h>

#define DC_INCLUDE_DATA
#include <ndddata.c>
#undef DC_INCLUDE_DATA

#include <cbchash.c>


/*
 * Calculate number of hash buckets given cache enties
 */
UINT RDPCALL CH_CalculateHashBuckets(UINT NumEntries)
{
    UINT NumHashBuckets, Temp, i;

    DC_BEGIN_FN("CH_CalculateHashBuckets");

    if (NumEntries) {
        // Good hash table performance can be created by allocating four times
        // the number of hash buckets as there are items. Round this number to
        // the next higher power of 2 to make masking the hash key bits
        // efficient.
        Temp = NumHashBuckets = 4 * NumEntries;

        // Find the highest bit set in the hash bucket value.
        for (i = 0; Temp > 1; i++)
            Temp >>= 1;

        // See if the original value was actually a power of two, if so we
        // need not waste the extra memory by doubling the number of buckets.
        if ((unsigned)(1 << i) != NumHashBuckets)
            NumHashBuckets = (1 << (i + 1));
    }
    else {
        NumHashBuckets = 0;
    }

    DC_END_FN();
    return NumHashBuckets;
}


/*
 * Calculate cache size in bytes given cache entries
 */
UINT RDPCALL CH_CalculateCacheSize(UINT NumEntries)
{
    UINT CacheSize, NumHashBuckets;
    
    DC_BEGIN_FN("CH_CalculateCacheSize");

    if (NumEntries) {
        NumHashBuckets = CH_CalculateHashBuckets(NumEntries);

        CacheSize = sizeof(CHCACHEDATA) +
                (NumHashBuckets - 1) * sizeof(LIST_ENTRY) +
                NumEntries * sizeof(CHNODE);
    }
    else {
        CacheSize = 0;
    }

    DC_END_FN();
    return CacheSize;
}


/*
 * Init a cache in pre-allocated memory. pContext is caller-
 * defined information particular to the cache. bNotifyRemoveLRU signals that
 * the creator wants to be notified via its cache callback of removal of an
 * LRU entry. bQueryRemoveLRU means the creator wants to be queried for whether
 * a particular LRU cache entry can be removed. If either of bNotifyRemoveLRU
 * or bQueryRemoveLRU is nonzero, a cache callback must be provided.
 * Returns TRUE on success.
 */
void RDPCALL CH_InitCache(
        PCHCACHEDATA    pCacheData,
        unsigned        NumEntries,
        void            *pContext,
        BOOLEAN         bNotifyRemoveLRU,
        BOOLEAN         bQueryRemoveLRU,
        CHCACHECALLBACK pfnCacheCallback)
{
    BOOLEAN rc = FALSE;
    unsigned i;    
    unsigned NumHashBuckets;
    
    DC_BEGIN_FN("CH_InitCache");

    TRC_ASSERT((NumEntries > 0), (TB, "Must have > 0 cache entries"));
    
    NumHashBuckets = CH_CalculateHashBuckets(NumEntries);

    // Initialize the cache. Since the cache mem was not zeroed during
    // alloc, be sure to init all members whose initial value matters.
    pCacheData->HashKeyMask = NumHashBuckets - 1;

    for (i = 0; i < NumHashBuckets; i++)
        InitializeListHead(&pCacheData->HashBuckets[i]);

    pCacheData->pContext = pContext;
    pCacheData->pfnCacheCallback = pfnCacheCallback;
    pCacheData->bNotifyRemoveLRU = (bNotifyRemoveLRU ? TRUE : FALSE);
    pCacheData->bQueryRemoveLRU = (bQueryRemoveLRU ? TRUE : FALSE);
    InitializeListHead(&pCacheData->MRUList);
    InitializeListHead(&pCacheData->FreeList);
    pCacheData->NumEntries = 0;

#ifdef DC_DEBUG
    // Init stat counters.
    pCacheData->MaxEntries = NumEntries;
    pCacheData->NumSearches = 0;
    pCacheData->DeepestSearch = 0;
    pCacheData->NumHits = 0;
    pCacheData->TotalDepthOnHit = 0;
    pCacheData->TotalDepthOnMiss = 0;
    memset(&pCacheData->SearchHitDepthHistogram, 0,
           sizeof(unsigned) * 8);
    memset(&pCacheData->SearchMissDepthHistogram, 0,
           sizeof(unsigned) * 8);
#endif // DC_DEBUG

    // Add all nodes to the free list.
    pCacheData->NodeArray = (CHNODE *)((BYTE *)pCacheData +
                                       sizeof(CHCACHEDATA) + (NumHashBuckets - 1) *
                                       sizeof(LIST_ENTRY));

    for (i = 0; i < NumEntries; i++)
        InsertTailList(&pCacheData->FreeList,
                       &pCacheData->NodeArray[i].HashList);

    TRC_NRM((TB, "Created %u slot cache (%p), hash buckets = %u",
             NumEntries, pCacheData, NumHashBuckets));
 
    DC_END_FN();
}

/*
 * Search the cache using the provided key.
 * Returns FALSE if the key is not present. If the key is present, returns
 * TRUE and fills in *pUserDefined with the UserDefined value associated
 * with the key and *piCacheEntry with the cache index of the item.
 */
BOOLEAN RDPCALL CH_SearchCache(
        CHCACHEHANDLE hCache,
        UINT32        Key1,
        UINT32        Key2,
        void          **pUserDefined,
        unsigned      *piCacheEntry)
{
    PCHCACHEDATA pCacheData;
    BOOLEAN      rc = FALSE;
    CHNODE       *pNode;
    PLIST_ENTRY  pBucketListHead, pCurrentListEntry;
#ifdef DC_DEBUG
    unsigned     SearchDepth = 0;
#endif

    DC_BEGIN_FN("CH_SearchCache");

    TRC_ASSERT((hCache != NULL), (TB, "NULL cache handle"));

    pCacheData = (CHCACHEDATA *)hCache;

    // Find the appropriate hash bucket. Then search the bucket list for the
    // right key.
    pBucketListHead = &pCacheData->HashBuckets[Key1 & pCacheData->HashKeyMask];
    pCurrentListEntry = pBucketListHead->Flink;
    while (pCurrentListEntry != pBucketListHead) {

#ifdef DC_DEBUG
        SearchDepth++;
#endif

        pNode = CONTAINING_RECORD(pCurrentListEntry, CHNODE, HashList);
        if (pNode->Key1 == Key1 && pNode->Key2 == Key2) {
            // Whenever we search a cache entry we bump it to the top of
            // both its bucket list (for perf on real access patterns --
            // add an entry then access it a lot) and its MRU list.
            RemoveEntryList(pCurrentListEntry);
            InsertHeadList(pBucketListHead, pCurrentListEntry);
            RemoveEntryList(&pNode->MRUList);
            InsertHeadList(&pCacheData->MRUList, &pNode->MRUList);

            *pUserDefined = pNode->UserDefined;
            *piCacheEntry = (unsigned)(pNode - pCacheData->NodeArray);
            rc = TRUE;
            break;
        }

        pCurrentListEntry = pCurrentListEntry->Flink;
    }
    
#ifdef DC_DEBUG
    TRC_NRM((TB, "Searched hCache %p, depth count %lu, rc = %d",
            hCache, SearchDepth, rc));

    // Add search to various search stats.
    if (SearchDepth > pCacheData->DeepestSearch) {
        pCacheData->DeepestSearch = SearchDepth;
        TRC_NRM((TB,"hCache %p: New deepest search depth %u",
                hCache, SearchDepth));
    }
    pCacheData->NumSearches++;
    if (SearchDepth > 7)
        SearchDepth = 7;
    if (rc) {
        pCacheData->NumHits++;
        pCacheData->TotalDepthOnHit += SearchDepth;
        pCacheData->SearchHitDepthHistogram[SearchDepth]++;
    }
    else {
        pCacheData->TotalDepthOnMiss += SearchDepth;
        pCacheData->SearchMissDepthHistogram[SearchDepth]++;
    }
    
    if ((pCacheData->NumSearches % CH_STAT_DISPLAY_FREQ) == 0)
        TRC_NRM((TB,"hCache %p: entr=%u/%u, hits/searches=%u/%u, "
                "avg hit srch depth=%u, avg miss srch depth=%u, "
                "hit depth hist: %u %u %u %u %u %u %u %u; "
                "miss depth hist: %u %u %u %u %u %u %u %u",
                hCache,
                pCacheData->NumEntries,
                pCacheData->MaxEntries,
                pCacheData->NumHits,
                pCacheData->NumSearches,
                ((pCacheData->TotalDepthOnHit +
                        (pCacheData->NumHits / 2)) /
                        pCacheData->NumHits),
                ((pCacheData->TotalDepthOnMiss +
                        ((pCacheData->NumSearches -
                            pCacheData->NumHits) / 2)) /
                        (pCacheData->NumSearches - pCacheData->NumHits)),
                pCacheData->SearchHitDepthHistogram[0],
                pCacheData->SearchHitDepthHistogram[1],
                pCacheData->SearchHitDepthHistogram[2],
                pCacheData->SearchHitDepthHistogram[3],
                pCacheData->SearchHitDepthHistogram[4],
                pCacheData->SearchHitDepthHistogram[5],
                pCacheData->SearchHitDepthHistogram[6],
                pCacheData->SearchHitDepthHistogram[7],
                pCacheData->SearchMissDepthHistogram[0],
                pCacheData->SearchMissDepthHistogram[1],
                pCacheData->SearchMissDepthHistogram[2],
                pCacheData->SearchMissDepthHistogram[3],
                pCacheData->SearchMissDepthHistogram[4],
                pCacheData->SearchMissDepthHistogram[5],
                pCacheData->SearchMissDepthHistogram[6],
                pCacheData->SearchMissDepthHistogram[7]));
#endif  // defined(DC_DEBUG)

    DC_END_FN();
    return rc;
}



/*
 * Adds a key to a cache. Returns the index of the new entry within the cache.
 * If no entry could be allocated because the cache callback refused all
 * requests to evict least-recently-used entries, returns CH_KEY_UNCACHABLE.
 */
unsigned RDPCALL CH_CacheKey(
        CHCACHEHANDLE hCache,
        UINT32        Key1,
        UINT32        Key2,
        void          *UserDefined)
{
    PCHCACHEDATA pCacheData;
    PCHNODE      pNode;
    PLIST_ENTRY  pListEntry;
    unsigned     CacheEntryIndex;
    
    DC_BEGIN_FN("CH_CacheKey");

    TRC_ASSERT((hCache != NULL), (TB, "NULL cache handle"));

    pCacheData = (CHCACHEDATA *)hCache;

    // Get a free cache node, either from the free list or by removing
    // the last entry in the MRU list.
    if (!IsListEmpty(&pCacheData->FreeList)) {
        pListEntry = RemoveHeadList(&pCacheData->FreeList);
        pNode = CONTAINING_RECORD(pListEntry, CHNODE, HashList);

        CacheEntryIndex = (unsigned)(pNode - pCacheData->NodeArray);
        pCacheData->NumEntries++;
    }
    else {
        TRC_ASSERT((!IsListEmpty(&pCacheData->MRUList)),
                (TB,"Empty free and MRU lists!"));

        // Different code paths depending on whether the cache creator
        // wants to be queried for LRU removal.
        if (pCacheData->bQueryRemoveLRU) {
            // Start iterating from the end of the MRU list, asking
            // the caller if the entry can be removed.
            pListEntry = pCacheData->MRUList.Blink;
            for (;;) {
                pNode = CONTAINING_RECORD(pListEntry, CHNODE, MRUList);
                CacheEntryIndex = (unsigned)(pNode - pCacheData->NodeArray);
                
                if ((*(pCacheData->pfnCacheCallback))
                        (hCache, CH_EVT_QUERYREMOVEENTRY, CacheEntryIndex,
                        pNode->UserDefined)) {
                    // We can use this entry.
                    RemoveEntryList(pListEntry);
                    RemoveEntryList(&pNode->HashList);
                    break;
                }

                pListEntry = pListEntry->Blink;
                if (pListEntry == &pCacheData->MRUList) {
                    // We reached the end of the list, no removable entries.
                    CacheEntryIndex = CH_KEY_UNCACHABLE;
                    goto EndFunc;
                }
            }
        }
        else {
            pListEntry = RemoveTailList(&pCacheData->MRUList);
            pNode = CONTAINING_RECORD(pListEntry, CHNODE, MRUList);
            RemoveEntryList(&pNode->HashList);
            CacheEntryIndex = (unsigned)(pNode - pCacheData->NodeArray);
        }

        // Call the cache callback to inform of the entry removal.
        if (pCacheData->bNotifyRemoveLRU)
            (*(pCacheData->pfnCacheCallback))
                    (hCache, CH_EVT_ENTRYREMOVED, CacheEntryIndex,
                    pNode->UserDefined);
    }

    // Prepare the node for use.
    pNode->Key1 = Key1;
    pNode->Key2 = Key2;
    pNode->UserDefined = UserDefined;
    pNode->hCache = hCache;

    // Add the node to the front of its bucket list and the MRU list.
    InsertHeadList(&pCacheData->MRUList, &pNode->MRUList);
    InsertHeadList(&pCacheData->HashBuckets[Key1 & pCacheData->HashKeyMask],
            &pNode->HashList);

    TRC_NRM((TB, "Cache %p index %u key1 %lx key2 %lx userdef %p",
            pCacheData, CacheEntryIndex, Key1, Key2, UserDefined));

EndFunc:
    DC_END_FN();
    return CacheEntryIndex;
}



/*
 * Used by bitmap cache code for force the internal representation of
 * the cache structures to a known initial state. This function does minimal
 * checking to make sure of cache integrity -- the cache should be cleared
 * before forcing the contents of the cache else some cache nodes may illegally
 * remain in the MRU lists.
 */
void RDPCALL CH_ForceCacheKeyAtIndex(
        CHCACHEHANDLE hCache,
        unsigned      CacheEntryIndex,
        UINT32        Key1,
        UINT32        Key2,
        void          *UserDefined)
{
    PCHCACHEDATA pCacheData;
    PCHNODE      pNode;
    
    DC_BEGIN_FN("CH_ForceCacheKeyAtIndex");

    TRC_ASSERT((hCache != NULL), (TB, "NULL cache handle"));

    pCacheData = (CHCACHEDATA *)hCache;

    // Find the node. Remove it from the free list.
    TRC_ASSERT((CacheEntryIndex <= pCacheData->MaxEntries),
            (TB,"Index out of bounds!"));
    pNode = &pCacheData->NodeArray[CacheEntryIndex];
    RemoveEntryList(&pNode->HashList);

    // Prepare the node for use.
    pNode->Key1 = Key1;
    pNode->Key2 = Key2;
    pNode->UserDefined = UserDefined;
    pNode->hCache = hCache;

    // Add the node to the front of its bucket list and the end of the MRU list.
    InsertTailList(&pCacheData->MRUList, &pNode->MRUList);
    InsertHeadList(&pCacheData->HashBuckets[Key1 & pCacheData->HashKeyMask],
            &pNode->HashList);

    pCacheData->NumEntries++;

    TRC_NRM((TB, "Cache %p index %u key1 %lx key2 %lx userdef %p",
            pCacheData, CacheEntryIndex, Key1, Key2, UserDefined));

    DC_END_FN();
}



/*
 * Remove an entry by its index number.
 */
void RDPCALL CH_RemoveCacheEntry(
        CHCACHEHANDLE hCache,
        unsigned      CacheEntryIndex)
{
    PCHNODE      pNode;
    PCHCACHEDATA pCacheData;

    DC_BEGIN_FN("CH_RemoveCacheEntry");

    TRC_ASSERT((hCache != NULL), (TB, "NULL cache handle"));

    pCacheData = (CHCACHEDATA *)hCache;
    pNode = &pCacheData->NodeArray[CacheEntryIndex];

    RemoveEntryList(&pNode->MRUList);
    RemoveEntryList(&pNode->HashList);
    InsertHeadList(&pCacheData->FreeList, &pNode->HashList);

    // Call the cache callback to inform of the entry removal.
    if (pCacheData->bNotifyRemoveLRU)
        (*(pCacheData->pfnCacheCallback))
                (hCache, CH_EVT_ENTRYREMOVED, CacheEntryIndex,
                pNode->UserDefined);

    pCacheData->NumEntries--;

    DC_END_FN();
}



/*
 * Clears the cache contents.
 */
void RDPCALL CH_ClearCache(CHCACHEHANDLE hCache)
{
    PCHCACHEDATA pCacheData;
    PLIST_ENTRY  pListEntry;
    PCHNODE      pNode;

    DC_BEGIN_FN("CH_ClearCache");

    TRC_ASSERT((hCache != NULL), (TB, "NULL cache handle"));

    pCacheData = (CHCACHEDATA *)hCache;

    TRC_NRM((TB, "Clear cache %p", pCacheData));

    // Remove all entries in the MRU list.
    while (!IsListEmpty(&pCacheData->MRUList)) {
        pListEntry = RemoveHeadList(&pCacheData->MRUList);
        pNode = CONTAINING_RECORD(pListEntry, CHNODE, MRUList);
        RemoveEntryList(&pNode->HashList);
        InsertHeadList(&pCacheData->FreeList, &pNode->HashList);

        // Call the cache callback to inform of the entry removal.
        if (pCacheData->bNotifyRemoveLRU)
            (*(pCacheData->pfnCacheCallback))
                    (hCache, CH_EVT_ENTRYREMOVED,
                    (unsigned)(pNode - pCacheData->NodeArray),
                    pNode->UserDefined);
    }

    pCacheData->NumEntries = 0;

#if DC_DEBUG
    // Reset stats.
    pCacheData->NumSearches = 0;
    pCacheData->DeepestSearch = 0;
    pCacheData->NumHits = 0;
    pCacheData->TotalDepthOnHit = 0;
    memset(pCacheData->SearchHitDepthHistogram, 0, sizeof(unsigned) * 8);
    pCacheData->TotalDepthOnMiss = 0;
    memset(pCacheData->SearchMissDepthHistogram, 0, sizeof(unsigned) * 8);
#endif

    DC_END_FN();
}

/*
 * Touch the node so that it will be moved to the top of the mru list
 */
void RDPCALL CH_TouchCacheEntry(
        CHCACHEHANDLE hCache, 
        unsigned      CacheEntryIndex)
{
    PCHCACHEDATA pCacheData;
    CHNODE       *pNode;

    DC_BEGIN_FN("CH_TouchCacheEntry");

    TRC_ASSERT((hCache != NULL), (TB, "NULL cache handle"));
    
    pCacheData = (CHCACHEDATA *)hCache;    
    pNode = pCacheData->NodeArray + CacheEntryIndex;

    TRC_ASSERT((pNode != NULL), (TB, "NULL cache node"));

    RemoveEntryList(&pNode->MRUList);
    InsertHeadList(&pCacheData->MRUList, &pNode->MRUList);

    DC_END_FN();
}


/*
 * Return the LRU cache entry
 */
unsigned RDPCALL CH_GetLRUCacheEntry(
        CHCACHEHANDLE hCache)
{
    PCHCACHEDATA pCacheData;
    PCHNODE      pNode;
    PLIST_ENTRY  pListEntry;
    unsigned     CacheEntryIndex;
    
    DC_BEGIN_FN("CH_GetLRUCacheEntry");

    TRC_ASSERT((hCache != NULL), (TB, "NULL cache handle"));

    pCacheData = (CHCACHEDATA *)hCache;

    // Get a free cache node, either from the free list or by removing
    // the last entry in the MRU list.
    if (!IsListEmpty(&pCacheData->MRUList)) {
        pListEntry = (&pCacheData->MRUList)->Blink;
        pNode = CONTAINING_RECORD(pListEntry, CHNODE, MRUList);
        CacheEntryIndex = (unsigned)(pNode - pCacheData->NodeArray);
    }
    else {
        CacheEntryIndex = CH_KEY_UNCACHABLE;
    }
    DC_END_FN();
    return CacheEntryIndex;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpdd\ncmapi.c ===
/****************************************************************************/
// ncmapi.c
//
// RDP Cursor Manager API functions.
//
// Copyright (C) 1996-2000 Microsoft Corporation
/****************************************************************************/

#include <precmpdd.h>
#pragma hdrstop

#define TRC_FILE "ncmapi"
#include <adcg.h>

#include <ncmdisp.h>
#include <nschdisp.h>

#define DC_INCLUDE_DATA
#include <ndddata.c>
#undef DC_INCLUDE_DATA

#include <ncmdata.c>
#include <nchdisp.h>


/****************************************************************************/
/* Name:      CM_DDInit                                                     */
/*                                                                          */
/* Purpose:   Initialises the display driver component of the cursor        */
/*            manager.                                                      */
/*                                                                          */
/* Returns:   TRUE if successful, FALSE otherwise.                          */
/*                                                                          */
/* Params:    IN ppDev - pointer to pDev for work bitmap                    */
/****************************************************************************/
BOOL RDPCALL CM_DDInit(PDD_PDEV ppDev)
{
    BOOL rc = TRUE;
    SIZEL bitmapSize;

    DC_BEGIN_FN("CM_DDInit");

    /************************************************************************/
    /* Allocate the work bitmap, at the local device resolution.  Note that */
    /* we create it "top down" rather than the default of "bottom up" to    */
    /* simplify copying data from the bitmap (we don't have to work out     */
    /* offsets into the data - we can copy from the beginning).             */
    /************************************************************************/
    bitmapSize.cx  = CM_MAX_CURSOR_WIDTH;
    bitmapSize.cy  = CM_MAX_CURSOR_HEIGHT;
    cmWorkBitmap24 = EngCreateBitmap(bitmapSize,
            TS_BYTES_IN_SCANLINE(bitmapSize.cx, 24), BMF_24BPP, BMF_TOPDOWN,
            NULL);

#ifdef DC_HICOLOR
    cmWorkBitmap16 = EngCreateBitmap(bitmapSize,
            TS_BYTES_IN_SCANLINE(bitmapSize.cx, 16), BMF_16BPP, BMF_TOPDOWN,
            NULL);
    if (cmWorkBitmap16 == NULL)
    {
        /********************************************************************/
        /* We can carry on with reduced function without this one           */
        /********************************************************************/
        TRC_ERR((TB, "Failed to create 16bpp work bitmap"));
        pddShm->cm.cmSendAnyColor = FALSE;
    }
#endif

    if (cmWorkBitmap24 != NULL) {
        TRC_NRM((TB, "Created work bitmap successfully"));

        // Reset the cursor stamp.
        cmNextCursorStamp = 0;
    }
    else {
        TRC_ERR((TB, "Failed to create work bitmaps"));
        rc = FALSE;
    }

    DC_END_FN();
    return rc;
}


/****************************************************************************/
/* Name:      CM_Update                                                     */
/*                                                                          */
/* Purpose:   The capabilities may have changed                             */
/****************************************************************************/
void RDPCALL CM_Update(void)
{
    PCHCACHEDATA pCacheData;

    DC_BEGIN_FN("CM_Update");

    /************************************************************************/
    /* Create the cursor cache.                                             */
    /************************************************************************/
    if (cmCursorCacheHandle == NULL) {
        if (pddShm->cm.cmCacheSize) {
            pCacheData = (PCHCACHEDATA)EngAllocMem(0, 
                    CH_CalculateCacheSize(pddShm->cm.cmCacheSize),
                    DD_ALLOC_TAG);

            if (pCacheData != NULL) {
                CH_InitCache(pCacheData, pddShm->cm.cmCacheSize, NULL,
                        FALSE, FALSE, NULL);
                cmCursorCacheHandle = pCacheData;
            }
            else {
                TRC_ERR((TB, "Failed to create cache: cEntries(%u)",
                        pddShm->cm.cmCacheSize));
            }
        }
        else {
            TRC_ERR((TB, "Zero size Cursor Cache"));
        }
    }

    // Else just clear it for synchonization purposes.
    else {
        CH_ClearCache(cmCursorCacheHandle);
    }

    DC_END_FN();
} /* CM_Update */


/****************************************************************************/
/* Name:      CM_DDDisc                                                     */
/*                                                                          */
/* Purpose:   Disconnects the display driver component of the cursor        */
/*            manager.                                                      */
/****************************************************************************/
void RDPCALL CM_DDDisc(void)
{
    DC_BEGIN_FN("CM_DDDisc");

    /************************************************************************/
    /* Free up the cursor cache                                             */
    /************************************************************************/
    if (cmCursorCacheHandle != 0) {
        TRC_NRM((TB, "Destroying CM cache"));
        CH_ClearCache(cmCursorCacheHandle);
        EngFreeMem(cmCursorCacheHandle);
        cmCursorCacheHandle = 0;
    }

    DC_END_FN();
} /* CM_DDDisc */


/****************************************************************************/
/* Name:      CM_DDTerm                                                     */
/*                                                                          */
/* Purpose:   Terminates the display driver component of the cursor         */
/*            manager.                                                      */
/*                                                                          */
/* Returns:   TRUE if successful, FALSE otherwise.                          */
/****************************************************************************/
void RDPCALL CM_DDTerm(void)
{
    DC_BEGIN_FN("CM_DDTerm");

    /************************************************************************/
    /* Destroy the work bitmaps.  Despite its name, EngDeleteSurface is the */
    /* correct function to do this.                                         */
    /************************************************************************/
#ifdef DC_HICOLOR
    if (cmWorkBitmap24)
    {
        if (!EngDeleteSurface((HSURF)cmWorkBitmap24))
        {
            TRC_ERR((TB, "Failed to delete 24bpp work bitmap"));
        }
    }

    if (cmWorkBitmap16)
    {
        if (!EngDeleteSurface((HSURF)cmWorkBitmap16))
        {
        TRC_ERR((TB, "Failed to delete 16bpp work bitmap"));
        }
    }
#else
    if (cmWorkBitmap24 != NULL) {
        if (!EngDeleteSurface((HSURF)cmWorkBitmap24)) {
            TRC_ERR((TB, "Failed to delete work bitmap"));
        }
    }
#endif

    /************************************************************************/
    /* Free up the cursor cache                                             */
    /************************************************************************/
    if (cmCursorCacheHandle != 0) {
        TRC_NRM((TB, "Destroying CM cache"));
        CH_ClearCache(cmCursorCacheHandle);
        EngFreeMem(cmCursorCacheHandle);
        cmCursorCacheHandle = 0;
    }

    TRC_NRM((TB, "CM terminated"));

    DC_END_FN();
} /* CM_DDTerm */


/****************************************************************************/
/* CM_InitShm                                                               */
/*                                                                          */
/* Initializes CM Shared Memory.                                            */
/****************************************************************************/
void RDPCALL CM_InitShm(void)
{
    DC_BEGIN_FN("CM_InitShm");

    // Set up initial contents of Shm memory, since it is not zeroed on
    // init. Don't set up the initially unused cursor shape data.
    // NOTE: cmCursorShapeData is specifically placed at the end of
    // CM_SHARED_DATA to allow this memset to work. If you change
    // the shared mem struct be sure this gets changed.
    memset(&pddShm->cm, 0, (unsigned)FIELDOFFSET(CM_SHARED_DATA,
            cmCursorShapeData.data));

    // Set the last known position to something impossible.  The IM
    // periodic processing will not move the client's mouse until a
    // sensible value is found here, ie until the client has sent us a
    // mouse position and it has percolated through to the DD. This
    // avoids the problem of the mouse leaping to 0,0 on connection.
    pddShm->cm.cmCursorPos.x = 0xffffffff;

    DC_END_FN();
}

/****************************************************************************/
/*                                                                          */
/* DrvMovePointer - see NT DDK documentation.                               */
/*                                                                          */
/****************************************************************************/
VOID DrvMovePointer(SURFOBJ *pso, LONG x, LONG y, RECTL *prcl)
{
    DC_BEGIN_FN(("DrvMovePointer"));

    //
    // Win32k hides the hardware cursor by calling the MovePointer
    // entry point with (-1,-1). Treat this as a procedural move
    // and pass it on to the real worker function
    //
    // All other paths are handled directly by win32k calling
    // DrvMovePointerEx with the right flags
    //
    if (-1 == x && -1 == y) {
        DrvMovePointerEx(pso, x, y, MP_PROCEDURAL);
    }

    DC_END_FN();
}

//
// DrvMovePointerEx
//
// Params:
// x,y    - new mouse position.
// ulFlags - source of move (see winddits.h).
//
// This function replaces the regular DrvMovePointer entry point
// by also sending us an event source parameter.
//
// This allows us to determine if we should ignore the update (e.g
// if it originates from the primary stack). Or send it down to the
// client in the case of a server initiated move or a shadow move.
//
// We ignore updates from the primary stack because by definition
// those came from the client so it doesn't need feedback from the
// server.
//
BOOL DrvMovePointerEx(SURFOBJ *pso, LONG x, LONG y, ULONG ulFlags)
{
    BOOL fTriggerUpdate = FALSE;
    PDD_PDEV ppDev = (PDD_PDEV)pso->dhpdev;

    DC_BEGIN_FN("CM_DrvMovePointerEx");

    if (pddShm != NULL) {
        if ((ulFlags & MP_TERMSRV_SHADOW) ||
            (ulFlags & MP_PROCEDURAL))
        {
            if (x == -1) {
                // -1 means hide the pointer.
                TRC_NRM((TB, "Hide the pointer"));
                pddShm->cm.cmHidden = TRUE;
            }
            else {
                // Pointer is not hidden.
                if (pddShm->cm.cmHidden) {
                    TRC_NRM((TB, "Unhide the pointer"));
                }
    
                pddShm->cm.cmHidden = FALSE;
    
                // 
                // We always update the position for server initated moves.
                // 
                pddShm->cm.cmCursorPos.x = x;
                pddShm->cm.cmCursorPos.y = y;

                //
                // Send an update so we don't need to wait
                // for the next output flush.
                //
                fTriggerUpdate = TRUE;

                // Set the cursor moved flag.
                pddShm->cm.cmCursorMoved = TRUE;
            }
        }
        else
        {
            TRC_ALT((TB,"Discarding move (%d,%d) - src 0x%x",
                     x,y, ulFlags));
        }

        if (fTriggerUpdate)
        {
            //
            // Tell the scheduler to send an update
            //
            SCH_DDOutputAvailable(ppDev, FALSE);
        }
    }
    else {
        TRC_DBG((TB, "Ignoring move to %d %d as no shr mem yet", x,y));
    }

    DC_END_FN();
    return TRUE;
}



/****************************************************************************/
/*                                                                          */
/* DrvSetPointerShape - see winddi.h                                        */
/*                                                                          */
/****************************************************************************/
ULONG DrvSetPointerShape(SURFOBJ  *pso,
                         SURFOBJ  *psoMask,
                         SURFOBJ  *psoColor,
                         XLATEOBJ *pxlo,
                         LONG      xHot,
                         LONG      yHot,
                         LONG      x,
                         LONG      y,
                         RECTL    *prcl,
                         FLONG     fl)
{
    ULONG   rc = SPS_ACCEPT_NOEXCLUDE;
    SURFOBJ *pWorkSurf;
    PDD_PDEV ppDev = (PDD_PDEV)pso->dhpdev;

    XLATEOBJ workXlo;
    SURFOBJ  *psoToUse;

    PCM_CURSOR_SHAPE_DATA pCursorShapeData;
    RECTL destRectl;
    POINTL sourcePt;
    unsigned ii;
    LONG lineLen;
    LONG colorLineLen;
    PBYTE srcPtr;
    PBYTE dstPtr;
#ifdef DC_HICOLOR
    unsigned targetBpp;
#endif

    ULONG palMono[2];
    ULONG palBGR[256];

    unsigned iCacheEntry;
    void     *UserDefined;
    CHDataKeyContext CHContext;

    DC_BEGIN_FN("DrvSetPointerShape");

    /************************************************************************/
    // Trace useful info about the cursor
    /************************************************************************/
    TRC_DBG((TB, "pso %#hlx psoMask %#hlx psoColor %#hlx pxlo %#hlx",
                  pso, psoMask, psoColor, pxlo));
    TRC_DBG((TB, "hot spot (%d, %d) x, y (%d, %d)", xHot, yHot, x, y));
    TRC_DBG((TB, "Flags %#hlx", fl));

    /************************************************************************/
    /* check for the shared memory                                          */
    /************************************************************************/
    if (pddShm != NULL && cmCursorCacheHandle != NULL)
    {
        /********************************************************************/
        // Check to see if the WD got the last cursor we passed it.
        //
        // Potentially, we might get called and then called again before the
        // WD gets round to sending the first cursor.  This doesn't matter
        // for a cursor that is already cached - its just a form of spoiling!
        // But if it was a cursor definition packet that didn't get sent,
        // then later on when we try to use it again, we will send the client
        // instructions to use a cache entry for which it doesn't have any
        // bits!
        /********************************************************************/
        if (pddShm->cm.cmBitsWaiting)
        {
            TRC_ALT((TB, "WD did not pick up cursor bits - removing entry %d",
                    pddShm->cm.cmCacheEntry));

            CH_RemoveCacheEntry(cmCursorCacheHandle,
                    pddShm->cm.cmCacheEntry);
        }

        /************************************************************************/
        /* Returning SPS_ACCEPT_NOEXCLUDE means we can ignore prcl.             */
        /************************************************************************/
        DC_IGNORE_PARAMETER(prcl);
        DC_IGNORE_PARAMETER(x);
        DC_IGNORE_PARAMETER(y);

        /************************************************************************/
        /* Set up the position information - in particular, the cursor can be   */
        /* unhidden via this function                                           */
        /************************************************************************/
        if (x == -1) {
            /********************************************************************/
            /* -1 means hide the pointer.                                       */
            /********************************************************************/
            TRC_NRM((TB, "Hide the pointer"));
            pddShm->cm.cmHidden = TRUE;
        }
        else {
            if (pddShm->cm.cmHidden) {
                TRC_NRM((TB, "Unhide the pointer"));
            }

            pddShm->cm.cmHidden = FALSE;
        }

        // Set up a local pointer to the cursor shape data.
        pCursorShapeData = &(pddShm->cm.cmCursorShapeData);

        // Check mask pointer and cursor size. For no mask or too-large pointer,
        // we send a null cursor. Note that the bitmap we are passed contains
        // TWO masks, one 'above' the other, and so is in fact twice the
        // height of the cursor, so we divide cy by 2.
        if (psoMask == NULL ||
                (psoMask->sizlBitmap.cx > CM_MAX_CURSOR_WIDTH) ||
                ((psoMask->sizlBitmap.cy / 2) > CM_MAX_CURSOR_HEIGHT)) {
            // Note that NULL cursor is not the same as hiding the cursor using
            // DrvMovePointer(), it is a transparent shape that cannot be
            // changed without another DrvSetPointerShape() call.
            TRC_NRM((TB, "Transparent or too-large cursor: psoMask=%p, "
                    "width=%u, height=%u", psoMask,
                    (psoMask != NULL ? psoMask->sizlBitmap.cx : 0),
                    (psoMask != NULL ? psoMask->sizlBitmap.cy / 2 : 0)));
            CM_SET_NULL_CURSOR(pCursorShapeData);
            pddShm->cm.cmHidden = FALSE;
            pddShm->cm.cmCacheHit = FALSE;
            pddShm->cm.cmCursorStamp = cmNextCursorStamp++;

            // We set a null cursor. Now tell GDI to simulate it.
            // do this if it's alpha or if a mask is specified which
            // means the cursor is too big per the test above
            if ( fl & SPS_ALPHA || psoMask) {
                rc = SPS_DECLINE;
                SCH_DDOutputAvailable(ppDev, TRUE);
            }
            DC_QUIT;
        }

        /************************************************************************/
        // Now we look to see if the cursor is one we've sent before.
        // We have to cache both the mask and any color information as
        // potentially we could have the same _shape_ cursor but with different
        // colors.
        /************************************************************************/
        CH_CreateKeyFromFirstData(&CHContext, psoMask->pvBits, psoMask->cjBits);
        if (psoColor != NULL)
            CH_CreateKeyFromNextData(&CHContext, psoColor->pvBits,
                    psoColor->cjBits);

        /************************************************************************/
        /* Now we can look for the cursor in the cache                          */
        /************************************************************************/
        if (CH_SearchCache(cmCursorCacheHandle, CHContext.Key1, CHContext.Key2,
                &UserDefined, &iCacheEntry))
        {
            TRC_NRM((TB, "Found cached cursor %d", iCacheEntry));

            /********************************************************************/
            /* Flag a cache hit                                                 */
            /********************************************************************/
            pddShm->cm.cmCacheHit   = TRUE;
            pddShm->cm.cmCacheEntry = iCacheEntry;
        }
        else
        {
            /********************************************************************/
            /* If we didn't find it, then let's cache it                        */
            /********************************************************************/
            pddShm->cm.cmCacheHit = FALSE;
            iCacheEntry = CH_CacheKey(cmCursorCacheHandle, CHContext.Key1,
                     CHContext.Key2, NULL);
            pddShm->cm.cmCacheEntry  = iCacheEntry;
            TRC_NRM((TB, "Cache new cursor: iEntry(%u)", iCacheEntry));

            /********************************************************************/
            // Tell the WD that there are bits waiting for it.
            // We do this here no matter if we DC_QUIT later, to make sure
            // we clean up the new cache entry on the next call if the WD has
            // not picked up the bits.
            /********************************************************************/
            pddShm->cm.cmBitsWaiting = TRUE;

            /********************************************************************/
            /* We've been passed a system cursor.  Fill in the header for our   */
            /* local cursor.  We can get the hot spot position and cursor size  */
            /* and width easily.  Note that the bitmap we are passed contains   */
            /* TWO masks, one 'above' the other, and so is in fact twice the    */
            /* height of the cursor                                             */
            /********************************************************************/
            pCursorShapeData->hdr.ptHotSpot.x = xHot;
            pCursorShapeData->hdr.ptHotSpot.y = yHot;

            TRC_NRM((TB, "Pointer mask is %#hlx by %#hlx pixels (lDelta: %#hlx)",
                     psoMask->sizlBitmap.cx,
                     psoMask->sizlBitmap.cy,
                     psoMask->lDelta));

            pCursorShapeData->hdr.cx = (WORD)psoMask->sizlBitmap.cx;
            pCursorShapeData->hdr.cy = (WORD)psoMask->sizlBitmap.cy / 2;

            /********************************************************************/
            /* lDelta may be negative for an inverted cursor                    */
            /********************************************************************/
            lineLen = (psoMask->lDelta >= 0 ? psoMask->lDelta : -psoMask->lDelta);

            /********************************************************************/
            /* set up the common parts of the shape header                      */
            /********************************************************************/
            pCursorShapeData->hdr.cPlanes     = 1;
            
            pCursorShapeData->hdr.cbMaskRowWidth = 
                    (WORD)(((psoMask->sizlBitmap.cx + 15) & ~15) / 8);

            /********************************************************************/
            /* Check to see what format we want the cursor in                   */
            /********************************************************************/
            if (pddShm->cm.cmNativeColor)
            {
                TRC_NRM((TB, "Using native bpp %d", ppDev->cClientBitsPerPel));

                /****************************************************************/
                /* If we've been passed a mono cursor, we just get the bits as  */
                /* for the AND mask, flipping as we go                          */
                /****************************************************************/
                if (NULL == psoColor)
                {
                    unsigned targetRowWidth;

                    TRC_NRM((TB, "Monochrome pointer"));
                    /************************************************************/
                    /* Get the AND mask - this is always mono.  Note that we    */
                    /* have to flip it too                                      */
                    /************************************************************/
                    TRC_NRM((TB, "Copy %d bytes of 1bpp AND mask",
                            psoMask->cjBits));

                    targetRowWidth = ((psoMask->sizlBitmap.cx + 15) & ~15) / 8;
                    
                    dstPtr = pCursorShapeData->data;
                    srcPtr = (BYTE *)psoMask->pvScan0
                             + psoMask->cjBits / 2
                             - lineLen;
                    
                    for (ii = pCursorShapeData->hdr.cy; ii > 0 ; ii--)
                    {
                        memcpy(dstPtr, srcPtr, targetRowWidth);
                        srcPtr -= lineLen;
                        dstPtr += targetRowWidth;
                    }

                    /************************************************************/
                    /* now the XOR mask                                         */
                    /************************************************************/
                    pCursorShapeData->hdr.cBitsPerPel = 1;
                    dstPtr = &(pCursorShapeData->data[targetRowWidth * 
                               pCursorShapeData->hdr.cy]);
                    srcPtr = (BYTE *)psoMask->pvScan0
                             + psoMask->cjBits - lineLen;

                    pCursorShapeData->hdr.cbColorRowWidth = targetRowWidth;

                    for (ii = pCursorShapeData->hdr.cy; ii > 0 ; ii--)
                    {
                        memcpy(dstPtr, srcPtr, targetRowWidth);
                        srcPtr -= lineLen;
                        dstPtr += targetRowWidth;
                    }
                }
                else
                {
                    unsigned targetMaskRowWidth;
                    
                    TRC_NRM((TB, "Color pointer"));

                    /************************************************************/
                    /* Get the AND mask - this is always mono                   */
                    /************************************************************/
                    TRC_NRM((TB, "Copy %d bytes of 1bpp AND mask",
                            psoMask->cjBits));

                    targetMaskRowWidth = ((psoMask->sizlBitmap.cx + 15) & ~15) / 8;
                    
                    dstPtr = pCursorShapeData->data;
                    srcPtr = (BYTE *)psoMask->pvScan0;
                    for (ii = pCursorShapeData->hdr.cy; ii > 0 ; ii--)
                    {
                        memcpy(dstPtr, srcPtr, targetMaskRowWidth);
                        srcPtr += lineLen;
                        dstPtr += targetMaskRowWidth;
                    }

                    /************************************************************/
                    /* and the XOR mask                                         */
                    /************************************************************/
#ifndef DC_HICOLOR
                    pCursorShapeData->hdr.cBitsPerPel =
                            (BYTE)ppDev->cClientBitsPerPel;
#endif
                    colorLineLen = psoColor->lDelta >=0 ? psoColor->lDelta :
                            -psoColor->lDelta;

                    pCursorShapeData->hdr.cbColorRowWidth = colorLineLen;
#ifdef DC_HICOLOR

                    if (psoColor->iBitmapFormat < BMF_24BPP) {
                        pCursorShapeData->hdr.cBitsPerPel =  1 << psoColor->iBitmapFormat;                    
                    }
                    else if (psoColor->iBitmapFormat == BMF_24BPP) {
                        pCursorShapeData->hdr.cBitsPerPel =  24;                    
                    }
                    else if (psoColor->iBitmapFormat == BMF_32BPP) {
                        pCursorShapeData->hdr.cBitsPerPel =  32;                    
                    }
                    else {
                        TRC_ASSERT((FALSE), (TB, "Bitmap format not supported"));
                        DC_QUIT;
                    }

                    /********************************************************/
                    /* We've got a number of options at this point:         */
                    /*                                                      */
                    /* - old clients only understand 8 or 24bpp cursors, so */
                    /* if the cursor is at 15/16bpp and its an old client,  */
                    /* we need to convert it to 24bpp                       */
                    /*                                                      */
                    /* - 8bpp cursors assume the color information is in a  */
                    /* color table; if we're running in hicolor, there      */
                    /* won't be one, so we have to convert the cursor to a  */
                    /* hicolor depth                                        */
                    /*                                                      */
                    /* - anything else, we can just copy the bytes across   */
                    /* and send them                                        */
                    /*                                                      */
                    /********************************************************/
                    if ((!pddShm->cm.cmSendAnyColor &&
                                 ((pCursorShapeData->hdr.cBitsPerPel == 15) ||
                                  (pCursorShapeData->hdr.cBitsPerPel == 16)))
                    || ((pCursorShapeData->hdr.cBitsPerPel == 8) &&
                                              (ppDev->cClientBitsPerPel > 8)))
                    {
                        /****************************************************/
                        /* if we can send at any old color...
                        /****************************************************/
                        if (pddShm->cm.cmSendAnyColor)
                        {
                            /************************************************/
                            /* ...we'll convert to the client session color */
                            /* depth                                        */
                            /************************************************/
                            targetBpp = ppDev->cClientBitsPerPel;
                        }
                        else
                        {
                            /************************************************/
                            /* otherwise we'll convert to 24bpp             */
                            /************************************************/
                            targetBpp = 24;
                        }

                        TRC_NRM((TB, "Convert %dbpp cursor to %d...",
                               pCursorShapeData->hdr.cBitsPerPel, targetBpp));

                        /****************************************************/
                        /* Use the supplied xlate object to convert to the  */
                        /* client bpp                                       */
                        /****************************************************/
                        if (targetBpp == 24)
                        {
                            pWorkSurf = EngLockSurface((HSURF)cmWorkBitmap24);
                            pCursorShapeData->hdr.cBitsPerPel = 24;
                        }
                        else
                        {
                            pWorkSurf = EngLockSurface((HSURF)cmWorkBitmap16);
                            pCursorShapeData->hdr.cBitsPerPel = 16;
                        }
                        if (NULL == pWorkSurf)
                        {
                            TRC_ERR((TB, "Failed to lock work surface"));
                            DC_QUIT;
                        }
                        TRC_DBG((TB, "Locked surface"));

                        /****************************************************/
                        /* Set up the 'to' rectangle                        */
                        /****************************************************/
                        destRectl.top    = 0;
                        destRectl.left   = 0;
                        destRectl.right  = psoColor->sizlBitmap.cx;
                        destRectl.bottom = psoColor->sizlBitmap.cy;

                        /****************************************************/
                        /* and the source start point                       */
                        /****************************************************/
                        sourcePt.x = 0;
                        sourcePt.y = 0;

                        if (!EngBitBlt(pWorkSurf,
                                psoColor,
                                NULL,                   /* mask surface     */
                                NULL,                   /* clip object      */
                                pxlo,                   /* XLATE object     */
                                &destRectl,
                                &sourcePt,
                                NULL,                   /* mask origin      */
                                NULL,                   /* brush            */
                                NULL,                   /* brush origin     */
                                0xcccc))                /* SRCCPY           */
                        {
                            TRC_ERR((TB, "Failed to Blt to work bitmap"));
                            EngUnlockSurface(pWorkSurf);
                            DC_QUIT;
                        }
                        TRC_DBG((TB, "Got the bits into the work bitmap"));

                        /****************************************************/
                        /* Finally we extract the color AND mask from the   */
                        /* work bitmap                                      */
                        /****************************************************/
                        TRC_NRM((TB, "Copy %d bytes of color",
                                  pWorkSurf->cjBits));
                        memcpy(&(pCursorShapeData->data[targetMaskRowWidth *
                                pCursorShapeData->hdr.cy]),
                                pWorkSurf->pvBits,
                                pWorkSurf->cjBits);
                        pCursorShapeData->hdr.cbColorRowWidth = pWorkSurf->lDelta;

                        EngUnlockSurface(pWorkSurf);
                    }
                    else
                    {
#endif
                        TRC_NRM((TB, "Copy %d bytes of %ubpp AND mask (lDelta %u)",
                                colorLineLen * pCursorShapeData->hdr.cy,
                                pCursorShapeData->hdr.cBitsPerPel,
                                colorLineLen));

                        dstPtr = &(pCursorShapeData->data[targetMaskRowWidth *
                                    pCursorShapeData->hdr.cy]);
                        srcPtr = (BYTE *)psoColor->pvScan0;
                        for (ii = pCursorShapeData->hdr.cy; ii > 0 ; ii--)
                        {
                            memcpy(dstPtr, srcPtr, colorLineLen);
                            srcPtr += psoColor->lDelta;
                            dstPtr += colorLineLen;
                        }


#ifdef DC_HICOLOR
                    }
#endif
                //  {
                //      memcpy(dstPtr, srcPtr, lineLen);
                //      srcPtr += colorLineLen;
                //      dstPtr += colorLineLen;
                //  }
                   
                }
            }
            else
            {
                /****************************************************************/
                // Now we need to blt the bitmap in to our work bitmap at
                // 24bpp and get the bits from there.
                /****************************************************************/
                TRC_NRM((TB, "Forcing 24bpp"));
                pCursorShapeData->hdr.cBitsPerPel = 24;

                /****************************************************************/
                /* Get the AND mask - this is always mono                       */
                /****************************************************************/
                TRC_NRM((TB, "Copy %d bytes of 1bpp AND mask", psoMask->cjBits/2))

                dstPtr = pCursorShapeData->data;
                srcPtr = (BYTE *)psoMask->pvScan0;
                for (ii = pCursorShapeData->hdr.cy; ii > 0 ; ii--)
                {
                    memcpy(dstPtr, srcPtr, lineLen);
                    srcPtr += lineLen;
                    dstPtr += lineLen;
                }

                /****************************************************************/
                /* If we've been passed a mono cursor, we need to set up our    */
                /* own translation object, complete with color table            */
                /****************************************************************/
                if (NULL == psoColor)
                {
                    TRC_NRM((TB, "Monochrome pointer"));

                    // Row Width should be LONG aligned
                    pCursorShapeData->hdr.cbColorRowWidth =
                            (psoMask->sizlBitmap.cx *
                            pCursorShapeData->hdr.cBitsPerPel / 8 + 3) & ~3;

                    palMono[0] = 0;
                    palMono[1] = 0xFFFFFFFF;

                    workXlo.iUniq    = 0;
                    workXlo.flXlate  = XO_TABLE;
                    workXlo.iSrcType = PAL_INDEXED;
                    workXlo.iDstType = PAL_RGB;
                    workXlo.cEntries = 2;
                    workXlo.pulXlate = palMono;

                    /************************************************************/
                    /* Set up the 'to' rectangle                                */
                    /************************************************************/
                    destRectl.top    = 0;
                    destRectl.left   = 0;
                    destRectl.right  = psoMask->sizlBitmap.cx;
                    destRectl.bottom = psoMask->sizlBitmap.cy / 2;

                    /************************************************************/
                    /* the source AND mask is the 'lower' half of the supplied  */
                    /* bitmap                                                   */
                    /************************************************************/
                    sourcePt.x = 0;
                    sourcePt.y = psoMask->sizlBitmap.cy / 2;

                    /************************************************************/
                    /* and set up a pointer to the correct SO to use            */
                    /************************************************************/
                    psoToUse = psoMask;
                }
                else
                {
                    /************************************************************/
                    /* check that we're at 8bpp - this won't work if not        */
                    /************************************************************/
                    TRC_ASSERT( (ppDev->cProtocolBitsPerPel == 8),
                            (TB, "Palette at %d bpp",
                            ppDev->cProtocolBitsPerPel) );

                    colorLineLen = psoColor->lDelta >= 0 ? psoColor->lDelta :
                            -psoColor->lDelta;
                    pCursorShapeData->hdr.cbColorRowWidth = colorLineLen * 
                            pCursorShapeData->hdr.cBitsPerPel / 8;

                    if (psoColor->iBitmapFormat <= BMF_8BPP) {

                        /************************************************************/
                        /* For color cursors, the supplied XLATEOBJ is set up to    */
                        /* convert from the cursor bpp to the screen bpp - which in */
                        /* most cases for us is a no-op since we will most often be */
                        /* at 8bpp (the maximum color depth we support).  However,  */
                        /* we actually need to convert to 24bpp for the wire        */
                        /* format, which requires a change to the XLATEOBJ.  We     */
                        /* can't do this in place, since the XLATEOBJ we are passed */
                        /* seems to be used elsewhere - not least to display the    */
                        /* desktop icons - so we set up our own                     */
                        /************************************************************/
                        workXlo.iUniq = 0;          /* don't cache               */
    
                        /************************************************************/
                        /* Set up to use the current palette (which is fortunately  */
                        /* held in the DD_PDEV structure)                           */
                        /************************************************************/
                        workXlo.flXlate = XO_TABLE;   /* we provide a lookup table */
                                                       /* to do the translation     */
    
                        workXlo.iSrcType = PAL_INDEXED;/* pel values in the src bmp */
                                                       /* are indices into the table*/
    
                        workXlo.iDstType = PAL_RGB;    /* entries in the table are  */
                                                       /* RGB values for the dst bmp*/
    
                        workXlo.cEntries = 1 << ppDev->cProtocolBitsPerPel;
                                                       /* which has this many entries */
    
                        /************************************************************/
                        /* Now set up the palette to use in the XLATEOBJ.  We have  */
                        /* the current palette stored in the DD_PDEV structure -    */
                        /* unfortunately it is in RGB format and we need BGR...     */
                        /************************************************************/
                        for (ii = 0 ; ii < workXlo.cEntries; ii++)
                        {
                            palBGR[ii] = (ppDev->Palette[ii].peRed   << 16)
                                     | (ppDev->Palette[ii].peGreen << 8)
                                     | (ppDev->Palette[ii].peBlue);
                        }
                        workXlo.pulXlate = palBGR;
    
                        /************************************************************/
                        /* Set up the 'to' rectangle                                */
                        /************************************************************/
                        destRectl.top    = 0;
                        destRectl.left   = 0;
                        destRectl.right  = psoColor->sizlBitmap.cx;
                        destRectl.bottom = psoColor->sizlBitmap.cy;
    
                        /************************************************************/
                        /* and the source start point                               */
                        /************************************************************/
                        sourcePt.x = 0;
                        sourcePt.y = 0;
    
                        /************************************************************/
                        /* set up a pointer to the correct SO to use                */
                        /************************************************************/
                        psoToUse = psoColor;
                    }
                    else {
                        // We got a high color cursor to translate to 24bpp workbitmap
                        // can't easily simulate the XLATEOBJ, since this is TS4 code path
                        // only, we will just let it fall back to GDI bitmap cursor!
                        CM_SET_NULL_CURSOR(pCursorShapeData);
                        pddShm->cm.cmHidden = FALSE;
                        pddShm->cm.cmCacheHit = FALSE;
                        pddShm->cm.cmCursorStamp = cmNextCursorStamp++;
            
                        rc = SPS_DECLINE;
                        SCH_DDOutputAvailable(ppDev, TRUE);
                        DC_QUIT;
                    }
                }

                // Lock the work bitmap to get a surface to pass to EngBitBlt.
                pWorkSurf = EngLockSurface((HSURF)cmWorkBitmap24);
                if (pWorkSurf != NULL) {
                    BOOL RetVal;

                    TRC_DBG((TB, "Locked surface"));

                    // Do the blt.
                    RetVal = EngBitBlt(pWorkSurf,
                            psoToUse,
                            NULL,       /* mask surface     */
                            NULL,       /* clip object      */
                            &workXlo,   /* XLATE object     */
                            &destRectl,
                            &sourcePt,
                            NULL,       /* mask origin      */
                            NULL,       /* brush            */
                            NULL,       /* brush origin     */
                            0xcccc);   /* SRCCPY           */

                    EngUnlockSurface(pWorkSurf);
                    if (RetVal) {
                        TRC_DBG((TB, "Got the bits into the work bitmap"));
                    }
                    else {
                        TRC_ERR((TB, "Failed to Blt to work bitmap"));
                        goto FailBlt;
                    }
                }
                else {
                    TRC_ERR((TB, "Failed to lock work surface"));

FailBlt:
                    // Set the cursor bits to all black. On the client,
                    // this will be seen as the correct mask but a black
                    // region inside where the cursor color bits would have
                    // been.
                    memset(pWorkSurf->pvBits, 0, pWorkSurf->cjBits);

                    // We do not DC_QUIT here, we want to complete the cursor
                    // creation even if the output is mostly wrong, since
                    // we've already cached the bits.
                }

                /****************************************************************/
                /* Finally we extract the color AND mask from the work bitmap   */
                /****************************************************************/
                TRC_NRM((TB, "Copy %d bytes of color", pWorkSurf->cjBits));

                memcpy(&(pCursorShapeData->data[psoMask->cjBits / 2]),
                          pWorkSurf->pvBits,
                          pWorkSurf->cjBits);
            }
        }

        /************************************************************************/
        /* Set the cursor stamp                                                 */
        /************************************************************************/
        pddShm->cm.cmCursorStamp = cmNextCursorStamp++;

        /************************************************************************/
        /* Tell the scheduler that we have some new cursor info                 */
        /************************************************************************/
        SCH_DDOutputAvailable(ppDev, FALSE);
    }
    else {
        TRC_ERR((TB, "shared memory is not allocated or invalid cursor handle: "
                "pddshm=%p, cmCursorCacheHandle=%p", pddShm, cmCursorCacheHandle));
    }

DC_EXIT_POINT:
    DC_END_FN();

    return(rc);
} /* DrvSetPointerShape */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpdd\ncmdisp.h ===
/****************************************************************************/
// ncmdisp.h
//
// RDP Cursor Manager display driver header
//
// Copyright (c) 1996-2000 Microsoft Corporation
/****************************************************************************/
#ifndef __NCMDISP_H
#define __NCMDISP_H

#include <acmapi.h>
#include <nddapi.h>


BOOL RDPCALL CM_DDInit(PDD_PDEV ppdev);

void RDPCALL CM_Update(void);

void RDPCALL CM_DDDisc(void);

void RDPCALL CM_DDTerm(void);

void RDPCALL CM_InitShm(void);


/****************************************************************************/
/* Name:      CM_DDGetCursorStamp                                           */
/*                                                                          */
/* Purpose:   Returns the current cursor stamp.                             */
/*                                                                          */
/* Returns:   Current cursor stamp.                                         */
/****************************************************************************/
//__inline UINT32 RDPCALL CM_DDGetCursorStamp(void)
#define CM_DDGetCursorStamp() pddShm->cm.cmCursorStamp



#endif  // !defined(__NCMDISP_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpdd\nchdisp.h ===
/****************************************************************************/
// chdisp.h
//
// Cache Handler display driver specific header
//
// (C) 1997-2000 Microsoft Corp.
/****************************************************************************/
#ifndef _H_CHDISP
#define _H_CHDISP


#include <achapi.h>
#include <cbchash.h>


/*
 * Prototypes.
 */

void RDPCALL CH_InitCache(
        PCHCACHEDATA    pCacheData,
        unsigned        NumEntries,
        void            *pContext,
        BOOLEAN         bNotifyRemoveLRU,
        BOOLEAN         bQueryRemoveLRU,
        CHCACHECALLBACK pfnCacheCallback);

BOOLEAN RDPCALL CH_SearchCache(
        CHCACHEHANDLE hCache,
        UINT32        Key1,
        UINT32        Key2,
        void          **pUserDefined,
        unsigned      *piCacheEntry);

unsigned RDPCALL CH_CacheKey(
        CHCACHEHANDLE hCache,
        UINT32        Key1,
        UINT32        Key2,
        void          *UserDefined);

void RDPCALL CH_ForceCacheKeyAtIndex(
        CHCACHEHANDLE hCache,
        unsigned      CacheEntryIndex,
        UINT32        Key1,
        UINT32        Key2,
        void          *UserDefined);

void RDPCALL CH_RemoveCacheEntry(CHCACHEHANDLE hCache, unsigned CacheEntryIndex);

void RDPCALL CH_ClearCache(CHCACHEHANDLE hCache);

UINT RDPCALL CH_CalculateCacheSize(UINT cacheEntries);

void RDPCALL CH_TouchCacheEntry(CHCACHEHANDLE hCache, unsigned CacheEntryIndex);

unsigned RDPCALL CH_GetLRUCacheEntry(CHCACHEHANDLE hCache);

/****************************************************************************/
// Generates a cache key for the given data. The First function is for the
// 1st block in a series, the Next for the next in the series. We wrap the
// CBC64 functions in order to provide asserts.
/****************************************************************************/
typedef CBC64Context CHDataKeyContext;

//__inline void __fastcall CH_CreateKeyFromFirstData(
//        CHDataKeyContext *pContext,
//        BYTE     *pData,
//        unsigned DataSize)
#define CH_CreateKeyFromFirstData(pContext, pData, DataSize) \
{ \
    TRC_ASSERT((((UINT_PTR)(pData) % sizeof(UINT32)) == 0), \
            (TB,"Data pointer not DWORD aligned")); \
    TRC_ASSERT(((DataSize % sizeof(UINT32)) == 0), \
            (TB,"Data size not multiple of DWORD")); \
\
    FirstCBC64((pContext), (UINT32 *)(pData), (DataSize) / sizeof(UINT32)); \
}


//__inline void __fastcall CH_CreateKeyFromNextData(
//        CHDataKeyContext *pContext,
//        BYTE *pData,
//        unsigned DataSize)
#define CH_CreateKeyFromNextData(pContext, pData, DataSize) \
{ \
    TRC_ASSERT((((UINT_PTR)(pData) % sizeof(UINT32)) == 0), \
            (TB,"Data pointer not DWORD aligned")); \
    TRC_ASSERT(((DataSize % sizeof(UINT32)) == 0), \
            (TB,"Data size not multiple of DWORD")); \
\
    NextCBC64((pContext), (UINT32 *)(pData), (DataSize) / sizeof(UINT32)); \
}


#endif  // _H_CHDISP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpdd\ncmdata.c ===
/****************************************************************************/
// ncmdata.c
//
// Cursor manager data
//
// Copyright (C) 1996-2000 Microsoft Corporation
/****************************************************************************/

#include <ndcgdata.h>


/****************************************************************************/
/* Handle to the cursor manager work bitmap.                                */
/****************************************************************************/
DC_DATA(HBITMAP, cmWorkBitmap24, NULL);
#ifdef DC_HICOLOR
DC_DATA (HBITMAP,cmWorkBitmap16, NULL);
#endif

/****************************************************************************/
/* Cursor stamp                                                             */
/****************************************************************************/
DC_DATA(UINT32, cmNextCursorStamp, 0);

/****************************************************************************/
/* Cursor cache handle                                                      */
/****************************************************************************/
DC_DATA(CHCACHEHANDLE, cmCursorCacheHandle, 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpdd\nddapi.c ===
/****************************************************************************/
// nddapi.c
//
// RDP DD exported functions.
//
// Copyright (c) 1996-2000 Microsoft Corporation
/****************************************************************************/

#include <precmpdd.h>
#define hdrstop

#define TRC_FILE "nddapi"
#include <adcg.h>
#include <atrcapi.h>

#include <winddi.h>

#include <ndddata.c>

#include <nddapi.h>
#include <nshmapi.h>
#include <nsbcdisp.h>
#include <ncmdisp.h>
#include <nwdwioct.h>
#include <nschdisp.h>
#include <nbadisp.h>
#include <noadisp.h>
#include <nssidisp.h>
#include <noedisp.h>
#include <nchdisp.h>

#include <nddifn.h>
#include <nbainl.h>


#ifdef DC_DEBUG
/****************************************************************************/
/* Useful function for outputting lines to the debugger                     */
/****************************************************************************/
void DrvDebugPrint(char * str, ...)
{
    va_list ap;
    va_start(ap, str);
    
    EngDebugPrint("RDPDD: ", str, ap);
}

void WDIcaBreakOnDebugger()
{
    ULONG   dummyBytesReturned; 
    ULONG   status;
    DC_BEGIN_FN("WDIcaBreakOnDebugger");

    status = EngFileIoControl( ddWdHandle,
        IOCTL_WDTS_DD_ICABREAKONDEBUGGER, 0, 0, 0, 0, 
        &dummyBytesReturned);

    if (STATUS_SUCCESS != status) {
        TRC_ERR((TB, "IOCTL_WDTS_DD_ICABREAKONDEBUGGER returned %lu",
            status ));
    }

    DC_END_FN();
}
#endif


/****************************************************************************/
/* DrvEnableDriver - see NT DDK documentation.                              */
/*                                                                          */
/* This is the only directly exported entry point to the display driver.    */
/* All other entry points are exported through the data returned from this  */
/* function.                                                                */
/****************************************************************************/
BOOL DrvEnableDriver(ULONG iEngineVersion, ULONG cj, DRVENABLEDATA *pded)
{
    DC_BEGIN_FN("DrvEnableDriver");

#ifdef DC_DEBUG
    // Initialize the trace level.
    ddTrcType = TT_API1 | TT_API2 | TT_API3 | TT_API4;
    DD_SET_STATE(DD_ENABLE_DRIVER);
#endif

#ifdef DDINT3
    _asm int 3;
#endif

    // Check that the engine version is correct - we refuse to load on
    // other versions because we will almost certainly not work.
    if (iEngineVersion < DDI_DRIVER_VERSION_SP3)
        return FALSE;

    // Fill in as much as we can.  Start with the entry points.
    if (cj >= FIELDOFFSET(DRVENABLEDATA, pdrvfn) +
            FIELDSIZE(DRVENABLEDATA, pdrvfn)) {
        pded->pdrvfn = (DRVFN *)ddDriverFns;
        TRC_DBG((TB, "Passing back driver functions %p", pded->pdrvfn));
    }

    // Size of our entry point array.
    if (cj >= FIELDOFFSET(DRVENABLEDATA, c) + FIELDSIZE(DRVENABLEDATA, c)) {
        pded->c = DD_NUM_DRIVER_INTERCEPTS;
        TRC_DBG((TB, "Passing back function count %lu", pded->c));
    }

    // DDI version this driver was targeted for is passed back to engine.
    // Future graphics engines may break calls down to old driver format.
    if (cj >= FIELDOFFSET(DRVENABLEDATA, iDriverVersion) +
            FIELDSIZE(DRVENABLEDATA, iDriverVersion)) {
        pded->iDriverVersion = DDI_DRIVER_VERSION_SP3;
        TRC_DBG((TB, "Using driver type %lu", pded->iDriverVersion));
    }

    TRC_NRM((TB, "Num driver intercepts: %d", DD_NUM_DRIVER_INTERCEPTS));

    DC_END_FN();
    return TRUE;
}


/****************************************************************************/
// DrvDisableDriver - see NT DDK documentation.
/****************************************************************************/
VOID DrvDisableDriver(VOID)
{
    DC_BEGIN_FN("DrvDisableDriver");

    // Release any resources allocated in DrvEnableDriver.
    TRC_NRM((TB, "DrvDisableDriver"));

    DDTerm();

    DC_END_FN();
}

/****************************************************************************/
/* DrvEnablePDEV - see NT DDK documentation.                                */
/*                                                                          */
/* Initializes a bunch of fields for GDI, based on the mode we've been      */
/* asked to do.  This is the first thing called after DrvEnableDriver, when */
/* GDI wants to get some information about us.                              */
/*                                                                          */
/* (This function mostly returns back information; DrvEnableSurface is used */
/* for initializing the hardware and driver components.)                    */
/****************************************************************************/
DHPDEV DrvEnablePDEV(
        DEVMODEW *pdm,
        PWSTR pwszLogAddr,
        ULONG cPat,
        HSURF *phsurfPatterns,
        ULONG cjCaps,
        ULONG *pdevcaps,
        ULONG cjDevInfo,
        DEVINFO *pdi,
        HDEV hdev,
        PWSTR pwszDeviceName,
        HANDLE hDriver)
{
    DHPDEV rc = NULL;
    PDD_PDEV pPDev = NULL;
    GDIINFO gdiInfoNew;
    INT32 cModes;
    PVIDEO_MODE_INFORMATION pVideoModeInformation = NULL;
    INT32 cbModeSize;

    DC_BEGIN_FN("DrvEnablePDEV");

    // Make sure that we have large enough data to reference.
    if (cjCaps >= sizeof(GDIINFO) && cjDevInfo >= sizeof(DEVINFO)) {
        // Allocate a physical device structure; store the hDriver in it.
        pPDev = EngAllocMem(0, sizeof(DD_PDEV), DD_ALLOC_TAG);
        if (pPDev != NULL) {
            // Don't zero the palette since we'll be setting that up soon.
            memset(pPDev, 0, sizeof(DD_PDEV) - sizeof(pPDev->Palette));
            pPDev->hDriver = hDriver;
        }
        else {
            TRC_ERR((TB, "DrvEnablePDEV - Failed EngAllocMem"));
            DC_QUIT;
        }
    }
    else {
        TRC_ERR((TB, "Buffer size too small %lu %lu", cjCaps, cjDevInfo));
        DC_QUIT;
    }

    // Set up the current screen mode information based upon the supplied
    // mode settings.
    DDInitializeModeFields(pPDev, (GDIINFO *)pdevcaps, &gdiInfoNew, pdi, pdm);
    memcpy(pdevcaps, &gdiInfoNew, min(sizeof(GDIINFO), cjCaps));

    // Since DrvGetModes is only called when the DD is test-loaded, we must
    // get a mode count here so that we can determine if we're loaded into
    // the console session.
    cModes = DDGetModes(hDriver, &pVideoModeInformation, &cbModeSize);
    if (cModes == -1) {
        TRC_NRM((TB, "We are a chained console driver"));
        ddConsole = TRUE;
        // see DDK : must be set for a mirror driver
        pdi->flGraphicsCaps |= GCAPS_LAYERED;
        // to support alpha cursor
        pdi->flGraphicsCaps2 |= GCAPS2_ALPHACURSOR;
    } else {
        if (cModes == 0) {
            TRC_ERR((TB, "Failed to get the video modes."));
            DC_QUIT;
        }
    }

#if 0
    // Dump the returned GDIINFO details to the debugger.
    TRC_ALT((TB, "Returned GDIINFO:"));
    TRC_ALT((TB, "  ulVersion        %#x", gdiInfoNew.ulVersion));
    TRC_ALT((TB, "  ulTechnology     %#x", gdiInfoNew.ulTechnology));
    TRC_ALT((TB, "  ulHorzSize       %#x", gdiInfoNew.ulHorzSize));
    TRC_ALT((TB, "  ulVertSize       %#x", gdiInfoNew.ulVertSize));
    TRC_ALT((TB, "  ulHorzRes        %#x", gdiInfoNew.ulHorzRes));
    TRC_ALT((TB, "  ulVertRes        %#x", gdiInfoNew.ulVertRes));
    TRC_ALT((TB, "  cBitsPixel       %#x", gdiInfoNew.cBitsPixel));
    TRC_ALT((TB, "  cPlanes          %#x", gdiInfoNew.cPlanes));
    TRC_ALT((TB, "  ulNumColors      %#x", gdiInfoNew.ulNumColors));
    TRC_ALT((TB, "  flRaster         %#x", gdiInfoNew.flRaster));
    TRC_ALT((TB, "  ulLogPixelsX     %#x", gdiInfoNew.ulLogPixelsX));
    TRC_ALT((TB, "  ulLogPixelsY     %#x", gdiInfoNew.ulLogPixelsY));
    TRC_ALT((TB, "  flTextCaps       %#x", gdiInfoNew.flTextCaps));
    TRC_ALT((TB, "  ulDACRed         %#x", gdiInfoNew.ulDACRed));
    TRC_ALT((TB, "  ulDACGreen       %#x", gdiInfoNew.ulDACGreen));
    TRC_ALT((TB, "  ulDACBlue        %#x", gdiInfoNew.ulDACBlue));
    TRC_ALT((TB, "  ulAspectX        %#x", gdiInfoNew.ulAspectX));
    TRC_ALT((TB, "  ulAspectY        %#x", gdiInfoNew.ulAspectY));
    TRC_ALT((TB, "  ulAspectXY       %#x", gdiInfoNew.ulAspectXY));
    TRC_ALT((TB, "  xStyleStep       %#x", gdiInfoNew.xStyleStep));
    TRC_ALT((TB, "  yStyleStep       %#x", gdiInfoNew.yStyleStep));
    TRC_ALT((TB, "  denStyleStep     %#x", gdiInfoNew.denStyleStep));
    TRC_ALT((TB, "  ptlPhysOffset.x  %#x", gdiInfoNew.ptlPhysOffset.x));
    TRC_ALT((TB, "  ptlPhysOffset.y  %#x", gdiInfoNew.ptlPhysOffset.y));
    TRC_ALT((TB, "  szlPhysSize.cx   %#x", gdiInfoNew.szlPhysSize.cx));
    TRC_ALT((TB, "  szlPhysSize.cy   %#x", gdiInfoNew.szlPhysSize.cy));
    TRC_ALT((TB, "  ulNumPalReg      %#x", gdiInfoNew.ulNumPalReg));
    TRC_ALT((TB, "  ulVRefresh       %#x", gdiInfoNew.ulVRefresh));
    TRC_ALT((TB, "  ulBltAlignment   %#x", gdiInfoNew.ulBltAlignment));
    TRC_ALT((TB, "  ulPanningHorzRes %#x", gdiInfoNew.ulPanningHorzRes));
    TRC_ALT((TB, "  ulPanningVertRes %#x", gdiInfoNew.ulPanningVertRes));
#endif

    // Set the default palette.
    if (DDInitializePalette(pPDev, pdi)) {
        // We have successfully initialized - return the new PDEV.
        rc = (DHPDEV)pPDev;
        TRC_NRM((TB, "PDEV 0x%p screen format %lu", pPDev,
                pPDev->iBitmapFormat));
    }
    else {
        TRC_ERR((TB, "Failed to initialize palette"));
        DC_QUIT;
    }

DC_EXIT_POINT:
    //    This is a temporary buffer. We use it to call DDGetModes in order
    //    to find out if we are in chained mode or not. We always free it.
    if (pVideoModeInformation != NULL) {
        EngFreeMem(pVideoModeInformation);
        pVideoModeInformation = NULL;
    }
    
    // Release any resources if we failed to initialize.
    if (rc != NULL) {
        DD_UPD_STATE(DD_ENABLE_PDEV);
    }
    else {
        //    In case pPDev is allocated this will free first try to free the
        //    palette (if any) and then it will free pPDev.
        DrvDisablePDEV((DHPDEV)pPDev);
        DD_UPD_STATE(DD_ENABLE_PDEV_ERR);
    }

    TRC_DBG((TB, "Returning %p", rc));

    DC_END_FN();
    return rc;
}


/****************************************************************************/
// DrvDisablePDEV - see NT DDK documentation
//
// Release the resources allocated in DrvEnablePDEV. If a surface has been
// enabled DrvDisableSurface will have already been called. Note that this
// function will be called when previewing modes in the Display Applet, but
// not at system shutdown. Note: In an error, we may call this before
// DrvEnablePDEV is done.
/****************************************************************************/
VOID DrvDisablePDEV(DHPDEV dhpdev)
{
    PDD_PDEV pPDev = (PDD_PDEV)dhpdev;

    DC_BEGIN_FN("DrvDisablePDEV");

    TRC_NRM((TB, "Disabling PDEV %p", dhpdev));

    // Free the resources we allocated for the display.
    if (pPDev != NULL) {
        // Destroy the default palette, if created.
        if (pPDev->hpalDefault != 0) {
            EngDeletePalette(pPDev->hpalDefault);
            pPDev->hpalDefault = 0;
        }

        EngFreeMem(pPDev);
    }

    DC_END_FN();
}


/****************************************************************************/
/* DrvCompletePDEV - see NT DDK documentation                               */
/*                                                                          */
/* Stores the HPDEV, the engine's handle for this PDEV, in the DHPDEV.      */
/****************************************************************************/
VOID DrvCompletePDEV(DHPDEV dhpdev, HDEV hdev)
{
    DC_BEGIN_FN("DrvCompletePDEV");

    // Store the device handle for our display handle.
    TRC_NRM((TB, "Completing PDEV %p", dhpdev));

    ((PDD_PDEV)dhpdev)->hdevEng = hdev;
    DD_UPD_STATE(DD_COMPLETE_PDEV);

    DC_END_FN();
}


/****************************************************************************/
/* DrvShadowConnect - called when the display driver should start           */
/*                    shadowing.                                            */
/*                                                                          */
/* Primary job seems to be getting the shadow target WD up and running by   */
/* pretending the display driver is coming up for the first time.  Also     */
/*                                                                          */
/* Params:    IN - pClientThinwireData (DD data from client)                */
/*            IN - ThinwireDataLength (length of data)                      */
/****************************************************************************/
BOOL DrvShadowConnect(PVOID pClientThinwireData, ULONG ThinwireDataLength)
{
    TSHARE_DD_SHADOWSYNC_IN shadowSync;
    ULONG                   bytesReturned;
    NTSTATUS                status;
    BOOL                    rc = FALSE;

    DC_BEGIN_FN("DrvShadowConnect");

    DD_UPD_STATE(DD_SHADOW_SETUP);

    // Make sure we are still connected!  TODO: Restrict to only one shadow for
    // now...
    TRC_ERR((TB, "Shadow Connect: %p [%ld]",
            pClientThinwireData,
            ThinwireDataLength));

#ifdef DC_DEBUG
    // NT BUG 539912 - track calls to DD fns.
    DBG_DD_FNCALL_HIST_ADD( DBG_DD_FNCALL_DRV_SHADOWCONNECT, 
        pClientThinwireData, ThinwireDataLength, ddConnected, pddTSWdShadow);
#endif

    if ((ddConnected) && (pddTSWdShadow == NULL)) {
        // Drive the DD and WD into a disconnected state.  Indicate this is in
        // preparation for a shadow session to disable saving the persistent key
        // database, etc. It also has the effect of destroying the SHM and
        // taking down all of the related cache information and encoding state.
        ddIgnoreShadowDisconnect = FALSE;
        TRC_ERR((TB, "Disconnecting stack prior to shadow"));
        DDDisconnect(TRUE);
        TRC_ERR((TB, "Done disconnecting"));

        // Reconnect to the WD to establish the shadow session
        TRC_ERR((TB, "Reinitializing primary/shadow stacks: ddConnected(%ld)",
                 ddConnected));

        // If both stacks connected successfully, reestablish the SHM and
        // recreate the caches and encoding state.
        if (DDInit(NULL, TRUE, FALSE, (PTSHARE_VIRTUAL_MODULE_DATA) pClientThinwireData,
                ThinwireDataLength)) {
#ifdef DC_HICOLOR
            // Get the shadower caps - in particular, it may have changed its
            // cache caps because of a color depth change
            PTSHARE_VIRTUAL_MODULE_DATA pShadowCaps;
            ULONG dataLen = 256;

            // Supply a small amount of memory so the Wd can tell us how much
            // it actually needs - we can't just use the returned length from
            // EngFileIoControl since when the IOCTL gets passed to both the
            // primary and shadow stacks, the shadow's result overwrites the
            // primary's result.  Doh!
            pShadowCaps = EngAllocMem(FL_ZERO_MEMORY,
                                      dataLen,
                                      DD_ALLOC_TAG);

            if (pShadowCaps)
            {
                // First pass tells us the size we need for the caps
                TRC_ERR((TB, "Getting shadow caps len..."));
                status = EngFileIoControl(ddWdHandle,
                                          IOCTL_WDTS_DD_QUERY_SHADOW_CAPS,
                                          NULL, 0,
                                          pShadowCaps, dataLen,
                                          &dataLen);

                if (pShadowCaps->capsLength)
                {
                    TRC_ERR((TB, "Getting shadow caps..."));
                    // remember this is the *caps* len - we need a bit
                    // extra for the rest of a vurtual module data structure
                    dataLen = pShadowCaps->capsLength + sizeof(unsigned);
                    // Free the old memory!
                    EngFreeMem(pShadowCaps);
                    pShadowCaps = EngAllocMem(FL_ZERO_MEMORY,
                                              dataLen,
                                              DD_ALLOC_TAG);
                    if (pShadowCaps)
                    {
                        // now we'll get the data
                        status = EngFileIoControl(ddWdHandle,
                                              IOCTL_WDTS_DD_QUERY_SHADOW_CAPS,
                                              NULL, 0,
                                              pShadowCaps, dataLen,
                                              &dataLen);
                    }
                    else
                    {
                        TRC_ERR((TB, "Couldn't get memory for shadow caps"));
                        status = STATUS_NO_MEMORY;
                    }

                }
                else
                {
                    TRC_ERR((TB, "Unexpected status %08lx", status));
                    status = STATUS_BUFFER_OVERFLOW;
                }
            }
            else
            {
                TRC_ERR((TB, "Couldn't get memory for shadow caps"));
                status = STATUS_NO_MEMORY;
            }

            if (status != STATUS_SUCCESS)
            {
                TRC_ERR((TB, "Couldn't get updated shadow caps"));
                DC_QUIT;
            }
#endif

            // Tell the shadow target and shadow client(s) to synchronize
            TRC_ERR((TB, "Shadow Connect - WD Sync Start"));
            shadowSync.pShm = pddShm;
#ifdef DC_HICOLOR
            shadowSync.capsLen     = pShadowCaps->capsLength;
            shadowSync.pShadowCaps = &pShadowCaps->combinedCapabilities;
#endif

            status = EngFileIoControl(ddWdHandle,
                    IOCTL_WDTS_DD_SHADOW_SYNCHRONIZE, &shadowSync,
                    sizeof(shadowSync), NULL, 0, &bytesReturned);
            TRC_ERR((TB, "Shadow Connect - WD Sync End"));

#ifdef DC_HICOLOR
            // release the caps memory
            if (pShadowCaps)
            {
                EngFreeMem(pShadowCaps);
            }
#endif


            // Free all pending orders.  This is OK as we will get a full redraw
            // when the shadow starts
            BAResetBounds();
            
            // With Direct Encoding, at this point the orders in the order
            // heap have already changed the encoding state, blowing away
            // orders at this point will cause inconsistent state of the encoding
            // table between the server and client.  This is because we keep
            // the last order type sent, so blowing away orders here means 
            // order type will not be sent to the client, but the server encoding
            // table and state still kept the last order state.  It's almost 
            // impossible to rewind the orders at this point.  So, we simply have
            // to send the orders to the client to keep order encoding state 
            // consistent. 
            //OA_DDSyncUpdatesNow();

            if (status != STATUS_SUCCESS) {
                TRC_ERR((TB,"Could not synchronize primary/shadow stacks: %lx",
                         status));
            }

            rc = NT_SUCCESS(status);
        }

        else {
            TRC_ERR((TB,"Could not connect to primary/shadow stacks"));
        }
    }

    // TODO: This is a temporary restriction until we allow n-way shadowing.
    // Rejecting this connection causes us to get an associated
    // DrvShadowDisconnect() which we need to ignore.  See bug 229479
    else {
        TRC_ERR((TB, "Shadow Connect: already shadowing -> reject!"));
        ddIgnoreShadowDisconnect = TRUE;
        rc = STATUS_CTX_SHADOW_DENIED;
    }

#ifdef DC_HICOLOR
DC_EXIT_POINT:
#endif
    DD_CLR_STATE(DD_SHADOW_SETUP);
    DC_END_FN();
    return rc;
}


/****************************************************************************/
/* DrvShadowDisconnect - called when the display driver should stop         */
/*                       shadowing.                                         */
/*                                                                          */
/* Primary job seems to be telling the shadow target WD that shadowing is   */
/* stopping and potentially restoring the former capability set for the     */
/* target.                                                                  */
/*                                                                          */
/* Params:    IN - pClientThinwireData (DD data from client)                */
/*            IN - ThinwireDataLength (length of data)                      */
/****************************************************************************/
BOOL DrvShadowDisconnect(PVOID pThinwireData, ULONG ThinwireDataLength)
{

    NTSTATUS status;
    ULONG bytesReturned;
    TSHARE_DD_DISCONNECT_IN disconnIn;

    DC_BEGIN_FN("DrvShadowDisconnect");

    // Now tell the WD we're disconnecting.  We don't do anything with a
    // failure here - there's no point - we're already disconnecting!
    TRC_ERR((TB, "Shadow Disconnect: %p [%ld]", pThinwireData,
            ThinwireDataLength));

#ifdef DC_DEBUG
    // NT BUG 539912 - track calls to DD fns.
    DBG_DD_FNCALL_HIST_ADD( DBG_DD_FNCALL_DRV_SHADOWDISCONNECT, 
        pThinwireData, ThinwireDataLength, ddConnected, ddIgnoreShadowDisconnect);
#endif

    if (ddConnected) {
        // For now we are limited to one shadow per session. Any subsequent
        // attempts will be rejected, but we must ignore the associated
        // and unnecessary disconnect!
        if (!ddIgnoreShadowDisconnect) {

            pddShm->pShadowInfo = NULL;
            disconnIn.pShm = pddShm;
            disconnIn.bShadowDisconnect = FALSE;
    
            status = EngFileIoControl(ddWdHandle,
                    IOCTL_WDTS_DD_SHADOW_DISCONNECT, &disconnIn,
                    sizeof(disconnIn), NULL, 0, &bytesReturned);
            TRC_ERR((TB, "Status on Shadow Disc IOCtl to WD %lu", status));
            pddTSWdShadow = NULL;
    
            // Update capabilities now that a party left the share
            TRC_ERR((TB, "Updating new capabilities"));               
            
            // Initiate a disconnect for shadow exiting
            DDDisconnect(TRUE);
            TRC_ERR((TB, "Done disconnecting"));
        
            // Reconnect to the WD to establish the primary session
            TRC_ERR((TB, "Reinitializing primary stack: ddConnected(%ld)",
                     ddConnected));
        
            // If primary stack connected successfully, reestablish the SHM and
            // recreate the caches and encoding state.
            if (DDInit(NULL, TRUE, FALSE, NULL, 0)) {
                TRC_NRM((TB, "Reintialized the DD"));
                status = STATUS_SUCCESS;
            }
            else {
                TRC_ERR((TB, "Failed to initialize DD Components"));
                status = STATUS_UNSUCCESSFUL;
            }
        }
        else {
           ddIgnoreShadowDisconnect = FALSE;
           status = STATUS_SUCCESS;
        }
    }

    // else we have already been disconnected so just return an error
    else {
        status = STATUS_FILE_CLOSED;
    }

    DC_END_FN();
    return NT_SUCCESS(status);
}


/****************************************************************************/
/* DrvEnableSurface - see NT DDK documentation                              */
/*                                                                          */
/* Creates the drawing surface and initializes driver components.  This     */
/* function is called after DrvEnablePDEV, and performs the final device    */
/* initialization.                                                          */
/****************************************************************************/
HSURF DrvEnableSurface(DHPDEV dhpdev)
{
    PDD_PDEV   pPDev = (PDD_PDEV)dhpdev;
    SIZEL      sizl, tempSizl;
    HSURF      rc = 0;
    ULONG      memSize;
    PBYTE      newFrameBuf;

    HANDLE     SectionObject = NULL;

    DC_BEGIN_FN("DrvEnableSurface");

    TRC_NRM((TB, "Enabling surface for %p", dhpdev));
    DD_UPD_STATE(DD_ENABLE_SURFACE_IN);

    // Have GDI create the actual SURFOBJ.
    sizl.cx = pPDev->cxScreen;
    sizl.cy = pPDev->cyScreen;

    /************************************************************************/
    /* An RDP display driver has a bitmap where GDI does all its drawing,   */
    /* since it is the only driver in the IWS.  We need to allocate the     */
    /* bitmap ourselves in order to know its address.                       */
    /*                                                                      */
    /* We allocate a Frame Buffer at DrvEnableSurface time to make          */
    /* sure that the frame buffer surface is same as the device surface     */
    /* GDI thinks.  This will prevent a lot of mismatch reconnect condition */
    /************************************************************************/
#ifdef DC_HICOLOR
    if ((pPDev->cClientBitsPerPel != ddFrameBufBpp + 1) ||
        (pddFrameBuf == NULL) ||
        (ddFrameBufX < sizl.cx) || (ddFrameBufY < sizl.cy))
#else
    if ((pPDev->cClientBitsPerPel != ddFrameBufBpp) ||
         (ddFrameBufX != sizl.cx) || (ddFrameBufY != sizl.cy))
#endif
    {
        // Allocate a new one. Note that we do not free the old one here -
        // that's done in DrvDisableSurface.
        memSize = TS_BYTES_IN_BITMAP(pPDev->cxScreen,
                                     pPDev->cyScreen,
                                     pPDev->cClientBitsPerPel);
         
        newFrameBuf = (PBYTE)EngAllocSectionMem(&SectionObject,
                                                FL_ZERO_MEMORY,
                                                memSize,
                                                DD_ALLOC_TAG);

        if (newFrameBuf == NULL) {
            TRC_ERR((TB, "DrvEnableSurface - "
                    "Failed FrameBuf EngAllocSectionMem for %lu bytes", memSize));
            newFrameBuf = (PBYTE)EngAllocMem(FL_ZERO_MEMORY,
                                             memSize,
                                             DD_ALLOC_TAG);
            SectionObject = NULL;
        }
#ifdef DC_DEBUG
        // NT BUG 539912 - Instance count section memory objects
        else {
            dbg_ddSectionAllocs++;
            TRC_DBG(( TB, "DrvEnableSurface - %d outstanding surfaces allocated",
                dbg_ddSectionAllocs ));

            DBG_DD_FNCALL_HIST_ADD( DBG_DD_ALLOC_SECTIONOBJ,
                dbg_ddSectionAllocs, 0, newFrameBuf, SectionObject);
        }
#endif
 
        TRC_NRM((TB, "Reallocate Frame Buffer %p, SectionObject %p", newFrameBuf, SectionObject));

        if (newFrameBuf == NULL) {
            TRC_ERR((TB, "DrvEnableSurface - "
                    "Failed FrameBuf EngAllocMem for %lu bytes", memSize));
            if (pddFrameBuf == NULL) {
                // Reset the frame buffer size back to 0.
                ddFrameBufX = ddFrameBufY = 0;
            }
            DC_QUIT;
        }

        pddFrameBuf = newFrameBuf;
        ddFrameBufX = sizl.cx;
        ddFrameBufY = sizl.cy;
        ddFrameBufBpp = pPDev->cClientBitsPerPel;        
        ddFrameIFormat = pPDev->iBitmapFormat;

        ddSectionObject = SectionObject;          
    }

    // Create the frame buffer surface.
    tempSizl.cx = ddFrameBufX;
    tempSizl.cy = ddFrameBufY;

    pPDev->hsurfFrameBuf = (HSURF)EngCreateBitmap(tempSizl,
            TS_BYTES_IN_SCANLINE(ddFrameBufX, ddFrameBufBpp),
            ddFrameIFormat, BMF_TOPDOWN, (PVOID)pddFrameBuf);


    if (pPDev->hsurfFrameBuf == 0) {
        TRC_ERR((TB, "Could not allocate surface"));
        DC_QUIT;

    }

    // Update Frame Buffer pointers in PDEV.
    pPDev->pFrameBuf = pddFrameBuf;
    pPDev->SectionObject = ddSectionObject;

    // Associate the frame buffer with the pdev.
    if (EngAssociateSurface(pPDev->hsurfFrameBuf, pPDev->hdevEng, 0)) {
        // Get a pointer to the frame buffer SURFOBJ.
        pPDev->psoFrameBuf = EngLockSurface(pPDev->hsurfFrameBuf);
    }
    else {
        TRC_ERR((TB, "EngAssociateSurface failed: hsurfFrameBuf(%p)",
                 pPDev->hsurfFrameBuf));
        DC_QUIT;
    }

    /************************************************************************/
    /* Create a device surface.  This is what we will pass back to the      */
    /* Graphics Engine.  The fact that it is a device surface forces all    */
    /* drawing to come through the display driver.                          */
    /*                                                                      */
    /* We pass the Frame Buffer SURFOBJ pointer as the DHSURF, so we can    */
    /* easily convert the (SURFOBJ *) parameters in the Drv... functions    */
    /* into real Frame Buffer SURFOBJ pointers:                             */
    /*                                                                      */
    /*      psoFrameBuf = (SURFOBJ *)(psoTrg->dhsurf);                      */
    /************************************************************************/
    pPDev->hsurfDevice = EngCreateDeviceSurface((DHSURF)pPDev->psoFrameBuf,
            sizl, pPDev->iBitmapFormat);

    // Now associate the device surface and the PDEV.
    if (!EngAssociateSurface(pPDev->hsurfDevice, pPDev->hdevEng,
            pPDev->flHooks)) {
        TRC_ERR((TB, "DrvEnableSurface - Failed EngAssociateSurface"));
        DC_QUIT;
    }

    TRC_NRM((TB, "hsurfFrameBuf(%p) hsurfDevice(%p) psoFrameBuf(%p)",
            pPDev->hsurfFrameBuf, pPDev->hsurfDevice, pPDev->psoFrameBuf));

    // Finally initialize the DD components, if necessary.
    if (ddInitPending) {
        TRC_NRM((TB, "DD init pending"));
        ddInitPending = FALSE;
        if (!DDInit(pPDev, FALSE, FALSE, NULL, 0)) {
            TRC_ERR((TB, "Failed to initialize DD Components"));
            DC_QUIT;
        }
    }
    else {
        // Don't do this is we're not connected.
        if (ddConnected && pddShm != NULL) {
            TRC_ALT((TB, "Re-enable surface"));

            // Initialization not pending - this must be a desktop change.
            // Flush the SDA & Order Heap.
            TRC_ALT((TB, "New surface"));
            
            BAResetBounds();

            // With Direct Encoding, at this point the orders in the order
            // heap have already changed the encoding state, blowing away
            // orders at this point will cause inconsistent state of the encoding
            // table between the server and client.  This is because we keep
            // the last order type sent, so blowing away orders here means 
            // order type will not be sent to the client, but the server encoding
            // table and state still kept the last order state.  It's almost 
            // impossible to rewind the orders at this point.  So, we simply have
            // to send the orders to the client to keep order encoding state 
            // consistent. 
            //OA_DDSyncUpdatesNow();
            
            // SBC_DDSync();  // TODO: Determine how this affects shadowing!!!

            DD_UPD_STATE(DD_REINIT);
        }
        else {
            TRC_ALT((TB, "Not connected"));
        }
    }

    // We have successfully associated the surface so return it to the GDI.
    rc = pPDev->hsurfDevice;
    DD_UPD_STATE(DD_ENABLE_SURFACE_OUT);
    TRC_NRM((TB, "Enabled surface for %p, FB %p", pPDev, pPDev->pFrameBuf));

DC_EXIT_POINT:

    // Tidy up any resources if we failed.
    if (rc == 0) {
        DrvDisableSurface((DHPDEV) pPDev);
        DD_UPD_STATE(DD_ENABLE_SURFACE_ERR);
    }

    DC_END_FN();
    return rc;
}


/****************************************************************************/
/* DrvDisableSurface - see NT DDK documentation                             */
/*                                                                          */
/* Free resources allocated by DrvEnableSurface.  Release the surface.      */
/*                                                                          */
/* Note that this function will be called when previewing modes in the      */
/* Display Applet, but not at system shutdown.  If you need to reset the    */
/* hardware at shutdown, you can do it in the miniport by providing a       */
/* 'HwResetHw' entry point in the VIDEO_HW_INITIALIZATION_DATA structure.   */
/*                                                                          */
/* Note: In an error case, we may call this before DrvEnableSurface is      */
/*       completely done.                                                   */
/****************************************************************************/
VOID DrvDisableSurface(DHPDEV dhpdev)
{
    BOOL     rc;
    PDD_PDEV pPDev = (PDD_PDEV)dhpdev;

    DC_BEGIN_FN("DrvDisableSurface");

    TRC_NRM((TB, "Disabling surface for %p", dhpdev));

    if (pPDev->psoFrameBuf != NULL) {
        EngUnlockSurface(pPDev->psoFrameBuf);
        pPDev->psoFrameBuf = NULL;
    }

    if (pPDev->hsurfDevice != 0) {
        TRC_DBG((TB, "Deleting device surface"));
        EngDeleteSurface(pPDev->hsurfDevice);
        pPDev->hsurfDevice = 0;
    }

    // Delete the Frame Buffer only if it is not still in use.
    if (pPDev->hsurfFrameBuf != 0) {
        TRC_DBG((TB, "Deleting frame buffer surface"));
        EngDeleteSurface(pPDev->hsurfFrameBuf);
        pPDev->hsurfFrameBuf = 0;
    }

    if ((pPDev->pFrameBuf != NULL) && (pPDev->pFrameBuf != pddFrameBuf)) {
        if (pPDev->SectionObject != NULL) {
            TRC_NRM((TB, "Freeing section frame buffer %p", pPDev->pFrameBuf));
            rc = EngFreeSectionMem(pPDev->SectionObject, (PVOID)pPDev->pFrameBuf);
            if (!rc) {
                TRC_ABORT((TB, "EngFreeSectionMem failed, section object will "
                    "leak"));
#ifdef DC_DEBUG                
                WDIcaBreakOnDebugger();
#endif // DC_DEBUG
            }
                
#ifdef DC_DEBUG
            else {
                // NT BUG 539912 - Instance count section memory objects
                dbg_ddSectionAllocs--;
                TRC_DBG(( TB, "DrvDisableSurface - %d outstanding surfaces allocated",
                    dbg_ddSectionAllocs ));

                DBG_DD_FNCALL_HIST_ADD( DBG_DD_FREE_SECTIONOBJ_SURFACE, 
                    dbg_ddSectionAllocs, 0, pddFrameBuf, ddSectionObject);
            }
#endif
            pPDev->SectionObject = NULL;
        } else {
            TRC_NRM((TB, "Freeing frame buffer %p", pPDev->pFrameBuf));
            EngFreeMem((PVOID)pPDev->pFrameBuf);
        }    
        pPDev->pFrameBuf = NULL;
    }

    DC_END_FN();
}


/****************************************************************************/
// DDHandleWDSync
//
// Moves rare WD SHM data update notifications out of the perf path.
/****************************************************************************/
void DDHandleWDSync()
{
    ULONG bytesReturned;
    NTSTATUS Status;

    DC_BEGIN_FN("DDHandleWDSync");

    // Now look for any updated fields that might be available.
    if (pddShm->oe.newCapsData) {
        TRC_DBG((TB, "Update for OE, %d", pddShm->oe.newCapsData));
        OE_Update();
    }
    if (pddShm->sbc.newCapsData) {
        TRC_NRM((TB, "newCapsData for SBC"));
        SBC_Update(NULL);
    }
    if (pddShm->sbc.syncRequired) {
        TRC_NRM((TB, "syncRequired for SBC"));
        SBC_DDSync(FALSE);
    }
    if (pddShm->sbc.fClearCache) {
        unsigned i;

        // reset the flag
        pddShm->sbc.fClearCache = FALSE;

        // walk through each cache to determine if that cache
        // needs to be cleared
        for (i = 0; i < pddShm->sbc.NumBitmapCaches; i++) {
            if (pddShm->sbc.bitmapCacheInfo[i].fClearCache) {
                TRC_NRM((TB, "clear cache with cacheID=%d", i));

                // clear the entries in the cache
                CH_ClearCache(pddShm->sbc.bitmapCacheInfo[i].
                        cacheHandle);

                // reset the clear cache flag in SBC
                pddShm->sbc.bitmapCacheInfo[i].fClearCache = FALSE;
            }
        }

        // send an IOCTL to RDPWD for screen redraw
        Status = EngFileIoControl(ddWdHandle,
                IOCTL_WDTS_DD_REDRAW_SCREEN,
                NULL, 0, NULL, 0, &bytesReturned);

        if (Status != STATUS_SUCCESS) {
            TRC_ERR((TB, "Redraw Screen IOCtl returned %lu", Status));
        }
    }

    if (pddShm->sbc.fDisableOffscreen) {
        
        // reset the flag
        pddShm->sbc.fDisableOffscreen = FALSE;

        // disable offscreen rendering support
        pddShm->sbc.offscreenCacheInfo.supportLevel = TS_OFFSCREEN_DEFAULT;

        // send an IOCTL to RDPWD for screen redraw
        Status = EngFileIoControl(ddWdHandle, IOCTL_WDTS_DD_REDRAW_SCREEN,
                NULL, 0, NULL, 0, &bytesReturned);

        if (Status != STATUS_SUCCESS) {
            TRC_ERR((TB, "Redraw Screen IOCtl returned %lu", Status));
        }
    }

#ifdef DRAW_NINEGRID
    if (pddShm->sbc.fDisableDrawNineGrid) {

        // reset the flag
        pddShm->sbc.fDisableDrawNineGrid = FALSE;

        // disable offscreen rendering support
        pddShm->sbc.drawNineGridCacheInfo.supportLevel = TS_DRAW_NINEGRID_DEFAULT;

        // send an IOCTL to RDPWD for screen redraw
        Status = EngFileIoControl(ddWdHandle, IOCTL_WDTS_DD_REDRAW_SCREEN,
                NULL, 0, NULL, 0, &bytesReturned);

        if (Status != STATUS_SUCCESS) {
            TRC_ERR((TB, "Redraw Screen IOCtl returned %lu", Status));
        }
    }
#endif

#ifdef DRAW_GDIPLUS
    if (pddShm->sbc.fDisableDrawGdiplus) {

        // reset the flag
        pddShm->sbc.fDisableDrawGdiplus = FALSE;

        // disable gdiplus support
        pddShm->sbc.drawGdiplusInfo.supportLevel = TS_DRAW_GDIPLUS_DEFAULT;

        // send an IOCTL to RDPWD for screen redraw
        Status = EngFileIoControl(ddWdHandle, IOCTL_WDTS_DD_REDRAW_SCREEN,
                NULL, 0, NULL, 0, &bytesReturned);

        if (Status != STATUS_SUCCESS) {
            TRC_ERR((TB, "Redraw Screen IOCtl returned %lu", Status));
        }
    }
#endif


    // Check SSI flags.
    if (pddShm->ssi.saveBitmapSizeChanged ||
            pddShm->ssi.resetInterceptor) {
        TRC_DBG((TB, "Update for SSI, %d:%d",
                pddShm->ssi.saveBitmapSizeChanged,
                pddShm->ssi.resetInterceptor));
        SSI_Update(FALSE);
    }

    DC_END_FN();
}


/****************************************************************************/
// DrvEscape - see NT DDK documentation.
/****************************************************************************/
ULONG DrvEscape(
        SURFOBJ *pso,
        ULONG iEsc,
        ULONG cjIn,
        PVOID pvIn,
        ULONG cjOut,
        PVOID pvOut)
{
    ULONG rc = FALSE;
    ULONG escCode = 0;
    ULONG bytesReturned;
    NTSTATUS status;
    TSHARE_DD_TIMER_INFO timerInfo;
    TSHARE_DD_OUTPUT_IN outputIn;
    PDD_PDEV pPDev;

    DC_BEGIN_FN("DrvEscape");

    // DrvEscape sometimes gets called after the driver has terminated,
    // especially with ESC_TIMEROBJ_SIGNALLED.
    if (ddConnected) {
        pPDev = (PDD_PDEV)pso->dhpdev;

        // Performance path in this function is the desktop thread timer
        // trigger.
        if (iEsc == ESC_TIMEROBJ_SIGNALED) {
            TRC_DBG((TB, "Got a timer kick - IOCtl to WD"));
            TRC_ASSERT((NULL != pso), (TB, "NULL pso"));

            rc = TRUE;

            // Race condition: we got output (or, more likely, a timer pop)
            // after a disconnect. Just ignore it.
            if (NULL != pddShm) {
                status = SCH_DDOutputAvailable(pPDev, TRUE);

                // If this fails, either
                // - the failure was in the WD, and it's up to the WD to
                //   correct it (or quit the session)
                // - the failure was in the infrastructure carrying the
                //   IOCtl to the WD.  There's nothing we can do in this
                //   case other than try on the next output call.
                if (status != STATUS_SUCCESS) {
                    TRC_ERR((TB, "Error on sending output IOCtl, status %lu",
                            status));
                }

                if (!pddShm->fShmUpdate) {
                    DC_QUIT;
                }
                else {
                    DDHandleWDSync();
                    pddShm->fShmUpdate = FALSE;
                }
            }

            DC_QUIT;
        }
    }
    else {
        TRC_ERR((TB, "DrvEscape %s (%d) called after DD terminated",
                iEsc == QUERYESCSUPPORT       ? "QUERYESCSUPPORT      " :
                iEsc == ESC_TIMEROBJ_SIGNALED ? "ESC_TIMEROBJ_SIGNALED" :
                iEsc == ESC_SET_WD_TIMEROBJ   ? "ESC_SET_WD_TIMEROBJ  " :
                                                "- Unknown -",
                iEsc));

        // Return FALSE for QUERYESCSUPPORT, TRUE for others (otherwise
        // USER asserts).
        rc = (iEsc == QUERYESCSUPPORT ? FALSE : TRUE);
        DC_QUIT;
    }

    // Process the non-performance-path escape codes.
    switch (iEsc) {
        case QUERYESCSUPPORT:
            // Do we support the function?  If so, mark the function as OK.
            escCode = *((PUINT32)pvIn);

            TRC_DBG((TB, "Query for escape code %lu", escCode));

            if ((escCode == ESC_TIMEROBJ_SIGNALED) ||
                    (escCode == ESC_SET_WD_TIMEROBJ)) {
                // Supported functions - return TRUE.
                TRC_DBG((TB, "We support escape code %lu", escCode));
                rc = TRUE;
            }
            break;


        case ESC_SET_WD_TIMEROBJ:
        {
            DD_UPD_STATE(DD_TIMEROBJ);

            // We have been given the timer details from Win32: pass them
            // to the WD. Note, only allow this to occur once to prevent
            // evil apps from trying to fake this call.
            if (pddWdTimer == NULL) {
                if (cjIn != sizeof(PKTIMER)) {
                    TRC_ERR((TB, "Unexpected size %lu arrived", cjIn));
                }
                else {
                    // Got the timer object OK.  Save the handle here, and
                    // then IOCtl across to the WD to tell it the handle.
                    TRC_DBG((TB, "Timer object %p arrived", pvIn));
                    pddWdTimer = (PKTIMER)pvIn;
                    TRC_ASSERT((ddWdHandle != NULL), (TB, "NULL WD handle"));

                    timerInfo.pKickTimer = pddWdTimer;
                    status = EngFileIoControl(ddWdHandle,
                            IOCTL_WDTS_DD_TIMER_INFO, &timerInfo,
                            sizeof(TSHARE_DD_TIMER_INFO), NULL, 0,
                            &bytesReturned);
                    if (status != STATUS_SUCCESS) {
                        TRC_ERR((TB, "Timer Info IOCtl returned %lu", status));

                        // Looking at the current NT code, there is NO WAY of
                        // reporting an error on this operation. If we return
                        // 0 from DrvEscape, then USER will assert. Great.
                    }
                }
            }

            rc = TRUE;
        }

        break;

#ifdef DC_DEBUG
        // This event is generated by Bungle, a test app which displays the
        // contents of the frame buffer.  Here we return it the address of
        // the frame buffer so it can do the displaying.
        case 3:
        {
            ULONG cBytes;

            TRC_ALT((TB, "copy frame buffer requested"));

            pPDev = (PDD_PDEV)pso->dhpdev;
            cBytes = (ULONG)(pPDev->cxScreen * pPDev->cyScreen);
            if (cjOut != cBytes) {
                TRC_ERR((TB, "Wrong memory block size"));
            }
            else {
                memcpy(pvOut, pPDev->pFrameBuf, cBytes);
                rc = TRUE;
            }
        }
        break;

#ifdef i386
        // This event will be generated by the DbgBreak program. It forces
        // us to break to the kernel debugger in the right WinStation
        // context and in the DD, thus letting us set break points in a
        // sensible fashion!
        case 4:
            TRC_ALT((TB, "break to debugger requested"));
            _asm int 3;
            break;
#endif

#endif  // DC_DEBUG

        case ESC_GET_DEVICEBITMAP_SUPPORT:
        {
            SIZEL bitmapSize;
             
            if (cjIn >= sizeof(ICA_DEVICE_BITMAP_INFO)) {
            
                if (cjOut >= sizeof(ULONG)) {
                    
                    bitmapSize.cx = (*((PICA_DEVICE_BITMAP_INFO)pvIn)).cx;
                    bitmapSize.cy = (*((PICA_DEVICE_BITMAP_INFO)pvIn)).cy;
                    
                    rc = TRUE;
                    
                    if (OEDeviceBitmapCachable(pPDev, bitmapSize, pPDev->iBitmapFormat)) {
                        *((PULONG)pvOut) = TRUE;
                    }
                    else {
                        *((PULONG)pvOut) = FALSE;
                    }
                }
                else {
                    TRC_ERR((TB, "Wrong output block size"));
                }
            }
            else {
                TRC_ERR((TB, "Wrong input block size"));
            }
        }
        break;

        default:
            TRC_ERR((TB, "Unrecognised request %lu", iEsc));
            break;
    }

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}


/****************************************************************************/
/* DrvGetModes - see NT DDK documentation                                   */
/*                                                                          */
/* Returns the list of available modes for the device.                      */
/****************************************************************************/
ULONG DrvGetModes(HANDLE hDriver, ULONG cjSize, DEVMODEW *pdm)
{
    INT32 cModes;
    INT32 cbOutputSize = 0;
    PVIDEO_MODE_INFORMATION pVideoModeInformation = NULL;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    INT32 cOutputModes = cjSize / sizeof(DEVMODEW);
    INT32 cbModeSize;

    DC_BEGIN_FN("DrvGetModes");

    TRC_NRM((TB, "DrvGetModes"));

    // Get the list of valid modes.
    cModes = DDGetModes(hDriver, &pVideoModeInformation, &cbModeSize);

    // Should only ever return zero modes or one mode:
    // If we're chained into the console session, we'll see zero modes so
    // we return 0 to indicate that we will do whatever was set up in the
    // registry before we got loaded. Otherwise, if we got more than one mode
    // we bail out now.
    if (cModes == -1) {
        TRC_NRM((TB, "DrvGetModes returning 0 modes"));
        ddConsole = TRUE;
        DC_QUIT;
    }

    if (cModes != 1) {
        TRC_ERR((TB, "DrvGetModes failed to get mode information"));
        ddConsole = FALSE;
        DC_QUIT;
    }

    if (pdm == NULL) {
        // Return the size of the buffer required to receive all our modes.
        cbOutputSize = cModes * sizeof(DEVMODEW);
        TRC_DBG((TB, "Require %ld bytes for data", cbOutputSize));
    }
    else {
        // Now copy the information for the supported modes back into the
        // output buffer.
        cbOutputSize = 0;
        pVideoTemp = pVideoModeInformation;

        do {
            if (pVideoTemp->Length != 0) {
                // Check we still have room in the buffer.
                if (cOutputModes == 0) {
                    TRC_DBG((TB, "No more room %ld modes left", cModes));
                    break;
                }

                // Clear the structure.
                memset(pdm, 0, sizeof(DEVMODEW));

                // Set the name of the device to the name of the DLL.
                memcpy(pdm->dmDeviceName, DD_DLL_NAME, sizeof(DD_DLL_NAME));

                // Fill in the rest of the mode info.
                pdm->dmSpecVersion      = DM_SPECVERSION;
                pdm->dmDriverVersion    = DM_SPECVERSION;
                pdm->dmSize             = sizeof(DEVMODEW);
                pdm->dmDriverExtra      = 0;

                pdm->dmBitsPerPel       = pVideoTemp->BitsPerPlane;
                pdm->dmPelsWidth        = pVideoTemp->VisScreenWidth;
                pdm->dmPelsHeight       = pVideoTemp->VisScreenHeight;
                pdm->dmDisplayFrequency = pVideoTemp->Frequency;
                pdm->dmDisplayFlags     = 0;

                pdm->dmFields           = DM_BITSPERPEL       |
                                          DM_PELSWIDTH        |
                                          DM_PELSHEIGHT       |
                                          DM_DISPLAYFREQUENCY |
                                          DM_DISPLAYFLAGS     ;

                TRC_NRM((TB, "Returned mode info:"));
                TRC_NRM((TB, "  pdm->dmBitsPerPel: %u", pdm->dmBitsPerPel));
                TRC_NRM((TB, "  pdm->dmPelsWidth: %u", pdm->dmPelsWidth));
                TRC_NRM((TB, "  pdm->dmPelsHeight: %u", pdm->dmPelsHeight));
                TRC_NRM((TB, "  pdm->dmDisplayFrequency: %u",
                                                    pdm->dmDisplayFrequency));

                // Go to the next DEVMODE entry in the buffer.
                cOutputModes--;

                pdm = (LPDEVMODEW) ( ((UINT_PTR)pdm) + sizeof(DEVMODEW));

                cbOutputSize += sizeof(DEVMODEW);
            }

            pVideoTemp = (PVIDEO_MODE_INFORMATION)
                (((PCHAR)pVideoTemp) + cbModeSize);

        } while (--cModes);
    }

DC_EXIT_POINT:
    if (pVideoModeInformation != NULL) {
        TRC_DBG((TB, "Freeing mode list"));
        EngFreeMem(pVideoModeInformation);
    }

    DC_END_FN();
    return cbOutputSize;
}


/****************************************************************************/
// DrvAssertMode - see NT DDK documentation.
/****************************************************************************/
BOOL DrvAssertMode(DHPDEV dhpdev, BOOL bEnable)
{
    PDD_PDEV pPDev = (PDD_PDEV)dhpdev;
    BOOL bRc;
    SURFOBJ *psoFrameBuf;
    SURFOBJ *psoDevice;

    DC_BEGIN_FN("DrvAssertMode");

    TRC_NRM((TB, "pPDev %p, bEnable %d", pPDev, bEnable));

#ifdef DC_DEBUG
    // NT BUG 539912 - track calls to DD fns.
    DBG_DD_FNCALL_HIST_ADD( DBG_DD_FNCALL_DRV_ASSERTMODE, 
        dhpdev, bEnable, pddFrameBuf, ddSectionObject);
#endif
    
    if (bEnable) {
        // The surface is being re-enabled.
        TRC_ALT((TB, "Enabling pPDev %p", pPDev));

        // Re-associate the surface handles with the device handle.
        if (!EngAssociateSurface(pPDev->hsurfFrameBuf, pPDev->hdevEng, 0)) {
            TRC_ERR((TB, "Failed to associate surface %p and dev %p",
                    pPDev->hsurfFrameBuf, pPDev->hdevEng));
            bRc = FALSE;
            DC_QUIT;
        }

        if (!EngAssociateSurface(pPDev->hsurfDevice, pPDev->hdevEng,
                pPDev->flHooks)) {
            TRC_ERR((TB, "Failed to associate surface %p and dev %p",
                    pPDev->hsurfDevice, pPDev->hdevEng));
            bRc = FALSE;
            DC_QUIT;
        }

        TRC_ALT((TB, "Associated surfaces %p & %p with dev %p",
                pPDev->hsurfDevice, pPDev->hsurfFrameBuf, pPDev->hdevEng));

        TRC_ASSERT((pddFrameBuf != NULL), (TB, "NULL frame buffer"));
        
        // Fixup the Frame Buffer surface object to point to the current
        // Frame Buffer.
        psoFrameBuf = pPDev->psoFrameBuf;
        TRC_ASSERT((psoFrameBuf != NULL), (TB,"NULL psoFrameBuf"));
        TRC_ASSERT((psoFrameBuf->iType == STYPE_BITMAP),
                    (TB, "Wrong FB surface iType, %d", psoFrameBuf->iType));
        psoFrameBuf->sizlBitmap.cx = ddFrameBufX;
        psoFrameBuf->sizlBitmap.cy = ddFrameBufY;
        psoFrameBuf->cjBits = TS_BYTES_IN_BITMAP(ddFrameBufX,
                                                 ddFrameBufY,
                                                 ddFrameBufBpp);
        psoFrameBuf->pvBits = pddFrameBuf;
        psoFrameBuf->pvScan0 = pddFrameBuf;
        psoFrameBuf->lDelta = TS_BYTES_IN_SCANLINE(ddFrameBufX, ddFrameBufBpp);
#ifdef DC_HICOLOR
        TRC_ERR((TB, "New DD frameBufBpp %d", ddFrameBufBpp));
        switch (ddFrameBufBpp) {
            case 4:
                psoFrameBuf->iBitmapFormat = BMF_4BPP;
                break;

            case 8:
                psoFrameBuf->iBitmapFormat = BMF_8BPP;
                break;

            case 15:
            case 16:
                psoFrameBuf->iBitmapFormat = BMF_16BPP;
                break;

            case 24:
                psoFrameBuf->iBitmapFormat = BMF_24BPP;
                break;

            default:
                TRC_ERR((TB, "Unsupported frame buf bpp %u - default to 8",
                        ddFrameBufBpp));
                psoFrameBuf->iBitmapFormat = BMF_8BPP;
                break;
        }
#else
        psoFrameBuf->iBitmapFormat = ddFrameBufBpp == 8 ? BMF_8BPP : BMF_4BPP;
#endif

        // Fixup the device surface object with the characteristics of the
        // current Frame Buffer.
        psoDevice = EngLockSurface(pPDev->hsurfDevice);

        TRC_ASSERT((psoDevice != NULL), (TB,"Null device surfac"));
        TRC_ASSERT((psoDevice->iType == STYPE_DEVICE),
                    (TB, "Wrong device surface iType, %d", psoDevice->iType));
        TRC_ASSERT((psoDevice->pvBits == NULL),
                    (TB, "Device surface has bits, %p", psoDevice->pvBits));
        TRC_ASSERT((psoDevice->dhsurf == (DHSURF)psoFrameBuf),
                    (TB, "Wrong dhSurf, expect/is %p/%p",
                    psoFrameBuf, psoDevice->dhsurf));

        // We assert now since we should always get the same iBitmapFormat
        // as 8BPP.  This will change once we have 24bit color support.
        // Then this needs to be looked at it and fix anything as necessary
        TRC_ASSERT((psoDevice->iBitmapFormat == psoFrameBuf->iBitmapFormat),
                   (TB, "iBitmapFormat has changed"));

        // We shouldn't change the device surface size.  This has already
        // been advertised to GDI, changing this will cause AV in GDI,
        // since GDI has cached the surface size.
        //psoDevice->sizlBitmap = psoFrameBuf->sizlBitmap;
        //psoDevice->iBitmapFormat = psoFrameBuf->iBitmapFormat;

        EngUnlockSurface(psoDevice);

        // We should never overwrite the frame-buffer pointer or section
        // object; This could cause a memory leak.  If we hit this assert,
        // we can investigate if this does in fact lead to a memory leak.
        TRC_ASSERT(((pPDev->pFrameBuf == pddFrameBuf) &&
                    (pPDev->SectionObject == ddSectionObject)),
                    (TB, "Frame buffer or section object pointer overwritten"));

#ifdef DC_DEBUG
        // NT BUG 539912 - because the above assert is not hit in stress, we
        // change this case to produce an IcaBreakOnDebugger
        if (pPDev->pFrameBuf != pddFrameBuf ||
            pPDev->SectionObject != ddSectionObject) {
            WDIcaBreakOnDebugger();
        }
#endif

        // Make sure the PDev points to the current Frame Buffer.
        pPDev->pFrameBuf = pddFrameBuf;
        TRC_ALT((TB, "Pointed PDev %p to Frame Buf %p", pPDev,
                pPDev->pFrameBuf));

        // Make sure the pDev points to the current SectionObject
        pPDev->SectionObject = ddSectionObject;
        TRC_ALT((TB, "Pointed PDev %p to Section Object %p", pPDev,
                pPDev->SectionObject));
    }

    bRc = TRUE;

DC_EXIT_POINT:
    DC_END_FN();
    return bRc;
}


/****************************************************************************/
/* Name:      DrvDisconnect                                                 */
/*                                                                          */
/* Purpose:   Process a disconnect from W32 - clean up the output capture   */
/*            code and the connection to the WD.                            */
/*                                                                          */
/* Returns:   TRUE if all is well                                           */
/*                                                                          */
/* Params:    IN - channel handle                                           */
/*            IN - file object for channel                                  */
/*                                                                          */
/* Operation: Gives all sub-components notice of the disconnect, and then   */
/*            IOCtls to the WD to tell it that we're going.                 */
/****************************************************************************/
BOOL DrvDisconnect(HANDLE channelHandle, PVOID pChannelFileObject)
{
    DC_BEGIN_FN("DrvDisconnect");

    TRC_NRM((TB, "DrvDisconnect called"));

#ifdef DC_DEBUG
    // NT BUG 539912 - track calls to DD fns.
    DBG_DD_FNCALL_HIST_ADD( DBG_DD_FNCALL_DRV_DISCONNECT, 
        channelHandle, pChannelFileObject, ddConnected, 0);
#endif

    // Check that we're connected.
    if (ddConnected) {
        // Terminate the dependent components.
        DDDisconnect(FALSE);
    }
    else {
        TRC_ERR((TB, "Disconnect called when not connected"));
        DD_UPD_STATE(DD_DISCONNECT_ERR);
    }

    DC_END_FN();
    return TRUE;
} /* DrvDisconnect */


/****************************************************************************/
/* Name:      DrvConnect - see Citrix documentation/code                    */
/*                                                                          */
/* Purpose:   Called when a Winstation is first connected                   */
/*                                                                          */
/* Returns:   TRUE if all is well                                           */
/*                                                                          */
/* Params:    IN - channel handle to use to IOCtl to WD                     */
/*            IN - file object for channel - used on EngFileWrite           */
/*            IN - video file object                                        */
/*            IN - cache statistics memory.  NB This is doc'd as OUT, but   */
/*                 the code actually passes a ptr in.                       */
/*                                                                          */
/* Operation: Save the key parameters                                       */
/*                                                                          */
/*            Note that this function is called before DrvEnablePDEV and    */
/*            DrvEnableSurface, hence it is not a good place to initialize  */
/*            TShare components.  This is done later, in DDInit, called     */
/*            from DrvEnableSurface.                                        */
/****************************************************************************/
BOOL DrvConnect(
        HANDLE channelHandle,
        PVOID pChannelFileObject,
        PVOID pVideoFileObject,
        PVOID pThinWireCache)
{
    PCACHE_STATISTICS pPerformanceCounters;

    DC_BEGIN_FN("DrvConnect");

    TRC_NRM((TB, "DrvConnect"));

#ifdef DC_DEBUG
    // NT BUG 539912 - track calls to DD fns.
    DBG_DD_FNCALL_HIST_ADD( DBG_DD_FNCALL_DRV_CONNECT, 
        channelHandle, pChannelFileObject, pVideoFileObject, pThinWireCache);
#endif

    /************************************************************************/
    /* Check for sensible values - the chained DD could get loaded other    */
    /* than on a connect call                                               */
    /************************************************************************/
    if ((channelHandle      == NULL) ||
            (pChannelFileObject == NULL) ||
            (pVideoFileObject   == NULL) ||
            (pThinWireCache     == NULL)) {
        TRC_ERR((TB, "Null input params"));

#ifdef DC_DEBUG
        TRC_ALT((TB, "But load anyway!"));
        return TRUE;
#endif
        return FALSE;
    }

#ifdef DC_DEBUG
    if (ddState & DD_DISCONNECT_OUT)
        DD_SET_STATE(DD_WAS_DISCONNECTED);
    DD_UPD_STATE(DD_CONNECT);
#endif

    // Save the channel handle, and perf counters for later - the other
    // params are currently not needed.
    ddWdHandle = pChannelFileObject;
    pPerformanceCounters = pThinWireCache;
    pPerformanceCounters->ProtocolType = PROTOCOL_ICA;
    pPerformanceCounters->Length = sizeof(ICA_CACHE);
    pddCacheStats = pPerformanceCounters->Specific.IcaCacheStats.ThinWireCache;

    // Note that init is pending.
    ddInitPending = TRUE;

    // Note that we're connected.
    ddConnected = TRUE;

    DC_END_FN();
    return TRUE;
} /* DrvConnect */


/****************************************************************************/
/* Name:      DrvReconnect                                                  */
/*                                                                          */
/* Pass the IOCtl to the WD, and save off the returned values, as on        */
/* connect.                                                                 */
/****************************************************************************/
BOOL DrvReconnect(HANDLE channelHandle, PVOID pChannelFileObject)
{
    BOOL rc;

    DC_BEGIN_FN("DrvReconnect");

    TRC_NRM((TB, "DrvReconnect"));

#ifdef DC_DEBUG
    // NT BUG 539912 - track calls to DD fns.
    DBG_DD_FNCALL_HIST_ADD( DBG_DD_FNCALL_DRV_RECONNECT, 
        channelHandle, pChannelFileObject, ddConnected, ddConsole);
#endif

    // In case the dd has not been unloaded at the end of the previous
    // console shadow, we're getting called to handle this.
    if (ddConsole && ddConnected) {
        // no need to reconnect
        rc = TRUE;
        TRC_ASSERT((ddWdHandle == pChannelFileObject),
                   (TB,"Reconnecting with different WD handle for Console Shadow)"));
        DC_QUIT;
    }

#ifdef DC_DEBUG
    if (ddState & DD_DISCONNECT_OUT)
        DD_SET_STATE(DD_WAS_DISCONNECTED);
    DD_UPD_STATE(DD_RECONNECT_IN);
#endif

    // Save the channel handle for later - the other params are currently
    // not needed.
    ddWdHandle = pChannelFileObject;

    // Note that we're connected. Do this whether we reconnect
    // successfully or not, as DrvDisconnect is called if we fail to        */
    // reconnect.
    ddConnected = TRUE;

    // Reinitialize RDPDD.
    rc = DDInit(NULL, TRUE, ddConsole?TRUE: FALSE, NULL, 0);
    if (!rc) {
        TRC_ERR((TB, "Failed to reinitialize DD"));
    }

    DD_UPD_STATE(DD_RECONNECT_OUT);

DC_EXIT_POINT:

    DC_END_FN();
    return rc;
} /* DrvReconnect */


/****************************************************************************/
/* DrvResetPDEV - see NT DDK documentation                                  */
/*                                                                          */
/* Allows us to reject dynamic screen changes if necessary                  */
/****************************************************************************/
BOOL DrvResetPDEV(DHPDEV dhpdevOld, DHPDEV dhpdevNew)
{
    BOOL rc = TRUE;
    ULONG bytesReturned;
    NTSTATUS Status;
    ICA_CHANNEL_END_SHADOW_DATA Data;

    DC_BEGIN_FN("DrvResetPDEV");

    // On the console, we can only allow the display driver to change modes
    // while the connection is not up.
    if (ddConsole && ddConnected) {
        TRC_ALT((TB, "Mode change during console shadow: ending console shadow now"));

        Data.StatusCode = STATUS_CTX_SHADOW_ENDED_BY_MODE_CHANGE;
        Data.bLogError = TRUE;

        Status = EngFileIoControl(ddWdHandle,
                                  IOCTL_ICA_CHANNEL_END_SHADOW,
                                  &Data, sizeof(Data),
                                  NULL, 0,
                                  &bytesReturned);
    }
    else {
        TRC_ALT((TB, "Allowing mode change"));
    }

    DC_END_FN();
    return rc;
}



/****************************************************************************/
/* DrvGetDirectDrawInfo - see NT DDK documentation.                         */
/*                                                                          */
/* Function called by DirectDraw to returns the capabilities of the         */
/* graphics hardware                                                        */
/*                                                                          */
/****************************************************************************/
BOOL 
DrvGetDirectDrawInfo(
    DHPDEV dhpdev,
    DD_HALINFO*     pHalInfo,
    DWORD*          pdwNumHeaps,
    VIDEOMEMORY*    pvmList,            // Will be NULL on first call
    DWORD*          pdwNumFourCC,
    DWORD*          pdwFourCC)          // Will be NULL on first call
{
    BOOL rc = TRUE;
    PDD_PDEV pPDev = (PDD_PDEV)dhpdev;
    BOOL bCanFlip=0;

    DC_BEGIN_FN("DrvGetDirectDrawInfo");

    TRC_NRM((TB, "DrvGetDirectDrawInfo"));

    // DirectDraw only supports 8, 16, 24 or 32 bpp
    if ( (8  != pPDev->cClientBitsPerPel) &&
         (16 != pPDev->cClientBitsPerPel) &&
         (24 != pPDev->cClientBitsPerPel) &&
         (32 != pPDev->cClientBitsPerPel) )
    {
        rc = FALSE;
        DC_QUIT;
    }
    
    //    DirectDraw is not supported if our frame buffer is not allocated as
    //    section mem.
    if (pPDev->SectionObject == NULL) {
        TRC_ERR((TB, "The section object is null."));
        rc = FALSE;
        DC_QUIT;
    }
        

    pHalInfo->dwSize = sizeof(*pHalInfo);

    // Current primary surface attributes.  Since HalInfo is zero-initialized
    // by GDI, we only have to fill in the fields which should be non-zero:

    pHalInfo->vmiData.pvPrimary       = pPDev->pFrameBuf;
    pHalInfo->vmiData.dwDisplayWidth  = pPDev->cxScreen;
    pHalInfo->vmiData.dwDisplayHeight = pPDev->cyScreen;
    pHalInfo->vmiData.lDisplayPitch   = pPDev->psoFrameBuf->lDelta;
	
    pHalInfo->vmiData.ddpfDisplay.dwSize  = sizeof(DDPIXELFORMAT);
    pHalInfo->vmiData.ddpfDisplay.dwFlags = DDPF_RGB; 
    pHalInfo->vmiData.ddpfDisplay.dwRGBBitCount = pPDev->cClientBitsPerPel;
	
    if (pPDev->iBitmapFormat == BMF_8BPP)
    {
        pHalInfo->vmiData.ddpfDisplay.dwFlags |= DDPF_PALETTEINDEXED8;
    }

    // These masks will be zero at 8bpp:

    pHalInfo->vmiData.ddpfDisplay.dwRBitMask = pPDev->flRed;
    pHalInfo->vmiData.ddpfDisplay.dwGBitMask = pPDev->flGreen;
    pHalInfo->vmiData.ddpfDisplay.dwBBitMask = pPDev->flBlue;

    if (pPDev->iBitmapFormat == BMF_32BPP)
    {
        pHalInfo->vmiData.ddpfDisplay.dwRGBAlphaBitMask
            = ~(pPDev->flRed | pPDev->flGreen | pPDev->flBlue);
    }
    else
    {
        pHalInfo->vmiData.ddpfDisplay.dwRGBAlphaBitMask = 0;
    }

    //We don't support flip
    bCanFlip = FALSE;

    // We don't have any video memory for offscreen use
    *pdwNumHeaps = 0;
 
    // Capabilities supported:
    pHalInfo->ddCaps.dwFXCaps = 0;

    // No hardware support
    pHalInfo->ddCaps.dwCaps = DDCAPS_NOHARDWARE;

    pHalInfo->ddCaps.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;

    if (bCanFlip)
    {
        pHalInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_FLIP;
    }

    // FourCCs supported:

    *pdwNumFourCC = 0;
    // We see rdpdd passes 4bpp to directx in stress, which it does't support
    // so we assert here
    TRC_ASSERT(((pHalInfo->vmiData.ddpfDisplay.dwRGBBitCount != 4) &&
               (pHalInfo->vmiData.ddpfDisplay.dwRGBBitCount != 15)),
               (TB, "RDPDD shoould not pass bpp %d to DirectX",
               pHalInfo->vmiData.ddpfDisplay.dwRGBBitCount));
	
DC_EXIT_POINT:
    DC_END_FN();
    return rc;
} 

/****************************************************************************/
/* DrvEnableDirectDraw - see NT DDK documentation.                          */
/*                                                                          */
/* GDI calls DrvEnableDirectDraw to obtain pointers to the DirectDraw       */
/* callbacks that the driver supports.                                      */
/*                                                                          */
/****************************************************************************/
BOOL DrvEnableDirectDraw(
    DHPDEV                  dhpdev,
    DD_CALLBACKS*           pCallBacks,
    DD_SURFACECALLBACKS*    pSurfaceCallBacks,
    DD_PALETTECALLBACKS*    pPaletteCallBacks)
{
    BOOL rc = TRUE;
    PDD_PDEV   pPDev = (PDD_PDEV)dhpdev;

    DC_BEGIN_FN("DrvEnableDirectDraw");

    TRC_NRM((TB, "DrvEnableDirectDraw"));

#ifdef DC_DEBUG
    DBG_DD_FNCALL_HIST_ADD( DBG_DD_FNCALL_DRV_ENABLEDIRECTDRAW,
        0, 0, pPDev->SectionObject, ddSectionObject);
#endif

    //    DirectDraw is not supported if our frame buffer is not allocated as
    //    section mem.
    if (pPDev->SectionObject == NULL ) {
        TRC_ERR((TB, "The section object is NULL!"));
        rc = FALSE;
        DC_QUIT;
    }

    pCallBacks->MapMemory            = DdMapMemory;
    pCallBacks->dwFlags              = DDHAL_CB32_MAPMEMORY;

    pSurfaceCallBacks->Lock          = DdLock;
    pSurfaceCallBacks->Unlock        = DdUnlock;
    pSurfaceCallBacks->dwFlags       = DDHAL_SURFCB32_LOCK
                                     | DDHAL_SURFCB32_UNLOCK;

DC_EXIT_POINT:
    DC_END_FN();
    return rc; 
} 


/****************************************************************************/
/* DrvDisableDirectDraw - see NT DDK documentation.                         */
/*                                                                          */
/****************************************************************************/
VOID DrvDisableDirectDraw(
    DHPDEV  dhpdev)
{   
    DC_BEGIN_FN("DrvDisableDirectDraw");

    TRC_NRM((TB, "DrvDisableDirectDraw"));

#ifdef DC_DEBUG
    DBG_DD_FNCALL_HIST_ADD( DBG_DD_FNCALL_DRV_DISABLEDIRECTDRAW,
        0, 0, 0, ddSectionObject);
#endif

    //Do nothing here

    DC_END_FN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpdd\nddint.c ===
/****************************************************************************/
// nddint.c
//
// RDP DD internal functions.
//
// Copyright (C) 1996-2000 Microsoft Corporation
/****************************************************************************/

#include <precmpdd.h>
#define hdrstop

#define TRC_FILE "nddint"
#include <adcg.h>
#include <atrcapi.h>

#include <nddapi.h>
#include <nsbcdisp.h>
#include <nbadisp.h>
#include <nshmapi.h>
#include <nwdwioct.h>
#include <nwdwapi.h>
#include <noadisp.h>
#include <nssidisp.h>
#include <abcapi.h>
#include <nchdisp.h>
#include <ncmdisp.h>
#include <noedisp.h>
#include <nschdisp.h>
#include <oe2.h>

#define DC_INCLUDE_DATA
#include <ndddata.c>
#undef DC_INCLUDE_DATA


/****************************************************************************/
// DDInitializeModeFields
//
// Initializes a bunch of fields in the pdev, devcaps (aka gdiinfo), and
// devinfo based on the requested mode. Returns FALSE on failure.
/****************************************************************************/
void RDPCALL DDInitializeModeFields(
        PDD_PDEV ppdev,
        GDIINFO *pGdiInfoOrg,
        GDIINFO *pgdi,
        DEVINFO *pdi,
        DEVMODEW *pdm)
{
    HPALETTE hpal;

    DC_BEGIN_FN("DDInitializeModeFields");

    TRC_NRM((TB, "Size of pdm: %d (should be %d)",
            pdm->dmSize, sizeof(DEVMODEW)));
    TRC_NRM((TB, "Requested mode..."));
    TRC_NRM((TB, "   Screen width  -- %li", pdm->dmPelsWidth));
    TRC_NRM((TB, "   Screen height -- %li", pdm->dmPelsHeight));
    TRC_NRM((TB, "   Bits per pel  -- %li", pdm->dmBitsPerPel));
    TRC_NRM((TB, "   Frequency     -- %li", pdm->dmDisplayFrequency));

    // Set up screen information from the DEVMODE structure.
    ppdev->ulMode      = 0;
    ppdev->cxScreen    = pdm->dmPelsWidth;
    ppdev->cyScreen    = pdm->dmPelsHeight;
    ppdev->cClientBitsPerPel = pdm->dmBitsPerPel;
    ppdev->cProtocolBitsPerPel = 8;

    // Mark which functions we provide hooks for.
    ppdev->flHooks = ( HOOK_TEXTOUT    |
                       HOOK_STROKEPATH |
                       HOOK_BITBLT     |
                       HOOK_COPYBITS   |
                       HOOK_FILLPATH   |
                       HOOK_LINETO     |
                       HOOK_PAINT      |
                       HOOK_STRETCHBLT |
                       HOOK_SYNCHRONIZEACCESS);

    // Fill in the GDIINFO data structure with the default 8bpp values.
    *pgdi = ddDefaultGdi;

    // Now overwrite the defaults with the relevant information returned
    // from the kernel driver:
    pgdi->ulHorzRes         = ppdev->cxScreen;
    pgdi->ulVertRes         = ppdev->cyScreen;
    pgdi->ulPanningHorzRes  = 0;
    pgdi->ulPanningVertRes  = 0;

    pgdi->cBitsPixel        = ppdev->cClientBitsPerPel;
    pgdi->cPlanes           = 1;
    pgdi->ulVRefresh        = 0;

    pgdi->ulDACRed          = 8;
    pgdi->ulDACGreen        = 8;
    pgdi->ulDACBlue         = 8;

    pgdi->ulLogPixelsX      = pdm->dmLogPixels;
    pgdi->ulLogPixelsY      = pdm->dmLogPixels;

#ifdef DC_HICOLOR
    /************************************************************************/
    /* Fill in the mask values.                                             */
    /************************************************************************/
    if (pgdi->cBitsPixel == 24)
    {
        ppdev->flRed            = TS_RED_MASK_24BPP;
        ppdev->flGreen          = TS_GREEN_MASK_24BPP;
        ppdev->flBlue           = TS_BLUE_MASK_24BPP;
    }
    else if (pgdi->cBitsPixel == 16)
    {
        ppdev->flRed            = TS_RED_MASK_16BPP;
        ppdev->flGreen          = TS_GREEN_MASK_16BPP;
        ppdev->flBlue           = TS_BLUE_MASK_16BPP;
    }
    else if (pgdi->cBitsPixel == 15)
    {
        ppdev->flRed            = TS_RED_MASK_15BPP;
        ppdev->flGreen          = TS_GREEN_MASK_15BPP;
        ppdev->flBlue           = TS_BLUE_MASK_15BPP;
    }
    else
    {
        ppdev->flRed            = 0;
        ppdev->flGreen          = 0;
        ppdev->flBlue           = 0;
    }
#else
    ppdev->flRed            = 0;
    ppdev->flGreen          = 0;
    ppdev->flBlue           = 0;
#endif

    // Fill in the devinfo structure with the default 8bpp values, taking
    // care not to trash the supplied hpalDefault (which allows us to
    // query information about the real display driver's color format).
    hpal = pdi->hpalDefault;
    *pdi = ddDefaultDevInfo;
    pdi->hpalDefault = hpal;

    switch (ppdev->cClientBitsPerPel) {
        case 8:
            ppdev->iBitmapFormat   = BMF_8BPP;

            pgdi->ulNumColors      = 20;
            pgdi->ulNumPalReg      = 256;
            pgdi->ulHTOutputFormat = HT_FORMAT_8BPP;

            pdi->iDitherFormat     = BMF_8BPP;
            break;

        case 4:
            ppdev->iBitmapFormat   = BMF_4BPP;

            pgdi->ulNumColors      = 16;
            pgdi->ulNumPalReg      = 0;
            pgdi->ulHTOutputFormat = HT_FORMAT_4BPP;

            pdi->iDitherFormat     = BMF_4BPP;
            pdi->flGraphicsCaps   &= ~GCAPS_PALMANAGED;
            pgdi->ulDACRed         = 4;
            pgdi->ulDACGreen       = 4;
            pgdi->ulDACBlue        = 4;
            break;

        case 15:
        case 16:
            ppdev->iBitmapFormat   = BMF_16BPP;

            pgdi->ulHTOutputFormat = HT_FORMAT_16BPP;

            pdi->iDitherFormat     = BMF_16BPP;
            pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
            break;

        case 24:
            // DIB conversions will only work if we have a standard RGB
            // surface for 24bpp.
            TRC_ASSERT((ppdev->flRed   == 0x00ff0000), (TB,"Invalid red"));
            TRC_ASSERT((ppdev->flGreen == 0x0000ff00), (TB,"Invalid green"));
            TRC_ASSERT((ppdev->flBlue  == 0x000000ff), (TB,"Invalid blue"));

            ppdev->iBitmapFormat   = BMF_24BPP;

            pgdi->ulHTOutputFormat = HT_FORMAT_24BPP;

            pdi->iDitherFormat     = BMF_24BPP;
            pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
            break;

        case 32:
            ppdev->iBitmapFormat   = BMF_32BPP;

            pgdi->ulHTOutputFormat = HT_FORMAT_32BPP;

            pdi->iDitherFormat = BMF_32BPP;
            pdi->flGraphicsCaps &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
            break;

        default:
            // Unsupported bpp - pretend we are 8 bpp.
            TRC_ERR((TB, "Unsupported bpp value: %d",
                    pGdiInfoOrg->cBitsPixel * pGdiInfoOrg->cPlanes));
            break;
    }

    DC_END_FN();
}


/****************************************************************************/
// DDInitializePalette
//
// Set up the default palette for the display driver. Returns FALSE on
// failure.
/****************************************************************************/
BOOL RDPCALL DDInitializePalette(PDD_PDEV ppdev, DEVINFO *pdi)
{
    BOOL rc;
    PALETTEENTRY *ppalTmp;
    ULONG ulLoop;
    BYTE jRed;
    BYTE jGre;
    BYTE jBlu;
    HPALETTE hpal;

    DC_BEGIN_FN("DDInitializePalette");

    if (ppdev->iBitmapFormat == BMF_8BPP || ppdev->iBitmapFormat == BMF_4BPP) {
        if (ppdev->iBitmapFormat == BMF_8BPP) {
            // cColors == 256: Generate 256 (8*8*4) RGB combinations to fill
            // the palette.
            jRed = 0;
            jGre = 0;
            jBlu = 0;

            ppalTmp = ppdev->Palette;
            for (ulLoop = 256; ulLoop != 0; ulLoop--) {
                // JPB: The values used in the default rainbow set of
                // colors do not particularly matter. However, we do not
                // want any of the entries to match entries in the default
                // VGA colors.  Therefore we tweak the color values
                // slightly to ensure that there are no matches.
                ppalTmp->peRed   = ((jRed == 0) ? (jRed+1) : (jRed-1));
                ppalTmp->peGreen = ((jGre == 0) ? (jGre+1) : (jGre-1));
                ppalTmp->peBlue  = ((jBlu == 0) ? (jBlu+1) : (jBlu-1));
                ppalTmp->peFlags = 0;

                ppalTmp++;

                if (!(jRed += 32))
                    if (!(jGre += 32))
                        jBlu += 64;
            }

            // Fill in Windows reserved colors from the WIN 3.0 DDK. The
            // Windows Manager reserved the first and last 10 colours for
            // painting windows borders and for non-palette managed
            // applications.
            memcpy(ppdev->Palette, ddDefaultPalette, sizeof(PALETTEENTRY) *
                    10);
            memcpy(&(ppdev->Palette[246]), &(ddDefaultPalette[10]),
                    sizeof(PALETTEENTRY) * 10);

            // Create handle for palette.
            hpal = EngCreatePalette(PAL_INDEXED, 256, (ULONG*)ppdev->Palette, 0,
                   0, 0);
        }
        else {
            // Set up the new palette.  The palette contains 256 colors, as
            // that is the color depth of the protocol.  For convenience,
            // - copy entire 16-color palette into slots 0-15
            // - copy high colors (8-15) into high end of palette (240-255)
            // This means that we can use indices 0-15, or 0-7, 248-255
            // later.
            memcpy(ppdev->Palette, ddDefaultVgaPalette,
                    sizeof(ddDefaultVgaPalette));

            // Zero the middle entries since the palette was uninitialized.
            memset(&(ppdev->Palette[16]), 0, sizeof(PALETTEENTRY) * 208);

            memcpy(&(ppdev->Palette[248]), &(ddDefaultVgaPalette[8]),
                    sizeof(*ddDefaultVgaPalette) * 8);

            // Create handle for palette.
            hpal = EngCreatePalette(PAL_INDEXED, 16, (ULONG*)ppdev->Palette, 0,
                   0, 0);
        }
    }
    else {
        TRC_ASSERT(((ppdev->iBitmapFormat == BMF_16BPP) ||
                (ppdev->iBitmapFormat == BMF_24BPP) ||
                (ppdev->iBitmapFormat == BMF_32BPP)),
                (TB, "This case handles only 16, 24 or 32bpp"));

        hpal = EngCreatePalette(PAL_BITFIELDS, 0, NULL, ppdev->flRed,
                ppdev->flGreen, ppdev->flBlue);
    }

    ppdev->hpalDefault = hpal;
    pdi->hpalDefault   = hpal;

    if (hpal != 0) {
        rc = TRUE;
    }
    else {
        rc = FALSE;
        TRC_ERR((TB, "EngCreatePalette returned zero"));
    }

    // Note that we don't need to free the memory for the palette as that
    // is always tidied up in the driver termination code
    // (DrvDisableDriver).
    DC_END_FN();
    return rc;
}


/****************************************************************************/
// DDGetModes
//
// Returns the list of modes supported. Sends an IOCtl to the miniport
// driver (the WD) to get the information. NOTE: the buffer must be freed up
// by the caller. Returns the number of entries in the videomode buffer.
// A return code of 0 is an error.
// A return code of -1 indicates that we are in chained mode.
/****************************************************************************/
INT32 RDPCALL DDGetModes(
        HANDLE hDriver,
        PVIDEO_MODE_INFORMATION *modeInformation,
        PINT32 pModeSize)
{
    ULONG ulTemp;
    VIDEO_NUM_MODES modes;
    INT32 rc = 0;
    UINT32 bytesReturned;
    NTSTATUS status; 

    DC_BEGIN_FN("DDGetModes");

    // Get the number of modes supported by the mini-port.
    if (!EngDeviceIoControl(hDriver, IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES,
            NULL, 0, &modes, sizeof(VIDEO_NUM_MODES), &ulTemp)) {
        // When we're chained into the console session, our miniport will
        // return 0 for the number of modes, indicating that we'll do whatever
        // was specified in the registry when we got loaded.
        if (modes.NumModes != 0) {
            // Allocate the buffer to receive the modes from the miniport.
            *pModeSize = modes.ModeInformationLength;
             *modeInformation = (PVIDEO_MODE_INFORMATION)EngAllocMem(0,
                    modes.NumModes*modes.ModeInformationLength, DD_ALLOC_TAG);

            
            if (*modeInformation != NULL) {
                // Ask the mini-port to fill in the available modes.
                if (!EngDeviceIoControl(hDriver, IOCTL_VIDEO_QUERY_AVAIL_MODES,
                        NULL, 0, *modeInformation,
                        modes.NumModes * modes.ModeInformationLength,
                        &ulTemp)) {
                    // Store the number of modes.
                    rc = modes.NumModes;
                }
                else {
                    TRC_ERR((TB, "getAvailableModes failed "
                            "VIDEO_QUERY_AVAIL_MODES"));

                    // Free the memory and quit.
                    EngFreeMem(*modeInformation);
                    *modeInformation = NULL;
                }
            }
            else {
                TRC_ERR((TB, "getAvailableModes failed EngAllocMem"));
            }
        }
        else {
            TRC_NRM((TB, "Num modes is 0 - chained"));
            rc = -1;
        }
    }
    else {
        TRC_ERR((TB, "getAvailableModes failed VIDEO_QUERY_NUM_AVAIL_MODES"));
    }

    DC_END_FN();
    return rc;
}

/****************************************************************************/
// DDInit
//
// Initialize the display protocol components of RDPDD. Returns FALSE on
// failure.
/****************************************************************************/
#define PERSISTENT_CACHE_ENTRIES_DEFAULT    3072

BOOL RDPCALL DDInit(
        PDD_PDEV pPDev,
        BOOL reconnect,
        BOOL reinit,
        PTSHARE_VIRTUAL_MODULE_DATA pVirtModuleData,
        UINT32 virtModuleDataLen)
{
    TSHARE_DD_CONNECT_IN connIn;
    TSHARE_DD_CONNECT_OUT *connOut = NULL;
    ULONG connOutSize;
    ULONG bytesReturned;
    NTSTATUS status;
    BOOL rc = FALSE;
    UINT32 IOCtlCode;

    DC_BEGIN_FN("DDInit");

    // Set the reconnect flag for debugging purposes.
    ddReconnected = reconnect;

    // Clear the order encoding histories since the client just reset its
    // history as well.
    OE_ClearOrderEncoding();
    SSI_ClearOrderEncoding();
    OE2_Reset();
    OE_Reset();

    // For reconnect, pPDev can be NULL. For connect, it is required.
    TRC_ASSERT((reconnect || pPDev || reinit), (TB,"Bad call %d, %p", reconnect, pPDev));
    DD_UPD_STATE(DD_INIT_IN);

    // Create shared memory (SHM).
    if (SHM_Init(pPDev)) {
        DD_UPD_STATE(DD_INIT_SHM_OUT);
    }
    else {
        TRC_ERR((TB, "Failed to init SHM"));
        DC_QUIT;
    }

    // IOCtl to the WD.
    connIn.pShm = pddShm;
    connIn.DDShmSize = sizeof(SHM_SHARED_MEMORY);

    // Following 3 fields have meaning only for reconnect - set them
    // anyway, RDPWD doesn't look at them for connect.
    connIn.pKickTimer = pddWdTimer;
    connIn.desktopHeight = ddDesktopHeight;
    connIn.desktopWidth = ddDesktopWidth;

#ifdef DC_HICOLOR
    // Need to supply this on the 'in' parameter - but note that it is not
    // updated until DrvEnableSurface is called.
    connIn.desktopBpp = ddFrameBufBpp;
#endif

    // Fields for shadow connect, NULL for normal connection processing
    connIn.pVirtModuleData = pVirtModuleData;
    connIn.virtModuleDataLen = virtModuleDataLen;

    connOutSize = sizeof(TSHARE_DD_CONNECT_OUT) + sizeof(SBC_BITMAP_CACHE_KEY_INFO) + 
            (PERSISTENT_CACHE_ENTRIES_DEFAULT - 1) * sizeof(SBC_MRU_KEY);
    connOut = (TSHARE_DD_CONNECT_OUT *)EngAllocMem(0, connOutSize, DD_ALLOC_TAG);

    if (connOut == NULL) {
        TRC_ERR((TB, "Failed to allocate memory for connOut"));    
        DC_QUIT;
    }

    memset(connOut, 0, connOutSize);
    connOut->primaryStatus = STATUS_SUCCESS;
    connOut->secondaryStatus = STATUS_SUCCESS;
    connOut->bitmapKeyDatabaseSize = sizeof(SBC_BITMAP_CACHE_KEY_INFO) + 
            (PERSISTENT_CACHE_ENTRIES_DEFAULT - 1) * sizeof(SBC_MRU_KEY);

    if (pVirtModuleData == NULL)
        IOCtlCode = (reconnect && !reinit)? IOCTL_WDTS_DD_RECONNECT :
                IOCTL_WDTS_DD_CONNECT;
    else
        IOCtlCode = IOCTL_WDTS_DD_SHADOW_CONNECT;

    bytesReturned = 0;
    status = EngFileIoControl(ddWdHandle, IOCtlCode, &connIn,
            sizeof(TSHARE_DD_CONNECT_IN), connOut,
            connOutSize, &bytesReturned);
    DD_UPD_STATE(DD_INIT_IOCTL_OUT);

    // If the primary stack connected, then we can continue output
    // regardless of whether or not the shadow stack came up.
    status = connOut->primaryStatus;
    if (connOut->primaryStatus == STATUS_SUCCESS) {
        ddConnected = TRUE;
    }
    else {
        TRC_ERR((TB, "Primary stack failed to connect! -> %lx", status));
        DD_UPD_STATE(DD_INIT_FAIL1);
        DC_QUIT;
    }

    if (bytesReturned && bytesReturned <= connOutSize) {
        DD_UPD_STATE(DD_INIT_OK1);

        // Save off the returned values that we need.
        if (IOCtlCode != IOCTL_WDTS_DD_SHADOW_CONNECT)
            pddTSWd = connOut->pTSWd;
        else
            pddTSWdShadow = connOut->pTSWd;
    }
    else {
        TRC_ERR((TB, "Wrong no %lu of bytes returned", bytesReturned));
        DD_UPD_STATE(DD_INIT_FAIL2);
        DC_QUIT;
    }

    // Enable trace to WD, since the correct config will now be in SHM.
#ifdef DC_DEBUG
    ddTrcToWD = TRUE;
#endif

#ifdef DC_COUNTERS
    // Zero out the counters and cache statistics.
    // We do not use counters unless specifically built to do so using
    // DC_COUNTERS. However, even if we wanted to, there is a bad
    // corruption problem owing to a timing problem where the counters are
    // freed while the DD still believes they are present. This is Windows NT
    // Bug #391762. If we want to have counters in production code we need
    // to fix that Win32K timing bug. Enable DC_COUNTERS and special pool
    // for rdpdd to make the bug come back.
    pddProtStats = connOut->pProtocolStatus;
    pddProtStats->Input.ProtocolType = PROTOCOL_ICA;
    pddProtStats->Output.ProtocolType = PROTOCOL_ICA;
    memset(pddCacheStats, 0, sizeof(ICA_CACHE));
    memset(&(pddProtStats->Output.Specific),
            0, sizeof(pddProtStats->Output.Specific));
    memset(&(pddProtStats->Input.Specific),
            0, sizeof(pddProtStats->Input.Specific));
#endif

    TRC_ERR((TB, "Received pTSWD %p", pddTSWd));
    ddDesktopHeight = connOut->desktopHeight;
    ddDesktopWidth = connOut->desktopWidth;

    // Once pddShm is set up, tracing should work - try it now.
    TRC_NRM((TB, "Handshake with RDPWD complete"));

    // Perform any other init that may be required for the wire protocol.
    if (!reconnect && !reinit) {
        TRC_NRM((TB, "Connect"));
        DD_UPD_STATE(DD_INIT_CONNECT);

        BA_DDInit();
        OA_DDInit();
        SSI_DDInit();
        if (!CM_DDInit(pPDev)) {
            TRC_ERR((TB, "CM Failed"));
            DC_QUIT;
        }

        SBC_DDInit(pPDev);
    } /* !reconnect */

    // RDPWD waits to receive all of ConfirmActivePDU, persistent bitmap
    // cache keys, and font lists from the Client before returning from the
    // IOCTL_WDTS_DD_(RE)CONNECT above. Hence, by the time we get here,
    // the capabilities have been updated in SHM. We do this for connect and
    // reconnect cases.
    TRC_NRM((TB, "Update capabilities"));
    OE_Update();
    CM_Update();

    // If bitmapKeyDatabaseSize is 0, then we failed to get the keydatabase
    // or there is no persistent caching
    if (connOut->bitmapKeyDatabaseSize) {
        if (connOut->bitmapKeyDatabaseSize <= sizeof(SBC_BITMAP_CACHE_KEY_INFO) + 
            (PERSISTENT_CACHE_ENTRIES_DEFAULT - 1) * sizeof(SBC_MRU_KEY)) {
            SBC_Update((SBC_BITMAP_CACHE_KEY_INFO *)(&(connOut->bitmapKeyDatabase)));
        }
        else {
            PTSHARE_DD_BITMAP_KEYDATABASE_OUT pKeyDBOut;
            unsigned keyDBOutSize;
            unsigned bytesReturned;

            //  the buffer is too small, reallocate a big one and try once more
            keyDBOutSize = sizeof(TSHARE_DD_BITMAP_KEYDATABASE_OUT) - 1+
                                connOut->bitmapKeyDatabaseSize;

            pKeyDBOut = (PTSHARE_DD_BITMAP_KEYDATABASE_OUT)
                    EngAllocMem(0, keyDBOutSize, DD_ALLOC_TAG);

            if (pKeyDBOut == NULL) {
                TRC_ERR((TB, "Failed to allocate memory for connOut"));    
                SBC_Update(NULL);
            }
            else {
                pKeyDBOut->bitmapKeyDatabaseSize = connOut->bitmapKeyDatabaseSize;

                status = EngFileIoControl(ddWdHandle, IOCTL_WDTS_DD_GET_BITMAP_KEYDATABASE, 
                        NULL, 0, pKeyDBOut,
                        keyDBOutSize, &bytesReturned);
    
                if (status == STATUS_SUCCESS && pKeyDBOut->bitmapKeyDatabaseSize <=
                        connOut->bitmapKeyDatabaseSize) {
                    SBC_Update((SBC_BITMAP_CACHE_KEY_INFO *)(&(pKeyDBOut->bitmapKeyDatabase)));
                }
                else {
                    SBC_Update(NULL);
                }

                EngFreeMem(pKeyDBOut);

            }
        }
    }
    else {
        SBC_Update(NULL);
    }

    SSI_Update(pVirtModuleData != NULL);

    // All OK for Primary Stack
    ddInitialised = TRUE;
    DD_UPD_STATE(DD_INIT_OK_ALL);

    // If the shadow stack failed to init, then flag it so we disconnect
    // the failed shadow stack via DrvShadowDisconnect
    if (connOut->secondaryStatus != STATUS_SUCCESS) {
        status = connOut->secondaryStatus;
        TRC_ERR((TB, "Shadow stack failed to connect! -> %lx", status));
        DD_UPD_STATE(DD_SHADOW_FAIL);
        DC_QUIT;
    }
    
    // If we got here then absolutely everything went OK
    rc = TRUE;

DC_EXIT_POINT:

    if (connOut != NULL) {
        EngFreeMem(connOut);
        connOut = NULL;
    }
    DC_END_FN();
    return rc;
} /* DDInit */


/****************************************************************************/
/* Name:      DDDisconnect                                                  */
/*                                                                          */
/* Purpose:   Terminate the share aspects of the DD.                        */
/*                                                                          */
/* Params:    bShadowDisconnect - TRUE is this is being done in preparation */
/*            for a shadow session request.                                 */
/*                                                                          */
/* Operation: Terminates all sub-components, and then IOCtls to the WD to   */
/*            tell it that we're going.                                     */
/*                                                                          */
/*            Finally it cleans up all refereces to WD data.                */
/*                                                                          */
/*            NB This routine can be called on connect failure - so all the */
/*            XX_Disc() APIs called by this routine must be robust to the   */
/*            component not having been initialized.                        */
/****************************************************************************/
void RDPCALL DDDisconnect(BOOL bShadowDisconnect)
{
    NTSTATUS status;
    ULONG bytesReturned;
    TSHARE_DD_DISCONNECT_IN disconnIn;

    DC_BEGIN_FN("DDDisconnect");
    DD_UPD_STATE(DD_DISCONNECT_IN);

    // Call disconnect functions where needed.
    CM_DDDisc();

    // Now tell the WD we're disconnecting.  We don't do anything with a
    // failure here - there's no point - we're already disconnecting!
    memset(&disconnIn, 0, sizeof(disconnIn));
    disconnIn.pShm = pddShm;
    disconnIn.bShadowDisconnect = bShadowDisconnect;

    status = EngFileIoControl(ddWdHandle, IOCTL_WDTS_DD_DISCONNECT,
           &disconnIn, sizeof(disconnIn), NULL, 0, &bytesReturned);

    // Send Bitmap Cache. Must be destroyed after the IOCTL to allow the
    // IOCTL to dump the cache contents for reconnect.
    SBC_DDDisc();

    // Finally, free SHM.
    SHM_Term();

    // If this is a real session disconnect, then blow away the WD ioctl
    // handle since we will get a new on one DrvReconnect(). Otherwise
    // we need to keep it since we will immediately reconnect back to the
    // same stack.
    if (!bShadowDisconnect)
        ddWdHandle = NULL;

    // Don't allow any drawing while we are disconnected!
    ddConnected = FALSE;

    TRC_NRM((TB, "Status on Disc IOCtl to WD %lu", status));
    DD_UPD_STATE(DD_DISCONNECT_OUT);

    DC_END_FN();
} /* DDDisconnect */


/****************************************************************************/
// DDTerm
//
// Terminate the output-remoting components of the DD.
/****************************************************************************/
void RDPCALL DDTerm(void)
{
    BOOL     rc;
    NTSTATUS status;

    DC_BEGIN_FN("DDTerm");

    // Call terminate functions where needed.
    SBC_DDTerm();
    CM_DDTerm();

    // Finally, free SHM.
    SHM_Term();

    ddWdHandle = NULL;
    pddWdTimer = NULL;

    if (pddFrameBuf != NULL) {
        if (ddSectionObject != NULL) {
            TRC_NRM((TB, "Freeing section mem frame buffer %p", pddFrameBuf));
            rc = EngFreeSectionMem(ddSectionObject, pddFrameBuf);
            if (!rc) {
                TRC_ABORT((TB, "EngFreeSectionMem failed, section object will "
                    "leak"));
            }
            
#ifdef DC_DEBUG
            else {
                // NT BUG 539912 - Instance count section memory objects
                 dbg_ddSectionAllocs--;
                TRC_DBG(( TB, "DDTerm - %d outstanding surfaces allocated",
                    dbg_ddSectionAllocs ));

                DBG_DD_FNCALL_HIST_ADD( DBG_DD_FREE_SECTIONOBJ_DDTERM, 
                    dbg_ddSectionAllocs, 0, pddFrameBuf, ddSectionObject);
            }
#endif // DC_DEBUG   
            ddSectionObject = NULL;
        } else {
            TRC_NRM((TB, "Freeing non-section frame buffer %p", pddFrameBuf));
            EngFreeMem(pddFrameBuf);
        }
        pddFrameBuf = NULL;
    }

#ifdef DC_DEBUG
    if (0 != dbg_ddSectionAllocs) {
        TRC_ABORT(( TB, "DDTerm - no section allocations should be outstanding" ));
    }
#endif  

    // Reset the frame buffer size to 0
    ddFrameBufX = ddFrameBufY = 0;

    ddInitialised = FALSE;

    DC_END_FN();
}

#define TS_GDIPLUS_LOCK_FALG 0x00000001
/****************************************************************************/
/* DdLock - see NT DDK documentation.                                       */
/*                                                                          */
/****************************************************************************/
DWORD DdLock(PDD_LOCKDATA  lpLock)
{
    DC_BEGIN_FN("DdLock");

    TRC_NRM((TB, "DdLock"));
#ifdef DRAW_GDIPLUS
    if (lpLock->dwFlags & DDLOCK_NODIRTYUPDATE) {
        // The lock is from GDI+ through DCI
        // set the flag
        lpLock->lpDDSurface->dwReserved1 |= TS_GDIPLUS_LOCK_FALG;
    }
    else {
#endif
        // We assume that DdLock and DdUnlock will be called in pair. 
        // If this is not the case, we return error in DdLock
        if(ddLocked){
            TRC_ERR((TB, "Error: DdLock is called twice in a row"));
            lpLock->ddRVal = DDERR_GENERIC;
            return(DDHAL_DRIVER_HANDLED);
        }

        // Record the locked area
        ddLockAreaLeft = lpLock->rArea.left;
        ddLockAreaTop= lpLock->rArea.top;
        ddLockAreaRight = lpLock->rArea.right;
        ddLockAreaBottom = lpLock->rArea.bottom;

        // Record that DdLock is called
        ddLocked = TRUE;
#ifdef DRAW_GDIPLUS
    }
#endif
         
    return(DDHAL_DRIVER_NOTHANDLED );
    DC_END_FN();
}


/****************************************************************************/
/* DdUnlock - see NT DDK documentation.                                     */
/*                                                                          */
/****************************************************************************/
DWORD DdUnlock(PDD_UNLOCKDATA  lpUnlock)
{
    PDD_PDEV pPDev;
    RECTL rLockArea;

    DC_BEGIN_FN("DdUnlock");

    TRC_NRM((TB, "DdUnlock"));

    pPDev = (PDD_PDEV)lpUnlock->lpDD->dhpdev;
#ifdef DRAW_GDIPLUS
    if (lpUnlock->lpDDSurface->dwReserved1 & TS_GDIPLUS_LOCK_FALG) {
        // The lock is from GDI+ through DCI
    }
    else {
#endif
        // We assume that DdLock and DdUnlock will be called in pair. 
        // If this is not the case, we return error in DdLock
        if(!ddLocked){
            TRC_ERR((TB, "Error: DdUnlock is called before DdLock"));
            lpUnlock->ddRVal = DDERR_GENERIC;
            return(DDHAL_DRIVER_HANDLED);
        }

        // Reset the lock flag
        ddLocked = FALSE;

        // Sometimes, we're called after being disconnected.
        if (ddConnected && pddShm != NULL) {
            rLockArea.left = ddLockAreaLeft;
            rLockArea.right = ddLockAreaRight;
            rLockArea.top = ddLockAreaTop;
            rLockArea.bottom = ddLockAreaBottom;

        
            // Send changed rectangle of framebuffer to the client
            OEClipAndAddScreenDataArea(&rLockArea, NULL);

            // Have scheduler consider sending output
            SCH_DDOutputAvailable(pPDev, FALSE);
        }
        else {
            TRC_ERR((TB, "Called when disconnected"));
        }
#ifdef DRAW_GDIPLUS
    }
#endif
    
    return(DDHAL_DRIVER_NOTHANDLED );
    DC_END_FN();
}




/******************************Public*Routine********************************/
/*  DdMapMemory - see NT DDK documentation.                                 */
/*                                                                          */
/*  This is a new DDI call specific to Windows NT that is used to map       */
/*  or unmap all the application modifiable portions of the frame buffer    */
/*  into the specified process's address space.                             */
/****************************************************************************/
DWORD DdMapMemory(PDD_MAPMEMORYDATA lpMapMemory)
{
    PDD_PDEV    pPDev;
    PVOID       pMapped = NULL;
    NTSTATUS    Status;
    BOOL        bEngMap;

    DC_BEGIN_FN("DdMapMemory");

    TRC_NRM((TB, "DdMapMemory"));

    pPDev = (PDD_PDEV) lpMapMemory->lpDD->dhpdev;
    
    //    In case the section object is null our frame buffer is not allocated
    //    as section mem. We don't support DDraw in this case.
    if (NULL == pPDev->SectionObject) {
        TRC_ERR((TB,"Null SectionObject"));
        lpMapMemory->ddRVal = DDERR_GENERIC;
        DC_QUIT;
    }

    if(lpMapMemory->bMap)     //Map the meory
        pMapped = NULL;
    else                      //Unmap the memory
        pMapped = (PVOID)lpMapMemory->fpProcess;
   
    bEngMap = EngMapSection(
                pPDev->SectionObject,
                lpMapMemory->bMap,
                lpMapMemory->hProcess,
                &pMapped);

    if(lpMapMemory->bMap && bEngMap)
        lpMapMemory->fpProcess = (FLATPTR)pMapped;
    
    if(bEngMap)
        lpMapMemory->ddRVal = DD_OK;
    else
        lpMapMemory->ddRVal = DDERR_GENERIC;
  
DC_EXIT_POINT:
    DC_END_FN();
    return(DDHAL_DRIVER_HANDLED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpdd\ndddata.c ===
/****************************************************************************/
// ndddata.c
//
// RDP DD data
//
// Copyright (C) 1996-2000 Microsoft Corporation
/****************************************************************************/

#include <ndcgdata.h>
#include <nddapi.h>
#include <nshmapi.h>
#include <aschapi.h>


/****************************************************************************/
/* Functions supported by our Display Driver.  Each entry is of the form:   */
/*  index    - NT DDK defined index for the DDI function                    */
/*  function - pointer to our intercept function                            */
/****************************************************************************/
#ifdef DRAW_GDIPLUS
#ifdef DRAW_NINEGRID
DC_CONST_DATA_ARRAY(DRVFN, ddDriverFns, DD_NUM_DRIVER_INTERCEPTS,
    DC_STRUCT38(
        // Required display driver functions.
        DC_STRUCT2( INDEX_DrvEnablePDEV,        (PFN)DrvEnablePDEV        ),
        DC_STRUCT2( INDEX_DrvCompletePDEV,      (PFN)DrvCompletePDEV      ),
        DC_STRUCT2( INDEX_DrvDisablePDEV,       (PFN)DrvDisablePDEV       ),
        DC_STRUCT2( INDEX_DrvEnableSurface,     (PFN)DrvEnableSurface     ),
        DC_STRUCT2( INDEX_DrvDisableSurface,    (PFN)DrvDisableSurface    ),

        // Non-required display driver functions.
        DC_STRUCT2( INDEX_DrvAssertMode,        (PFN)DrvAssertMode        ),
        DC_STRUCT2( INDEX_DrvResetPDEV,         (PFN)DrvResetPDEV         ),
        DC_STRUCT2( INDEX_DrvDisableDriver,     (PFN)DrvDisableDriver     ),
        DC_STRUCT2( INDEX_DrvGetModes,          (PFN)DrvGetModes          ),
        DC_STRUCT2( INDEX_DrvCreateDeviceBitmap, (PFN)DrvCreateDeviceBitmap),
        DC_STRUCT2( INDEX_DrvDeleteDeviceBitmap, (PFN)DrvDeleteDeviceBitmap),

        // Mouse pointer related functions.
        DC_STRUCT2( INDEX_DrvMovePointer,       (PFN)DrvMovePointer       ),
        DC_STRUCT2( INDEX_DrvSetPointerShape,   (PFN)DrvSetPointerShape   ),

        // Ouput functions.
        DC_STRUCT2( INDEX_DrvCopyBits,          (PFN)DrvCopyBits          ),
        DC_STRUCT2( INDEX_DrvStrokePath,        (PFN)DrvStrokePath        ),
        DC_STRUCT2( INDEX_DrvTextOut,           (PFN)DrvTextOut           ),
        DC_STRUCT2( INDEX_DrvBitBlt,            (PFN)DrvBitBlt            ),
        DC_STRUCT2( INDEX_DrvLineTo,            (PFN)DrvLineTo            ),
        DC_STRUCT2( INDEX_DrvStretchBlt,        (PFN)DrvStretchBlt        ),
        DC_STRUCT2( INDEX_DrvFillPath,          (PFN)DrvFillPath          ),
        DC_STRUCT2( INDEX_DrvPaint,             (PFN)DrvPaint             ),
        DC_STRUCT2( INDEX_DrvSaveScreenBits,    (PFN)DrvSaveScreenBits    ),
        DC_STRUCT2( INDEX_DrvNineGrid,          (PFN)DrvNineGrid          ),
        DC_STRUCT2( INDEX_DrvDrawEscape,        (PFN)DrvDrawEscape        ),

        // Support functions.
        DC_STRUCT2( INDEX_DrvDestroyFont,       (PFN)DrvDestroyFont       ),
        DC_STRUCT2( INDEX_DrvSetPalette,        (PFN)DrvSetPalette        ),
        DC_STRUCT2( INDEX_DrvRealizeBrush,      (PFN)DrvRealizeBrush      ),
        DC_STRUCT2( INDEX_DrvEscape,            (PFN)DrvEscape            ),
        DC_STRUCT2( INDEX_DrvDitherColor,       (PFN)DrvDitherColor       ),

        // TS-specfic entry points.
        DC_STRUCT2( INDEX_DrvConnect,           (PFN)DrvConnect           ),
        DC_STRUCT2( INDEX_DrvDisconnect,        (PFN)DrvDisconnect        ),
        DC_STRUCT2( INDEX_DrvReconnect,         (PFN)DrvReconnect         ),
        DC_STRUCT2( INDEX_DrvShadowConnect,     (PFN)DrvShadowConnect     ),
        DC_STRUCT2( INDEX_DrvShadowDisconnect,  (PFN)DrvShadowDisconnect  ),
        DC_STRUCT2( INDEX_DrvMovePointerEx,     (PFN)DrvMovePointerEx     ),

        // For Direct Draw.
        DC_STRUCT2( INDEX_DrvGetDirectDrawInfo,	(PFN) DrvGetDirectDrawInfo),
        DC_STRUCT2( INDEX_DrvEnableDirectDraw,	(PFN) DrvEnableDirectDraw ),
        DC_STRUCT2( INDEX_DrvDisableDirectDraw,	(PFN) DrvDisableDirectDraw)
    )
);
#else
DC_CONST_DATA_ARRAY(DRVFN, ddDriverFns, DD_NUM_DRIVER_INTERCEPTS,
    DC_STRUCT37(
        // Required display driver functions.
        DC_STRUCT2( INDEX_DrvEnablePDEV,        (PFN)DrvEnablePDEV        ),
        DC_STRUCT2( INDEX_DrvCompletePDEV,      (PFN)DrvCompletePDEV      ),
        DC_STRUCT2( INDEX_DrvDisablePDEV,       (PFN)DrvDisablePDEV       ),
        DC_STRUCT2( INDEX_DrvEnableSurface,     (PFN)DrvEnableSurface     ),
        DC_STRUCT2( INDEX_DrvDisableSurface,    (PFN)DrvDisableSurface    ),

        // Non-required display driver functions.
        DC_STRUCT2( INDEX_DrvAssertMode,        (PFN)DrvAssertMode        ),
        DC_STRUCT2( INDEX_DrvResetPDEV,         (PFN)DrvResetPDEV         ),
        DC_STRUCT2( INDEX_DrvDisableDriver,     (PFN)DrvDisableDriver     ),
        DC_STRUCT2( INDEX_DrvGetModes,          (PFN)DrvGetModes          ),
        DC_STRUCT2( INDEX_DrvCreateDeviceBitmap, (PFN)DrvCreateDeviceBitmap),
        DC_STRUCT2( INDEX_DrvDeleteDeviceBitmap, (PFN)DrvDeleteDeviceBitmap),

        // Mouse pointer related functions.
        DC_STRUCT2( INDEX_DrvMovePointer,       (PFN)DrvMovePointer       ),
        DC_STRUCT2( INDEX_DrvSetPointerShape,   (PFN)DrvSetPointerShape   ),

        // Ouput functions.
        DC_STRUCT2( INDEX_DrvCopyBits,          (PFN)DrvCopyBits          ),
        DC_STRUCT2( INDEX_DrvStrokePath,        (PFN)DrvStrokePath        ),
        DC_STRUCT2( INDEX_DrvTextOut,           (PFN)DrvTextOut           ),
        DC_STRUCT2( INDEX_DrvBitBlt,            (PFN)DrvBitBlt            ),
        DC_STRUCT2( INDEX_DrvLineTo,            (PFN)DrvLineTo            ),
        DC_STRUCT2( INDEX_DrvStretchBlt,        (PFN)DrvStretchBlt        ),
        DC_STRUCT2( INDEX_DrvFillPath,          (PFN)DrvFillPath          ),
        DC_STRUCT2( INDEX_DrvPaint,             (PFN)DrvPaint             ),
        DC_STRUCT2( INDEX_DrvSaveScreenBits,    (PFN)DrvSaveScreenBits    ),
        DC_STRUCT2( INDEX_DrvDrawEscape,        (PFN)DrvDrawEscape        ),

        // Support functions.
        DC_STRUCT2( INDEX_DrvDestroyFont,       (PFN)DrvDestroyFont       ),
        DC_STRUCT2( INDEX_DrvSetPalette,        (PFN)DrvSetPalette        ),
        DC_STRUCT2( INDEX_DrvRealizeBrush,      (PFN)DrvRealizeBrush      ),
        DC_STRUCT2( INDEX_DrvEscape,            (PFN)DrvEscape            ),
        DC_STRUCT2( INDEX_DrvDitherColor,       (PFN)DrvDitherColor       ),

        // TS-specfic entry points.
        DC_STRUCT2( INDEX_DrvConnect,           (PFN)DrvConnect           ),
        DC_STRUCT2( INDEX_DrvDisconnect,        (PFN)DrvDisconnect        ),
        DC_STRUCT2( INDEX_DrvReconnect,         (PFN)DrvReconnect         ),
        DC_STRUCT2( INDEX_DrvShadowConnect,     (PFN)DrvShadowConnect     ),
        DC_STRUCT2( INDEX_DrvShadowDisconnect,  (PFN)DrvShadowDisconnect  ),
        DC_STRUCT2( INDEX_DrvMovePointerEx,     (PFN)DrvMovePointerEx     ),

        // For Direct Draw.
        DC_STRUCT2( INDEX_DrvGetDirectDrawInfo,	(PFN) DrvGetDirectDrawInfo),
        DC_STRUCT2( INDEX_DrvEnableDirectDraw,	(PFN) DrvEnableDirectDraw ),
        DC_STRUCT2( INDEX_DrvDisableDirectDraw,	(PFN) DrvDisableDirectDraw)
    )
);
#endif // DRAW_NINEGRID
#else // DRAW_GDIPLUS
#ifdef DRAW_NINEGRID
DC_CONST_DATA_ARRAY(DRVFN, ddDriverFns, DD_NUM_DRIVER_INTERCEPTS,
    DC_STRUCT37(
        // Required display driver functions.
        DC_STRUCT2( INDEX_DrvEnablePDEV,        (PFN)DrvEnablePDEV        ),
        DC_STRUCT2( INDEX_DrvCompletePDEV,      (PFN)DrvCompletePDEV      ),
        DC_STRUCT2( INDEX_DrvDisablePDEV,       (PFN)DrvDisablePDEV       ),
        DC_STRUCT2( INDEX_DrvEnableSurface,     (PFN)DrvEnableSurface     ),
        DC_STRUCT2( INDEX_DrvDisableSurface,    (PFN)DrvDisableSurface    ),

        // Non-required display driver functions.
        DC_STRUCT2( INDEX_DrvAssertMode,        (PFN)DrvAssertMode        ),
        DC_STRUCT2( INDEX_DrvResetPDEV,         (PFN)DrvResetPDEV         ),
        DC_STRUCT2( INDEX_DrvDisableDriver,     (PFN)DrvDisableDriver     ),
        DC_STRUCT2( INDEX_DrvGetModes,          (PFN)DrvGetModes          ),
        DC_STRUCT2( INDEX_DrvCreateDeviceBitmap, (PFN)DrvCreateDeviceBitmap),
        DC_STRUCT2( INDEX_DrvDeleteDeviceBitmap, (PFN)DrvDeleteDeviceBitmap),

        // Mouse pointer related functions.
        DC_STRUCT2( INDEX_DrvMovePointer,       (PFN)DrvMovePointer       ),
        DC_STRUCT2( INDEX_DrvSetPointerShape,   (PFN)DrvSetPointerShape   ),

        // Ouput functions.
        DC_STRUCT2( INDEX_DrvCopyBits,          (PFN)DrvCopyBits          ),
        DC_STRUCT2( INDEX_DrvStrokePath,        (PFN)DrvStrokePath        ),
        DC_STRUCT2( INDEX_DrvTextOut,           (PFN)DrvTextOut           ),
        DC_STRUCT2( INDEX_DrvBitBlt,            (PFN)DrvBitBlt            ),
        DC_STRUCT2( INDEX_DrvLineTo,            (PFN)DrvLineTo            ),
        DC_STRUCT2( INDEX_DrvStretchBlt,        (PFN)DrvStretchBlt        ),
        DC_STRUCT2( INDEX_DrvFillPath,          (PFN)DrvFillPath          ),
        DC_STRUCT2( INDEX_DrvPaint,             (PFN)DrvPaint             ),
        DC_STRUCT2( INDEX_DrvSaveScreenBits,    (PFN)DrvSaveScreenBits    ),
        DC_STRUCT2( INDEX_DrvNineGrid,          (PFN)DrvNineGrid          ),

        // Support functions.
        DC_STRUCT2( INDEX_DrvDestroyFont,       (PFN)DrvDestroyFont       ),
        DC_STRUCT2( INDEX_DrvSetPalette,        (PFN)DrvSetPalette        ),
        DC_STRUCT2( INDEX_DrvRealizeBrush,      (PFN)DrvRealizeBrush      ),
        DC_STRUCT2( INDEX_DrvEscape,            (PFN)DrvEscape            ),
        DC_STRUCT2( INDEX_DrvDitherColor,       (PFN)DrvDitherColor       ),

        // TS-specfic entry points.
        DC_STRUCT2( INDEX_DrvConnect,           (PFN)DrvConnect           ),
        DC_STRUCT2( INDEX_DrvDisconnect,        (PFN)DrvDisconnect        ),
        DC_STRUCT2( INDEX_DrvReconnect,         (PFN)DrvReconnect         ),
        DC_STRUCT2( INDEX_DrvShadowConnect,     (PFN)DrvShadowConnect     ),
        DC_STRUCT2( INDEX_DrvShadowDisconnect,  (PFN)DrvShadowDisconnect  ),
        DC_STRUCT2( INDEX_DrvMovePointerEx,     (PFN)DrvMovePointerEx     ),

        // For Direct Draw.
        DC_STRUCT2( INDEX_DrvGetDirectDrawInfo,	(PFN) DrvGetDirectDrawInfo),
        DC_STRUCT2( INDEX_DrvEnableDirectDraw,	(PFN) DrvEnableDirectDraw ),
        DC_STRUCT2( INDEX_DrvDisableDirectDraw,	(PFN) DrvDisableDirectDraw)
    )
);
#else  // DRAW_NINEGRID
DC_CONST_DATA_ARRAY(DRVFN, ddDriverFns, DD_NUM_DRIVER_INTERCEPTS,
    DC_STRUCT36(
        // Required display driver functions.
        DC_STRUCT2( INDEX_DrvEnablePDEV,        (PFN)DrvEnablePDEV        ),
        DC_STRUCT2( INDEX_DrvCompletePDEV,      (PFN)DrvCompletePDEV      ),
        DC_STRUCT2( INDEX_DrvDisablePDEV,       (PFN)DrvDisablePDEV       ),
        DC_STRUCT2( INDEX_DrvEnableSurface,     (PFN)DrvEnableSurface     ),
        DC_STRUCT2( INDEX_DrvDisableSurface,    (PFN)DrvDisableSurface    ),

        // Non-required display driver functions.
        DC_STRUCT2( INDEX_DrvAssertMode,        (PFN)DrvAssertMode        ),
        DC_STRUCT2( INDEX_DrvResetPDEV,         (PFN)DrvResetPDEV         ),
        DC_STRUCT2( INDEX_DrvDisableDriver,     (PFN)DrvDisableDriver     ),
        DC_STRUCT2( INDEX_DrvGetModes,          (PFN)DrvGetModes          ),
        DC_STRUCT2( INDEX_DrvCreateDeviceBitmap, (PFN)DrvCreateDeviceBitmap),
        DC_STRUCT2( INDEX_DrvDeleteDeviceBitmap, (PFN)DrvDeleteDeviceBitmap),

        // Mouse pointer related functions.
        DC_STRUCT2( INDEX_DrvMovePointer,       (PFN)DrvMovePointer       ),
        DC_STRUCT2( INDEX_DrvSetPointerShape,   (PFN)DrvSetPointerShape   ),

        // Ouput functions.
        DC_STRUCT2( INDEX_DrvCopyBits,          (PFN)DrvCopyBits          ),
        DC_STRUCT2( INDEX_DrvStrokePath,        (PFN)DrvStrokePath        ),
        DC_STRUCT2( INDEX_DrvTextOut,           (PFN)DrvTextOut           ),
        DC_STRUCT2( INDEX_DrvBitBlt,            (PFN)DrvBitBlt            ),
        DC_STRUCT2( INDEX_DrvLineTo,            (PFN)DrvLineTo            ),
        DC_STRUCT2( INDEX_DrvStretchBlt,        (PFN)DrvStretchBlt        ),
        DC_STRUCT2( INDEX_DrvFillPath,          (PFN)DrvFillPath          ),
        DC_STRUCT2( INDEX_DrvPaint,             (PFN)DrvPaint             ),
        DC_STRUCT2( INDEX_DrvSaveScreenBits,    (PFN)DrvSaveScreenBits    ),       

        // Support functions.
        DC_STRUCT2( INDEX_DrvDestroyFont,       (PFN)DrvDestroyFont       ),
        DC_STRUCT2( INDEX_DrvSetPalette,        (PFN)DrvSetPalette        ),
        DC_STRUCT2( INDEX_DrvRealizeBrush,      (PFN)DrvRealizeBrush      ),
        DC_STRUCT2( INDEX_DrvEscape,            (PFN)DrvEscape            ),
        DC_STRUCT2( INDEX_DrvDitherColor,       (PFN)DrvDitherColor       ),

        // TS-specfic entry points.
        DC_STRUCT2( INDEX_DrvConnect,           (PFN)DrvConnect           ),
        DC_STRUCT2( INDEX_DrvDisconnect,        (PFN)DrvDisconnect        ),
        DC_STRUCT2( INDEX_DrvReconnect,         (PFN)DrvReconnect         ),
        DC_STRUCT2( INDEX_DrvShadowConnect,     (PFN)DrvShadowConnect     ),
        DC_STRUCT2( INDEX_DrvShadowDisconnect,  (PFN)DrvShadowDisconnect  ),
        DC_STRUCT2( INDEX_DrvMovePointerEx,     (PFN)DrvMovePointerEx     ),

        // For Direct Draw.
        DC_STRUCT2( INDEX_DrvGetDirectDrawInfo,	(PFN) DrvGetDirectDrawInfo),
        DC_STRUCT2( INDEX_DrvEnableDirectDraw,	(PFN) DrvEnableDirectDraw ),
        DC_STRUCT2( INDEX_DrvDisableDirectDraw,	(PFN) DrvDisableDirectDraw)
    )
);
#endif // DRAW_NINEGRID
#endif // DRAW_GDIPLUS

/****************************************************************************/
/* Global Table defining the 20 Windows default colours.  For 256 colour    */
/* palettes the first 10 must be put at the beginning of the palette and    */
/* the last 10 at the end of the palette.                                   */
/****************************************************************************/
DC_CONST_DATA_ARRAY(PALETTEENTRY, ddDefaultPalette, 20,
    DC_STRUCT20(
        DC_STRUCT4( 0,   0,   0,   0 ),       /* 0 */
        DC_STRUCT4( 0x80,0,   0,   0 ),       /* 1 */
        DC_STRUCT4( 0,   0x80,0,   0 ),       /* 2 */
        DC_STRUCT4( 0x80,0x80,0,   0 ),       /* 3 */
        DC_STRUCT4( 0,   0,   0x80,0 ),       /* 4 */
        DC_STRUCT4( 0x80,0,   0x80,0 ),       /* 5 */
        DC_STRUCT4( 0,   0x80,0x80,0 ),       /* 6 */
        DC_STRUCT4( 0xC0,0xC0,0xC0,0 ),       /* 7 */
        DC_STRUCT4( 192, 220, 192, 0 ),       /* 8 */
        DC_STRUCT4( 166, 202, 240, 0 ),       /* 9 */
        DC_STRUCT4( 255, 251, 240, 0 ),       /* 10 */
        DC_STRUCT4( 160, 160, 164, 0 ),       /* 11 */
        DC_STRUCT4( 0x80,0x80,0x80,0 ),       /* 12 */
        DC_STRUCT4( 0xFF,0,   0   ,0 ),       /* 13 */
        DC_STRUCT4( 0,   0xFF,0   ,0 ),       /* 14 */
        DC_STRUCT4( 0xFF,0xFF,0   ,0 ),       /* 15 */
        DC_STRUCT4( 0   ,0,   0xFF,0 ),       /* 16 */
        DC_STRUCT4( 0xFF,0,   0xFF,0 ),       /* 17 */
        DC_STRUCT4( 0,   0xFF,0xFF,0 ),       /* 18 */
        DC_STRUCT4( 0xFF,0xFF,0xFF,0 )        /* 19 */
));


/****************************************************************************/
/* Global Table defining the 16 Windows default VGA colours.                */
/****************************************************************************/
DC_CONST_DATA_ARRAY(PALETTEENTRY, ddDefaultVgaPalette, 16,
    DC_STRUCT16(
        DC_STRUCT4( 0,   0,   0,   0 ),       /* 0 */
        DC_STRUCT4( 0x80,0,   0,   0 ),       /* 1 */
        DC_STRUCT4( 0,   0x80,0,   0 ),       /* 2 */
        DC_STRUCT4( 0x80,0x80,0,   0 ),       /* 3 */
        DC_STRUCT4( 0,   0,   0x80,0 ),       /* 4 */
        DC_STRUCT4( 0x80,0,   0x80,0 ),       /* 5 */
        DC_STRUCT4( 0,   0x80,0x80,0 ),       /* 6 */
        DC_STRUCT4( 0x80,0x80,0x80,0 ),       /* 7 */
        DC_STRUCT4( 0xC0,0xC0,0xC0,0 ),       /* 8 */
        DC_STRUCT4( 0xFF,0,   0,   0 ),       /* 9 */
        DC_STRUCT4( 0,   0xFF,0,   0 ),       /* 10 */
        DC_STRUCT4( 0xFF,0xFF,0,   0 ),       /* 11 */
        DC_STRUCT4( 0,   0,   0xFF,0 ),       /* 12 */
        DC_STRUCT4( 0xFF,0,   0xFF,0 ),       /* 13 */
        DC_STRUCT4( 0,   0xFF,0xFF,0 ),       /* 14 */
        DC_STRUCT4( 0xFF,0xFF,0xFF,0 )        /* 15 */
));


/****************************************************************************/
/* ddDefaultGdi                                                             */
/*                                                                          */
/* This contains the default GDIINFO fields that are passed back to GDI     */
/* during DrvEnablePDEV.                                                    */
/*                                                                          */
/* NOTE: This structure defaults to values for an 8bpp palette device.      */
/*       Some fields are overwritten for different colour depths.           */
/*                                                                          */
/*       It is expected that DDML ignores a lot of these parameters and     */
/*       uses the values from the primary driver instead                    */
/****************************************************************************/
DC_CONST_DATA(GDIINFO, ddDefaultGdi,
DC_STRUCT35(
    GDI_DRIVER_VERSION,
    DT_RASDISPLAY,          /* ulTechnology                                 */
    320,                    /* ulHorzSize (display width: mm)               */
    240,                    /* ulVertSize (display height: mm)              */

    0,                      /* ulHorzRes (filled in later)                  */
    0,                      /* ulVertRes (filled in later)                  */
    0,                      /* cBitsPixel (filled in later)                 */
    0,                      /* cPlanes (filled in later)                    */
    20,                     /* ulNumColors (palette managed)                */
    0,                      /* flRaster (DDI reserved field)                */

    0,                      /* ulLogPixelsX (filled in later)               */
    0,                      /* ulLogPixelsY (filled in later)               */

    TC_RA_ABLE,             /* flTextCaps - If we had wanted console windows*/

                            /* to scroll by repainting the entire window,   */
                            /* instead of doing a screen-to-screen blt, we  */
                            /* would have set TC_SCROLLBLT (yes, the flag   */
                            /* is backwards).                               */

    0,                      /* ulDACRed (filled in later)                   */
    0,                      /* ulDACGreen (filled in later)                 */
    0,                      /* ulDACBlue (filled in later)                  */

    0x24,                   /* ulAspectX                                    */
    0x24,                   /* ulAspectY                                    */
    0x33,                   /* ulAspectXY (one-to-one aspect ratio)         */

    1,                      /* xStyleStep                                   */
    1,                      /* yStyleStep                                   */
    3,                      /* denStyleStep -- Styles have a one-to-one     */

                            /* aspect ratio, and every dot is 3 pixels long */

    DC_STRUCT2( 0, 0 ),     /* ptlPhysOffset                                */
    DC_STRUCT2( 0, 0 ),     /* szlPhysSize                                  */

    256,                    /* ulNumPalReg                                  */

    DC_STRUCT16(            /* ciDevice                                     */
       DC_STRUCT3( 6700, 3300, 0 ),   /*      Red                           */
       DC_STRUCT3( 2100, 7100, 0 ),   /*      Green                         */
       DC_STRUCT3( 1400,  800, 0 ),   /*      Blue                          */
       DC_STRUCT3( 1750, 3950, 0 ),   /*      Cyan                          */
       DC_STRUCT3( 4050, 2050, 0 ),   /*      Magenta                       */
       DC_STRUCT3( 4400, 5200, 0 ),   /*      Yellow                        */
       DC_STRUCT3( 3127, 3290, 0 ),   /*      AlignmentWhite                */
       20000,               /*      RedGamma                                */
       20000,               /*      GreenGamma                              */
       20000,               /*      BlueGamma                               */
       0, 0, 0, 0, 0, 0     /*      No dye correction for raster displays   */
    ),

    0,                       /* ulDevicePelsDPI (for printers only)         */
    PRIMARY_ORDER_CBA,       /* ulPrimaryOrder                              */
    HT_PATSIZE_4x4_M,        /* ulHTPatternSize                             */
    HT_FORMAT_8BPP,          /* ulHTOutputFormat                            */
    HT_FLAG_ADDITIVE_PRIMS,  /* flHTFlags                                   */
    0,                       /* ulVRefresh                                  */
    1,                       /* ulBltAlignment                              */
    800,                     /* ulPanningHorzRes                            */
    600                      /* ulPanningVertRes                            */

    /*                                                                      */
    /* NOTE:                                                                */
    /* NT 5 has added these fields post SP-3, if we care                    */
    /*                                                                      */
    /* 0,                       /* xPanningAlignment                        */
    /* 0,                       /* yPanningAlignment                        */
    /*                                                                      */
));


/****************************************************************************/
/* ddDefaultDevInfo                                                         */
/*                                                                          */
/* This contains the default DEVINFO fields that are passed back to GDI     */
/* during DrvEnablePDEV.                                                    */
/*                                                                          */
/* NOTE: This structure defaults to values for an 8bpp palette device.      */
/*       Some fields are overwritten for different colour depths.           */
/****************************************************************************/
#ifdef DRAW_NINEGRID
DC_CONST_DATA(DEVINFO, ddDefaultDevInfo,
DC_STRUCT10(
    DC_STRUCT1(
        GCAPS_OPAQUERECT       |
        GCAPS_PALMANAGED       |
        GCAPS_COLOR_DITHER     |
        GCAPS_MONO_DITHER      |
        GCAPS_ALTERNATEFILL    |
        GCAPS_WINDINGFILL
    ),                          /* NOTE: Only enable ASYNCMOVE if your code */
                                /*   and hardware can handle DrvMovePointer */
                                /*   calls at any time, even while another  */
                                /*   thread is in the middle of a drawing   */
                                /*   call such as DrvBitBlt.                */
                                /* flGraphicsFlags                          */

    DC_STRUCT14(
     16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,
     CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,
     VARIABLE_PITCH | FF_DONTCARE,L"System"),
                                /* lfDefaultFont                            */

    DC_STRUCT14(
     12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,
     CLIP_STROKE_PRECIS,PROOF_QUALITY,
     VARIABLE_PITCH | FF_DONTCARE,L"MS Sans Serif"),
                                /* lfAnsiVarFont                            */

    DC_STRUCT14(
     12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,
     CLIP_STROKE_PRECIS,PROOF_QUALITY,
     FIXED_PITCH | FF_DONTCARE, L"Courier"),
                                /* lfAnsiFixFont                            */

    0,                          /* cFonts                                   */
    BMF_8BPP,                   /* iDitherFormat                            */
    8,                          /* cxDither                                 */
    8,                          /* cyDither                                 */
    0,                          /* hpalDefault (filled in later)            */
    GCAPS2_REMOTEDRIVER         /* this is to advertise as remote driver    */
) );
#else
DC_CONST_DATA(DEVINFO, ddDefaultDevInfo,
DC_STRUCT9(
    DC_STRUCT1(
        GCAPS_OPAQUERECT       |
        GCAPS_PALMANAGED       |
        GCAPS_COLOR_DITHER     |
        GCAPS_MONO_DITHER      |
        GCAPS_ALTERNATEFILL    |
        GCAPS_WINDINGFILL
    ),                          /* NOTE: Only enable ASYNCMOVE if your code */
                                /*   and hardware can handle DrvMovePointer */
                                /*   calls at any time, even while another  */
                                /*   thread is in the middle of a drawing   */
                                /*   call such as DrvBitBlt.                */
                                /* flGraphicsFlags                          */

    DC_STRUCT14(
     16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,
     CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,
     VARIABLE_PITCH | FF_DONTCARE,L"System"),
                                /* lfDefaultFont                            */

    DC_STRUCT14(
     12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,
     CLIP_STROKE_PRECIS,PROOF_QUALITY,
     VARIABLE_PITCH | FF_DONTCARE,L"MS Sans Serif"),
                                /* lfAnsiVarFont                            */

    DC_STRUCT14(
     12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,
     CLIP_STROKE_PRECIS,PROOF_QUALITY,
     FIXED_PITCH | FF_DONTCARE, L"Courier"),
                                /* lfAnsiFixFont                            */

    0,                          /* cFonts                                   */
    BMF_8BPP,                   /* iDitherFormat                            */
    8,                          /* cxDither                                 */
    8,                          /* cyDither                                 */
    0                           /* hpalDefault (filled in later)            */
) );

#endif

// Flag for DDInit to set when it initializes correctly.
DC_DATA(BOOL, ddInitialised, FALSE);

// Flag to tell DrvEnableSurface that it's time to initialize.
DC_DATA(BOOL, ddInitPending, FALSE);

// Connection and reconnection flags. ddConnected is used to alter the
// behavior of the DD depending on whether we've been connected according to
// Win32K. Both are useful for debugging.
DC_DATA(BOOL, ddConnected, FALSE);
DC_DATA(BOOL, ddReconnected, FALSE);

// Flag to specify whether we're connected to a console.
DC_DATA(BOOL, ddConsole, FALSE);

// Temporary flag to aid in limiting the number of shadows per session to two
// It should go away when n-way shadowing is supported.
// TODO: Remove this when no longer needed.
DC_DATA(BOOL, ddIgnoreShadowDisconnect, FALSE);

// Pointer to the Shared Memory.
DC_DATA(PSHM_SHARED_MEMORY, pddShm, NULL);

// Handle to timer object for signalling the WD.
DC_DATA(PKTIMER, pddWdTimer, NULL);

// Handle to the WD channel - provided on DrvConnect.
DC_DATA(HANDLE, ddWdHandle, NULL);

// TSWDs - for diagnostic purposes.
DC_DATA(PVOID, pddTSWd, NULL);
DC_DATA(PVOID, pddTSWdShadow, NULL);

// Size of the current session's desktop.
DC_DATA(INT32, ddDesktopHeight, 0);
DC_DATA(INT32, ddDesktopWidth, 0);

// The cursor stamp the last time we IOCtl'd into the WD.
DC_DATA(UINT32, ddLastSentCursorStamp, 0);

// Current scheduler mode.
DC_DATA(UINT32, ddSchCurrentMode, SCH_MODE_ASLEEP);
DC_DATA(BOOL, ddSchInputKickMode, FALSE);

// Frame Buffer.
DC_DATA(BYTE *, pddFrameBuf, NULL);
DC_DATA(INT32, ddFrameBufX, 0);
DC_DATA(INT32, ddFrameBufY, 0);
DC_DATA(INT32, ddFrameBufBpp, 0);
DC_DATA(UINT32, ddFrameIFormat, 0);

// Section object for the frame buffer
DC_DATA(HANDLE, ddSectionObject, NULL);

// Record rectangle passed by DdLock
DC_DATA(INT32, ddLockAreaLeft, 0);
DC_DATA(INT32, ddLockAreaRight, 0);
DC_DATA(INT32, ddLockAreaTop, 0);
DC_DATA(INT32, ddLockAreaBottom, 0);

// Flag to record if DdLock/DdUnlock is called in pair
DC_DATA(BOOL, ddLocked, FALSE);

// Performance counters
DC_DATA(PTHINWIRECACHE, pddCacheStats, NULL);
#ifdef DC_COUNTERS
DC_DATA(PPROTOCOLSTATUS, pddProtStats, NULL);
#endif

#ifdef DC_DEBUG
#include "dbg_fncall_hist.h"

// NT BUG 539912 - track how many sections are allocated and how many are
// deleted
// This is a signed value to track possible excess deletion
DC_DATA(INT32, dbg_ddSectionAllocs, 0);
DC_DATA(BYTE,  dbg_ddFnCallHistoryIndex, 0);
DC_DATA(BYTE,  dbg_ddFnCallHistoryIndexMAX, DBG_DD_FNCALL_HIST_MAX);
DC_DATA_ARRAY(DBG_DD_FUNCALL_HISTORY, dbg_ddFnCallHistory, DBG_DD_FNCALL_HIST_MAX, 0);
#endif // DC_DEBUG

/****************************************************************************/
/* Flag to tell debugger extensions whether this is a debug build           */
/****************************************************************************/
#ifdef DC_DEBUG
DC_DATA(BOOL, ddDebug, TRUE);
#else
DC_DATA(BOOL, ddDebug, FALSE);
#endif

#ifdef DC_DEBUG
/****************************************************************************/
/* Trace data (explicitly initialized in DrvEnableDriver)                   */
/****************************************************************************/
DC_DATA(unsigned, ddTrcType, 0);
DC_DATA(BOOL, ddTrcToWD, 0);

/****************************************************************************/
/* State data for debugging                                                 */
/****************************************************************************/
#define DD_SET_STATE(a) ddState = a
#define DD_UPD_STATE(a) ddState |= a
#define DD_CLR_STATE(a) ddState &= ~a

#define DD_ENABLE_DRIVER            0x00000001
#define DD_CONNECT                  0x00000002
#define DD_RECONNECT_IN             0x00000004
#define DD_RECONNECT_OUT            0x00000008
#define DD_ENABLE_PDEV              0x00000010
#define DD_ENABLE_PDEV_ERR          0x00000020
#define DD_COMPLETE_PDEV            0x00000040
#define DD_ENABLE_SURFACE_IN        0x00000080
#define DD_ENABLE_SURFACE_OUT       0x00000100
#define DD_ENABLE_SURFACE_ERR       0x00000200
#define DD_INIT_IN                  0x00000400
#define DD_INIT_OUT                 0x00000800
#define DD_INIT_FAIL1               0x00001000
#define DD_INIT_FAIL2               0x00002000
#define DD_INIT_OK1                 0x00004000
#define DD_INIT_OK_ALL              0x00008000
#define DD_INIT_IOCTL_IN            0x00010000
#define DD_INIT_IOCTL_OUT           0x00020000
#define DD_INIT_SHM_OUT             0x00040000
#define DD_INIT_CONNECT             0x00080000
#define DD_REINIT                   0x00100000
#define DD_DISCONNECT_IN            0x00200000
#define DD_DISCONNECT_OUT           0x00400000
#define DD_DISCONNECT_ERR           0x00800000
#define DD_TIMEROBJ                 0x01000000
#define DD_WAS_DISCONNECTED         0x02000000
#define DD_SHADOW_SETUP             0x04000000
#define DD_SHADOW_FAIL              0x08000000

#define DD_BITBLT                   0x80000000

DC_DATA(unsigned, ddState, 0);


// Trace string.
DC_DATA_ARRAY(char, ddTraceString, TRC_BUFFER_SIZE, 0);

#else
#define DD_SET_STATE(a)
#define DD_UPD_STATE(a)
#define DD_CLR_STATE(a)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpdd\noadisp.c ===
/****************************************************************************/
// noadisp.c
//
// RDP Order Accumulation code
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <precmpdd.h>
#define hdrstop

#define TRC_FILE "noadisp"
#define TRC_GROUP TRC_GROUP_DCSHARE
#include <adcg.h>
#include <adcs.h>

#define DC_INCLUDE_DATA
#include <ndddata.c>
#undef DC_INCLUDE_DATA

#include <noadisp.h>

#include <nprcount.h>

// No data, don't waste time including the file.
//#include <noadata.c>

#include <nschdisp.h>

// Common functions.
#include <aoacom.c>


/****************************************************************************/
// OA_DDInit
/****************************************************************************/
void RDPCALL OA_DDInit()
{
    DC_BEGIN_FN("OA_DDInit");

// Don't waste time including the nonexistent data.
//#define DC_INIT_DATA
//#include <noadata.c>
//#undef DC_INIT_DATA

    DC_END_FN();
}


/****************************************************************************/
// OA_InitShm
/****************************************************************************/
void RDPCALL OA_InitShm(void)
{
    DC_BEGIN_FN("OA_InitShm");

    // Init OA shm variables that need it. Be sure not to init the
    // order heap itself.
    OA_ResetOrderList();

    DC_END_FN();
}


/****************************************************************************/
// OA_AllocOrderMem
//
// Allocates order heap memory. Returns a pointer to the heap block.
/****************************************************************************/
PINT_ORDER RDPCALL OA_AllocOrderMem(PDD_PDEV ppdev, unsigned OrderDataLength)
{
    unsigned Size;
    PINT_ORDER pOrder;

    DC_BEGIN_FN("OA_AllocOrderMem");

    // Round up the total allocation to the nearest 4 bytes to keep the 4 byte
    // alignment within the heap.
    Size = sizeof(INT_ORDER) + OrderDataLength;
    Size = (Size + sizeof(PVOID) - 1) & ~(sizeof(PVOID)-1);

    // If we don't have enough heap space, flush and check again.
    // Not being able to flush simply means the network is backed up,
    // callers should be able to handle this.
    if ((pddShm->oa.nextOrder + Size) >= OA_ORDER_HEAP_SIZE)
        SCH_DDOutputAvailable(ppdev, TRUE);
    if ((pddShm->oa.nextOrder + Size) < OA_ORDER_HEAP_SIZE) {
        TRC_ASSERT((pddShm->oa.nextOrder == (pddShm->oa.nextOrder & ~(sizeof(PVOID)-1))),
                (TB,"oa.nextOrder %u is not DWORD_PTR-aligned",
                pddShm->oa.nextOrder));

        // Init the header.
        pOrder = (INT_ORDER *)(pddShm->oa.orderHeap + pddShm->oa.nextOrder);
        pOrder->OrderLength = OrderDataLength;

        // Add to the end of the order list.
        InsertTailList(&pddShm->oa.orderListHead, &pOrder->list);

        // Update the end-of-heap pointer to point to the next section of
        // free heap.
        pddShm->oa.nextOrder += Size;

        TRC_DBG((TB, "Alloc order, addr %p, size %u", pOrder,
                OrderDataLength));
    }
    else {
        TRC_ALT((TB, "Heap limit hit"));
        pOrder = NULL;
    }

    DC_END_FN();
    return pOrder;
}


/****************************************************************************/
// OA_FreeOrderMem
//
// Frees order memory allocated by OA_AllocOrderMem().
/****************************************************************************/
void RDPCALL OA_FreeOrderMem(PINT_ORDER pOrder)
{
    PINT_ORDER pOrderTail;

    DC_BEGIN_FN("OA_FreeOrderMem");

    TRC_DBG((TB, "Free order %p", pOrder));

    // Check for freeing the last item in the list.
    if ((&pOrder->list) == pddShm->oa.orderListHead.Blink) {
        // This is the last item in the heap, so we can set the marker for
        // the next order memory to be used back to the start of the order
        // being freed.
        pddShm->oa.nextOrder = (UINT32)((BYTE *)pOrder - pddShm->oa.orderHeap);
    }

    // Remove the item from the chain.
    RemoveEntryList(&pOrder->list);

    DC_END_FN();
}

/****************************************************************************/
// OA_AppendToOrderList
//
// Finalizes the heap addition of an order, without doing extra processing, 
// by adding the final order size to the total size of ready-to-send orders
// in the heap.
/****************************************************************************/
void OA_AppendToOrderList(PINT_ORDER _pOrder)
{  
    unsigned i, j;
    PINT_ORDER pPrevOrder;

    DC_BEGIN_FN("OA_AppendToOrderList");

    pddShm->oa.TotalOrderBytes += (_pOrder)->OrderLength;  
    
#if DC_DEBUG
    // Add checksum for order  
    _pOrder->CheckSum = 0;
    for (i = 0; i < _pOrder->OrderLength; i++) {
        _pOrder->CheckSum += _pOrder->OrderData[i];
    }
#endif
    
#if DC_DEBUG    
    // Check past 3 orders
    pPrevOrder = (PINT_ORDER)_pOrder;
    for (j = 0; j < 3; j++) {
        unsigned sum = 0;

        if (pPrevOrder->list.Blink != &_pShm->oa.orderListHead) {
            pPrevOrder = CONTAINING_RECORD(pPrevOrder->list.Blink,
                    INT_ORDER, list);
            
            for (i = 0; i < pPrevOrder->OrderLength; i++) {
                sum += pPrevOrder->OrderData[i];
            }
            

            if (pPrevOrder->CheckSum != sum) {
                TRC_ASSERT((FALSE), (TB, "order heap corruption: %p", pPrevOrder));
            }
        }
        else {
            break;
        }
    }
#endif

    TRC_ASSERT(((BYTE *)(_pOrder) - pddShm->oa.orderHeap +  
            ((_pOrder)->OrderLength) <=  
            pddShm->oa.nextOrder),(TB,"OA_Append: Order is too long "  
            "for heap allocation size: OrdLen=%u, Start=%u, NextOrd=%u",  
            (_pOrder)->OrderLength, (BYTE *)(_pOrder) - pddShm->oa.orderHeap,  
            pddShm->oa.nextOrder));  

    TRC_DBG((TB,"OA_Append: Appending %u bytes at %p",  
            (_pOrder)->OrderLength, (_pOrder)));  

    INC_INCOUNTER(IN_SND_TOTAL_ORDER);  
    ADD_INCOUNTER(IN_SND_ORDER_BYTES, (_pOrder)->OrderLength);  

    DC_END_FN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpdd\noadisp.h ===
/****************************************************************************/
// noadisp.h
//
// DD-specific header for OA
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/
#ifndef __OADISP_H
#define __OADISP_H

#include <aoaapi.h>
#include <aoacom.h>
#include <nddapi.h>


void RDPCALL OA_DDInit();

void RDPCALL OA_InitShm(void);

void OA_AppendToOrderList(PINT_ORDER);

PINT_ORDER RDPCALL OA_AllocOrderMem(PDD_PDEV, unsigned);

void RDPCALL OA_FreeOrderMem(PINT_ORDER);


/****************************************************************************/
// OA_DDSyncUpdatesNow
//
// Called when a sync operation is required.
/****************************************************************************/
__inline void OA_DDSyncUpdatesNow()
{
    // Discard all outstanding orders.
    OA_ResetOrderList();
}


/****************************************************************************/
// OA_AppendToOrderList
//
// Finalizes the heap addition of an order, without doing extra processing, 
// by adding the final order size to the total size of ready-to-send orders
// in the heap.
/****************************************************************************/
void OA_AppendToOrderList(PINT_ORDER _pOrder);


/****************************************************************************/
// OA_TruncateAllocatedOrder
//
// Returns heap space at the end of the heap allocated via OA_AllocOrderMem.
// Requires a bit more housekeeping than returning additional order mem.
// The caller should be sure that no other orders or additional order mem
// has been allocated after this order. NewSize is the final size
// of the order.
//
// __inline void OA_TruncateAllocatedOrder(
//         INT_ORDER *pOrder,
//         unsigned NewSize)
/****************************************************************************/
#define OA_TruncateAllocatedOrder(_pOrder, _NewSize)  \
{  \
    unsigned SizeToRemove = (_pOrder)->OrderLength - (_NewSize);  \
\
    /* Update the next order location, rounding up to the next higher DWORD */  \
    /* boundary by rounding down the difference in the old and new sizes.   */  \
    pddShm->oa.nextOrder -= (SizeToRemove & ~(sizeof(PVOID)-1));  \
\
    (_pOrder)->OrderLength = (_NewSize);  \
}



#endif  // __OADISP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpdd\noadata.c ===
/****************************************************************************/
// noadata.c
//
// Order Accumulation data in the DD.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

//#include <ndcgdata.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpdd\noeapi.c ===
/****************************************************************************/
// noeapi.c
//
// RDP Order Encoder functions
//
// Copyright (C) 1996-2000 Microsoft Corporation
/****************************************************************************/

#include <precmpdd.h>
#pragma hdrstop

#define TRC_FILE "noeapi"
#include <adcg.h>
#include <atrcapi.h>

#include <nshmapi.h>
#include <tsrvexp.h>
#include <nschdisp.h>
#include <noadisp.h>
#include <nsbcdisp.h>
#include <nprcount.h>
#include <noedisp.h>
#include <oe2.h>

#define DC_INCLUDE_DATA
#include <ndddata.c>
#include <noedata.c>
#include <nsbcddat.c>
#include <oe2data.c>
#undef DC_INCLUDE_DATA

#include <nbadisp.h>
#include <nbainl.h>

#include <noeinl.h>
#include <nsbcinl.h>
#include <nchdisp.h>

#include <tsgdiplusenums.h>

/****************************************************************************/
// OE_InitShm
//
// Alloc-time SHM init.
/****************************************************************************/
void OE_InitShm(void)
{
    DC_BEGIN_FN("OE_InitShm");

    memset(&pddShm->oe, 0, sizeof(OE_SHARED_DATA));

    DC_END_FN();
}

/****************************************************************************/
// OE_Reset
//
// Reset oe components as necessary
/****************************************************************************/
void OE_Reset(void)
{
    DC_BEGIN_FN("OE_Reset");

    oeLastDstSurface = 0;

    DC_END_FN();
}

/****************************************************************************/
// OE_Update
//
// Called when the share is reset on logon or reconnect.
// Sets new capabilities.
/****************************************************************************/
void RDPCALL OE_Update()
{
    if (pddShm->oe.newCapsData) {
        oeSendSolidPatternBrushOnly = pddShm->oe.sendSolidPatternBrushOnly;
        oeColorIndexSupported = pddShm->oe.colorIndices;

        // The share core has passed down a pointer to its copy of the order
        // support array. We take a copy for the kernel here.
        memcpy(&oeOrderSupported, pddShm->oe.orderSupported,
                sizeof(oeOrderSupported));

        pddShm->oe.newCapsData = FALSE;
    }

    DC_END_FN();
}


/****************************************************************************/
// OE_ClearOrderEncoding
//
// Called on a share state toggle to clear the order encoding states held
// in the DD data segment.
/****************************************************************************/
void OE_ClearOrderEncoding()
{
    DC_BEGIN_FN("OE_ClearOrderEncoding");

    memset(&PrevMemBlt, 0, sizeof(PrevMemBlt));
    memset(&PrevMem3Blt, 0, sizeof(PrevMem3Blt));
    memset(&PrevDstBlt, 0, sizeof(PrevDstBlt));
    memset(&PrevMultiDstBlt, 0, sizeof(PrevMultiDstBlt));
    memset(&PrevPatBlt, 0, sizeof(PrevPatBlt));
    memset(&PrevMultiPatBlt, 0, sizeof(PrevMultiPatBlt));
    memset(&PrevScrBlt, 0, sizeof(PrevScrBlt));
    memset(&PrevMultiScrBlt, 0, sizeof(PrevMultiScrBlt));
    memset(&PrevOpaqueRect, 0, sizeof(PrevOpaqueRect));
    memset(&PrevMultiOpaqueRect, 0, sizeof(PrevMultiOpaqueRect));

    memset(&PrevLineTo, 0, sizeof(PrevLineTo));
    memset(&PrevPolyLine, 0, sizeof(PrevPolyLine));
    memset(&PrevPolygonSC, 0, sizeof(PrevPolygonSC));
    memset(&PrevPolygonCB, 0, sizeof(PrevPolygonCB));
    memset(&PrevEllipseSC, 0, sizeof(PrevEllipseSC));
    memset(&PrevEllipseCB, 0, sizeof(PrevEllipseCB));

    memset(&PrevFastIndex, 0, sizeof(PrevFastIndex));
    memset(&PrevFastGlyph, 0, sizeof(PrevFastGlyph));
    memset(&PrevGlyphIndex, 0, sizeof(PrevGlyphIndex));

#ifdef DRAW_NINEGRID
    memset(&PrevDrawNineGrid, 0, sizeof(PrevDrawNineGrid));
    memset(&PrevMultiDrawNineGrid, 0, sizeof(PrevMultiDrawNineGrid));
#endif

    DC_END_FN();
}


/****************************************************************************/
/* OE_SendGlyphs - Send text glyphs to the client                           */
/****************************************************************************/
BOOL RDPCALL OE_SendGlyphs(
        SURFOBJ *pso,
        STROBJ *pstro,
        FONTOBJ *pfo,
        OE_ENUMRECTS *pClipRects,
        RECTL *prclOpaque,
        BRUSHOBJ *pboFore,
        BRUSHOBJ *pboOpaque,
        POINTL *pptlOrg,
        PFONTCACHEINFO pfci)
{
    BOOL rc;
    GLYPHCONTEXT glc;
    POE_BRUSH_DATA pbdOpaque;
    PDD_PDEV ppdev;

    DC_BEGIN_FN("OE_SendGlyphs");

    rc = FALSE;

    // Rasterized fonts are bitmaps - others are PATHOBJ structures.
    if (pfo->flFontType & RASTER_FONTTYPE) {
        ppdev = (PDD_PDEV)pso->dhpdev;
        pddCacheStats[GLYPH].CacheReads += pstro->cGlyphs;

        // Make sure we don't exceed our max glyph_out capacity.
        if (pstro->cGlyphs <= OE_GL_MAX_INDEX_ENTRIES) {
            // The system can only handle 'simple' brushes.
            if (OECheckBrushIsSimple(ppdev, pboOpaque, &pbdOpaque)) {
                // Get the text fore color.
                OEConvertColor(ppdev, &pbdOpaque->back,
                        pboFore->iSolidColor, NULL);

                // Initialize our glyph context structure.
                glc.fontId = pfci->fontId;
                glc.cacheTag = oeTextOut++;

                glc.nCacheHit = 0;
                glc.nCacheIndex = 0;
                glc.indexNextSend = 0;
                glc.cbDataSize = 0;
                glc.cbTotalDataSize = 0;
                glc.cbBufferSize = 0;

                // Cache all glyphs for this message .
                if (OECacheGlyphs(pstro, pfo, pfci, &glc)) {
                    // Send all newly cached glyphs to the client.
                    // If this is single glyph and we support fast glyph order
                    // and the glyph data length can fit in one byte. We will
                    // send the glyph index and data in one order.  Note we
                    // can bypass fragment caching in this case since we don't
                    // cache fragment of length less than 3 glyphs.
                    if (OE_SendAsOrder(TS_ENC_FAST_GLYPH_ORDER) &&
                            (pstro->cGlyphs == 1) && (glc.cbTotalDataSize +
                            sizeof(UINT16)) <= FIELDSIZE(VARIABLE_GLYPHBYTES,
                            glyphData)) {
                        rc = OESendGlyphAndIndexOrder(ppdev, pstro,
                                pClipRects, prclOpaque, pbdOpaque,
                                pfci, &glc);
                    }
                    else {
                        if (OESendGlyphs(pso, pstro, pfo, pfci, &glc)) {
                            // Send glyph index orders to the client.
                            rc = OESendIndexes(pso, pstro, pfo, pClipRects,
                                    prclOpaque, pbdOpaque, pptlOrg, pfci,
                                    &glc);
                        }
                    }
                }
            }
        }
    }

    DC_END_FN();
    return rc;
}


/****************************************************************************/
// DrvBitBlt - see NT DDK documentation.
/****************************************************************************/
BOOL RDPCALL DrvBitBlt(
        SURFOBJ  *psoTrg,
        SURFOBJ  *psoSrc,
        SURFOBJ  *psoMask,
        CLIPOBJ  *pco,
        XLATEOBJ *pxlo,
        RECTL    *prclTrg,
        POINTL   *pptlSrc,
        POINTL   *pptlMask,
        BRUSHOBJ *pbo,
        POINTL   *pptlBrush,
        ROP4      rop4)
{
    PDD_PDEV  ppdev = (PDD_PDEV)psoTrg->dhpdev;
    PDD_DSURF pdsurfTrg = NULL;
    PDD_DSURF pdsurfSrc = NULL;
    SURFOBJ *psoSrcArg = NULL;
    SURFOBJ *psoTrgArg = NULL;
    BOOL rc;
    BYTE rop3;
    RECTL bounds;
    OE_ENUMRECTS ClipRects;

    DC_BEGIN_FN("DrvBitBlt");

    // Sometimes we're called after being disconnected.
    if (ddConnected && pddShm != NULL) {
        psoSrcArg = psoSrc;
        psoTrgArg = psoTrg;
        psoTrg = OEGetSurfObjBitmap(psoTrg, &pdsurfTrg);
        if (psoSrc != NULL)
            psoSrc = OEGetSurfObjBitmap(psoSrc, &pdsurfSrc);

        DD_UPD_STATE(DD_BITBLT);
        INC_OUTCOUNTER(OUT_BITBLT_ALL);

        if (((pco == NULL) && (psoTrg->sizlBitmap.cx >= prclTrg->right) &&
                (psoTrg->sizlBitmap.cy >= prclTrg->bottom)) ||
                ((pco != NULL) && (psoTrg->sizlBitmap.cx >= pco->rclBounds.right) &&
                (psoTrg->sizlBitmap.cy >= pco->rclBounds.bottom))) {
        
            // Punt the call back to GDI to do the drawing.
            rc = EngBitBlt(psoTrg, psoSrc, psoMask, pco, pxlo, prclTrg, pptlSrc,
                    pptlMask, pbo, pptlBrush, rop4);
        }
        else {
            // If the bounding rectangle is greater the frame buffer, something
            // is really wrong here.  This means the desktop surface size and
            // the framebuffer is not matched up.  We need to bail out here.
            rc = FALSE;
        }

        if (rc) {
            TRC_DBG((TB, "ppdev(%p) psoSrc(%p) psoTrg(%p)"
                            "s[sizl(%d,%d) format(%d) type(%d)]"
                            "d[sizl(%d,%d) format(%d) type(%d)]"
                            "src(%d,%d) dst(%d,%d,%d,%d), rop %#x",
                    ppdev, psoSrc, psoTrg,
                    (psoSrc != NULL) ? psoSrc->sizlBitmap.cx : -1,
                    (psoSrc != NULL) ? psoSrc->sizlBitmap.cy : -1,
                    (psoSrc != NULL) ? psoSrc->iBitmapFormat : -1,
                    (psoSrc != NULL) ? psoSrc->iType : -1,
                    (psoTrg != NULL) ? psoTrg->sizlBitmap.cx : -1,
                    (psoTrg != NULL) ? psoTrg->sizlBitmap.cy : -1,
                    (psoTrg != NULL) ? psoTrg->iBitmapFormat : -1,
                    (psoTrg != NULL) ? psoTrg->iType : -1,
                    (pptlSrc != NULL) ? pptlSrc->x : -1,
                    (pptlSrc != NULL) ? pptlSrc->y : -1,
                    prclTrg->left,
                    prclTrg->top,
                    prclTrg->right,
                    prclTrg->bottom,
                    rop4));

            // If ppdev is NULL then this is a blt to GDI managed memory bitmap, 
            // so there is no need to accumulate any output.
            if (ppdev != NULL) {
                // Get the bounding rectangle for the operation. According to
                // the DDK, this rectangle is always well-ordered and does not
                // need to be rearranged. Clip it to 16 bits.
                bounds = *prclTrg;
                OEClipRect(&bounds);

                // If this function is changed, need to know that psoTrg points
                // to the GDI DIB bitmap in offscreen bitmap case.
            }
            else {
                // if ppdev is NULL, we are blt to GDI managed bitmap,
                // so, the dhurf of the target surface should be NULL
                TRC_ASSERT((pdsurfTrg == NULL), 
                        (TB, "NULL ppdev - psoTrg has non NULL dhsurf"));

                TRC_NRM((TB, "NULL ppdev - blt to GDI managed bitmap"));
                DC_QUIT;
            }
        }
        else {
            TRC_ERR((TB, "EngBitBlt failed"));
            DC_QUIT;
        }
    }
    else {
        if (psoTrg->iType == STYPE_DEVBITMAP) {
        
            psoTrg = OEGetSurfObjBitmap(psoTrg, &pdsurfTrg);
            if (psoSrc != NULL)
                psoSrc = OEGetSurfObjBitmap(psoSrc, &pdsurfSrc);
    
            // Punt the call back to GDI to do the drawing.
            rc = EngBitBlt(psoTrg, psoSrc, psoMask, pco, pxlo, prclTrg, pptlSrc,
                    pptlMask, pbo, pptlBrush, rop4);
        }
        else {
            TRC_ERR((TB, "Called when disconnected"));
            rc = TRUE;
        }

        goto CalledOnDisconnected;
    }

    if ((psoTrg->hsurf == ppdev->hsurfFrameBuf) ||
            (!(pdsurfTrg->flags & DD_NO_OFFSCREEN))) {
        // Send a switch surface PDU if the destination surface is different
        // from last drawing order. If we failed to send the PDU, we will
        // just have to bail on this drawing order.
        if (!OESendSwitchSurfacePDU(ppdev, pdsurfTrg)) {
            TRC_ERR((TB, "failed to send the switch surface PDU"));
            DC_QUIT;
        }
    }
    else {
        // If noOffscreen flag is on, we will bail on sending 
        // the client any further offscreen rendering. And we'll send the
        // final offscreen to screen blt as regular memblt.
        TRC_NRM((TB, "Offscreen blt bail"));
        INC_OUTCOUNTER(OUT_BITBLT_NOOFFSCR);
        DC_QUIT;
    }

    // Check if this 4-way ROP simplifies to a 3-way ROP. A 4-way ROP
    // contains two 3-way ROPS, one for each setting of a mask bit - the
    // high ROP3 corresponds to a value of zero in the mask bit. If the two
    // 3-way ROPs are the same, we know the 4-way ROP is a 3-way ROP.
    rop3 = ROP3_HIGH_FROM_ROP4(rop4);
    if (ROP3_LOW_FROM_ROP4(rop4) == rop3) {
        // Take the high byte as the 3-way ROP.
        TRC_DBG((TB, "4-way ROP %04x is really 3-way %02x", rop4, rop3));

        // Check if we are allowed to send the ROP.
        if (OESendRop3AsOrder(rop3)) {
            unsigned RetVal;

            // Get the intersection between the dest rect and the
            // clip rects. Check for overcomplicated or nonintersecting
            // clipping.
            RetVal = OEGetIntersectingClipRects(pco, &bounds, CD_ANY,
                   &ClipRects);
            if (RetVal == CLIPRECTS_TOO_COMPLEX) {
                TRC_NRM((TB, "Clipping is too complex"));
                INC_OUTCOUNTER(OUT_BITBLT_SDA_COMPLEXCLIP);
                if (oeLastDstSurface == NULL)
                    ADD_INCOUNTER(IN_SDA_BITBLT_COMPLEXCLIP_AREA,
                            COM_SIZEOF_RECT(bounds));
                goto SendScreenData;
            }
            else if (RetVal == CLIPRECTS_NO_INTERSECTIONS) {
                TRC_NRM((TB, "Clipping does not intersect destrect"));
                DC_QUIT;
            }
#ifdef PERF_SPOILING
            else if (psoTrg->hsurf == ppdev->hsurfFrameBuf) {
                // This is the case where the bitblt lies completely within
                // the current screen-data dirty-rect, so we can just send
                // it as screendata.  (Actually, it's benign to goto
                // SendScreenData, since the new RECT will just be collapsed
                // into the current screen-data dirty-rects.)
                if (ClipRects.rects.c==0) {
                    if (OEIsSDAIncluded(&bounds, 1)) {
                        goto SendScreenData;
                    }
                } else {
                    if (OEIsSDAIncluded(&ClipRects.rects.arcl[0],
                                        ClipRects.rects.c)) {
                        goto SendScreenData;
                    }
                }
            }
#endif
        }
        else {
            TRC_NRM((TB, "Cannot send ROP %d", rop3));
            INC_OUTCOUNTER(OUT_BITBLT_SDA_NOROP3);
            if (oeLastDstSurface == NULL)
                ADD_INCOUNTER(IN_SDA_BITBLT_NOROP3_AREA,
                        COM_SIZEOF_RECT(bounds));
            goto SendScreenData;
        }
    }
    else {
        TRC_NRM((TB, "4-way ROP %08x", rop4));
        INC_OUTCOUNTER(OUT_BITBLT_SDA_ROP4);
        if (oeLastDstSurface == NULL)
            ADD_INCOUNTER(IN_SDA_BITBLT_ROP4_AREA, COM_SIZEOF_RECT(bounds));
        goto SendScreenData;
    }

    // Determine the blt type. It can be one of the following. Note that the
    // following if statements are carefully tuned based on the most common
    // blt types seen in WinStone/WinBench, to minimize mispredictions.
    // In order of frequency:
    //
    // OpaqueRect: A destination-only blt where the output bits are overlaid
    //             on the output screen and the pattern is a solid color.
    // PatBlt: An OpaqueRect with a non-solid-color pattern.
    // MemBlt: A memory-to-memory/screen blt with no pattern.
    // Mem3Blt: A memory-to-memory/screen blt with an accompanying pattern.
    // DstBlt: Destination-only blt; the output is dependent on the screen
    //         contents.
    // ScrBlt: A screen-to-screen blt (copy screen contents).

    // Check for destination only BLTs (ie. independent of source bits).
    if ((psoSrc == NULL) || ROP3_NO_SOURCE(rop3)) {
        // Check for a pattern or true destination BLT.
        if (!ROP3_NO_PATTERN(rop3)) {
            // Check whether we can encode the PatBlt as an OpaqueRect.
            // It must be solid with a PATCOPY rop.
            if (pbo->iSolidColor != -1 && rop3 == OE_PATCOPY_ROP) {
                if (!OEEncodeOpaqueRect(&bounds, pbo, ppdev, &ClipRects)) {
                    // Something went wrong with the encoding, so skip
                    // to the end to add this operation to the SDA.
                    if (oeLastDstSurface == NULL)
                        ADD_INCOUNTER(IN_SDA_OPAQUERECT_AREA,
                                COM_SIZEOF_RECT(bounds));
                    goto SendScreenData;
                }
            }
            else if (!OEEncodePatBlt(ppdev, pbo, &bounds, pptlBrush, rop3,
                    &ClipRects)) {
                // Something went wrong with the encoding, so skip to
                // the end to add this operation to the SDA.
                if (oeLastDstSurface == NULL)
                    ADD_INCOUNTER(IN_SDA_PATBLT_AREA,
                            COM_SIZEOF_RECT(bounds));
                goto SendScreenData;
            }
        }
        else {
            if (!OEEncodeDstBlt(&bounds, rop3, ppdev, &ClipRects)) {
                if (oeLastDstSurface == NULL)
                    ADD_INCOUNTER(IN_SDA_DSTBLT_AREA,
                            COM_SIZEOF_RECT(bounds));
                goto SendScreenData;
            }
        }
    }
    else {
        // We have a source BLT, check whether we have screen or memory BLTs.
        if (psoSrc->hsurf != ppdev->hsurfFrameBuf) {
            // The source surface is memory, so this is either memory to screen
            // blt or memory to offscreen blt
            if (psoTrg->hsurf == ppdev->hsurfFrameBuf || pdsurfTrg != NULL) {
                // We only support destination surface as the screen surface
                // or driver managed offscreen surface
                unsigned OffscrBitmapId = 0;
                MEMBLT_ORDER_EXTRA_INFO MemBltExtraInfo;

                // Fill in extra info structure.
                MemBltExtraInfo.pSource = psoSrc;
                MemBltExtraInfo.pDest = psoTrg;
                MemBltExtraInfo.pXlateObj = pxlo;
                MemBltExtraInfo.bNoFastPathCaching = FALSE;
                MemBltExtraInfo.iDeviceUniq = psoSrcArg ? (psoSrcArg->iUniq) : 0;
#ifdef PERF_SPOILING
                MemBltExtraInfo.bIsPrimarySurface = (psoTrg->hsurf == ppdev->hsurfFrameBuf);
#endif

                if (pdsurfSrc != NULL &&
                        (psoTrg->hsurf == ppdev->hsurfFrameBuf ||
                        pdsurfSrc == pdsurfTrg)) {
                    if ((pddShm->sbc.offscreenCacheInfo.supportLevel > TS_OFFSCREEN_DEFAULT) &&
                        (sbcEnabled & SBC_OFFSCREEN_CACHE_ENABLED)) {

                        if (pdsurfSrc->shareId == pddShm->shareId) {
                        
                            // We are blting from an offscreen surface to client screen,
                            // Or from one area of an offscreen to another area of the 
                            // same offscreen bitmap
                            if (!(pdsurfSrc->flags & DD_NO_OFFSCREEN)) {
                                OffscrBitmapId = pdsurfSrc->bitmapId;
                                CH_TouchCacheEntry(sbcOffscreenBitmapCacheHandle,
                                        OffscrBitmapId);
                            }
                            else {
                                // If the source surface is offscreen surface, and we
                                // have the noOffscreen flag on, this means we will 
                                // send the bitmap bits as regular memory bitmap bits
                                // This means that the offscreen bitmap has been evicted
                                // out of the offscreen cache or screen data needs to be 
                                // sent for the offscreen bitmap
                                TRC_ALT((TB, "noOffscreen flag is on for %p", pdsurfSrc));
                                OffscrBitmapId = CH_KEY_UNCACHABLE;
                            }
                        }
                        else {
                            //  This is the stale offscreen bitmap from last disconnected
                            //  session.  We need to turn off the offscreen flag on this
                            TRC_ALT((TB, "Need to turn off this offscreen bitmap"));
                            pdsurfSrc->flags |= DD_NO_OFFSCREEN;
                            OffscrBitmapId = CH_KEY_UNCACHABLE;
                        }
                    }
                    else {
                        // These are offscreen bitmaps from the disconnected session
                        // or client has sent an error pdu,
                        // We have to treat them as memory bitmap now since the client
                        // doesn't have the offscreen bitmap locally
                        TRC_ALT((TB, "Need to turn off this offscreen bitmap"));
                        pdsurfSrc->flags |= DD_NO_OFFSCREEN;
                        OffscrBitmapId = CH_KEY_UNCACHABLE;
                    }
                }
                else {
                    OffscrBitmapId = CH_KEY_UNCACHABLE;
                }

                // We send MemBlts for clients that allow offscreen rendering
                // or if iUniq is nonzero. Zero iUniq is supposed to be a GDI
                // hack in NT5 that tells us that Windows Layering for window
                // borders is being used. We would want to send screen data
                // for these cases to prevent flushing the bitmap cache.
                // Unfortunately, quite a few bitmaps seem to also have
                // iUniq==0, so for 5.1 clients using offscreen we save some
                // bandwidth instead of sending screen data. The Windows
                // Layering stuff uses offscreen rendering anyway...
                if (psoSrcArg->iUniq != 0) {
                    // We have a memory to screen BLT, check which type.
                    if (ROP3_NO_PATTERN(rop3)) {
                        // Make sure orders are not turned off.
                        if (OE_SendAsOrder(TS_ENC_MEMBLT_R2_ORDER)) {
                            if (!OEEncodeMemBlt(&bounds, &MemBltExtraInfo,
                                    TS_ENC_MEMBLT_R2_ORDER, OffscrBitmapId,
                                    rop3, pptlSrc, pptlBrush, pbo, ppdev,
                                    &ClipRects)) {
                                if (oeLastDstSurface == NULL)
                                    ADD_INCOUNTER(IN_SDA_MEMBLT_AREA,
                                            COM_SIZEOF_RECT(bounds));
                                goto SendScreenData;
                            }
                        }
                        else {
                            TRC_NRM((TB, "MemBlt order not allowed"));
                            INC_OUTCOUNTER(OUT_BITBLT_SDA_UNSUPPORTED);
                            goto SendScreenData;
                        }
                    }
                    else {
                        // Make sure orders are not turned off.
                        if (OE_SendAsOrder(TS_ENC_MEM3BLT_R2_ORDER)) {
                            if (!OEEncodeMemBlt(&bounds, &MemBltExtraInfo,
                                    TS_ENC_MEM3BLT_R2_ORDER, OffscrBitmapId,
                                    rop3, pptlSrc, pptlBrush, pbo, ppdev,
                                    &ClipRects)) {
                                if (oeLastDstSurface == NULL)
                                    ADD_INCOUNTER(IN_SDA_MEM3BLT_AREA,
                                            COM_SIZEOF_RECT(bounds));
                                goto SendScreenData;
                            }
                        }
                        else {
                            TRC_NRM((TB, "Mem3Blt order not allowed"));
                            INC_OUTCOUNTER(OUT_BITBLT_SDA_UNSUPPORTED);
                            goto SendScreenData;
                        }
                    }
                }
                else {
                    // To avoid Windows Layering Mem to Mem Blt flush bitmap caches
                    // on the client, we have to send it as screen data instead
                    TRC_NRM((TB, "Get a windows layering mem-mem blt, "
                            "send as screen data"));
                    INC_OUTCOUNTER(OUT_BITBLT_SDA_WINDOWSAYERING);
                    goto SendScreenData;
                }
            }
            else {
                TRC_ALT((TB, "Unsupported MEM to MEM blt!"));
                DC_QUIT;
            }
        }
        else {
            // The source surface is screen, so this is either screen to screen
            // blt or screen to offscreen memory blt
            if (psoTrg->hsurf == ppdev->hsurfFrameBuf || pdsurfTrg != NULL) {
                // We only support destination only screen BLTs (ie.  no
                // patterns allowed).
                if (ROP3_NO_PATTERN(rop3)) {
                    if (!OEEncodeScrBlt(&bounds, rop3, pptlSrc, ppdev,
                            &ClipRects, pco)) {
                        if (oeLastDstSurface == NULL)
                            ADD_INCOUNTER(IN_SDA_SCRBLT_AREA,
                                    COM_SIZEOF_RECT(bounds));
                        goto SendScreenData;
                    }
                }
                else {
                    TRC_ALT((TB, "Unsupported screen ROP %x", rop3));
                    if (oeLastDstSurface == NULL)
                        ADD_INCOUNTER(IN_SDA_SCRSCR_FAILROP_AREA,
                                COM_SIZEOF_RECT(bounds));
                    INC_OUTCOUNTER(OUT_BITBLT_SDA_UNSUPPORTED);
                    goto SendScreenData;
                }
            }
            else {
                TRC_NRM((TB, "Unsupported SCR to MEM blt!"));
                DC_QUIT;
            }
        }
    }

    // We added an order to the list, increment global counts.
    goto PostSDA;

SendScreenData:
    if (psoTrg->hsurf == ppdev->hsurfFrameBuf) {
        INC_OUTCOUNTER(OUT_BITBLT_SDA);
        OEClipAndAddScreenDataArea(&bounds, pco);
    }
    else {
        // if we can't send orders for offscreen rendering, we will 
        // bail offscreen support for this bitmap
        TRC_ALT((TB, "screen data call for offscreen rendering"));

        // Remove the bitmap from the offscreen bitmap cache
        if (!(pdsurfTrg->flags & DD_NO_OFFSCREEN))
            CH_RemoveCacheEntry(sbcOffscreenBitmapCacheHandle,
                    pdsurfTrg->bitmapId);

        DC_QUIT;
    }

PostSDA:
    SCH_DDOutputAvailable(ppdev, FALSE);

DC_EXIT_POINT:
    // EngStretchBlt called from DrvStretchBlt sometimes calls DrvBitBlt to
    // do its drawing. Clear the flag here to tell DrvStretchBlt that it
    // doesn't need to send any output.
    oeAccumulateStretchBlt = FALSE;

CalledOnDisconnected:
    DC_END_FN();
    return rc;
}


/****************************************************************************/
// DrvStretchBlt - see NT DDK documentation.
/****************************************************************************/
BOOL RDPCALL DrvStretchBlt(
        SURFOBJ *psoTrg,
        SURFOBJ *psoSrc,
        SURFOBJ *psoMask,
        CLIPOBJ *pco,
        XLATEOBJ *pxlo,
        COLORADJUSTMENT *pca,
        POINTL *pptlHTOrg,
        RECTL *prclTrg,
        RECTL *prclSrc,
        POINTL *pptlMask,
        ULONG iMode)
{
    PDD_PDEV ppdev = (PDD_PDEV)psoTrg->dhpdev;
    PDD_DSURF pdsurfTrg = NULL;
    PDD_DSURF pdsurfSrc = NULL;
    SURFOBJ *psoTrgBitmap, *psoSrcBitmap;
    BOOL rc = TRUE;
    POINTL ptlSrc;
    RECTL rclTrg;
    int bltWidth;
    int bltHeight;
    OE_ENUMRECTS ClipRects;
    MEMBLT_ORDER_EXTRA_INFO MemBltExtraInfo;

    DC_BEGIN_FN("DrvStretchBlt");

    // psoTrg and psoSrc should not be NULL.
    psoTrgBitmap = OEGetSurfObjBitmap(psoTrg, &pdsurfTrg);
    psoSrcBitmap = OEGetSurfObjBitmap(psoSrc, &pdsurfSrc);

    // Sometimes, we're called after being disconnected. This is a pain,
    // but we can trap it here.
    if (ddConnected && pddShm != NULL) {
        
        INC_OUTCOUNTER(OUT_STRTCHBLT_ALL);

        // Get the destination rectangle, ordering it properly if necessary.
        // Note we don't have to order the src rect -- according to the
        // DDK it is guaranteed well-ordered. Clip the result to 16 bits.
        RECT_FROM_RECTL(rclTrg, (*prclTrg));
        OEClipRect(&rclTrg);

        if ((psoTrgBitmap->hsurf == ppdev->hsurfFrameBuf) ||
                (!(pdsurfTrg->flags & DD_NO_OFFSCREEN))) {
            // Send a switch surface PDU if the destination surface is different
            // from last drawing order.  If we failed to send the PDU, we will 
            // just have to bail on this drawing order.
            if (!OESendSwitchSurfacePDU(ppdev, pdsurfTrg)) {
                TRC_ERR((TB, "failed to send the switch surface PDU"));
                goto SendSDA;
            }
        } 
        else {
            // if noOffscreen flag is on, we will bail on sending 
            // the client any further offscreen rendering. And will send the
            // final offscreen to screen blt as regular memblt.
            TRC_NRM((TB, "Offscreen blt bail"));
            goto SendSDA;
        }

        // Check that we have a valid ROP code. The NT DDK states that
        // the ROP code for the StretchBlt is implicit in the mask
        // specification. If a mask is specified, we have an implicit
        // ROP4 of 0xCCAA, otherwise the code is 0xCCCC.
        //
        // Our BitBlt code only encodes orders for ROP3s, so we must
        // throw any StretchBlts with a mask.
        if (psoMask == NULL) {
            unsigned RetVal;

            // Get the intersection between the dest rect and the
            // clip rects. Check for overcomplicated or nonintersecting
            // clipping.
            RetVal = OEGetIntersectingClipRects(pco, &rclTrg, CD_ANY,
                    &ClipRects);
            if (RetVal == CLIPRECTS_TOO_COMPLEX) {
                TRC_NRM((TB, "Clipping is too complex"));
                INC_OUTCOUNTER(OUT_STRTCHBLT_SDA_COMPLEXCLIP);
                goto SendSDA;
            }
            else if (RetVal == CLIPRECTS_NO_INTERSECTIONS) {
                TRC_NRM((TB, "Clipping does not intersect destrect"));
                goto PostSDA;
            }
        }
        else {
            TRC_NRM((TB, "Mask specified"));
            INC_OUTCOUNTER(OUT_STRTCHBLT_SDA_MASK);
            goto SendSDA;
        }
    }
    else {
        if (psoTrg->iType == STYPE_DEVBITMAP) {
            rc = EngStretchBlt(psoTrgBitmap, psoSrcBitmap, psoMask, pco, pxlo,
                pca, pptlHTOrg, prclTrg, prclSrc, pptlMask, iMode);
        }
        else {
            TRC_ERR((TB, "Called when disconnected"));
        }
        
        goto CalledOnDisconnected;
    }

    // DrvStretchBlt can be called with unclipped coords, but we need clipped
    // coords. We must therefore perform clipping here to avoid faults in
    // callbacks to EngBitBlt from DrvBitBlt.
    // First clip the destination rect to the destination surface.
    ptlSrc.x = prclSrc->left;
    ptlSrc.y = prclSrc->top;
    if (rclTrg.left < 0) {
        ptlSrc.x += (-rclTrg.left);
        rclTrg.left = 0;
        TRC_NRM((TB, "Clip trg left"));
    }
    if (rclTrg.top < 0) {
        ptlSrc.y += (-rclTrg.top);
        rclTrg.top = 0;
        TRC_NRM((TB, "Clip trg top"));
    }

    // We need to clip to the screen size instead of the size of psoTrg
    // (the screen surface) here - after reconnection at lower resolution
    // psoTrg->sizlBitmap can be larger than the real screen size.
    rclTrg.right = min(rclTrg.right, ppdev->cxScreen);
    rclTrg.bottom = min(rclTrg.bottom, ppdev->cyScreen);

    // Check if we have a degenerate (ie. no stretch) case. Use the
    // original coords, because it is possible for one of the rects to
    // be flipped to perform an inverted blt.
    if ((prclSrc->right - prclSrc->left == prclTrg->right - prclTrg->left) &&
            (prclSrc->bottom - prclSrc->top == prclTrg->bottom - prclTrg->top)) {
        // Adjust the destination blt size to keep the source rect within
        // the source bitmap, if necessary. Note this should be done here
        // instead of before determining 1:1 stretch since the amount to
        // change rclTrg by would vary according to the stretch ratio.
        if (ptlSrc.x < 0) {
            rclTrg.left += (-ptlSrc.x);
            ptlSrc.x = 0;
            TRC_NRM((TB, "Clip src left"));
        }
        if (ptlSrc.y < 0) {
            rclTrg.top += (-ptlSrc.y);
            ptlSrc.y = 0;
            TRC_NRM((TB, "Clip src top"));
        }

        bltWidth = rclTrg.right - rclTrg.left;
        if ((ptlSrc.x + bltWidth) > psoSrcBitmap->sizlBitmap.cx) {
            rclTrg.right -= ((ptlSrc.x + bltWidth) -
                    psoSrcBitmap->sizlBitmap.cx);
            TRC_NRM((TB, "Clip src right"));
        }

        bltHeight = rclTrg.bottom - rclTrg.top;
        if ((ptlSrc.y + bltHeight) > psoSrcBitmap->sizlBitmap.cy) {
            rclTrg.bottom -= ((ptlSrc.y + bltHeight) -
                    psoSrcBitmap->sizlBitmap.cy);
            TRC_NRM((TB, "Clip src bottom"));
        }

        // Check again for complete clipping out.
        if (rclTrg.right > rclTrg.left && rclTrg.bottom > rclTrg.top) {
            INC_OUTCOUNTER(OUT_STRTCHBLT_BITBLT);
            rc = DrvBitBlt(psoTrg, psoSrc, psoMask, pco, pxlo, &rclTrg,
                    &ptlSrc, pptlMask, NULL, NULL, 0xCCCC);
        }
        else {
            TRC_NRM((TB, "StretchBlt completely clipped"));
        }

        goto PostSDA;
    }
    else {
        // Non-degenerate case -- we are really stretching.
        // Here we simply blt to the screen, then do a bitblt specifying the
        // destination rect to the screen as the source rect.

        // EngStretchBlt sometimes calls DrvBitBlt to do its drawing. Set
        // the flag here before we call to default to sending SDA output.
        // If DrvBitBlt has done all the processing it needs to it will
        // clear the flag.
        oeAccumulateStretchBlt = TRUE;

        rc = EngStretchBlt(psoTrgBitmap, psoSrcBitmap, psoMask, pco, pxlo,
                pca, pptlHTOrg, prclTrg, prclSrc, pptlMask, iMode);
        if (rc && oeAccumulateStretchBlt) {
            // DrvBitBlt was not called already, and we're drawing to our
            // screen surface.

            // Fill in extra info structure. Note NULL pxlo meaning no
            // color translation -- we're drawing from screen to screen.
            // Also, because we are caching directly from the screen
            // we need to turn off fast-path caching -- sometimes we
            // get multiple StretchBlts to nearby areas of the screen,
            // where we may fast-path cache a block that is drawn again
            // on a successive StretchBlt, thereby drawing the wrong tile
            // at the client.
            MemBltExtraInfo.pSource   = psoTrgBitmap;
            MemBltExtraInfo.pDest     = psoTrgBitmap;
            MemBltExtraInfo.pXlateObj = NULL;
            MemBltExtraInfo.bNoFastPathCaching = TRUE;
            MemBltExtraInfo.iDeviceUniq = psoTrg ? (psoTrg->iUniq) : 0;
#ifdef PERF_SPOILING
            MemBltExtraInfo.bIsPrimarySurface = (psoTrgBitmap->hsurf == ppdev->hsurfFrameBuf);
#endif

            // Make sure orders are not turned off.
            if (OE_SendAsOrder(TS_ENC_MEMBLT_R2_ORDER)) {
                // Note pco is clip obj for destination and so is applicable
                // here. We also use ROP3 of 0xCC meaning copy src->dest.
                if (!OEEncodeMemBlt(&rclTrg, &MemBltExtraInfo,
                        TS_ENC_MEMBLT_R2_ORDER, CH_KEY_UNCACHABLE, 0xCC,
                        (PPOINTL)&rclTrg.left, NULL, NULL, ppdev,
                        &ClipRects))
                    goto SendSDAPostEngStretchBlt;
            }
            else {
                TRC_NRM((TB, "MemBlt order not allowed"));
                INC_OUTCOUNTER(OUT_BITBLT_SDA_UNSUPPORTED);
                goto SendSDAPostEngStretchBlt;
            }
        }

        goto PostSDA;
    }

SendSDA:
    // Accumulate screen data if necessary.  EngStretchBlt may have
    // called DrvCopyBits or DrvBitblt to do the work.  These two will
    // have accumulated the data, so no need to do it here.
    TRC_NRM((TB, "***Add SDA for STRETCHBLT"));

    // EngStretchBlt sometimes calls DrvBitBlt to do its drawing. Set
    // the flag here before we call to default to sending SDA output.
    // If DrvBitBlt has done all the processing it needs to it will
    // clear the flag.
    oeAccumulateStretchBlt = TRUE;
    
    rc = EngStretchBlt(psoTrgBitmap, psoSrcBitmap, psoMask, pco, pxlo, pca,
            pptlHTOrg, prclTrg, prclSrc, pptlMask, iMode);

    if (oeAccumulateStretchBlt) {

SendSDAPostEngStretchBlt:

        if (psoTrgBitmap->hsurf == ppdev->hsurfFrameBuf) {
            INC_OUTCOUNTER(OUT_STRTCHBLT_SDA);
            SCH_DDOutputAvailable(ppdev, FALSE);
        }
        else {
            // if we can't send orders for offscreen rendering, we will 
            // bail offscreen support for this bitmap
            TRC_ALT((TB, "screen data call for offscreen rendering"));
            if (!(pdsurfTrg->flags & DD_NO_OFFSCREEN))
                CH_RemoveCacheEntry(sbcOffscreenBitmapCacheHandle,
                        pdsurfTrg->bitmapId);
        }
    }
    
PostSDA:
CalledOnDisconnected:
    DC_END_FN();
    return rc;
}


/****************************************************************************/
// DrvCopyBits - see NT DDK documentation.
/****************************************************************************/
BOOL RDPCALL DrvCopyBits(
        SURFOBJ  *psoTrg,
        SURFOBJ  *psoSrc,
        CLIPOBJ  *pco,
        XLATEOBJ *pxlo,
        RECTL    *prclTrg,
        POINTL   *pptlSrc)
{
    BOOL rc;

    DC_BEGIN_FN("DrvCopyBits");

    if (ddConnected) {
        INC_OUTCOUNTER(OUT_COPYBITS_ALL);

        // CopyBits is a fast path for the NT display drivers. In our case it
        // can always be processed as a BitBlt with copy ROP.
        rc = DrvBitBlt(psoTrg, psoSrc, NULL, pco, pxlo, prclTrg, pptlSrc,
                NULL, NULL, NULL, 0xCCCC);
    }
    else {
        PDD_DSURF pdsurfTrg;
        PDD_DSURF pdsurfSrc;

        TRC_NRM((TB, "Called when disconnected"));

        TRC_ASSERT((psoSrc != NULL),(TB,"NULL source surface!"));

        // We can get called by GDI after disconnection to translate offscreen
        // bitmap surfaces from the DD-specific representation to a GDI surface,
        // for reuse with a different DD. Most often this occurs with Personal
        // TS switching between a remote DD, the disconnected DD (tsddd.dll),
        // and a hardware DD. For this case we really do need to do the
        // CopyBits action. So, we have GDI do it for us since we're really
        // already having GDI manage our "internal" representation.
        psoTrg = OEGetSurfObjBitmap(psoTrg, &pdsurfTrg);
        psoSrc = OEGetSurfObjBitmap(psoSrc, &pdsurfSrc);

        rc = EngCopyBits(psoTrg, psoSrc, pco, pxlo, prclTrg, pptlSrc);
        if (!rc) {
            TRC_ERR((TB,"Post-disc copy: rc=FALSE"));
        }

        // Must return TRUE to ensure that the PTS console will reconnect
        // properly, otherwise the user's machine gets stuck in limbo.
        rc = TRUE;
    }

    DC_END_FN();
    return rc;
}


/***************************************************************************/
// OE_SendCreateOffscrBitmapOrder
//
// Send create offscreen bitmap request to client
/***************************************************************************/
BOOL RDPCALL OE_SendCreateOffscrBitmapOrder(
        PDD_PDEV ppdev,
        SIZEL sizl,
        ULONG iFormat,
        unsigned clientBitmapId)
{
    BOOL rc;
    unsigned cbOrderSize, bitmapSize;
    PINT_ORDER pOrder;
    PTS_CREATE_OFFSCR_BITMAP_ORDER pOffscrBitmapOrder;

    DC_BEGIN_FN("OE_SendCreateOffscrBitmapOrder");

    // Get the current bitmap Size
    if (iFormat < 5) {
        bitmapSize = sizl.cx * sizl.cy * (1 << iFormat) / 8;
    } else if (iFormat == 5) {
        bitmapSize = sizl.cx * sizl.cy * 24 / 8;
    } else if (iFormat == 6) {
        bitmapSize = sizl.cx * sizl.cy * 32 / 8;
    } else {
        TRC_NRM((TB, "Bitmap format not supported"));
        return FALSE;
    }

    // The last entry in the delete list will always be the entry we are using
    // for create this bitmap.  So, remove this from the delete list.
    if (sbcNumOffscrBitmapsToDelete) {
        TRC_ASSERT((sbcOffscrBitmapsDelList[sbcNumOffscrBitmapsToDelete-1].bitmapId ==
                    clientBitmapId), (TB, "different bitmap id"));
        sbcOffscrBitmapsToDeleteSize -= 
                sbcOffscrBitmapsDelList[sbcNumOffscrBitmapsToDelete - 1].bitmapSize;
        sbcNumOffscrBitmapsToDelete--;
    }

    // check if we need to send the delete bitmap list.  We only need to
    // send the list if we are about to exceed client offscreen cache size
    // limit.
    if (bitmapSize + oeCurrentOffscreenCacheSize + sbcOffscrBitmapsToDeleteSize <=
            (pddShm->sbc.offscreenCacheInfo.cacheSize * 1024)) {
        cbOrderSize = sizeof(TS_CREATE_OFFSCR_BITMAP_ORDER) -
                sizeof(pOffscrBitmapOrder->variableBytes);
    } else {
        // Note we use the UINT16 at variableBytes for the number of
        // bitmaps. Hence, we don't subtract the size of variableBytes here.
        cbOrderSize = sizeof(TS_CREATE_OFFSCR_BITMAP_ORDER) + sizeof(UINT16) *
                sbcNumOffscrBitmapsToDelete;
    }

    pOrder = OA_AllocOrderMem(ppdev, cbOrderSize);
    if (pOrder != NULL) {
        // Fill in the details. This is an alternate secondary order
        // type.
        pOffscrBitmapOrder = (PTS_CREATE_OFFSCR_BITMAP_ORDER)pOrder->OrderData;
        pOffscrBitmapOrder->ControlFlags = (TS_ALTSEC_CREATE_OFFSCR_BITMAP <<
                TS_ALTSEC_ORDER_TYPE_SHIFT) | TS_SECONDARY;
        pOffscrBitmapOrder->Flags = (UINT16)clientBitmapId;
        pOffscrBitmapOrder->cx = (UINT16)sizl.cx;
        pOffscrBitmapOrder->cy = (UINT16)sizl.cy;

        // Send the delete bitmap list
        if (cbOrderSize > sizeof(TS_CREATE_OFFSCR_BITMAP_ORDER)) {
            PUINT16_UA pData;
            unsigned i;

            // This flag indicates that the delete bitmap list is appended.
            pOffscrBitmapOrder->Flags |= 0x8000;
            pData = (PUINT16_UA)pOffscrBitmapOrder->variableBytes;
            
            *pData++ = (UINT16)sbcNumOffscrBitmapsToDelete;

            for (i = 0; i < sbcNumOffscrBitmapsToDelete; i++)
                *pData++ = (UINT16)sbcOffscrBitmapsDelList[i].bitmapId;

            // Reset the flags.
            sbcNumOffscrBitmapsToDelete = 0;
            sbcOffscrBitmapsToDeleteSize = 0;
        }

        INC_OUTCOUNTER(OUT_OFFSCREEN_BITMAP_ORDER);
        ADD_OUTCOUNTER(OUT_OFFSCREEN_BITMAP_ORDER_BYTES, cbOrderSize);
        OA_AppendToOrderList(pOrder);
        rc = TRUE;
    }
    else {
        TRC_ERR((TB,"Unable to alloc heap space"));
        rc = FALSE;
    }

    DC_END_FN();
    return rc;
}


/****************************************************************************/
// DrvCreateDeviceBitmap - See NT DDK for documentation
/****************************************************************************/
HBITMAP DrvCreateDeviceBitmap(DHPDEV dhpdev, SIZEL sizl, ULONG iFormat)
{
    PDD_PDEV ppdev;
    PDD_DSURF pdsurf;
    HBITMAP hbmDevice = NULL;
    HBITMAP hbmDib;
    FLONG flHooks;
    SURFOBJ *pso;
    unsigned bitmapSize;
    ULONG iFormatArg = iFormat;

    DC_BEGIN_FN("DrvCreateDeviceBitmap");
    
    if (ddConnected && pddShm != NULL) {
        INC_OUTCOUNTER(OUT_OFFSCREEN_BITMAP_ALL);

        ppdev = (PDD_PDEV) dhpdev;

        if (ddConsole) {
            //
            // For the console case, since we accept any Format by overwritting it,
            // we accept Format=1 (1bpp). This case is not fully supported by GDI.
            // So skip it and do as a regular remote session.
            //
            if (iFormat == 1)
                DC_QUIT;

            iFormat = ppdev->iBitmapFormat;
        }

        if (OEDeviceBitmapCachable(ppdev, sizl, iFormat)) {
            if (iFormat < 5) 
                bitmapSize = sizl.cx * sizl.cy * (1 << iFormat) / 8;
            else if (iFormat == 5) 
                bitmapSize = sizl.cx * sizl.cy * 24 / 8;
            else if (iFormat == 6) 
                bitmapSize = sizl.cx * sizl.cy * 32 / 8;
            else {
                TRC_NRM((TB, "Bitmap format not supported"));
                DC_QUIT;
            }
            goto CreateBitmap;
        }
        else {
            TRC_DBG((TB, "OEDeviceBitmapCachable returns FALSE"));
            DC_QUIT;
        }
    }
    else {
        //TRC_DBG((TB, "Call on disconnected"));
        DC_QUIT;
    }

CreateBitmap:

    // Create the device surface for this offscreen bitmap.
    // This device surface handle is used to identify the offscreen
    // bitmap in all DrvXXX calls.
    pdsurf = EngAllocMem(FL_ZERO_MEMORY, sizeof(DD_DSURF), DD_ALLOC_TAG);

    if (pdsurf != NULL) {   
        // initialize the DD_DSURF fields
        memset(pdsurf, 0, sizeof(DD_DSURF));

        // Create a device bitmap for this offscreen bitmap
        hbmDevice = EngCreateDeviceBitmap((DHSURF) pdsurf, sizl, iFormat);

        if (hbmDevice != NULL) {
            // Get the flHooks flag from the PDEV struct
            flHooks = ppdev->flHooks;

            // Associate the bitmap to the PDEV device
            if (EngAssociateSurface((HSURF) hbmDevice, ppdev->hdevEng,
                    flHooks)) {
                // Create a DIB backup bitmap for this offscreen bitmap
                hbmDib = EngCreateBitmap(sizl, 
                        TS_BYTES_IN_SCANLINE(sizl.cx, ppdev->cClientBitsPerPel), 
                        ppdev->iBitmapFormat, BMF_TOPDOWN, NULL);

                if (hbmDib) {
                    // Associate the bitmap to the PDEV device
                    if (EngAssociateSurface((HSURF) hbmDib, ppdev->hdevEng, 0)) {
                        // Lock the surface to get the surf obj
                        pso = EngLockSurface((HSURF) hbmDib);

                        if (pso != NULL)
                        {
                            int i;
                            unsigned clientBitmapId;
                            CHDataKeyContext CHContext;

                            // Setup offscreen device surface struct
                            pdsurf->shareId = pddShm->shareId;
                            pdsurf->sizl  = sizl;
                            pdsurf->iBitmapFormat = iFormat;
                            pdsurf->ppdev = ppdev;
                            pdsurf->pso   = pso;
                            pdsurf->flags = 0;

                            CH_CreateKeyFromFirstData(&CHContext,
                                    (BYTE *)(&pdsurf), sizeof(pdsurf));

                            // Cache the offscreen bitmap in the cache
                            clientBitmapId = CH_CacheKey(
                                    sbcOffscreenBitmapCacheHandle, 
                                    CHContext.Key1, CHContext.Key2,
                                    (VOID *)pdsurf);

                            if (clientBitmapId != CH_KEY_UNCACHABLE) {
                                // send a create offscreen bitmap pdu
                                if (OE_SendCreateOffscrBitmapOrder(ppdev,
                                        sizl, iFormat, clientBitmapId)) {
                                    // Update the current offscreen cache size
                                    oeCurrentOffscreenCacheSize += bitmapSize;
                                    pdsurf->bitmapId = clientBitmapId;
                                    TRC_NRM((TB, "Created an offscreen bitmap"));
                                    DC_QUIT;
                                } else {
                                    TRC_ERR((TB, "Failed to send the create bitmap pdu"));
                                    CH_RemoveCacheEntry(
                                            sbcOffscreenBitmapCacheHandle, clientBitmapId);
                                    EngDeleteSurface((HSURF)hbmDevice);
                                    hbmDevice = NULL;
                                    DC_QUIT;
                                }
                            } else {
                                TRC_ERR((TB, "Failed to cache the bitmap"));
                                EngDeleteSurface((HSURF)hbmDevice);
                                hbmDevice = NULL;
                                DC_QUIT;
                            }

                        } else {
                            TRC_ERR((TB, "Failed to lock the surfac"));
                            EngDeleteSurface((HSURF)hbmDib);
                            EngDeleteSurface((HSURF)hbmDevice);
                            hbmDevice = NULL;
                            DC_QUIT;
                        }
                    } else {
                        TRC_ERR((TB, "Failed to associate the surface to device"));
                        EngDeleteSurface((HSURF)hbmDib);
                        EngDeleteSurface((HSURF)hbmDevice);
                        hbmDevice = NULL;
                        DC_QUIT;
                    }
                } else {
                    TRC_ERR((TB, "Failed to create backup DIB bitmap"));
                    EngDeleteSurface((HSURF)hbmDevice);
                    hbmDevice = NULL;
                    DC_QUIT;
                }
            } else {
                TRC_ERR((TB, "Failed to associate the device surface to the device"));
                EngDeleteSurface((HSURF)hbmDevice);
                hbmDevice = NULL;
                DC_QUIT;
            }
        } else {
            TRC_ERR((TB, "Failed to allocate memory for the device surface"));
            EngFreeMem(pdsurf);
            DC_QUIT;
        }
    } else {
        TRC_ERR((TB, "Failed to allocate memory for the device surface"));
        DC_QUIT;
    }

DC_EXIT_POINT:

    DC_END_FN();
    return hbmDevice;
}


/****************************************************************************/
// DrvDeleteDeviceBitmap - See NT DDK for documentation
/****************************************************************************/
VOID DrvDeleteDeviceBitmap(DHSURF dhsurf)
{
    PDD_DSURF pdsurf;
    PDD_PDEV ppdev;
    SURFOBJ *psoDib;
    HSURF hsurfDib;

    DC_BEGIN_FN("DrvDeleteDeviceBitmap");

    pdsurf = (PDD_DSURF)dhsurf;
    ppdev = pdsurf->ppdev;

    if (ddConnected && pddShm != NULL) {
        if ((pddShm->sbc.offscreenCacheInfo.supportLevel > TS_OFFSCREEN_DEFAULT) &&
            (sbcEnabled & SBC_OFFSCREEN_CACHE_ENABLED)) {
            if (!(pdsurf->flags & DD_NO_OFFSCREEN) && 
                    (pdsurf->shareId == pddShm->shareId)) {
                CH_RemoveCacheEntry(sbcOffscreenBitmapCacheHandle, pdsurf->bitmapId);
            } else {
                // This is when the bitmap is bumped out of the cache
                TRC_NRM((TB, "Failed to find the offscreen bitmap in the cache"));
                DC_QUIT;
            }
        }
        else {
            TRC_ERR((TB, "offscreen rendering is not supported"));
            DC_QUIT;
        }
    }
    else {
        TRC_ERR((TB, "Call on disconnected"));
        DC_QUIT;
    }

DC_EXIT_POINT:

    // Get the hsurf from the SURFOBJ before we unlock it (it's not
    // legal to dereference psoDib when it's unlocked):
    psoDib = pdsurf->pso;

    if (psoDib) {
        hsurfDib = psoDib->hsurf;
        EngUnlockSurface(psoDib);
        EngDeleteSurface(hsurfDib);
    }

    EngFreeMem(pdsurf);

    DC_END_FN();
}


#ifdef DRAW_NINEGRID
/****************************************************************************/
// DrvNineGrid - This is to support Whistler Luna Draw9Grid operation
/****************************************************************************/
BOOL DrvNineGrid(
        SURFOBJ    *psoTrg,
        SURFOBJ    *psoSrc,
        CLIPOBJ    *pco,
        XLATEOBJ   *pxlo,
        PRECTL      prclTrg,
        PRECTL      prclSrc,
        PNINEGRID   png,
        BLENDOBJ*   pBlendObj,
        PVOID       pvReserved)
{
    BOOL rc = TRUE;
    SURFOBJ *psoTrgArg;
    SURFOBJ *psoSrcArg;
    PDD_PDEV ppdev = (PDD_PDEV)psoTrg->dhpdev;
    PDD_DSURF pdsurfTrg = NULL;
    PDD_DSURF pdsurfSrc = NULL;
    RECTL bounds;
    OE_ENUMRECTS clipRects;
    unsigned nineGridBitmapId = 0;
    unsigned clipVal;
    
    DC_BEGIN_FN("DrvNineGrid")

    if (ddConnected && pddShm != NULL) {        
        psoTrgArg = psoTrg;
        psoSrcArg = psoSrc;
        
        // Get the GDI format source and destination bitmaps
        psoTrg = OEGetSurfObjBitmap(psoTrg, &pdsurfTrg);
        if (psoSrc != NULL)
            psoSrc = OEGetSurfObjBitmap(psoSrc, &pdsurfSrc);

        // if the client doesn't support drawninegrid, return false to reroute
        if (sbcDrawNineGridBitmapCacheHandle == NULL || (pddShm != NULL && 
                pddShm->sbc.drawNineGridCacheInfo.supportLevel <= TS_DRAW_NINEGRID_DEFAULT) ||
                !OE_SendAsOrder(TS_ENC_DRAWNINEGRID_ORDER) ||
                !OE_SendAsOrder(TS_ENC_MULTI_DRAWNINEGRID_ORDER) ||
                (ppdev != NULL && !((psoTrg->hsurf == ppdev->hsurfFrameBuf) ||
                (!(pdsurfTrg->flags & DD_NO_OFFSCREEN))))) { 
            return EngNineGrid(psoTrgArg, psoSrcArg, pco, pxlo, prclTrg, prclSrc, png,
                    pBlendObj, pvReserved);
        }

        //DD_UPD_STATE(DD_BITBLT);
        //INC_OUTCOUNTER(OUT_BITBLT_ALL);

        // Punt the call back to GDI to do the drawing.
        rc = EngNineGrid(psoTrg, psoSrc, pco, pxlo, prclTrg, prclSrc, png,
                pBlendObj, pvReserved);

        if (rc) {
            // If ppdev is NULL then this is a blt to GDI managed memory bitmap, 
            // so there is no need to accumulate any output.
            if (ppdev != NULL) {
                BOOL bMirror;

                // The following is true for DrvBitBlt, need to find out for 
                // get the bounding rectangle for the operation. According to
                // the DDK, this rectangle is always well-ordered and does not
                // need to be rearranged. 
                // Clip it to 16 bits.
                bounds = *prclTrg;
                OEClipRect(&bounds);   

                // If the bound is right to left, we need to switch it.
                bMirror = bounds.left > bounds.right; 
                if (bMirror)
                {
                    LONG    lRight = bounds.left;
                    bounds.left = bounds.right;
                    bounds.right = lRight;
                }
            }
            else {
                // if ppdev is NULL, we are blt to GDI managed bitmap,
                // so, the dhurf of the target surface should be NULL
                TRC_ASSERT((pdsurfTrg == NULL), 
                        (TB, "NULL ppdev - psoTrg has non NULL dhsurf"));

                TRC_NRM((TB, "NULL ppdev - blt to GDI managed bitmap"));
                DC_QUIT;
            }
        }
        else {
            TRC_ERR((TB, "EngBitBlt failed"));
            DC_QUIT;
        }
    }
    else {
        if (psoTrg->iType == STYPE_DEVBITMAP) {
        
            psoTrg = OEGetSurfObjBitmap(psoTrg, &pdsurfTrg);
            if (psoSrc != NULL)
                psoSrc = OEGetSurfObjBitmap(psoSrc, &pdsurfSrc);
    
            // Punt the call back to GDI to do the drawing.
            rc = EngNineGrid(psoTrg, psoSrc, pco, pxlo, prclTrg, prclSrc, png,
                    pBlendObj, pvReserved);
        }
        else {
            TRC_ERR((TB, "Called when disconnected"));
            rc = TRUE;
        }

        DC_QUIT;
    }
    

    if (!((psoTrg->hsurf == ppdev->hsurfFrameBuf) ||
            (!(pdsurfTrg->flags & DD_NO_OFFSCREEN)))) {
        // If noOffscreen flag is on, we will bail on sending 
        // the client any further offscreen rendering. And we'll send the
        // final offscreen to screen blt as regular memblt.
        TRC_NRM((TB, "Offscreen blt bail"));

        //INC_OUTCOUNTER(OUT_BITBLT_NOOFFSCR);
        DC_QUIT;
    }
        
    // Get the intersection between the dest rect and the
    // clip rects. Check for overcomplicated or nonintersecting
    // clipping.
    clipVal = OEGetIntersectingClipRects(pco, &bounds, CD_ANY,
            &clipRects);

    if (clipVal == CLIPRECTS_TOO_COMPLEX) {
        TRC_NRM((TB, "Clipping is too complex"));
        
        //INC_OUTCOUNTER(OUT_BITBLT_SDA_COMPLEXCLIP);
        //if (oeLastDstSurface == NULL)
        //    ADD_INCOUNTER(IN_SDA_BITBLT_COMPLEXCLIP_AREA,
        //            COM_SIZEOF_RECT(bounds));
        goto SendScreenData;
    }
    else if (clipVal == CLIPRECTS_NO_INTERSECTIONS) {
        TRC_NRM((TB, "Clipping does not intersect destrect"));
        DC_QUIT;
    }

    // Cache the source bitmap
    TRC_ASSERT((psoSrcArg->iUniq != 0), (TB, "Source bitmap should be cachable"));
    TRC_ASSERT((pdsurfSrc == NULL), (TB, "The source bitmap for this should be GDI managed bitmap"));
    TRC_ASSERT((psoSrc->iBitmapFormat == BMF_32BPP), (TB, "for now, we always get 32bpp bitmap"));
    TRC_ASSERT((pBlendObj->BlendFunction.BlendOp == 0 && 
            pBlendObj->BlendFunction.BlendFlags == 0 &&
            pBlendObj->BlendFunction.SourceConstantAlpha == 255 &&
            pBlendObj->BlendFunction.AlphaFormat == 1), (TB, "Received unknown blend function"));

    if (!OECacheDrawNineGridBitmap(ppdev, psoSrc, png, &nineGridBitmapId)) {
        TRC_ERR((TB, "Failed to cache drawninegrid bitmap"));
        goto SendScreenData;
    }
    
    // Switch drawing surface if needed
    if ((psoTrg->hsurf == ppdev->hsurfFrameBuf) ||
            (!(pdsurfTrg->flags & DD_NO_OFFSCREEN))) {
        // Send a switch surface PDU if the destination surface is different
        // from last drawing order.  If we failed to send the PDU, we will 
        // just have to bail on this drawing order.
        if (!OESendSwitchSurfacePDU(ppdev, pdsurfTrg)) {
            TRC_ERR((TB, "failed to send the switch surface PDU"));
            goto SendScreenData;
        }
    } 
    else {
        // if noOffscreen flag is on, we will bail on sending 
        // the client any further offscreen rendering. And will send the
        // final offscreen to screen blt as regular memblt.
        TRC_NRM((TB, "Offscreen blt bail"));
        goto SendScreenData;
    }

    // Send the drawninegrid encoded primary order 
    if (OEEncodeDrawNineGrid(&bounds, prclSrc, nineGridBitmapId, ppdev, &clipRects)) {
        // We added an order to the list, increment global counts.
        goto PostSDA;
    }
    else {
        goto SendScreenData;
    }
 
SendScreenData:
    
    if ((psoTrg->hsurf == ppdev->hsurfFrameBuf) ||
            (!(pdsurfTrg->flags & DD_NO_OFFSCREEN))) {
        // Send a switch surface PDU if the destination surface is different
        // from last drawing order. If we failed to send the PDU, we will
        // just have to bail on this drawing order.
        if (!OESendSwitchSurfacePDU(ppdev, pdsurfTrg)) {
            TRC_ERR((TB, "failed to send the switch surface PDU"));
            DC_QUIT;
        }
    }
    else {
        // If noOffscreen flag is on, we will bail on sending 
        // the client any further offscreen rendering. And we'll send the
        // final offscreen to screen blt as regular memblt.
        TRC_NRM((TB, "Offscreen blt bail"));

        //INC_OUTCOUNTER(OUT_BITBLT_NOOFFSCR);
        DC_QUIT;
    }

    if (psoTrg->hsurf == ppdev->hsurfFrameBuf) {
        //INC_OUTCOUNTER(OUT_BITBLT_SDA);
        OEClipAndAddScreenDataArea(&bounds, pco);
    }
    else {
        // if we can't send orders for offscreen rendering, we will 
        // bail offscreen support for this bitmap
        TRC_ALT((TB, "screen data call for offscreen rendering"));

        // Remove the bitmap from the offscreen bitmap cache
        if (!(pdsurfTrg->flags & DD_NO_OFFSCREEN))
            CH_RemoveCacheEntry(sbcOffscreenBitmapCacheHandle,
                    pdsurfTrg->bitmapId);

        DC_QUIT;
    }

PostSDA:
    
    SCH_DDOutputAvailable(ppdev, FALSE);

DC_EXIT_POINT:

    DC_END_FN();
    return rc;
}


#if 0
BOOL DrvDrawStream(
        SURFOBJ    *psoTrg,
        SURFOBJ    *psoSrc,
        CLIPOBJ    *pco,
        XLATEOBJ   *pxlo,
        RECTL      *prclTrg,
        POINTL     *pptlDstOffset,
        ULONG       ulIn,
        PVOID       pvIn,
        PVOID       pvReserved)
{
    BOOL rc = TRUE;
    SURFOBJ *psoTrgArg;
    SURFOBJ *psoSrcArg;
    PDD_PDEV ppdev = (PDD_PDEV)psoTrg->dhpdev;
    PDD_DSURF pdsurfTrg = NULL;
    PDD_DSURF pdsurfSrc = NULL;
    RECTL bounds;
    OE_ENUMRECTS clipRects;
    unsigned drawStreamBitmapId = 0;
    unsigned offscrBitmapId = 0;
    unsigned RetVal;

    DC_BEGIN_FN("DrvDrawStream")

    if (ddConnected) {
        
        psoTrgArg = psoTrg;
        psoSrcArg = psoSrc;
        
        // Get the GDI format source and destination bitmaps
        psoTrg = OEGetSurfObjBitmap(psoTrg, &pdsurfTrg);
        if (psoSrc != NULL)
            psoSrc = OEGetSurfObjBitmap(psoSrc, &pdsurfSrc);

        //DD_UPD_STATE(DD_BITBLT);
        //INC_OUTCOUNTER(OUT_BITBLT_ALL);

        // Punt the call back to GDI to do the drawing.
        rc = EngDrawStream(psoTrg, psoSrc, pco, pxlo, prclTrg, pptlDstOffset,
                ulIn, pvIn, pvReserved);

        if (rc) {
            // If ppdev is NULL then this is a blt to GDI managed memory bitmap, 
            // so there is no need to accumulate any output.
            if (ppdev != NULL) {
                // The following is true for DrvBitBlt, need to find out for Get 
                // the bounding rectangle for the operation. According to
                // the DDK, this rectangle is always well-ordered and does not
                // need to be rearranged. 
                // Clip it to 16 bits.
                bounds = *prclTrg;
                OEClipRect(&bounds);                                
            }
            else {
                // if ppdev is NULL, we are blt to GDI managed bitmap,
                // so, the dhurf of the target surface should be NULL
                TRC_ASSERT((pdsurfTrg == NULL), 
                        (TB, "NULL ppdev - psoTrg has non NULL dhsurf"));

                TRC_NRM((TB, "NULL ppdev - blt to GDI managed bitmap"));
                DC_QUIT;
            }
        }
        else {
            TRC_ERR((TB, "EngBitBlt failed"));
            DC_QUIT;
        }
    }
    else {
        if (psoTrg->iType == STYPE_DEVBITMAP) {
        
            psoTrg = OEGetSurfObjBitmap(psoTrg, &pdsurfTrg);
            if (psoSrc != NULL)
                psoSrc = OEGetSurfObjBitmap(psoSrc, &pdsurfSrc);
    
            // Punt the call back to GDI to do the drawing.
            rc = EngDrawStream(psoTrg, psoSrc, pco, pxlo, prclTrg, pptlDstOffset,
                    ulIn, pvIn, pvReserved);
        }
        else {
            TRC_ERR((TB, "Called when disconnected"));
            rc = TRUE;
        }

        DC_QUIT;
    }
    

    if (!((psoTrg->hsurf == ppdev->hsurfFrameBuf) ||
            (!(pdsurfTrg->flags & DD_NO_OFFSCREEN)))) {
        // If noOffscreen flag is on, we will bail on sending 
        // the client any further offscreen rendering. And we'll send the
        // final offscreen to screen blt as regular memblt.
        TRC_NRM((TB, "Offscreen blt bail"));

        //INC_OUTCOUNTER(OUT_BITBLT_NOOFFSCR);
        DC_QUIT;
    }
        
    // Get the intersection between the dest rect and the
    // clip rects. Check for overcomplicated or nonintersecting
    // clipping.
    RetVal = OEGetIntersectingClipRects(pco, &bounds, CD_ANY,
            &clipRects);

    if (RetVal == CLIPRECTS_TOO_COMPLEX) {
        TRC_NRM((TB, "Clipping is too complex"));
        
        //INC_OUTCOUNTER(OUT_BITBLT_SDA_COMPLEXCLIP);
        //if (oeLastDstSurface == NULL)
        //    ADD_INCOUNTER(IN_SDA_BITBLT_COMPLEXCLIP_AREA,
        //            COM_SIZEOF_RECT(bounds));
        goto SendScreenData;
    }
    else if (RetVal == CLIPRECTS_NO_INTERSECTIONS) {
        TRC_NRM((TB, "Clipping does not intersect destrect"));
        DC_QUIT;
    }

    // Cache the source bitmap
    
    TRC_ASSERT((psoSrcArg->iUniq != 0), (TB, "Source bitmap should be cachable"));

    // For the source bitmap
    //
    // Case 1: This is an RDP managed device bitmap and the bitmap
    // is still cached at the client and we can just use the bitmapId
    //
    // Case 2: This is an RDP managed device bitmap, but no longer
    // cached at the client side
    //
    // Case 3: This is a GDI managed bitmap
    //
    // For case 2 and 3, we need to cache the bitmap first
    //
    if (pdsurfSrc != NULL) {
        if ((pddShm->sbc.offscreenCacheInfo.supportLevel > TS_OFFSCREEN_DEFAULT) &&
            (sbcEnabled & SBC_OFFSCREEN_CACHE_ENABLED)) {
    
            if (pdsurfSrc->shareId == pddShm->shareId) {
            
                // The client has the offscreen bitmap in cache
                if (!(pdsurfSrc->flags & DD_NO_OFFSCREEN)) {
                    offscrBitmapId = pdsurfSrc->bitmapId;
                    CH_TouchCacheEntry(sbcOffscreenBitmapCacheHandle,
                            offscrBitmapId);
                }
                else {
                    // If the source surface is offscreen surface, and we
                    // have the noOffscreen flag on, this means we will 
                    // send the bitmap bits as regular memory bitmap bits
                    // This means that the offscreen bitmap has been evicted
                    // out of the offscreen cache or screen data needs to be 
                    // sent for the offscreen bitmap
                    TRC_ALT((TB, "noOffscreen flag is on for %p", pdsurfSrc));                    
                    offscrBitmapId = CH_KEY_UNCACHABLE;
                }
            }
            else {
                //  This is the stale offscreen bitmap from last disconnected
                //  session.  We need to turn off the offscreen flag on this
                TRC_ALT((TB, "Need to turn off this offscreen bitmap"));                
                pdsurfSrc->flags |= DD_NO_OFFSCREEN;
                offscrBitmapId = CH_KEY_UNCACHABLE;
            }
        }
        else {
            // These are offscreen bitmaps from the disconnected session
            // or client has sent an error pdu,
            // We have to treat them as memory bitmap now since the client
            // doesn't have the offscreen bitmap locally
            TRC_ALT((TB, "Need to turn off this offscreen bitmap"));        
            pdsurfSrc->flags |= DD_NO_OFFSCREEN;
            offscrBitmapId = CH_KEY_UNCACHABLE;
        }
    }
    else {
        if ((pddShm->sbc.offscreenCacheInfo.supportLevel > TS_OFFSCREEN_DEFAULT) &&
            (sbcEnabled & SBC_OFFSCREEN_CACHE_ENABLED)) {
            offscrBitmapId = CH_KEY_UNCACHABLE;
        }
        else {
            TRC_NRM((TB, "No offscreen support, can't support draw stream"));
            goto SendScreenData;
        }
    }

    // Need to create an offscreen 

    if (offscrBitmapId == CH_KEY_UNCACHABLE) {
        MEMBLT_ORDER_EXTRA_INFO MemBltExtraInfo;
        POINTL ptlSrc;
        CHDataKeyContext CHContext;
        void *UserDefined;
        
        drawStreamBitmapId = CH_KEY_UNCACHABLE;

        CH_CreateKeyFromFirstData(&CHContext, psoSrc->pvBits, psoSrc->cjBits);
        
        if (!CH_SearchCache(sbcDrawStreamBitmapCacheHandle, CHContext.Key1, CHContext.Key2, 
                           &UserDefined, &drawStreamBitmapId)) {
            
            drawStreamBitmapId = CH_CacheKey(
                   sbcDrawStreamBitmapCacheHandle, 
                   CHContext.Key1, CHContext.Key2,
                   NULL);

            if (drawStreamBitmapId != CH_KEY_UNCACHABLE) {

                unsigned BitmapRawSize;
                unsigned BitmapBufferSize;
                unsigned BitmapCompSize;
                unsigned BitmapBpp;
                SIZEL size;
                PBYTE BitmapBuffer;
                PBYTE BitmapRawBuffer;
                PINT_ORDER pOrder = NULL; 
                unsigned paddedBitmapWidth;
                HSURF hWorkBitmap;
                SURFOBJ *pWorkSurf;
                BOOL rc;

                BitmapBuffer = oeTempBitmapBuffer;
                BitmapBufferSize = TS_MAX_STREAM_BITMAP_SIZE;
                
                // Convert to the protocol wire bitmap bpp format
                switch (psoSrc->iBitmapFormat)
                {
                case BMF_16BPP:
                    BitmapBpp = 16;
                    break;

                case BMF_24BPP:
                    BitmapBpp = 24;
                    break;

                case BMF_32BPP:
                    BitmapBpp = 32;
                    break;

                default:
                    BitmapBpp = 8;
                }
                
                paddedBitmapWidth = (psoSrc->sizlBitmap.cx + 3) & ~3;
                size.cx = paddedBitmapWidth;
                size.cy = psoSrc->sizlBitmap.cy;

                // We need to copy to a worker bitmap if the bitmap width is 
                // not dword aligned, or the color depth is not 32bpp and
                // doesn't match the frame buffer color depth
                if (paddedBitmapWidth != psoSrc->sizlBitmap.cx || 
                        (psoSrc->iBitmapFormat != ppdev->iBitmapFormat &&
                         psoSrc->iBitmapFormat != BMF_32BPP)) {
                    
                    RECTL rect;
                    POINTL origin;

                    rect.left = 0;
                    rect.top = 0;

                    rect.right = paddedBitmapWidth;
                    rect.bottom = psoSrc->sizlBitmap.cy;
                    
                    origin.x = 0;
                    origin.y = 0;

                    hWorkBitmap = (HSURF)EngCreateBitmap(size,
                            TS_BYTES_IN_SCANLINE(size.cx, BitmapBpp),
                            psoSrc->iBitmapFormat, 0, NULL);

                    pWorkSurf = EngLockSurface(hWorkBitmap);

                    if (EngCopyBits(pWorkSurf, psoSrc, NULL, NULL, &rect, &origin)) {
                        BitmapRawSize = pWorkSurf->cjBits;
                        BitmapRawBuffer = pWorkSurf->pvBits;

                        rc = BC_CompressBitmap(BitmapRawBuffer, BitmapBuffer, BitmapBufferSize,
                                      &BitmapCompSize, paddedBitmapWidth, psoSrc->sizlBitmap.cy,
                                      BitmapBpp);

                        EngUnlockSurface(pWorkSurf);
                        EngDeleteSurface(hWorkBitmap);
                    }
                    else {
                        EngUnlockSurface(pWorkSurf);
                        EngDeleteSurface(hWorkBitmap);
                        goto SendScreenData;
                    }

                    EngUnlockSurface(pWorkSurf);
                    EngDeleteSurface(hWorkBitmap);
                
                }
                else {
                    BitmapRawSize = psoSrc->cjBits;
                    BitmapRawBuffer = psoSrc->pvBits;

                    rc = BC_CompressBitmap(BitmapRawBuffer, BitmapBuffer, BitmapBufferSize,
                                      &BitmapCompSize, paddedBitmapWidth, psoSrc->sizlBitmap.cy,
                                      BitmapBpp);
                }

                if (rc) {
                    if (!OESendStreamBitmapOrder(ppdev, TS_DRAW_NINEGRID_BITMAP_CACHE, &size, 
                            BitmapBpp, BitmapBuffer, BitmapCompSize, TRUE)) {
                        goto SendScreenData;
                    }
                }
                else {
                    // Send uncompressed bitmap
                    
                    if (!OESendStreamBitmapOrder(ppdev, TS_DRAW_NINEGRID_BITMAP_CACHE, &size,  
                            BitmapBpp, BitmapRawBuffer, BitmapRawSize, FALSE))
                    {
                        goto SendScreenData;
                    }
                }

                // send a create drawStream bitmap pdu
                if (OESendCreateDrawStreamOrder(ppdev,drawStreamBitmapId,
                        &(psoSrc->sizlBitmap), BitmapBpp)) {
                    // Update the current offscreen cache size
                    //oeCurrentOffscreenCacheSize += bitmapSize;
                    TRC_NRM((TB, "Created an offscreen bitmap"));                
                } 
                else {
                    TRC_ERR((TB, "Failed to send the create bitmap pdu"));
                    CH_RemoveCacheEntry(
                            sbcDrawStreamBitmapCacheHandle, drawStreamBitmapId);
                    goto SendScreenData;
                }
            } 
            else {
                TRC_ERR((TB, "Failed to cache the bitmap"));
                goto SendScreenData;
            }
            
#if 0
            if (!OESendSwitchSurfacePDU(ppdev, (PDD_DSURF)(&drawStreamBitmapId), DRAW_STREAM_SURFACE)) {
                TRC_ERR((TB, "failed to send the switch surface PDU"));
                goto SendScreenData;
            }
            
            // Fill in extra info structure.
            MemBltExtraInfo.pSource = psoSrc;
            MemBltExtraInfo.pDest = psoSrc;
            MemBltExtraInfo.pXlateObj = NULL; 
            MemBltExtraInfo.bNoFastPathCaching = FALSE;
            MemBltExtraInfo.iDeviceUniq = psoSrcArg ? (psoSrcArg->iUniq) : 0;

            ptlSrc.x = 0;
            ptlSrc.y = 0;
            
            // Make sure orders are not turned off.
            if (OE_SendAsOrder(TS_ENC_MEMBLT_R2_ORDER)) {
                RECTL srcBound;
                OE_ENUMRECTS srcClipRect;
            
                // Get the intersection rect.
                srcBound.left = 0;
                srcBound.top = 0;
                srcBound.right = psoSrc->sizlBitmap.cx;
                srcBound.bottom = psoSrc->sizlBitmap.cy;
            
                srcClipRect.rects.c = 1;
                srcClipRect.rects.arcl[0] = srcBound;
            
                if (!OEEncodeMemBlt(&srcBound, &MemBltExtraInfo,
                        TS_ENC_MEMBLT_R2_ORDER, CH_KEY_UNCACHABLE,
                        0xCC, &ptlSrc, NULL, NULL, ppdev,
                        &srcClipRect)) {
                    //if (oeLastDstSurface == NULL)
                    //    ADD_INCOUNTER(IN_SDA_MEMBLT_AREA,
                    //            COM_SIZEOF_RECT(bounds));
                    goto SendScreenData;
                }
            }
            else {
                TRC_NRM((TB, "MemBlt order not allowed"));
                //INC_OUTCOUNTER(OUT_BITBLT_SDA_UNSUPPORTED);
                goto SendScreenData;
            }
#endif
            
        }
        else {
            //DrvDebugPrint("JOYC: drawstream source already cached\n");
        }
    }
    else {
        // The client already has the bitmap cached in offscreen bitmap cache
        //DrvDebugPrint("JOYC: offscreen already cached!\n");        
    }

    if ((psoTrg->hsurf == ppdev->hsurfFrameBuf) ||
            (!(pdsurfTrg->flags & DD_NO_OFFSCREEN))) {
        // Send a switch surface PDU if the destination surface is different
        // from last drawing order.  If we failed to send the PDU, we will 
        // just have to bail on this drawing order.
        if (!OESendSwitchSurfacePDU(ppdev, pdsurfTrg, 0)) {
            TRC_ERR((TB, "failed to send the switch surface PDU"));
            goto SendScreenData;
        }
    } 
    else {
        // if noOffscreen flag is on, we will bail on sending 
        // the client any further offscreen rendering. And will send the
        // final offscreen to screen blt as regular memblt.
        TRC_NRM((TB, "Offscreen blt bail"));
        goto SendScreenData;
    }

    // Send the drawstream bits, first round sending as secondary order
    if (OESendDrawStreamOrder(ppdev, drawStreamBitmapId, ulIn, pvIn, pptlDstOffset,
            &bounds, &clipRects)) {
        //DrvDebugPrint("JOYC: Send DrawStream Order\n");
        // We added an order to the list, increment global counts.
        goto PostSDA;
    }
    else {
        goto SendScreenData;
    }

SendScreenData:
    DrvDebugPrint("JOYC: DrawStream using SendScreenData\n");

    if ((psoTrg->hsurf == ppdev->hsurfFrameBuf) ||
            (!(pdsurfTrg->flags & DD_NO_OFFSCREEN))) {
        // Send a switch surface PDU if the destination surface is different
        // from last drawing order. If we failed to send the PDU, we will
        // just have to bail on this drawing order.
        if (!OESendSwitchSurfacePDU(ppdev, pdsurfTrg, 0)) {
            TRC_ERR((TB, "failed to send the switch surface PDU"));
            DC_QUIT;
        }
    }
    else {
        // If noOffscreen flag is on, we will bail on sending 
        // the client any further offscreen rendering. And we'll send the
        // final offscreen to screen blt as regular memblt.
        TRC_NRM((TB, "Offscreen blt bail"));

        //INC_OUTCOUNTER(OUT_BITBLT_NOOFFSCR);
        DC_QUIT;
    }

    if (psoTrg->hsurf == ppdev->hsurfFrameBuf) {
        //INC_OUTCOUNTER(OUT_BITBLT_SDA);
        OEClipAndAddScreenDataArea(&bounds, pco);
    }
    else {
        // if we can't send orders for offscreen rendering, we will 
        // bail offscreen support for this bitmap
        TRC_ALT((TB, "screen data call for offscreen rendering"));

        // Remove the bitmap from the offscreen bitmap cache
        if (!(pdsurfTrg->flags & DD_NO_OFFSCREEN))
            CH_RemoveCacheEntry(sbcOffscreenBitmapCacheHandle,
                    pdsurfTrg->bitmapId);

        DC_QUIT;
    }

PostSDA:
    
    SCH_DDOutputAvailable(ppdev, FALSE);

DC_EXIT_POINT:

    DC_END_FN();
    return rc;
}
#endif
#endif //DRAW_NINEGRID

#ifdef DRAW_GDIPLUS
// DrawGdiPlus
ULONG DrawGdiPlus(
    IN SURFOBJ  *pso,
    IN ULONG  iEsc,
    IN CLIPOBJ  *pco,
    IN RECTL  *prcl,
    IN ULONG  cjIn,
    IN PVOID  pvIn)
{
    SURFOBJ *psoTrgArg;
    SURFOBJ *psoSrcArg;
    PDD_PDEV ppdev = (PDD_PDEV)pso->dhpdev;
    PDD_DSURF pdsurf = NULL;
    BOOL rc = TRUE;

    DC_BEGIN_FN("DrawGdiplus");
    //    The callers should check this. Asserting they do.
    TRC_ASSERT((pddShm != NULL),(TB, "DrawGdiPlus called when pddShm is NULL"))
        
    // Sometimes, we're called after being disconnected.
    if (ddConnected) {
        // Surface is non-NULL.
        pso = OEGetSurfObjBitmap(pso, &pdsurf);

        if ((pso->hsurf == ppdev->hsurfFrameBuf) || 
                (!(pdsurf->flags & DD_NO_OFFSCREEN))) {
            // Send a switch surface PDU if the destination surface is
            // different from last drawing order. If we failed to send the
            // PDU, we will just have to bail on this drawing order.
            if (!OESendSwitchSurfacePDU(ppdev, pdsurf)) {
                TRC_ERR((TB, "failed to send the switch surface PDU"));
                DC_QUIT;
            }
        } else {
            // if noOffscreen flag is on, we will bail on sending 
            // the client any further offscreen rendering.  And will send the final
            // offscreen to screen blt as regular memblt.
            TRC_NRM((TB, "Offscreen blt bail"));
            DC_QUIT;
        }
    } else {
        TRC_ERR((TB, "Called when disconnected"));
        DC_QUIT;
    }
        
    // Create and Send DrawGdiplus Order
    if (OECreateDrawGdiplusOrder(ppdev, prcl, cjIn, pvIn)) {
        goto PostSDA;
    }
    // Send screen data when OECreateDrawGdiplusOrder fails
    OEClipAndAddScreenDataArea(prcl, NULL);
PostSDA:
    // All done: consider sending the output.
    SCH_DDOutputAvailable(ppdev, FALSE);

DC_EXIT_POINT:
    
    DC_END_FN();
    return rc;
}


/****************************************************************************/
// DrvDrawEscape - see NT DDK documentation.
/****************************************************************************/
ULONG DrvDrawEscape(
    IN SURFOBJ  *pso,
    IN ULONG  iEsc,
    IN CLIPOBJ  *pco,
    IN RECTL  *prcl,
    IN ULONG  cjIn,
    IN PVOID  pvIn)
{
    PDD_PDEV ppdev = (PDD_PDEV)pso->dhpdev;

    DC_BEGIN_FN("DrvDrawEscape");
    
    TRC_NRM((TB, "DrvDrawEscape %d", iEsc));
    switch (iEsc) {
    case GDIPLUS_TS_QUERYVER:
        // Query the gdiplus version
        // DDraw only support 8, 16, 24, 32 bpp
        if ((ppdev->cClientBitsPerPel != 8) &&
            (ppdev->cClientBitsPerPel != 16) &&
            (ppdev->cClientBitsPerPel != 24) &&
            (ppdev->cClientBitsPerPel != 32)) {
            TRC_ERR((TB, "The DDrawColor does not support the color depth %d", 
                                                    ppdev->cClientBitsPerPel));
            return 0;
        }
           
        if (ppdev->SectionObject == NULL) {
            TRC_ERR((TB, "The section memory is not allocated"));
            return 0;
        }

        if (pddShm == NULL) {
            TRC_ERR((TB, "The pddShm is NULL"));
            return 0;
        }
        
        if (pddShm->sbc.drawGdiplusInfo.supportLevel > TS_DRAW_GDIPLUS_DEFAULT) {
            TRC_NRM((TB, "Gdiplus version is %d", pddShm->sbc.drawGdiplusInfo.GdipVersion));
            return pddShm->sbc.drawGdiplusInfo.GdipVersion;
        }
        else {
            TRC_ERR((TB, "TSDrawGdip not supported"));
            return 0;
        }
        break;
    case GDIPLUS_TS_RECORD:
        // Send out the Gdiplus EMF+ record
        // DDraw only support 8, 16, 24, 32 bpp
        if ((ppdev->cClientBitsPerPel != 8) &&
            (ppdev->cClientBitsPerPel != 16) &&
            (ppdev->cClientBitsPerPel != 24) &&
            (ppdev->cClientBitsPerPel != 32)) {
            TRC_ERR((TB, "The DDrawColor does not support the color depth %d", 
                                                    ppdev->cClientBitsPerPel));
            return 0;
        }
        
        if (pddShm == NULL) {
            TRC_ERR((TB, "The pddShm is NULL !"));
            return 0;
        }
        
        if (ppdev->SectionObject == NULL) {
            TRC_ERR((TB, "Called when Gdiplus is not supported!"));
            return 0;
        }
           
        if (pddShm->sbc.drawGdiplusInfo.supportLevel > TS_DRAW_GDIPLUS_DEFAULT) {
            TRC_ASSERT((pvIn != NULL), (TB, "DrvDrawEscape gets NULL data"))
            TRC_ASSERT((cjIn != 0), (TB, "DrvDrawEscape gets data with size 0"))
            return DrawGdiPlus(pso, iEsc, pco, prcl, cjIn, pvIn);
        }
        else {
            TRC_ERR((TB, "TSDrawGdip not supported"));
            return 0;
        }
    default :
        TRC_ERR((TB, "DrvDrawEscape %d not supported", iEsc));
        return 0;
    }
    DC_END_FN()
}
#endif // DRAW_GDIPLUS



/****************************************************************************/
// DrvTextOut - see NT DDK documentation.
/****************************************************************************/
BOOL RDPCALL DrvTextOut(
        SURFOBJ  *pso,
        STROBJ   *pstro,
        FONTOBJ  *pfo,
        CLIPOBJ  *pco,
        RECTL    *prclExtra,
        RECTL    *prclOpaque,
        BRUSHOBJ *pboFore,
        BRUSHOBJ *pboOpaque,
        POINTL   *pptlOrg,
        MIX       mix)
{
    BOOL rc;
    RECTL rectTrg;
    PDD_PDEV ppdev = (PDD_PDEV)pso->dhpdev;
    PDD_DSURF pdsurf = NULL;
    PFONTCACHEINFO pfci;
    OE_ENUMRECTS ClipRects;

    DC_BEGIN_FN("DrvTextOut");

    rc = TRUE;

    // Sometimes, we're called after being disconnected.
    if (ddConnected && pddShm != NULL) {
        // Surface is non-NULL.
        pso = OEGetSurfObjBitmap(pso, &pdsurf);
        INC_OUTCOUNTER(OUT_TEXTOUT_ALL);

        if (((pco == NULL) && (pso->sizlBitmap.cx >= prclOpaque->right) &&
                (pso->sizlBitmap.cy >= prclOpaque->bottom)) ||
                ((pco != NULL) && (pso->sizlBitmap.cx >= pco->rclBounds.right) &&
                (pso->sizlBitmap.cy >= pco->rclBounds.bottom))) {
        
            // Let GDI to do the local drawing.
            rc = EngTextOut(pso, pstro, pfo, pco, prclExtra, prclOpaque, pboFore,
                    pboOpaque, pptlOrg, mix);
        }
        else {
            // If the bounding rectangle is greater the frame buffer, something
            // is really wrong here.  This means the desktop surface size and
            // the framebuffer is not matched up.  We need to bail out here.
            rc = FALSE;
        }
        

        if (rc) {
            if ((pso->hsurf == ppdev->hsurfFrameBuf) || 
                    (!(pdsurf->flags & DD_NO_OFFSCREEN))) {
                // Send a switch surface PDU if the destination surface is different
                // from last drawing order.  If we failed to send the PDU, we will 
                // just have to bail on this drawing order.
                if (!OESendSwitchSurfacePDU(ppdev, pdsurf)) {
                    TRC_ERR((TB, "failed to send the switch surface PDU"));
                    DC_QUIT;
                }
            } else {
                // if noOffscreen flag is on, we will bail on sending the
                // client any further offscreen rendering. And will send the
                // final offscreen to screen blt as regular memblt.
                TRC_NRM((TB, "Offscreen blt bail"));
                DC_QUIT;
            }

            // Check we have a valid string.
            if (pstro->pwszOrg != NULL) {
                if (OEGetClipRects(pco, &ClipRects)) {


                    // Special case when the clipobj is not correct.
                    // When rdpdd is used as a mirroring driver the Mul layer
                    // will modify the CLIPOBJ and in some cases we get a complex
                    // CLIPOBJ but the enumeration gives no rectangles.
                    // If it happens then don't draw anything.
                    // We test only the DC_COMPLEX case because in that case we
                    // are supposed to always get at least one rect.
                    // If it's DC_RECT we always have one rect without enumeration,
                    // so no need to test it (see OEGetClipRects).
                    // If it's DC_TRIVIAL we have to draw it, so don't test it.
                    if ((pco != NULL) &&
                        (pco->iDComplexity == DC_COMPLEX) &&
                        (ClipRects.rects.c == 0)) {

                        TRC_NRM((TB, "Complex CLIPOBJ without any rects"));

                        DC_QUIT;
                    }

                    // Check that we don't have any modifier rects on the
                    // font.
                    if (prclExtra == NULL) {
                        // Get a ptr to this font's cached information.
                        pfci = OEGetFontCacheInfo(pfo);
                        if (pfci == NULL) {
                            TRC_NRM((TB, "Cannot allocate font cache info "
                                    "struct"));
                            INC_OUTCOUNTER(OUT_TEXTOUT_SDA_NOFCI);
                            goto SendAsSDA;
                        }
                    }
                    else {
                        TRC_NRM((TB, "Unsupported rects"));
                        INC_OUTCOUNTER(OUT_TEXTOUT_SDA_EXTRARECTS);
                        goto SendAsSDA;
                    }
                }
                else {
                    TRC_NRM((TB, "Clipping is too complex"));
                    INC_OUTCOUNTER(OUT_TEXTOUT_SDA_COMPLEXCLIP);
                    goto SendAsSDA;
                }
            }
            else {
                TRC_NRM((TB, "No string - opaque %p", prclOpaque));
                INC_OUTCOUNTER(OUT_TEXTOUT_SDA_NOSTRING);
                goto SendAsSDA;
            }
        }
        else {
            TRC_ERR((TB, "EngTextOut failed"));
            DC_QUIT;
        }
    }
    else {
        if (pso->iType == STYPE_DEVBITMAP) {
        
            pso = OEGetSurfObjBitmap(pso, &pdsurf);
        
            // Let GDI to do the local drawing.
            rc = EngTextOut(pso, pstro, pfo, pco, prclExtra, prclOpaque, pboFore,
                    pboOpaque, pptlOrg, mix);
        }
        else {
            TRC_ERR((TB, "Called when disconnected"));
        }
        
        goto CalledOnDisconnected;
    }

    // Process the request according to the glyph support level setting
    // we can attempt to send a Glyph order

    if (pddShm->sbc.caps.GlyphSupportLevel >= CAPS_GLYPH_SUPPORT_PARTIAL) {
        if (OE_SendGlyphs(pso, pstro, pfo, &ClipRects, prclOpaque, pboFore,
                pboOpaque, pptlOrg, pfci))
            goto PostSDA;
    }

SendAsSDA:
    // We reach here in the case we could not send for some reason.
    // Accumulate in screen data area.
    if (pso->hsurf == ppdev->hsurfFrameBuf) {
        INC_OUTCOUNTER(OUT_TEXTOUT_SDA);

        // Get bounding rectangle, convert to a RECT, and convert to
        // inclusive coordinates.
        if (prclOpaque != NULL) {
            RECT_FROM_RECTL(rectTrg, (*prclOpaque));
        } else {
            RECT_FROM_RECTL(rectTrg, pstro->rclBkGround);
            TRC_DBG((TB, "Using STROBJ bgd for size"));
        }

        OEClipRect(&rectTrg);
        ADD_INCOUNTER(IN_SDA_TEXTOUT_AREA, COM_SIZEOF_RECT(rectTrg));
        
        // Output to SDA
        OEClipAndAddScreenDataArea(&rectTrg, pco);
    }
    else {
        // If we can't send orders for offscreen rendering, we will 
        // bail offscreen support for this bitmap.
        TRC_ALT((TB, "screen data call for offscreen rendering"));
        if (!(pdsurf->flags & DD_NO_OFFSCREEN))
            CH_RemoveCacheEntry(sbcOffscreenBitmapCacheHandle,
                    pdsurf->bitmapId);

        DC_QUIT;
    }

PostSDA:
    // All done: consider sending the output.
    SCH_DDOutputAvailable(ppdev, FALSE);

CalledOnDisconnected:
DC_EXIT_POINT:

    DC_END_FN();
    return rc;
}


/****************************************************************************/
// DrvDestroyFont - see NT DDK documentation.
/****************************************************************************/
VOID DrvDestroyFont(FONTOBJ *pfo)
{
    FONTCACHEINFO *pfci;

    DC_BEGIN_FN("DrvDestroyFont");

    pfci = pfo->pvConsumer;

    if (pfci != NULL) {
        if (pddShm != NULL && pfci->cacheHandle)
            pddShm->sbc.glyphCacheInfo[pfci->cacheId].cbUseCount--;

        if (sbcFontCacheInfoList != NULL && 
                sbcFontCacheInfoList[pfci->listIndex] == pfci) {
            sbcFontCacheInfoList[pfci->listIndex] = NULL;
        }
        EngFreeMem(pfci);
        pfo->pvConsumer = NULL;
    }

    DC_END_FN();
}


/****************************************************************************/
// DrvLineTo - see NT DDK documentation.
/****************************************************************************/
BOOL RDPCALL DrvLineTo(
        SURFOBJ  *pso,
        CLIPOBJ  *pco,
        BRUSHOBJ *pbo,
        LONG     x1,
        LONG     y1,
        LONG     x2,
        LONG     y2,
        RECTL    *prclBounds,
        MIX      mix)
{
    PDD_PDEV ppdev = (PDD_PDEV)pso->dhpdev;
    PDD_DSURF pdsurf = NULL;
    BOOL rc = TRUE;
    RECTL rectTrg;
    POINTL startPoint;
    POINTL endPoint;
    OE_ENUMRECTS ClipRects;

    DC_BEGIN_FN("DrvLineTo");

    // Sometimes, we're called after being disconnected.
    if (ddConnected && pddShm != NULL) {
        // Surface is non-NULL.
        pso = OEGetSurfObjBitmap(pso, &pdsurf);
        INC_OUTCOUNTER(OUT_LINETO_ALL);

        // Get bounding rectangle and clip to 16-bit wire size.
        RECT_FROM_RECTL(rectTrg, (*prclBounds));
        OEClipRect(&rectTrg);

        // Punt the call back to GDI to do the drawing.
        rc = EngLineTo(pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix);
        if (rc) {
            if ((pso->hsurf == ppdev->hsurfFrameBuf) || 
                    (!(pdsurf->flags & DD_NO_OFFSCREEN))) {
                // Send a switch surface PDU if the destination surface is
                // different from last drawing order. If we failed to send the
                // PDU, we will just have to bail on this drawing order.
                if (!OESendSwitchSurfacePDU(ppdev, pdsurf)) {
                    TRC_ERR((TB, "failed to send the switch surface PDU"));
                    DC_QUIT;
                }
            } else {
                // if noOffscreen flag is on, we will bail on sending 
                // the client any further offscreen rendering.  And will send the final
                // offscreen to screen blt as regular memblt.
                TRC_NRM((TB, "Offscreen blt bail"));
                DC_QUIT;
            }

            TRC_NRM((TB, "LINETO"));
        }
        else {
            TRC_ERR((TB, "EngLineTo failed"));
            DC_QUIT;
        }
    }
    else {
        if (pso->iType == STYPE_DEVBITMAP) {
            // Surface is non-NULL.
            pso = OEGetSurfObjBitmap(pso, &pdsurf);
        
            // Punt the call back to GDI to do the drawing.
            rc = EngLineTo(pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix);
        }
        else {
            TRC_ERR((TB, "Called when disconnected"));
        }
        goto CalledOnDisconnect;
    }

    // Check if we are allowed to send this order.
    if (OE_SendAsOrder(TS_ENC_LINETO_ORDER)) {
        // Check for a solid brush required for the order.
        if (pbo->iSolidColor != -1) {
            unsigned RetVal;

            // Get the intersection between the dest rect and the
            // clip rects. Check for overcomplicated or nonintersecting
            // clipping.
            RetVal = OEGetIntersectingClipRects(pco, &rectTrg,
                    CD_ANY, &ClipRects);
            if (RetVal == CLIPRECTS_OK) {
                // Set up data for order.
                startPoint.x = x1;
                startPoint.y = y1;
                endPoint.x   = x2;
                endPoint.y   = y2;
            }
            else if (RetVal == CLIPRECTS_TOO_COMPLEX) {
                TRC_NRM((TB, "Clipping is too complex"));
                INC_OUTCOUNTER(OUT_LINETO_SDA_COMPLEXCLIP);
                goto SendAsSDA;
            }
            else if (RetVal == CLIPRECTS_NO_INTERSECTIONS) {
                TRC_NRM((TB, "Clipping does not intersect destrect"));
                DC_QUIT;
            }
        }
        else {
            TRC_NRM((TB, "Bad brush for line"));
            INC_OUTCOUNTER(OUT_LINETO_SDA_BADBRUSH);
            goto SendAsSDA;
        }
    }
    else {
        TRC_NRM((TB, "LineTo order not allowed"));
        INC_OUTCOUNTER(OUT_LINETO_SDA_UNSUPPORTED);
        goto SendAsSDA;
    }

    // Store the order.
    if (OEEncodeLineToOrder(ppdev, &startPoint, &endPoint, mix & 0x1F,
            pbo->iSolidColor, &ClipRects)) {
        goto PostSDA;
    }
    else {
        TRC_DBG((TB, "Failed to add order - use SDA"));
        INC_OUTCOUNTER(OUT_LINETO_SDA_FAILEDADD);
        goto SendAsSDA;
    }

SendAsSDA:
    // If we got here we could not send as an order, send as screen data
    // instead.
    if (pso->hsurf == ppdev->hsurfFrameBuf) {
        INC_OUTCOUNTER(OUT_LINETO_SDA);
        ADD_INCOUNTER(IN_SDA_LINETO_AREA, COM_SIZEOF_RECT(rectTrg));
        OEClipAndAddScreenDataArea(&rectTrg, pco);
    }
    else {
        // if we can't send orders for offscreen rendering, we will 
        // bail offscreen support for this bitmap
        TRC_ALT((TB, "screen data call for offscreen rendering"));
        if (!(pdsurf->flags & DD_NO_OFFSCREEN))
            CH_RemoveCacheEntry(sbcOffscreenBitmapCacheHandle, pdsurf->bitmapId);      

        DC_QUIT;
    }

PostSDA:
    // Have the scheduler consider flushing output.
    SCH_DDOutputAvailable(ppdev, FALSE);

CalledOnDisconnect:
DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}



/****************************************************************************/
// OEEmitReplayOrders
//
// Direct-encodes a series of replay-last primary orders.
/****************************************************************************/
BOOL OEEmitReplayOrders(
        PDD_PDEV ppdev,
        unsigned NumFieldFlagBytes,
        OE_ENUMRECTS *pClipRects)
{
    BOOL rc = TRUE;
    BYTE *pBuffer;
    unsigned i;
    unsigned NumRects;
    PINT_ORDER pOrder;

    DC_BEGIN_FN("OEEmitReplayOrders");

    // Since the first order took the first rect, emit replay orders for the
    // remaining rects.
    NumRects = pClipRects->rects.c;
    for (i = 1; i < NumRects; i++) {
        pOrder = OA_AllocOrderMem(ppdev, MAX_REPLAY_CLIPPED_ORDER_SIZE);
        if (pOrder != NULL) {
            pBuffer = pOrder->OrderData;

            // Control flags are primary order plus all field flag bytes zero.
            *pBuffer++ = TS_STANDARD | TS_BOUNDS |
                    (NumFieldFlagBytes << TS_ZERO_FIELD_COUNT_SHIFT);

            // Construct the new bounds rect just after this.
            OE2_EncodeBounds(pBuffer - 1, &pBuffer,
                    &pClipRects->rects.arcl[i]);

            pOrder->OrderLength = (unsigned)(pBuffer - pOrder->OrderData);

            INC_INCOUNTER(IN_REPLAY_ORDERS);
            ADD_INCOUNTER(IN_REPLAY_BYTES, pOrder->OrderLength);
            OA_AppendToOrderList(pOrder);

            TRC_DBG((TB,"Emit replay order for cliprect (%d,%d,%d,%d)",
                    pClipRects->rects.arcl[i].left,
                    pClipRects->rects.arcl[i].top,
                    pClipRects->rects.arcl[i].right,
                    pClipRects->rects.arcl[i].bottom));
        }
        else {
            TRC_ERR((TB,"Error allocating mem for replay order"));
            rc = FALSE;
            break;
        }
    }

    DC_END_FN();
    return rc;
}


/****************************************************************************/
// DrvStrokePath - see NT DDK documentation.
/****************************************************************************/

// Worker function - encodes a delta from one point to another in a minimal
// form in the PolyLine coded delta list. The encoding follows the
// following rules:
//   1. If a coordinate delta is zero, a flag is set saying so. This
//      closely follows the data distribution which tends to have vertical
//      and horizontal lines and so have a lot of zero deltas.
//   2. If we can pack the delta into 7 bits, do so, with the high bit
//      cleared. This is similar to ASN.1 PER encoding; the high bit is a
//      flag telling us whether the encoding is long.
//   3. Otherwise, we must be able to pack into 15 bits (fail if not);
//      do so and set the high-order bit to indicate this is a long
//      encoding. This differs from ASN.1 PER encoding in that we don't
//      allow more than 15 bits of data.
BOOL OEEncodePolyLinePointDelta(
        BYTE **ppCurEncode,
        unsigned *pNumDeltas,
        unsigned *pDeltaSize,
        BYTE *ZeroFlags,
        POINTL *pFromPoint,
        POINTL *pToPoint,
        RECTL *pBoundRect)
{
    int Delta;
    BYTE Zeros = 0;
    BYTE *pBuffer;
    unsigned EncodeLen;

    DC_BEGIN_FN("OEEncodePolyLinePointDelta");

    pBuffer = *ppCurEncode;

    Delta = pToPoint->x - pFromPoint->x;
    if (Delta == 0) {
        EncodeLen = 0;
        Zeros |= ORD_POLYLINE_XDELTA_ZERO;
    }
    else if (Delta >= -64 && Delta <= 63) {
        *pBuffer++ = (BYTE)(Delta & 0x7F);
        EncodeLen = 1;
    }
    else {
        // This is ugly, but necessitated by some stress-type apps that
        // will send us a large coordinate and expect us to clip it. In an
        // ideal world we would actually clip the line coordinates to the
        // clip rectangle given us in DrvStrokePath and recalc the deltas
        // based on the new line endpoints. However, since no normal apps
        // seem to send these bad lines, we simply clip the delta and hope
        // the slope of the resulting line is similar to the slope from the
        // original delta.
        if (Delta >= -16384 && Delta <= 16384) {
            *pBuffer++ = (BYTE)((Delta >> 8) | ORD_POLYLINE_LONG_DELTA);
            *pBuffer++ = (BYTE)(Delta & 0xFF);
            EncodeLen = 2;
        }
        else {
            TRC_ALT((TB,"X delta %d too large/small to encode", Delta));
            return FALSE;
        }
    }

    Delta = pToPoint->y - pFromPoint->y;
    if (Delta == 0) {
        Zeros |= ORD_POLYLINE_YDELTA_ZERO;
    }
    else if (Delta >= -64 && Delta <= 63) {
        *pBuffer++ = (BYTE)(Delta & 0x7F);
        EncodeLen += 1;
    }
    else {
        // See comments for the similar code above.
        if (Delta >= -16384 && Delta <= 16384) {
            *pBuffer++ = (BYTE)((Delta >> 8) | ORD_POLYLINE_LONG_DELTA);
            *pBuffer++ = (BYTE)(Delta & 0xFF);
            EncodeLen += 2;
        }
        else {
            TRC_ALT((TB,"Y delta %d too large/small to encode", Delta));
            return FALSE;
        }
    }

    // Set the zero flags by shifting the two bits we've accumulated.
    ZeroFlags[(*pNumDeltas / 4)] |= (Zeros >> (2 * (*pNumDeltas & 0x03)));

    *pNumDeltas += 1;
    *pDeltaSize += EncodeLen;
    *ppCurEncode = pBuffer;

    // Update the bounding rect (exclusive coords).
    if (pToPoint->x < pBoundRect->left)
        pBoundRect->left = pToPoint->x;
    else if ((pToPoint->x + 1) >= pBoundRect->right)
        pBoundRect->right = pToPoint->x + 1;
    if (pToPoint->y < pBoundRect->top)
        pBoundRect->top = pToPoint->y;
    else if ((pToPoint->y + 1) >= pBoundRect->bottom)
        pBoundRect->bottom = pToPoint->y + 1;

    DC_END_FN();
    return TRUE;
}

// Worker function to allocate and direct-encode a PolyLine order.
// Note that the subpathing of a PolyLine makes it possible for
// the entire order to be clipped out by part of the clip rectangles.
// We cannot encode these clipped orders since they change the
// direct-encode state. To counter this we receive as a parameter the list of
// clip rects, and we don't allocate and create the order if it will be
// entirely clipped. Returns TRUE if there was no problem allocating space
// for the order (clipping the order completely is not an error).
BOOL OECreateAndFlushPolyLineOrder(
        PDD_PDEV ppdev,
        RECTL *pBoundRect,
        OE_ENUMRECTS *pClipRects,
        POINTL *pStartPoint,
        BRUSHOBJ *pbo,
        CLIPOBJ *pco,
        unsigned ROP2,
        unsigned NumDeltas,
        unsigned DeltaSize,
        BYTE *Deltas,
        BYTE *ZeroFlags)
{
    BOOL rc = TRUE;
    unsigned i, NumRects;
    unsigned NumZeroFlagBytes;
    PINT_ORDER pOrder;
    OE_ENUMRECTS IntersectRects;

    DC_BEGIN_FN("OECreateAndFlushPolyLineOrder");

    // First check to see if the order is completely clipped by the
    // rects returned by the clip object. pBoundRect is exclusive.
    IntersectRects.rects.c = 0;
    if (pClipRects->rects.c == 0 ||
            OEGetIntersectionsWithClipRects(pBoundRect, pClipRects,
            &IntersectRects) > 0) {
        // Round the number of zero flag bits actually used upward to the
        // nearest byte. Each point encoded takes two bits.
        NumZeroFlagBytes = (NumDeltas + 3) / 4;
        TRC_ASSERT((NumZeroFlagBytes <= ORD_MAX_POLYLINE_ZERO_FLAGS_BYTES),
                   (TB,"Too many zero-flags bytes"));
        TRC_ASSERT((NumDeltas <= ORD_MAX_POLYLINE_ENCODED_POINTS),
                   (TB,"Too many encoded orders"));
        TRC_ASSERT((DeltaSize <= ORD_MAX_POLYLINE_CODEDDELTAS_LEN),
                   (TB,"Too many encoded delta bytes"));

        // 1 field flag byte.
        pOrder = OA_AllocOrderMem(ppdev, MAX_ORDER_SIZE(IntersectRects.rects.c,
                1, MAX_POLYLINE_BASE_FIELDS_SIZE + 1 + NumZeroFlagBytes +
                DeltaSize));
        if (pOrder != NULL) {
            BYTE *pControlFlags = pOrder->OrderData;
            BYTE *pBuffer = pControlFlags + 1;
            BYTE *pFieldFlags;
            short Delta, NormalCoordEncoding[2];
            BOOLEAN bUseDeltaCoords;
            unsigned NumFields;
            DCCOLOR Color;
            unsigned TotalSize;

            // Direct-encode the primary order fields. 1 field flag byte.
            *pControlFlags = TS_STANDARD;
            OE2_EncodeOrderType(pControlFlags, &pBuffer,
                    TS_ENC_POLYLINE_ORDER);
            pFieldFlags = pBuffer;
            *pFieldFlags = 0;
            pBuffer++;
            if (IntersectRects.rects.c != 0)
                OE2_EncodeBounds(pControlFlags, &pBuffer,
                        &IntersectRects.rects.arcl[0]);

            // Inline field encode directly to wire format.
            // Simultaneously determine if each of the coordinate fields has
            // changed, whether we can use delta coordinates, and save changed
            // fields.
            NumFields = 0;
            bUseDeltaCoords = TRUE;

            // XStart
            Delta = (short)(pStartPoint->x - PrevPolyLine.XStart);
            if (Delta) {
                PrevPolyLine.XStart = pStartPoint->x;
                if (Delta != (short)(char)Delta)
                    bUseDeltaCoords = FALSE;
                pBuffer[NumFields] = (char)Delta;
                NormalCoordEncoding[NumFields] = (short)pStartPoint->x;
                NumFields++;
                *pFieldFlags |= 0x01;
            }

            // YStart
            Delta = (short)(pStartPoint->y - PrevPolyLine.YStart);
            if (Delta) {
                PrevPolyLine.YStart = pStartPoint->y;
                if (Delta != (short)(char)Delta)
                    bUseDeltaCoords = FALSE;
                pBuffer[NumFields] = (char)Delta;
                NormalCoordEncoding[NumFields] = (short)pStartPoint->y;
                NumFields++;
                *pFieldFlags |= 0x02;
            }

            // Copy the final coordinates to the order.
            if (bUseDeltaCoords) {
                *pControlFlags |= TS_DELTA_COORDINATES;
                pBuffer += NumFields;
            }
            else {
                *((DWORD UNALIGNED *)pBuffer) =
                        *((DWORD *)NormalCoordEncoding);
                pBuffer += NumFields * sizeof(short);
            }

            // ROP2
            if (ROP2 != PrevPolyLine.ROP2) {
                PrevPolyLine.ROP2 = ROP2;
                *pBuffer++ = (BYTE)ROP2;
                *pFieldFlags |= 0x04;
            }
        
            // BrushCacheEntry. This field is currently unused. We simply choose
            // always to send zero, which means we can skip the field for
            // the encoding. This is field encoding flag 0x08.

            // PenColor is a 3-byte color field.
            OEConvertColor(ppdev, &Color, pbo->iSolidColor, NULL);
            if (memcmp(&Color, &PrevPolyLine.PenColor, sizeof(Color))) {
                PrevPolyLine.PenColor = Color;
                *pBuffer++ = Color.u.rgb.red;
                *pBuffer++ = Color.u.rgb.green;
                *pBuffer++ = Color.u.rgb.blue;
                *pFieldFlags |= 0x10;
            }

            // NumDeltaEntries
            if (NumDeltas != PrevPolyLine.NumDeltaEntries) {
                PrevPolyLine.NumDeltaEntries = NumDeltas;
                *pBuffer++ = (BYTE)NumDeltas;
                *pFieldFlags |= 0x20;
            }
        
            // CodedDeltaList - a variable-length byte stream. First 1-byte
            // value is the count of bytes, followed by the zero flags and
            // then the deltas. This field is considered different from the
            // previous if the length or the contents are different.
            *pBuffer = (BYTE)(DeltaSize + NumZeroFlagBytes);
            memcpy(pBuffer + 1, ZeroFlags, NumZeroFlagBytes);
            memcpy(pBuffer + 1 + NumZeroFlagBytes, Deltas, DeltaSize);
            TotalSize = 1 + NumZeroFlagBytes + DeltaSize;
            if (memcmp(pBuffer, &PrevPolyLine.CodedDeltaList, TotalSize)) {
                memcpy(&PrevPolyLine.CodedDeltaList, pBuffer, TotalSize);
                pBuffer += TotalSize;
                *pFieldFlags |= 0x40;
            }

            pOrder->OrderLength = (unsigned)(pBuffer - pOrder->OrderData);

            // See if we can save sending the order field bytes.
            pOrder->OrderLength -= OE2_CheckOneZeroFlagByte(pControlFlags,
                    pFieldFlags, (unsigned)(pBuffer - pFieldFlags - 1));

            INC_OUTCOUNTER(OUT_STROKEPATH_POLYLINE);
            ADD_INCOUNTER(IN_POLYLINE_BYTES, pOrder->OrderLength);
            OA_AppendToOrderList(pOrder);

            // Flush the order.
            if (IntersectRects.rects.c < 2)
                rc = TRUE;
            else
                rc = OEEmitReplayOrders(ppdev, 1, &IntersectRects);
        }
        else {
            TRC_ERR((TB,"Failed to alloc space for order"));
            rc = FALSE;
        }
    }
    else {
        TRC_DBG((TB,"Clipping PolyLine order - no intersecting clip rects"));
    }

    DC_END_FN();
    return rc;
}

// Worker function - combines the chore of allocating EllipseSC order from
// the OA heap and contructing the order given the parameters. Then we give
// the order to OE to finish encoding. Returns TRUE on success (meaning no
// error allocating from the order heap).
BOOL OECreateAndFlushEllipseSCOrder(
        PDD_PDEV ppdev,
        RECT *pEllipseRect,
        BRUSHOBJ *pbo,
        OE_ENUMRECTS *pClipRects,
        unsigned ROP2,
        FLONG flOptions)
{
    BOOL rc = TRUE;
    PINT_ORDER pOrder;
    PELLIPSE_SC_ORDER pEllipseSC;
    OE_ENUMRECTS IntersectRects;
    RECTL ExclusiveRect;

    DC_BEGIN_FN("OECreateAndFlushEllipseSCOrder");

    // EllipseRect is inclusive, we need exclusive for getting clip rects.
    ExclusiveRect = *((RECTL *)pEllipseRect);
    ExclusiveRect.right++;
    ExclusiveRect.bottom++;

    // First make sure the clip rects actually intersect with the ellipse
    // after its target screen rect has been calculated. Note that
    // *pEllipseRect is already in inclusive coords.
    IntersectRects.rects.c = 0;
    if (pClipRects->rects.c == 0 ||
            OEGetIntersectionsWithClipRects(&ExclusiveRect, pClipRects,
            &IntersectRects) > 0) {
        // 1 field flag byte.
        pOrder = OA_AllocOrderMem(ppdev, MAX_ORDER_SIZE(IntersectRects.rects.c,
                1, MAX_ELLIPSE_SC_FIELD_SIZE));
        if (pOrder != NULL) {
            // Set up the order fields in the temp buffer.
            pEllipseSC = (PELLIPSE_SC_ORDER)oeTempOrderBuffer;
            pEllipseSC->LeftRect = pEllipseRect->left;
            pEllipseSC->RightRect = pEllipseRect->right;
            pEllipseSC->TopRect = pEllipseRect->top;
            pEllipseSC->BottomRect = pEllipseRect->bottom;
            pEllipseSC->ROP2 = ROP2;
            pEllipseSC->FillMode = flOptions;
            OEConvertColor(ppdev, &pEllipseSC->Color, pbo->iSolidColor, NULL);

            // Slow-field-encode the order with the first clip rect
            // (if present).
            pOrder->OrderLength = OE2_EncodeOrder(pOrder->OrderData,
                    TS_ENC_ELLIPSE_SC_ORDER, NUM_ELLIPSE_SC_FIELDS,
                    (BYTE *)pEllipseSC, (BYTE *)&PrevEllipseSC, etable_EC,
                    (IntersectRects.rects.c == 0 ? NULL :
                    &IntersectRects.rects.arcl[0]));

            ADD_INCOUNTER(IN_ELLIPSE_SC_BYTES, pOrder->OrderLength);
            OA_AppendToOrderList(pOrder);

            // Flush the order.
            if (IntersectRects.rects.c < 2)
                rc = TRUE;
            else
                rc = OEEmitReplayOrders(ppdev, 1, &IntersectRects);
        }
        else {
            TRC_ERR((TB,"Failed to alloc order heap space for ellipse"));
            rc = FALSE;
        }
    }
    else {
        // We still return TRUE here since the order was handled OK, just not
        // sent.
        TRC_NRM((TB,"Ellipse does not intersect with cliprects"));
    }

    DC_END_FN();
    return rc;
}

// The real function.
BOOL RDPCALL DrvStrokePath(
        SURFOBJ   *pso,
        PATHOBJ   *ppo,
        CLIPOBJ   *pco,
        XFORMOBJ  *pxo,
        BRUSHOBJ  *pbo,
        POINTL    *pptlBrushOrg,
        LINEATTRS *plineattrs,
        MIX       mix)
{
    PDD_PDEV ppdev = (PDD_PDEV)pso->dhpdev;
    PDD_DSURF pdsurf = NULL;
    BOOL rc = TRUE;
    RECTFX rectfxTrg;
    RECTL rectTrg;
    BOOL fMore = TRUE;
    PATHDATA pathData;
    POINTL originPoint;
    POINTL startPoint;
    POINTL nextPoint;
    POINTL endPoint;
    unsigned pathIndex;
    OE_ENUMRECTS ClipRects;

    DC_BEGIN_FN("DrvStrokePath");

    // Sometimes, we're called after being disconnected.
    if (ddConnected && pddShm != NULL) {
        // Surface is non-NULL.
        pso = OEGetSurfObjBitmap(pso, &pdsurf);

        // Get bounding rectangle.
        PATHOBJ_vGetBounds(ppo, &rectfxTrg);
        RECT_FROM_RECTFX(rectTrg, rectfxTrg);

        // Punt the call back to GDI to do the drawing.
        INC_OUTCOUNTER(OUT_STROKEPATH_ALL);

        rc = EngStrokePath(pso, ppo, pco, pxo, pbo, pptlBrushOrg, plineattrs,
                mix);
        if (!rc) {
            TRC_ERR((TB, "EngStrokePath failed"));
            DC_QUIT;
        }

        // if the path bound gives empty rect, we'll just ignore
        if (rectTrg.left == 0 && rectTrg.right == 0 &&
                rectTrg.top == 0 && rectTrg.bottom == 0) {
            TRC_ERR((TB, "Empty Path obj bounding rect, ignore"));
            DC_QUIT;
        }
    }
    else {
        if (pso->iType == STYPE_DEVBITMAP) {
        
            // Surface is non-NULL.
            pso = OEGetSurfObjBitmap(pso, &pdsurf);

            rc = EngStrokePath(pso, ppo, pco, pxo, pbo, pptlBrushOrg, plineattrs,
                    mix);
        }
        else {
            TRC_ERR((TB, "Called when disconnected"));
        }
        goto CalledOnDisconnected;
    }

    if ((pso->hsurf == ppdev->hsurfFrameBuf) || 
            (!(pdsurf->flags & DD_NO_OFFSCREEN))) {
        // Send a switch surface PDU if the destination surface is different
        // from last drawing order. If we failed to send the PDU, we will 
        // just have to bail on this drawing order.
        if (!OESendSwitchSurfacePDU(ppdev, pdsurf)) {
            TRC_ERR((TB, "failed to send the switch surface PDU"));
            DC_QUIT;
        }
    } else {
        // if noOffscreen flag is on, we will bail on sending 
        // the client any further offscreen rendering.  And will send the final
        // offscreen to screen blt as regular memblt.
        TRC_NRM((TB, "Offscreen blt bail"));
        DC_QUIT;
    }

    // Check if we are allowed to send this order.
    if (OE_SendAsOrder(TS_ENC_POLYLINE_ORDER)) {
        // Check for a valid brush for the test operation.
        if (pbo->iSolidColor != -1) {
            unsigned RetVal;

            // Get the intersection between the entire dest rect and
            // the clip rects. Check for overcomplicated or
            // nonintersecting clipping. Note this is a first cut,
            // further interactions are calculated for each PolyLine
            // subpath and ellipse created.
            RetVal = OEGetIntersectingClipRects(pco, &rectTrg, CD_ANY,
                    &ClipRects);
            if (RetVal == CLIPRECTS_TOO_COMPLEX) {
                TRC_NRM((TB, "Clipping is too complex"));
                INC_OUTCOUNTER(OUT_STROKEPATH_SDA_COMPLEXCLIP);
                goto SendAsSDA;
            }
            else if (RetVal == CLIPRECTS_NO_INTERSECTIONS) {
                TRC_NRM((TB, "Clipping does not intersect destrect"));
                DC_QUIT;

            }
        }
        else {
            TRC_NRM((TB, "Bad brush for line"));
            INC_OUTCOUNTER(OUT_STROKEPATH_SDA_BADBRUSH);
            goto SendAsSDA;
        }
    }
    else {
        TRC_NRM((TB, "PolyLine order not allowed"));
        INC_OUTCOUNTER(OUT_STROKEPATH_SDA_NOLINETO);
        goto SendAsSDA;
    }

    // See if we can optimize the path...
    // We cannot send beziers, geometric lines, or nonstandard patterns.
    if (ppo->fl & PO_ELLIPSE &&
            OE_SendAsOrder(TS_ENC_ELLIPSE_SC_ORDER)) {
        RECT EllipseRect;

        // Get the inclusive rect covering only the ellipse itself.
        // Add 4/16 to left and top, subtract from right and bottom, to undo
        // the GDI transformation already performed.
        EllipseRect.left = FXTOLROUND(rectfxTrg.xLeft + 4);
        EllipseRect.top = FXTOLROUND(rectfxTrg.yTop + 4);
        EllipseRect.right = FXTOLROUND(rectfxTrg.xRight - 4);
        EllipseRect.bottom = FXTOLROUND(rectfxTrg.yBottom - 4);

        // We use fillmode 0 to indidate this is a polyline ellipse.
        if (OECreateAndFlushEllipseSCOrder(ppdev, &EllipseRect, pbo,
                &ClipRects, mix & 0x1F, 0)) {
            INC_OUTCOUNTER(OUT_STROKEPATH_ELLIPSE_SC);
            goto PostSDA;
        }
        else {
            // No order heap space, send all as SDAs.
            INC_OUTCOUNTER(OUT_STROKEPATH_SDA_FAILEDADD);
            goto SendAsSDA;
        }
    }

    else if (!(ppo->fl & PO_BEZIERS) &&
            !(plineattrs->fl & LA_GEOMETRIC) &&
            plineattrs->pstyle == NULL) {
        BYTE Deltas[ORD_MAX_POLYLINE_CODEDDELTAS_LEN];
        BYTE ZeroFlags[ORD_MAX_POLYLINE_ZERO_FLAGS_BYTES];
        BYTE *pCurEncode;
        RECTL BoundRect;
        POINTL HoldPoint;
        unsigned NumDeltas;
        unsigned DeltaSize;

        // This is a set of solid cosmetic (i.e.  no fancy end styles)
        // width-1 lines. NT stores all paths as a set of independent
        // sub-paths. Each sub-path can start at a new point that is NOT
        // linked to the previous sub-path. Paths used for this function
        // (as opposed to DrvFillPath or DrvStrokeAndFillPath) do not need
        // to be closed. We assume that the first enumerated subpath will
        // have the PD_BEGINSUBPATH flag set; this appears to match reality.
        PATHOBJ_vEnumStart(ppo);

        while (fMore) {
            // Get the next set of lines.
            fMore = PATHOBJ_bEnum(ppo, &pathData);

            TRC_DBG((TB, "PTS: %lu FLAG: %08lx",
                         pathData.count,
                         pathData.flags));

            // If this is the start of a path, remember the origin point in
            // case we need to close the path at the end. startPoint is the
            // start point for the current PolyLine order in the rare case
            // where we have more than MAX_POLYLINE_ENCODED_POINTS points.
            if (pathData.flags & PD_BEGINSUBPATH) {
                POINT_FROM_POINTFIX(originPoint, pathData.pptfx[0]);
                nextPoint = originPoint;
                startPoint = originPoint;

                // Set up encoding variables. Start the bound rect with
                // a zero-size rect.
                BoundRect.left = BoundRect.right = startPoint.x;
                BoundRect.top = BoundRect.bottom = startPoint.y;
                NumDeltas = DeltaSize = 0;
                pCurEncode = Deltas;
                memset(ZeroFlags, 0, sizeof(ZeroFlags));
                pathIndex = 1;
            }
            else {
                // This is a continuation from a previous PATHDATA.
                nextPoint = HoldPoint;
                pathIndex = 0;
            }

            // Generate deltas for each point in the path.
            for (; pathIndex < pathData.count; pathIndex++) {
                POINT_FROM_POINTFIX(endPoint, pathData.pptfx[pathIndex]);

                // Don't try to encode points where both deltas are zero.
                if ((nextPoint.x != endPoint.x) ||
                        (nextPoint.y != endPoint.y)) {
                    if (OEEncodePolyLinePointDelta(&pCurEncode, &NumDeltas,
                            &DeltaSize, ZeroFlags, &nextPoint, &endPoint,
                            &BoundRect)) {
                        // Check for full order and flush if need be.
                        if (NumDeltas == ORD_MAX_POLYLINE_ENCODED_POINTS) {
                            if (OECreateAndFlushPolyLineOrder(ppdev,
                                    &BoundRect, &ClipRects, &startPoint, pbo,
                                    pco, mix & 0x1F, NumDeltas, DeltaSize,
                                    Deltas, ZeroFlags)) {
                                // We have a new temporary start point in the
                                // middle of the path.
                                startPoint = endPoint;

                                // Reset encoding variables.
                                BoundRect.left = BoundRect.right = startPoint.x;
                                BoundRect.top = BoundRect.bottom = startPoint.y;
                                NumDeltas = DeltaSize = 0;
                                pCurEncode = Deltas;
                                memset(ZeroFlags, 0, sizeof(ZeroFlags));
                            } else {
                                // No order heap space, send all as SDAs.
                                INC_OUTCOUNTER(OUT_STROKEPATH_SDA_FAILEDADD);
                                goto SendAsSDA;
                            }
                        }
                    }
                    else {
                        goto SendAsSDA;
                    }
                }

                nextPoint = endPoint;
            }

            // Close the path if necessary.
            if (pathData.flags & PD_CLOSEFIGURE) {
                // Don't try to encode points where both deltas are zero.
                if ((nextPoint.x != originPoint.x) ||
                        (nextPoint.y != originPoint.y)) {
                    if (!OEEncodePolyLinePointDelta(&pCurEncode, &NumDeltas,
                            &DeltaSize, ZeroFlags, &nextPoint, &originPoint,
                            &BoundRect)) {
                        goto SendAsSDA;
                    }
                }

                // PD_CLOSEFIGURE is present only with PD_ENDSUBPATH but
                // just in case...
                TRC_ASSERT((pathData.flags & PD_ENDSUBPATH),
                           (TB,"CLOSEFIGURE received without ENDSUBPATH"));
            }

            if (pathData.flags & PD_ENDSUBPATH) {
                if (NumDeltas > 0) {
                    // We are at the end of the subpath. Flush the data we
                    // have.
                    if (!OECreateAndFlushPolyLineOrder(ppdev, &BoundRect,
                            &ClipRects, &startPoint, pbo, pco,
                            mix & 0x1F, NumDeltas, DeltaSize, Deltas,
                            ZeroFlags)) {
                        // No order heap space, send all as SDAs.
                        INC_OUTCOUNTER(OUT_STROKEPATH_SDA_FAILEDADD);
                        goto SendAsSDA;
                    }
                }
            }
            else {
                HoldPoint = endPoint;
            }
        }

        goto PostSDA;
    }

SendAsSDA:
    if (pso->hsurf == ppdev->hsurfFrameBuf) {
        INC_OUTCOUNTER(OUT_STROKEPATH_SDA);
        ADD_INCOUNTER(IN_SDA_STROKEPATH_AREA, COM_SIZEOF_RECT(rectTrg));

        // Clip the bound rect to 16 bits and add to SDA.
        OEClipRect(&rectTrg);
        TRC_DBG((TB, "SDA: (%d,%d)(%d,%d)", rectTrg.left, rectTrg.top,
                rectTrg.right, rectTrg.bottom));
        OEClipAndAddScreenDataArea(&rectTrg, pco);
    }
    else {
        // If we can't send orders for offscreen rendering, we will
        // bail offscreen support for this bitmap.
        TRC_ALT((TB, "screen data call for offscreen rendering"));
        if (!(pdsurf->flags & DD_NO_OFFSCREEN))
            CH_RemoveCacheEntry(sbcOffscreenBitmapCacheHandle, pdsurf->bitmapId);     

        DC_QUIT;
    }

PostSDA:
    // Have scheduler consider sending output.
    SCH_DDOutputAvailable(ppdev, FALSE);

CalledOnDisconnected:
DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}


/****************************************************************************/
/* DrvFillPath - see NT DDK documentation.                                  */
/****************************************************************************/

// Worker function - combines the chore of allocating PolyGonCB order from
// the OA heap and contructing the order given the parameters. Then we give
// the order to OE to finish encoding. Returns TRUE on success (meaning no
// error allocating from the order heap).
BOOL OECreateAndFlushPolygonCBOrder(
        PDD_PDEV   ppdev,
        RECTL      *pBoundRect,
        POINTL     *pStartPoint,
        POE_BRUSH_DATA pCurrentBrush,
        POINTL     *pptlBrushOrg, 
        OE_ENUMRECTS *pClipRects,
        MIX        mix,
        FLONG      flOptions,
        unsigned   NumDeltas,
        unsigned   DeltaSize,
        BYTE       *Deltas,
        BYTE       *ZeroFlags)
{
    BOOL rc = TRUE;
    unsigned NumZeroFlagBytes;
    PINT_ORDER pOrder;
    PPOLYGON_CB_ORDER pPolygonCB;
    OE_ENUMRECTS IntersectRects;

    DC_BEGIN_FN("OECreateAndFlushPolygonCBOrder");

    // First make sure the clip rects actually intersect with the polygon
    // after its target screen rect has been calculated. Note that
    // *pBoundRect is in exclusive coords.
    IntersectRects.rects.c = 0;
    if (pClipRects->rects.c == 0 ||
            OEGetIntersectionsWithClipRects(pBoundRect, pClipRects,
            &IntersectRects) > 0) {
        // Round the number of zero flag bits actually used upward to the
        // nearest byte. Each point encoded takes two bits.
        NumZeroFlagBytes = (NumDeltas + 3) / 4;
        TRC_ASSERT((NumZeroFlagBytes <= ORD_MAX_POLYGON_ZERO_FLAGS_BYTES),
                   (TB,"Too many zero-flags bytes"));
        TRC_ASSERT((NumDeltas <= ORD_MAX_POLYGON_ENCODED_POINTS),
                   (TB,"Too many encoded orders"));
        TRC_ASSERT((DeltaSize <= ORD_MAX_POLYGON_CODEDDELTAS_LEN),
                   (TB,"Too many encoded delta bytes"));

        // 2 field flag bytes.
        pOrder = OA_AllocOrderMem(ppdev, MAX_ORDER_SIZE(IntersectRects.rects.c,
                2, MAX_POLYGON_CB_BASE_FIELDS_SIZE + 1 + NumZeroFlagBytes +
                DeltaSize));
        if (pOrder != NULL) {
            // Set up the order fields.
            pPolygonCB = (PPOLYGON_CB_ORDER)oeTempOrderBuffer;
            pPolygonCB->XStart = pStartPoint->x;
            pPolygonCB->YStart = pStartPoint->y;

            // If this is a hatched brush, the high bit of ROP2 indicates the
            // background fill mode: 1 means transparent, 0 means opaque.
            pPolygonCB->ROP2 = mix & 0x1F;
            if (pCurrentBrush->style == BS_HATCHED &&
                    ((mix & 0x1F00) >> 8) == R2_NOP)
                pPolygonCB->ROP2 |= 0x80;

            pPolygonCB->FillMode = flOptions;
            pPolygonCB->NumDeltaEntries = NumDeltas;
            pPolygonCB->CodedDeltaList.len = DeltaSize + NumZeroFlagBytes;

            // Pattern colors.
            pPolygonCB->BackColor = pCurrentBrush->back;
            pPolygonCB->ForeColor = pCurrentBrush->fore;

            // The protocol brush origin is the point on the screen where
            // we want the brush to start being drawn from (tiling where
            // necessary).
            pPolygonCB->BrushOrgX  = pptlBrushOrg->x;
            pPolygonCB->BrushOrgY  = pptlBrushOrg->y;
            OEClipPoint((PPOINTL)&pPolygonCB->BrushOrgX);

            // Extra brush data from the data when we realised the brush.
            pPolygonCB->BrushStyle = pCurrentBrush->style;
            pPolygonCB->BrushHatch = pCurrentBrush->hatch;

            memcpy(pPolygonCB->BrushExtra, pCurrentBrush->brushData,
                      sizeof(pPolygonCB->BrushExtra));

            // Copy the zero flags first.
            memcpy(pPolygonCB->CodedDeltaList.Deltas, ZeroFlags, NumZeroFlagBytes);

            // Next copy the encoded deltas.
            memcpy(pPolygonCB->CodedDeltaList.Deltas + NumZeroFlagBytes, Deltas,
                    DeltaSize);

            // Slow-field-encode the order with the first clip rect
            // (if present).
            pOrder->OrderLength = OE2_EncodeOrder(pOrder->OrderData,
                    TS_ENC_POLYGON_CB_ORDER, NUM_POLYGON_CB_FIELDS,
                    (BYTE *)pPolygonCB, (BYTE *)&PrevPolygonCB, etable_BG,
                    (IntersectRects.rects.c == 0 ? NULL :
                    &IntersectRects.rects.arcl[0]));

            ADD_INCOUNTER(IN_POLYGON_CB_BYTES, pOrder->OrderLength);
            OA_AppendToOrderList(pOrder);

            // Flush the order.
            if (IntersectRects.rects.c < 2)
                rc = TRUE;
            else
                rc = OEEmitReplayOrders(ppdev, 2, &IntersectRects);
        }
        else {
            TRC_ERR((TB,"Failed to alloc space for PolygonSC"));
            rc = FALSE;
        }
    }
    else {
        // We still return TRUE here since we handled the order by not
        // sending it.
        TRC_NRM((TB,"PolygonCB fully clipped out"));
    }

    DC_END_FN();
    return rc;
}

// Worker function - combines the chore of allocating PolygonSC order from
// the OA heap and contructing the order given the parameters. Then we give
// the order to OE to finish encoding. Returns TRUE on success (meaning no
// error allocating from the order heap).
BOOL OECreateAndFlushPolygonSCOrder(
        PDD_PDEV ppdev,
        RECTL    *pBoundRect,
        POINTL   *pStartPoint,
        BRUSHOBJ *pbo, 
        OE_ENUMRECTS *pClipRects,
        unsigned ROP2,
        FLONG    flOptions,
        unsigned NumDeltas,
        unsigned DeltaSize,
        BYTE     *Deltas,
        BYTE     *ZeroFlags)
{
    BOOL rc = TRUE;
    unsigned NumZeroFlagBytes;
    PINT_ORDER pOrder;
    PPOLYGON_SC_ORDER pPolygonSC;
    OE_ENUMRECTS IntersectRects;

    DC_BEGIN_FN("OECreateAndFlushPolygonSCOrder");

    // First make sure the clip rects actually intersect with the polygon
    // after its target screen rect has been calculated. Note that
    // *pBoundRect is in exclusive coords.
    IntersectRects.rects.c = 0;
    if (pClipRects->rects.c == 0 ||
            OEGetIntersectionsWithClipRects(pBoundRect, pClipRects,
            &IntersectRects) > 0) {
        // Round the number of zero flag bits actually used upward to the
        // nearest byte. Each point encoded takes two bits.
        NumZeroFlagBytes = (NumDeltas + 3) / 4;
        TRC_ASSERT((NumZeroFlagBytes <= ORD_MAX_POLYGON_ZERO_FLAGS_BYTES),
                   (TB,"Too many zero-flags bytes"));
        TRC_ASSERT((NumDeltas <= ORD_MAX_POLYGON_ENCODED_POINTS),
                   (TB,"Too many encoded orders"));
        TRC_ASSERT((DeltaSize <= ORD_MAX_POLYGON_CODEDDELTAS_LEN),
                   (TB,"Too many encoded delta bytes"));

        // 1 field flag byte.
        pOrder = OA_AllocOrderMem(ppdev, MAX_ORDER_SIZE(IntersectRects.rects.c,
                1, MAX_POLYGON_SC_BASE_FIELDS_SIZE + 1 + NumZeroFlagBytes +
                DeltaSize));
        if (pOrder != NULL) {
            // Set up the order fields.
            pPolygonSC = (PPOLYGON_SC_ORDER)oeTempOrderBuffer;
            pPolygonSC->XStart = pStartPoint->x;
            pPolygonSC->YStart = pStartPoint->y;
            pPolygonSC->ROP2 = ROP2;
            pPolygonSC->FillMode = flOptions;
            pPolygonSC->NumDeltaEntries = NumDeltas;
            pPolygonSC->CodedDeltaList.len = DeltaSize + NumZeroFlagBytes;

            // Pattern colors.
            OEConvertColor(ppdev, &pPolygonSC->BrushColor, pbo->iSolidColor,
                    NULL);

            // Copy the zero flags first.
            memcpy(pPolygonSC->CodedDeltaList.Deltas, ZeroFlags,
                    NumZeroFlagBytes);

            // Next copy the encoded deltas.
            memcpy(pPolygonSC->CodedDeltaList.Deltas + NumZeroFlagBytes,
                    Deltas, DeltaSize);

            // Slow-field-encode the order with the first clip rect
            // (if present).
            pOrder->OrderLength = OE2_EncodeOrder(pOrder->OrderData,
                    TS_ENC_POLYGON_SC_ORDER, NUM_POLYGON_SC_FIELDS,
                    (BYTE *)pPolygonSC, (BYTE *)&PrevPolygonSC, etable_CG,
                    (IntersectRects.rects.c == 0 ? NULL :
                    &IntersectRects.rects.arcl[0]));

            ADD_INCOUNTER(IN_POLYGON_SC_BYTES, pOrder->OrderLength);
            OA_AppendToOrderList(pOrder);

            // Flush the order.
            if (IntersectRects.rects.c < 2)
                rc = TRUE;
            else
                rc = OEEmitReplayOrders(ppdev, 1, &IntersectRects);
        }
        else {
            TRC_ERR((TB,"Failed to alloc space for PolygonCB"));
            rc = FALSE;
        }
    }
    else {
        // We still return TRUE here since we handled the order by not
        // sending it.
        TRC_NRM((TB,"PolygonSC completely clipped"));
    }

    DC_END_FN();
    return rc;
}

// Worker function - combines the chore of allocating EllipseCB order from
// the OA heap and contructing the order given the parameters. Then we give
// the order to OE to finish encoding. Returns TRUE on success (meaning no
// error allocating from the order heap).
BOOL OECreateAndFlushEllipseCBOrder(
        PDD_PDEV ppdev,
        RECT *pEllipseRect,
        POE_BRUSH_DATA pCurrentBrush,
        POINTL *pptlBrushOrg, 
        OE_ENUMRECTS *pClipRects,
        MIX mix,
        FLONG flOptions)
{
    BOOL rc = TRUE;
    PINT_ORDER pOrder;
    PELLIPSE_CB_ORDER pEllipseCB;
    OE_ENUMRECTS IntersectRects;
    RECTL ExclusiveRect;

    DC_BEGIN_FN("OECreateAndFlushEllipseCBOrder");

    // EllipseRect is inclusive, we need exclusive for getting clip rects.
    ExclusiveRect = *((RECTL *)pEllipseRect);
    ExclusiveRect.right++;
    ExclusiveRect.bottom++;

    // First make sure the clip rects actually intersect with the ellipse
    // after its target screen rect has been calculated. Note that
    // *pEllipseRect is already in inclusive coords.
    IntersectRects.rects.c = 0;
    if (pClipRects->rects.c == 0 ||
            OEGetIntersectionsWithClipRects(&ExclusiveRect, pClipRects,
            &IntersectRects) > 0) {

        // 2 field flag bytes.
        pOrder = OA_AllocOrderMem(ppdev, MAX_ORDER_SIZE(IntersectRects.rects.c,
                2, MAX_ELLIPSE_CB_FIELD_SIZE));
        if (pOrder != NULL) {
            // Set up the order fields.
            pEllipseCB = (PELLIPSE_CB_ORDER)oeTempOrderBuffer;
            pEllipseCB->LeftRect = pEllipseRect->left;
            pEllipseCB->RightRect = pEllipseRect->right;
            pEllipseCB->TopRect = pEllipseRect->top;
            pEllipseCB->BottomRect = pEllipseRect->bottom;
            pEllipseCB->FillMode = flOptions;

            // If this is a hatched brush, the high bit of ROP2 indicates the
            // background fill mode: 1 means transparent, 0 means opaque.
            pEllipseCB->ROP2 = mix & 0x1F;
            if (pCurrentBrush->style == BS_HATCHED &&
                    ((mix & 0x1F00) >> 8) == R2_NOP)
                pEllipseCB->ROP2 |= 0x80;
            
            // Pattern colors.
            pEllipseCB->BackColor = pCurrentBrush->back;
            pEllipseCB->ForeColor = pCurrentBrush->fore;

            // The protocol brush origin is the point on the screen where
            // we want the brush to start being drawn from (tiling where
            // necessary).
            pEllipseCB->BrushOrgX  = pptlBrushOrg->x;
            pEllipseCB->BrushOrgY  = pptlBrushOrg->y;
            OEClipPoint((PPOINTL)&pEllipseCB->BrushOrgX);

            // Extra brush data from the data when we realised the brush.
            pEllipseCB->BrushStyle = pCurrentBrush->style;
            pEllipseCB->BrushHatch = pCurrentBrush->hatch;

            memcpy(pEllipseCB->BrushExtra, pCurrentBrush->brushData,
                      sizeof(pEllipseCB->BrushExtra));

            // Slow-field-encode the order with the first clip rect
            // (if present).
            pOrder->OrderLength = OE2_EncodeOrder(pOrder->OrderData,
                    TS_ENC_ELLIPSE_CB_ORDER, NUM_ELLIPSE_CB_FIELDS,
                    (BYTE *)pEllipseCB, (BYTE *)&PrevEllipseCB, etable_EB,
                    (IntersectRects.rects.c == 0 ? NULL :
                    &IntersectRects.rects.arcl[0]));

            ADD_INCOUNTER(IN_ELLIPSE_CB_BYTES, pOrder->OrderLength);
            OA_AppendToOrderList(pOrder);

            // Flush the order.
            if (IntersectRects.rects.c < 2)
                rc = TRUE;
            else
                rc = OEEmitReplayOrders(ppdev, 2, &IntersectRects);
        }
        else {
            TRC_ERR((TB,"Unable to alloc space for EllipseCB"));
            rc = FALSE;
        }
    }
    else {
        // We still return TRUE here since we handled the order by not
        // sending it.
        TRC_NRM((TB,"EllipseCB completely clipped"));
    }

    DC_END_FN();
    return rc;
}

//
// DrvFillPath
//
BOOL RDPCALL DrvFillPath(
        SURFOBJ  *pso,
        PATHOBJ  *ppo,
        CLIPOBJ  *pco,
        BRUSHOBJ *pbo,
        POINTL   *pptlBrushOrg,
        MIX      mix,
        FLONG    flOptions)
{
    PDD_PDEV ppdev = (PDD_PDEV)pso->dhpdev;
    PDD_DSURF pdsurf = NULL;
    BOOL     rc = TRUE;
    RECTFX   rectfxTrg;
    RECTL    rectTrg;
    RECT     EllipseRect;
    BOOL     fMore = TRUE;
    PATHDATA pathData;
    POINTL   startPoint;
    POINTL   nextPoint;
    POINTL   endPoint;
    unsigned pathIndex;
    POE_BRUSH_DATA pCurrentBrush;
    OE_ENUMRECTS ClipRects;

    DC_BEGIN_FN("DrvFillPath");

    // Sometimes, we're called after being disconnected.
    if (ddConnected && pddShm != NULL) {
        // Surface is non-NULL.
        pso = OEGetSurfObjBitmap(pso, &pdsurf);

        // Get bounding rectangle.
        PATHOBJ_vGetBounds(ppo, &rectfxTrg);
        RECT_FROM_RECTFX(rectTrg, rectfxTrg);

        // Punt the call back to GDI to do the drawing.
        INC_OUTCOUNTER(OUT_FILLPATH_ALL);

        // Check if we are allowed to send this order (determined by the
        // negotiated capabilities of all the machines in the conference).
        // We shouldn't do Eng call if we return FALSE.  Otherwise, the frame
        // buffer will be already drawn, and it will cause rendering problems
        // when GDI re-renders it to other drawings.
        if (OE_SendAsOrder(TS_ENC_POLYGON_SC_ORDER) || 
                    OE_SendAsOrder(TS_ENC_POLYGON_CB_ORDER)) {
            rc = EngFillPath(pso, ppo, pco, pbo, pptlBrushOrg, mix,
                    flOptions);
        }
        else {
            TRC_NRM((TB, "Polygon order not allowed"));
            INC_OUTCOUNTER(OUT_FILLPATH_SDA_NOPOLYGON);

            // If the client doesn't support polygon, we just have
            // to fail DrvFillPath, the GDI will rerender the drawing
            // to other Drv calls
            return FALSE;
        }

        // if the path bound gives empty rect, we'll just ignore
        if (rectTrg.left == 0 && rectTrg.right == 0 &&
                rectTrg.top == 0 && rectTrg.bottom == 0) {
            TRC_ERR((TB, "Empty Path obj bounding rect, ignore"));
            DC_QUIT;
        }

        if (rc) {
            if ((pso->hsurf == ppdev->hsurfFrameBuf) || 
                    (!(pdsurf->flags & DD_NO_OFFSCREEN))) {
                // Send a switch surface PDU if the destination surface is different
                // from last drawing order. If we failed to send the PDU, we will
                // just have to bail on this drawing order.
                if (!OESendSwitchSurfacePDU(ppdev, pdsurf)) {
                    TRC_ERR((TB, "failed to send the switch surface PDU"));
                    DC_QUIT;
                }
            } else {
                // if noOffscreen flag is on, we will bail on sending 
                // the client any further offscreen rendering.  And will send the final
                // offscreen to screen blt as regular memblt.
                TRC_NRM((TB, "Offscreen blt bail"));
                DC_QUIT;
            }

            // Check for a valid brush for the test operation.
            if (OECheckBrushIsSimple(ppdev, pbo, &pCurrentBrush)) {
                unsigned RetVal;

                // Get the intersection between the dest rect and the
                // clip rects. Check for overcomplicated or
                // nonintersecting clipping. Note that this is an
                // initial pass, we so another intersection with
                // the (possibly smaller) individual order rect
                // generated later.
                RetVal = OEGetIntersectingClipRects(pco, &rectTrg,
                        CD_ANY, &ClipRects);
                if (RetVal == CLIPRECTS_TOO_COMPLEX) {
                    TRC_NRM((TB, "Clipping is too complex"));
                    INC_OUTCOUNTER(OUT_FILLPATH_SDA_COMPLEXCLIP);
                    goto SendAsSDA;
                }
                else if (RetVal == CLIPRECTS_NO_INTERSECTIONS) {
                    TRC_NRM((TB, "Clipping does not intersect destrect"));
                    DC_QUIT;
            }
            }
            else {
                TRC_NRM((TB, "Bad brush for polygon"));
                INC_OUTCOUNTER(OUT_FILLPATH_SDA_BADBRUSH);
                goto SendAsSDA;
            }

            // See if we can optimize the path...
            // We cannot send beziers, and ellipses are sent as a distinct order.
            if (ppo->fl & PO_ELLIPSE && 
                    (OE_SendAsOrder(TS_ENC_ELLIPSE_SC_ORDER) || 
                    OE_SendAsOrder(TS_ENC_ELLIPSE_CB_ORDER))) {
                // Get the inclusive rect covering only the ellipse itself.
                // Add 4/16 to left and top, subtract from right and bottom,
                // to undo the GDI transformation.
                EllipseRect.left = FXTOLROUND(rectfxTrg.xLeft + 4);
                EllipseRect.top = FXTOLROUND(rectfxTrg.yTop + 4);
                EllipseRect.right = FXTOLROUND(rectfxTrg.xRight - 4);
                EllipseRect.bottom = FXTOLROUND(rectfxTrg.yBottom - 4);

                if (pbo->iSolidColor != -1) {
                    // Solid color ellipse.
                    if (OECreateAndFlushEllipseSCOrder(ppdev, &EllipseRect,
                            pbo, &ClipRects, mix & 0x1F, flOptions)) {
                        INC_OUTCOUNTER(OUT_FILLPATH_ELLIPSE_SC);
                        goto PostSDA;
                    } else {
                        // No order heap space, send all as SDAs.
                        INC_OUTCOUNTER(OUT_FILLPATH_SDA_FAILEDADD);
                        goto SendAsSDA;
                    }
                }
                else {
                    // Color pattern brush ellipse.
                    if (OECreateAndFlushEllipseCBOrder(ppdev, &EllipseRect,
                             pCurrentBrush, pptlBrushOrg, &ClipRects, mix,
                             flOptions)) {
                        INC_OUTCOUNTER(OUT_FILLPATH_ELLIPSE_CB);
                        goto PostSDA;
                    } else {
                        // No order heap space, send all as SDAs.
                        INC_OUTCOUNTER(OUT_FILLPATH_SDA_FAILEDADD);
                        goto SendAsSDA;
                    } 
                }
            }
            
            else if (!(ppo->fl & PO_BEZIERS)) {
                BYTE Deltas[ORD_MAX_POLYGON_CODEDDELTAS_LEN];
                BYTE ZeroFlags[ORD_MAX_POLYGON_ZERO_FLAGS_BYTES];
                POINTL SubPathBoundPts[ORD_MAX_POLYGON_ENCODED_POINTS];
                BYTE *pCurEncode;
                RECTL BoundRect;
                POINTL HoldPoint;
                unsigned NumDeltas;
                unsigned DeltaSize;
                int PointIndex = 0;
                BOOL bPathStart = TRUE;

                // This is a set of solid cosmetic (i.e.  no fancy end styles)
                // width-1 lines. NT stores all paths as a set of independent
                // sub-paths. Each sub-path can start at a new point that is
                // NOT linked to the previous sub-path. Paths used for this
                // function need to be closed.
                PATHOBJ_vEnumStart(ppo);

                while (fMore) {
                    // Get the next set of lines.
                    fMore = PATHOBJ_bEnum(ppo, &pathData);

                    TRC_DBG((TB, "PTS: %lu FLAG: %08lx",
                             pathData.count,
                             pathData.flags));

                    // If this is the start of a path, remember the start point as
                    // we need to close the path at the end. startPoint is the
                    // start point for the current PolyGon order.
                    if (bPathStart) {
                        POINT_FROM_POINTFIX(startPoint, pathData.pptfx[0]);
                        nextPoint = startPoint;

                        // Set up encoding variables.
                        BoundRect.left = BoundRect.right = startPoint.x;
                        BoundRect.top = BoundRect.bottom = startPoint.y;

                        NumDeltas = DeltaSize = 0;
                        pCurEncode = Deltas;
                        memset(ZeroFlags, 0, sizeof(ZeroFlags));
                        pathIndex = 1;
                        bPathStart = FALSE;
                    } 
                    else {
                        // This is a continuation from a previous PATHDATA.
                        nextPoint = HoldPoint;
                        pathIndex = 0;
                    }

                    // If NumDeltas is > max, we have to send as screen
                    // data unfortunately since we can't encode this.
                    if (NumDeltas + pathData.count + PointIndex >
                            ORD_MAX_POLYGON_ENCODED_POINTS) {
                        // No order heap space, send all as SDAs.
                        INC_OUTCOUNTER(OUT_FILLPATH_SDA_FAILEDADD);
                        goto SendAsSDA;
                    }

                    // record subpath's start point
                    if (pathData.flags & PD_BEGINSUBPATH) {
                        POINT_FROM_POINTFIX(SubPathBoundPts[PointIndex] , pathData.pptfx[0]);
                        PointIndex++;
                    }

                    // Generate deltas for each point in the path.
                    for (; pathIndex < pathData.count; pathIndex++) {
                        POINT_FROM_POINTFIX(endPoint, pathData.pptfx[pathIndex]);

                        // Don't try to encode points where both deltas are zero.
                        if ((nextPoint.x != endPoint.x) ||
                                (nextPoint.y != endPoint.y)) {
                            if (!OEEncodePolyLinePointDelta(&pCurEncode,
                                    &NumDeltas, &DeltaSize, ZeroFlags,
                                    &nextPoint, &endPoint, &BoundRect)) {
                                goto SendAsSDA;
                            }
                        }

                        nextPoint = endPoint;
                    }

                    // Record subpath's end point
                    if (pathData.flags & PD_ENDSUBPATH) {
                        SubPathBoundPts[PointIndex] = endPoint;
                        PointIndex++;
                    }

                    HoldPoint = endPoint;
                }

                if (NumDeltas > 0) {
                    // If NumDeltas is > max, we have to send as screen
                    // data unfortunately since we can't encode this.
                    if (NumDeltas + PointIndex - 2 >
                            ORD_MAX_POLYGON_ENCODED_POINTS) {
                        // No order heap space, send all as SDAs.
                        INC_OUTCOUNTER(OUT_FILLPATH_SDA_FAILEDADD);
                        goto SendAsSDA;                       
                    }

                    // For Polygon, we append all the subpath together 
                    // and send as one polygon order.  But we need to close
                    // each subpath respectively to make sure all the subpath
                    // are closed properly
                    for (pathIndex = PointIndex - 2; pathIndex > 0; pathIndex--) {
                        endPoint = SubPathBoundPts[pathIndex];

                        // Don't try to encode points where both deltas are zero.
                        if ((nextPoint.x != endPoint.x) ||
                                (nextPoint.y != endPoint.y)) {
                            if (!OEEncodePolyLinePointDelta(&pCurEncode,
                                    &NumDeltas, &DeltaSize, ZeroFlags,
                                    &nextPoint, &endPoint, &BoundRect))
                                goto SendAsSDA;
                        }

                        nextPoint = endPoint;
                    }
 
                    // We are at the end of the path. Flush the data we have.
                    if (pbo->iSolidColor != -1) {
                        // solid color polygon
                        if (OECreateAndFlushPolygonSCOrder(ppdev,
                                &BoundRect,
                                &startPoint,
                                pbo,
                                &ClipRects,                                                      
                                mix & 0x1F,
                                flOptions,
                                NumDeltas,
                                DeltaSize,
                                Deltas,
                                ZeroFlags)) {
                            INC_OUTCOUNTER(OUT_FILLPATH_POLYGON_SC);
                        } else {
                            // No order heap space, send all as SDAs.
                            INC_OUTCOUNTER(OUT_FILLPATH_SDA_FAILEDADD);
                            goto SendAsSDA;
                        }

                    } else {
                        // color pattern brush polygon
                        if (OECreateAndFlushPolygonCBOrder(ppdev,
                                &BoundRect,
                                &startPoint,
                                pCurrentBrush,
                                pptlBrushOrg,
                                &ClipRects,
                                mix,
                                flOptions,
                                NumDeltas,
                                DeltaSize,
                                Deltas,
                                ZeroFlags)) {
                            INC_OUTCOUNTER(OUT_FILLPATH_POLYGON_CB);
                        } else {
                            // No order heap space, send all as SDAs.
                            INC_OUTCOUNTER(OUT_FILLPATH_SDA_FAILEDADD);
                            goto SendAsSDA;
                        }
                    }
                }
                goto PostSDA;
            }
            else {
                TRC_DBG((TB, "Got PO_BEZIERS fill"));
                goto SendAsSDA;
            }
        }
        else {
            TRC_ERR((TB, "EngFillPath failed"));
            DC_QUIT;
        }
    }
    else {
        if (pso->iType == STYPE_DEVBITMAP) {
            // Surface is non-NULL.
            pso = OEGetSurfObjBitmap(pso, &pdsurf);

            rc = EngFillPath(pso, ppo, pco, pbo, pptlBrushOrg, mix,
                    flOptions);

        }
        else {
            TRC_ERR((TB, "Called when disconnected"));
        }
        goto CalledOnDisconnected;
    }


SendAsSDA:

    if (pso->hsurf == ppdev->hsurfFrameBuf) {
        // If we reached here we did not encode as an order, clip the bound
        // rect to 16 bits and add to screen data.
        INC_OUTCOUNTER(OUT_FILLPATH_SDA);
        ADD_INCOUNTER(IN_SDA_FILLPATH_AREA, COM_SIZEOF_RECT(rectTrg));
        OEClipRect(&rectTrg);
        TRC_DBG((TB, "SDA: (%d,%d)(%d,%d)", rectTrg.left, rectTrg.top,
                rectTrg.right, rectTrg.bottom));
        if((rectTrg.right != rectTrg.left) &&
           (rectTrg.bottom != rectTrg.top)) {
            OEClipAndAddScreenDataArea(&rectTrg, pco);
        }
        else {
            TRC_ASSERT(FALSE,(TB,"Invalid Add Rect (%d,%d,%d,%d)",
                        rectTrg.left, rectTrg.top, rectTrg.right, rectTrg.bottom));
            DC_QUIT;
        }
    }
    else {
        // For now, if we can't send orders for offscreen rendering, we will 
        // bail offscreen support for this bitmap
        TRC_ALT((TB, "screen data call for offscreen rendering"));
        if (!(pdsurf->flags & DD_NO_OFFSCREEN))
            CH_RemoveCacheEntry(sbcOffscreenBitmapCacheHandle, pdsurf->bitmapId);

        DC_QUIT;
    }

PostSDA:
    // Have scheduler consider sending output.
    SCH_DDOutputAvailable(ppdev, FALSE);

CalledOnDisconnected:
DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}


/****************************************************************************/
// DrvPaint - see NT DDK documentation.
/****************************************************************************/
BOOL RDPCALL DrvPaint(
        SURFOBJ  *pso,
        CLIPOBJ  *pco,
        BRUSHOBJ *pbo,
        POINTL   *pptlBrushOrg,
        MIX      mix)
{
    PDD_PDEV ppdev = (PDD_PDEV)pso->dhpdev;
    PDD_DSURF pdsurf = NULL;
    SURFOBJ *psoBitmap;
    BOOL rc = TRUE;
    RECTL rectTrg;
    BYTE rop3;
    OE_ENUMRECTS ClipRects;

    DC_BEGIN_FN("DrvPaint");

    // Sometimes, we're called after being disconnected.
    if (ddConnected && pddShm != NULL) {
        // Surface is non-NULL.
        psoBitmap = OEGetSurfObjBitmap(pso, &pdsurf);
        INC_OUTCOUNTER(OUT_PAINT_ALL);

        // Throw the drawing to GDI first.
        rc = EngPaint(psoBitmap, pco, pbo, pptlBrushOrg, mix);
        if (rc) {
            // If ppdev is NULL then this is a blt to GDI managed memory
            // bitmap, so there is no need to send any orders to the client.
            if (ppdev != NULL) {
                unsigned RetVal;

                // Get bounding rectangle and clip to 16 bits.
                RECT_FROM_RECTL(rectTrg, pco->rclBounds);
                OEClipRect(&rectTrg);

                // If this function is changed, need to know that psoTrg
                // points to the GDI DIB bitmap in offscreen bitmap case.

                // Enumerate the clip rects into a usable form.
                RetVal = OEGetIntersectingClipRects(pco, &rectTrg,
                        CD_ANY, &ClipRects);
                if (RetVal == CLIPRECTS_TOO_COMPLEX) {
                    TRC_NRM((TB, "Clipping is too complex"));
                    INC_OUTCOUNTER(OUT_PAINT_SDA_COMPLEXCLIP);
                    goto SendAsSDA;
                }

                TRC_ASSERT((RetVal != CLIPRECTS_NO_INTERSECTIONS),
                        (TB,"clipobj for DrvPaint is messed up"));
            }
            else {
                // if ppdev is NULL, we are blt to GDI managed bitmap,
                // so, the dhurf of the target surface should be NULL
                TRC_ASSERT((pdsurf == NULL), 
                        (TB, "NULL ppdev - psoTrg has non NULL dhsurf"));
                TRC_NRM((TB, "NULL ppdev - paint to GDI managed bitmap"));
                INC_OUTCOUNTER(OUT_PAINT_UNSENT);
                DC_QUIT;
            }

            if ((psoBitmap->hsurf == ppdev->hsurfFrameBuf) ||
                    (!(pdsurf->flags & DD_NO_OFFSCREEN))) {
                // Send a switch surface PDU if the destination surface is
                // different from last drawing order. If we failed to send
                // the PDU, we will just have to bail on this drawing order.
                if (!OESendSwitchSurfacePDU(ppdev, pdsurf)) {
                    TRC_ERR((TB, "failed to send the switch surface PDU"));
                    goto SendAsSDA;
                }
            } else {
                // If noOffscreen flag is on, we will bail on sending
                // the client any further offscreen rendering.
                // And will send the final offscreen to screen blt as
                // regular memblt.
                TRC_NRM((TB, "Offscreen blt bail"));
                goto SendAsSDA;
            }
        }
        else {
            TRC_ERR((TB,"Failed EngPaint call"));
            INC_OUTCOUNTER(OUT_PAINT_UNSENT);
            DC_QUIT;
        }
    }
    else {
        if (pso->iType == STYPE_DEVBITMAP) {
            // Surface is non-NULL.
            psoBitmap = OEGetSurfObjBitmap(pso, &pdsurf);
            
            // Throw the drawing to GDI first.
            rc = EngPaint(psoBitmap, pco, pbo, pptlBrushOrg, mix);
        }
        else {
            TRC_ERR((TB, "Called when disconnected"));
        }
        
        goto CalledOnDisconnected;
    }

    // The low byte of the mix represents a ROP2. We need a ROP3 for
    // the paint operation, so convert the mix as follows.
    //
    // Remember the definitions of 2, 3 & 4 way ROP codes.
    //
    //  Msk Pat Src Dst
    //
    //  1   1   1   1    --------+------+         ROP2 uses P & D only
    //  1   1   1   0            |      |
    //  1   1   0   1    -+      |      |         ROP3 uses P, S & D
    //  1   1   0   0     |ROP2-1|ROP3  |ROP4
    //  1   0   1   1     |(see  |      |         ROP4 uses M, P, S & D
    //  1   0   1   0    -+ note)|      |
    //  1   0   0   1            |      |
    //  1   0   0   0    --------+      |
    //  0   1   1   1                   |
    //  0   1   1   0                   |         NOTE: Windows defines its
    //  0   1   0   1                   |         ROP2 codes as the bitwise
    //  0   1   0   0                   |         value calculated here
    //  0   0   1   1                   |         plus one. All other ROP
    //  0   0   1   0                   |         codes are the straight
    //  0   0   0   1                   |         bitwise value.
    //  0   0   0   0    ---------------+
    //
    // Or, algorithmically...
    // ROP3 = (ROP2 & 0x3) | ((ROP2 & 0xC) << 4) | (ROP2 << 2)
    // ROP4 = (ROP3 << 8) | ROP3
    mix  = (mix & 0x1F) - 1;
    rop3 = (BYTE)((mix & 0x3) | ((mix & 0xC) << 4) | (mix << 2));

    // Check if we are allowed to send the ROP3.
    if (OESendRop3AsOrder(rop3)) {
        // Check for a pattern or true destination BLT.
        if (!ROP3_NO_PATTERN(rop3)) {
            // Check whether we can encode the PatBlt as an OpaqueRect.
            // It must be solid with a PATCOPY rop.
            if (pbo->iSolidColor != -1 && rop3 == OE_PATCOPY_ROP) {
                if (!OEEncodeOpaqueRect(&rectTrg, pbo, ppdev, &ClipRects)) {
                    // Something went wrong with the encoding, so skip
                    // to the end to add this operation to the SDA.
                    goto SendAsSDA;
                }
            }
            else if (!OEEncodePatBlt(ppdev, pbo, &rectTrg, pptlBrushOrg, rop3,
                    &ClipRects)) {
                // Something went wrong with the encoding, so skip to
                // the end to add this operation to the SDA.
                goto SendAsSDA;
            }
        }
        else {
            if (!OEEncodeDstBlt(&rectTrg, rop3, ppdev, &ClipRects))
                goto SendAsSDA;
        }
    }
    else {
        TRC_NRM((TB, "Cannot send ROP3 %d", rop3));
        INC_OUTCOUNTER(OUT_BITBLT_SDA_NOROP3);
        goto SendAsSDA;
    }

    // Sent the order, skip sending SDA.
    goto PostSDA;

SendAsSDA:
    // If we reached here we could not send via DrvBitBlt().
    // Use EngPaint to paint the screen backdrop then add the area to the SDA.
    if (psoBitmap->hsurf == ppdev->hsurfFrameBuf) {
        OEClipAndAddScreenDataArea(&rectTrg, pco);

        // All done: consider sending the output.
        SCH_DDOutputAvailable(ppdev, FALSE);
        INC_OUTCOUNTER(OUT_PAINT_SDA);
    }
    else {
        // If we can't send orders for offscreen rendering, we will 
        // bail offscreen support for the target bitmap.
        TRC_ALT((TB, "screen data call for offscreen rendering"));
        if (!(pdsurf->flags & DD_NO_OFFSCREEN))
            CH_RemoveCacheEntry(sbcOffscreenBitmapCacheHandle,
                    pdsurf->bitmapId);
    }

PostSDA:
CalledOnDisconnected:
DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}


/****************************************************************************/
// DrvRealizeBrush - see NT DDK documentation.
/****************************************************************************/
BOOL RDPCALL DrvRealizeBrush(
        BRUSHOBJ *pbo,
        SURFOBJ  *psoTarget,
        SURFOBJ  *psoPattern,
        SURFOBJ  *psoMask,
        XLATEOBJ *pxlo,
        ULONG    iHatch)
{
    PDD_PDEV ppdev = (PDD_PDEV)psoTarget->dhpdev;
    BOOL     rc    = TRUE;
    PBYTE    pData;
    ULONG    iBitmapFormat;
#ifdef DC_HICOLOR
    BYTE      brushBits[192];
    BYTE      brushIndices[64];
    unsigned  pelSizeFactor = 1;
    UINT32    osColor;
    unsigned  iColor;
#else
    BYTE     brushBits[64];
#endif
    UINT32   color1;
    UINT32   color2;
    UINT32   currColor;
    INT      i, j, currIndex;
    BOOL     brushSupported = TRUE;
    BYTE     palette[MAX_UNIQUE_COLORS];
    UINT32   brushSupportLevel;
    UINT32   colors[MAX_BRUSH_ENCODE_COLORS] = {1, 0};
    UINT32   colorCount = 2;
    ULONG    iBytes = 0;

    DC_BEGIN_FN("DrvRealizeBrush");

    INC_OUTCOUNTER(OUT_BRUSH_ALL);

    // A valid brush satisfies any of the following criteria.
    //  1) It is a standard hatch brush (as passed by DrvEnablePDEV).
    //  2) It is an 8x8 monochrome bitmap.
    //  3) It is an 8x8 color bitmap and the client can support it.

    // Check for a Windows standard hatch.
    if (iHatch < HS_DDI_MAX) {
        TRC_DBG((TB, "Standard hatch %lu", iHatch));
        rc = OEStoreBrush(ppdev,
                          pbo,
                          BS_HATCHED,
                          1,
                          &psoPattern->sizlBitmap,
                          0,
                          NULL,
                          pxlo,
                          (BYTE)iHatch,
                          palette,
                          colors,
                          colorCount);

        INC_OUTCOUNTER(OUT_BRUSH_STANDARD);
        //standard brushes count as mono, don't double count
        DEC_OUTCOUNTER(OUT_BRUSH_MONO);
        DC_QUIT;
    }

    // If the driver has been passed a dither color brush we can support
    // this by sending a solid color brush definition.
    if ((iHatch & RB_DITHERCOLOR) != 0) {
        TRC_DBG((TB, "Standard hatch %lu", iHatch));
        colors[0] = iHatch & 0x00FFFFFF;
        rc = OEStoreBrush(ppdev,
                pbo,
                BS_SOLID,
                1,
                &psoPattern->sizlBitmap,
                0,
                NULL,
                NULL,
                (BYTE)iHatch,
                palette,
                colors,
                colorCount);

        INC_OUTCOUNTER(OUT_BRUSH_STANDARD);
        //standard brushes count as mono, don't double count
        DEC_OUTCOUNTER(OUT_BRUSH_MONO);
        DC_QUIT;
    }

    if ((psoPattern->sizlBitmap.cx == 8) &&
            (psoPattern->sizlBitmap.cy == 8)) 
    {
        brushSupportLevel = pddShm->sbc.caps.brushSupportLevel;

        // NOTE: There's a flag (BMF_TOPDOWN) in psoPattern->fjBitmap
        // that's supposed to indicate whether the bitmap is top-down or
        // bottom-up, but it is not always set up correctly.  In fact, the
        // bitmaps are always the wrong way up for our protocol, so we have
        // to flip them regardless of the flag.  Hence the row numbers are
        // reversed ('i' loops) in all the conversions below.
        pData = psoPattern->pvScan0;
        iBitmapFormat = psoPattern->iBitmapFormat;

#ifdef DC_HICOLOR
        // mono brushes are easy, regardless of operating color depth
        if (iBitmapFormat == BMF_1BPP) {
            // every 8 pixels take a byte @ 1bpp
            iBytes = 8;
            for (i = 7; i >= 0; i--) {
                brushBits[i] = *pData;
                pData += psoPattern->lDelta;
            }
        }
        else if (ppdev->cClientBitsPerPel < 15) {
            // for 4 and 8 bpp sessions, colors end up as indices regardless
            //  of the color depth of the brush;
            switch (iBitmapFormat) {
                case BMF_4BPP:
                {
                    iBitmapFormat = BMF_8BPP;

                    // Copy over the brush bits at 1 byte / pixel and track
                    // how many unique colors we have.  The vast vast majority
                    // of brushes are 4 colors or less.
                    iBytes = 64;
                    memset(palette, 0, sizeof(palette));
                    colorCount = 0;

                    for (i = 7; i >= 0; i--) {
                        currIndex = i * 8;
                        for (j = 0; j < 4; j++) {
                            color1 = XLATEOBJ_iXlate(pxlo, (pData[j] >> 4));
                            color2 = XLATEOBJ_iXlate(pxlo, (pData[j] & 0x0F));

                            brushBits[currIndex]     = (BYTE) color1;
                            brushBits[currIndex + 1] = (BYTE) color2;
                            currIndex += 2;

                            if (palette[color1] && palette[color2])
                                continue;

                            // if possible assign each unique color a four bit index
                            if (!palette[color1]) {
                                if (colorCount < MAX_BRUSH_ENCODE_COLORS)
                                    colors[colorCount] = color1;
                                colorCount++;
                                palette[color1] = (BYTE) colorCount;
                            }

                            if (!palette[color2]) {
                                if (colorCount < MAX_BRUSH_ENCODE_COLORS)
                                    colors[colorCount] = color2;
                                colorCount++;
                                palette[color2] = (BYTE) colorCount;
                            }
                        }
                        pData += psoPattern->lDelta;
                    }

                    // The encoding value was set one larger than it should
                    // have been so adjust it
                    if (colorCount <= MAX_BRUSH_ENCODE_COLORS) {
                        for (currColor = 0; currColor < colorCount; currColor++)
                            palette[colors[currColor]]--;
                    }

                    brushSupported = (colorCount <= 2) ||
                                     (brushSupportLevel > TS_BRUSH_DEFAULT);
                }
                break;

                case BMF_24BPP:
                case BMF_16BPP:
                case BMF_8BPP:
                {
                    // When running at 4/8bpp, the xlateobj will convert the
                    // Nbpp bitmap pel values to 8bpp palette indices, so we
                    // just have to
                    // - set up a multiplier to access the pels correctly
                    // - fix up the number of bytes in the bitmap
                    // - lie about the color depth of the bitmap
                    TRC_DBG((TB, "Examining brush format %d", iBitmapFormat));
                    if (iBitmapFormat == BMF_24BPP)
                        pelSizeFactor = 3;
                    else if (iBitmapFormat == BMF_16BPP)
                        pelSizeFactor = 2;
                    else
                        pelSizeFactor = 1;

                    iBytes        = 64;
                    iBitmapFormat = BMF_8BPP;

                    // Copy over the brush bits and track how many unique
                    // colors we have.  The vast vast majority of brushes are
                    // 4 colors or less.
                    memset(palette, 0, sizeof(palette));
                    colorCount = 0;

                    for (i = 7; i >= 0; i--) {
                        currIndex = i * 8;
                        for (j = 0; j < 8; j++) {
                            osColor = 0;
                            memcpy(&osColor, &pData[j * pelSizeFactor],
                                   pelSizeFactor);
                            currColor = XLATEOBJ_iXlate(pxlo, osColor);

                            TRC_DBG((TB, "This pel: %02x %02x %02x",
                                        (UINT)pData[j * 3],
                                        (UINT)pData[j * 3 + 1],
                                        (UINT)pData[j * 3 + 2] ));
                            TRC_DBG((TB, "Color     %08lx", currColor));

                            brushBits[currIndex] = (BYTE) currColor;
                            currIndex++;

                            // assign each unique color a two bit index
                            if (palette[currColor]) {
                                continue;
                            }
                            else {
                                if (colorCount < MAX_BRUSH_ENCODE_COLORS)
                                    colors[colorCount] = currColor;
                                colorCount++;
                                palette[currColor] = (BYTE) colorCount;
                            }
                        }

                        pData += psoPattern->lDelta;
                    }

                    // The encoding value was set one larger than it should
                    // have been so adjust it
                    if (colorCount <= MAX_BRUSH_ENCODE_COLORS) {
                        for (currColor = 0; currColor < colorCount; currColor++)
                            palette[colors[currColor]]--;
                    }

                    brushSupported = (colorCount <= 2) ||
                            (brushSupportLevel > TS_BRUSH_DEFAULT);
                }
                break;

                default:
                {
                    // Unsupported brush format.
                    TRC_ALT((TB, "Brush of unsupported format %d",
                                        (UINT32)psoPattern->iBitmapFormat));
                    iBytes = 0;
                    brushSupported = FALSE;
                }
                break;
            }
        }
        else {
            // hicolor makes things a little more complex for us; we have
            // to handle and 3 byte color values instead of color indices
            switch (iBitmapFormat) {
                case BMF_4BPP:
                {
                    // Copy over the brush bits at the correct color depth,
                    // tracking how many unique colors we have.  The vast
                    // vast majority of brushes are 4 colors or less.
                    // First set up the correct formats
                    if (ppdev->cClientBitsPerPel == 24) {
                        iBitmapFormat = BMF_24BPP;
                        iBytes        = 192;
                    }
                    else {
                        iBitmapFormat = BMF_16BPP;
                        iBytes        = 128;
                    }
                    colorCount = 0;

                    for (i = 7; i >= 0; i--) {
                        currIndex = i * 8;
                        for (j = 0; j < 4; j++) {
                            color1 = XLATEOBJ_iXlate(pxlo, (pData[j] >> 4));
                            color2 = XLATEOBJ_iXlate(pxlo, (pData[j] & 0x0F));

                            // we will store each pel twice - once 'as is' and
                            // once as an index to the in-use color table
                            if (ppdev->cClientBitsPerPel == 24) {
                                brushBits[currIndex * 3]     =
                                     (TSUINT8)( color1       & 0x000000FF);
                                brushBits[currIndex * 3 + 1] =
                                     (TSUINT8)((color1 >> 8) & 0x000000FF);
                                brushBits[currIndex * 3 + 2] =
                                     (TSUINT8)((color1 >> 16)& 0x000000FF);

                                brushBits[currIndex * 3 + 4] =
                                     (TSUINT8)( color2       & 0x000000FF);
                                brushBits[currIndex * 3 + 5] =
                                     (TSUINT8)((color2 >> 8) & 0x000000FF);
                                brushBits[currIndex * 3 + 6] =
                                     (TSUINT8)((color2 >> 16)& 0x000000FF);
                            }
                            else {
                                brushBits[currIndex * 2] =
                                         (TSUINT8)( color1       & 0x00FF);
                                brushBits[currIndex * 2 + 1] =
                                         (TSUINT8)((color1 >> 8) & 0x00FF);
                                brushBits[currIndex * 2 + 3] =
                                         (TSUINT8)( color2       & 0x00FF);
                                brushBits[currIndex * 2 + 4] =
                                         (TSUINT8)((color2 >> 8) & 0x00FF);
                            }

                            if (colorCount <= MAX_BRUSH_ENCODE_COLORS) {
                                // we try to assign each unique color a two bit
                                // index.  We can't just look in the palette
                                // this time; we have to actually search the
                                // in-use color table

                                for (iColor = 0; iColor < colorCount; iColor++) {
                                    if (colors[iColor] == color1)
                                        break;
                                }

                                // Did we find the color in the in-use table?
                                if (iColor < colorCount) {
                                    brushIndices[currIndex] = (BYTE)iColor;
                                }
                                else {
                                    // maybe record the new color
                                    if (colorCount < MAX_BRUSH_ENCODE_COLORS) {
                                        colors[colorCount] = color1;
                                        brushIndices[currIndex] = (BYTE)colorCount;
                                    }
                                    TRC_DBG((TB, "New color %08lx", color1));
                                    colorCount++;
                                }

                                // update the index
                                currIndex ++;

                                for (iColor = 0; iColor < colorCount; iColor++) {
                                    if (colors[iColor] == color2)
                                        break;
                                }

                                // Did we find the color in the in-use table?
                                if (iColor < colorCount) {
                                    brushIndices[currIndex] = (BYTE)iColor;
                                }
                                else {
                                    // maybe record the new color
                                    if (colorCount < MAX_BRUSH_ENCODE_COLORS) {
                                        colors[colorCount] = color2;
                                        brushIndices[currIndex] = (BYTE)colorCount;
                                    }
                                    TRC_DBG((TB, "New color %08lx", color2));
                                    colorCount++;
                                }
                                currIndex ++;
                            }
                            else {
                                // update the index
                                currIndex += 2;
                            }
                        }

                        pData += psoPattern->lDelta;
                    }

                    TRC_DBG((TB, "Final color count %d", colorCount));
                    brushSupported = (colorCount <= 2) ||
                                     (brushSupportLevel > TS_BRUSH_DEFAULT);

                    // Should we use the index versions instead of full RGBs?
                    if (brushSupported &&
                            (colorCount <= MAX_BRUSH_ENCODE_COLORS)) {
                        // yes - copy them over
                        memcpy(brushBits, brushIndices, 64);
                        iBytes = 64;
                    }
                }
                break;

                case BMF_24BPP:
                case BMF_16BPP:
                case BMF_8BPP:
                {
                    // When running in hicolor, just as for 8bpp, we have to
                    // set up a multiplier to access the bits correctly and
                    // fix up the number of bytes in the bitmap and color
                    // format of the bitmap
                    //
                    // The complication is that the xlate object can give us
                    // 2 or 3 byte color values depending on the session bpp.
                    // Its not practical to use these to build a color table
                    // as for the 8bpp case (the color array would have to
                    // have 16.4 million entries!), so instead we build a
                    // list of the colors used
                    TRC_DBG((TB, "Examining brush format %d", iBitmapFormat));
                    if (iBitmapFormat == BMF_24BPP)
                        pelSizeFactor = 3;
                    else if (iBitmapFormat == BMF_16BPP)
                        pelSizeFactor = 2;
                    else
                        pelSizeFactor = 1;

                    // now set up the converted formats
                    if (ppdev->cClientBitsPerPel == 24) {
                        iBitmapFormat = BMF_24BPP;
                        iBytes        = 192;
                    }
                    else {
                        iBitmapFormat = BMF_16BPP;
                        iBytes        = 128;
                    }

                    // Copy over the brush bits and track how many unique colors
                    // we have.  The vast vast majority of brushes are 4 colors
                    // or less.
                    colorCount = 0;

                    for (i = 7; i >= 0; i--) {
                        currIndex = i * 8;
                        for (j = 0; j < 8; j++) {
                            osColor = 0;
                            memcpy(&osColor,
                                   &pData[j * pelSizeFactor],
                                   pelSizeFactor);

                            currColor = XLATEOBJ_iXlate(pxlo, osColor);

                            TRC_DBG((TB, "OS Color :  %08lx", osColor));
                            TRC_DBG((TB, "Color :     %08lx", currColor));

                            // we will store each pel twice - once 'as is' and
                            // once as an index to the in-use color table
                            if (ppdev->cClientBitsPerPel == 24) {
                                brushBits[currIndex * 3]     =
                                     (TSUINT8)( currColor       & 0x000000FF);
                                brushBits[currIndex * 3 + 1] =
                                     (TSUINT8)((currColor >> 8) & 0x000000FF);
                                brushBits[currIndex * 3 + 2] =
                                     (TSUINT8)((currColor >> 16)& 0x000000FF);

                                TRC_DBG((TB, "This pel  : %02x %02x %02x",
                                            (UINT)pData[j * pelSizeFactor],
                                            (UINT)pData[j * pelSizeFactor + 1],
                                            (UINT)pData[j * pelSizeFactor + 2] ));

                                TRC_DBG((TB, "Brush bits: %02x %02x %02x",
                                      (UINT)brushBits[currIndex * 3],
                                      (UINT)brushBits[currIndex * 3 + 1],
                                      (UINT)brushBits[currIndex * 3 + 2] ));
                            }
                            else {
                                brushBits[currIndex * 2] =
                                         (TSUINT8)( currColor       & 0x00FF);
                                brushBits[currIndex * 2 + 1] =
                                         (TSUINT8)((currColor >> 8) & 0x00FF);

                                TRC_DBG((TB, "This pel  : %02x %02x",
                                            (UINT)pData[j * pelSizeFactor],
                                            (UINT)pData[j * pelSizeFactor + 1] ));

                                TRC_DBG((TB, "Brush bits: %02x %02x",
                                      (UINT)brushBits[currIndex * 2],
                                      (UINT)brushBits[currIndex * 2 + 1] ));
                            }

                            if (colorCount <= MAX_BRUSH_ENCODE_COLORS) {
                                // we try to assign each unique color a two bit
                                // index.  We can't just look in the palette
                                // this time; we have to actually search the
                                // in-use color table
                                for (iColor = 0; iColor < colorCount; iColor++) {
                                    if (colors[iColor] == currColor)
                                        break; // from for loop
                                }

                                // Did we find the color in the in-use table?
                                if (iColor < colorCount) {
                                    brushIndices[currIndex] = (BYTE)iColor;

                                    // safe to update the index now
                                    currIndex++;
                                    continue; // next j
                                }

                                // maybe record the new color
                                if (colorCount < MAX_BRUSH_ENCODE_COLORS) {
                                    colors[colorCount] = currColor;
                                    brushIndices[currIndex] = (BYTE)colorCount;
                                }
                                TRC_DBG((TB, "New color %08lx", currColor));
                                colorCount++;
                            }

                            // safe to update the index now
                            currIndex++;
                        } // next j

                        pData += psoPattern->lDelta;
                    } // next i

                    TRC_DBG((TB, "Final color count %d", colorCount));
                    brushSupported = (colorCount <= 2) ||
                                     (brushSupportLevel > TS_BRUSH_DEFAULT);

                    // Should we use the index versions instead of full RGBs?
                    if (brushSupported &&
                            (colorCount <= MAX_BRUSH_ENCODE_COLORS)) {
                        // yes - copy them over
                        memcpy(brushBits, brushIndices, 64);
                        iBytes = 64;
                    }
                }
                break;

                default:
                {
                    // Unsupported brush format.
                    TRC_ALT((TB, "Brush of unsupported format %d",
                            (UINT32)psoPattern->iBitmapFormat));
                    iBytes = 0;
                    brushSupported = FALSE;
                }
                break;
            }
        }
#else
        switch (psoPattern->iBitmapFormat)
        {
            case BMF_1BPP:
            {
                // every 8 pixels take a byte @ 1bpp
                iBytes = 8;
                for (i = 7; i >= 0; i--) {
                    brushBits[i] = *pData;
                    pData += psoPattern->lDelta;
                }
            }
            break;

            case BMF_4BPP:
            {
                // Copy over the brush bits at 1 byte / pixel and track how many
                // unique colors we have.  The vast vast majority of brushes are
                // 4 colors or less.
                iBytes = 64;
                memset(palette, 0, sizeof(palette));
                colorCount = 0;

                for (i = 7; i >= 0; i--) {
                    currIndex = i * 8;
                    for (j = 0; j < 4; j++) {
                        color1 = XLATEOBJ_iXlate(pxlo, (pData[j] >> 4));
                        color2 = XLATEOBJ_iXlate(pxlo, (pData[j] & 0x0F));
                        brushBits[currIndex] = (BYTE) color1;
                        brushBits[currIndex + 1] = (BYTE) color2;
                        currIndex += 2;

                        if (palette[color1] && palette[color2])
                            continue;

                        // If possible assign each unique color a two bit index
                        if (!palette[color1]) {
                            if (colorCount < MAX_BRUSH_ENCODE_COLORS)
                                colors[colorCount] = color1;
                            colorCount++;
                            palette[color1] = (BYTE) colorCount;
                        }

                        if (!palette[color2]) {
                            if (colorCount < MAX_BRUSH_ENCODE_COLORS)
                                colors[colorCount] = color2;
                            colorCount++;
                            palette[color2] = (BYTE) colorCount;
                        }
                    }
                    pData += psoPattern->lDelta;
                }

                // The encoding value was set one larger than it should
                // have been so adjust it
                if (colorCount <= MAX_BRUSH_ENCODE_COLORS) {
                    for (currColor = 0; currColor < colorCount; currColor++) {
                        palette[colors[currColor]]--;
                    }
                }

                brushSupported = (colorCount <= 2) ||
                                 (brushSupportLevel > TS_BRUSH_DEFAULT);
            }
            break;

            case BMF_8BPP:
            {
                // Copy over the brush bits and track how many unique colors
                // we have.  The vast vast majority of brushes are 4 colors
                // or less.
                iBytes = 64;
                memset(palette, 0, sizeof(palette));
                colorCount = 0;

                for (i = 7; i >= 0; i--) {
                    currIndex = i * 8;
                    for (j = 0; j < 8; j++) {
                        currColor = XLATEOBJ_iXlate(pxlo, pData[j]);
                        brushBits[currIndex] = (BYTE) currColor;
                        currIndex++;

                        // assign each unique color a two bit index
                        if (palette[currColor]) {
                            continue;
                        }
                        else {
                            if (colorCount < MAX_BRUSH_ENCODE_COLORS)
                                colors[colorCount] = currColor;
                            colorCount++;
                            palette[currColor] = (BYTE) colorCount;
                        }
                    }

                    pData += psoPattern->lDelta;
                }

                // The encoding value was set one larger than it should
                // have been so adjust it
                if (colorCount <= MAX_BRUSH_ENCODE_COLORS) {
                    for (currColor = 0; currColor < colorCount; currColor++)
                        palette[colors[currColor]]--;
                }

                brushSupported = (colorCount <= 2) ||
                        (brushSupportLevel > TS_BRUSH_DEFAULT);
            }
            break;

            default:
            {
                // Unsupported colour depth.
                iBytes = 0;
                brushSupported = FALSE;
            }
            break;
        }
#endif
    }
    else {
        iBitmapFormat = psoPattern->iBitmapFormat;

        // The brush is the wrong size or requires dithering and so cannot
        // be sent over the wire.
#ifdef DC_HICOLOR
        TRC_ALT((TB, "Non-8x8 or dithered brush"));
#endif
        brushSupported = FALSE;
    }

    // Store the brush.
    if (brushSupported) {
        if (colorCount <= 2)
            INC_OUTCOUNTER(OUT_BRUSH_MONO);

        // Store the brush - note that if we have a monochrome brush the
        // color bit is set up so that 0 = color2 and 1 = color1. This
        // actually corresponds to 0 = fg and 1 = bg for the protocol
        // colors.
        TRC_DBG((TB, "Storing brush: type %d bg %x fg %x",
                     psoPattern->iBitmapFormat,
                     colors[0],
                     colors[1]));

        rc = OEStoreBrush(ppdev,
                          pbo,
                          BS_PATTERN,
                          iBitmapFormat,
                          &psoPattern->sizlBitmap,
                          iBytes,
                          brushBits,
                          pxlo,
                          0,
                          palette,
                          colors,
                          colorCount);
    }
    else
    {
        if (!iBytes) {
            TRC_ALT((TB, "Rejected brush h %08lx s (%ld, %ld) fmt %lu",
                         iHatch,
                         psoPattern != NULL ? psoPattern->sizlBitmap.cx : 0,
                         psoPattern != NULL ? psoPattern->sizlBitmap.cy : 0,
                         psoPattern != NULL ? psoPattern->iBitmapFormat : 0));
        }
        rc = OEStoreBrush(ppdev, pbo, BS_NULL, iBitmapFormat,
                          &psoPattern->sizlBitmap, iBytes, brushBits, pxlo,
                          0, NULL, NULL, 0);
        INC_OUTCOUNTER(OUT_BRUSH_REJECTED);
    }

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}


/****************************************************************************/
// OE_RectIntersectsSDA
//
// Returns nonzero if the supplied exclusive rect intersects any of the
// current screen data areas.
/****************************************************************************/
BOOL RDPCALL OE_RectIntersectsSDA(PRECTL pRect)
{
    RECTL aBoundRects[BA_MAX_ACCUMULATED_RECTS];
    unsigned cBounds;
    BOOL fIntersection = FALSE;
    unsigned i;

    DC_BEGIN_FN("OE_RectIntersectsSDA");

    // Fetch the current Screen Data Area (SDA). It is returned in
    // virtual desktop (inclusive) coordinates.
    BA_QueryBounds(aBoundRects, &cBounds);

    // Loop through each of the bounding rectangles checking for
    // an intersection with the supplied rectangle.
    // Note we use '<' for pRect->right and pRect->bottom because *pRect is
    // in exclusive coords.
    for (i = 0; i < cBounds; i++) {
        if (aBoundRects[i].left < pRect->right &&
                aBoundRects[i].top < pRect->bottom &&
                aBoundRects[i].right > pRect->left &&
                aBoundRects[i].bottom > pRect->top) {
            TRC_NRM((TB, "ExclRect(%d,%d)(%d,%d) intersects SDA(%d,%d)(%d,%d)",
                    pRect->left, pRect->top, pRect->right, pRect->bottom,
                    aBoundRects[i].left, aBoundRects[i].top,
                    aBoundRects[i].right, aBoundRects[i].bottom));
            fIntersection = TRUE;
            break;
        }
    }

    DC_END_FN();
    return fIntersection;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpdd\noedata.c ===
/****************************************************************************/
// noedata.c
//
// RDP Order Encoder data definitions
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <ndcgdata.h>
#include <aordprot.h>
#include <noedisp.h>


// Are non-solid brushes supported?
DC_DATA(BOOLEAN, oeSendSolidPatternBrushOnly, FALSE);

// Flag that indicates support for color indices rather than RGBs.
DC_DATA(BOOLEAN, oeColorIndexSupported, FALSE);

// Flag set and tested by DrvStretchBlt, cleared by DrvBitBlt. It
// indicates whether StretchBlt output has been drawn (and hence
// accumulated) by DrvBitBlt.
DC_DATA(BOOLEAN, oeAccumulateStretchBlt, FALSE);

// Array of supported orders.
DC_DATA_ARRAY_NULL(BYTE, oeOrderSupported, TS_MAX_ORDERS, DC_STRUCT1(0));

#ifdef DRAW_NINEGRID
// Translation table, indexed by TS_ENC_XXX_ORDER, values are corresponding
// TS_NEG_XXX_INDEX. Orders we do not support for sending are given the
// value 0xFF to force an error.
DC_CONST_DATA_ARRAY(BYTE, oeEncToNeg, TS_MAX_ORDERS,
    DC_STRUCT32(
        TS_NEG_DSTBLT_INDEX,
        TS_NEG_PATBLT_INDEX,
        TS_NEG_SCRBLT_INDEX,
        0xFF,  // TS_NEG_MEMBLT_INDEX (historical, never encoded)
        0xFF,  // TS_NEG_MEM3BLT_INDEX (historical, never encoded)
        0xFF,  // TS_NEG_ATEXTOUT_INDEX (no longer supported)
        0xFF,  // TS_NEG_AEXTTEXTOUT_INDEX (no longer supported)
        TS_NEG_DRAWNINEGRID_INDEX,
        TS_NEG_MULTI_DRAWNINEGRID_INDEX,
        TS_NEG_LINETO_INDEX,
        TS_NEG_OPAQUERECT_INDEX,
        TS_NEG_SAVEBITMAP_INDEX,
        0xFF,
        TS_NEG_MEMBLT_INDEX,   // Actually TS_NEG_MEM(3)BLT_R2_ORDER, but
        TS_NEG_MEM3BLT_INDEX,  // the caps are specified with non-R2 bits.
        TS_NEG_MULTIDSTBLT_INDEX,
        TS_NEG_MULTIPATBLT_INDEX,
        TS_NEG_MULTISCRBLT_INDEX,
        TS_NEG_MULTIOPAQUERECT_INDEX,
        TS_NEG_FAST_INDEX_INDEX,
        TS_NEG_POLYGON_SC_INDEX,              
        TS_NEG_POLYGON_CB_INDEX,  
        TS_NEG_POLYLINE_INDEX,
        0xFF,  // Unused 0x17
        TS_NEG_FAST_GLYPH_INDEX,
        TS_NEG_ELLIPSE_SC_INDEX,  
        TS_NEG_ELLIPSE_CB_INDEX,
        TS_NEG_INDEX_INDEX,
        0xFF,  // TS_NEG_WTEXTOUT_INDEX (no longer supported)
        0xFF,  // TS_NEG_WEXTTEXTOUT_INDEX (no longer supported)
        0xFF,  // TS_NEG_WLONGTEXTOUT_INDEX (no longer supported)
        0xFF   // TS_NEG_WLONGEXTTEXTOUT_INDEX (no longer supported)
    ));
#else
// Translation table, indexed by TS_ENC_XXX_ORDER, values are corresponding
// TS_NEG_XXX_INDEX. Orders we do not support for sending are given the
// value 0xFF to force an error.
DC_CONST_DATA_ARRAY(BYTE, oeEncToNeg, TS_MAX_ORDERS,
    DC_STRUCT32(
        TS_NEG_DSTBLT_INDEX,
        TS_NEG_PATBLT_INDEX,
        TS_NEG_SCRBLT_INDEX,
        0xFF,  // TS_NEG_MEMBLT_INDEX (historical, never encoded)
        0xFF,  // TS_NEG_MEM3BLT_INDEX (historical, never encoded)
        0xFF,  // TS_NEG_ATEXTOUT_INDEX (no longer supported)
        0xFF,  // TS_NEG_AEXTTEXTOUT_INDEX (no longer supported)
        0xFF,
        0xFF,
        TS_NEG_LINETO_INDEX,
        TS_NEG_OPAQUERECT_INDEX,
        TS_NEG_SAVEBITMAP_INDEX,
        0xFF,
        TS_NEG_MEMBLT_INDEX,   // Actually TS_NEG_MEM(3)BLT_R2_ORDER, but
        TS_NEG_MEM3BLT_INDEX,  // the caps are specified with non-R2 bits.
        TS_NEG_MULTIDSTBLT_INDEX,
        TS_NEG_MULTIPATBLT_INDEX,
        TS_NEG_MULTISCRBLT_INDEX,
        TS_NEG_MULTIOPAQUERECT_INDEX,
        TS_NEG_FAST_INDEX_INDEX,
        TS_NEG_POLYGON_SC_INDEX,              
        TS_NEG_POLYGON_CB_INDEX,  
        TS_NEG_POLYLINE_INDEX,
        0xFF,  // Unused 0x17
        TS_NEG_FAST_GLYPH_INDEX,
        TS_NEG_ELLIPSE_SC_INDEX,  
        TS_NEG_ELLIPSE_CB_INDEX,
        TS_NEG_INDEX_INDEX,
        0xFF,  // TS_NEG_WTEXTOUT_INDEX (no longer supported)
        0xFF,  // TS_NEG_WEXTTEXTOUT_INDEX (no longer supported)
        0xFF,  // TS_NEG_WLONGTEXTOUT_INDEX (no longer supported)
        0xFF   // TS_NEG_WLONGEXTTEXTOUT_INDEX (no longer supported)
    ));
#endif

// Storage space to create a temporary solid brush for BitBlt orders.
DC_DATA_NULL(OE_BRUSH_DATA, oeBrushData, DC_STRUCT1(0));

// Running font ID.
DC_DATA(UINT32, oeFontId, 0);

// Running TextOut ID.
DC_DATA(UINT32, oeTextOut, 0);

// Last drawing surface                                                     
DC_DATA(PDD_DSURF, oeLastDstSurface, 0);

// Current offscreen bitmap cache size
DC_DATA(UINT32, oeCurrentOffscreenCacheSize, 0);

// Encoding temp buffer to assemble the intermediate format prior to field
// encoding and clipping.
DC_DATA_ARRAY_UNINIT(BYTE, oeTempOrderBuffer, MAX_ORDER_INTFMT_SIZE);

// Temp intermediate workspace for Mem(3)Blt order creation.
DC_DATA(MEM3BLT_R2_ORDER, oeTempMemBlt, DC_STRUCT1(0));

// Order encoding states.
DC_DATA(MEMBLT_R2_ORDER, PrevMemBlt, DC_STRUCT1(0));
DC_DATA(MEM3BLT_R2_ORDER, PrevMem3Blt, DC_STRUCT1(0));
DC_DATA(DSTBLT_ORDER, PrevDstBlt, DC_STRUCT1(0));
DC_DATA(MULTI_DSTBLT_ORDER, PrevMultiDstBlt, DC_STRUCT1(0));
DC_DATA(PATBLT_ORDER, PrevPatBlt, DC_STRUCT1(0));
DC_DATA(MULTI_PATBLT_ORDER, PrevMultiPatBlt, DC_STRUCT1(0));
DC_DATA(SCRBLT_ORDER, PrevScrBlt, DC_STRUCT1(0));
DC_DATA(MULTI_SCRBLT_ORDER, PrevMultiScrBlt, DC_STRUCT1(0));
DC_DATA(OPAQUERECT_ORDER, PrevOpaqueRect, DC_STRUCT1(0));
DC_DATA(MULTI_OPAQUERECT_ORDER, PrevMultiOpaqueRect, DC_STRUCT1(0));

DC_DATA(LINETO_ORDER, PrevLineTo, DC_STRUCT1(0));
DC_DATA(POLYLINE_ORDER, PrevPolyLine, DC_STRUCT1(0));
DC_DATA(POLYGON_SC_ORDER, PrevPolygonSC, DC_STRUCT1(0));
DC_DATA(POLYGON_CB_ORDER, PrevPolygonCB, DC_STRUCT1(0));
DC_DATA(ELLIPSE_SC_ORDER, PrevEllipseSC, DC_STRUCT1(0));
DC_DATA(ELLIPSE_CB_ORDER, PrevEllipseCB, DC_STRUCT1(0));

DC_DATA(FAST_INDEX_ORDER, PrevFastIndex, DC_STRUCT1(0));
DC_DATA(FAST_GLYPH_ORDER, PrevFastGlyph, DC_STRUCT1(0));
DC_DATA(INDEX_ORDER, PrevGlyphIndex, DC_STRUCT1(0));

#ifdef DRAW_NINEGRID
DC_DATA(DRAWNINEGRID_ORDER, PrevDrawNineGrid, DC_STRUCT1(0));
DC_DATA(MULTI_DRAWNINEGRID_ORDER, PrevMultiDrawNineGrid, DC_STRUCT1(0));
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpdd\npmdisp.h ===
/****************************************************************************/
// npmdisp.h
//
// RDP Palette Manager display driver header
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/
#ifndef _H_NPMDISP
#define _H_NPMDISP


void RDPCALL PM_InitShm(PDD_PDEV);



#endif /* _H_NPMDISP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpdd\noedisp.h ===
/****************************************************************************/
// noedisp.h
//
// DD-only definitions and prototypes for OE.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/
#ifndef __NOEDISP_H
#define __NOEDISP_H

#include <aoeapi.h>
#include <nddapi.h>
#include <aoaapi.h>
#include <nsbcdisp.h>
#include <aordprot.h>

// From Winbench99 Business Graphics benchmark, we found
// creating offscreen bitmaps of 2K or smaller does not
// improve our bandwidth. This parameter needs to be highly
// tuned. 
// We also don't want to cache any cursor bitmaps for offscreen
// the maximum cursor size is 32x32, which is less than the 
// minBitmapSize.
#define MIN_OFFSCREEN_BITMAP_PIXELS  2048

/****************************************************************************/
/* Number of rectangles that can make up a clip region before it is too     */
/* complicated to send as an order.                                         */
/*                                                                          */
/* The File Open dialog is drawn with 41 clip rects(!), so we use a number  */
/* larger than this to allow it to be sent as orders rather than Screen     */
/* Data,                                                                    */
/****************************************************************************/
#define COMPLEX_CLIP_RECT_COUNT     45

/****************************************************************************/
// Define minimum and maximum coords. Note that positive value needs to be
// one less than the max signed 16-bit value since on 16-bit clients,
// conversion from inclusive to exclusive coords for sending to GDI
// would otherwise overflow.
/****************************************************************************/
#define OE_MIN_COORD -32768
#define OE_MAX_COORD  32766

#define OE_GL_MAX_INDEX_ENTRIES 256


typedef struct tagGLYPHCONTEXT
{
    UINT32   fontId;
    UINT_PTR cacheTag;
    unsigned cbDataSize;
    unsigned cbTotalDataSize;
    unsigned cbBufferSize;
    unsigned nCacheHit;
    unsigned nCacheIndex;
    unsigned rgCacheIndex[OE_GL_MAX_INDEX_ENTRIES];
    unsigned indexNextSend;
} GLYPHCONTEXT, *PGLYPHCONTEXT;

#define OE_FG_MIN_FRAG_SIZE 10
#define OE_FG_MAX_FRAG_SIZE 28

typedef struct tagFRAGCONTEXT
{
    void *cacheHandle;
    unsigned cbCellSize;
    unsigned nCacheIndex;
    unsigned rgCacheIndex[OE_GL_MAX_INDEX_ENTRIES];
} FRAGCONTEXT, *PFRAGCONTEXT;


/****************************************************************************/
/* Structure to store brushes used as BLT patterns.                         */
/*                                                                          */
/* style     - Standard brush style (used in order to send brush type).     */
/*             BS_HATCHED                                                   */
/*             BS_PATTERN                                                   */
/*             BS_SOLID                                                     */
/*             BS_NULL                                                      */
/*                                                                          */
/* hatch     - Standard hatch definition.  Can be one of the following.     */
/*             style = BS_HATCHED                                           */
/*             HS_HORIZONTAL                                                */
/*             HS_VERTICAL                                                  */
/*             HS_FDIAGONAL                                                 */
/*             HS_BDIAGONAL                                                 */
/*             HS_CROSS                                                     */
/*             HS_DIAGCROSS                                                 */
/*                                                                          */
/*             style = BS_PATTERN                                           */
/*                                                                          */
/*             This field contains the first byte of the brush definition   */
/*             from the brush bitmap.                                       */
/*                                                                          */
/* brushData - bit data for the brush.                                      */
/*                                                                          */
/* fore      - foreground color for the brush                               */
/*                                                                          */
/* back      - background color for the brush                               */
/*                                                                          */
/* brushData - bit data for the brush (8x8x1bpp - 1 (see above) = 7 bytes)  */
/****************************************************************************/
#define MAX_UNIQUE_COLORS 256

typedef struct tagOE_BRUSH_DATA
{
    BYTE    style;
    BYTE    hatch;
    UINT16  pad1;
    INT32   brushId;
    UINT32  cacheEntry;
    DCCOLOR fore;
    DCCOLOR back;
    ULONG   iBitmapFormat;
    SIZEL   sizlBitmap;
    UINT32  key1, key2;
    ULONG   iBytes;
    BYTE    brushData[7];
} OE_BRUSH_DATA, *POE_BRUSH_DATA;


/****************************************************************************/
/* Structure allowing sufficient stack to be allocated for an ENUMRECTS     */
/* structure containing more than one (in fact COMPLEX_CLIP_RECT_COUNT)     */
/* rectangles.                                                              */
/* This holds one RECTL more than we need to allow us to determine whether  */
/* there are too many rects for order encoding by making a single call to   */
/* CLIPOBJ_bEnumRects.                                                      */
/****************************************************************************/
typedef struct tagOE_ENUMRECTS
{
    ENUMRECTS rects;
    RECTL     extraRects[COMPLEX_CLIP_RECT_COUNT];
} OE_ENUMRECTS;


/****************************************************************************/
// OS specific RECTL to well-ordered RECT conversion macro.
/****************************************************************************/
#define RECT_FROM_RECTL(dcr, rec)   if (rec.right >= rec.left) {             \
                                        dcr.left   = rec.left;               \
                                        dcr.right  = rec.right;              \
                                    }                                        \
                                    else {                                   \
                                        dcr.left   = rec.right;              \
                                        dcr.right  = rec.left;               \
                                    }                                        \
                                    if (rec.bottom >= rec.top) {             \
                                        dcr.top    = rec.top;                \
                                        dcr.bottom = rec.bottom;             \
                                    }                                        \
                                    else {                                   \
                                        dcr.bottom = rec.top;                \
                                        dcr.top    = rec.bottom;             \
                                    }


/****************************************************************************/
// RECTFX to RECT conversion macro. Note that this macro guarantees to return
// a well-ordered rectangle.
//
// A RECTFX uses fixed point (28.4 bit) numbers so we need to truncate the
// fraction and move to the correct integer value, i.e. shift right 4 bits.
/****************************************************************************/
#define RECT_FROM_RECTFX(dcr, rec)                                           \
                                if (rec.xRight >= rec.xLeft) {               \
                                    dcr.left  = FXTOLFLOOR(rec.xLeft);       \
                                    dcr.right = FXTOLCEILING(rec.xRight);    \
                                }                                            \
                                else {                                       \
                                    dcr.left  = FXTOLFLOOR(rec.xRight);      \
                                    dcr.right = FXTOLCEILING(rec.xLeft);     \
                                }                                            \
                                if (rec.yBottom >= rec.yTop) {               \
                                    dcr.top   = FXTOLFLOOR(rec.yTop);        \
                                    dcr.bottom= FXTOLCEILING(rec.yBottom);   \
                                }                                            \
                                else {                                       \
                                    dcr.bottom= FXTOLCEILING(rec.yTop);      \
                                    dcr.top   = FXTOLFLOOR(rec.yBottom);     \
                                }

/****************************************************************************/
// cast 32bit rectl to 16bit rect
/****************************************************************************/
#define RECTL_TO_TSRECT16(dst, src) \
    (dst).left = (TSINT16)(src).left; \
    (dst).top = (TSINT16)(src).top; \
    (dst).right = (TSINT16)(src).right; \
    (dst).bottom = (TSINT16)(src).bottom;
    
/****************************************************************************/
// cast 32bit pointl to 16bit point
/****************************************************************************/
#define POINTL_TO_TSPOINT16(dst, src) \
    (dst).x = (TSINT16)(src).x; \
    (dst).y = (TSINT16)(src).y; 
    
/****************************************************************************/
// POINTFIX to POINTL conversion macro.
/****************************************************************************/
#define POINT_FROM_POINTFIX(dcp, pnt) dcp.x = FXTOLROUND(pnt.x);  \
                                      dcp.y = FXTOLROUND(pnt.y)

/****************************************************************************/
// ROP codes and conversions.
/****************************************************************************/
#define ROP3_NO_PATTERN(rop) ((rop & 0x0f) == (rop >> 4))
#define ROP3_NO_SOURCE(rop)  ((rop & 0x33) == ((rop & 0xCC) >> 2))
#define ROP3_NO_TARGET(rop)  ((rop & 0x55) == ((rop & 0xAA) >> 1))

// Checking for SRCCOPY, PATCOPY, BLACKNESS, WHITENESS
#define ROP3_IS_OPAQUE(rop)  (((rop) == 0xCC) || ((rop) == 0xF0) || \
                              ((rop) == 0x00) || ((rop) == 0xFF) )

#define OE_PATCOPY_ROP 0xF0
#define OE_COPYPEN_ROP3 0xF0

// ROP4 to ROP3 conversion macros. Note that we don't use the full Windows
// 3-way ROP code - we are only interested in the index byte.
#define ROP3_HIGH_FROM_ROP4(rop) ((BYTE)((rop & 0xff00) >> 8))
#define ROP3_LOW_FROM_ROP4(rop)  ((BYTE)((rop & 0x00ff)))

// Rop 0x5f is used by MSDN to highlight search keywords. This XOR's a
// pattern with the destination, producing markedly different (and
// sometimes unreadable) shadow output. As this rop appears not to be
// widely used in other scenarios, we special-case not encoding it.
#define OESendRop3AsOrder(_rop3) ((_rop3) != 0x5F)


/****************************************************************************/
// Extra font info specific to our driver.
/****************************************************************************/
typedef struct
{
    UINT32 fontId;
    INT32  cacheId;
    void   *cacheHandle;
    INT32  shareId;
    UINT32 listIndex;
} FONTCACHEINFO, *PFONTCACHEINFO;


/****************************************************************************/
// Prototypes
/****************************************************************************/

void OE_InitShm();

void RDPCALL OE_Update();

void OE_Reset();

void OE_ClearOrderEncoding();

BOOL RDPCALL OE_RectIntersectsSDA(PRECTL);

#ifdef NotUsed
void  RDPCALL OEConvertMask(
        ULONG   mask,
        PUSHORT pBitDepth,
        PUSHORT pShift);
#endif

void  RDPCALL OEConvertColor(
        PDD_PDEV ppdev,
        DCCOLOR  *pDCColor,
        ULONG    osColor,
        XLATEOBJ *pxlo);

BOOL  RDPCALL OEStoreBrush(PDD_PDEV ppdev,
                           BRUSHOBJ* pbo,
                           BYTE      style,
                           ULONG     iBitmapFormat,
                           SIZEL     *sizlBitmap,
                           ULONG     iBytes,
                           PBYTE     pBits,
                           XLATEOBJ* pxlo,
                           BYTE      hatch,
                           PBYTE     pEncode,
                           PUINT32   pColors,
                           UINT32    numColors);

BOOL RDPCALL OECheckBrushIsSimple(
        PDD_PDEV       ppdev,
        BRUSHOBJ       *pbo,
        POE_BRUSH_DATA *ppBrush);

PFONTCACHEINFO RDPCALL OEGetFontCacheInfo(FONTOBJ *);

unsigned OEGetIntersectionsWithClipRects(RECTL *, OE_ENUMRECTS *,
        OE_ENUMRECTS *);

unsigned OEBuildPrecodeMultiClipFields(OE_ENUMRECTS *, BYTE **,
        UINT32 *, BYTE *);

void RDPCALL OEClipAndAddScreenDataAreaByIntersectRects(PRECTL, OE_ENUMRECTS *);

void RDPCALL OEClipAndAddScreenDataArea(PRECTL, CLIPOBJ *);

unsigned OEDirectEncodeRect(RECTL *, RECT *, BYTE **, BYTE *);

BOOL RDPCALL OETileBitBltOrder(PDD_PDEV, PPOINTL, RECTL *, unsigned,
        unsigned, PMEMBLT_ORDER_EXTRA_INFO, OE_ENUMRECTS *);

BOOL RDPCALL OEAddTiledBitBltOrder(PDD_PDEV, PINT_ORDER,
        PMEMBLT_ORDER_EXTRA_INFO, OE_ENUMRECTS *, int, int);

BOOL RDPCALL OEEncodeLineToOrder(PDD_PDEV, PPOINTL, PPOINTL, UINT32,
        UINT32, OE_ENUMRECTS *);

BOOL RDPCALL OEEncodeOpaqueRect(RECTL *, BRUSHOBJ *, PDD_PDEV, OE_ENUMRECTS *);

BOOL RDPCALL OEEncodePatBlt(PDD_PDEV, BRUSHOBJ *, RECTL *, POINTL *, BYTE,
        OE_ENUMRECTS *);

BOOL RDPCALL OEEncodeMemBlt(RECTL *, MEMBLT_ORDER_EXTRA_INFO *, unsigned,
        unsigned, BYTE, POINTL *, POINTL *, BRUSHOBJ *, PDD_PDEV,
        OE_ENUMRECTS *);

BOOL RDPCALL OEEncodeScrBlt(RECTL *, BYTE, POINTL *, PDD_PDEV, OE_ENUMRECTS *,
        CLIPOBJ *);

BOOL RDPCALL OEEncodeDstBlt(RECTL *, BYTE, PDD_PDEV, OE_ENUMRECTS *);

#ifdef DRAW_NINEGRID
BOOL RDPCALL OEEncodeDrawNineGrid(RECTL *, RECTL *, unsigned, PDD_PDEV,
        OE_ENUMRECTS *);
#endif

BOOL RDPCALL OESendSwitchSurfacePDU(PDD_PDEV ppdev, PDD_DSURF pdsurf);

unsigned OEBuildMultiClipOrder(PDD_PDEV,
        CLIP_RECT_VARIABLE_CODEDDELTALIST *, OE_ENUMRECTS *);

BOOL OEEmitReplayOrders(PDD_PDEV, unsigned, OE_ENUMRECTS *);

BOOL RDPCALL OECacheGlyphs(STROBJ *, FONTOBJ *, PFONTCACHEINFO, PGLYPHCONTEXT);

BOOL RDPCALL OESendGlyphs(SURFOBJ *, STROBJ *, FONTOBJ *,
        PFONTCACHEINFO, PGLYPHCONTEXT);

BOOL OESendGlyphAndIndexOrder(PDD_PDEV, STROBJ *, OE_ENUMRECTS *, PRECTL,
        POE_BRUSH_DATA, PFONTCACHEINFO, PGLYPHCONTEXT);

unsigned RDPCALL OESendIndexOrder(PDD_PDEV, STROBJ *, OE_ENUMRECTS *, PRECTL,
        POE_BRUSH_DATA, PFONTCACHEINFO, PGLYPHCONTEXT, unsigned,
        unsigned, int, int, int, int, int, int, PBYTE, unsigned);

BOOL RDPCALL OESendIndexes(SURFOBJ *, STROBJ *, FONTOBJ *, OE_ENUMRECTS *,
        PRECTL, POE_BRUSH_DATA, POINTL *, PFONTCACHEINFO, PGLYPHCONTEXT);

void OETransformClipRectsForScrBlt(OE_ENUMRECTS *, PPOINTL, RECTL *, CLIPOBJ *);

BOOL RDPCALL OEGetClipRects(CLIPOBJ *, OE_ENUMRECTS *);

BOOL RDPCALL OEDeviceBitmapCachable(PDD_PDEV ppdev, SIZEL sizl, ULONG iFormat);

#ifdef PERF_SPOILING
BOOL RDPCALL OEIsSDAIncluded(PRECTL pRects, UINT rectCount);
#endif

#ifdef DRAW_NINEGRID
#if 0
// These are the drawstream prototype work, keep it for future reference
BOOL RDPCALL OESendCreateDrawStreamOrder(PDD_PDEV ppdev, 
        unsigned drawStreamBitmapId, SIZEL *sizl, unsigned bitmapBpp);

BOOL RDPCALL OESendDrawStreamOrder(PDD_PDEV ppdev, unsigned bitmapId, 
        unsigned ulIn, PVOID pvIn, PPOINTL dstOffset, RECTL *bounds, 
        OE_ENUMRECTS *clipRects);

BOOL RDPCALL OESendDrawNineGridOrder(PDD_PDEV ppdev, unsigned bitmapId, 
        PRECTL prclSrc, RECTL *bounds, OE_ENUMRECTS *clipRects);
#endif

BOOL RDPCALL OESendCreateNineGridBitmapOrder(PDD_PDEV ppdev, unsigned bitmapId, 
        SIZEL *sizl, unsigned bitmapBpp, PNINEGRID png);

BOOL RDPCALL OECacheDrawNineGridBitmap(PDD_PDEV ppdev, SURFOBJ *psoSrc, 
                                       PNINEGRID png, unsigned *bitmapId);

BOOL RDPCALL OESendStreamBitmapOrder(PDD_PDEV ppdev, unsigned bitmapId, 
        SIZEL *sizl, unsigned bitmapBpp, PBYTE BitmapBuffer, unsigned BitmapSize, 
        BOOL compressed);
#endif

#ifdef DRAW_GDIPLUS
BOOL RDPCALL OECreateDrawGdiplusOrder(PDD_PDEV ppdev, RECTL *prcl, ULONG cjIn, PVOID pvIn);

BOOL RDPCALL OECacheDrawGdiplus(PDD_PDEV ppdev, PVOID pvIn, unsigned int *CacheID);

BOOL RDPCALL OESendDrawGdiplusOrder(PDD_PDEV ppdev, RECTL *prcl, ULONG cjIn, PVOID pvIn, ULONG TotalEmfSize);

BOOL RDPCALL OESendDrawGdiplusCacheOrder(PDD_PDEV ppdev, PVOID pvIn, unsigned int *CacheID, TSUINT16 CacheType, 
                                         TSUINT16 RemoveCacheNum, TSUINT16 *RemoveCacheIDList);
#endif

#define CLIPRECTS_OK               0
#define CLIPRECTS_TOO_COMPLEX      1
#define CLIPRECTS_NO_INTERSECTIONS 2
unsigned RDPCALL OEGetIntersectingClipRects(CLIPOBJ *, RECTL *, unsigned,
        OE_ENUMRECTS *);


/****************************************************************************/
// Inlined functions
/****************************************************************************/

/****************************************************************************/
// OEClipPoint
//
// Clips a point to a 16-bit range.
/****************************************************************************/
__inline void RDPCALL OEClipPoint(PPOINTL pPoint)
{
    if (pPoint->x >= OE_MIN_COORD && pPoint->x <= OE_MAX_COORD)
        goto ClipY;
    if (pPoint->x > OE_MAX_COORD)
        pPoint->x = OE_MAX_COORD;
    else if (pPoint->x < OE_MIN_COORD)
        pPoint->x = OE_MIN_COORD;

ClipY:
    if (pPoint->y >= OE_MIN_COORD && pPoint->y <= OE_MAX_COORD)
        return;
    if (pPoint->y > OE_MAX_COORD)
        pPoint->y = OE_MAX_COORD;
    else if (pPoint->y < OE_MIN_COORD)
        pPoint->y = OE_MIN_COORD;
}


/****************************************************************************/
// OEClipRect
//
// Clips a rect to be within the 16-bit wire encoding size.
/****************************************************************************/
__inline void RDPCALL OEClipRect(PRECTL pRect)
{
    OEClipPoint((PPOINTL)(&pRect->left));
    OEClipPoint((PPOINTL)(&pRect->right));
}



#endif  // !defined(__NOEDISP_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpdd\npmdisp.c ===
/****************************************************************************/
// npmdisp.c
//
// RDP Palette Manager display driver code.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <precmpdd.h>
#define hdrstop

#define TRC_FILE "npmdisp"
#include <adcg.h>
#include <atrcapi.h>

#include <apmapi.h>
#include <nddapi.h>
#include <npmdisp.h>
#include <nsbcdisp.h>

#define DC_INCLUDE_DATA
#include <ndddata.c>
#undef DC_INCLUDE_DATA

#include <nsbcinl.h>


/****************************************************************************/
// PM_InitShm
//
// Alloc-time SHM init.
/****************************************************************************/
void RDPCALL PM_InitShm(PDD_PDEV pPDev)
{
    int i;

    DC_BEGIN_FN("PM_InitShm");

    DC_IGNORE_PARAMETER(pPDev);

    // There are several options here:
    // - Connecting or reconnecting to a 4bpp client: we need to create a
    //     default VGA palette.
    // - Connecting or reconnecting to an 8bpp client: it doesn't really
    //     matter what we do here as the first call to DrvSetPalette() will
    //     overwrite anything we set up.
    // - Shadowing a console session: if the console's primary monitor is
    //     >8bpp, DrvSetPalette will never get called.  Our chained console DD
    //     always runs at 8bpp so we set up an 8bpp rainbow palette which also
    //     contains the standard windows colors.
    if (!ddConsole) {
        // This is a connect or reconnect to a non-console session.
        TRC_NRM((TB, "Create default 4BPP palette"));

        for (i = 16; i < 248; i++) {
            // Fill unused slots with some shade of pink.
            pddShm->pm.palette[i].rgbBlue = 255;
            pddShm->pm.palette[i].rgbGreen = 128;
            pddShm->pm.palette[i].rgbRed = 128;
        }

        // Copy real VGA colors
        // - copy entire 16-color palette into slots 0-15
        // - copy high colors (8-15) into high end of palette (240-255)
        memcpy(&(pddShm->pm.palette[0]),
                  ddDefaultVgaPalette,
                  sizeof(ddDefaultVgaPalette));
        memcpy(&(pddShm->pm.palette[248]),
                  &(ddDefaultVgaPalette[8]),
                  sizeof(* ddDefaultVgaPalette) * 8);
    }
    else {
        // This is a chained console DD -- this always runs at 8bpp and we
        // must create a default rainbow palette.
        PALETTEENTRY *ppalTmp;
        ULONG        ulLoop;
        BYTE         jRed;
        BYTE         jGre;
        BYTE         jBlu;

        TRC_NRM((TB, "Create default 8BPP rainbow palette"));

        // cColors == 256
        // Generate 256 (8*8*4) RGB combinations to fill the palette
        jRed = 0;
        jGre = 0;
        jBlu = 0;

        ppalTmp = (PALETTEENTRY *)(pddShm->pm.palette);

        for (ulLoop = 256; ulLoop != 0; ulLoop--) {
            // JPB: The values used in the default rainbow set of colors do
            // not particularly matter.  However, we do not want any of the
            // entries to match entries in the default VGA colors.
            // Therefore we tweak the color values slightly to ensure that
            // there are no matches.
            ppalTmp->peRed   = ((jRed == 0) ? (jRed+1) : (jRed-1));
            ppalTmp->peGreen = ((jGre == 0) ? (jGre+1) : (jGre-1));
            ppalTmp->peBlue  = ((jBlu == 0) ? (jBlu+1) : (jBlu-1));
            ppalTmp->peFlags = 0;

            ppalTmp++;

            if (!(jRed += 32))
                if (!(jGre += 32))
                    jBlu += 64;
        }

        // Now copy in the system colors.
        memcpy(&(pddShm->pm.palette[0]),
                  ddDefaultPalette,
                  sizeof(* ddDefaultPalette) * 10);

        memcpy(&(pddShm->pm.palette[246]),
                  &(ddDefaultPalette[10]),
                  sizeof(* ddDefaultPalette) * 10);
    }

    pddShm->pm.paletteChanged = TRUE;

    DC_END_FN();
}


/****************************************************************************/
// DrvSetPalette - see NT DDK documentation.
/****************************************************************************/
BOOL DrvSetPalette(
        DHPDEV dhpdev,
        PALOBJ *ppalo,
        FLONG  fl,
        ULONG  iStart,
        ULONG  cColors)
{
    BOOL rc = FALSE;
    PDD_PDEV ppdev = (PDD_PDEV)dhpdev;
    unsigned numColorsReturned;
    UINT32   length;

    DC_BEGIN_FN("DrvSetPalette");

#ifdef DC_DEBUG
    if (ppdev->cClientBitsPerPel > 8) {
        TRC_ERR((TB, "Unexpected palette operation when in high color mode"));
    }
#endif

    if (ddConnected && pddShm != NULL) {
        // Check that the parameters are within range.
        if ((iStart + cColors) <= PM_NUM_8BPP_PAL_ENTRIES) {
            // Get the palette colors into PDEV.
            numColorsReturned = PALOBJ_cGetColors(ppalo, iStart, cColors,
                    (ULONG*)&(ppdev->Palette[iStart]));
            if (numColorsReturned == cColors) {
                // See if these new entries are actually different to the old
                // ones by comparing the colors we've just put in the PDEV with
                // the ones that we're about to update in the shared memory.
                length = cColors * sizeof(PALETTEENTRY);

                if (memcmp(&(pddShm->pm.palette[iStart]),
                        &(ppdev->Palette[iStart]), length)) {
                    // The colors have changed - copy them into the shared
                    // memory.
                    memcpy(&(pddShm->pm.palette[iStart]),
                            &(ppdev->Palette[iStart]), length);

                    // Set flags to indicate that the palette has changed.
                    pddShm->pm.paletteChanged = TRUE;

                    // Inform the SBC.
                    SBC_PaletteChanged();

                    TRC_ALT((TB, "Palette changed"));
                }
                else {
                    // The palette hasn't actually changed at all.  This is
                    // slightly unusual, but not an error condition, so we
                    // return TRUE.
                    TRC_ALT((TB, "%lu new colors at index %lu haven't changed "
                            "palette - not sending.", cColors, iStart));
                }

                rc = TRUE;
            }
            else {
                TRC_ERR((TB, "numColorsReturned(%u) cColors(%u)",
                        numColorsReturned, cColors));
            }
        }
        else {
            TRC_ERR((TB, "Invalid params: iStart(%u) cColors(%u)",
                    iStart, cColors));
        }
    }
    else {
        TRC_ERR((TB, "Called when disconnected"));
    }

    DC_END_FN();
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpdd\noeint.c ===
/****************************************************************************/
// noeint.c
//
// RDP Order Encoder Display Driver internal functions
//
// Copyright (C) 1996-2000 Microsoft Corporation
/****************************************************************************/

#include <precmpdd.h>
#pragma hdrstop

#include <limits.h>

#define TRC_FILE "noeint"
#include <adcg.h>
#include <atrcapi.h>

#include <noedisp.h>

#include <noadisp.h>
#include <nsbcdisp.h>
#include <nschdisp.h>
#include <nprcount.h>
#include <oe2.h>

#define DC_INCLUDE_DATA
#include <ndddata.c>
#include <nsbcddat.c>
#include <oe2data.c>
#undef DC_INCLUDE_DATA

#include <noedata.c>

#include <nchdisp.h>
#include <nbadisp.h>
#include <nbainl.h>
#include <noeinl.h>

#include <nsbcdisp.h>
#include <nsbcinl.h>
#include <at128.h>
#include <tsgdiplusenums.h>


#define BAD_FRAG_INDEX 0xffff

#ifdef NotUsed
/****************************************************************************/
// OEConvertMask
//
// Convert a colour mask to bit depth and shift values.
/****************************************************************************/
void RDPCALL OEConvertMask(
        ULONG mask,
        PUSHORT pBitDepth,
        PUSHORT pShift)
{
    UINT16 count;

    DC_BEGIN_FN("OEConvertMask");

    /************************************************************************/
    /* A color mask is a bitwise field containing a 1 where the color uses  */
    /* the bit entry for the color and a 0 to indicate that it is not used  */
    /* for the color index.                                                 */
    /*                                                                      */
    /* The bit sequences for each color must be one set of continuous data, */
    /* so for example 00011100 is valid but 00110100 is not.  An example    */
    /* bitmask for a 16 bit palette is as follows.                          */
    /*                                                                      */
    /*  Red ----> 11111000 00000000 - 0xF800 - 5 bits - 11 shift            */
    /*  Green --> 00000111 11100000 - 0x07E0 - 6 bits - 5 shift             */
    /*  Blue ---> 00000000 00011111 - 0x001F - 5 bits - 0 shift             */
    /*                                                                      */
    /* This function converts the mask to a bit and shift value.            */
    /************************************************************************/

    // Set up default values.
    *pShift    = 0;
    *pBitDepth = 0;

    // Make sure we have a valid mask.
    if (mask == 0) {
        TRC_NRM((TB, "Ignoring mask"));
        DC_QUIT;
    }

    // Keep shifting the mask right until we hit a non-zero value in bit 0.
    // Store the resulting count as the color shift.
    count = 0;
    while ((mask & 1) == 0) {
        mask >>= 1;
        count++;
    }
    *pShift = count;

    // Keep shifting the mask right until we hit a zero value in bit 0.
    // Store the resulting count as the color bit depth.
    count = 0;
    while ((mask & 1) != 0) {
        mask >>= 1;
        count++;
    }
    *pBitDepth = count;

    TRC_DBG((TB, "Shift %hd bits %hd", *pShift, *pBitDepth));

    DC_END_FN();
}
#endif  // NotUsed


/****************************************************************************/
// OEConvertColor
//
// Converts a color from the NT Display Driver to a DCCOLOR.
/****************************************************************************/
void RDPCALL OEConvertColor(
        PDD_PDEV ppdev,
        DCCOLOR  *pDCColor,
        ULONG    osColor,
        XLATEOBJ *pxlo)
{
    ULONG realIndex;

    DC_BEGIN_FN("OEConvertColor");

    // Check if color translation is required.
    if (pxlo == NULL || pxlo->flXlate == XO_TRIVIAL) {
        // Use the OS color without translation.
        realIndex = osColor;
    }
    else {
        // Convert from BMP to device color.
        realIndex = XLATEOBJ_iXlate(pxlo, osColor);
        if (realIndex == -1) {
            TRC_ERR((TB, "Failed to convert color 0x%lx", osColor));
            memset(pDCColor, 0, sizeof(DCCOLOR));
            DC_QUIT;
        }
    }

    TRC_DBG((TB, "Device color 0x%lX", realIndex));

#ifdef DC_HICOLOR
    if (ppdev->cClientBitsPerPel == 24) {
        TRC_DBG((TB, "using real RGB value %06lx", realIndex));
        pDCColor->u.rgb.red   = ((RGBQUAD *)&realIndex)->rgbRed;
        pDCColor->u.rgb.green = ((RGBQUAD *)&realIndex)->rgbGreen;
        pDCColor->u.rgb.blue  = ((RGBQUAD *)&realIndex)->rgbBlue;
    }
    else if ((ppdev->cClientBitsPerPel == 16) ||
            (ppdev->cClientBitsPerPel == 15)) {
        TRC_DBG((TB, "using 16bpp color %04lx", realIndex));
        ((BYTE *)pDCColor)[0] = (BYTE)realIndex;
        ((BYTE *)pDCColor)[1] = (BYTE)(realIndex >> 8);
        ((BYTE *)pDCColor)[2] = 0;
    }
    else
#endif
    if (oeColorIndexSupported) {
        TRC_DBG((TB, "using index %d", realIndex));
        pDCColor->u.index = (BYTE)realIndex;

        // Zero out the rest of the color.
        pDCColor->u.rgb.green = 0;
        pDCColor->u.rgb.blue = 0;
    }
    else {
        pDCColor->u.rgb.red  = (BYTE)ppdev->Palette[realIndex].peRed;
        pDCColor->u.rgb.green= (BYTE)ppdev->Palette[realIndex].peGreen;
        pDCColor->u.rgb.blue = (BYTE)ppdev->Palette[realIndex].peBlue;
        TRC_DBG((TB, "Red %x green %x blue %x", pDCColor->u.rgb.red,
                pDCColor->u.rgb.green, pDCColor->u.rgb.blue));
    }

DC_EXIT_POINT:
    DC_END_FN();
}


/****************************************************************************/
// OESendBrushOrder
//
// Allocates and sends brush orders. Returns FALSE on failure.
/****************************************************************************/
BOOL RDPCALL OESendBrushOrder(
        PDD_PDEV       ppdev,
        POE_BRUSH_DATA pBrush,
        PBYTE          pBits,
        UINT32         oeBrushId)
{
    PINT_ORDER pOrder;
    PTS_CACHE_BRUSH_ORDER pBrushOrder;
    unsigned cbOrderSize;
    BOOL rc;

    DC_BEGIN_FN("OESendBrushOrder");

    // Calculate and allocate brush order buffer.
    cbOrderSize = sizeof(TS_CACHE_BRUSH_ORDER) -
            FIELDSIZE(TS_CACHE_BRUSH_ORDER, brushData) + pBrush->iBytes;
    pOrder = OA_AllocOrderMem(ppdev, cbOrderSize);
    if (pOrder != NULL) {
        // We've successfully allocated the order, so fill in the details.
        pBrushOrder = (PTS_CACHE_BRUSH_ORDER)pOrder->OrderData;
        pBrushOrder->header.extraFlags = 0;
        pBrushOrder->header.orderType = TS_CACHE_BRUSH;
        pBrushOrder->header.orderHdr.controlFlags = TS_STANDARD | TS_SECONDARY;
        pBrushOrder->cacheEntry = (char)pBrush->cacheEntry;
        pBrushOrder->iBitmapFormat = (char)pBrush->iBitmapFormat;
        pBrushOrder->cx = (char)pBrush->sizlBitmap.cx;
        pBrushOrder->cy = (char)pBrush->sizlBitmap.cy;
        pBrushOrder->style = pBrush->style;

        // Copy over the brush bits.
        pBrushOrder->iBytes = (char)pBrush->iBytes;
        memcpy(pBrushOrder->brushData, pBits, pBrush->iBytes);

        pBrushOrder->header.orderLength = (UINT16)
                TS_CALCULATE_SECONDARY_ORDER_ORDERLENGTH(cbOrderSize);

        INC_OUTCOUNTER(OUT_CACHEBRUSH);
        ADD_OUTCOUNTER(OUT_CACHEBRUSH_BYTES, cbOrderSize);
        OA_AppendToOrderList(pOrder);

        TRC_NRM((TB, "Brush Data PDU (%08lx, %08lx):%02ld entry(%02ld:%02ld), "
                "format:%ld, cx/cy:%02ld/%02ld",
                pBrush->key1, pBrush->key2, pBrushOrder->iBytes, oeBrushId,
                pBrushOrder->cacheEntry, pBrushOrder->iBitmapFormat,
                pBrushOrder->cx, pBrushOrder->cy));

        rc = TRUE;
    }
    else {
        TRC_ERR((TB, "Failed to allocate brush order"));
        pBrush->style = BS_NULL;
        rc = FALSE;
    }

    DC_END_FN();
    return rc;
}


/****************************************************************************/
/* Function:    OEStoreBrush                                                */
/*                                                                          */
/* Description: Store the brush data required for pattern realted orders.   */
/*              This function is called by DrvRealiseBrush when it has data */
/*              to be stored about a brush.                                 */
/*                                                                          */
/* Parameters:  pbo        - BRUSHOBJ of the brush to be stored             */
/*              style      - Style of the brush (as defined in the DC-Share */
/*                           protocol)                                      */
/*              iBitmapFormat - color depth of brush                        */
/*              sizlBitmap - dimensions of brush                            */
/*              iBytes     - number of brush bytes                          */
/*              pBits      - Pointer to the bits which are used to define   */
/*                           a BS_PATTERN brush.                            */
/*              pxlo       - XLATEOBJ for the brush.                        */
/*              hatch      - Standard Windows hatch pattern index for a     */
/*                           BS_HATCHED brush.                              */
/*              pEncode    - brush color encoding table                     */
/*              pColors    - table of unique colors                         */
/*              numColors  - number of unique colors                        */
/****************************************************************************/
BOOL RDPCALL OEStoreBrush(
        PDD_PDEV ppdev,
        BRUSHOBJ *pbo,
        BYTE     style,
        ULONG    iBitmapFormat,
        SIZEL    *sizlBitmap,
        ULONG    iBytes,
        PBYTE    pBits,
        XLATEOBJ *pxlo,
        BYTE     hatch,
        PBYTE    pEncode,
        PUINT32  pColors,
        UINT32   numColors)
{    
    BOOL           rc = FALSE;
    ULONG          i, j;
    PBYTE          pData = pBits;
    PULONG         pColorTable;
    POE_BRUSH_DATA pBrush;
    BOOL           bFoundIt;
    DCCOLOR        devColor;
    UINT32         brushSupportLevel, brushSize;
    PVOID          pUserDefined = NULL;

    DC_BEGIN_FN("OEStoreBrush");

#ifdef DC_HICOLOR
    // Determine which realized brush size we will need
    if (numColors <= 2) {
        brushSize = 8;
    }
    else if (numColors <= MAX_BRUSH_ENCODE_COLORS) {
        if (ppdev->cClientBitsPerPel == 24)
            brushSize = 28;
        else if (ppdev->cClientBitsPerPel > 8) // 15 and 16 bpp
            brushSize = 24;
        else
            brushSize = 20;
    }
    else {
        brushSize = iBytes;
    }
#else
    // Determine which realized brush size we will need
    if (numColors <= 2)
        brushSize = 8;
    else if (numColors <= MAX_BRUSH_ENCODE_COLORS)
        brushSize = 20;
    else
        brushSize = 64;
#endif

    // Allocate the space for the brush data.
    pBrush = (POE_BRUSH_DATA)BRUSHOBJ_pvAllocRbrush(pbo,
            sizeof(OE_BRUSH_DATA) - FIELDSIZE(OE_BRUSH_DATA, brushData) +
            brushSize);
    if (pBrush != NULL) {
        // Reset the brush definition (init the minimum size).
        memset(pBrush, 0, sizeof(OE_BRUSH_DATA));

        // Set the new brush data. Brush fore and back colors are set below
        // depending on the brush style.
        pBrush->style = style;
        pBrush->hatch = hatch;
        pBrush->iBitmapFormat = iBitmapFormat;
        pBrush->sizlBitmap = *sizlBitmap;
        pBrush->iBytes = brushSize;
        pBrush->cacheEntry = -1;
    }
    else {
        TRC_ERR((TB, "No memory"));
        DC_QUIT;
    }

    // For pattern brushes, copy the brush specific data.
    if (style == BS_PATTERN) {
        brushSupportLevel = pddShm->sbc.caps.brushSupportLevel;
        
        // Encode all monochrome brushes as 1 bpp - hence the name!
        if (numColors <= 2) {
            switch (iBitmapFormat) {            
                // already in the right format
                case BMF_1BPP:
                    // Store the foreground and background colours for the brush
                    OEConvertColor(ppdev, &pBrush->fore, 0, pxlo);
                    OEConvertColor(ppdev, &pBrush->back, 1, pxlo);
                    TRC_ASSERT((pxlo != NULL), (TB, "pxlo is NULL"));
                    break;

                // convert to 1bpp
                case BMF_4BPP:
                case BMF_8BPP:
                case BMF_16BPP:
                case BMF_24BPP:
                    // Store the foreground and background colours for the brush
#ifdef DC_HICOLOR
                    // The convert color fn takes care of the color depth
                    OEConvertColor(ppdev, &pBrush->fore, pColors[0], NULL);
                    OEConvertColor(ppdev, &pBrush->back, pColors[1], NULL);
#else
                    pBrush->fore.u.rgb.red = 0;
                    pBrush->fore.u.rgb.green = 0;
                    pBrush->fore.u.rgb.blue = 0;
                    pBrush->back.u.rgb.red = 0;
                    pBrush->back.u.rgb.green = 0;
                    pBrush->back.u.rgb.blue = 0;
                    pBrush->fore.u.index = (BYTE)pColors[0];
                    pBrush->back.u.index = (BYTE)pColors[1];
#endif

                    // Each pixel is represented by 1 bit
#ifdef DC_HICOLOR
                    if (ppdev->cClientBitsPerPel > 8) {
                        // Don't use endcoding table for hicolor sessions
                        for (i = 0; i < 8; i++) {
                            pBits[i] = (BYTE)((pBits[i * 8] << 7) & 0x80);
                            for (j = 1; j < 8; j++)
                                pBits[i] |= (BYTE)(pBits[i * 8 + j] <<
                                        (7 - j));
                        }
                    }
                    else {
#endif
                        for (i = 0; i < 8; i++) {
                            pBits[i] = (BYTE)
                                    (((pEncode[pBits[i * 8]]) << 7) & 0x80);
                            for (j = 1; j < 8; j++)
                                pBits[i] |= (BYTE)
                                        ((pEncode[pBits[i * 8 + j]]) <<
                                        (7 - j));
                        }
#ifdef DC_HICOLOR
                    }
#endif

                    TRC_DBG((TB, "Encoded Bytes:"));
                    TRC_DBG((TB, "%02lx %02lx %02lx %02lx",
                            pBits[0], pBits[1], pBits[2], pBits[3]));
                    TRC_DBG((TB, "%02lx %02lx %02lx %02lx",
                            pBits[4], pBits[5], pBits[6], pBits[7]));

                    iBitmapFormat = pBrush->iBitmapFormat = BMF_1BPP;
                    iBytes = pBrush->iBytes = 8;
                    break;

                default:
                    TRC_ASSERT((FALSE), (TB, "Unknown brush depth: %ld", 
                               iBitmapFormat));
            }

            // if brush caching is enabled, check the cache
            if ((brushSupportLevel > TS_BRUSH_DEFAULT) &&
                (sbcEnabled & SBC_BRUSH_CACHE_ENABLED)) {
                UINT32 key1, key2;

                key1 = pBits[0] + 
                        ((ULONG) pBits[1] << 8) + 
                        ((ULONG) pBits[2] << 16) + 
                        ((ULONG) pBits[3] << 24);

                key2 = pBits[4] + 
                        ((ULONG) pBits[5] << 8) + 
                        ((ULONG) pBits[6] << 16) + 
                        ((ULONG) pBits[7] << 24);

                pBrush->key1 = key1;
                pBrush->key2 = key2;
                bFoundIt = CH_SearchCache(sbcSmallBrushCacheHandle, key1, key2,
                                          &pUserDefined, &pBrush->cacheEntry);
            
                pBrush->style = (BYTE) (TS_CACHED_BRUSH | iBitmapFormat);

                // this brush was already cached
                if (bFoundIt) {
                    pBrush->hatch = (BYTE) pBrush->cacheEntry;
                    pBrush->brushId = (INT32) (UINT_PTR) pUserDefined;
                    pddCacheStats[BRUSH].CacheHits++;
                }
    
                // cache and send the brush
                else {
                    pBrush->hatch = pBrush->cacheEntry = (BYTE)CH_CacheKey(
                            sbcSmallBrushCacheHandle, key1, key2, 
                            (PVOID)ULongToPtr(pddShm->shareId));

                    pBrush->brushId = pddShm->shareId;

                    OESendBrushOrder(ppdev, pBrush, pBits, pBrush->brushId);
                    TRC_NRM((TB, "Small Brush(%08lx,%08lx):%02ld, "
                            "F/S/H(%ld/%d/%d), ID %02ld:%02ld", 
                            key1, key2, iBytes, iBitmapFormat, style, hatch,
                            pBrush->brushId, pBrush->hatch));
                }

                // Note: this branch intentionally does NOT copy the brush
                // bits into the brush realization, but leaves that data zero.
                // This causes OE2 to think this field never changes.  If the
                // brush becomes stale across reconnects, then the cache is
                // restored using key1/key2 since in this case the keys == data
            }
            
            else {
                // Copy the brush bits. Since this is an 8x8 mono bitmap, we can
                // copy the first byte of the brush data for each scan line.
                // NOTE however that the brush structures sent over the wire
                // re-use the hatching variable as the first byte of the brush
                // data.
                pData = pBits;
                pBrush->hatch = *pData;
                TRC_DBG((TB, " Hatch: %d", *pData));

                pData++;
        
                for (i = 0; i < 7; i++)
                    pBrush->brushData[i] = pData[i];
            }
        }

        // Else we have to use the large brush cache.  Note that DrvRealize
        // will not ask us to cache a brush if the client does not support
        // color brushes.
        else {
            CHDataKeyContext CHContext;
            CH_CreateKeyFromFirstData(&CHContext, pData, iBytes);
#ifdef DC_HICOLOR
            /****************************************************************/
            /* If we're running in high color mode, the way we encode the   */
            /* colors means that brushes with the same pattern but          */
            /* different colors will appear the same.  E.g.  a brush that   */
            /* starts lt blue, dk blue, pink will be encoded as 0,1,2 with  */
            /* the color table set to                                       */
            /*                                                              */
            /*    0 = lt blue                                               */
            /*    1 = dk blue                                               */
            /*    2 = pink                                                  */
            /*                                                              */
            /* Now consider a brush that goes green, blue, purple.  It too  */
            /* will be encoded as 0,1,2, with the color table set to        */
            /*                                                              */
            /*    0 = green                                                 */
            /*    1 = blue                                                  */
            /*    2 = purple                                                */
            /*                                                              */
            /* Thus a check simply on the pel values will find a false      */
            /* match with the first brush.  To avoid this, we need to build */
            /* the cache key from the pels AND the color table.             */
            /****************************************************************/
            if ((ppdev->cClientBitsPerPel > 8) &&
                    (numColors <= MAX_BRUSH_ENCODE_COLORS))
                CH_CreateKeyFromNextData(&CHContext, pColors,
                        4 * sizeof(UINT32));
#endif
            pBrush->key1 = CHContext.Key1;
            pBrush->key2 = CHContext.Key2;

            // see if it is already cached
            bFoundIt = CH_SearchCache(sbcLargeBrushCacheHandle, 
                    CHContext.Key1, CHContext.Key2,
                    &pUserDefined, &pBrush->cacheEntry);
                    
#ifdef DC_HICOLOR
            pBrush->iBitmapFormat = iBitmapFormat;
#else
            // Only send 8 bpp brushes for simplicity
            iBitmapFormat = pBrush->iBitmapFormat = BMF_8BPP;
#endif
            pBrush->style = (BYTE) (TS_CACHED_BRUSH | iBitmapFormat);
            pBrush->fore.u.rgb.red = 0;
            pBrush->fore.u.rgb.green = 0;
            pBrush->fore.u.rgb.blue = 0;
            pBrush->back.u.rgb.red = 0;
            pBrush->back.u.rgb.green = 0;
            pBrush->back.u.rgb.blue = 0;
            
            // this brush was already cached
            if (bFoundIt) {
                pBrush->hatch = (BYTE) pBrush->cacheEntry;
                pBrush->brushId = (INT32) (UINT_PTR) pUserDefined;
                pddCacheStats[BRUSH].CacheHits++;
            }

            // else cache and send the brush
            else {
                pBrush->hatch = pBrush->cacheEntry = (BYTE)CH_CacheKey(
                        sbcLargeBrushCacheHandle, CHContext.Key1,
                        CHContext.Key2, (PVOID) ULongToPtr(pddShm->shareId));

#ifdef DC_HICOLOR
                // The vast majority of brushes are less than 4 unique colors
                // Note that to have got here, it has however got more than
                // 2 colors or we'd have sent it as mono!
                if (numColors <= MAX_BRUSH_ENCODE_COLORS) {
                    UINT32 currIndex;

                    // This code assumse that MAX_BRUSH_ENCODE_COLORS is 4!
                    // If not, the sizes will be wrong
                    TRC_ASSERT((MAX_BRUSH_ENCODE_COLORS == 4),
                               (TB, "Max Brush Encode colors must be 4"));

                    // Encode as 2 bits per pixel.  We have to use the
                    // pEncode table for lo color; for hi color we don't
                    // need it because the pColors array contains the actual
                    // colors rather than indices into a color table
                    currIndex = 0;

                    if (ppdev->cClientBitsPerPel > 8) {
                        for (i = 0; i < (iBytes / 4); i++) {
                            pBrush->brushData[i] =
                                    (((BYTE) pBits[currIndex    ]) << 6) |
                                    (((BYTE) pBits[currIndex + 1]) << 4) |
                                    (((BYTE) pBits[currIndex + 2]) << 2) |
                                    (((BYTE) pBits[currIndex + 3]));
                            currIndex += 4;
                        }

                        // Tag on the encoding table - remembering that the
                        // size differs by color depth
                        if (ppdev->cClientBitsPerPel == 24) {
                            RGBTRIPLE *pIntoData =
                                    (RGBTRIPLE *)&(pBrush->brushData[16]);

                            TRC_DBG((TB, "Encoding table:"));
                            for (i = 0; i < 4; i++) {
                                TRC_DBG((TB, "%d    %08lx", i,
                                        (UINT32)pColors[i]));
                                pIntoData[i] = *((RGBTRIPLE * )&pColors[i]);
                            }
                            pBrush->iBytes = iBytes = 28;
                        }
                        else {
                            BYTE *pIntoData =
                                    (BYTE *)&(pBrush->brushData[16]);

                            TRC_DBG((TB, "Encoding table:"));
                            for (i = 0; i < 4; i++) {
                                TRC_DBG((TB, "%d    %08lx", i,
                                        (UINT32)pColors[i]));
                                pIntoData[i * 2]     = (BYTE)pColors[i];
                                pIntoData[i * 2 + 1] = (BYTE)(pColors[i] >> 8);
                            }
                            pBrush->iBytes = iBytes = 24;
                        }
                    }
                    else {
                        for (i = 0; i < (iBytes / 4); i++) {
                            pBrush->brushData[i] =
                                    (((BYTE)pEncode[pBits[currIndex    ]]) << 6) |
                                    (((BYTE)pEncode[pBits[currIndex + 1]]) << 4) |
                                    (((BYTE)pEncode[pBits[currIndex + 2]]) << 2) |
                                    (((BYTE)pEncode[pBits[currIndex + 3]]));
                            currIndex += 4;
                        }

                        // Tag on the encoding table
                        TRC_DBG((TB, "Encoding table:"));
                        for (i = 0; i < 4; i++) {
                            TRC_DBG((TB, "%d    %08lx", i, (UINT32)pColors[i]));
                            pBrush->brushData[i + 16] = (BYTE) pColors[i];
                        }
                        pBrush->iBytes = iBytes = 20;
                    }
                }

                // Else, leave it as N bytes per pixel
                else {
                    memcpy(pBrush->brushData, pBits, iBytes);
                    TRC_ALT((TB, "Non-compressed N-bpp brush (colors=%ld):",
                            numColors));
                }
#else

                // The vast majority of brushes are less than 4 unique colors
                if (numColors <= MAX_BRUSH_ENCODE_COLORS) {
                    UINT32 currIndex;
    
                    // Encode as 2 bits per pixel
                    currIndex = 0;
                    for (i = 0; i < (iBytes / MAX_BRUSH_ENCODE_COLORS); i++) {
                        pBrush->brushData[i] =
                            (((BYTE) pEncode[pBits[currIndex]]) << 6) |
                            (((BYTE) pEncode[pBits[currIndex + 1]]) << 4) |
                            (((BYTE) pEncode[pBits[currIndex + 2]]) << 2) |
                            (((BYTE) pEncode[pBits[currIndex + 3]]));
                        currIndex += MAX_BRUSH_ENCODE_COLORS;

                    }

                    // Tag on the encoding table
                    for (i = 0; i < MAX_BRUSH_ENCODE_COLORS; i++) {
                        pBrush->brushData[i + 16] = (BYTE) pColors[i];
                    }
                    pBrush->iBytes = iBytes = 20;
                }

                // Else, leave it as 1 byte per pixel
                else {
                    for (i = 0; i < iBytes; i++)
                        pBrush->brushData[i] = pBits[i];

                    TRC_ALT((TB, "Non-compressed 8-bpp brush (colors=%ld):", 
                            numColors));
                }
#endif
                pBrush->brushId = pddShm->shareId;
                OESendBrushOrder(ppdev, pBrush, pBrush->brushData,
                        pBrush->brushId);
                TRC_NRM((TB, "Large Brush(%08lx,%08lx):%02ld, "
                        "F/S/H(%ld/%d/%d), ID %02ld:%02ld", 
                        CHContext.Key1, CHContext.Key2, iBytes, 
                        iBitmapFormat, style, hatch, 
                        pBrush->brushId, pBrush->hatch));
            }
        }
    }
    else {
        if (pColors) {
            // Store the foreground and background colors for the brush
            OEConvertColor(ppdev, &pBrush->fore, pColors[0], pxlo);
            OEConvertColor(ppdev, &pBrush->back, pColors[1], pxlo);
        }
    }

    rc = TRUE;
    INC_OUTCOUNTER(OUT_BRUSH_STORED);

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}


/****************************************************************************/
/* Function:    OEReCacheBrush                                              */
/*                                                                          */
/* Description: This routine is called when we discover a GRE cached brush  */
/*              which was realized in a previous session.  In this case we  */
/*              must recache the brush and send it to the client.           */
/****************************************************************************/
BOOL RDPCALL OEReCacheBrush(
        PDD_PDEV ppdev,
        POE_BRUSH_DATA pBrush)
{    
    BOOL rc = FALSE;
    PVOID pUserDefined = NULL;
    UINT32 key1, key2;
    CHCACHEHANDLE hBrushCache;
    BYTE brushData[8];
    PBYTE pBits;

    DC_BEGIN_FN("OEReCacheBrush");

    key1 = pBrush->key1;
    key2 = pBrush->key2;

    if (pBrush->iBitmapFormat == BMF_1BPP) {
        brushData[0] = key1 & 0x000000FF;
        brushData[1] = (key1 >> 8) & 0x000000FF;
        brushData[2] = (key1 >> 16) & 0x000000FF;
        brushData[3] = (key1 >> 24) & 0x000000FF;
        brushData[4] = key2 & 0x000000FF;
        brushData[5] = (key2 >> 8) & 0x000000FF;
        brushData[6] = (key2 >> 16) & 0x000000FF;
        brushData[7] = (key2 >> 24) & 0x000000FF;
        pBits = brushData;

        if ((pddShm->sbc.caps.brushSupportLevel > TS_BRUSH_DEFAULT) &&
            (sbcEnabled & SBC_BRUSH_CACHE_ENABLED)) {
            hBrushCache = sbcSmallBrushCacheHandle;
        }
        else {
            int i;
            
            // Copy the brush bits. Since this is an 8x8 mono bitmap, we can
            // copy the first byte of the brush data for each scan line.
            // NOTE however that the brush structures sent over the wire
            // re-use the hatching variable as the first byte of the brush
            // data.
            pBrush->style = BS_PATTERN;
            pBrush->brushId = pddShm->shareId;
            pBrush->cacheEntry = -1;
            pBrush->hatch = *pBits++;       

            for (i = 0; i < 7; i++)
                pBrush->brushData[i] = pBits[i];
            
            rc = TRUE;
            DC_QUIT;
        }
    }
    else {
        if ((pddShm->sbc.caps.brushSupportLevel > TS_BRUSH_DEFAULT) &&
            (sbcEnabled & SBC_BRUSH_CACHE_ENABLED)) {
            hBrushCache = sbcLargeBrushCacheHandle;
            pBits = pBrush->brushData;
        }
        else {
            DC_QUIT;
        }
    }
    
    // cache and send the brush
    pBrush->hatch = pBrush->cacheEntry = (BYTE)CH_CacheKey(
            hBrushCache, key1, key2, (PVOID) ULongToPtr(pddShm->shareId));
    pBrush->brushId = pddShm->shareId;
 
    rc = OESendBrushOrder(ppdev, pBrush, pBits, pBrush->brushId);

    if (rc) {
        TRC_ERR((TB, "Re-cached brush(%08lx,%08lx):%02ld, ID %02ld:%02ld", 
                key1, key2, pBrush->iBytes, pBrush->brushId, pBrush->hatch));
    
        INC_OUTCOUNTER(OUT_BRUSH_STORED);
    }
    
DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}


/****************************************************************************/
// OECheckBrushIsSimple
//
// Check that the brush is a 'simple' object the protocol can send.
/****************************************************************************/
BOOL RDPCALL OECheckBrushIsSimple(
        PDD_PDEV ppdev,
        BRUSHOBJ *pbo,
        POE_BRUSH_DATA *ppBrush)
{
    BOOL rc;
    POE_BRUSH_DATA pBrush = NULL;
    UINT32 style;

    DC_BEGIN_FN("OECheckBrushIsSimple");

    // A 'simple' brush satisfies any of the following.
    //  1) It is a solid color.
    //  2) It is a valid brush as stored by DrvRealizeBrush.

    // Check for a simple solid color.
    if (pbo->iSolidColor != -1) {
        // Use the reserved brush definition to set up the solid colour.
        TRC_DBG((TB, "Simple solid colour %08lx", pbo->iSolidColor));
        pBrush = &oeBrushData;

        // Set up the specific data for this brush.
        OEConvertColor(ppdev, &pBrush->fore, pbo->iSolidColor, NULL);

        pBrush->back.u.index     = 0;
        pBrush->back.u.rgb.red   = 0;
        pBrush->back.u.rgb.green = 0;
        pBrush->back.u.rgb.blue  = 0;
        pBrush->style = BS_SOLID;
        pBrush->hatch = 0;
        RtlFillMemory(pBrush->brushData, sizeof(pBrush->brushData), 0);

        rc = TRUE;
        DC_QUIT;
    }

    rc = FALSE;

    // Check brush definition (which was stored when we realized the
    // brush). Here we find out if we've realised (cached) the brush already.
    // This is counted as a automatic cache read.  Subsequent routines
    // increment the hit count if the brush was already cached.
    pddCacheStats[BRUSH].CacheReads++;

    pBrush = (POE_BRUSH_DATA)pbo->pvRbrush;
    if (pBrush == NULL) {
        pBrush = (POE_BRUSH_DATA)BRUSHOBJ_pvGetRbrush(pbo);
        if (pBrush == NULL) {
            // We can get NULL returned from BRUSHOBJ_pvGetRbrush when the
            // brush is NULL or in low-memory situations (when the brush
            // realization may fail).
            TRC_NRM((TB, "NULL returned from BRUSHOBJ_pvGetRbrush"));
            INC_OUTCOUNTER(OUT_CHECKBRUSH_NOREALIZATION);
            DC_QUIT;
        }
    }

    // If brush caching make sure this brush isn't from a previous session
    else if (pBrush->style & TS_CACHED_BRUSH) {
        if (pBrush->brushId == pddShm->shareId) {
            pddCacheStats[BRUSH].CacheHits++;
        }
        else {
            TRC_ERR((TB, "Stale brush [%ld] detected! (%ld != %ld)", 
                     pBrush->cacheEntry, pBrush->brushId, pddShm->shareId));
            if (!OEReCacheBrush(ppdev, pBrush)) {
                TRC_NRM((TB, "Unencodable brush, failed to ReCacheBrush"));
                INC_OUTCOUNTER(OUT_CHECKBRUSH_COMPLEX);  
                DC_QUIT;
            }
        }
    }

    // Check it is an encodable brush. We cannot encode 
    // - BS_NULL
    // - anything other than BS_SOLID or BS_PATTERN if
    // oeSendSolidPatternBrushOnly is TRUE.
    style = pBrush->style;
    if ((style == BS_NULL) ||
            (oeSendSolidPatternBrushOnly &&
            (style != BS_SOLID) &&
            (style != BS_PATTERN) &&
            (!(style & TS_CACHED_BRUSH))))
    {
        TRC_NRM((TB, "Unencodable brush type %d", style));
        INC_OUTCOUNTER(OUT_CHECKBRUSH_COMPLEX);
        DC_QUIT;
    }

    // Everything passed - let's use this brush.
    rc = TRUE;

DC_EXIT_POINT:
    // Return the brush definition
    *ppBrush = pBrush;
    TRC_DBG((TB, "Returning %d - 0x%p", rc, pBrush));

    DC_END_FN();
    return rc;
}

#ifdef PERF_SPOILING
/****************************************************************************/
// OEIsSDAIncluded
//
// Returns TRUE if the list of RECTs passed in all lie completely within
// our current SDA bounds.
/****************************************************************************/
BOOL RDPCALL OEIsSDAIncluded(PRECTL prc, UINT count)
{
   
    BOOL rc = FALSE;
    unsigned uCurrentSDARect;
    PRECTL pSDARect;
    UINT i;

    DC_BEGIN_FN("OEIsSDAIncluded");

    // first check if we have SDA rects.
    if (pddShm->ba.firstRect != BA_INVALID_RECT_INDEX) {        
        for (i=0 ; i < count; i++) {
            for (uCurrentSDARect = pddShm->ba.firstRect; 
                 uCurrentSDARect != BA_INVALID_RECT_INDEX;
                 uCurrentSDARect = pddShm->ba.bounds[uCurrentSDARect].iNext) { 

                pSDARect = &pddShm->ba.bounds[uCurrentSDARect].coord;

                if (prc[i].top >= pSDARect->top &&
                    prc[i].bottom <= pSDARect->bottom &&
                    prc[i].left >= pSDARect->left &&
                    prc[i].right <= pSDARect->right) {

                    break;
                }
            }

            //    We got to the end of the SDA array so that means
            //    we didn't find a rect that includes the target rect
            if (uCurrentSDARect == BA_INVALID_RECT_INDEX) {
                DC_QUIT;
            }
        }
        
        // We looped through all the rects and all were clipped
        rc = TRUE;
        DC_QUIT;        
    }
    
DC_EXIT_POINT:

    DC_END_FN();
    return rc;

}
#endif

/****************************************************************************/
// OEGetClipRects
//
// Fills in *pEnumRects with up to COMPLEX_CLIP_RECT_COUNT clip rectangles,
// in standard GDI exclusive coordinates. The number of rects returned
// is zero if there is no clip object or the clipping is trivial.
// Returns FALSE if there are more than COMPLEX_CLIP_RECT_COUNT rects,
// indicating the clip object is too complex to encode.
/****************************************************************************/
BOOL RDPCALL OEGetClipRects(CLIPOBJ *pco, OE_ENUMRECTS *pEnumRects)
{
    BOOL rc = TRUE;

    DC_BEGIN_FN("OEGetClipRects");

    // No clip obj or trivial are the most common.
    if (pco == NULL || pco->iDComplexity == DC_TRIVIAL) {
        TRC_DBG((TB,"No/trivial clipobj"));
        pEnumRects->rects.c = 0;
    }
    else if (pco->iDComplexity == DC_RECT) {
        // Single rect is easy, just grab it.
        pEnumRects->rects.c = 1;
        pEnumRects->rects.arcl[0] = pco->rclBounds;
    }
    else {
        BOOL fMoreRects;
        unsigned NumRects = 0;
        OE_ENUMRECTS clip;

        TRC_ASSERT((pco->iDComplexity == DC_COMPLEX),
                (TB,"Unknown clipping %u", pco->iDComplexity));

        // Enumerate all the rectangles involved in this drawing operation.
        // The documentation for this function incorrectly states that the
        // returned value is the total number of rectangles comprising the
        // clip region. In fact, -1 is always returned, even when the final
        // parameter is non-zero.
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        // Get the clip rectangles. We fetch these into the clip buffer which
        // is big enough to get all the clip rectangles we expect + 1. The
        // clip rectangle fetching is contained within a loop because, while
        // we expect to call CLIPOBJ_bEnum once only, it is possible for this
        // function to return zero rects and report that there are more to
        // fetch (according to MSDN).
        do {
            fMoreRects = CLIPOBJ_bEnum(pco, sizeof(clip),
                    (ULONG *)&clip.rects);

            // CLIPOBJ_bEnum can return a count of zero when there are still
            // more rects.
            if (clip.rects.c != 0) {
                // Check to see if we have too many rects.
                if ((NumRects + clip.rects.c) <= COMPLEX_CLIP_RECT_COUNT) {
                    // Copy the rects into the final destination.
                    memcpy(&pEnumRects->rects.arcl[NumRects],
                            &clip.rects.arcl[0],
                            sizeof(RECTL) * clip.rects.c);
                    NumRects += clip.rects.c;
                }
                else {
                    rc = FALSE;
                    break;
                }
            }
        } while (fMoreRects);

        pEnumRects->rects.c = NumRects;
    }

    DC_END_FN();
    return rc;
}


/****************************************************************************/
// OEGetIntersectingClipRects
//
// Fills in *pClipRects with up to COMPLEX_CLIP_RECT_COUNT clip rectangles,
// in standard GDI exclusive coordinates. Each result rectangle is clipped
// against the provided (exclusive) order rect. The number of rects
// returned is zero if there is no clip object or the clipping is trivial.
// Returns CLIPRECTS_TOO_COMPLEX if there are more than
// COMPLEX_CLIP_RECT_COUNT rects, CLIPRECTS_NO_INTERSECTIONS if there is
// no intersection between the order rect and the clip rects.
/****************************************************************************/
unsigned RDPCALL OEGetIntersectingClipRects(
        CLIPOBJ *pco,
        RECTL *pRect,
        unsigned EnumType,
        OE_ENUMRECTS *pClipRects)
{
    unsigned rc = CLIPRECTS_OK;
    RECTL OrderRect;
    RECTL ClippedRect;
    unsigned i;
    unsigned NumIntersections;
    OE_ENUMRECTS clip;

    DC_BEGIN_FN("OEGetIntersectingClipRects");

    // No clip obj or trivial are the most common.
    if (pco == NULL || pco->iDComplexity == DC_TRIVIAL) {
        TRC_DBG((TB,"No/trivial clipobj"));
        pClipRects->rects.c = 0;
        DC_QUIT;
    }

    OrderRect = *pRect;

    if (pco->iDComplexity == DC_RECT) {
        // Check for an intersection.
        ClippedRect = pco->rclBounds;
        if (ClippedRect.left < OrderRect.right &&
                ClippedRect.bottom > OrderRect.top &&
                ClippedRect.right > OrderRect.left &&
                ClippedRect.top < OrderRect.bottom) {
            // Get the intersection rect.
            ClippedRect.left = max(ClippedRect.left, OrderRect.left);
            ClippedRect.top = max(ClippedRect.top, OrderRect.top);
            ClippedRect.bottom = min(ClippedRect.bottom, OrderRect.bottom);
            ClippedRect.right = min(ClippedRect.right, OrderRect.right);

            pClipRects->rects.c = 1;
            pClipRects->rects.arcl[0] = ClippedRect;
        }
        else {
            rc = CLIPRECTS_NO_INTERSECTIONS;
        }
    }
    else {
        BOOL fMoreRects;
        unsigned NumRects = 0;
        OE_ENUMRECTS clip;

        TRC_ASSERT((pco->iDComplexity == DC_COMPLEX),
                (TB,"Unknown clipping %u", pco->iDComplexity));

        // Enumerate all the rectangles involved in this drawing operation.
        // The documentation for this function incorrectly states that the
        // returned value is the total number of rectangles comprising the
        // clip region. In fact, -1 is always returned, even when the final
        // parameter is non-zero.
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, EnumType, 0);

        // Get the clip rectangles. We fetch these into the clip buffer which
        // is big enough to get all the clip rectangles we expect + 1. The
        // clip rectangle fetching is contained within a loop because, while
        // we expect to call CLIPOBJ_bEnum once only, it is possible for this
        // function to return zero rects and report that there are more to
        // fetch (according to MSDN).
        NumIntersections = 0;
        do {
            fMoreRects = CLIPOBJ_bEnum(pco, sizeof(clip),
                    (ULONG *)&clip.rects);

            // CLIPOBJ_bEnum can return a count of zero when there are still
            // more rects.
            if (clip.rects.c != 0) {
                // Check to see if we have too many rects.
                if ((NumIntersections + clip.rects.c) <=
                        COMPLEX_CLIP_RECT_COUNT) {
                    for (i = 0; i < clip.rects.c; i++) {
                        // Check for an intersection.
                        if (clip.rects.arcl[i].left < OrderRect.right &&
                                clip.rects.arcl[i].bottom > OrderRect.top &&
                                clip.rects.arcl[i].right > OrderRect.left &&
                                clip.rects.arcl[i].top < OrderRect.bottom) {
                            // Clip the intersection rect.
                            ClippedRect.left = max(clip.rects.arcl[i].left,
                                    OrderRect.left);
                            ClippedRect.top = max(clip.rects.arcl[i].top,
                                    OrderRect.top);
                            ClippedRect.right = min(clip.rects.arcl[i].right,
                                    OrderRect.right);
                            ClippedRect.bottom = min(clip.rects.arcl[i].bottom,
                                    OrderRect.bottom);

                            pClipRects->rects.arcl[NumIntersections] =
                                    ClippedRect;
                            NumIntersections++;
                        }
                    }
                }
                else {
                    rc = CLIPRECTS_TOO_COMPLEX;
                    DC_QUIT;
                }
            }
        } while (fMoreRects);

        if (NumIntersections > 0)
            pClipRects->rects.c = NumIntersections;
        else
            rc = CLIPRECTS_NO_INTERSECTIONS;
    }

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}


/****************************************************************************/
// OEGetFontCacheInfo
//
// Gets the FCI for a font, allocating it if need be. Returns NULL on failure.
/****************************************************************************/
PFONTCACHEINFO RDPCALL OEGetFontCacheInfo(FONTOBJ *pfo)
{
    PFONTCACHEINFO pfci;
    PVOID pvConsumer;

    DC_BEGIN_FN("OEGetFontCacheInfo");

    pvConsumer = pfo->pvConsumer;

    if (pvConsumer == NULL) {
        pvConsumer = EngAllocMem(FL_ZERO_MEMORY, sizeof(FONTCACHEINFO),
                DD_ALLOC_TAG);

        if (pvConsumer != NULL && sbcFontCacheInfoList != NULL) { 
            // Save the pvConsumer data pointer so that on disconnect/logoff
            // we can cleanup the memory.
            if (sbcFontCacheInfoListIndex < sbcFontCacheInfoListSize) {          
                sbcFontCacheInfoList[sbcFontCacheInfoListIndex] = 
                        (PFONTCACHEINFO)pvConsumer;
                ((PFONTCACHEINFO)pvConsumer)->listIndex = sbcFontCacheInfoListIndex;
                sbcFontCacheInfoListIndex++;
            }
            else {
                unsigned i, j;
                PFONTCACHEINFO * tempList;

                // We ran out of the preallocated memory, we have to  
                // reallocate the info list and recompact the list to the 
                // new one.  
                // Note: We need to update the list index now!
                tempList = (PFONTCACHEINFO *) EngAllocMem(0, 
                        sizeof(PFONTCACHEINFO) * sbcFontCacheInfoListSize * 2, 
                        DD_ALLOC_TAG);            

                if (tempList != NULL) {
                    j = 0;
                    
                    for (i = 0; i < sbcFontCacheInfoListIndex; i++) {
                        if (sbcFontCacheInfoList[i] != NULL) {
                            tempList[j] = sbcFontCacheInfoList[i];
                            ((PFONTCACHEINFO)tempList[j])->listIndex = j;
                            j++;
                        }
                    }

                    EngFreeMem(sbcFontCacheInfoList);
                    sbcFontCacheInfoListSize = sbcFontCacheInfoListSize * 2;
                    sbcFontCacheInfoList = tempList;

                    sbcFontCacheInfoList[j] = (PFONTCACHEINFO)pvConsumer;
                    ((PFONTCACHEINFO)pvConsumer)->listIndex = j;
                    sbcFontCacheInfoListIndex = ++j;
                }
                else {
                    EngFreeMem(pvConsumer);
                    pvConsumer = NULL;
                }
            }
        }        
    }

    if (pvConsumer != NULL) {
        pfci = (PFONTCACHEINFO)pvConsumer;

        if (pfo->pvConsumer == NULL || pfci->shareId != pddShm->shareId ||
                pfci->cacheHandle != pddShm->sbc.glyphCacheInfo[pfci->cacheId].cacheHandle) {
            pfci->shareId = pddShm->shareId;
            pfci->fontId = oeFontId++;
            pfci->cacheId = -1;
        }

        pfo->pvConsumer = pvConsumer;
    }

    DC_END_FN();
    return pvConsumer;
}


/****************************************************************************/
/* Worker function - encodes a delta from one rect to another in a minimal  */
/* form in the MultiRectangle coded delta list. The encoding follows the    */
/* following rules:                                                         */
/*   1. If a coordinate delta is zero, a flag is set saying so. This        */
/*      closely follows the data distribution which tends to have vertical  */
/*      and horizontal lines and so have a lot of zero deltas.              */
/*   2. If we can pack the delta into 7 bits, do so, with the high bit      */
/*      cleared. This is similar to ASN.1 PER encoding; the high bit is a   */
/*      flag telling us whether the encoding is long.                       */
/*   3. Otherwise, we must be able to pack into 15 bits (assert if not),    */
/*      do so and set the high-order bit to indicate this is a long         */
/*      encoding. This differs from ASN.1 PER encoding in that we don't     */
/*      allow more than 15 bits of data.                                    */
/*                                                                          */
/* We usually see several small rectangles starting from about the same     */
/* place but of wildly different shapes, so the delta between subsequent    */
/* top-left's is small, and should normally fit in one byte, but the delta  */
/* between bottom-rights may be large                                       */
/*                                                                          */
/* Thus we calculate the delta differently for the two corners:             */
/* - the top left delta is the change from the last rectangle               */
/* - the bottom right is the change from the top left of this rectangle     */
/****************************************************************************/
void OEEncodeMultiRectangles(
        BYTE     **ppCurEncode,
        unsigned *pNumDeltas,
        unsigned *pDeltaSize,
        BYTE     *ZeroFlags,
        RECTL    *pFromRect,
        RECTL    *pToRect)
{
    int Delta;
    BYTE Zeros = 0;
    BYTE *pBuffer;
    unsigned EncodeLen = 0;

    DC_BEGIN_FN("OEEncodeMultiRectangles");

    pBuffer = *ppCurEncode;

    // calculate the top-left x delta
    Delta = pToRect->left - pFromRect->left;
    TRC_DBG((TB, "Delta x-left %d", Delta));
    if (Delta == 0) {
        EncodeLen += 0;
        Zeros |= ORD_CLIP_RECTS_XLDELTA_ZERO;
    }
    else if (Delta >= -64 && Delta <= 63) {
        *pBuffer++ = (BYTE)(Delta & 0x7F);
        EncodeLen += 1;
    }
    else {
        // We can't encode deltas outside the range -16384 to +16383
        if (Delta < -16384) {
            TRC_ERR((TB,"X delta %d is too large to encode, clipping",Delta));
            Delta = -16384;
        }
        else if (Delta > 16383) {
            TRC_ERR((TB,"X delta %d is too large to encode, clipping",Delta));
            Delta = 16383;
        }

        *pBuffer++ = (BYTE)((Delta >> 8) | ORD_CLIP_RECTS_LONG_DELTA);
        *pBuffer++ = (BYTE)(Delta & 0xFF);
        EncodeLen += 2;
    }

    // and the top-left y delta
    Delta = pToRect->top - pFromRect->top;
    TRC_DBG((TB, "Delta y-top %d", Delta));
    if (Delta == 0) {
        Zeros |= ORD_CLIP_RECTS_YTDELTA_ZERO;
    }
    else if (Delta >= -64 && Delta <= 63) {
        *pBuffer++ = (BYTE)(Delta & 0x7F);
        EncodeLen += 1;
    }
    else {
        // See comments for the similar code above.
        if (Delta < -16384) {
            TRC_ERR((TB,"Y delta %d is too large to encode, clipping",Delta));
            Delta = -16384;
        }
        else if (Delta > 16383) {
            TRC_ERR((TB,"Y delta %d is too large to encode, clipping",Delta));
            Delta = 16383;
        }

        *pBuffer++ = (BYTE)((Delta >> 8) | ORD_CLIP_RECTS_LONG_DELTA);
        *pBuffer++ = (BYTE)(Delta & 0xFF);
        EncodeLen += 2;
    }

    // Now the bottom-right x delta. Note this is relative to the current
    // top left rather than the previous bottom right.
    Delta = pToRect->right - pToRect->left;
    TRC_DBG((TB, "Delta x-right %d", Delta));
    if (Delta == 0) {
        EncodeLen += 0;
        Zeros |= ORD_CLIP_RECTS_XRDELTA_ZERO;
    }
    else if (Delta >= -64 && Delta <= 63) {
        *pBuffer++ = (BYTE)(Delta & 0x7F);
        EncodeLen += 1;
    }
    else {
        // We can't encode deltas outside the range -16384 to +16383.
        if (Delta < -16384) {
            TRC_ERR((TB,"X delta %d is too large to encode, clipping",Delta));
            Delta = -16384;
        }
        else if (Delta > 16383) {
            TRC_ERR((TB,"X delta %d is too large to encode, clipping",Delta));
            Delta = 16383;
        }

        *pBuffer++ = (BYTE)((Delta >> 8) | ORD_CLIP_RECTS_LONG_DELTA);
        *pBuffer++ = (BYTE)(Delta & 0xFF);
        EncodeLen += 2;
    }

    // and the bottom-right y delta.
    Delta = pToRect->bottom - pToRect->top;
    TRC_DBG((TB, "Delta y-bottom %d", Delta));
    if (Delta == 0) {
        Zeros |= ORD_CLIP_RECTS_YBDELTA_ZERO;
    }
    else if (Delta >= -64 && Delta <= 63) {
        *pBuffer++ = (BYTE)(Delta & 0x7F);
        EncodeLen += 1;
    }
    else {
        // See comments for the similar code above.
        if (Delta < -16384) {
            TRC_ERR((TB,"Y delta %d is too large to encode, clipping",Delta));
            Delta = -16384;
        }
        else if (Delta > 16383) {
            TRC_ERR((TB,"Y delta %d is too large to encode, clipping",Delta));
            Delta = 16383;
        }

        *pBuffer++ = (BYTE)((Delta >> 8) | ORD_CLIP_RECTS_LONG_DELTA);
        *pBuffer++ = (BYTE)(Delta & 0xFF);
        EncodeLen += 2;
    }

    // Set the zero flags by shifting the two bits we've accumulated.
    ZeroFlags[(*pNumDeltas / 2)] |= (Zeros >> (4 * (*pNumDeltas & 0x01)));

    *pNumDeltas += 1;
    *pDeltaSize += EncodeLen;
    *ppCurEncode = pBuffer;

    DC_END_FN();
}


/****************************************************************************/
// OEBuildMultiClipOrder
//
// Creates a multi-clip-rect blob in intermediate format for multi-clip
// orders. Returns the number of clip rects in the blob.
/****************************************************************************/
unsigned OEBuildMultiClipOrder(
        PDD_PDEV ppdev,
        CLIP_RECT_VARIABLE_CODEDDELTALIST *pCodedDeltaList,
        OE_ENUMRECTS *pClipRects)
{
    unsigned NumRects;
    unsigned i;
    unsigned NumZeroFlagBytes;
    BYTE Deltas[ORD_MAX_CLIP_RECTS_CODEDDELTAS_LEN] = { 0 };
    BYTE ZeroFlags[ORD_MAX_CLIP_RECTS_ZERO_FLAGS_BYTES] = { 0 };
    BYTE *pCurEncode;
    unsigned NumDeltas = 0;
    unsigned DeltaSize = 0;
    RECTL nextRect = { 0 };

    DC_BEGIN_FN("OEBuildMultiClipOrder");

#ifdef DRAW_NINEGRID
    // Check that we actually have at least one clip rect.
    TRC_ASSERT((pClipRects->rects.c > 0), (TB, "Got non-complex pClipObj"));
#else
    // Check that we actually have more than one clip rect.
    TRC_ASSERT((pClipRects->rects.c > 1), (TB, "Got non-complex pClipObj"));
#endif

    // We expect no more than COMPLEX_CLIP_RECT_COUNT since
    // somewhere up the encoding path we would have determined
    // the number of clip rects already.
    TRC_ASSERT((pClipRects->rects.c <= COMPLEX_CLIP_RECT_COUNT),
            (TB, "Got %u rects but more exist", pClipRects->rects.c));

    NumRects = pClipRects->rects.c;
    pCurEncode = Deltas;
    for (i = 0; i < NumRects; i++) {
        // Add it to the delta array.
        OEEncodeMultiRectangles(&pCurEncode, &NumDeltas, &DeltaSize,
                ZeroFlags, &nextRect, &pClipRects->rects.arcl[i]);
        nextRect = pClipRects->rects.arcl[i];
    }

    // Put the deltas into the supplied array.
    NumZeroFlagBytes = (NumDeltas + 1) / 2;
    TRC_NRM((TB, "Num zero flags %d", NumZeroFlagBytes));
    pCodedDeltaList->len = DeltaSize + NumZeroFlagBytes;

    // Copy the zero flags first.
    memcpy(pCodedDeltaList->Deltas, ZeroFlags, NumZeroFlagBytes);

    // Next copy the encoded deltas.
    memcpy(pCodedDeltaList->Deltas + NumZeroFlagBytes, Deltas, DeltaSize);

    TRC_NRM((TB, "num deltas %d in list len %d",
            NumDeltas,
            pCodedDeltaList->len));

    TRC_DATA_NRM("zero flags", ZeroFlags, NumZeroFlagBytes);
    TRC_DATA_NRM("deltas", Deltas, DeltaSize);

    DC_END_FN();
    return NumDeltas;
}


/****************************************************************************/
// OEBuildPrecodeMultiClipFields
//
// Given a CLIPOBJ, encodes the clip rects directly into the wire format for
// the nDeltaEntries and CLIP_RECT_VARIABLE_CODEDDELTALIST fields.
// Returns field flags for the nDeltaEntries and deltas fields:
//   0x01 for nDeltaEntries
//   0x02 for deltas
/****************************************************************************/
unsigned RDPCALL OEBuildPrecodeMultiClipFields(
        OE_ENUMRECTS *pClipRects,
        BYTE **ppBuffer,
        UINT32 *pPrevNumDeltaEntries,
        BYTE *pPrevCodedDeltas)
{
    BYTE     *pBuffer;
    unsigned rc;
    unsigned i;
    unsigned NumRects;
    unsigned NumZeroFlagBytes;
    BYTE     *pCurEncode;
    unsigned NumDeltas = 0;
    unsigned DeltaSize = 0;
    unsigned TotalSize;
    RECTL    nextRect = { 0 };
    BYTE     Deltas[ORD_MAX_CLIP_RECTS_CODEDDELTAS_LEN] = { 0 };
    BYTE     ZeroFlags[ORD_MAX_CLIP_RECTS_ZERO_FLAGS_BYTES] = { 0 };

    DC_BEGIN_FN("OEBuildPrecodeMultiClipFields");

    // Check that we actually have more than one clip rect.
    TRC_ASSERT((pClipRects->rects.c > 1), (TB, "Got non-complex clip"));

    // We expect no more than COMPLEX_CLIP_RECT_COUNT since
    // somewhere up the encoding path we would have determined
    // the number of clip rects already.
    TRC_ASSERT((pClipRects->rects.c <= COMPLEX_CLIP_RECT_COUNT),
            (TB, "Got %u rects but more exist", pClipRects->rects.c));

    NumRects = pClipRects->rects.c;
    TRC_NRM((TB,"Encoding %u rects", NumRects));
    pCurEncode = Deltas;
    for (i = 0; i < NumRects; i++) {
        // Add it to the delta array.
        OEEncodeMultiRectangles(&pCurEncode, &NumDeltas, &DeltaSize,
                ZeroFlags, &nextRect, &pClipRects->rects.arcl[i]);
        TRC_DBG((TB,"    Added rect (%d,%d,%d,%d)",
                pClipRects->rects.arcl[i].left,
                pClipRects->rects.arcl[i].top,
                pClipRects->rects.arcl[i].right,
                pClipRects->rects.arcl[i].bottom));
        nextRect = pClipRects->rects.arcl[i];
    }

    // Now use the accumulated information to encode the wire format.
    pBuffer = *ppBuffer;

    // nDeltaEntries - one-byte encoding if not same as previous.
    if (NumDeltas == *pPrevNumDeltaEntries) {
        rc = 0;
    }
    else {
        rc = 0x01;
        *pBuffer++ = (BYTE)NumDeltas;
        *pPrevNumDeltaEntries = NumDeltas;
    }

    // The size is placed on the wire as 2 bytes, followed by the flag bytes
    // and the deltas, as long as they are different from the previous.
    NumZeroFlagBytes = (NumDeltas + 1) / 2;
    TRC_DBG((TB, "Num flag bytes %d", NumZeroFlagBytes));

    // Assemble the encoded rect deltas for comparison to the previous
    // deltas in the last OE2 order encoding.
    *((PUINT16_UA)pBuffer) = (UINT16)(DeltaSize + NumZeroFlagBytes);
    memcpy(pBuffer + 2, ZeroFlags, NumZeroFlagBytes);
    memcpy(pBuffer + 2 + NumZeroFlagBytes, Deltas, DeltaSize);
    TotalSize = 2 + NumZeroFlagBytes + DeltaSize;
    if (memcmp(pBuffer, pPrevCodedDeltas, TotalSize)) {
        // Only send the deltas if the block is different from
        // the previous block.
        memcpy(pPrevCodedDeltas, pBuffer, TotalSize);
        pBuffer += TotalSize;
        rc |= 0x02;
    }

    *ppBuffer = pBuffer;

    DC_END_FN();
    return rc;
}


/****************************************************************************/
// OEGetIntersectionsWithClipRects
//
// Determines the rects that intersect between a set of (exclusive) clip
// rects and a single (exclusive) order rect. Clips the rects to the order
// rect while returning them; result rects are in exclusive coords.
// Returns the number of intersecting rects. Should only be called when
// there are more than zero clip rects.
/****************************************************************************/
unsigned OEGetIntersectionsWithClipRects(
        RECTL *pRect,
        OE_ENUMRECTS *pClipRects,
        OE_ENUMRECTS *pResultRects)
{
    RECTL OrderRect;
    RECTL ClippedRect;
    RECTL ClipRect;
    unsigned i;
    unsigned NumRects;
    unsigned NumIntersections;

    DC_BEGIN_FN("OEGetIntersectionsWithClipRects");

    TRC_ASSERT((pClipRects->rects.c != 0),(TB,"Zero cliprects not allowed"));

    OrderRect = *pRect;
    NumRects = pClipRects->rects.c;
    NumIntersections = 0;
    for (i = 0; i < NumRects; i++) {
        ClipRect = pClipRects->rects.arcl[i];

        // Check for an intersection.
        if (ClipRect.left < OrderRect.right &&
                ClipRect.bottom > OrderRect.top &&
                ClipRect.right > OrderRect.left &&
                ClipRect.top < OrderRect.bottom) {
            // Clip the intersection rect.
            ClippedRect.left = max(ClipRect.left, OrderRect.left);
            ClippedRect.bottom = min(ClipRect.bottom, OrderRect.bottom);
            ClippedRect.right = min(ClipRect.right, OrderRect.right);
            ClippedRect.top = max(ClipRect.top, OrderRect.top);

            pResultRects->rects.arcl[NumIntersections] = ClippedRect;
            NumIntersections++;
        }
    }

    pResultRects->rects.c = NumIntersections;

    DC_END_FN();
    return NumIntersections;
}


/****************************************************************************/
// OEClipAndAddScreenDataAreaByIntersectRects
//
// Adds areas specified in intersect rect list to the SDA. If there are
// no intersect rects, adds the entire *pRect to the SDA.
/****************************************************************************/
void RDPCALL OEClipAndAddScreenDataAreaByIntersectRects(
        PRECTL pRect,
        OE_ENUMRECTS *pClipRects)
{
    RECTL ClippedRect;
    unsigned i;
    unsigned NumRects;

    DC_BEGIN_FN("OEClipAndAddScreenDataAreaByIntersectRects");

    NumRects = pClipRects->rects.c;

    if (NumRects == 0) {
        // No clip rects; add the entire bounds.
        // Use the inclusive rect. We make a copy because BA_AddScreenData
        // can modify the rectangle.
        ClippedRect = *pRect;
        TRC_NRM((TB, "Adding SDA (%d,%d)(%d,%d)", ClippedRect.left,
                ClippedRect.top, ClippedRect.right, ClippedRect.bottom));
        BA_AddScreenData(&ClippedRect);
    }
    else {
        for (i = 0; i < NumRects; i++) {
            // Convert each rect to inclusive.
            ClippedRect.left = pClipRects->rects.arcl[i].left;
            ClippedRect.top = pClipRects->rects.arcl[i].top;
            ClippedRect.right = pClipRects->rects.arcl[i].right;
            ClippedRect.bottom = pClipRects->rects.arcl[i].bottom;

            // Add the clipped rect into the SDA.
            TRC_NRM((TB, "Adding SDA (%d,%d)(%d,%d)",
                    ClippedRect.left, ClippedRect.top,
                    ClippedRect.right, ClippedRect.bottom));
            BA_AddScreenData(&ClippedRect);
        }
    }

    DC_END_FN();
}


/****************************************************************************/
// OEClipAndAddScreenDataArea
//
// ClipObj version of OEClipAndAddScreenDataAreaByIntersectRects(), uses pco
// for enumeration since it may contain more than COMPLEX_CLIP_RECT_COUNT
// rects.
/****************************************************************************/
void RDPCALL OEClipAndAddScreenDataArea(PRECTL pRect, CLIPOBJ *pco)
{
    BOOL fMoreRects;
    RECTL clippedRect;
    unsigned i;
    OE_ENUMRECTS clip;

    DC_BEGIN_FN("OEClipAndAddScreenDataArea");

    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL)) {
        // No clipping -- add the (exclusive) *pRect directly, making a copy
        // since BA_AddScreenData() can modify the rect.
        clippedRect = *pRect;
        TRC_NRM((TB, "Adding SDA (%d,%d)(%d,%d)", clippedRect.left,
                clippedRect.top, clippedRect.right, clippedRect.bottom));
        BA_AddScreenData(&clippedRect);
    }
    else if (pco->iDComplexity == DC_RECT) {
        // One clipping rectangle - use it directly. Make sure the rectangle
        // is valid before adding to the SDA.
        clippedRect.left = max(pco->rclBounds.left, pRect->left);
        clippedRect.right = min(pco->rclBounds.right, pRect->right);

        if (clippedRect.left < clippedRect.right) {
            clippedRect.bottom = min(pco->rclBounds.bottom,
                    pRect->bottom);
            clippedRect.top = max(pco->rclBounds.top, pRect->top);

            if (clippedRect.bottom > clippedRect.top) {
                // Add the clipped rect into the SDA.
                TRC_NRM((TB, "Adding SDA RECT (%d,%d)(%d,%d)",
                        clippedRect.left, clippedRect.top,
                        clippedRect.right, clippedRect.bottom));
                BA_AddScreenData(&clippedRect);
            }
        }
    }
    else {
        // Enumerate all the rectangles involved in this drawing operation.
        // The documentation for this function incorrectly states that
        // the returned value is the total number of rectangles
        // comprising the clip region. In fact, -1 is always returned,
        // even when the final parameter is non-zero.
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        do {
            // Get the next batch of clipping rectangles.
            fMoreRects = CLIPOBJ_bEnum(pco, sizeof(clip),
                    (ULONG *)&clip.rects);

            for (i = 0; i < clip.rects.c; i++) {
                TRC_DBG((TB, "  (%d,%d)(%d,%d)",
                        clip.rects.arcl[i].left, clip.rects.arcl[i].top,
                        clip.rects.arcl[i].right, clip.rects.arcl[i].bottom));

                // Intersect the SDA rect with the clip rect, checking for
                // no intersection. Convert clip.rects.arcl[i] to inclusive
                // coords during comparisons.
                clippedRect.left = max(clip.rects.arcl[i].left,
                        pRect->left);
                clippedRect.right = min(clip.rects.arcl[i].right,
                        pRect->right);

                // No horizontal intersection if the left boundary is to the
                // right of the right boundary.
                if (clippedRect.left < clippedRect.right) {
                    clippedRect.bottom = min(clip.rects.arcl[i].bottom,
                            pRect->bottom);
                    clippedRect.top = max(clip.rects.arcl[i].top, pRect->top);

                    // No vertical intersection if the top boundary is below
                    // the bottom boundary.
                    if (clippedRect.top < clippedRect.bottom) {
                        TRC_NRM((TB, "Adding SDA (%d,%d)(%d,%d)",
                                clippedRect.left, clippedRect.top,
                                clippedRect.right, clippedRect.bottom));
                        BA_AddScreenData(&clippedRect);
                    }
                }
            }
        } while (fMoreRects);
    }

    DC_END_FN();
}


/****************************************************************************/
// OEEncodeLineToOrder
//
// Encodes a LineTo order to wire format.
/****************************************************************************/
BOOL RDPCALL OEEncodeLineToOrder(
        PDD_PDEV ppdev,
        PPOINTL startPoint,
        PPOINTL endPoint,
        UINT32 rop2,
        UINT32 color,
        OE_ENUMRECTS *pClipRects)
{
    BOOL rc;
    PINT_ORDER pOrder;

    DC_BEGIN_FN("OEEncodeLineToOrder");

    // 2 field flag bytes.
    pOrder = OA_AllocOrderMem(ppdev, MAX_ORDER_SIZE(pClipRects->rects.c,
            2, MAX_LINETO_FIELD_SIZE));
    if (pOrder != NULL) {
        BYTE *pControlFlags = pOrder->OrderData;
        BYTE *pBuffer = pControlFlags + 1;
        PUINT32_UA pFieldFlags;
        short Delta, NormalCoordEncoding[4];
        BOOLEAN bUseDeltaCoords;
        unsigned NumFields;
        DCCOLOR Color;
        POINTL ClippedPoint;

        memset(NormalCoordEncoding, 0, sizeof(NormalCoordEncoding));
        // Direct-encode the primary order fields. 2 field flag bytes.
        *pControlFlags = TS_STANDARD;
        OE2_EncodeOrderType(pControlFlags, &pBuffer, TS_ENC_LINETO_ORDER);
        pFieldFlags = (PUINT32_UA)pBuffer;
        *pFieldFlags = 0;
        *(pFieldFlags + 1) = 0;
        pBuffer += 2;
        if (pClipRects->rects.c != 0)
            OE2_EncodeBounds(pControlFlags, &pBuffer,
                    &pClipRects->rects.arcl[0]);

        // Start with the BackMode field.
        // We only draw solid lines with no option as to what we do to the
        // background, so this is always transparent. We will end up sending
        // the field once with the first LineTo we send.
        if (PrevLineTo.BackMode != TRANSPARENT) {
            PrevLineTo.BackMode = TRANSPARENT;
            *((unsigned short UNALIGNED *)pBuffer) =
                    (unsigned short)TRANSPARENT;
            pBuffer += sizeof(short);
            *pFieldFlags |= 0x0001;
        }

        // Simultaneously determine if each of the coordinate fields has
        // changed, whether we can use delta coordinates, and save changed
        // fields.
        NumFields = 0;
        bUseDeltaCoords = TRUE;

        // Clip the start point coords.
        ClippedPoint = *startPoint;
        OEClipPoint(&ClippedPoint);

        // nXStart
        Delta = (short)(ClippedPoint.x - PrevLineTo.nXStart);
        if (Delta) {
            PrevLineTo.nXStart = ClippedPoint.x;
            if (Delta != (short)(char)Delta)
                bUseDeltaCoords = FALSE;
            pBuffer[NumFields] = (char)Delta;
            NormalCoordEncoding[NumFields] = (short)ClippedPoint.x;
            NumFields++;
            *pFieldFlags |= 0x0002;
        }

        // nYStart
        Delta = (short)(ClippedPoint.y - PrevLineTo.nYStart);
        if (Delta) {
            PrevLineTo.nYStart = ClippedPoint.y;
            if (Delta != (short)(char)Delta)
                bUseDeltaCoords = FALSE;
            pBuffer[NumFields] = (char)Delta;
            NormalCoordEncoding[NumFields] = (short)ClippedPoint.y;
            NumFields++;
            *pFieldFlags |= 0x0004;
        }

        // Clip the end point coords.
        ClippedPoint = *endPoint;
        OEClipPoint(&ClippedPoint);

        // nXEnd
        Delta = (short)(ClippedPoint.x - PrevLineTo.nXEnd);
        if (Delta) {
            PrevLineTo.nXEnd = ClippedPoint.x;
            if (Delta != (short)(char)Delta)
                bUseDeltaCoords = FALSE;
            pBuffer[NumFields] = (char)Delta;
            NormalCoordEncoding[NumFields] = (short)ClippedPoint.x;
            NumFields++;
            *pFieldFlags |= 0x0008;
        }

        // nYEnd
        Delta = (short)(ClippedPoint.y - PrevLineTo.nYEnd);
        if (Delta) {
            PrevLineTo.nYEnd = ClippedPoint.y;
            if (Delta != (short)(char)Delta)
                bUseDeltaCoords = FALSE;
            pBuffer[NumFields] = (char)Delta;
            NormalCoordEncoding[NumFields] = (short)ClippedPoint.y;
            NumFields++;
            *pFieldFlags |= 0x0010;
        }

        // Copy the final coordinates to the order.
        if (bUseDeltaCoords) {
            *pControlFlags |= TS_DELTA_COORDINATES;
            pBuffer += NumFields;
        }
        else {
            *((DWORD UNALIGNED *)pBuffer) = *((DWORD *)NormalCoordEncoding);
            *((DWORD UNALIGNED *)(pBuffer + 4)) =
                    *((DWORD *)&NormalCoordEncoding[2]);
            pBuffer += NumFields * sizeof(short);
        }

        // BackColor is a 3-byte color field.
        // As it happens, we always draw solid lines, so we can choose any
        // color. For convenience we choose black (0,0,0) so we never have to
        // send this field at all. We skip encoding flag 0x0020.

        // ROP2
        if (rop2 != PrevLineTo.ROP2) {
            PrevLineTo.ROP2 = rop2;
            *pBuffer++ = (BYTE)rop2;
            *pFieldFlags |= 0x0040;
        }
    
        // PenStyle
        // The NT Display Driver is only called to accelerate simple solid
        // lines. So we only support pen styles of PS_SOLID. Since PS_SOLID is
        // zero, we never have to send this field. Skip encoding flag 0x0080.

        // PenWidth
        // We only accelerate width 1 fields. Which means we will send the
        // 1 value only once in the first LineTo in the session.
        if (PrevLineTo.PenWidth != 1) {
            PrevLineTo.PenWidth = 1;
            *pBuffer++ = 1;
            *pFieldFlags |= 0x0100;
        }

        // PenColor is a 3-byte color field.
        OEConvertColor(ppdev, &Color, color, NULL);
        if (memcmp(&Color, &PrevLineTo.PenColor, sizeof(Color))) {
            PrevLineTo.PenColor = Color;
            *pBuffer++ = Color.u.rgb.red;
            *pBuffer++ = Color.u.rgb.green;
            *pBuffer++ = Color.u.rgb.blue;
            *pFieldFlags |= 0x0200;
        }

        // Set final size.
        pOrder->OrderLength = (unsigned)(pBuffer - pOrder->OrderData);

        // See if we can save sending some of the order field bytes.
        pOrder->OrderLength -= OE2_CheckTwoZeroFlagBytes(pControlFlags,
                (BYTE *)pFieldFlags,
                (unsigned)(pBuffer - (BYTE *)pFieldFlags - 2));

        INC_OUTCOUNTER(OUT_LINETO_ORDR);
        ADD_INCOUNTER(IN_LINETO_BYTES, pOrder->OrderLength);
        OA_AppendToOrderList(pOrder);

        // Flush the order.
        if (pClipRects->rects.c < 2)
            rc = TRUE;
        else
            rc = OEEmitReplayOrders(ppdev, 2, pClipRects);

        TRC_NRM((TB, "LineTo: rop2=%02X, PenColor=%04X, start=(%d,%d), "
                "end=(%d,%d)", rop2, Color.u.index,
                startPoint->x, startPoint->y,
                endPoint->x, endPoint->y));
    }
    else {
        TRC_ERR((TB, "Failed to alloc order"));
        rc = FALSE;
    }

    DC_END_FN();
    return rc;
}


/****************************************************************************/
// OESendSwitchSurfacePDU
//
// If the last drawing surface changed since, we need to send a switch
// surface PDU to the client to switch to the new surface
// This PDU is added to support multisurface rendering.
/****************************************************************************/
BOOL RDPCALL OESendSwitchSurfacePDU(PDD_PDEV ppdev, PDD_DSURF pdsurf)
{
    unsigned bitmapSurfaceId;
    void *UserDefined;
    PINT_ORDER pOrder;
    PTS_SWITCH_SURFACE_ORDER pSurfSwitchOrder;
    BOOL rc;

    DC_BEGIN_FN("OESendSwitchSurfacePDU");

    // Check if the surface has changed since the last drawing order.
    // If not, then we don't need to send the switch surface order.
    if (pdsurf != oeLastDstSurface) {
        // set last surface to the new surface
        oeLastDstSurface = pdsurf;
        
        if (pdsurf == NULL) {
            // Destination surface is the client screen
            bitmapSurfaceId = SCREEN_BITMAP_SURFACE;
        }
        else {
            if (pdsurf->shareId == pddShm->shareId) {
                // Get the offscreen bitmap Id.
                bitmapSurfaceId = pdsurf->bitmapId;
                
                // Udate the mru list of the offscreen cache
                CH_TouchCacheEntry(sbcOffscreenBitmapCacheHandle,
                        pdsurf->bitmapId);
            }
            else {
                //  This is the stale offscreen bitmap from last disconnected
                //  session.  We need to turn off the offscreen flag on this
                TRC_ALT((TB, "Need to turn off this offscreen bitmap"));
                pdsurf->flags |= DD_NO_OFFSCREEN;
                rc = FALSE;
                DC_QUIT;
            }
        }
    }
    else {
        // Return TRUE here since we didn't fail the send the order,
        // there's just no need to send it.
        rc = TRUE;
        DC_QUIT;
    }

    pOrder = OA_AllocOrderMem(ppdev, sizeof(TS_SWITCH_SURFACE_ORDER));
    if (pOrder != NULL) {
        pSurfSwitchOrder = (PTS_SWITCH_SURFACE_ORDER)pOrder->OrderData;
        pSurfSwitchOrder->ControlFlags = (TS_ALTSEC_SWITCH_SURFACE <<
                TS_ALTSEC_ORDER_TYPE_SHIFT) | TS_SECONDARY;
        pSurfSwitchOrder->BitmapID = (UINT16)bitmapSurfaceId;
        
        INC_OUTCOUNTER(OUT_SWITCHSURFACE);
        ADD_OUTCOUNTER(OUT_SWITCHSURFACE_BYTES,
                sizeof(TS_SWITCH_SURFACE_ORDER));
        OA_AppendToOrderList(pOrder);
        rc = TRUE;
    }
    else {
        TRC_ERR((TB, "Failed to add a switch surface PDU to the order heap"));
        rc = FALSE;
    }

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}

#ifdef DRAW_NINEGRID
/****************************************************************************/
// OESendStreamBitmapOrder
//
// This is to stream the bitmap bits (either compressed or not compressed 
// to the client in 4K block 
/****************************************************************************/
BOOL RDPCALL OESendStreamBitmapOrder(PDD_PDEV ppdev, unsigned bitmapId, 
        SIZEL *sizl, unsigned bitmapBpp, PBYTE BitmapBuffer, unsigned BitmapSize, 
        BOOL compressed)
{
    PINT_ORDER pIntOrder;
    PTS_STREAM_BITMAP_FIRST_PDU pStreamBitmapFirstPDU;
    PTS_STREAM_BITMAP_FIRST_PDU_REV2 pStreamBitmapFirstPDURev2;
    PTS_STREAM_BITMAP_NEXT_PDU pStreamBitmapNextPDU;
    BOOL rc = FALSE;
    BOOL fEndOfStream = FALSE;
    unsigned StreamBlockSize;
    unsigned BitmapRemainingSize;
    PBYTE BitmapRemainingBuffer;

    DC_BEGIN_FN("OESendStreamBitmapOrder");

    // Send the first stream block
    BitmapRemainingBuffer = BitmapBuffer;
    StreamBlockSize = min(BitmapSize, TS_STREAM_BITMAP_BLOCK);
    BitmapRemainingSize = BitmapSize - StreamBlockSize;
    
    if (pddShm->sbc.drawNineGridCacheInfo.supportLevel < TS_DRAW_NINEGRID_SUPPORTED_REV2) {
        pIntOrder = OA_AllocOrderMem(ppdev, sizeof(TS_STREAM_BITMAP_FIRST_PDU) +
                StreamBlockSize);
    }
    else {
        // TS_STREAM_BITMAP REV2
        pIntOrder = OA_AllocOrderMem(ppdev, sizeof(TS_STREAM_BITMAP_FIRST_PDU_REV2) +
                StreamBlockSize);
    }
    
    if (BitmapRemainingSize == 0) {
        fEndOfStream = TRUE;
    }

    if (pIntOrder != NULL) {
        if (pddShm->sbc.drawNineGridCacheInfo.supportLevel < TS_DRAW_NINEGRID_SUPPORTED_REV2) {
            pStreamBitmapFirstPDU = (PTS_STREAM_BITMAP_FIRST_PDU)pIntOrder->OrderData;
            pStreamBitmapFirstPDU->ControlFlags = (TS_ALTSEC_STREAM_BITMAP_FIRST <<
                    TS_ALTSEC_ORDER_TYPE_SHIFT) | TS_SECONDARY;
            pStreamBitmapFirstPDU->BitmapFlags = fEndOfStream ? TS_STREAM_BITMAP_END : 0;
            pStreamBitmapFirstPDU->BitmapFlags |= compressed ? TS_STREAM_BITMAP_COMPRESSED : 0;
            pStreamBitmapFirstPDU->BitmapId = (unsigned short)bitmapId;
            pStreamBitmapFirstPDU->BitmapBpp = (TSUINT8)bitmapBpp;
            pStreamBitmapFirstPDU->BitmapWidth = (TSUINT16)(sizl->cx);
            pStreamBitmapFirstPDU->BitmapHeight = (TSUINT16)(sizl->cy);
            pStreamBitmapFirstPDU->BitmapLength = (TSUINT16)BitmapSize;
            pStreamBitmapFirstPDU->BitmapBlockLength = (TSUINT16)(StreamBlockSize);

            memcpy(pStreamBitmapFirstPDU + 1, BitmapRemainingBuffer, StreamBlockSize);
        }
        else {
            // TS_STREAM_BITMAP REV2
            pStreamBitmapFirstPDURev2 = (PTS_STREAM_BITMAP_FIRST_PDU_REV2)pIntOrder->OrderData;
            pStreamBitmapFirstPDURev2->ControlFlags = (TS_ALTSEC_STREAM_BITMAP_FIRST <<
                    TS_ALTSEC_ORDER_TYPE_SHIFT) | TS_SECONDARY;
            pStreamBitmapFirstPDURev2->BitmapFlags = fEndOfStream ? TS_STREAM_BITMAP_END : 0;
            pStreamBitmapFirstPDURev2->BitmapFlags |= compressed ? TS_STREAM_BITMAP_COMPRESSED : 0;
            pStreamBitmapFirstPDURev2->BitmapFlags |= TS_STREAM_BITMAP_REV2; 
            pStreamBitmapFirstPDURev2->BitmapId = (unsigned short)bitmapId;
            pStreamBitmapFirstPDURev2->BitmapBpp = (TSUINT8)bitmapBpp;
            pStreamBitmapFirstPDURev2->BitmapWidth = (TSUINT16)(sizl->cx);
            pStreamBitmapFirstPDURev2->BitmapHeight = (TSUINT16)(sizl->cy);
            pStreamBitmapFirstPDURev2->BitmapLength = (TSUINT32)BitmapSize;
            pStreamBitmapFirstPDURev2->BitmapBlockLength = (TSUINT16)(StreamBlockSize);

            memcpy(pStreamBitmapFirstPDURev2 + 1, BitmapRemainingBuffer, StreamBlockSize);
        }

        BitmapRemainingBuffer += StreamBlockSize;

        OA_AppendToOrderList(pIntOrder);        
    }
    else {
        TRC_ERR((TB, "Failed to allocated order for stream bitmap"));
        DC_QUIT;
    }
    
    
    // Send the subsequent streamblock
    while (BitmapRemainingSize) {
        StreamBlockSize = min(BitmapRemainingSize, TS_STREAM_BITMAP_BLOCK);
        BitmapRemainingSize = BitmapRemainingSize - StreamBlockSize;

        pIntOrder = OA_AllocOrderMem(ppdev, sizeof(TS_STREAM_BITMAP_NEXT_PDU) +
                                     StreamBlockSize);

        if (BitmapRemainingSize == 0) {
            fEndOfStream = TRUE;
        }

        if (pIntOrder != NULL) {
            pStreamBitmapNextPDU = (PTS_STREAM_BITMAP_NEXT_PDU)pIntOrder->OrderData;
            pStreamBitmapNextPDU->ControlFlags = (TS_ALTSEC_STREAM_BITMAP_NEXT <<
                    TS_ALTSEC_ORDER_TYPE_SHIFT) | TS_SECONDARY;
            pStreamBitmapNextPDU->BitmapFlags = fEndOfStream ? TS_STREAM_BITMAP_END : 0;
            pStreamBitmapNextPDU->BitmapFlags |= compressed ? TS_STREAM_BITMAP_COMPRESSED : 0;
            pStreamBitmapNextPDU->BitmapId = (unsigned short)bitmapId;
            pStreamBitmapNextPDU->BitmapBlockLength = (TSUINT16)StreamBlockSize;

            memcpy(pStreamBitmapNextPDU + 1, BitmapRemainingBuffer, StreamBlockSize);
            BitmapRemainingBuffer += StreamBlockSize;
            
            OA_AppendToOrderList(pIntOrder);
        }
        else {
            TRC_ERR((TB, "Failed to allocated order for stream bitmap"));
            DC_QUIT;
        }
    }

    rc = TRUE;

DC_EXIT_POINT:

    DC_END_FN();
    return rc;
}


/****************************************************************************/
// OESendCreateNineGridBitmapOrder
//
// Send the alternative secondary order to client to create the ninegrid bitmap
/****************************************************************************/
BOOL RDPCALL OESendCreateNineGridBitmapOrder(PDD_PDEV ppdev, unsigned nineGridBitmapId, 
        SIZEL *sizl, unsigned bitmapBpp, PNINEGRID png)
{
    PINT_ORDER pOrder;
    PTS_CREATE_NINEGRID_BITMAP_ORDER pCreateNineGridBitmapOrder;
    BOOL rc = FALSE;
    
    DC_BEGIN_FN("OESendCreateNineGridBitmapOrder");

    pOrder = OA_AllocOrderMem(ppdev, sizeof(TS_CREATE_NINEGRID_BITMAP_ORDER));

    if (pOrder != NULL) {
        
        pCreateNineGridBitmapOrder = (PTS_CREATE_NINEGRID_BITMAP_ORDER)pOrder->OrderData;
        pCreateNineGridBitmapOrder->ControlFlags = (TS_ALTSEC_CREATE_NINEGRID_BITMAP <<
                TS_ALTSEC_ORDER_TYPE_SHIFT) | TS_SECONDARY;
        pCreateNineGridBitmapOrder->BitmapID = (UINT16)nineGridBitmapId;
        pCreateNineGridBitmapOrder->BitmapBpp = (BYTE)bitmapBpp;
        pCreateNineGridBitmapOrder->cx = (TSUINT16)sizl->cx;
        pCreateNineGridBitmapOrder->cy = (TSUINT16)sizl->cy;
        pCreateNineGridBitmapOrder->nineGridInfo.crTransparent = png->crTransparent;
        pCreateNineGridBitmapOrder->nineGridInfo.flFlags = png->flFlags;
        pCreateNineGridBitmapOrder->nineGridInfo.ulLeftWidth = (TSUINT16)png->ulLeftWidth;
        pCreateNineGridBitmapOrder->nineGridInfo.ulRightWidth = (TSUINT16)png->ulRightWidth;
        pCreateNineGridBitmapOrder->nineGridInfo.ulTopHeight = (TSUINT16)png->ulTopHeight;
        pCreateNineGridBitmapOrder->nineGridInfo.ulBottomHeight = (TSUINT16)png->ulBottomHeight;
        
        //INC_OUTCOUNTER(OUT_SWITCHSURFACE);
        //ADD_OUTCOUNTER(OUT_SWITCHSURFACE_BYTES,
        //        sizeof(TS_SWITCH_SURFACE_ORDER));
        OA_AppendToOrderList(pOrder);
        rc = TRUE;
    }
    else {
        TRC_ERR((TB, "Failed to add a create drawninegrid order to the order heap"));
        rc = FALSE;
    }

    DC_END_FN();
    return rc;
}

/****************************************************************************/
// OECacheDrawNineGridBitmap
//
// Cache the draw ninegrid bitmap
/****************************************************************************/
BOOL RDPCALL OECacheDrawNineGridBitmap(PDD_PDEV ppdev, SURFOBJ *psoSrc, 
        PNINEGRID png, unsigned *bitmapId)
{
    CHDataKeyContext CHContext;
    void *UserDefined;
    HSURF hWorkBitmap = NULL;
    SURFOBJ *pWorkSurf = NULL;
    SIZEL bitmapSize;
    BOOL rc = FALSE;
    PBYTE pWorkingBuffer = NULL;
    PBYTE BitmapBuffer = NULL;
    unsigned BitmapBufferSize = 0;

    DC_BEGIN_FN("OECacheDrawNineGridBitmap");

    CH_CreateKeyFromFirstData(&CHContext, psoSrc->pvBits, psoSrc->cjBits);
    CH_CreateKeyFromNextData(&CHContext, png, sizeof(NINEGRID));
    
    if (!CH_SearchCache(sbcDrawNineGridBitmapCacheHandle, CHContext.Key1, CHContext.Key2, 
            &UserDefined, bitmapId)) {
        
        *bitmapId = CH_CacheKey(sbcDrawNineGridBitmapCacheHandle, CHContext.Key1, 
                CHContext.Key2, NULL);

        if (*bitmapId != CH_KEY_UNCACHABLE) {
            unsigned BitmapRawSize;
            unsigned BitmapCompSize = 0;
            unsigned BitmapBpp;
            
            PBYTE BitmapRawBuffer;
            
            unsigned paddedBitmapWidth;            
            BOOL ret;
            // Get the protocol bitmap bpp
            switch (psoSrc->iBitmapFormat)
            {
            case BMF_16BPP:
                BitmapBpp = 16;
                break;

            case BMF_24BPP:
                BitmapBpp = 24;
                break;

            case BMF_32BPP:
                BitmapBpp = 32;
                break;

            default:
                TRC_ASSERT((FALSE), (TB, "Invalid bitmap bpp: %d", psoSrc->iBitmapFormat));
                BitmapBpp = 8;
            }

            paddedBitmapWidth = (psoSrc->sizlBitmap.cx + 3) & ~3;
            bitmapSize.cx = paddedBitmapWidth;
            bitmapSize.cy = psoSrc->sizlBitmap.cy;

            // The bitmap width needs to be dword aligned
            if (paddedBitmapWidth != psoSrc->sizlBitmap.cx) {
                RECTL rect = { 0 };
                POINTL origin = { 0 };

                rect.right = psoSrc->sizlBitmap.cx;
                rect.bottom = psoSrc->sizlBitmap.cy;
                
                hWorkBitmap = (HSURF)EngCreateBitmap(bitmapSize,
                        TS_BYTES_IN_SCANLINE(bitmapSize.cx, BitmapBpp),
                        psoSrc->iBitmapFormat, 0, NULL);

                if (hWorkBitmap) {
                
                    pWorkSurf = EngLockSurface(hWorkBitmap);
    
                    if (pWorkSurf) {
                        // Copy to a worker bitmap
                        if (EngCopyBits(pWorkSurf, psoSrc, NULL, NULL, &rect, &origin)) {
                            BitmapRawSize = pWorkSurf->cjBits;
                            BitmapRawBuffer = pWorkSurf->pvBits;
         
                            BitmapBuffer = EngAllocMem(0, BitmapRawSize, WD_ALLOC_TAG);
                            BitmapBufferSize = BitmapRawSize;
            
                            if (BitmapBuffer == NULL) {
                                ret = FALSE;
                                goto Post_Compression;
                            }

                            if (BitmapRawSize > MAX_UNCOMPRESSED_DATA_SIZE) {
                                pWorkingBuffer = EngAllocMem(0, BitmapRawSize, WD_ALLOC_TAG);

                                if (pWorkingBuffer == NULL) {
                                    ret = FALSE;
                                    goto Post_Compression;
                                }
                            }

                            ret = BC_CompressBitmap(pWorkSurf->pvBits, BitmapBuffer, pWorkingBuffer,
                                     BitmapBufferSize, &BitmapCompSize, paddedBitmapWidth, 
                                     psoSrc->sizlBitmap.cy, BitmapBpp);

                            
                        }
                        else {
                            TRC_ERR((TB, "Failed EngCopyBits"));
                            DC_QUIT;
                        }
                    }
                    else {
                        TRC_ERR((TB, "Failed to lock the bitmap"));
                        DC_QUIT;
                    }
                }
                else {
                    TRC_ERR((TB, "Failed to create the bitmap"));
                    DC_QUIT;
                }
            }
            else {
                BitmapRawSize = psoSrc->cjBits;
                BitmapRawBuffer = psoSrc->pvBits;
                
                BitmapBuffer = EngAllocMem(0, BitmapRawSize, WD_ALLOC_TAG);
                BitmapBufferSize = BitmapRawSize;

                if (BitmapBuffer == NULL) {
                    ret = FALSE;
                    goto Post_Compression;
                }

                if (BitmapRawSize > MAX_UNCOMPRESSED_DATA_SIZE) {
                    pWorkingBuffer = EngAllocMem(0, BitmapRawSize, WD_ALLOC_TAG);
                    if (pWorkingBuffer == NULL) {
                        ret = FALSE;
                        goto Post_Compression;
                    }
                }

                ret = BC_CompressBitmap(psoSrc->pvBits, BitmapBuffer, pWorkingBuffer, BitmapBufferSize,
                                  &BitmapCompSize, paddedBitmapWidth, psoSrc->sizlBitmap.cy,
                                  BitmapBpp);
            }

Post_Compression:

            if (ret) {
                // Send compressed bitmap
                if (!OESendStreamBitmapOrder(ppdev, TS_DRAW_NINEGRID_BITMAP_CACHE, &bitmapSize, BitmapBpp, 
                        BitmapBuffer, BitmapCompSize, TRUE)) {
                    TRC_ERR((TB, "Failed to send stream bitmap order"));
                    DC_QUIT;
                }

            }
            else {
                // Send uncompressed bitmap
                if (!OESendStreamBitmapOrder(ppdev, TS_DRAW_NINEGRID_BITMAP_CACHE, &bitmapSize, BitmapBpp,
                        BitmapRawBuffer, BitmapRawSize, FALSE))
                {
                    TRC_ERR((TB, "Failed to send stream bitmap order"));
                    DC_QUIT;
                }
            }

            // send a create drawninegrid bitmap pdu
            if (OESendCreateNineGridBitmapOrder(ppdev, *bitmapId,
                    &(psoSrc->sizlBitmap), BitmapBpp, png)) {
                // Update the current offscreen cache size
                //oeCurrentOffscreenCacheSize += bitmapSize;
                //pdsurf->bitmapId = offscrBitmapId;
                TRC_NRM((TB, "Created a drawninegrid bitmap"));                
            } 
            else {
                TRC_ERR((TB, "Failed to send the create bitmap pdu"));                
                DC_QUIT;
            }
        } 
        else {
            TRC_ERR((TB, "Failed to cache the bitmap"));
            DC_QUIT;
        }                        
    }
    else {
        // bitmap already cached        
    }

    rc = TRUE;

DC_EXIT_POINT:
  
    if (pWorkSurf) 
        EngUnlockSurface(pWorkSurf);

    if (hWorkBitmap) 
        EngDeleteSurface(hWorkBitmap);

    if (pWorkingBuffer) {
        EngFreeMem(pWorkingBuffer);
    }

    if (BitmapBuffer) {
        EngFreeMem(BitmapBuffer);
    }

    if (rc != TRUE && *bitmapId != CH_KEY_UNCACHABLE) 
        CH_RemoveCacheEntry(sbcDrawNineGridBitmapCacheHandle, *bitmapId);
    
    DC_END_FN();
    return rc;
}

/****************************************************************************/
// OEEncodeDrawNineGrid
//
// Encodes the DrawNineGrid order. Returns FALSE on failure.
/****************************************************************************/
BOOL RDPCALL OEEncodeDrawNineGrid(
        RECTL *pBounds,
        RECTL *psrcRect,
        unsigned bitmapId,
        PDD_PDEV ppdev,
        OE_ENUMRECTS *pClipRects)
{
    BOOL rc = FALSE;
    unsigned OrderSize;
    unsigned NumFieldFlagBytes = 0;
    BYTE OrderType = 0;
    PINT_ORDER pOrder;
    MULTI_DRAWNINEGRID_ORDER *pPrevDNG;
    
    DC_BEGIN_FN("OEEncodeDrawNineGrid");

    // Check whether we should use the multi-cliprect version.     
    if (pClipRects->rects.c == 0) {
        // Non-multi version.
        OrderType = TS_ENC_DRAWNINEGRID_ORDER;
        OrderSize = MAX_DRAWNINEGRID_FIELD_SIZE;
        pPrevDNG = (MULTI_DRAWNINEGRID_ORDER *)&PrevDrawNineGrid;
        NumFieldFlagBytes = 1;        
    }
    else {
        // Multi version.
        OrderType = TS_ENC_MULTI_DRAWNINEGRID_ORDER;
        OrderSize = MAX_MULTI_DRAWNINEGRID_FIELD_SIZE_NCLIP(pClipRects->rects.c);
        pPrevDNG = &PrevMultiDrawNineGrid;
        NumFieldFlagBytes = 1;        
    }

    // Encode and send the order
    pOrder = OA_AllocOrderMem(ppdev, MAX_ORDER_SIZE(((NULL == pBounds) ? 0 : 1),
            NumFieldFlagBytes, OrderSize));

    if (pOrder != NULL) {
        DRAWNINEGRID_ORDER *pDNG;

        pDNG = (DRAWNINEGRID_ORDER *)oeTempOrderBuffer;
        pDNG->srcLeft = psrcRect->left;
        pDNG->srcTop = psrcRect->top;
        pDNG->srcRight = psrcRect->right;
        pDNG->srcBottom = psrcRect->bottom;
        pDNG->bitmapId = (unsigned short)bitmapId;

        // Need to increment this bound as we use it as cliprect and in the encode order
        // code it'll make it includsive over the wire
        pBounds->right += 1;
        pBounds->bottom += 1;

        if (OrderType == TS_ENC_DRAWNINEGRID_ORDER) {
            // Slow-field-encode the order 
            pOrder->OrderLength = OE2_EncodeOrder(pOrder->OrderData,
                    TS_ENC_DRAWNINEGRID_ORDER, NUM_DRAWNINEGRID_FIELDS,
                    (BYTE *)pDNG, (BYTE *)pPrevDNG, etable_NG,
                    pBounds);

            //INC_OUTCOUNTER(OUT_SCRBLT_ORDER);
            //ADD_INCOUNTER(IN_SCRBLT_BYTES, pOrder->OrderLength);
            OA_AppendToOrderList(pOrder);
            rc = TRUE;            
        }
        else {
            MULTI_DRAWNINEGRID_ORDER *pMultiDNG = (MULTI_DRAWNINEGRID_ORDER *)
                    oeTempOrderBuffer;

            // Encode the clip rects directly into the order.
            pMultiDNG->nDeltaEntries = OEBuildMultiClipOrder(ppdev,
                    &pMultiDNG->codedDeltaList, pClipRects);

            // Slow-field-encode the order with no clip rects.
            pOrder->OrderLength = OE2_EncodeOrder(pOrder->OrderData,
                    TS_ENC_MULTI_DRAWNINEGRID_ORDER, NUM_MULTI_DRAWNINEGRID_FIELDS,
                    (BYTE *)pMultiDNG, (BYTE *)pPrevDNG, etable_MG,
                    pBounds);

            //INC_OUTCOUNTER(OUT_MULTI_SCRBLT_ORDER);
            //ADD_INCOUNTER(IN_MULTI_SCRBLT_BYTES, pOrder->OrderLength);
            OA_AppendToOrderList(pOrder);
            rc = TRUE;
        }
    }
    else {
        TRC_ERR((TB, "Failed to alloc order"));
        INC_OUTCOUNTER(OUT_BITBLT_SDA_HEAPALLOCFAILED);
        rc = FALSE;
    }

    DC_END_FN();
    return rc;
}


#if 0
BOOL RDPCALL OESendCreateDrawStreamOrder(PDD_PDEV ppdev, unsigned bitmapId, 
        SIZEL *sizl, unsigned bitmapBpp)
{
    PINT_ORDER pOrder;
    PTS_CREATE_DRAW_STREAM_ORDER pCreateDrawStreamOrder;
    BOOL rc = FALSE;
    
    DC_BEGIN_FN("OESendCreateDrawStreamOrder");

    pOrder = OA_AllocOrderMem(ppdev, sizeof(TS_CREATE_DRAW_STREAM_ORDER));

    if (pOrder != NULL) {
        
        pCreateDrawStreamOrder = (PTS_CREATE_DRAW_STREAM_ORDER)pOrder->OrderData;
        pDrawStreamOrder->ControlFlags = (TS_ALTSEC_DRAW_STREAM <<
                TS_ALTSEC_ORDER_TYPE_SHIFT) | TS_SECONDARY;
        pCreateDrawStreamOrder->BitmapID = (UINT16)bitmapId;
        pCreateDrawStreamOrder->bitmapBpp = (BYTE)bitmapBpp;
        pCreateDrawStreamOrder->cx = (TSUINT16)sizl->cx;
        pCreateDrawStreamOrder->cy = (TSUINT16)sizl->cy;
        
        //INC_OUTCOUNTER(OUT_SWITCHSURFACE);
        //ADD_OUTCOUNTER(OUT_SWITCHSURFACE_BYTES,
        //        sizeof(TS_SWITCH_SURFACE_ORDER));
        OA_AppendToOrderList(pOrder);
        rc = TRUE;
    }
    else {
        TRC_ERR((TB, "Failed to add a create draw stream order to the order heap"));
        rc = FALSE;
    }

    rc = TRUE;

    DC_END_FN();
    return rc;
}

VOID OEEncodeDrawStream(PVOID stream, ULONG streamSize, PPOINTL dstOffset, 
        PBYTE streamOut, unsigned* streamSizeOut)
{
    ULONG * pul = (ULONG *) stream;
    ULONG   cjIn = streamSize;
    
    DC_BEGIN_FN("OEEncodeDrawStream");

    *streamSizeOut = 0;

    while(cjIn >= sizeof(ULONG))
    {
        ULONG   command = *pul;
        ULONG   commandSize;

        switch(command)
        {
        case DS_COPYTILEID: 
            {
                DS_COPYTILE * cmd = (DS_COPYTILE *) pul;
                RDP_DS_COPYTILE * rdpcmd = (RDP_DS_COPYTILE *) streamOut;

                commandSize = sizeof(*cmd);

                if (cjIn < commandSize) {
                    DC_QUIT;
                }

                cmd->rclDst.left += dstOffset->x;
                cmd->rclDst.right += dstOffset->x;
                cmd->rclDst.top += dstOffset->y;
                cmd->rclDst.bottom += dstOffset->y;                                


                rdpcmd->ulCmdID = (BYTE)(DS_COPYTILEID);

                OEClipRect(&(cmd->rclDst));
                OEClipRect(&(cmd->rclSrc));
                OEClipPoint(&(cmd->ptlOrigin));
                
                RECTL_TO_TSRECT16(rdpcmd->rclDst, cmd->rclDst);
                RECTL_TO_TSRECT16(rdpcmd->rclSrc, cmd->rclSrc);
                POINTL_TO_TSPOINT16(rdpcmd->ptlOrigin, cmd->ptlOrigin);

                *streamSizeOut += sizeof(RDP_DS_COPYTILE);
                streamOut += sizeof(RDP_DS_COPYTILE);
            }
            break;
        
        case DS_SOLIDFILLID: 
            {             
                DS_SOLIDFILL * cmd = (DS_SOLIDFILL *) pul;
                RDP_DS_SOLIDFILL * rdpcmd = (RDP_DS_SOLIDFILL *) streamOut;

                commandSize = sizeof(*cmd);

                if (cjIn < commandSize) {
                    DC_QUIT;
                }

                cmd->rclDst.left += dstOffset->x;
                cmd->rclDst.right += dstOffset->x;
                cmd->rclDst.top += dstOffset->y;
                cmd->rclDst.bottom += dstOffset->y;   


                rdpcmd->ulCmdID = (BYTE)(DS_SOLIDFILLID);
                rdpcmd->crSolidColor = cmd->crSolidColor;

                OEClipRect(&(cmd->rclDst));
                RECTL_TO_TSRECT16(rdpcmd->rclDst, cmd->rclDst);
                
                *streamSizeOut += sizeof(RDP_DS_SOLIDFILL);
                streamOut += sizeof(RDP_DS_SOLIDFILL);
            }
            break;

        case DS_TRANSPARENTTILEID: 
            {
                DS_TRANSPARENTTILE * cmd = (DS_TRANSPARENTTILE *) pul;
                RDP_DS_TRANSPARENTTILE * rdpcmd = (RDP_DS_TRANSPARENTTILE *) streamOut;

                commandSize = sizeof(*cmd);

                if (cjIn < commandSize) {
                    DC_QUIT;
                }

                cmd->rclDst.left += dstOffset->x;
                cmd->rclDst.right += dstOffset->x;
                cmd->rclDst.top += dstOffset->y;
                cmd->rclDst.bottom += dstOffset->y;  


                rdpcmd->ulCmdID = (BYTE)(DS_TRANSPARENTTILEID);
                rdpcmd->crTransparentColor = cmd->crTransparentColor;

                OEClipRect(&(cmd->rclDst));
                OEClipRect(&(cmd->rclSrc));
                OEClipPoint(&(cmd->ptlOrigin));
                
                RECTL_TO_TSRECT16(rdpcmd->rclDst, cmd->rclDst);
                RECTL_TO_TSRECT16(rdpcmd->rclSrc, cmd->rclSrc);
                POINTL_TO_TSPOINT16(rdpcmd->ptlOrigin, cmd->ptlOrigin);

                *streamSizeOut += sizeof(RDP_DS_TRANSPARENTTILE);
                streamOut += sizeof(RDP_DS_TRANSPARENTTILE);

            }
            break;

        case DS_ALPHATILEID: 
            {
                DS_ALPHATILE * cmd = (DS_ALPHATILE *) pul;
                RDP_DS_ALPHATILE * rdpcmd = (RDP_DS_ALPHATILE *) streamOut;

                commandSize = sizeof(*cmd);

                if (cjIn < commandSize) {
                    DC_QUIT;
                }

                cmd->rclDst.left += dstOffset->x;
                cmd->rclDst.right += dstOffset->x;
                cmd->rclDst.top += dstOffset->y;
                cmd->rclDst.bottom += dstOffset->y;           

                rdpcmd->ulCmdID = (BYTE)(DS_ALPHATILEID);
                rdpcmd->blendFunction.AlphaFormat = cmd->blendFunction.AlphaFormat;
                rdpcmd->blendFunction.BlendFlags = cmd->blendFunction.BlendFlags;
                rdpcmd->blendFunction.BlendOp = cmd->blendFunction.BlendOp;
                rdpcmd->blendFunction.SourceConstantAlpha = cmd->blendFunction.SourceConstantAlpha;

                OEClipRect(&(cmd->rclDst));
                OEClipRect(&(cmd->rclSrc));
                OEClipPoint(&(cmd->ptlOrigin));
                
                RECTL_TO_TSRECT16(rdpcmd->rclDst, cmd->rclDst);
                RECTL_TO_TSRECT16(rdpcmd->rclSrc, cmd->rclSrc);
                POINTL_TO_TSPOINT16(rdpcmd->ptlOrigin, cmd->ptlOrigin);

                *streamSizeOut += sizeof(RDP_DS_ALPHATILE);
                streamOut += sizeof(RDP_DS_ALPHATILE);
            }
            break;

        case DS_STRETCHID: 
            {
                DS_STRETCH * cmd = (DS_STRETCH *) pul;
                RDP_DS_STRETCH * rdpcmd = (RDP_DS_STRETCH *) streamOut;

                commandSize = sizeof(*cmd);

                if (cjIn < commandSize) {
                    DC_QUIT;
                }

                cmd->rclDst.left += dstOffset->x;
                cmd->rclDst.right += dstOffset->x;
                cmd->rclDst.top += dstOffset->y;
                cmd->rclDst.bottom += dstOffset->y;           

                rdpcmd->ulCmdID = (BYTE)(DS_STRETCHID);
                
                OEClipRect(&(cmd->rclDst));
                OEClipRect(&(cmd->rclSrc));
                
                RECTL_TO_TSRECT16(rdpcmd->rclDst, cmd->rclDst);
                RECTL_TO_TSRECT16(rdpcmd->rclSrc, cmd->rclSrc);
                
                *streamSizeOut += sizeof(RDP_DS_STRETCH);
                streamOut += sizeof(RDP_DS_STRETCH);                
            }
            break;

        case DS_TRANSPARENTSTRETCHID: 
            {
                DS_TRANSPARENTSTRETCH * cmd = (DS_TRANSPARENTSTRETCH *) pul;
                RDP_DS_TRANSPARENTSTRETCH * rdpcmd = (RDP_DS_TRANSPARENTSTRETCH *) streamOut;

                commandSize = sizeof(*cmd);

                if (cjIn < commandSize) {
                    DC_QUIT;
                }

                cmd->rclDst.left += dstOffset->x;
                cmd->rclDst.right += dstOffset->x;
                cmd->rclDst.top += dstOffset->y;
                cmd->rclDst.bottom += dstOffset->y;   

                rdpcmd->ulCmdID = (BYTE)(DS_TRANSPARENTSTRETCHID);
                rdpcmd->crTransparentColor = cmd->crTransparentColor;
                
                OEClipRect(&(cmd->rclDst));
                OEClipRect(&(cmd->rclSrc));
                
                RECTL_TO_TSRECT16(rdpcmd->rclDst, cmd->rclDst);
                RECTL_TO_TSRECT16(rdpcmd->rclSrc, cmd->rclSrc);
                
                *streamSizeOut += sizeof(RDP_DS_TRANSPARENTSTRETCH);
                streamOut += sizeof(RDP_DS_TRANSPARENTSTRETCH);
            }
            break;

        case DS_ALPHASTRETCHID: 
            {
                DS_ALPHASTRETCH * cmd = (DS_ALPHASTRETCH *) pul;
                RDP_DS_ALPHASTRETCH * rdpcmd = (RDP_DS_ALPHASTRETCH *) streamOut;

                commandSize = sizeof(*cmd);

                if (cjIn < commandSize) {
                    DC_QUIT;
                }

                cmd->rclDst.left += dstOffset->x;
                cmd->rclDst.right += dstOffset->x;
                cmd->rclDst.top += dstOffset->y;
                cmd->rclDst.bottom += dstOffset->y;            

                rdpcmd->ulCmdID = (BYTE)(DS_ALPHASTRETCHID);
                rdpcmd->blendFunction.AlphaFormat = cmd->blendFunction.AlphaFormat;
                rdpcmd->blendFunction.BlendFlags = cmd->blendFunction.BlendFlags;
                rdpcmd->blendFunction.BlendOp = cmd->blendFunction.BlendOp;
                rdpcmd->blendFunction.SourceConstantAlpha = cmd->blendFunction.SourceConstantAlpha;

                OEClipRect(&(cmd->rclDst));
                OEClipRect(&(cmd->rclSrc));
                
                RECTL_TO_TSRECT16(rdpcmd->rclDst, cmd->rclDst);
                RECTL_TO_TSRECT16(rdpcmd->rclSrc, cmd->rclSrc);
                
                *streamSizeOut += sizeof(RDP_DS_ALPHASTRETCH);
                streamOut += sizeof(RDP_DS_ALPHASTRETCH);
            }
            break;

        default: 
            {
                DC_QUIT;
            }
        }

        cjIn -= commandSize;
        pul += commandSize / 4;
    }

DC_EXIT_POINT:

   DC_END_FN();
}

BOOL RDPCALL OESendDrawStreamOrder(PDD_PDEV ppdev, unsigned bitmapId, unsigned ulIn, PVOID pvIn,
        PPOINTL dstOffset, RECTL *bounds, OE_ENUMRECTS *pclipRects)
{
    PINT_ORDER pOrder;
    PTS_DRAW_STREAM_ORDER pDrawStreamOrder;
    unsigned cbOrderSize;
    BOOL rc = FALSE;
    
    DC_BEGIN_FN("OESendDrawStreamOrder");

    cbOrderSize = sizeof(TS_DRAW_STREAM_ORDER) + ulIn + 
            sizeof(TS_RECTANGLE16) * pclipRects->rects.c;

    pOrder = OA_AllocOrderMem(ppdev, cbOrderSize);

    if (pOrder != NULL) {
        unsigned i, streamSize;
        TS_RECTANGLE16 *clipRects;
        PBYTE stream;
        
        pDrawStreamOrder = (PTS_DRAW_STREAM_ORDER)pOrder->OrderData;
        pDrawStreamOrder->ControlFlags = (TS_ALTSEC_DRAW_STREAM <<
                TS_ALTSEC_ORDER_TYPE_SHIFT) | TS_SECONDARY;
        pDrawStreamOrder->Bounds.left = (TSINT16)(bounds->left);
        pDrawStreamOrder->Bounds.top = (TSINT16)(bounds->top);
        pDrawStreamOrder->Bounds.right = (TSINT16)(bounds->right);
        pDrawStreamOrder->Bounds.bottom = (TSINT16)(bounds->bottom);

        pDrawStreamOrder->nClipRects = (TSUINT8)(pclipRects->rects.c);
        pDrawStreamOrder->BitmapID = (UINT16)bitmapId;
        
        clipRects = (TS_RECTANGLE16 *)(pDrawStreamOrder + 1);

        // add the cliprects here.
        for (i = 0; i < pclipRects->rects.c; i++) {
            clipRects[i].left = (TSINT16)pclipRects->rects.arcl[i].left;
            clipRects[i].right = (TSINT16)pclipRects->rects.arcl[i].right;
            clipRects[i].top = (TSINT16)pclipRects->rects.arcl[i].top;
            clipRects[i].bottom = (TSINT16)pclipRects->rects.arcl[i].bottom;
        }

        // add the stream data
        stream = (PBYTE)clipRects + sizeof(TS_RECTANGLE16) * pclipRects->rects.c;

        OEEncodeDrawStream(pvIn, ulIn, dstOffset, stream, &streamSize);
        pDrawStreamOrder->StreamLen = (TSUINT16)streamSize;

        cbOrderSize = sizeof(TS_DRAW_STREAM_ORDER) + streamSize + 
            sizeof(TS_RECTANGLE16) * pclipRects->rects.c;

        
        //INC_OUTCOUNTER(OUT_SWITCHSURFACE);
        //ADD_OUTCOUNTER(OUT_SWITCHSURFACE_BYTES,
        //        sizeof(TS_SWITCH_SURFACE_ORDER));

        OA_TruncateAllocatedOrder(pOrder, cbOrderSize);
        OA_AppendToOrderList(pOrder);
        rc = TRUE;
    }
    else {
        TRC_ERR((TB, "Failed to add a draw stream order to the order heap"));
        rc = FALSE;
    }

    rc = TRUE;

    DC_END_FN();
    return rc;
}

BOOL RDPCALL OESendDrawNineGridOrder(PDD_PDEV ppdev, unsigned bitmapId, 
        PRECTL prclSrc, RECTL *bounds, OE_ENUMRECTS *pclipRects)
{
    PINT_ORDER pOrder;
    PTS_DRAW_NINEGRID_ORDER pDrawNineGridOrder;
    BOOL rc;
    unsigned cbOrderSize;
    unsigned srcRectIndex;

    DC_BEGIN_FN("OESendDrawNineGridOrder");

    cbOrderSize = sizeof(TS_DRAW_NINEGRID_ORDER) + 
            sizeof(TS_RECTANGLE16) * pclipRects->rects.c;

    pOrder = OA_AllocOrderMem(ppdev, cbOrderSize);

    if (pOrder != NULL) {
        unsigned i;
        TS_RECTANGLE16 *clipRects;
        
        pDrawNineGridOrder = (PTS_DRAW_NINEGRID_ORDER)pOrder->OrderData;
        pDrawNineGridOrder->ControlFlags = (TS_ALTSEC_DRAW_NINEGRID <<
                TS_ALTSEC_ORDER_TYPE_SHIFT) | TS_SECONDARY;
        pDrawNineGridOrder->Bounds.left = (TSINT16)(bounds->left);
        pDrawNineGridOrder->Bounds.top = (TSINT16)(bounds->top);
        pDrawNineGridOrder->Bounds.right = (TSINT16)(bounds->right);
        pDrawNineGridOrder->Bounds.bottom = (TSINT16)(bounds->bottom);

        pDrawNineGridOrder->nClipRects = (TSUINT8)(pclipRects->rects.c);
        pDrawNineGridOrder->BitmapID = (TSUINT8)bitmapId;
        
        pDrawNineGridOrder->srcBounds.left = (TSINT16)(prclSrc->left);
        pDrawNineGridOrder->srcBounds.top = (TSINT16)(prclSrc->top);
        pDrawNineGridOrder->srcBounds.right = (TSINT16)(prclSrc->right);
        pDrawNineGridOrder->srcBounds.bottom = (TSINT16)(prclSrc->bottom);

        clipRects = (TS_RECTANGLE16 *)(pDrawNineGridOrder + 1);

        // add the cliprects here.
        for (i = 0; i < pclipRects->rects.c; i++) {
            clipRects[i].left = (TSINT16)pclipRects->rects.arcl[i].left;
            clipRects[i].right = (TSINT16)pclipRects->rects.arcl[i].right;
            clipRects[i].top = (TSINT16)pclipRects->rects.arcl[i].top;
            clipRects[i].bottom = (TSINT16)pclipRects->rects.arcl[i].bottom;
        }

        OA_AppendToOrderList(pOrder);
        rc = TRUE;
    }
    else {
        TRC_ERR((TB, "Failed to add a draw stream order to the order heap"));
        rc = FALSE;
    }

    rc = TRUE;

    DC_END_FN();
    return rc;
}
#endif
#endif //DRAW_NINEGRID

#ifdef DRAW_GDIPLUS
/****************************************************************************/
// OECreateDrawGdiplusOrder
//
// Create and Send DrawGdiplus order.
/****************************************************************************/
BOOL RDPCALL OECreateDrawGdiplusOrder(PDD_PDEV ppdev, RECTL *prcl, ULONG cjIn, PVOID pvIn)
{
    BOOL rc = FALSE;
    unsigned int sizeLeft;
    unsigned int CopyDataSize, MoveDataSize;
    PTSEmfPlusRecord pEmfRecord;
    unsigned int NewRecordSize = 0;
    unsigned int CacheID;
    BYTE *pData;
    BOOL bReturn;
    BYTE *pGdipOrderBuffer = NULL;
    unsigned int GdipOrderBufferOffset, GdipOrderBufferLeft;
    unsigned int GdipOrderSize, NewEmfSize;

    DC_BEGIN_FN("OECreateDrawGdiplusOrder");

    sizeLeft = (int)cjIn;
    pData = (BYTE*) pvIn;

    // Allocate the draw order buffer
    pGdipOrderBuffer = EngAllocMem(FL_ZERO_MEMORY, TS_GDIPLUS_ORDER_SIZELIMIT, DD_ALLOC_TAG);
    if (NULL == pGdipOrderBuffer) {
        rc = FALSE;
        DC_QUIT;
    }
    GdipOrderBufferOffset = 0;
    GdipOrderBufferLeft = TS_GDIPLUS_ORDER_SIZELIMIT;
    GdipOrderSize = 0;
    NewEmfSize = 0;
    
    while (sizeLeft >= sizeof(TSEmfPlusRecord)) {
        bReturn = FALSE;
        CacheID = CH_KEY_UNCACHABLE;
        pEmfRecord = (PTSEmfPlusRecord)pData;
        if ((pEmfRecord->Size > sizeLeft) ||
            (pEmfRecord->Size == 0)) {
            TRC_ERR((TB, "GDI+ EMF record size %d is not correct", pEmfRecord->Size));
            rc = FALSE;
            DC_QUIT;
        }
        if (pddShm->sbc.drawGdiplusInfo.GdipCacheLevel > TS_DRAW_GDIPLUS_CACHE_LEVEL_DEFAULT) {
            // Cache this record
            bReturn = OECacheDrawGdiplus(ppdev, pEmfRecord, &CacheID);
        }
        if (bReturn && (CacheID != CH_KEY_UNCACHABLE)) {
            //This record is cached
            MoveDataSize = pEmfRecord->Size;   // This is used data size in pData
            CopyDataSize =  sizeof(TSEmfPlusRecord) + sizeof(TSUINT16);

            // If the order buffer can't hold more data, send this order first
            if (CopyDataSize > GdipOrderBufferLeft) {
                OESendDrawGdiplusOrder(ppdev, prcl, GdipOrderSize, pGdipOrderBuffer, NewEmfSize);
                GdipOrderBufferOffset = 0;
                GdipOrderBufferLeft =  TS_GDIPLUS_ORDER_SIZELIMIT;
                GdipOrderSize = 0;
                NewEmfSize = 0;
            }

            // Copy the data to the order buffer
            memcpy(pGdipOrderBuffer + GdipOrderBufferOffset, pData, CopyDataSize);
            pEmfRecord = (PTSEmfPlusRecord)(pGdipOrderBuffer + GdipOrderBufferOffset);
            GdipOrderBufferOffset += CopyDataSize;
            GdipOrderBufferLeft -= CopyDataSize;
            GdipOrderSize += CopyDataSize;
            NewEmfSize += MoveDataSize;

            pEmfRecord->Size = CopyDataSize;
            // set the cache flag
            pEmfRecord->Size |= 0x80000000;
            // CacheID follows
            *(TSUINT16 *)(pEmfRecord +1) = (TSUINT16)CacheID;           
        }
        else {
            // Not cachable, just copy the data
            MoveDataSize = pEmfRecord->Size;  // This is used data size in pData

            // If the order buffer can't hold more data, send this order first
            if ((MoveDataSize > GdipOrderBufferLeft) && (GdipOrderSize != 0)) {
                OESendDrawGdiplusOrder(ppdev, prcl, GdipOrderSize, pGdipOrderBuffer, NewEmfSize);
                GdipOrderBufferOffset = 0;
                GdipOrderBufferLeft =  TS_GDIPLUS_ORDER_SIZELIMIT;
                GdipOrderSize = 0;
                NewEmfSize = 0;
            }

            if (MoveDataSize > GdipOrderBufferLeft) {
                // This single EMF record is larger than the order sizelimit, send it
                OESendDrawGdiplusOrder(ppdev, prcl, MoveDataSize, pData, MoveDataSize);
            }
            else {
                // Copy the data to the order buffer
                memcpy(pGdipOrderBuffer + GdipOrderBufferOffset, pData, MoveDataSize);
                GdipOrderBufferOffset += MoveDataSize;
                GdipOrderBufferLeft -= MoveDataSize;
                GdipOrderSize += MoveDataSize;
                NewEmfSize += MoveDataSize;
            }
        }
        sizeLeft -= (int)MoveDataSize;
        pData += MoveDataSize;
    }
    // Temporarily remove this assert since GDI+ might send incorrect EMF record size
    //TRC_ASSERT((sizeLeft == 0), (TB, "Gdiplus EMF+ record has invalid data size"));

    // Send the remaining in the order buffer
    if (GdipOrderSize != 0) {
        OESendDrawGdiplusOrder(ppdev, prcl, GdipOrderSize, pGdipOrderBuffer, NewEmfSize);
    }

    rc = TRUE;
    DC_END_FN();

DC_EXIT_POINT:
    if (pGdipOrderBuffer) {
        EngFreeMem(pGdipOrderBuffer);
    }

    return rc;
}


/****************************************************************************/
// OECacheDrawGdiplus
//
// Cache the Gdiplus EMF+ record
/****************************************************************************/
BOOL RDPCALL OECacheDrawGdiplus(PDD_PDEV ppdev, PVOID pvIn, unsigned int *CacheID)
{
    BOOL rc = FALSE;
    CHDataKeyContext CHContext;
    PTSEmfPlusRecord pEmfRecord = (PTSEmfPlusRecord)pvIn;
    CHCACHEHANDLE CacheHandle;
    TSUINT16 CacheType;
    void *UserDefined;
    BYTE *CacheBuffer;
    unsigned CacheBufferSize;
    unsigned Temp, RemoveCacheID;
    TSUINT16 RemoveCacheNum = 0, *RemoveCacheIDList = NULL;
    TSUINT16 CacheSize;      // used for image cache, in number of chunks
    unsigned MaxCacheSize;   // used for other caches, in bytes 

    DC_BEGIN_FN("OECacheDrawGdiplus");
    
    TRC_NRM((TB, "EmfPlusRecord type is %d", pEmfRecord->Type));
    if (pEmfRecord->Type == EmfPlusRecordTypeSetTSGraphics) {
        CacheHandle = sbcGdipGraphicsCacheHandle;
        CacheType = GDIP_CACHE_GRAPHICS_DATA;
        MaxCacheSize = sbcGdipGraphicsCacheChunkSize;
    }
    else if (pEmfRecord->Type == EmfPlusRecordTypeObject) {
        switch ((enum ObjectType)(pEmfRecord->Flags >> 8) ) {
        case ObjectTypeBrush:
            CacheHandle = sbcGdipObjectBrushCacheHandle;
            CacheType = GDIP_CACHE_OBJECT_BRUSH;
            MaxCacheSize = sbcGdipObjectBrushCacheChunkSize;
            break;
        case ObjectTypePen:
            CacheHandle = sbcGdipObjectPenCacheHandle;
            CacheType = GDIP_CACHE_OBJECT_PEN;
            MaxCacheSize = sbcGdipObjectPenCacheChunkSize;
            break;
        case ObjectTypeImage:
            CacheHandle = sbcGdipObjectImageCacheHandle;
            CacheType = GDIP_CACHE_OBJECT_IMAGE;
            break;
        case ObjectTypeImageAttributes:
            CacheHandle = sbcGdipObjectImageAttributesCacheHandle;
            CacheType = GDIP_CACHE_OBJECT_IMAGEATTRIBUTES;
            MaxCacheSize = sbcGdipObjectImageAttributesCacheChunkSize;
            break;
        default:
            *CacheID = CH_KEY_UNCACHABLE;
            goto NO_CACHE;
        }
    }
    else {
        *CacheID = CH_KEY_UNCACHABLE;
        goto NO_CACHE;
    }
    // Data size needs to be multiple of DWORD to calculate cache key
    Temp =  (pEmfRecord->Size - sizeof(TSEmfPlusRecord)) % sizeof(UINT32);
    if (Temp != 0) {
        // Not multiple of DWORD, need to craete a new buffer to hold the data
        CacheBufferSize = (((pEmfRecord->Size - sizeof(TSEmfPlusRecord)) / sizeof(UINT32) + 1) * sizeof(UINT32));
        CacheBuffer = (BYTE *)EngAllocMem(FL_ZERO_MEMORY, CacheBufferSize, DD_ALLOC_TAG);
        if (CacheBuffer == NULL) {
            *CacheID = CH_KEY_UNCACHABLE;
            goto NO_CACHE;
        }
        memcpy(CacheBuffer, (BYTE *)(pEmfRecord + 1), (pEmfRecord->Size - sizeof(TSEmfPlusRecord)));
        CH_CreateKeyFromFirstData(&CHContext, CacheBuffer, CacheBufferSize);
        EngFreeMem(CacheBuffer);
    }
    else {
        CH_CreateKeyFromFirstData(&CHContext, (pEmfRecord + 1), (pEmfRecord->Size - sizeof(TSEmfPlusRecord)));
    }
    
    if (!CH_SearchCache(CacheHandle, CHContext.Key1, CHContext.Key2, &UserDefined, CacheID)) {
        // This record is not cached, need to create a new one
        if (CacheType == GDIP_CACHE_OBJECT_IMAGE) {
            // Convert the size in bytes to the number of cache chunks
            CacheSize = (TSUINT16)ActualSizeToChunkSize(pEmfRecord->Size, sbcGdipObjectImageCacheChunkSize);
            if (CacheSize > sbcGdipObjectImageCacheMaxSize) {
                TRC_NRM((TB, ("Image Cache Size %d too big, will not cache it"), CacheSize));
                *CacheID = CH_KEY_UNCACHABLE;
                goto NO_CACHE;
            }
            // The total cache cap is sbcGdipObjectImageCacheTotalSize
            // if sbcGdipObjectImageCacheSizeUsed plus the new cache size exceeds the cap
            // we remove the cache entry in LRU list until cache cap won't be exceeded
            RemoveCacheID = CH_GetLRUCacheEntry(CacheHandle);
            //TRC_ERR((TB, ("Shoud discard cache type: %d, ID: %d"), CacheType, CH_GetLRUCacheEntry(CacheHandle)));
            *CacheID = CH_CacheKey(CacheHandle, CHContext.Key1, CHContext.Key2, NULL);

            if ((RemoveCacheID == *CacheID) &&
                (RemoveCacheID != CH_KEY_UNCACHABLE)) { 
                // New cache entry will replace an old one, need to update sbcGdipObjectImageCacheSizeUsed
                sbcGdipObjectImageCacheSizeUsed -= sbcGdipObjectImageCacheSizeList[RemoveCacheID];
            }
            TRC_NRM((TB, ("Size used is %d, will add %d"), sbcGdipObjectImageCacheSizeUsed, CacheSize));
            if ((sbcGdipObjectImageCacheSizeUsed + CacheSize) > sbcGdipObjectImageCacheTotalSize) {
                RemoveCacheNum = 0;
                RemoveCacheIDList = EngAllocMem(FL_ZERO_MEMORY, 
                                    sizeof(TSUINT16) * pddShm->sbc.drawGdiplusInfo.GdipCacheEntries.GdipObjectImageCacheEntries, DD_ALLOC_TAG);
                if (RemoveCacheIDList == NULL) {
                    TRC_ERR((TB, "Can't allocate the memory for RemoveCacheIDList"));
                    goto NO_CACHE;
                }
                while ((sbcGdipObjectImageCacheSizeUsed + CacheSize) > sbcGdipObjectImageCacheTotalSize) {
                    RemoveCacheID = CH_GetLRUCacheEntry(CacheHandle);
                    sbcGdipObjectImageCacheSizeUsed -= sbcGdipObjectImageCacheSizeList[RemoveCacheID];
                    TRC_NRM((TB, ("Remove cacheId %d, minus size %d, Used size is %d"), RemoveCacheID,
                               sbcGdipObjectImageCacheSizeList[RemoveCacheID], sbcGdipObjectImageCacheSizeUsed));
                    CH_RemoveCacheEntry(CacheHandle, RemoveCacheID);
                    // Add the RemoveCacheID to the list, will send it with the cache order
                    RemoveCacheIDList[RemoveCacheNum] = (TSUINT16)RemoveCacheID;
                    RemoveCacheNum++;
                    sbcGdipObjectImageCacheSizeList[RemoveCacheID] = 0;
                }
            }
        }
        else {
            if (pEmfRecord->Size > MaxCacheSize) {
                TRC_NRM((TB, ("Cache Size %d with type %d too big, will not cache it"), pEmfRecord->Size, CacheType));
                *CacheID = CH_KEY_UNCACHABLE;
                goto NO_CACHE;
            }
            *CacheID = CH_CacheKey(CacheHandle, CHContext.Key1, CHContext.Key2, NULL);
        }
        
        if (CacheType == GDIP_CACHE_OBJECT_IMAGE) 
            TRC_NRM((TB, ("new cache: type %d, ID: %d, size: %d"), CacheType, *CacheID, CacheSize));
        if (*CacheID != CH_KEY_UNCACHABLE) {
            if (!OESendDrawGdiplusCacheOrder(ppdev, pEmfRecord, CacheID, CacheType, RemoveCacheNum, RemoveCacheIDList))
            {
                TRC_ERR((TB, ("OESendDrawGdiplusCacheOrder failed to send cache order")));
                DC_QUIT;
            }
            if (CacheType == GDIP_CACHE_OBJECT_IMAGE) {
                // Update the used image cache size
                sbcGdipObjectImageCacheSizeList[*CacheID] = CacheSize;
                sbcGdipObjectImageCacheSizeUsed += CacheSize;
                TRC_NRM((TB, ("add size %d, new used size is %d"), CacheSize, sbcGdipObjectImageCacheSizeUsed));
            }
        }
        else {
            TRC_ERR((TB, "Failed to cache the Gdiplus object"));
            goto NO_CACHE;
        }
    }
    else {
        TRC_NRM((TB, ("Already cached: type %d, ID: %d"), CacheType, *CacheID));        
    }

NO_CACHE:
    rc = TRUE;
DC_EXIT_POINT:
    if (rc != TRUE && *CacheID != CH_KEY_UNCACHABLE) 
        CH_RemoveCacheEntry(CacheHandle, *CacheID);
    if (NULL != RemoveCacheIDList) {
        EngFreeMem(RemoveCacheIDList);
    }
    DC_END_FN();
    return rc;
}


/****************************************************************************/
// OESendDrawGdiplusCacheOrder
//
// Send the Gdiplus EMF+ record cache order
/****************************************************************************/
BOOL RDPCALL OESendDrawGdiplusCacheOrder(PDD_PDEV ppdev, PVOID pvIn, unsigned int *CacheID, TSUINT16 CacheType,
                                         TSUINT16 RemoveCacheNum, TSUINT16 * RemoveCacheIDList)
{
    BOOL rc = FALSE;
    PINT_ORDER pIntOrder;
    PTSEmfPlusRecord pEmfRecord = (PTSEmfPlusRecord)pvIn;
    PTS_DRAW_GDIPLUS_CACHE_ORDER_FIRST pDrawGdiplusCachePDUFirst;
    PTS_DRAW_GDIPLUS_CACHE_ORDER_NEXT pDrawGdiplusCachePDUNext;
    PTS_DRAW_GDIPLUS_CACHE_ORDER_END pDrawGdiplusCachePDUEnd;
    unsigned sizeLeft, sizeOrder, sizeTotal, sizeUsed;
    BOOL bFirst = TRUE;
    BOOL bAddRemoveCacheList = FALSE;
    BYTE *pDataOffset;
    TSUINT16 *pImageCacheData, i;

    DC_BEGIN_FN("OESendDrawGdiplusCacheOrder");

    sizeTotal = pEmfRecord->Size - sizeof(TSEmfPlusRecord);
    sizeLeft = sizeTotal;
    pDataOffset = (BYTE *)(pEmfRecord +1);
    while (sizeLeft > 0) {
        sizeUsed = (sizeLeft <= TS_GDIPLUS_ORDER_SIZELIMIT) ? sizeLeft : TS_GDIPLUS_ORDER_SIZELIMIT;
        sizeLeft -= sizeUsed;

        if (bFirst && (RemoveCacheNum != 0) &&
            (CacheType == GDIP_CACHE_OBJECT_IMAGE)) {
            // Need to add the RemoveCacheList to this order
            sizeOrder = sizeUsed + sizeof(TSUINT16) * (RemoveCacheNum + 1);
            bAddRemoveCacheList = TRUE;
        }
        else {
            sizeOrder = sizeUsed;
        }

        if (bFirst) {
            pIntOrder = OA_AllocOrderMem(ppdev, sizeof(TS_DRAW_GDIPLUS_CACHE_ORDER_FIRST) + sizeOrder);
            if (pIntOrder != NULL) {
                // First block of the order data
                pDrawGdiplusCachePDUFirst = (PTS_DRAW_GDIPLUS_CACHE_ORDER_FIRST)pIntOrder->OrderData;
                pDrawGdiplusCachePDUFirst->ControlFlags = (TS_ALTSEC_GDIP_CACHE_FIRST <<
                        TS_ALTSEC_ORDER_TYPE_SHIFT) | TS_SECONDARY;
                bFirst = FALSE;
                if (bAddRemoveCacheList) {
                    // Need to add the RemoveCacheList to this order              
                    pImageCacheData = (TSUINT16 *)(pDrawGdiplusCachePDUFirst + 1);
                    *pImageCacheData = RemoveCacheNum;
                    pImageCacheData ++;
                    for (i=0; i<RemoveCacheNum; i++) {
                        TRC_NRM((TB, "Remove Cache ID: %d", *(RemoveCacheIDList + i)));
                        *pImageCacheData = *(RemoveCacheIDList + i);
                        pImageCacheData++;
                    }
                }
                pDrawGdiplusCachePDUFirst->Flags = 0;
                pDrawGdiplusCachePDUFirst->CacheID = (TSUINT16)*CacheID;
                pDrawGdiplusCachePDUFirst->CacheType = CacheType;
                pDrawGdiplusCachePDUFirst->cbTotalSize = sizeTotal;
                pDrawGdiplusCachePDUFirst->cbSize = (TSUINT16)sizeOrder;

                if (!bAddRemoveCacheList) {
                    memcpy(pDrawGdiplusCachePDUFirst + 1, pDataOffset, sizeUsed);
                }
                else {
                    // Set the flag to indicate there's RemoveCacheIDList in this order
                    pDrawGdiplusCachePDUFirst->Flags |= TS_GDIPLUS_CACHE_ORDER_REMOVE_CACHEENTRY;
                    memcpy((BYTE *)pImageCacheData, pDataOffset, sizeUsed);
                    bAddRemoveCacheList = FALSE;
                }
            }
            else {
                TRC_ERR((TB, "Failed to allocated order for drawgdiplus cache"));
                DC_QUIT;
            }
        }
        else {
            if (sizeLeft == 0) {
                // Last block of the order data
                pIntOrder = OA_AllocOrderMem(ppdev, sizeof(TS_DRAW_GDIPLUS_CACHE_ORDER_END) + sizeOrder);
                if (pIntOrder != NULL) {
                    pDrawGdiplusCachePDUEnd = (PTS_DRAW_GDIPLUS_CACHE_ORDER_END)pIntOrder->OrderData;                
                    pDrawGdiplusCachePDUEnd->ControlFlags = (TS_ALTSEC_GDIP_CACHE_END <<
                        TS_ALTSEC_ORDER_TYPE_SHIFT) | TS_SECONDARY;
                    pDrawGdiplusCachePDUEnd->Flags = 0;
                    pDrawGdiplusCachePDUEnd->CacheID = (TSUINT16)*CacheID;
                    pDrawGdiplusCachePDUEnd->CacheType = CacheType;
                    pDrawGdiplusCachePDUEnd->cbSize = (TSUINT16)sizeOrder;
                    pDrawGdiplusCachePDUEnd->cbTotalSize = sizeTotal;
                    memcpy(pDrawGdiplusCachePDUEnd + 1, pDataOffset, sizeUsed);
                }
                else {
                    TRC_ERR((TB, "Failed to allocated order for drawgdiplus cache"));
                    DC_QUIT;
                }
            }
            else {
                // subsequent block of the order data    
                pIntOrder = OA_AllocOrderMem(ppdev, sizeof(TS_DRAW_GDIPLUS_CACHE_ORDER_NEXT) + sizeOrder);
                if (pIntOrder != NULL) {
                    pDrawGdiplusCachePDUNext = (PTS_DRAW_GDIPLUS_CACHE_ORDER_NEXT)pIntOrder->OrderData;                
                    pDrawGdiplusCachePDUNext->ControlFlags = (TS_ALTSEC_GDIP_CACHE_NEXT <<
                    TS_ALTSEC_ORDER_TYPE_SHIFT) | TS_SECONDARY;
                    pDrawGdiplusCachePDUNext->Flags = 0;
                    pDrawGdiplusCachePDUNext->CacheID = (TSUINT16)*CacheID;
                    pDrawGdiplusCachePDUNext->CacheType = CacheType;
                    pDrawGdiplusCachePDUNext->cbSize = (TSUINT16)sizeOrder;
                    memcpy(pDrawGdiplusCachePDUNext + 1, pDataOffset, sizeUsed);
                }
                else {
                    TRC_ERR((TB, "Failed to allocated order for drawgdiplus cache"));
                    DC_QUIT;
                }
            }
        }
        pDataOffset += sizeUsed;

        OA_AppendToOrderList(pIntOrder); 
    }
    rc = TRUE;
DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}


/****************************************************************************/
// OESendDrawGdiplusOrder
//
// Send the Gdiplus EMF+ record order
/****************************************************************************/
BOOL RDPCALL OESendDrawGdiplusOrder(PDD_PDEV ppdev, RECTL *prcl, ULONG cjIn, PVOID pvIn, ULONG TotalEmfSize)
{
    BOOL rc = FALSE;
    PINT_ORDER pIntOrder;
    PTS_DRAW_GDIPLUS_ORDER_FIRST pDrawGdiplusPDUFirst;
    PTS_DRAW_GDIPLUS_ORDER_NEXT pDrawGdiplusPDUNext;
    PTS_DRAW_GDIPLUS_ORDER_END pDrawGdiplusPDUEnd;
    unsigned sizeLeft, sizeOrder, sizeTotal;
    BOOL bFirst = TRUE;
    BYTE *pDataOffset;

    DC_BEGIN_FN("OESendDrawGdiplusOrder");

    sizeTotal = cjIn;
    sizeLeft = sizeTotal;         
    pDataOffset = pvIn;
    while (sizeLeft > 0) {
        sizeOrder = (sizeLeft <= TS_GDIPLUS_ORDER_SIZELIMIT) ? sizeLeft : TS_GDIPLUS_ORDER_SIZELIMIT;    
        sizeLeft -= sizeOrder;                                                                       

        if (bFirst) {
            // First block of the order data
            pIntOrder = OA_AllocOrderMem(ppdev, sizeof(TS_DRAW_GDIPLUS_ORDER_FIRST) + sizeOrder);
            if (pIntOrder != NULL) {
                pDrawGdiplusPDUFirst = (PTS_DRAW_GDIPLUS_ORDER_FIRST)pIntOrder->OrderData;
                pDrawGdiplusPDUFirst->ControlFlags = (TS_ALTSEC_GDIP_FIRST <<
                    TS_ALTSEC_ORDER_TYPE_SHIFT) | TS_SECONDARY;
                pDrawGdiplusPDUFirst->cbTotalSize = sizeTotal;
                pDrawGdiplusPDUFirst->cbSize = (TSUINT16)sizeOrder;
                pDrawGdiplusPDUFirst->cbTotalEmfSize = TotalEmfSize;

                memcpy(pDrawGdiplusPDUFirst + 1, pDataOffset, sizeOrder);
                bFirst = FALSE;
            }
            else {
                TRC_ERR((TB, "Failed to allocated order for drawgdiplus"));
                DC_QUIT;
            }
        }
        else {
            if (sizeLeft == 0) {
                // Last block of the order data     
                pIntOrder = OA_AllocOrderMem(ppdev, sizeof(TS_DRAW_GDIPLUS_ORDER_END) + sizeOrder);
                if (pIntOrder != NULL) {
                    pDrawGdiplusPDUEnd = (PTS_DRAW_GDIPLUS_ORDER_END)pIntOrder->OrderData;
                    pDrawGdiplusPDUEnd->ControlFlags = (TS_ALTSEC_GDIP_END <<
                        TS_ALTSEC_ORDER_TYPE_SHIFT) | TS_SECONDARY;
                    pDrawGdiplusPDUEnd->cbTotalSize = sizeTotal;
                    pDrawGdiplusPDUEnd->cbSize = (TSUINT16)sizeOrder;
                    pDrawGdiplusPDUEnd->cbTotalEmfSize = TotalEmfSize;

                    memcpy(pDrawGdiplusPDUEnd + 1, pDataOffset, sizeOrder);
                }
                else {
                    TRC_ERR((TB, "Failed to allocated order for drawgdiplus"));
                    DC_QUIT;
                }
            }
            else {
                // subsequent block of the order data                   
                pIntOrder = OA_AllocOrderMem(ppdev, sizeof(TS_DRAW_GDIPLUS_ORDER_NEXT) + sizeOrder);
                if (pIntOrder != NULL) {
                    pDrawGdiplusPDUNext = (PTS_DRAW_GDIPLUS_ORDER_NEXT)pIntOrder->OrderData;
                    pDrawGdiplusPDUNext->ControlFlags = (TS_ALTSEC_GDIP_NEXT <<
                        TS_ALTSEC_ORDER_TYPE_SHIFT) | TS_SECONDARY;
                    pDrawGdiplusPDUNext->cbSize = (TSUINT16)sizeOrder;

                    memcpy(pDrawGdiplusPDUNext + 1, pDataOffset, sizeOrder);
                }
                else {
                    TRC_ERR((TB, "Failed to allocated order for drawgdiplus"));
                    DC_QUIT;
                }
            }
        }
        OA_AppendToOrderList(pIntOrder);
        pDataOffset += sizeOrder;
    }

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}
#endif // DRAW_GDIPLUS

/****************************************************************************/
// OEEncodeDstBlt
//
// Performs all encoding steps required to encode a DstBlt order, then adds
// to order list. Returns FALSE if the order needs to be added to the screen
// data area.
/****************************************************************************/
BOOL RDPCALL OEEncodeDstBlt(
        RECTL *pBounds,
        BYTE Rop3,
        PDD_PDEV ppdev,
        OE_ENUMRECTS *pClipRects)
{
    BOOL rc;
    unsigned OrderSize;
    BYTE OrderType;
    PINT_ORDER pOrder;
    MULTI_DSTBLT_ORDER *pPrevDB;

    DC_BEGIN_FN("OEEncodeDstBlt");

    // Check whether we should use the multi-cliprect version. Must be a
    // complex clip region and the client must support the order.
    if (pClipRects->rects.c < 2 ||
            !OE_SendAsOrder(TS_ENC_MULTIDSTBLT_ORDER)) {
        // Non-multi version.
        OrderType = TS_ENC_DSTBLT_ORDER;
        OrderSize = MAX_DSTBLT_FIELD_SIZE;
        pPrevDB = (MULTI_DSTBLT_ORDER *)&PrevDstBlt;
    }
    else {
        // Multi version.
        OrderType = TS_ENC_MULTIDSTBLT_ORDER;
        OrderSize = MAX_MULTI_DSTBLT_FIELD_SIZE_NCLIP(pClipRects->rects.c);
        pPrevDB = &PrevMultiDstBlt;
    }

    if (OE_SendAsOrder(OrderType)) {
        // Alloc the order memory.
        // 1 field flag byte for both regular and Multi.
        pOrder = OA_AllocOrderMem(ppdev, MAX_ORDER_SIZE(pClipRects->rects.c,
                1, OrderSize));
        if (pOrder != NULL) {
            BYTE *pControlFlags = pOrder->OrderData;
            BYTE *pBuffer = pControlFlags + 1;
            BYTE *pFieldFlags;

            // Direct-encode the primary order fields. 1 field flag byte.
            *pControlFlags = TS_STANDARD;
            OE2_EncodeOrderType(pControlFlags, &pBuffer, OrderType);
            pFieldFlags = pBuffer;
            *pFieldFlags = 0;
            pBuffer++;

            // Only set boundrect for non-multi order.
            if (pClipRects->rects.c != 0 && OrderType == TS_ENC_DSTBLT_ORDER)
                OE2_EncodeBounds(pControlFlags, &pBuffer,
                        &pClipRects->rects.arcl[0]);

            // Simultaneously determine if each of the coordinate fields has
            // changed, whether we can use delta coordinates, and save changed
            // fields.
            *pFieldFlags |= (BYTE)OEDirectEncodeRect(pBounds,
                    (RECT *)&pPrevDB->nLeftRect, &pBuffer,
                    pControlFlags);

            // bRop
            if (Rop3 != pPrevDB->bRop) {
                pPrevDB->bRop = Rop3;
                *pBuffer++ = Rop3;
                *pFieldFlags |= 0x10;
            }

            // Add the order to the list.
            if (OrderType == TS_ENC_DSTBLT_ORDER) {
                pOrder->OrderLength = (unsigned)(pBuffer - pOrder->OrderData);

                // See if we can save sending the order field bytes.
                pOrder->OrderLength -= OE2_CheckOneZeroFlagByte(pControlFlags,
                        pFieldFlags, (unsigned)(pBuffer - pFieldFlags - 1));

                INC_OUTCOUNTER(OUT_DSTBLT_ORDER);
                ADD_INCOUNTER(IN_DSTBLT_BYTES, pOrder->OrderLength);
                OA_AppendToOrderList(pOrder);

                // Flush the order.
                if (pClipRects->rects.c < 2)
                    rc = TRUE;
                else
                    rc = OEEmitReplayOrders(ppdev, 1, pClipRects);
            }
            else {
                // Append the cliprect info.
                *pFieldFlags |= (BYTE)(OEBuildPrecodeMultiClipFields(
                        pClipRects, &pBuffer, &pPrevDB->nDeltaEntries,
                        (BYTE *)&pPrevDB->codedDeltaList) << 5);

                pOrder->OrderLength = (unsigned)(pBuffer - pOrder->OrderData);

                // See if we can save sending the order field bytes.
                pOrder->OrderLength -= OE2_CheckOneZeroFlagByte(pControlFlags,
                        pFieldFlags, (unsigned)(pBuffer - pFieldFlags - 1));

                INC_OUTCOUNTER(OUT_MULTI_DSTBLT_ORDER);
                ADD_INCOUNTER(IN_MULTI_DSTBLT_BYTES, pOrder->OrderLength);
                OA_AppendToOrderList(pOrder);
                rc = TRUE;
            }

            TRC_NRM((TB, "%sDstBlt X %d Y %d w %d h %d rop %02X",
                    (OrderType == TS_ENC_DSTBLT_ORDER ? "" : "Multi"),
                    pBounds->left, pBounds->top, pBounds->right,
                    pBounds->bottom, Rop3));
        }
        else {
            TRC_ERR((TB, "Failed to alloc order"));
            INC_OUTCOUNTER(OUT_BITBLT_SDA_HEAPALLOCFAILED);
            rc = FALSE;
        }
    }
    else {
        TRC_NRM((TB,"(Multi)DstBlt order not supported"));
        INC_OUTCOUNTER(OUT_BITBLT_SDA_UNSUPPORTED);
        rc = FALSE;
    }

    DC_END_FN();
    return rc;
}


/****************************************************************************/
// OEEncodeOpaqueRect
//
// Encodes the OpaqueRect order. Returns FALSE on failure.
/****************************************************************************/
BOOL RDPCALL OEEncodeOpaqueRect(
        RECTL *pBounds,
        BRUSHOBJ *pbo,
        PDD_PDEV ppdev,
        OE_ENUMRECTS *pClipRects)
{
    BOOL rc;
    unsigned OrderSize = 0;
    unsigned NumFieldFlagBytes = 0;
    BYTE OrderType = 0;
    PINT_ORDER pOrder;
    MULTI_OPAQUERECT_ORDER *pPrevOR = NULL;

    DC_BEGIN_FN("OEEncodeOpaqueRect");

    // Check whether we should use the multi-cliprect version. Must be a
    // complex clip region and the client must support the order.
    if (pClipRects->rects.c < 2 ||
            !OE_SendAsOrder(TS_ENC_MULTIOPAQUERECT_ORDER)) {
        // The single version is implied by PatBlt, so we check for that
        // order support instead.
        if (OE_SendAsOrder(TS_ENC_PATBLT_ORDER)) {
            // Non-multi version.
            OrderType = TS_ENC_OPAQUERECT_ORDER;
            OrderSize = MAX_OPAQUERECT_FIELD_SIZE;
            pPrevOR = (MULTI_OPAQUERECT_ORDER *)&PrevOpaqueRect;
            NumFieldFlagBytes = 1;
        }
        else {
            TRC_NRM((TB,"OpaqueRect/PatBlt order not supported"));
            INC_OUTCOUNTER(OUT_BITBLT_SDA_UNSUPPORTED);
            rc = FALSE;
            DC_QUIT;
        }
    }
    else {
        // Multi version.
        OrderType = TS_ENC_MULTIOPAQUERECT_ORDER;
        OrderSize = MAX_MULTI_OPAQUERECT_FIELD_SIZE_NCLIP(pClipRects->rects.c);
        pPrevOR = &PrevMultiOpaqueRect;
        NumFieldFlagBytes = 2;
    }

    pOrder = OA_AllocOrderMem(ppdev, MAX_ORDER_SIZE(pClipRects->rects.c,
            NumFieldFlagBytes, OrderSize));
    if (pOrder != NULL) {
        BYTE *pControlFlags = pOrder->OrderData;
        BYTE *pBuffer = pControlFlags + 1;
        PUINT32_UA pFieldFlags;
        DCCOLOR Color;

        // Direct-encode the primary order fields.
        *pControlFlags = TS_STANDARD;
        OE2_EncodeOrderType(pControlFlags, &pBuffer, OrderType);
        pFieldFlags = (PUINT32_UA)pBuffer;
        *pFieldFlags = 0;
        pBuffer += NumFieldFlagBytes;

        // Only set boundrect for non-multi order.
        if (pClipRects->rects.c != 0 && OrderType == TS_ENC_OPAQUERECT_ORDER)
            OE2_EncodeBounds(pControlFlags, &pBuffer,
                    &pClipRects->rects.arcl[0]);

        *pFieldFlags |= OEDirectEncodeRect(pBounds,
                (RECT *)&pPrevOR->nLeftRect, &pBuffer, pControlFlags);

        // Copy non-coordinate fields, saving copies as needed.

        OEConvertColor(ppdev, &Color, pbo->iSolidColor, NULL);
        if (Color.u.rgb.red != pPrevOR->Color.u.rgb.red) {
            pPrevOR->Color.u.rgb.red = Color.u.rgb.red;
            *pBuffer++ = Color.u.rgb.red;
            *pFieldFlags |= 0x10;
        }
        if (Color.u.rgb.green != pPrevOR->Color.u.rgb.green) {
            pPrevOR->Color.u.rgb.green = Color.u.rgb.green;
            *pBuffer++ = Color.u.rgb.green;
            *pFieldFlags |= 0x20;
        }
        if (Color.u.rgb.blue != pPrevOR->Color.u.rgb.blue) {
            pPrevOR->Color.u.rgb.blue = Color.u.rgb.blue;
            *pBuffer++ = Color.u.rgb.blue;
            *pFieldFlags |= 0x40;
        }

        // Different handling based on the type.
        if (OrderType == TS_ENC_OPAQUERECT_ORDER) {
            pOrder->OrderLength = (unsigned)(pBuffer - pOrder->OrderData);

            // See if we can save sending the order field bytes.
            pOrder->OrderLength -= OE2_CheckOneZeroFlagByte(pControlFlags,
                    (BYTE *)pFieldFlags,
                    (unsigned)(pBuffer - (BYTE *)pFieldFlags - 1));

            // Flush the order.
            INC_OUTCOUNTER(OUT_OPAQUERECT_ORDER);
            ADD_INCOUNTER(IN_OPAQUERECT_BYTES, pOrder->OrderLength);
            OA_AppendToOrderList(pOrder);
            if (pClipRects->rects.c < 2)
                rc = TRUE;
            else
                rc = OEEmitReplayOrders(ppdev, 1, pClipRects);
        }
        else {
            // Append the cliprect info.
            *pFieldFlags |= (OEBuildPrecodeMultiClipFields(pClipRects,
                    &pBuffer, &pPrevOR->nDeltaEntries,
                    (BYTE *)&pPrevOR->codedDeltaList) << 7);

            pOrder->OrderLength = (unsigned)(pBuffer - pOrder->OrderData);

            // See if we can save sending the order field bytes.
            pOrder->OrderLength -= OE2_CheckTwoZeroFlagBytes(pControlFlags,
                    (BYTE *)pFieldFlags,
                    (unsigned)(pBuffer - (BYTE *)pFieldFlags - 2));

            // Flush the order.
            INC_OUTCOUNTER(OUT_MULTI_OPAQUERECT_ORDER);
            ADD_INCOUNTER(IN_MULTI_OPAQUERECT_BYTES, pOrder->OrderLength);
            OA_AppendToOrderList(pOrder);
            rc = TRUE;
        }

        TRC_NRM((TB, "%sOpaqueRect x(%d) y(%d) w(%d) h(%d) c(%#02x)",
                (OrderType == TS_ENC_OPAQUERECT_ORDER ? "" : "Multi"),
                pBounds->left, pBounds->top,
                pBounds->right - pBounds->left,
                pBounds->bottom - pBounds->top,
                Color.u.index));
    }
    else {
        TRC_ERR((TB, "Failed to alloc order"));
        INC_OUTCOUNTER(OUT_BITBLT_SDA_HEAPALLOCFAILED);
        rc = FALSE;
    }

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}


/****************************************************************************/
// OEDirectEncodeRect
//
// Common code for handling the various XxxBlt and MultiXxxBlt direct
// encoding to wire format. Encodes the left, top, width, and height
// of the exclusive bound rect. Assumes that the bound rect values are
// encoded as 2-byte coords on the wire and that they are the only coords
// in the target order. Returns the field encoding flags.
/****************************************************************************/
unsigned OEDirectEncodeRect(
        RECTL *pBounds,
        RECT *pPrevBounds,
        BYTE **ppBuf,
        BYTE *pControlFlags)
{
    BYTE *pBuf = *ppBuf;
    long Temp;
    BOOL bUseDeltaCoords;
    short Delta, NormalCoordEncoding[4];
    unsigned NumFields;
    unsigned FieldFlags;

    DC_BEGIN_FN("OEDirectEncodeRect");

    memset(NormalCoordEncoding, 0, sizeof(NormalCoordEncoding));
    // Simultaneously determine if each of the coordinate fields
    // has changed, whether we can use delta coordinates, and
    // save changed fields. Note bounds are in exclusive coords.
    FieldFlags = 0;
    NumFields = 0;
    bUseDeltaCoords = TRUE;

    // Left
    Delta = (short)(pBounds->left - pPrevBounds->left);
    if (Delta) {
        pPrevBounds->left = pBounds->left;
        if (Delta != (short)(char)Delta)
            bUseDeltaCoords = FALSE;
        pBuf[NumFields] = (char)Delta;
        NormalCoordEncoding[NumFields] = (short)pBounds->left;
        NumFields++;
        FieldFlags |= 0x01;
    }

    // Top
    Delta = (short)(pBounds->top - pPrevBounds->top);
    if (Delta) {
        pPrevBounds->top = pBounds->top;
        if (Delta != (short)(char)Delta)
            bUseDeltaCoords = FALSE;
        pBuf[NumFields] = (char)Delta;
        NormalCoordEncoding[NumFields] = (short)pBounds->top;
        NumFields++;
        FieldFlags |= 0x02;
    }

    // Width -- we use pPrevBounds->right as prev value.
    Temp = pBounds->right - pBounds->left;
    Delta = (short)(Temp - pPrevBounds->right);
    if (Delta) {
        pPrevBounds->right = Temp;
        if (Delta != (short)(char)Delta)
            bUseDeltaCoords = FALSE;
        pBuf[NumFields] = (char)Delta;
        NormalCoordEncoding[NumFields] = (short)Temp;
        NumFields++;
        FieldFlags |= 0x04;
    }

    // Height -- we use pPrevBounds->bottom as prev value.
    Temp = pBounds->bottom - pBounds->top;
    Delta = (short)(Temp - pPrevBounds->bottom);
    if (Delta) {
        pPrevBounds->bottom = Temp;
        if (Delta != (short)(char)Delta)
            bUseDeltaCoords = FALSE;
        pBuf[NumFields] = (char)Delta;
        NormalCoordEncoding[NumFields] = (short)Temp;
        NumFields++;
        FieldFlags |= 0x08;
    }

    // Copy the final coordinates to the order.
    if (bUseDeltaCoords) {
        *pControlFlags |= TS_DELTA_COORDINATES;
        pBuf += NumFields;
    }
    else {
        *((DWORD UNALIGNED *)pBuf) = *((DWORD *)NormalCoordEncoding);
        *((DWORD UNALIGNED *)(pBuf + 4)) = *((DWORD *)&NormalCoordEncoding[2]);
        pBuf += NumFields * sizeof(short);
    }

    *ppBuf = pBuf;

    DC_END_FN();
    return FieldFlags;
}


/****************************************************************************/
// OEEncodePatBlt
//
// Encodes a PatBlt order. Retruns FALSE on failure.
/****************************************************************************/
BOOL RDPCALL OEEncodePatBlt(
        PDD_PDEV ppdev,
        BRUSHOBJ *pbo,
        RECTL    *pBounds,
        POINTL   *pptlBrush,
        BYTE     Rop3,
        OE_ENUMRECTS *pClipRects)
{
    BOOL rc;
    unsigned OrderSize;
    BYTE OrderType;
    PINT_ORDER pOrder;
    MULTI_PATBLT_ORDER *pPrevPB;
    POE_BRUSH_DATA pCurrentBrush;

    DC_BEGIN_FN("OEEncodePatBlt");

    // Check for a simple brush pattern.
    if (OECheckBrushIsSimple(ppdev, pbo, &pCurrentBrush)) {
        // Check whether we should use the multi-cliprect version. Must be a
        // complex clip region and the client must support the order.
        if (pClipRects->rects.c < 2 ||
                !OE_SendAsOrder(TS_ENC_MULTIPATBLT_ORDER)) {
            // Non-multi version.
            OrderType = TS_ENC_PATBLT_ORDER;
            OrderSize = MAX_PATBLT_FIELD_SIZE;
            pPrevPB = (MULTI_PATBLT_ORDER *)&PrevPatBlt;
        }
        else {
            // Multi version.
            OrderType = TS_ENC_MULTIPATBLT_ORDER;
            OrderSize = MAX_MULTI_PATBLT_FIELD_SIZE_NCLIP(pClipRects->rects.c);
            pPrevPB = &PrevMultiPatBlt;
        }

        // Make sure we don't have orders turned off.
        if (OE_SendAsOrder(OrderType)) {
            // 2 field flag bytes for regular and multi.
            pOrder = OA_AllocOrderMem(ppdev, MAX_ORDER_SIZE(
                    pClipRects->rects.c, 2, OrderSize));
            if (pOrder != NULL) {
                BYTE *pControlFlags = pOrder->OrderData;
                BYTE *pBuffer = pControlFlags + 1;
                PUINT32_UA pFieldFlags;
                DCCOLOR Color;
                POINTL ClippedBrushOrg;

                // Direct-encode the primary order fields.
                *pControlFlags = TS_STANDARD;
                OE2_EncodeOrderType(pControlFlags, &pBuffer, OrderType);
                pFieldFlags = (PUINT32_UA)pBuffer;
                *pFieldFlags = 0;
                pBuffer += 2;

                // Only set boundrect for non-multi order.
                if (pClipRects->rects.c != 0 &&
                        OrderType == TS_ENC_PATBLT_ORDER)
                    OE2_EncodeBounds(pControlFlags, &pBuffer,
                            &pClipRects->rects.arcl[0]);

                // Inline field encoding to wire format.
                *pFieldFlags |= OEDirectEncodeRect(pBounds,
                        (RECT *)&pPrevPB->nLeftRect, &pBuffer, pControlFlags);

                // bRop
                if (Rop3 != pPrevPB->bRop) {
                    pPrevPB->bRop = Rop3;
                    *pBuffer++ = (BYTE)Rop3;
                    *pFieldFlags |= 0x0010;
                }

                // BackColor is a 3-byte color field.
                if (memcmp(&pCurrentBrush->back, &pPrevPB->BackColor,
                        sizeof(pCurrentBrush->back))) {
                    pPrevPB->BackColor = pCurrentBrush->back;
                    *pBuffer++ = pCurrentBrush->back.u.rgb.red;
                    *pBuffer++ = pCurrentBrush->back.u.rgb.green;
                    *pBuffer++ = pCurrentBrush->back.u.rgb.blue;
                    *pFieldFlags |= 0x0020;
                }

                // ForeColor is a 3-byte color field.
                if (memcmp(&pCurrentBrush->fore, &pPrevPB->ForeColor,
                        sizeof(pCurrentBrush->fore))) {
                    pPrevPB->ForeColor = pCurrentBrush->fore;
                    *pBuffer++ = pCurrentBrush->fore.u.rgb.red;
                    *pBuffer++ = pCurrentBrush->fore.u.rgb.green;
                    *pBuffer++ = pCurrentBrush->fore.u.rgb.blue;
                    *pFieldFlags |= 0x0040;
                }

                // The protocol brush origin is the point on the screen where
                // we want the brush to start being drawn from (tiling where
                // necessary).
                ClippedBrushOrg = *pptlBrush;
                OEClipPoint(&ClippedBrushOrg);

                // BrushOrgX
                if (ClippedBrushOrg.x != pPrevPB->BrushOrgX) {
                    pPrevPB->BrushOrgX = ClippedBrushOrg.x;
                    *pBuffer++ = (BYTE)ClippedBrushOrg.x;
                    *pFieldFlags |= 0x0080;
                }

                // BrushOrgY
                if (ClippedBrushOrg.y != pPrevPB->BrushOrgY) {
                    pPrevPB->BrushOrgY = ClippedBrushOrg.y;
                    *pBuffer++ = (BYTE)ClippedBrushOrg.y;
                    *pFieldFlags |= 0x0100;
                }

                // BrushStyle
                if (pCurrentBrush->style != pPrevPB->BrushStyle) {
                    pPrevPB->BrushStyle = pCurrentBrush->style;
                    *pBuffer++ = (BYTE)pCurrentBrush->style;
                    *pFieldFlags |= 0x0200;
                }

                // BrushHatch
                if (pCurrentBrush->hatch != pPrevPB->BrushHatch) {
                    pPrevPB->BrushHatch = pCurrentBrush->hatch;
                    *pBuffer++ = (BYTE)pCurrentBrush->hatch;
                    *pFieldFlags |= 0x0400;
                }

                // BrushExtra, a 7-byte field.
                if (memcmp(pCurrentBrush->brushData, pPrevPB->BrushExtra, 7)) {
                    memcpy(pPrevPB->BrushExtra, pCurrentBrush->brushData, 7);
                    memcpy(pBuffer, pCurrentBrush->brushData, 7);
                    pBuffer += 7;
                    *pFieldFlags |= 0x0800;
                }

                // Different handling based on the order type.
                if (OrderType == TS_ENC_PATBLT_ORDER) {
                    pOrder->OrderLength = (unsigned)(pBuffer -
                            pOrder->OrderData);

                    // See if we can save sending the order field bytes.
                    pOrder->OrderLength -= OE2_CheckTwoZeroFlagBytes(
                            pControlFlags, (BYTE *)pFieldFlags,
                            (unsigned)(pBuffer - (BYTE *)pFieldFlags - 2));

                    INC_OUTCOUNTER(OUT_PATBLT_ORDER);
                    ADD_INCOUNTER(IN_PATBLT_BYTES, pOrder->OrderLength);
                    OA_AppendToOrderList(pOrder);

                    // Flush the order.
                    if (pClipRects->rects.c < 2)
                        rc = TRUE;
                    else
                        rc = OEEmitReplayOrders(ppdev, 2, pClipRects);
                }
                else {
                    // Append the cliprect info.
                    *pFieldFlags |= (OEBuildPrecodeMultiClipFields(pClipRects,
                            &pBuffer, &pPrevPB->nDeltaEntries,
                            (BYTE *)&pPrevPB->codedDeltaList) << 12);

                    pOrder->OrderLength = (unsigned)(pBuffer -
                            pOrder->OrderData);

                    // See if we can save sending the order field bytes.
                    pOrder->OrderLength -= OE2_CheckTwoZeroFlagBytes(
                            pControlFlags, (BYTE *)pFieldFlags,
                            (unsigned)(pBuffer - (BYTE *)pFieldFlags - 2));

                    INC_OUTCOUNTER(OUT_MULTI_PATBLT_ORDER);
                    ADD_INCOUNTER(IN_MULTI_PATBLT_BYTES, pOrder->OrderLength);
                    OA_AppendToOrderList(pOrder);
                    rc = TRUE;
                }

                TRC_NRM((TB, "%sPatBlt BC %02x FC %02x "
                        "Brush %02X %02X X %d Y %d w %d h %d rop %02X",
                        (OrderType == TS_ENC_PATBLT_ORDER ? "" : "Multi"),
                        pCurrentBrush->back.u.index,
                        pCurrentBrush->fore.u.index,
                        pCurrentBrush->style,
                        pCurrentBrush->hatch,
                        pBounds->left,
                        pBounds->top,
                        pBounds->right - pBounds->left,
                        pBounds->bottom = pBounds->top,
                        Rop3));
            }
            else {
                TRC_ERR((TB, "Failed to alloc order"));
                INC_OUTCOUNTER(OUT_BITBLT_SDA_HEAPALLOCFAILED);
                rc = FALSE;
            }
        }
        else {
            TRC_NRM((TB,"(Multi)PatBlt order not supported"));
            INC_OUTCOUNTER(OUT_BITBLT_SDA_UNSUPPORTED);
            rc = FALSE;
        }
    }
    else {
        TRC_NRM((TB, "Brush is not simple"));
        rc = FALSE;
    }

    DC_END_FN();
    return rc;
}


/****************************************************************************/
// OEDirectEncodeMemBlt
//
// Handles all steps required to encode MemBlt. Assumes the order data
// has been placed in oeTempMemBlt.
/****************************************************************************/
BOOL OEDirectEncodeMemBlt(PDD_PDEV ppdev, OE_ENUMRECTS *pClipRects)
{
    BOOL rc;
    BYTE DeltaEncoding2[2];
    short Delta, NormalEncoding1[4], NormalEncoding2[2];
    BOOLEAN bUseDeltaCoords;
    unsigned NumFields1, NumFields2;
    PINT_ORDER pOrder;

    DC_BEGIN_FN("OEDirectEncodeMemBlt");

    TRC_NRM((TB,"MemBlt: Dst=(%d,%d),w=%d,h=%d, Src=(%d,%d), "
            "clip=%s (%d,%d,%d,%d)",
            oeTempMemBlt.Common.nLeftRect,
            oeTempMemBlt.Common.nTopRect,
            oeTempMemBlt.Common.nWidth,
            oeTempMemBlt.Common.nHeight,
            oeTempMemBlt.Common.nXSrc,
            oeTempMemBlt.Common.nYSrc,
            pClipRects->rects.c == 0 ? "n/a" : "present",
            pClipRects->rects.arcl[0].left,
            pClipRects->rects.arcl[0].top,
            pClipRects->rects.arcl[0].right,
            pClipRects->rects.arcl[0].bottom));

    // 2 field flag bytes.
    pOrder = OA_AllocOrderMem(ppdev, MAX_ORDER_SIZE(pClipRects->rects.c, 2,
            MAX_MEMBLT_FIELD_SIZE));
    if (pOrder != NULL) {
        BYTE *pControlFlags = pOrder->OrderData;
        BYTE *pBuffer = pControlFlags + 1;
        PUINT32_UA pFieldFlags;

        // Direct-encode the primary order fields. 2 field flag bytes.
        *pControlFlags = TS_STANDARD;
        OE2_EncodeOrderType(pControlFlags, &pBuffer, TS_ENC_MEMBLT_R2_ORDER);
        pFieldFlags = (PUINT32_UA)pBuffer;
        *pFieldFlags = 0;
        pBuffer += 2;
        if (pClipRects->rects.c != 0)
            OE2_EncodeBounds(pControlFlags, &pBuffer,
                    &pClipRects->rects.arcl[0]);

        if (oeTempMemBlt.Common.cacheId != PrevMemBlt.Common.cacheId) {
            PrevMemBlt.Common.cacheId = oeTempMemBlt.Common.cacheId;
            *((UNALIGNED unsigned short *)pBuffer) =
                    oeTempMemBlt.Common.cacheId;
            pBuffer += sizeof(unsigned short);
            *pFieldFlags |= 0x0001;
        }

        // Simultaneously determine if each of the coordinate fields has changed,
        // whether we can use delta coordinates, and save changed fields.
        NumFields1 = NumFields2 = 0;
        bUseDeltaCoords = TRUE;

        Delta = (short)(oeTempMemBlt.Common.nLeftRect -
                PrevMemBlt.Common.nLeftRect);
        if (Delta) {
            PrevMemBlt.Common.nLeftRect = oeTempMemBlt.Common.nLeftRect;
            if (Delta != (short)(char)Delta)
                bUseDeltaCoords = FALSE;
            pBuffer[NumFields1] = (char)Delta;
            NormalEncoding1[NumFields1] = (short)oeTempMemBlt.Common.nLeftRect;
            NumFields1++;
            *pFieldFlags |= 0x0002;
        }

        Delta = (short)(oeTempMemBlt.Common.nTopRect -
                PrevMemBlt.Common.nTopRect);
        if (Delta) {
            PrevMemBlt.Common.nTopRect = oeTempMemBlt.Common.nTopRect;
            if (Delta != (short)(char)Delta)
                bUseDeltaCoords = FALSE;
            pBuffer[NumFields1] = (char)Delta;
            NormalEncoding1[NumFields1] = (short)oeTempMemBlt.Common.nTopRect;
            NumFields1++;
            *pFieldFlags |= 0x0004;
        }

        Delta = (short)(oeTempMemBlt.Common.nWidth - PrevMemBlt.Common.nWidth);
        if (Delta) {
            PrevMemBlt.Common.nWidth = oeTempMemBlt.Common.nWidth;
            if (Delta != (short)(char)Delta)
                bUseDeltaCoords = FALSE;
            pBuffer[NumFields1] = (char)Delta;
            NormalEncoding1[NumFields1] = (short)oeTempMemBlt.Common.nWidth;
            NumFields1++;
            *pFieldFlags |= 0x0008;
        }

        Delta = (short)(oeTempMemBlt.Common.nHeight -
                PrevMemBlt.Common.nHeight);
        if (Delta) {
            PrevMemBlt.Common.nHeight = oeTempMemBlt.Common.nHeight;
            if (Delta != (short)(char)Delta)
                bUseDeltaCoords = FALSE;
            pBuffer[NumFields1] = (char)Delta;
            NormalEncoding1[NumFields1] = (short)oeTempMemBlt.Common.nHeight;
            NumFields1++;
            *pFieldFlags |= 0x0010;
        }

        Delta = (short)(oeTempMemBlt.Common.nXSrc - PrevMemBlt.Common.nXSrc);
        if (Delta) {
            PrevMemBlt.Common.nXSrc = oeTempMemBlt.Common.nXSrc;
            if (Delta != (short)(char)Delta)
                bUseDeltaCoords = FALSE;
            DeltaEncoding2[NumFields2] = (char)Delta;
            NormalEncoding2[NumFields2] = (short)oeTempMemBlt.Common.nXSrc;
            NumFields2++;
            *pFieldFlags |= 0x0040;
        }

        Delta = (short)(oeTempMemBlt.Common.nYSrc - PrevMemBlt.Common.nYSrc);
        if (Delta) {
            PrevMemBlt.Common.nYSrc = oeTempMemBlt.Common.nYSrc;
            if (Delta != (short)(char)Delta)
                bUseDeltaCoords = FALSE;
            DeltaEncoding2[NumFields2] = (char)Delta;
            NormalEncoding2[NumFields2] = (short)oeTempMemBlt.Common.nYSrc;
            NumFields2++;
            *pFieldFlags |= 0x0080;
        }

        // Begin copying the final coordinates to the order.
        if (bUseDeltaCoords) {
            *pControlFlags |= TS_DELTA_COORDINATES;
            pBuffer += NumFields1;
        }
        else {
            memcpy(pBuffer, NormalEncoding1, NumFields1 * sizeof(short));
            pBuffer += NumFields1 * sizeof(short);
        }

        // Copy the intervening bRop field.
        if (oeTempMemBlt.Common.bRop != PrevMemBlt.Common.bRop) {
            PrevMemBlt.Common.bRop = oeTempMemBlt.Common.bRop;
            *pBuffer++ = (BYTE)oeTempMemBlt.Common.bRop;
            *pFieldFlags |= 0x0020;
        }

        // Copy the src coords.
        if (bUseDeltaCoords) {
            memcpy(pBuffer, DeltaEncoding2, NumFields2);
            pBuffer += NumFields2;
        }
        else {
            memcpy(pBuffer, NormalEncoding2, NumFields2 * sizeof(short));
            pBuffer += NumFields2 * sizeof(short);
        }

        // Finish with the cache index.
        if (oeTempMemBlt.Common.cacheIndex != PrevMemBlt.Common.cacheIndex) {
            PrevMemBlt.Common.cacheIndex = oeTempMemBlt.Common.cacheIndex;
            *((UNALIGNED unsigned short *)pBuffer) =
                    oeTempMemBlt.Common.cacheIndex;
            pBuffer += sizeof(unsigned short);
            *pFieldFlags |= 0x0100;
        }

        pOrder->OrderLength = (unsigned)(pBuffer - pOrder->OrderData);

        // See if we can save sending the order field bytes.
        pOrder->OrderLength -= OE2_CheckTwoZeroFlagBytes(pControlFlags,
                (BYTE *)pFieldFlags,
                (unsigned)(pBuffer - (BYTE *)pFieldFlags - 2));

        INC_OUTCOUNTER(OUT_MEMBLT_ORDER);
        ADD_INCOUNTER(IN_MEMBLT_BYTES, pOrder->OrderLength);
        OA_AppendToOrderList(pOrder);

        // Flush the order.
        if (pClipRects->rects.c < 2)
            rc = TRUE;
        else
            rc = OEEmitReplayOrders(ppdev, 2, pClipRects);
    }
    else {
        TRC_ERR((TB,"Failed alloc MemBlt order on heap"));
        INC_OUTCOUNTER(OUT_BITBLT_SDA_HEAPALLOCFAILED);
        rc = FALSE;
    }

    DC_END_FN();
    return rc;
}


/****************************************************************************/
// OEAllocAndSendMem3BltOrder
//
// Performs steps needed to launch a Mem3Blt order. Assumes the order data
// has been placed in oeTempMemBlt.
/****************************************************************************/
BOOL OEAllocAndSendMem3BltOrder(PDD_PDEV ppdev, OE_ENUMRECTS *pClipRects)
{
    BOOL rc;
    PINT_ORDER pOrder;

    DC_BEGIN_FN("OEAllocAndSendMem3BltOrder");

    TRC_NRM((TB,"Mem3Blt: Dst=(%d,%d),w=%d,h=%d, Src=(%d,%d), "
            "clip=%s (%d,%d,%d,%d)",
            oeTempMemBlt.Common.nLeftRect,
            oeTempMemBlt.Common.nTopRect,
            oeTempMemBlt.Common.nWidth,
            oeTempMemBlt.Common.nHeight,
            oeTempMemBlt.Common.nXSrc,
            oeTempMemBlt.Common.nYSrc,
            pClipRects->rects.c == 0 ? "n/a" : "present",
            pClipRects->rects.arcl[0].left,
            pClipRects->rects.arcl[0].top,
            pClipRects->rects.arcl[0].right,
            pClipRects->rects.arcl[0].bottom));

    // 3 field flag bytes.
    pOrder = OA_AllocOrderMem(ppdev, MAX_ORDER_SIZE(pClipRects->rects.c,
            3, MAX_MEM3BLT_FIELD_SIZE));
    if (pOrder != NULL) {
        // Slow-field-encode the order with the first clip rect
        // (if present).
        pOrder->OrderLength = OE2_EncodeOrder(pOrder->OrderData,
                TS_ENC_MEM3BLT_R2_ORDER, NUM_MEM3BLT_FIELDS,
                (BYTE *)&oeTempMemBlt, (BYTE *)&PrevMem3Blt, etable_3C,
                (pClipRects->rects.c == 0 ? NULL :
                &pClipRects->rects.arcl[0]));

        INC_OUTCOUNTER(OUT_MEM3BLT_ORDER);
        ADD_INCOUNTER(IN_MEM3BLT_BYTES, pOrder->OrderLength);
        OA_AppendToOrderList(pOrder);

        // Flush the order.
        if (pClipRects->rects.c < 2)
            rc = TRUE;
        else
            rc = OEEmitReplayOrders(ppdev, 3, pClipRects);
    }
    else {
        TRC_ERR((TB,"Failed alloc Mem3Blt order on heap"));
        INC_OUTCOUNTER(OUT_BITBLT_SDA_HEAPALLOCFAILED);
        rc = FALSE;
    }

    DC_END_FN();
    return rc;
}


/****************************************************************************/
// OETileBitBltOrder
//
// Divides a single large BitBlt order into a series of small, "tiled"
// BitBlt orders, each of which is added to the order queue. Returns FALSE
// on failure (alloc failure on offscr target).
/****************************************************************************/
BOOL OETileBitBltOrder(
        PDD_PDEV ppdev,
        PPOINTL pptlSrc,
        RECTL *pBounds,
        unsigned OrderType,
        unsigned ColorTableIndex,
        PMEMBLT_ORDER_EXTRA_INFO pExInfo,
        OE_ENUMRECTS *pClipRects)
{
    int srcRight, srcBottom;
    int xTile, yTile;
    unsigned xFirstTile, yFirstTile;
    unsigned Width, Height;
    BOOL rc = TRUE;
    RECTL SrcRect, DestRect;
    OE_ENUMRECTS TileClipRects;
    POINTL SrcPt;
    SIZEL SrcSize;
#ifdef PERF_SPOILING
    BOOL bDiscardTile;
#endif

    DC_BEGIN_FN("OETileBitBltOrder");

    Width = pBounds->right - pBounds->left;
    Height = pBounds->bottom - pBounds->top;
    SrcSize = pExInfo->pSource->sizlBitmap;

    // Find out what the tile size and ID will be.
    pExInfo->TileID = SBC_DDQueryBitmapTileSize(SrcSize.cx, SrcSize.cy,
            pptlSrc, Width, Height);
    pExInfo->TileSize = (unsigned)(SBC_CACHE_0_DIMENSION << pExInfo->TileID);

    // Tile the order. If an individual tile fails to go as an order,
    // it's up to OEAddTiledBitBltOrder to add the tile's destination as
    // screen data.
    SrcPt = *pptlSrc;
    TRC_NRM((TB, "Tiling order"));
    TRC_DBG((TB, "l=%u, t=%u, w=%u, h=%u, tile=%u",
            SrcPt.x, SrcPt.y, Width, Height, pExInfo->TileSize));
    xFirstTile = SrcPt.x - (SrcPt.x & (pExInfo->TileSize - 1));
    yFirstTile = SrcPt.y - (SrcPt.y & (pExInfo->TileSize - 1));
    TRC_DBG((TB, "xStart=%hd, yStart=%hd", xFirstTile, yFirstTile));

    // Note we are creating exclusive bounds now.
    srcRight  = (int)(SrcPt.x + Width);
    srcBottom = (int)(SrcPt.y + Height);

    // Enumerate all tiles, left-to-right, top-to-bottom, and send
    // Cache Bitmap and Mem(3)Blt orders for each tile.
    for (yTile = yFirstTile; (yTile < srcBottom && yTile < SrcSize.cy);
            yTile += pExInfo->TileSize) {
        for (xTile = xFirstTile; (xTile < srcRight && xTile < SrcSize.cx);
                xTile += pExInfo->TileSize) {
            // SrcRect and DestRect are exclusive rects.
            SrcRect.left = SrcPt.x;
            SrcRect.top = SrcPt.y;
            SrcRect.right = SrcRect.left + Width;
            SrcRect.bottom = SrcRect.top + Height;
            DestRect.left = pBounds->left;
            DestRect.top = pBounds->top;

            // Intersect source and tile rects, and set up destination rect
            // accordingly.
            TRC_DBG((TB, "pre: xTile(%d) yTile(%d) src.left(%d) src.top(%d)",
                    xTile, yTile, SrcRect.left, SrcRect.top));

            // Modify srcRect to contain the tile's left and top if they are
            // within the full blt rect. Also move the destRect left and top
            // out the same amount to match.
            if (xTile > SrcRect.left) {
                DestRect.left += (xTile - SrcRect.left);
                SrcRect.left = xTile;
            }
            if (yTile > SrcRect.top) {
                DestRect.top += (yTile - SrcRect.top);
                SrcRect.top = yTile;
            }

            TRC_DBG((TB, "post: xTile(%d) yTile(%d) src.left(%d) src.top(%d)",
                    xTile, yTile, SrcRect.left, SrcRect.top));

            // Find the right and bottom of the tile, making sure not to
            // overrun the actual blt boundaries and the screen boundaries,
            // and remaining in exclusive coords.
            SrcRect.right  = min((unsigned)SrcRect.right, (unsigned)xTile +
                    pExInfo->TileSize);
            SrcRect.bottom = min((unsigned)SrcRect.bottom, (unsigned)yTile +
                    pExInfo->TileSize);
            DestRect.right  = DestRect.left + (SrcRect.right - SrcRect.left);
            DestRect.bottom = DestRect.top + (SrcRect.bottom - SrcRect.top);

            // Now that we have the exclusive dest rect, find out if the
            // overall DrvBitBlt() clip rects intersect with the tile. If not,
            // no need to either cache the tile or send the order.

            TileClipRects.rects.c = 0;

#ifndef PERF_SPOILING
            if (pClipRects->rects.c == 0 ||
                OEGetIntersectionsWithClipRects(&DestRect, pClipRects,
                                                &TileClipRects)) {
#else
            // Normally, we send the tile to the client to be rendered and
            // added to the bitmap cache.  However, there are two cases where
            // this can be avoided:
            // 1) The tile doesn't intersect with the current clipping-region.
            //    In this case, the bitmap won't paint anyway.
            // 2) The tile lies completely within our SDA bounds, meaning that
            //    it is already being sent as SDA.  In this case, sending it
            //    as a cached-item would just be sending it twice over the wire!
            if (pClipRects->rects.c == 0) {
                bDiscardTile = pExInfo->bIsPrimarySurface && 
                                 OEIsSDAIncluded(&DestRect,1);
            } else {
                if (OEGetIntersectionsWithClipRects(&DestRect, 
                                                    pClipRects,
                                                    &TileClipRects)) {

                    bDiscardTile = pExInfo->bIsPrimarySurface && 
                          OEIsSDAIncluded(&(TileClipRects.rects.arcl[0]), TileClipRects.rects.c);
                } else {
                    bDiscardTile = TRUE;
                }
            }
            
            if (!bDiscardTile) {
#endif //PERF_SPOILING
                // First step is to make sure the source data tile is in the
                // bitmap cache. If we fail this, we simply add the
                // intersected clip rects to the SDA.
                if (SBC_CacheBitmapTile(ppdev, pExInfo, &SrcRect, &DestRect)) {
                    // nXSrc and nYSrc are the source within the tile.
                    // Since we've cached tiles sitting at TileSize
                    // boundaries, we simply use the offset into the tile by
                    // taking the modulo.
                    oeTempMemBlt.Common.nXSrc = SrcRect.left &
                            (pExInfo->TileSize - 1);
                    oeTempMemBlt.Common.nYSrc = SrcRect.top &
                            (pExInfo->TileSize - 1);
                    oeTempMemBlt.Common.nLeftRect = DestRect.left;
                    oeTempMemBlt.Common.nTopRect = DestRect.top;
                    oeTempMemBlt.Common.nWidth = SrcRect.right - SrcRect.left;
                    oeTempMemBlt.Common.nHeight = SrcRect.bottom - SrcRect.top;
                    oeTempMemBlt.Common.cacheId = (UINT16)
                            ((ColorTableIndex << 8) | pExInfo->CacheID);
                    oeTempMemBlt.Common.cacheIndex =
                            (UINT16)pExInfo->CacheIndex;

                    if (OrderType == TS_ENC_MEMBLT_R2_ORDER)
                        rc = OEDirectEncodeMemBlt(ppdev, &TileClipRects);
                    else
                        rc = OEAllocAndSendMem3BltOrder(ppdev, &TileClipRects);

                    if (!rc) {
                        if (oeLastDstSurface == NULL) {
                            // If this is a screen target, send screen data and
                            // continue trying to create tiles. Reset the
                            // return value to TRUE to indicate the tile
                            // was handled.
                            OEClipAndAddScreenDataAreaByIntersectRects(
                                    &DestRect, &TileClipRects);
                            rc = TRUE;
                        }
                        else {
                            // On failure for offscreen rendering, we forget
                            // the rest of the tiles and return FALSE.
                            DC_QUIT;
                        }
                    }                    
                }
                else {
                    TRC_ERR((TB, "Failed cache bitmap order"));
                    INC_OUTCOUNTER(OUT_BITBLT_SDA_HEAPALLOCFAILED);

                    // If this is a screen target, send screen data, but still
                    // return TRUE to indicate we handled the tile. If an
                    // offscreen target, return FALSE to force the target
                    // surface to become uncacheable.
                    if (oeLastDstSurface == NULL) {
                        OEClipAndAddScreenDataAreaByIntersectRects(&DestRect,
                                &TileClipRects);
                    }
                    else {
                        // On failure for offscreen rendering, we forget
                        // the rest of the tiles and return FALSE.
                        rc = FALSE;
                        DC_QUIT;
                    }
                }
            }
            else {
                // We still succeed here -- the tile was handled OK.
                TRC_NRM((TB,"Dropping tile - no intersections w/clip rects"));
            }
        }
    }

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}


/****************************************************************************/
// OEEncodeMemBlt
//
// Performs all encoding steps required to encode a Mem(3)Blt order, then adds
// to order list. Returns FALSE if the order needs to be added to the screen
// data area.
/****************************************************************************/
BOOL RDPCALL OEEncodeMemBlt(
        RECTL *pBounds,
        MEMBLT_ORDER_EXTRA_INFO *pMemBltExtraInfo,
        unsigned OrderType,
        unsigned SrcSurfaceId,
        BYTE Rop3,
        POINTL *pptlSrc,
        POINTL *pptlBrush,
        BRUSHOBJ *pbo,
        PDD_PDEV ppdev,
        OE_ENUMRECTS *pClipRects)
{
    BOOL rc;
    unsigned ColorTableIndex;
    PINT_ORDER pOrder;
    MEMBLT_COMMON *pCommon;
    MEM3BLT_R2_ORDER *pMem3Blt;

    DC_BEGIN_FN("OEEncodeMemBlt");

    // Make sure we can cache the blt -- caching must be enabled too.
    if (SrcSurfaceId == CH_KEY_UNCACHABLE) {
        rc = SBC_DDIsMemScreenBltCachable(pMemBltExtraInfo);
    }
    else {
        // The surface bitmap bits already cached at the client.
        // There is no need to send the bits
        rc = (sbcEnabled & SBC_BITMAP_CACHE_ENABLED);
    }

    if (rc) {
        // We have to cache the color table first.
        if (SBC_SendCacheColorTableOrder(ppdev, &ColorTableIndex)) {
            TRC_ASSERT((ColorTableIndex < SBC_NUM_COLOR_TABLE_CACHE_ENTRIES),
                    (TB, "Invalid ColorTableIndex(%u)", ColorTableIndex));

            // Set up only the ROP common MemBlt field here; the rest need
            // to wait until we have tile information (if retrived).
            oeTempMemBlt.Common.bRop = Rop3;

            if (OrderType == TS_ENC_MEMBLT_R2_ORDER) {
                TRC_NRM((TB, "MemBlt dx %d dy %d w %d h %d sx %d sy %d "
                        "rop %04X", pBounds->left, pBounds->top,
                        pBounds->right - pBounds->left,
                        pBounds->bottom - pBounds->top,
                        pptlSrc->x, pptlSrc->y, Rop3));
            }
            else {
                POE_BRUSH_DATA pCurrentBrush;

                // For Mem3Blt, create the extra brush-related fields
                // in oeTempMemBlt so it will be set up properly
                // when we encode the order later.

                // Check that the brush pattern is simple.
                if (OECheckBrushIsSimple(ppdev, pbo, &pCurrentBrush)) {
                    // The protocol brush origin is the point on the screen
                    // where we want the brush to start being drawn from
                    // (tiling where necessary).
                    oeTempMemBlt.BrushOrgX = pptlBrush->x;
                    oeTempMemBlt.BrushOrgY = pptlBrush->y;
                    OEClipPoint((PPOINTL)&oeTempMemBlt.BrushOrgX);

                    // Pattern data.
                    oeTempMemBlt.BackColor = pCurrentBrush->back;
                    oeTempMemBlt.ForeColor = pCurrentBrush->fore;

                    // Realized brush data.
                    oeTempMemBlt.BrushStyle = pCurrentBrush->style;
                    oeTempMemBlt.BrushHatch = pCurrentBrush->hatch;
                    memcpy(oeTempMemBlt.BrushExtra, pCurrentBrush->brushData,
                            sizeof(oeTempMemBlt.BrushExtra));

                    TRC_NRM((TB, "Mem3Blt brush %02X %02X dx %d dy %d "
                            "w %d h %d sx %d sy %d rop %04X",
                            oeTempMemBlt.BrushStyle,
                            oeTempMemBlt.BrushHatch,
                            oeTempMemBlt.Common.nLeftRect,
                            oeTempMemBlt.Common.nTopRect,
                            oeTempMemBlt.Common.nWidth,
                            oeTempMemBlt.Common.nHeight,
                            oeTempMemBlt.Common.nXSrc,
                            oeTempMemBlt.Common.nYSrc,
                            oeTempMemBlt.Common.bRop));
                }
                else {
                    TRC_NRM((TB, "Mem3Blt brush is not simple"));
                    INC_OUTCOUNTER(OUT_BITBLT_SDA_M3BCOMPLEXBRUSH);
                    rc = FALSE;
                    DC_QUIT;
                }
            }

            // Send the order to be cached.
            if (SrcSurfaceId == CH_KEY_UNCACHABLE) {
                rc = OETileBitBltOrder(ppdev, pptlSrc, pBounds, OrderType,
                        ColorTableIndex, pMemBltExtraInfo, pClipRects);
            }
            else {
                // Set up the order fields not set up above. We rely on the
                // Common field in MEMBLT_ORDER and MEM3BLT_ORDER orders
                // being in the same position.
                oeTempMemBlt.Common.nLeftRect = pBounds->left;
                oeTempMemBlt.Common.nTopRect = pBounds->top;
                oeTempMemBlt.Common.nWidth = pBounds->right - pBounds->left;
                oeTempMemBlt.Common.nHeight = pBounds->bottom - pBounds->top;

                // Store the source bitmap origin.
                oeTempMemBlt.Common.nXSrc = pptlSrc->x;
                oeTempMemBlt.Common.nYSrc = pptlSrc->y;

                // Store the color table cache index and cache ID.
                // The source bitmap is at client offscreen bitmap, we
                // use 0xff as bitmap ID to indicate that. The cache index
                // is used to indicate the client offscreen bitmap Id.
                oeTempMemBlt.Common.cacheId = (UINT16)((ColorTableIndex << 8) |
                        TS_BITMAPCACHE_SCREEN_ID);
                oeTempMemBlt.Common.cacheIndex = (UINT16)SrcSurfaceId;

                if (OrderType == TS_ENC_MEMBLT_R2_ORDER)
                    rc = OEDirectEncodeMemBlt(ppdev, pClipRects);
                else
                    rc = OEAllocAndSendMem3BltOrder(ppdev, pClipRects);
            }
        }
        else {
            TRC_ALT((TB, "Unable to send color table for MemBlt"));
            INC_OUTCOUNTER(OUT_BITBLT_SDA_NOCOLORTABLE);
            rc = FALSE;
        }
    }
    else {
        TRC_NRM((TB, "MemBlt is not cachable"));
        INC_OUTCOUNTER(OUT_BITBLT_SDA_MBUNCACHEABLE);
    }

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}


/****************************************************************************/
// OEIntersectScrBltWithSDA
//
// Intersects a ScrBlt order (given the source point and exclusive dest rect)
// with the current SDA. Returns FALSE if the entire ScrBlt order should be
// spoiled because its source rect is entirely within the current SDA.
//
// Algorithm notes:
//
// OLD (ORIGINAL) SCRBLT SCHEME
// ----------------------------
// If the source rectangle intersects the current SDA then the src rectangle
// is modified so that no there is no intersection with the SDA, and the dst
// rectangle adjusted accordingly (this is the theory - in practice the
// operation remains the same and we just adjust the dst clip rectangle).
// The destination area that is removed is added into the SDA. The code
// works, but can result in more screen data being sent than is required.
// E.g. for the following operation:
//
//      SSSSSS      DDDDDD      | S = src rect
//      SSSSSS  ->  DDDDDD      | D = dst rect
//      SSSSSS      DDDDDD      | x = SDA overlap
//      SxSSSS      DDDDDD      |
//
// The bottom edge of the blt is trimmed off, and the corresponding
// destination area added into the SDA.
//
//      SSSSSS      DDDDDD
//      SSSSSS  ->  DDDDDD
//      SSSSSS      DDDDDD
//                  xxxxxx
//
// NEW SCRBLT SCHEME
// -----------------
// The new scheme does not modify the blt rectangles, and just maps the SDA
// overlap to the destination rect and adds that area back into the SDA.
// E.g. (as above):
//
//      SSSSSS      DDDDDD
//      SSSSSS  ->  DDDDDD
//      SSSSSS      DDDDDD
//      SxSSSS      DDDDDD
//
// The blt operation remains the same, but the overlap area is mapped to the
// destination rectangle and added into the SDA.
//
//      SSSSSS      DDDDDD
//      SSSSSS  ->  DDDDDD
//      SSSSSS      DDDDDD
//      SxSSSS      DxDDDD
//
// This scheme results in a smaller SDA area. However, this scheme does blt
// potentially invalid data to the destination - which may briefly be visible
// at the remote machine (because orders are replayed before Screen Data).
// This has not (yet) proved to be a problem. The main benefit of the new
// scheme vs. the old is when scrolling an area that includes a small SDA:
//
//                                         new         old
//     AAAAAAAA                          AAAAAAAA    AAAAAAAA
//     AAAAAAAA                          AAAxAAAA    xxxxxxxx
//     AAAAAAAA  scroll up 3 times ->    AAAxAAAA    xxxxxxxx
//     AAAAAAAA                          AAAxAAAA    xxxxxxxx
//     AAAxAAAA                          AAAxAAAA    xxxxxxxx
/****************************************************************************/
BOOL OEIntersectScrBltWithSDA(
        PPOINTL pSrcPt,
        RECTL *pDestRect,
        OE_ENUMRECTS *pClipRects)
{
    BOOL rc = TRUE;
    unsigned NumSDA;
    unsigned totalBounds;
    unsigned i, j;
    unsigned NumClipRects;
    int dx;
    int dy;
    RECTL SrcRect;
    RECTL TempRect;
    RECTL InvalidDestRect;
    RECTL SDARects[BA_MAX_ACCUMULATED_RECTS];

    DC_BEGIN_FN("OEIntersectScrBltWithSDA");

    // Calculate the full source rect (exclusive coords).
    SrcRect.left = pSrcPt->x;
    SrcRect.top = pSrcPt->y;
    SrcRect.right = SrcRect.left + pDestRect->right - pDestRect->left;
    SrcRect.bottom = SrcRect.top + pDestRect->bottom - pDestRect->top;

    // Calculate the offset from the src to the dest.
    dx = pDestRect->left - SrcRect.left;
    dy = pDestRect->top - SrcRect.top;

    NumClipRects = pClipRects->rects.c;

    // Get the current SDA rects.
    BA_QueryBounds(SDARects, &NumSDA);

    for (i = 0; i < NumSDA; i++) {
        if (SrcRect.left < SDARects[i].left ||
                SrcRect.right > SDARects[i].right ||
                SrcRect.top < SDARects[i].top ||
                SrcRect.bottom > SDARects[i].bottom) {
            // Intersect the src rect with the SDA rect and offset to
            // get the invalid dest rect.
            InvalidDestRect.left = max(SrcRect.left, SDARects[i].left) + dx;
            InvalidDestRect.right = min(SrcRect.right, SDARects[i].right) + dx;
            InvalidDestRect.top = max(SrcRect.top, SDARects[i].top) + dy;
            InvalidDestRect.bottom = min(SrcRect.bottom,
                    SDARects[i].bottom) + dy;

            // Walk through each of the dest clip rects (or the entire
            // dest rect if there are no clip rects), intersecting with the
            // invalid dest rect, and adding the intersections into the SDA.
            if (NumClipRects == 0) {
                // DestRect is already in inclusive coords.
                TempRect.left = max(InvalidDestRect.left,
                        pDestRect->left);
                TempRect.top = max(InvalidDestRect.top,
                        pDestRect->top);
                TempRect.right = min(InvalidDestRect.right,
                        pDestRect->right);
                TempRect.bottom = min(InvalidDestRect.bottom,
                        pDestRect->bottom);

                // If there is a 3-way intersection, add the rect to the SDA.
                if (TempRect.left < TempRect.right &&
                        TempRect.top < TempRect.bottom)
                    BA_AddScreenData(&TempRect);
            }
            else {
                // Clip rects are in exclusive coords, we have to take
                // this into account when getting the intersection.
                for (j = 0; j < NumClipRects; j++) {
                    TempRect.left = max(InvalidDestRect.left,
                            pClipRects->rects.arcl[j].left);
                    TempRect.top = max(InvalidDestRect.top,
                            pClipRects->rects.arcl[j].top);
                    TempRect.right = min(InvalidDestRect.right,
                            pClipRects->rects.arcl[j].right);
                    TempRect.bottom = min(InvalidDestRect.bottom,
                            pClipRects->rects.arcl[j].bottom);

                    // If there is a 3-way intersection, add the rect to the
                    // SDA.
                    if (TempRect.left < TempRect.right &&
                            TempRect.top < TempRect.bottom)
                        BA_AddScreenData(&TempRect);
                }
            }
        }
        else {
            // The src of the ScrBlt is completely within the SDA. We
            // must add each of the dest clip rects (or the entire
            // dest rect if there are no clip rects) into the SDA and
            // spoil the ScrBlt.
            TRC_NRM((TB, "ScrBlt src within SDA - spoil it"));

            if (NumClipRects == 0) {
                // We can just add DestRect to SDA.
                InvalidDestRect = *pDestRect;
                BA_AddScreenData(&InvalidDestRect);
            }
            else {
                for (j = 0; j < NumClipRects; j++) {
                    InvalidDestRect = pClipRects->rects.arcl[j];
                    BA_AddScreenData(&InvalidDestRect);
                }
            }

            rc = FALSE;
            DC_QUIT;
        }
    }

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}

/****************************************************************************/
// OEDeviceBitmapCachable
//
// Check if we can cache this device bitmap in the client side offscreen 
// bitmap memory
/****************************************************************************/
BOOL RDPCALL OEDeviceBitmapCachable(PDD_PDEV ppdev,SIZEL sizl, ULONG iFormat)
{
    BOOL rc = FALSE;
    unsigned bitmapSize, minBitmapSize;

    DC_BEGIN_FN("OEDeviceBitmapCachable");

    // Return 0 if client doesn't support offscreen rendering
    if (pddShm != NULL &&  sbcOffscreenBitmapCacheHandle != NULL &&
            pddShm->sbc.offscreenCacheInfo.supportLevel > TS_OFFSCREEN_DEFAULT) {
        
        // We only support device bitmaps that are the same color depth
        // as our display.
        // Actually, those are the only kind GDI will ever call us with,
        // but we may as well check.  Note that this implies you'll never
        // get a crack at 1bpp bitmaps.
        if (iFormat == ppdev->iBitmapFormat) {
            // Get the bitmap size
            // The assumption here is that iFormat is > 1BPP, i << iFormat
            // gives the actual bits per pel.  bitmapSize is in bytes.

            if (iFormat < 5) {
                bitmapSize = sizl.cx * sizl.cy * (1 << iFormat) / 8;
                minBitmapSize = MIN_OFFSCREEN_BITMAP_PIXELS * (1 << iFormat) / 8;
            }
            else if (iFormat == 5) {
                bitmapSize = sizl.cx * sizl.cy * 24 / 8;
                minBitmapSize = MIN_OFFSCREEN_BITMAP_PIXELS * 24 / 8;
        
            }
            else if (iFormat == 6) {
                bitmapSize = sizl.cx * sizl.cy * 32 / 8;
                minBitmapSize = MIN_OFFSCREEN_BITMAP_PIXELS * 32 / 8;
            }
            else {
                minBitmapSize = 0;
                TRC_NRM((TB, "Bitmap format not supported"));
                DC_QUIT;
            }
        
            // From Winbench99 Business Graphics benchmark, we found
            // creating offscreen bitmaps of 2K or smaller does not
            // improve our bandwidth. This parameter needs to be highly
            // tuned. 
            // We also don't want to cache any cursor bitmaps for offscreen
            // the maximum cursor size is 32x32, which is less than the 
            // minBitmapSize.
            if (bitmapSize > minBitmapSize) {
                SURFOBJ *psoDevice;
                SIZEL screenSize;
        
                // Get the bitmap size for the primary device.  
                psoDevice = EngLockSurface(ppdev->hsurfDevice);
                TRC_ERR((TB,"Null device surfac"));
                if (NULL == psoDevice) {
                    TRC_ERR((TB, "Failed to lock ppdev surface"));
                    DC_QUIT;
                }
                screenSize = psoDevice->sizlBitmap;
                EngUnlockSurface(psoDevice);
        
                // We only support bitmap of size less than the primary device
                if ((sizl.cx <= screenSize.cx) && (sizl.cy <= screenSize.cy)) {
                    // If adding this offscreen bitmap exceeds the client total
                    // offscreen bitmap memory, we have to let GDI to manage
                    // this bitmap
                    if (oeCurrentOffscreenCacheSize + bitmapSize <= 
                            (pddShm->sbc.offscreenCacheInfo.cacheSize * 1024)) {
                        rc = TRUE;
                    }
                    else {
                        TRC_NRM((TB, "run out of offscreen memory"));
                        DC_QUIT;
                    }
                } else {
                    TRC_NRM((TB, "offscreen bitmap size too big"));
                    DC_QUIT;
                }
            } else {
                TRC_NRM((TB, "Offscreen bitmap size is 2K or less"));
                DC_QUIT;
            }
        }
        else {
            TRC_NRM((TB, "offscreen bitmap iFormat different from ppdev"));
            DC_QUIT;
        }
    }
    else {
        TRC_NRM((TB, "Offscreen bitmap rendering not supported"));
        DC_QUIT;
    }

DC_EXIT_POINT:
    return rc;
}

/****************************************************************************/
// OETransformClipRectsForScrBlt
//
// Transforms the CD_ANY cliprect ordering to a particular order depending
// on the direction of the scrblt.
/****************************************************************************/
void OETransformClipRectsForScrBlt(
        OE_ENUMRECTS *pClipRects,
        PPOINTL pSrcPt,
        RECTL *pDestRect,
        CLIPOBJ *pco)
{
    unsigned EnumType;
    unsigned RetVal;

    DC_BEGIN_FN("OESendScrBltAsOrder");

    // If there are zero or one clip rectangles then we can send it OK.
    TRC_ASSERT((pClipRects->rects.c > 1),(TB,"Called with too few cliprects"));

    // Check common cases and re-enumerate the rectangles as needed to
    // get an ordering compatible with the direction of scroll.
    if (pDestRect->top <= pSrcPt->y) {
        // Upward/horizontal cases.
        if (pDestRect->left <= pSrcPt->x) {
            // Vertical up (most common case), horizontal to the left,
            // or up and to the left. Enumerate rects left-to-right,
            // top-to-bottom.
            EnumType = CD_RIGHTDOWN;
        }
        else {
            // Up and to the right or horizontal right. Enumerate
            // right-to-left, top-to-bottom.
            EnumType = CD_LEFTDOWN;
        }
    }
    else {
        // Downward cases.
        if (pDestRect->left <= pSrcPt->x) {
            // Vertical down or down and to the left. Enumerate left-to-right,
            // bottom-to-top.
            EnumType = CD_RIGHTUP;
        }
        else {
            // Down and to the right. Enumerate right-to-left, bottom-to-top.
            EnumType = CD_LEFTUP;
        }
    }

    RetVal = OEGetIntersectingClipRects(pco, pDestRect, EnumType, pClipRects);
    TRC_ASSERT((RetVal == CLIPRECTS_OK),
            (TB,"Re-enumeration of clip rects produced err %u", RetVal));

    DC_END_FN();
}


/****************************************************************************/
// OEEncodeScrBlt
//
// Performs all encoding steps required to encode a ScrBlt order, then adds
// to order list. Returns FALSE if the order needs to be added to the screen
// data area.
/****************************************************************************/
BOOL RDPCALL OEEncodeScrBlt(
        RECTL *pBounds,
        BYTE Rop3,
        POINTL *pptlSrc,
        PDD_PDEV ppdev,
        OE_ENUMRECTS *pClipRects,
        CLIPOBJ *pco)
{
    unsigned i;
    unsigned OrderSize;
    unsigned NumFieldFlagBytes;
    POINTL Origin;
    BYTE OrderType;
    BOOL rc = TRUE;
    RECTL SrcRect;
    PINT_ORDER pOrder;
    SCRBLT_ORDER *pScrBlt;

    DC_BEGIN_FN("OEEncodeScrBlt");

    // Check whether we should use the multi-cliprect version. Must be a
    // complex clip region and the client must support the order.
    if (pClipRects->rects.c < 2 ||
            !OE_SendAsOrder(TS_ENC_MULTISCRBLT_ORDER)) {
        // Non-multi version.
        OrderType = TS_ENC_SCRBLT_ORDER;
        OrderSize = MAX_SCRBLT_FIELD_SIZE;
        NumFieldFlagBytes = 1;
    }
    else {
        // Multi version.
        OrderType = TS_ENC_MULTISCRBLT_ORDER;
        OrderSize = MAX_MULTI_SCRBLT_FIELD_SIZE_NCLIP(pClipRects->rects.c);
        NumFieldFlagBytes = 2;
    }

    // Make sure we don't have orders turned off.
    if (OE_SendAsOrder(OrderType)) {
        // Clip source point.
        Origin = *pptlSrc;
        OEClipPoint(&Origin);

        // Where there are multiple clipping rectangles, it is
        // difficult to calculate the correct order to move the various
        // bits of target surface around - we might move the bottom left
        // to the middle before we moved the middle up to the top right.
        //
        // We make an exception where:
        // - there is only horizontal or vertical movement
        // - there is no overlap between the different clipping
        //   rectangles (source or destination)
        // - there are 3 or fewer clipping rectangles.
        //
        // This takes care of several important cases - particularly
        // scrolling in Excel.
        if (pClipRects->rects.c > 1)
            OETransformClipRectsForScrBlt(pClipRects, &Origin, pBounds, pco);

        // For screen targets, we have to take into account the existing
        // screen data areas. The problem here arises from the fact that
        // SDA is bltted to the screen *after* all orders in a packet
        // are drawn. If we do not take this into account, we can end
        // up ScrBltting pieces of the screen around that are wrong
        // because the SDA should have been written first, but won't
        // have been.
        if (oeLastDstSurface == NULL) {
            if (!OEIntersectScrBltWithSDA(&Origin, pBounds, pClipRects)) {
                TRC_NRM((TB,"ScrBlt entirely contained within SDA, "
                        "not sending"));
                DC_QUIT;
            }
        }

        // By this point either we've got no clip rects, so we simply send
        // the order straight, or some clip rects that might have been
        // intersected with the SDA if the target is the screen, so we
        // send one or more copies of the order, one for each clip rect.

        // 1 or 2 field flag bytes.
        pOrder = OA_AllocOrderMem(ppdev, MAX_ORDER_SIZE(
                pClipRects->rects.c, NumFieldFlagBytes, OrderSize));
        if (pOrder != NULL) {
            pScrBlt = (SCRBLT_ORDER *)oeTempOrderBuffer;
            pScrBlt->nLeftRect = pBounds->left;
            pScrBlt->nTopRect = pBounds->top;
            pScrBlt->nWidth = pBounds->right - pBounds->left;
            pScrBlt->nHeight = pBounds->bottom - pBounds->top;
            pScrBlt->bRop = Rop3;
            pScrBlt->nXSrc = Origin.x;
            pScrBlt->nYSrc = Origin.y;

            if (OrderType == TS_ENC_SCRBLT_ORDER) {
                // Slow-field-encode the order with the first clip rect
                // (if present).
                pOrder->OrderLength = OE2_EncodeOrder(pOrder->OrderData,
                        TS_ENC_SCRBLT_ORDER, NUM_SCRBLT_FIELDS,
                        (BYTE *)pScrBlt, (BYTE *)&PrevScrBlt, etable_SB,
                        (pClipRects->rects.c == 0 ? NULL :
                        &pClipRects->rects.arcl[0]));

                INC_OUTCOUNTER(OUT_SCRBLT_ORDER);
                ADD_INCOUNTER(IN_SCRBLT_BYTES, pOrder->OrderLength);
                OA_AppendToOrderList(pOrder);

                // Flush the order.
                if (pClipRects->rects.c < 2)
                    rc = TRUE;
                else
                    rc = OEEmitReplayOrders(ppdev, 1, pClipRects);
            }
            else {
                MULTI_SCRBLT_ORDER *pMultiSB = (MULTI_SCRBLT_ORDER *)
                        oeTempOrderBuffer;

                // Encode the clip rects directly into the order.
                pMultiSB->nDeltaEntries = OEBuildMultiClipOrder(ppdev,
                        &pMultiSB->codedDeltaList, pClipRects);

                // Slow-field-encode the order with no clip rects.
                pOrder->OrderLength = OE2_EncodeOrder(pOrder->OrderData,
                        TS_ENC_MULTISCRBLT_ORDER, NUM_MULTI_SCRBLT_FIELDS,
                        (BYTE *)pMultiSB, (BYTE *)&PrevMultiScrBlt, etable_MS,
                        NULL);

                INC_OUTCOUNTER(OUT_MULTI_SCRBLT_ORDER);
                ADD_INCOUNTER(IN_MULTI_SCRBLT_BYTES, pOrder->OrderLength);
                OA_AppendToOrderList(pOrder);
            }

            TRC_NRM((TB, "%sScrBlt x %d y %d w %d h %d sx %d sy %d rop %02X",
                   (OrderType == TS_ENC_SCRBLT_ORDER ? "" : "Multi"),
                   pScrBlt->nLeftRect, pScrBlt->nTopRect,
                   pScrBlt->nWidth, pScrBlt->nHeight,
                   pScrBlt->nXSrc, pScrBlt->nYSrc, pScrBlt->bRop));
        }
        else {
            TRC_ERR((TB, "Failed to alloc order"));
            INC_OUTCOUNTER(OUT_BITBLT_SDA_HEAPALLOCFAILED);

            // On failure with a screen target, add all of the clip
            // destination rects to SDA. Clip rects are in exclusive
            // coords so convert before adding.
            if (oeLastDstSurface == NULL)
                OEClipAndAddScreenDataAreaByIntersectRects(pBounds,
                        pClipRects);

            rc = FALSE;
        }
    }
    else {
        TRC_NRM((TB, "(Multi)ScrBlt order not allowed"));
        INC_OUTCOUNTER(OUT_BITBLT_SDA_UNSUPPORTED);
        rc = FALSE;
    }

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}


/****************************************************************************/
// OECacheGlyphs
//
// Caches glyphs as presented in the given font and string objects. Returns
// FALSE on failure to cache.
/****************************************************************************/
BOOL RDPCALL OECacheGlyphs(
        STROBJ         *pstro,
        FONTOBJ        *pfo,
        PFONTCACHEINFO pfci,
        PGLYPHCONTEXT  pglc)
{
    unsigned i;
    unsigned j;
    BOOL fMore;
    UINT32 cGlyphs;
    unsigned cbDataSize;
    GLYPHPOS *pGlyphPos;
    UINT32 Key1, Key2;
    void *UserDefined;
    unsigned cx;
    unsigned cy;
    unsigned dx;
    unsigned dy;
    unsigned x;
    unsigned y;
    FONTINFO fi;

    DC_BEGIN_FN("OECacheGlyphs");

    // Determine appropriate glyph cache if we haven't already done so.
    if (pfci->cacheId < 0) {
        FONTOBJ_vGetInfo(pfo, sizeof(fi), &fi);
        cbDataSize = (fi.cjMaxGlyph1 + 3) & ~3;
        if (SBCSelectGlyphCache(cbDataSize, &pfci->cacheId)) {
            pfci->cacheHandle =
                    pddShm->sbc.glyphCacheInfo[pfci->cacheId].cacheHandle;
            pddShm->sbc.glyphCacheInfo[pfci->cacheId].cbUseCount++;
        }
        else {
            TRC_NRM((TB, "Failed to determine glyph cache"));
            goto FailCache;
        }
    }

    // Establish our cache context.
    CH_SetCacheContext(pfci->cacheHandle, pglc);

    // Loop through each glyph, caching it appropriately.
    if (pstro->pgp == NULL)
        STROBJ_vEnumStart(pstro);
    dx = 0;
    dy = 0;
    j = 0;
    fMore = TRUE;
    while (fMore) {
        if (pstro->pgp != NULL) {
            fMore = FALSE;
            cGlyphs = pstro->cGlyphs;
            pGlyphPos = pstro->pgp;
        }
        else {
            fMore = STROBJ_bEnum(pstro, &cGlyphs, &pGlyphPos);
            if (cGlyphs == 0) {
                TRC_NRM((TB, "STROBJ_bEnum - 0 glyphs"));
                goto FailCache;
            }
        }

        if (j == 0) {
            x = pGlyphPos->ptl.x;
            y = pGlyphPos->ptl.y;
        }

        for (i = 0; i < cGlyphs; i++) {
            // GDI never sets the SO_VERTICAL bit, and there are cases where
            // it does not properly set the SO_HORIZONTAL bit either. As a
            // result, when GDI is silent we need to look for ourselves if
            // we plan on catching these cases.
            if ((pstro->flAccel & SO_HORIZONTAL) == 0) {
                dx += (x - pGlyphPos->ptl.x);
                dy += (y - pGlyphPos->ptl.y);
                if (dx && dy) {
                    TRC_NRM((TB, "Can't process horizertical text"));
                    goto FailCache;
                }
            }

            // Search for cache entry.
            Key1 = pGlyphPos->hg; // Key1 has to be the most variable for the hash.
            Key2 = pfci->fontId;
            if (CH_SearchCache(pfci->cacheHandle, Key1, Key2, &UserDefined,
                    &pglc->rgCacheIndex[j])) {
                // If the cache entry already existed, then flag our index
                // item as such so we know later on not to send the glyph
                // Set the entry tag for this DrvTextOut.
                CH_SetUserDefined(pfci->cacheHandle, pglc->rgCacheIndex[j],
                        (void *)pglc->cacheTag);
                pddCacheStats[GLYPH].CacheHits++;
                pglc->rgCacheIndex[j] = ~pglc->rgCacheIndex[j];
                pglc->nCacheHit++;
            }
            else {
                // Cache the key.
                pglc->rgCacheIndex[j] = CH_CacheKey(pfci->cacheHandle, Key1,
                        Key2, (void *)pglc->cacheTag);
                if (pglc->rgCacheIndex[j] != CH_KEY_UNCACHABLE) {
                    // Keep a running total of the glyph data size for
                    // later use.
                    cx = pGlyphPos->pgdf->pgb->sizlBitmap.cx;
                    cy = pGlyphPos->pgdf->pgb->sizlBitmap.cy;

                    cbDataSize = ((cx + 7) / 8) * cy;
                    cbDataSize = (cbDataSize + 3) & ~3;

                    pglc->cbTotalDataSize += cbDataSize;

                    pglc->cbTotalDataSize += sizeof(TS_CACHE_GLYPH_DATA) -
                            FIELDSIZE(TS_CACHE_GLYPH_DATA, aj);
                }
                else {
                    TRC_NRM((TB, "Glyph could not be added to cache"));
                    goto FailCache;
                }
            }

            pglc->nCacheIndex = ++j;
            pGlyphPos++;
        }
    }

    // Establish text orientation when GDI is silent (see above comment).
    if ((pstro->flAccel & SO_HORIZONTAL) == 0) {
        if (dx != 0)
            pstro->flAccel |= SO_HORIZONTAL;
        else if (dy != 0)
            pstro->flAccel |= SO_VERTICAL;
    }

    // De-establish our context to be used for the cache callback.
    if (pfci->cacheId >= 0)
        CH_SetCacheContext(pfci->cacheHandle, NULL);

    DC_END_FN();
    return TRUE;

FailCache:
    // De-establish our context to be used for the cache callback.
    if (pfci->cacheId >= 0)
        CH_SetCacheContext(pfci->cacheHandle, NULL);

    // Remove any entries we did cache.
    for (i = 0; i < pglc->nCacheIndex; i++)
        if (pglc->rgCacheIndex[i] < SBC_NUM_GLYPH_CACHE_ENTRIES)
            CH_RemoveCacheEntry(pfci->cacheHandle, pglc->rgCacheIndex[i]);

    DC_END_FN();
    return FALSE;
}


/****************************************************************************/
// OEFlushCacheGlyphOrder
//
// Flushes a buffered Cache Glyph order.
/****************************************************************************/
void OEFlushCacheGlyphOrder(
        STROBJ *pstro,
        PINT_ORDER pOrder,
        PGLYPHCONTEXT pglc)
{
    unsigned cbOrderSize;
    PTS_CACHE_GLYPH_ORDER pGlyphOrder;
    unsigned i, cGlyphs;
    UINT16 UNALIGNED *pUnicode;
    UINT16 UNALIGNED *pUnicodeEnd;

    DC_BEGIN_FN("OEFlushCacheGlyphOrder");

    if (pOrder != NULL) {
        TRC_ASSERT((pglc->cbDataSize > 0),
                (TB, "Bad pglc->cbDataSize"));

        pGlyphOrder = (PTS_CACHE_GLYPH_ORDER)pOrder->OrderData;

        if (pddShm->sbc.caps.GlyphSupportLevel >= CAPS_GLYPH_SUPPORT_ENCODE) {
            cGlyphs = (pGlyphOrder->header.extraFlags & 
                    TS_CacheGlyphRev2_cGlyphs_Mask) >> 8;

            cbOrderSize = sizeof(TS_CACHE_GLYPH_ORDER_REV2) -
                    FIELDSIZE(TS_CACHE_GLYPH_ORDER_REV2, glyphData) +
                    pglc->cbDataSize;
        }
        else {
            cGlyphs = pGlyphOrder->cGlyphs;

            cbOrderSize = sizeof(TS_CACHE_GLYPH_ORDER) -
                    FIELDSIZE(TS_CACHE_GLYPH_ORDER, glyphData) +
                    pglc->cbDataSize;
        }

        pUnicode = (UINT16 UNALIGNED *)&pOrder->OrderData[cbOrderSize];
        pUnicodeEnd = pUnicode + cGlyphs;

        for (i = pglc->indexNextSend; pUnicode < pUnicodeEnd; i++)
            if (pglc->rgCacheIndex[i] < SBC_NUM_GLYPH_CACHE_ENTRIES)
                *pUnicode++ = pstro->pwszOrg[i];

        cbOrderSize += cGlyphs * sizeof(UINT16);
        pGlyphOrder->header.orderLength = (USHORT)
                TS_CALCULATE_SECONDARY_ORDER_ORDERLENGTH(cbOrderSize);
        OA_TruncateAllocatedOrder(pOrder, cbOrderSize);
        INC_OUTCOUNTER(OUT_CACHEGLYPH);
        ADD_OUTCOUNTER(OUT_CACHEGLYPH_BYTES, cbOrderSize);
        OA_AppendToOrderList(pOrder);

        pglc->cbDataSize = 0;
        pglc->cbBufferSize = 0;
    }

    DC_END_FN();
}

__inline void Encode2ByteFields(
        BYTE     **pEncode,
        unsigned Val,
        unsigned *pOrderSize)
{
    if (Val <= 127) {
        **pEncode = (BYTE) Val;
        (*pOrderSize)++;
        (*pEncode)++;
    }
    else {
        **pEncode = (BYTE)(((Val & 0x7F00) >> 8) | 0x80);
        *(*pEncode + 1) = (BYTE)(Val & 0x00FF);
        (*pOrderSize) += 2;
        (*pEncode) += 2;
    }
}

__inline void Encode2ByteSignedFields(
        BYTE **pEncode,
        int Val,
        unsigned *pOrderSize)
{
    if (Val < 0) {
        **pEncode = 0x40;
        Val = - Val;
    }
    else {
        **pEncode = 0;
    }

    if (Val <= 63) {
        **pEncode |= (BYTE)Val;
        (*pOrderSize)++;
        (*pEncode)++;
    }
    else {
        **pEncode |= ((BYTE)(((Val & 0x3F00) >> 8) | 0x80));
        *((*pEncode) + 1) = (BYTE)(Val & 0x00FF);
        (*pOrderSize) += 2;
        (*pEncode) += 2;
    }
}


/****************************************************************************/
// OESendCacheGlyphRev2
//
// Allocates and sends a Cache Glyph Rev2 secondary order. REturns FALSE on
// failure.
/****************************************************************************/
BOOL OESendCacheGlyphRev2(
        PDD_PDEV       ppdev,
        STROBJ         *pstro,
        FONTOBJ        *pfo,
        PFONTCACHEINFO pfci,
        PGLYPHCONTEXT  pglc,
        unsigned       index,
        GLYPHPOS       *pGlyphPos,
        PINT_ORDER     *ppOrder)
{
    BOOL rc = TRUE;
    unsigned cbDataSize, cbGlyphSize;
    unsigned cx;
    unsigned cy;
    PTS_CACHE_GLYPH_ORDER_REV2 pGlyphOrder;
    PBYTE pGlyphData;
    PINT_ORDER pOrder = *ppOrder;

    DC_BEGIN_FN("OESendCacheGlyphRev2");

    // Calculate and allocate glyph order buffer.
    cx = pGlyphPos->pgdf->pgb->sizlBitmap.cx;
    cy = pGlyphPos->pgdf->pgb->sizlBitmap.cy;

    cbGlyphSize = ((cx + 7) / 8) * cy;
    cbGlyphSize = (cbGlyphSize + 3) & ~3;

    cbDataSize = cbGlyphSize;

    if (pglc->cbBufferSize < (TS_GLYPH_DATA_REV2_HDR_MAX_SIZE + cbDataSize +
            sizeof(UINT16))) {
        if (pOrder != NULL) {
            pglc->cbTotalDataSize += pglc->cbBufferSize;
            OEFlushCacheGlyphOrder(pstro, pOrder, pglc);
            pglc->indexNextSend = index;
        }

        pglc->cbBufferSize = min(pglc->cbTotalDataSize, 4096);
        pglc->cbTotalDataSize -= pglc->cbBufferSize;

        pOrder = OA_AllocOrderMem(ppdev, sizeof(TS_CACHE_GLYPH_ORDER_REV2) -
                FIELDSIZE(TS_CACHE_GLYPH_ORDER_REV2, glyphData) +
                pglc->cbBufferSize);
        if (pOrder != NULL) {
            pGlyphOrder = (PTS_CACHE_GLYPH_ORDER_REV2)pOrder->OrderData;
            pGlyphOrder->header.extraFlags = TS_EXTRA_GLYPH_UNICODE |
                    TS_CacheGlyphRev2_Mask;
            pGlyphOrder->header.orderType = TS_CACHE_GLYPH;
            pGlyphOrder->header.orderHdr.controlFlags = TS_STANDARD |
                    TS_SECONDARY;
            pGlyphOrder->header.extraFlags  |= (((char)pfci->cacheId) &
                    TS_CacheGlyphRev2_CacheID_Mask);
        }
        else {
            TRC_ERR((TB, "Failed to allocate glyph order"));
            rc = FALSE;
            DC_QUIT;
        }
    }

    pGlyphOrder = (PTS_CACHE_GLYPH_ORDER_REV2)pOrder->OrderData;
    pGlyphData  = (PBYTE)(pGlyphOrder->glyphData) + pglc->cbDataSize;

    *pGlyphData++ = (BYTE)pglc->rgCacheIndex[index];
    cbDataSize++;

    Encode2ByteSignedFields(&pGlyphData, (INT16)pGlyphPos->pgdf->pgb->ptlOrigin.x,
            &cbDataSize);
    Encode2ByteSignedFields(&pGlyphData, (INT16)pGlyphPos->pgdf->pgb->ptlOrigin.y,
            &cbDataSize);
    Encode2ByteFields(&pGlyphData, (UINT16)cx, &cbDataSize);
    Encode2ByteFields(&pGlyphData, (UINT16)cy, &cbDataSize);
    RtlCopyMemory(pGlyphData, pGlyphPos->pgdf->pgb->aj, cbGlyphSize);
    
    // number of glyphs.  cGlyphs is the upper byte in extraflag
    pGlyphOrder->header.extraFlags += 0x100;

    TRC_ASSERT((pglc->cbBufferSize >= cbDataSize),
               (TB, "Bad pglc->cbBufferSize"));

    pglc->cbDataSize  += cbDataSize;
    pglc->cbBufferSize -= (cbDataSize + sizeof(UINT16));

DC_EXIT_POINT:
    *ppOrder = pOrder;
    DC_END_FN();
    return rc;
}


/****************************************************************************/
// OESendCacheGlyph
//
// Allocates and sends glyph orders. Returns FALSE on failure.
/****************************************************************************/
BOOL OESendCacheGlyph(
        PDD_PDEV ppdev,
        STROBJ *pstro,
        FONTOBJ *pfo,
        PFONTCACHEINFO pfci,
        PGLYPHCONTEXT pglc,
        unsigned index,
        GLYPHPOS *pGlyphPos,
        PINT_ORDER *ppOrder)
{
    BOOL rc = TRUE;
    unsigned cbDataSize;
    unsigned cbOrderSize;
    unsigned cx;
    unsigned cy;
    PTS_CACHE_GLYPH_DATA pGlyphData;
    PTS_CACHE_GLYPH_ORDER pGlyphOrder;
    PINT_ORDER pOrder = *ppOrder;

    DC_BEGIN_FN("OESendCacheGlyph");

    // Calculate and allocate glyph order buffer.
    cx = pGlyphPos->pgdf->pgb->sizlBitmap.cx;
    cy = pGlyphPos->pgdf->pgb->sizlBitmap.cy;

    cbDataSize = ((cx + 7) / 8) * cy;
    cbDataSize = (cbDataSize + 3) & ~3;

    cbOrderSize = (sizeof(TS_CACHE_GLYPH_DATA) -
            FIELDSIZE(TS_CACHE_GLYPH_DATA, aj) + cbDataSize);

    if (pglc->cbBufferSize < cbOrderSize + sizeof(UINT16)) {
        if (*ppOrder != NULL) {
            pglc->cbTotalDataSize += pglc->cbBufferSize;
            OEFlushCacheGlyphOrder(pstro, pOrder, pglc);
            pglc->indexNextSend = index;
        }
        
        pglc->cbBufferSize = min(pglc->cbTotalDataSize, 4096);
        pglc->cbTotalDataSize -= pglc->cbBufferSize;

        pOrder = OA_AllocOrderMem(ppdev, sizeof(TS_CACHE_GLYPH_ORDER) -
                FIELDSIZE(TS_CACHE_GLYPH_ORDER, glyphData) +
                pglc->cbBufferSize);
        if (pOrder != NULL) {
            pGlyphOrder = (PTS_CACHE_GLYPH_ORDER)pOrder->OrderData;
            pGlyphOrder->header.extraFlags = TS_EXTRA_GLYPH_UNICODE;
            pGlyphOrder->header.orderType = TS_CACHE_GLYPH;
            pGlyphOrder->header.orderHdr.controlFlags = TS_STANDARD |
                    TS_SECONDARY;
            pGlyphOrder->cacheId = (char)pfci->cacheId;
            pGlyphOrder->cGlyphs = 0;
        }
        else {
            TRC_ERR((TB, "Failed to allocate glyph order"));
            rc = FALSE;
            DC_QUIT;
        }
    }

    pGlyphOrder = (PTS_CACHE_GLYPH_ORDER)pOrder->OrderData;
    pGlyphData  = (PTS_CACHE_GLYPH_DATA)
            ((PBYTE)(pGlyphOrder->glyphData) + pglc->cbDataSize);

    pGlyphData->cacheIndex = (UINT16)pglc->rgCacheIndex[index];
    pGlyphData->x  = (INT16)pGlyphPos->pgdf->pgb->ptlOrigin.x;
    pGlyphData->y  = (INT16)pGlyphPos->pgdf->pgb->ptlOrigin.y;
    pGlyphData->cx = (INT16)cx;
    pGlyphData->cy = (INT16)cy;

    RtlCopyMemory(pGlyphData->aj, pGlyphPos->pgdf->pgb->aj, cbDataSize);
    pGlyphOrder->cGlyphs++;

    TRC_ASSERT((pglc->cbBufferSize >= cbOrderSize),
            (TB, "Bad pglc->cbBufferSize"));

    pglc->cbDataSize += cbOrderSize;
    pglc->cbBufferSize -= (cbOrderSize + sizeof(UINT16));

DC_EXIT_POINT:
    *ppOrder = pOrder;
    DC_END_FN();
    return rc;
}


/****************************************************************************/
// OESendGlyphs
//
// Sends glyphs. Returns FALSE on failure.
/****************************************************************************/
BOOL RDPCALL OESendGlyphs(
        SURFOBJ *pso,
        STROBJ *pstro,
        FONTOBJ *pfo,
        PFONTCACHEINFO pfci,
        PGLYPHCONTEXT pglc)
{
    BOOL rc = TRUE;
    unsigned i;
    unsigned j;
    BOOL fMore;
    UINT32 cGlyphs;
    UINT32 dwSize;
    GLYPHPOS *pGlyphPos;
    PDD_PDEV ppdev;
    PINT_ORDER pOrder;

    DC_BEGIN_FN("OESendGlyphs");

    j = 0;
    pOrder = NULL;

    // If we don't have to send ANY glyphs, then just exit.
    if (pglc->nCacheHit < pstro->cGlyphs) {
        ppdev = (PDD_PDEV)pso->dhpdev;
        pglc->cbTotalDataSize += ((pstro->cGlyphs - pglc->nCacheHit) *
                (sizeof(UINT16)));      

        // Loop through all glyphs, sending those that have not yet been sent.
        if (pstro->pgp == NULL)
            STROBJ_vEnumStart(pstro);

        fMore = TRUE;
        while (rc && fMore) {
            if (pstro->pgp != NULL) {
                fMore = FALSE;
                cGlyphs = pstro->cGlyphs;
                pGlyphPos = pstro->pgp;
            }
            else {
                fMore = STROBJ_bEnum(pstro, &cGlyphs, &pGlyphPos);
                if (cGlyphs == 0) {
                    TRC_NRM((TB, "STROBJ_bEnum - 0 glyphs"));
                    goto SucceedEncode;
                }
            }

            // Send all current retrieved glyphs.
            for (i = 0; i < cGlyphs; i++) {
                if (pglc->rgCacheIndex[j] < SBC_NUM_GLYPH_CACHE_ENTRIES) {
                    if (pddShm->sbc.caps.GlyphSupportLevel >=
                            CAPS_GLYPH_SUPPORT_ENCODE) {
                        rc = OESendCacheGlyphRev2(ppdev, pstro, pfo, pfci,
                                pglc, j, pGlyphPos, &pOrder);
                    }
                    else {
                        rc = OESendCacheGlyph(ppdev, pstro, pfo, pfci, pglc,
                                j, pGlyphPos, &pOrder);
                    }

                    if (!rc)
                        goto FailEncode;
                }

                j++;
                pGlyphPos++;
            }
        }
    }

SucceedEncode:
    // All is well, make sure we flush out any buffered glyphs.
    if (pOrder != NULL)
        OEFlushCacheGlyphOrder(pstro, pOrder, pglc);

    DC_END_FN();
    return TRUE;

FailEncode:
    // If we could not send all the required glyphs, then remove them from
    // the cache (as future hits on this entry will be invalid).
    if (pOrder != NULL)
        OA_FreeOrderMem(pOrder);

    for (i = 0; i < pglc->nCacheIndex; i++) {
        if (pglc->rgCacheIndex[i] < SBC_NUM_GLYPH_CACHE_ENTRIES)
            CH_RemoveCacheEntry(pfci->cacheHandle, pglc->rgCacheIndex[i]);
    }

    DC_END_FN();
    return FALSE;
}


/****************************************************************************/
// OESendGlyphAndIndexOrder
//
// Sends FastGlyph order. Returns FALSE on failure.
/****************************************************************************/
BOOL OESendGlyphAndIndexOrder(
        PDD_PDEV ppdev,
        STROBJ *pstro,
        OE_ENUMRECTS *pClipRects,
        PRECTL prclOpaque,
        POE_BRUSH_DATA pCurrentBrush, 
        PFONTCACHEINFO pfci,
        PGLYPHCONTEXT pglc)
{
    BOOL rc = TRUE;
    GLYPHPOS *pGlyphPos;
    PINT_ORDER pOrder;
    unsigned tempVar, OpEncodeFlags;
    unsigned cx, cy, cbDataSize, cbGlyphSize;
    PBYTE pGlyphData;
    LPFAST_GLYPH_ORDER pFastGlyphOrder;
    RECTL BoundRect;
    OE_ENUMRECTS IntersectRects;

    DC_BEGIN_FN("OESendGlyphIndexOrder");

    pOrder = NULL;

    // First determine if this order is clipped out by the clip rects.
    // If so, no need to allocate and send it.
    if (prclOpaque != NULL) {
        // Bounded by the opaque rect. Clip it to our max first.
        if (prclOpaque->right > OE_MAX_COORD)
            prclOpaque->right = OE_MAX_COORD;

        if (prclOpaque->bottom > OE_MAX_COORD)
            prclOpaque->bottom = OE_MAX_COORD;

        // If the rect is inverted or null, we use the target string rect
        // instead.
        if (prclOpaque->top < prclOpaque->bottom)
            BoundRect = *prclOpaque;
        else
            BoundRect = pstro->rclBkGround;
    }
    else {
        // Bounded by the string target rect.
        BoundRect = pstro->rclBkGround;
    }

    IntersectRects.rects.c = 0;
    if (pClipRects->rects.c == 0 ||
            OEGetIntersectionsWithClipRects(&BoundRect, pClipRects,
            &IntersectRects)) {
        if (pstro->pgp != NULL) {
            pGlyphPos = pstro->pgp;
        }
        else {
            STROBJ_vEnumStart(pstro);
            STROBJ_bEnum(pstro, &tempVar, &pGlyphPos);
            if (tempVar == 0) {
                TRC_NRM((TB, "STROBJ_bEnum - 0 glyphs"));
                rc = FALSE;
                DC_QUIT;
            }
        }
    }
    else {
        TRC_NRM((TB,"Order bounds do not intersect with clip, not sending"));
        rc = FALSE;
        DC_QUIT;
    }

    pFastGlyphOrder = (LPFAST_GLYPH_ORDER)oeTempOrderBuffer;

    if (pglc->nCacheHit == 0) {
        // We don't have a cache hit, so need to send the glyph.
        // First create the variable-size data in the temp order buf
        // to determine its size.
        pGlyphData = (PBYTE)(pFastGlyphOrder->variableBytes.glyphData);

        *pGlyphData++ = (BYTE)pglc->rgCacheIndex[0];
        cbDataSize = 1;
        Encode2ByteSignedFields(&pGlyphData,
                (INT16)pGlyphPos->pgdf->pgb->ptlOrigin.x, &cbDataSize);
        Encode2ByteSignedFields(&pGlyphData,
                (INT16)pGlyphPos->pgdf->pgb->ptlOrigin.y, &cbDataSize);

        cx = pGlyphPos->pgdf->pgb->sizlBitmap.cx;
        cy = pGlyphPos->pgdf->pgb->sizlBitmap.cy;
        cbGlyphSize = ((cx + 7) / 8) * cy;
        cbGlyphSize = (cbGlyphSize + 3) & ~3;
        cbDataSize += cbGlyphSize;

        *pGlyphData++ = (BYTE)cx;
        *pGlyphData++ = (BYTE)cy;
        cbDataSize += 2;

        memcpy(pGlyphData, pGlyphPos->pgdf->pgb->aj, cbGlyphSize);

        // append unicode to the end of glyph data
        *((UINT16 UNALIGNED *)(pGlyphData + cbGlyphSize)) = pstro->pwszOrg[0];
        cbDataSize += 2;

        pFastGlyphOrder->variableBytes.len = cbDataSize;
    }
    else {
        // We have a cache hit. We only need to send a 1-byte cache index
        // in the variable size data.
        cbDataSize = 1;

        // Store the variable data in the order data
        if (pglc->rgCacheIndex[0] > SBC_GL_MAX_CACHE_ENTRIES)
            pFastGlyphOrder->variableBytes.glyphData[0] = 
                    (BYTE)(~pglc->rgCacheIndex[0]);
        else 
            pFastGlyphOrder->variableBytes.glyphData[0] =
                    (BYTE)pglc->rgCacheIndex[0];

        pFastGlyphOrder->variableBytes.len = 1;
    }
    
    // 2 field flag bytes, plus the variable data size.
    pOrder = OA_AllocOrderMem(ppdev, MAX_ORDER_SIZE(IntersectRects.rects.c,
            2, MAX_FAST_GLYPH_FIELD_SIZE_DATASIZE(cbDataSize)));
    if (pOrder != NULL) {
        // Establish per order settings.
        pFastGlyphOrder->cacheId = (BYTE)pfci->cacheId;
        pFastGlyphOrder->fDrawing =  (((BYTE) pstro->flAccel) << 8) | 
                ((BYTE)pstro->ulCharInc);
        pFastGlyphOrder->BackColor = pCurrentBrush->back;
        pFastGlyphOrder->ForeColor = pCurrentBrush->fore;

        // Establish bounding rect left and right values.
        pFastGlyphOrder->BkTop = pstro->rclBkGround.top;
        pFastGlyphOrder->BkBottom = pstro->rclBkGround.bottom;
        pFastGlyphOrder->BkLeft = pstro->rclBkGround.left;
        pFastGlyphOrder->BkRight = pstro->rclBkGround.right;

        // Set up x, y coordinates
        if (pGlyphPos->ptl.x == pFastGlyphOrder->BkLeft)
            pFastGlyphOrder->x = INT16_MIN;
        else
            pFastGlyphOrder->x = pGlyphPos->ptl.x;

        if (pGlyphPos->ptl.y == pFastGlyphOrder->BkTop)
            pFastGlyphOrder->y = INT16_MIN;
        else
            pFastGlyphOrder->y = pGlyphPos->ptl.y;

        // Setup Opaque rect coordinates. Note we clipped to OE_MAX_COORD
        // above.
        if (prclOpaque) {
            pFastGlyphOrder->OpTop = prclOpaque->top;
            pFastGlyphOrder->OpBottom = prclOpaque->bottom;
            pFastGlyphOrder->OpLeft = prclOpaque->left;
            pFastGlyphOrder->OpRight = prclOpaque->right;
        }
        else {
            pFastGlyphOrder->OpTop = 0;
            pFastGlyphOrder->OpBottom = 0;
            pFastGlyphOrder->OpLeft = 0;
            pFastGlyphOrder->OpRight = 0;
        }

        // Is the Opaque rect redundant?
        OpEncodeFlags =
                ((pFastGlyphOrder->OpLeft == pFastGlyphOrder->BkLeft) << 3) |
                ((pFastGlyphOrder->OpTop == pFastGlyphOrder->BkTop) << 2) |
                ((pFastGlyphOrder->OpRight == pFastGlyphOrder->BkRight) << 1) |
                (pFastGlyphOrder->OpBottom == pFastGlyphOrder->BkBottom);

        // For Fast Index order, we can encode even better for x, y and 
        // opaque rect.
        if (OpEncodeFlags == 0xf) {
            // All 4 bits present, Opaque rect is same as Bk rect.
            pFastGlyphOrder->OpLeft = 0;
            pFastGlyphOrder->OpTop = OpEncodeFlags;
            pFastGlyphOrder->OpRight = 0;
            pFastGlyphOrder->OpBottom = INT16_MIN;
        }    
        else if (OpEncodeFlags == 0xd) {
            // Bit 1 is 0, others are 1.
            // Opaque rect matches Bk rect except OpRight
            // we store OpRight at OpRight field
            pFastGlyphOrder->OpLeft = 0;
            pFastGlyphOrder->OpTop = OpEncodeFlags;
            pFastGlyphOrder->OpRight = pFastGlyphOrder->OpRight;
            pFastGlyphOrder->OpBottom = INT16_MIN;           
        }

        // Slow-field-encode the order with the first clip rect
        // (if present).
        pOrder->OrderLength = OE2_EncodeOrder(pOrder->OrderData,
                TS_ENC_FAST_GLYPH_ORDER, NUM_FAST_GLYPH_FIELDS,
                (BYTE *)pFastGlyphOrder, (BYTE *)&PrevFastGlyph, etable_FG,
                (IntersectRects.rects.c == 0 ? NULL :
                &IntersectRects.rects.arcl[0]));

        INC_OUTCOUNTER(OUT_TEXTOUT_FAST_GLYPH);
        ADD_INCOUNTER(IN_FASTGLYPH_BYTES, pOrder->OrderLength);
        OA_AppendToOrderList(pOrder);

        // Flush the order.
        if (IntersectRects.rects.c < 2)
            rc = TRUE;
        else
            rc = OEEmitReplayOrders(ppdev, 2, &IntersectRects);
    }
    else {
        rc = FALSE;
        TRC_ERR((TB, "Failed to alloc Fast Index order"));
    }

DC_EXIT_POINT:

    // If we could not send all the required glyphs, then remove them from
    // the cache (as future hits on this entry will be invalid).
    if (!rc && pglc->nCacheHit == 0)
        CH_RemoveCacheEntry(pfci->cacheHandle, pglc->rgCacheIndex[0]);

    DC_END_FN();
    return rc;
}


/****************************************************************************/
// OESendIndexOrder
//
// Sends GlyphIndex and FastIndex orders. Returns FALSE on failure.
/****************************************************************************/
unsigned RDPCALL OESendIndexOrder(
        PDD_PDEV       ppdev,
        STROBJ         *pstro,
        OE_ENUMRECTS   *pClipRects,
        PRECTL         prclOpaque,
        POE_BRUSH_DATA pCurrentBrush,
        PFONTCACHEINFO pfci,
        PGLYPHCONTEXT  pglc,
        unsigned       iGlyph,
        unsigned       cGlyphs,
        int            x,
        int            y,
        int            cx,
        int            cy,
        int            cxLast,
        int            cyLast,
        PBYTE          pjData,
        unsigned       cbData)
{
    UINT32 dwSize;
    LPINDEX_ORDER pIndexOrder;
    LPFAST_INDEX_ORDER pFastIndexOrder;
    PINT_ORDER pOrder;
    BOOL fFastIndex;
    unsigned fStatus, OpEncodeFlags;
    unsigned NumFieldFlagBytes;
    RECTL *pBoundRect;
    RECTL OpaqueRect;
    RECTL BkRect;
    OE_ENUMRECTS IntersectRects;

    DC_BEGIN_FN("OESendIndexOrder");

    fStatus = GH_STATUS_SUCCESS;

    // First determine the opaque rect and background rects we will send
    // on the wire. We'll use these to determine the target bound rect for the
    // GlyphIndex order, to see if it is clipped out by the cliprects.
    if (pstro->flAccel & SO_HORIZONTAL) {
        BkRect.top = pstro->rclBkGround.top;
        BkRect.bottom = pstro->rclBkGround.bottom;

        OpaqueRect.top = prclOpaque->top;
        OpaqueRect.bottom = prclOpaque->bottom;

        // Left to right
        if (x <= cx) {
            if (iGlyph == 0) {
                BkRect.left = pstro->rclBkGround.left;
                OpaqueRect.left = prclOpaque->left;
            }
            else {
                BkRect.left = min(cxLast, x);
                if (OpaqueRect.top == OpaqueRect.bottom)
                    OpaqueRect.left = 0;
                else
                    OpaqueRect.left = cxLast;
            }

            if (iGlyph + cGlyphs >= pglc->nCacheIndex) {
                BkRect.right = pstro->rclBkGround.right;
                OpaqueRect.right = prclOpaque->right;
            }
            else {
                BkRect.right = cx;
                if (OpaqueRect.top == OpaqueRect.bottom)
                    OpaqueRect.right = 0;
                else
                    OpaqueRect.right = cx;
            }
        }

        // Right to left
        else {
            if (iGlyph == 0) {
                BkRect.right = pstro->rclBkGround.right;
                OpaqueRect.right = prclOpaque->right;
            }
            else {
                BkRect.right = x;
                if (OpaqueRect.top == OpaqueRect.bottom)
                    OpaqueRect.right = 0;
                else
                    OpaqueRect.right = x;
            }

            if (iGlyph + cGlyphs >= pglc->nCacheIndex) {
                BkRect.left = pstro->rclBkGround.left;
                OpaqueRect.left = prclOpaque->left;
            }
            else {
                BkRect.left = cx;
                if (prclOpaque->top == prclOpaque->bottom)
                    OpaqueRect.left = 0;
                else
                    OpaqueRect.left = cx;
            }
        }
    }
    else {
        BkRect.left = pstro->rclBkGround.left;
        BkRect.right = pstro->rclBkGround.right;

        OpaqueRect.left = prclOpaque->left;
        OpaqueRect.right = prclOpaque->right;

        // Top to bottom
        if (y <= cy) {
            if (iGlyph == 0) {
                BkRect.top = pstro->rclBkGround.top;
                OpaqueRect.top = prclOpaque->top;
            }
            else {
                BkRect.top = cyLast;
                if (prclOpaque->top == prclOpaque->bottom)
                    OpaqueRect.top = 0;
                else
                    OpaqueRect.top = cyLast;
            }

            if (iGlyph + cGlyphs >= pglc->nCacheIndex) {
                BkRect.bottom = pstro->rclBkGround.bottom;
                OpaqueRect.bottom = prclOpaque->bottom;
            }
            else {
                BkRect.bottom = cy;
                if (prclOpaque->top == prclOpaque->bottom)
                    OpaqueRect.bottom = 0;
                else
                    OpaqueRect.bottom = cy;
            }
        }
        else {
            // Bottom to top
            if (iGlyph == 0) {
                BkRect.bottom = pstro->rclBkGround.bottom;
                OpaqueRect.bottom = prclOpaque->bottom;
            }
            else {
                BkRect.bottom = y;
                if (prclOpaque->top == prclOpaque->bottom)
                    OpaqueRect.bottom = 0;
                else
                    OpaqueRect.bottom = y;
            }

            if (iGlyph + cGlyphs >= pglc->nCacheIndex) {
                BkRect.top = pstro->rclBkGround.top;
                OpaqueRect.top = prclOpaque->top;
            }
            else {
                BkRect.top = cy;
                if (prclOpaque->top == prclOpaque->bottom)
                    OpaqueRect.top = 0;
                else
                    OpaqueRect.top = cy;
            }
        }
    }

    // If the opaque rect is normally-ordered, it is our bound rect.
    // Otherwise use the target background string rect.
    if (OpaqueRect.top < OpaqueRect.bottom)
        pBoundRect = &OpaqueRect;
    else
        pBoundRect = &BkRect;

    IntersectRects.rects.c = 0;
    if (pClipRects->rects.c == 0 ||
            OEGetIntersectionsWithClipRects(pBoundRect, pClipRects,
            &IntersectRects) > 0) {
        fFastIndex = OE_SendAsOrder(TS_ENC_FAST_INDEX_ORDER);

        // Calculate and allocate the req memory for this order.
        if (fFastIndex) {
            dwSize = MAX_FAST_INDEX_FIELD_SIZE_DATASIZE(cbData);
            NumFieldFlagBytes = 2;
        }
        else {
            dwSize = MAX_INDEX_FIELD_SIZE_DATASIZE(cbData);
            NumFieldFlagBytes = 3;
        }

        pOrder = OA_AllocOrderMem(ppdev, MAX_ORDER_SIZE(IntersectRects.rects.c,
                NumFieldFlagBytes, dwSize));

        if (pOrder != NULL) {
            // Since most of the fields are the same between Index order and
            // fast index order. We arrange them in such a way that they can
            // both be cast to the Index order in a lot of cases.
            pIndexOrder = (LPINDEX_ORDER)oeTempOrderBuffer;
            pFastIndexOrder = (LPFAST_INDEX_ORDER)oeTempOrderBuffer;

            pIndexOrder->cacheId = (BYTE)pfci->cacheId;
            pIndexOrder->ForeColor = pCurrentBrush->fore;
            pIndexOrder->BackColor = pCurrentBrush->back;
            pIndexOrder->x = x;
            pIndexOrder->y = y;


            pIndexOrder->BkLeft = BkRect.left;
            pIndexOrder->BkTop = BkRect.top;
            pIndexOrder->BkRight = BkRect.right;
            pIndexOrder->BkBottom = BkRect.bottom;

            pIndexOrder->OpLeft = OpaqueRect.left;
            pIndexOrder->OpTop = OpaqueRect.top;
            pIndexOrder->OpRight = OpaqueRect.right;
            pIndexOrder->OpBottom = OpaqueRect.bottom;

            // Is the Opaque rect redundant?
            // We use 4 bits in OpTop field to encode Opaque Rect. 1 means
            // a field is same as BkRect's field. 0 means a field is supplied
            // in OpLeft or OpRight.
            //     bit 0: OpBottom
            //     bit 1: OpRight
            //     bit 2: OpTop
            //     bit 3: OpLeft
            OpEncodeFlags = ((OpaqueRect.left == BkRect.left) << 3) |
                    ((OpaqueRect.top == BkRect.top) << 2) |
                    ((OpaqueRect.right == BkRect.right) << 1) |
                    (OpaqueRect.bottom == BkRect.bottom);

            if (fFastIndex) {
                pFastIndexOrder->fDrawing = (((BYTE) pstro->flAccel) << 8) | 
                        ((BYTE) pstro->ulCharInc);

                 // For Fast Index order, we can encode even better for x, y and 
                 // opaque rect. We use INT16_MIN when possible to let the
                 // field encoder not send that field more often.
                if (OpEncodeFlags == 0xf) {
                    // All 4 bits present, Opaque rect is same as Bk rect.
                    pFastIndexOrder->OpLeft = 0;
                    pFastIndexOrder->OpTop = OpEncodeFlags;
                    pFastIndexOrder->OpRight = 0;
                    pFastIndexOrder->OpBottom = INT16_MIN;
                }
                else if (OpEncodeFlags == 0xd) {
                    // Bit 1 is 0, others are 1.
                    // Opaque rect matches Bk rect except OpRight
                    // we store OpRight at OpRight field
                    pFastIndexOrder->OpLeft = 0;
                    pFastIndexOrder->OpTop = OpEncodeFlags;
                    pFastIndexOrder->OpRight = pFastIndexOrder->OpRight;
                    pFastIndexOrder->OpBottom = INT16_MIN;
                }

                // Set to same val if x coordinate same as BkLeft or y same as
                // BkTop. This lets field encoding not send the value more often.
                if (pFastIndexOrder->x == pFastIndexOrder->BkLeft)
                    pFastIndexOrder->x = INT16_MIN;
                if (pFastIndexOrder->y == pFastIndexOrder->BkTop)
                    pFastIndexOrder->y = INT16_MIN;

                // Store the order data and encode the order.
                memcpy(pFastIndexOrder->variableBytes.arecs, pjData, cbData);
                pFastIndexOrder->variableBytes.len = cbData;

                // Slow-field-encode the order with the first clip rect
                // (if present).
                pOrder->OrderLength = OE2_EncodeOrder(pOrder->OrderData,
                        TS_ENC_FAST_INDEX_ORDER, NUM_FAST_INDEX_FIELDS,
                        (BYTE *)pFastIndexOrder, (BYTE *)&PrevFastIndex,
                        etable_FI,
                        (IntersectRects.rects.c == 0 ? NULL :
                        &IntersectRects.rects.arcl[0]));

                INC_OUTCOUNTER(OUT_TEXTOUT_FAST_INDEX);
                ADD_INCOUNTER(IN_FASTINDEX_BYTES, pOrder->OrderLength);
                OA_AppendToOrderList(pOrder);

                // Flush the order.
                if (IntersectRects.rects.c >= 2)
                    if (!OEEmitReplayOrders(ppdev, 2, &IntersectRects))
                        fStatus = GH_STATUS_CLIPPED;
            }
            else {
                pIndexOrder->flAccel = (BYTE)pstro->flAccel;
                pIndexOrder->ulCharInc = (BYTE)pstro->ulCharInc;
                pIndexOrder->BrushStyle = pCurrentBrush->style;
                TRC_ASSERT((pIndexOrder->BrushStyle == BS_SOLID),
                        (TB,"Non solid brush"));

                if (OpEncodeFlags == 0xf) {
                    pIndexOrder->OpTop = 0;
                    pIndexOrder->OpRight = 0;
                    pIndexOrder->OpBottom = 0;
                    pIndexOrder->OpLeft = 0;
                    pIndexOrder->fOpRedundant = TRUE;
                }
                else {
                    pIndexOrder->fOpRedundant = FALSE;
                }

                // Store the order data and encode the order.
                memcpy(pIndexOrder->variableBytes.arecs, pjData, cbData);
                pIndexOrder->variableBytes.len = cbData;

                // Slow-field-encode the order with the first clip rect
                // (if present).
                pOrder->OrderLength = OE2_EncodeOrder(pOrder->OrderData,
                        TS_ENC_INDEX_ORDER, NUM_INDEX_FIELDS,
                        (BYTE *)pIndexOrder, (BYTE *)&PrevGlyphIndex,
                        etable_GI,
                        (IntersectRects.rects.c == 0 ? NULL :
                        &IntersectRects.rects.arcl[0]));

                INC_OUTCOUNTER(OUT_TEXTOUT_GLYPH_INDEX);
                ADD_INCOUNTER(IN_GLYPHINDEX_BYTES, pOrder->OrderLength);
                OA_AppendToOrderList(pOrder);

                // Flush the order.
                if (IntersectRects.rects.c >= 2)
                    if (!OEEmitReplayOrders(ppdev, 3, &IntersectRects))
                        fStatus = GH_STATUS_CLIPPED;
            }
        }
        else {
            fStatus = GH_STATUS_NO_MEMORY;
            TRC_ERR((TB, "Failed to alloc Index order"));
        }
    }
    else {
        TRC_NRM((TB,"(Fast)Index order completely clipped, not sending"));
        fStatus = GH_STATUS_CLIPPED;
    }

    DC_END_FN();
    return fStatus;
}


/****************************************************************************/
// OEGetFragment
//
// Retrieves text fragments (run of contig glyphs). Returns number of bytes
// copied into fragment buffer.
/****************************************************************************/
unsigned RDPCALL OEGetFragment(
        STROBJ        *pstro,
        FONTOBJ       *pfo,
        GLYPHPOS      **ppGlyphPos,
        PGLYPHCONTEXT pglc,
        PUINT         pcGlyphs,
        PUINT         pcCurGlyphs,
        PINT          px,
        PINT          py,
        PINT          pcx,
        PINT          pcy,
        PBYTE         pjFrag,
        unsigned      maxFrag)
{
    unsigned cbFrag;
    unsigned cbEntrySize;
    unsigned cacheIndex;
    int      delta;
    BOOL     fMore;

    DC_BEGIN_FN("OEGetFragment");

    // Loop through each glyph index accumulating the fragment.
    cbFrag = 0;
    cbEntrySize = (pstro->flAccel & SO_CHAR_INC_EQUAL_BM_BASE) ? 1 : 2;

    while (*pcGlyphs < pglc->nCacheIndex) {
        // If we have exhausted our fragment space, then exit.
        if (cbFrag + cbEntrySize >= maxFrag)
            break;

        // We may need to get a new batch of current glyphs.
        if (*pcCurGlyphs == 0) {
            fMore = STROBJ_bEnum(pstro, pcCurGlyphs, ppGlyphPos);
            if (*pcCurGlyphs == 0) {
                cbFrag = 0;

                TRC_NRM((TB, "STROBJ_bEnum - 0 glyphs"));
                DC_QUIT;
            }
        }

        // Place the glyph cache index into the fragment.
        cacheIndex = pglc->rgCacheIndex[*pcGlyphs];
        if (cacheIndex > SBC_GL_MAX_CACHE_ENTRIES)
            cacheIndex = ~cacheIndex;

        if (!(pstro->flAccel & SO_GLYPHINDEX_TEXTOUT) && (cbFrag > 0) &&
                (pstro->pwszOrg[*pcGlyphs] == 0x20)) {
            if (pstro->ulCharInc || (pstro->flAccel & SO_CHAR_INC_EQUAL_BM_BASE))
                pjFrag[cbFrag++] = (BYTE) cacheIndex;
        }
        else {
            pjFrag[cbFrag++] = (BYTE) cacheIndex;

            // If we do not have a mono-spaced font, nor an equal base font,
            // then we need to also provide a delta coordinate.
            if (pstro->ulCharInc == 0) {
                if ((pstro->flAccel & SO_CHAR_INC_EQUAL_BM_BASE) == 0) {
                    // The delta coordinate is either the x-delta or the
                    // y-delta, based upon whether the text is horizontal
                    // or vertical.
                    if (pstro->flAccel & SO_HORIZONTAL)
                        delta = ((*ppGlyphPos)->ptl.x - *px);
                    else
                        delta = ((*ppGlyphPos)->ptl.y - *py);

                    if (delta >= 0 && delta <= 127) {
                        pjFrag[cbFrag++] = (char) delta;
                    }
                    else {
                        pjFrag[cbFrag++] = 0x80;
                        *(UNALIGNED short *)(&pjFrag[cbFrag]) = (SHORT)delta;
                        cbFrag += sizeof(INT16);
                    }
                }

                // Return the new glyph spacing coordinates to the main
                // routine.
                *px = (*ppGlyphPos)->ptl.x;
                *py = (*ppGlyphPos)->ptl.y;
                *pcx = (*ppGlyphPos)->ptl.x +
                        (*ppGlyphPos)->pgdf->pgb->ptlOrigin.x +
                        (*ppGlyphPos)->pgdf->pgb->sizlBitmap.cx;
                *pcy = (*ppGlyphPos)->ptl.y +
                        (*ppGlyphPos)->pgdf->pgb->ptlOrigin.y +
                        (*ppGlyphPos)->pgdf->pgb->sizlBitmap.cy;
            }
        }

        // Next glyph.
        (*pcGlyphs)++;
        (*ppGlyphPos)++;
        (*pcCurGlyphs)--;
    }

DC_EXIT_POINT:
    DC_END_FN();
    return cbFrag;
}


/****************************************************************************/
// OEMatchFragment
//
// Matches text fragments with cached fragments. Returns the number of bytes
// in the fragment index returned in *pNewFragIndex.
/****************************************************************************/
unsigned RDPCALL OEMatchFragment(
        STROBJ         *pstro,
        FONTOBJ        *pfo,
        PFONTCACHEINFO pfci,
        PFRAGCONTEXT   pfgc,
        PBYTE          pjFrag,
        unsigned       cbFrag,
        PUINT          pNewFragIndex,
        unsigned       cx,
        unsigned       cy,
        unsigned       cxLast,
        unsigned       cyLast)
{
    unsigned cacheIndex;
    UINT16 delta;
    unsigned i;
    void *UserDefined;
    CHDataKeyContext CHContext;
    INT16  dx, dy;
    
    DC_BEGIN_FN("OEMatchFragment");

    if (pfgc->cacheHandle) {
        // If this is not a mono-spaced font, nor an equal base font, then
        // we need to normalize the first delta, and the trailing padding.
        if (pstro->ulCharInc == 0) {
            if ((pstro->flAccel & SO_CHAR_INC_EQUAL_BM_BASE) == 0) {
                if (pjFrag[1] != 0x80) {
                    delta = pjFrag[1];
                    pjFrag[1] = (BYTE) (pfci->cacheId);
                }
                else {
                    delta = *(UNALIGNED short *)(&pjFrag[2]);
                    pjFrag[2] = (BYTE) (pfci->cacheId);
                    pjFrag[3] = (BYTE) (pfci->cacheId);
                }
            }
        }

        i = (cbFrag + 3) & ~3;

        memset(&pjFrag[cbFrag], (0xff), i - cbFrag);

        // Multiple fonts can fall into the same cacheId, so two fragments
        // of different fonts may collide if we use cacheId instead of fontId.
        // memset(&pjFrag[i], (BYTE) (pfci->cacheId), sizeof(DWORD));
        *(PUINT32)(&pjFrag[i]) = pfci->fontId;

        i += sizeof(UINT32);

        // Restore the normalized first delta.
        if (pstro->ulCharInc == 0) {
            if ((pstro->flAccel & SO_CHAR_INC_EQUAL_BM_BASE) == 0) {
                if (delta >= 0 && delta <= 127)
                    pjFrag[1] = (char) delta;
                else
                    *(UNALIGNED short *)(&pjFrag[2]) = delta;
            }
        }

        // Make the default key for this fragment, and then search the
        // fragment cache for a match.
        CH_CreateKeyFromFirstData(&CHContext, pjFrag, i);
        
        // Check if it is a fragment cache key collision by verifying the
        // bounding background rectangle.
        if (pstro->flAccel & SO_HORIZONTAL) {
            dy = (INT16) (pstro->rclBkGround.bottom - pstro->rclBkGround.top);
            if (cxLast == 0) 
                dx = (INT16)(cx - pstro->rclBkGround.left);
            else
                dx = (INT16)(cx - cxLast);
        }
        else {
            dx = (INT16) (pstro->rclBkGround.right - pstro->rclBkGround.left);
            if (cyLast == 0) 
                dy = (INT16)(cy - pstro->rclBkGround.top);
            else
                dy = (INT16)(cy - cyLast);
        }

        if (CH_SearchCache(pfgc->cacheHandle, CHContext.Key1, 
                CHContext.Key2, &UserDefined, &cacheIndex)) {
            if (dx == (INT16) HIWORD((UINT32)(UINT_PTR)UserDefined) && 
                    dy == (INT16) LOWORD((UINT32)(UINT_PTR)UserDefined)) {
                // If the entry already exists, then we can use it.
                for (i = 0; i < pfgc->nCacheIndex; i++) {
                    if (cacheIndex == pfgc->rgCacheIndex[i])
                        DC_QUIT;
                }

                cbFrag = 0;
                pjFrag[cbFrag++] = ORD_INDEX_FRAGMENT_USE;
                pjFrag[cbFrag++] = (BYTE)cacheIndex;

                if (pstro->ulCharInc == 0) {
                    if ((pstro->flAccel & SO_CHAR_INC_EQUAL_BM_BASE) == 0) {
                        if (delta >= 0 && delta <= 127) {
                            pjFrag[cbFrag++] = (char) delta;
                        }
                        else {
                            pjFrag[cbFrag++] = 0x80;
                            *(UNALIGNED short *)(&pjFrag[cbFrag]) = delta;
                            cbFrag += sizeof(INT16);
                        }
                    }
                }
            }
            else {
                TRC_ALT((TB, "Fragment cache Key collision at index %d",
                        cacheIndex));
                UserDefined = (void *) ULongToPtr((((((UINT32) ((UINT16) dx)) << 16) | 
                        (UINT32) ((UINT16) dy))));
                CH_SetUserDefined(pfgc->cacheHandle, cacheIndex, UserDefined);

                // Pass the entry along to the client.
                i = cbFrag;

                pjFrag[cbFrag++] = ORD_INDEX_FRAGMENT_ADD;
                pjFrag[cbFrag++] = (BYTE)cacheIndex;
                pjFrag[cbFrag++] = (BYTE)i;

                *pNewFragIndex = cacheIndex;
            }
        }
        else {
            UserDefined = (void *) ULongToPtr((((((UINT32) ((UINT16) dx)) << 16) | 
                        (UINT32) ((UINT16) dy))));           
            cacheIndex = CH_CacheKey(pfgc->cacheHandle, CHContext.Key1,
                    CHContext.Key2, UserDefined);

            // If we could not add the cache entry, then bail.
            if (cacheIndex != CH_KEY_UNCACHABLE) {
                // Pass the entry along to the client.
                i = cbFrag;

                pjFrag[cbFrag++] = ORD_INDEX_FRAGMENT_ADD;
                pjFrag[cbFrag++] = (BYTE)cacheIndex;
                pjFrag[cbFrag++] = (BYTE)i;

                *pNewFragIndex = cacheIndex;
            }
            else {
                TRC_NRM((TB, "Fragment could not be added to cache"));
                DC_QUIT;
            }
        }
    }

DC_EXIT_POINT:
    DC_END_FN();
    return cbFrag;
}


/****************************************************************************/
// OEClearFragments
//
// Clears the newly added cache fragments.
/****************************************************************************/
void RDPCALL OEClearFragments(PFRAGCONTEXT pfgc)
{
    unsigned  i;

    DC_BEGIN_FN("OEClearFragments");

    // Remove all fragment cache entries that were being newly defined to
    // to the client.
    for (i = 0; i < pfgc->nCacheIndex; i++)
        CH_RemoveCacheEntry(pfgc->cacheHandle, pfgc->rgCacheIndex[i]);

    pfgc->nCacheIndex = 0;

    DC_END_FN();
}


/****************************************************************************/
// OEMatchFragment
//
// Matches text fragments with cached fragments. Returns FALSE on failure.
/****************************************************************************/
BOOL RDPCALL OESendIndexes(
        SURFOBJ *pso,
        STROBJ *pstro,
        FONTOBJ *pfo,
        OE_ENUMRECTS *pClipRects,
        PRECTL prclOpaque,
        POE_BRUSH_DATA pbdOpaque,
        POINTL *pptlOrg,
        PFONTCACHEINFO pfci,
        PGLYPHCONTEXT pglc)
{
    BOOL rc;
    unsigned iGlyph;
    UINT32 cGlyphs;
    RECTL rclOpaque;
    LPINDEX_ORDER pIndexOrder;
    GLYPHPOS *pGlyphPos;
    FRAGCONTEXT fgc;
    unsigned cCurGlyphs;
    unsigned cbData;
    unsigned cbFrag;
    BYTE ajFrag[255];
    BYTE ajData[255];
    int x, y;
    int cx, cy;
    int cxPre, cyPre;
    int cxLast, cyLast;
    int dx, dy;
    int cdx, cdy;
    int xFrag, yFrag;
    unsigned maxFrag;
    unsigned minFrag;
    unsigned fStatus;
    PDD_PDEV ppdev;
    BOOL fMore;
    unsigned newFragIndex;

    DC_BEGIN_FN("OEMatchFragment");

    rc = FALSE;
    fStatus = GH_STATUS_NO_MEMORY;

    ppdev = (PDD_PDEV)pso->dhpdev;

    // If no opaque rect is specified, default to the null rect.
    if (prclOpaque == NULL) {
        prclOpaque = &rclOpaque;
        prclOpaque->left = 0;
        prclOpaque->top = 0;
        prclOpaque->right = 0;
        prclOpaque->bottom = 0;
    }
    else {
        if (prclOpaque->right > OE_MAX_COORD)
            prclOpaque->right = OE_MAX_COORD;

        if (prclOpaque->bottom > OE_MAX_COORD)
            prclOpaque->bottom = OE_MAX_COORD;
    }

    // Establish min and max fragment limits.
    fgc.nCacheIndex = 0;
    fgc.cacheHandle = pddShm->sbc.fragCacheInfo[0].cacheHandle;
    fgc.cbCellSize = pddShm->sbc.fragCacheInfo[0].cbCellSize;

    maxFrag = fgc.cacheHandle ? fgc.cbCellSize : sizeof(ajFrag);
    maxFrag = min(maxFrag, sizeof(ajFrag) - 2 * sizeof(DWORD) - 4);
    minFrag = 3 * ((pstro->flAccel & SO_CHAR_INC_EQUAL_BM_BASE) ? 1 : 2);

    // Loop through each glyph index, sending as many entries as
    // possible per each order.
    if (pstro->pgp != NULL) {
        pGlyphPos = pstro->pgp;
        cCurGlyphs = pglc->nCacheIndex;
    }
    else {
        STROBJ_vEnumStart(pstro);
        fMore = STROBJ_bEnum(pstro, &cCurGlyphs, &pGlyphPos);
        if (cCurGlyphs == 0) {
            TRC_NRM((TB, "STROBJ_bEnum - 0 glyphs"));
            DC_QUIT;
        }
    }

    cbData = 0;
    iGlyph = 0;
    cGlyphs = 0;

    x = dx = pGlyphPos->ptl.x;
    y = dy = pGlyphPos->ptl.y;
    cx = cy = cxLast = cyLast = 0;

    while (cGlyphs < pglc->nCacheIndex) {
        xFrag = pGlyphPos->ptl.x;
        yFrag = pGlyphPos->ptl.y;

        // Get the next available fragment.
        cbFrag = OEGetFragment(pstro, pfo, &pGlyphPos,
                pglc, &cGlyphs, &cCurGlyphs,
                &dx, &dy, &cdx, &cdy, ajFrag, maxFrag);            
        
        if (cbFrag == 0) {
            if (fgc.nCacheIndex > 0)
                OEClearFragments(&fgc);

            TRC_NRM((TB, "Fragment could not be gotten"));
            DC_QUIT;
        }
        
        // Keep track of the running coordinates.
        cxPre = cx;
        cyPre = cy;
        
        if (pstro->ulCharInc == 0) {
            cx = cdx;
            cy = cdy;
        }
        else {
            if (pstro->flAccel & SO_HORIZONTAL)
                cx = x + (pstro->ulCharInc * (cGlyphs - iGlyph));
            else
                cy = y + (pstro->ulCharInc * (cGlyphs - iGlyph));
        }

        // If the fragment size is within limits, then attempt to match it
        // with a previously defined fragment.
        newFragIndex = BAD_FRAG_INDEX;
        if (cbFrag >= minFrag)
            cbFrag = OEMatchFragment(pstro, pfo, pfci, &fgc,
                    ajFrag, cbFrag, &newFragIndex, cx, cy, cxPre, cyPre);

        // If this fragment will not fit into the current index order, then
        // send the current buffered index data.
        if (cbData + cbFrag > sizeof(pIndexOrder->variableBytes.arecs)) {
            fStatus = OESendIndexOrder(ppdev, pstro, pClipRects,
                    prclOpaque, pbdOpaque, pfci, pglc,
                    iGlyph, cGlyphs - iGlyph, x, y,
                    cx, cy, cxLast, cyLast, ajData, cbData);
            if (fStatus != GH_STATUS_SUCCESS) {
                if (fgc.nCacheIndex > 0)
                    OEClearFragments(&fgc);

                if (fStatus == GH_STATUS_NO_MEMORY) {
                    if (newFragIndex != BAD_FRAG_INDEX)
                        CH_RemoveCacheEntry(fgc.cacheHandle, newFragIndex);

                    TRC_NRM((TB, "Index order could not be sent - no memory"));
                    DC_QUIT;
                }
            }

            // Reset the process.
            cbData = 0;
            iGlyph += cGlyphs;

            cxLast = cxPre;
            cyLast = cyPre;

            if (pstro->ulCharInc == 0) {
                x = xFrag;
                y = yFrag;
            }
            else {
                if (pstro->flAccel & SO_HORIZONTAL)
                    x = cxLast;
                else
                    y = cyLast;
            }

            if (pstro->ulCharInc == 0) {
                if ((pstro->flAccel & SO_CHAR_INC_EQUAL_BM_BASE) == 0) {
                    if (ajFrag[1] != 0x80) {
                        ajFrag[1] = 0;
                    }
                    else {
                        ajFrag[2] = 0;
                        ajFrag[3] = 0;
                    }
                }
            }

            fgc.nCacheIndex = 0;
        }
        
        // Copy the fragment into the order data buffer.
        memcpy(&ajData[cbData], ajFrag, cbFrag);
        cbData += cbFrag;

        if (newFragIndex != BAD_FRAG_INDEX)
            fgc.rgCacheIndex[fgc.nCacheIndex++] = newFragIndex;
    }

    // Flush out any remaining buffered fragments.
    if (cbData > 0) {
        fStatus = OESendIndexOrder(ppdev, pstro, pClipRects,
                prclOpaque, pbdOpaque, pfci, pglc,
                iGlyph, cGlyphs - iGlyph, x, y, cx, cy, cxLast, cyLast,
                ajData, cbData);
        if (fStatus != GH_STATUS_SUCCESS) {
            if (fgc.nCacheIndex > 0)
                OEClearFragments(&fgc);
        }
    }

    rc = TRUE;

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpdd\nshmdisp.c ===
/****************************************************************************/
// nshmdisp.c
//
// RDP Shared Memory header
//
// Copyright (C) 1996-2000 Microsoft Corporation
/****************************************************************************/

#include <precmpdd.h>
#pragma hdrstop

#define TRC_FILE "nshmdisp"

#include <adcg.h>

#include <nshmapi.h>

#define DC_INCLUDE_DATA
#include <ndddata.c>
#undef DC_INCLUDE_DATA

#include <nbadisp.h>
#include <noadisp.h>
#include <noedisp.h>
#include <ncmdisp.h>
#include <nschdisp.h>
#include <npmdisp.h>
#include <nssidisp.h>
#include <nsbcdisp.h>
#include <compress.h>


/****************************************************************************/
/* Name:      SHM_Init                                                      */
/*                                                                          */
/* Purpose:   Initialize the shared memory                                  */
/*                                                                          */
/* Returns:   TRUE if successful, FALSE otherwise                           */
/*                                                                          */
/*            NB Address is passed to the DD on a later IOCtl.              */
/****************************************************************************/
BOOLEAN RDPCALL SHM_Init(PDD_PDEV pPDev)
{
    BOOLEAN rc;

    DC_BEGIN_FN("SHM_Init");

    pddShm = (PSHM_SHARED_MEMORY)EngAllocMem(0, sizeof(SHM_SHARED_MEMORY),
            WD_ALLOC_TAG);
    if (pddShm != NULL) {
        TRC_ALT((TB, "Allocated shared memory OK(%p -> %p) size(%#x)",
                pddShm, ((BYTE *)pddShm) + sizeof(SHM_SHARED_MEMORY) - 1,
                sizeof(SHM_SHARED_MEMORY)));

#ifdef DC_DEBUG
        memset(pddShm, 0, sizeof(SHM_SHARED_MEMORY));
#endif

        // Init non-component members that need known initial values.
        // We DO NOT zero the shm on alloc (except in debug) to reduce paging
        // and cache flushing. Each component is responsible for initializing
        // its Shm memory.
        pddShm->shareId = 0;
        pddShm->guardVal1 = SHM_CHECKVAL;
        pddShm->guardVal2 = SHM_CHECKVAL;
        pddShm->guardVal3 = SHM_CHECKVAL;
        pddShm->guardVal4 = SHM_CHECKVAL;
        pddShm->guardVal5 = SHM_CHECKVAL;
        pddShm->pShadowInfo = NULL;

        // Now call each of the SHM component owners to init its memory.
        BA_InitShm();
        OA_InitShm();
        OE_InitShm();
        CM_InitShm();
        SCH_InitShm();
        PM_InitShm(pPDev);
        SSI_InitShm();
        SBC_InitShm();

        // BC does not need to be initialized.

#ifdef DC_DEBUG
        // Init trace info.
        memset(&pddShm->trc, 0, sizeof(pddShm->trc));
#endif

        rc = TRUE;
    }
    else {
        TRC_ERR((TB, "Failed to allocate %d bytes of shared memory",
                     sizeof(SHM_SHARED_MEMORY)));
        rc = FALSE;
    }

    DC_END_FN();
    return rc;
}


/****************************************************************************/
// SHM_Term
/****************************************************************************/
void RDPCALL SHM_Term(void)
{
    DC_BEGIN_FN("SHM_Term");

    if (pddShm != NULL) {
        TRC_DBG((TB, "Freeing shared memory at %p", pddShm));
        EngFreeMem(pddShm);
        pddShm = NULL;
    }

    DC_END_FN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpdd\nssidata.c ===
/****************************************************************************/
// nssidata.c
//
// SSI data
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <ndcgdata.h>


DC_DATA_NULL(REMOTE_SSB_STATE, ssiRemoteSSBState, DC_STRUCT1(0));

DC_DATA_NULL(LOCAL_SSB_STATE, ssiLocalSSBState, DC_STRUCT1(0));

DC_DATA(SAVEBITMAP_ORDER, PrevSaveBitmap, DC_STRUCT1(0));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpdd\nsbcddat.c ===
/****************************************************************************/
// nsbcddat.c
//
// RDP cache manager display driver data declarations.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <ndcgdata.h>
#include <asbcapi.h>
#include <noedisp.h>

DC_DATA(BOOLEAN, sbcEnabled, FALSE);

// Flag that indicates whether the system palette has changed since the
// last Palette PDU sent.
DC_DATA(BOOLEAN, sbcPaletteChanged, FALSE);

DC_DATA(CHCACHEHANDLE, sbcColorTableCacheHandle, 0);
DC_DATA(unsigned, sbcCurrentColorTableCacheIndex, 0);

DC_DATA(BYTE *, sbcXlateBuf, NULL);

DC_DATA(CHCACHEHANDLE, sbcSmallBrushCacheHandle, 0);
DC_DATA(CHCACHEHANDLE, sbcLargeBrushCacheHandle, 0);

DC_DATA(unsigned, sbcClientBitsPerPel, 0);
#ifdef DC_HICOLOR
DC_DATA(unsigned, sbcCacheFlags, 0);
#endif

// sbcFragInfo is used to check if there is fragment collision in the fragment cache
DC_DATA(PSBC_FRAG_INFO, sbcFragInfo, NULL);

DC_DATA(PCHCACHEDATA, sbcCacheData, NULL);

DC_DATA(CHCACHEHANDLE, sbcOffscreenBitmapCacheHandle, 0);

#ifdef DRAW_NINEGRID
DC_DATA(CHCACHEHANDLE, sbcDrawNineGridBitmapCacheHandle, 0);
#endif

#ifdef DRAW_GDIPLUS
// Cache Handle for GdipGraphics 
DC_DATA(CHCACHEHANDLE, sbcGdipGraphicsCacheHandle, 0);
// Cache Handle for GdipBrush
DC_DATA(CHCACHEHANDLE, sbcGdipObjectBrushCacheHandle, 0);
// Cache Handle for GdipPen
DC_DATA(CHCACHEHANDLE, sbcGdipObjectPenCacheHandle, 0);
// Cache Handle for GdipImage
DC_DATA(CHCACHEHANDLE, sbcGdipObjectImageCacheHandle, 0);
// Cache Handle for GdipImgeaAttributes
DC_DATA(CHCACHEHANDLE, sbcGdipObjectImageAttributesCacheHandle, 0);

// Chunk size for GdipGraphics cache data
DC_DATA(TSUINT16, sbcGdipGraphicsCacheChunkSize, 0);
// Chunk size for GdipBrush cache data
DC_DATA(TSUINT16, sbcGdipObjectBrushCacheChunkSize, 0);
// Chunk size for GdipPen cache data
DC_DATA(TSUINT16, sbcGdipObjectPenCacheChunkSize, 0);
// Chunk size for GdipGraphics cache data
DC_DATA(TSUINT16, sbcGdipObjectImageAttributesCacheChunkSize, 0);
// Chunk size for GdipImageAttrbutes cache data
DC_DATA(TSUINT16, sbcGdipObjectImageCacheChunkSize, 0);
// Record the size (in number of chunks) already used by GdipImage cache data
DC_DATA(TSUINT16, sbcGdipObjectImageCacheSizeUsed, 0);
// Record total size (in number of chunks) allowded for all GdipImage cache data
DC_DATA(TSUINT16, sbcGdipObjectImageCacheTotalSize, 0);
// The maximun single image size (in number of chunks) we can cache GdipImage
DC_DATA(TSUINT16, sbcGdipObjectImageCacheMaxSize, 0);
// Record the size (in number of chunks) for each GdipImage data cached
DC_DATA(TSUINT16 *, sbcGdipObjectImageCacheSizeList, NULL);
#endif

// Total number of offscreen bitmaps to be deleted by client
DC_DATA(unsigned, sbcNumOffscrBitmapsToDelete, 0);

// Total size of offscreen bitmaps to be deleted by client in bytes
DC_DATA(unsigned, sbcOffscrBitmapsToDeleteSize, 0);

// sbcOffscrBitmapsToDelete
DC_DATA(PSBC_OFFSCR_BITMAP_DEL_INFO, sbcOffscrBitmapsDelList, NULL); 

// Current index of font cache info in the list
DC_DATA(unsigned, sbcFontCacheInfoListIndex, 0);

// Toal number of items in the sbcFontCacheInfoList
DC_DATA(unsigned, sbcFontCacheInfoListSize, 0);

// sbcFontCacheInfoList - store all the font cache info created
DC_DATA(FONTCACHEINFO **, sbcFontCacheInfoList, NULL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpdd\nsbcdisp.c ===
/****************************************************************************/
// nsbcdisp.c
//
// RDP Send Bitmap Cache display driver code
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <precmpdd.h>
#define hdrstop

#define TRC_FILE "nsbcdisp"
#include <adcg.h>
#include <atrcapi.h>

#define DC_INCLUDE_DATA
#include <ndddata.c>
#include <noedata.c>
#undef DC_INCLUDE_DATA

#include <asbcapi.h>
#include <nsbcdisp.h>
#include <noadisp.h>
#include <abcapi.h>
#include <nprcount.h>
#include <nschdisp.h>
#include <nchdisp.h>
#include <noedisp.h>

#include <nsbcinl.h>

#include <nsbcddat.c>


#ifdef DC_DEBUG
BOOL SBC_VerifyBitmapBits(PBYTE pBitmapData, unsigned cbBitmapSize, UINT iCacheID, UINT iCacheIndex);
#endif


/****************************************************************************/
// SBC_DDInit: SBC display driver initialization function.
/****************************************************************************/
void RDPCALL SBC_DDInit(PDD_PDEV pPDev)
{
    DC_BEGIN_FN("SBC_DDInit");

    // Initializes all the global data for this component.
#define DC_INIT_DATA
#include <nsbcddat.c>
#undef DC_INIT_DATA

#ifndef DC_HICOLOR
    sbcClientBitsPerPel = pPDev->cClientBitsPerPel;
#endif

    TRC_NRM((TB, "Completed SBC_DDInit"));
    DC_END_FN();
}


/****************************************************************************/
// SBC_InitShm(): Inits the SBC shm component on connect/reconnect.
/****************************************************************************/
void RDPCALL SBC_InitShm(void)
{
    DC_BEGIN_FN("SBC_InitShm");

    // Zero only the parts which need to be zeroed.
    memset(&pddShm->sbc, 0, sizeof(SBC_SHARED_DATA));

    DC_END_FN();
}


/****************************************************************************/
// SBCProcessBitmapKeyDatabase
//
// Given persistent bitmap key database, populates caches.
/****************************************************************************/
__inline void RDPCALL SBCProcessBitmapKeyDatabase(
        SBC_BITMAP_CACHE_KEY_INFO *pKeyDatabase)
{
    unsigned i, j;

#ifdef DC_DEBUG
    unsigned BitmapHdrSize;
    SBC_BITMAP_CACHE_EXTRA_INFO *pBitmapHdr;
#endif

    DC_BEGIN_FN("SBCProcessBitmapKeyDatabase");
    
    // This call should not be made if the database ptr is NULL.
    TRC_ASSERT((pKeyDatabase != NULL), (TB,"NULL pKeyDatabase"));

    for (i = 0; i < pddShm->sbc.NumBitmapCaches; i++) {

        TRC_NRM((TB,"Cache %d: %d keys", i, pKeyDatabase->NumKeys[i]));

        // Place each persistent key in its corresponding index
        // in the cache. Note that the MRU sequence is implicit in the
        // order in the database -- CH_ForceCacheKeyAtIndex() appends the
        // entry to the MRU.
        for (j = 0; j < pKeyDatabase->NumKeys[i]; j++) {
            if ((&(pKeyDatabase->Keys[pKeyDatabase->KeyStart[i]]))[j].Key1 !=
                    TS_BITMAPCACHE_NULL_KEY ||
                    (&(pKeyDatabase->Keys[pKeyDatabase->KeyStart[i]]))[j].Key2 !=
                    TS_BITMAPCACHE_NULL_KEY) {

#ifdef DC_DEBUG
                // We have no cache bits, so set the header data size to zero
                // on debug.
                BitmapHdrSize = sizeof(SBC_BITMAP_CACHE_EXTRA_INFO) +
                        SBC_CellSizeFromCacheID(i);
                if (pddShm->sbc.bitmapCacheInfo[i].pExtraEntryInfo != NULL) {
                    pBitmapHdr = (SBC_BITMAP_CACHE_EXTRA_INFO *)(pddShm->sbc.
                            bitmapCacheInfo[i].pExtraEntryInfo +
                            (&(pKeyDatabase->Keys[pKeyDatabase->KeyStart[i]]))[j].CacheIndex *
                            BitmapHdrSize);
                    pBitmapHdr->DataSize = 0;
                }
#endif

                // We have to set the UserDefined to NULL since we have no
                // associated fast-path cache entry pointer.
                CH_ForceCacheKeyAtIndex(
                        pddShm->sbc.bitmapCacheInfo[i].cacheHandle,
                        (&(pKeyDatabase->Keys[pKeyDatabase->KeyStart[i]]))[j].CacheIndex,
                        (&(pKeyDatabase->Keys[pKeyDatabase->KeyStart[i]]))[j].Key1,
                        (&(pKeyDatabase->Keys[pKeyDatabase->KeyStart[i]]))[j].Key2,
                        NULL);
            }
        }
    }

    DC_END_FN();
}


/****************************************************************************/
// SBCAllocBitmapCache; Allocates bitmap cache data buffers according to the
// current negotiated capabilities.
//
// Returns: SBC_BITMAP_CACHE_ENABLED if successful, 0 otherwise.
/****************************************************************************/
unsigned RDPCALL SBCAllocBitmapCache(PCHCACHEHANDLE pCacheHandle)
{
    SIZEL TileSize;
    BOOLEAN rc;
    unsigned i, j;
    unsigned TotalCacheEntries;
    unsigned iFormat;
    PSBC_BITMAP_CACHE_INFO pInfo;
    PCHCACHEDATA pCacheData;

#if DC_DEBUG
    unsigned BitmapHdrSize;
#endif

    DC_BEGIN_FN("SBCAllocBitmapCache");

    TRC_NRM((TB, "Alloc bitmap cache data and work bitmaps"));

    rc = FALSE;
    i = j = 0;
    
    // Cell caching is disabled if NumCellCaches is zero. It is set to
    // zero by the WD caps negotiation code if the client indicated zero,
    // if any of the requested cell cache NumEntries is zero, or if the rev1
    // caps returned a CacheNMaximumCellSize that was not the required tile
    // size.
    if (pddShm->sbc.NumBitmapCaches > 0) {
        // Work tile bitmap format type, and translation buffer for 4bpp to
        // 8bpp conversions. The translation buffer must be as large as the
        // largest tile size.
        if (sbcClientBitsPerPel != 4) {
#ifdef DC_HICOLOR
            if (sbcClientBitsPerPel == 24)
            {
                iFormat = BMF_24BPP;
            }
            else if ((sbcClientBitsPerPel == 16) || (sbcClientBitsPerPel == 15))
            {
                iFormat = BMF_16BPP;
            }
            else
            {
                iFormat = BMF_8BPP;
            }
#else
            iFormat = BMF_8BPP;
#endif
        }
        else {
            iFormat = BMF_4BPP;
            sbcXlateBuf = EngAllocMem(0, SBC_CellSizeFromCacheID(
                    pddShm->sbc.NumBitmapCaches - 1), DD_ALLOC_TAG);
            if (sbcXlateBuf == NULL) {
                TRC_ERR((TB,"Failed to create 4bpp to 8bpp translate buf"));
                DC_QUIT;
            }
        }

        TotalCacheEntries = 0;

        for (i = 0; i < pddShm->sbc.NumBitmapCaches; i++) {
            pInfo = &(pddShm->sbc.bitmapCacheInfo[i]);

            // Create a square work tile bitmap.
            // We set the last parameter to NULL, to allow GDI to allocate
            // memory for the bits.  We can get a pointer to the bits later
            // when we have a SURFOBJ for the bitmap.
            TileSize.cx = TileSize.cy = (SBC_CACHE_0_DIMENSION << i);
            pddShm->sbc.bitmapCacheInfo[i].hWorkBitmap = (HSURF)
                    EngCreateBitmap(TileSize,
                    TS_BYTES_IN_SCANLINE(TileSize.cx, sbcClientBitsPerPel),
                    iFormat, 0, NULL);
            if (pddShm->sbc.bitmapCacheInfo[i].hWorkBitmap == NULL) {
                TRC_ERR((TB, "Failed to create work bitmap %d", i));
                DC_QUIT;
            }

#ifdef DC_DEBUG
            // Alloc set of SBC_BITMAP_DATA_HEADERs and space for bitmap
            // bits to be kept for comparison in debug builds.
            BitmapHdrSize = sizeof(SBC_BITMAP_CACHE_EXTRA_INFO) +
                    SBC_CellSizeFromCacheID(i);
            pInfo->pExtraEntryInfo = EngAllocMem(0,
                    pInfo->Info.NumEntries * BitmapHdrSize, DD_ALLOC_TAG);
            // If persistent cache is enabled and in high-color, we will ask for big memory (~20MB)
            // from session space and memory allocation will fail.
            // We don't quit here if memory allocation fails since this memory is only for
            // comparison use in debug build. We'll check the NULL pointer in every usage of this memory (not many)
            if (pInfo->pExtraEntryInfo == NULL) {
                TRC_ERR((TB, "Failed to alloc save-bitmap-data memory "
                        "(cell cache %u)", i));
                //DC_QUIT;
            }
#endif

            // We create the bitmap caches with their indices (cache IDs) in
            // the pContext value so we can backtrack the cache ID when
            // using the fast-path cache.
            if (pInfo->Info.NumEntries) {
                pCacheData = (PCHCACHEDATA)(*pCacheHandle);

                // Bitmap cache list handle
                CH_InitCache(pCacheData, pInfo->Info.NumEntries,
                        (void *)ULongToPtr(i), TRUE, FALSE, SBCBitmapCacheCallback);
            
                pInfo->cacheHandle = pCacheData;

                (BYTE *)(*pCacheHandle) += CH_CalculateCacheSize(
                        pInfo->Info.NumEntries);

                TRC_NRM((TB, "Created cell cache %u: hCache=%p, NumEntries=%u", i,
                        pInfo->cacheHandle, pInfo->Info.NumEntries));

                TotalCacheEntries += pInfo->Info.NumEntries;

                // Waiting list cache handle
                if (pddShm->sbc.fAllowCacheWaitingList) {
                    pCacheData = (PCHCACHEDATA)(*pCacheHandle);
    
                    CH_InitCache(pCacheData, pInfo->Info.NumEntries,
                            (void *)ULongToPtr(i), FALSE, FALSE, NULL);
                
                    pInfo->waitingListHandle = pCacheData;
    
                    (BYTE *)(*pCacheHandle) += CH_CalculateCacheSize(
                            pInfo->Info.NumEntries);
                }
                else {
                    pInfo->waitingListHandle = NULL;
                }
            }
            else {
                TRC_ERR((TB, "Zero entry Cache %d", i));
                DC_QUIT;
            }
        }

        // Allocate fast path cache.        
        pCacheData = (PCHCACHEDATA)(*pCacheHandle);
        CH_InitCache(pCacheData, TotalCacheEntries,
                NULL, TRUE, FALSE, SBCFastPathCacheCallback);

        pddShm->sbc.hFastPathCache = pCacheData;

        TRC_NRM((TB, "Fast Path Cache created(%p) entries(%u)",
                pddShm->sbc.hFastPathCache, TotalCacheEntries));

        (BYTE*)(*pCacheHandle) += CH_CalculateCacheSize(TotalCacheEntries);

        //
        // Color table cache is only required for lo color sessions
        // But we need to allocate for shadow case, when a 256 color
        // client shadows a high color client or console.
        //

        // Allocate color table cache. This is required for bitmap caching.
        pCacheData = (PCHCACHEDATA)(*pCacheHandle);
    
        CH_InitCache(pCacheData,
                SBC_NUM_COLOR_TABLE_CACHE_ENTRIES, NULL, FALSE, FALSE, NULL);
    
        sbcColorTableCacheHandle = pCacheData;    
        
        (BYTE *)(*pCacheHandle) += CH_CalculateCacheSize(
                SBC_NUM_COLOR_TABLE_CACHE_ENTRIES);
    
        //
        //  This is only needed for 256 client case.
        //
        if (sbcClientBitsPerPel <= 8)
        {

            // Make sure we send a first color table to the client. This is important
            // to do here because on a server-initiated sync we no longer force
            // the color table to be sent again to save bandwidth. On 8-bit clients
            // this is not a problem since the palette is always set with
            // DrvSetPalette. However, on 4-bit clients, the client's color tables
            // are never initialized until we send one across.
            sbcPaletteChanged = TRUE;
        }
        
        rc = TRUE;
    }

DC_EXIT_POINT:

    // If we failed to allocate some or all of the required resources then
    // free up any that we did allocate before we return the failure code.
    if (rc == FALSE) {
        SBCFreeBitmapCacheData();

        // Don't waste space for bitmap cache.  back it up
        for (j = 0; j < i; j++) {
            pInfo = &(pddShm->sbc.bitmapCacheInfo[j]);

            (BYTE *)(*pCacheHandle) -= CH_CalculateCacheSize(
                    pInfo->Info.NumEntries);
        }
    }

    DC_END_FN();
    return (rc ? SBC_BITMAP_CACHE_ENABLED : 0);
}


/****************************************************************************/
// SBCCreateGlyphCache
//
// Creates a single bitmap cache of a given size. Returns FALSE on failure.
/****************************************************************************/
__inline BOOLEAN RDPCALL SBCCreateGlyphCache(
        unsigned     cEntries,
        unsigned     cbCellSize,
        PCHCACHEDATA pCacheData)
{
    BOOLEAN rc;

    DC_BEGIN_FN("SBC_CreateGlyphCache");

    if (cEntries != 0 && cbCellSize != 0) {
        // Allocate glyph cache.
        CH_InitCache(pCacheData, cEntries, NULL, FALSE, TRUE,
                SBCGlyphCallback);
        rc = TRUE;
    }
    else {
        TRC_ERR((TB, "Zero: cEntries(%u) cbCellSize(%u)", cEntries,
                cbCellSize));
        rc = FALSE;
    }

    TRC_NRM((TB, "Created glyph cache: pCacheData(%p), cEntries(%u) "
            "cbCellSize(%u)", pCacheData, cEntries, cbCellSize));

    DC_END_FN();
    return rc;
}


/****************************************************************************/
// SBCCreateFragCache
//
// Creates a single bitmap cache of a given size. Returns FALSE on failure.
/****************************************************************************/
__inline BOOLEAN RDPCALL SBCCreateFragCache(
        unsigned     cEntries,
        unsigned     cbCellSize,
        PCHCACHEDATA pCacheData)
{
    BOOLEAN rc;

    DC_BEGIN_FN("SBCCreateFragCache");

    if (cEntries != 0 && cbCellSize != 0) {
        CH_InitCache(pCacheData, cEntries, NULL, FALSE, FALSE, NULL);
        rc = TRUE;
    }
    else {
        TRC_ERR((TB, "Zero: cEntries(%u) cbCellSize(%u)", cEntries,
                cbCellSize));
        rc = FALSE;
    }

    TRC_NRM((TB, "Created frag cache: pCacheData(%p), cEntries(%u) "
            "cbCellSize(%u)", pCacheData, cEntries, cbCellSize));

    DC_END_FN();
    return rc;
}


/****************************************************************************/
// SBCAllocGlyphCache: Allocates glyph cache data buffers according to the
// current negotiated capabilities.
//
// Returns: SBC_GLYPH_CACHE_ENABLED if successful, 0 otherwise.
/****************************************************************************/
unsigned RDPCALL SBCAllocGlyphCache(PCHCACHEHANDLE pCacheHandle)
{
    BOOLEAN rc;
    unsigned i;
    PSBC_GLYPH_CACHE_INFO pGlyphCacheInfo;
    PSBC_FRAG_CACHE_INFO  pFragCacheInfo;
    PCHCACHEDATA pCacheData;

    DC_BEGIN_FN("SBCAllocGlyphCache");

    TRC_NRM((TB, "Alloc glyph cache data"));

    rc = FALSE;

    // Create glyph cache(s).
    if (pddShm->sbc.caps.GlyphSupportLevel > 0) {
        for (i = 0; i < SBC_NUM_GLYPH_CACHES; i++) {
            pGlyphCacheInfo = &(pddShm->sbc.glyphCacheInfo[i]);

            pCacheData = (PCHCACHEDATA)(*pCacheHandle);
            if (SBCCreateGlyphCache(
                    pddShm->sbc.caps.glyphCacheSize[i].cEntries,
                    pddShm->sbc.caps.glyphCacheSize[i].cbCellSize,
                    pCacheData)) {
                TRC_NRM((TB,
                        "Created glyph cache %u: cEntries(%u), cbCellSize(%u)",
                        i,
                        pddShm->sbc.caps.glyphCacheSize[i].cEntries,
                        pddShm->sbc.caps.glyphCacheSize[i].cbCellSize));

                pGlyphCacheInfo->cbCellSize =
                        pddShm->sbc.caps.glyphCacheSize[i].cbCellSize;

                pGlyphCacheInfo->cacheHandle = pCacheData;

                (BYTE *)(*pCacheHandle) += CH_CalculateCacheSize(
                        pddShm->sbc.caps.glyphCacheSize[i].cEntries);

                sbcFontCacheInfoListSize += pddShm->sbc.caps.glyphCacheSize[i].cEntries;

                rc = TRUE;
            }
            else {
                TRC_ERR((TB,
                        "Failed to create glyph cache %u: cEntries(%u), cbCellSize(%u)",
                        i,
                        pddShm->sbc.caps.glyphCacheSize[i].cEntries,
                        pddShm->sbc.caps.glyphCacheSize[i].cbCellSize));

                pGlyphCacheInfo->cbCellSize = 0;
            }
        }

        // Create fragment cache.
        if (rc) {
            pFragCacheInfo = pddShm->sbc.fragCacheInfo;

            pCacheData = (PCHCACHEDATA)(*pCacheHandle);

            if (SBCCreateFragCache(pddShm->sbc.caps.fragCacheSize[0].cEntries,
                    pddShm->sbc.caps.fragCacheSize[0].cbCellSize,
                    pCacheData)) {                    
                pFragCacheInfo->cbCellSize = pddShm->sbc.caps.fragCacheSize[0].
                        cbCellSize;
                pFragCacheInfo->cacheHandle = pCacheData;

                (BYTE*)(*pCacheHandle) += CH_CalculateCacheSize(
                        pddShm->sbc.caps.fragCacheSize[0].cEntries);
            }
            else {
                pFragCacheInfo->cbCellSize = 0;
            }
        }

        // Create the list to store font context info data
        if (rc ) {
            sbcFontCacheInfoList = (PFONTCACHEINFO *) EngAllocMem(0, 
                    sizeof(PFONTCACHEINFO) * sbcFontCacheInfoListSize, 
                    DD_ALLOC_TAG);            
        }
    }

    DC_END_FN();

    return (rc ? SBC_GLYPH_CACHE_ENABLED : 0);
}


/****************************************************************************/
/* Name:      SBCAllocBrushCache                                            */
/*                                                                          */
/* Purpose:   Allocates brush cache data buffers according to the           */
/*            current negotiated capabilities.                              */
/*                                                                          */
/* Returns:   TRUE if successful, FALSE otherwise.                          */
/****************************************************************************/
unsigned RDPCALL SBCAllocBrushCache(PCHCACHEHANDLE pCacheHandle)
{
    BOOLEAN rc = FALSE;
    PCHCACHEDATA pCacheData;

    DC_BEGIN_FN("SBCAllocBrushCache");

    TRC_NRM((TB, "Alloc brush cache data"));

    if (pddShm->sbc.caps.brushSupportLevel > TS_BRUSH_DEFAULT) 
    {
       /********************************************************************/
       /* Allocate brush caches                                            */
       /********************************************************************/
       // small brush cache
       pCacheData = (PCHCACHEDATA) (*pCacheHandle);
       CH_InitCache(pCacheData, SBC_NUM_BRUSH_CACHE_ENTRIES, NULL,
               FALSE, FALSE, NULL);       
       sbcSmallBrushCacheHandle = pCacheData;
       (BYTE *)(*pCacheHandle) += CH_CalculateCacheSize(SBC_NUM_BRUSH_CACHE_ENTRIES);

       // large brush cache
       pCacheData = (PCHCACHEDATA) (*pCacheHandle);
       CH_InitCache(pCacheData, SBC_NUM_BRUSH_CACHE_ENTRIES, NULL,
                FALSE, FALSE, NULL); 
       sbcLargeBrushCacheHandle = pCacheData;
       (BYTE *)(*pCacheHandle) += CH_CalculateCacheSize(SBC_NUM_BRUSH_CACHE_ENTRIES);

       rc = TRUE;
    }   
    
    DC_END_FN();

    return (rc ? SBC_BRUSH_CACHE_ENABLED : 0);
}

/****************************************************************************/
// SBCAllocOffscreenBitmapCache
/****************************************************************************/
unsigned RDPCALL SBCAllocOffscreenBitmapCache(PCHCACHEHANDLE pCacheHandle)
{
    BOOLEAN rc = FALSE;
    PCHCACHEDATA pCacheData;

    DC_BEGIN_FN("SBCAllocOffscreenBitmapCache");

    if (pddShm->sbc.offscreenCacheInfo.supportLevel > TS_OFFSCREEN_DEFAULT) {
        // Allocate memory for offscreen bitmap delete list
        sbcOffscrBitmapsDelList = (PSBC_OFFSCR_BITMAP_DEL_INFO) EngAllocMem(0, 
                sizeof(SBC_OFFSCR_BITMAP_DEL_INFO) * 
                pddShm->sbc.offscreenCacheInfo.cacheEntries, 
                DD_ALLOC_TAG);

        if (sbcOffscrBitmapsDelList) {
            pCacheData = (PCHCACHEDATA) (*pCacheHandle);
            CH_InitCache(pCacheData, pddShm->sbc.offscreenCacheInfo.cacheEntries, NULL,
                         TRUE, FALSE, SBCOffscreenCallback);
            sbcOffscreenBitmapCacheHandle = pCacheData;
            (BYTE *)(*pCacheHandle) += 
                    CH_CalculateCacheSize(pddShm->sbc.offscreenCacheInfo.cacheEntries);

            rc = TRUE;
        } else {
            rc = FALSE;
        }
    }

    DC_END_FN();

    return (rc ? SBC_OFFSCREEN_CACHE_ENABLED : 0);
}

#ifdef DRAW_NINEGRID
/****************************************************************************/
// SBCAllocDrawNineGridBitmapCache
/****************************************************************************/
unsigned RDPCALL SBCAllocDrawNineGridBitmapCache(PCHCACHEHANDLE pCacheHandle)
{
    BOOLEAN rc = FALSE;
    PCHCACHEDATA pCacheData;

    DC_BEGIN_FN("SBCAllocDrawNineGridBitmapCache");

    if (pddShm->sbc.drawNineGridCacheInfo.supportLevel > TS_DRAW_NINEGRID_DEFAULT) {
        pCacheData = (PCHCACHEDATA) (*pCacheHandle);            
        
        CH_InitCache(pCacheData, pddShm->sbc.drawNineGridCacheInfo.cacheEntries, NULL,
                     FALSE, FALSE, NULL);
        sbcDrawNineGridBitmapCacheHandle = pCacheData;
        (BYTE *)(*pCacheHandle) += 
                CH_CalculateCacheSize(pddShm->sbc.drawNineGridCacheInfo.cacheEntries);
    
        rc = TRUE;        
    }

    DC_END_FN();

    return (rc ? SBC_DRAWNINEGRID_CACHE_ENABLED : 0);
}
#endif

#ifdef DRAW_GDIPLUS
/****************************************************************************/
// SBCAllocDrawGdiplusCache
/****************************************************************************/
unsigned RDPCALL SBCAllocDrawGdiplusCache(PCHCACHEHANDLE pCacheHandle)
{
    BOOLEAN rc = FALSE;
    PCHCACHEDATA pCacheData;

    DC_BEGIN_FN("SBCAllocDrawGdiplusCache");

    if ((pddShm->sbc.drawGdiplusInfo.supportLevel > TS_DRAW_GDIPLUS_DEFAULT) &&
        (pddShm->sbc.drawGdiplusInfo.GdipCacheLevel > TS_DRAW_GDIPLUS_CACHE_LEVEL_DEFAULT)) {
        pCacheData = (PCHCACHEDATA) (*pCacheHandle);     

        sbcGdipGraphicsCacheHandle = (PCHCACHEDATA) (*pCacheHandle);
        CH_InitCache(sbcGdipGraphicsCacheHandle, pddShm->sbc.drawGdiplusInfo.GdipCacheEntries.GdipGraphicsCacheEntries, NULL,
                     FALSE, FALSE, NULL);   
        (BYTE *)(*pCacheHandle) += 
                CH_CalculateCacheSize(pddShm->sbc.drawGdiplusInfo.GdipCacheEntries.GdipGraphicsCacheEntries);

        sbcGdipObjectBrushCacheHandle = (PCHCACHEDATA) (*pCacheHandle);
        CH_InitCache(sbcGdipObjectBrushCacheHandle, pddShm->sbc.drawGdiplusInfo.GdipCacheEntries.GdipObjectBrushCacheEntries, NULL,
                     FALSE, FALSE, NULL);       
        (BYTE *)(*pCacheHandle) += 
                CH_CalculateCacheSize(pddShm->sbc.drawGdiplusInfo.GdipCacheEntries.GdipObjectBrushCacheEntries);

        sbcGdipObjectPenCacheHandle = (PCHCACHEDATA) (*pCacheHandle);
        CH_InitCache(sbcGdipObjectPenCacheHandle, pddShm->sbc.drawGdiplusInfo.GdipCacheEntries.GdipObjectPenCacheEntries, NULL,
                     FALSE, FALSE, NULL);
        (BYTE *)(*pCacheHandle) += 
                CH_CalculateCacheSize(pddShm->sbc.drawGdiplusInfo.GdipCacheEntries.GdipObjectPenCacheEntries);

        sbcGdipObjectImageCacheHandle = (PCHCACHEDATA) (*pCacheHandle);
        CH_InitCache(sbcGdipObjectImageCacheHandle, pddShm->sbc.drawGdiplusInfo.GdipCacheEntries.GdipObjectImageCacheEntries, NULL,
                     FALSE, FALSE, NULL);
        (BYTE *)(*pCacheHandle) += 
                CH_CalculateCacheSize(pddShm->sbc.drawGdiplusInfo.GdipCacheEntries.GdipObjectImageCacheEntries);

        sbcGdipObjectImageAttributesCacheHandle = (PCHCACHEDATA) (*pCacheHandle);
        CH_InitCache(sbcGdipObjectImageAttributesCacheHandle, pddShm->sbc.drawGdiplusInfo.GdipCacheEntries.GdipObjectImageAttributesCacheEntries, NULL,
                     FALSE, FALSE, NULL);       
        (BYTE *)(*pCacheHandle) += 
                CH_CalculateCacheSize(pddShm->sbc.drawGdiplusInfo.GdipCacheEntries.GdipObjectImageAttributesCacheEntries);

        sbcGdipGraphicsCacheChunkSize =  pddShm->sbc.drawGdiplusInfo.GdipCacheChunkSize.GdipGraphicsCacheChunkSize;
        sbcGdipObjectBrushCacheChunkSize =  pddShm->sbc.drawGdiplusInfo.GdipCacheChunkSize.GdipObjectBrushCacheChunkSize;
        sbcGdipObjectPenCacheChunkSize =  pddShm->sbc.drawGdiplusInfo.GdipCacheChunkSize.GdipObjectPenCacheChunkSize;
        sbcGdipObjectImageAttributesCacheChunkSize =  pddShm->sbc.drawGdiplusInfo.GdipCacheChunkSize.GdipObjectImageAttributesCacheChunkSize;
        sbcGdipObjectImageCacheChunkSize =  pddShm->sbc.drawGdiplusInfo.GdipImageCacheProperties.GdipObjectImageCacheChunkSize;
        sbcGdipObjectImageCacheMaxSize =  pddShm->sbc.drawGdiplusInfo.GdipImageCacheProperties.GdipObjectImageCacheMaxSize;
        sbcGdipObjectImageCacheTotalSize =  pddShm->sbc.drawGdiplusInfo.GdipImageCacheProperties.GdipObjectImageCacheTotalSize;
        sbcGdipObjectImageCacheSizeUsed =  0;

        sbcGdipObjectImageCacheSizeList = (UINT16 *)EngAllocMem(0, 
            pddShm->sbc.drawGdiplusInfo.GdipCacheEntries.GdipObjectImageCacheEntries * sizeof(UINT16), DD_ALLOC_TAG);
        if (sbcGdipObjectImageCacheSizeList == NULL) {
            rc = FALSE;
            DC_QUIT;
        }

        rc = TRUE;        
    }

    DC_END_FN();
DC_EXIT_POINT:
    return (rc ? SBC_DRAWGDIPLUS_CACHE_ENABLED : 0);
}
#endif // DRAW_GDIPLUS

void RDPCALL SBCAllocCaches(void)
{
    UINT i;
    ULONG cacheSize;
    PCHCACHEDATA pCacheData;

    DC_BEGIN_FN("SBCAllocCaches");

    TRC_NRM((TB, "Alloc SBC cache data"));

    // Initialize cacheSize;
    cacheSize = 0;

    // Calculate glyph fragment cache sizes.
    if (pddShm->sbc.caps.GlyphSupportLevel > 0) {
        for (i = 0; i < SBC_NUM_GLYPH_CACHES; i++)
            cacheSize += CH_CalculateCacheSize(
                    pddShm->sbc.caps.glyphCacheSize[i].cEntries);

        cacheSize += CH_CalculateCacheSize(
                pddShm->sbc.caps.fragCacheSize[0].cEntries);
    }

    if (pddShm->sbc.NumBitmapCaches > 0) {
        UINT totalEntries = 0;

        // Calculate bitmap cache sizes
        for (i = 0; i < pddShm->sbc.NumBitmapCaches; i++) {
            // one for the cache, another for the waiting list
            if (pddShm->sbc.fAllowCacheWaitingList) {
                cacheSize += CH_CalculateCacheSize(
                        pddShm->sbc.bitmapCacheInfo[i].Info.NumEntries) * 2;
            }
            else {
                cacheSize += CH_CalculateCacheSize(
                        pddShm->sbc.bitmapCacheInfo[i].Info.NumEntries);
            }

            totalEntries += pddShm->sbc.bitmapCacheInfo[i].Info.NumEntries;
        }

        // fast path cache
        cacheSize += CH_CalculateCacheSize(totalEntries);

        // Calculate color table cache
        cacheSize += CH_CalculateCacheSize(
                                          SBC_NUM_COLOR_TABLE_CACHE_ENTRIES);
    }

    // Calculate brush cache size
    if (pddShm->sbc.caps.brushSupportLevel > TS_BRUSH_DEFAULT) {
        // both large brush cache and small brush cache
        cacheSize += CH_CalculateCacheSize(SBC_NUM_BRUSH_CACHE_ENTRIES) * 2;
    }

    // Calculate offscreen cache size
    if (pddShm->sbc.offscreenCacheInfo.supportLevel > TS_OFFSCREEN_DEFAULT) {
        cacheSize += CH_CalculateCacheSize(pddShm->sbc.offscreenCacheInfo.cacheEntries);
    }

#ifdef DRAW_NINEGRID
    // Calculate drawstream cache size
    if (pddShm->sbc.drawNineGridCacheInfo.supportLevel > TS_DRAW_NINEGRID_DEFAULT) {
        cacheSize += CH_CalculateCacheSize(pddShm->sbc.drawNineGridCacheInfo.cacheEntries);
    }
#endif

#ifdef DRAW_GDIPLUS
    // Calculate drawgdiplus cache size
    if ((pddShm->sbc.drawGdiplusInfo.supportLevel > TS_DRAW_GDIPLUS_DEFAULT) &&
        (pddShm->sbc.drawGdiplusInfo.GdipCacheLevel > TS_DRAW_GDIPLUS_CACHE_LEVEL_DEFAULT)) {
        cacheSize += CH_CalculateCacheSize(pddShm->sbc.drawGdiplusInfo.GdipCacheEntries.GdipGraphicsCacheEntries);
        cacheSize += CH_CalculateCacheSize(pddShm->sbc.drawGdiplusInfo.GdipCacheEntries.GdipObjectBrushCacheEntries);
        cacheSize += CH_CalculateCacheSize(pddShm->sbc.drawGdiplusInfo.GdipCacheEntries.GdipObjectPenCacheEntries);
        cacheSize += CH_CalculateCacheSize(pddShm->sbc.drawGdiplusInfo.GdipCacheEntries.GdipObjectImageCacheEntries);
        cacheSize += CH_CalculateCacheSize(pddShm->sbc.drawGdiplusInfo.GdipCacheEntries.GdipObjectImageAttributesCacheEntries);
    }
#endif

    // Allocate memory for the cache    
    if (cacheSize)
        sbcCacheData = (PCHCACHEDATA)EngAllocMem(0, cacheSize, DD_ALLOC_TAG);

    DC_END_FN();
}


/****************************************************************************/
// SBC_Update: Allocate and initialize data structures according to the
// current negotiated capabilities.
/****************************************************************************/
void RDPCALL SBC_Update(SBC_BITMAP_CACHE_KEY_INFO *pKeyDatabase)
{
    PCHCACHEDATA pCacheData;

    DC_BEGIN_FN("SBC_Update");

    SBCFreeCacheData();

#ifdef DC_HICOLOR
    // Update the client bits per pel
    sbcClientBitsPerPel = pddShm->sbc.clientBitsPerPel;
    switch (sbcClientBitsPerPel)
    {
        case 24:
        {
            sbcCacheFlags = TS_CacheBitmapRev2_24BitsPerPel;
        }
        break;

        case 15:
        case 16:
        {
            sbcCacheFlags = TS_CacheBitmapRev2_16BitsPerPel;
        }
        break;

        default:
        {
            sbcCacheFlags = TS_CacheBitmapRev2_8BitsPerPel;
        }
        break;
    }
#endif

    if (pddShm->sbc.fCachingEnabled) {
        TRC_NRM((TB, "Alloc cache data"));

        sbcEnabled = SBC_NO_CACHE_ENABLED;

        SBCAllocCaches();
        if (sbcCacheData) {
            pCacheData = sbcCacheData;

            // Create glyph and fragment cache(s).
            sbcEnabled |= SBCAllocGlyphCache(&pCacheData);

            // Create bitmap cache(s), work bitmaps, and color table cache.
            sbcEnabled |= SBCAllocBitmapCache(&pCacheData);

            // We expect the key database to have come to us by the time we get
            // here.
            if (sbcEnabled & SBC_BITMAP_CACHE_ENABLED) {
                if (pKeyDatabase != NULL)
                    SBCProcessBitmapKeyDatabase(pKeyDatabase);
            }

            // Create brush cache.
            sbcEnabled |= SBCAllocBrushCache(&pCacheData);
            if (!(sbcEnabled & SBC_BRUSH_CACHE_ENABLED))
                pddShm->sbc.caps.brushSupportLevel = TS_BRUSH_DEFAULT;

            sbcEnabled |= SBCAllocOffscreenBitmapCache(&pCacheData);

            if (!(sbcEnabled & SBC_OFFSCREEN_CACHE_ENABLED)) {
                pddShm->sbc.offscreenCacheInfo.supportLevel = 
                        TS_OFFSCREEN_DEFAULT;
            }

#ifdef DRAW_NINEGRID
            sbcEnabled |= SBCAllocDrawNineGridBitmapCache(&pCacheData);

            if (!(sbcEnabled & SBC_DRAWNINEGRID_CACHE_ENABLED)) {
                pddShm->sbc.drawNineGridCacheInfo.supportLevel = 
                        TS_DRAW_NINEGRID_DEFAULT;
            }
#endif
#ifdef DRAW_GDIPLUS
            sbcEnabled |= SBCAllocDrawGdiplusCache(&pCacheData);

            if (!(sbcEnabled & SBC_DRAWGDIPLUS_CACHE_ENABLED)) {
                pddShm->sbc.drawGdiplusInfo.GdipCacheLevel = TS_DRAW_GDIPLUS_CACHE_LEVEL_DEFAULT;
            }
#endif
        }
        else {
            // Force brush cache disabled to prevent use of the caches.
            pddShm->sbc.caps.brushSupportLevel = TS_BRUSH_DEFAULT;

            // Force offscreen cache disabled
            pddShm->sbc.offscreenCacheInfo.supportLevel = 
                    TS_OFFSCREEN_DEFAULT;

#ifdef DRAW_NINEGRID
            // Force drawstream cache disabled
            pddShm->sbc.drawNineGridCacheInfo.supportLevel = 
                    TS_DRAW_NINEGRID_DEFAULT;
#endif
        }
    }
    else {
        // Force brush cache disabled to prevent use of the caches.
        pddShm->sbc.caps.brushSupportLevel = TS_BRUSH_DEFAULT;

        // Force offscreen cache disabled
        pddShm->sbc.offscreenCacheInfo.supportLevel = 
                TS_OFFSCREEN_DEFAULT;

#ifdef DRAW_NINEGRID
        // Force drawstream cache disabled
        pddShm->sbc.drawNineGridCacheInfo.supportLevel = 
                TS_DRAW_NINEGRID_DEFAULT;
#endif

    }

    pddShm->sbc.newCapsData = FALSE;

    DC_END_FN();
}


/****************************************************************************/
// SBCFreeGlyphCacheData: Free glyph cache data buffers.
/****************************************************************************/
__inline void RDPCALL SBCFreeGlyphCacheData(void)
{
    unsigned i;
    PSBC_GLYPH_CACHE_INFO pGlyphCacheInfo;
    PSBC_FRAG_CACHE_INFO  pFragCacheInfo;

    DC_BEGIN_FN("SBCFreeGlyphCacheData");

    TRC_NRM((TB, "Free glyph cache data"));

    // Free glyph cache(s).
    for (i = 0; i < SBC_NUM_GLYPH_CACHES; i++) {
        pGlyphCacheInfo = &(pddShm->sbc.glyphCacheInfo[i]);

        if (pGlyphCacheInfo->cacheHandle != NULL) {
            CH_ClearCache(pGlyphCacheInfo->cacheHandle);
            pGlyphCacheInfo->cacheHandle = NULL;
            pGlyphCacheInfo->cbCellSize = 0;
        }
    }

    // Free fragment cache.
    pFragCacheInfo = pddShm->sbc.fragCacheInfo;

    if (pFragCacheInfo->cacheHandle != NULL) {
        CH_ClearCache(pFragCacheInfo->cacheHandle);
        pFragCacheInfo->cacheHandle = NULL;
        pFragCacheInfo->cbCellSize = 0;
    }

    // Free the font cache info list
    if (sbcFontCacheInfoList != 0) {
        // Reset all the font cache info to 0.
        for (i = 0; i < sbcFontCacheInfoListIndex; i++) {
            if (sbcFontCacheInfoList[i] != 0) {
                memset(sbcFontCacheInfoList[i], 0, sizeof(FONTCACHEINFO));
            }
        }

        // Free the font cache info list
        EngFreeMem(sbcFontCacheInfoList);
        sbcFontCacheInfoList = 0;
        sbcFontCacheInfoListSize = 0;
        sbcFontCacheInfoListIndex = 0;        
    }

    sbcEnabled &= ~SBC_GLYPH_CACHE_ENABLED;

    DC_END_FN();
}


/****************************************************************************/
/* Name:      SBCFreeBrushCacheData                                         */
/*                                                                          */
/* Purpose:   Free brush cache data buffers.                                */
/****************************************************************************/
void RDPCALL SBCFreeBrushCacheData(void)
{
    DC_BEGIN_FN("SBCFreeBrushCacheData");

    TRC_NRM((TB, "Free brush cache data"));

    /************************************************************************/
    /* Free brush cache                                                     */
    /************************************************************************/
    if (sbcSmallBrushCacheHandle != 0)
    {
        CH_ClearCache(sbcSmallBrushCacheHandle);
        sbcSmallBrushCacheHandle = 0;
    }
    
    if (sbcLargeBrushCacheHandle != 0)
    {
        CH_ClearCache(sbcLargeBrushCacheHandle);
        sbcLargeBrushCacheHandle = 0;
    }

    sbcEnabled &= ~SBC_BRUSH_CACHE_ENABLED;

    DC_END_FN();
}

/****************************************************************************/
// SBCFreeOffscreenBitmapCacheData                               
/****************************************************************************/
void RDPCALL SBCFreeOffscreenBitmapCacheData(void)
{
    DC_BEGIN_FN("SBCFreeOffscreenBitmapCacheData");

    TRC_NRM((TB, "Free offscreen Bitmap cache data"));

    /************************************************************************/
    /* Free Offscreen cache                                                 */
    /************************************************************************/
    if (pddShm->sbc.offscreenCacheInfo.supportLevel > TS_OFFSCREEN_DEFAULT)
    {
        CH_ClearCache(sbcOffscreenBitmapCacheHandle);
    }
    
    sbcOffscreenBitmapCacheHandle = 0;
    
    // Free the offscreen bitmap delete list
    if (sbcOffscrBitmapsDelList != 0) {
        EngFreeMem(sbcOffscrBitmapsDelList);
        sbcOffscrBitmapsDelList = 0;
        sbcNumOffscrBitmapsToDelete = 0;
        sbcOffscrBitmapsToDeleteSize = 0;
    }

    sbcEnabled &= ~SBC_OFFSCREEN_CACHE_ENABLED;

    DC_END_FN();
}

#ifdef DRAW_NINEGRID
/****************************************************************************/
// SBCFreeDrawNineGridBitmapCacheData                               
/****************************************************************************/
void RDPCALL SBCFreeDrawNineGridBitmapCacheData(void)
{
    DC_BEGIN_FN("SBCFreeDrawNineGridBitmapCacheData");

    TRC_NRM((TB, "Free drawsninegrid Bitmap cache data"));

    /************************************************************************/
    // Free DrawNineGrid cache                                                 
    /************************************************************************/
    if (pddShm->sbc.drawNineGridCacheInfo.supportLevel > TS_DRAW_NINEGRID_DEFAULT)
    {
        CH_ClearCache(sbcDrawNineGridBitmapCacheHandle);
    }
    
    sbcDrawNineGridBitmapCacheHandle = 0;
    
    sbcEnabled &= ~SBC_DRAWNINEGRID_CACHE_ENABLED;

    DC_END_FN();
}
#endif

#ifdef DRAW_GDIPLUS
/****************************************************************************/
// SBCFreeDrawGdiplusCacheData                               
/****************************************************************************/
void RDPCALL SBCFreeDrawGdiplusCacheData(void)
{
    DC_BEGIN_FN("SBCFreeDrawGdiplusCacheData");

    TRC_NRM((TB, "Free drawgdiplus cache data"));

    /************************************************************************/
    // Free DrawGdiplus cache                                                 
    /************************************************************************/
    if ((pddShm->sbc.drawGdiplusInfo.supportLevel > TS_DRAW_GDIPLUS_DEFAULT) &&
        (pddShm->sbc.drawGdiplusInfo.GdipCacheLevel > TS_DRAW_GDIPLUS_CACHE_LEVEL_DEFAULT))
    {
        CH_ClearCache(sbcGdipGraphicsCacheHandle);
        CH_ClearCache(sbcGdipObjectBrushCacheHandle);
        CH_ClearCache(sbcGdipObjectPenCacheHandle);
        CH_ClearCache(sbcGdipObjectImageCacheHandle);
        CH_ClearCache(sbcGdipObjectImageAttributesCacheHandle);
        EngFreeMem(sbcGdipObjectImageCacheSizeList);
    }
    
    sbcGdipGraphicsCacheHandle = 0;
    
    sbcEnabled &= ~SBC_DRAWGDIPLUS_CACHE_ENABLED;

    DC_END_FN();
}
#endif // DRAW_GDIPLUS

/****************************************************************************/
// SBCFreeBitmapCacheData: Free bitmap cache data buffers.
/****************************************************************************/
__inline void RDPCALL SBCFreeBitmapCacheData(void)
{
    unsigned i;
    PSBC_BITMAP_CACHE_INFO pBitmapCacheInfo;

    DC_BEGIN_FN("SBCFreeBitmapCacheData");

    TRC_NRM((TB, "Free bitmap cache data"));

    // Free cell caches.
    for (i = 0; i < pddShm->sbc.NumBitmapCaches; i++) {
        pBitmapCacheInfo = &(pddShm->sbc.bitmapCacheInfo[i]);

        // Destroy the work bitmap.
        if (pBitmapCacheInfo->hWorkBitmap != NULL) {
            // The bitmap has been created, so now destroy it. Despite its
            // name, EngDeleteSurface is the correct function to do this.
            if (EngDeleteSurface(pBitmapCacheInfo->hWorkBitmap))
            {
                TRC_NRM((TB, "Deleted work bitmap %d", i));
            }
            else
            {
                TRC_ERR((TB, "Failed to delete work bitmap %d", i));
            }
            pBitmapCacheInfo->hWorkBitmap = NULL;
        }

        if (pBitmapCacheInfo->cacheHandle != NULL) {
            CH_ClearCache(pBitmapCacheInfo->cacheHandle);
            pBitmapCacheInfo->cacheHandle = NULL;
        }

        if (pBitmapCacheInfo->waitingListHandle != NULL) {
            CH_ClearCache(pBitmapCacheInfo->waitingListHandle);
            pBitmapCacheInfo->waitingListHandle = NULL;
        }
        
#ifdef DC_DEBUG
        // Free the bitmap header buffer.
        if (pBitmapCacheInfo->pExtraEntryInfo != NULL) {
            EngFreeMem(pBitmapCacheInfo->pExtraEntryInfo);
            pBitmapCacheInfo->pExtraEntryInfo = NULL;
        }
#endif

    }

    if (pddShm->sbc.hFastPathCache != NULL) {
        CH_ClearCache(pddShm->sbc.hFastPathCache);
        pddShm->sbc.hFastPathCache = NULL;
    }

    // Free colortable cache.
    if (sbcColorTableCacheHandle != NULL) {
        CH_ClearCache(sbcColorTableCacheHandle);
        sbcColorTableCacheHandle = NULL;
    }

    // Destroy the 4bpp to 8bpp translation buffer, if present.
    if (sbcXlateBuf != NULL) {
        EngFreeMem(sbcXlateBuf);
        sbcXlateBuf = NULL;
    }

    sbcEnabled &= ~SBC_BITMAP_CACHE_ENABLED;

    DC_END_FN();
}


/****************************************************************************/
// SBCFreeCacheData: Free cache data buffers.
/****************************************************************************/
void RDPCALL SBCFreeCacheData(void)
{
    DC_BEGIN_FN("SBCFreeCacheData");

    TRC_NRM((TB, "Free cache data"));

    if (sbcEnabled != SBC_NO_CACHE_ENABLED) {
        // Free glyph and fragment caches.
        if (sbcEnabled & SBC_GLYPH_CACHE_ENABLED)
            SBCFreeGlyphCacheData();

        // Free bitmap cache(s) and color table cache.
        if (sbcEnabled & SBC_BITMAP_CACHE_ENABLED)
            SBCFreeBitmapCacheData();

        // Free brush caches.
        if (sbcEnabled & SBC_BRUSH_CACHE_ENABLED) {
            SBCFreeBrushCacheData();
        }

        // Free offscreen cache
        if (sbcEnabled & SBC_OFFSCREEN_CACHE_ENABLED) {
            SBCFreeOffscreenBitmapCacheData();
        }

#ifdef DRAW_NINEGRID
        // Free drawstream cache
        if (sbcEnabled & SBC_DRAWNINEGRID_CACHE_ENABLED) {
            SBCFreeDrawNineGridBitmapCacheData();
        }
#endif

#ifdef DRAW_GDIPLUS
        // Free drawgdiplus cache
        if (sbcEnabled & SBC_DRAWGDIPLUS_CACHE_ENABLED) {
            SBCFreeDrawGdiplusCacheData();
        }
#endif

        if (sbcCacheData) {
            EngFreeMem(sbcCacheData);
            sbcCacheData = NULL;
        }

        TRC_ASSERT((sbcEnabled == SBC_NO_CACHE_ENABLED),
                   (TB, "sbcEnabled should be disabled: %lx", sbcEnabled));
    }

    DC_END_FN();
}


/****************************************************************************/
// SBC_DDSync
//
// Performs a server-initiated sync, which occurs during the client connection
// sequence after the client responds with a ConfirmActivePDU, the persistent
// bitmap keys, and the font list PDUs. In RDP 4.0 a server-side sync would
// have reset all the caches. In this version we have to be more careful since
// we absolutely do not want to lose any of the current bitmap cache
// information, which includes persistent as well as new keys added since
// connection time.
//
// bMustSync is currently used by DrvShadowConnect() only
/****************************************************************************/
void RDPCALL SBC_DDSync(BOOLEAN bMustSync)
{
    unsigned i;

    DC_BEGIN_FN("SBC_DDSync");

    if ((sbcEnabled != SBC_NO_CACHE_ENABLED) && bMustSync) {
        TRC_ALT((TB, "Sync: resetting caches"));
        
        // Reset the glyph and fragment caches.
        if (sbcEnabled & SBC_GLYPH_CACHE_ENABLED) {
            for (i = 0; i < SBC_NUM_GLYPH_CACHES; i++) {
                if (pddShm->sbc.glyphCacheInfo[i].cacheHandle != NULL)
                    CH_ClearCache(pddShm->sbc.glyphCacheInfo[i].cacheHandle);
            }
            TRC_NRM((TB, "Sync: reset glyph info caches"));

            if (pddShm->sbc.fragCacheInfo[0].cacheHandle != NULL) {
                CH_ClearCache(pddShm->sbc.fragCacheInfo[0].cacheHandle);
                TRC_NRM((TB, "Sync: reset glyph fragment cache"));
            }
        }

        // Reset the brush caches.
        if (sbcEnabled & SBC_BRUSH_CACHE_ENABLED)
        {
            if (sbcSmallBrushCacheHandle) {
                TRC_NRM((TB, "Sync: reset small brush cache"));
                CH_ClearCache(sbcSmallBrushCacheHandle);
            }
            if (sbcLargeBrushCacheHandle) {
                TRC_NRM((TB, "Sync: reset large brush cache"));
                CH_ClearCache(sbcLargeBrushCacheHandle);
            }
        }
        
        // Reset the bitmap, fastpath, and color table caches.
        if (sbcEnabled & SBC_BITMAP_CACHE_ENABLED) {
            for (i = 0; i < pddShm->sbc.NumBitmapCaches; i++)
                if (pddShm->sbc.bitmapCacheInfo[i].cacheHandle != NULL) {
                    TRC_NRM((TB, "Sync: reset bitmap cache[%ld]", i));
                    CH_ClearCache(pddShm->sbc.bitmapCacheInfo[i].cacheHandle);
                }

            if (pddShm->sbc.hFastPathCache != NULL) {
                TRC_NRM((TB, "Sync: reset fast path bitmap"));
                CH_ClearCache(pddShm->sbc.hFastPathCache);
            }

            // Reset the color table cache.
            if (sbcColorTableCacheHandle != NULL) {
                CH_ClearCache(sbcColorTableCacheHandle);
                TRC_NRM((TB, "Sync: reset color table cache"));
            }
        }

        // Pretend that the palette has changed, so we send a color table
        // before our next MemBlt.
        SBC_PaletteChanged();
    }
    else {
        TRC_NRM((TB, "Nothing to do sbcEnabled(%lx), bMustSync(%ld)",
                sbcEnabled, bMustSync));
    }

    // Reset the sync flag.
    pddShm->sbc.syncRequired = FALSE;

    DC_END_FN();
}


/****************************************************************************/
// SBCSelectGlyphCache: Decides which cache a given max font glyph size
// should go in.
//
// Returns:   TRUE if the glyph size can be cached
//            *pCache is updated with the index of the selected cache
//
//            FALSE if the glyph size cannot be cached
//            *pCache is -1
//
// Params:    cbSize - size in bytes of the data to be cached
//
//            pCache - pointer to variable that receives the cache index
//            to use
/****************************************************************************/
BOOLEAN RDPCALL SBCSelectGlyphCache(unsigned cbSize, PINT32 pCache)
{
    int i;
    INT32 cacheId;
    BOOLEAN rc;
    unsigned cbCellSize;
    unsigned cbUseCount;

    DC_BEGIN_FN("SBCSelectGlyphCache");

    *pCache = -1;

    cbUseCount = 0;
    cbCellSize = 65535;

    for (i = 0; i < SBC_NUM_GLYPH_CACHES; i++) {
        if (pddShm->sbc.glyphCacheInfo[i].cbCellSize >= cbSize) {
            if (pddShm->sbc.glyphCacheInfo[i].cbCellSize < cbCellSize) {
                *pCache = i;

                cbCellSize = pddShm->sbc.glyphCacheInfo[i].cbCellSize;
                cbUseCount = pddShm->sbc.glyphCacheInfo[i].cbUseCount;
            }
            else if (pddShm->sbc.glyphCacheInfo[i].cbCellSize == cbCellSize) {
                if (pddShm->sbc.glyphCacheInfo[i].cbUseCount <= cbUseCount) {
                    *pCache = i;

                    cbCellSize = pddShm->sbc.glyphCacheInfo[i].cbCellSize;
                    cbUseCount = pddShm->sbc.glyphCacheInfo[i].cbUseCount;
                }
            }
        }
    }

    if (*pCache != -1) {
        rc = TRUE;
    }
    else {
        TRC_ALT((TB, "Failed to find cache for cbSize(%u)", cbSize));
        rc = FALSE;
    }

    DC_END_FN();
    return rc;
}


/****************************************************************************/
// SBCDDGetTickCount: Get a system tick count.
//
// Returns: The number of centi-seconds since the system was started.
//          This number will wrap after approximately 497 days!
/****************************************************************************/
__inline UINT32 RDPCALL SBCDDGetTickCount(void)
{
    LONGLONG perfTickCount;

    /************************************************************************/
    /* Get the number of system ticks since the system was started.         */
    /************************************************************************/
    EngQueryPerformanceCounter(&perfTickCount);

    /************************************************************************/
    /* Now convert this into a number of centi-seconds.  sbcPerfFrequency   */
    /* contains the number of system ticks per second.                      */
    /************************************************************************/
    return (UINT32)(perfTickCount & 0xFFFFFFFF);
}


/****************************************************************************/
// SBCBitmapCacheCallback
//
// Called whenever an entry is evicted from the bitmap cache.
//
// Params: hCache - cache handle
//
//         event - the cache event that has occurred.
//
//         iCacheEntry - index of the cache entry that the event is affecting
//
//         pData - pointer to the cache data associated with the given
//         cache entry
//
//         UserDefined - user-supplied value from CH_CacheKey
/****************************************************************************/
BOOLEAN __fastcall SBCBitmapCacheCallback(
        CHCACHEHANDLE hCache,
        unsigned      Event,
        unsigned      iCacheEntry,
        void          *UserDefined)
{
    DC_BEGIN_FN("SBCBitmapCacheCallback");

    if (Event == CH_EVT_ENTRYREMOVED) {
        TRC_NRM((TB, "Cache entry removed hCache(%p) iCacheEntry(%u)",
                hCache, iCacheEntry));

        // Keep the fast path cache in sync by removing the
        // corresponding fast path entry.
        if (UserDefined != NULL) {
            CH_SetNodeUserDefined((CHNODE *)UserDefined, NULL);
            CH_RemoveCacheEntry(pddShm->sbc.hFastPathCache,
                    CH_GetCacheIndexFromNode((CHNODE *)UserDefined));

            TRC_NRM((TB, "Remove fastpath entry %u",
                    CH_GetCacheIndexFromNode((CHNODE *)UserDefined)));
        }
    }

    DC_END_FN();
    return TRUE;
}


/****************************************************************************/
// SBCFastPathCacheCallback
//
// Called whenever an entry is evicted from the cache.
//
// Params: hCache - cache handle
//
//         Event - the cache event that has occured
//
//         iCacheEntry - index of the cache entry that the event is affecting
//
//         UserDefined - value passed in when entry was placed in cache.
/****************************************************************************/
BOOLEAN __fastcall SBCFastPathCacheCallback(
        CHCACHEHANDLE hCache,
        unsigned      Event,
        unsigned      iCacheEntry,
        void          *UserDefined)
{
    DC_BEGIN_FN("SBCFastPathCacheCallback");

    if (Event == CH_EVT_ENTRYREMOVED) {
        TRC_NRM((TB, "Fastpath cache entry removed hCache(%p) "
                "iCacheEntry(%u)", hCache, iCacheEntry));

        if (UserDefined != NULL) {
            // We are losing a fast-path cache entry. UserDefined is a
            // pointer to the node in the main cache corresponding to this
            // fast path entry. Update the main cache entry with a NULL
            // UserDefined to indicate there is no longer an associated
            // fast-path entry.
            CH_SetNodeUserDefined((CHNODE *)UserDefined, NULL);
        }
    }

    DC_END_FN();
    return TRUE;
}


/****************************************************************************/
// SBCGlyphCallback
//
// Called whenever an entry is to be evicted from the cache.
//
// Params: hCache - cache handle
//
//         Event - the cache event that has occured
//
//         iCacheEntry - index of the cache entry that the event is affecting
//
//         UserDefined - value passed in when entry was placed in cache.
/****************************************************************************/
BOOLEAN __fastcall SBCGlyphCallback(
        CHCACHEHANDLE hCache,
        unsigned      event,
        unsigned      iCacheEntry,
        void          *UserDefined)
{
    BOOLEAN rc;
    unsigned i;
    PGLYPHCONTEXT pglc;

    DC_BEGIN_FN("SBCGlyphCallback");

    rc = TRUE;

    switch (event) {
        /********************************************************************/
        /* We are being asked if the given entry can be evicted from the    */
        /* cache.                                                           */
        /********************************************************************/
        case CH_EVT_QUERYREMOVEENTRY:
            pglc = (PGLYPHCONTEXT)CH_GetCacheContext(hCache);
            if (pglc != NULL && (UINT_PTR)UserDefined == pglc->cacheTag)
                rc = FALSE;
            break;
    }

    DC_END_FN();
    return rc;
}


/****************************************************************************/
// SBCOffscreenCallback
//
// Called whenever an entry is to be evicted from the cache.
//
// Params: hCache - cache handle
//
//         Event - the cache event that has occured
//
//         iCacheEntry - index of the cache entry that the event is affecting
//
//         UserDefined - value passed in when entry was placed in cache.
/****************************************************************************/
BOOLEAN __fastcall SBCOffscreenCallback(
        CHCACHEHANDLE hCache,
        unsigned      event,
        unsigned      iCacheEntry,
        void          *UserDefined)
{
    BOOLEAN rc;
    unsigned bitmapSize;
    PGLYPHCONTEXT pglc;

    DC_BEGIN_FN("SBCOffscreenCallback");

    if (event == CH_EVT_ENTRYREMOVED) {
        TRC_NRM((TB, "Offscreen cache entry removed hCache(%p) "
                "iCacheEntry(%u)", hCache, iCacheEntry));

        if (UserDefined != NULL) {
            // We are losing an offscreen cache entry. UserDefined is a
            // handle to the offscreen bitmap that's going to be evicted. 
            // We need to set the flag to noOffscreen for this bitmap  
            ((PDD_DSURF)UserDefined)->flags |= DD_NO_OFFSCREEN;

            // Get the bitmap size
            // The assumption here is that iFormat is > 1BPP, i << iFormat
            // gives the actual bits per pel.  bitmapSize is in bytes.
            if (((PDD_DSURF)UserDefined)->iBitmapFormat < 5) {
                bitmapSize = ((PDD_DSURF)UserDefined)->sizl.cx *
                    ((PDD_DSURF)UserDefined)->sizl.cy *
                    (1 << ((PDD_DSURF)UserDefined)->iBitmapFormat) / 8;
            }
            else if (((PDD_DSURF)UserDefined)->iBitmapFormat == 5) {
                bitmapSize = ((PDD_DSURF)UserDefined)->sizl.cx *
                    ((PDD_DSURF)UserDefined)->sizl.cy * 24 / 8;
            }
            else {
                bitmapSize = ((PDD_DSURF)UserDefined)->sizl.cx *
                    ((PDD_DSURF)UserDefined)->sizl.cy * 32 / 8;
            }

            // Current cache size
            oeCurrentOffscreenCacheSize -= bitmapSize;

            // Add this bitmap to the offscreen bitmap delete list
            sbcOffscrBitmapsDelList[sbcNumOffscrBitmapsToDelete].bitmapId = iCacheEntry;
            sbcOffscrBitmapsDelList[sbcNumOffscrBitmapsToDelete].bitmapSize = bitmapSize;

            // Update the delete list data
            sbcNumOffscrBitmapsToDelete++;
            sbcOffscrBitmapsToDeleteSize += bitmapSize;
        }
    }

    DC_END_FN();
    return TRUE;
}


BOOLEAN RDPCALL SBC_CopyToWorkBitmap(
	    SURFOBJ  *pWorkSurf,
	    PMEMBLT_ORDER_EXTRA_INFO pMemBltInfo,
	    unsigned cxSubBitmapWidth,
        unsigned cySubBitmapHeight,
        PPOINTL  ptileOrigin,
        RECTL    *pDestRect)
{
    BOOLEAN     rc = FALSE;
    RECTL       destRectl;
    unsigned    yLastSrcRow;

    DC_BEGIN_FN("SBC_CopyToWorkBitmap");

    // Do the Blt to our work bitmap to perform any color/format
    // conversions to get to screen format.
    //
    // We fiddle with the coords so that the data we want begins at
    // the first byte of the work bitmap (which is the BOTTOM, as the
    // bitmap is stored in bottom-up format).
    //
    // Note that destRectl is in exclusive coords.
    destRectl.top    = pMemBltInfo->TileSize - cySubBitmapHeight;
    destRectl.left   = 0;
    destRectl.right  = cxSubBitmapWidth;
    destRectl.bottom = pMemBltInfo->TileSize;

    // Clip the operation so that EngBitBlt does not try to copy any
    // data from outside the source bitmap (it crashes if you try it!).
    TRC_ASSERT((ptileOrigin->y <
            pMemBltInfo->pSource->sizlBitmap.cy),
            (TB, "Invalid tileOrigin.y(%d) sizlBitmap.cy(%d)",
            ptileOrigin->y, pMemBltInfo->pSource->sizlBitmap.cy));
    yLastSrcRow = ptileOrigin->y + (cySubBitmapHeight - 1);
    if ((int)yLastSrcRow > (pMemBltInfo->pSource->sizlBitmap.cy - 1)) {
        destRectl.bottom -= ((int)yLastSrcRow -
                (pMemBltInfo->pSource->sizlBitmap.cy - 1));
        TRC_ALT((TB, "Clip source from (%d) to (%d)",
                cySubBitmapHeight, destRectl.bottom));
    }

    TRC_NRM((TB, "Blt to work bitmap from src point (%d,%d)",
            ptileOrigin->x, ptileOrigin->y));

    // Reset the work bitmap bits that we will be using if the copied
    // data will not completely fill the area that we are going to
    // cache (there may be some empty space to the right of the bitmap).
    // This ensures that every time a bitmap is cached it has the
    // same (zero) pad bytes and will match previously cached entries.
    // It also aids compression (if enabled).
    if ((destRectl.right - destRectl.left) < (int)pMemBltInfo->TileSize) {
        unsigned cbResetBytes;

        // The lDelta field in the SURFOBJ is negative because the
        // bitmap is a "bottom-up" DIB.
        cbResetBytes = (unsigned)((-pWorkSurf->lDelta) *
                (destRectl.bottom - destRectl.top));

        TRC_NRM((TB, "Reset %u bytes in work bitmap", cbResetBytes));

        TRC_ASSERT((cbResetBytes <= pWorkSurf->cjBits),
                   (TB, "cbResetBytes(%u) too big (> %u) lDelta(%d)",
                     cbResetBytes, pWorkSurf->cjBits, pWorkSurf->lDelta));

        memset(pWorkSurf->pvBits, 0, cbResetBytes);
    }

    TRC_ASSERT(((destRectl.left >= 0) &&
           (destRectl.top  >= 0) &&
           (destRectl.right <= pWorkSurf->sizlBitmap.cx) &&
           (destRectl.bottom <= pWorkSurf->sizlBitmap.cy)),
           (TB, "destRect(%d, %d, %d, %d) exceeds bitmap(%d, %d)",
           destRectl.left, destRectl.top, destRectl.right,
           destRectl.bottom, pWorkSurf->sizlBitmap.cx,
           pWorkSurf->sizlBitmap.cy));

    // Now we have to fill in the backdrop bits for delta RLE bitmaps.
    // We just grab screen bits from the screen bitmap to fill in the
    // extents of the incoming bitmap.
    if (pMemBltInfo->bDeltaRLE) {
        POINTL ScrOrigin;

        ScrOrigin.x = pDestRect->left;
        ScrOrigin.y = pDestRect->top;

        // Need to adjust the coordinates 
        if (ScrOrigin.y < 0) {
            destRectl.top += (0 - ScrOrigin.y);
            ScrOrigin.y = 0;             
        }

        destRectl.bottom = min(destRectl.bottom,
                (pMemBltInfo->pDest->sizlBitmap.cy - 
                ScrOrigin.y + destRectl.top));

        // SRCCOPY screen to work bitmap. Note we use no XlateObj since
        // the color schemes should be the same.
        if (EngCopyBits(pWorkSurf, pMemBltInfo->pDest, NULL, NULL,
                &destRectl, &ScrOrigin)) {
            TRC_NRM((TB,"Blt screen->tile for RLE delta backdrop, "
                    "scr src=(%d,%d)", pDestRect->left,
                    pDestRect->top));
        }
        else {
            TRC_ERR((TB,"Failed to blt screen data for RLE delta"));
            DC_QUIT;
        }
    }

    // SRCCOPY the final bits to the work bitmap.
    if (!EngCopyBits(pWorkSurf, pMemBltInfo->pSource, NULL,
            pMemBltInfo->pXlateObj, &destRectl, ptileOrigin)) {
        TRC_ERR((TB, "Failed to Blt to work bitmap"));
        DC_QUIT;
    }

    TRC_DBG((TB, "Completed CopyBits"));

    rc = TRUE;

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}


/****************************************************************************/
// SBC_CacheBitmapTile
//
// Caches the tiled bitmap data for the provided blt info. Returns: TRUE if
// the data is already cached, or successfully cached and a Cache Bitmap order
// sent. SrcRect and DestRect are in exclusive coordinates. Returns FALSE
// if the Cache Bitmap order allocation fails.
/****************************************************************************/
BOOLEAN RDPCALL SBC_CacheBitmapTile(
        PDD_PDEV ppdev,
        PMEMBLT_ORDER_EXTRA_INFO pMemBltInfo,
        RECTL *pSrcRect,
        RECTL *pDestRect)
{
    BOOLEAN rc = FALSE;
    BOOLEAN fSearchFastPath;
    BOOLEAN fFastPathMatch;
    POINTL tileOrigin;
    unsigned cxSubBitmapWidth, cySubBitmapHeight;
    unsigned fastPathIndex;
    SURFOBJ *pWorkSurf = NULL;
    void *UserDefined;
    CHDataKeyContext CHContext;

    DC_BEGIN_FN("SBC_CacheBitmapTile");

    pddCacheStats[BITMAP].CacheReads++;

    TRC_NRM((TB, "Request to cache MemBlt (%d, %d), %d x %d -> (%d, %d), "
            "src %p", pSrcRect->left, pSrcRect->top,
            pSrcRect->right - pSrcRect->left,
            pSrcRect->bottom - pSrcRect->top,
            pDestRect->left, pDestRect->top,
            pMemBltInfo->pSource->hsurf));
    TRC_NRM((TB, "bmpWidth(%u) bmpHeight(%u) TileSize(%u)",
            pMemBltInfo->pSource->sizlBitmap.cx,
            pMemBltInfo->pSource->sizlBitmap.cy,
            pMemBltInfo->TileSize));

    // In stress, we have seen cases where fCachingEnabled is NULL when called
    // in this code path from OEEncodeMemBlt
    if (!pddShm->sbc.fCachingEnabled) {
        DC_QUIT;
    }

    // Calculate the tile origin within the source bitmap coordinates and
    // the size of the remaining bitmap. Origin is rounded down to the
    // nearest tile. Actual size of bitmap to cache may be smaller than
    // tile size if the tile runs off the right/bottom of the bitmap.
    // Note that since TileSize is a power of 2, we can accelerate the
    // modulo operation.
    tileOrigin.x = pSrcRect->left - (pSrcRect->left &
            (pMemBltInfo->TileSize - 1));
    tileOrigin.y = pSrcRect->top - (pSrcRect->top &
            (pMemBltInfo->TileSize - 1));

    // Actual size of bitmap to cache may be smaller than tile size if the
    // tile runs off the right/bottom of the bitmap. To see why this
    // calculation is correct, realize that (bmpWidth - tileOrigin.x) is
    // the remaining width of the bitmap after the start of this tile.
    cxSubBitmapWidth  = min(pMemBltInfo->TileSize,
            (unsigned)(pMemBltInfo->pSource->sizlBitmap.cx - tileOrigin.x));
    cySubBitmapHeight = min(pMemBltInfo->TileSize,
            (unsigned)(pMemBltInfo->pSource->sizlBitmap.cy - tileOrigin.y));

    // We need not search the fast-path cache if we've forced fastpath off.
    fSearchFastPath = !pMemBltInfo->bNoFastPathCaching;
    fFastPathMatch = FALSE;

    // The BMF_DONTCACHE flag indicates that the source surface is an
    // application-controlled DIB. The iUniq flag can therefore not be
    // used to determine if/when the bitmap is updated, and we 
    // cannot use fastpathing to handle this surface.
    if (pMemBltInfo->pSource->iType == STYPE_BITMAP &&
            pMemBltInfo->pSource->fjBitmap & BMF_DONTCACHE) {
        TRC_NRM((TB, "Source hsurf(%p) has BMF_DONTCACHE set",
                pMemBltInfo->pSource->hsurf));
        fSearchFastPath = FALSE;
    }

    if (fSearchFastPath) {
        SBC_FAST_PATH_INFO fastPathInfo;

        fastPathInfo.hsurf = pMemBltInfo->pSource->hsurf;
        fastPathInfo.iUniq = pMemBltInfo->pSource->iUniq;
        fastPathInfo.iDeviceUniq = pMemBltInfo->iDeviceUniq;
        fastPathInfo.pXlateObj = pMemBltInfo->pXlateObj;
        fastPathInfo.iUniqXlate = ((pMemBltInfo->pXlateObj != NULL) ?
                pMemBltInfo->pXlateObj->iUniq : 0);
        fastPathInfo.tileOrigin = tileOrigin;
        fastPathInfo.TileSize = pMemBltInfo->TileSize;
        fastPathInfo.bDeltaRLE = pMemBltInfo->bDeltaRLE;

        CH_CreateKeyFromFirstData(&CHContext, &fastPathInfo,
                sizeof(fastPathInfo));
        if (CH_SearchCache(pddShm->sbc.hFastPathCache, CHContext.Key1,
                CHContext.Key2, &UserDefined, &fastPathIndex)) {
            CHCACHEHANDLE hCache;

            // Found match in fast path. UserDefined is a pointer to the
            // real CHNODE for the bitmap.
            hCache = CH_GetCacheHandleFromNode((CHNODE *)UserDefined);
            pMemBltInfo->CacheID = (unsigned)(UINT_PTR)CH_GetCacheContext(
                    hCache);
            pMemBltInfo->CacheIndex = CH_GetCacheIndexFromNode(
                    (CHNODE *)UserDefined);

            TRC_NRM((TB, "FP hit: cacheId(%u) cacheIndex(%u) FPIndex(%u)"
                    "hsurf(%p) iUniq(%u) pXlate(%p) iUniqX(%u) "
                    "tileOrigin.x(%d) tileOrigin.y(%d) "
                    "TileSize(%d), bDeltaRLE(%u)",
                    pMemBltInfo->CacheID, pMemBltInfo->CacheIndex,
                    fastPathIndex, fastPathInfo.hsurf,
                    fastPathInfo.iUniq, fastPathInfo.pXlateObj,
                    fastPathInfo.iUniqXlate,
                    fastPathInfo.tileOrigin.x, fastPathInfo.tileOrigin.y,
                    fastPathInfo.TileSize, fastPathInfo.bDeltaRLE));
            fFastPathMatch = TRUE;

#ifdef DC_DEBUG
            // Verify that the bits for this are identical to the real bits
            pWorkSurf = EngLockSurface(pddShm->sbc.bitmapCacheInfo[
                    pMemBltInfo->TileID].hWorkBitmap);
            if (pWorkSurf)
            {
                if (SBC_CopyToWorkBitmap(pWorkSurf, pMemBltInfo, cxSubBitmapWidth,
                	    cySubBitmapHeight, &tileOrigin, pDestRect))
                {
                    SBC_VerifyBitmapBits(pWorkSurf->pvBits,
                    	    TS_BYTES_IN_BITMAP(pMemBltInfo->TileSize, cySubBitmapHeight, sbcClientBitsPerPel),
                    	    pMemBltInfo->CacheID,
                    	    pMemBltInfo->CacheIndex);
                }

            	EngUnlockSurface(pWorkSurf);
                pWorkSurf = NULL;
            }
#endif //DC_DEBUG

            pddCacheStats[BITMAP].CacheHits++;
        }
        else {
            TRC_NRM((TB, "FP miss: hsurf(%p) iUniq(%u) pXlate(%p) "
                    "iUniqX(%u) tileOrigin.x(%d) tileOrigin.y(%d) "
                    "TileSize(%d), bDeltaRLE(%u)",
                    fastPathInfo.hsurf, fastPathInfo.iUniq,
                    fastPathInfo.pXlateObj, fastPathInfo.iUniqXlate,
                    fastPathInfo.tileOrigin.x, fastPathInfo.tileOrigin.y,
                    fastPathInfo.TileSize, fastPathInfo.bDeltaRLE));
        }
    }

    if (!fFastPathMatch) {
        // We know how large a tile we have - we now have to Blt it into
        // the work bitmap corresponding to the TileID.

        // Lock the work bitmap to get a surface to pass to EngBitBlt.
        pWorkSurf = EngLockSurface(pddShm->sbc.bitmapCacheInfo[
                pMemBltInfo->TileID].hWorkBitmap);
        if (pWorkSurf == NULL) {
            TRC_ERR((TB, "Failed to lock work surface"));
            DC_QUIT;
        }

        TRC_DBG((TB, "Locked surface"));

        if (!SBC_CopyToWorkBitmap(pWorkSurf, pMemBltInfo, cxSubBitmapWidth,
        	    cySubBitmapHeight, &tileOrigin, pDestRect))
        {
            TRC_ERR((TB, "Failed to copy bitmap to work surface"));
            DC_QUIT;
        }

        // Cache the bits in the main cache, including sending a Cache
        // Bitmap seondary order if need be.
        if (!SBCCacheBits(ppdev, pWorkSurf->pvBits, cxSubBitmapWidth,
                pMemBltInfo->TileSize, cySubBitmapHeight,
                TS_BYTES_IN_BITMAP(pMemBltInfo->TileSize,
                cySubBitmapHeight, sbcClientBitsPerPel),
                pMemBltInfo->TileID,
#ifdef PERF_SPOILING
                &pMemBltInfo->CacheID, &pMemBltInfo->CacheIndex,
                pMemBltInfo->bIsPrimarySurface)) {
#else
                &pMemBltInfo->CacheID, &pMemBltInfo->CacheIndex)) {
#endif
            TRC_ERR((TB, "Failed to cache bits"));
            DC_QUIT;
        }

        // If we could search for this bitmap in the fast-path cache, add
        // it to the fast-path.
        // However, skip this step if the bitmap is in the waiting list only
        if (fSearchFastPath && 
                pMemBltInfo->CacheIndex != BITMAPCACHE_WAITING_LIST_INDEX) {
            CHNODE *pFastPathNode;
            CHCACHEHANDLE hCache;

            // Get the handle of the cache into which we just placed the
            // bitmap.
            hCache = pddShm->sbc.bitmapCacheInfo[pMemBltInfo->CacheID].
                    cacheHandle;

            // Check if there is already a fast-path cache entry for this
            // node. If so, we need to remove it before adding this new
            // fast path entry. We maintain a one-to-one correspondence to
            // save memory and time, and because the old fast-path entry is
            // probably stale and won't be seen again.
            //
            // UserDefined in free builds is a pointer to the CHNODE in the
            // real bitmap cache; otherwise it is an indirect pointer
            // to the CHNODE contained in a blob of memory used to hold the
            // bitmap data corresponding to the key to verify that the key
            // generation algorithm is working okay.
            pFastPathNode = (CHNODE *)CH_GetUserDefined(hCache,
                    pMemBltInfo->CacheIndex);
            if (pFastPathNode != NULL)
                CH_RemoveCacheEntry(pddShm->sbc.hFastPathCache,
                        CH_GetCacheIndexFromNode(pFastPathNode));

            // Reuse the key created before for fast search.
            // We do not care if we evict a fast-path cache entry
            // when adding a new one -- the cache callbacks ensure that
            // both sets of cache entries are updated with respect to each
            // other.
            fastPathIndex = CH_CacheKey(pddShm->sbc.hFastPathCache,
                    CHContext.Key1, CHContext.Key2,
                    (void *)CH_GetNodeFromCacheIndex(hCache,
                    pMemBltInfo->CacheIndex));

            // Now change the UserDefined for the entry in the main cache.
            // This allows us to remove the fast-path entry when main cache
            // entry goes away.
            CH_SetUserDefined(hCache, pMemBltInfo->CacheIndex,
                    CH_GetNodeFromCacheIndex(pddShm->sbc.hFastPathCache,
                    fastPathIndex));

            TRC_NRM((TB, "FP add: cacheId(%u) cacheIndex(%u) FPIndex(%u)"
                    "hsurf(%p) iUniq(%u) pXlate(%p) iUniqX(%u) "
                    "tileOrigin.x(%d) tileOrigin.y(%d) TileSize(%d) "
                    "bDeltaRLE(%u)",
                    pMemBltInfo->CacheID, pMemBltInfo->CacheIndex,
                    fastPathIndex, pMemBltInfo->pSource->hsurf,
                    pMemBltInfo->pSource->iUniq, pMemBltInfo->pXlateObj,
                    ((pMemBltInfo->pXlateObj != NULL) ?
                    pMemBltInfo->pXlateObj->iUniq : 0),
                    tileOrigin.x, tileOrigin.y,
                    pMemBltInfo->TileSize, pMemBltInfo->bDeltaRLE));
        }
    }

    TRC_ASSERT((pMemBltInfo->CacheID < pddShm->sbc.NumBitmapCaches),
            (TB, "Invalid bm cacheid %u (max %u)", pMemBltInfo->CacheID,
            pddShm->sbc.NumBitmapCaches - 1));
    TRC_NRM((TB, "cacheId(%u) cacheIndex(%u)", pMemBltInfo->CacheID,
            pMemBltInfo->CacheIndex));

    rc = TRUE;

DC_EXIT_POINT:
    if (NULL != pWorkSurf)
    {
    	EngUnlockSurface(pWorkSurf);
        TRC_DBG((TB, "Unlocked surface"));
    }

    DC_END_FN();
    return rc;
}


/****************************************************************************/
// SBCSelectBitmapCache
//
// Determines the destination cell for a tiled bitmap based on the size and
// the TileID. Since all bitmaps are derived from tiles, this function cannot
// fail -- at worst we have to use the same CacheID as the TileID.
/****************************************************************************/
__inline unsigned RDPCALL SBCSelectBitmapCache(
        unsigned BitmapSize,
        unsigned TileID)
{
    unsigned CacheID;

    DC_BEGIN_FN("SBCSelectBitmapCache");

    // We scan from the smallest tile size to the TileID size to try to find
    // the smallest possible size that will hold the bitmap.
    for (CacheID = 0; CacheID < TileID; CacheID++) {
        if (BitmapSize <= (unsigned)SBC_CellSizeFromCacheID(CacheID)) {
            TRC_DBG((TB,"Selected CacheID %u for BitmapSize %u", CacheID,
                    BitmapSize));
            break;
        }
    }

    DC_END_FN();
    return CacheID;
}


/****************************************************************************/
// SBCCacheBits: This function ensures that on return the supplied bitmap is
// in the bitmap cache.  If the data is not already in the cache it is added
// (possibly evicting another entry).
//
// Returns:   TRUE if the bits have been cached OK, FALSE otherwise
//
// Params:    IN  pOrder           - A pointer to a BMC order.
//            IN  destBitsSize     - The number of bytes available in
//                                   pOrder to store the bitmap data.
//            IN  pDIBits          - A pointer to the bits to be cached.
//            IN  bitmapWidth      - The "in use" width of the bitmap
//            IN  fixedBitmapWidth - The actual width of the bitmap
//            IN  bitmapHeight     - The height of the bitmap
//            IN  numBytes         - The number of bytes in the bitmap.
//            OUT pCache           - The cache that we put the bits into.
//            OUT pCacheIndex      - The cache index within *pCache at
//                                   which we cached the data.
/****************************************************************************/

// Encode a value in one or two bytes. The high bit of the first byte is 0 if
// there is only one byte, 1 if there are 2 (with the 7 low bits of the first
// byte being most significant).
__inline void Encode2ByteField(
        BYTE     *pEncode,
        unsigned Val,
        unsigned *pOrderSize)
{
    if (Val <= 127) {
        *pEncode = (BYTE)Val;
        (*pOrderSize)++;
    }
    else {
        *pEncode = (BYTE)(((Val & 0x7F00) >> 8) | 0x80);
        *(pEncode + 1) = (BYTE)(Val & 0x00FF);
        (*pOrderSize) += 2;
    }
}

// Encode a value in up to 4 bytes. The high 2 bits of the first byte indicate
// the length of the encoding -- 00 is 1 byte, 01 is 2 bytes, 10 is 3 bytes,
// 11 is 4 bytes. The bytes are encoded with the most significant bits in the
// low 6 bits of the first byte, the least signifiant bits in the last byte.
__inline void Encode4ByteField(
        BYTE     *pEncode,
        unsigned Val,
        unsigned *pOrderSize)
{
    if (Val <= 0x3F) {
        *pEncode = (BYTE)Val;
        (*pOrderSize)++;
    }
    else if (Val <= 0x3FFF) {
        *pEncode = (BYTE)(((Val & 0x3F00) >> 8) | 0x40);
        *(pEncode + 1) = (BYTE)(Val & 0x00FF);
        (*pOrderSize) += 2;
    }
    else if (Val <= 0x3FFFFF) {
        *pEncode = (BYTE)(((Val & 0x3F0000) >> 16) | 0x80);
        *(pEncode + 1) = (BYTE)((Val & 0x00FF00) >> 8);
        *(pEncode + 2) = (BYTE)(Val & 0x0000FF);
        (*pOrderSize) += 3;
    }
    else {
        *pEncode = (BYTE)(((Val & 0x3F000000) >> 24) | 0xC0);
        *(pEncode + 1) = (BYTE)((Val & 0x00FF0000) >> 16);
        *(pEncode + 2) = (BYTE)((Val & 0x0000FF00) >> 8);
        *(pEncode + 3) = (BYTE)(Val & 0x000000FF);
        (*pOrderSize) += 4;
    }
}


#ifdef DC_DEBUG
BOOL SBC_VerifyBitmapBits(PBYTE pBitmapData, unsigned cbBitmapSize, UINT iCacheID, UINT iCacheIndex)
{
    BOOL fRetVal = TRUE;
    SBC_BITMAP_CACHE_EXTRA_INFO *pBitmapHdr;
    unsigned BitmapHdrSize;
    BYTE *pStoredBitmapData;

    DC_BEGIN_FN("SBC_VerifyBitmapBits");

    // In debug builds we look for a collision after checking the key
    // and checksum, by comparing the bitmap bits.
    BitmapHdrSize = sizeof(SBC_BITMAP_CACHE_EXTRA_INFO) +
            SBC_CellSizeFromCacheID(iCacheID);

    if (pddShm->sbc.bitmapCacheInfo[iCacheID].pExtraEntryInfo != NULL) {
        pBitmapHdr = (SBC_BITMAP_CACHE_EXTRA_INFO *)(pddShm->sbc.
                bitmapCacheInfo[iCacheID].pExtraEntryInfo +
                    BitmapHdrSize * iCacheIndex);
        pStoredBitmapData = (BYTE *)pBitmapHdr +
                sizeof(SBC_BITMAP_CACHE_EXTRA_INFO);

        if (pBitmapHdr->DataSize != 0) {
            TRC_NRM((TB,"Hit non-persistent cell entry, cache=%d, "
                    "index=%d", iCacheID, iCacheIndex));

            if (pBitmapHdr->DataSize != cbBitmapSize)
            {
                TRC_ERR((TB,"Size mismatch between stored and new bitmap "
                    "data! (stored=0x%X, new=0x%X)", pBitmapHdr->DataSize,
                    cbBitmapSize));

                fRetVal = FALSE;
            }
            else
            {
                if (memcmp(pStoredBitmapData, pBitmapData, cbBitmapSize))
                {
                    TRC_ERR((TB,"Key-data mismatch - pStoredData=%p, "
                        "pNewData=%p, size=0x%X", pStoredBitmapData,
                        pBitmapData, cbBitmapSize));

                    fRetVal = FALSE;
                }
            }
        }
        else {
            TRC_NRM((TB,"Persistent cell bitmap entry hit, cache=%d, "
                    "index=%d", *pCacheID, *pCacheIndex));
        }
    }

    DC_END_FN();
    return fRetVal;
}
#endif //DC_DEBUG


BOOLEAN RDPCALL SBCCacheBits(
        PDD_PDEV ppdev,
        PBYTE    pBitmapData,
        unsigned bitmapWidth,
        unsigned paddedBitmapWidth,
        unsigned bitmapHeight,
        unsigned cbBitmapSize,
        unsigned TileID,
        PUINT    pCacheID,
#ifdef PERF_SPOILING
        PUINT    pCacheIndex,
        BOOL     bIsPrimarySurface)
#else
        PUINT    pCacheIndex)
#endif
{
    BOOLEAN rc = TRUE;
    BOOLEAN bOnWaitingList = FALSE;
    unsigned compressedSize;
    PSBC_BITMAP_CACHE_INFO pCacheInfo;
    INT_ORDER *pOrder;
    unsigned BitmapSpace;
    unsigned OrderSize;
    PTS_SECONDARY_ORDER_HEADER pHdr;
    unsigned cbActualOrderSize;
    unsigned waitingListCacheEntry;
    BYTE *pRev2BitmapSizeField;
    void *UserDefined, *UserDefined2;
    CHDataKeyContext CHContext;
    UINT32 ExtraKeyInfo[2];

#ifdef DC_DEBUG
    SBC_BITMAP_CACHE_EXTRA_INFO *pBitmapHdr;
    unsigned BitmapHdrSize;
    BYTE *pStoredBitmapData;
#endif

    DC_BEGIN_FN("SBCCacheBits");

    // Select the cache based on the data size. Note that for 4bpp bitmaps
    // the size is doubled because we split the colors into individual 8bpp
    // bytes indexed on a 16-color palette.
#ifdef DC_HICOLOR
    // The logic regarding 4bpp holds for high color as the supplied bitmap
    // size already correctly takes into account higher color depths.      
    *pCacheID = SBCSelectBitmapCache(
                       (sbcClientBitsPerPel == 4 ?
                                           (2 * cbBitmapSize) : cbBitmapSize),
                       TileID);
#else
    *pCacheID = SBCSelectBitmapCache((sbcClientBitsPerPel == 8 ? cbBitmapSize :
            (2 * cbBitmapSize)), TileID);
#endif
    TRC_NRM((TB, "Selected cache %u", *pCacheID));

    pCacheInfo = &(pddShm->sbc.bitmapCacheInfo[*pCacheID]);

    // Generate a key for the bitmap data. Add in the width and height of the
    // blt as extra keyed data, since we don't want to collide when
    // displaying blts of different dimensions but the same number of bytes
    // and same contents. Also add in the checksum gathered from the bitmap
    // bits to decrease the fail rate.
    CH_CreateKeyFromFirstData(&CHContext, pBitmapData, cbBitmapSize);
    ExtraKeyInfo[0] = (paddedBitmapWidth << 16) | bitmapHeight;
    ExtraKeyInfo[1] = CHContext.Checksum;
    CH_CreateKeyFromNextData(&CHContext, ExtraKeyInfo, sizeof(ExtraKeyInfo));

    // If the key is already present, and its extra checksum matches,
    // no need to cache.
    if (CH_SearchCache(pCacheInfo->cacheHandle, CHContext.Key1,
            CHContext.Key2, &UserDefined, pCacheIndex)) {
        TRC_NRM((TB, "Bitmap already cached %u:%u cx(%u) cy(%u)",
                *pCacheID, *pCacheIndex, bitmapWidth, bitmapHeight));
        pddCacheStats[BITMAP].CacheHits++;

#ifdef DC_DEBUG
        SBC_VerifyBitmapBits(pBitmapData, cbBitmapSize, *pCacheID, *pCacheIndex);
#endif

        DC_QUIT;
    }

    // The bitmap is not in the cache list, check if it's in the waiting list
    // First check if the client supports waiting list cache
    if (pddShm->sbc.fAllowCacheWaitingList) {
        // The bitmap is in the waiting list, so cache it now, first remove
        // it from the waiting list
        if (CH_SearchCache(pCacheInfo->waitingListHandle, CHContext.Key1,
                CHContext.Key2, &UserDefined2, &waitingListCacheEntry)) {
            CH_RemoveCacheEntry(pCacheInfo->waitingListHandle, waitingListCacheEntry);
            goto CacheBitmap;
        }
        else {
            // The bitmap is not in the waiting list, put it in the waiting list
            // don't cache for this round, if we see it again, then we'll cache it
            waitingListCacheEntry = CH_CacheKey(pCacheInfo->waitingListHandle, 
                    CHContext.Key1, CHContext.Key2, NULL);
            *pCacheIndex = BITMAPCACHE_WAITING_LIST_INDEX;

#ifdef PERF_SPOILING
            // We waitlisted this tile. We don't need to send it as 
            // cache order. We will try to send it as screen data.
            if (bIsPrimarySurface) {
                rc = FALSE;
                DC_QUIT;
            }
#endif

            bOnWaitingList = TRUE;
            
        }
    }
    else {
        goto CacheBitmap;
    }

CacheBitmap:

    // Allocate an order in the order heap big enough to hold the entire
    // tile. We will relinquish any extra space we don't use because of
    // compression. Size is also dependent on the color depth of the client
    // since for 4bpp we unpack the colors into 8 bits for the protocol.
#ifdef DC_HICOLOR
    // Again, the logic holds for high color as the supplied bitmap size
    // already correctly takes into account higher color depths.
    BitmapSpace = cbBitmapSize * (sbcClientBitsPerPel == 4 ? 2 : 1);
    TRC_DBG((TB, "Bitmap is %ux%u, size %u bytes",
                               paddedBitmapWidth, bitmapHeight, BitmapSpace));
#else
    BitmapSpace = cbBitmapSize * (sbcClientBitsPerPel == 8 ? 1 : 2);
#endif
    OrderSize = max(TS_CACHE_BITMAP_ORDER_REV2_MAX_SIZE,
            (sizeof(TS_CACHE_BITMAP_ORDER) -
            FIELDSIZE(TS_CACHE_BITMAP_ORDER, bitmapData))) +
            BitmapSpace;
    pOrder = OA_AllocOrderMem(ppdev, OrderSize);
    if (pOrder != NULL) {
        // We have to add the key to the cache. Note we use NULL for the
        // UserDefined until we know the cache index to get the
        // BITMAP_DATA_HEADER.
        if (!bOnWaitingList) {
            *pCacheIndex = CH_CacheKey(pCacheInfo->cacheHandle,
                    CHContext.Key1, CHContext.Key2, NULL);

#ifdef DC_DEBUG
            // We need to store the bitmap data after the BITMAP_DATA_HEADER.
            BitmapHdrSize = sizeof(SBC_BITMAP_CACHE_EXTRA_INFO) +
                    SBC_CellSizeFromCacheID(*pCacheID);

            if (pddShm->sbc.bitmapCacheInfo[*pCacheID].pExtraEntryInfo != NULL) {
                pBitmapHdr = (SBC_BITMAP_CACHE_EXTRA_INFO *)(pddShm->sbc.
                        bitmapCacheInfo[*pCacheID].pExtraEntryInfo +
                            BitmapHdrSize * *pCacheIndex);
                pStoredBitmapData = (BYTE *)pBitmapHdr +
                        sizeof(SBC_BITMAP_CACHE_EXTRA_INFO);
                pBitmapHdr->DataSize = cbBitmapSize;
                memcpy(pStoredBitmapData, pBitmapData, cbBitmapSize);
            }
#endif //DC_DEBUG
        }

        TRC_NRM((TB,"Creating new cache entry, cache=%d, index=%d\n",
                *pCacheID, *pCacheIndex));

        // Fill in cache bitmap order. Differentiate based on the
        // order revision.
        pHdr = (TS_SECONDARY_ORDER_HEADER *)pOrder->OrderData;
        pHdr->orderHdr.controlFlags = TS_STANDARD | TS_SECONDARY;
        // Fill in pHdr->orderType when we know it below.

        if (pddShm->sbc.bUseRev2CacheBitmapOrder) {
            TS_CACHE_BITMAP_ORDER_REV2_HEADER *pCacheOrderHdr;

            // Revision 2 order.
            pCacheOrderHdr = (TS_CACHE_BITMAP_ORDER_REV2_HEADER *)
                    pOrder->OrderData;

            // Set up the CacheID and BitsPerPelID in header.extraFlags.
            // If the client supports noBitmapCompression Header, we have to
            // turn on the no-compression-header flag to indicate that
            // this order doesn't contain the header. This is necessary in
            // addition to capability negotiation because shadow can turn
            // this cap off.
#ifdef DC_HICOLOR
            if (!bOnWaitingList) {
                pCacheOrderHdr->header.extraFlags = *pCacheID | sbcCacheFlags |
                        pddShm->bc.noBitmapCompressionHdr;
            }
            else {
                pCacheOrderHdr->header.extraFlags = *pCacheID | sbcCacheFlags |
                        pddShm->bc.noBitmapCompressionHdr | 
                        TS_CacheBitmapRev2_bNotCacheFlag;
            }

#else
            pCacheOrderHdr->header.extraFlags = *pCacheID |
                    TS_CacheBitmapRev2_8BitsPerPel |
                    pddShm->bc.noBitmapCompressionHdr;
#endif

            // We'll write over the key values if the cache is tagged
            // as non-persistent.
            pCacheOrderHdr->Key1 = CHContext.Key1;
            pCacheOrderHdr->Key2 = CHContext.Key2;

            // Now add the variable-sized fields.

            // Bitmap key.
            if (pCacheInfo->Info.bSendBitmapKeys) {
                cbActualOrderSize =
                        sizeof(TS_CACHE_BITMAP_ORDER_REV2_HEADER);
                pCacheOrderHdr->header.extraFlags |=
                        TS_CacheBitmapRev2_bKeyPresent_Mask;
            }
            else {
                cbActualOrderSize =
                        sizeof(TS_CACHE_BITMAP_ORDER_REV2_HEADER) -
                        2 * sizeof(UINT32);
            }

            // Real width of the bits in this tile.
            Encode2ByteField((BYTE *)pCacheOrderHdr + cbActualOrderSize,
                    paddedBitmapWidth, &cbActualOrderSize);

            // Height, if not same as width.
            if (paddedBitmapWidth == bitmapHeight) {
                pCacheOrderHdr->header.extraFlags |=
                        TS_CacheBitmapRev2_bHeightSameAsWidth_Mask;
            }
            else {
                Encode2ByteField((BYTE *)pCacheOrderHdr + cbActualOrderSize,
                        bitmapHeight, &cbActualOrderSize);
            }

            // Bitmap size: Here we have to lose a bit of performance.
            // We have not yet compressed the bitmap and so cannot determine
            // size of this field (see Encode4ByteField() above). Since we
            // know that the size is never bigger than 4K (64x64 tile), we
            // can just set up to always encode a 2-byte size even if the
            // compressed size is less than 128 (this can cause a bit of a
            // wire performance hit).
//TODO: If we add tile sizes above 64x64 we will need to modify this logic to
// handle the potential 3-byte sizes.
            pRev2BitmapSizeField = (BYTE *)pCacheOrderHdr + cbActualOrderSize;
            cbActualOrderSize += 2;
//TODO: Not encoding the streaming bitmap size field here, needs to be added if
// bitmap streaming is enabled.

            Encode2ByteField((BYTE *)pCacheOrderHdr + cbActualOrderSize,
                    *pCacheIndex, &cbActualOrderSize);
        }
        else {
            PTS_CACHE_BITMAP_ORDER pCacheOrder;

            // Revision 1 order.
            pCacheOrder = (PTS_CACHE_BITMAP_ORDER)pOrder->OrderData;

            // If the client supports noBitmapCompression Header, we have to
            // turn on the no-compression-header flag to indicate that
            // this order doesn't contain the header. This is necessary in
            // addition to capability negotiation because shadow can turn
            // this cap off
            pCacheOrder->header.extraFlags = pddShm->bc.noBitmapCompressionHdr;
            pCacheOrder->cacheId = (BYTE)*pCacheID;
            pCacheOrder->pad1octet = 0;
            pCacheOrder->bitmapWidth = (BYTE)paddedBitmapWidth;
            pCacheOrder->bitmapHeight = (BYTE)bitmapHeight;
#ifdef DC_HICOLOR
            pCacheOrder->bitmapBitsPerPel = (BYTE)sbcClientBitsPerPel;
#else
            pCacheOrder->bitmapBitsPerPel = (BYTE)SBC_PROTOCOL_BPP;
#endif
            // We fill in pCacheOrder->bitmapLength when we have it below.
            pCacheOrder->cacheIndex = (UINT16)*pCacheIndex;
            cbActualOrderSize = sizeof(TS_CACHE_BITMAP_ORDER) -
                    FIELDSIZE(TS_CACHE_BITMAP_ORDER, bitmapData);
        }

#ifdef DC_HICOLOR
        if (sbcClientBitsPerPel != 4)
#else
        if (sbcClientBitsPerPel == 8)
#endif
        {

            compressedSize = cbBitmapSize;
        }
        else {
            BYTE *pEnd, *pSrc, *pDst;

            compressedSize = cbBitmapSize * 2;

            // Expand the 4bpp packing into full bytes -- protocol is 8bpp
            // and we need to have these bits before compressing.
            pEnd = pBitmapData + cbBitmapSize;
            pSrc = pBitmapData;
            pDst = sbcXlateBuf;
            while (pSrc < pEnd) {
                *pDst = (*pSrc >> 4) & 0xF;
                pDst++;
                *pDst = *pSrc & 0xF;
                pDst++;
                pSrc++;
            }

            pBitmapData = sbcXlateBuf;
        }

        // Try to compress the bitmap data, or copy it if the
        // compression will do no good.
#ifdef DC_HICOLOR
        if (BC_CompressBitmap(pBitmapData,
                              pOrder->OrderData + cbActualOrderSize,
                              NULL,
                              compressedSize,
                              &compressedSize,
                              paddedBitmapWidth,
                              bitmapHeight,
                              sbcClientBitsPerPel))
#else
        if (BC_CompressBitmap(pBitmapData, pOrder->OrderData +
                cbActualOrderSize, compressedSize,
                &compressedSize, paddedBitmapWidth, bitmapHeight))
#endif
        {
            TRC_NRM((TB, "Compressed to %u bytes", compressedSize));
            if (pddShm->sbc.bUseRev2CacheBitmapOrder) {
                pHdr->orderType = TS_CACHE_BITMAP_COMPRESSED_REV2;

                // Encode 2 bytes for size within 4-byte encoding.
                TRC_ASSERT((compressedSize <= 0x3FFF),
                        (TB,"compressedSize too large for 2 bytes!"));
                *pRev2BitmapSizeField = (BYTE)(compressedSize >> 8) | 0x40;
                *(pRev2BitmapSizeField + 1) = (BYTE)(compressedSize &
                        0x00FF);
            }
            else {
                pHdr->orderType = TS_CACHE_BITMAP_COMPRESSED;
                ((PTS_CACHE_BITMAP_ORDER)pOrder->OrderData)->
                        bitmapLength = (UINT16)compressedSize;
            }
        }
        else {
            // Failed to compress bitmap data, so just copy it
            // uncompressed.
            TRC_NRM((TB, "Failed to compress %u bytes, copying",
                    compressedSize));
            memcpy(pOrder->OrderData + cbActualOrderSize,
                    pBitmapData, compressedSize);

            if (pddShm->sbc.bUseRev2CacheBitmapOrder) {
                pHdr->orderType = TS_CACHE_BITMAP_UNCOMPRESSED_REV2;

                // Encode 2 bytes for size within 4-byte encoding.
                TRC_ASSERT((compressedSize <= 0x3FFF),
                        (TB,"compressedSize too large for 2 bytes!"));
                *pRev2BitmapSizeField = (BYTE)(compressedSize >> 8) | 0x40;
                *(pRev2BitmapSizeField + 1) = (BYTE)(compressedSize &
                        0x00FF);
            }
            else {
                pHdr->orderType = TS_CACHE_BITMAP_UNCOMPRESSED;
                ((PTS_CACHE_BITMAP_ORDER)pOrder->OrderData)->
                        bitmapLength = (UINT16)compressedSize;
            }
        }

        pHdr->orderLength = (UINT16)
                TS_CALCULATE_SECONDARY_ORDER_ORDERLENGTH(
                cbActualOrderSize + compressedSize);

        // Return any extra space to the order heap.
        OA_TruncateAllocatedOrder(pOrder, cbActualOrderSize +
                compressedSize);

        // Add the order.
        OA_AppendToOrderList(pOrder);
        INC_OUTCOUNTER(OUT_CACHEBITMAP);
        ADD_OUTCOUNTER(OUT_CACHEBITMAP_BYTES, cbActualOrderSize +
                compressedSize);
    }
    else {
        TRC_ALT((TB, "Failed to alloc cache bitmap order size %d", OrderSize));
        INC_OUTCOUNTER(OUT_CACHEBITMAP_FAILALLOC);
        rc = FALSE;
    }

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}


/****************************************************************************/
// SBC_SendCacheColorTableOrder
//
// Queues a color table order if the palette has
// changed since the last call to this function.
//
// Returns: TRUE if no action required, or color table successfully
//          queued.  FALSE otherwise.
//
// Params: pPDev - pointer to PDev
//         pCacheIndex - pointer to variable that receives cache index
/****************************************************************************/
BOOLEAN RDPCALL SBC_SendCacheColorTableOrder(
        PDD_PDEV pPDev,
        unsigned *pCacheIndex)
{
    int orderSize;
    void *UserDefined;
    CHDataKeyContext CHContext;
    BOOLEAN rc = TRUE;
    unsigned numColors;
    unsigned i;
    PINT_ORDER pOrder;
    PTS_CACHE_COLOR_TABLE_ORDER pColorTableOrder;

    DC_BEGIN_FN("SBC_SendCacheColorTableOrder");

    // Currently only support 8bpp protocol.
    TRC_ASSERT((pPDev->cProtocolBitsPerPel == SBC_PROTOCOL_BPP),
               (TB, "Unexpected bpp: %u", pPDev->cProtocolBitsPerPel));

    numColors = SBC_NUM_8BPP_COLORS;

    // Check the boolean in our PDEV to see if the palette has changed
    // since the last time we sent a color table order.
    // In high color case, no color table is needed
    if (!sbcPaletteChanged || (sbcClientBitsPerPel > 8)) {
        *pCacheIndex = sbcCurrentColorTableCacheIndex;
        DC_QUIT;
    }

    // If the key is already present (very often the case), no need to cache.
    CH_CreateKeyFromFirstData(&CHContext, (BYTE *)(pPDev->Palette),
            numColors * sizeof(PALETTEENTRY));
    if (CH_SearchCache(sbcColorTableCacheHandle, CHContext.Key1,
            CHContext.Key2, &UserDefined, pCacheIndex)) {
        TRC_NRM((TB, "Color table matched cache entry %u", *pCacheIndex));
        DC_QUIT;
    }

    // We have to add the key to the cache.
    *pCacheIndex = CH_CacheKey(sbcColorTableCacheHandle, CHContext.Key1,
            CHContext.Key2, NULL);

    // The palette has changed and is not currently in the color table
    // cache.  Allocate order memory to queue a color table order. The
    // order size depends on the bpp of our device. Note that the
    // allocation can fail if the order buffer is full.
    orderSize = sizeof(TS_CACHE_COLOR_TABLE_ORDER) -
            FIELDSIZE(TS_CACHE_COLOR_TABLE_ORDER, colorTable) +
            (numColors * sizeof(TS_COLOR_QUAD));

    pOrder = OA_AllocOrderMem(pPDev, orderSize);
    if (pOrder != NULL) {
        TRC_DBG((TB, "Allocate %u bytes for color table order", orderSize));

        // We've successfully allocated the order, so fill in the details.
        pColorTableOrder = (PTS_CACHE_COLOR_TABLE_ORDER)pOrder->OrderData;
        pColorTableOrder->header.orderHdr.controlFlags = TS_STANDARD |
                TS_SECONDARY;
        pColorTableOrder->header.orderLength = (USHORT)
                TS_CALCULATE_SECONDARY_ORDER_ORDERLENGTH(orderSize);
        pColorTableOrder->header.extraFlags = 0;
        pColorTableOrder->header.orderType = TS_CACHE_COLOR_TABLE;

        pColorTableOrder->cacheIndex = (BYTE)*pCacheIndex;
        pColorTableOrder->numberColors = (UINT16)numColors;

        // Unfortunately we can't just copy the palette from the PDEV into the
        // color table order because the PDEV has an array of PALETTEENTRY
        // structures which are RGBs whereas the order has an array of
        // RGBQUADs which are BGRs...
        for (i = 0; i < numColors; i++) {
            pColorTableOrder->colorTable[i].blue  = pPDev->Palette[i].peRed;
            pColorTableOrder->colorTable[i].green = pPDev->Palette[i].peGreen;
            pColorTableOrder->colorTable[i].red   = pPDev->Palette[i].peBlue;
            pColorTableOrder->colorTable[i].pad1octet = 0;
        }

        // Add the order.
        OA_AppendToOrderList(pOrder);
        INC_OUTCOUNTER(OUT_CACHECOLORTABLE);
        ADD_OUTCOUNTER(OUT_CACHECOLORTABLE_BYTES, orderSize);
        TRC_NRM((TB, "Added internal color table order, size %u", orderSize));

        // Reset the flag which indicates that the palette needs to be sent.
        sbcPaletteChanged = FALSE;

        sbcCurrentColorTableCacheIndex = *pCacheIndex;
        TRC_NRM((TB, "Added new color table at index(%u)", *pCacheIndex));

#ifdef DC_HICOLOR
        TRC_ASSERT((sbcCurrentColorTableCacheIndex <
                SBC_NUM_COLOR_TABLE_CACHE_ENTRIES),
                (TB, "Invalid ColorTableIndex(%u)",
                sbcCurrentColorTableCacheIndex));
#endif
    }
    else {
        rc = FALSE;
        TRC_ERR((TB, "Failed to allocate %d bytes for color table order",
                orderSize));
    }

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpdd\nssidisp.c ===
/****************************************************************************/
// nssidisp.c
//
// SaveScreenBits Interceptor API functions.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <precmpdd.h>
#define TRC_FILE "nssidisp"
#include <winddi.h>
#include <adcg.h>

#include <adcs.h>
#include <aprot.h>
#include <aordprot.h>

#include <nddapi.h>
#include <aoaapi.h>
#include <noadisp.h>
#include <noedisp.h>
#include <acpcapi.h>
#include <ausrapi.h>
#include <nschdisp.h>
#include <nprcount.h>
#include <oe2.h>

#define DC_INCLUDE_DATA
#include <ndddata.c>
#include <oe2data.c>
#undef DC_INCLUDE_DATA

#include <assiapi.h>
#include <nssidisp.h>

#include <nssidata.c>

#include <noeinl.h>


/****************************************************************************/
// SSI_DDInit
/****************************************************************************/
void SSI_DDInit()
{
    DC_BEGIN_FN("SSI_DDInit");

    memset(&ssiLocalSSBState, 0, sizeof(LOCAL_SSB_STATE));
    SSIResetSaveScreenBitmap();

    DC_END_FN();
}


/****************************************************************************/
// SSI_InitShm
//
// Alloc-time SHM init.
/****************************************************************************/
void SSI_InitShm()
{
    DC_BEGIN_FN("SSI_InitShm");

    pddShm->ssi.resetInterceptor = FALSE;
    pddShm->ssi.newSaveBitmapSize = FALSE;
    pddShm->ssi.sendSaveBitmapSize = 0;
    pddShm->ssi.newSaveBitmapSize = 0;

    DC_END_FN();
}


/****************************************************************************/
// SSI_Update
//
// Called when there is an SSI update from the WD. bForce forces a reset;
// it's used by shadowing.
/****************************************************************************/
void SSI_Update(BOOL bForce)
{
    DC_BEGIN_FN("SSI_Update");

    if (pddShm->ssi.resetInterceptor || bForce)
        SSIResetSaveScreenBitmap();

    if (pddShm->ssi.saveBitmapSizeChanged || bForce) {
        pddShm->ssi.sendSaveBitmapSize = pddShm->ssi.newSaveBitmapSize;
        pddShm->ssi.saveBitmapSizeChanged = FALSE;
        TRC_NRM((TB, "SSI caps: Size %ld", pddShm->ssi.sendSaveBitmapSize));
    }

    DC_END_FN();
}


/****************************************************************************/
// SSI_ClearOrderEncoding
//
// Called on share state change to reset the order state info for
// orders stored in the DD data segment.
/****************************************************************************/
void SSI_ClearOrderEncoding()
{
    DC_BEGIN_FN("SSI_ClearOrderEncoding");

    memset(&PrevSaveBitmap, 0, sizeof(PrevSaveBitmap));

    DC_END_FN();
}


/****************************************************************************/
// SSIResetSaveScreenBitmap
//
// Resets the SaveScreenBitmap state.
/****************************************************************************/
void SSIResetSaveScreenBitmap()
{
    int i;

    DC_BEGIN_FN("SSIResetSaveScreenBitmap");

    TRC_DBG((TB, "Reset (%d)", ssiLocalSSBState.saveLevel));

    // Discard all currently saved bits.
    ssiLocalSSBState.saveLevel = 0;

    // Reset the number of remote pels saved.
    ssiRemoteSSBState.pelsSaved = 0;

    // Note that we've seen the update.
    pddShm->ssi.resetInterceptor = FALSE;

    // Free off any memory we may have allocated.
    for (i = 0; i < SSB_MAX_SAVE_LEVEL; i++) {
        if (ssiLocalSSBState.saveState[i].pSaveData != NULL) {
            EngFreeMem(ssiLocalSSBState.saveState[i].pSaveData);
            ssiLocalSSBState.saveState[i].pSaveData = NULL;
        }
    }

    DC_END_FN();
}


/****************************************************************************/
// DrvSaveScreenBits - see NT DDK documentation.
/****************************************************************************/
ULONG_PTR DrvSaveScreenBits(
        SURFOBJ   *pso,
        ULONG     iMode,
        ULONG_PTR ident,
        RECTL     *prcl)
{
    ULONG_PTR rc;
    unsigned ourMode;
    RECTL rectTrg;
    PDD_PDEV ppdev = (PDD_PDEV)pso->dhpdev;
    PDD_DSURF pdsurf;

    DC_BEGIN_FN("DrvSaveScreenBits");

    // Default is FALSE: let GRE handle SaveBits if we are not in a
    // position to do it ourselves - no reason for us to get in the
    // business of saving off memory etc.
    rc = FALSE;

    // Sometimes we're called after being disconnected.
    if (ddConnected && pddShm != NULL) {
        // Surface is non-NULL.
        pso = OEGetSurfObjBitmap(pso, &pdsurf);

        INC_OUTCOUNTER(OUT_SAVESCREEN_ALL);

        // Get the exclusive bounding rectangle for the operation.
        RECT_FROM_RECTL(rectTrg, (*prcl));

        TRC_ASSERT((pso->hsurf == ppdev->hsurfFrameBuf),
                (TB, "DrvSaveScreenBits should be called for screen surface only"));

        if (pso->hsurf == ppdev->hsurfFrameBuf) {
            // Send a switch surface PDU if the destination surface is different
            // from last drawing order.  If we failed to send the PDU, we will 
            // just have to bail on this drawing order.
            if (!OESendSwitchSurfacePDU(ppdev, pdsurf)) {
                TRC_ERR((TB, "failed to send the switch surface PDU"));
                
                // We always return TRUE on SS_SAVE operations, as we
                // don't want the engine saving away the bits in a bitmap
                // and doing a MemBlt to restore the data (not very
                // efficient). Instead we return FALSE (failure) on the
                // SS_RESTORE to force User to repaint the affected area,
                // which we then accumulate in the normal way.
                //
                // Return TRUE for SS_DISCARD too (although it shouldn't
                // matter what we return).
                rc = (iMode == SS_RESTORE) ? FALSE : TRUE;

                DC_QUIT;
            }
        } else {
            // We don't support DrvSaveScreenBits for offscreen
            // rendering.
            TRC_ERR((TB, "Offscreen blt bail"));
            
            // We always return TRUE on SS_SAVE operations, as we
            // don't want the engine saving away the bits in a bitmap
            // and doing a MemBlt to restore the data (not very
            // efficient). Instead we return FALSE (failure) on the
            // SS_RESTORE to force User to repaint the affected area,
            // which we then accumulate in the normal way.
            //
            // Return TRUE for SS_DISCARD too (although it shouldn't
            // matter what we return).
            rc = (iMode == SS_RESTORE) ? FALSE : TRUE;

            DC_QUIT;
        }

        // Make sure we can send the order.
        if (OE_SendAsOrder(TS_ENC_SAVEBITMAP_ORDER)) {
            switch (iMode) {
                case SS_SAVE:
                    TRC_DBG((TB, "SaveBits=%u", ssiLocalSSBState.saveLevel));

                    // Save the bits.
                    // Update the save level if the save was successful.
                    // If it was not successful then RestoreBits will not
                    // be called so we do not want to increment the save
                    // level.
                    rc = SSISaveBits(pso, &rectTrg);
                    if (rc) {
                        ssiLocalSSBState.saveLevel++;

                        // Set the returned ident value to the index of
                        // the save. Do this after the increment in
                        // order to avoid returning index 0 (0=FAIL).
                        rc = ssiLocalSSBState.saveLevel;
                    }

                    break;


                case SS_RESTORE:
                    // Update the save level first.
                    ssiLocalSSBState.saveLevel--;
                    ident--;

                    TRC_DBG((TB, "RestoreBits (%d), ident (%u)",
                            ssiLocalSSBState.saveLevel, ident));

                    // Restore the bits.
                    rc = SSIRestoreBits(pso, &rectTrg, ident);

                    // Check for a negative save level. This will happen
                    // if there are outstanding saves when the share is
                    // started or when we get out-of-order restores/
                    // discards.
                    if (ssiLocalSSBState.saveLevel < 0) {
                        TRC_NRM((TB, "RestoreBits caused neg save level"));
                        ssiLocalSSBState.saveLevel = 0;
                    }

                    break;


                case SS_FREE:
                    // Update the save level first.
                    ssiLocalSSBState.saveLevel--;
                    ident--;

                    TRC_DBG((TB, "Discard Bits (%d) ident(%d)",
                            ssiLocalSSBState.saveLevel, ident));

                    // Discard the saved bits.
                    rc = SSIDiscardSave(&rectTrg, ident);

                    // Check for a negative save level. This will happen
                    // if there are outstanding saves when the share is
                    // started or when we get out-of-order restores/
                    // discards.
                    if (ssiLocalSSBState.saveLevel < 0) {
                        TRC_NRM((TB, "DiscardSave caused neg save level"));
                        ssiLocalSSBState.saveLevel = 0;
                    }

                    break;
            }

            // Make an "insurance" check: If the local save level is zero
            // then there should be no pels saved remotely.
            if ((ssiLocalSSBState.saveLevel == 0) &&
                    (ssiRemoteSSBState.pelsSaved != 0)) {
                TRC_ALT((TB, "Outstanding remote pels %ld",
                        ssiRemoteSSBState.pelsSaved ));
                ssiRemoteSSBState.pelsSaved = 0;
            }

            TRC_DBG((TB, "RemotePelsSaved (%ld) rc %u",
                    ssiRemoteSSBState.pelsSaved, rc));
        }
        else {
            // If the SaveBitmap order is not supported then return
            // 0 immediately. 0 is failure for SAVE (the return value
            // is a non-0 identifier for success) and FALSE is failure
            // for RESTORE. If we've failed SAVEs, we can never get a
            // FREE.
            TRC_DBG((TB, "SaveBmp not supported"));
            INC_OUTCOUNTER(OUT_SAVESCREEN_UNSUPP);

            // We always return TRUE on SS_SAVE operations, as we
            // don't want the engine saving away the bits in a bitmap
            // and doing a MemBlt to restore the data (not very
            // efficient). Instead we return FALSE (failure) on the
            // SS_RESTORE to force User to repaint the affected area,
            // which we then accumulate in the normal way.
            //
            // Return TRUE for SS_DISCARD too (although it shouldn't
            // matter what we return).
            rc = (iMode == SS_RESTORE) ? FALSE : TRUE;
        }
    }
    else {
        TRC_ERR((TB, "Called when disconnected"));
        rc = (iMode == SS_RESTORE) ? FALSE : TRUE;
    }

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}


/****************************************************************************/
// SSIRemotePelsRequired
//
// Returns the number of remote pels required to store the supplied
// rectangle, taking account of the Save Bitmap granularity.
/****************************************************************************/
__inline UINT32 SSIRemotePelsRequired(PRECTL pRect)
{
    UINT32 rectWidth, rectHeight;
    UINT32 rc;

    DC_BEGIN_FN("SSIRemotePelsRequired");

    // Calculate the supplied rectangle size (it is in EXCLUSIVE coords).
    rectWidth = pRect->right - pRect->left;
    rectHeight = pRect->bottom - pRect->top;

    // Required width and height are rounded up to next granularity level for
    // that dimension.
    rc = (UINT32)(((rectWidth + SAVE_BITMAP_X_GRANULARITY - 1) /
            SAVE_BITMAP_X_GRANULARITY * SAVE_BITMAP_X_GRANULARITY) *
            ((rectHeight + SAVE_BITMAP_Y_GRANULARITY - 1) /
            SAVE_BITMAP_Y_GRANULARITY * SAVE_BITMAP_Y_GRANULARITY));

    DC_END_FN();
    return rc;
}


/****************************************************************************/
// SSISendSaveBitmapOrder
//
// Sends a SaveBitmap order. Returns FALSE on failure.
/****************************************************************************/
BOOL SSISendSaveBitmapOrder(
        PDD_PDEV ppdev,
        PRECTL pRect,
        unsigned SavePosition,
        unsigned Operation)
{
    SAVEBITMAP_ORDER *pSaveBitmapOrder;
    PINT_ORDER pOrder;
    BOOL rc;

    DC_BEGIN_FN("SSISendSaveBitmapOrder");

    TRC_NRM((TB, "Rect before conversion (%d,%d)(%d,%d)", pRect->left,
            pRect->bottom, pRect->right, pRect->top));

    // 1 field flag byte. Note that SaveBitmap orders are not clipped,
    // so set zero for the number of clip rects.
    pOrder = OA_AllocOrderMem(ppdev, MAX_ORDER_SIZE(0, 1,
            MAX_SAVEBITMAP_FIELD_SIZE));
    if (pOrder != NULL) {
        // Target rect is in exclusive coords, convert to inclusive
        // for the wire format.
        pSaveBitmapOrder = (SAVEBITMAP_ORDER *)oeTempOrderBuffer;
        pSaveBitmapOrder->SavedBitmapPosition = SavePosition;
        pSaveBitmapOrder->nLeftRect = pRect->left;
        pSaveBitmapOrder->nTopRect = pRect->top;
        pSaveBitmapOrder->nRightRect = pRect->right - 1;
        pSaveBitmapOrder->nBottomRect = pRect->bottom - 1;
        pSaveBitmapOrder->Operation = Operation;

        // Slow-field-encode the order. NULL for clip rect since we don't clip
        // SaveBitmaps.
        pOrder->OrderLength = OE2_EncodeOrder(pOrder->OrderData,
                TS_ENC_SAVEBITMAP_ORDER, NUM_SAVEBITMAP_FIELDS,
                (BYTE *)pSaveBitmapOrder, (BYTE *)&PrevSaveBitmap, etable_SV,
                NULL);

        INC_OUTCOUNTER(OUT_SAVEBITMAP_ORDERS);
        ADD_INCOUNTER(IN_SAVEBITMAP_BYTES, pOrder->OrderLength);
        OA_AppendToOrderList(pOrder);

        // All done: consider sending the output.
        SCH_DDOutputAvailable(ppdev, FALSE);
        rc = TRUE;

        TRC_NRM((TB, "SaveBitmap op %d pos %ld rect %d %d %d %d",
                Operation, SavePosition, pRect->left, pRect->top,
                pRect->right - 1, pRect->bottom - 1));
    }
    else {
        TRC_ERR((TB, "Failed to alloc order mem"));
        rc= FALSE;
    }

    DC_END_FN();
    return rc;
}


/****************************************************************************/
// SSISaveBits
//
// Saves the specified screen rectangle bits and sends a SaveBitmap order.
// pRect is in exclusive coords. We return FALSE only on low-bounds errors;
// this indicates to GDI that it must simulate the SaveBits using a
// BitBlt without corresponding RestoreBits calls, which is not desirable.
// Instead, if we cannot send a SaveBitmap order or other problems, we return
// TRUE and note that we need to return FALSE on the Restore call, which
// causes a less expensive repaint of the target area.
/****************************************************************************/
BOOL SSISaveBits(SURFOBJ *pso, PRECTL pRect)
{
    BOOL rc = TRUE;

    DC_BEGIN_FN("SSISaveBits");

    TRC_DBG((TB, "SaveScreenBits (%d, %d, %d, %d) level %d",
            pRect->left, pRect->bottom, pRect->right, pRect->top,
            ssiLocalSSBState.saveLevel));

    // The saveLevel should never be negative.
    if (ssiLocalSSBState.saveLevel >= 0) {
        // If the save level is greater than the number of levels that we
        // support we just return TRUE. The corresponding RestoreBits call
        // will return FALSE, causing Windows to repaint the area.
        // Our maximum save level is such that we should very rarely (if ever)
        // go through this path.
        if (ssiLocalSSBState.saveLevel < SSB_MAX_SAVE_LEVEL) {
            CURRENT_LOCAL_SSB_STATE.pSaveData = NULL;
            CURRENT_LOCAL_SSB_STATE.rect = *pRect;
            CURRENT_LOCAL_SSB_STATE.fSavedRemotely = FALSE;

            // If the rectangle to be saved intersects the current SDA then
            // we will have to force a repaint on the restore. This is
            // because orders are always sent before Screen Data, so if we
            // sent a SAVEBITS order at this point, we would not save the
            // intersecting Screen Data.
            if (!OE_RectIntersectsSDA(pRect)) {
                UINT32 cRemotePelsRequired;

                // Calculate the number of pels required in the remote Save
                // Bitmap to handle this rectangle.
                cRemotePelsRequired = SSIRemotePelsRequired(pRect);

                // If there aren't enough pels in the remote Save Bitmap to
                // handle this rectangle then return immediately.
                if ((ssiRemoteSSBState.pelsSaved + cRemotePelsRequired) <=
                        pddShm->ssi.sendSaveBitmapSize) {
                    // Try to send the SaveBits as an order.
                    CURRENT_LOCAL_SSB_STATE.fSavedRemotely =
                            SSISendSaveBitmapOrder((PDD_PDEV)(pso->dhpdev),
                            pRect, ssiRemoteSSBState.pelsSaved, SV_SAVEBITS);
                    if (CURRENT_LOCAL_SSB_STATE.fSavedRemotely) {
                        // Store the relevant details in the current entry of
                        // the local SSB structure.
                        CURRENT_LOCAL_SSB_STATE.remoteSavedPosition =
                                ssiRemoteSSBState.pelsSaved;
                        CURRENT_LOCAL_SSB_STATE.remotePelsRequired =
                                cRemotePelsRequired;

                        // Update the count of remote pels saved.
                        ssiRemoteSSBState.pelsSaved += cRemotePelsRequired;

                        // Store the rectangle saved. Note that we still claim
                        // success, even if the copy fails. The result of this
                        // is that
                        // - we send save and restore orders to the client
                        //   (gives bandwidth saving and client
                        //   responsiveness)
                        // - we fail the restore, causing a less efficient
                        //   repaint at the server.
                        // Other compromise options also available if this
                        // proves inappropriate.
                        SSICopyRect(pso, TRUE);
                    }
                }
                else {
                    TRC_NRM((TB, "no space for %lu pels", cRemotePelsRequired));
                }
            }
            else {
                // Note we do not save the rect via SSICopyRect -- we only
                // restore when fSavedRemotely is TRUE.
                TRC_DBG((TB, "SSI intersects SDA, storing failed save"));
                CURRENT_LOCAL_SSB_STATE.fSavedRemotely = FALSE;
            }
        }
        else {
            // We return TRUE. On Restore, we'll get the same out-of-bounds
            // value and return FALSE to repaint.
            TRC_ALT((TB, "saveLevel(%d) exceeds maximum",
                    ssiLocalSSBState.saveLevel));
        }
    }
    else {
        // This is a real problem, so we tell GDI to to what it needs to.
        TRC_ERR((TB, "SSISaveBits called with negative saveLevel"));
        rc = FALSE;
    }

    DC_END_FN();
    return rc;
}


/****************************************************************************/
/* FUNCTION: SSIFindSlotAndDiscardAbove                                     */
/*                                                                          */
/* Finds the top slot in the SSB stack which matches pRect and updates     */
/* ssiLocalSSBState.saveLevel to index it.                                  */
/* RETURNS: TRUE if a match was found, FALSE otherwise                      */
/****************************************************************************/
BOOL SSIFindSlotAndDiscardAbove(PRECTL pRect, ULONG_PTR ident)
{
    int i;
    BOOL rc = FALSE;

    DC_BEGIN_FN("SSIFindSlotAndDiscardAbove");

    // Find the bits we are trying to restore.
    for (i = ssiLocalSSBState.saveLevel; i >= 0; i--) {
        if (i == (int)ident) {
            // We're at the right level in the saveState.
            TRC_NRM((TB, "found match at level %d", i));
            TRC_DBG((TB, "Rect matched (%d, %d, %d, %d)",
                    ssiLocalSSBState.saveState[i].rect.left,
                    ssiLocalSSBState.saveState[i].rect.bottom,
                    ssiLocalSSBState.saveState[i].rect.right,
                    ssiLocalSSBState.saveState[i].rect.top));

            ssiLocalSSBState.saveLevel = i;
            rc = TRUE;
            DC_QUIT;
        }
        else {
            // Discard this entry on the stack.
            ssiRemoteSSBState.pelsSaved -=
                    ssiLocalSSBState.saveState[i].remotePelsRequired;
            if (ssiLocalSSBState.saveState[i].pSaveData != NULL) {
                TRC_DBG((TB, "Freeing memory at %p",
                                   ssiLocalSSBState.saveState[i].pSaveData));
                EngFreeMem(ssiLocalSSBState.saveState[i].pSaveData);
                ssiLocalSSBState.saveState[i].pSaveData = NULL;
            }
        }
    }

    // If we get here we failed to match on any of the entries.
    TRC_NRM((TB, "no match on stack"));
    ssiLocalSSBState.saveLevel = 0;

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}


/****************************************************************************/
// SSIRestoreBits
//
// Restores the specified screen rectangle. If the bits were saved remotely
// we make sure to send a SaveBitmap order. We return TRUE if we restored
// the bits at the client, else we return FALSE to have GDI repaint the
// target rect.
/****************************************************************************/
BOOL SSIRestoreBits(SURFOBJ *pso, PRECTL pRect, ULONG_PTR ident)
{
    BOOL rc = FALSE;

    DC_BEGIN_FN("SSIRestoreBits");

    TRC_DBG((TB, "RestoreScreenBits (%d, %d, %d, %d) level %d",
            pRect->left, pRect->bottom, pRect->right, pRect->top,
            ssiLocalSSBState.saveLevel));

    pddCacheStats[SSI].CacheReads++;

    // If the save level is negative then either there was a save
    // outstanding when we hooked the SSB or we have received out of order
    // restores/discards so we discarded stuff from the SSB stack
    // ourselves.  We can't distinguish between these two cases at this
    // point so we will always pass this on to the display driver and hope
    // that it is robust enough to cope with a discard which didn't have a
    // corresponding save.
    if (ssiLocalSSBState.saveLevel >= 0) {
        // If we don't have enough levels (rare problem), we return FALSE
        // which causes a repaint.
        if (ssiLocalSSBState.saveLevel < SSB_MAX_SAVE_LEVEL) {
            // Search for the corresponding save order on our stack.
            if (SSIFindSlotAndDiscardAbove(pRect, ident)) {
                if (CURRENT_LOCAL_SSB_STATE.fSavedRemotely) {
                    // Make sure GDI is giving us back the same sized
                    // block, otherwise the client can get messed up.
                    //TRC_ASSERT((CURRENT_LOCAL_SSB_STATE.remotePelsRequired ==
                    //        SSIRemotePelsRequired(pRect)),
                    //        (TB,"Rect (%d,%d,%d,%d) for restore level %u "
                    //        "size %u is too large (stored size=%u)",
                    //        pRect->left, pRect->top, pRect->right,
                    //        pRect->bottom, ssiLocalSSBState.saveLevel,
                    //        SSIRemotePelsRequired(pRect),
                    //        CURRENT_LOCAL_SSB_STATE.remotePelsRequired));

                    // Update the remote pel count first. Even if we fail
                    // to send the order we want to free up the remote pels.
                    ssiRemoteSSBState.pelsSaved -=
                            CURRENT_LOCAL_SSB_STATE.remotePelsRequired;

                    // The bits were saved remotely, send the restore order.
                    TRC_DBG((TB, "Try sending the order"));
                    rc = SSISendSaveBitmapOrder((PDD_PDEV)(pso->dhpdev),
                            pRect, CURRENT_LOCAL_SSB_STATE.remoteSavedPosition,
                            SV_RESTOREBITS);

                    // Now restore the bits to the screen, so long as we sent
                    // the order. No point repainting the screen if we could
                    // not send the order as we'll want GRE+USER to redraw it
                    // so that we can accumulate the output.
                    if (rc) {
                        pddCacheStats[SSI].CacheHits++;

                        if (CURRENT_LOCAL_SSB_STATE.pSaveData != NULL) {
                            TRC_DBG((TB, "Restore bits to local screen"));
                            SSICopyRect(pso, FALSE);
                        }
                        else {
                            TRC_DBG((TB, "No data to restore, repaint"));
                            rc = FALSE;
                        }
                    }
                    else {
                        // We failed the send, but still need to discard any
                        // locally saved data.
                        if (CURRENT_LOCAL_SSB_STATE.pSaveData != NULL) {
                            EngFreeMem(CURRENT_LOCAL_SSB_STATE.pSaveData);
                            CURRENT_LOCAL_SSB_STATE.pSaveData = NULL;
                        }
                    }
                }
                else {
                    // We failed to save the bitmap remotely originally so now
                    // we need to return FALSE to force a repaint.
                    // We should never have allocated any local memory.
                    TRC_ASSERT((CURRENT_LOCAL_SSB_STATE.pSaveData == NULL),
                            (TB,"We allocated memory without remote save!"));
                    TRC_NRM((TB, "No remote save, force repaint"));
                }
            }
            else {
                // We failed to find a match. This is not an error -
                // it will happen when saves are not restored in LIFO fashion
                // and it will also happen when SSI gets a sync now whilst
                // something is saved.
                TRC_DBG((TB, "Cannot find save request"));
            }
        }
        else {
            TRC_ALT((TB, "saveLevel(%d) exceeds maximum",
                    ssiLocalSSBState.saveLevel));
        }
    }
    else {
        TRC_ALT((TB, "Restore without save"));
    }

    DC_END_FN();
    return rc;
}


/****************************************************************************/
// SSIDiscardSave
//
// Discards the specified screen rectangle bits. Always returns TRUE
// saying that the discard succeeded.
/****************************************************************************/
BOOL SSIDiscardSave(PRECTL pRect, ULONG_PTR ident)
{
    BOOL rc;

    DC_BEGIN_FN("SSIDiscardSave");

    TRC_DBG((TB, "Discard for rect L%u R%u T%u B%u", pRect->left,
            pRect->right, pRect->top, pRect->bottom));

    // If the save level is negative then either there was a save
    // outstanding when we hooked the SSB or we have received out of order
    // restores/discards so we discarded stuff from the SSB stack ourselves.
    if (ssiLocalSSBState.saveLevel >= 0) {
        // If the save level is greater than the number of levels that we
        // support we just return TRUE. We will have ignored the SaveBits
        // call - so we have effectively discarded the bits already.
        // Our maximum save level is such that we should very rarely (if ever)
        // go through this path.
        if (ssiLocalSSBState.saveLevel < SSB_MAX_SAVE_LEVEL) {
            pddCacheStats[SSI].CacheReads++;

            // Search for the corresponding save order on our stack.
            // Not finding a slot match is not unusual, it can happen
            // when saves are not restored in LIFO fashion or when SSI
            // gets a sync while something is saved.
            if (SSIFindSlotAndDiscardAbove(pRect, ident)) {
                // If the bits were saved remotely then update local counter
                // for removed bits.
                if (CURRENT_LOCAL_SSB_STATE.fSavedRemotely) {
                    // We don't transmit FREE/DISCARDSAVE orders - there is
                    // no need because each Save/Restore order contains all
                    // the necessary information (e.g. position of the bits
                    // in the Save Bitmap). Just update our counter to take
                    // account of the remote freed bits.
                    ssiRemoteSSBState.pelsSaved -=
                            CURRENT_LOCAL_SSB_STATE.remotePelsRequired;
                }

                // If we actually copied the bits, then free the memory.
                if (CURRENT_LOCAL_SSB_STATE.pSaveData != NULL) {
                    TRC_DBG((TB, "Free off stored memory at %p",
                            CURRENT_LOCAL_SSB_STATE.pSaveData));
                    EngFreeMem(CURRENT_LOCAL_SSB_STATE.pSaveData);
                    CURRENT_LOCAL_SSB_STATE.pSaveData = NULL;
                }
            }
        }
        else {
            TRC_ALT((TB, "saveLevel(%d) exceeds maximum",
                    ssiLocalSSBState.saveLevel));
        }
    }
    else {
        TRC_ALT((TB, "Restore without save"));
    }

    DC_END_FN();
    return TRUE;
}


/****************************************************************************/
// SSICopyRect
//
// Copy a screen rectangle.
/****************************************************************************/
void SSICopyRect(SURFOBJ *pso, BOOL save)
{
    UINT32 size;
    PBYTE pSrc;
    PBYTE pDest;
    PBYTE pScreenLocation;
    unsigned rectWidth;
    unsigned rectHeight;
    unsigned paddedRectWidth;
    unsigned row;
    unsigned srcDelta;
    unsigned destDelta;
    PDD_PDEV pPDev;
#ifdef DC_HICOLOR
#ifdef DC_DEBUG
    unsigned bpp;
#endif
#endif

    DC_BEGIN_FN("SSICopyRect");

    // Set up some key params which are independent of the direction of
    // copy.
    rectHeight = CURRENT_LOCAL_SSB_STATE.rect.bottom -
            CURRENT_LOCAL_SSB_STATE.rect.top;

    pPDev = (PDD_PDEV)pso->dhpdev;

#ifdef DC_HICOLOR
    if (pso->iBitmapFormat == BMF_24BPP) {
        pScreenLocation = pPDev->pFrameBuf +
                          (CURRENT_LOCAL_SSB_STATE.rect.top * pso->lDelta) +
                           (CURRENT_LOCAL_SSB_STATE.rect.left * 3);

        // rectWidth is in bytes.  At 24bpp, this is 3 * number of pels.
        rectWidth = (CURRENT_LOCAL_SSB_STATE.rect.right -
                     CURRENT_LOCAL_SSB_STATE.rect.left) * 3;
#ifdef DC_DEBUG
        bpp = 24;
#endif
    }
    else if (pso->iBitmapFormat == BMF_16BPP) {
        pScreenLocation = pPDev->pFrameBuf +
                          (CURRENT_LOCAL_SSB_STATE.rect.top * pso->lDelta) +
                           (CURRENT_LOCAL_SSB_STATE.rect.left * 2);

        // rectWidth is in bytes.  At 16bpp, this is 2 * number of pels.
        rectWidth = (CURRENT_LOCAL_SSB_STATE.rect.right -
                     CURRENT_LOCAL_SSB_STATE.rect.left) * 2;
#ifdef DC_DEBUG
        bpp = 16;
#endif
    }
    else
#endif
    if (pso->iBitmapFormat == BMF_8BPP) {
        pScreenLocation = pPDev->pFrameBuf +
                (CURRENT_LOCAL_SSB_STATE.rect.top * pso->lDelta) +
                CURRENT_LOCAL_SSB_STATE.rect.left;

        // rectWidth is in bytes. At 8bpp, this is the number of pels.
        rectWidth =  CURRENT_LOCAL_SSB_STATE.rect.right -
                CURRENT_LOCAL_SSB_STATE.rect.left;
#ifdef DC_HICOLOR
#ifdef DC_DEBUG
        bpp = 8;
#endif
#endif
    }
    else {
        pScreenLocation = pPDev->pFrameBuf +
                (CURRENT_LOCAL_SSB_STATE.rect.top * pso->lDelta) +
                (CURRENT_LOCAL_SSB_STATE.rect.left / 2);

        // rectWidth is in bytes.  At 4bpp, this is (number of pels)/2.
        // However, since we copy whole bytes, we need to round 'right' up
        // and 'left' down to the nearest multiple of 2.
        rectWidth =  ((CURRENT_LOCAL_SSB_STATE.rect.right + 1) -
                (CURRENT_LOCAL_SSB_STATE.rect.left & ~1)) / 2;

#ifdef DC_HICOLOR
#ifdef DC_DEBUG
        bpp = 4;
#endif
#endif
    }
    paddedRectWidth = (unsigned)DC_ROUND_UP_4(rectWidth);

    TRC_DBG((TB, "CopyRect: L%u R%u B%u T%u H%u W%u, PW%u sc%p index %d",
            CURRENT_LOCAL_SSB_STATE.rect.left,
            CURRENT_LOCAL_SSB_STATE.rect.right,
            CURRENT_LOCAL_SSB_STATE.rect.bottom,
            CURRENT_LOCAL_SSB_STATE.rect.top,
            rectHeight,
            rectWidth,
            paddedRectWidth,
            pScreenLocation,
            ssiLocalSSBState.saveLevel));

#ifdef DC_HICOLOR
    TRC_ASSERT(((pso->iBitmapFormat == BMF_4BPP)  ||
            (pso->iBitmapFormat == BMF_8BPP)  ||
            (pso->iBitmapFormat == BMF_16BPP) ||
            (pso->iBitmapFormat == BMF_24BPP)),
            (TB, "Bitmap format %d unsupported", pso->iBitmapFormat));
#else

    // Only coded for 4bpp and 8bpp thus far.
    TRC_ASSERT(((pso->iBitmapFormat == BMF_8BPP) ||
            (pso->iBitmapFormat == BMF_4BPP)),
            (TB, "Bitmap format %d unsupported", pso->iBitmapFormat));
#endif

    // Allocate memory if required. The size can be calculated from the
    // rectl field: NB This is in exclusive coords.
    if (save) {
        size = rectHeight * paddedRectWidth;

        CURRENT_LOCAL_SSB_STATE.pSaveData = EngAllocMem(FL_ZERO_MEMORY,
                size, DD_ALLOC_TAG);

#ifdef DC_HICOLOR
        TRC_DBG((TB, "Save: alloc %u bytes for %dBPP at %p",
                size, bpp,
                CURRENT_LOCAL_SSB_STATE.pSaveData));
#else
        TRC_DBG((TB, "Save: alloc %u bytes for %dBPP at %p",
                size,
                pso->iBitmapFormat == BMF_8BPP ? 8 : 4,
                CURRENT_LOCAL_SSB_STATE.pSaveData));
#endif

        if (CURRENT_LOCAL_SSB_STATE.pSaveData != NULL) {
            // Now copy the bits. No need to explicitly zero the pad bytes as
            // we've nulled the memory on allocation.
            pSrc = pScreenLocation;
            pDest = CURRENT_LOCAL_SSB_STATE.pSaveData;
            srcDelta =  pso->lDelta;
            destDelta = paddedRectWidth;
            TRC_DBG((TB, "Save: Copying from %p to %p", pSrc, pDest));

            for (row = 0; row < rectHeight; row++) {
                memcpy(pDest, pSrc, rectWidth);
                pDest += destDelta;
                pSrc  += srcDelta;
            }
        }
        else {
            TRC_ALT((TB, "Failed alloc %ul bytes, SSI save aborted", size));
        }
    }
    else {
        // Copy the bits to the screen bitmap.
        pSrc = CURRENT_LOCAL_SSB_STATE.pSaveData;
        pDest = pScreenLocation;
        srcDelta  = paddedRectWidth;
        destDelta = pso->lDelta;
        TRC_DBG((TB, "Restore: Copying from %p to %p", pSrc, pDest));
        TRC_ASSERT((pSrc != NULL), (TB,"Source for SSI restore is NULL!"));

        for (row = 0; row < rectHeight; row++) {
            memcpy(pDest, pSrc, rectWidth);
            pDest += destDelta;
            pSrc  += srcDelta;
        }

        TRC_DBG((TB, "Freeing memory at %p"));
        EngFreeMem(CURRENT_LOCAL_SSB_STATE.pSaveData);
        CURRENT_LOCAL_SSB_STATE.pSaveData = NULL;
    }

    DC_END_FN();
} /* SSICopyRect */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpdd\nssidisp.h ===
/****************************************************************************/
// nssidisp.h
//
// Header for DD side of SSI.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/
#ifndef __NSSIDISP_H
#define __NSSIDISP_H

#include <assiapi.h>


// Maximum depth of save bitmaps we can handle.
#define SSB_MAX_SAVE_LEVEL  6


// Macro that makes it easier (more readable) to access the current
// local SSB state.
#define CURRENT_LOCAL_SSB_STATE \
        ssiLocalSSBState.saveState[ssiLocalSSBState.saveLevel]


// Local SaveScreenBitmap state structures.
typedef struct _SAVE_STATE
{
    PVOID  pSaveData;            /* the actual bits. can be NULL          */
    BOOL   fSavedRemotely;
    UINT32 remoteSavedPosition;  /* valid if (fSavedRemotely == TRUE)     */
    UINT32 remotePelsRequired;   /* valid if (fSavedRemotely == TRUE)     */
    RECTL  rect;
} SAVE_STATE, * PSAVE_STATE;

typedef struct _LOCAL_SSB_STATE
{
    int saveLevel;
    SAVE_STATE saveState[SSB_MAX_SAVE_LEVEL];
} LOCAL_SSB_STATE;


// Remote SaveScreenBitmap structures.
typedef struct _REMOTE_SSB_STATE
{
    UINT32 pelsSaved;
} REMOTE_SSB_STATE;


/****************************************************************************/
// Prototypes and inlines
/****************************************************************************/

void SSI_DDInit(void);

void SSI_InitShm(void);

void SSI_Update(BOOL);

void SSI_ClearOrderEncoding();

void SSIResetSaveScreenBitmap(void);

BOOL SSISendSaveBitmapOrder(PDD_PDEV, PRECTL, unsigned, unsigned);

BOOL SSISaveBits(SURFOBJ *, PRECTL);

BOOL SSIRestoreBits(SURFOBJ *, PRECTL, ULONG_PTR);

BOOL SSIDiscardSave(PRECTL, ULONG_PTR);

UINT32 SSIRemotePelsRequired(PRECTL);

BOOL SSIFindSlotAndDiscardAbove(PRECTL, ULONG_PTR);

void SSICopyRect(SURFOBJ *, BOOL);



#endif  // !defined(__NSSIDISP_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpdd\nsbcdisp.h ===
/****************************************************************************/
// nsbcdisp.h
//
// RDP Send Bitmap Cache display driver header.
//
// Copyright(c) Microsoft 1997-2000
/****************************************************************************/
#ifndef _H_NSBCDISP
#define _H_NSBCDISP

#include <nddapi.h>
#include <asbcapi.h>


#define GH_STATUS_SUCCESS       0
#define GH_STATUS_NO_MEMORY     1
#define GH_STATUS_CLIPPED       2

#define SBC_NUM_BRUSH_CACHE_ENTRIES 64

#define SBC_NUM_GLYPH_CACHE_ENTRIES 256


/****************************************************************************/
// Structure: SBC_COLOR_TABLE
/****************************************************************************/
typedef struct tagSBC_COLOR_TABLE
{
    PALETTEENTRY color[SBC_NUM_8BPP_COLORS];
} SBC_COLOR_TABLE, *PSBC_COLOR_TABLE;


/****************************************************************************/
// Structure: MEMBLT_ORDER_EXTRA_INFO
//
// Description: Extra information required by SBC to process a MEMBLT
// order.
/****************************************************************************/
typedef struct
{
    // MemBlt source and destination surfaces.
    SURFOBJ *pSource;
    SURFOBJ *pDest;

    // iUniq value from the device surface
    ULONG   iDeviceUniq;

    // XLATEOBJ for the blt.
    XLATEOBJ *pXlateObj;

    // Tile size per side, in ID form (corresponding to a bitmap cache ID
    // and its protocol-defined cell size) and expanded form.
    unsigned TileID;
    unsigned TileSize;

    // Determines if special background screen bit construction is needed
    // before caching a bitmap.
    BOOLEAN bDeltaRLE;

    // Used under special conditions where we need to turn off fast-path
    // caching. Only use right now is when caching directly from the screen
    // bitmap.
    BOOLEAN bNoFastPathCaching;

    // Used during caching call chain to keep from attempting to re-cache
    // the same tile for each intersecting clip rect.
    unsigned CacheID;
    unsigned CacheIndex;

#ifdef PERF_SPOILING
    // Used to tell the caching functions if the target for the current
    // operation is the screen. If it is the caching functions will force
    // waitlist orders to be sent as screen data.
    BOOL bIsPrimarySurface;
#endif
} MEMBLT_ORDER_EXTRA_INFO, *PMEMBLT_ORDER_EXTRA_INFO;


/****************************************************************************/
// Structure: SBC_FAST_PATH_INFO
//
// Description: Information used to create fast-path cache keys.
/****************************************************************************/
typedef struct tagSBC_FAST_PATH_INFO
{
    HSURF    hsurf;
    ULONG    iUniq;
    ULONG    iDeviceUniq;
    XLATEOBJ *pXlateObj;
    ULONG    iUniqXlate;
    POINTL   tileOrigin;
    unsigned TileSize;
    BOOL     bDeltaRLE;
} SBC_FAST_PATH_INFO, *PSBC_FAST_PATH_INFO;


/****************************************************************************/
// SBC_FRAG_INFO
//
// Glyph fragment info.
/****************************************************************************/
typedef struct tagSBC_FRAG_INFO
{
    INT32 dx;  // width of fragment background rect
    INT32 dy;  // height of fragment background rect
} SBC_FRAG_INFO, *PSBC_FRAG_INFO;


/****************************************************************************/
// SBC_OFFSCR_BITMAP_DELETE_INFO
/****************************************************************************/
typedef struct tagSBC_OFFSCR_BITMAP_DEL_INFO
{
    unsigned bitmapId;
    unsigned bitmapSize;
} SBC_OFFSCR_BITMAP_DEL_INFO, *PSBC_OFFSCR_BITMAP_DEL_INFO;


/****************************************************************************/
// Prototypes and inlines
/****************************************************************************/

void RDPCALL SBC_DDInit(PDD_PDEV);

void RDPCALL SBC_InitShm(void);

BOOLEAN RDPCALL SBCSelectGlyphCache(unsigned, PINT32);

BOOLEAN __fastcall SBCBitmapCacheCallback(
        CHCACHEHANDLE hCache,
        unsigned      Event,
        unsigned      iCacheEntry,
        void          *UserDefined);

BOOLEAN __fastcall SBCFastPathCacheCallback(
        CHCACHEHANDLE hCache,
        unsigned      event,
        unsigned      iCacheEntry,
        void          *UserDefined);

BOOLEAN RDPCALL SBCCreateGlyphCache(
        unsigned     cEntries,
        unsigned     cbCellSize,
        PCHCACHEDATA pCacheHandle);

BOOLEAN RDPCALL SBCCreateFragCache(
        unsigned     cEntries,
        unsigned     cbCellSize,
        PCHCACHEDATA pCacheHandle);

BOOLEAN __fastcall SBCGlyphCallback(
        CHCACHEHANDLE hCache,
        unsigned      event,
        unsigned      iCacheEntry,
        void          *UserDefined);

BOOLEAN __fastcall SBCOffscreenCallback(
        CHCACHEHANDLE hCache,
        unsigned      event,
        unsigned      iCacheEntry,
        void          *UserDefined);

unsigned RDPCALL SBCSelectBitmapCache(unsigned, unsigned);

unsigned SBC_DDQueryBitmapTileSize(unsigned, unsigned, PPOINTL, unsigned,
        unsigned);

BOOLEAN RDPCALL SBCCacheBits(PDD_PDEV, BYTE *, unsigned, unsigned, unsigned,
#ifdef PERF_SPOILING
        unsigned, unsigned, unsigned *, unsigned *, BOOL);
#else
        unsigned, unsigned, unsigned *, unsigned *);
#endif

BOOLEAN RDPCALL SBC_SendCacheColorTableOrder(PDD_PDEV, unsigned *);

BOOLEAN RDPCALL SBC_CacheBitmapTile(PDD_PDEV, PMEMBLT_ORDER_EXTRA_INFO,
        RECTL *, RECTL *);

void RDPCALL SBC_Update(SBC_BITMAP_CACHE_KEY_INFO *);

void RDPCALL SBC_DDSync(BOOLEAN bMustSync);

unsigned RDPCALL SBCAllocGlyphCache(PCHCACHEHANDLE);

unsigned RDPCALL SBCAllocBitmapCache(PCHCACHEHANDLE);

void RDPCALL SBCFreeColorTableCacheData(void);

void RDPCALL SBCFreeGlyphCacheData(void);

void RDPCALL SBCFreeBitmapCacheData(void);

void RDPCALL SBCFreeCacheData(void);

UINT32 RDPCALL SBCDDGetTickCount(void);


/****************************************************************************/
// SBC_DDTerm
/****************************************************************************/
__inline void RDPCALL SBC_DDTerm(void)
{
    SBCFreeCacheData();
}


/****************************************************************************/
// SBC_DDDisc
/****************************************************************************/
__inline void RDPCALL SBC_DDDisc(void)
{
    SBCFreeCacheData();
}



#endif /* _H_NSBCDISP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpdd\nschdisp.c ===
/****************************************************************************/
// nschdisp.c
//
// Scheduler Display Driver code.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <precmpdd.h>
#define hdrstop

#define TRC_FILE "nschdisp"
#include <adcg.h>
#include <winddi.h>

#include <adcs.h>
#include <nddapi.h>
#include <aschapi.h>
#include <nshmapi.h>
#include <nwdwioct.h>
#include <nbadisp.h>
#include <nprcount.h>
#include <nsbcdisp.h>
#include <ncmdisp.h>

#define DC_INCLUDE_DATA
#include <ndddata.c>
#undef DC_INCLUDE_DATA

#include <nbainl.h>
#include <nsbcinl.h>




/****************************************************************************/
// SCH_InitShm
//
// Alloc-time SHM init.
/****************************************************************************/
void RDPCALL SCH_InitShm(void)
{
    DC_BEGIN_FN("SCH_InitShm");

    pddShm->sch.baCompressionEst = SCH_BA_INIT_EST;
    pddShm->sch.MPPCCompressionEst = SCH_MPPC_INIT_EST;

    DC_END_FN();
}



/****************************************************************************/
// SCHEnoughOutputAccumulated
//
// Determine if there's enough output accumulated to make it worth sending
// to the WD.
/****************************************************************************/
__inline BOOL RDPCALL SCHEnoughOutputAccumulated(void)
{
    BOOL rc = FALSE;
    UINT32 EstimatedTotal;

    DC_BEGIN_FN("SCHEnoughOutputAccumulated");

    // We want to flush through to the WD if any of the following are true.
    // - new cursor shape (helps snappy feel)
    // - the estimated compressed size of the pending orders will fit into
    //   a large order buffer (estimated to 7/8 of buffer size to increase
    //   the chances of really fitting into the buffer after running through
    //   jittery compression algorithms).
    EstimatedTotal =
            pddShm->oa.TotalOrderBytes +
            (BA_GetTotalBounds() * pddShm->sch.baCompressionEst /
                SCH_UNCOMP_BYTES) +
            (pddShm->pm.paletteChanged *
                (UINT32)FIELDOFFSET(TS_UPDATE_PALETTE_PDU, data.palette[0]) +
                (PM_NUM_8BPP_PAL_ENTRIES * sizeof(TS_COLOR)));

    // If we're using the MPPC compressor, take into account the predicted
    // compression ratio.
    if (pddShm->sch.schSlowLink)
        EstimatedTotal = EstimatedTotal * pddShm->sch.MPPCCompressionEst /
                SCH_UNCOMP_BYTES;

    if (EstimatedTotal >= (pddShm->sch.LargePackingSize * 7 / 8)) {
        INC_INCOUNTER(IN_SCH_OUTPUT);
        TRC_NRM((TB,"Enough output bytes - %u", EstimatedTotal));
        rc = TRUE;
    }
    else if (CM_DDGetCursorStamp() != ddLastSentCursorStamp) {
    	// If we're not shadowing, we optimize to only flush due to
    	// cursor-shape-change when user input happened recently.
        if (NULL != pddShm->pShadowInfo ||
        	ddSchInputKickMode)
        {
            INC_INCOUNTER(IN_SCH_NEW_CURSOR);
            TRC_NRM((TB,"Changed cursor"));

            rc = TRUE;
        }
        else
        {
            TRC_NRM((TB,"Avoided changing cursor; not in InputKickMode"));
        }
    }

    DC_END_FN();
    return rc;
}


/****************************************************************************/
// SCH_DDOutputAvailable
//
// Called to decide whether to send output to the WD.
/****************************************************************************/
NTSTATUS RDPCALL SCH_DDOutputAvailable(PDD_PDEV ppdev, BOOL mustSend)
{
    NTSTATUS status;
    TSHARE_DD_OUTPUT_IN outputIn;
    TSHARE_DD_OUTPUT_OUT outputOut;
    ULONG bytesReturned;
    BOOL IoctlNow, schedOnly;

    DC_BEGIN_FN("SCH_DDOutputAvailable");

    INC_INCOUNTER(IN_SCH_OUT_ALL);
    ADD_INCOUNTER(IN_SCH_MUSTSEND, mustSend);

    TRC_DBG((TB, "Orders %d, mustSend? %s, scheduler mode %s (%d), %s",
            pddShm->oa.TotalOrderBytes,
            (mustSend ? "TRUE" : "FALSE"),
            ddSchCurrentMode == SCH_MODE_ASLEEP ? "Asleep" :
            ddSchCurrentMode == SCH_MODE_NORMAL ? "Normal" :
            ddSchCurrentMode == SCH_MODE_TURBO  ? "Turbo" : "Unknown",
            ddSchCurrentMode,
            pddShm->sch.schSlowLink ? "slow link" : "fast link"));

    // This routine contains part of the key scheduling algorithm.
    // The intent is to IOCTL to the WD if any of the following are true:
    //     - we have been told that we must send pending data immediately
    //     - there is enough output to make it worthwhile
    //     - the current SCH state is ASLEEP
    // If the scheduler is ASLEEP and it's a slow link, then we wake the
    // scheduler up but we don't do an actual send for performance reasons.
    if (mustSend || SCHEnoughOutputAccumulated()) {
        IoctlNow = TRUE;
        schedOnly = FALSE;
        TRC_DBG((TB, "Send data 'cos enough"));
    }
    else if (ddSchCurrentMode == SCH_MODE_ASLEEP) {
        INC_INCOUNTER(IN_SCH_ASLEEP);
        IoctlNow = TRUE;
        schedOnly = pddShm->sch.schSlowLink;
        TRC_DBG((TB, "Send data 'cos asleep: sched only: %d", schedOnly));
    }
    else {
        IoctlNow = FALSE;
        schedOnly = FALSE;
    }

    // If we have decided to send something, do so now. Most often we have
    // nothing to do.
    if (!IoctlNow) {
        INC_INCOUNTER(IN_SCH_DO_NOTHING);
        status = STATUS_SUCCESS;
    }
    else {
        outputIn.forceSend = mustSend;
        outputIn.pFrameBuf = ppdev->pFrameBuf;
        outputIn.frameBufWidth = ddFrameBufX;
        outputIn.frameBufHeight = ddFrameBufY;
        outputIn.pShm = pddShm;
        outputIn.schedOnly = schedOnly;

        // Note the current cursor stamp for future reference.
        ddLastSentCursorStamp = CM_DDGetCursorStamp();

        TRC_DBG((TB, "Send IOCtl to WD, bounds %d, orders %d, mustSend? %s",
                BA_GetTotalBounds(), pddShm->oa.TotalOrderBytes,
                (mustSend)? "TRUE":"FALSE"));

        // If we are not shadowing, then all output will be completely flushed
        // on this call.
        if (pddShm->pShadowInfo == NULL) {
            status = EngFileIoControl(ddWdHandle,
                    IOCTL_WDTS_DD_OUTPUT_AVAILABLE,
                    &outputIn, sizeof(TSHARE_DD_OUTPUT_IN),
                    &outputOut, sizeof(TSHARE_DD_OUTPUT_OUT),
                    &bytesReturned);
        }

        // else we are shadowing and may require multiple flush calls
        else {
#ifdef DC_DEBUG
            unsigned NumRepetitions = 0;
#endif

            do {
                TRC_DBG((TB, "Send IOCtl to WD, bounds %d, orders %d, mustSend? %s",
                        BA_GetTotalBounds(), pddShm->oa.TotalOrderBytes,
                        (mustSend)? "TRUE":"FALSE"));

                // The primary stack will update this to indicate how many bytes
                // were copied into the shadow data buffer. This will subsequently
                // be used by the shadow stack(s) to send the data to its client.
                pddShm->pShadowInfo->messageSize = 0;
#ifdef DC_HICOLOR
                pddShm->pShadowInfo->messageSizeEx = 0;
#endif
                status = EngFileIoControl(ddWdHandle,
                        IOCTL_WDTS_DD_OUTPUT_AVAILABLE,
                        &outputIn, sizeof(TSHARE_DD_OUTPUT_IN),
                        &outputOut, sizeof(TSHARE_DD_OUTPUT_OUT),
                        &bytesReturned);

                pddShm->pShadowInfo->messageSize = 0;
#ifdef DC_HICOLOR
                pddShm->pShadowInfo->messageSizeEx = 0;
#endif

#ifdef DC_DEBUG
                // If we have a locked-up shadow session looping in sending
                // output, break out. We should only have to call to the
                // WD a few times, so make the check 250 to be safe.
                NumRepetitions++;
                if (NumRepetitions == 250) {
                    TRC_ASSERT((NumRepetitions != 250),
                            (TB,"We seem to be in an infinite output loop "
                            "on shadow output flushing; TotalOrders=%u, "
                            "TotalBounds=%u",  pddShm->oa.TotalOrderBytes,
                            pddShm->ba.totalArea));
                }
#endif

            } while ((pddShm->oa.TotalOrderBytes || BA_GetTotalBounds()) &&
                    (status == STATUS_SUCCESS) && !schedOnly);
        }

        // Update the new scheduler mode.
        ddSchCurrentMode = outputOut.schCurrentMode;
        ddSchInputKickMode = outputOut.schInputKickMode;
        TRC_DBG((TB, "New Scheduler mode is %s (%d)",
                ddSchCurrentMode == SCH_MODE_ASLEEP ? "Asleep" :
                ddSchCurrentMode == SCH_MODE_NORMAL ? "Normal" :
                ddSchCurrentMode == SCH_MODE_TURBO  ? "Turbo" : "Unknown",
                ddSchCurrentMode));
    }

    DC_END_FN();
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpdd\oe2.c ===
/****************************************************************************/
// oe2.c
//
// RDP field compression utility code
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <precmpdd.h>
#pragma hdrstop

#define TRC_FILE "oe2"
#include <adcg.h>
#include <adcs.h>

#define DC_INCLUDE_DATA
#include <ndddata.c>
#undef DC_INCLUDE_DATA

#include <oe2.h>
#include <oe2data.c>


/****************************************************************************/
// Local file prototypes
/****************************************************************************/
BYTE *OE2EncodeFieldSingle(void *, BYTE *, unsigned, unsigned);
BYTE *OE2EncodeFieldMultiple(void *, BYTE *, unsigned, unsigned, unsigned);

#ifdef DC_DEBUG
void OE2PerformUnitTests();
#endif


/****************************************************************************/
// OE2_Reset
//
// Called on session reconnection or addition or removal of a shadower.
// Clears the OE2 state to the protocol default start condition.
/****************************************************************************/
void OE2_Reset(void)
{
#ifdef DC_DEBUG
    OE2PerformUnitTests();
#endif

    oe2LastOrderType = TS_ENC_PATBLT_ORDER;
    memset(&oe2LastBounds, 0, sizeof(oe2LastBounds));
}


/****************************************************************************/
// OE2_CheckZeroFlagBytes
//
// Performs post-field-encoding logic to see if there are any zero field
// encoding flag bytes, and if so shifts the entire contents of the order
// bytes following the encoding flags to compensate. Returns the number of
// bytes removed.
/****************************************************************************/
unsigned OE2_CheckZeroFlagBytes(
        BYTE *pControlFlags,
        BYTE *pFieldFlags,
        unsigned NumFieldBytes,
        unsigned PostFlagsDataLength)
{
    int i;
    unsigned NumZeroBytes;

    DC_BEGIN_FN("OE2_CheckZeroFlagBytes");

    TRC_ASSERT((NumFieldBytes >= 1 && NumFieldBytes <= 3),
            (TB,"NumFieldBytes %u out of allowed range 1..3",
            NumFieldBytes));

    // Count how many (if any!) contiguous zero field flag bytes there are
    // (going from the last byte to the first).
    NumZeroBytes = 0;
    for (i = (int)(NumFieldBytes - 1); i >= 0; i--) {
        if (pFieldFlags[i] != 0)
            break;
        NumZeroBytes++;
    }

    if (NumZeroBytes > 0) {
        // There are some zero field flag bytes. We now remove them and
        // store the number in two bits in the control flag byte.
        TRC_DBG((TB,"Remove NumZeroBytes=%u", NumZeroBytes));
        TRC_ASSERT((NumZeroBytes <= 3),
                (TB,"Invalid NumZeroBytes %u", NumZeroBytes));

        *pControlFlags |= (NumZeroBytes << TS_ZERO_FIELD_COUNT_SHIFT);

        memmove(pFieldFlags + NumFieldBytes - NumZeroBytes,
                pFieldFlags + NumFieldBytes,
                PostFlagsDataLength);
    }

    DC_END_FN();
    return NumZeroBytes;
}


/****************************************************************************/
// OE2_EncodeBounds
//
// Used by order encoding paths to encode the order bounds rect if a clip
// rect is used for the order.
/****************************************************************************/
void OE2_EncodeBounds(
        BYTE *pControlFlags,
        BYTE **ppBuffer,
        RECTL *pRect)
{
    BYTE *pFlags, *pNextFreeSpace;
    short Delta;

    DC_BEGIN_FN("OE2_EncodeBounds");

    *pControlFlags |= TS_BOUNDS;

    // The encoding used is a byte of flags followed by a variable number
    // of 16bit coordinate values and/or 8bit delta coordinate values.
    pFlags = *ppBuffer;
    pNextFreeSpace = pFlags + 1;
    *pFlags = 0;

    // For each of the four coordinate values in the rectangle: If the
    // coordinate has not changed then the encoding is null. If the
    // coordinate can be encoded as an 8-bit delta then do so and set the
    // appropriate flag. Otherwise copy the coordinate as a 16-bit value
    // and set the appropriate flag.
    TRC_ASSERT((pRect->left <= 0xFFFF),
            (TB,"Rect.left %d will not fit in 16-bit wire encoding",
            pRect->left));
    Delta = (short)(pRect->left - oe2LastBounds.left);
    if (Delta) {
        if (Delta != (short)(char)Delta) {
            *((UNALIGNED short *)pNextFreeSpace) = (short)pRect->left;
            pNextFreeSpace += sizeof(short);
            *pFlags |= TS_BOUND_LEFT;
        }
        else {
            *pNextFreeSpace++ = (char)Delta;
            *pFlags |= TS_BOUND_DELTA_LEFT;
        }
    }
    
    TRC_ASSERT((pRect->top <= 0xFFFF),
            (TB,"Rect.top %d will not fit in 16-bit wire encoding",
            pRect->top));
    Delta = (short)(pRect->top - oe2LastBounds.top);
    if (Delta) {
        if (Delta != (short)(char)Delta) {
            *((UNALIGNED short *)pNextFreeSpace) = (short)pRect->top;
            pNextFreeSpace += sizeof(short);
            *pFlags |= TS_BOUND_TOP;
        }
        else {
            *pNextFreeSpace++ = (char)Delta;
            *pFlags |= TS_BOUND_DELTA_TOP;
        }
    }
    
    TRC_ASSERT((pRect->right <= 0xFFFF),
            (TB,"Rect.right %d will not fit in 16-bit wire encoding",
            pRect->right));
    Delta = (short)(pRect->right - oe2LastBounds.right);
    if (Delta) {
        if (Delta != (short)(char)Delta) {
            *((UNALIGNED short *)pNextFreeSpace) = (short)pRect->right - 1;
            pNextFreeSpace += sizeof(short);
            *pFlags |= TS_BOUND_RIGHT;
        }
        else {
            *pNextFreeSpace++ = (char)Delta;
            *pFlags |= TS_BOUND_DELTA_RIGHT;
        }
    }
    
    TRC_ASSERT((pRect->bottom <= 0xFFFF),
            (TB,"Rect.bottom %d will not fit in 16-bit wire encoding",
            pRect->bottom));
    Delta = (short)(pRect->bottom - oe2LastBounds.bottom);
    if (Delta) {
        if (Delta != (short)(char)Delta) {
            *((UNALIGNED short *)pNextFreeSpace) = (short)pRect->bottom - 1;
            pNextFreeSpace += sizeof(short);
            *pFlags |= TS_BOUND_BOTTOM;
        }
        else {
            *pNextFreeSpace++ = (char)Delta;
            *pFlags |= TS_BOUND_DELTA_BOTTOM;
        }
    }

    // Copy the rectangle for reference with the next encoding.
    oe2LastBounds = *pRect;

    // If no bounds were encoded (i.e. the rectangle is identical to the
    // previous one) set the no-change-in-bounds flag.
    if (*pFlags)
        *ppBuffer = pNextFreeSpace;
    else
        *pControlFlags |= TS_ZERO_BOUNDS_DELTAS;

    DC_END_FN();
}


/****************************************************************************/
// OE2_TableEncodeOrderFields
//
// Uses an order field encoding table to encode an intermediate order
// format into wire format.
/****************************************************************************/
void OE2_TableEncodeOrderFields(
        BYTE *pControlFlags,
        PUINT32_UA pFieldFlags,
        BYTE **ppBuffer,
        PINT_FMT_FIELD pFieldTable,
        unsigned NumFields,
        BYTE *pIntFmt,
        BYTE *pPrevIntFmt)
{
    BYTE UseDeltaCoords;
    BYTE *pNextFreeSpace;
    PBYTE pVariableField;
    UINT32 ThisFlag;
    unsigned i, j;
    unsigned NumReps;
    unsigned FieldLength;
    PINT_FMT_FIELD pTableEntry;

    DC_BEGIN_FN("OE2_TableEncodeOrderFields");

    pNextFreeSpace = *ppBuffer;

    // Before we do the field encoding check all the field entries flagged
    // as coord to see if we can switch to TS_DELTA_COORDINATES mode.
    pTableEntry = pFieldTable;

    UseDeltaCoords = TS_DELTA_COORDINATES;

    // Loop through each fixed field in this order structure.
    i = 0;
    while (i < NumFields && pTableEntry->FieldType & OE2_ETF_FIXED) {
        // If this field entry is coord then compare it to the previous
        // coordinate we sent for this field to determine whether we can send
        // it as a delta.
        if (pTableEntry->FieldType & OE2_ETF_COORDINATES) {
            // We assume that coordinates are always signed.
            if (pTableEntry->FieldUnencodedLen == 4) {
                __int32 Temp;

                // Most common case: 4-byte source.
                Temp = (*((__int32 *)(pIntFmt + pTableEntry->FieldPos)) -
                        *((__int32 *)(pPrevIntFmt + pTableEntry->FieldPos)));
                if (Temp != (INT32)(char)Temp) {
                    UseDeltaCoords = FALSE;
                    break;
                }
            }
            else if (pTableEntry->FieldUnencodedLen == 2) {
                short Temp;

                // Uncommon: 2-byte source.
                Temp = (*((short *)(pIntFmt + pTableEntry->FieldPos)) -
                        *((short *)(pPrevIntFmt + pTableEntry->FieldPos)));
                if (Temp != (short)(char)Temp) {
                    UseDeltaCoords = FALSE;
                    break;
                }
            }
            else {
                TRC_ASSERT((pTableEntry->FieldUnencodedLen == 2),
                        (TB,"Unhandled field size %d",
                        pTableEntry->FieldUnencodedLen));
            }

            TRC_DBG((TB, "Use Delta coord A %d", UseDeltaCoords));
        }
        pTableEntry++;
        i++;
    }

#ifdef USE_VARIABLE_COORDS
    // Next loop through each of the variable fields.
    pVariableField = pIntFmt + pTableEntry->FieldPos;
    while (i < NumFields && UseDeltaCoords) {
        // The length of the field (in bytes) is given in the first
        // UINT32 of the variable sized field structure.
        FieldLength = *(PUINT32)pVariableField;
        pVariableField += sizeof(UINT32);

        // If this field entry is a coord then compare it to the
        // previous coord we sent for this field to determine whether
        // we can send it as a delta.
        if (pTableEntry->FieldType & OE2_ETF_COORDINATES) {
            // The number of coords is given by the number of bytes in
            // the field divided by the size of each entry.
            NumReps = FieldLength / pTableEntry->FieldUnencodedLen;

            // We assume that coords are always signed.
            if (pTableEntry->FieldUnencodedLen == 4) {
                __int32 Temp;

                // Most common case: 4-byte source.
                for (j = 0; j < NumReps; j++) {
                    Temp = (*((__int32 *)(pIntFmt + pTableEntry->FieldPos)) -
                            *((__int32 *)(pPrevIntFmt + pTableEntry->FieldPos)));
                    if (Temp != (__int32)(char)Temp) {
                        UseDeltaCoords = FALSE;
                        break;
                    }
                }
            }
            else if (pTableEntry->FieldUnencodedLen == 2) {
                short Temp;

                // Uncommon: 2-byte source.
                for (j = 0; j < NumReps; j++) {
                    Temp = (*((short *)(pIntFmt + pTableEntry->FieldPos)) -
                            *((short *)(pPrevIntFmt + pTableEntry->FieldPos)));
                    if (Temp != (short)(char)Temp) {
                        UseDeltaCoords = FALSE;
                        break;
                    }
                }
            }
            else {
                TRC_ASSERT((pTableEntry->FieldUnencodedLen == 2),
                        (TB,"Unhandled field size %d",
                        pTableEntry->FieldUnencodedLen));
            }

            TRC_DBG((TB, "Use Delta coord B %d", UseDeltaCoords));
        }

        // Move on to the next field in the order structure. Note that
        // variable sized fields are packed on the send side (i.e.
        // increment pVariableField by fieldLength not by
        // pTableEntry->FieldLen).
        pVariableField += FieldLength;
        pTableEntry++;
        i++;
    }
#endif  // USE_VARIABLE_COORDS

    TRC_DBG((TB, "Final UseDeltaCoords: %d", UseDeltaCoords));
    *pControlFlags |= UseDeltaCoords;

    // Now do the encoding.
    pTableEntry = pFieldTable;
    ThisFlag = 0x00000001;

    // First process all the fixed size fields in the order structure.
    // (These come before the variable sized fields.)
    i = 0;
    while (i < NumFields && pTableEntry->FieldType & OE2_ETF_FIXED) {
        // If the field has changed since it was previously transmitted then
        // we need to send it again.
        TRC_DBG((TB, "Processing field pos %u, type %u",
                pTableEntry->FieldPos, pTableEntry->FieldType));
        if (memcmp(pIntFmt + pTableEntry->FieldPos,
                pPrevIntFmt + pTableEntry->FieldPos,
                pTableEntry->FieldUnencodedLen)) {
            TRC_DBG((TB, "Bothering to encode this"));

            // Update the encoding flags.
            *pFieldFlags |= ThisFlag;

            // If we are encoding in delta coordinate mode and this field
            // is a coordinate...
            if (UseDeltaCoords &&
                    (pTableEntry->FieldType & OE2_ETF_COORDINATES) != 0) {
                TRC_DBG((TB, "Using delta coords"));

                // We assume that coordinates are always signed.
                if (pTableEntry->FieldUnencodedLen == 4) {
                    // Most common case: 4-byte source.
                    *pNextFreeSpace++ =
                            (char)(*((__int32 *)(pIntFmt + pTableEntry->FieldPos)) -
                            *((__int32 *)(pPrevIntFmt + pTableEntry->FieldPos)));
                }
                else if (pTableEntry->FieldUnencodedLen == 2) {
                    // Uncommon: 2-byte source.
                    *pNextFreeSpace++ =
                            (char)(*((short *)(pIntFmt + pTableEntry->FieldPos)) -
                            *((short *)(pPrevIntFmt + pTableEntry->FieldPos)));
                }
                else {
                    TRC_ASSERT((pTableEntry->FieldUnencodedLen == 2),
                            (TB,"Unhandled field size %d",
                            pTableEntry->FieldUnencodedLen));
                }
            }
            else {
                TRC_DBG((TB, "Regular encoding"));

                // Update the data to be sent.
                pNextFreeSpace = OE2EncodeFieldSingle(
                        pIntFmt + pTableEntry->FieldPos,
                        pNextFreeSpace, pTableEntry->FieldUnencodedLen,
                        pTableEntry->FieldEncodedLen);
            }

            // Save the current value for comparison next time.
            memcpy(pPrevIntFmt + pTableEntry->FieldPos,
                    pIntFmt + pTableEntry->FieldPos,
                    pTableEntry->FieldUnencodedLen);
        }

        // Move on to the next field in the structure.
        ThisFlag <<= 1;
        pTableEntry++;
        i++;
    }

    // Now process the variable sized entries.
    pVariableField = pIntFmt + pTableEntry->FieldPos;
    while (i < NumFields) {
        // The length of the field is given in the first UINT32 of the
        // variable sized field structure.
        FieldLength = *(PUINT32)pVariableField;
        TRC_DBG((TB, "Var field length %u", FieldLength));

        // If the field has changed (either in size or in contents) then we
        // need to copy it across.
        if (memcmp(pVariableField, pPrevIntFmt + pTableEntry->FieldPos,
                FieldLength + sizeof(UINT32))) {
            // Update the encoding flags.
            *pFieldFlags |= ThisFlag;

            // Work out how many elements we are encoding for this field.
            NumReps = FieldLength / pTableEntry->FieldUnencodedLen;

            // Fill in the length of the field into the encoded buffer then
            // increment the pointer ready to encode the actual field.
            // Note that the length must always be set to the length
            // required for regular second level encoding of the field,
            // regardless of whether regular encoding or delta encoding is
            // used.
            if (pTableEntry->FieldType & OE2_ETF_LONG_VARIABLE) {
                *((PUINT16_UA)pNextFreeSpace) =
                           (UINT16)(NumReps * pTableEntry->FieldEncodedLen);
                pNextFreeSpace += sizeof(UINT16);
            }
            else {
                *pNextFreeSpace++ =
                        (BYTE)(NumReps * pTableEntry->FieldEncodedLen);
            }

#ifdef USE_VARIABLE_COORDS
            // If we are encoding in delta coord mode and this field
            // is a coordinate...
            if (UseDeltaCoords &&
                    (pTableEntry->FieldType & OE2_ETF_COORDINATES) != 0) {
                // We assume that coordinates are always signed.
                if (pTableEntry->FieldUnencodedLen == 4) {
                    // Most common case: 4-byte source.
                    for (j = 0; j < NumReps; j++)
                        *pNextFreeSpace++ =
                                (char)(((__int32 *)(pVariableField +
                                  sizeof(DWORD)))[j] -
                                ((__int32 *)(pPrevIntFmt +
                                  pTableEntry->FieldPos + sizeof(DWORD)))[j]);
                }
                else if (pTableEntry->FieldUnencodedLen == 2) {
                    // Uncommon: 2-byte source.
                    for (j = 0; j < NumReps; j++)
                        *pNextFreeSpace++ =
                                (char)(((short *)(pVariableField +
                                  sizeof(DWORD)))[j] -
                                ((short *)(pPrevIntFmt +
                                  pTableEntry->FieldPos + sizeof(DWORD)))[j]);
                }
                else {
                    TRC_ASSERT((fieldLength == 2), (TB,"Unhandled field size %d",
                            pTableEntry->FieldUnencodedLen));
                }
            }
            else
#endif  // USE_VARIABLE_COORDS
            {
                // Use regular encoding.
                TRC_DBG((TB, "Encode: encLen %u, unencLen %u reps %u",
                        pTableEntry->FieldEncodedLen,
                        pTableEntry->FieldUnencodedLen,
                        NumReps));
                pNextFreeSpace = OE2EncodeFieldMultiple(
                        pVariableField + sizeof(UINT32), pNextFreeSpace,
                        pTableEntry->FieldUnencodedLen,
                        pTableEntry->FieldEncodedLen, NumReps);
            }

            // Keep data for comparison next time.
            // Note that the variable fields of pLastOrder are not packed
            // (unlike the order which we are encoding), so we can use
            // pTableEntry->FieldPos to get the start of the field.
            memcpy(pPrevIntFmt + pTableEntry->FieldPos,
                    pVariableField, FieldLength + sizeof(UINT32));
        }
        else {
            TRC_NRM((TB, "Duplicate var field length %u", FieldLength));
        }

        // Move on to the next field in the order structure, remembering to
        // step. Note that past the size field.  variable sized fields are
        // packed on the send side. (ie increment pVariableField by
        // fieldLength not by pTableEntry->FieldLen).
        pVariableField += FieldLength + sizeof(UINT32);

        // Make sure that we are at the next 4-byte boundary.
        pVariableField = (PBYTE)DC_ROUND_UP_4((UINT_PTR)pVariableField);

        ThisFlag <<= 1;
        pTableEntry++;
        i++;
    }

    *ppBuffer = pNextFreeSpace;
    DC_END_FN();
}


/****************************************************************************/
// OE2_EncodeOrder
//
// Provided with buffer space and an intermediate (OE) representation of
// order data, field-encodes the order into wire (OE2) format.
/****************************************************************************/
unsigned OE2_EncodeOrder(
        BYTE *pBuffer,
        unsigned OrderType,
        unsigned NumFields,
        BYTE *pIntFmt,
        BYTE *pPrevIntFmt,
        PINT_FMT_FIELD pFieldTable,
        RECTL *pBoundRect)
{
    BYTE *pControlFlags;
    PUINT32_UA pFieldFlags;
    unsigned NumFieldFlagBytes;

    DC_BEGIN_FN("OE2_EncodeOrder");

    TRC_ASSERT((OrderType < TS_MAX_ORDERS),
            (TB,"Ordertype %u exceeds max", OrderType));
    TRC_ASSERT((NumFields == OE2OrdAttr[OrderType].NumFields),
            (TB,"Ordertype %u does not have %u fields", OrderType,
            OE2OrdAttr[OrderType].NumFields));
    TRC_ASSERT((pFieldTable == OE2OrdAttr[OrderType].pFieldTable),
            (TB,"Ord table %p does not match ordtype %u's table %p",
            pFieldTable, OrderType, OE2OrdAttr[OrderType].pFieldTable));

    // The first byte is always a control flag byte.
    pControlFlags = pBuffer;
    *pControlFlags = TS_STANDARD;
    pBuffer++;

    // Add the order change if need be.
    OE2_EncodeOrderType(pControlFlags, &pBuffer, OrderType);

    // Make room for the field flags.
    pFieldFlags = (PUINT32_UA)pBuffer;
    *pFieldFlags = 0;
    NumFieldFlagBytes = ((NumFields + 1) + 7) / 8;
    pBuffer += NumFieldFlagBytes;

    // Bounds before encoded fields.
    if (pBoundRect != NULL)
        OE2_EncodeBounds(pControlFlags, &pBuffer, pBoundRect);

    // Use the translation table to convert the internal format to wire
    // format.
    OE2_TableEncodeOrderFields(pControlFlags, pFieldFlags, &pBuffer,
            pFieldTable, NumFields, pIntFmt, pPrevIntFmt);

    // Check to see if we can optimize the field flag bytes.
    pBuffer -= OE2_CheckZeroFlagBytes(pControlFlags,
            (BYTE *)pFieldFlags, NumFieldFlagBytes,
            (unsigned)(pBuffer - (BYTE *)pFieldFlags - NumFieldFlagBytes));

    DC_END_FN();
    return (unsigned)(pBuffer - pControlFlags);
}


/****************************************************************************/
// OE2EncodeFieldSingle
//
// Encodes an element by copying it to the destination, doing a width
// conversion if need be. Returns the new pDest value incremented by the
// length used.
//
// We can ignore signed values since we only ever truncate the data.
// Consider the case where we have a 16 bit integer that we want to
// convert to 8 bits.  We know our values are permissable within the
// lower integer size (ie.  we know the unsigned value will be less
// than 256 of that a signed value will be -128 >= value >= 127), so we
// just need to make sure that we have the right high bit set.
// But this must be the case for a 16-bit equivalent of an 8-bit
// number.  No problems - just take the truncated integer.
/****************************************************************************/
BYTE *OE2EncodeFieldSingle(
        void     *pSrc,
        BYTE     *pDest,
        unsigned srcFieldLength,
        unsigned destFieldLength)
{
    DC_BEGIN_FN("OE2EncodeFieldSingle");

    // Note that the source should always be aligned, but the destination
    // may not be.

    // Most common case: 4-byte source.
    if (srcFieldLength == 4) {
        // Most common case: 2-byte destination.
        if (destFieldLength == 2)
            *((UNALIGNED unsigned short *)pDest) = *((unsigned short *)pSrc);

        // Second most common: 1-byte destination.
        else if (destFieldLength == 1)
            *pDest = *((BYTE *)pSrc);

        // Only other allowed case, very rare: 4-byte destination.
        else if (destFieldLength == 4)
            *((UNALIGNED DWORD *)pDest) = *((DWORD *)pSrc);

        else
            TRC_ASSERT((destFieldLength == 4),
                    (TB,"Src len = 4, unhandled dest len %d",
                    destFieldLength));
    }

    // Next most common case: Color entries. Avoid pipeline-costly memcpy
    // since it's short.
    else if (srcFieldLength == 3) {
        pDest[0] = ((BYTE *)pSrc)[0];
        pDest[1] = ((BYTE *)pSrc)[1];
        pDest[2] = ((BYTE *)pSrc)[2];
    }
    
    // Somewhat common (usually cache indices): 2-byte source.
    else if (srcFieldLength == 2) {
        if (destFieldLength == 2)
            *((UNALIGNED unsigned short *)pDest) = *((unsigned short *)pSrc);
        else if (destFieldLength == 1)
            *pDest = *((BYTE *)pSrc);
        else
            TRC_ASSERT((destFieldLength == 1),
                    (TB,"Src len = 2, unhandled dest len %d",
                    destFieldLength));
    }

    // Next: Same-sized fields, including rare 1-byte fields and brushes etc.
    else if (srcFieldLength == destFieldLength) {
        memcpy(pDest, pSrc, srcFieldLength);
    }
    
    // We didn't handle the combination.
    else {
        TRC_ASSERT((destFieldLength == srcFieldLength),
                (TB,"Unhandled encode conbination, src len = %d, dest len %d",
                srcFieldLength, destFieldLength));
    }

    DC_END_FN();
    return pDest + destFieldLength;
}


/****************************************************************************/
// OE2EncodeFieldMultiple
// Encodes an array of elements by copying them to the destination, doing a
// width conversion if need be. Returns the new pDest value incremented by
// the length used.
//
// See notes for OE2EncodeFieldSingle above for signed value truncation info.
/****************************************************************************/
BYTE *OE2EncodeFieldMultiple(
        void     *pSrc,
        BYTE     *pDest,
        unsigned srcFieldLength,
        unsigned destFieldLength,
        unsigned numElements)
{
    unsigned i;

    DC_BEGIN_FN("OE2EncodeFieldMultiple");

    // Note that the source should always be aligned, but the destination
    // may not be.

    // Most common case: 1-byte source to 1-byte destination.
    if (srcFieldLength == 1) {
        memcpy(pDest, pSrc, numElements);
    }
    
    // Next most common: 4-byte source.
    else if (srcFieldLength == 4) {
        // Common: 2-byte destination.
        if (destFieldLength == 2)
            for (i = 0; i < numElements; i++)
                ((UNALIGNED unsigned short *)pDest)[i] =
                        (unsigned short)((DWORD *)pSrc)[i];

        // Less common: 1-byte destination.
        else if (destFieldLength == 1)
            for (i = 0; i < numElements; i++)
                pDest[i] = (BYTE)((DWORD *)pSrc)[i];

        // Rare if any: 4-byte destination.
        else if (destFieldLength == 4)
            for (i = 0; i < numElements; i++)
                ((UNALIGNED DWORD *)pDest)[i] = ((DWORD *)pSrc)[i];

        else
            TRC_ASSERT((destFieldLength == 4),
                    (TB,"Src len = 4, unhandled dest len %d",
                    destFieldLength));
    }
    
    // We don't handle anything else.
    else {
        TRC_ASSERT((srcFieldLength == 4),
                (TB,"Unhandled encode conbination, src len = %d, dest len %d",
                srcFieldLength, destFieldLength));
    }

    DC_END_FN();
    return pDest + destFieldLength * numElements;
}


#ifdef DC_DEBUG

/****************************************************************************/
// OE2PerformUnitTests
//
// Debug-only test code designed to ensure OE2 is functioning properly.
/****************************************************************************/

// Data for OE2_EncodeBounds test. Note that EncBounds converts to inclusive
// coordinates.
const RECTL BoundsTest1_InputRect = { 0x100, 0x200, 0x300, 0x400 };
#define BoundsTest1_OutputLen 9
const BYTE BoundsTest1_Output[BoundsTest1_OutputLen] =
    { 0x0F, 0x00, 0x01, 0x00, 0x02, 0xFF, 0x02, 0xFF, 0x03 };

const RECTL BoundsTest2_InputRect = { 0x101, 0x202, 0x303, 0x404 };
#define BoundsTest2_OutputLen 5
const BYTE BoundsTest2_Output[BoundsTest2_OutputLen] =
    { 0xF0, 0x01, 0x02, 0x03, 0x04 };

const RECTL BoundsTest3_InputRect = { 0x101, 0x202, 0x303, 0x404 };
#define BoundsTest3_OutputLen 0


// Data for ScrBlt test encoding via OE2_EncodeOrder.
const SCRBLT_ORDER OrderTest1_IntOrderFmt =
{
    0, 0,  // dest left, top
    0x200, 0x100,  // width, height
    0xCC,  // rop=copyrop
    0x201, 0x101   // src left, top
};

SCRBLT_ORDER UnitTestPrevScrBlt;

#define OrderTest1_OutputLen 12
const BYTE OrderTest1_Output[OrderTest1_OutputLen] =
{
    0x09,  // Control flags: TS_STANDARD | TS_TYPE_CHANGE
    TS_ENC_SCRBLT_ORDER,
    0x7C,  // Field flags byte: width, height, rop, srcleft, srctop
    0x00, 0x02,  // width
    0x00, 0x01,  // height
    0xCC,  // rop
    0x01, 0x02,  // srcleft
    0x01, 0x01,  // srctop
};    

void OE2PerformUnitTests()
{
    BYTE *pBuffer;
    BYTE ControlFlags;
    RECTL InputRect;
    BYTE OutputBuffer[256];
    unsigned Len;

    DC_BEGIN_FN("OE2PerformUnitTests");

    // Test OE2_EncodeBounds.
    // Reset the bounds, then perform a few rect encodings (regular, delta,
    // zero delta) to make sure the bounds are being encoded properly and
    // the control flags come out right.
    memset(&oe2LastBounds, 0, sizeof(oe2LastBounds));

    // First rect: should result in non-delta, non-zero-delta encoding.
    ControlFlags = TS_STANDARD | TS_BOUNDS;
    pBuffer = OutputBuffer;
    OE2_EncodeBounds(&ControlFlags, &pBuffer, (RECTL *)&BoundsTest1_InputRect);
    Len = (unsigned)(pBuffer - OutputBuffer);
    TRC_ASSERT((ControlFlags == (TS_STANDARD | TS_BOUNDS)),
            (TB,"Bounds1: Control flag value 0x%02X does not match "
            "expected 0x%02X", ControlFlags, (TS_STANDARD | TS_BOUNDS)));
    TRC_ASSERT((Len == BoundsTest1_OutputLen),
            (TB,"Bounds1: Len %u != expected %u", Len, BoundsTest1_OutputLen));
    TRC_ASSERT((!memcmp(OutputBuffer, BoundsTest1_Output, Len)),
            (TB,"Bounds1: Mem at %p != expected at %p (Len=%u)",
            OutputBuffer, BoundsTest1_Output, Len));

    // Second rect: should result in delta encoding.
    ControlFlags = TS_STANDARD | TS_BOUNDS;
    pBuffer = OutputBuffer;
    OE2_EncodeBounds(&ControlFlags, &pBuffer, (RECTL *)&BoundsTest2_InputRect);
    Len = (unsigned)(pBuffer - OutputBuffer);
    TRC_ASSERT((ControlFlags == (TS_STANDARD | TS_BOUNDS)),
            (TB,"Bounds2: Control flag value 0x%02X does not match "
            "expected 0x%02X", ControlFlags, (TS_STANDARD | TS_BOUNDS)));
    TRC_ASSERT((Len == BoundsTest2_OutputLen),
            (TB,"Bounds2: Len %u != expected %u", Len, BoundsTest2_OutputLen));
    TRC_ASSERT((!memcmp(OutputBuffer, BoundsTest2_Output, Len)),
            (TB,"Bounds2: Mem at %p != expected at %p (Len=%u)",
            OutputBuffer, BoundsTest2_Output, Len));

    // Third rect: Should result in zero-delta encoding.
    ControlFlags = TS_STANDARD | TS_BOUNDS;
    pBuffer = OutputBuffer;
    OE2_EncodeBounds(&ControlFlags, &pBuffer, (RECTL *)&BoundsTest3_InputRect);
    Len = (unsigned)(pBuffer - OutputBuffer);
    TRC_ASSERT((ControlFlags ==
            (TS_STANDARD | TS_BOUNDS | TS_ZERO_BOUNDS_DELTAS)),
            (TB,"Bounds3: Control flag value 0x%02X does not match "
            "expected 0x%02X", ControlFlags,
            (TS_STANDARD | TS_BOUNDS | TS_ZERO_BOUNDS_DELTAS)));
    TRC_ASSERT((Len == BoundsTest3_OutputLen),
            (TB,"Bounds3: Len %u != expected %u", Len, BoundsTest3_OutputLen));

    // Reset the bounds after the encoding test.
    memset(&oe2LastBounds, 0, sizeof(oe2LastBounds));


    // Test OE2_EncodeOrder by encoding a ScrBlt order. We need to make sure
    // oe2LastOrderType is reset to default (PatBlt). Reset the prev ScrBlt
    // to an initial state.
    oe2LastOrderType = TS_ENC_PATBLT_ORDER;
    memset(&UnitTestPrevScrBlt, 0, sizeof(UnitTestPrevScrBlt));
    Len = OE2_EncodeOrder(OutputBuffer, TS_ENC_SCRBLT_ORDER,
            NUM_SCRBLT_FIELDS, (BYTE *)&OrderTest1_IntOrderFmt,
            (BYTE *)&UnitTestPrevScrBlt, etable_SB, NULL);
    TRC_ASSERT((Len == OrderTest1_OutputLen),
            (TB,"Order1: Len %u != expected %u", Len, OrderTest1_OutputLen));
    TRC_ASSERT((!memcmp(OutputBuffer, OrderTest1_Output, Len)),
            (TB,"Order1: Mem at %p != expected at %p (Len=%u)",
            OutputBuffer, OrderTest1_Output, Len));

    DC_END_FN();
}

#endif  // DC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpdd\oe2data.c ===
/****************************************************************************/
// oe2data.c
//
// RDP field encoding global data.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <ndcgdata.h>
#include <aordprot.h>


// Encoding state.
DC_DATA(unsigned, oe2LastOrderType, TS_ENC_PATBLT_ORDER);
DC_DATA(RECTL, oe2LastBounds, { 0 });


/****************************************************************************/
// Field encoding translation tables
//
// Entries can be of fixed size of variable size. Variable size entries
// must be the last in each order structure.
/****************************************************************************/

// Fields can either be signed (INT16 etc), or unsigned (UINT16 etc).
#define SIGNED_FIELD   TRUE
#define UNSIGNED_FIELD FALSE

// INT_FMT_FIELD entry flag types.
#define OE2_ETF_FIXED         0x01
#define OE2_ETF_VARIABLE      0x02
#define OE2_ETF_COORDINATES   0x04
#define OE2_ETF_DATA          0x08
#define OE2_ETF_LONG_VARIABLE 0x10


/****************************************************************************/
/* Field is a fixed size                                                    */
/*   type   - The unencoded order structure type                            */
/*   size   - The size of the encoded version of the field                  */
/*   signed - Is the field a signed field ?                                 */
/*   field  - The name of the field in the order structure                  */
/****************************************************************************/
#define ETABLE_FIXED_ENTRY(type,size,signed,field)      \
  { (unsigned)FIELDOFFSET(type,field),                            \
    (unsigned)FIELDSIZE(type,field),                              \
    size,                                               \
    signed,                                             \
    (unsigned)(OE2_ETF_FIXED) }

/****************************************************************************/
/* Field is coordinate of a fixed size                                      */
/*   type   - The unencoded order structure type                            */
/*   size   - The size of the encoded version of the field                  */
/*   signed - Is the field a signed field ?                                 */
/*   field  - The name of the field in the order structure                  */
/****************************************************************************/
#define ETABLE_FIXED_COORDS_ENTRY(type,size,signed,field)      \
  { (unsigned)FIELDOFFSET(type,field),                            \
    (unsigned)FIELDSIZE(type,field),                              \
    size,                                               \
    signed,                                             \
    (unsigned)(OE2_ETF_FIXED|OE2_ETF_COORDINATES) }

/****************************************************************************/
/* Field is a fixed number of bytes (array?)                                */
/*   type   - The unencoded order structure type                            */
/*   size   - The number of bytes in the encoded version of the field       */
/*   signed - Is the field a signed field ?                                 */
/*   field  - The name of the field in the order structure                  */
/****************************************************************************/
#define ETABLE_DATA_ENTRY(type,size,signed,field)       \
  { (unsigned)FIELDOFFSET(type,field),                            \
    (unsigned)FIELDSIZE(type,field),                              \
    size,                                               \
    signed,                                             \
    (unsigned)(OE2_ETF_FIXED|OE2_ETF_DATA) }

/****************************************************************************/
/* Field is a variable structure with its length encoded in ONE byte and    */
/* containing coords of the form                                            */
/*   typedef struct                                                         */
/*   {                                                                      */
/*      UINT32 len;                                                         */
/*      varType  varEntry[len];                                             */
/*   } varStruct                                                            */
/*                                                                          */
/*   type   - The unencoded order structure type                            */
/*   size   - The size of the encoded version of the field                  */
/*   signed - Is the field a signed field ?                                 */
/*   field  - The name of the field in the order structure (varStruct)      */
/*   elem   - The name of the variable element array (varEntry)             */
/****************************************************************************/
#define ETABLE_VARIABLE_ENTRY(type,size,signed,field,elem)     \
  { (unsigned)FIELDOFFSET(type,field.len),                        \
    (unsigned)FIELDSIZE(type,field.elem[0]),                      \
    size,                                               \
    signed,                                             \
    (unsigned)(OE2_ETF_VARIABLE)}

/****************************************************************************/
/* Field is a variable structure with its length encoded in TWO bytes and   */
/* containing coords of the form                                            */
/*   typedef struct                                                         */
/*   {                                                                      */
/*      UINT32 len;                                                         */
/*      varType  varEntry[len];                                             */
/*   } varStruct                                                            */
/*                                                                          */
/*   type   - The unencoded order structure type                            */
/*   size   - The size of the encoded version of the field                  */
/*   signed - Is the field a signed field ?                                 */
/*   field  - The name of the field in the order structure (varStruct)      */
/*   elem   - The name of the variable element array (varEntry)             */
/****************************************************************************/
#define ETABLE_LONG_VARIABLE_ENTRY(type,size,signed,field,elem)     \
  { (unsigned)FIELDOFFSET(type,field.len),                        \
    (unsigned)FIELDSIZE(type,field.elem[0]),                      \
    size,                                               \
    signed,                                             \
    (unsigned)(OE2_ETF_LONG_VARIABLE)}

#ifdef USE_VARIABLE_COORDS
/****************************************************************************/
/* Field is a variable structure with its length encoded in ONE byte and    */
/* containing coords of the form                                            */
/*   typedef struct                                                         */
/*   {                                                                      */
/*      UINT32 len;                                                         */
/*      varCoord varEntry[len];                                             */
/*   } varStruct                                                            */
/*                                                                          */
/*   type   - The unencoded order structure type                            */
/*   size   - The size of the encoded version of the field                  */
/*   signed - Is the field a signed field ?                                 */
/*   field  - The name of the field in the order structure (varStruct)      */
/*   elem   - The name of the variable element array (varEntry)             */
/****************************************************************************/
#define ETABLE_VARIABLE_COORDS_ENTRY(type,size,signed,field,elem)   \
  { (unsigned)FIELDOFFSET(type,field.len),                                    \
    (unsigned)FIELDSIZE(type,field.elem[0]),                                  \
    size,                                                           \
    signed,                                                         \
    (unsigned)(OE2_ETF_VARIABLE|OE2_ETF_COORDINATES)}

/****************************************************************************/
/* Field is a variable structure with its length encoded in two bytes and   */
/* containing coords of the form                                            */
/*   typedef struct                                                         */
/*   {                                                                      */
/*      UINT32 len;                                                       */
/*      varCoord varEntry[len];                                             */
/*   } varStruct                                                            */
/*                                                                          */
/*   type   - The unencoded order structure type                            */
/*   size   - The size of the encoded version of the field                  */
/*   signed - Is the field a signed field ?                                 */
/*   field  - The name of the field in the order structure (varStruct)      */
/*   elem   - The name of the variable element array (varEntry)             */
/****************************************************************************/
#define ETABLE_LONG_VARIABLE_COORDS_ENTRY(type,size,signed,field,elem)   \
  { (unsigned)FIELDOFFSET(type,field.len),                                    \
    (unsigned)FIELDSIZE(type,field.elem[0]),                                  \
    size,                                                           \
    signed,                                                         \
    (unsigned)(OE2_ETF_LONG_VARIABLE | OE2_ETF_COORDINATES)}
#endif  // USE_VARIABLE_COORDS


// Direct-encoded.
#if 0
/****************************************************************************/
// DSTBLT_ORDER
/****************************************************************************/
DC_CONST_DATA_ARRAY(INT_FMT_FIELD, etable_DB, NUM_DSTBLT_FIELDS,
    DC_STRUCT5(
        ETABLE_FIXED_COORDS_ENTRY(DSTBLT_ORDER, 2, SIGNED_FIELD, nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(DSTBLT_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(DSTBLT_ORDER, 2, SIGNED_FIELD, nWidth),
        ETABLE_FIXED_COORDS_ENTRY(DSTBLT_ORDER, 2, SIGNED_FIELD, nHeight),
        ETABLE_FIXED_ENTRY(DSTBLT_ORDER, 1, UNSIGNED_FIELD, bRop),
    ));
#endif


// Direct-encoded.
#if 0
/****************************************************************************/
// PATBLT_ORDER
/****************************************************************************/
DC_CONST_DATA_ARRAY(INT_FMT_FIELD, etable_PB, NUM_PATBLT_FIELDS,
    DC_STRUCT12(
        ETABLE_FIXED_COORDS_ENTRY(PATBLT_ORDER, 2, SIGNED_FIELD, nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(PATBLT_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(PATBLT_ORDER, 2, SIGNED_FIELD, nWidth),
        ETABLE_FIXED_COORDS_ENTRY(PATBLT_ORDER, 2, SIGNED_FIELD, nHeight),
        ETABLE_FIXED_ENTRY(PATBLT_ORDER, 1, UNSIGNED_FIELD, bRop),
        ETABLE_DATA_ENTRY(PATBLT_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_DATA_ENTRY(PATBLT_ORDER, 3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_ENTRY(PATBLT_ORDER, 1, SIGNED_FIELD, BrushOrgX),
        ETABLE_FIXED_ENTRY(PATBLT_ORDER, 1, SIGNED_FIELD, BrushOrgY),
        ETABLE_FIXED_ENTRY(PATBLT_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
        ETABLE_FIXED_ENTRY(PATBLT_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
        ETABLE_DATA_ENTRY(PATBLT_ORDER, 7, UNSIGNED_FIELD, BrushExtra),
    ));
#endif


/****************************************************************************/
// SCRBLT_ORDER
/****************************************************************************/
DC_CONST_DATA_ARRAY(INT_FMT_FIELD, etable_SB, NUM_SCRBLT_FIELDS,
    DC_STRUCT7(
        ETABLE_FIXED_COORDS_ENTRY(SCRBLT_ORDER, 2, SIGNED_FIELD, nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(SCRBLT_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(SCRBLT_ORDER, 2, SIGNED_FIELD, nWidth),
        ETABLE_FIXED_COORDS_ENTRY(SCRBLT_ORDER, 2, SIGNED_FIELD, nHeight),
        ETABLE_FIXED_ENTRY(SCRBLT_ORDER, 1, UNSIGNED_FIELD, bRop),
        ETABLE_FIXED_COORDS_ENTRY(SCRBLT_ORDER, 2, SIGNED_FIELD, nXSrc),
        ETABLE_FIXED_COORDS_ENTRY(SCRBLT_ORDER, 2, SIGNED_FIELD, nYSrc)
    ));


// Direct-encoded.
#if 0
/****************************************************************************/
// LINETO_ORDER
/****************************************************************************/
DC_CONST_DATA_ARRAY(INT_FMT_FIELD, etable_LT, NUM_LINETO_FIELDS,
    DC_STRUCT10(
        ETABLE_FIXED_ENTRY(LINETO_ORDER, 2, SIGNED_FIELD, BackMode),
        ETABLE_FIXED_COORDS_ENTRY(LINETO_ORDER, 2, SIGNED_FIELD, nXStart),
        ETABLE_FIXED_COORDS_ENTRY(LINETO_ORDER, 2, SIGNED_FIELD, nYStart),
        ETABLE_FIXED_COORDS_ENTRY(LINETO_ORDER, 2, SIGNED_FIELD, nXEnd),
        ETABLE_FIXED_COORDS_ENTRY(LINETO_ORDER, 2, SIGNED_FIELD, nYEnd),
        ETABLE_DATA_ENTRY(LINETO_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_FIXED_ENTRY(LINETO_ORDER, 1, UNSIGNED_FIELD, ROP2),
        ETABLE_FIXED_ENTRY(LINETO_ORDER, 1, UNSIGNED_FIELD, PenStyle),
        ETABLE_FIXED_ENTRY(LINETO_ORDER, 1, UNSIGNED_FIELD, PenWidth),
        ETABLE_DATA_ENTRY(LINETO_ORDER, 3, UNSIGNED_FIELD, PenColor)
    ));
#endif


// Direct-encoded.
#if 0
/****************************************************************************/
// MULTI_DSTBLT_ORDER
/****************************************************************************/
DC_CONST_DATA_ARRAY(INT_FMT_FIELD, etable_MD, NUM_MULTI_DSTBLT_FIELDS,
    DC_STRUCT7(
        ETABLE_FIXED_COORDS_ENTRY(MULTI_DSTBLT_ORDER, 2, SIGNED_FIELD,   nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(MULTI_DSTBLT_ORDER, 2, SIGNED_FIELD,   nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(MULTI_DSTBLT_ORDER, 2, SIGNED_FIELD,   nWidth),
        ETABLE_FIXED_COORDS_ENTRY(MULTI_DSTBLT_ORDER, 2, SIGNED_FIELD,   nHeight),
        ETABLE_FIXED_ENTRY       (MULTI_DSTBLT_ORDER, 1, UNSIGNED_FIELD, bRop),
        ETABLE_FIXED_ENTRY       (MULTI_DSTBLT_ORDER, 1, UNSIGNED_FIELD, nDeltaEntries),
        ETABLE_LONG_VARIABLE_ENTRY    (MULTI_DSTBLT_ORDER, 1, UNSIGNED_FIELD, codedDeltaList, Deltas)
    ));
#endif


// Direct-encoded.
#if 0
/****************************************************************************/
// MULTI_PATBLT_ORDER
/****************************************************************************/
DC_CONST_DATA_ARRAY(INT_FMT_FIELD, etable_MP, NUM_MULTI_PATBLT_FIELDS,
    DC_STRUCT14(
        ETABLE_FIXED_COORDS_ENTRY(MULTI_PATBLT_ORDER, 2, SIGNED_FIELD,   nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(MULTI_PATBLT_ORDER, 2, SIGNED_FIELD,   nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(MULTI_PATBLT_ORDER, 2, SIGNED_FIELD,   nWidth),
        ETABLE_FIXED_COORDS_ENTRY(MULTI_PATBLT_ORDER, 2, SIGNED_FIELD,   nHeight),
        ETABLE_FIXED_ENTRY       (MULTI_PATBLT_ORDER, 1, UNSIGNED_FIELD, bRop),
        ETABLE_DATA_ENTRY        (MULTI_PATBLT_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_DATA_ENTRY        (MULTI_PATBLT_ORDER, 3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_ENTRY       (MULTI_PATBLT_ORDER, 1, SIGNED_FIELD,   BrushOrgX),
        ETABLE_FIXED_ENTRY       (MULTI_PATBLT_ORDER, 1, SIGNED_FIELD,   BrushOrgY),
        ETABLE_FIXED_ENTRY       (MULTI_PATBLT_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
        ETABLE_FIXED_ENTRY       (MULTI_PATBLT_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
        ETABLE_DATA_ENTRY        (MULTI_PATBLT_ORDER, 7, UNSIGNED_FIELD, BrushExtra),
        ETABLE_FIXED_ENTRY       (MULTI_PATBLT_ORDER, 1, UNSIGNED_FIELD, nDeltaEntries),
        ETABLE_LONG_VARIABLE_ENTRY(MULTI_PATBLT_ORDER, 1, UNSIGNED_FIELD, codedDeltaList, Deltas)
    ));
#endif


/****************************************************************************/
// MULTI_SCRBLT_ORDER
/****************************************************************************/
DC_CONST_DATA_ARRAY(INT_FMT_FIELD, etable_MS, NUM_MULTI_SCRBLT_FIELDS,
    DC_STRUCT9(
        ETABLE_FIXED_COORDS_ENTRY(MULTI_SCRBLT_ORDER, 2, SIGNED_FIELD,   nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(MULTI_SCRBLT_ORDER, 2, SIGNED_FIELD,   nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(MULTI_SCRBLT_ORDER, 2, SIGNED_FIELD,   nWidth),
        ETABLE_FIXED_COORDS_ENTRY(MULTI_SCRBLT_ORDER, 2, SIGNED_FIELD,   nHeight),
        ETABLE_FIXED_ENTRY       (MULTI_SCRBLT_ORDER, 1, UNSIGNED_FIELD, bRop),
        ETABLE_FIXED_COORDS_ENTRY(MULTI_SCRBLT_ORDER, 2, SIGNED_FIELD,   nXSrc),
        ETABLE_FIXED_COORDS_ENTRY(MULTI_SCRBLT_ORDER, 2, SIGNED_FIELD,   nYSrc),
        ETABLE_FIXED_ENTRY       (MULTI_SCRBLT_ORDER, 1, UNSIGNED_FIELD, nDeltaEntries),
        ETABLE_LONG_VARIABLE_ENTRY    (MULTI_SCRBLT_ORDER, 1, UNSIGNED_FIELD, codedDeltaList, Deltas)
    ));


// Direct-encoded.
#if 0
/****************************************************************************/
// MULTI_OPAQUERECT_ORDER
/****************************************************************************/
DC_CONST_DATA_ARRAY(INT_FMT_FIELD, etable_MO, NUM_MULTI_OPAQUERECT_FIELDS,
    DC_STRUCT9(
        ETABLE_FIXED_COORDS_ENTRY(MULTI_OPAQUERECT_ORDER, 2, SIGNED_FIELD,   nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(MULTI_OPAQUERECT_ORDER, 2, SIGNED_FIELD,   nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(MULTI_OPAQUERECT_ORDER, 2, SIGNED_FIELD,   nWidth),
        ETABLE_FIXED_COORDS_ENTRY(MULTI_OPAQUERECT_ORDER, 2, SIGNED_FIELD,   nHeight),
        ETABLE_DATA_ENTRY        (MULTI_OPAQUERECT_ORDER, 1, UNSIGNED_FIELD, Color.u.rgb.red),
        ETABLE_DATA_ENTRY        (MULTI_OPAQUERECT_ORDER, 1, UNSIGNED_FIELD, Color.u.rgb.green),
        ETABLE_DATA_ENTRY        (MULTI_OPAQUERECT_ORDER, 1, UNSIGNED_FIELD, Color.u.rgb.blue),
        ETABLE_FIXED_ENTRY       (MULTI_OPAQUERECT_ORDER, 1, UNSIGNED_FIELD, nDeltaEntries),
        ETABLE_LONG_VARIABLE_ENTRY    (MULTI_OPAQUERECT_ORDER, 1, UNSIGNED_FIELD, codedDeltaList, Deltas)
    ));
#endif


/****************************************************************************/
// FAST_INDEX_ORDER
/****************************************************************************/
DC_CONST_DATA_ARRAY(INT_FMT_FIELD, etable_FI, NUM_FAST_INDEX_FIELDS,
    DC_STRUCT15(
        ETABLE_DATA_ENTRY(FAST_INDEX_ORDER,  1, UNSIGNED_FIELD, cacheId),
        ETABLE_DATA_ENTRY(FAST_INDEX_ORDER,  2, UNSIGNED_FIELD, fDrawing),
        ETABLE_DATA_ENTRY(FAST_INDEX_ORDER,  3, UNSIGNED_FIELD, BackColor),
        ETABLE_DATA_ENTRY(FAST_INDEX_ORDER,  3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_COORDS_ENTRY(FAST_INDEX_ORDER, 2, SIGNED_FIELD,   BkLeft),
        ETABLE_FIXED_COORDS_ENTRY(FAST_INDEX_ORDER, 2, SIGNED_FIELD,   BkTop),
        ETABLE_FIXED_COORDS_ENTRY(FAST_INDEX_ORDER, 2, SIGNED_FIELD,   BkRight),
        ETABLE_FIXED_COORDS_ENTRY(FAST_INDEX_ORDER, 2, SIGNED_FIELD,   BkBottom),
        ETABLE_FIXED_COORDS_ENTRY(FAST_INDEX_ORDER, 2, SIGNED_FIELD,   OpLeft),
        ETABLE_FIXED_COORDS_ENTRY(FAST_INDEX_ORDER, 2, SIGNED_FIELD,   OpTop),
        ETABLE_FIXED_COORDS_ENTRY(FAST_INDEX_ORDER, 2, SIGNED_FIELD,   OpRight),
        ETABLE_FIXED_COORDS_ENTRY(FAST_INDEX_ORDER, 2, SIGNED_FIELD,   OpBottom),
        ETABLE_FIXED_COORDS_ENTRY(FAST_INDEX_ORDER, 2, SIGNED_FIELD,   x),
        ETABLE_FIXED_COORDS_ENTRY(FAST_INDEX_ORDER, 2, SIGNED_FIELD,   y),
        ETABLE_VARIABLE_ENTRY(FAST_INDEX_ORDER, 1, UNSIGNED_FIELD, variableBytes, arecs)
    ));


/****************************************************************************/
// POLYGON_SC_ORDER
/****************************************************************************/
DC_CONST_DATA_ARRAY(INT_FMT_FIELD, etable_CG, NUM_POLYGON_SC_FIELDS,
    DC_STRUCT7(
        ETABLE_FIXED_COORDS_ENTRY(POLYGON_SC_ORDER, 2, SIGNED_FIELD, XStart),
        ETABLE_FIXED_COORDS_ENTRY(POLYGON_SC_ORDER, 2, SIGNED_FIELD, YStart),
        ETABLE_FIXED_ENTRY(POLYGON_SC_ORDER, 1, UNSIGNED_FIELD, ROP2),
        ETABLE_FIXED_ENTRY(POLYGON_SC_ORDER, 1, UNSIGNED_FIELD, FillMode),
        ETABLE_DATA_ENTRY(POLYGON_SC_ORDER, 3, UNSIGNED_FIELD, BrushColor),        
        ETABLE_FIXED_ENTRY(POLYGON_SC_ORDER, 1, UNSIGNED_FIELD,
                                                      NumDeltaEntries),
        ETABLE_VARIABLE_ENTRY(POLYGON_SC_ORDER, 1, UNSIGNED_FIELD,
                                                      CodedDeltaList, Deltas)
    ));


/****************************************************************************/
// POLYGON_CB_ORDER
/****************************************************************************/
DC_CONST_DATA_ARRAY(INT_FMT_FIELD, etable_BG, NUM_POLYGON_CB_FIELDS,
    DC_STRUCT13(
        ETABLE_FIXED_COORDS_ENTRY(POLYGON_CB_ORDER, 2, SIGNED_FIELD, XStart),
        ETABLE_FIXED_COORDS_ENTRY(POLYGON_CB_ORDER, 2, SIGNED_FIELD, YStart),
        ETABLE_FIXED_ENTRY(POLYGON_CB_ORDER, 1, UNSIGNED_FIELD, ROP2),
        ETABLE_FIXED_ENTRY(POLYGON_CB_ORDER, 1, UNSIGNED_FIELD, FillMode),
        ETABLE_DATA_ENTRY(POLYGON_CB_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_DATA_ENTRY(POLYGON_CB_ORDER, 3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_ENTRY(POLYGON_CB_ORDER, 1, SIGNED_FIELD, BrushOrgX),
        ETABLE_FIXED_ENTRY(POLYGON_CB_ORDER, 1, SIGNED_FIELD, BrushOrgY),
        ETABLE_FIXED_ENTRY(POLYGON_CB_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
        ETABLE_FIXED_ENTRY(POLYGON_CB_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
        ETABLE_DATA_ENTRY(POLYGON_CB_ORDER, 7, UNSIGNED_FIELD, BrushExtra),        
        ETABLE_FIXED_ENTRY(POLYGON_CB_ORDER, 1, UNSIGNED_FIELD,
                                                      NumDeltaEntries),
        ETABLE_VARIABLE_ENTRY(POLYGON_CB_ORDER, 1, UNSIGNED_FIELD,
                                                      CodedDeltaList, Deltas)
    ));


// Direct-encoded.
#if 0
/****************************************************************************/
// POLYLINE_ORDER
/****************************************************************************/
DC_CONST_DATA_ARRAY(INT_FMT_FIELD, etable_PL, NUM_POLYLINE_FIELDS,
    DC_STRUCT7(
        ETABLE_FIXED_COORDS_ENTRY(POLYLINE_ORDER, 2, SIGNED_FIELD, XStart),
        ETABLE_FIXED_COORDS_ENTRY(POLYLINE_ORDER, 2, SIGNED_FIELD, YStart),
        ETABLE_FIXED_ENTRY(POLYLINE_ORDER, 1, UNSIGNED_FIELD, ROP2),
        ETABLE_FIXED_ENTRY(POLYLINE_ORDER, 2, UNSIGNED_FIELD,
                                                             BrushCacheEntry),
        ETABLE_DATA_ENTRY(POLYLINE_ORDER, 3, UNSIGNED_FIELD, PenColor),
        ETABLE_FIXED_ENTRY(POLYLINE_ORDER, 1, UNSIGNED_FIELD,
                                                             NumDeltaEntries),
        ETABLE_VARIABLE_ENTRY(POLYLINE_ORDER, 1, UNSIGNED_FIELD,
                                                      CodedDeltaList, Deltas)
    ));
#endif


// Direct-encoded.
#if 0
/****************************************************************************/
// OPAQUERECT_ORDER
/****************************************************************************/
DC_CONST_DATA_ARRAY(INT_FMT_FIELD, etable_OR, NUM_OPAQUERECT_FIELDS,
    DC_STRUCT7(
        ETABLE_FIXED_COORDS_ENTRY(OPAQUERECT_ORDER, 2, SIGNED_FIELD,
                                                                   nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(OPAQUERECT_ORDER, 2, SIGNED_FIELD,
                                                                    nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(OPAQUERECT_ORDER, 2, SIGNED_FIELD, nWidth),
        ETABLE_FIXED_COORDS_ENTRY(OPAQUERECT_ORDER, 2, SIGNED_FIELD, nHeight),
        ETABLE_DATA_ENTRY(OPAQUERECT_ORDER, 1, UNSIGNED_FIELD,
                                                           Color.u.rgb.red),
        ETABLE_DATA_ENTRY(OPAQUERECT_ORDER, 1, UNSIGNED_FIELD,
                                                           Color.u.rgb.green),
        ETABLE_DATA_ENTRY(OPAQUERECT_ORDER, 1, UNSIGNED_FIELD,
                                                           Color.u.rgb.blue)
    ));
#endif


/****************************************************************************/
// SAVEBITMAP_ORDER
/****************************************************************************/
DC_CONST_DATA_ARRAY(INT_FMT_FIELD, etable_SV, NUM_SAVEBITMAP_FIELDS,
    DC_STRUCT6(
        ETABLE_FIXED_ENTRY(SAVEBITMAP_ORDER, 4, UNSIGNED_FIELD,
                                                         SavedBitmapPosition),
        ETABLE_FIXED_COORDS_ENTRY(SAVEBITMAP_ORDER, 2, SIGNED_FIELD,
                                                                   nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(SAVEBITMAP_ORDER, 2, SIGNED_FIELD,
                                                                    nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(SAVEBITMAP_ORDER, 2, SIGNED_FIELD,
                                                                  nRightRect),
        ETABLE_FIXED_COORDS_ENTRY(SAVEBITMAP_ORDER, 2, SIGNED_FIELD,
                                                                 nBottomRect),
        ETABLE_FIXED_ENTRY(SAVEBITMAP_ORDER, 1, UNSIGNED_FIELD, Operation)
    ));


// Direct encoded.
#if 0
/****************************************************************************/
// MEMBLT_R2_ORDER
/****************************************************************************/
DC_CONST_DATA_ARRAY(INT_FMT_FIELD, etable_MC, NUM_MEMBLT_FIELDS,
    DC_STRUCT9(
        ETABLE_FIXED_ENTRY(MEMBLT_R2_ORDER, 2, UNSIGNED_FIELD, Common.cacheId),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_R2_ORDER, 2, SIGNED_FIELD,
                Common.nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_R2_ORDER, 2, SIGNED_FIELD,
                Common.nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_R2_ORDER, 2, SIGNED_FIELD,
                Common.nWidth),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_R2_ORDER, 2, SIGNED_FIELD,
                Common.nHeight),
        ETABLE_FIXED_ENTRY(MEMBLT_R2_ORDER, 1, UNSIGNED_FIELD,
                Common.bRop),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_R2_ORDER, 2, SIGNED_FIELD,
                Common.nXSrc),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_R2_ORDER, 2, SIGNED_FIELD,
                Common.nYSrc),
        ETABLE_FIXED_ENTRY(MEMBLT_R2_ORDER, 2, UNSIGNED_FIELD,
                Common.cacheIndex)
    ));
#endif


/****************************************************************************/
// MEM3BLT_R2_ORDER
/****************************************************************************/
DC_CONST_DATA_ARRAY(INT_FMT_FIELD, etable_3C, NUM_MEM3BLT_FIELDS,
    DC_STRUCT16(
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 2, UNSIGNED_FIELD,
                Common.cacheId),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_R2_ORDER, 2, SIGNED_FIELD,
                Common.nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_R2_ORDER, 2, SIGNED_FIELD,
                Common.nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_R2_ORDER, 2, SIGNED_FIELD,
                Common.nWidth),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_R2_ORDER, 2, SIGNED_FIELD,
                Common.nHeight),
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 1, UNSIGNED_FIELD,
                Common.bRop),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_R2_ORDER, 2, SIGNED_FIELD,
                Common.nXSrc),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_R2_ORDER, 2, SIGNED_FIELD,
                Common.nYSrc),
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 1, SIGNED_FIELD,   BrushOrgX),
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 1, SIGNED_FIELD,   BrushOrgY),
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 7, UNSIGNED_FIELD, BrushExtra),
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 2, UNSIGNED_FIELD,
                Common.cacheIndex)
    ));


/****************************************************************************/
// FAST_GLYPH_ORDER
/****************************************************************************/
DC_CONST_DATA_ARRAY(INT_FMT_FIELD, etable_FG, NUM_FAST_GLYPH_FIELDS,
    DC_STRUCT15(
        ETABLE_DATA_ENTRY(FAST_GLYPH_ORDER,  1, UNSIGNED_FIELD, cacheId),
        ETABLE_DATA_ENTRY(FAST_GLYPH_ORDER,  2, UNSIGNED_FIELD, fDrawing),
        ETABLE_DATA_ENTRY(FAST_GLYPH_ORDER,  3, UNSIGNED_FIELD, BackColor),
        ETABLE_DATA_ENTRY(FAST_GLYPH_ORDER,  3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_COORDS_ENTRY(FAST_GLYPH_ORDER, 2, SIGNED_FIELD,   BkLeft),
        ETABLE_FIXED_COORDS_ENTRY(FAST_GLYPH_ORDER, 2, SIGNED_FIELD,   BkTop),
        ETABLE_FIXED_COORDS_ENTRY(FAST_GLYPH_ORDER, 2, SIGNED_FIELD,   BkRight),
        ETABLE_FIXED_COORDS_ENTRY(FAST_GLYPH_ORDER, 2, SIGNED_FIELD,   BkBottom),
        ETABLE_FIXED_COORDS_ENTRY(FAST_GLYPH_ORDER, 2, SIGNED_FIELD,   OpLeft),
        ETABLE_FIXED_COORDS_ENTRY(FAST_GLYPH_ORDER, 2, SIGNED_FIELD,   OpTop),
        ETABLE_FIXED_COORDS_ENTRY(FAST_GLYPH_ORDER, 2, SIGNED_FIELD,   OpRight),
        ETABLE_FIXED_COORDS_ENTRY(FAST_GLYPH_ORDER, 2, SIGNED_FIELD,   OpBottom),
        ETABLE_FIXED_COORDS_ENTRY(FAST_GLYPH_ORDER, 2, SIGNED_FIELD,   x),
        ETABLE_FIXED_COORDS_ENTRY(FAST_GLYPH_ORDER, 2, SIGNED_FIELD,   y),
        ETABLE_VARIABLE_ENTRY(FAST_GLYPH_ORDER, 1,  UNSIGNED_FIELD,
                                                  variableBytes, glyphData)
    ));


/****************************************************************************/
// ELLIPSE_SC_ORDER
/****************************************************************************/
DC_CONST_DATA_ARRAY(INT_FMT_FIELD, etable_EC, NUM_ELLIPSE_SC_FIELDS,
    DC_STRUCT7(
        ETABLE_FIXED_COORDS_ENTRY(ELLIPSE_SC_ORDER, 2, SIGNED_FIELD, LeftRect),
        ETABLE_FIXED_COORDS_ENTRY(ELLIPSE_SC_ORDER, 2, SIGNED_FIELD, TopRect),
        ETABLE_FIXED_COORDS_ENTRY(ELLIPSE_SC_ORDER, 2, SIGNED_FIELD, RightRect),
        ETABLE_FIXED_COORDS_ENTRY(ELLIPSE_SC_ORDER, 2, SIGNED_FIELD, BottomRect),
        ETABLE_FIXED_ENTRY(ELLIPSE_SC_ORDER, 1, UNSIGNED_FIELD, ROP2),
        ETABLE_FIXED_ENTRY(ELLIPSE_SC_ORDER, 1, UNSIGNED_FIELD, FillMode),
        ETABLE_DATA_ENTRY(ELLIPSE_SC_ORDER, 3, UNSIGNED_FIELD, Color)
    ));


/****************************************************************************/
// ELLIPSE_CB_ORDER
/****************************************************************************/
DC_CONST_DATA_ARRAY(INT_FMT_FIELD, etable_EB, NUM_ELLIPSE_CB_FIELDS,
    DC_STRUCT13(
        ETABLE_FIXED_COORDS_ENTRY(ELLIPSE_CB_ORDER, 2, SIGNED_FIELD, LeftRect),
        ETABLE_FIXED_COORDS_ENTRY(ELLIPSE_CB_ORDER, 2, SIGNED_FIELD, TopRect),
        ETABLE_FIXED_COORDS_ENTRY(ELLIPSE_CB_ORDER, 2, SIGNED_FIELD, RightRect),
        ETABLE_FIXED_COORDS_ENTRY(ELLIPSE_CB_ORDER, 2, SIGNED_FIELD, BottomRect),
        ETABLE_FIXED_ENTRY(ELLIPSE_CB_ORDER, 1, UNSIGNED_FIELD, ROP2),
        ETABLE_FIXED_ENTRY(ELLIPSE_CB_ORDER, 1, UNSIGNED_FIELD, FillMode),
        ETABLE_DATA_ENTRY(ELLIPSE_CB_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_DATA_ENTRY(ELLIPSE_CB_ORDER, 3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_ENTRY(ELLIPSE_CB_ORDER, 1, SIGNED_FIELD, BrushOrgX),
        ETABLE_FIXED_ENTRY(ELLIPSE_CB_ORDER, 1, SIGNED_FIELD, BrushOrgY),
        ETABLE_FIXED_ENTRY(ELLIPSE_CB_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
        ETABLE_FIXED_ENTRY(ELLIPSE_CB_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
        ETABLE_DATA_ENTRY(ELLIPSE_CB_ORDER, 7, UNSIGNED_FIELD, BrushExtra)
    ));


/****************************************************************************/
// (Glyph)INDEX_ORDER
/****************************************************************************/
DC_CONST_DATA_ARRAY(INT_FMT_FIELD, etable_GI, NUM_INDEX_FIELDS,
    DC_STRUCT22(
        ETABLE_DATA_ENTRY(INDEX_ORDER,  1, UNSIGNED_FIELD, cacheId),
        ETABLE_DATA_ENTRY(INDEX_ORDER,  1, UNSIGNED_FIELD, flAccel),
        ETABLE_DATA_ENTRY(INDEX_ORDER,  1, UNSIGNED_FIELD, ulCharInc),
        ETABLE_DATA_ENTRY(INDEX_ORDER,  1, UNSIGNED_FIELD, fOpRedundant),
        ETABLE_DATA_ENTRY(INDEX_ORDER,  3, UNSIGNED_FIELD, BackColor),
        ETABLE_DATA_ENTRY(INDEX_ORDER,  3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_ENTRY(INDEX_ORDER, 2, SIGNED_FIELD,   BkLeft),
        ETABLE_FIXED_ENTRY(INDEX_ORDER, 2, SIGNED_FIELD,   BkTop),
        ETABLE_FIXED_ENTRY(INDEX_ORDER, 2, SIGNED_FIELD,   BkRight),
        ETABLE_FIXED_ENTRY(INDEX_ORDER, 2, SIGNED_FIELD,   BkBottom),
        ETABLE_FIXED_ENTRY(INDEX_ORDER, 2, SIGNED_FIELD,   OpLeft),
        ETABLE_FIXED_ENTRY(INDEX_ORDER, 2, SIGNED_FIELD,   OpTop),
        ETABLE_FIXED_ENTRY(INDEX_ORDER, 2, SIGNED_FIELD,   OpRight),
        ETABLE_FIXED_ENTRY(INDEX_ORDER, 2, SIGNED_FIELD,   OpBottom),
        ETABLE_FIXED_ENTRY(INDEX_ORDER, 1, SIGNED_FIELD,   BrushOrgX),
        ETABLE_FIXED_ENTRY(INDEX_ORDER, 1, SIGNED_FIELD,   BrushOrgY),
        ETABLE_FIXED_ENTRY(INDEX_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
        ETABLE_FIXED_ENTRY(INDEX_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
        ETABLE_DATA_ENTRY (INDEX_ORDER, 7, UNSIGNED_FIELD, BrushExtra),
        ETABLE_FIXED_ENTRY(INDEX_ORDER, 2, SIGNED_FIELD,   x),
        ETABLE_FIXED_ENTRY(INDEX_ORDER, 2, SIGNED_FIELD,   y),
        ETABLE_VARIABLE_ENTRY(INDEX_ORDER, 1, UNSIGNED_FIELD,
                                                  variableBytes, arecs)
    ));

#ifdef DRAW_NINEGRID
/****************************************************************************/
// DRAWNINEGRID_ORDER
/****************************************************************************/
DC_CONST_DATA_ARRAY(INT_FMT_FIELD, etable_NG, NUM_DRAWNINEGRID_FIELDS,
    DC_STRUCT5(
        ETABLE_FIXED_COORDS_ENTRY(DRAWNINEGRID_ORDER, 2, SIGNED_FIELD,   srcLeft),
        ETABLE_FIXED_COORDS_ENTRY(DRAWNINEGRID_ORDER, 2, SIGNED_FIELD,   srcTop),
        ETABLE_FIXED_COORDS_ENTRY(DRAWNINEGRID_ORDER, 2, SIGNED_FIELD,   srcRight),
        ETABLE_FIXED_COORDS_ENTRY(DRAWNINEGRID_ORDER, 2, SIGNED_FIELD,   srcBottom),
        ETABLE_FIXED_ENTRY       (DRAWNINEGRID_ORDER, 2, UNSIGNED_FIELD, bitmapId)        
    ));

/****************************************************************************/
// MULTI_DRAWNINEGRID_ORDER
/****************************************************************************/
DC_CONST_DATA_ARRAY(INT_FMT_FIELD, etable_MG, NUM_MULTI_DRAWNINEGRID_FIELDS,
    DC_STRUCT7(
        ETABLE_FIXED_COORDS_ENTRY(MULTI_DRAWNINEGRID_ORDER, 2, SIGNED_FIELD,   srcLeft),
        ETABLE_FIXED_COORDS_ENTRY(MULTI_DRAWNINEGRID_ORDER, 2, SIGNED_FIELD,   srcTop),
        ETABLE_FIXED_COORDS_ENTRY(MULTI_DRAWNINEGRID_ORDER, 2, SIGNED_FIELD,   srcRight),
        ETABLE_FIXED_COORDS_ENTRY(MULTI_DRAWNINEGRID_ORDER, 2, SIGNED_FIELD,   srcBottom),
        ETABLE_FIXED_ENTRY       (MULTI_DRAWNINEGRID_ORDER, 2, UNSIGNED_FIELD, bitmapId),        
        ETABLE_FIXED_ENTRY       (MULTI_DRAWNINEGRID_ORDER, 1, UNSIGNED_FIELD, nDeltaEntries),
        ETABLE_LONG_VARIABLE_ENTRY    (MULTI_DRAWNINEGRID_ORDER, 1, UNSIGNED_FIELD, codedDeltaList, Deltas)
    ));
#endif

#ifdef DC_DEBUG
/****************************************************************************/
// Primary order information table. Used to make sure params passed into
// OE2 functions make sense.
/****************************************************************************/

typedef struct
{
    PINT_FMT_FIELD pFieldTable;
    unsigned NumFields;
    unsigned MaxSize;
} OE2_PRIMARY_ORDER_ATTRIBUTES;

#ifdef DRAW_NINEGRID
DC_CONST_DATA_ARRAY(OE2_PRIMARY_ORDER_ATTRIBUTES, OE2OrdAttr, TS_MAX_ORDERS,
DC_STRUCT32(
  DC_STRUCT3(NULL,      NUM_DSTBLT_FIELDS,      MAX_DSTBLT_FIELD_SIZE),  // direct-encode order
  DC_STRUCT3(NULL,      NUM_PATBLT_FIELDS,      MAX_PATBLT_FIELD_SIZE),  // direct-encode order
  DC_STRUCT3(etable_SB, NUM_SCRBLT_FIELDS,      MAX_SCRBLT_FIELD_SIZE),
  DC_STRUCT3(NULL,      0,                      0),
  DC_STRUCT3(NULL,      0,                      0),
  DC_STRUCT3(NULL,      0,                      0),
  DC_STRUCT3(NULL,      0,                      0),

  DC_STRUCT3(etable_NG, NUM_DRAWNINEGRID_FIELDS, MAX_DRAWNINEGRID_FIELD_SIZE),
  DC_STRUCT3(etable_MG, NUM_MULTI_DRAWNINEGRID_FIELDS, MAX_MULTI_DRAWNINEGRID_FIELD_SIZE),
  DC_STRUCT3(NULL,      NUM_LINETO_FIELDS,      MAX_LINETO_FIELD_SIZE),  // direct-encode order
  DC_STRUCT3(NULL,      NUM_OPAQUERECT_FIELDS,  MAX_OPAQUERECT_FIELD_SIZE),  // direct-encode order
  DC_STRUCT3(etable_SV, NUM_SAVEBITMAP_FIELDS,  MAX_SAVEBITMAP_FIELD_SIZE),
  DC_STRUCT3(NULL,      0,                      0),
  DC_STRUCT3(NULL,      NUM_MEMBLT_FIELDS,      MAX_MEMBLT_FIELD_SIZE),  // etable_MC not used (fast fath)
  DC_STRUCT3(etable_3C, NUM_MEM3BLT_FIELDS,     MAX_MEM3BLT_FIELD_SIZE),
  DC_STRUCT3(NULL,      NUM_MULTI_DSTBLT_FIELDS, MAX_MULTI_DSTBLT_FIELD_SIZE),  // direct-encode order
  DC_STRUCT3(NULL,      NUM_MULTI_PATBLT_FIELDS, MAX_MULTI_PATBLT_FIELD_SIZE),  // direct-encode order
  DC_STRUCT3(etable_MS, NUM_MULTI_SCRBLT_FIELDS, MAX_MULTI_SCRBLT_FIELD_SIZE),
  DC_STRUCT3(NULL,      NUM_MULTI_OPAQUERECT_FIELDS, MAX_MULTI_OPAQUERECT_FIELD_SIZE),  // direct-encode order
  DC_STRUCT3(etable_FI, NUM_FAST_INDEX_FIELDS,  MAX_FAST_INDEX_FIELD_SIZE),
  DC_STRUCT3(etable_CG, NUM_POLYGON_SC_FIELDS,  MAX_POLYGON_SC_FIELD_SIZE),
  DC_STRUCT3(etable_BG, NUM_POLYGON_CB_FIELDS,  MAX_POLYGON_CB_FIELD_SIZE),
  DC_STRUCT3(NULL,      NUM_POLYLINE_FIELDS,    MAX_POLYLINE_FIELD_SIZE),    // direct-encode order
  DC_STRUCT3(NULL,      0,                      0),
  DC_STRUCT3(etable_FG, NUM_FAST_GLYPH_FIELDS,  MAX_FAST_GLYPH_FIELD_SIZE),
  DC_STRUCT3(etable_EC, NUM_ELLIPSE_SC_FIELDS,  MAX_ELLIPSE_SC_FIELD_SIZE),
  DC_STRUCT3(etable_EB, NUM_ELLIPSE_CB_FIELDS,  MAX_ELLIPSE_CB_FIELD_SIZE),
  DC_STRUCT3(etable_GI, NUM_INDEX_FIELDS,       MAX_INDEX_FIELD_SIZE),
  DC_STRUCT3(NULL,      0,                      0),
  DC_STRUCT3(NULL,      0,                      0),
  DC_STRUCT3(NULL,      0,                      0),
  DC_STRUCT3(NULL,      0,                      0)));
#else
DC_CONST_DATA_ARRAY(OE2_PRIMARY_ORDER_ATTRIBUTES, OE2OrdAttr, TS_MAX_ORDERS,
DC_STRUCT32(
  DC_STRUCT3(NULL,      NUM_DSTBLT_FIELDS,      MAX_DSTBLT_FIELD_SIZE),  // direct-encode order
  DC_STRUCT3(NULL,      NUM_PATBLT_FIELDS,      MAX_PATBLT_FIELD_SIZE),  // direct-encode order
  DC_STRUCT3(etable_SB, NUM_SCRBLT_FIELDS,      MAX_SCRBLT_FIELD_SIZE),
  DC_STRUCT3(NULL,      0,                      0),
  DC_STRUCT3(NULL,      0,                      0),
  DC_STRUCT3(NULL,      0,                      0),
  DC_STRUCT3(NULL,      0,                      0),
  DC_STRUCT3(NULL,      0,                      0),
  DC_STRUCT3(NULL,      0,                      0),
  DC_STRUCT3(NULL,      NUM_LINETO_FIELDS,      MAX_LINETO_FIELD_SIZE),  // direct-encode order
  DC_STRUCT3(NULL,      NUM_OPAQUERECT_FIELDS,  MAX_OPAQUERECT_FIELD_SIZE),  // direct-encode order
  DC_STRUCT3(etable_SV, NUM_SAVEBITMAP_FIELDS,  MAX_SAVEBITMAP_FIELD_SIZE),
  DC_STRUCT3(NULL,      0,                      0),
  DC_STRUCT3(NULL,      NUM_MEMBLT_FIELDS,      MAX_MEMBLT_FIELD_SIZE),  // etable_MC not used (fast fath)
  DC_STRUCT3(etable_3C, NUM_MEM3BLT_FIELDS,     MAX_MEM3BLT_FIELD_SIZE),
  DC_STRUCT3(NULL,      NUM_MULTI_DSTBLT_FIELDS, MAX_MULTI_DSTBLT_FIELD_SIZE),  // direct-encode order
  DC_STRUCT3(NULL,      NUM_MULTI_PATBLT_FIELDS, MAX_MULTI_PATBLT_FIELD_SIZE),  // direct-encode order
  DC_STRUCT3(etable_MS, NUM_MULTI_SCRBLT_FIELDS, MAX_MULTI_SCRBLT_FIELD_SIZE),
  DC_STRUCT3(NULL,      NUM_MULTI_OPAQUERECT_FIELDS, MAX_MULTI_OPAQUERECT_FIELD_SIZE),  // direct-encode order
  DC_STRUCT3(etable_FI, NUM_FAST_INDEX_FIELDS,  MAX_FAST_INDEX_FIELD_SIZE),
  DC_STRUCT3(etable_CG, NUM_POLYGON_SC_FIELDS,  MAX_POLYGON_SC_FIELD_SIZE),
  DC_STRUCT3(etable_BG, NUM_POLYGON_CB_FIELDS,  MAX_POLYGON_CB_FIELD_SIZE),
  DC_STRUCT3(NULL,      NUM_POLYLINE_FIELDS,    MAX_POLYLINE_FIELD_SIZE),    // direct-encode order
  DC_STRUCT3(NULL,      0,                      0),
  DC_STRUCT3(etable_FG, NUM_FAST_GLYPH_FIELDS,  MAX_FAST_GLYPH_FIELD_SIZE),
  DC_STRUCT3(etable_EC, NUM_ELLIPSE_SC_FIELDS,  MAX_ELLIPSE_SC_FIELD_SIZE),
  DC_STRUCT3(etable_EB, NUM_ELLIPSE_CB_FIELDS,  MAX_ELLIPSE_CB_FIELD_SIZE),
  DC_STRUCT3(etable_GI, NUM_INDEX_FIELDS,       MAX_INDEX_FIELD_SIZE),
  DC_STRUCT3(NULL,      0,                      0),
  DC_STRUCT3(NULL,      0,                      0),
  DC_STRUCT3(NULL,      0,                      0),
  DC_STRUCT3(NULL,      0,                      0)));
#endif

#endif  // DC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpdd\precmpdd.h ===
#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#ifndef _H_PRECMPDD
#define _H_PRECMPDD
/*
 *  Includes
 */
#include <ntddk.h>
#include <ntddvdeo.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <ntddbeep.h>

#ifndef _HYDRA_
#include <cxstatus.h>
#endif
#include <winstaw.h>
#include <ctxver.h>
#include <compress.h>
#include <winerror.h>

#ifdef far
#undef far
#endif
#define far

#include <icadd.h>
#include <sdapi.h>

#include <adcg.h>
#include <winddits.h>

#endif /* _H_PRECMPDD */

#ifdef __cplusplus
}
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpmport\nmpapi.h ===
/****************************************************************************/
/* nmpdata.c                                                                */
/*                                                                          */
/* RDP Miniport API Declarations                                            */
/*                                                                          */
/* Copyright(c) Microsoft 1998                                              */
/****************************************************************************/
//
// Define device extension structure. This is device dependant/private
// information.
//

typedef struct _HW_DEVICE_EXTENSION {
    PVOID VideoRamBase;
    ULONG VideoRamLength;
    ULONG CurrentModeNumber;
    PVOID SectionPointer;
    PMDL  Mdl;
} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;


#define ONE_MEG 0x100000

extern VIDEO_MODE_INFORMATION mpModes[];
extern ULONG mpNumModes;

extern ULONG mpLoaded;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpmport\nmpdata.c ===
/****************************************************************************/
/* nmpdata.c                                                                */
/*                                                                          */
/* RDP Miniport Data                                                        */
/*                                                                          */
/* Copyright(c) Microsoft 1998                                              */
/****************************************************************************/

#define TRC_FILE "nmpdata"

#define _NTDRIVER_

#ifndef FAR
#define FAR
#endif

#include "ntosp.h"
#include "stdarg.h"
#include "stdio.h"

#undef PAGED_CODE

#include "ntddvdeo.h"
#include "video.h"
#include "nmpapi.h"


#if defined(ALLOC_PRAGMA)
#pragma data_seg("PAGE")
#endif


ULONG mpLoaded = 0;

/****************************************************************************/
/* Data returned on IOCTL_VIDEO_QUERY_CURRENT_MODE                          */
/****************************************************************************/
VIDEO_MODE_INFORMATION mpModes[] =
{
    sizeof(VIDEO_MODE_INFORMATION),     /* length                           */
    0,                                  /* Mode index                       */

    /************************************************************************/
    /* VisScreenWidth and VisScreenHeight can be in two forms:              */
    /* - 0xaaaabbbb - range of values supported (aaaa = max, bbbb = min)    */
    /* - 0x0000aaaa - single value supported                                */
    /* For example:                                                         */
    /* - 0x07d0012c = 2000-300                                              */
    /* - 0x0640012c = 1600-300                                              */
    /* - 0x04b000c8 = 1200-200                                              */
    /************************************************************************/
    0x00000500,                     /* VisScreenWidth                       */
    0x00000400,                     /* VisScrenHeight                       */

    0x00000320,                     /* ScreenStride (0xffff0000 = any)      */
    0x00000001,                     /* NumberOfPlanes                       */
    0x00000008,                     /* BitsPerPlane                         */
    0,                              /* Frequency                            */
    0,                              /* XMillimeter                          */
    0,                              /* YMillimeter                          */
    0,                              /* NumberRedBits                        */
    0,                              /* NumberGreenBits                      */
    0,                              /* NumberBlueBits                       */
    0x00000000,                     /* RedMask                              */
    0x00000000,                     /* GreenMask                            */
    0x00000000,                     /* BlueMask                             */
    VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
                                    /* AttributeFlags                       */
    0x00000500,                     /* VideoMemoryBitmapWidth               */
    0x00000400,                     /* VideoMemoryBitmapHeight              */
    0                               /* DriverSpecificAttributeFlags         */
};


ULONG mpNumModes = sizeof(mpModes) / sizeof(VIDEO_MODE_INFORMATION);

#if defined(ALLOC_PRAGMA)
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpdd\ntrcdisp.c ===
/****************************************************************************/
// ntrcdisp.c
//
// RDP Trace helper functions.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <precmpdd.h>
#pragma hdrstop


#ifdef DC_DEBUG

#include <adcg.h>
#include <atrcapi.h>

#define DC_INCLUDE_DATA
#include <ndddata.c>
#undef DC_INCLUDE_DATA


/****************************************************************************/
/* TRCTraceLocal - internal function used by TRC_TraceLine                  */
/****************************************************************************/
void TRCTraceLocal(char *traceFormat, ...)
{
    va_list ap;
    va_start(ap, traceFormat);

    EngDebugPrint("RDPDD:", traceFormat, ap);

    va_end(ap);
}


/****************************************************************************/
/* TRC_TraceLine - trace a line                                             */
/****************************************************************************/
void TRC_TraceLine(
        PVOID  pWD,
        UINT32 traceClass,
        UINT32 traceType,
        char *traceString,
        char separator,
        unsigned lineNumber,
        char *funcName,
        char *fileName)
{
    /************************************************************************/
    /* Check whether trace to WD is required and initialized                */
    /************************************************************************/
    if (ddTrcToWD && pddShm)
    {
        ICA_TRACE_BUFFER trc;
        unsigned bytesReturned;

        trc.DataLength = sprintf(trc.Data,
                "RDPDD%c%p%c"TRC_FUNC_FMT"%c"TRC_LINE_FMT"%c%s\n",
                separator,
                pddTSWd,
                separator,
                TRC_FUNCNAME_LEN,
                TRC_FUNCNAME_LEN,
                funcName,
                separator,
                lineNumber,
                separator,
                traceString);

        trc.TraceClass = TC_DISPLAY;
        trc.TraceEnable = traceType;

        EngFileIoControl(ddWdHandle,
                         IOCTL_ICA_CHANNEL_TRACE,
                         &trc,
                         sizeof(trc),
                         NULL,
                         0,
                         &bytesReturned);
    }
    else
    {
        /********************************************************************/
        /* Local-only tracing                                               */
        /********************************************************************/
        TRCTraceLocal("%c"TRC_FUNC_FMT"%c"TRC_LINE_FMT"%c%s\n",
                separator,
                TRC_FUNCNAME_LEN,
                TRC_FUNCNAME_LEN,
                funcName,
                separator,
                lineNumber,
                separator,
                traceString);
    }
}


/****************************************************************************/
/* TRCPrefixMatch                                                           */
/*                                                                          */
/* Internal function to compare a component name to a prefix.               */
/* - assumes both are the same case                                         */
/* - returns                                                                */
/*   - TRUE  if characters up to end of prefix match                        */
/*   - FALSE otherwise                                                      */
/****************************************************************************/
BOOL TRCPrefixMatch(char *cpnt, char *prefix)
{
    while ((*cpnt == *prefix) && (*prefix != 0))
    {
        cpnt++;
        prefix++;
    }
    if (*prefix == 0)
    {
        return TRUE;
    }
    return FALSE;
}


/****************************************************************************/
/* TRC_WillTrace                                                            */
/****************************************************************************/
BOOL TRC_WillTrace(
        UINT32 traceType,
        UINT32 traceClass,
        char *fileName,
        UINT32 line)
{
    BOOL rc;
    int i;

    /************************************************************************/
    /* If tracing is not going to WD, OR SHM is not set up, check the local */
    /* trace level.  No prefix checking is done in this case.               */
    /************************************************************************/
    if (!ddTrcToWD || !pddShm)
    {
        rc = (ddTrcType & traceType);
        DC_QUIT;
    }

    /************************************************************************/
    /* Tracing is going to WD, AND SHM is set up.                           */
    /************************************************************************/
    /************************************************************************/
    /* Check whether this type and class are enabled.                       */
    /************************************************************************/
    if (!(traceType & pddShm->trc.TraceEnable) ||
        !(traceClass & pddShm->trc.TraceClass))
    {
        rc = FALSE;
        DC_QUIT;
    }

    /************************************************************************/
    /* If we get here, this line will be traced by WD.  Now decide whether  */
    /* we want to pass it to WD.                                            */
    /************************************************************************/

    /************************************************************************/
    /* Always trace errors, irrespective of prefix.                         */
    /************************************************************************/
    if (traceType & TT_API4)
    {
        rc = TRUE;
        DC_QUIT;
    }

    /************************************************************************/
    /* Trace all lines if no prefixes are defined.                          */
    /************************************************************************/
    if (pddShm->trc.prefix[0].name[0] == 0)
    {
        rc = TRUE;
        DC_QUIT;
    }

    /************************************************************************/
    /* Some prefixes are defined - check whether this line matches any of   */
    /* them.                                                                */
    /************************************************************************/
    for (i = 0; i < TRC_MAX_PREFIX; i++)
    {
        if (pddShm->trc.prefix[i].name[0] == 0)
        {
            /****************************************************************/
            /* End of list - break                                          */
            /****************************************************************/
            break;
        }

        if (TRCPrefixMatch(&(fileName[1]), pddShm->trc.prefix[i].name))
        {
            /****************************************************************/
            /* Found matching filename - is there a line number range       */
            /* specified?                                                   */
            /****************************************************************/
            if ((pddShm->trc.prefix[i].start == 0) &&
                (pddShm->trc.prefix[i].end == 0))
            {
                /************************************************************/
                /* No line number range - trace this line                   */
                /************************************************************/
                rc = TRUE;
                DC_QUIT;
            }

            /****************************************************************/
            /* There's a line number range - see if this line falls within  */
            /* it.                                                          */
            /****************************************************************/
            if ((line >= pddShm->trc.prefix[i].start) &&
                (line <= pddShm->trc.prefix[i].end))
            {
                /************************************************************/
                /* Line within prefix range - trace it.                     */
                /************************************************************/
                rc = TRUE;
                DC_QUIT;
            }
        }
    } /* for */

    /************************************************************************/
    /* If we get here, we've searched the list of prefixes and failed to    */
    /* find a match - don't trace the line                                  */
    /************************************************************************/
    rc = FALSE;

DC_EXIT_POINT:
    return rc;
}


#endif /* DC_DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpdd\oe2.h ===
/****************************************************************************/
// oe2.h
//
// Header for RDP field compression.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/
#ifndef __OE2_H
#define __OE2_H


/****************************************************************************/
// Field compression (OE2) overview
//
// OE2 compression maintains a copy of each field value of the last order
// sent, plus other state information like the last bounding rectangle used
// and the last order type. OE2 encoding involves comparing a new display
// order to the last copy, and sending only the fields which have changed.
// Other specialized encoding occurs for certain fields declared to be of
// "coord" type, meaning that a one-byte delta can be sent instead of a
// 2-byte value, if the delta will fit into 8 bits.
//
// The wire format for OE2 encoded orders consists of the following fields:
//
// +------------+------+-------------+--------+----------------+
// | Ctrl flags | Type | Field flags | Bounds | Encoded Fields |
// +------------+------+-------------+--------+----------------+
//
// Control flags: Required byte, corresponding to a TS_ORDER_HEADER and
//     available flags. Always contains at least TS_STANDARD flag. These
//     flags describe the following encoding; flag meanings are discussed
//     below.
//
// Type: If TS_TYPE_CHANGE is present in the control flags, this is a one-
//     byte order type value. The initial value agreed-on by both server
//     and client is TS_ENC_PATBLT_ORDER.
//
// Field flags: One or more bytes, where the number of bytes is ceil(((number
//     of order fields) + 1) / 8). The "+ 1" in that equation is historical
//     and means that the first byte of field flags can only encompass 7
//     flag bits. The presence of these flags is also governed by the control
//     flags TS_ZERO_FIELD_BYTE_BIT0 and TS_ZERO_FIELD_BYTE_BIT1
//     (see at128.h description). The ordering of the bytes is as a DWORD
//     -- the low order byte is first. The field flags indicate the presence
//     of an order field in the encoded fields portion of the packet.
//     The ordering of the flags proceeds from 0x01 corresponding to the
//     first order field, 0x02 the second, 0x04 the third, etc.
//
// Bounds: The presence of this field is governed by the TS_BOUNDS control
//     flag, which indicates the order must have a bounding region applied.
//     If control flag TS_ZERO_BOUNDS_DELTAS is set, the bound rect to be
//     used is the same as the last bound rect used. Otherwise, the
//     bounds are encoded as an encoding description byte followed by one
//     or more encoded bounds. The description byte contains two flags
//     for each of the left, top, right, and bottom rect components.
//     One flag (TS_BOUND_XXX) indicates that the component is present
//     and encoded as a 2-byte Intel-ordering value. The other flag
//     (TS_BOUND_DELTA_XXX) indicates the component is present and encoded
//     as a one-byte value used as an offset (-128 to 127) from the previous
//     value of the component. If neither flag is present the component
//     value is the same as used last. The initial value for the bounds
//     agreed-on by both server and client is the zero rect (0, 0, 0, 0).
//
// Encoded fields: These are the encoded order field values whose presence
//     is governed by the field flags. The fields are encoded in order if
//     present. The control flag TS_DELTA_COORDINATES is set if all COORD
//     type fields in the order can be specified as a one-byte delta from
//     their last values. If a field is not present its value is the same
//     as the last value sent. The initial values the client and server
//     use for all fields is zero. See the order field description tables in
//     noe2disp.c for specific order information.
/****************************************************************************/


/****************************************************************************/
// Defines
/****************************************************************************/
#define MAX_BOUNDS_ENCODE_SIZE 9
#define MAX_REPLAY_CLIPPED_ORDER_SIZE (1 + MAX_BOUNDS_ENCODE_SIZE)

#define OE2_CONTROL_FLAGS_FIELD_SIZE    1
#define OE2_TYPE_FIELD_SIZE             1
#define OE2_MAX_FIELD_FLAG_BYTES        3

#define MAX_ENCODED_ORDER_PREFIX_BYTES (OE2_CONTROL_FLAGS_FIELD_SIZE +  \
        OE2_TYPE_FIELD_SIZE + OE2_MAX_FIELD_FLAG_BYTES +  \
        MAX_BOUNDS_ENCODE_SIZE)

// Max size: 1 control flag + 1 type change byte + num field flag bytes +
// 9 bounds bytes + fields.
#define MAX_ORDER_SIZE(_NumRects, _NumFieldFlagBytes, _MaxFieldSize) \
        (2 + (_NumFieldFlagBytes) + ((_NumRects == 0) ? 0 : 9) +  \
        (_MaxFieldSize))


/****************************************************************************/
// Types
/****************************************************************************/

// INT_FMT_FIELD: Const data definitions for table-based OE2 order translation.
// Describes the source intermediate and destination wire data formats.
//
// FieldPos: Byte offset into the source intermediate format for the field.
// FieldUnencodedLen: Length of the source field.
// FieldEncodedLen: Length of the destination field (wore format).
// FieldSigned: Flag for signed field value.
// FieldType: Descriptor that specifies how to translate the field.
typedef struct
{
    unsigned FieldPos;
    unsigned FieldUnencodedLen;
    unsigned FieldEncodedLen;
    BOOL     FieldSigned;
    unsigned FieldType;
} INT_FMT_FIELD;
typedef INT_FMT_FIELD const *PINT_FMT_FIELD;


/****************************************************************************/
// Prototypes and inlines
/****************************************************************************/
void OE2_Reset(void);
void OE2_EncodeBounds(BYTE *, BYTE **, RECTL *);
unsigned OE2_CheckZeroFlagBytes(BYTE *, BYTE *, unsigned, unsigned);
void OE2_TableEncodeOrderFields(BYTE *, PUINT32_UA, BYTE **, PINT_FMT_FIELD,
        unsigned, BYTE *, BYTE *);
unsigned OE2_EncodeOrder(BYTE *, unsigned, unsigned, BYTE *, BYTE *,
        PINT_FMT_FIELD, RECTL *);


/****************************************************************************/
// OE2_EncodeOrderType
//
// Used by order encoding paths to encode the order type byte if different
// from the last order.
//
// void OE2_EncodeOrderType(
//         BYTE *pControlFlags,
//         BYTE **ppBuffer,
//         unsigned OrderType);
/****************************************************************************/
#define OE2_EncodeOrderType(_pControlFlags, _ppBuffer, _OrderType)  \
{  \
    if (oe2LastOrderType != (_OrderType)) {  \
        *(_pControlFlags) |= TS_TYPE_CHANGE;  \
        **(_ppBuffer) = (BYTE)(_OrderType);  \
        (*(_ppBuffer))++;  \
        oe2LastOrderType = (_OrderType);  \
    }  \
}


/****************************************************************************/
// OE2_CheckOneZeroFlagByte
//
// 1-field-flag-byte version of OE2_CheckZeroFlagBytes(), optimizes out the
// generalized loop.
/****************************************************************************/
__inline unsigned OE2_CheckOneZeroFlagByte(
        BYTE *pControlFlags,
        BYTE *pFieldFlag,
        unsigned PostFlagsDataLength)
{
    if (*pFieldFlag != 0) {
        return 0;
    }
    else {
        *pControlFlags |= (1 << TS_ZERO_FIELD_COUNT_SHIFT);
        memmove(pFieldFlag, pFieldFlag + 1, PostFlagsDataLength);
        return 1;
    }
}


/****************************************************************************/
// OE2_CheckTwoZeroFlagBytes
//
// 2-field-flag-byte version of OE2_CheckZeroFlagBytes(), optimizes out the
// generalized loop.
/****************************************************************************/
__inline unsigned OE2_CheckTwoZeroFlagBytes(
        BYTE *pControlFlags,
        BYTE *pFieldFlags,
        unsigned PostFlagsDataLength)
{
    if (pFieldFlags[1] != 0) {
        return 0;
    }
    else if (pFieldFlags[0] != 0) {
        *pControlFlags |= (1 << TS_ZERO_FIELD_COUNT_SHIFT);
        memmove(pFieldFlags + 1, pFieldFlags + 2, PostFlagsDataLength);
        return 1;
    }
    else {
        *pControlFlags |= (2 << TS_ZERO_FIELD_COUNT_SHIFT);
        memmove(pFieldFlags, pFieldFlags + 2, PostFlagsDataLength);
        return 2;
    }
}


/****************************************************************************/
// OE2_EmitClippedReplayOrder
//
// Creates a "play-it-again" order -- same order type and all fields
// the same as previous, except with a different bound rect.
//
// void OE2_EmitClippedReplayOrder(
//         BYTE **ppBuffer,
//         unsigned NumFieldFlagBytes,
//         RECTL *pClipRect)
/****************************************************************************/
#define OE2_EmitClippedReplayOrder(_ppBuffer, _NumFieldFlagBytes, _pClipRect) \
{  \
    BYTE *pBuffer = *(_ppBuffer);  \
\
    /* Control flags are primary order plus all field flags bytes zero. */  \
    *pBuffer++ = TS_STANDARD | TS_BOUNDS |  \
            ((_NumFieldFlagBytes) << TS_ZERO_FIELD_COUNT_SHIFT);  \
\
    /* Construct the new bounds rect just after this. */  \
    OE2_EncodeBounds(pBuffer - 1, &pBuffer, (_pClipRect));  \
\
    *(_ppBuffer) = pBuffer;  \
}



#endif  // __OE2_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpmport\nmpapi.c ===
/****************************************************************************/
/* nmpapi.c                                                                 */
/*                                                                          */
/* RDP Miniport API Functions                                               */
/*                                                                          */
/* Copyright(c) Microsoft 1998                                              */
/****************************************************************************/

#define _NTDRIVER_

#ifndef FAR
#define FAR
#endif

#include "dderror.h"
#include "ntosp.h"
#include "stdarg.h"
#include "stdio.h"
#include "zwapi.h"


#undef PAGED_CODE

#include "ntddvdeo.h"
#include "video.h"
#include "nmpapi.h"

// #define TRC_FILE "nmpapi"
// #include <adcgbtyp.h>
// #include <adcgmcro.h>
// #include <atrcapi.h>

/****************************************************************************/
/* Function Prototypes                                                      */
/****************************************************************************/
ULONG       DriverEntry( PVOID Context1, PVOID Context2 );

VP_STATUS   MPFindAdapter( PVOID                   HwDeviceExtension,
                           PVOID                   HwContext,
                           PWSTR                   ArgumentString,
                           PVIDEO_PORT_CONFIG_INFO ConfigInfo,
                           PUCHAR                  Again );

BOOLEAN     MPInitialize( PVOID HwDeviceExtension );

BOOLEAN     MPStartIO( PVOID                 HwDeviceExtension,
                       PVIDEO_REQUEST_PACKET RequestPacket );


#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,DriverEntry)
#pragma alloc_text(PAGE,MPFindAdapter)
#pragma alloc_text(PAGE,MPInitialize)
#pragma alloc_text(PAGE,MPStartIO)
#endif

/****************************************************************************/
/*                                                                          */
/* DriverEntry                                                              */
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*     Installable driver initialization entry point.                       */
/*     This entry point is called directly by the I/O system.               */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*     Context1 - First context value passed by the operating system.       */
/*                This is the value with which the miniport driver          */
/*                calls VideoPortInitialize().                              */
/*                                                                          */
/*     Context2 - Second context value passed by the operating system.      */
/*                This is the value with which the miniport driver          */
/*                calls VideoPortInitialize().                              */
/*                                                                          */
/* Return Value:                                                            */
/*                                                                          */
/*     Status from VideoPortInitialize()                                    */
/*                                                                          */
/****************************************************************************/
ULONG DriverEntry ( PVOID Context1, PVOID Context2 )
{

    VIDEO_HW_INITIALIZATION_DATA hwInitData;
    ULONG status;
    ULONG initializationStatus;
    ULONG regValue = 0;

    /************************************************************************/
    /* first up, ensure that the DD will NOT get attached to the desktop at */
    /* boot time.  This might happen if the registry changes were made and  */
    /* then the machine got powered off rather than shut down cleanly       */
    /*                                                                      */
    /* @@@ Is it OK to just hard code this path?  I notice that this _is_   */
    /* done elsewhere!                                                      */
    /************************************************************************/
    RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                          L"\\Registry\\Machine\\System\\CurrentControlSet"
                          L"\\Hardware Profiles\\Current\\System"
                          L"\\CurrentControlSet\\Services\\RDPCDD\\DEVICE0",
                          L"Attach.ToDesktop",
                          REG_DWORD,
                          &regValue,
                          sizeof(ULONG));

    RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                          L"\\Registry\\Machine\\System\\CurrentControlSet"
                          L"\\Hardware Profiles\\Current\\System"
                          L"\\CurrentControlSet\\Control\\Video"
                          L"\\{DEB039CC-B704-4F53-B43E-9DD4432FA2E9}\\0000",
                          L"Attach.ToDesktop",
                          REG_DWORD,
                          &regValue,
                          sizeof(ULONG));

    /************************************************************************/
    /* Zero out structure.                                                  */
    /************************************************************************/
    VideoPortZeroMemory(&hwInitData, sizeof(VIDEO_HW_INITIALIZATION_DATA));

    /************************************************************************/
    /* Specify sizes of structure and extension.                            */
    /************************************************************************/
    hwInitData.HwInitDataSize = sizeof(VIDEO_HW_INITIALIZATION_DATA);

    /************************************************************************/
    /* Set entry points.                                                    */
    /************************************************************************/
    hwInitData.HwFindAdapter = MPFindAdapter;
    hwInitData.HwInitialize  = MPInitialize;
    hwInitData.HwInterrupt   = NULL;
    hwInitData.HwStartIO     = MPStartIO;

    /************************************************************************/
    /* Determine the size we require for the device extension.              */
    /************************************************************************/
    hwInitData.HwDeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);

    /************************************************************************/
    /* Once all the relevant information has been stored, call the video    */
    /* port driver to do the initialization.                                */
    /*                                                                      */
    /* Since we don't actually have any hardware, just claim its on the PCI */
    /* bus                                                                  */
    /************************************************************************/
    hwInitData.AdapterInterfaceType = PCIBus;

    return (VideoPortInitialize(Context1,
                                Context2,
                                &hwInitData,
                                NULL));

} /* DriverEntry() */



/****************************************************************************/
/*                                                                          */
/* MPFindAdapter                                                            */
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*   This routine is called to determine if the adapter for this driver     */
/*   is present in the system.                                              */
/*   If it is present, the function fills out some information describing   */
/*   the adapter.                                                           */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*   HwDeviceExtension - Supplies the miniport driver's adapter storage.    */
/*       This storage is initialized to zero before this call.              */
/*                                                                          */
/*   HwContext - Supplies the context value which was passed to             */
/*       VideoPortInitialize().                                             */
/*                                                                          */
/*   ArgumentString - Suuplies a NULL terminated ASCII string. This string  */
/*       originates from the user.                                          */
/*                                                                          */
/*   ConfigInfo - Returns the configuration information structure which is  */
/*       filled by the miniport driver. This structure is initialized with  */
/*       any knwon configuration information (such as SystemIoBusNumber) by */
/*       the port driver. Where possible, drivers should have one set of    */
/*       defaults which do not require any supplied configuration           */
/*       information.                                                       */
/*                                                                          */
/*   Again - Indicates if the miniport driver wants the port driver to call */
/*       its VIDEO_HW_FIND_ADAPTER function again with a new device         */
/*       extension and the same config info. This is used by the miniport   */
/*       drivers which can search for several adapters on a bus.            */
/*                                                                          */
/* Return Value:                                                            */
/*                                                                          */
/*   This routine must return:                                              */
/*                                                                          */
/*   NO_ERROR - Indicates a host adapter was found and the                  */
/*       configuration information was successfully determined.             */
/*                                                                          */
/*   ERROR_INVALID_PARAMETER - Indicates an adapter was found but there     */
/*       was an error obtaining the configuration information. If           */
/*       possible an error should be logged.                                */
/*                                                                          */
/*   ERROR_DEV_NOT_EXIST - Indicates no host adapter was found for the      */
/*       supplied configuration information.                                */
/*                                                                          */
/****************************************************************************/
VP_STATUS MPFindAdapter( PVOID                   HwDeviceExtension,
                         PVOID                   HwContext,
                         PWSTR                   ArgumentString,
                         PVIDEO_PORT_CONFIG_INFO ConfigInfo,
                         PUCHAR                  Again)
{

    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    NTSTATUS             Status;
    HANDLE               SectionHandle;
    ACCESS_MASK          SectionAccess;
    ULONGLONG            SectionSize = 0x100000;

    /************************************************************************/
    /* Make sure the size of the structure is at least as large as what we  */
    /* are expecting (check version of the config info structure).          */
    /************************************************************************/
    if (ConfigInfo->Length < sizeof(VIDEO_PORT_CONFIG_INFO))
    {
        return ERROR_INVALID_PARAMETER;
    }

    /************************************************************************/
    /* Only create a device once.                                           */
    /************************************************************************/
    if (mpLoaded++)
    {
        return ERROR_DEV_NOT_EXIST;
    }

    /************************************************************************/
    /* Clear out the Emulator entries and the state size since this driver  */
    /* does not support them.                                               */
    /************************************************************************/
    ConfigInfo->NumEmulatorAccessEntries     = 0;
    ConfigInfo->EmulatorAccessEntries        = NULL;
    ConfigInfo->EmulatorAccessEntriesContext = 0;
    ConfigInfo->HardwareStateSize            = 0;

    ConfigInfo->VdmPhysicalVideoMemoryAddress.LowPart  = 0x00000000;
    ConfigInfo->VdmPhysicalVideoMemoryAddress.HighPart = 0x00000000;
    ConfigInfo->VdmPhysicalVideoMemoryLength           = 0x00000000;

    /************************************************************************/
    /* Initialize the current mode number.                                  */
    /************************************************************************/
    hwDeviceExtension->CurrentModeNumber = 0;

    /************************************************************************/
    /* Indicate we do not wish to be called over                            */
    /************************************************************************/
    *Again = 0;

    /************************************************************************/
    /* Indicate a successful completion status.                             */
    /************************************************************************/
    return NO_ERROR;

} /* MPFindAdapter() */


/****************************************************************************/
/* MPInitialize                                                             */
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*     This routine does one time initialization of the device.             */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*     HwDeviceExtension - Supplies a pointer to the miniport's device      */
/*         extension.                                                       */
/*                                                                          */
/* Return Value:                                                            */
/*                                                                          */
/*     Always returns TRUE since this routine can never fail.               */
/*                                                                          */
/****************************************************************************/
BOOLEAN MPInitialize( PVOID HwDeviceExtension )
{
    ULONG i;

    /************************************************************************/
    /* Walk through the list of modes and mark the indexes properly         */
    /************************************************************************/
    for (i = 0; i < mpNumModes; i++)
    {
        mpModes[i].ModeIndex = i;
    }

    return TRUE;

} /* MPInitialize() */


/****************************************************************************/
/*                                                                          */
/* MPStartIO                                                                */
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*     This routine is the main execution routine for the miniport driver.  */
/*     It accepts a Video Request Packet, performs the request, and then    */
/*     returns with the appropriate status.                                 */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*     HwDeviceExtension - Supplies a pointer to the miniport's device      */
/*         extension.                                                       */
/*                                                                          */
/*     RequestPacket - Pointer to the video request packet.  This           */
/*         structure contains all the parameters passed to the              */
/*         VideoIoControl function.                                         */
/*                                                                          */
/* Return Value:                                                            */
/*                                                                          */
/*                                                                          */
/****************************************************************************/

BOOLEAN MPStartIO( PVOID                 HwDeviceExtension,
                   PVIDEO_REQUEST_PACKET RequestPacket )
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    VP_STATUS status = NO_ERROR;
    PVIDEO_MODE_INFORMATION modeInformation;
    PVIDEO_MEMORY_INFORMATION memoryInformation;
    PVIDEO_SHARE_MEMORY pShareMemory;
    PVIDEO_SHARE_MEMORY_INFORMATION pShareMemoryInformation;
    ULONG ulTemp;
    NTSTATUS ntStatus;
    ULONG ViewSize;
    PVOID ViewBase;
    LARGE_INTEGER ViewOffset;
    HANDLE sectionHandle;

    // DC_BEGIN_FN("MPStartIO");

    if ((RequestPacket == NULL) || (HwDeviceExtension == NULL))
        return FALSE;

    /************************************************************************/
    /* Switch on the IoContolCode in the RequestPacket.  It indicates which */
    /* function must be performed by the driver.                            */
    /************************************************************************/

    switch (RequestPacket->IoControlCode)
    {

        case IOCTL_VIDEO_QUERY_CURRENT_MODE:
        {
            /****************************************************************/
            /* return the current mode                                      */
            /****************************************************************/
            // TRC_DBG((TB, "MPStartIO - QueryCurrentModes"));

            modeInformation = RequestPacket->OutputBuffer;

            RequestPacket->StatusBlock->Information =
                                               sizeof(VIDEO_MODE_INFORMATION);
            if (RequestPacket->OutputBufferLength
                                    < RequestPacket->StatusBlock->Information)
            {
                status = ERROR_INSUFFICIENT_BUFFER;
            }
            else
            {
                *((PVIDEO_MODE_INFORMATION)RequestPacket->OutputBuffer) =
                                mpModes[hwDeviceExtension->CurrentModeNumber];
                status = NO_ERROR;
            }

        }
        break;

        case IOCTL_VIDEO_QUERY_AVAIL_MODES:
        {
            /****************************************************************/
            /* return the mode information                                  */
            /****************************************************************/
            UCHAR i;

            // TRC_DBG((TB, "MPStartIO - QueryAvailableModes"));

            /****************************************************************/
            /* check for space                                              */
            /****************************************************************/
            RequestPacket->StatusBlock->Information =
                                  mpNumModes * sizeof(VIDEO_MODE_INFORMATION);
            if (RequestPacket->OutputBufferLength
                                    < RequestPacket->StatusBlock->Information)
            {
                status = ERROR_INSUFFICIENT_BUFFER;
            }
            else
            {
                modeInformation = RequestPacket->OutputBuffer;

                for (i = 0; i < mpNumModes; i++)
                {
                    *modeInformation = mpModes[i];
                    modeInformation++;
                }

                status = NO_ERROR;
            }
        }
        break;


        case IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES:
        {
            /****************************************************************/
            /* return the number of modes we support - which we claim to be */
            /* zero                                                         */
            /****************************************************************/
            // TRC_DBG((TB, "MPStartIO - QueryNumAvailableModes"));

            if (RequestPacket->OutputBufferLength <
                    (RequestPacket->StatusBlock->Information =
                                                    sizeof(VIDEO_NUM_MODES)) )
            {
                status = ERROR_INSUFFICIENT_BUFFER;
            }
            else
            {
                ((PVIDEO_NUM_MODES)RequestPacket->OutputBuffer)->NumModes = 0;
                ((PVIDEO_NUM_MODES)RequestPacket->OutputBuffer)
                                                  ->ModeInformationLength = 0;
                status = NO_ERROR;
            }

        }
        break;


        case IOCTL_VIDEO_SET_CURRENT_MODE:
        {
            /****************************************************************/
            /* sets the current mode                                        */
            /****************************************************************/
            // TRC_DBG((TB, "MPStartIO - SetCurrentMode"));
            if (RequestPacket->InputBufferLength < sizeof(VIDEO_MODE))
            {
                status = ERROR_INSUFFICIENT_BUFFER;
            }

            hwDeviceExtension->CurrentModeNumber = ((PVIDEO_MODE)
                                 (RequestPacket->InputBuffer))->RequestedMode;

            status = NO_ERROR;

        }
        break;


        case IOCTL_VIDEO_SET_COLOR_REGISTERS:
        {
            // TRC_DBG((TB, "MPStartIO - SetColorRegs"));
            status = NO_ERROR;
        }
        break;


        case IOCTL_VIDEO_RESET_DEVICE:
        {
            // TRC_DBG((TB, "MPStartIO - RESET_DEVICE"));
            status = NO_ERROR;
        }
        break;

        case IOCTL_VIDEO_MAP_VIDEO_MEMORY:
        case IOCTL_VIDEO_UNMAP_VIDEO_MEMORY:
        case IOCTL_VIDEO_SHARE_VIDEO_MEMORY:
        case IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY:
        {
            /****************************************************************/
            /* might get these, but shouldn't                               */
            /****************************************************************/
            // TRC_ALT((TB, "Unexpected IOCtl %x",RequestPacket->IoControlCode));
            status = ERROR_INVALID_FUNCTION;
        }
        break;

        default:
        {
            /****************************************************************/
            /* definitely shouldn't get here                                */
            /****************************************************************/
            // TRC_DBG((TB, "Fell through MP startIO routine - invalid command"));
            status = ERROR_INVALID_FUNCTION;
        }
        break;
    }

    RequestPacket->StatusBlock->Status = status;

    // DC_END_FN();

    return TRUE;

} /* MPStartIO() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpperf\rdpcount\dbgtool.h ===
/***********************************************************************
* DBGTRACE.H
*     This module contains typedefs and defines required for
*     the DBGTRACE utility.
*
* Copyright (C) 1994 Citrix Systems Inc.
* Copyright (C) 1997-1999 Microsoft Corp.
*************************************************************************/

#define USAGE \
L"RDPCOUNT [name] [/zero] \n" \
L"RDPCOUNT [name] [/perf] \n" \
L"RDPCOUNT [id] [/zero]\n" \
L"RDPCOUNT [id] [/perf]\n"

#define MAX_IDS_LEN   256     // maximum length that the input parm can be
#define MAX_OPTION     64     // max length of winstation tracing option


#define ERROR_MEMORY    L"Error allocating memory\n"
#define ERROR_PARAMS    L"Invalid parameter(s)\n"
#define ERROR_SESSION   L"ERROR: invalid Terminal Session %s\n"
#define ERROR_SET_TRACE L"ERROR: unable to set trace information, 0x%x\n"
#define ERROR_SET_PERF  L"ERROR: unable to set performance count, 0x%x\n"
#define ERROR_GET_PERF  L"ERROR: unable to GET performance count, 0x%x\n"

#define TRACE_DIS_LOG   L"Trace disabled on WINFRAME.LOG\n"
#define TRACE_EN_LOG    L"Trace enabled on WINFRAME.LOG\n"
#define DEBUGGER        L"Debugger"
#define TRACE_UNSUPP    L"Trace on LogonId 0 not supported\n"
#define TRACE_DISABLED  L"Trace disabled on SessionId %u\n"
#define TRACE_ENABLED   L"Trace enabled on SessionId %u\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpperf\rdpcount\dbgtool.c ===
/*****************************************************************************/
// dbgtool.c
//
// Dump or reset the RDP performance counters
//
// Copyright (C) 1998-2000 Microsoft Corporation
/*****************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>
#include <winstaw.h>
#include <icadd.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <utilsub.h>
#include <nprcount.h>

#include "dbgtool.h"


WCHAR CurDir[ 256 ];
WCHAR WinStation[MAX_IDS_LEN+1];
WCHAR TraceOption[MAX_OPTION];
int bTraceOption = FALSE;
int fDebugger  = FALSE;
int fTimestamp = FALSE;
int fHelp      = FALSE;
int fSystem    = FALSE;
int fAll       = FALSE;
int fPerf      = FALSE;
int fZero      = FALSE;
ULONG TraceClass  = 0;
ULONG TraceEnable = 0;
ULONG LogonId;

WINSTATIONINFORMATION WinInfo;

TOKMAP ptm[] = {
      {L" ",      TMFLAG_OPTIONAL, TMFORM_STRING,  MAX_IDS_LEN,    WinStation},
      {L"/c",     TMFLAG_OPTIONAL, TMFORM_LONGHEX, sizeof(ULONG),  &TraceClass},
      {L"/e",     TMFLAG_OPTIONAL, TMFORM_LONGHEX, sizeof(ULONG),  &TraceEnable},
      {L"/d",     TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(int),    &fDebugger},
      {L"/t",     TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(int),    &fTimestamp},
      {L"/o",     TMFLAG_OPTIONAL, TMFORM_STRING,  MAX_OPTION,     TraceOption},
      {L"/system", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(int),   &fSystem},
      {L"/all",   TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(int),    &fAll},
      {L"/?",     TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fHelp},
      {L"/perf",  TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fPerf},
      {L"/zero",  TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fZero},
      {0, 0, 0, 0, 0}
};


void SetSystemTrace( PICA_TRACE );
void SetStackTrace( PICA_TRACE );
void GetTSPerfCounters( ULONG LogonId, WINSTATIONINFORMATION *pInfo);
void ZeroTSPerfCounters( ULONG LogonId );
void ShowPerfCounters( void );


/*******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

int _cdecl main(INT argc, CHAR **argv)
{
   WCHAR *CmdLine;
   WCHAR **argvW;
   ULONG rc;
   int i;
   ICA_TRACE Trace;

    /*
     * We can't use argv[] because its always ANSI, regardless of UNICODE
     */
    CmdLine = GetCommandLine();

    /*
     * Massage the new command line to look like an argv[] type
     * because ParseCommandLine() depends on this format
     */

    argvW = (WCHAR **)malloc( sizeof(WCHAR *) * (argc+1) );
    if(argvW == NULL) {
        fwprintf(stderr, ERROR_MEMORY);
        return(1);
    }

    argvW[0] = wcstok(CmdLine, L" ");
    for(i=1; i < argc; i++){
        argvW[i] = wcstok(0, L" ");
    }
    argvW[argc] = NULL;

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( fHelp || (rc && !(rc & PARSE_FLAG_NO_PARMS)) ) {

        if ( !fHelp ) {

            fwprintf(stderr, ERROR_PARAMS);
            fwprintf(stderr, USAGE);
            return(1);

        } else {

            wprintf(USAGE);
            return(0);
        }
    }

    if ( fAll ) {
        TraceClass  = 0xffffffff;
        TraceEnable = 0xffffffff;
    }

    /*
     *  Get current directory
     */
    (VOID) GetCurrentDirectory( 256, CurDir );

    /*
     *  Get the LogonId
     */
    if ( ptm[0].tmFlag & TMFLAG_PRESENT ) {

        if ( iswdigit( WinStation[0] ) ) {

            LogonId = (ULONG) wcstol( WinStation, NULL, 10 );

        } else {

            if ( !LogonIdFromWinStationName( SERVERNAME_CURRENT, WinStation, &LogonId ) ) {
                wprintf( ERROR_SESSION, WinStation );
                return(-1);
            }
        }

        if ( fSystem )
            wsprintf( Trace.TraceFile, L"%s\\winframe.log", CurDir );
        else
            wsprintf( Trace.TraceFile, L"%s\\%s.log", CurDir, WinStation );

    } else {

        LogonId = GetCurrentLogonId();

        if ( fSystem )
            wsprintf( Trace.TraceFile, L"%s\\winframe.log", CurDir );
        else
            wsprintf( Trace.TraceFile, L"%s\\%u.log", CurDir, LogonId );
    }

    /************************************************************************/
    /* TShare Performance Counters additions!                               */
    /************************************************************************/
    if (fZero)
    {
        ZeroTSPerfCounters(LogonId);
        goto EXIT_POINT;
    }

    if (fPerf)
    {
        GetTSPerfCounters(LogonId, &WinInfo);
        ShowPerfCounters();
        goto EXIT_POINT;
    }

    /*
     *  Build trace structure
     */
    Trace.fDebugger   = fDebugger ? TRUE : FALSE;
    Trace.fTimestamp  = fTimestamp ? FALSE : TRUE;
    Trace.TraceClass  = TraceClass;
    Trace.TraceEnable = TraceEnable;

    if ( TraceClass == 0 || TraceEnable == 0 )
        Trace.TraceFile[0] = '\0';

    /*
     * Fill in the trace option if any
     */
    bTraceOption = ptm[5].tmFlag & TMFLAG_PRESENT;
    if ( bTraceOption )
        memcpy(Trace.TraceOption, TraceOption, sizeof(TraceOption));
    else
        memset(Trace.TraceOption, 0, sizeof(TraceOption));

    /*
     *  Set trace information
     */
    if ( fSystem )
        SetSystemTrace( &Trace );
    else
        SetStackTrace( &Trace );

EXIT_POINT:
    return(0);
}


void
SetSystemTrace( PICA_TRACE pTrace )
{
    /*
     *  Set trace information
     */
    if ( !WinStationSetInformation( SERVERNAME_CURRENT,
                                    LogonId,
                                    WinStationSystemTrace,
                                    pTrace,
                                    sizeof(ICA_TRACE) ) ) {

        wprintf(ERROR_SET_TRACE, GetLastError());
        return;
    }

    if ( pTrace->TraceClass == 0 || pTrace->TraceEnable == 0 ) {
        wprintf( TRACE_DIS_LOG );
    } else {
        wprintf( TRACE_EN_LOG );
        wprintf( L"- %08x %08x [%s] %s\n", pTrace->TraceClass, pTrace->TraceEnable,
                pTrace->TraceFile, fDebugger ? DEBUGGER : L"" );
    }

}


void
SetStackTrace( PICA_TRACE pTrace )
{
    WINSTATIONINFOCLASS InfoClass;
    ULONG               InfoSize;

    /*
     *  Check for console
     */
    if ( LogonId == 0 ) {
        wprintf( TRACE_UNSUPP );
        return;
    }

    /*
     *  Set trace information
     */
    if ( !WinStationSetInformation( SERVERNAME_CURRENT,
                                    LogonId,
                                    WinStationTrace,
                                    pTrace,
                                                sizeof(ICA_TRACE))) {
        wprintf(ERROR_SET_TRACE, GetLastError());
        return;
    }

    if ( pTrace->TraceClass == 0 || pTrace->TraceEnable == 0 ) {
        wprintf( TRACE_DISABLED, LogonId );
    } else {
        wprintf( TRACE_ENABLED, LogonId );
        wprintf( L"- %08x %08x [%s] %s\n", pTrace->TraceClass, pTrace->TraceEnable,
                pTrace->TraceFile, fDebugger ? DEBUGGER : L"" );
    }
}

void
GetTSPerfCounters( ULONG LogonId, WINSTATIONINFORMATION *pInfo)
{

    ULONG retLength = 0;

    if (!WinStationQueryInformation( SERVERNAME_CURRENT,
                              LogonId,
                              WinStationInformation,
                              pInfo,
                              sizeof(WinInfo),
                              &retLength))
    {
        wprintf(ERROR_GET_PERF, GetLastError());
        return;
    }
}

void
ShowPerfCounters( void )
{
#define OUTPUT            WinInfo.Status.Output
#define INPUT            WinInfo.Status.Input
#define OUT_COUNTER       WinInfo.Status.Output.Specific.Reserved
#define IN_COUNTER        WinInfo.Status.Input.Specific.Reserved
#define CACHE        WinInfo.Status.Cache.Specific.IcaCacheStats.ThinWireCache

    /************************************************************************/
    /*                                                                      */
    /* NOTE that the apparently arcane tabbing means this stuff can be      */
    /* loaded straight into excel!  Don't change it without good reason!!   */
    /*                                                                      */
    /************************************************************************/
    wprintf(L"Output frames     \t\t\t\t\t%u\n",  OUTPUT.WdFrames);
    wprintf(L"Output bytes      \t\t\t\t\t%u\n",  OUTPUT.WdBytes);
    wprintf(L"Network layer packets sent\t\t\t\t\t%u\n",  IN_COUNTER[IN_PKT_TOTAL_SENT]);
    wprintf(L"Largest packet sent\t\t\t\t\t%u\n",  IN_COUNTER[IN_MAX_PKT_SIZE]);
    wprintf(L"Packet size histogram:\n");
    wprintf(L"\t0 - 200        bytes\t\t\t\t%u\n",  IN_COUNTER[IN_PKT_BYTE_SPREAD1]);
    wprintf(L"\t201 - 400      bytes\t\t\t\t%u\n",  IN_COUNTER[IN_PKT_BYTE_SPREAD2]);
    wprintf(L"\t401 - 600      bytes\t\t\t\t%u\n",  IN_COUNTER[IN_PKT_BYTE_SPREAD3]);
    wprintf(L"\t601 - 800      bytes\t\t\t\t%u\n",  IN_COUNTER[IN_PKT_BYTE_SPREAD4]);
    wprintf(L"\t801 - 1000     bytes\t\t\t\t%u\n",  IN_COUNTER[IN_PKT_BYTE_SPREAD5]);
    wprintf(L"\t1001 - 1200    bytes\t\t\t\t%u\n",  IN_COUNTER[IN_PKT_BYTE_SPREAD6]);
    wprintf(L"\t1201 - 1400    bytes\t\t\t\t%u\n",  IN_COUNTER[IN_PKT_BYTE_SPREAD7]);
    wprintf(L"\t1401 - 1600    bytes\t\t\t\t%u\n",  IN_COUNTER[IN_PKT_BYTE_SPREAD8]);
    wprintf(L"\t1601 - 2000    bytes\t\t\t\t%u\n",  IN_COUNTER[IN_PKT_BYTE_SPREAD9]);
    wprintf(L"\t2001 - 4000    bytes\t\t\t\t%u\n",  IN_COUNTER[IN_PKT_BYTE_SPREAD10]);
    wprintf(L"\t4001 - 6000    bytes\t\t\t\t%u\n",  IN_COUNTER[IN_PKT_BYTE_SPREAD11]);
    wprintf(L"\t6001 - 8000    bytes\t\t\t\t%u\n",  IN_COUNTER[IN_PKT_BYTE_SPREAD12]);
    wprintf(L"\t> 8000         bytes\t\t\t\t%u\n",  IN_COUNTER[IN_PKT_BYTE_SPREAD13]);

    wprintf(L"\nSCHEDULING\n");
    wprintf(L"\tSmall payload size\t\t\t\t%u\n",  IN_COUNTER[IN_SCH_SMALL_PAYLOAD  ]);
    wprintf(L"\tLarge payload size\t\t\t\t%u\n",  IN_COUNTER[IN_SCH_LARGE_PAYLOAD  ]);
    wprintf(L"\ttotal available   \t\t\t\t%u\n",  IN_COUNTER[IN_SCH_OUT_ALL        ]);
    wprintf(L"\t  must-send       \t\t\t\t%u\n",  IN_COUNTER[IN_SCH_MUSTSEND       ]);
    wprintf(L"\t  output data pop \t\t\t\t%u\n",  IN_COUNTER[IN_SCH_OUTPUT         ]);
    wprintf(L"\t  heap limit hit  \t\t\t\t%u\n",  IN_COUNTER[IN_SCH_OE_NUMBER      ]);
    wprintf(L"\t  new cursor pop  \t\t\t\t%u\n",  IN_COUNTER[IN_SCH_NEW_CURSOR     ]);
    wprintf(L"\t  wake-up pop!    \t\t\t\t%u\n",  IN_COUNTER[IN_SCH_ASLEEP         ]);
    wprintf(L"\t  do nothing!     \t\t\t\t%u\n\n", IN_COUNTER[IN_SCH_DO_NOTHING    ]);

    wprintf(L"\nORDER PDU DETAILS\n");
    wprintf(L"\ttotal update orders sent            \t\t\t\t%u\n",  IN_COUNTER[IN_SND_TOTAL_ORDER ]);
    wprintf(L"\tupdate order bytes sent             \t\t\t\t%u\n",  IN_COUNTER[IN_SND_ORDER_BYTES ]);
    wprintf(L"\tOutBuf alloc failures               \t\t\t\t%u\n",  IN_COUNTER[IN_SND_NO_BUFFER   ]);

    wprintf(L"\nSDA PDU DETAILS\n");
    wprintf(L"\tcalls to SDG_SendSDA                \t\t\t\t%u\n",  IN_COUNTER[IN_SND_SDA_ALL     ]);
    wprintf(L"\tSDA region area sent                \t\t\t\t%u\n",  IN_COUNTER[IN_SND_SDA_AREA    ]);
    wprintf(L"\tnumber of SDA packets               \t\t\t\t%u\n",  IN_COUNTER[IN_SND_SDA_PDUS    ]);

    wprintf(L"\nDrvBitBlt\n");
    wprintf(L"\tCalls             \t\t\t\t%u\n", OUT_COUNTER[OUT_BITBLT_ALL        ]);
    wprintf(L"\tFailed for no-offscr flag \t\t\t\t%u\n", OUT_COUNTER[OUT_BITBLT_NOOFFSCR]);
    wprintf(L"\tSent as SDA       \t\t\t\t%u\n", OUT_COUNTER[OUT_BITBLT_SDA        ]);
    wprintf(L"\t\tUnencodable ROP4\t\t\t%u\n", OUT_COUNTER[OUT_BITBLT_SDA_ROP4]);
    wprintf(L"\t\t\tSDA pixels\t\t\t%u\n", IN_COUNTER[IN_SDA_BITBLT_ROP4_AREA]);
    wprintf(L"\t\tUnsupported order\t\t\t%u\n", OUT_COUNTER[OUT_BITBLT_SDA_UNSUPPORTED]);
    wprintf(L"\t\t\tUnsupp scrscr ROP SDA pixels\t\t%u\n", IN_COUNTER[IN_SDA_SCRSCR_FAILROP_AREA]);
    wprintf(L"\t\tUnsupported ROP3\t\t\t%u\n", OUT_COUNTER[OUT_BITBLT_SDA_NOROP3]);
    wprintf(L"\t\t\tSDA pixels\t\t\t%u\n", IN_COUNTER[IN_SDA_BITBLT_NOROP3_AREA]);
    wprintf(L"\t\tComplex clipping\t\t\t%u\n", OUT_COUNTER[OUT_BITBLT_SDA_COMPLEXCLIP]);
    wprintf(L"\t\t\tSDA pixels\t\t\t%u\n", IN_COUNTER[IN_SDA_BITBLT_COMPLEXCLIP_AREA]);
    wprintf(L"\t\tMemblt Uncacheable\t\t\t%u\n", OUT_COUNTER[OUT_BITBLT_SDA_MBUNCACHEABLE]);
    wprintf(L"\t\tUnqueued color table\t\t\t%u\n", OUT_COUNTER[OUT_BITBLT_SDA_NOCOLORTABLE]);
    wprintf(L"\t\tFailed heap alloc\t\t\t%u\n", OUT_COUNTER[OUT_BITBLT_SDA_HEAPALLOCFAILED]);
    wprintf(L"\t\tFailed ScrBlt encoding (complex clip)\t\t\t%u\n", OUT_COUNTER[OUT_BITBLT_SDA_SBCOMPLEXCLIP]);
    wprintf(L"\t\tComplex brush on Mem3Blt\t\t\t%u\n", OUT_COUNTER[OUT_BITBLT_SDA_M3BCOMPLEXBRUSH]);
    wprintf(L"\t\tWindows layering\t\t\t%u\n", OUT_COUNTER[OUT_BITBLT_SDA_WINDOWSAYERING]);

    wprintf(L"\n\tMem(3)Blts\n");
    wprintf(L"\t\tMemBlt orders\t\t\t%u\n", OUT_COUNTER[OUT_MEMBLT_ORDER]);
    wprintf(L"\t\tMemBlt bytes \t\t\t%u\n", IN_COUNTER[IN_MEMBLT_BYTES]);
    wprintf(L"\t\tMemBlt SDA pixels\t\t\t%u\n", IN_COUNTER[IN_SDA_MEMBLT_AREA]);
    wprintf(L"\t\tMem3Blt orders\t\t\t%u\n", OUT_COUNTER[OUT_MEM3BLT_ORDER]);
    wprintf(L"\t\tMem3Blt bytes \t\t\t%u\n", IN_COUNTER[IN_MEM3BLT_BYTES]);
    wprintf(L"\t\tMem3Blt SDA pixels\t\t\t%u\n", IN_COUNTER[IN_SDA_MEM3BLT_AREA]);
    wprintf(L"\t\tCacheColorTable orders\t\t\t\t%u\n", OUT_COUNTER[OUT_CACHECOLORTABLE]);
    wprintf(L"\t\tCacheColorTable bytes\t\t\t\t%u\n", OUT_COUNTER[OUT_CACHECOLORTABLE_BYTES]);
    wprintf(L"\t\tCacheBitmap orders\t\t\t\t%u\n", OUT_COUNTER[OUT_CACHEBITMAP]);
    wprintf(L"\t\tCacheBitmap bytes\t\t\t\t%u\n", OUT_COUNTER[OUT_CACHEBITMAP_BYTES]);

    wprintf(L"\tDstBlts\n");
    wprintf(L"\t\tDstBlt orders\t\t\t%u\n", OUT_COUNTER[OUT_DSTBLT_ORDER]);
    wprintf(L"\t\tDstBlt bytes\t\t\t%u\n", IN_COUNTER[IN_DSTBLT_BYTES]);
    wprintf(L"\t\tMultiDstBlts\t\t\t%u\n", OUT_COUNTER[OUT_MULTI_DSTBLT_ORDER]);
    wprintf(L"\t\tMultiDstBlt bytes\t\t\t%u\n", IN_COUNTER[IN_MULTI_DSTBLT_BYTES]);
    wprintf(L"\t\tDstBlt SDA pixels\t\t\t%u\n", IN_COUNTER[IN_SDA_DSTBLT_AREA]);
    wprintf(L"\tPatBlts\n");
    wprintf(L"\t\tPatBlt orders\t\t\t%u\n", OUT_COUNTER[OUT_PATBLT_ORDER]);
    wprintf(L"\t\tPatBlt bytes\t\t\t%u\n", IN_COUNTER[IN_PATBLT_BYTES]);
    wprintf(L"\t\tMultiPatBlts\t\t\t%u\n", OUT_COUNTER[OUT_MULTI_PATBLT_ORDER]);
    wprintf(L"\t\tMultiPatBlt bytes\t\t\t%u\n", IN_COUNTER[IN_MULTI_PATBLT_BYTES]);
    wprintf(L"\t\tPatBlt SDA pixels\t\t\t%u\n", IN_COUNTER[IN_SDA_PATBLT_AREA]);
    wprintf(L"\tOpaqueRects\n");
    wprintf(L"\t\tOpaqueRect orders\t\t\t%u\n", OUT_COUNTER[OUT_OPAQUERECT_ORDER]);
    wprintf(L"\t\tOpaqueRect bytes\t\t\t%u\n", IN_COUNTER[IN_OPAQUERECT_BYTES]);
    wprintf(L"\t\tMultiOpaqueRects\t\t\t%u\n", OUT_COUNTER[OUT_MULTI_OPAQUERECT_ORDER]);
    wprintf(L"\t\tMultiOpaqueRect bytes\t\t\t%u\n", IN_COUNTER[IN_MULTI_OPAQUERECT_BYTES]);
    wprintf(L"\t\tOpaqueRect SDA pixels\t\t\t%u\n", IN_COUNTER[IN_SDA_OPAQUERECT_AREA]);
    wprintf(L"\tScrBlts\n");
    wprintf(L"\t\tScrBlt orders\t\t\t%u\n", OUT_COUNTER[OUT_SCRBLT_ORDER]);
    wprintf(L"\t\tScrBlt bytes\t\t\t%u\n", IN_COUNTER[IN_SCRBLT_BYTES]);
    wprintf(L"\t\tMultiScrBlts\t\t\t%u\n", OUT_COUNTER[OUT_MULTI_SCRBLT_ORDER]);
    wprintf(L"\t\tMultiScrBlt bytes\t\t\t%u\n", IN_COUNTER[IN_MULTI_SCRBLT_BYTES]);
    wprintf(L"\t\tScrBlt SDA pixels\t\t\t%u\n", IN_COUNTER[IN_SDA_SCRBLT_AREA]);

    wprintf(L"\nDrvCreateDeviceBitmap\n");
    wprintf(L"\tCalls             \t\t\t\t%u\n", OUT_COUNTER[OUT_OFFSCREEN_BITMAP_ALL]);
    wprintf(L"\tSent as Create Offscr PDUs\t\t\t%u\n", OUT_COUNTER[OUT_OFFSCREEN_BITMAP_ORDER]);
    wprintf(L"\tCreate Offscr bytes\t\t\t%u\n", OUT_COUNTER[OUT_OFFSCREEN_BITMAP_ORDER_BYTES]);

    wprintf(L"\nSwitch Offscreen Surface PDUs sent\t\t\t%u\n", OUT_COUNTER[OUT_SWITCHSURFACE]);
    wprintf(L"\nSwitch Offscreen Surface bytes\t\t\t%u\n", OUT_COUNTER[OUT_SWITCHSURFACE_BYTES]);

    wprintf(L"\nDrvStretchBlt\n");
    wprintf(L"\tCalls             \t\t\t\t%u\n", OUT_COUNTER[OUT_STRTCHBLT_ALL     ]);
    wprintf(L"\tSent as SDA       \t\t\t\t%u\n", OUT_COUNTER[OUT_STRTCHBLT_SDA     ]);
    wprintf(L"\t\tMask specified  \t\t\t%u\n", OUT_COUNTER[OUT_STRTCHBLT_SDA_MASK]);
    wprintf(L"\t\tComplex clipping\t\t\t%u\n", OUT_COUNTER[OUT_STRTCHBLT_SDA_COMPLEXCLIP]);
    wprintf(L"\tHandled as BitBlt \t\t\t\t%u\n", OUT_COUNTER[OUT_STRTCHBLT_BITBLT  ]);

    wprintf(L"\nDrvCopyBits\n");
    wprintf(L"\tCalls             \t\t\t\t%u\n", OUT_COUNTER[OUT_COPYBITS_ALL     ]);

    wprintf(L"\nDrvTextOut\n");
    wprintf(L"\tCalls             \t\t\t\t%u\n", OUT_COUNTER[OUT_TEXTOUT_ALL        ]);
    wprintf(L"\tSent as SDA       \t\t\t\t%u\n", OUT_COUNTER[OUT_TEXTOUT_SDA        ]);
    wprintf(L"\t\tExtra rects\t\t\t%u\n", OUT_COUNTER[OUT_TEXTOUT_SDA_EXTRARECTS]);
    wprintf(L"\t\tNo string\t\t\t%u\n", OUT_COUNTER[OUT_TEXTOUT_SDA_NOSTRING]);
    wprintf(L"\t\tComplex clipping\t\t\t%u\n", OUT_COUNTER[OUT_TEXTOUT_SDA_COMPLEXCLIP]);
    wprintf(L"\t\tFailed alloc FCI\t\t\t%u\n", OUT_COUNTER[OUT_TEXTOUT_SDA_NOFCI]);
    wprintf(L"\tSDA pixels\t\t\t%u\n", IN_COUNTER[IN_SDA_TEXTOUT_AREA]);
    wprintf(L"\tGlyph Index Order \t\t\t%u\n", OUT_COUNTER[OUT_TEXTOUT_GLYPH_INDEX]);
    wprintf(L"\tGlyph Index bytes \t\t\t%u\n", IN_COUNTER[IN_GLYPHINDEX_BYTES]);
    wprintf(L"\tFast Index Order \t\t\t%u\n", OUT_COUNTER[OUT_TEXTOUT_FAST_INDEX]);
    wprintf(L"\tFast Index bytes \t\t\t%u\n", IN_COUNTER[IN_FASTINDEX_BYTES]);
    wprintf(L"\tFast Glyph Order \t\t\t%u\n", OUT_COUNTER[OUT_TEXTOUT_FAST_GLYPH]);
    wprintf(L"\tFast Glyph bytes \t\t\t%u\n", IN_COUNTER[IN_FASTGLYPH_BYTES]);
    wprintf(L"\tCache Glyph orders\t\t\t%u\n", OUT_COUNTER[OUT_CACHEGLYPH]);
    wprintf(L"\tCache Glyph bytes \t\t\t%u\n", OUT_COUNTER[OUT_CACHEGLYPH_BYTES]);

    wprintf(L"\nDrvLineTo\n");
    wprintf(L"\tCalls             \t\t\t\t%u\n", OUT_COUNTER[OUT_LINETO_ALL        ]);
    wprintf(L"\tLineTo orders    \t\t\t\t%u\n", OUT_COUNTER[OUT_LINETO_ORDR       ]);
    wprintf(L"\tLineTo bytes      \t\t\t%u\n", IN_COUNTER[IN_LINETO_BYTES]);
    wprintf(L"\tSent as SDA       \t\t\t\t%u\n", OUT_COUNTER[OUT_LINETO_SDA        ]);
    wprintf(L"\t\tUnsupported order\t\t\t%u\n", OUT_COUNTER[OUT_LINETO_SDA_UNSUPPORTED]);
    wprintf(L"\t\tUnsupported brush\t\t\t%u\n", OUT_COUNTER[OUT_LINETO_SDA_BADBRUSH]);
    wprintf(L"\t\tComplex clipping\t\t\t%u\n", OUT_COUNTER[OUT_LINETO_SDA_COMPLEXCLIP]);
    wprintf(L"\t\tFailed to add order\t\t\t%u\n", OUT_COUNTER[OUT_LINETO_SDA_FAILEDADD]);
    wprintf(L"\tSDA pixels\t\t\t%u\n", IN_COUNTER[IN_SDA_LINETO_AREA]);

    wprintf(L"\nDrvStrokePath\n");
    wprintf(L"\tCalls \t\t\t\t%u\n", OUT_COUNTER[OUT_STROKEPATH_ALL    ]);
    wprintf(L"\tSent as SDA       \t\t\t\t%u\n", OUT_COUNTER[OUT_STROKEPATH_SDA    ]);
    wprintf(L"\t\tLineTo unsupported\t\t\t%u\n", OUT_COUNTER[OUT_STROKEPATH_SDA_NOLINETO]);
    wprintf(L"\t\tUnsupported brush\t\t\t%u\n", OUT_COUNTER[OUT_STROKEPATH_SDA_BADBRUSH]);
    wprintf(L"\t\tComplex clipping\t\t\t%u\n", OUT_COUNTER[OUT_STROKEPATH_SDA_COMPLEXCLIP]);
    wprintf(L"\t\tFailed to add order\t\t\t%u\n", OUT_COUNTER[OUT_STROKEPATH_SDA_FAILEDADD]);
    wprintf(L"\tSDA pixels\t\t\t%u\n", IN_COUNTER[IN_SDA_STROKEPATH_AREA]);
    wprintf(L"\tNot sent            \t\t\t\t%u\n", OUT_COUNTER[OUT_STROKEPATH_UNSENT ]);
    wprintf(L"\tPolyLine orders     \t\t\t\t%u\n", OUT_COUNTER[OUT_STROKEPATH_POLYLINE]);
    wprintf(L"\tPolyLine bytes      \t\t\t\t%u\n", IN_COUNTER[IN_POLYLINE_BYTES]);
    wprintf(L"\tEllipseSC           \t\t\t\t%u\n", OUT_COUNTER[OUT_STROKEPATH_ELLIPSE_SC]);
    wprintf(L"\tEllipseSC bytes (dup below)\t\t\t\t%u\n", IN_COUNTER[IN_ELLIPSE_SC_BYTES]);

    wprintf(L"\nDrvFillPath\n");
    wprintf(L"\tCalls             \t\t\t\t%u\n", OUT_COUNTER[OUT_FILLPATH_ALL      ]);
    wprintf(L"\tSent as SDA       \t\t\t\t%u\n", OUT_COUNTER[OUT_FILLPATH_SDA      ]);
    wprintf(L"\tSDA pixels        \t\t\t\t%u\n", IN_COUNTER[IN_SDA_FILLPATH_AREA]);
    wprintf(L"\tNot sent          \t\t\t\t%u\n", OUT_COUNTER[OUT_FILLPATH_UNSENT   ]);
    wprintf(L"\tPolygon Solid     \t\t\t\t%u\n", OUT_COUNTER[OUT_FILLPATH_POLYGON_SC]);
    wprintf(L"\tPolygonSC bytes   \t\t\t\t%u\n", IN_COUNTER[IN_POLYGON_SC_BYTES]);
    wprintf(L"\tPolygon Brush     \t\t\t\t%u\n", OUT_COUNTER[OUT_FILLPATH_POLYGON_CB]);
    wprintf(L"\tPolygonCB bytes   \t\t\t\t%u\n", IN_COUNTER[IN_POLYGON_CB_BYTES]);
    wprintf(L"\tEllipse Solid     \t\t\t\t%u\n", OUT_COUNTER[OUT_FILLPATH_ELLIPSE_SC]);
    wprintf(L"\tEllipseSC bytes (dup above)\t\t\t\t%u\n", IN_COUNTER[IN_ELLIPSE_SC_BYTES]);
    wprintf(L"\tEllipse Brush     \t\t\t\t%u\n", OUT_COUNTER[OUT_FILLPATH_ELLIPSE_CB]);
    wprintf(L"\tEllipseCB bytes   \t\t\t\t%u\n", IN_COUNTER[IN_ELLIPSE_CB_BYTES]);

    wprintf(L"\nDrvPaint\n");
    wprintf(L"\tCalls             \t\t\t\t%u\n", OUT_COUNTER[OUT_PAINT_ALL         ]);
    wprintf(L"\tSent as SDA       \t\t\t\t%u\n", OUT_COUNTER[OUT_PAINT_SDA         ]);
    wprintf(L"\t\tComplex clipping\t\t\t%u\n",   OUT_COUNTER[OUT_PAINT_SDA_COMPLEXCLIP]);
    wprintf(L"\tNot sent          \t\t\t\t%u\n", OUT_COUNTER[OUT_PAINT_UNSENT      ]);

    wprintf(L"\nDrvRealizeBrush\n");
    wprintf(L"\tCalls             \t\t\t\t%u\n", OUT_COUNTER[OUT_BRUSH_ALL         ]);
    wprintf(L"\tNumber stored     \t\t\t\t%u\n", OUT_COUNTER[OUT_BRUSH_STORED      ]);
    wprintf(L"\tMono (!standard)  \t\t\t\t%u\n", OUT_COUNTER[OUT_BRUSH_MONO        ]);
    wprintf(L"\tStandard          \t\t\t\t%u\n", OUT_COUNTER[OUT_BRUSH_STANDARD    ]);
    wprintf(L"\tRejected          \t\t\t\t%u\n", OUT_COUNTER[OUT_BRUSH_REJECTED    ]);
    wprintf(L"\tCacheBrush orders \t\t\t\t%u\n", OUT_COUNTER[OUT_CACHEBRUSH]);
    wprintf(L"\tCacheBrush bytes  \t\t\t\t%u\n", OUT_COUNTER[OUT_CACHEBRUSH_BYTES]);

    wprintf(L"\nDrvSaveScreenBits\n");
    wprintf(L"\tCalls             \t\t\t\t%u\n", OUT_COUNTER[OUT_SAVESCREEN_ALL    ]);
    wprintf(L"\tSaveBitmap orders \t\t\t\t%u\n", OUT_COUNTER[OUT_SAVEBITMAP_ORDERS]);
    wprintf(L"\tSaveBitmap bytes  \t\t\t\t%u\n", IN_COUNTER[IN_SAVEBITMAP_BYTES]);
    wprintf(L"\tNot supported     \t\t\t\t%u\n", OUT_COUNTER[OUT_SAVESCREEN_UNSUPP ]);

    wprintf(L"\nOECheckBrushIsSimple\n");
    wprintf(L"\tFailed realization\t\t\t\t%u\n", OUT_COUNTER[OUT_CHECKBRUSH_NOREALIZATION]);
    wprintf(L"\tFailed because of complex brush\t\t\t\t%u\n", OUT_COUNTER[OUT_CHECKBRUSH_COMPLEX]);
    
    wprintf(L"*** END ***\n");
}


void
ZeroTSPerfCounters( ULONG LogonId )
{
    /************************************************************************/
    /* Get the current values in the winstation info record                 */
    /************************************************************************/
    GetTSPerfCounters(LogonId, &WinInfo);
    /************************************************************************/
    /* Zero out the counters                                                */
    /************************************************************************/
    memset (WinInfo.Status.Output.Specific.Reserved, 0,
            sizeof(WinInfo.Status.Output.Specific));
    memset (WinInfo.Status.Input.Specific.Reserved, 0,
            sizeof(WinInfo.Status.Input.Specific));
    /************************************************************************/
    /* Set the new values back                                              */
    /************************************************************************/
    if ( !WinStationSetInformation( SERVERNAME_CURRENT,
                                    //LogonId,
                                    LOGONID_CURRENT,
                                    WinStationInformation,
                                    &WinInfo,
                                    sizeof(WinInfo))) {
        wprintf(ERROR_SET_PERF, GetLastError());
        return;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpperf\rdpcount\utildll.h ===
/*******************************************************************************
* utildll.h
*
* UTILDLL WinStation utility support functions header file (export stuff)
*
* Copyright (C) 1997, Citrix Systems Inc.
* Copyright (C) 1997-1999 Microsoft Corp.
*
* $Author:   butchd  $  Butch Davis
*******************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

/*
 * UTILDLL defines and typedefs
 */
typedef struct _ELAPSEDTIME {
    USHORT days;
    USHORT hours;
    USHORT minutes;
    USHORT seconds;
} ELAPSEDTIME, * PELAPSEDTIME;

#define MAX_PROCESSNAME                 18
#define UTILDLL_NAME                    TEXT("UTILDLL.DLL")
#define SYSTEM_MESSAGE_MAX              256
#define MAX_ELAPSED_TIME_LENGTH         15
#define MAX_DATE_TIME_LENGTH            16

/*
 * UTILDLL function prototypes
 */
void StandardErrorMessage( LPCTSTR pszAppName,
                           HWND hwndApp,
                           HINSTANCE hinstApp,
                           ULONG LogonId,
                           UINT nId,
                           int nErrorResourceID, ...);
LPWSTR WINAPI GetSystemMessageW( ULONG LogonId, UINT nId, LPWSTR chBuffer, int chBuffSize );
LPSTR WINAPI GetSystemMessageA( ULONG LogonId, UINT nId, LPSTR chBuffer, int chBuffSize );
#ifdef UNICODE
#define GetSystemMessage GetSystemMessageW
#else
#define GetSystemMessage GetSystemMessageA
#endif

PPDPARAMS WINAPI WinEnumerateDevices( HWND hWnd,
                                      PPDCONFIG3 pPdConfig,
                                      PULONG pEntries,
                                      BOOL bInSetup );
BOOL WINAPI NetworkDeviceEnumerate( PPDCONFIG3, PULONG, PPDPARAMS,
                                    PULONG, BOOL );
BOOL WINAPI QueryCurrentWinStation( PWINSTATIONNAME pWSName, LPTSTR pUserName,
                                    PULONG pLogonId, PULONG pWSFlags );
LONG WINAPI RegGetNetworkDeviceName( HANDLE hServer, PPDCONFIG3 pPdConfig,
                                     PPDPARAMS pPdParams, LPTSTR szDeviceName,
                                     int nDeviceName );
LONG WINAPI RegGetNetworkServiceName( HANDLE hServer,
                                      LPTSTR szServiceKey,
                                      LPTSTR szServiceName,
                                      int nServiceName );
BOOL WINAPI AsyncDeviceEnumerate( PPDCONFIG3, PULONG, PPDPARAMS,
                                  PULONG, BOOL );
BOOL WINAPI NetBIOSDeviceEnumerate( PPDCONFIG3, PULONG, PPDPARAMS,
                                    PULONG, BOOL );
void WINAPI FormDecoratedAsyncDeviceName( LPTSTR pDeviceName,
                                          PASYNCCONFIG pAsyncConfig );
void WINAPI ParseDecoratedAsyncDeviceName( LPCTSTR pDeviceName,
                                           PASYNCCONFIG pAsyncConfig );
void WINAPI SetupAsyncCdConfig( PASYNCCONFIG pAsyncConfig,
                                PCDCONFIG pCdConfig );
BOOL WINAPI InstallModem( HWND hwndOwner );
BOOL WINAPI ConfigureModem( LPCTSTR pModemName, HWND hwndOwner );
BOOL GetAssociatedPortName(char  *szKeyName, WCHAR *wszPortName);
void WINAPI InitializeAnonymousUserCompareList( const WCHAR *pszServer );
BOOL WINAPI HaveAnonymousUsersChanged();
void WINAPI GetUserFromSid( PSID pSid, LPTSTR pUserName, DWORD cbUserName );
void WINAPI CachedGetUserFromSid( PSID pSid, PWCHAR pUserName, PULONG cbUserName );
BOOL WINAPI TestUserForAdmin( BOOL dom );
BOOL WINAPI IsPartOfDomain( VOID );
LPCTSTR WINAPI StrSdClass( SDCLASS SdClass );
LPCTSTR WINAPI StrConnectState( WINSTATIONSTATECLASS ConnectState,
                                BOOL bShortString );
LPCTSTR WINAPI StrProcessState( ULONG State );
LPCTSTR WINAPI StrSystemWaitReason( ULONG WaitReason );
LPCTSTR WINAPI GetUnknownString();
void WINAPI CalculateElapsedTime( LARGE_INTEGER *pTime,
                                  ELAPSEDTIME *pElapsedTime );
int WINAPI CompareElapsedTime( ELAPSEDTIME *pElapsedTime1,
                               ELAPSEDTIME *pElapsedTime2,
                               BOOL bCompareSeconds );
void WINAPI ElapsedTimeString( ELAPSEDTIME *pElapsedTime,
                               BOOL bIncludeSeconds,
                               LPTSTR pString );
void WINAPI DateTimeString( LARGE_INTEGER *pTime, LPTSTR pString );
void WINAPI CurrentDateTimeString( LPTSTR pString );
LARGE_INTEGER WINAPI CalculateDiffTime( LARGE_INTEGER, LARGE_INTEGER );
LPWSTR WINAPI EnumerateMultiUserServers( LPWSTR pDomain );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpperf\rdpcount\expand.h ===
/*****************************************************************************
* EXPAND.H
*
* Copyright (C) Citrix Systems Inc. 1990, 1992
* Copyright (C) 1997-1999 Microsoft Corp.
*
*   Author:   Kurt Perry
*             Ann Mizell
****************************************************************************/

/*
* Argument structure
*    Used by expand_path routine to build argument list.
*    Caller should initialize using args_init().  Use args_reset() to
*    reset values, args_free() to free memory allocated by args_init().
*/
struct arg_data {
   int argc;
   WCHAR **argv;
   WCHAR **argvp;
   int maxargc;
   int maxargs;
   WCHAR *buf;
   WCHAR *bufptr;
   WCHAR *bufend;
};
typedef struct arg_data ARGS;

/*
 * max size of segment to allocate for pathname storage
 */
#define MAX_ARG_ALLOC 10*1024-20

extern void args_init(ARGS *, int);
extern void args_trunc(ARGS *);
extern void args_reset(ARGS *);
extern void args_free(ARGS *);
extern int  expand_path(WCHAR *, unsigned short, ARGS *);
extern int  unix_match(WCHAR *, WCHAR *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpperf\rdpcount\ansiuni.h ===
/*******************************************************************************
* ansiuni.h
*
* Utility (host and client) ANSI / UNICODE function defines
*
* Copyright (C) 1995, Citrix Systems Inc.
* Copyright (C) 1997-1999 Microsoft Corp.
*******************************************************************************/

#ifdef UNICODE
#ifndef TCHAR
#define TCHAR WCHAR
#endif // TCHAR
#define lstrscanf swscanf
#define lstrncpy wcsncpy
#define lstrtoul wcstoul
#define lstrtol wcstol
#define lstrnicmp _wcsnicmp
#define lstrupr _wcsupr
#define lstrlwr _wcslwr
#define islstrdigit iswdigit
#define lstrtok wcstok
#define lstrprintf swprintf
#define lstrnprintf _snwprintf
#define lstrchr wcschr
#define lstrpbrk wcspbrk
#define lstrrchr wcsrchr
#define lstr_getcwd _wgetcwd
#define lstr_access _waccess
#define lstr_mkdir _wmkdir
#define lstrstr wcsstr
#define lstrcspn wcscspn
#else
#ifndef TCHAR
#define TCHAR char
#endif // TCHAR
#ifdef WIN16
#define lstrscanf sscanf	    // need to cast string args to NEAR pointers
#define lstrncpy _fstrncpy
#define lstrtoul strtoul	    // need to cast string args to NEAR pointers
#define lstrtol strtol		    // need to cast string args to NEAR pointers
#define lstrnicmp _fstrnicmp
#define lstrupr _fstrupr
#define lstrlwr _fstrlwr
#define islstrdigit isdigit
#define lstrtok _fstrtok
#define lstrprintf sprintf          // need to cast string args to NEAR pointers
#define lstrnprintf _snprintf	    // need to cast string args to NEAR pointers
#define lstrchr _fstrchr
#define lstrpbrk _fstrpbrk
#define lstrrchr _fstrrchr
#define lstr_getcwd _getcwd	    // need to cast string args to NEAR pointers
#define lstr_access _access	    // need to cast string args to NEAR pointers
#define lstr_mkdir _mkdir	    // need to cast string args to NEAR pointers
#define lstrstr strstr  	    // need to cast string args to NEAR pointers
#define lstrcspn strcspn	    // need to cast string args to NEAR pointers
#else
#define lstrscanf sscanf
#define lstrncpy strncpy
#define lstrtoul strtoul
#define lstrtol strtol
#define lstrnicmp _strnicmp
#define lstrupr _strupr
#define lstrlwr _strlwr
#define islstrdigit isdigit
#define lstrtok strtok
#define lstrprintf sprintf
#define lstrnprintf _snprintf
#define lstrchr strchr
#define lstrpbrk strpbrk
#define lstrrchr strrchr
#define lstr_getcwd _getcwd
#define lstr_access _access
#define lstr_mkdir _mkdir
#define lstrstr strstr
#define lstrcspn strcspn
#endif // WIN16
#endif // UNICODE

#define lengthof(x)    (sizeof(x) / sizeof(TCHAR))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpperf\utilsub\ansiuni.h ===
/*******************************************************************************
* ansiuni.h
*
* Utility (host and client) ANSI / UNICODE function defines
*
* Copyright 1995, Citrix Systems Inc.
* Copyright (C) 1997-1999 Microsoft Corp.
*
* $Author:   butchd  $ Butch Davis
*******************************************************************************/

#ifdef UNICODE
#ifndef TCHAR
#define TCHAR WCHAR
#endif // TCHAR
#define lstrscanf swscanf
#define lstrncpy wcsncpy
#define lstrtoul wcstoul
#define lstrtol wcstol
#define lstrnicmp _wcsnicmp
#define lstrupr _wcsupr
#define lstrlwr _wcslwr
#define islstrdigit iswdigit
#define lstrtok wcstok
#define lstrprintf swprintf
#define lstrnprintf _snwprintf
#define lstrchr wcschr
#define lstrpbrk wcspbrk
#define lstrrchr wcsrchr
#define lstr_getcwd _wgetcwd
#define lstr_access _waccess
#define lstr_mkdir _wmkdir
#define lstrstr wcsstr
#define lstrcspn wcscspn
#else
#ifndef TCHAR
#define TCHAR char
#endif // TCHAR
#ifdef WIN16
#define lstrscanf sscanf	    // need to cast string args to NEAR pointers
#define lstrncpy _fstrncpy
#define lstrtoul strtoul	    // need to cast string args to NEAR pointers
#define lstrtol strtol		    // need to cast string args to NEAR pointers
#define lstrnicmp _fstrnicmp
#define lstrupr _fstrupr
#define lstrlwr _fstrlwr
#define islstrdigit isdigit
#define lstrtok _fstrtok
#define lstrprintf sprintf          // need to cast string args to NEAR pointers
#define lstrnprintf _snprintf	    // need to cast string args to NEAR pointers
#define lstrchr _fstrchr
#define lstrpbrk _fstrpbrk
#define lstrrchr _fstrrchr
#define lstr_getcwd _getcwd	    // need to cast string args to NEAR pointers
#define lstr_access _access	    // need to cast string args to NEAR pointers
#define lstr_mkdir _mkdir	    // need to cast string args to NEAR pointers
#define lstrstr strstr  	    // need to cast string args to NEAR pointers
#define lstrcspn strcspn	    // need to cast string args to NEAR pointers
#else
#define lstrscanf sscanf
#define lstrncpy strncpy
#define lstrtoul strtoul
#define lstrtol strtol
#define lstrnicmp _strnicmp
#define lstrupr _strupr
#define lstrlwr _strlwr
#define islstrdigit isdigit
#define lstrtok strtok
#define lstrprintf sprintf
#define lstrnprintf _snprintf
#define lstrchr strchr
#define lstrpbrk strpbrk
#define lstrrchr strrchr
#define lstr_getcwd _getcwd
#define lstr_access _access
#define lstr_mkdir _mkdir
#define lstrstr strstr
#define lstrcspn strcspn
#endif // WIN16
#endif // UNICODE

#define lengthof(x)    (sizeof(x) / sizeof(TCHAR))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpperf\utilsub\makefile.inc ===
#
#       Do not delete this file, needed to build .lib file.
#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpperf\rdpcount\utilsub.h ===
/*****************************************************************************
* UTILSUB.H
*      This file contains the structure definitions and equtates for
*      communication between calling programs and functions in utilsub.lib.
*
* Copyright Citrix Systems Inc. 1990-1995
* Copyright (C) 1997-1999 Microsoft Corp.
*
*   $Author:   butchd  $
****************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

/*-----------------------------------------------------------------------------
 --   type-defs for File List Structure.
 ----------------------------------------------------------------------------*/
typedef struct _FILELIST {
   int	  argc;
   WCHAR  **argv;
} FILELIST, *PFILELIST;

/*-----------------------------------------------------------------------------
 --   type-defs for Token Map Structure.
 ----------------------------------------------------------------------------*/
// UNICODE version
typedef struct _TOKMAPW {
   PWCHAR tmToken;	   /* token; null pointer terminates list */
   USHORT tmFlag;	   /* flags for control communication */
   USHORT tmForm;	   /* format control string */
   USHORT tmDLen;	   /* length of data fields */
   PVOID  tmAddr;	   /* pointer to interpreted data */
} TOKMAPW, *PTOKMAPW;

// ANSI version
typedef struct _TOKMAPA {
   PCHAR  tmToken;	   /* token; null pointer terminates list */
   USHORT tmFlag;	   /* flags for control communication */
   USHORT tmForm;	   /* format control string */
   USHORT tmDLen;	   /* length of data fields */
   PVOID  tmAddr;	   /* pointer to interpreted data */
} TOKMAPA, *PTOKMAPA;

/*-----------------------------------------------------------------------------
 --   type-defs for Token Map Structure USE FOR CALLING SDM.DLL FUNCIONS
 ----------------------------------------------------------------------------*/
typedef struct _FILETOKMAP {
   PWCHAR tmToken;         /* token; null pointer terminates list */
   USHORT tmFlag;	   /* flags for control communication */
   USHORT tmForm;	   /* format control string */
   USHORT tmDLen;	   /* length of data fields */
   PVOID  tmAddr;	   /* pointer to interpreted data */
   USHORT tmLast;	   /* pointer for FindFirst FindNext junk */
} FILETOKMAP, FAR * PFILETOKMAP, NEAR * NPFILETOKMAP, * DPFILETOKMAP;

/*-----------------------------------------------------------------------------
 --   equates for _TOKMAP->tmFlag
 ----------------------------------------------------------------------------*/
#define TMFLAG_OPTIONAL       0x0000
#define TMFLAG_REQUIRED       0x0001
#define TMFLAG_PRESENT	      0x0002   /* was present in command line */
#define TMFLAG_MODIFIED       0x0004   /* was modified by app, request write */
#define TMFLAG_DELETE	      0x0008   /* request delete */

/*-----------------------------------------------------------------------------
 --   equates for _TOKMAP->tmForm
 ----------------------------------------------------------------------------*/
#define TMFORM_VOID	      0x0000
#define TMFORM_BOOLEAN	      0x0001
#define TMFORM_BYTE	      0x0002
#define TMFORM_CHAR	      0x0003
#define TMFORM_STRING	      0x0004
#define TMFORM_SHORT	      0x0005
#define TMFORM_USHORT	      0x0006
#define TMFORM_LONG	      0x0007
#define TMFORM_ULONG	      0x0008
#define TMFORM_HEX	      0x0009
#define TMFORM_LONGHEX	      0x000A
#define TMFORM_SERIAL	      0x000B
#define TMFORM_DATE	      0x000C
#define TMFORM_PHONE	      0x000D
#define TMFORM_X_STRING       0x000E
#define TMFORM_FILES	      0x000F
#define TMFORM_S_STRING       0x0010

/*-----------------------------------------------------------------------------
 --   equates for _TOKMAP->tmDLen
 ----------------------------------------------------------------------------*/
#define TMDLEN_VOID	      0x0000

/*-----------------------------------------------------------------------------
 --   prototype for Parse and setargv functions
 ----------------------------------------------------------------------------*/
// UNICODE prototypes
int WINAPI setargvW( LPWSTR szModuleName, LPWSTR szCmdLine, int *, WCHAR *** );
void WINAPI freeargvW( WCHAR ** );
USHORT WINAPI ParseCommandLineW(INT, WCHAR **, PTOKMAPW, USHORT);
BOOLEAN WINAPI IsTokenPresentW( PTOKMAPW, PWCHAR );
BOOLEAN WINAPI SetTokenPresentW( PTOKMAPW, PWCHAR );
BOOLEAN WINAPI SetTokenNotPresentW( PTOKMAPW, PWCHAR );

// ANSI prototypes
int WINAPI setargvA( LPSTR szModuleName, LPSTR szCmdLine, int *, char *** );
void WINAPI freeargvA( char ** );
USHORT WINAPI ParseCommandLineA(INT, CHAR **, PTOKMAPA, USHORT);
BOOLEAN WINAPI IsTokenPresentA( PTOKMAPA, PCHAR );
BOOLEAN WINAPI SetTokenPresentA( PTOKMAPA, PCHAR );
BOOLEAN WINAPI SetTokenNotPresentA( PTOKMAPA, PCHAR );

#ifdef UNICODE
#define setargv setargvW
#define freeargv freeargvW
#define ParseCommandLine ParseCommandLineW
#define IsTokenPresent IsTokenPresentW
#define SetTokenPresent SetTokenPresentW
#define SetTokenNotPresent SetTokenNotPresentW
#define TOKMAP TOKMAPW
#define PTOKMAP PTOKMAPW
#else
#define setargv setargvA
#define freeargv freeargvA
#define ParseCommandLine ParseCommandLineA
#define IsTokenPresent IsTokenPresentA
#define SetTokenPresent SetTokenPresentA
#define SetTokenNotPresent SetTokenNotPresentA
#define TOKMAP TOKMAPA
#define PTOKMAP PTOKMAPA
#endif /* UNICODE */

/*-----------------------------------------------------------------------------
 --   flags for ParseCommandLine().
 ----------------------------------------------------------------------------*/
#define PCL_FLAG_CONTINUE_ON_ERROR     0x0001
#define PCL_FLAG_RET_ON_FIRST_SUCCESS  0x0002
#define PCL_FLAG_IGNORE_INVALID        0x0004
#define PCL_FLAG_NO_CLEAR_MEMORY       0x0008
#define PCL_FLAG_NO_VERSION_CHECK      0x0010
#define PCL_FLAG_VERSION_CHK_UPWARD    0x0020

/*-----------------------------------------------------------------------------
 --   flags for rc=ParseCommandLine(),	PARSE_FLAG_* (BIT FLAGS)
 ----------------------------------------------------------------------------*/
#define PARSE_FLAG_NO_ERROR	       0x0000
#define PARSE_FLAG_MISSING_REQ_FIELD   0x0001
#define PARSE_FLAG_INVALID_PARM        0x0002
#define PARSE_FLAG_DUPLICATE_FIELD     0x0004
#define PARSE_FLAG_NO_PARMS	       0x0008
#define PARSE_FLAG_TOO_MANY_PARMS      0x0010
#define PARSE_FLAG_NOT_ENOUGH_MEMORY   0x0020

/*-----------------------------------------------------------------------------
 --   prototypes for WinStation utility functions
 ----------------------------------------------------------------------------*/

VOID WINAPI RefreshAllCaches();

VOID WINAPI RefreshWinStationCaches();

VOID WINAPI RefreshWinStationObjectCache();

VOID WINAPI RefreshWinStationNameCache();

ULONG WINAPI GetCurrentLogonId( );

VOID WINAPI GetCurrentWinStationName( PWCHAR, int );

BOOLEAN WINAPI GetWinStationNameFromId( ULONG, PWCHAR, int );

BOOLEAN WINAPI GetWinStationUserName( ULONG, PWCHAR, int );

VOID WINAPI GetCurrentUserName( PWCHAR, int );

BOOLEAN WINAPI WinStationObjectMatch( VOID *, PWCHAR );

/*-----------------------------------------------------------------------------
 --   prototypes for process/user utility functions
 ----------------------------------------------------------------------------*/

VOID WINAPI RefreshProcessObjectCaches();

VOID WINAPI RefreshUserSidCrcCache();

BOOLEAN WINAPI ProcessObjectMatch( ULONG, ULONG, int, PWCHAR, PWCHAR, PWCHAR, PWCHAR );

VOID WINAPI GetUserNameFromSid( VOID *, PWCHAR, PULONG );

/*-----------------------------------------------------------------------------
 --   prototypes for helper functions
 ----------------------------------------------------------------------------*/

USHORT WINAPI CalculateCrc16( PBYTE, USHORT );

INT WINAPI ExecProgram( PPROGRAMCALL, INT, WCHAR ** );

VOID WINAPI ProgramUsage( LPCWSTR, PPROGRAMCALL, BOOLEAN );

VOID WINAPI Message( int nResourceID, ... );

VOID WINAPI ErrorPrintf( int nErrorResourceID, ... );

VOID WINAPI TruncateString( PWCHAR pString, int MaxLength );

PPDPARAMS WINAPI EnumerateDevices(PDLLNAME pDllName, PULONG pEntries);

FILE * WINAPI wfopen( LPCWSTR filename, LPCWSTR mode );

PWCHAR WINAPI wfgets( PWCHAR Buffer, int Len, FILE *Stream);

int WINAPI PutStdErr(unsigned int MsgNum, unsigned int NumOfArgs, ...);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpperf\utilsub\expand.h ===
/*****************************************************************************
* EXPAND.H
*
* Copyright Citrix Systems Inc. 1990, 1992
* Copyright (C) 1997-1999 Microsoft Corp.
*
*   Author:   Kurt Perry
*             Ann Mizell
****************************************************************************/

/*
* Argument structure
*    Used by expand_path routine to build argument list.
*    Caller should initialize using args_init().  Use args_reset() to
*    reset values, args_free() to free memory allocated by args_init().
*/
struct arg_data {
   int argc;
   WCHAR **argv;
   WCHAR **argvp;
   int maxargc;
   int maxargs;
   WCHAR *buf;
   WCHAR *bufptr;
   WCHAR *bufend;
};
typedef struct arg_data ARGS;

/*
 * max size of segment to allocate for pathname storage
 */
#define MAX_ARG_ALLOC 10*1024-20

extern void args_init(ARGS *, int);
extern void args_trunc(ARGS *);
extern void args_reset(ARGS *);
extern void args_free(ARGS *);
extern int  expand_path(WCHAR *, unsigned short, ARGS *);
extern int  unix_match(WCHAR *, WCHAR *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpperf\utilsub\parse_a.c ===
/*****************************************************************************
* PARSE_A.C
*
*      ANSI stubs / replacements for the UNICODE command line parsing 
*      routines (parse.c)
*
*      External Entry Points:  (defined in utilsub.h)
*
*         ParseCommandLineA()
*         IsTokenPresentA()
*         SetTokenPresentA()
*         SetTokenNotPresentA()
*
* Copyright Citrix Systems Inc. 1995
* Copyright (C) 1997-1999 Microsoft Corp.
*
*   $Author:   butchd  $ Butch Davis
****************************************************************************/

/* Get the standard C includes */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

#include <winstaw.h>
#include <utilsub.h>

/*=============================================================================
 ==   Local Functions Defined
 ============================================================================*/

/*=============================================================================
 ==   External Functions Used
 ============================================================================*/

/*=============================================================================
 ==   Local Variables Used
 ============================================================================*/

/*=============================================================================
 ==   Global Variables Used
 ============================================================================*/

/*****************************************************************************
*
*   ParseCommandLineA (ANSI stub for ParseCommandLineW)
*
*   Thunks over argv_a (ANSI) to argv_w (UNICODE) and TOKMAPA to TOKMAPW, 
*   calls ParseCommandLineW(), then thunks back TOKMAPW to TOKMAPA and
*   returns
*
*   ENTRY:
*       (refer to ParseCommandLineW)
*   EXIT:
*       (refer to ParseCommandLineW), plus
*       PARSE_FLAG_NOT_ENOUGH_MEMORY
*
****************************************************************************/

#define tmFormIsString(x) ((x == TMFORM_S_STRING) || (x == TMFORM_DATE) || (x == TMFORM_PHONE) || (x == TMFORM_STRING) || (x == TMFORM_X_STRING))

USHORT WINAPI
ParseCommandLineA( INT argc,
                   CHAR **argv_a,
                   PTOKMAPA ptm_a,
                   USHORT flag )
{
    int i, len1, len2;
    USHORT rc = PARSE_FLAG_NOT_ENOUGH_MEMORY;   // default to memory error
    WCHAR **argv_w = NULL;
    PTOKMAPA ptmtmp_a;
    PTOKMAPW ptmtmp_w, ptm_w = NULL;

    /*
     * If no parameters, we skip a lot of work.
     */
    if ( argc == 0 ) {
        rc = PARSE_FLAG_NO_PARMS;
        return(rc);
    }

    /*        
     * Alloc and form WCHAR argvw array.
     */
    if ( !(argv_w = (WCHAR **)malloc( (len1 = argc * sizeof(WCHAR *)) )) )
        goto done;  // memory error
    memset(argv_w, 0, len1);     // zero all to init pointers to NULL
    for ( i = 0; i < argc; i++ ) {
        if ( argv_w[i] = malloc((len1 = ((len2 = strlen(argv_a[i])+1) * 2))) ) {
            memset(argv_w[i], 0, len1);
            mbstowcs(argv_w[i], argv_a[i], len2);
        } else {
            goto done;  // memory error
        }
    }

    /*
     * Alloc and form TOKMAPW array.
     */
    for ( ptmtmp_a=ptm_a, i=0; 
          ptmtmp_a->tmToken != NULL; 
          ptmtmp_a++, i++ );
    if ( !(ptm_w = (PTOKMAPW)malloc( (len1 = ++i * sizeof(TOKMAPW)) )) )
        goto done;  // memory error
    memset(ptm_w, 0, len1);     // zero all to init pointers to NULL
    for ( ptmtmp_w=ptm_w, ptmtmp_a=ptm_a;
          ptmtmp_a->tmToken != NULL; 
          ptmtmp_w++, ptmtmp_a++ ) {

        /*                
         * Allocate and convert token.
         */
        if ( ptmtmp_w->tmToken = 
                malloc((len1 = ((len2 = strlen(ptmtmp_a->tmToken)+1) * 2))) ) {
            memset(ptmtmp_w->tmToken, 0, len1);
            mbstowcs(ptmtmp_w->tmToken, ptmtmp_a->tmToken, len2);
        } else {
            goto done;  // memory error
        }

        /*
         * Copy flag, form, and length (no conversion needed).
         */
        ptmtmp_w->tmFlag = ptmtmp_a->tmFlag;
        ptmtmp_w->tmForm = ptmtmp_a->tmForm;
        ptmtmp_w->tmDLen = ptmtmp_a->tmDLen;

        /*
         * Allocate or copy address if a data length was specified.
         */
        if ( ptmtmp_w->tmDLen ) {

            /*
             * Allocate new WCHAR address if we're a string type.  
             * Otherwise, point to original address (no conversion needed).
             */
            if ( tmFormIsString(ptmtmp_w->tmForm) ) {

                if ( ptmtmp_w->tmAddr =
                        malloc(len1 = ptmtmp_w->tmDLen*sizeof(WCHAR)) )
                    memset(ptmtmp_w->tmAddr, 0, len1);
                else
                    goto done;  // memory error

            } else {

                ptmtmp_w->tmAddr = ptmtmp_a->tmAddr;
            }

            /*
             * For proper default behavior, zero ANSI address contents if 
             * the "don't clear memory" flag is not set.
             */
            if ( !(flag & PCL_FLAG_NO_CLEAR_MEMORY) )
                memset(ptmtmp_a->tmAddr, 0, ptmtmp_a->tmDLen);
        }
    }

    /*
     * Call ParseCommandLineW
     */
    rc = ParseCommandLineW(argc, argv_w, ptm_w, flag);

    /*
     * Copy flags for each TOPMAPW element.  Also, convert to ANSI strings
     * that were present on the command line into caller's TOKMAPA array, if 
     * data length was specified.
     */
    for ( ptmtmp_w=ptm_w, ptmtmp_a=ptm_a;
          ptmtmp_w->tmToken != NULL; 
          ptmtmp_w++, ptmtmp_a++ ) {

        ptmtmp_a->tmFlag = ptmtmp_w->tmFlag;

        if ( ptmtmp_w->tmDLen && 
             (ptmtmp_w->tmFlag & TMFLAG_PRESENT) &&
             tmFormIsString(ptmtmp_w->tmForm) )
            wcstombs(ptmtmp_a->tmAddr, ptmtmp_w->tmAddr, ptmtmp_w->tmDLen);
    }

done:
    /*
     * Free the argvw array.
     */
    if ( argv_w ) {

        for ( i = 0; i < argc; i++ ) {
            if ( argv_w[i] )
                free(argv_w[i]);
        }
        free(argv_w);
    }

    /*
     * Free the TOKMAPW tokens, string addresses, and TOKMAK array itself.
     */
    if ( ptm_w ) {

        for ( ptmtmp_w=ptm_w; ptmtmp_w->tmToken != NULL; ptmtmp_w++ ) {

            /*                
             * Free token.
             */
            free(ptmtmp_w->tmToken);

            /*
             * Free address if a data length was specified and we're a
             * string type.
             */
            if ( ptmtmp_w->tmDLen && tmFormIsString(ptmtmp_w->tmForm) )
                free(ptmtmp_w->tmAddr);
        }
        free(ptm_w);
    }

    /*
     * Return ParseCommandLineW status.
     */
    return(rc);

}  // end ParseCommandLineA


/*****************************************************************************
*
*   IsTokenPresentA (ANSI version)
*
*       Determines if a specified command line token (in given TOKMAPA array)
*       was present on the command line.
*
*   ENTRY:
*       ptm (input)
*           Points to 0-terminated TOKMAPA array to scan.
*       pToken (input)
*           The token to scan for.
*
*   EXIT:
*       TRUE if the specified token was present on the command line;
*       FALSE otherwise.
*
****************************************************************************/

BOOLEAN WINAPI
IsTokenPresentA( PTOKMAPA ptm,
                 PCHAR pToken )
{
    int i;

    for ( i = 0; ptm[i].tmToken; i++ ) {
        if ( !strcmp( ptm[i].tmToken, pToken ) )
            return( (ptm[i].tmFlag & TMFLAG_PRESENT) ? TRUE : FALSE );
    }

    return(FALSE);

}  // end IsTokenPresentA


/*****************************************************************************
*
*   SetTokenPresentA (ANSI version)
*
*       Forces a specified command line token (in given TOKMAPA array)
*       to be flagged as 'present' on the command line.
*
*   ENTRY:
*       ptm (input)
*           Points to 0-terminated TOKMAPA array to scan.
*       pToken (input)
*           The token to scan for and set flags.
*
*   EXIT:
*       TRUE if the specified token was found in the TOKMAPA array
*       (TMFLAG_PRESENT flag is set).  FALSE otherwise.
*
****************************************************************************/

BOOLEAN WINAPI
SetTokenPresentA( PTOKMAPA ptm,
                  PCHAR pToken )
{
    int i;

    for ( i = 0; ptm[i].tmToken; i++ ) {
        if ( !strcmp( ptm[i].tmToken, pToken ) ) {
            ptm[i].tmFlag |= TMFLAG_PRESENT;
            return(TRUE);
        }
    }

    return(FALSE);

}  // end SetTokenPresentA


/*****************************************************************************
*
*   SetTokenNotPresentA (ANSI Versio)
*
*       Forces a specified command line token (in given TOKMAPA array)
*       to be flagged as 'not present' on the command line.
*
*   ENTRY:
*       ptm (input)
*           Points to 0-terminated TOKMAPA array to scan.
*       pToken (input)
*           The token to scan for and set flags.
*
*   EXIT:
*       TRUE if the specified token was found in the TOKMAPA array
*       (TMFLAG_PRESENT flag is reset).  FALSE otherwise.
*
****************************************************************************/

BOOLEAN WINAPI
SetTokenNotPresentA( PTOKMAPA ptm,
                     PCHAR pToken )
{
    int i;

    for ( i = 0; ptm[i].tmToken; i++ ) {
        if ( !strcmp( ptm[i].tmToken, pToken ) ) {
            ptm[i].tmFlag &= ~TMFLAG_PRESENT;
            return(TRUE);
        }
    }

    return(FALSE);

}  // end SetTokenNotPresentA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpperf\utilsub\expand.c ===
/******************************************************************************
*
* EXPAND.C
*
* Copyright Citrix Systems Inc. 1994
* Copyright (C) 1997-1999 Microsoft Corp.
******************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define INCL_DOSPROCESS
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_ERRORS
#ifdef DOS
#define INCL_NOXLATE_DOS16
#endif

#include "expand.h"

#define TRUE 1
#define FALSE 0

#define SUCCESS 0       /* function call successful */
#define FAILURE (-1)    /* function call had a failure */

#define READ_ONLY 0x0001   /* file is read only */
#define HIDDEN    0x0002   /* file is hidden */
#define SYSTEM    0x0004   /* file is a system file */
#define VOLUME    0x0008   /* file is a volume label */
#define SUBDIR    0x0010   /* file is a subdirectory */
#define ARCHIVE   0x0020   /* file has archive bit on */

#define uint unsigned int
#define ulong unsigned long
#define ushort unsigned short

/*
 * struct search_rec is used to form a linked list of path specifications
 * that are still left to be searched.
 */
struct search_rec {
   struct search_rec *next;
   WCHAR *dir_spec;         /* path spec up until component w/ wildcard */
   WCHAR *wild_spec;        /* component containing wildcard char(s) */
   WCHAR *remain;           /* remainder of name after wildcard component */
   ushort attr;
   };

/*
 * global variables
 */
static struct search_rec *search_head = NULL;

/*
 * prototypes of functions referenced
 */
split_path(WCHAR *, WCHAR *, WCHAR *, WCHAR *);
add_search_list(WCHAR *, WCHAR *, WCHAR *, ushort);
add_arg_to_list(WCHAR *, ARGS *);
do_tree(struct search_rec *, ushort, ARGS *);
file_exists(WCHAR *);


/******************************************************************************
*
* args_init()
*
*   Initialize the ARGS struct passed as an argument.
*
*   ENTRY:
*       argp = pointer to ARGS struct
*       maxargs = max number of args expected
*
*   EXIT:
*
******************************************************************************/

void
args_init( ARGS *argp,
           int maxargs )
{

   argp->argc = 0;
   argp->argv = argp->argvp = NULL;
   argp->maxargc = argp->maxargs = maxargs;
   argp->buf = argp->bufptr = argp->bufend = NULL;
}


/******************************************************************************
* args_trunc()
*
*   Truncate the memory used by the ARGS struct
*   so that unused memory is freed.
*
*   ENTRY:
*       argp = pointer to ARGS struct
*
*   EXIT:
*
******************************************************************************/

void
args_trunc( ARGS *argp )
{

   /*
    * call realloc to shrink size of argv array, set maxargc = argc
    * to indicate no more room in argv array.
    */
   realloc(argp->argv, (argp->argc + 1) * sizeof(WCHAR*));
   argp->maxargc = argp->argc;

   /*
    * call realloc to shrink size of argument string buffer, set bufend
    * pointer to current buf pointer to indicate buf is full.
    */
   realloc(argp->buf, (size_t)(argp->bufptr - argp->buf));
   argp->bufend = argp->bufptr - 1;
}


/******************************************************************************
*
* args_reset()
*
*   Re-initialize the ARGS struct passed as an argument,
*   free memory if possible.
*
*   ENTRY:
*       argp = pointer to ARGS struct
*
*   EXIT:
*
******************************************************************************/

void
args_reset( ARGS *argp )
{

   /*
    * if there is an argv array, but it has been truncated, then free
    * the array so a new one will be allocated later.
    */
   if (argp->argv && argp->maxargc != argp->maxargs) {
      free(argp->argv);
      argp->argv = NULL;
   }
   argp->argc = 0;
   argp->argvp = argp->argv;
   argp->maxargc = argp->maxargs;

   /*
    * if there is an argument buffer, but it has been truncated, then
    * free the buffer so a new one will be allocated later.
    */
   if (argp->buf && argp->bufend != argp->buf + MAX_ARG_ALLOC - 1) {
      free(argp->buf);
      argp->buf = argp->bufend = NULL;
   }
   argp->bufptr = argp->buf;
}


/******************************************************************************
*
* args_free()
*
*   Will free the memory allocated for
*   argument storage by all preceeding calls to expand_path().
*   Args_init() must be called before reusing this ARGS structure.
*
*   ENTRY:
*       argp = pointer to ARGSW struct
*
*   EXIT:
*
******************************************************************************/

void
args_free( ARGS *argp )
{

   if (argp->argv != NULL)
      free(argp->argv);
   argp->argv = argp->argvp = NULL;

   if (argp->buf != NULL)
      free(argp->buf);
   argp->buf = argp->bufptr = argp->bufend = NULL;
}


/******************************************************************************
*
* expand_path()
*
*   This routine will expand the specified path string into pathnames
*   that match.  The matching pathnames will be added to the specified
*   argv array and the specified argc count will be incremented to
*   reflect the number of pathnames added.
*
*   This routine will expand filename arguments in Unix fashion
*   (i.e. '[..]' is supported, '?' and '*' are allowed anywhere in the
*   pathname, even in the directory part of the name, and the
*   name/extension separator '.' is not treated special but is just
*   considered part of the filename).
*
*   Storage for the pathname strings will be obtained via malloc.
*   This space may later be free'd with a call to args_free();
*
*   ENTRY:
*       path     Pathname string to be expanded.
*       attr     Attribute bits of files to include
*                   (regular, directory, hidden, system).
*                   -1 = return the specified pathname string unmodified
*                        in the argv array.
*       argp     Pointer to an ARGSW struct containing fields to be used/
*                updated by expand_path.  The ARGS struct must be initialized
*                by calling args_init() before calling expand_path().
*
*    EXIT:
*       TRUE  -- indicates at least 1 pathname was found matching
*                the pathname string specified.
*       FALSE -- indicates no matching pathnames were found.  The specified
*                pathname string is returned unmodified in the argv array.
*
******************************************************************************/

int
expand_path( WCHAR *path,
             ushort attr,
             ARGS *argp )
{
   int argc, add_count, rc, i, j, k;
   WCHAR **argv;
   WCHAR dirname[128], wild[128], remain[128];
   struct search_rec *save, *q;

#ifdef DEBUG
   printf("expand_path: path=%s attr=%d\n", path, attr);
#endif

   argc = argp->argc;
   argv = argp->argvp;
   if ( attr != -1 && split_path(path, dirname, wild, remain)) {
      add_search_list(dirname, wild, remain, attr);
      while (search_head) {
         /*
          * save the next portion and allow new directories to be
          * added to the head.
          */
         save = search_head->next;
         search_head->next = NULL;

         /*
          * perform the do_tree operation on the current path
          */
         rc = do_tree(search_head, attr, argp);

         /*
          * restore the saved list at the end of the head list
          */
         if ( save ) {
            q = search_head;
            while ( q->next ) {
               q = q->next;
            }
            q->next = save;
         }

         /*
          * move to the next path in the list and free the memory used
          * by the link we are done with
          */
         do {
            q = search_head;
            search_head = search_head->next;
            free( q->dir_spec );
            free( q->wild_spec );
            free( q->remain );
            free( q );
         } while (rc==FAILURE && search_head);
      }
   }

/*
 * If no filenames were expanded, just put the original name
 * into the buffer and indicate no names were expanded.
 */
   if (argc == argp->argc) {
      add_arg_to_list(path, argp);
      return(FALSE);
   }

/*
 * Sort the names just added
 */
   if ( argv == NULL )
      argv = argp->argv;
   add_count = argp->argc - argc;
   for (i=add_count-1; i>0; --i) {
      uint swap = FALSE;
      for (j=0; j<i; ++j) {
         if (!argv[j] || !argv[j+1]) {
            fprintf(stderr,"internal error 1\n");
         }
         for (k=0; k<128; ++k) {
            if (argv[j][k] < argv[j+1][k]) {
               break;
            } else if (argv[j][k] > argv[j+1][k]) {
               WCHAR *temp;
               swap = TRUE;
               temp = argv[j];
               argv[j] = argv[j+1];
               argv[j+1] = temp;
               break;
            }
         }
         if (k>125) {
            fprintf(stderr,"internal error 2\n");
         }
      }
      if (!swap) {
         break;
      }
   }
   return(TRUE);
}


/******************************************************************************
*
* add_search_list()
*
*    Adds a record to the global search list, search_head.
*
******************************************************************************/

static
add_search_list(
    WCHAR *dir_spec,        /* the dir to be added to the list */
    WCHAR *wild_spec,       /* the file to be added to the list */
    WCHAR *remain_spec,     /* remaining portion of pathname */
    ushort attr )
{
   struct search_rec *new, /* pointer to the new link */
                     *q;   /* used to traverse the linked list */

#ifdef DEBUG
   wprintf(L"add_search_list: dir=%s: file=%s: rem=%s:\n", dir_spec, wild_spec, remain_spec);
#endif

/*
 * allocate the new link.  make sure that it is initialized to zeros.
 */
   new = malloc(sizeof(struct search_rec));
   memset(new, 0, sizeof(struct search_rec));
   if (!new) {
      fprintf(stderr, "add_search_list: not enough memory (malloc)");
      return FAILURE;
   }

/*
 * allocate memory for and copy the dir spec and file spec.
 */
   if (dir_spec) {
      new->dir_spec = _wcslwr(_wcsdup(dir_spec));
      if (!new->dir_spec) {
         fprintf(stderr, "add_search_list: not enough memory (strdup1)");
         return FAILURE;
      }
   }
   if (wild_spec) {
      new->wild_spec = _wcslwr(_wcsdup(wild_spec));
      if (!new->wild_spec) {
         fprintf(stderr, "add_search_list: not enough memory (strdup2)");
         return FAILURE;
      }
   }
   if (remain_spec) {
      new->remain = _wcslwr(_wcsdup(remain_spec));
      if (!new->remain) {
         fprintf(stderr, "add_search_list: not enough memory (strdup3)");
         return FAILURE;
      }
   }

/*
 * store file attributes
 */
   if (remain_spec)
      new->attr = attr | SUBDIR;
   else
      new->attr = attr;

/*
 * add the new link at the end of the list
 */
   if (!search_head) {
      search_head = new;
   } else {
      q = search_head;
      while (q->next) {
         q = q->next;
      }
      q->next = new;
   }

   return SUCCESS;
}


/******************************************************************************
*
* add_arg_to_list()
*
*   This routine adds the specified argument string to the argv array,
*   and increments the argv pointer and argc counter.
*   If necessary, memory for the argument string is allocated.
*
*   EXIT:
*       SUCCESS -- if argument added successfully
*       FAILURE -- if argument could not be added
*             (indicates too many args or out of memory for argument string)
*
******************************************************************************/
static int
add_arg_to_list( WCHAR *arg_string,
                 ARGS *argp )
{
   int len;

#ifdef DEBUG
   wprintf(L"add_arg_to_list: arg_string=%s:, argc=%d, argvp=%x, maxargs=%d\n",
           arg_string,argp->argc,argp->argvp,argp->maxargc);
#endif
   if (argp->argc >= argp->maxargc) {
      fprintf(stderr,"add_arg_to_list: too many arguments\n");
      return FAILURE;
   }
   if (!argp->argv) {
      argp->argv = malloc(sizeof(WCHAR *) * (argp->maxargs+1));
      if (argp->argv) {
         argp->argc = 0;
         argp->argvp = argp->argv;
         argp->maxargc = argp->maxargs;
      } else {
         fprintf(stderr,"add_arg_to_list: not enough memory\n");
         return FAILURE;
      }
   }
   if (!argp->buf) {
      argp->buf = malloc(MAX_ARG_ALLOC);
      if (argp->buf) {
         argp->bufptr = argp->buf;
         argp->bufend = argp->buf + MAX_ARG_ALLOC - 1;
      } else {
         fprintf(stderr,"add_arg_to_list: not enough memory\n");
         return FAILURE;
      }
   }
   len = wcslen(arg_string) + 1;
   if (argp->bufptr + len > argp->bufend) {
      fprintf(stderr,"add_arg_to_list: argument buffer too small\n");
      return FAILURE;
   }
   wcscpy(argp->bufptr, arg_string);
   *(argp->argvp) = argp->bufptr;
   argp->bufptr += len;
   ++argp->argc;
   ++argp->argvp;
   *(argp->argvp) = NULL;
   return SUCCESS;
}


/******************************************************************************
*
* do_tree()
*
******************************************************************************/

static
do_tree( struct search_rec *searchp,
         ushort attr,
         ARGS *argp )
{
   int rc;                 /* return code from Dos calls */
   WIN32_FIND_DATA result; /* the structure returned from FindFirst/Next */
   ushort count = 1;       /* number of files to look for at one time */
   HANDLE handle;   /* the dir handle used by FindFirst/Next */
   WCHAR full_path[128];    /* used to hold the path/file combination */
   WCHAR dirname[128], wild[128], remain[128];
   WCHAR *fptr;             /* pointer to file portion of full_path */
   ULONG Status;

#ifdef DEBUG
   wprintf(L"do_tree: dirname=%s:\n", searchp->dir_spec);
#endif

   /*
    * build up directory part of path and save a pointer to the file portion
    */
   wcscpy(full_path, searchp->dir_spec);
   fptr = full_path + wcslen(searchp->dir_spec);
   wcscpy(fptr, L"*.*");

   handle = FindFirstFile ( full_path,                  /* files to find */
			&result
		       );

   if(handle == INVALID_HANDLE_VALUE){
       Status = GetLastError();
       if(Status == ERROR_NO_MORE_FILES) {
           // no files match
	   return(SUCCESS);
       }
       return(FAILURE);
   }

   rc = TRUE;
   while (rc) {
      /*
       * do not do anything for the "." and ".." entries
       */
      if (wcscmp(result.cFileName, L".") == 0 ||
         wcscmp(result.cFileName, L"..") == 0) {
         rc = FindNextFile( handle, &result );
         continue;
      }

      /*
       * fully qualify the found file
       */
      wcscpy(fptr, _wcslwr(result.cFileName));
      if (searchp->remain)
         wcscat(full_path, searchp->remain);

      /*
       * see if current wild_spec matches FindFirst/Next file
       */
      if (unix_match(searchp->wild_spec, result.cFileName)) {
         if (searchp->remain && split_path(full_path, dirname, wild, remain)) {
            if (result.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY &&
		file_exists(dirname))
               add_search_list(dirname, wild, remain, attr);
         } else if (file_exists(full_path)) {
            rc = add_arg_to_list(full_path, argp);
            if (rc != SUCCESS)
               break;
         }
      }

      /*
       * find the next file
       */
      rc = FindNextFile( handle, &result );
   }

   /*
    * if no more files to find then reset the error code back to successful.
    */

   if(!rc) {
       Status = GetLastError();
       if(Status == ERROR_NO_MORE_FILES)
	   rc = SUCCESS;
   }

   return rc;
}


/******************************************************************************
*
* split_path()
*
*   This routine splits the specified pathname into 3 parts, any of which
*   may be null; 1) the pathname from the beginning up to but not including
*   the first component containing a wildcard character, 2) the component
*   containing the wildcard, and 3) the remainder of the path string after
*   the component containing the wildcard.
*
*   Examples:
*      Original path              dir            file     remain
*      "c:\mydir\dir??\*.c"       "c:\mydir\"    "dir??"  "\*.c"
*      "*\abc.def"                ""             "*"      "\abc.def"
*      "mydir\*.c"                "mydir\"       "*.c"    ""
*
*   EXIT:
*       TRUE  -- if the pathname could be split
*       FALSE -- otherwise (i.e. pathname did not contain any wildcards)
*
******************************************************************************/

static int
split_path( WCHAR *path,
            WCHAR *dir,
            WCHAR *file,
            WCHAR *remain )
{
   WCHAR *cp, *end_dir, *end_wild = NULL;

#ifdef DEBUG
   wprintf("split_path: path=%s:\n", path);
#endif
   for (cp=end_dir=path; *cp!=L'\0'; ) {
      if (*cp==L'\\' || *cp==L'/' || *cp==L':') {
         ++cp;
         while (*cp==L'\\' || *cp==L'/' ) ++cp;
         end_dir = cp;
      } else if (*cp==L'*' || *cp==L'?' || *cp==L'[') {
         ++cp;
         while (*cp!=L'\\' && *cp!=L'/' && *cp!=L'\0') ++cp;
         end_wild = cp;
         break;
      } else {
         ++cp;
      }
   }
   if (!end_wild)
      return(FALSE);

   for (cp=path; cp<end_dir; ++cp, ++dir)
      *dir = *cp;
   *dir = L'\0';
   for (cp=end_dir; cp<end_wild; ++cp, ++file)
      *file = *cp;
   *file = L'\0';
   wcscpy(remain, cp);
#ifdef DEBUG
   wprintf("split_path: dir=%s: file=%s: remain=%s:\n", dir, file, remain);
#endif

   return(TRUE);
}


/******************************************************************************
*
* file_existsW()
*
*   Returns TRUE if specified file exists, otherwise returns FALSE.
*
******************************************************************************/

static int
file_exists( WCHAR *path )
{
   int len;
   WCHAR path2[128];
   WCHAR ch;
   ULONG Result;

   wcscpy(path2, path);
   len = wcslen(path2);
   while ((ch=path2[--len]) == L'\\' || ch == L'/' ) path2[len] = L'\0';
   
   Result = GetFileAttributes(path2);
   if(Result == 0xFFFFFFFF) {
       return(FALSE);
   }
   return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpperf\utilsub\helpers.c ===
/******************************************************************************
*  HELPERS.C
*
*  Various helper functions.
*
* Copyright Citrix Systems Inc. 1994
* Copyright (C) 1997-1999 Microsoft Corp.
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>

#include <winstaw.h>
#include <utilsub.h>
#include <tchar.h>


#define PERCENT TEXT('%')
#define NULLC TEXT('\0')
#define MAXCBMSGBUFFER 2048
TCHAR MsgBuf[MAXCBMSGBUFFER];
HANDLE NtDllHandle = NULL;

TCHAR *
mystrchr(TCHAR const *string, int c);


int
PutMsg(unsigned int MsgNum, unsigned int NumOfArgs, va_list *arglist);

/*******************************************************************************
 *
 *  CalculateCrc16
 *
 *      Calculates a 16-bit CRC of the specified buffer.
 *
 *  ENTRY:
 *      pBuffer (input)
 *          Points to buffer to calculate CRC for.
 *      length (input)
 *          Length in bytes of the buffer.
 *
 *  EXIT:
 *      (USHORT)
 *          The 16-bit CRC of the buffer.
 *
 ******************************************************************************/

/*
 * updcrc macro derived from article Copyright (C) 1986 Stephen Satchell.
 *  NOTE: First argument must be in range 0 to 255.
 *        Second argument is referenced twice.
 *
 * Programmers may incorporate any or all code into their programs,
 * giving proper credit within the source. Publication of the
 * source routines is permitted so long as proper credit is given
 * to Stephen Satchell, Satchell Evaluations and Chuck Forsberg,
 * Omen Technology.
 */

#define updcrc(cp, crc) ( crctab[((crc >> 8) & 255)] ^ (crc << 8) ^ cp)


/* crctab calculated by Mark G. Mendel, Network Systems Corporation */
unsigned short crctab[256] = {
    0x0000,  0x1021,  0x2042,  0x3063,  0x4084,  0x50a5,  0x60c6,  0x70e7,
    0x8108,  0x9129,  0xa14a,  0xb16b,  0xc18c,  0xd1ad,  0xe1ce,  0xf1ef,
    0x1231,  0x0210,  0x3273,  0x2252,  0x52b5,  0x4294,  0x72f7,  0x62d6,
    0x9339,  0x8318,  0xb37b,  0xa35a,  0xd3bd,  0xc39c,  0xf3ff,  0xe3de,
    0x2462,  0x3443,  0x0420,  0x1401,  0x64e6,  0x74c7,  0x44a4,  0x5485,
    0xa56a,  0xb54b,  0x8528,  0x9509,  0xe5ee,  0xf5cf,  0xc5ac,  0xd58d,
    0x3653,  0x2672,  0x1611,  0x0630,  0x76d7,  0x66f6,  0x5695,  0x46b4,
    0xb75b,  0xa77a,  0x9719,  0x8738,  0xf7df,  0xe7fe,  0xd79d,  0xc7bc,
    0x48c4,  0x58e5,  0x6886,  0x78a7,  0x0840,  0x1861,  0x2802,  0x3823,
    0xc9cc,  0xd9ed,  0xe98e,  0xf9af,  0x8948,  0x9969,  0xa90a,  0xb92b,
    0x5af5,  0x4ad4,  0x7ab7,  0x6a96,  0x1a71,  0x0a50,  0x3a33,  0x2a12,
    0xdbfd,  0xcbdc,  0xfbbf,  0xeb9e,  0x9b79,  0x8b58,  0xbb3b,  0xab1a,
    0x6ca6,  0x7c87,  0x4ce4,  0x5cc5,  0x2c22,  0x3c03,  0x0c60,  0x1c41,
    0xedae,  0xfd8f,  0xcdec,  0xddcd,  0xad2a,  0xbd0b,  0x8d68,  0x9d49,
    0x7e97,  0x6eb6,  0x5ed5,  0x4ef4,  0x3e13,  0x2e32,  0x1e51,  0x0e70,
    0xff9f,  0xefbe,  0xdfdd,  0xcffc,  0xbf1b,  0xaf3a,  0x9f59,  0x8f78,
    0x9188,  0x81a9,  0xb1ca,  0xa1eb,  0xd10c,  0xc12d,  0xf14e,  0xe16f,
    0x1080,  0x00a1,  0x30c2,  0x20e3,  0x5004,  0x4025,  0x7046,  0x6067,
    0x83b9,  0x9398,  0xa3fb,  0xb3da,  0xc33d,  0xd31c,  0xe37f,  0xf35e,
    0x02b1,  0x1290,  0x22f3,  0x32d2,  0x4235,  0x5214,  0x6277,  0x7256,
    0xb5ea,  0xa5cb,  0x95a8,  0x8589,  0xf56e,  0xe54f,  0xd52c,  0xc50d,
    0x34e2,  0x24c3,  0x14a0,  0x0481,  0x7466,  0x6447,  0x5424,  0x4405,
    0xa7db,  0xb7fa,  0x8799,  0x97b8,  0xe75f,  0xf77e,  0xc71d,  0xd73c,
    0x26d3,  0x36f2,  0x0691,  0x16b0,  0x6657,  0x7676,  0x4615,  0x5634,
    0xd94c,  0xc96d,  0xf90e,  0xe92f,  0x99c8,  0x89e9,  0xb98a,  0xa9ab,
    0x5844,  0x4865,  0x7806,  0x6827,  0x18c0,  0x08e1,  0x3882,  0x28a3,
    0xcb7d,  0xdb5c,  0xeb3f,  0xfb1e,  0x8bf9,  0x9bd8,  0xabbb,  0xbb9a,
    0x4a75,  0x5a54,  0x6a37,  0x7a16,  0x0af1,  0x1ad0,  0x2ab3,  0x3a92,
    0xfd2e,  0xed0f,  0xdd6c,  0xcd4d,  0xbdaa,  0xad8b,  0x9de8,  0x8dc9,
    0x7c26,  0x6c07,  0x5c64,  0x4c45,  0x3ca2,  0x2c83,  0x1ce0,  0x0cc1,
    0xef1f,  0xff3e,  0xcf5d,  0xdf7c,  0xaf9b,  0xbfba,  0x8fd9,  0x9ff8,
    0x6e17,  0x7e36,  0x4e55,  0x5e74,  0x2e93,  0x3eb2,  0x0ed1,  0x1ef0
};

USHORT WINAPI
CalculateCrc16( PBYTE pBuffer,
                USHORT length )
{

   USHORT Crc = 0;
   USHORT Data;

   while ( length-- ) {
      Data = (USHORT) *pBuffer++;
      Crc = updcrc( Data, Crc );
   }

   return(Crc);

} /* CalculateCrc16() */


/*****************************************************************************
*
*  ExecProgram
*     Build a command line argument string and execute a program.
*
*  ENTRY:
*       pProgCall (input)
*           ptr to PROGRAMCALL structure with program to execute.
*       argc (input)
*           count of the command line arguments.
*       argv (input)
*           vector of strings containing the command line arguments.
*
*  EXIT:
*       (int)
*           0 for success; 1 for error.  An error message will have already
*           been output on error.
*
*****************************************************************************/

#define ARGS_LEN       512      // maximum # of characters on command line
                                // for CreateProcess() call.

INT WINAPI
ExecProgram( PPROGRAMCALL pProgCall,
             INT argc,
             WCHAR **argv )
{
    int count;
    WCHAR program[50];
    WCHAR args[ARGS_LEN];
    PWCHAR pCurrArg;
    STARTUPINFO StartInfo;
    PROCESS_INFORMATION ProcInfo;
    BOOL flag;
    DWORD Status;

    wcscpy(program, pProgCall->Program);
    wcscpy(args, program);

    if (pProgCall->Args != NULL) {

        wcscat(args, L" ");
        wcscat(args, pProgCall->Args);
    }

    for (count = 0; count < argc; count++) {

        pCurrArg = argv[count];

        if ( (int)(wcslen(pCurrArg) + wcslen(args) + 3) > ARGS_LEN ) {

	    fwprintf(stderr, L"Maximum command line length exceeded\n");
            return(1);
        }
        wcscat(args, L" ");
        wcscat(args, pCurrArg);
    }

    /*
     * Setup the NT CreateProcess parameters
     */
    memset( &StartInfo, 0, sizeof(StartInfo) );
    StartInfo.cb = sizeof(STARTUPINFO);
    StartInfo.lpReserved = NULL;
    StartInfo.lpTitle = NULL; // Use the program name
    StartInfo.dwFlags = 0;  // no extra flags
    StartInfo.cbReserved2 = 0;
    StartInfo.lpReserved2 = NULL;

    /*
     * Confusing NT DOC: If program name is set, it does not do a search using
     * PATH.  If program is NULL, then program is specified from args, and will
     * search using the PATH. Some programs may be using the argv[0] trick. If
     * they do, then we have to put back in the OS/2 method of defining search
     * directories rooted on GetSystemDirectory() since NT can boot from
     * multiple locations on a disk.
     */
    flag = CreateProcess(NULL, // program, // Program name
		   args, // program name and arguments
		   NULL, // lpsaProcess
		   NULL, // lpsaThread
		   TRUE, // Allow handles to be inherited
		   0,    // No additional creation flags
		   NULL, // inherit parent environment block
		   NULL, // inherit parent directory
		   &StartInfo,
		   &ProcInfo);

    if ( !flag ) {

        Status = GetLastError();
        if(Status == ERROR_FILE_NOT_FOUND) {

            fwprintf(stderr, L"Terminal Server System Utility %s Not Found\n", program);
	    return(1);

        } else if ( Status == ERROR_INVALID_NAME ) {

	    fwprintf(stderr, L"Bad Internal Program Name :%s:, args :%s:\n", program, args);
            return(1);
        }
        fwprintf(stderr, L"CreateProcess Failed, Status %u\n", Status);
        return(1);
    }

    /*
     * Wait for the process to terminate
     */
    Status =  WaitForSingleObject(ProcInfo.hProcess, INFINITE);
    if ( Status == WAIT_FAILED ) {

        Status = GetLastError();
        fwprintf(stderr, L"WaitForSingle Object Failed, Status %u\n", Status);
        return(1);
    }

    /*
     * Close the process and thread handles
     */
    CloseHandle(ProcInfo.hThread);
    CloseHandle(ProcInfo.hProcess);
    return(0);

} /* ExecProgram() */


/*****************************************************************************
*
*  ProgramUsage
*     Output a standard 'usage' message for the given program.
*
*  ENTRY:
*       pProgramName (input)
*           Points to string of program's name.
*       pProgramCommands (input)
*           Points to an array of PROGRAMCALL structures defining the
*           valid commands for the program.  The last element in the array
*           will contain all 0 or NULL items.
*       fError (input)
*           If TRUE, will output message with fwprintf to stderr; otherwise,
*           will output message to stdout via wprintf.
*
*  EXIT:
*
*   Only commands not flagged as 'alias' commands will be output in the
*   usage message.
*
*****************************************************************************/

VOID WINAPI
ProgramUsage( LPCWSTR pProgramName,
              PPROGRAMCALL pProgramCommands,
              BOOLEAN fError )
{
    WCHAR szUsage[83];    // 80 characters per line + newline chars & null
    PPROGRAMCALL pProg;
    BOOL bFirst;
    int i, namelen = wcslen(pProgramName);

    i = wsprintf(szUsage, L"%s {", pProgramName);
    for ( pProg = pProgramCommands->pFirst, bFirst = TRUE;
          pProg != NULL;
          pProg = pProg->pNext ) {

        if ( !pProg->fAlias ) {

            if ( (i + wcslen(pProg->Command) + (bFirst ? 1 : 3)) >= 80 ) {

                wcscat(szUsage, L"\n");

                if ( fError )
                    fwprintf(stderr, szUsage);
                else
                    wprintf(szUsage);

                bFirst = TRUE;
                for ( i=0; i < namelen; i++)
                    szUsage[i] = L' ';
            }

            i += wsprintf( &(szUsage[i]),
                           bFirst ? L" %s" : L" | %s",
                           pProg->Command );
            bFirst = FALSE;
        }
    }

    wcscat(szUsage, L" }\n");

    if ( fError )
        fwprintf(stderr, szUsage);
    else
        wprintf(szUsage);
}


/*******************************************************************************
 *
 *  Message
 *      Display a message to stdout with variable arguments.  Message
 *      format string comes from the application resources.
 *
 *  ENTRY:
 *      nResourceID (input)
 *          Resource ID of the format string to use in the message.
 *      ... (input)
 *          Optional additional arguments to be used with format string.
 *
 *  EXIT:
 *
 ******************************************************************************/

VOID WINAPI
Message( int nResourceID, ...)
{
    WCHAR sz1[256], sz2[512];

    va_list args;
    va_start( args, nResourceID );

    if ( LoadString( NULL, nResourceID, sz1, 256 ) ) {

        vswprintf( sz2, sz1, args );
        wprintf( sz2 );

    } else {

        fwprintf( stderr, L"{Message(): LoadString failed, Error %ld, (0x%08X)}\n",
                  GetLastError(), GetLastError() );
    }

    va_end(args);

}  /* Message() */


/*******************************************************************************
 *
 *  ErrorPrintf
 *      Output an error message to stderr with variable arguments.  Message
 *      format string comes from the application resources.
 *
 *  ENTRY:
 *      nErrorResourceID (input)
 *          Resource ID of the format string to use in the error message.
 *      ... (input)
 *          Optional additional arguments to be used with format string.
 *
 *  EXIT:
 *
 ******************************************************************************/

VOID WINAPI
ErrorPrintf( int nErrorResourceID, ...)
{
    WCHAR sz1[256], sz2[512];

    va_list args;
    va_start( args, nErrorResourceID );

    if ( LoadString( NULL, nErrorResourceID, sz1, 256 ) ) {

        vswprintf( sz2, sz1, args );
        fwprintf( stderr, sz2 );

    } else {

        fwprintf( stderr, L"{ErrorPrintf(): LoadString failed, Error %ld, (0x%08X)}\n",
                  GetLastError(), GetLastError() );
        PutStdErr( GetLastError(), 0 );
    }

    va_end(args);

}  /* ErrorPrintf() */


/*******************************************************************************
 *
 *  TruncateString
 *
 *  This routine truncates given string with elipsis '...' suffix, if needed.
 *
 *
 *  ENTRY:
 *     pString (input/output)
 *        pointer to string to truncate
 *     MaxLength (input)
 *        maximum length of string
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID WINAPI
TruncateString( PWCHAR pString, int MaxLength )
{
    /*
     *  if string is too long, trucate it
     */
    if ( (int)wcslen(pString) > MaxLength && MaxLength > 2 ) {
        wcscpy( pString + MaxLength - 3, L"..." );
    }

}  /* TruncateString() */


/*******************************************************************************
 *
 *  EnumerateDevices
 *
 *  Perform PD device enumeration for the specified PD DLL.
 *
 *  ENTRY:
 *      pDllName (input)
 *          Pointer to DLLNAME string specifying the PD DLL to enumerate.
 *      pEntries (output)
 *          Points to variable to return number of devices that were enumerated.
 *
 *  EXIT:
 *      (PPDPARAMS) Points to a malloc()'ed PDPARAMS array containing the
 *                  enumeration results if sucessful.  The caller must perform
 *                  free of this array when done.  NULL if error.
 *
 ******************************************************************************/

/*
 * Typedefs for PdEnumerate function (from ...WINDOWS\INC\CITRIX\PDAPI.H)
 */
typedef NTSTATUS (APIENTRY * PPDENUMERATE)(PULONG, PPDPARAMS, PULONG);
#define INITIAL_ENUMERATION_COUNT   30

PPDPARAMS WINAPI
EnumerateDevices( PDLLNAME pDllName,
                  PULONG pEntries )
{
    PPDENUMERATE pPdEnumerate;
    HANDLE Handle;
    ULONG ByteCount;
    NTSTATUS Status;
    int i;
    PPDPARAMSW pPdParams = NULL;

    /*
     *  Load the specified PD DLL.
     */
    if ( (Handle = LoadLibrary(pDllName)) == NULL ) {
        fwprintf(
            stderr,
            L"Device enumeration failure:\n\tCan't load the %s DLL for device enumeration\n",
            pDllName );
        goto CantLoad;
    }

    /*
     *  Get the PD enumeration function's load entry pointer.
     */
    if ( (pPdEnumerate =
          (PPDENUMERATE)GetProcAddress((HMODULE)Handle, "PdEnumerate"))
            == NULL ) {

        fwprintf(
            stderr,
            L"Device enumeration failure:\n\tDLL %s has no enumeration entry point\n",
            pDllName );
        goto EnumerateMissing;
    }

    /*
     * Call enumerate in loop till we hit enough buffer entries to handle
     * a complete enumeration.
     */
    for ( i = INITIAL_ENUMERATION_COUNT; ; i *= 2 ) {


        if ( pPdParams == NULL ) {
            pPdParams =
                (PPDPARAMS)malloc(ByteCount = (sizeof(PDPARAMS) * i));
        } else {
            free(pPdParams);
            pPdParams =
                (PPDPARAMS)malloc(ByteCount = (sizeof(PDPARAMS) * i));
        }

        if ( pPdParams == NULL ) {
            fwprintf(stderr, L"Error allocating memory\n");
            goto OutOfMemory;
        }

        /*
         * Perform enumeration and break loop if successful.
         */
        if ( (Status = (*pPdEnumerate)(pEntries, pPdParams, &ByteCount))
                == STATUS_SUCCESS )
            break;

        /*
         * If we received any other error other than 'buffer too small',
         * complain and quit.
         */
        if ( Status != STATUS_BUFFER_TOO_SMALL ) {
            fwprintf(
                stderr,
                L"Device enumeration failure\n\tDLL %s, Error 0x%08lX\n",
                pDllName, Status );
            goto BadEnumerate;
        }
    }

    /*
     * Close the DLL handle and return the PDPARAMS pointer.
     */
    CloseHandle(Handle);
    return(pPdParams);

/*-------------------------------------
 * Error cleanup and return
 */
BadEnumerate:
    free(pPdParams);
OutOfMemory:
EnumerateMissing:
    CloseHandle( Handle );
CantLoad:
    return(NULL);

}  /* EnumerateDevices() */


/******************************************************************************
 *
 *  wfopen
 *
 *  UNICODE version of fopen
 *
 *  ENTRY:
 *    filename (input)
 *       UNICODE filename to open.
 *    mode (input)
 *       UNICODE file open mode string.
 *
 *  EXIT:
 *      Pointer to FILE or NULL if open error.
 *
 *****************************************************************************/

FILE * WINAPI
wfopen( LPCWSTR filename, LPCWSTR mode )
{
    PCHAR FileBuf, ModeBuf;
    FILE *pFile;

    if ( !(FileBuf = (PCHAR)malloc((wcslen(filename)+1) * sizeof(CHAR))) )
        goto BadFileBufAlloc;

    if ( !(ModeBuf = (PCHAR)malloc((wcslen(mode)+1) * sizeof(CHAR))) )
        goto BadModeBufAlloc;

    /*
     * Convert UNICODE strings to ANSI and call ANSI fopen.
     */
    wcstombs(FileBuf, filename, wcslen(filename)+1);
    wcstombs(ModeBuf, mode, wcslen(mode)+1);
    pFile = fopen(FileBuf, ModeBuf);

    /*
     * Clean up and return
     */
    free(FileBuf);
    free(ModeBuf);
    return(pFile);

/*-------------------------------------
 * Error cleanup and return
 */
BadModeBufAlloc:
    free(FileBuf);
BadFileBufAlloc:
    return(NULL);

}  /* wfopen() */


/******************************************************************************
 *
 *  wfgets
 *
 *  UNICODE version of fgets
 *
 *  ENTRY:
 *    Buffer (output)
 *       Buffer to place string retreived from stream
 *    Len (input)
 *       Maximum number of WCHARs in buffer.
 *    Stream (input)
 *       STDIO file stream for input
 *
 *  EXIT:
 *      Pointer to Buffer or NULL.
 *
 *****************************************************************************/

PWCHAR WINAPI
wfgets( PWCHAR Buffer, int Len, FILE *Stream )
{
    PCHAR AnsiBuf, pRet;
    int count;

    if ( !(AnsiBuf = (PCHAR)malloc(Len * sizeof(CHAR))) )
        goto BadAnsiBufAlloc;

    /*
     * Get the ANSI version of the string from the stream
     */
    if ( !(pRet = fgets(AnsiBuf, Len, Stream)) )
        goto NullFgets;

    /*
     * Convert to UNICODE string in user's buffer.
     */
    count = mbstowcs(Buffer, AnsiBuf, strlen(AnsiBuf)+1);

    /*
     * Clean up and return
     */
    free(AnsiBuf);
    return(Buffer);

/*-------------------------------------
 * Error cleanup and return
 */
NullFgets:
    free(AnsiBuf);
BadAnsiBufAlloc:
    return(NULL);

}  /* wfgets() */




/***	PutStdErr - Print a message to STDERR
 *
 *  Purpose:
 *	Calls PutMsg sending STDERR as the handle to which the message
 *	will be written.
 *
 *  int PutStdErr(unsigned MsgNum, unsigned NumOfArgs, ...)
 *
 *  Args:
 *	MsgNum		- the number of the message to print
 *	NumOfArgs	- the number of total arguments
 *	...             - the additonal arguments for the message
 *
 *  Returns:
 *	Return value from PutMsg()			M026
 *
 */

int WINAPI
PutStdErr(unsigned int MsgNum, unsigned int NumOfArgs, ...)
{
        int Result;

        va_list arglist;

	va_start(arglist, NumOfArgs);
        Result = PutMsg(MsgNum, NumOfArgs, &arglist);
        va_end(arglist);
        return Result;
}


int
FindMsg(unsigned MsgNum, PTCHAR NullArg, unsigned NumOfArgs, va_list *arglist)
{
    unsigned msglen;
    DWORD msgsource;
    TCHAR *Inserts[ 2 ];
    CHAR numbuf[ 32 ];
    TCHAR   wnumbuf[ 32 ];

    //
    // find message without doing argument substitution
    //

    if (MsgNum == ERROR_MR_MID_NOT_FOUND) {
        msglen = 0;
    }
    else {
#ifdef LATER
        msgsource = MsgNum >= IDS_ERROR_MALLOC ?
                       FORMAT_MESSAGE_FROM_HMODULE :
                       FORMAT_MESSAGE_FROM_SYSTEM;
#endif
        msgsource = FORMAT_MESSAGE_FROM_SYSTEM;
    	msglen = FormatMessage(msgsource | FORMAT_MESSAGE_IGNORE_INSERTS,
			       NULL,
			       MsgNum,
			       0,
			       MsgBuf,
			       MAXCBMSGBUFFER,
			       NULL
			     );
        if (msglen == 0) {
            if (NtDllHandle == NULL) {
                NtDllHandle = GetModuleHandle( TEXT("NTDLL") );
            }
            msgsource = FORMAT_MESSAGE_FROM_HMODULE;
            msglen = FormatMessage(msgsource | FORMAT_MESSAGE_IGNORE_INSERTS,
				   (LPVOID)NtDllHandle,
				   MsgNum,
				   0,
				   MsgBuf,
				   MAXCBMSGBUFFER,
				   NULL
				 );
        }
    }

    if (msglen == 0) {
        //
        // didn't find message
        //
        msgsource = FORMAT_MESSAGE_FROM_SYSTEM |
                    FORMAT_MESSAGE_ARGUMENT_ARRAY;
        _ultoa( MsgNum, numbuf, 16 );
	MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, numbuf, -1, wnumbuf, 32);
        Inserts[ 0 ]= wnumbuf;
#ifdef LATER
        Inserts[ 1 ]= (MsgNum >= IDS_ERROR_MALLOC ? TEXT("Application") : TEXT("System"));
#endif
        Inserts[ 1 ]= TEXT("System");
        MsgNum = ERROR_MR_MID_NOT_FOUND;
	msglen = FormatMessage(msgsource,
			       NULL,
			       MsgNum,
			       0,
			       MsgBuf,
			       MAXCBMSGBUFFER,
			       (va_list *)Inserts
			     );
    }
    else {

        // see how many arguments are expected and make sure we have enough

        PTCHAR tmp;
        ULONG count;

        tmp=MsgBuf;
        count = 0;
        while (tmp = mystrchr(tmp, PERCENT)) {
            tmp++;
            if (*tmp >= TEXT('1') && *tmp <= TEXT('9')) {
                count += 1;
            }
	    else if (*tmp == PERCENT) {
                tmp++;
            }
        }
        if (count > NumOfArgs) {
            PTCHAR *LocalArgList;
            ULONG i;

            LocalArgList = (PTCHAR*)malloc(sizeof(PTCHAR) * count);
            for (i=0; i<count; i++) {
                if (i < NumOfArgs) {
                    LocalArgList[i] = (PTCHAR)va_arg( *arglist, ULONG );
                    }
                else {
                    LocalArgList[i] = NullArg;
                    }
                }
            msglen = FormatMessage(msgsource | FORMAT_MESSAGE_ARGUMENT_ARRAY,
				   NULL,
				   MsgNum,
				   0,
				   MsgBuf,
				   MAXCBMSGBUFFER,
				   (va_list *)LocalArgList
				 );
            free(LocalArgList);
        }
	else {
            msglen = FormatMessage(msgsource,
				   NULL,
				   MsgNum,
				   0,
				   MsgBuf,
				   MAXCBMSGBUFFER,
				   arglist
				 );
        }
    }
    return msglen;
}

/***	PutMsg - Print a message to a handle
 *
 *   Purpose:
 *	PutMsg is the work routine which interfaces command.com with the
 *	DOS message retriever.	This routine is called by PutStdOut and
 *	PutStdErr.
 *
 *  int PutMsg(unsigned MsgNum, unsigned Handle, unsigned NumOfArgs, ...)
 *
 *  Args:
 *	MsgNum		- the number of the message to print
 *	NumOfArgs	- the number of total arguments
 *	Handle		- the handle to print to
 *	Arg1 [Arg2...]	- the additonal arguments for the message
 *
 *  Returns:
 *	Return value from DOSPUTMESSAGE 		M026
 *
 *  Notes:
 *    - PutMsg builds an argument table which is passed to DOSGETMESSAGE;
 *	this table contains the variable information which the DOS routine
 *	inserts into the message.
 *    - If more than one Arg is sent into PutMsg, it (or they)	are taken
 *	from the stack in the first for loop.
 *    - M020 MsgBuf is a static array of 2K length.  It is temporary and
 *	will be replaced by a more efficient method when decided upon.
 *
 */

int
PutMsg(unsigned int MsgNum, unsigned int NumOfArgs, va_list *arglist)
{
	unsigned msglen;
    PTCHAR   NullArg = TEXT(" ");

    msglen = FindMsg(MsgNum,NullArg,NumOfArgs,arglist);

    fwprintf( stderr, L"Error [%u]: ", MsgNum );
    fwprintf( stderr, MsgBuf );

    return NO_ERROR;
}


 /***
 * mystrchr(string, c) - search a string for a character
 *
 * mystrchr will search through string and return a pointer to the first
 * occurance of the character c. This version of mystrchr knows about
 * double byte characters. Note that c must be a single byte character.
 *
 */

TCHAR *
mystrchr(TCHAR const *string, int c)
{

	/* handle null seperatly to make main loop easier to code */
	if (string == NULL)
	    return(NULL);

	if (c == NULLC)
        return((TCHAR *)(string + wcslen(string)));

    return wcschr( string, (TCHAR)c );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpperf\utilsub\setargv.h ===
/*******************************************************************************
* SETARGV.h (ANSI argc, argv routines)
*
*   argc / argv routines
*
* Copyright Citrix Systems Inc. 1995
* Copyright (C) 1997-1999 Microsoft Corp.
*
*   $Author:   butchd  $
******************************************************************************/

/*
 * Argument structure
 *    Caller should initialize using args_init().  Use args_reset() to
 *    reset values, args_free() to free memory allocated by args_init().
 */
struct arg_data {
   int argc;
   char **argv;
   int argvlen;
   char **argvp;
   int buflen;
   char *buf;
   char *bufptr;
   char *bufend;
};
typedef struct arg_data ARGS;

/*
 * minimum size for argv/string buffer allocation
 */
#define MIN_ARG_ALLOC 128
#define MIN_BUF_ALLOC 1024
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpperf\utilsub\parse.c ===
/*****************************************************************************
* PARSE.C
*
*      This module contains the code to implement generic parsing routines
*      for utilities.  There are several parsing routines included here.
*
*      External Entry Points:  (defined in utilsub.h)
*
*         ParseCommandLineW()
*         IsTokenPresentW()
*         SetTokenPresentW()
*         SetTokenNotPresentW()
*
* Copyright Citrix Systems Inc. 1990-1995
* Copyright (C) 1997-1999 Microsoft Corp.
*
*   $Author:   miked  $ Kurt Perry
****************************************************************************/

/* Get the standard C includes */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

#include <winstaw.h>
#include <utilsub.h>
#include <expand.h>


#define READ_ONLY 0x0001   /* file is read only */
#define HIDDEN    0x0002   /* file is hidden */
#define SYSTEM    0x0004   /* file is a system file */
#define VOLUME    0x0008   /* file is a volume label */
#define SUBDIR    0x0010   /* file is a subdirectory */
#define ARCHIVE   0x0020   /* file has archive bit on */


/*=============================================================================
 ==   Local Functions Defined
 ============================================================================*/
static USHORT StoreArgument(PTOKMAPW, WCHAR *);

/*=============================================================================
 ==   External Functions Used
 ============================================================================*/

/*=============================================================================
 ==   Local Variables Used
 ============================================================================*/
ARGS  arg_data;

/*=============================================================================
 ==   Global Variables Used
 ============================================================================*/

/*****************************************************************************
*
*   ParseCommandLineW (UNICODE version)
*
*      This is the main function of the ParseCommandLine function. If the
*      caller is passing argv from the main() function the caller is
*      is responsible for pointing to argv[1], unless he wants this function
*      to parse the program name (argv[0]).
*
*      If the user wishes to parse an admin file it is necessary to massage
*      the data into a form compatible with the command line arguements
*      passed to a main() function before calling ParseCommandLine().
*
*   ENTRY:
*      argc - count of the command line arguments.
*      argv - vector of strings containing the
*      ptm  - pointer to begining of the token map array
*      flag - USHORT set of flags (see utilsub.h for flag descriptions).
*
*   EXIT:
*      Normal:                           ********** NOTE***********
*         PARSE_FLAG_NO_ERROR            * All errors returned    *
*                                        * from this function are *
*      Error:                            * BIT flags and must be  *
*         PARSE_FLAG_NO_PARMS            * converted by caller to *
*         PARSE_FLAG_INVALID_PARM        * OS/2+ ERRORS!!!!       *
*         PARSE_FLAG_TOO_MANY_PARMS      ********** NOTE***********
*         PARSE_FLAG_MISSING_REQ_FIELD
*   ALGORITHM:
*
****************************************************************************/

USHORT WINAPI
ParseCommandLineW( INT argc,
                   WCHAR **argv,
                   PTOKMAPW ptm,
                   USHORT flag )
{
   BOOL     *pBool, everyonespos = FALSE;
   WCHAR     *pChar;
   USHORT    rc, argi, found;
   USHORT    tokenlen, arglen;
   PTOKMAPW   ptmtmp, nextpositional;
   PFILELIST pFileList;

   rc = PARSE_FLAG_NO_ERROR;

   /*--------------------------------------------------------------------------
   -- If there are no parameters inform the caller of this fact.
   --------------------------------------------------------------------------*/
   if(argc == 0) {
      rc |= PARSE_FLAG_NO_PARMS;
      return(rc);
   }

   /*--------------------------------------------------------------------------
   -- Find the first positional parameter in the token map array, if any.
   -- Also set the valid memory locations to '\0'.
   --------------------------------------------------------------------------*/
   nextpositional = NULL;
   for(ptmtmp=ptm; ptmtmp->tmToken != NULL; ptmtmp++) {
      if(ptmtmp->tmDLen && !(flag & PCL_FLAG_NO_CLEAR_MEMORY)) {
         pChar = (WCHAR *) ptmtmp->tmAddr;
         /*
          * Clear the 'string' form fields for tmDLen*sizeof(WCHAR) bytes;
          * all other forms to tmDLen bytes.
          */
         if ( (ptmtmp->tmForm == TMFORM_S_STRING) ||
              (ptmtmp->tmForm == TMFORM_DATE) ||
              (ptmtmp->tmForm == TMFORM_PHONE) ||
              (ptmtmp->tmForm == TMFORM_STRING) ||
              (ptmtmp->tmForm == TMFORM_X_STRING) )
            memset(pChar, L'\0', (ptmtmp->tmDLen*sizeof(WCHAR)));
        else
            memset(pChar, L'\0', ptmtmp->tmDLen);
      }
      if(ptmtmp->tmToken[0] != L'/' && ptmtmp->tmToken[0] != L'-' && nextpositional == NULL) {
         nextpositional = ptmtmp;
      }
   }

   /*--------------------------------------------------------------------------
   -- Scan the argument array looking for /x or -x switches or positional
   -- parameters.  If a switch is found look it up in the token map array
   -- and if found see if it has a trailing parameter of the format:
   --              -x:foo || /x:foo || -x foo || /x foo
   -- when found set the found flag and if there is a trailing parameter
   -- store it at the location the user requested.
   --
   -- If it is not found in the token map array return the proper error
   -- unless the user requests us to ignore it (PCL_FLAG_IGNORE_INVALID).
   --
   -- If it is a positional parameter enter it into the token map array if
   -- there is room for it (i.e. nextpositional != NULL), if there is no
   -- room for it then return the proper error.
   --------------------------------------------------------------------------*/
   for(argi=0; argi<argc;) {
      if(everyonespos) {
         if( (wcslen(nextpositional->tmAddr) + wcslen(argv[argi]) + 1) > nextpositional->tmDLen) {
            rc |= PARSE_FLAG_TOO_MANY_PARMS;
            return(rc);
         }
         wcscat((WCHAR *) nextpositional->tmAddr, L" ");
         wcscat((WCHAR *) nextpositional->tmAddr, argv[argi]);
         argi++;
      }
      else if(argv[argi][0] == L'/' ||     /* argument is a switch (/x or -x) */
         argv[argi][0] == L'-') {
         found = FALSE;
         for(ptmtmp=ptm; ptmtmp->tmToken != NULL; ptmtmp++) {
            /*-----------------------------------------------------------------
             --   The string is found if a few requirements are met:
             --   1) The first N-1 characters are the same, where N is
             --      the length of the string in the token map array.
             --      We ignore the first character (could be '-' or '/').
             --   2) If the strings are not the same length, then the only
             --      valid character after /x can be ':', this is only  true
             --      if the switch has a trailing parameter.
             ----------------------------------------------------------------*/
            tokenlen = (USHORT)wcslen(ptmtmp->tmToken);    /* get token length       */
            arglen   = (USHORT)wcslen(argv[argi]);         /* get argument length    */
            if(!(_wcsnicmp(&(ptmtmp->tmToken[1]), &(argv[argi][1]), tokenlen-1))) {
               if(tokenlen != arglen) {            /* not same length        */
                  if(ptmtmp->tmForm != TMFORM_VOID && /* if trailing parm is    */
                     argv[argi][tokenlen] == L':') {/* delemited with a ':'   */
                     if(ptmtmp->tmFlag & TMFLAG_PRESENT) { /* seen already  */
                        rc |= PARSE_FLAG_DUPLICATE_FIELD;
                     }
                     found = TRUE;                 /* then report it found.  */
                     break;
                  }
               }
               else {                              /* all character same and */
                  if(ptmtmp->tmFlag & TMFLAG_PRESENT) { /* seen already  */
                     rc |= PARSE_FLAG_DUPLICATE_FIELD;
                  }
                  found = TRUE;                    /* strings are the same   */
                  break;                           /* len report it found.   */
               }
            }
         }
         /* switch not found in token map array and not requested to ignore */
         if(found != TRUE && !(flag & PCL_FLAG_IGNORE_INVALID)) {
            rc |= PARSE_FLAG_INVALID_PARM;
            if(!(flag & PCL_FLAG_CONTINUE_ON_ERROR)) {
               return(rc);
            }
            ++argi;
         }
         else if (!found) {
            ++argi;
         }
         else {               /* switch was found in token map array */
            if(ptmtmp->tmForm == TMFORM_VOID) { /* no trailing parameter, done */
               ptmtmp->tmFlag |= TMFLAG_PRESENT;
               ++argi;
            }
            else if(ptmtmp->tmForm == TMFORM_BOOLEAN) {  /* need confirmation */
               ptmtmp->tmFlag |= TMFLAG_PRESENT;
               pBool = (BOOL *) ptmtmp->tmAddr;
              *pBool = TRUE;
               ++argi;
            }
            else {         /* has a trailing parameter */
               if(argv[argi][tokenlen] == L':') { /* all in one switch (i.e. /x:foo) */
                  if(StoreArgument(ptmtmp, &(argv[argi][tokenlen+1]))) {
                     ptmtmp->tmFlag |= TMFLAG_PRESENT;
                     if(flag & PCL_FLAG_RET_ON_FIRST_SUCCESS) {
                        return(rc);
                     }
                  }
                  else {
                     rc |= PARSE_FLAG_INVALID_PARM;
                     if(!(flag & PCL_FLAG_CONTINUE_ON_ERROR)) {
                        return(rc);
                     }
                  }
                  ++argi;                 /* bump up to next argument */
               }
               else {   /* two argument switch (i.e. /x foo) */
                  if ((++argi >= argc) ||
                      (argv[argi][0] == L'/') ||
                      (argv[argi][0] == L'-')) { /* bump up to trailing parm */
                     switch ( ptmtmp->tmForm ) {
                     case TMFORM_S_STRING:
                     case TMFORM_STRING:
                        ptmtmp->tmFlag |= TMFLAG_PRESENT;
                        pChar    = (WCHAR *) ptmtmp->tmAddr;
                        pChar[0] = (WCHAR)NULL;
                        break;
                     default:
                        rc |= PARSE_FLAG_INVALID_PARM;
                        if(!(flag & PCL_FLAG_CONTINUE_ON_ERROR)) {
                           return(rc);
                        }
                        break;
                     }
                  }
                  else if(StoreArgument(ptmtmp, argv[argi])) {
                     ptmtmp->tmFlag |= TMFLAG_PRESENT;
                     if(flag & PCL_FLAG_RET_ON_FIRST_SUCCESS) {
                        return(rc);
                     }
                     ++argi;           /* bump up to next argument         */
                  }
                  else {
                     rc |= PARSE_FLAG_INVALID_PARM;
                     if(!(flag & PCL_FLAG_CONTINUE_ON_ERROR)) {
                        return(rc);
                     }
                     ++argi;           /* bump up to next argument         */
                  }
               }
            }
         }
      }                                /* endif - is switch                */
      else {                           /* argument is a positional parmater*/
         if(nextpositional == NULL) {  /* if there are no positional left  */
            rc |= PARSE_FLAG_TOO_MANY_PARMS;
            if(!(flag & PCL_FLAG_CONTINUE_ON_ERROR)) {
               return(rc);
            }
         }
         else {                        /* set positional in token array **/
            /*
            *  Is the current PTM the start of TMFORM_FILES?
            */
            if (nextpositional->tmForm == TMFORM_FILES) {
               nextpositional->tmFlag |= TMFLAG_PRESENT;
               args_init(&arg_data, MAX_ARG_ALLOC);
               do {
                  /*
                  *  If no match was found then return the current id.
                  */
//                if (!expand_path(argv[argi], (HIDDEN|SYSTEM), &arg_data)) {
//                   arg_data.argc--;
//                   arg_data.argvp--;
//                }
                  expand_path(argv[argi], (HIDDEN|SYSTEM), &arg_data);
               } while (++argi<argc);
               pFileList = (PFILELIST) nextpositional->tmAddr;
               pFileList->argc = arg_data.argc;
               pFileList->argv = &arg_data.argv[0];
               return (rc);
            }
            else if(StoreArgument(nextpositional, argv[argi])) {
               nextpositional->tmFlag |= TMFLAG_PRESENT;
               if(flag & PCL_FLAG_RET_ON_FIRST_SUCCESS) {
                  return(rc);
               }
               /*--------------------------------------------------------------
               -- if this is an X_STRING then every thing from now on is
               -- going to be a concatenated string
               --------------------------------------------------------------*/
               if(nextpositional->tmForm == TMFORM_X_STRING) {
                  everyonespos = TRUE;
               }
               else {
                  for(++nextpositional; nextpositional->tmToken!=NULL; nextpositional++) {
                     if(nextpositional->tmToken[0] != L'/' && nextpositional->tmToken[0] != L'-') {
                        break;
                     }
                  }
                  if(nextpositional->tmToken == NULL) {  /* ran out of PP */
                     nextpositional = NULL;
                  }
               }
            }
            else {                                    /* invalid PP */
               rc |= PARSE_FLAG_INVALID_PARM;
               if(!(flag & PCL_FLAG_CONTINUE_ON_ERROR)) {
                  return(rc);
               }
            }
         }
         argi++;
      }
   }

   for(ptmtmp=ptm; ptmtmp->tmToken!=NULL; ptmtmp++) {
      if(ptmtmp->tmFlag & TMFLAG_REQUIRED && !(ptmtmp->tmFlag & TMFLAG_PRESENT)) {
         rc |= PARSE_FLAG_MISSING_REQ_FIELD;
         break;
      }
   }

   return(rc);

}  // end ParseCommandLineW


/*****************************************************************************
*
*   IsTokenPresentW (UNICODE version)
*
*       Determines if a specified command line token (in given TOKMAPW array)
*       was present on the command line.
*
*   ENTRY:
*       ptm (input)
*           Points to 0-terminated TOKMAPW array to scan.
*       pToken (input)
*           The token to scan for.
*
*   EXIT:
*       TRUE if the specified token was present on the command line;
*       FALSE otherwise.
*
****************************************************************************/

BOOLEAN WINAPI
IsTokenPresentW( PTOKMAPW ptm,
                 PWCHAR pToken )
{
    int i;

    for ( i = 0; ptm[i].tmToken; i++ ) {
        if ( !wcscmp( ptm[i].tmToken, pToken ) )
            return( (ptm[i].tmFlag & TMFLAG_PRESENT) ? TRUE : FALSE );
    }

    return(FALSE);

}  // end IsTokenPresentW


/*****************************************************************************
*
*   SetTokenPresentW (UNICODE version)
*
*       Forces a specified command line token (in given TOKMAPW array)
*       to be flagged as 'present' on the command line.
*
*   ENTRY:
*       ptm (input)
*           Points to 0-terminated TOKMAPW array to scan.
*       pToken (input)
*           The token to scan for and set flags.
*
*   EXIT:
*       TRUE if the specified token was found in the TOKMAPW array
*       (TMFLAG_PRESENT flag is set).  FALSE otherwise.
*
****************************************************************************/

BOOLEAN WINAPI
SetTokenPresentW( PTOKMAPW ptm,
                  PWCHAR pToken )
{
    int i;

    for ( i = 0; ptm[i].tmToken; i++ ) {
        if ( !wcscmp( ptm[i].tmToken, pToken ) ) {
            ptm[i].tmFlag |= TMFLAG_PRESENT;
            return(TRUE);
        }
    }

    return(FALSE);

}  // end SetTokenPresentW


/*****************************************************************************
*
*   SetTokenNotPresentW (UNICODE version)
*
*       Forces a specified command line token (in given TOKMAPW array)
*       to be flagged as 'not present' on the command line.
*
*   ENTRY:
*       ptm (input)
*           Points to 0-terminated TOKMAPW array to scan.
*       pToken (input)
*           The token to scan for and set flags.
*
*   EXIT:
*       TRUE if the specified token was found in the TOKMAPW array
*       (TMFLAG_PRESENT flag is reset).  FALSE otherwise.
*
****************************************************************************/

BOOLEAN WINAPI
SetTokenNotPresentW( PTOKMAPW ptm,
                     PWCHAR pToken )
{
    int i;

    for ( i = 0; ptm[i].tmToken; i++ ) {
        if ( !wcscmp( ptm[i].tmToken, pToken ) ) {
            ptm[i].tmFlag &= ~TMFLAG_PRESENT;
            return(TRUE);
        }
    }

    return(FALSE);

}  // end SetTokenNotPresentW


/*****************************************************************************
*
*   StoreArgument:
*
*   ENTRY:
*      ptm - a pointer to an entry in the token array map
*      s   - the argument to be entered into the current token array map entry.
*
*   EXIT:
*      Normal:
*         TRUE
*
*      Error:
*         FALSE
*
*   ALGORITHM:
*
****************************************************************************/

USHORT
StoreArgument( PTOKMAPW ptm,
               WCHAR *s )
{
   char *pByte;
   WCHAR *pChar;
   BOOL *pBool;
   SHORT *pShort;
   USHORT *pUShort;
   LONG *pLong;
   ULONG *pULong;

   /*
    * If the string is empty, allow it for real 'strings'!
    */
   if( !wcslen(s) ) {
      switch ( ptm->tmForm ) {
      case TMFORM_S_STRING:
      case TMFORM_STRING:
         pChar    = (WCHAR *) ptm->tmAddr;
         pChar[0] = (WCHAR)NULL;
         return( TRUE );
      }
      return( FALSE );
   }

   /*
    * Fail if there is no room to store result.
    */
   if ( ptm->tmDLen == 0) {
      return(FALSE);
   }

   switch(ptm->tmForm) {
      case TMFORM_BOOLEAN:
         pBool = (BOOL *) ptm->tmAddr;
        *pBool = TRUE;
         break;
      case TMFORM_BYTE:
         pByte = (BYTE *) ptm->tmAddr;
        *pByte = (BYTE) wcstol(s, NULL, 10);
         break;
      case TMFORM_CHAR:
         pChar = (WCHAR *) ptm->tmAddr;
        *pChar = s[0];
         break;
      case TMFORM_S_STRING:
         if (*s == L'\\') {
            ++s;
         }
      case TMFORM_DATE:
      case TMFORM_PHONE:
      case TMFORM_STRING:
      case TMFORM_X_STRING:
         pChar = (WCHAR *) ptm->tmAddr;
         wcsncpy(pChar, s, ptm->tmDLen);
         break;
      case TMFORM_SHORT:
         pShort = (SHORT *) ptm->tmAddr;
        *pShort = (SHORT) wcstol(s, NULL, 10);
         break;
      case TMFORM_USHORT:
         if ( s[0] == L'-') {        /* no negative numbers! */
            return( FALSE );
         }
         pUShort = (USHORT *) ptm->tmAddr;
        *pUShort = (USHORT) wcstol(s, NULL, 10);
         break;
      case TMFORM_LONG:
         pLong = (LONG *) ptm->tmAddr;
        *pLong = wcstol(s, NULL, 10);
         break;
      case TMFORM_SERIAL:
      case TMFORM_ULONG:
         if ( s[0] == L'-') {        /* no negative numbers! */
            return( FALSE );
         }
         pULong = (ULONG *) ptm->tmAddr;
        *pULong = (ULONG) wcstol(s, NULL, 10);
         break;
      case TMFORM_HEX:
         if ( s[0] == L'-') {        /* no negative numbers! */
            return( FALSE );
         }
         pUShort = (USHORT *) ptm->tmAddr;
        *pUShort = (USHORT) wcstoul(s,NULL,16);
	 break;
      case TMFORM_LONGHEX:
         if ( s[0] == L'-') {        /* no negative numbers! */
            return( FALSE );
         }
         pULong = (ULONG *) ptm->tmAddr;
        *pULong = wcstoul(s,NULL,16);
         break;
      default:                         /* if invalid format return FALSE */
         return(FALSE);
         break;
   }

   return(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpperf\utilsub\setargv.c ===
/*******************************************************************************
* SETARGV.C (ANSI argc, argv routines)
*
*   argc / argv routines
*
* Copyright Citrix Systems Inc. 1995
* Copyright (C) 1997-1999 Microsoft Corp.
*
*   $Author:   butchd  $
******************************************************************************/

/*
 * Include files
 */
#include <windows.h>

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/*
 * ANSI ARGS structure and other stuff (private).
 */
#include "setargv.h"

/*
 * Local function prototypes.
 */
void args_init(ARGS *);
int add_arg_to_list(char *, ARGS *);
int args_trunc(ARGS *);

/*
 * setargv()
 *
 *    Forms a standard C-runtime argc, argv parsed command line.
 *
 *  ENTRY:
 *      szModuleName (input)
 *          Optional Windows module name.  If not NULL, will be added as first
 *          parsed argument (argv[0], argc=1).
 *      szCmdLine (input)
 *          Points to command line to parse into argc, argv
 *      argc (output)
 *          Points to int to save argument count into on exit.
 *      argv (output)
 *          Points to (char **) to save argv array into on exit.
 *
 *  RETURNS:
 *       ERROR_SUCCESS if ok; ERROR_xxx code if not ok.
 *
 *    A typical use of this routine is by a Windows UI application to 
 *    convert a command line into the C argc & argv variables prior to calling 
 *    the utilsub.lib ParseCommandLine() function.  Therefore, a companion 
 *    routine, freeargv(), allows for alloc'd memory to be freed by the caller 
 *    after use, if desired.
 *
 */
int WINAPI
setargv( LPSTR szModuleName, 
         LPSTR szCmdLine, 
         int *argc, 
         char ***argv )
{
    int rc;
   char *cp;
   char FAR *cfp = szCmdLine;
   char ch, fname[_MAX_PATH];
   ARGS arg_data;

   /*
    * Initialize arg_data
    */
   args_init( &arg_data );

   /*
    * If present, add module name as argv[0].
    */
   if ( szModuleName ) {
      if ( (rc = add_arg_to_list( szModuleName, &arg_data )) != ERROR_SUCCESS )
         goto setargv_error;
   }

   /*
    * Skip leading blanks/tabs of remaining args
    */
   cp = fname;
   /* skip consecutive blanks and/or tabs */
   while ( (ch = *cfp) == ' ' || ch == '\t' )
      cfp++;

   /*
    * Process remainder of command line
    */
   while ( ch = *cfp++ ) {

      /*
       * Process quoted strings.
       */
      if ( ch == '"' ) {
         while ( (ch = *cfp++) && ch != '"' )
            *cp++ = ch;
         if ( ch == '\0' )
            cfp--;

      /*
       * If we find a delimeter, process the pathname we just scanned.
       */
      } else if ( ch == ' ' || ch == '\t') {
         *cp = '\0';
         if ( (rc = add_arg_to_list( fname, &arg_data )) != ERROR_SUCCESS )
            goto setargv_error;

         cp = fname;
         /* skip consecutive blanks and/or tabs */
         while ( (ch = *cfp) == ' ' || ch == '\t')
	    cfp++;

      /*
       * All other chars, just copy to internal buffer.
       */
      } else {
         *cp++ = ch;
      }
   }
   if ( cp != fname ) {
      *cp = '\0';
      if ( (rc = add_arg_to_list( fname, &arg_data )) != ERROR_SUCCESS )
        goto setargv_error;
   }

   if ( (rc = args_trunc( &arg_data )) != ERROR_SUCCESS )
       goto setargv_error;

   /*
    * Initialize global variables __argc and __argv
    */
   *argc = arg_data.argc;
   *argv = arg_data.argv;

   return(ERROR_SUCCESS);

//--------------
// Error return
//--------------
setargv_error:
    return(rc);
}


/*
 * freeargv()
 *
 *    Frees up the memory alloc'd for argv strings and argv
 *    array itself.
 *
 *    ENTER:
 *       argv = argv array as created by this setargv() routine.
 *
 */
void WINAPI
freeargv( char **argv )
{
    free(*argv);
    free(argv);
}


/*
 * args_init()
 *
 *    Initialize the ARGS struct passed as an argument.
 *
 *    ENTER:
 *       argp = pointer to ARGS struct
 *
 */
static void
args_init( ARGS *argp )
{

   argp->argc = 0;
   argp->argv = NULL;
   argp->argvlen = 0;
   argp->argvp = NULL;
   argp->buflen = 0;
   argp->buf = argp->bufptr = argp->bufend = NULL;
}


/*
 * add_arg_to_list()
 *
 *    This routine adds the specified argument string to the argv array,
 *    and increments the argv pointer and argc counter.
 *    If necessary, memory for the argument string is allocated.
 *
 *    RETURNS:
 *       ERROR_SUCCESS if ok; ERROR_NOT_ENOUGH_MEMORY if not.
 *
 */
static int
add_arg_to_list( char *arg_string,
                 ARGS *argp )
{
   int len;

#ifdef notdef
   printf( "add_arg_to_list: arg_string=%s:, argc=%d, argvp=%x",
           arg_string,argp->argc,argp->argvp );
#endif

   /*
    * Verify we have an argv array buffer.
    * If we have one but it is full, expand the array.
    * If we can't alloc/realloc the array, return an error.
    */
   if ( !argp->argv ) {
      argp->argvlen = MIN_ARG_ALLOC;
      argp->argc = 0;
      argp->argv = malloc( argp->argvlen * sizeof( char *) );
      argp->argvp = argp->argv;
   } else if ( argp->argc + 1 >= argp->argvlen ) {
      argp->argvlen += MIN_ARG_ALLOC;
      argp->argv = realloc( argp->argv, argp->argvlen * sizeof(char *) );
      argp->argvp = argp->argv + argp->argc;
   }
   if ( !argp->argv ) {
#ifdef notdef
      printf("add_arg_to_list: failed to (re)alloc argv buf\n");
#endif
      goto add_arg_to_list_error;
   }

   /*
    * Verify we have a string buffer to store the argument string.
    * If we have one but there is not room for the new arg, expand the
    * buffer.  If we can't alloc/realloc the buffer, return an error.
    */
   len = strlen( arg_string ) + 1;
   if ( !argp->buf ) {
      argp->buflen = MIN_BUF_ALLOC;
      while ( argp->buflen < len )
	 argp->buflen += MIN_BUF_ALLOC;
      argp->buf = malloc( argp->buflen );
      argp->bufptr = argp->buf;
      argp->bufend = argp->buf + argp->buflen - 1;

   } else if ( argp->bufptr + len > argp->bufend ) {
      char *old_buf;
      int buf_offset = argp->bufptr - argp->buf;
      while ( argp->buflen < buf_offset + len )
         argp->buflen += MIN_BUF_ALLOC;
      old_buf = argp->buf;
      argp->buf = realloc( argp->buf, argp->buflen );
      argp->bufend = argp->buf + argp->buflen - 1;
      argp->bufptr = argp->buf + buf_offset;

      /*
       * If the argument string buffer moved, then we need to relocate the
       * argv pointers in the argv array to point to the new string locations.
       */
      if ( argp->buf != old_buf ) {
	 char *buf_ptr, **argv_ptr;
	 argv_ptr = argp->argv;
	 buf_ptr = argp->buf;
	 while ( buf_ptr != argp->bufptr ) {
	    *argv_ptr++ = buf_ptr;
	    buf_ptr += strlen( buf_ptr ) + 1;
	 }
      }
   }
   if ( !argp->buf ) {
#ifdef notdef
      printf("add_arg_to_list: failed to (re)alloc string buf\n");
#endif
      goto add_arg_to_list_error;
   }

   /*
    * Add the new argument to the buffer and the argv array.
    * Increment the arg count, the argv pointer, and the buffer pointer.
    */
   strcpy( argp->bufptr, arg_string );
   *(argp->argvp) = argp->bufptr;
   argp->bufptr += len;
   ++argp->argc;
   ++argp->argvp;
   *(argp->argvp) = NULL;
   return(ERROR_SUCCESS);

//--------------
// Error return
//--------------
add_arg_to_list_error:
    return(ERROR_NOT_ENOUGH_MEMORY);
}


/*
 * args_trunc()
 *
 *    Truncate the memory used by the ARGS struct
 *    so that unused memory is freed.
 *
 *    ENTER:
 *       argp = pointer to ARGS struct
 *
 *    RETURNS:
 *       ERROR_SUCCESS if ok; ERROR_NOT_ENOUGH_MEMORY code if not ok.
 *
 */
static int
args_trunc( ARGS *argp )
{
   char *old_buf;

   /*
    * call realloc to shrink size of argv array, set argvlen = argc
    * to indicate no more room in argv array.
    */
   argp->argvlen = argp->argc + 1;
   argp->argv = realloc( argp->argv, argp->argvlen * sizeof(char *) );
   if ( !argp->argv )
      goto args_trunc_error;
   argp->argvp = argp->argv + argp->argc;

   /*
    * call realloc to shrink size of argument string buffer, set bufend
    * pointer to end of buffer to indicate buf is full.
    */
   old_buf = argp->buf;
   argp->buflen = argp->bufptr - argp->buf;
   argp->buf = realloc( argp->buf, argp->buflen );
   if ( !argp->buf )
      goto args_trunc_error;
   argp->bufptr = argp->buf + argp->buflen;
   argp->bufend = argp->buf + argp->buflen - 1;

   /*
    * If the argument string buffer moved, then we need to relocate the
    * argv pointers in the argv array to point to the new string locations.
    */
   if ( old_buf != argp->buf ) {
      char *buf_ptr, **argv_ptr;

      argv_ptr = argp->argv;
      buf_ptr = argp->buf;
      while ( buf_ptr != argp->bufptr ) {
         *argv_ptr++ = buf_ptr;
	 buf_ptr += strlen( buf_ptr ) + 1;
      }
   }

   return(ERROR_SUCCESS);

//--------------
// Error return
//--------------
args_trunc_error:
   return(ERROR_NOT_ENOUGH_MEMORY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpperf\utilsub\procutil.c ===
/******************************************************************************
* PROCUTIL.C
*
*  Various useful utilities for dealing with processes under CITRIX NT
*  Multi-user that are useful across a range of utilities and apps.
*
* Copyright Citrix Systems Inc. 1994
* Copyright (C) 1997-1999 Microsoft Corp.
*
*  Author:      John Richardson
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <process.h>
#include <string.h>
#include <malloc.h>

#include <winstaw.h>
#include <utilsub.h>

/*
 * Local function prototypes.
 */
VOID LookupSidUser( PSID pSid, PWCHAR pUserName, PULONG pcbUserName );

/*
 * RefreshProcessObjectCaches()
 *
 *  Refresh (invalidate) any caches that may be used by process object
 *  utilities.
 *
 * This is currently a place holder, but is here so that utilities can call
 * it, thus being isolated from any future decisions to add caching.
 */
VOID WINAPI
RefreshProcessObjectCaches()
{
    RefreshUserSidCrcCache();
}

/******************************************************************************
 *
 * ProcessObjectMatch
 *
 * General Name match function against a process.
 *
 * The CITRIX admin utilities can take a user name, winstation name,
 * a winstation id, or process id as an argument to a command that targets
 * a process for some action (query status, kill, etc.)
 *
 * This function does general compares of the supplied name to see if it
 * applies to the given process because the name represents the NT user
 * account, a winstations system name, the winstations unique id, or the
 * processes unique id. It replaces some of the function in MumProc()
 * on the CITRIX OS/2 product.
 *
 * The various information about a process is supplied by the caller. Because
 * of the way processes are enumerated from the NT system, it is easier
 * and faster for the caller to supply this information than for the routine
 * to retrieve it itself. This could be folded into a general EnumerateProcess()
 * if needed. Currently this routine serves the purpose of having one unified
 * way of handling process objects across all utilities.
 *
 *
 * Matching:
 *
 *  An integer number is assumed to be an NT process ID unless NumberIsLogonId
 *  is set, which then says to treat it as a LogonId.
 *
 *  A name starting with a character is tested first as a winstation name, then
 *  as a user name, finally as a program image name.  A user or group name
 *  could stand alone, or be preceded by a '\' to be [somewhat] compatible
 *  with the OS/2 product.
 *
 * Parameters:
 *
 *  Pid (input)
 *      Windows NT unique process identifier
 *  LogonId (input)
 *      CITRIX Logon ID the process is executing on.
 *  NumberIsLogonId (input)
 *      Treat a number in pMatchName as a LogonId not an PID number.
 *  pMatchName (input)
 *      Name for match testing
 *  pWinStationName (input)
 *      Name of WinStation for process.
 *  pUserName (input)
 *      Name of User for process.
 *  pImageName (input)
 *      Image name of executing program for process.
 *
 *****************************************************************************/

BOOLEAN WINAPI
ProcessObjectMatch( ULONG Pid,
                    ULONG LogonId,
                    int NumberIsLogonId,
                    PWCHAR pMatchName,
                    PWCHAR pWinStationName,
                    PWCHAR pUserName,
                    PWCHAR pImageName )
{
    ULONG tmp;

    /*
     * Check for wild card
     */
    if( pMatchName[0] == L'*' ) return( TRUE );

    /*
     * If someone puts a '\' in front of pMatchName, strip it off
     */
    if( pMatchName[0] == L'\\' ) pMatchName++;

    /*
     * First, if the match name is a number, check for == to process ID or
     * LogonId.
     */
    if( iswdigit( pMatchName[0] ) ) {
        tmp = wcstol( pMatchName, NULL, 10 );

	if( NumberIsLogonId && (tmp == LogonId) )
            return( TRUE );
	else if( tmp == Pid )
	   return( TRUE );
        else
	   return( FALSE );
    }

    /*
     * Then, check the match name against the WinStation Name of the process.
     */
    if ( !_wcsicmp( pWinStationName, pMatchName ) ) {
        return( TRUE );
    }

    /*
     * Then, check the match name against the UserName of the process.
     */
    if( !_wcsicmp( pUserName, pMatchName ) ) {
        return( TRUE );
    }

    /*
     * Finally, check the match name against the image name of the process.
     */
    if( !_wcsicmp( pImageName, pMatchName ) ) {
        return(TRUE);
    }

    return( FALSE );
}


/*
 * This is the cache maintained by the GetUserNameFromSid function
 *
 * It is thread safe through the use of ULock.
 */

typedef struct TAGUSERSIDLIST {
    struct TAGUSERSIDLIST *Next;
    USHORT SidCrc;
    WCHAR UserName[USERNAME_LENGTH];
} USERSIDLIST, *PUSERSIDLIST;

static PUSERSIDLIST pUList = NULL;
static RTL_CRITICAL_SECTION ULock;
static BOOLEAN ULockInited = FALSE;

/***************************************************************************
 *
 *  InitULock
 *
 *  Since we do not require the user to call an initialize function,
 *  we must initialize our critical section in a thread safe manner.
 *
 *  The problem is, a critical section is needed to guard against multiple
 *  threads trying to init the critical section at the same time.
 *
 *  The solution that Nt uses, in which RtlInitializeCriticalSection itself
 *  uses, is to wait on a kernel supported process wide Mutant before proceding.
 *  This Mutant almost works by itself, but RtlInitializeCriticalSection does
 *  not wait on it until after trashing the semaphore count. So we wait on
 *  it ourselves, since it can be acquired recursively.
 *
 ***************************************************************************/
NTSTATUS InitULock()
{
    NTSTATUS status = STATUS_SUCCESS;

    RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()->LoaderLock);

    /*
     * Make sure another thread did not beat us here
     */
    if( ULockInited == FALSE ){
	     status = RtlInitializeCriticalSection( &ULock );
        
        if (status == STATUS_SUCCESS) {
            ULockInited = TRUE;
        }
    }

    RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()->LoaderLock);

    return status;
}


/***************************************************************************
 *
 * RefreshUserSidCrcCache
 *
 *  Invalidate the User/SidCrc cache so that the newest information
 *  will be fetched from the system.
 *
 ***************************************************************************/

VOID WINAPI
RefreshUserSidCrcCache( )
{
    NTSTATUS status = STATUS_SUCCESS;

    PUSERSIDLIST pEntry, pNext;

    if( pUList == NULL ) return;

    /*
     * Make sure critical section has been inited
     */
    if( !ULockInited ) {
       status = InitULock();
    }

    if (status == STATUS_SUCCESS) {
        RtlEnterCriticalSection( &ULock );

        pEntry = pUList;

        while( pEntry ) {
           pNext = pEntry->Next;
           free( pEntry );
           pEntry = pNext;
        }

        pUList = NULL;

        RtlLeaveCriticalSection( &ULock );
    }
}


/******************************************************************************
 *
 * GetUserNameFromSid
 *
 *  Attempts to retrieve the user (login) name of the process by first looking
 *  in our User/SidCrc cache table, then (if no match) looking up the SID in
 *  the SAM database and adding the new entry to the User/SidCrc table.
 *
 *  Input
 *
 *   IN pUserSid   Sid pointer
 *
 *   OUT NameBuf   WCHAR pointer to buffer for name
 *
 *   IN/OUT  pBufSize   PULONG NameBuf size
 *
 *  Will always return a user name, which will be "(unknown)" if the SID is
 *  invalid or can't determine the user/SID relationship for any other reason.
 *
 *****************************************************************************/

VOID WINAPI
GetUserNameFromSid( PSID pUserSid, PWCHAR pBuffer, PULONG pcbBuffer )
{
    NTSTATUS status = STATUS_SUCCESS;
    USHORT SidCrc = 0;
    PUSERSIDLIST pEntry;

    /*
     * Make sure critical section has been inited
     */
    if( !ULockInited ) {
       status = InitULock();
    }

    /*        
     * Determine SID length in bytes and calculate a 16-bit CRC for it,
     * to facilitate quick matching.
     */
    if ( pUserSid )
        SidCrc = CalculateCrc16( (PBYTE)pUserSid,
                                 (USHORT)GetLengthSid(pUserSid) );

    /*                                    
     * First: Before performing the expensive LookupAccountSid() function,
     * see if we've encountered this SID already, and match the user name
     * if so.
     */
    if ( status == STATUS_SUCCESS && pUList ) {

        RtlEnterCriticalSection( &ULock );

        pEntry = pUList;

        while( pEntry ) {

            if ( SidCrc == pEntry->SidCrc ) {

                wcsncpy( pBuffer, pEntry->UserName, (*pcbBuffer)-1 );
                pBuffer[(*pcbBuffer)-1] = 0;
                *pcbBuffer = wcslen(pBuffer);
                RtlLeaveCriticalSection( &ULock );
                return;
            }
            pEntry = pEntry->Next;
        }

        RtlLeaveCriticalSection( &ULock );
    }

    /*
     * Last resort: Determine the user name associated with the SID using
     * the LookupAccountSid() API, embedded in our local function
     * LookupSidUser().
     */
    LookupSidUser( pUserSid, pBuffer, pcbBuffer );

    /*        
     * Add this new User/Sid relationship in our User/Sid cache list.
     */
    if (status == STATUS_SUCCESS) {
        RtlEnterCriticalSection( &ULock );

        if ( (pEntry = (PUSERSIDLIST)malloc(sizeof(USERSIDLIST))) ) {

            pEntry->SidCrc = SidCrc;
            wcsncpy( pEntry->UserName, pBuffer, USERNAME_LENGTH - 1 );
            pEntry->UserName[USERNAME_LENGTH-1] = 0;
            pEntry->Next = pUList;
            pUList = pEntry;
        }

        RtlLeaveCriticalSection( &ULock );
    }
}


/******************************************************************************
 * LookupSidUser
 *
 *      Fetch the user name associated with the specified SID.
 *
 *  ENTRY:
 *      pSid (input)
 *          Points to SID to match to user name.
 *      pUserName (output)
 *          Points to buffer to place the user name into.
 *      pcbUserName (input/output)
 *          Specifies the size in bytes of the user name buffer.  The returned
 *          user name will be truncated to fit this buffer (including NUL
 *          terminator) if necessary and this variable set to the number of
 *          characters copied to pUserName.
 *
 *  EXIT:
 *
 *      LookupSidUser() will always return a user name.  If the specified
 *      SID fails to match to a user name, then the user name "(unknown)" will
 *      be returned.
 *
 *****************************************************************************/

VOID
LookupSidUser( PSID pSid,
               PWCHAR pUserName,
               PULONG pcbUserName )
{
    WCHAR DomainBuffer[DOMAIN_LENGTH], UserBuffer[USERNAME_LENGTH];
    DWORD cbDomainBuffer=sizeof(DomainBuffer), cbUserBuffer=sizeof(UserBuffer),
          Error;
    PWCHAR pDomainBuffer = NULL, pUserBuffer = NULL;
    SID_NAME_USE SidNameUse;
    PWCHAR pUnknown = L"(unknown)";

    /*
     * Fetch user name from SID: try user lookup with a reasonable Domain and
     * Sid buffer size first, before resorting to alloc.
     */
    if ( !LookupAccountSid( NULL, pSid,
                            UserBuffer, &cbUserBuffer,
                            DomainBuffer, &cbDomainBuffer, &SidNameUse ) ) {

        if ( ((Error = GetLastError()) == ERROR_INSUFFICIENT_BUFFER) ) {

            if ( cbDomainBuffer > sizeof(DomainBuffer) ) {

                if ( !(pDomainBuffer =
                        (PWCHAR)malloc(
                            cbDomainBuffer * sizeof(WCHAR))) ) {

                    Error = ERROR_NOT_ENOUGH_MEMORY;
                    goto BadDomainAlloc;
                }
            }

            if ( cbUserBuffer > sizeof(UserBuffer) ) {

                if ( !(pUserBuffer =
                        (PWCHAR)malloc(
                            cbUserBuffer * sizeof(WCHAR))) ) {

                    Error = ERROR_NOT_ENOUGH_MEMORY;
                    goto BadUserAlloc;
                }
            }

            if ( !LookupAccountSid( NULL, pSid,
                                     pUserBuffer ?
                                        pUserBuffer : UserBuffer,
                                     &cbUserBuffer,
                                     pDomainBuffer ?
                                        pDomainBuffer : DomainBuffer,
                                     &cbDomainBuffer,
                                     &SidNameUse ) ) {

                Error = GetLastError();
                goto BadLookup;
            }

        } else {

            goto BadLookup;                
        }
    }

    /*
     * Copy the user name into the specified buffer, truncating if necessary.
     */
    wcsncpy( pUserName, pUserBuffer ? pUserBuffer : UserBuffer, 
              (*pcbUserName)-1 );
    pUserName[(*pcbUserName)-1] = 0;
    *pcbUserName = wcslen(pUserName);

    /*
     * Free our allocs (if any) and return.
     */
    if ( pDomainBuffer )
        free(pDomainBuffer);
    if ( pUserBuffer )
        free(pUserBuffer);
    return;

/*--------------------------------------
 * Error clean-up and return...
 */
BadLookup:
BadUserAlloc:
BadDomainAlloc:
    if ( pDomainBuffer )
        free(pDomainBuffer);
    if ( pUserBuffer )
        free(pUserBuffer);
    wcsncpy( pUserName, pUnknown, (*pcbUserName)-1 );
    pUserName[(*pcbUserName)-1] = 0;
    *pcbUserName = wcslen(pUserName);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpperf\utilsub\setargva.c ===
/*******************************************************************************
*
* SETARGVA.C (ANSI argc, argv routines)
*
*   argc / argv routines
*
* Copyright Citrix Systems Inc. 1995
* Copyright (C) 1997-1999 Microsoft Corp.
*
*   $Author:   butchd  $
******************************************************************************/

/*
 * Include files
 */
#include <windows.h>

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/*
 * ANSI ARGS structure and other stuff (private).
 */
#include "setargva.h"

/*
 * Local function prototypes.
 */
void args_init(ARGS *);
int add_arg_to_list(char *, ARGS *);
int args_trunc(ARGS *);

/*
 * setargvA()
 *
 *    Forms a standard C-runtime argc, argv parsed command line.
 *
 *  ENTRY:
 *      szModuleName (input)
 *          Optional Windows module name.  If not NULL, will be added as first
 *          parsed argument (argv[0], argc=1).
 *      szCmdLine (input)
 *          Points to command line to parse into argc, argv
 *      argc (output)
 *          Points to int to save argument count into on exit.
 *      argv (output)
 *          Points to (char **) to save argv array into on exit.
 *
 *  RETURNS:
 *       ERROR_SUCCESS if ok; ERROR_xxx code if not ok.
 *
 *    A typical use of this routine is by a Windows UI application to 
 *    convert a command line into the C argc & argv variables prior to calling 
 *    the utilsub.lib ParseCommandLine() function.  Therefore, a companion 
 *    routine, freeargv(), allows for alloc'd memory to be freed by the caller 
 *    after use, if desired.
 *
 */
int WINAPI
setargvA( LPSTR szModuleName, 
          LPSTR szCmdLine, 
          int *argc, 
          char ***argv )
{
    int rc;
   char *cp;
   char FAR *cfp = szCmdLine;
   char ch, fname[_MAX_PATH];
   ARGS arg_data;

   /*
    * Initialize arg_data
    */
   args_init( &arg_data );

   /*
    * If present, add module name as argv[0].
    */
   if ( szModuleName ) {
      if ( (rc = add_arg_to_list( szModuleName, &arg_data )) != ERROR_SUCCESS )
         goto setargv_error;
   }

   /*
    * Skip leading blanks/tabs of remaining args
    */
   cp = fname;
   /* skip consecutive blanks and/or tabs */
   while ( (ch = *cfp) == ' ' || ch == '\t' )
      cfp++;

   /*
    * Process remainder of command line
    */
   while ( ch = *cfp++ ) {

      /*
       * Process quoted strings.
       */
      if ( ch == '"' ) {
         while ( (ch = *cfp++) && ch != '"' )
            *cp++ = ch;
         if ( ch == '\0' )
            cfp--;

      /*
       * If we find a delimeter, process the pathname we just scanned.
       */
      } else if ( ch == ' ' || ch == '\t') {
         *cp = '\0';
         if ( (rc = add_arg_to_list( fname, &arg_data )) != ERROR_SUCCESS )
            goto setargv_error;

         cp = fname;
         /* skip consecutive blanks and/or tabs */
         while ( (ch = *cfp) == ' ' || ch == '\t')
	    cfp++;

      /*
       * All other chars, just copy to internal buffer.
       */
      } else {
         *cp++ = ch;
      }
   }
   if ( cp != fname ) {
      *cp = '\0';
      if ( (rc = add_arg_to_list( fname, &arg_data )) != ERROR_SUCCESS )
        goto setargv_error;
   }

   if ( (rc = args_trunc( &arg_data )) != ERROR_SUCCESS )
       goto setargv_error;

   /*
    * Initialize global variables __argc and __argv
    */
   *argc = arg_data.argc;
   *argv = arg_data.argv;

   return(ERROR_SUCCESS);

//--------------
// Error return
//--------------
setargv_error:
    return(rc);
}


/*
 * freeargvA()
 *
 *    Frees up the memory alloc'd for argv strings and argv
 *    array itself.
 *
 *    ENTER:
 *       argv = argv array as created by this setargv() routine.
 *
 */
void WINAPI
freeargvA( char **argv )
{
    free(*argv);
    free(argv);
}


/*
 * args_init()
 *
 *    Initialize the ARGS struct passed as an argument.
 *
 *    ENTER:
 *       argp = pointer to ARGS struct
 *
 */
static void
args_init( ARGS *argp )
{

   argp->argc = 0;
   argp->argv = NULL;
   argp->argvlen = 0;
   argp->argvp = NULL;
   argp->buflen = 0;
   argp->buf = argp->bufptr = argp->bufend = NULL;
}


/*
 * add_arg_to_list()
 *
 *    This routine adds the specified argument string to the argv array,
 *    and increments the argv pointer and argc counter.
 *    If necessary, memory for the argument string is allocated.
 *
 *    RETURNS:
 *       ERROR_SUCCESS if ok; ERROR_NOT_ENOUGH_MEMORY if not.
 *
 */
static int
add_arg_to_list( char *arg_string,
                 ARGS *argp )
{
   int len;

#ifdef notdef
   printf( "add_arg_to_list: arg_string=%s:, argc=%d, argvp=%x",
           arg_string,argp->argc,argp->argvp );
#endif

   /*
    * Verify we have an argv array buffer.
    * If we have one but it is full, expand the array.
    * If we can't alloc/realloc the array, return an error.
    */
   if ( !argp->argv ) {
      argp->argvlen = MIN_ARG_ALLOC;
      argp->argc = 0;
      argp->argv = malloc( argp->argvlen * sizeof( char *) );
      argp->argvp = argp->argv;
   } else if ( argp->argc + 1 >= argp->argvlen ) {
      argp->argvlen += MIN_ARG_ALLOC;
      argp->argv = realloc( argp->argv, argp->argvlen * sizeof(char *) );
      argp->argvp = argp->argv + argp->argc;
   }
   if ( !argp->argv ) {
#ifdef notdef
      printf("add_arg_to_list: failed to (re)alloc argv buf\n");
#endif
      goto add_arg_to_list_error;
   }

   /*
    * Verify we have a string buffer to store the argument string.
    * If we have one but there is not room for the new arg, expand the
    * buffer.  If we can't alloc/realloc the buffer, return an error.
    */
   len = strlen( arg_string ) + 1;
   if ( !argp->buf ) {
      argp->buflen = MIN_BUF_ALLOC;
      while ( argp->buflen < len )
	 argp->buflen += MIN_BUF_ALLOC;
      argp->buf = malloc( argp->buflen );
      argp->bufptr = argp->buf;
      argp->bufend = argp->buf + argp->buflen - 1;

   } else if ( argp->bufptr + len > argp->bufend ) {
      char *old_buf;
      int buf_offset = (int)(argp->bufptr - argp->buf);
      while ( argp->buflen < buf_offset + len )
         argp->buflen += MIN_BUF_ALLOC;
      old_buf = argp->buf;
      argp->buf = realloc( argp->buf, argp->buflen );
      argp->bufend = argp->buf + argp->buflen - 1;
      argp->bufptr = argp->buf + buf_offset;

      /*
       * If the argument string buffer moved, then we need to relocate the
       * argv pointers in the argv array to point to the new string locations.
       */
      if ( argp->buf != old_buf ) {
	 char *buf_ptr, **argv_ptr;
	 argv_ptr = argp->argv;
	 buf_ptr = argp->buf;
	 while ( buf_ptr != argp->bufptr ) {
	    *argv_ptr++ = buf_ptr;
	    buf_ptr += strlen( buf_ptr ) + 1;
	 }
      }
   }
   if ( !argp->buf ) {
#ifdef notdef
      printf("add_arg_to_list: failed to (re)alloc string buf\n");
#endif
      goto add_arg_to_list_error;
   }

   /*
    * Add the new argument to the buffer and the argv array.
    * Increment the arg count, the argv pointer, and the buffer pointer.
    */
   strcpy( argp->bufptr, arg_string );
   *(argp->argvp) = argp->bufptr;
   argp->bufptr += len;
   ++argp->argc;
   ++argp->argvp;
   *(argp->argvp) = NULL;
   return(ERROR_SUCCESS);

//--------------
// Error return
//--------------
add_arg_to_list_error:
    return(ERROR_NOT_ENOUGH_MEMORY);
}


/*
 * args_trunc()
 *
 *    Truncate the memory used by the ARGS struct
 *    so that unused memory is freed.
 *
 *    ENTER:
 *       argp = pointer to ARGS struct
 *
 *    RETURNS:
 *       ERROR_SUCCESS if ok; ERROR_NOT_ENOUGH_MEMORY code if not ok.
 *
 */
static int
args_trunc( ARGS *argp )
{
   char *old_buf;

   /*
    * call realloc to shrink size of argv array, set argvlen = argc
    * to indicate no more room in argv array.
    */
   argp->argvlen = argp->argc + 1;
   argp->argv = realloc( argp->argv, argp->argvlen * sizeof(char *) );
   if ( !argp->argv )
      goto args_trunc_error;
   argp->argvp = argp->argv + argp->argc;

   /*
    * call realloc to shrink size of argument string buffer, set bufend
    * pointer to end of buffer to indicate buf is full.
    */
   old_buf = argp->buf;
   argp->buflen = (int)(argp->bufptr - argp->buf);
   argp->buf = realloc( argp->buf, argp->buflen );
   if ( !argp->buf )
      goto args_trunc_error;
   argp->bufptr = argp->buf + argp->buflen;
   argp->bufend = argp->buf + argp->buflen - 1;

   /*
    * If the argument string buffer moved, then we need to relocate the
    * argv pointers in the argv array to point to the new string locations.
    */
   if ( old_buf != argp->buf ) {
      char *buf_ptr, **argv_ptr;

      argv_ptr = argp->argv;
      buf_ptr = argp->buf;
      while ( buf_ptr != argp->bufptr ) {
         *argv_ptr++ = buf_ptr;
	 buf_ptr += strlen( buf_ptr ) + 1;
      }
   }

   return(ERROR_SUCCESS);

//--------------
// Error return
//--------------
args_trunc_error:
   return(ERROR_NOT_ENOUGH_MEMORY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpperf\utilsub\utildll.h ===
/*******************************************************************************
* utildll.h
*
* UTILDLL WinStation utility support functions header file (export stuff)
*
* Copyright 1997, Citrix Systems Inc.
* Copyright (C) 1997-1999 Microsoft Corp.
*
* $Author:   butchd  $  Butch Davis
*******************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

/*
 * UTILDLL defines and typedefs
 */
typedef struct _ELAPSEDTIME {
    USHORT days;
    USHORT hours;
    USHORT minutes;
    USHORT seconds;
} ELAPSEDTIME, * PELAPSEDTIME;

#define MAX_PROCESSNAME                 18
#define UTILDLL_NAME                    TEXT("UTILDLL.DLL")
#define SYSTEM_MESSAGE_MAX              256
#define MAX_ELAPSED_TIME_LENGTH         15
#define MAX_DATE_TIME_LENGTH            16

/*
 * UTILDLL function prototypes
 */
void StandardErrorMessage( LPCTSTR pszAppName,
                           HWND hwndApp,
                           HINSTANCE hinstApp,
                           ULONG LogonId,
                           UINT nId,
                           int nErrorResourceID, ...);
LPWSTR WINAPI GetSystemMessageW( ULONG LogonId, UINT nId, LPWSTR chBuffer, int chBuffSize );
LPSTR WINAPI GetSystemMessageA( ULONG LogonId, UINT nId, LPSTR chBuffer, int chBuffSize );
#ifdef UNICODE
#define GetSystemMessage GetSystemMessageW
#else
#define GetSystemMessage GetSystemMessageA
#endif

PPDPARAMS WINAPI WinEnumerateDevices( HWND hWnd,
                                      PPDCONFIG3 pPdConfig,
                                      PULONG pEntries,
                                      BOOL bInSetup );
BOOL WINAPI NetworkDeviceEnumerate( PPDCONFIG3, PULONG, PPDPARAMS,
                                    PULONG, BOOL );
BOOL WINAPI QueryCurrentWinStation( PWINSTATIONNAME pWSName, LPTSTR pUserName,
                                    PULONG pLogonId, PULONG pWSFlags );
LONG WINAPI RegGetNetworkDeviceName( HANDLE hServer, PPDCONFIG3 pPdConfig,
                                     PPDPARAMS pPdParams, LPTSTR szDeviceName,
                                     int nDeviceName );
LONG WINAPI RegGetNetworkServiceName( HANDLE hServer,
                                      LPTSTR szServiceKey,
                                      LPTSTR szServiceName,
                                      int nServiceName );
BOOL WINAPI AsyncDeviceEnumerate( PPDCONFIG3, PULONG, PPDPARAMS,
                                  PULONG, BOOL );
BOOL WINAPI NetBIOSDeviceEnumerate( PPDCONFIG3, PULONG, PPDPARAMS,
                                    PULONG, BOOL );
void WINAPI FormDecoratedAsyncDeviceName( LPTSTR pDeviceName,
                                          PASYNCCONFIG pAsyncConfig );
void WINAPI ParseDecoratedAsyncDeviceName( LPCTSTR pDeviceName,
                                           PASYNCCONFIG pAsyncConfig );
void WINAPI SetupAsyncCdConfig( PASYNCCONFIG pAsyncConfig,
                                PCDCONFIG pCdConfig );
BOOL WINAPI InstallModem( HWND hwndOwner );
BOOL WINAPI ConfigureModem( LPCTSTR pModemName, HWND hwndOwner );
BOOL GetAssociatedPortName(char  *szKeyName, WCHAR *wszPortName);
void WINAPI InitializeAnonymousUserCompareList( const WCHAR *pszServer );
BOOL WINAPI HaveAnonymousUsersChanged();
void WINAPI GetUserFromSid( PSID pSid, LPTSTR pUserName, DWORD cbUserName );
void WINAPI CachedGetUserFromSid( PSID pSid, PWCHAR pUserName, PULONG cbUserName );
BOOL WINAPI TestUserForAdmin( BOOL dom );
BOOL WINAPI IsPartOfDomain( VOID );
LPCTSTR WINAPI StrSdClass( SDCLASS SdClass );
LPCTSTR WINAPI StrConnectState( WINSTATIONSTATECLASS ConnectState,
                                BOOL bShortString );
LPCTSTR WINAPI StrProcessState( ULONG State );
LPCTSTR WINAPI StrSystemWaitReason( ULONG WaitReason );
LPCTSTR WINAPI GetUnknownString();
void WINAPI CalculateElapsedTime( LARGE_INTEGER *pTime,
                                  ELAPSEDTIME *pElapsedTime );
int WINAPI CompareElapsedTime( ELAPSEDTIME *pElapsedTime1,
                               ELAPSEDTIME *pElapsedTime2,
                               BOOL bCompareSeconds );
void WINAPI ElapsedTimeString( ELAPSEDTIME *pElapsedTime,
                               BOOL bIncludeSeconds,
                               LPTSTR pString );
void WINAPI DateTimeString( LARGE_INTEGER *pTime, LPTSTR pString );
void WINAPI CurrentDateTimeString( LPTSTR pString );
LARGE_INTEGER WINAPI CalculateDiffTime( LARGE_INTEGER, LARGE_INTEGER );
LPWSTR WINAPI EnumerateMultiUserServers( LPWSTR pDomain );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpperf\utilsub\setargva.h ===
/*******************************************************************************
* SETARGVA.h (ANSI argc, argv routines)
*
*   argc / argv routines
*
* Copyright Citrix Systems Inc. 1995
* Copyright (C) 1997-1999 Microsoft Corp.
*
*   $Author:   butchd  $
******************************************************************************/

/*
 * Argument structure
 *    Caller should initialize using args_init().  Use args_reset() to
 *    reset values, args_free() to free memory allocated by args_init().
 */
struct arg_data {
   int argc;
   char **argv;
   int argvlen;
   char **argvp;
   int buflen;
   char *buf;
   char *bufptr;
   char *bufend;
};
typedef struct arg_data ARGS;

/*
 * minimum size for argv/string buffer allocation
 */
#define MIN_ARG_ALLOC 128
#define MIN_BUF_ALLOC 1024
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpperf\utilsub\umatch.c ===
/******************************************************************************
* UMATCH.C
*
*   The unix_match() function, performing unix style wild-card matching on
*   a given file name.
*
* Copyright Citrix Systems Inc. 1994
* Copyright (C) 1997-1999 Microsoft Corp.
******************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <string.h>

#define TRUE 1
#define FALSE 0

/******************************************************************************
*
* unix_match()
*
*   Check specified filename (found_file) to see if it matches
*   the filename with global characters (with globals).
*   Uses unix style wild-card matching.
*
*   EXIT:
*       TRUE  -- the specified filename matched the filename with wildcards
*       FALSE -- the specified filename did not match
*
******************************************************************************/

int
unix_match(
     WCHAR *with_globals,     /* the file with possible global characters */
     WCHAR *found_file )      /* file name returned - no globals in it */
{
   WCHAR *c1, *c2, *start_c1, *start_c2, *sav_c1, *sav_c2;
   WCHAR ch, ch2;
   int  i, j, k, char_ok, match, want_match;

/*
 * Play with filename so that blanks are removed.
 */
   j = k = 0;
   for (i=0; found_file[i]!=L'\0'; ++i) {
      if (found_file[i] == L' ') {
         if (j == 0) {
            j = i;
         } else {
            found_file[i] = L'\0';
         }
      } else if (found_file[i] == L'.') {
         k = i;
      }
   }
   if (j && k) {
      wcscpy(&found_file[j], &found_file[k]);
   }

/*
 * If Search name is just "*", simply return success now.
 */
   if (with_globals[0]==L'*' && with_globals[1]==L'\0') {
      return TRUE;
   }

#ifdef DEBUG
   wprintf("unix_match: search=%s: found=%s:\n", with_globals, found_file);
#endif

/*
 * Now compare the 2 filenames to see if we have a match.
 */
   c1 = with_globals,
   c2 = found_file;
   start_c1 = sav_c1 = NULL;
      while (*c2!=L'\0') {
         char_ok = FALSE;
         switch (*c1) {
         case L'\0':
            break;
         case '*':
            while (*++c1 == L'*') ;     /* skip consecutive '*'s */
            if (*c1 == L'\0') {         /* if we reached the end, we match */
               return TRUE;
            }
            start_c1 = c1;             /* remember where '*' was and where */
            start_c2 = c2;             /* we were in filename string */
            sav_c1 = NULL;
            char_ok = TRUE;
            break;
         case L'?':
            ++c1; ++c2;
            char_ok = TRUE;
            break;
         case L'[':
            if (!sav_c1) {
               sav_c1 = c1;
               sav_c2 = c2;
            }
            match = FALSE;
            want_match = TRUE;
            if (*++c1 == L'!') {
               ++c1;
               want_match = FALSE;
            }
            while ((ch=*c1) && ch != L']') {             /* BJP */
               if (c1[1] == L'-') {
                  ch2 = *c2;
                  if (ch<=ch2 && c1[2]>=ch2) {
                     match = TRUE;
                     break;
                  }
                  ++c1; ++c1;    /* skip '-' and following char */
               } else if (ch == *c2) {
                  match = TRUE;
                  break;
               }
               ++c1;
            }
            if (want_match) {
               if (match) {
                  while ((ch=*c1++) && ch != L']') ;     /* BJP */
                  ++c2;
                  char_ok = TRUE;
               } else if (!start_c1) {
                  return FALSE;
               }
            } else /*!want_match*/ {
               if (match) {
                  return FALSE;
               } else if (start_c1) {
                  if (sav_c1 != start_c1) {
                     while ((ch=*c1++) && ch != L']') ;  /* BJP */
                     ++c2;
                     sav_c1 = NULL;
                     char_ok = TRUE;
                  } else if (c2[1] == L'\0') {
                     while ((ch=*c1++) && ch != L']') ;  /* BJP */
                     c2 = sav_c2;
                     sav_c1 = NULL;
                     char_ok = TRUE;
                  }
               } else {
                  while ((ch=*c1++) && ch != L']') ;     /* BJP */
                  ++c2;
                  char_ok = TRUE;
               }
            }
            break;
         default:
            if (*c1 == *c2) {     /* See if this char matches exactly */
               ++c1; ++c2;
               char_ok = TRUE;
            }
         }
         if (!char_ok) {               /* No match found */
            if (start_c1) {            /* If there was a '*', start over after*/
               c1 = start_c1;          /* the '*', and one char further into */
               c2 = ++start_c2;        /* the filename string than before */
            } else {
               return FALSE;
            }
         }
      }

   while (*c1==L'*') ++c1;

   if (*c1==L'\0' && *c2==L'\0')
      return TRUE;
   else
      return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpperf\utilsub\utilsub.h ===
/*****************************************************************************
* UTILSUB.H
*      This file contains the structure definitions and equtates for
*      communication between calling programs and functions in utilsub.lib.
*
* Copyright Citrix Systems Inc. 1990-1995
* Copyright (C) 1997-1999 Microsoft Corp.
*
*   $Author:   butchd  $
****************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

/*-----------------------------------------------------------------------------
 --   type-defs for File List Structure.
 ----------------------------------------------------------------------------*/
typedef struct _FILELIST {
   int	  argc;
   WCHAR  **argv;
} FILELIST, *PFILELIST;

/*-----------------------------------------------------------------------------
 --   type-defs for Token Map Structure.
 ----------------------------------------------------------------------------*/
// UNICODE version
typedef struct _TOKMAPW {
   PWCHAR tmToken;	   /* token; null pointer terminates list */
   USHORT tmFlag;	   /* flags for control communication */
   USHORT tmForm;	   /* format control string */
   USHORT tmDLen;	   /* length of data fields */
   PVOID  tmAddr;	   /* pointer to interpreted data */
} TOKMAPW, *PTOKMAPW;

// ANSI version
typedef struct _TOKMAPA {
   PCHAR  tmToken;	   /* token; null pointer terminates list */
   USHORT tmFlag;	   /* flags for control communication */
   USHORT tmForm;	   /* format control string */
   USHORT tmDLen;	   /* length of data fields */
   PVOID  tmAddr;	   /* pointer to interpreted data */
} TOKMAPA, *PTOKMAPA;

/*-----------------------------------------------------------------------------
 --   type-defs for Token Map Structure USE FOR CALLING SDM.DLL FUNCIONS
 ----------------------------------------------------------------------------*/
typedef struct _FILETOKMAP {
   PWCHAR tmToken;         /* token; null pointer terminates list */
   USHORT tmFlag;	   /* flags for control communication */
   USHORT tmForm;	   /* format control string */
   USHORT tmDLen;	   /* length of data fields */
   PVOID  tmAddr;	   /* pointer to interpreted data */
   USHORT tmLast;	   /* pointer for FindFirst FindNext junk */
} FILETOKMAP, FAR * PFILETOKMAP, NEAR * NPFILETOKMAP, * DPFILETOKMAP;

/*-----------------------------------------------------------------------------
 --   equates for _TOKMAP->tmFlag
 ----------------------------------------------------------------------------*/
#define TMFLAG_OPTIONAL       0x0000
#define TMFLAG_REQUIRED       0x0001
#define TMFLAG_PRESENT	      0x0002   /* was present in command line */
#define TMFLAG_MODIFIED       0x0004   /* was modified by app, request write */
#define TMFLAG_DELETE	      0x0008   /* request delete */

/*-----------------------------------------------------------------------------
 --   equates for _TOKMAP->tmForm
 ----------------------------------------------------------------------------*/
#define TMFORM_VOID	      0x0000
#define TMFORM_BOOLEAN	      0x0001
#define TMFORM_BYTE	      0x0002
#define TMFORM_CHAR	      0x0003
#define TMFORM_STRING	      0x0004
#define TMFORM_SHORT	      0x0005
#define TMFORM_USHORT	      0x0006
#define TMFORM_LONG	      0x0007
#define TMFORM_ULONG	      0x0008
#define TMFORM_HEX	      0x0009
#define TMFORM_LONGHEX	      0x000A
#define TMFORM_SERIAL	      0x000B
#define TMFORM_DATE	      0x000C
#define TMFORM_PHONE	      0x000D
#define TMFORM_X_STRING       0x000E
#define TMFORM_FILES	      0x000F
#define TMFORM_S_STRING       0x0010

/*-----------------------------------------------------------------------------
 --   equates for _TOKMAP->tmDLen
 ----------------------------------------------------------------------------*/
#define TMDLEN_VOID	      0x0000

/*-----------------------------------------------------------------------------
 --   prototype for Parse and setargv functions
 ----------------------------------------------------------------------------*/
// UNICODE prototypes
int WINAPI setargvW( LPWSTR szModuleName, LPWSTR szCmdLine, int *, WCHAR *** );
void WINAPI freeargvW( WCHAR ** );
USHORT WINAPI ParseCommandLineW(INT, WCHAR **, PTOKMAPW, USHORT);
BOOLEAN WINAPI IsTokenPresentW( PTOKMAPW, PWCHAR );
BOOLEAN WINAPI SetTokenPresentW( PTOKMAPW, PWCHAR );
BOOLEAN WINAPI SetTokenNotPresentW( PTOKMAPW, PWCHAR );

// ANSI prototypes
int WINAPI setargvA( LPSTR szModuleName, LPSTR szCmdLine, int *, char *** );
void WINAPI freeargvA( char ** );
USHORT WINAPI ParseCommandLineA(INT, CHAR **, PTOKMAPA, USHORT);
BOOLEAN WINAPI IsTokenPresentA( PTOKMAPA, PCHAR );
BOOLEAN WINAPI SetTokenPresentA( PTOKMAPA, PCHAR );
BOOLEAN WINAPI SetTokenNotPresentA( PTOKMAPA, PCHAR );

#ifdef UNICODE
#define setargv setargvW
#define freeargv freeargvW
#define ParseCommandLine ParseCommandLineW
#define IsTokenPresent IsTokenPresentW
#define SetTokenPresent SetTokenPresentW
#define SetTokenNotPresent SetTokenNotPresentW
#define TOKMAP TOKMAPW
#define PTOKMAP PTOKMAPW
#else
#define setargv setargvA
#define freeargv freeargvA
#define ParseCommandLine ParseCommandLineA
#define IsTokenPresent IsTokenPresentA
#define SetTokenPresent SetTokenPresentA
#define SetTokenNotPresent SetTokenNotPresentA
#define TOKMAP TOKMAPA
#define PTOKMAP PTOKMAPA
#endif /* UNICODE */

/*-----------------------------------------------------------------------------
 --   flags for ParseCommandLine().
 ----------------------------------------------------------------------------*/
#define PCL_FLAG_CONTINUE_ON_ERROR     0x0001
#define PCL_FLAG_RET_ON_FIRST_SUCCESS  0x0002
#define PCL_FLAG_IGNORE_INVALID        0x0004
#define PCL_FLAG_NO_CLEAR_MEMORY       0x0008
#define PCL_FLAG_NO_VERSION_CHECK      0x0010
#define PCL_FLAG_VERSION_CHK_UPWARD    0x0020

/*-----------------------------------------------------------------------------
 --   flags for rc=ParseCommandLine(),	PARSE_FLAG_* (BIT FLAGS)
 ----------------------------------------------------------------------------*/
#define PARSE_FLAG_NO_ERROR	       0x0000
#define PARSE_FLAG_MISSING_REQ_FIELD   0x0001
#define PARSE_FLAG_INVALID_PARM        0x0002
#define PARSE_FLAG_DUPLICATE_FIELD     0x0004
#define PARSE_FLAG_NO_PARMS	       0x0008
#define PARSE_FLAG_TOO_MANY_PARMS      0x0010
#define PARSE_FLAG_NOT_ENOUGH_MEMORY   0x0020

/*-----------------------------------------------------------------------------
 --   prototypes for WinStation utility functions
 ----------------------------------------------------------------------------*/

VOID WINAPI RefreshAllCaches();

VOID WINAPI RefreshWinStationCaches();

VOID WINAPI RefreshWinStationObjectCache();

VOID WINAPI RefreshWinStationNameCache();

ULONG WINAPI GetCurrentLogonId( );

VOID WINAPI GetCurrentWinStationName( PWCHAR, int );

BOOLEAN WINAPI GetWinStationNameFromId( ULONG, PWCHAR, int );

BOOLEAN WINAPI GetWinStationUserName( ULONG, PWCHAR, int );

VOID WINAPI GetCurrentUserName( PWCHAR, int );

BOOLEAN WINAPI WinStationObjectMatch( VOID *, PWCHAR );

/*-----------------------------------------------------------------------------
 --   prototypes for process/user utility functions
 ----------------------------------------------------------------------------*/

VOID WINAPI RefreshProcessObjectCaches();

VOID WINAPI RefreshUserSidCrcCache();

BOOLEAN WINAPI ProcessObjectMatch( ULONG, ULONG, int, PWCHAR, PWCHAR, PWCHAR, PWCHAR );

VOID WINAPI GetUserNameFromSid( VOID *, PWCHAR, PULONG );

/*-----------------------------------------------------------------------------
 --   prototypes for helper functions
 ----------------------------------------------------------------------------*/

USHORT WINAPI CalculateCrc16( PBYTE, USHORT );

INT WINAPI ExecProgram( PPROGRAMCALL, INT, WCHAR ** );

VOID WINAPI ProgramUsage( LPCWSTR, PPROGRAMCALL, BOOLEAN );

VOID WINAPI Message( int nResourceID, ... );

VOID WINAPI ErrorPrintf( int nErrorResourceID, ... );

VOID WINAPI TruncateString( PWCHAR pString, int MaxLength );

PPDPARAMS WINAPI EnumerateDevices(PDLLNAME pDllName, PULONG pEntries);

FILE * WINAPI wfopen( LPCWSTR filename, LPCWSTR mode );

PWCHAR WINAPI wfgets( PWCHAR Buffer, int Len, FILE *Stream);

int WINAPI PutStdErr(unsigned int MsgNum, unsigned int NumOfArgs, ...);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpperf\utilsub\setargvw.h ===
/*******************************************************************************
* SETARGVW.h
*
*   argc / argv routines
*
* Copyright Citrix Systems Inc. 1995
* Copyright (C) 1997-1999 Microsoft Corp.
*
*   $Author:   butchd  $
******************************************************************************/

/*
 * Argument structure
 *    Caller should initialize using args_init().  Use args_reset() to
 *    reset values, args_free() to free memory allocated by args_init().
 */
struct arg_data {
   int argc;
   WCHAR **argv;
   int argvlen;
   WCHAR **argvp;
   int buflen;
   WCHAR *buf;
   WCHAR *bufptr;
   WCHAR *bufend;
};
typedef struct arg_data ARGS;

/*
 * minimum size for argv/string buffer allocation
 */
#define MIN_ARG_ALLOC 128
#define MIN_BUF_ALLOC 1024
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpperf\utilsub\wstutil.c ===
/******************************************************************************
*  WSTUTIL.C
*
*  Various useful utilities for dealing with multi-user WinStations and User
*  accounts under CITRIX NT Multi-user that are useful across a range of
*  utilities and apps.
*
* Copyright Citrix Systems Inc. 1993
* Copyright (C) 1997-1999 Microsoft Corp.
*
*  Author:      John Richardson
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <process.h>
#include <string.h>
#include <malloc.h>

#include <winstaw.h>
#include <utilsub.h>

/*
 * RefreshAllCaches
 *
 *  Invalidate any caches maintained by the UTILSUB.DLL
 *
 *  This does not need to be called for utilities that exit when done, but
 *  are for server, or monitoring type programs that need to periodicly
 *  see the latest system information.
 *  IE: A new user could have logged onto a given winstation since the last
 *      call.
 *
 *
 * Exit
 *
 *  Any caches in the UTILSUB.DLL have been invalidated insuring fresh
 *  system information on future calls.
 *
 */
VOID WINAPI
RefreshAllCaches()
{
    RefreshWinStationCaches();
    RefreshProcessObjectCaches();
}

/*
 * RefreshWinStationCaches
 *
 *  Invalidate any caches maintained by the WinStation helper utilities.
 *
 *  This does not need to be called for utilities that exit when done, but
 *  are for server, or monitoring type programs that need to periodicly
 *  see the latest system information.
 *  IE: A new user could have logged onto a given winstation since the last
 *      call.
 *
 *
 * Exit
 *
 *   Makes sure that any WinStation helper utility calls will return the
 *   system information at least up to date as the time that this call
 *   was made.
 *
 */
VOID WINAPI
RefreshWinStationCaches()
{
    RefreshWinStationObjectCache();
    RefreshWinStationNameCache();
}


/*
 * GetCurrentLogonId
 *
 * Gets the WinStation ID for the current processes WinStation
 *
 * Exit
 *
 *  ID of the current processes WinStation
 *
 */

ULONG WINAPI
GetCurrentLogonId()
{
    return( NtCurrentPeb()->SessionId );
}

/*
 * GetCurrentWinStationName
 *
 * Get the current UNICODE name for the WinStation for this process
 *
 * Input:
 *
 *   pName - Pointer to wide character buffer for name
 *
 *   MaxSize - Maximum number of characters in buffer (including terminator).
 *
 *   pName - Pointer to wide character buffer for name
 *
 * Output:
 *
 */
VOID WINAPI
GetCurrentWinStationName( PWCHAR pName, int MaxSize )
{
    GetWinStationNameFromId( NtCurrentPeb()->SessionId, pName, MaxSize );
}

/*
 * This is the cache maintained by the GetWinStationNameFromId function
 *
 * It is thread safe through the use of WLock.
 */

typedef struct TAGWINSTATIONLIST {
    struct TAGWINSTATIONLIST *Next;
    LOGONID LogonId;
} WINSTATIONLIST, *PWINSTATIONLIST;

static PWINSTATIONLIST pWList = NULL;
static RTL_CRITICAL_SECTION WLock;
static BOOLEAN WLockInited = FALSE;

/***************************************************************************
 *
 *  InitWLock
 *
 *  Since we do not require the user to call an initialize function,
 *  we must initialize our critical section in a thread safe manner.
 *
 *  The problem is, a critical section is needed to guard against multiple
 *  threads trying to init the critical section at the same time.
 *
 *  The solution that Nt uses, in which RtlInitializeCriticalSection itself
 *  uses, is to wait on a kernel supported process wide Mutant before proceding.
 *  This Mutant almost works by itself, but RtlInitializeCriticalSection does
 *  not wait on it until after trashing the semaphore count. So we wait on
 *  it ourselves, since it can be acquired recursively.
 *
 ***************************************************************************/
NTSTATUS InitWLock()
{
    NTSTATUS status = STATUS_SUCCESS;

    RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()->LoaderLock);

    /*
     * Make sure another thread did not beat us here
     */
    if( WLockInited == FALSE ){
        status = RtlInitializeCriticalSection( &WLock );

        if (status == STATUS_SUCCESS) {
            WLockInited = TRUE;
        }
    }

    RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()->LoaderLock);

    return status;
}

/***************************************************************************
 *
 * RefreshWinStationNameCache
 *
 *  Invalidate the WinStation Name cache so that the newest information
 *  will be fetched from the system.
 *
 ***************************************************************************/

VOID WINAPI
RefreshWinStationNameCache( )
{
    NTSTATUS status = STATUS_SUCCESS;

    PWINSTATIONLIST pEntry, pNext;

    if( pWList == NULL ) return;

    /*
     * Make sure critical section has been inited
     */
    if( !WLockInited ) {
       status = InitWLock();
    }

    if (status == STATUS_SUCCESS) {
        RtlEnterCriticalSection( &WLock );

        pEntry = pWList;

        while( pEntry ) {
           pNext = pEntry->Next;
           free( pEntry );
           pEntry = pNext;
        }

        pWList = NULL;

        RtlLeaveCriticalSection( &WLock );
    }
}

/*
 * GetWinStationNameFromId
 *
 *  Attempt to retrieve the WinStationName for the given LogonId.
 *
 *  Parameters:
 *
 *     LogonId (input)
 *       Unique LogonId
 *
 *     pName (output)
 *       Pointer to buffer for name
 *
 *     MaxSize (input)
 *       Maximum number of characters in buffer (including terminator).
 *
 *  Returns
 *     TRUE if name was retreived, FALSE otherwise.
 *
 */

BOOLEAN WINAPI
GetWinStationNameFromId( ULONG LogonId, PWCHAR pName, int MaxSize )
{
    NTSTATUS status = STATUS_SUCCESS;
    PLOGONID pIdBase, pId;
    int          rc;
    ULONG        Count;
    PWINSTATIONLIST pEntryBase, pEntry;

    // Since We do not have a WinStationNamefromId Sm Api like we do for
    // LogonIdfromName, we will perform a WinStationEnumerate function across
    // all WinStations known by the Session Manager, and store them in a locally
    // maintained list. We do this so we that this search against the session
    // manager is not done every time we're called.
    //
    // Another alternative that was tested is to open the WinStation itself
    // and then do a WinStationQueryInformation against it in order to
    // retrieve its name from itself. This is much slower because we must
    // set up and tear down an LPC connection to each WinStation, as opposed
    // to the one connection we get to the session manager.

    /*
     * Make sure critical section has been inited
     */
    if( !WLockInited ) {
       status = InitWLock();
    }

    if (status == STATUS_SUCCESS) {
        RtlEnterCriticalSection( &WLock );

        // Initialize the list the first time
        if( pWList == NULL ) {

            rc = WinStationEnumerate( SERVERNAME_CURRENT, &pIdBase, &Count );
            if( rc ) {

                /*
                 * Allocate an Entry for each enumerated winstation.
                 */
                pEntryBase = (PWINSTATIONLIST)malloc( Count * sizeof(WINSTATIONLIST) );
	             if( pEntryBase == NULL ) {

                    pWList = NULL; // We are having severe problems
                    SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                    WinStationFreeMemory(pIdBase);
                    RtlLeaveCriticalSection( &WLock );
		              return( FALSE );
		          }

                /*
                 * Load up Entries.
                 */
                for ( pEntry = pEntryBase, pId = pIdBase; 
                      Count ; 
                      Count--, pEntry++, pId++ ) {

                    pEntry->LogonId = *pId;
                    pEntry->Next = pWList;
                    pWList = pEntry;
                }

                /*
                 * Free enumerate buffer.
                 */
                WinStationFreeMemory(pIdBase);
	         }

        } // End if pWList == NULL

        pEntry = pWList;
        while ( pEntry ) {

	         if( pEntry->LogonId.LogonId == LogonId ) {

                wcsncpy( pName, pEntry->LogonId.WinStationName, MaxSize-1 );
                pName[MaxSize-1] = 0;
                RtlLeaveCriticalSection( &WLock );
	             return( TRUE );
	         }
            pEntry = pEntry->Next;
        }

        RtlLeaveCriticalSection( &WLock );
    }

    // If we can not find its name, print its ID #

    wsprintf( pName, L"ID %d", LogonId );

    return( TRUE );
}


/*
 * GetCurrentUserName
 *
 * Get the current UNICODE name for the logon USER for this process
 *
 * Input:
 *
 *   pName - Pointer to wide character buffer for name
 *
 *   MaxSize - Maximum number of characters in buffer (including terminator)
 *
 *
 * Output:
 *
 */
VOID WINAPI
GetCurrentUserName( PWCHAR pName, int MaxSize )
{
    /*
     * The quickest way appears to open the current processes WinStation and
     * get the name from it. The other way would be to open the process, then
     * its token, extract the SID, then lookup the SID in the SAM database.
     * We have conviently stored the user name in the WinStation at Logon
     * time, so we'll use that.
     */
    GetWinStationUserName( LOGONID_CURRENT, pName, MaxSize );
    return;
}


/*
 * GetWinStationUserName
 *
 * Get the UNICODE name for the USER for the winstation
 *
 * Input:
 *
 *   LogonId - integer identifier for WinStation
 *
 *   pName - Pointer to wide character buffer for name
 *
 *   MaxSize - Maximum number of characters in buffer (including terminator)
 *
 *
 * Output:
 *
 */
BOOLEAN WINAPI
GetWinStationUserName( ULONG LogonId, PWCHAR pName, int MaxSize )
{
    BOOLEAN rc;
    ULONG ReturnLength;
    WINSTATIONINFORMATION Info;

    if( MaxSize == 0) return( FALSE );

    memset( &Info, 0, sizeof(WINSTATIONINFORMATION) );

    rc = WinStationQueryInformation( SERVERNAME_CURRENT,
                                     LogonId,
                                     WinStationInformation, 
                                     (PVOID)&Info,
				     sizeof(WINSTATIONINFORMATION), 
                                     &ReturnLength);
    if(!rc){
        pName[0] = 0;
	return( FALSE );
    }
    if(ReturnLength != sizeof(WINSTATIONINFORMATION)) {
        pName[0] = 0; // Version mismatch
	return( FALSE );
    }
    /*
     * Now copy the name out
     */
    if( MaxSize > USERNAME_LENGTH ) {
        MaxSize = USERNAME_LENGTH;
    }
    wcsncpy( pName, Info.UserName, MaxSize-1 );
    pName[MaxSize-1] = 0; // insure null termination if string is truncated
    return( TRUE );
}


/*
 * These variables maintain a one entry cache so that we
 * do not have to keep querying the winstation (causes an LPC)
 * each time called.
 */
static ULONG CachedId = (ULONG)(-1);
static WCHAR CachedUserName[USERNAME_LENGTH];

/**************************************************************************
*
* RefreshWinStationObjectCache
*
* Flush the cache for the WinStationObject name comparision function.
*
**************************************************************************/

VOID WINAPI
RefreshWinStationObjectCache()
{
    CachedId = (ULONG)(-1);
    CachedUserName[0] = 0;
}

/*
 * WinStationObjectMatch
 *
 * General Name match function against a WinStation.
 *
 * The CITRIX admin utilities can take a user name, winstation name, or
 * a winstation id as an argument to a command that targets a winstation
 * for some action (send a message, query status, reset, etc.)
 *
 * This function does general compares of the supplied name to see if it
 * applies to the given winstation because the name represents the logged
 * on user of the winstation, the winstations system name when attached, or
 * the winstations unique id. It replaces some of the function in MumProc()
 * on the CITRIX OS/2 product.
 *
 *
 * NOTE: The caching for this function assumes typical use of comparing this
 *       winstation against a list of names across multiple calls.
 *       It does not optimize for comparing one name at a time across all
 *       winstation(s) in succession.
 *
 * Parameters:
 *
 *   Id (input) WinStation Id for do the match against
 *
 *   pName (input) UNICODE name for match testing
 */

BOOLEAN WINAPI
WinStationObjectMatch( PLOGONID Id, PWCHAR pName )
{
    ULONG tmp;

    /*
     * Handle the wild card case
     */
    if( pName[0] == L'*' ) {
        return( TRUE );
    }

    /*
     * See if the supplied name is the name assigned to the WinStation
     */
    if( !_wcsnicmp( pName, Id->WinStationName, WINSTATIONNAME_LENGTH ) ) {
       return( TRUE );
    }

    /*
     * See if it represents the numerical id for the winstation
     */
    if( iswdigit( pName[0] ) ) {
       tmp = (ULONG)wcstol( pName, NULL, 10 );
       if( tmp == Id->LogonId ) {
	  return( TRUE );
       }
    }

    /*
     * Else extract the logged on user name from the winstation itself
     * and compare this.
     */
    if( CachedId == Id->LogonId ) {
       if( !_wcsnicmp( CachedUserName, pName, USERNAME_LENGTH ) ) {
	  return( TRUE );
       }
    }

    if ( Id->State == State_Down )
        return( FALSE );

    if( GetWinStationUserName( Id->LogonId, CachedUserName, USERNAME_LENGTH ) ) {
        CachedId = Id->LogonId;
    }
    else {
       CachedId = (ULONG)(-1); // In case name was trashed
       return( FALSE );
    }

    if( !_wcsnicmp( CachedUserName, pName, USERNAME_LENGTH ) ) {
       return( TRUE );
    }

    return( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\abaapi.cpp ===
/****************************************************************************/
/* abaapi.cpp                                                               */
/*                                                                          */
/* RDP Bounds Accumulator API functions                                     */
/*                                                                          */
/* Copyright(c) Microsoft, PictureTel 1992-1996                             */
/* (C) 1997-1999 Microsoft Corp.                                            */
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop

#define TRC_FILE "abaapi"
#include <as_conf.hpp>


/****************************************************************************/
/* Name:      BA_Init                                                       */
/*                                                                          */
/* Purpose:   Initializes the Bounds Accumulator.                           */
/****************************************************************************/
void RDPCALL SHCLASS BA_Init(void)
{
    DC_BEGIN_FN("BA_Init");

#define DC_INIT_DATA
#include <abadata.c>
#undef DC_INIT_DATA

    DC_END_FN();
}


/****************************************************************************/
/* Name:      BA_UpdateShm                                                  */
/*                                                                          */
/* Purpose:   Updates the BA Shm. Called on the correct WinStation context. */
/*****************************************************************************/
void RDPCALL SHCLASS BA_UpdateShm(void)
{
    DC_BEGIN_FN("BA_UpdateShm");

    if (baResetBounds)
    {
        TRC_ALT((TB, "Reset bounds"));
        BAResetBounds();
        baResetBounds = FALSE;
    }

    DC_END_FN();
}


/****************************************************************************/
/* Instantiate the non-inlined common code.                                 */
/****************************************************************************/
#include <abacom.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpperf\utilsub\setargvw.c ===
/*******************************************************************************
* SETARGVW.C (UNICODE argc, argv routines)
*
*   argc / argv routines
*
* Copyright Citrix Systems Inc. 1995
* Copyright (C) 1997-1999 Microsoft Corp.
*
*   $Author:   butchd  $
******************************************************************************/

/*
 * Include files
 */
#include <windows.h>

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/*
 * UNICODE ARGS structure and other stuff (private).
 */
#include "setargvw.h"

/*
 * Local function prototypes.
 */
void args_init( ARGS * );
int add_arg_to_list( WCHAR *, ARGS * );
int args_trunc( ARGS * );

/*
 * setargvW()
 *
 *    Forms a standard C-runtime argc, argv parsed command line.
 *
 *  ENTRY:
 *      szModuleName (input)
 *          Optional Windows module name.  If not NULL, will be added as first
 *          parsed argument (argv[0], argc=1).
 *      szCmdLine (input)
 *          Points to command line to parse into argc, argv
 *      argc (output)
 *          Points to int to save argument count into on exit.
 *      argv (output)
 *          Points to (WCHAR **) to save argv array into on exit.
 *
 *  RETURNS:
 *       ERROR_SUCCESS if ok; ERROR_xxx code if not ok.
 *
 *    A typical use of this routine is by a Windows UI application to 
 *    convert a command line into the C argc & argv variables prior to calling 
 *    the utilsub.lib ParseCommandLine() function.  Therefore, a companion 
 *    routine, freeargv(), allows for alloc'd memory to be freed by the caller 
 *    after use, if desired.
 *
 */
int WINAPI
setargvW( LPWSTR szModuleName, 
          LPWSTR szCmdLine, 
          int *argc, 
          WCHAR ***argv )
{
   int rc;
   WCHAR *cp;
   WCHAR FAR *cfp = szCmdLine;
   WCHAR ch, fname[_MAX_PATH];
   ARGS arg_data;

   /*
    * Initialize arg_data
    */
   args_init( &arg_data );

   /*
    * If present, add module name as argv[0].
    */
   if ( szModuleName ) {
      if ( (rc = add_arg_to_list( szModuleName, &arg_data )) != ERROR_SUCCESS )
         goto setargv_error;
   }

   /*
    * Skip leading blanks/tabs of remaining args
    */
   cp = fname;
   /* skip consecutive blanks and/or tabs */
   while ( (ch = *cfp) == L' ' || ch == L'\t' )
      cfp++;

   /*
    * Process remainder of command line
    */
   while ( ch = *cfp++ ) {

      /*
       * Process quoted strings.
       */
      if ( ch == '"' ) {
         while ( (ch = *cfp++) && ch != '"' )
            *cp++ = ch;
         if ( ch == '\0' )
            cfp--;

      /*
       * If we find a delimeter, process the pathname we just scanned.
       */
      } else if ( ch == ' ' || ch == '\t') {
         *cp = '\0';
         if ( (rc = add_arg_to_list( fname, &arg_data )) != ERROR_SUCCESS )
            goto setargv_error;

         cp = fname;
         /* skip consecutive blanks and/or tabs */
         while ( (ch = *cfp) == ' ' || ch == '\t')
	    cfp++;

      /*
       * All other chars, just copy to internal buffer.
       */
      } else {
         *cp++ = ch;
      }
   }
   if ( cp != fname ) {
      *cp = '\0';
      if ( (rc = add_arg_to_list( fname, &arg_data )) != ERROR_SUCCESS )
        goto setargv_error;
   }

   if ( (rc = args_trunc( &arg_data )) != ERROR_SUCCESS )
       goto setargv_error;

   /*
    * Initialize global variables __argc and __argv
    */
   *argc = arg_data.argc;
   *argv = arg_data.argv;

   return(ERROR_SUCCESS);

//--------------
// Error return
//--------------
setargv_error:
    return(rc);
}


/*
 * freeargvW()
 *
 *    Frees up the memory alloc'd for argv strings and argv
 *    array itself.
 *
 *    ENTER:
 *       argv = argv array as created by this setargv() routine.
 *
 */
void WINAPI
freeargvW( WCHAR **argv )
{
    free(*argv);
    free(argv);
}


/*
 * args_init()
 *
 *    Initialize the ARGS struct passed as an argument.
 *
 *    ENTER:
 *       argp = pointer to ARGS struct
 *
 */
static void
args_init( ARGS *argp )
{

   argp->argc = 0;
   argp->argv = NULL;
   argp->argvlen = 0;
   argp->argvp = NULL;
   argp->buflen = 0;
   argp->buf = argp->bufptr = argp->bufend = NULL;
}


/*
 * add_arg_to_list()
 *
 *    This routine adds the specified argument string to the argv array,
 *    and increments the argv pointer and argc counter.
 *    If necessary, memory for the argument string is allocated.
 *
 *    RETURNS:
 *       ERROR_SUCCESS if ok; ERROR_NOT_ENOUGH_MEMORY if not.
 *
 */
static int
add_arg_to_list( WCHAR *arg_string,
                 ARGS *argp )
{
   int len;

#ifdef notdef
   wprintf( L"add_arg_to_list: arg_string=%s:, argc=%d, argvp=%x",
            arg_string, argp->argc, argp->argvp );
#endif

   /*
    * Verify we have an argv array buffer.
    * If we have one but it is full, expand the array.
    * If we can't alloc/realloc the array, return an error.
    */
   if ( !argp->argv ) {
      argp->argvlen = MIN_ARG_ALLOC;
      argp->argc = 0;
      argp->argv = malloc( argp->argvlen * sizeof( WCHAR *) );
      argp->argvp = argp->argv;
   } else if ( argp->argc + 1 >= argp->argvlen ) {
      argp->argvlen += MIN_ARG_ALLOC;
      argp->argv = realloc( argp->argv, argp->argvlen * sizeof(WCHAR *) );
      argp->argvp = argp->argv + argp->argc;
   }
   if ( !argp->argv ) {
#ifdef notdef
      wprintf( L"add_arg_to_list: failed to (re)alloc argv buf\n" );
#endif
      goto add_arg_to_list_error;
   }

   /*
    * Verify we have a string buffer to store the argument string.
    * If we have one but there is not room for the new arg, expand the
    * buffer.  If we can't alloc/realloc the buffer, return an error.
    */
   len = wcslen( arg_string ) + 1;
   if ( !argp->buf ) {
      argp->buflen = MIN_BUF_ALLOC;
      while ( argp->buflen < len )
	 argp->buflen += MIN_BUF_ALLOC;
      argp->buf = malloc( argp->buflen );
      argp->bufptr = argp->buf;
      argp->bufend = argp->buf + argp->buflen - 1;

   } else if ( argp->bufptr + len > argp->bufend ) {
      WCHAR *old_buf;
      int buf_offset = (int)(argp->bufptr - argp->buf);
      while ( argp->buflen < buf_offset + len )
         argp->buflen += MIN_BUF_ALLOC;
      old_buf = argp->buf;
      argp->buf = realloc( argp->buf, argp->buflen );
      argp->bufend = argp->buf + argp->buflen - 1;
      argp->bufptr = argp->buf + buf_offset;

      /*
       * If the argument string buffer moved, then we need to relocate the
       * argv pointers in the argv array to point to the new string locations.
       */
      if ( argp->buf != old_buf ) {
	     WCHAR *buf_ptr, **argv_ptr;
	     argv_ptr = argp->argv;
	     buf_ptr = argp->buf;

	     while ( buf_ptr != argp->bufptr ) {
	        *argv_ptr++ = buf_ptr;
            buf_ptr += wcslen( buf_ptr ) + 1;
	     }
      }
   }
   if ( !argp->buf ) {
#ifdef notdef
      wprintf( L"add_arg_to_list: failed to (re)alloc string buf\n" );
#endif
      goto add_arg_to_list_error;
   }

   /*
    * Add the new argument to the buffer and the argv array.
    * Increment the arg count, the argv pointer, and the buffer pointer.
    */
   wcscpy( argp->bufptr, arg_string );
   *(argp->argvp) = argp->bufptr;
   argp->bufptr += len;
   ++argp->argc;
   ++argp->argvp;
   *(argp->argvp) = NULL;
   return(ERROR_SUCCESS);

//--------------
// Error return
//--------------
add_arg_to_list_error:
    return(ERROR_NOT_ENOUGH_MEMORY);
}


/*
 * args_trunc()
 *
 *    Truncate the memory used by the ARGS struct
 *    so that unused memory is freed.
 *
 *    ENTER:
 *       argp = pointer to ARGS struct
 *
 *    RETURNS:
 *       ERROR_SUCCESS if ok; ERROR_NOT_ENOUGH_MEMORY code if not ok.
 *
 */
static int
args_trunc( ARGS *argp )
{
   WCHAR *old_buf;

   /*
    * call realloc to shrink size of argv array, set argvlen = argc
    * to indicate no more room in argv array.
    */
   argp->argvlen = argp->argc + 1;
   argp->argv = realloc( argp->argv, argp->argvlen * sizeof(WCHAR *) );
   if ( !argp->argv )
      goto args_trunc_error;
   argp->argvp = argp->argv + argp->argc;

   /*
    * call realloc to shrink size of argument string buffer, set bufend
    * pointer to end of buffer to indicate buf is full.
    */
   old_buf = argp->buf;
   argp->buflen = (int)(argp->bufptr - argp->buf);
   argp->buf = realloc( argp->buf, argp->buflen );
   if ( !argp->buf )
      goto args_trunc_error;
   argp->bufptr = argp->buf + argp->buflen;
   argp->bufend = argp->buf + argp->buflen - 1;

   /*
    * If the argument string buffer moved, then we need to relocate the
    * argv pointers in the argv array to point to the new string locations.
    */
   if ( old_buf != argp->buf ) {
      WCHAR *buf_ptr, **argv_ptr;

      argv_ptr = argp->argv;
      buf_ptr = argp->buf;
      while ( buf_ptr != argp->bufptr ) {
         *argv_ptr++ = buf_ptr;
	     buf_ptr += wcslen( buf_ptr ) + 1;
      }
   }

   return(ERROR_SUCCESS);

//--------------
// Error return
//--------------
args_trunc_error:
   return(ERROR_NOT_ENOUGH_MEMORY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\abcwd.cpp ===
/****************************************************************************/
/* abcwd.cpp                                                                */
/*                                                                          */
/* RDP Bitmap Compressor C++ wrapper.                                       */
/*                                                                          */
/* Copyright(c) Microsoft 1997-1999                                         */
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop

#define TRC_FILE "abcwd"

#include <abcapi.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\acmapi.cpp ===
/****************************************************************************/
/* acmapi.cpp                                                               */
/*                                                                          */
/* Cursor Manager API functions.                                            */
/*                                                                          */
/* Copyright(c) Microsoft, PictureTel 1992-1997                             */
/* Copyright(c) Microsoft 1997-1999                                         */
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop

#define TRC_FILE "acmapi"
#include <as_conf.hpp>

/****************************************************************************/
/* CM_Init                                                                  */
/****************************************************************************/
void RDPCALL SHCLASS CM_Init(void)
{
    TS_POINTER_CAPABILITYSET PtrCaps;

    DC_BEGIN_FN("CM_Init");

#define DC_INIT_DATA
#include <acmdata.c>
#undef DC_INIT_DATA

    /************************************************************************/
    /* Set up the CM capabilities.                                          */
    /************************************************************************/
    PtrCaps.capabilitySetType     = TS_CAPSETTYPE_POINTER;
    PtrCaps.colorPointerFlag      = TRUE;
    PtrCaps.colorPointerCacheSize = CM_DEFAULT_RX_CACHE_ENTRIES;
    PtrCaps.pointerCacheSize      = CM_DEFAULT_RX_CACHE_ENTRIES;
    CPC_RegisterCapabilities((PTS_CAPABILITYHEADER)&PtrCaps,
            sizeof(TS_POINTER_CAPABILITYSET));

    TRC_NRM((TB, "CM initialized"));

    DC_END_FN();
}


/****************************************************************************/
/* CM_UpdateShm(..)                                                         */
/*                                                                          */
/* Updates CM Shared Memory.                                                */
/****************************************************************************/
void RDPCALL SHCLASS CM_UpdateShm(void)
{
    DC_BEGIN_FN("CM_UpdateShm");

    TRC_NRM((TB, "Update CM"));

    /************************************************************************/
    /* Setup the cache size to use                                          */
    /************************************************************************/
    m_pShm->cm.cmCacheSize = cmNewTxCacheSize;
    m_pShm->cm.cmNativeColor = cmSendNativeColorDepth;

#ifdef DC_HICOLOR
    /************************************************************************/
    /* Do we support any-bpp cursors?                                       */
    /************************************************************************/
    m_pShm->cm.cmSendAnyColor = (m_pTSWd->supportedBpps != 0);
#endif

    DC_END_FN();
}


/****************************************************************************/
/* CM_PartyJoiningShare()                                                   */
/*                                                                          */
/* Called when a new party is joining the share.                            */
/*                                                                          */
/* PARAMETERS:                                                              */
/*                                                                          */
/* locPersonID - local person ID of remote person joining the share.        */
/*                                                                          */
/* oldShareSize - the number of the parties which were in the share (ie     */
/* excludes the joining party).                                             */
/*                                                                          */
/* RETURNS: TRUE if the party can join the share.                           */
/*          FALSE if the party can NOT join the share.                      */
/****************************************************************************/
BOOL RDPCALL SHCLASS CM_PartyJoiningShare(
        LOCALPERSONID locPersonID,
        unsigned      oldShareSize)
{
    BOOL rc = TRUE;

    DC_BEGIN_FN("CM_PartyJoiningShare");

    /************************************************************************/
    /* Allow ourself to be added to the share, but do nothing else.         */
    /************************************************************************/
    if (locPersonID == SC_LOCAL_PERSON_ID) {
        TRC_DBG((TB, "Added ourself {%u} to the share", locPersonID));
    }
    else {
        // Flag that we must send a cursor shape update.
        cmNeedToSendCursorShape = TRUE;

        // Set cache size before enumerating capabilities.
        TRC_NRM((TB, "Default cache size: %u", CM_DEFAULT_TX_CACHE_ENTRIES));
        cmNewTxCacheSize = CM_DEFAULT_TX_CACHE_ENTRIES;
        cmSendNativeColorDepth = FALSE;
        TRC_NRM((TB, "Native color depth support is %s",
                cmSendNativeColorDepth ? "ON" : "OFF"));

        // Do capability renegotiation.
        CPC_EnumerateCapabilities(TS_CAPSETTYPE_POINTER, NULL, CMEnumCMCaps);

        // Check that the negotiated cache size is non-zero - the protocol
        // assumes this
        TRC_NRM((TB, "Negotiated cache size: %u", NULL, cmNewTxCacheSize));
        if (cmNewTxCacheSize == 0) {
            // This is a protocol error - log it
            TRC_ERR((TB, "Negotiated cache size is zero"));
            WDW_LogAndDisconnect(m_pTSWd, TRUE, Log_RDP_NoCursorCache, NULL, 0);
            rc = FALSE;
        }
        else {
            // Trigger an IOCTL from the DD so we have the right context to
            // update the shared memory.
            DCS_TriggerUpdateShmCallback();
        }
    }

    DC_END_FN();
    return rc;
}


/****************************************************************************/
/* FUNCTION: CMEnumCMCaps                                                   */
/*                                                                          */
/* CM callback function for CPC capabilities enumeration.                   */
/*                                                                          */
/* PARAMETERS:                                                              */
/* personID - ID of this person                                             */
/* pCapabilities - pointer to this person's cursor capabilites              */
/****************************************************************************/
void RDPCALL SHCLASS CMEnumCMCaps(
        LOCALPERSONID locPersonID,
        UINT_PTR UserData,
        PTS_CAPABILITYHEADER pCapabilities)
{
    PTS_POINTER_CAPABILITYSET pPointerCaps;
    BOOL fSupportsColorCursors;
    unsigned cCursorCacheSize;

    DC_BEGIN_FN("CMEnumCMCaps");

    DC_IGNORE_PARAMETER(UserData);

    pPointerCaps = (PTS_POINTER_CAPABILITYSET)pCapabilities;

    /************************************************************************/
    /* If the person does not have any cursor capabilites we still get      */
    /* called, but the sizeOfCapabilities field is zero.                    */
    /************************************************************************/
    if (pPointerCaps->lengthCapability < FIELDOFFSET(
            TS_POINTER_CAPABILITYSET, pointerCacheSize))
    {
        TRC_NRM((TB, "Person[0x%x] No cursor caps", locPersonID));

        cCursorCacheSize = 0;
        fSupportsColorCursors = FALSE;
    }
    else if (pPointerCaps->lengthCapability == FIELDOFFSET(
            TS_POINTER_CAPABILITYSET, pointerCacheSize))
    {
        TRC_NRM((TB,
          "Old style Person[0x%x] capsID(%u) size(%u) ccrs(%u) CacheSize(%u)",
                                       locPersonID,
                                       pPointerCaps->capabilitySetType,
                                       pPointerCaps->lengthCapability,
                                       pPointerCaps->colorPointerFlag,
                                       pPointerCaps->colorPointerCacheSize));

        cCursorCacheSize      = pPointerCaps->colorPointerCacheSize;
        fSupportsColorCursors = pPointerCaps->colorPointerFlag;
    }
    else
    {
        TRC_NRM((TB,
          "New style Person[0x%x] capsID(%u) size(%u) ccrs(%u) CacheSize(%u)",
                                       locPersonID,
                                       pPointerCaps->capabilitySetType,
                                       pPointerCaps->lengthCapability,
                                       pPointerCaps->colorPointerFlag,
                                       pPointerCaps->pointerCacheSize));

        cCursorCacheSize       = pPointerCaps->pointerCacheSize;
        fSupportsColorCursors  = pPointerCaps->colorPointerFlag;
        cmSendNativeColorDepth = TRUE;
    }

    TRC_ASSERT((fSupportsColorCursors), (TB, "Mono protocol not supported"));

    cmNewTxCacheSize = min(cmNewTxCacheSize, cCursorCacheSize);

    DC_END_FN();
}


/****************************************************************************/
/* FUNCTION: CM_SendCursorMovedPacket                                       */
/*                                                                          */
/* Called to try and send a cursor moved packet either from                 */
/* CM_SendCursorMovedPacket or CM_Periodic.                                 */
/****************************************************************************/
void RDPCALL SHCLASS CM_SendCursorMovedPacket(PPDU_PACKAGE_INFO pPkgInfo)
{
    unsigned packetSize;
    BYTE *pPackageSpace;
    TS_POINTER_PDU_DATA UNALIGNED *pPointerPDU;

    DC_BEGIN_FN("CMSendCursorMovedPacket");

    TRC_ASSERT((m_pShm), (TB,"NULL m_pShm"));

    // Work out how much space we need for a cursor packet.
    if (scUseFastPathOutput)
        packetSize = scUpdatePDUHeaderSpace + sizeof(TS_POINT16);
    else
        packetSize = scUpdatePDUHeaderSpace +
                FIELDOFFSET(TS_POINTER_PDU_DATA, pointerData.pointerPosition) +
                FIELDSIZE(TS_POINTER_PDU_DATA, pointerData.pointerPosition);

    pPackageSpace = SC_GetSpaceInPackage(pPkgInfo, packetSize);
    if (NULL != pPackageSpace) {
        TS_POINT16 UNALIGNED *pPoint;

        // Fill in the packet.
        if (scUseFastPathOutput) {
            pPackageSpace[0] = TS_UPDATETYPE_MOUSEPTR_POSITION |
                    scCompressionUsedValue;
            pPoint = (TS_POINT16 UNALIGNED *)(pPackageSpace +
                    scUpdatePDUHeaderSpace);
        }
        else {
            ((TS_POINTER_PDU UNALIGNED *)pPackageSpace)->shareDataHeader.
                    pduType2 = TS_PDUTYPE2_POINTER;
            pPointerPDU = (TS_POINTER_PDU_DATA UNALIGNED *)(pPackageSpace +
                    scUpdatePDUHeaderSpace);
            pPointerPDU->messageType = TS_PTRMSGTYPE_POSITION;
            pPoint = &pPointerPDU->pointerData.pointerPosition;
        }

        pPoint->x = (UINT16)m_pShm->cm.cmCursorPos.x;
        pPoint->y = (UINT16)m_pShm->cm.cmCursorPos.y;

        SC_AddToPackage(pPkgInfo, packetSize, FALSE);

        TRC_NRM((TB, "Send cursor move (%d,%d)", m_pShm->cm.cmCursorPos.x,
                m_pShm->cm.cmCursorPos.y));
    }
    else {
        TRC_ERR((TB, "couldn't get space in package"));
    }

    DC_END_FN();
}


/****************************************************************************/
/* FUNCTION: CMSendCursorShape                                              */
/*                                                                          */
/* Sends a packet containing the given cursor shape (bitmap). If the        */
/* same shape is located in the cache then a cached cursor packet is sent.  */
/*                                                                          */
/* PARAMETERS:                                                              */
/* pCursorShape - pointer to the cursor shape                               */
/* cbCursorDataSize - pointer to the cursor data size                       */
/*                                                                          */
/* RETURNS: TRUE if successful, FALSE otherwise.                            */
/****************************************************************************/
BOOL RDPCALL SHCLASS CMSendCursorShape(PPDU_PACKAGE_INFO pPkgInfo)
{
    BOOL rc = TRUE;
    PCM_CURSORSHAPE pCursorShape;
    unsigned cbCursorDataSize;

    DC_BEGIN_FN("CMSendCursorShape");

    TRC_ASSERT((m_pShm), (TB,"NULL m_pShm"));

    /************************************************************************/
    /* check for a cached cursor                                            */
    /************************************************************************/
    if (m_pShm->cm.cmCacheHit)
    {
        TRC_NRM((TB, "Cursor in cache: iEntry(%u)", m_pShm->cm.cmCacheEntry));
        if (CMSendCachedCursor(m_pShm->cm.cmCacheEntry, pPkgInfo))
        {
            /****************************************************************/
            /* Indicate to the DD that we got the new cursor and return     */
            /* success.                                                     */
            /****************************************************************/
            m_pShm->cm.cmBitsWaiting = FALSE;
        }
        else
        {
            TRC_ALT((TB, "Failed to send definition"));
            rc = FALSE;
        }
    }
    else
    {
        /********************************************************************/
        /* wasn't cached - get the bits and send them                       */
        /********************************************************************/
        if (CMGetCursorShape(&pCursorShape, &cbCursorDataSize))
        {
            if (!CM_CURSOR_IS_NULL(pCursorShape))
            {
                TRC_NRM((TB, "Send new cursor: pShape(%p), iEntry(%u)",
                        pCursorShape, m_pShm->cm.cmCacheEntry));

                if (CMSendColorBitmapCursor(pCursorShape,
                        m_pShm->cm.cmCacheEntry, pPkgInfo))
                {
                    /********************************************************/
                    /* Indicate to the DD that we got the new cursor and    */
                    /* return success.                                      */
                    /********************************************************/
                    m_pShm->cm.cmBitsWaiting = FALSE;
                }
                else
                {
                    TRC_ALT((TB, "Failed to send cursor"));
                    rc = FALSE;
                }
            }
            else
            {
                /************************************************************/
                /* If this is a Null pointer, send the relevant packet. We  */
                /* return FALSE here so that we will attempt to re-send the */
                /* cursor on the next CM_Periodic().                        */
                /************************************************************/
                TRC_NRM((TB, "Send Null cursor"));
                CMSendSystemCursor(TS_SYSPTR_NULL, pPkgInfo);
                rc = FALSE;
            }
        }
    }

    DC_END_FN();
    return rc;
}


/****************************************************************************/
/* FUNCTION: CMSendCachedCursor                                             */
/*                                                                          */
/* Sends a packet containing the given cache entry id.                      */
/*                                                                          */
/* PARAMETERS:                                                              */
/* iCacheEntry - cache index                                                */
/*                                                                          */
/* RETURNS: TRUE if packet sent, FALSE otherwise.                           */
/****************************************************************************/
BOOL RDPCALL SHCLASS CMSendCachedCursor(unsigned iCacheEntry,
                                        PPDU_PACKAGE_INFO pPkgInfo)
{
    BOOL rc = TRUE;
    BYTE *pPackageSpace;
    TS_POINTER_PDU_DATA UNALIGNED *pPointerPDU;
    unsigned cbPacketSize;

    DC_BEGIN_FN("CMSendCachedCursor");

    TRC_NRM((TB, "Send cached cursor(%u)", iCacheEntry));

    // See how much space we need.
    if (scUseFastPathOutput)
        cbPacketSize = scUpdatePDUHeaderSpace + sizeof(TSUINT16);
    else
        cbPacketSize = scUpdatePDUHeaderSpace +
                FIELDOFFSET(TS_POINTER_PDU_DATA,
                pointerData.cachedPointerIndex) +
                FIELDSIZE(TS_POINTER_PDU_DATA,
                pointerData.cachedPointerIndex);

    pPackageSpace = SC_GetSpaceInPackage(pPkgInfo, cbPacketSize);
    if (NULL != pPackageSpace) {
        TSUINT16 UNALIGNED *pIndex;

        // Fill in the packet.
        if (scUseFastPathOutput) {
            pPackageSpace[0] = TS_UPDATETYPE_MOUSEPTR_CACHED |
                    scCompressionUsedValue;
            pIndex = (TSUINT16 UNALIGNED *)(pPackageSpace +
                    scUpdatePDUHeaderSpace);
        }
        else {
            ((TS_POINTER_PDU UNALIGNED *)pPackageSpace)->shareDataHeader.
                    pduType2 = TS_PDUTYPE2_POINTER;

            pPointerPDU = (TS_POINTER_PDU_DATA UNALIGNED *)
                    (pPackageSpace + scUpdatePDUHeaderSpace);
            pPointerPDU->messageType = TS_PTRMSGTYPE_CACHED;
            pIndex = &pPointerPDU->pointerData.cachedPointerIndex;
        }

        *pIndex = (TSUINT16)iCacheEntry;

        SC_AddToPackage(pPkgInfo, cbPacketSize, TRUE);
    }
    else
    {
        TRC_ERR((TB, "couldn't get space in package"));
        rc = FALSE;
    }

    DC_END_FN();
    return rc;
}


/****************************************************************************/
/* FUNCTION: CMSendSystemCursor                                             */
/*                                                                          */
/* Sends a packet containing the given system cursor IDC.                   */
/*                                                                          */
/* PARAMETERS:                                                              */
/* cursorIDC - the IDC of the system cursor to send                         */
/*                                                                          */
/* RETURNS: TRUE if successful, FALSE otherwise.                            */
/****************************************************************************/
BOOL RDPCALL SHCLASS CMSendSystemCursor(UINT32          cursorIDC,
                                        PPDU_PACKAGE_INFO pPkgInfo)
{
    BOOL rc = TRUE;
    unsigned cbPacketSize;
    BYTE *pPackageSpace;
    TS_POINTER_PDU_DATA UNALIGNED *pPointerPDU;

    DC_BEGIN_FN("CMSendSystemCursor");

    // The cursor is one of the system cursors. Work out how big a packet
    // we need.
    if (scUseFastPathOutput)
        cbPacketSize = scUpdatePDUHeaderSpace;
    else
        cbPacketSize = scUpdatePDUHeaderSpace +
                FIELDOFFSET(TS_POINTER_PDU_DATA,
                pointerData.systemPointerType) +
                FIELDSIZE(TS_POINTER_PDU_DATA,
                pointerData.systemPointerType);

    pPackageSpace = SC_GetSpaceInPackage(pPkgInfo, cbPacketSize);
    if (NULL != pPackageSpace) {
        // Fill in the packet.
        if (scUseFastPathOutput) {
            TRC_ASSERT((cursorIDC == TS_SYSPTR_NULL ||
                    cursorIDC == TS_SYSPTR_DEFAULT),
                    (TB,"Unrecognized cursorIDC=%u", cursorIDC));
            pPackageSpace[0] = (cursorIDC == TS_SYSPTR_NULL ?
                    TS_UPDATETYPE_MOUSEPTR_SYSTEM_NULL :
                    TS_UPDATETYPE_MOUSEPTR_SYSTEM_DEFAULT) |
                    scCompressionUsedValue;
        }
        else {
            ((TS_POINTER_PDU UNALIGNED *)pPackageSpace)->shareDataHeader.
                    pduType2 = TS_PDUTYPE2_POINTER;

            pPointerPDU = (TS_POINTER_PDU_DATA UNALIGNED *)(pPackageSpace +
                    scUpdatePDUHeaderSpace);
            pPointerPDU->messageType = TS_PTRMSGTYPE_SYSTEM;
            pPointerPDU->pointerData.systemPointerType = (UINT16)cursorIDC;
        }

        TRC_NRM((TB, "Send UINT16 %ld", cursorIDC));

        SC_AddToPackage(pPkgInfo, cbPacketSize, TRUE);
    }
    else
    {
        TRC_ERR((TB, "couldn't get space in package"));
        rc = FALSE;
    }

    DC_END_FN();
    return rc;
}


/****************************************************************************/
/* FUNCTION: CMSendColorBitmapCursor                                        */
/*                                                                          */
/* Sends a given cursor as a color bitmap.                                  */
/*                                                                          */
/* PARAMETERS:                                                              */
/* pCursor - pointer to the cursor shape                                    */
/* iCacheEntry - cache index to store in the transmitted packet             */
/*                                                                          */
/* RETURNS: TRUE if packet sent, FALSE otherwise                            */
/****************************************************************************/
BOOL RDPCALL SHCLASS CMSendColorBitmapCursor(
        PCM_CURSORSHAPE pCursor,
        unsigned iCacheEntry,
        PPDU_PACKAGE_INFO pPkgInfo)
{
    unsigned cbPacketSize;
    BYTE *pPackageSpace;
    TS_POINTER_PDU_DATA UNALIGNED *pPointerPDU;
    BOOL rc = TRUE;
    unsigned cbANDMaskSize;
    unsigned cbXORBitmapSize;
    unsigned cbColorCursorSize;
    TS_COLORPOINTERATTRIBUTE UNALIGNED *pColAttr;

    DC_BEGIN_FN("CMSendColorBitmapCursor");

    /************************************************************************/
    /* Calculate the color cursor size in bytes -- both AND and XOR fields. */
    /************************************************************************/
    cbANDMaskSize = CURSOR_AND_MASK_SIZE(pCursor);
    cbXORBitmapSize = CURSOR_XOR_BITMAP_SIZE(pCursor);
    cbColorCursorSize = cbANDMaskSize + cbXORBitmapSize;

    // How big is a cursor packet?
    if (cmSendNativeColorDepth) {
        // New protocol.
        if (scUseFastPathOutput)
            cbPacketSize = scUpdatePDUHeaderSpace +
                    sizeof(TS_POINTERATTRIBUTE) + cbColorCursorSize;
        else
            cbPacketSize = scUpdatePDUHeaderSpace +
                    (unsigned)FIELDOFFSET(TS_POINTER_PDU_DATA,
                    pointerData.pointerAttribute.colorPtrAttr.
                    colorPointerData[0]) + cbColorCursorSize;
    }
    else {
        // old protocol - hard coded 24 bpp
        if (scUseFastPathOutput)
            cbPacketSize = scUpdatePDUHeaderSpace +
                    sizeof(TS_COLORPOINTERATTRIBUTE) + cbColorCursorSize;
        else
            cbPacketSize = scUpdatePDUHeaderSpace +
                    (unsigned)FIELDOFFSET(TS_POINTER_PDU_DATA,
                    pointerData.colorPointerAttribute.colorPointerData[0]) +
                    cbColorCursorSize;
    }

    pPackageSpace = SC_GetSpaceInPackage(pPkgInfo, cbPacketSize);
    if (NULL != pPackageSpace) {
        // Fill in the packet.
        if (scUseFastPathOutput) {
            if (cmSendNativeColorDepth) {
                TS_POINTERATTRIBUTE UNALIGNED *pAttr;
                
                // New protocol.
                pPackageSpace[0] = TS_UPDATETYPE_MOUSEPTR_POINTER |
                        scCompressionUsedValue;
                pAttr = (TS_POINTERATTRIBUTE UNALIGNED *)(pPackageSpace +
                        scUpdatePDUHeaderSpace);
                pAttr->XORBpp = pCursor->hdr.cBitsPerPel;
                pColAttr = &pAttr->colorPtrAttr;
            }
            else {
                // Old protocol.
                pPackageSpace[0] = TS_UPDATETYPE_MOUSEPTR_COLOR |
                        scCompressionUsedValue;
                pColAttr = (TS_COLORPOINTERATTRIBUTE UNALIGNED *)
                        (pPackageSpace + scUpdatePDUHeaderSpace);
            }
        }
        else {
            ((TS_POINTER_PDU UNALIGNED *)pPackageSpace)->shareDataHeader.
                    pduType2 = TS_PDUTYPE2_POINTER;
            pPointerPDU = (TS_POINTER_PDU_DATA UNALIGNED *)(pPackageSpace +
                    scUpdatePDUHeaderSpace);
            if (cmSendNativeColorDepth) {
                // new protocol
                pPointerPDU->messageType = TS_PTRMSGTYPE_POINTER;
                pPointerPDU->pointerData.pointerAttribute.XORBpp =
                        pCursor->hdr.cBitsPerPel;
                pColAttr = &(pPointerPDU->pointerData.pointerAttribute.
                        colorPtrAttr);
            }
            else {
                // old protocol - hard coded 24 bpp
                pPointerPDU->messageType = TS_PTRMSGTYPE_COLOR;
                pColAttr = &(pPointerPDU->pointerData.colorPointerAttribute);
            }
        }

        pColAttr->cacheIndex = (TSUINT16)iCacheEntry;

        // Now set up the details
        CMGetColorCursorDetails(
                       pCursor,
                       &(pColAttr->width),
                       &(pColAttr->height),
           (PUINT16_UA)&(pColAttr->hotSpot.x),
           (PUINT16_UA)&(pColAttr->hotSpot.y),
                       &(pColAttr->colorPointerData[0]) + cbXORBitmapSize,
                       &(pColAttr->lengthANDMask),
                       &(pColAttr->colorPointerData[0]),
                       &(pColAttr->lengthXORMask));

        // sanity checks
        TRC_ASSERT((pColAttr->lengthANDMask == cbANDMaskSize),
                   (TB, "AND mask size differs: %u, %u",
                        pColAttr->lengthANDMask,
                        cbANDMaskSize));

        TRC_ASSERT((pColAttr->lengthXORMask == cbXORBitmapSize),
                   (TB, "XOR bitmap size differs: %u, %u",
                        pColAttr->lengthXORMask,
                        cbXORBitmapSize));

        TRC_NRM((TB,
            "Color cursor id %u cx:%u cy:%u xhs:%u yhs:%u cbAND:%u cbXOR:%u",
                     pColAttr->cacheIndex,
                     pColAttr->width,
                     pColAttr->height,
                     pColAttr->hotSpot.x,
                     pColAttr->hotSpot.y,
                     pColAttr->lengthANDMask,
                     pColAttr->lengthXORMask));

        // Add it to the package.
        SC_AddToPackage(pPkgInfo, cbPacketSize, TRUE);
    }
    else
    {
        TRC_ERR((TB, "couldn't get space in package"));
        rc = FALSE;
    }

    DC_END_FN();
    return rc;
}


/****************************************************************************/
/* FUNCTION: CMGetColorCursorDetails                                        */
/*                                                                          */
/* Returns details of a cursor at 24bpp, given a CM_CURSORSHAPE structure.  */
/*                                                                          */
/* PARAMETERS:                                                              */
/* pCursor - pointer to a CM_CURSORSHAPE structure from which this function */
/*     extracts the details                                                 */
/* pcxWidth - pointer to a UINT16 variable that receives the cursor width   */
/*     in pixels                                                            */
/* pcyHeight - pointer to a UINT16 variable that receives the cursor        */
/*     height in pixels                                                     */
/* pxHotSpot - pointer to a UINT16 variable that receives the cursor        */
/*     hotspot x coordinate                                                 */
/* pyHotSpot - pointer to a UINT16 variable that receives the cursor        */
/*     hotspot y coordinate                                                 */
/* pANDMask - pointer to a buffer that receives the cursor AND mask         */
/* pcbANDMask - pointer to a UINT16 variable that receives the size in      */
/*     bytes of the cursor AND mask                                         */
/* pXORBitmap - pointer to a buffer that receives the cursor XOR bitmap at  */
/*     24bpp                                                                */
/* pcbXORBitmap - pointer to a UINT16 variable that receives the size in    */
/*     bytes of the cursor XOR bitmap                                       */
/****************************************************************************/
void RDPCALL SHCLASS CMGetColorCursorDetails(
        PCM_CURSORSHAPE pCursor,
        PUINT16_UA   pcxWidth,
        PUINT16_UA   pcyHeight,
        PUINT16_UA   pxHotSpot,
        PUINT16_UA   pyHotSpot,
        PBYTE        pANDMask,
        PUINT16_UA   pcbANDMask,
        PBYTE        pXORBitmap,
        PUINT16_UA   pcbXORBitmap)
{
    unsigned cbANDMaskSize;
    unsigned cbXORBitmapSize;
    unsigned cbXORBitmapRowWidth;
    unsigned cbANDMaskRowWidth;
    unsigned cbSrcRowOffset;
    unsigned cbDstRowOffset;
    unsigned y;
    PCM_CURSORSHAPEHDR pCursorHdr;

    DC_BEGIN_FN("CMGetColorCursorDetails");

    TRC_ASSERT((pCursor != NULL),(TB,"NULL pCursor not allowed!"));

    pCursorHdr = &(pCursor->hdr);

    /************************************************************************/
    /* Copy the cursor size and hotspot coords.                             */
    /************************************************************************/
    *pcxWidth  = pCursorHdr->cx;
    *pcyHeight = pCursorHdr->cy;
    *pxHotSpot = (UINT16)pCursorHdr->ptHotSpot.x;
    *pyHotSpot = (UINT16)pCursorHdr->ptHotSpot.y;
    TRC_NRM((TB, "cx(%u) cy(%u) cbWidth %d planes(%u) bpp(%u)",
                                                   pCursorHdr->cx,
                                                   pCursorHdr->cy,
                                                   pCursorHdr->cbMaskRowWidth,
                                                   pCursorHdr->cPlanes,
                                                   pCursorHdr->cBitsPerPel));

    cbANDMaskSize = CURSOR_AND_MASK_SIZE(pCursor);
    cbXORBitmapSize = CURSOR_XOR_BITMAP_SIZE(pCursor);

    /************************************************************************/
    /* Copy the AND mask - this is always mono.                             */
    /*                                                                      */
    /* The AND mask is currently in top-down format (the top row of the     */
    /* bitmap comes first).                                                 */
    /*                                                                      */
    /* The protocol sends bitmaps in Device Independent format, which is    */
    /* bottom-up.  We therefore have to flip the rows as we copy the mask.  */
    /************************************************************************/
    cbANDMaskRowWidth = pCursorHdr->cbMaskRowWidth;
    cbSrcRowOffset = 0;
    cbDstRowOffset = cbANDMaskRowWidth * (pCursorHdr->cy-1);

    for (y = 0; y < pCursorHdr->cy; y++)
    {
        memcpy( pANDMask + cbDstRowOffset,
                pCursor->Masks + cbSrcRowOffset,
                cbANDMaskRowWidth );
        cbSrcRowOffset += cbANDMaskRowWidth;
        cbDstRowOffset -= cbANDMaskRowWidth;
    }

    /************************************************************************/
    /* Copy the XOR mask a row at a time.  It starts at the end of the AND  */
    /* mask in the source data                                              */
    /************************************************************************/
    cbXORBitmapRowWidth = CURSOR_DIB_BITS_SIZE(pCursor->hdr.cx, 1,
                                               pCursor->hdr.cBitsPerPel);
    cbSrcRowOffset = cbANDMaskSize;
    cbDstRowOffset = cbXORBitmapRowWidth * (pCursorHdr->cy-1);

    for (y = 0; y < pCursorHdr->cy; y++)
    {
        memcpy( pXORBitmap + cbDstRowOffset,
                   pCursor->Masks + cbSrcRowOffset,
                   cbXORBitmapRowWidth );
        cbSrcRowOffset += pCursorHdr->cbColorRowWidth;
        cbDstRowOffset -= cbXORBitmapRowWidth;
    }

    TRC_NRM((TB, "XOR data len %d", cbXORBitmapSize ));
    TRC_DATA_NRM("XOR data", pXORBitmap, cbXORBitmapSize);

    *pcbANDMask   = (UINT16) CURSOR_AND_MASK_SIZE(pCursor);
    *pcbXORBitmap = (UINT16) CURSOR_XOR_BITMAP_SIZE(pCursor);

    DC_END_FN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\acadata.c ===
/****************************************************************************/
/* acadata.c                                                                */
/*                                                                          */
/* RDP Control Arbitrator global data                                       */
/*                                                                          */
/* Copyright(c) Microsoft, PictureTel 1993-1997                             */
/* Copyright(c) Microsoft 1997-1999                                         */
/****************************************************************************/

#include <ndcgdata.h>


DC_DATA_ARRAY_NULL(int, caStates, SC_DEF_MAX_PARTIES, DC_STRUCT1(0));

DC_DATA_ARRAY_NULL(CAMSGDATA, caPendingMessages,
        ((TS_CTRLACTION_LAST - TS_CTRLACTION_FIRST) + 1), DC_STRUCT1(0));

DC_DATA(LOCALPERSONID, caWhoHasControlToken, 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\acmdata.c ===
/****************************************************************************/
/* acmdata.c                                                                */
/*                                                                          */
/* Cursor Manager Data                                                      */
/*                                                                          */
/* Copyright(c) Microsoft, PictureTel 1992-1997                             */
/* Copyright (c) Microsoft 1997-1999                                        */
/****************************************************************************/

#include <ndcgdata.h>


/****************************************************************************/
// Capability storage for transfer to DD.
/****************************************************************************/
DC_DATA(unsigned, cmNewTxCacheSize, 0);
DC_DATA(BOOLEAN, cmSendNativeColorDepth, FALSE); // New cursor protocol supported?

/****************************************************************************/
// Used to track whether we need to send a cursor packet.
/****************************************************************************/
DC_DATA(BOOLEAN, cmNeedToSendCursorShape, FALSE);
DC_DATA(BOOLEAN, cmCursorHidden, FALSE);
DC_DATA(UINT32, cmLastCursorStamp, 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\abadata.c ===
/****************************************************************************/
/* abadata.c                                                                */
/*                                                                          */
/* RDP bounds accumulation code data declarations                           */
/*                                                                          */
/* Copyright(c) Microsoft, Data Connection Ltd 1992-1998                    */
/* (C) 1997-1999 Microsoft Corp.                                            */
/****************************************************************************/

#include <ndcgdata.h>


DC_DATA(BOOLEAN, baResetBounds,  FALSE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\acpcapi.cpp ===
/****************************************************************************/
// acpcapi.cpp
//
// Capabilities Coordinator API functions.
//
// Copyright(c) Microsoft, PictureTel 1992-1996
// (C) 1997-1999 Microsoft Corp.
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop

#define TRC_FILE "acpcapi"
#include <as_conf.hpp>

/****************************************************************************/
/* API FUNCTION: CPC_Init                                                   */
/*                                                                          */
/* Initializes the Capabilities Coordinator.                                */
/****************************************************************************/
void RDPCALL SHCLASS CPC_Init(void)
{
    DC_BEGIN_FN("CPC_Init");

    /************************************************************************/
    /* This initializes all the global data for this component              */
    /************************************************************************/
#define DC_INIT_DATA
#include <acpcdata.c>
#undef DC_INIT_DATA

    // Set up pointer to presized memory buffer and set initial size value
    // since the presized buffer is uninitialized.
    cpcLocalCombinedCaps = (PTS_COMBINED_CAPABILITIES)cpcLocalCaps;
    cpcLocalCombinedCaps->numberCapabilities = 0;

    DC_END_FN();
}


/****************************************************************************/
/* API FUNCTION: CPC_Term                                                   */
/*                                                                          */
/* Terminates the Capabilities Coordinator.                                 */
/****************************************************************************/
void RDPCALL SHCLASS CPC_Term(void)
{
    unsigned i;

    DC_BEGIN_FN("CPC_Term");

    /************************************************************************/
    /* Free capabilities for each party                                     */
    /************************************************************************/
    for (i = 0; i < SC_DEF_MAX_PARTIES; i++) {
        TRC_NRM((TB, "Free data for party %d", i));
        if (cpcRemoteCombinedCaps[i] != NULL)
            COM_Free(cpcRemoteCombinedCaps[i]);
    }

    DC_END_FN();
}


/****************************************************************************/
/* API FUNCTION: CPC_RegisterCapabilities                                   */
/*                                                                          */
/* Called at initialisation time by each component that has capabilities    */
/* which need to be negotiated across the share. This is used to register   */
/* all capabilities.                                                        */
/*                                                                          */
/* PARAMETERS:                                                              */
/* pCapabilities - pointer to a structure containing the capabilities ID    */
/*                 and any number of capability fields.                     */
/*                 The values used in these fields should be non-zero.  A   */
/*                 zero in any capability field is used to indicate that    */
/*                 the capability is either unknown or undefined by the     */
/*                 remote.                                                  */
/*                                                                          */
/* sizeOfCaps    - the size of the total capabilities.  The limit on the    */
/*                 total size of all secondary capabilities is 300 bytes,   */
/*                 but this is imposed locally and could be increased       */
/*                 without harming interoperability.                        */
/****************************************************************************/
void RDPCALL SHCLASS CPC_RegisterCapabilities(
        PTS_CAPABILITYHEADER pCapabilities,
        UINT16               sizeOfCaps)
{
    unsigned i;
    PTS_CAPABILITYHEADER pNextCaps;

    DC_BEGIN_FN("CPC_RegisterCapabilities");

    TRC_NRM((TB, "Registering capabilities ID %hd, size %hd",
             pCapabilities->capabilitySetType, sizeOfCaps));

#ifdef DC_DEBUG
    /************************************************************************/
    /* Check that CPC_GetCombinedCapabilities has not already been called.  */
    /************************************************************************/
    if (cpcLocalCombinedCapsQueried)
    {
        TRC_ERR((TB, "CPC_GetCombinedCapabilities has already been called"));
    }
#endif

    /************************************************************************/
    /* Register capabilities (if any)                                       */
    /************************************************************************/
    if (sizeOfCaps != 0) {
        pCapabilities->lengthCapability = sizeOfCaps;

        // Search for the end of the capabilities structure.
        pNextCaps = (PTS_CAPABILITYHEADER)&(cpcLocalCombinedCaps->data[0]);
        for (i = 0; i < cpcLocalCombinedCaps->numberCapabilities; i++)
            pNextCaps = (PTS_CAPABILITYHEADER)((PBYTE)pNextCaps +
                    pNextCaps->lengthCapability);

        // Check that we have enough room in our combined capabilities
        // structure to add the new capabilities.
        if (((PBYTE)pNextCaps - (PBYTE)cpcLocalCombinedCaps +
                pCapabilities->lengthCapability) <= CPC_MAX_LOCAL_CAPS_SIZE) {
            // Copy across the new capabilities into our combined capabilities
            // structure.
            memcpy(pNextCaps, pCapabilities, pCapabilities->lengthCapability);

            // Update the number of capabilities in our combined capabilities
            // structure.
            cpcLocalCombinedCaps->numberCapabilities++;

            TRC_DBG((TB, "Added %d bytes to capabilities for ID %d",
                    pCapabilities->lengthCapability,
                    pCapabilities->capabilitySetType));
        }
        else {
            // We do not have enough room to add the capabilities so return.
            // Any system communicating with us will think we do not support
            // these capabilities.  The size of the capabilities structure
            // can be increased (it is not limited as part of the protocol).
            // The value of CPC_MAX_LOCAL_CAPS_SIZE should be increased.
            TRC_ERR((TB,"Out of combined capabilities space ID %d; size %d",
                    pCapabilities->capabilitySetType,
                    pCapabilities->lengthCapability));
        }
    }

    DC_END_FN();
}


/****************************************************************************/
/* API FUNCTION: CPC_EnumerateCapabilities                                  */
/*                                                                          */
/* Enumerates the capabilities for each node in the share (not including    */
/* local).                                                                  */
/*                                                                          */
/* PARAMETERS:                                                              */
/* capabilitiesID - the ID of the capabilities (group structure) to be      */
/*     enumerated.                                                          */
/* UserData - Private caller data to be passed to each call of the enum     */
/*     func.                                                                */
/* pCapsEnumerateFN - function to be called for each person in the share    */
/*     with the persons capabilities structure.                             */
/****************************************************************************/
void RDPCALL SHCLASS CPC_EnumerateCapabilities(
        unsigned capabilitiesID,
        UINT_PTR UserData,
        PCAPSENUMERATEFN pCapsEnumerateFN)
{
    LOCALPERSONID localID;
    unsigned i;
    BOOL foundCapabilities;
    PTS_CAPABILITYHEADER pCaps;
    TS_CAPABILITYHEADER  emptyCaps;

    DC_BEGIN_FN("CPC_EnumerateCapabilities");

    /************************************************************************/
    /* Search for the capabilities ID within the remote party's section of  */
    /* the combined capabilities structure.                                 */
    /************************************************************************/
    for (localID = SC_DEF_MAX_PARTIES - 1; localID >= 1; localID--) {
        if (cpcRemoteCombinedCaps[localID-1] != NULL) {
            pCaps = (PTS_CAPABILITYHEADER)
                    &(cpcRemoteCombinedCaps[localID-1]->data[0]);

            for (i = 0, foundCapabilities = FALSE;
                    i < cpcRemoteCombinedCaps[localID-1]->numberCapabilities;
                    i++) {
                if (pCaps->capabilitySetType == capabilitiesID) {
                    /********************************************************/
                    /* We have found the capabilities structure requested.  */
                    /* Make the call to the enumeration callback function.  */
                    /********************************************************/
                    foundCapabilities = TRUE;
                    (this->*pCapsEnumerateFN)(localID, UserData, pCaps);

                    /********************************************************/
                    /* Go onto the next person.                             */
                    /********************************************************/
                    break;
                }
                pCaps = (PTS_CAPABILITYHEADER)((PBYTE)pCaps +
                        pCaps->lengthCapability);
            }

            if (!foundCapabilities) {
                /************************************************************/
                /* We did not find the requested capability structure for   */
                /* this party so we must return an empty one.               */
                /************************************************************/
                emptyCaps.capabilitySetType = (UINT16)capabilitiesID;
                emptyCaps.lengthCapability = 0;

                /************************************************************/
                /* Call the enumeration function callback with the empty    */
                /* capabilities for this personID.                          */
                /************************************************************/
                (this->*pCapsEnumerateFN)(localID, UserData, &emptyCaps);
            }
        }
    }

    DC_END_FN();
}


/****************************************************************************/
/* API FUNCTION: CPC_GetCombinedCapabilities                                */
/*                                                                          */
/* Called by the Share Controller (SC).  Returns a pointers to structures   */
/* containing the combined capabilities of all the registered capabilities. */
/*                                                                          */
/* Note that this relies on the initialisation order of the components.     */
/* The CPC must be initialized before any components with capabilities.     */
/* Any components with capabilities must register them at initialisation    */
/* time.  The SC must be initialized after any components with              */
/* capabilities.                                                            */
/*                                                                          */
/* PARAMETERS:                                                              */
/* localID - local ID of the person we are interested in.                   */
/* pSizeOfCaps - pointer to variable to be filled in with the size of the   */
/* combined capabilities structure returned as ppCaps.                      */
/*                                                                          */
/* ppCaps - pointer to variable to be filled in with the pointer to the     */
/* combined capabilities structure containing capabilities passed to        */
/* CPC_RegisterCapabilities.                                                */
/****************************************************************************/
void RDPCALL SHCLASS CPC_GetCombinedCapabilities(
         LOCALPERSONID             localID,
         PUINT                     pSizeOfCaps,
         PTS_COMBINED_CAPABILITIES *ppCaps)
{
    unsigned i;
    PTS_CAPABILITYHEADER pNextCaps;
    PTS_COMBINED_CAPABILITIES pCaps;
    unsigned numCaps;

    DC_BEGIN_FN("CPC_GetCombinedCapabilities");

    /************************************************************************/
    /* Try to find the requested capabilitiesID for this person.            */
    /*                                                                      */
    /* If the localID refers to the local system then search the combined   */
    /* capabilities structure (ie all capabilities registered with          */
    /* CPC_RegisterCapabilities).  Otherwise search the structure we        */
    /* received from the remote person.                                     */
    /************************************************************************/
    if (localID == SC_LOCAL_PERSON_ID) {
        pCaps = cpcLocalCombinedCaps;
        numCaps = cpcLocalCombinedCaps->numberCapabilities;
        
#ifdef DC_DEBUG
        /************************************************************************/
        /* Set our flag we use to check that CPC_Register is not called after   */
        /* this function has been called.                                       */
        /************************************************************************/
        cpcLocalCombinedCapsQueried = TRUE;
#endif

    }
    else {
        if (cpcRemoteCombinedCaps[localID - 1] != NULL) {
            pCaps = cpcRemoteCombinedCaps[localID - 1];
            numCaps = cpcRemoteCombinedCaps[localID - 1]->numberCapabilities;
        }
        else {
            TRC_ERR((TB, "Capabilities pointer is NULL"));

            *pSizeOfCaps = 0;
            *ppCaps = NULL;
            DC_QUIT;
        }
    }

    /************************************************************************/
    /* Search for the end of the capabilities structure for the local       */
    /* party.                                                               */
    /************************************************************************/
    TRC_DBG((TB, "Caps:"));
    pNextCaps = (PTS_CAPABILITYHEADER)&(pCaps->data[0]);

    for (i = 0; i < numCaps; i++) {
        TRC_DBG((TB, "caps size %hd", pNextCaps->lengthCapability));
        TRC_DBG((TB, "caps ID %hd", pNextCaps->capabilitySetType));

        pNextCaps = (PTS_CAPABILITYHEADER)( (PBYTE)pNextCaps
                                 + pNextCaps->lengthCapability );
    }

    *pSizeOfCaps = (unsigned)((PBYTE)pNextCaps - (PBYTE)pCaps);
    *ppCaps = pCaps;
    TRC_NRM((TB, "Total size %d", *pSizeOfCaps));

DC_EXIT_POINT:
    DC_END_FN();
}


/****************************************************************************/
/* CPC_SetCombinedCapabilities(..)                                          */
/*                                                                          */
/* Used by a shadow stack to initialize the combined capabilities to the    */
/* values negotiated so far by its predecessors.                            */
/****************************************************************************/
void RDPCALL SHCLASS CPC_SetCombinedCapabilities(
                                     UINT                      cbSizeOfCaps,
                                     PTS_COMBINED_CAPABILITIES pCaps)
{
    unsigned i;
    PTS_CAPABILITYHEADER pNextCaps;

    DC_BEGIN_FN("CPC_SetCombinedCapabilities");

    /************************************************************************/
    /* Replace the existing capability set with the new values              */
    /************************************************************************/
    cpcLocalCombinedCaps->numberCapabilities = 0;
    pNextCaps = (PTS_CAPABILITYHEADER)&(pCaps->data[0]);
    
    TRC_NRM((TB, "Caps:"));
    for (i = 0; i < pCaps->numberCapabilities; i++) {
        CPC_RegisterCapabilities(pNextCaps, pNextCaps->lengthCapability);

        pNextCaps = (PTS_CAPABILITYHEADER)( (PBYTE)pNextCaps
                                 + pNextCaps->lengthCapability );
    }

    TRC_ALT((TB, "Capability bytes accepted: %ld / %ld", 
            (unsigned)((PBYTE)pNextCaps - (PBYTE)cpcLocalCombinedCaps),
            cbSizeOfCaps));

    DC_END_FN();
}


/****************************************************************************/
/* API FUNCTION: CPC_PartyJoiningShare()                                    */
/*                                                                          */
/* Capabilities Coordinator function called when a new party is joining the */
/* share.                                                                   */
/*                                                                          */
/* Note that the capabilities data <pCapsData> is still in wire format      */
/* (Intel byte order) when CPC_PartyJoiningShare is called.                 */
/*                                                                          */
/* PARAMETERS:                                                              */
/*                                                                          */
/* personID - local person ID of remote person joining the share.           */
/*                                                                          */
/* oldShareSize - the number of the parties which were in the share (ie     */
/* excludes the joining party).                                             */
/*                                                                          */
/* sizeOfCapsData - size of the data pointed to by pCapsData.               */
/*                                                                          */
/* pCapsData - pointer to capabilities (returned by the person's            */
/* CPC_GetCombinedCapabilities) data for NET_EV_PERSON_ADDs.  For the other */
/* events this is NULL.                                                     */
/*                                                                          */
/* RETURNS: TRUE if the party can join the share.                           */
/*          FALSE if the party can NOT join the share.                      */
/****************************************************************************/
BOOL RDPCALL SHCLASS CPC_PartyJoiningShare(
        LOCALPERSONID personID,
        unsigned      oldShareSize,
        unsigned      sizeOfCapsData,
        PVOID         pCapsData)
{
    PTS_COMBINED_CAPABILITIES pCombinedCaps;
    PBYTE  pCaps;
    PBYTE  pSavedCaps;
    BOOL   rc = TRUE;
    int    i;
    UINT32 sizeOfCaps = FIELDOFFSET(TS_COMBINED_CAPABILITIES, data);
    UINT32 work;

    DC_BEGIN_FN("CPC_PartyJoiningShare");
    DC_IGNORE_PARAMETER(oldShareSize)

    /************************************************************************/
    /* Allow ourself to be added to the share, but do nothing else.         */
    /************************************************************************/
    if (personID == SC_LOCAL_PERSON_ID) {
        TRC_DBG((TB, "Ignore adding self to share"));
        DC_QUIT;
    }

    /************************************************************************/
    /* Calculate actual space required to save capabilities                 */
    /************************************************************************/
    // First we check if actually can deref the numberCapabilities member. 
    // We should have enough bytes till up to the data meber.
    if(sizeOfCapsData < FIELDOFFSET(TS_COMBINED_CAPABILITIES, data)){
            TRC_ERR((TB, "Buffer too small to fit a combined caps structure: %d", sizeOfCapsData));
            WDW_LogAndDisconnect(m_pTSWd, TRUE, Log_RDP_CapabilitySetTooSmall,
                    (PBYTE)pCapsData, sizeOfCapsData);
            rc = FALSE;
            DC_QUIT;
    }
    
    pCombinedCaps = (PTS_COMBINED_CAPABILITIES)pCapsData;
    pCaps = (PBYTE)pCombinedCaps->data;

    for (i = 0; i < pCombinedCaps->numberCapabilities; i++) {
    // here we check if we still have left  TS_CAPABILITYHEADER length worth of data
    // we can't just deref the length member without checking that we actually have 
    // enough buffer for a TS_CAPABILITYHEADER
    if ((PBYTE)pCaps + sizeof(TS_CAPABILITYHEADER) > 
                     (PBYTE)pCapsData + sizeOfCapsData) {
        TRC_ERR((TB, "Not enough space left for a capability header: %d",
                                sizeOfCapsData-(pCaps-(PBYTE)pCapsData) ));
        WDW_LogAndDisconnect(m_pTSWd, TRUE, Log_RDP_CapabilitySetTooSmall,
                (PBYTE)pCapsData, sizeOfCapsData);
        rc = FALSE;
        DC_QUIT;
    }
    
    work = (UINT32)(((PTS_CAPABILITYHEADER)pCaps)->lengthCapability);
    
    /********************************************************************/
    /* Reject capability sets whose length is too small to contain any  */
    /* data                                                             */
    /********************************************************************/
    if (work <= sizeof(TS_CAPABILITYHEADER)) {
        TRC_ERR((TB, "Capability set too small: %d", work));
        WDW_LogAndDisconnect(m_pTSWd, TRUE, Log_RDP_CapabilitySetTooSmall,
                (PBYTE)pCapsData, sizeOfCapsData);
        rc = FALSE;
        DC_QUIT;
    }
    
    /********************************************************************/
    /* Reject capability sets whose length would overrun the end of the */
    /* packet.                                                          */
    /********************************************************************/
    if ((pCaps+work> (PBYTE)pCapsData + sizeOfCapsData) ||
         (pCaps+work < (PBYTE)pCaps)) {
        TRC_ERR((TB, "Capability set too large: %d", work));
        WDW_LogAndDisconnect(m_pTSWd, TRUE, Log_RDP_CapabilitySetTooLarge,
                (PBYTE)pCapsData, sizeOfCapsData);
        rc = FALSE;
        DC_QUIT;
    }
   
    pCaps += work;

    work = (UINT32)DC_ROUND_UP_4(work);
    sizeOfCaps += work;
    }
    
    TRC_NRM((TB, "Caps size: passed %d, actual %d", sizeOfCapsData,
             sizeOfCaps));

    /************************************************************************/
    /* Allocate the space for this person's capabilities.                   */
    /************************************************************************/
    cpcRemoteCombinedCaps[personID - 1] =
            (PTS_COMBINED_CAPABILITIES)COM_Malloc(sizeOfCaps);
    if (cpcRemoteCombinedCaps[personID - 1] == NULL) {
        /********************************************************************/
        /* This party cannot join the share.                                */
        /********************************************************************/
        TRC_NRM((TB, "Failed to get %d bytes for personID %d caps",
               sizeOfCapsData,
               personID));

        rc = FALSE;
        DC_QUIT;
    }
    TRC_DBG((TB, "Allocated %d bytes for personID %d caps",
            sizeOfCapsData,
            personID));

    /************************************************************************/
    /* Initialize the memory to zero. Otherwise we can get little gaps of   */
    /* garbage - which can be interpreted as valid capabilities - when      */
    /* copying non-end-padded capability entries from the remote party's    */
    /* data.                                                                */
    /************************************************************************/
    memset(cpcRemoteCombinedCaps[personID-1], 0, sizeOfCaps);

    /************************************************************************/
    /* Copy the combined capabilities data.                                 */
    /************************************************************************/
    /************************************************************************/
    /* Copy the combined capabilities header                                */
    /************************************************************************/
    memcpy( cpcRemoteCombinedCaps[personID-1],
               pCapsData, FIELDOFFSET(TS_COMBINED_CAPABILITIES, data));

    /************************************************************************/
    /* Loop through capabilities, copying them to 4-byte aligned positions  */
    /************************************************************************/
    pSavedCaps = (PBYTE)(cpcRemoteCombinedCaps[personID-1]->data);
    pCaps = (PBYTE)((PBYTE)pCapsData +
            FIELDOFFSET(TS_COMBINED_CAPABILITIES, data));
    for (i = 0; i < pCombinedCaps->numberCapabilities; i++) {
        work = (UINT32)(((PTS_CAPABILITYHEADER)pCaps)->lengthCapability);
        memcpy( pSavedCaps, pCaps, work);
        pCaps += work;
        work = (UINT32)DC_ROUND_UP_4(work);
        ((PTS_CAPABILITYHEADER)pSavedCaps)->lengthCapability = (UINT16)work;
        pSavedCaps += work;
    }

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}


/****************************************************************************/
/* API FUNCTION: CPC_PartyLeftShare()                                       */
/*                                                                          */
/* Capabilities Coordinator function called when a party has left the       */
/* share.                                                                   */
/*                                                                          */
/* PARAMETERS:                                                              */
/* personID - local person ID of remote person leaving the share.           */
/*                                                                          */
/* newShareSize - the number of the parties now in the share (ie excludes   */
/* the leaving party).                                                      */
/****************************************************************************/
void RDPCALL SHCLASS CPC_PartyLeftShare(LOCALPERSONID locPersonID,
                                        unsigned          newShareSize)
{
    DC_BEGIN_FN("CPC_PartyLeftShare");

    DC_IGNORE_PARAMETER(newShareSize)

    /************************************************************************/
    /* If this is ourself leaving the share do nothing.                     */
    /************************************************************************/
    if (locPersonID != SC_LOCAL_PERSON_ID) {
        // Free this party's capabilities from the array and mark the entry
        // as invalid.
        if (cpcRemoteCombinedCaps[locPersonID - 1] != NULL) {
            COM_Free((PVOID)cpcRemoteCombinedCaps[locPersonID-1]);
            cpcRemoteCombinedCaps[locPersonID - 1] = NULL;
        }
    }

    DC_END_FN();
}


/****************************************************************************/
/* FUNCTION: CPCGetCapabilities                                             */
/*                                                                          */
/* Returns the capabilities for one person.                                 */
/*                                                                          */
/* PARAMETERS:                                                              */
/* localID        - local ID of person (0 == local person)                  */
/* capabilitiesID - the ID of the capabilities (group structure) to be      */
/*                  queried.                                                */
/*                                                                          */
/* RETURNS:                                                                 */
/* Pointer to a structure containing the capabilities ID, the size of the   */
/* capabilities, and any number of capability fields.                       */
/*                                                                          */
/* If the person has no capabilities with capabilitiesID, a NULL pointer is */
/* returned.                                                                */
/****************************************************************************/
PTS_CAPABILITYHEADER RDPCALL SHCLASS CPCGetCapabilities(
        LOCALPERSONID localID,
        unsigned      capabilitiesID)
{
    unsigned i;
    unsigned numCaps;
    PTS_CAPABILITYHEADER pCaps;
    PTS_CAPABILITYHEADER rc = NULL;

    DC_BEGIN_FN("CPCGetCapabilities");

    /************************************************************************/
    /* Try to find the requested capabilitiesID for this person.            */
    /*                                                                      */
    /* If the localID refers to the local system then search the combined   */
    /* capabilities structure (ie all capabilities registered with          */
    /* CPC_RegisterCapabilities).  Otherwise search the structure we        */
    /* received from the remote person.                                     */
    /************************************************************************/
    if (localID == 0) {
        pCaps = (PTS_CAPABILITYHEADER)&(cpcLocalCombinedCaps->data[0]);
        numCaps = cpcLocalCombinedCaps->numberCapabilities;
    }
    else {
        if (cpcRemoteCombinedCaps[localID-1] == NULL)
        {
            TRC_ERR((TB, "Capabilities pointer is NULL"));
            DC_QUIT;
        }
        pCaps = (PTS_CAPABILITYHEADER)
                                 &(cpcRemoteCombinedCaps[localID-1]->data[0]);
        numCaps = cpcRemoteCombinedCaps[localID-1]->numberCapabilities;
    }

    for (i = 0; i < numCaps; i++) {
        if (pCaps->capabilitySetType == capabilitiesID) {
            /****************************************************************/
            /* We have found the capabilities structure requested.  Return  */
            /* the address of the capabilities.                             */
            /****************************************************************/
            TRC_DBG((TB, "Found %d bytes of caps ID %d localID %d",
                    pCaps->lengthCapability,
                    capabilitiesID,
                    localID));
            rc = pCaps;
            break;
        }
        pCaps = (PTS_CAPABILITYHEADER)( (PBYTE)pCaps +
                                 pCaps->lengthCapability );
    }

    if (rc == NULL) {
        TRC_NRM((TB, " local ID = %u : No caps found for ID %d",
                (unsigned)localID,
                capabilitiesID));
    }

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\acaapi.cpp ===
/****************************************************************************/
// acaapi.cpp
//
// RDP Control Arbitrator API functions
//
// Copyright (C) Microsoft, PictureTel 1993-1997
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop

#define TRC_FILE "acaapi"
#include <adcg.h>

#include <as_conf.hpp>

/****************************************************************************/
/* API FUNCTION: CA_Init                                                    */
/*                                                                          */
/* Called to initialize the CA.                                             */
/****************************************************************************/
void RDPCALL SHCLASS CA_Init(void)
{
    DC_BEGIN_FN("CA_Init");

#define DC_INIT_DATA
#include <acadata.c>
#undef DC_INIT_DATA

    // Set local node initial state to detached.
    caStates[0] = CA_STATE_DETACHED;

    DC_END_FN();
}


/****************************************************************************/
// CA_ReceivedPacket
//
// Handles control PDUs inbound from the client.
/****************************************************************************/
void RDPCALL SHCLASS CA_ReceivedPacket(
        PTS_CONTROL_PDU pControlPDU,
        unsigned        DataLength,
        LOCALPERSONID   personID)
{
    DC_BEGIN_FN("CA_ReceivedPacket");

    // Ensure we can access the header.
    if (DataLength >= sizeof(TS_CONTROL_PDU)) {
        TRC_NRM((TB, "[%u] Packet:%d", personID, pControlPDU->action));

        switch (pControlPDU->action) {
            case TS_CTRLACTION_REQUEST_CONTROL:
                CAEvent(CA_EVENTI_TRY_GIVE_CONTROL, (UINT32)personID);
                break;

            case TS_CTRLACTION_COOPERATE:
                CAEvent(CA_EVENTI_REMOTE_COOPERATE, (UINT32)personID);
                break;

            default:
                // An invalid action - log and disconnect the Client.
                TRC_ERR((TB, "Invalid CA msg %d", pControlPDU->action));
                WDW_LogAndDisconnect(m_pTSWd, TRUE, Log_RDP_InvalidControlPDUAction,
                        (BYTE *)&(pControlPDU->action),
                        sizeof(pControlPDU->action));
                break;
        }
    }
    else {
        TRC_ERR((TB,"Data length %u too short for control header",
                DataLength));
        WDW_LogAndDisconnect(m_pTSWd, TRUE, Log_RDP_ShareDataTooShort,
                (BYTE *)pControlPDU, DataLength);
    }

    DC_END_FN();
}


/****************************************************************************/
/* API FUNCTION: CA_PartyJoiningShare                                       */
/*                                                                          */
/* Called when a new party is joining the share                             */
/*                                                                          */
/* PARAMETERS:                                                              */
/* personID - the ID of the new party.                                      */
/* oldShareSize - the number of the parties which were in the share (ie     */
/*     excludes the joining party).                                         */
/*                                                                          */
/* RETURNS:                                                                 */
/* TRUE - the CA can accept the new party                                   */
/* FALSE - the CA cannot accept the new party                               */
/****************************************************************************/
BOOL RDPCALL SHCLASS CA_PartyJoiningShare(
        LOCALPERSONID personID,
        unsigned      oldShareSize)
{
    DC_BEGIN_FN("CA_PartyJoiningShare");

    /************************************************************************/
    // Check for share start, do some init if need be.
    /************************************************************************/
    if (oldShareSize == 0) {
        // Enter cooperate mode then viewing.  Note that we don't send
        // a message now (we will send one when we process a CA_SyncNow call).
        CAEvent(CA_EVENTI_ENTER_COOP_MODE, CA_DONT_SEND_MSG);
        CAEvent(CA_EVENTI_ENTER_VIEWING_MODE, 0);
        caWhoHasControlToken = (LOCALPERSONID)-1;
    }

    // Set new node state to detached -- we should receive a CA packet
    // to tell us what the remote state really is before we receive any IM
    // packets. But just in case, choosing detached is the safest as it has
    // least priveleges. Note that we will not enable the shadow cursors
    // until (and if) we get a CA packet to tell us the remote system is
    // detached.
    caStates[personID] = CA_STATE_DETACHED;

    DC_END_FN();
    return TRUE;
}


/****************************************************************************/
/* API FUNCTION: CA_PartyLeftShare                                          */
/*                                                                          */
/* Called when a party has left the share.                                  */
/*                                                                          */
/* PARAMETERS:                                                              */
/* personID - the local ID of the new party.                                */
/* newShareSize - the number of the parties now in the share (ie excludes   */
/*     the leaving party).                                                  */
/****************************************************************************/
void RDPCALL SHCLASS CA_PartyLeftShare(
        LOCALPERSONID personID,
        unsigned      newShareSize)
{
    DC_BEGIN_FN("CA_PartyLeftShare");

    // Just ensure their state is left as detached for safety.
    caStates[personID] = CA_STATE_DETACHED;

    DC_END_FN();
}


/****************************************************************************/
/* API FUNCTION: CA_SyncNow                                                 */
/*                                                                          */
/* Called by the TT to signal the beginning of a sync.                      */
/****************************************************************************/
void RDPCALL SHCLASS CA_SyncNow(void)
{
    DC_BEGIN_FN("CA_SyncNow");

    /************************************************************************/
    /* Tell the world we're cooperating.                                    */
    /************************************************************************/
    TRC_NRM((TB, "Send cooperate"));
    CAFlushAndSendMsg(TS_CTRLACTION_COOPERATE, 0, 0);

    DC_END_FN();
}


/****************************************************************************/
/* FUNCTION: CASendMsg                                                      */
/*                                                                          */
/* Sends a CA message to remote system                                      */
/****************************************************************************/
__inline BOOL RDPCALL SHCLASS CASendMsg(
        UINT16 msg,
        UINT16 data1,
        UINT32 data2)
{
    NTSTATUS status;
    PTS_CONTROL_PDU pControlPDU;

    DC_BEGIN_FN("CASendMsg");

    status = SC_AllocBuffer((PPVOID)&pControlPDU, sizeof(TS_CONTROL_PDU));
    if ( STATUS_SUCCESS == status ) {
        // Set up the packet header for a request message
        pControlPDU->shareDataHeader.pduType2 = TS_PDUTYPE2_CONTROL;
        pControlPDU->action    = msg;
        pControlPDU->grantId   = data1;
        pControlPDU->controlId = data2;

        SC_SendData((PTS_SHAREDATAHEADER)pControlPDU,
                sizeof(TS_CONTROL_PDU),
                sizeof(TS_CONTROL_PDU),
                PROT_PRIO_MISC,
                0);

    }
    else {
        TRC_NRM((TB, "Failed to allocate packet %d", msg));

        // Continue periodic scheduling.
        SCH_ContinueScheduling(SCH_MODE_NORMAL);
    }

    DC_END_FN();
    return STATUS_SUCCESS == status;
}


/****************************************************************************/
/* FUNCTION: CAFlushAndSendMsg                                              */
/*                                                                          */
/* This function will attempt to flush any outstanding CA messages and send */
/* the supplied message.  This function relies on the CA messages being     */
/* contiguous between TS_CTRLACTION_FIRST and TS_CTRLACTION_LAST.  If it    */
/* fails to send the message then it will set a flag to remember it is      */
/* pending and continue to try to send the message every time it is called. */
/*                                                                          */
/* PARAMETERS:                                                              */
/* msg - the message to be sent.  If this is CA_NO_MESSAGE then the         */
/* function only attempts to send outstanding messages.                     */
/*                                                                          */
/* data1, data2 - the data for the extra fields in the message.             */
/*                                                                          */
/* RETURNS: TRUE or FALSE - whether the supplied message was sent           */
/****************************************************************************/
BOOL RDPCALL SHCLASS CAFlushAndSendMsg(
        UINT16 msg,
        UINT16 GrantID,
        UINT32 ControlID)
{
    BOOL rc;
    int  i;

    DC_BEGIN_FN("CAFlushAndSendMsg");

    /************************************************************************/
    /* The order messages get sent is not important - merely that they get  */
    /* sent as soon as possible whilst the conditions which triggered our   */
    /* intial attempt to send them are still valid (ie if we try to send a  */
    /* TS_CTRLACTION_COOPERATE we drop a pending TS_CTRLACTION_DETACH if    */
    /* there is one - see CAEvent).  This means we can just ensure that the */
    /* pending flag is set for our current event and then try to send all   */
    /* pending events.  The other important point about CA messages is that */
    /* the only one which can be sent out repeatedly is a                   */
    /* TS_CTRLACTION_REQUEST_CONTROL.  We effectively give that the lowest  */
    /* priority by looking through our array of pending flags backwards so  */
    /* that even if it is repeating and we can only ever get one packet     */
    /* here we will send the other messages (although it is unlikely that   */
    /* they'll be generated whilst we are requesting control).              */
    /************************************************************************/

    /************************************************************************/
    /* Set the pending flag for the current message                         */
    /************************************************************************/
    if (msg >= TS_CTRLACTION_FIRST && msg <= TS_CTRLACTION_LAST) {
        caPendingMessages[msg - TS_CTRLACTION_FIRST].pending = TRUE;
        caPendingMessages[msg - TS_CTRLACTION_FIRST].grantId = GrantID;
        caPendingMessages[msg - TS_CTRLACTION_FIRST].controlId = ControlID;
    }
    else {
        TRC_ASSERT((msg == CA_NO_MESSAGE),(TB,"Invalid msg"));
    }

    /************************************************************************/
    /* Now flush out the pending messages.                                  */
    /************************************************************************/
    for (i = (TS_CTRLACTION_LAST - TS_CTRLACTION_FIRST); i >= 0; i--) {
        if (caPendingMessages[i].pending) {
            // Try to send this message.
            if (CASendMsg((UINT16)(i + TS_CTRLACTION_FIRST),
                          caPendingMessages[i].grantId,
                          caPendingMessages[i].controlId)) {
                caPendingMessages[i].pending = FALSE;

                if (i == (TS_CTRLACTION_GRANTED_CONTROL -
                        TS_CTRLACTION_FIRST)) {
                    // When we successfully send a granted message to another
                    // party then we relinquish control and must issue a
                    // 'given control' event.
                    if (caPendingMessages[i].grantId !=
                            SC_GetMyNetworkPersonID()) {
                        CAEvent(CA_EVENTI_GIVEN_CONTROL,
                                (UINT32)SC_NetworkIDToLocalID(
                                caPendingMessages[i].grantId));
                    }
                }
            }
            else {
                // It didn't work so break out and don't try to send any
                // more messages.
                break;
            }
        }
    }

    /************************************************************************/
    /* Now return the status according to whether we sent the message that  */
    /* we were called with.                                                 */
    /************************************************************************/
    if (msg != CA_NO_MESSAGE)
        rc = !caPendingMessages[msg - TS_CTRLACTION_FIRST].pending;
    else
        rc = TRUE;

    DC_END_FN();
    return rc;
}


/****************************************************************************/
/* FUNCTION: CAEvent                                                        */
/*                                                                          */
/* Called from many CA functions to manage various inputs.                  */
/*                                                                          */
/* PARAMETERS:                                                              */
/* caEvent - the event, the possible events are (the meaning of the         */
/* additionalData parameter if any is given in brackets)                    */
/*                                                                          */
/*  The possible events for CA_Event plus                                   */
/*                                                                          */
/*  CA_EVENTI_REQUEST_CONTROL                                               */
/*  CA_EVENTI_TRY_GIVE_CONTROL(person ID of party requesting control)       */
/*  CA_EVENTI_GIVEN_CONTROL(person ID who we gave control to)               */
/*  CA_EVENTI_GRANTED_CONTROL(person ID of the party granted control)       */
/*  CA_EVENTI_ENTER_DETACHED_MODE                                           */
/*  CA_EVENTI_ENTER_COOPERATING_MODE                                        */
/*  CA_EVENTI_ENTER_CONTROL_MODE                                            */
/*  CA_EVENTI_ENTER_VIEWING_MODE                                            */
/*  CA_EVENTI_REMOTE_DETACH(person ID of remote party)                      */
/*  CA_EVENTI_REMOTE_COOPERATE(person ID of remote party)                   */
/*  CA_EVENTI_GRAB_CONTROL                                                  */
/*                                                                          */
/* additionalData - depends on the caEvent, see above.                      */
/****************************************************************************/
void RDPCALL SHCLASS CAEvent(
        unsigned caEvent,
        UINT32   additionalData)
{
    LOCALPERSONID i;

    DC_BEGIN_FN("CAEvent");

    TRC_NRM((TB, "Processing event - %d(%04lX)", caEvent, additionalData));

    switch (caEvent)
    {
        case CA_EVENT_OLD_UNATTENDED:
        case CA_EVENT_CANT_CONTROL:
        case CA_EVENT_BEGIN_UNATTENDED:
        case CA_EVENT_TAKE_CONTROL:
        case CA_EVENT_DETACH_CONTROL:
        case CA_EVENTI_REQUEST_CONTROL:
        case CA_EVENTI_REMOTE_DETACH:
        case CA_EVENTI_GRAB_CONTROL:
        case CA_EVENTI_GRANTED_CONTROL:
        case CA_EVENTI_ENTER_DETACHED_MODE:
        case CA_EVENTI_ENTER_CONTROL_MODE:
            /****************************************************************/
            /* we don't expect to get any of these                          */
            /****************************************************************/
            TRC_ALT((TB, "Nonsensical CA event %d", caEvent));
            break;


        case CA_EVENTI_TRY_GIVE_CONTROL:
        {
            NETPERSONID destPersonID;

            /****************************************************************/
            /* always try to give up control                                */
            /****************************************************************/
            destPersonID = SC_LocalIDToNetworkID(
                    (LOCALPERSONID)additionalData);

            /****************************************************************/
            /* Give control to the destPersonID.  If this fails             */
            /* CAFlushAndSendMsg will remember for us and retry.            */
            /****************************************************************/
            CAFlushAndSendMsg(TS_CTRLACTION_GRANTED_CONTROL,
                    (UINT16)destPersonID, SC_GetMyNetworkPersonID());

            break;
        }


        case CA_EVENTI_GIVEN_CONTROL:
            /****************************************************************/
            /* Now update our globals.                                      */
            /****************************************************************/
            caWhoHasControlToken = (LOCALPERSONID)additionalData;

            /****************************************************************/
            /* make sure we go to viewing                                   */
            /****************************************************************/
            CAEvent(CA_EVENTI_ENTER_VIEWING_MODE, 0);

            /****************************************************************/
            /* Update the state for the person we gave control to (as we    */
            /* will not see the GRANTED message).                           */
            /****************************************************************/
            i = (LOCALPERSONID)additionalData;
            if (caStates[i] == CA_STATE_VIEWING)
                caStates[i] = CA_STATE_IN_CONTROL;

            break;


        case CA_EVENTI_ENTER_COOP_MODE:
            /****************************************************************/
            /* Notify the remote system that we are cooperating - forget    */
            /* about any detach messages we've been unable to send.  If     */
            /* we fail to send the message now then CAFlushAndSendMsg will  */
            /* remember and retry for us.  We will enter cooperating state  */
            /* anyway.                                                      */
            /****************************************************************/
            caPendingMessages[TS_CTRLACTION_DETACH - TS_CTRLACTION_FIRST].
                    pending = FALSE;
            if (additionalData != CA_DONT_SEND_MSG)
                CAFlushAndSendMsg(TS_CTRLACTION_COOPERATE, 0, 0);
            break;


        case CA_EVENTI_ENTER_VIEWING_MODE:
            // Change to viewing state.
            caStates[0] = CA_STATE_VIEWING;
            break;

        case CA_EVENTI_REMOTE_COOPERATE:
            TRC_NRM((TB, "Person %d (Local) is cooperating", additionalData));

            /****************************************************************/
            /* Make the state change                                        */
            /****************************************************************/
            if (caWhoHasControlToken == (LOCALPERSONID)additionalData)
                caStates[additionalData] = CA_STATE_IN_CONTROL;
            else
                caStates[additionalData] = CA_STATE_VIEWING;
            break;


        case CA_EVENT_COOPERATE_CONTROL:
            TRC_ALT((TB, "Nonsensical CA event %d", caEvent));
#ifdef Unused
            /****************************************************************/
            /* need to change to viewing mode after leaving detached mode   */
            /****************************************************************/
            CAEvent(CA_EVENTI_ENTER_COOP_MODE, 0);

            /****************************************************************/
            /* Enter viewing mode.                                          */
            /****************************************************************/
            CAEvent(CA_EVENTI_ENTER_VIEWING_MODE, 0);
#endif
            break;


        default:
            TRC_ERR((TB, "Unrecognised event - %d", caEvent));
            break;
    }

    DC_END_FN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\acomapi.c ===
/****************************************************************************/
// acomapi.c
//
// RDP common functions API implemtation.
//
// Copyright (C) Microsoft, PictureTel 1992-1997
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#include <precomp.h>
#pragma hdrstop

#define pTRCWd pTSWd
#define TRC_FILE "acomapi"

#include <adcg.h>
#include <acomapi.h>
#include <nwdwapi.h>
#include <regapi.h>


/****************************************************************************/
/* Name:      COM_OpenRegistry                                              */
/*                                                                          */
/* Purpose:   Opens the given registry key relative to the WinStation       */
/*            key name. Calls to COM_ReadProfxxx use the resulting handle.  */
/*                                                                          */
/* Returns:   TRUE on success; FALSE otherwise                              */
/*                                                                          */
/* Params:    pTSWd    - handle to WD data                                  */
/*            pSection - name of section to open. This is appended to a     */
/*                base key defined in the COM_MAKE_SUBKEY macro             */
/****************************************************************************/
BOOL RDPCALL COM_OpenRegistry(PTSHARE_WD pTSWd, PWCHAR pSection)
{
    NTSTATUS          status;
    WCHAR             subKey[MAX_PATH];
    BOOL              rc = FALSE;
    UNICODE_STRING    registryPath;
    OBJECT_ATTRIBUTES objAttribs;

    DC_BEGIN_FN("COM_OpenRegistry");

    /************************************************************************/
    /* Do some checks                                                       */
    /************************************************************************/
    TRC_ASSERT((sizeof(pTSWd->WinStationRegName) ==
                             ((WINSTATIONNAME_LENGTH + 1) * sizeof(WCHAR))),
               (TB, "WinStationRegName doesn't appear to be Unicode"));
    TRC_ASSERT((pSection != NULL), (TB, "NULL pointer to section name"));

    /************************************************************************/
    /* Don't do this if someone has forgotten to close a key beforehand     */
    /************************************************************************/
    if (!pTSWd->regAttemptedOpen) {
        // Construct the complete registry path.
        swprintf(subKey, L"\\Registry\\Machine\\%s\\%s\\%s",
                WINSTATION_REG_NAME, pTSWd->WinStationRegName, pSection);

        RtlInitUnicodeString(&registryPath, subKey);

        // Try to open the key.
        InitializeObjectAttributes(&objAttribs,
                                   &registryPath,        // name
                                   OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, // attributes
                                   NULL,                 // root
                                   NULL);                // sec descriptor

        pTSWd->regAttemptedOpen = TRUE;

        status = ZwOpenKey(&(pTSWd->regKeyHandle),
                           KEY_ALL_ACCESS,
                           &objAttribs);

        if (status == STATUS_SUCCESS) {
            TRC_NRM((TB, "Opened key '%S'", subKey));
            rc = TRUE;
        }
        else {
            // The subkey probably doesn't exist.
            TRC_ALT((TB, "Couldn't open key '%S', rc = 0x%lx", subKey, status));
            pTSWd->regKeyHandle = NULL;
        }
    }
    else {
        TRC_ERR((TB, "COM_OpenRegistry called twice "
                                        "without calling COM_CloseRegistry"));
    }

    DC_END_FN();
    return rc;
} /* COM_OpenRegistry */


/****************************************************************************/
/* Name:      COM_CloseRegistry                                             */
/*                                                                          */
/* Purpose:   Closes registry key that was opened with COM_OpenRegistry     */
/****************************************************************************/
void RDPCALL COM_CloseRegistry(PTSHARE_WD pTSWd)
{
    NTSTATUS status;

    DC_BEGIN_FN("COM_CloseRegistry");

    if (pTSWd->regAttemptedOpen)
    {
        /********************************************************************/
        /* Close the registry only if our original open was successful      */
        /********************************************************************/
        if (pTSWd->regKeyHandle != NULL)
        {
            status = ZwClose(pTSWd->regKeyHandle);
            if (status != STATUS_SUCCESS)
            {
                TRC_ERR((TB, "Error closing registry key, rc = 0x%lx", status));
            }

            pTSWd->regKeyHandle = NULL;
        }
        else
        {
            TRC_NRM((TB, "Not closing key because open wasn't successful"));
        }

        pTSWd->regAttemptedOpen = FALSE;
    }
    else
    {
        TRC_ERR((TB, "Tried to close registry without opening it"));
    }

    DC_END_FN();
} /* COM_CloseRegistry */


/****************************************************************************/
/* Name:      COM_ReadProfInt32                                             */
/*                                                                          */
/* Purpose:   Reads a named value from the registry section opened          */
/*            previously with COM_OpenRegistry                              */
/*                                                                          */
/* Params:    pTSWd        - pointer to WD data structure                   */
/*            pEntry       - name of value to read                          */
/*            defaultValue - default to return if there's a problem         */
/*            pValue       - pointer to memory in which to return the value */
/****************************************************************************/
void RDPCALL COM_ReadProfInt32(PTSHARE_WD pTSWd,
                               PWCHAR     pEntry,
                               INT32      defaultValue,
                               long       *pValue)
{
    NTSTATUS Status;

    DC_BEGIN_FN("COM_ReadProfInt32");

    /************************************************************************/
    /* Check for NULL parameters                                            */
    /************************************************************************/
    TRC_ASSERT((pEntry != NULL), (TB, "NULL pointer to entry name"));

    /************************************************************************/
    /* Read the profile entry.                                              */
    /************************************************************************/
    Status = COMReadEntry(pTSWd, pEntry, (PVOID)pValue, sizeof(INT32),
             REG_DWORD);
    if (Status != STATUS_SUCCESS) {
        /********************************************************************/
        /* We failed to read the value - copy in the default                */
        /********************************************************************/
        TRC_NRM((TB, "Failed to read int32 from '%S'. Using default.",
                     pEntry));
        *pValue = defaultValue;
    }

    TRC_NRM((TB, "Returning '%S' = %lu (0x%lx)",
                 pEntry, *pValue, *pValue));

    DC_END_FN();
} /* COM_ReadProfInt32 */


/****************************************************************************/
/* FUNCTION: COMReadEntry(...)                                              */
/*                                                                          */
/* Read an entry from the given section of the registry.  Allow type        */
/* REG_BINARY (4 bytes) if REG_DWORD was requested.                         */
/*                                                                          */
/* PARAMETERS:                                                              */
/* pEntry           : the entry name to read.                               */
/* pBuffer          : a buffer to read the entry to.                        */
/* bufferSize       : the size of the buffer.                               */
/* expectedDataType : the type of data stored in the entry.                 */
/****************************************************************************/
NTSTATUS RDPCALL COMReadEntry(PTSHARE_WD pTSWd,
                              PWCHAR     pEntry,
                              PVOID      pBuffer,
                              unsigned   bufferSize,
                              UINT32     expectedDataType)
{
    NTSTATUS                       rc;
    UNICODE_STRING                 valueName;
    UINT32                         keyInfoBuffer[16];
    PKEY_VALUE_PARTIAL_INFORMATION pKeyInfo;
    ULONG                          keyInfoLength;

    DC_BEGIN_FN("COMReadEntry");

    /************************************************************************/
    /* Can't do much if the registry isn't open                             */
    /************************************************************************/
    if (pTSWd->regAttemptedOpen && pTSWd->regKeyHandle != NULL) {
        // Try to read the value.  It may not exist.
        pKeyInfo = (PKEY_VALUE_PARTIAL_INFORMATION)keyInfoBuffer;
        RtlInitUnicodeString(&valueName, pEntry);
        rc = ZwQueryValueKey(pTSWd->regKeyHandle,
                             &valueName,
                             KeyValuePartialInformation,
                             pKeyInfo,
                             sizeof(keyInfoBuffer),
                             &keyInfoLength);

        if (rc != STATUS_SUCCESS) {
            TRC_DBG((TB, "Couldn't read key '%S', rc = 0x%lx",
                          pEntry, rc));
            DC_QUIT;
        }

        // Check there's enough buffer space for the value.
        if (pKeyInfo->DataLength <= bufferSize) {
            // Check that the type is correct.  Special case: allow REG_BINARY
            // instead of REG_DWORD, as long as the length is 32 bits.
            if ((pKeyInfo->Type == expectedDataType) ||
                    (pKeyInfo->Type == REG_BINARY &&
                    expectedDataType == REG_DWORD &&
                    pKeyInfo->DataLength != 4)) {
                memcpy(pBuffer, pKeyInfo->Data, pKeyInfo->DataLength);
            }
            else {
                TRC_ALT((TB, "Read value from %S, but type is %u - expected %u",
                             pEntry,
                             pKeyInfo->Type,
                             expectedDataType));
                rc = STATUS_DATA_ERROR;
            }
        }
        else {
            TRC_ERR((TB, "Not enough buffer space (%u) for value (%lu)",
                          bufferSize,
                          pKeyInfo->DataLength));
            rc = STATUS_BUFFER_OVERFLOW;
        }
    }
    else {
        if (!pTSWd->regAttemptedOpen)
            TRC_ERR((TB, "Tried to read from registry without opening it"));
        rc = STATUS_INVALID_HANDLE;
    }

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
} /* COMReadEntry */



#ifdef __cplusplus
}
#endif /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\adata.c ===
/****************************************************************************/
// adata.c
//
// Includes all XXXdata.c files for ShareClass.
//
// Copyright (C) 1996-2000 Microsoft Corporation
/****************************************************************************/

#include <abadata.c>
#include <abcdata.c>
#include <acadata.c>
#include <acmdata.c>
#include <acpcdata.c>
#include <ausrdata.c>
#include <adcsdata.c>
#include <aimdata.c>
#include <aoadata.c>
#include <aoedata.c>
#include <apmdata.c>
#include <asbcdata.c>
#include <ascdata.c>
#include <assidata.c>
#include <asdgdata.c>
#include <aupdata.c>
#include <nschdata.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\acpcdata.c ===
/****************************************************************************/
/* acpcdata.c                                                               */
/*                                                                          */
/* RDP Capabilities Coordinator Data                                        */
/*                                                                          */
/* Copyright(c) Microsoft, PictureTel 1992-1996                             */
/* Copyright(c) Microsoft 1997-1999                                         */
/****************************************************************************/

#include <ndcgdata.h>


#ifdef DC_DEBUG
DC_DATA(BOOLEAN, cpcLocalCombinedCapsQueried, FALSE);
#endif

/****************************************************************************/
/* The local combined capabilities which were registered using              */
/* CPC_RegisterCapabilities                                                 */
/****************************************************************************/
DC_DATA(PTS_COMBINED_CAPABILITIES, cpcLocalCombinedCaps, NULL);

/****************************************************************************/
/* The remote combined capabilities which have been received. These are     */
/* indexed by local personID - 1.                                           */
/****************************************************************************/
DC_DATA_ARRAY_NULL(PTS_COMBINED_CAPABILITIES, cpcRemoteCombinedCaps,
        SC_DEF_MAX_PARTIES, NULL);

// Local capabilities buffer.
DC_DATA_ARRAY_UNINIT(BYTE, cpcLocalCaps, CPC_MAX_LOCAL_CAPS_SIZE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\adcsdata.c ===
/****************************************************************************/
/* adcsdata.c                                                               */
/*                                                                          */
/* RDP main component data.                                                 */
/*                                                                          */
/* Copyright (c) Microsoft, PictureTel 1992-1997                            */
/* Copyright (c) 1997-1999 Microsoft Corp.                                  */
/****************************************************************************/

#include <ndcgdata.h>


DC_DATA(BOOLEAN, dcsInitialized, FALSE);
DC_DATA(BOOLEAN, dcsUserLoggedOn, FALSE);
DC_DATA(BOOLEAN, dcsUpdateShmPending, FALSE);
DC_DATA(BOOLEAN, dcsCallbackTimerPending, FALSE);
DC_DATA(UINT32,  dcsLastMiscTime, 0);
DC_DATA_NULL(ULARGE_INTEGER, dcsLastArcUpdateTime, 0);
DC_DATA_NULL(ULARGE_INTEGER, dcsMinArcUpdateInterval, 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\adcsapi.cpp ===
/****************************************************************************/
// adcsapi.cpp
//
// RDP top-level component API functions.
//
// Copyright (C) Microsoft Corp., PictureTel 1992-1997
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop

#define TRC_FILE "adcsapi"
#include <randlib.h>
#include <as_conf.hpp>
#include <asmapi.h>

/****************************************************************************/
/* API FUNCTION: DCS_Init                                                   */
/*                                                                          */
/* Initializes DCS.                                                         */
/*                                                                          */
/* PARAMETERS:                                                              */
/* pTSWd - TShare WD handle                                                 */
/* pSMHandle - SM handle                                                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* TRUE if DCS successfully initialized, FALSE otherwise.                   */
/****************************************************************************/
BOOL RDPCALL SHCLASS DCS_Init(PTSHARE_WD pTSWd, PVOID pSMHandle)
{
    BOOL rc = FALSE;
    unsigned retCode;
    TS_GENERAL_CAPABILITYSET GeneralCaps;
    long arcUpdateIntervalSeconds;
    UINT32 drawGdipSupportLevel;
    NTSTATUS Status;

    DC_BEGIN_FN("DCS_Init");

    TRC_ALT((TB, "Initializing Core!"));

#define DC_INIT_DATA
#include <adcsdata.c>
#undef DC_INIT_DATA

    dcsInitialized = TRUE;

    // Read the registry key for the draw gdiplus support control
    COM_OpenRegistry(pTSWd, WINSTATION_INI_SECTION_NAME);
    Status = COMReadEntry(pTSWd, L"DrawGdiplusSupportLevel", (PVOID)&drawGdipSupportLevel, sizeof(INT32),
             REG_DWORD);
    if (Status != STATUS_SUCCESS) {
        /********************************************************************/
        /* We failed to read the value - copy in the default                */
        /********************************************************************/
        TRC_ERR((TB, "Failed to read int32. Using default."));
        drawGdipSupportLevel = TS_DRAW_GDIPLUS_DEFAULT;
    }
    else {
        TRC_NRM((TB, "Read from registry, gdipSupportLevel is %d", drawGdipSupportLevel));
    }
    COM_CloseRegistry(pTSWd);

    /************************************************************************/
    /* Open registry here.  Apart from SM_Init, all registry reads should   */
    /* be done from this function or its children.  We close the key at the */
    /* end of this function.                                                */
    /************************************************************************/
    COM_OpenRegistry(pTSWd, DCS_INI_SECTION_NAME);

    /************************************************************************/
    /* Initialize individual modules.                                       */
    /************************************************************************/
    TRC_DBG((TB, "Initializing components..."));

    // we can't do any registry reading on this csrss thread,
    // it'll cause deadlock in the system
    arcUpdateIntervalSeconds = DCS_ARC_UPDATE_INTERVAL_DFLT;
    
    //
    // Units specified are in seconds, convert to 100ns count
    //
    dcsMinArcUpdateInterval.QuadPart = 
        (LONGLONG)DCS_TIME_ONE_SECOND * (ULONGLONG)arcUpdateIntervalSeconds;
    TRC_NRM((TB,"Set ARC update interval to %d seconds",
             arcUpdateIntervalSeconds));

    /************************************************************************/
    // Share Controller - must go first
    /************************************************************************/
    if (SC_Init(pSMHandle)) {
        // Capabilities Coordinator. Must be before all components which
        // register capabilities structures.
        CPC_Init();

        // Register the SC's capabilities. This is required because SC is
        // initialized before CPC, so cannot register its capabilities in
        // SC_Init().
        SC_SetCapabilities();
    }
    else {
        TRC_ERR((TB, "SC Initialization failed"));
        DC_QUIT;
    }

    /************************************************************************/
    /* Register the general capabilities structure.                         */
    /************************************************************************/
    GeneralCaps.capabilitySetType = TS_CAPSETTYPE_GENERAL;
    GeneralCaps.osMajorType = TS_OSMAJORTYPE_WINDOWS;
    GeneralCaps.osMinorType = TS_OSMINORTYPE_WINDOWS_NT;
    GeneralCaps.protocolVersion = TS_CAPS_PROTOCOLVERSION;

    /************************************************************************/
    /* Mark the old DOS 6 compression field as unsupported.                 */
    /************************************************************************/
    GeneralCaps.pad2octetsA = 0;
    GeneralCaps.generalCompressionTypes = 0;

    // Server supports no BC header and fast-path output, returning long credentials
    // and sending the autoreconnect cookie
    // Also supports receiving safer encrypted data from the client (better salted
    // checksum)
    //
    GeneralCaps.extraFlags = TS_EXTRA_NO_BITMAP_COMPRESSION_HDR |
            TS_FASTPATH_OUTPUT_SUPPORTED | TS_LONG_CREDENTIALS_SUPPORTED |
            TS_AUTORECONNECT_COOKIE_SUPPORTED |
            TS_ENC_SECURE_CHECKSUM;

    /************************************************************************/
    /* We don't support remote machines changing their capabilities during  */
    /* a call                                                               */
    /************************************************************************/
    GeneralCaps.updateCapabilityFlag = TS_CAPSFLAG_UNSUPPORTED;

    /************************************************************************/
    /* We don't support unshare requests from remote parties                */
    /************************************************************************/
    GeneralCaps.remoteUnshareFlag = TS_CAPSFLAG_UNSUPPORTED;

    /************************************************************************/
    /* Now do the extension caps - these don't fit in the level 1 caps.     */
    /************************************************************************/
    GeneralCaps.generalCompressionLevel = 0;

    /************************************************************************/
    /* We can receive a TS_REFRESH_RECT_PDU                                 */
    /************************************************************************/
    GeneralCaps.refreshRectSupport = TS_CAPSFLAG_SUPPORTED;

    /************************************************************************/
    /* We can receive a TS_SUPPRESS_OUTPUT_PDU                              */
    /************************************************************************/
    GeneralCaps.suppressOutputSupport = TS_CAPSFLAG_SUPPORTED;

    CPC_RegisterCapabilities((PTS_CAPABILITYHEADER)&GeneralCaps,
            sizeof(TS_GENERAL_CAPABILITYSET));

    //
    // Register virtual channel capabilities
    //
    TS_VIRTUALCHANNEL_CAPABILITYSET VcCaps;
    VcCaps.capabilitySetType = TS_CAPSETTYPE_VIRTUALCHANNEL;
    VcCaps.lengthCapability = sizeof(TS_VIRTUALCHANNEL_CAPABILITYSET);
    //Indicate support for 8K VC compression (from client->server)
    //I.e server understands compressed channels
    VcCaps.vccaps1 = TS_VCCAPS_COMPRESSION_8K;
    CPC_RegisterCapabilities((PTS_CAPABILITYHEADER)&VcCaps,
                             sizeof(TS_VIRTUALCHANNEL_CAPABILITYSET));

    TS_DRAW_GDIPLUS_CAPABILITYSET DrawGdipCaps;
    DrawGdipCaps.capabilitySetType =  TS_CAPSETTYPE_DRAWGDIPLUS;
    DrawGdipCaps.lengthCapability = sizeof(TS_DRAW_GDIPLUS_CAPABILITYSET);
    DrawGdipCaps.drawGdiplusSupportLevel = drawGdipSupportLevel;
    DrawGdipCaps.drawGdiplusCacheLevel = TS_DRAW_GDIPLUS_CACHE_LEVEL_ONE;
    CPC_RegisterCapabilities((PTS_CAPABILITYHEADER)&DrawGdipCaps,
                             sizeof(TS_DRAW_GDIPLUS_CAPABILITYSET));

    USR_Init();
    CA_Init();
    PM_Init();
    SBC_Init();
    BC_Init();
    CM_Init();
    IM_Init();
    SSI_Init();
    SCH_Init();

    TRC_NRM((TB, "** All successfully initialized **"));

    rc = TRUE;

DC_EXIT_POINT:
    /************************************************************************/
    /* Close the registry key that we opened earlier.                       */
    /************************************************************************/
    COM_CloseRegistry(pTSWd);

    DC_END_FN();
    return rc;
}


/****************************************************************************/
/* API FUNCTION: DCS_Term                                                   */
/*                                                                          */
/* Terminates DCS.                                                          */
/****************************************************************************/
void RDPCALL SHCLASS DCS_Term()
{
    DC_BEGIN_FN("DCS_Term");

    if (!dcsInitialized) {
        TRC_ERR((TB,"DCS_Term() called when we have not been initialized"));
    }

    SBC_Term();
    PM_Term();
    CA_Term();
    BC_Term();
    CM_Term();
    IM_Term();
    SSI_Term();
    SCH_Term();
    CPC_Term();
    USR_Term();
    SC_Term();

    dcsInitialized = FALSE;
    TRC_NRM((TB, "BYE!"));

    DC_END_FN();
}


/****************************************************************************/
/* API FUNCTION: DCS_TimeToDoStuff                                          */
/*                                                                          */
/* This function is called to send updates etc in the correct order.        */
/*                                                                          */
/* PARAMETERS: IN  - pOutputIn - input from TShareDD                        */
/*             OUT - pSchCurrentMode - current Scheduler mode               */
/*                                                                          */
/* RETURNS: Millisecs to set the timer for (-1 means infinite).             */
/****************************************************************************/
/* Scheduling is the responsibility of the WDW, DD and SCH components.      */
/* These ensure that DCS_TimeToDoStuff() gets called.  The Scheduler is in  */
/* one of three states: asleep, normal or turbo.  When it is asleep, this   */
/* function is not called.  When it is in normal mode, this function is     */
/* called at least once, but the scheduler is a lazy guy, so will fall      */
/* asleep again unless you keep prodding him.  In turbo mode this function  */
/* is called repeatedly and rapidly, but only for a relatively short time,  */
/* after which the scheduler falls back into normal mode, and from there    */
/* falls asleep.                                                            */
/*                                                                          */
/* Hence when a component realises it has some processing to do later,      */
/* which is called from DCS_TimeToDoStuff(), it calls                       */
/* SCH_ContinueScheduling(SCH_MODE_NORMAL) which guarantees that this       */
/* function will be called at least one more time.  If the component wants  */
/* DCS_TimeToDoStuff() to be called again, it must make another call to     */
/* SCH_ContinueScheduling(), which prods the Scheduler again.               */
/*                                                                          */
/* The objective is to only keep the scheduler awake when it is really      */
/* necessary.                                                               */
/****************************************************************************/
NTSTATUS RDPCALL SHCLASS DCS_TimeToDoStuff(PTSHARE_DD_OUTPUT_IN pOutputIn,
                                        PUINT32            pSchCurrentMode,
                                        PINT32              pNextTimer)
{
    INT32  timeToSet;
    ULARGE_INTEGER sysTime;
    UINT32 sysTimeLowPart;
    NTSTATUS status = STATUS_SUCCESS;

    DC_BEGIN_FN("DCS_TimeToDoStuff");

#ifdef DC_DEBUG
    /************************************************************************/
    /* Update trace config in shared memory.                                */
    /************************************************************************/
    TRC_MaybeCopyConfig(m_pTSWd, &(m_pShm->trc));
#endif

    // Determine if we should do anything based on:
    // 1. SCH determining that this is the time to do something.
    // 2. We are in a share.
    if (SCH_ShouldWeDoStuff(pOutputIn->forceSend) && SC_InShare()) {
        PDU_PACKAGE_INFO pkgInfo = {0};

        // We check for the need to send a cursor-moved packet, by comparing
        // the current mouse position to the last known position at the last
        // mouse packet, only a few times a second, to reduce the traffic for
        // shadow clients.
        KeQuerySystemTime((PLARGE_INTEGER)&sysTime);
        sysTimeLowPart = sysTime.LowPart;
        if ((sysTimeLowPart - dcsLastMiscTime) > DCS_MISC_PERIOD) {
            dcsLastMiscTime = sysTimeLowPart;
            IM_CheckUpdateCursor(&pkgInfo, sysTimeLowPart);
        }

        //
        // Check if the ARC cookie needs to be updated
        //
        if (scEnablePeriodicArcUpdate      &&
            scUseAutoReconnect             &&
            ((sysTime.QuadPart - dcsLastArcUpdateTime.QuadPart) > dcsMinArcUpdateInterval.QuadPart)) {

            dcsLastArcUpdateTime = sysTime;
            DCS_UpdateAutoReconnectCookie();

        }

        // Try to send updates now.
        TRC_DBG((TB, "Send updates"));

        //
        // *** Keep the code path but still return status code ***
        //
        status = UP_SendUpdates(pOutputIn->pFrameBuf, pOutputIn->frameBufWidth,
                        &pkgInfo);

        // Call the cursor manager to decide if a new cursor needs to be
        // sent to the remote system.
        CM_Periodic(&pkgInfo);

        // Flush any remaining data in the package.
        SC_FlushPackage(&pkgInfo);
    }

    /************************************************************************/
    /* Check whether we have any pending callbacks.                         */
    /************************************************************************/
    if (dcsCallbackTimerPending)
        DCS_UpdateShm();

    /************************************************************************/
    /* Find out the timer period to set                                     */
    /************************************************************************/
    *pNextTimer = SCH_EndOfDoingStuff(pSchCurrentMode);

    DC_END_FN();
    return status;
}


/****************************************************************************/
/* DCS_DiscardAllOutput                                                     */
/*                                                                          */
/* This routine will discard accumulated orders, screen data, and any       */
/* pending shadow data.  It is currently only called when the WD is dead    */
/* to prevent the DD from looping during shadow termination, or when a      */
/* disconnect or terminate is occuring.                                     */
/****************************************************************************/
void RDPCALL SHCLASS DCS_DiscardAllOutput()
{
    RECTL sdaRect[BA_MAX_ACCUMULATED_RECTS];
    unsigned cRects;

    // Blow the order heap, screen data, and clear any shadow data.
    OA_ResetOrderList();
    BA_GetBounds(sdaRect, &cRects);

    if (m_pTSWd->pShadowInfo != NULL)
    {
        m_pTSWd->pShadowInfo->messageSize = 0;
#ifdef DC_HICOLOR
        m_pTSWd->pShadowInfo->messageSizeEx = 0;
#endif
    }
        
}


/****************************************************************************/
/* Name:      DCS_ReceivedShurdownRequestPDU                                */
/*                                                                          */
/* Purpose:   Handles ShutdownRequestPDU.                                   */
/*                                                                          */
/* Params:    personID: originator of the PDU                               */
/*            pPDU:     the PDU                                             */
/*                                                                          */
/* Operation: See embedded comments for each PDU type                       */
/*                                                                          */
/* Note that since a ShutdownRequestPDU is not really directed at a         */
/* particular component, DCS_ReceivedPacket is intended as a generic        */
/* received packet handler, and it therefore takes a generic 2nd parameter  */
/****************************************************************************/
void RDPCALL SHCLASS DCS_ReceivedShutdownRequestPDU(
        PTS_SHAREDATAHEADER pDataPDU,
        unsigned            DataLength,
        NETPERSONID         personID)
{
    UINT32                  packetSize;
    PTS_SHUTDOWN_DENIED_PDU pResponsePDU;

    DC_BEGIN_FN("DCS_ReceivedPacket");

    if (dcsUserLoggedOn) {
        TRC_NRM((TB, "User logged on - deny shutdown request"));
        packetSize = sizeof(TS_SHUTDOWN_DENIED_PDU);

        if (STATUS_SUCCESS == SC_AllocBuffer((PPVOID)&pResponsePDU, packetSize)) {
            pResponsePDU->shareDataHeader.pduType2 =
                    TS_PDUTYPE2_SHUTDOWN_DENIED;

            // The way in which this packet is handled in a multi-party
            // call is not yet clear.  We could send a directed or
            // broadcast reponse to the client(s).  I've chosen
            // broadcast.
            SC_SendData((PTS_SHAREDATAHEADER)pResponsePDU, packetSize,
                    packetSize, PROT_PRIO_MISC, 0);
        }
        else {
            TRC_ALT((TB,"Failed to allocate packet for "
                    "TS_SHUTDOWN_DENIED_PDU"));
        }
    }
    else {
        TRC_NRM((TB, "User not logged on - disconnect"));
        WDW_Disconnect(m_pTSWd);
    }

    DC_END_FN();
} /* DCS_ReceivedPacket */

/****************************************************************************
  DCS_UpdateAutoReconnectCookie
  
  Updates the autoreconnection cookie and sends it to the client
*****************************************************************************/
BOOL RDPCALL SHCLASS DCS_UpdateAutoReconnectCookie()
{
    BOOL fRet = FALSE;
    ARC_SC_PRIVATE_PACKET       arcSCPkt;

    DC_BEGIN_FN("DCS_UpdateAutoReconnectCookie");

    arcSCPkt.cbLen = sizeof(ARC_SC_PRIVATE_PACKET);
    arcSCPkt.LogonId = m_pTSWd->arcReconnectSessionID;
    arcSCPkt.Version = 1;

    if (NewGenRandom(NULL,
                     NULL,
                     arcSCPkt.ArcRandomBits,
                     sizeof(arcSCPkt.ArcRandomBits))) {

#ifdef ARC_INSTRUMENT_RDPWD
        LPDWORD pdwArcRandom = (LPDWORD)arcSCPkt.ArcRandomBits;
        KdPrint(("ARC-RDPWD:Sending arc for SID:%d - random: 0x%x,0x%x,0x%x,0x%x\n",
                 arcSCPkt.LogonId,
                 pdwArcRandom[0],pdwArcRandom[1],pdwArcRandom[2],pdwArcRandom[3]));
#endif

        //
        // Try to send the updated packet and if it succeeds
        //
        if (DCS_SendAutoReconnectCookie(&arcSCPkt)) {

            //
            // Update the locally stored ARC cookie even though
            // all we know is that we attempted to send it
            // i.e. if the client link drops before it recvs the
            // cookie then it won't be able to ARC.
            //

            memcpy(m_pTSWd->arcCookie, arcSCPkt.ArcRandomBits,
                   ARC_SC_SECURITY_TOKEN_LEN);
            m_pTSWd->arcTokenValid = TRUE;

#ifdef ARC_INSTRUMENT_RDPWD
            KdPrint(("ARC-RDPWD:ACTUALLY SENT ARC for SID:%d\n", arcSCPkt.LogonId));
#endif

            fRet = TRUE;
        }
        else {
#ifdef ARC_INSTRUMENT_RDPWD
            KdPrint(("ARC-RDPWD:Failed to send new ARC for SID:%d\n", arcSCPkt.LogonId));
#endif
        }
    }

    DC_END_FN();
    return fRet;
}

BOOL RDPCALL SHCLASS DCS_FlushAutoReconnectCookie()
{
    memset(m_pTSWd->arcCookie, 0, ARC_SC_SECURITY_TOKEN_LEN);
    m_pTSWd->arcTokenValid = FALSE;
    return TRUE;
}

/****************************************************************************
  DCS_SendAutoReconnectCookie
  
  Sends a autoreconnect cookie tot the client
*****************************************************************************/
BOOL RDPCALL SHCLASS DCS_SendAutoReconnectCookie(
        PARC_SC_PRIVATE_PACKET pArcSCPkt)
{
    BOOL fRet = FALSE;
    PTS_SAVE_SESSION_INFO_PDU pInfoPDU = NULL;
    PTS_LOGON_INFO_EXTENDED pLogonInfoExPkt = NULL;
    UINT32 cbLogonInfoExLen = sizeof(TS_SAVE_SESSION_INFO_PDU) +
                              sizeof(ARC_SC_PRIVATE_PACKET) +
                              sizeof(TSUINT32);
    TSUINT32 cbAutoReconnectInfoLen = sizeof(ARC_SC_PRIVATE_PACKET);
    TSUINT32 cbWrittenLen = 0;

    DC_BEGIN_FN("DCS_SendAutoReconnectCookie");

    //
    //Send down the autoreconnect cookie
    //
    if (scUseAutoReconnect) {
        if ( STATUS_SUCCESS == SC_AllocBuffer((PPVOID)&pInfoPDU,
                                              cbLogonInfoExLen)) {

            // Zero out the structure and set basic header info.
            memset(pInfoPDU, 0, cbLogonInfoExLen);
            pInfoPDU->shareDataHeader.pduType2 = TS_PDUTYPE2_SAVE_SESSION_INFO;
            pInfoPDU->data.InfoType = TS_INFOTYPE_LOGON_EXTENDED_INFO;

            // Now fill up the rest of the packet 
            pLogonInfoExPkt = &pInfoPDU->data.Info.LogonInfoEx;
            pLogonInfoExPkt->Length = sizeof(TS_LOGON_INFO_EXTENDED) +
                                      sizeof(ARC_SC_PRIVATE_PACKET) +
                                      sizeof(TSUINT32);

            //
            // For now the only info we pass down is
            // the autoreconnect cookie
            //
            pLogonInfoExPkt->Flags = LOGON_EX_AUTORECONNECTCOOKIE;

            //Copy in the fields
            //Autoreconnect field length
            PBYTE pBuf = (PBYTE)(pLogonInfoExPkt+1);
            memcpy(pBuf, &cbAutoReconnectInfoLen, sizeof(TSUINT32));
            pBuf += sizeof(TSUINT32);
            cbWrittenLen += sizeof(TSUINT32);
            //Autoreconnect cookie
            memcpy(pBuf, pArcSCPkt, cbAutoReconnectInfoLen);
            pBuf += cbAutoReconnectInfoLen; 
            cbWrittenLen += cbAutoReconnectInfoLen;

            TRC_ASSERT(cbWrittenLen + sizeof(TS_LOGON_INFO_EXTENDED) <=
                       pLogonInfoExPkt->Length,
                       (TB,"Wrote to much data to packet"));

            fRet = SC_SendData((PTS_SHAREDATAHEADER)pInfoPDU,
                        cbLogonInfoExLen,
                        cbLogonInfoExLen,
                        PROT_PRIO_UPDATES, 0);
        } else {
            TRC_ALT((TB, "Failed to alloc pkt for "
                     "PTS_SAVE_SESSION_INFO_PDU"));
        }
    }

    DC_END_FN();
    return fRet;
}


/****************************************************************************/
/* Name:      DCS_UserLoggedOn                                              */
/*                                                                          */
/* Purpose:   Notify that a user has logged on                              */
/****************************************************************************/
void RDPCALL SHCLASS DCS_UserLoggedOn(PLOGONINFO pLogonInfo)
{
    PTS_SAVE_SESSION_INFO_PDU   pInfoPDU;

    DC_BEGIN_FN("DCS_UserLoggedOn");

    // This can get called before we're initialised in the console remoting
    // case.  Since in that case the class data hasn't been initialized, we
    // can't use dcsInitialized to check whether we're inited or not.  We  
    //must use the non-class variable TSWd->shareClassInit.               
    if (m_pTSWd->shareClassInit) {

        // Note that a user has successfully logged on
        dcsUserLoggedOn = TRUE;
        m_pTSWd->sessionId = pLogonInfo->SessionId;

        // If a different domain/username has been selected for a non-
        // autologon session, then send the new values back to the client to
        // be cached for future use
        if (!(m_pTSWd->pInfoPkt->flags & RNS_INFO_AUTOLOGON) && 
                (m_pTSWd->pInfoPkt->flags & RNS_INFO_LOGONNOTIFY ||
                (wcscmp((const PWCHAR)(pLogonInfo->Domain),
                    (const PWCHAR)(m_pTSWd->pInfoPkt->Domain)) ||
                wcscmp((const PWCHAR)(pLogonInfo->UserName),
                    (const PWCHAR)(m_pTSWd->pInfoPkt->UserName))))) {
                
            // Get a buffer.
            // The buffer size and how it is going to be filled depends on the client's
            // capability to accept Long Credentials on return. Pre-Whistler Clients dont
            // support Long Credentials
            
            if (scUseLongCredentials == FALSE) {

                // Pre Whistler Client - has no capability for accepting long credentials
                if ( STATUS_SUCCESS == SC_AllocBuffer((PPVOID)&pInfoPDU, sizeof(TS_SAVE_SESSION_INFO_PDU)) ) {

                    // Zero out the structure and set basic header info.
                    memset(pInfoPDU, 0, sizeof(TS_SAVE_SESSION_INFO_PDU));
                    pInfoPDU->shareDataHeader.pduType2 = TS_PDUTYPE2_SAVE_SESSION_INFO;
                    
                    // Now fill up the rest of the packet 
                        
                    pInfoPDU->data.InfoType = TS_INFOTYPE_LOGON;
    
                    // Fill in the Domain info.
                    pInfoPDU->data.Info.LogonInfo.cbDomain =
                            (wcslen((const PWCHAR)(pLogonInfo->Domain)) + 1) *
                            sizeof(WCHAR);
    
                    memcpy(pInfoPDU->data.Info.LogonInfo.Domain,
                            pLogonInfo->Domain,
                            pInfoPDU->data.Info.LogonInfo.cbDomain);
    
                    // Fill in the UserName info.
                    //    In case the fDontDisplayLastUserName is set we should 
                    //    not send back the username for caching. 
                    pInfoPDU->data.Info.LogonInfo.cbUserName = 
                            (m_pTSWd->fDontDisplayLastUserName) ? 0 :
                            (wcslen((const PWCHAR)(pLogonInfo->UserName)) + 1) *
                            sizeof(WCHAR);

                    memcpy(pInfoPDU->data.Info.LogonInfo.UserName,
                            pLogonInfo->UserName,
                            pInfoPDU->data.Info.LogonInfo.cbUserName);

                    // Fill in the Session Id info.
                    pInfoPDU->data.Info.LogonInfo.SessionId =
                            pLogonInfo->SessionId;

                    // Send it
                    SC_SendData((PTS_SHAREDATAHEADER)pInfoPDU,
                                sizeof(TS_SAVE_SESSION_INFO_PDU),
                                sizeof(TS_SAVE_SESSION_INFO_PDU),
                                PROT_PRIO_UPDATES, 0);

                } else {
                    TRC_ALT((TB, "Failed to alloc pkt for "
                             "PTS_SAVE_SESSION_INFO_PDU"));
                }

            } else { 
                // Client CAN accept long Credentials  
                TSUINT32 DomainLen, UserNameLen, DataLen ; 

                DomainLen = (wcslen((const PWCHAR)(pLogonInfo->Domain)) + 1) * sizeof(WCHAR);
                // In case fDontDisplayLastUserName is set we won't send the user name
                UserNameLen = (m_pTSWd->fDontDisplayLastUserName) ? 0 :
                              (wcslen((const PWCHAR)(pLogonInfo->UserName)) + 1) * sizeof(WCHAR);
                
                // Compute the length of the data u r sending
                DataLen = sizeof(TS_SAVE_SESSION_INFO_PDU) + DomainLen + UserNameLen ; 

                TRC_DBG((TB, "DCS_UserLoggedOn : DomainLength allocated = %ul", DomainLen));
                TRC_DBG((TB, "DCS_UserLoggedOn : UserNameLength allocated = %ul", UserNameLen));

                if ( STATUS_SUCCESS == SC_AllocBuffer((PPVOID)&pInfoPDU, DataLen) ) {  

                    // Zero out the structure and set basic header info.
                    memset(pInfoPDU, 0, DataLen);
                    pInfoPDU->shareDataHeader.pduType2 = TS_PDUTYPE2_SAVE_SESSION_INFO;
                    
                    // Now fill up the rest of the packet 
                    pInfoPDU->data.InfoType = TS_INFOTYPE_LOGON_LONG;

                    pInfoPDU->data.Info.LogonInfoVersionTwo.Version = SAVE_SESSION_PDU_VERSION_ONE ; 
                    pInfoPDU->data.Info.LogonInfoVersionTwo.Size = sizeof(TS_LOGON_INFO_VERSION_2) ; 

                    // Fill in the Session Id info.
                    pInfoPDU->data.Info.LogonInfoVersionTwo.SessionId =
                            pLogonInfo->SessionId;
    
                    // Fill in the Domain info.
                    pInfoPDU->data.Info.LogonInfoVersionTwo.cbDomain = DomainLen ; 

                    // Fill in the UserName info.
                    pInfoPDU->data.Info.LogonInfoVersionTwo.cbUserName = UserNameLen ; 

                    memcpy((PBYTE)(pInfoPDU + 1),
                            pLogonInfo->Domain,
                            DomainLen);
                    
                    //    Note that in case the fDontDisplayLastUserName is TRUE
                    //    the UserNameLen is 0 so we won't copy anything.
                    memcpy((PBYTE)(pInfoPDU + 1) + DomainLen,
                           pLogonInfo->UserName,
                           UserNameLen);

                    // Send it
                    SC_SendData((PTS_SHAREDATAHEADER)pInfoPDU,
                                DataLen,
                                DataLen,
                                PROT_PRIO_UPDATES, 0);


                } else { 
                    TRC_ALT((TB, "Failed to alloc pkt for "
                    "PTS_SAVE_SESSION_INFO_PDU"));
                }

            } // Client can accept long credentials

        }
        else
        {
            //Send back a plain logon notification (without session update
            //information)
            //because the ActiveX control needs to expose an
            //OnLoginComplete event. Older clients (e.g 2195)
            //will just ignore this PDU
            if ( STATUS_SUCCESS == SC_AllocBuffer((PPVOID)&pInfoPDU,
                                                  sizeof(TS_SAVE_SESSION_INFO_PDU)) ) {

                // Zero out the structure and set basic header info.
                memset(pInfoPDU, 0, sizeof(TS_SAVE_SESSION_INFO_PDU));
                pInfoPDU->shareDataHeader.pduType2 = TS_PDUTYPE2_SAVE_SESSION_INFO;

                // Now fill up the rest of the packet 

                pInfoPDU->data.InfoType = TS_INFOTYPE_LOGON_PLAINNOTIFY;

                // Nothing else is needed
                // Send it
                //
                SC_SendData((PTS_SHAREDATAHEADER)pInfoPDU,
                            sizeof(TS_SAVE_SESSION_INFO_PDU),
                            sizeof(TS_SAVE_SESSION_INFO_PDU),
                            PROT_PRIO_UPDATES, 0);

            } else {
                TRC_ALT((TB, "Failed to alloc pkt for "
                         "PTS_SAVE_SESSION_INFO_PDU"));
            }
        }

        pInfoPDU = NULL;
        if (pLogonInfo->Flags & LI_USE_AUTORECONNECT) {

            if (scUseAutoReconnect) {

                //
                //Send down the autoreconnect cookie
                //
                m_pTSWd->arcReconnectSessionID = pLogonInfo->SessionId;
                if (DCS_UpdateAutoReconnectCookie()) {

                    //
                    // Record the update time to prevent a double-update
                    // in DCS_TimeToDoStuff
                    //
                    KeQuerySystemTime((PLARGE_INTEGER)&dcsLastArcUpdateTime);
                    scEnablePeriodicArcUpdate = TRUE;
                }
            }
            else {
                DCS_FlushAutoReconnectCookie();
                scEnablePeriodicArcUpdate = FALSE; 
            }

        }
    } else { 
        TRC_ALT((TB, "Called before init"));
    }

    DC_END_FN();
} /* DCS_UserLoggedOn */


/****************************************************************************/
/* Name:      DCS_WDWKeyboardSetIndicators                                  */
/*                                                                          */
/* Purpose:   Notify that keyboard indicators have changed                  */
/****************************************************************************/
void RDPCALL SHCLASS DCS_WDWKeyboardSetIndicators(void)
{
    PTS_SET_KEYBOARD_INDICATORS_PDU     pKeyPDU;

    DC_BEGIN_FN("DCS_WDWKeyboardSetIndicators");

    if ((_RNS_MAJOR_VERSION(m_pTSWd->version) >  8) ||
        (_RNS_MINOR_VERSION(m_pTSWd->version) >= 1))
    {
        // Get a buffer.
        if ( STATUS_SUCCESS == SC_AllocBuffer((PPVOID)&pKeyPDU,
                sizeof(TS_SET_KEYBOARD_INDICATORS_PDU)) )
        {
            // Zero out the structure and set basic header info.
            memset(pKeyPDU, 0, sizeof(TS_SET_KEYBOARD_INDICATORS_PDU));

            pKeyPDU->shareDataHeader.pduType2 = TS_PDUTYPE2_SET_KEYBOARD_INDICATORS;

            pKeyPDU->UnitId = m_pTSWd->KeyboardIndicators.UnitId;
            pKeyPDU->LedFlags = m_pTSWd->KeyboardIndicators.LedFlags;

            // Send it.
            SC_SendData((PTS_SHAREDATAHEADER)pKeyPDU,
                    sizeof(TS_SET_KEYBOARD_INDICATORS_PDU),
                    sizeof(TS_SET_KEYBOARD_INDICATORS_PDU),
                    PROT_PRIO_UPDATES, 0);
        }
        else {
            TRC_ALT((TB, "Failed to alloc pkt for PTS_SET_KEYBOARD_INDICATORS_PDU"));
        }
    }

    DC_END_FN();
} /* DCS_WDWKeyboardSetIndicators */



/****************************************************************************/
/* Name:      DCS_WDWKeyboardSetImeStatus                                   */
/*                                                                          */
/* Purpose:   Notify that ime status have changed                           */
/****************************************************************************/
void RDPCALL SHCLASS DCS_WDWKeyboardSetImeStatus(void)
{
    PTS_SET_KEYBOARD_IME_STATUS_PDU     pImePDU;

    DC_BEGIN_FN("DCS_WDWKeyboardSetImeStatus");

    if ((_RNS_MAJOR_VERSION(m_pTSWd->version) >  8) ||
        (_RNS_MINOR_VERSION(m_pTSWd->version) >= 2))
    {
        // Get a buffer.
        if ( STATUS_SUCCESS == SC_AllocBuffer((PPVOID)&pImePDU,
                sizeof(TS_SET_KEYBOARD_IME_STATUS_PDU)) )
        {
            // Zero out the structure and set basic header info.
            memset(pImePDU, 0, sizeof(TS_SET_KEYBOARD_IME_STATUS_PDU));

            pImePDU->shareDataHeader.pduType2 = TS_PDUTYPE2_SET_KEYBOARD_IME_STATUS;

            pImePDU->UnitId      = m_pTSWd->KeyboardImeStatus.UnitId;
            pImePDU->ImeOpen     = m_pTSWd->KeyboardImeStatus.ImeOpen;
            pImePDU->ImeConvMode = m_pTSWd->KeyboardImeStatus.ImeConvMode;

            // Send it.
            SC_SendData((PTS_SHAREDATAHEADER)pImePDU,
                    sizeof(TS_SET_KEYBOARD_IME_STATUS_PDU),
                    sizeof(TS_SET_KEYBOARD_IME_STATUS_PDU),
                    PROT_PRIO_UPDATES, 0);
        }
        else {
            TRC_ERR((TB, "Failed to alloc pkt for PTS_SET_KEYBOARD_IME_STATUS_PDU"));
        }
    }

    DC_END_FN();
} /* DCS_WDWKeyboardSetImeStatus */


/****************************************************************************/
/* Name:      DCS_TriggerUpdateShmCallback                                  */
/*                                                                          */
/* Purpose:   Triggers a callback to the XX_UpdateShm functions on the      */
/*            correct WinStation context.                                   */
/****************************************************************************/
void RDPCALL SHCLASS DCS_TriggerUpdateShmCallback(void)
{
    DC_BEGIN_FN("DCS_TriggerUpdateShmCallback");

    if (!dcsUpdateShmPending)
    {
        TRC_NRM((TB, "Trigger timer for UpdateShm"));
        dcsUpdateShmPending = TRUE;

        if (!dcsCallbackTimerPending)
        {
            WDW_StartRITTimer(m_pTSWd, 0);
            dcsCallbackTimerPending = TRUE;
        }
    }

    DC_END_FN();
} /* DCS_TriggerUpdateShmCallback */


/****************************************************************************/
/* Name:      DCS_TriggerCBDataReady                                        */
/*                                                                          */
/* Purpose:   Triggers a call to the clipboard data ready function in the   */
/*            correct WinStation context.                                   */
/****************************************************************************/
void RDPCALL SHCLASS DCS_TriggerCBDataReady(void)
{
    DC_BEGIN_FN("DCS_TriggerCBDataReady");

    TRC_NRM((TB, "Trigger timer for CBDataReady"));

    if (!dcsCallbackTimerPending)
        WDW_StartRITTimer(m_pTSWd, 10);  // @@@ try 10ms delay

    DC_END_FN();
} /* DCS_TriggerCBDataReady */


/****************************************************************************/
/* Name:      DCS_UpdateShm                                                 */
/*                                                                          */
/* Purpose:   Update SHM                                                    */
/*                                                                          */
/* Operation: Guaranteed to be called in a context where m_pShm is valid.   */
/****************************************************************************/
void RDPCALL SHCLASS DCS_UpdateShm(void)
{
    DC_BEGIN_FN("DCS_UpdateShm");

    TRC_NRM((TB, "Check for specific wake-up calls."));

    if (dcsUpdateShmPending)
    {
        TRC_NRM((TB, "Call UpdateShm calls"));

        // A Global flag indicating shm updates for all components
        m_pShm->fShmUpdate = TRUE;

        SSI_UpdateShm();
        SBC_UpdateShm();
        BA_UpdateShm();
        OA_UpdateShm();
        OE_UpdateShm();
        CM_UpdateShm();
        SCH_UpdateShm();
        SC_UpdateShm();

        dcsUpdateShmPending = FALSE;
    }
    dcsCallbackTimerPending = FALSE;

    DC_END_FN();
} /* DCS_UpdateShm */


/****************************************************************************/
/* Name:      DCS_SendErrorInfo                                             */
/*                                                                          */
/* Purpose:   Sends last error information to the client so that it can     */
/*            Display meaningful error messages to users about disconnects  */
/****************************************************************************/
void RDPCALL SHCLASS DCS_SendErrorInfo(TSUINT32 errInfo)
{
    PTS_SET_ERROR_INFO_PDU   pErrorPDU = NULL;
    PTS_SHAREDATAHEADER      pHdr = NULL;
    DC_BEGIN_FN("DCS_SendErrorInfo");

    TRC_ASSERT(m_pTSWd->bSupportErrorInfoPDU,
              (TB,"DCS_SendErrorInfo called but client doesn't"
                  "support errorinfo PDU"));
    //Send a PDU to the client to indicate the last error state
    //this is analogous to win32's SetLastError() the PDU doesn't
    //trigger a disconnect. The normal code path to disconnect
    //is unchanged so we don't worry about affecting compatability with
    //older clients

    if ( STATUS_SUCCESS == SM_AllocBuffer( m_pTSWd->pSmInfo, 
                        (PPVOID) &pErrorPDU,
                        sizeof(TS_SET_ERROR_INFO_PDU),
                        FALSE, //never wait for an error packet
                        FALSE) )
    {
        // Zero out the structure and set basic header info.
        memset(pErrorPDU, 0, sizeof(TS_SET_ERROR_INFO_PDU));

        //
        // First set the share data header info
        //
        pHdr = (PTS_SHAREDATAHEADER)pErrorPDU;
        pHdr->shareControlHeader.pduType   = TS_PDUTYPE_DATAPDU |
                                             TS_PROTOCOL_VERSION;
        pHdr->shareControlHeader.pduSource = 0; //user id may not be
                                                //available yet
        pHdr->shareControlHeader.totalLength = sizeof(TS_SET_ERROR_INFO_PDU);
        pHdr->shareID = 0;
        pHdr->streamID = (BYTE)PROT_PRIO_UPDATES;
        pHdr->uncompressedLength    = (UINT16)sizeof(TS_SET_ERROR_INFO_PDU);
        pHdr->generalCompressedType = 0;
        pHdr->generalCompressedLength = 0;
        m_pTSWd->pProtocolStatus->Output.CompressedBytes +=
            sizeof(TS_SET_ERROR_INFO_PDU);

        //
        // Error pdu specific info
        //
        pErrorPDU->shareDataHeader.pduType2 =
            TS_PDUTYPE2_SET_ERROR_INFO_PDU;
        pErrorPDU->errorInfo = errInfo;


        TRC_NRM((TB,"Sending ErrorInfo PDU for err:%d", errInfo));
        // Send it
        if(!SM_SendData( m_pTSWd->pSmInfo,
                         pErrorPDU,
                         sizeof(TS_SET_ERROR_INFO_PDU),
                         0, 0, FALSE, RNS_SEC_ENCRYPT, FALSE))
        {
            TRC_ERR((TB, "Failed to SM_SendData for "
                    "TS_SET_ERROR_INFO_PDU"));
        }
    }
    else
    {
        TRC_ALT((TB, "Failed to alloc pkt for "
                "TS_SET_ERROR_INFO_PDU"));
    }

    DC_END_FN();
}

/****************************************************************************/
/* Name:      DCS_SendAutoReconnectStatus
/*
/* Purpose:   Sends autoreconnect status info to the client
/*            (e.g. that autoreconnect failed so the client should go back to
/*             displaying output so the user can enter cred at winlogon)
/*
/* Params:    
/*
/*
/****************************************************************************/
void RDPCALL SHCLASS DCS_SendAutoReconnectStatus(TSUINT32 arcStatus)
{
    PTS_AUTORECONNECT_STATUS_PDU pArcStatus = NULL;
    PTS_SHAREDATAHEADER pHdr = NULL;
    DC_BEGIN_FN("DCS_SendErrorInfo");

    TRC_ASSERT(scUseAutoReconnect,
              (TB,"DCS_SendAutoReconnectStatus called but client doesn't"
                  "support autoreconnect status PDU"));

    if ( STATUS_SUCCESS == SM_AllocBuffer( m_pTSWd->pSmInfo, 
                        (PPVOID) &pArcStatus,
                        sizeof(TS_AUTORECONNECT_STATUS_PDU),
                        FALSE, //never wait for an error packet
                        FALSE) )
    {
        // Zero out the structure and set basic header info.
        memset(pArcStatus, 0, sizeof(TS_AUTORECONNECT_STATUS_PDU));

        //
        // First set the share data header info
        //
        pHdr = (PTS_SHAREDATAHEADER)pArcStatus;
        pHdr->shareControlHeader.pduType   = TS_PDUTYPE_DATAPDU |
                                             TS_PROTOCOL_VERSION;
        pHdr->shareControlHeader.pduSource = 0; //user id may not be
                                                //available yet
        pHdr->shareControlHeader.totalLength =
            sizeof(TS_AUTORECONNECT_STATUS_PDU);
        pHdr->shareID = scShareID;
        pHdr->streamID = (BYTE)PROT_PRIO_UPDATES;
        pHdr->uncompressedLength    =
            (UINT16)sizeof(TS_AUTORECONNECT_STATUS_PDU);
        pHdr->generalCompressedType = 0;
        pHdr->generalCompressedLength = 0;
        m_pTSWd->pProtocolStatus->Output.CompressedBytes +=
            sizeof(TS_AUTORECONNECT_STATUS_PDU);

        //
        // Error pdu specific info
        //
        pArcStatus->shareDataHeader.pduType2 =
            TS_PDUTYPE2_ARC_STATUS_PDU;
        pArcStatus->arcStatus = arcStatus;


        TRC_NRM((TB,"Sending ArcStatus PDU for status:%d", arcStatus));
        // Send it
        if(!SM_SendData( m_pTSWd->pSmInfo,
                         pArcStatus,
                         sizeof(TS_AUTORECONNECT_STATUS_PDU),
                         0, 0, FALSE, RNS_SEC_ENCRYPT, FALSE))
        {
            TRC_ERR((TB, "Failed to SM_SendData for "
                    "TS_AUTORECONNECT_STATUS_PDU"));
        }
    }
    else
    {
        TRC_ALT((TB, "Failed to alloc pkt for "
                "TS_AUTORECONNECT_STATUS_PDU"));
    }

    DC_END_FN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\aimapi.cpp ===
/****************************************************************************/
/* aimapi.cpp                                                               */
/*                                                                          */
/* RDP Input Manager API functions                                          */
/*                                                                          */
/* Copyright(c) Microsoft, PictureTel 1993-1997                             */
/* Copyright (c) 1997-1999 Microsoft Corporation                            */
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop

#define TRC_FILE "aimapi"
#include <adcg.h>

#include <as_conf.hpp>

#include <nwdwint.h>


/****************************************************************************/
/* API FUNCTION: IM_Init                                                    */
/*                                                                          */
/* Called to initialize the IM                                              */
/****************************************************************************/
void RDPCALL SHCLASS IM_Init(void)
{
    TS_INPUT_CAPABILITYSET Caps;

    DC_BEGIN_FN("IM_Init");

#define DC_INIT_DATA
#include <aimdata.c>
#undef DC_INIT_DATA

    // Set up the input capabilities.
    Caps.capabilitySetType = TS_CAPSETTYPE_INPUT;
    Caps.lengthCapability  = sizeof(Caps);
    Caps.inputFlags        = TS_INPUT_FLAG_SCANCODES | TS_INPUT_FLAG_MOUSEX |
            TS_INPUT_FLAG_FASTPATH_INPUT2 | TS_INPUT_FLAG_VKPACKET;
    CPC_RegisterCapabilities((PTS_CAPABILITYHEADER)&Caps,
            sizeof(TS_INPUT_CAPABILITYSET));

    TRC_NRM((TB, "IM initialized"));

    DC_END_FN();
}


/****************************************************************************/
// IM_PlaybackEvents
//
// Called when an IM input PDU arrives. Unpacks and injects events.
/****************************************************************************/

// Maximum number of batched mouse/keyboard events. We batch because sending
// the events to the next higher driver (IcaChannelInput()) is more expensive
// than the loop overhead and mispredicted branches incurred to create the
// array of events. This constant is set to the same number found as
// MAXIMUM_ITEMS_READ in ntos\w32\ntuser\kernel\ntinput.c.
#define EventBatchLen 10

void __fastcall SHCLASS IM_PlaybackEvents(
        PTS_INPUT_PDU pInputPDU,
        unsigned      DataLength)
{
    PTS_INPUT_EVENT pInputEvent;
    unsigned        i, j, MsgLimit;
    NTSTATUS        Status;

    DC_BEGIN_FN("IM_PlaybackEvents");

    /************************************************************************/
    /* We do not handle NULL packets.                                       */
    /************************************************************************/
    TRC_ASSERT((NULL != pInputPDU), (TB,"NULL input PDU"));

    /************************************************************************/
    // Make sure we have at least enough bytes to read the header. Not having
    // any inputs in the packet is also considered an error.
    /************************************************************************/
    if (DataLength >= sizeof(TS_INPUT_PDU)) {
        /********************************************************************/
        // Convert the TS_INPUT_PDU from wire format.
        /********************************************************************/
        TRC_NRM((TB, "Received packet of %u events", pInputPDU->numberEvents));

        // Make sure we have the full packet length available.
        if (DataLength >= (sizeof(TS_INPUT_PDU) +
                (pInputPDU->numberEvents - 1) * sizeof(TS_INPUT_EVENT))) {

            // For each packet in the piggybacked packets array...
            for (i = 0; i < pInputPDU->numberEvents; i++) {
                // Get a pointer to the packet within the array of events.
                pInputEvent = &pInputPDU->eventList[i];

                switch (pInputEvent->messageType) {
                case TS_INPUT_EVENT_SCANCODE: //intentional fallthru
                case TS_INPUT_EVENT_VKPACKET: //intentional fallthru
                    {
                        BYTE FastPathEmulate[4];
                        unsigned CurKbdData;
                        KEYBOARD_INPUT_DATA KbdData[EventBatchLen];

                        MsgLimit = min((pInputPDU->numberEvents - i),
                                EventBatchLen);
                        CurKbdData = 0;
                        for (j = 0; j < MsgLimit; j++) {
                            if (pInputPDU->eventList[i + j].messageType ==
                                    TS_INPUT_EVENT_SCANCODE) {
                                // To coalesce code, we convert this kbd format
                                // to fast-path and call the fast-path
                                // event converter. Since fast-path is now
                                // the default, extra work falls to this
                                // path.
                                FastPathEmulate[0] = (BYTE)
                                        ((pInputPDU->eventList[i + j].u.key.
                                        keyboardFlags &
                                        (TS_KBDFLAGS_EXTENDED |
                                        TS_KBDFLAGS_EXTENDED1)) >> 7);
                                if (pInputPDU->eventList[i + j].u.key.
                                        keyboardFlags & TS_KBDFLAGS_RELEASE)
                                    FastPathEmulate[0] |=
                                            TS_INPUT_FASTPATH_KBD_RELEASE;
                                FastPathEmulate[1] = (BYTE)
                                        pInputPDU->eventList[i + j].u.key.
                                        keyCode;

                                // Convert the wire packet to a kernel mode
                                // keyboard event. We pack into an array of
                                // events because an IcaChannelInput is
                                // expensive.
                                if (IMConvertFastPathKeyboardToEvent(
                                        FastPathEmulate,
                                        &KbdData[CurKbdData])) {
                                    TRC_NRM((TB, "Add kbd evt to batch index "
                                            "%d: MakeCode(%u) flags(%#x)",
                                            CurKbdData,
                                            KbdData[CurKbdData].MakeCode,
                                            KbdData[CurKbdData].Flags));

                                    CurKbdData++;
                                }
                            }
                            else if (pInputPDU->eventList[i+j].messageType ==
                                     TS_INPUT_EVENT_VKPACKET)
                            {
                                FastPathEmulate[0] = (BYTE)
                                        ((pInputPDU->eventList[i + j].u.key.
                                        keyboardFlags &
                                        (TS_KBDFLAGS_EXTENDED |
                                        TS_KBDFLAGS_EXTENDED1)) >> 7);
                                FastPathEmulate[0] |= 
                                    TS_INPUT_FASTPATH_EVENT_VKPACKET;
                                if (pInputPDU->eventList[i + j].u.key.
                                        keyboardFlags & TS_KBDFLAGS_RELEASE)
                                    FastPathEmulate[0] |=
                                            TS_INPUT_FASTPATH_KBD_RELEASE;
                                memcpy(&FastPathEmulate[1],
                                       &pInputPDU->eventList[i + j].u.key.keyCode,
                                       2);

                                // Convert the wire packet to a kernel mode
                                // keyboard event. We pack into an array of
                                // events because an IcaChannelInput is
                                // expensive.
                                if (IMConvertFastPathKeyboardToEvent(
                                        FastPathEmulate,
                                        &KbdData[CurKbdData])) {
                                    TRC_NRM((TB, "Add kbd evt to batch index "
                                            "%d: MakeCode(%u) flags(%#x)",
                                            CurKbdData,
                                            KbdData[CurKbdData].MakeCode,
                                            KbdData[CurKbdData].Flags));

                                    CurKbdData++;
                                }
                            }
                            else
                            {
                                break;
                            }
                        }

                        // Advance past the used messages, taking into account
                        // the outer loop increment.
                        i += j - 1;

                        // Now do the input.
                        if (m_pTSWd->shadowState != SHADOW_CLIENT) {
                            Status = IcaChannelInput(m_pTSWd->pContext,
                                    Channel_Keyboard, 0, NULL,
                                    (PUCHAR) KbdData,
                                    sizeof(KEYBOARD_INPUT_DATA) * CurKbdData);
                            TRC_DBG((TB,"Return from keyboard input injection %lu",
                                    Status));
                        }

                        // Else we must be shadowing, so blow the shadow if we
                        // see the hotkey in this set of input.
                        else {
                            Status = IMCheckForShadowHotkey(KbdData,
                                    CurKbdData);
                        }
                    }
                    break;


                    case TS_INPUT_EVENT_MOUSE:
                    case TS_INPUT_EVENT_MOUSEX:
                    {
                        unsigned CurMouseData;
                        MOUSE_INPUT_DATA MouseData[EventBatchLen];

                        MsgLimit = min((pInputPDU->numberEvents - i),
                                EventBatchLen);
                        CurMouseData = 0;
                        for (j = 0; j < MsgLimit; j++) {
                            if ((pInputPDU->eventList[i + j].messageType ==
                                    TS_INPUT_EVENT_MOUSE) ||
                                (pInputPDU->eventList[i + j].messageType ==
                                    TS_INPUT_EVENT_MOUSEX)) {
                                // Convert the wire packet to a kernel mode
                                // mouse event. We pack into an array of
                                // events because an IcaChannelInput is
                                // expensive.
                                if (IMConvertMousePacketToEvent(
                                        &pInputPDU->eventList[i + j].u.mouse,
                                        &MouseData[CurMouseData],
                                        (pInputPDU->eventList[i + j].messageType ==
                                        TS_INPUT_EVENT_MOUSEX)))
                                {
                                    TRC_NRM((TB, "Add mouse evt to batch "
                      "index %u: x(%ld) y(%ld) flags(%#hx) buttonflags(%#hx)",
                                            CurMouseData,
                                            MouseData[CurMouseData].LastX,
                                            MouseData[CurMouseData].LastY,
                                            MouseData[CurMouseData].Flags,
                                        MouseData[CurMouseData].ButtonFlags));

                                    CurMouseData++;
                                }
                            }
                            else
                            {
                                break;
                            }
                        }

                        // Advance past the used messages, taking into account
                        // the outer loop increment.
                        i += j - 1;

                        // Now do the input.
                        Status = IcaChannelInput(m_pTSWd->pContext,
                                Channel_Mouse, 0, NULL,
                                (unsigned char *)MouseData,
                                sizeof(MOUSE_INPUT_DATA) * CurMouseData);
                        TRC_DBG((TB,"Return from mouse input injection %lu",
                                Status));
                    }
                    break;


                    case TS_INPUT_EVENT_SYNC:
                        Status = IMDoSync(pInputEvent->u.sync.toggleFlags);
                        break;


                    default:
                    {
                        // Unknown event type - log an event and disconnect
                        // the offending Client.
                        TRC_ERR((TB, "Unrecognized imPacket (%d)",
                                pInputEvent->messageType));
                        WDW_LogAndDisconnect(m_pTSWd, TRUE,
                                Log_RDP_InvalidInputPDUType,
                                (PBYTE)&(pInputEvent->messageType),
                                sizeof(pInputEvent->messageType));
                        DC_QUIT;
                    }
                }
            }

            // Go into TURBO scheduling on user input to flush screen deltas
            // faster.
            SCH_ContinueScheduling(SCH_MODE_TURBO);
        }
        else {
            goto InsufficientData;
        }
    }
    else {
        goto InsufficientData;
    }

DC_EXIT_POINT:
    DC_END_FN();
    return;

// Error handling.
InsufficientData:
    TRC_ERR((TB,"Input PDU received, len=%u, but data is not long enough",
            DataLength));
    WDW_LogAndDisconnect(m_pTSWd, TRUE, Log_RDP_InputPDUBadLength,
            (PBYTE)pInputPDU, DataLength);

    DC_END_FN();
}


/****************************************************************************/
// IMCheckForShadowHotkey
//
// Looks for the shadow hotkey among client keyboard input.
/****************************************************************************/
NTSTATUS RDPCALL SHCLASS IMCheckForShadowHotkey(
        KEYBOARD_INPUT_DATA *pKbdData,
        unsigned NumData)
{
    unsigned i;
    NTSTATUS Status;
    ICA_CHANNEL_COMMAND Data;
    BOOLEAN bHotKeyDetected = FALSE;

    DC_BEGIN_FN("IMCheckForShadowHotkey");

    // Blow the shadow if we see the hotkey in this set of input.
    for (i = 0; i < NumData; i++) {
        bHotKeyDetected |= KeyboardHotKeyProcedure(
              m_pTSWd->HotkeyVk,
              m_pTSWd->HotkeyModifiers,
              &pKbdData[i],
              m_pTSWd->gpScancodeMap,
              m_pTSWd->pKbdTbl,
              m_pTSWd->KeyboardType101,
              m_pTSWd->pgafPhysKeyState);
    }

    if (!bHotKeyDetected) {
        Status = STATUS_SUCCESS;
    }
    else {
        m_pTSWd->HotkeyVk = 0; // cut off all piped data
        Data.Header.Command = ICA_COMMAND_SHADOW_HOTKEY;
        Status = IcaChannelInput(m_pTSWd->pContext, Channel_Command, 0, NULL,
                (PUCHAR)&Data, sizeof(Data));
        TRC_ALT((TB,"Injected shadow HOTKEY command! status=%08X", Status));
    }

    DC_END_FN();
    return Status;
}


/****************************************************************************/
// IM_DecodeFastPathInput
//
// On a primary stack, decodes optimized input bytestream and injects into
// the input stream. NumEvents is passed from MCS, decoded from the header
// -- if zero, the first byte of the data to decode contains the number of
// events.
/****************************************************************************/
void RDPCALL SHCLASS IM_DecodeFastPathInput(
        BYTE *pData,
        unsigned DataLength,
        unsigned NumEvents)
{
    unsigned i, j, MsgLimit;
    NTSTATUS Status;
    BYTE *pCurDecode = pData;

    DC_BEGIN_FN("IM_DecodeFastPathInput");

    // Make sure we've been given enough data.
    if (NumEvents == 0) {
        if (DataLength >= 1) {
            NumEvents = *pData;
            pData++;
            DataLength--;
        }
        else {
            TRC_ERR((TB,"Len %u too short for DataLength", DataLength));
            goto ShortData;
        }
    }

    // For each event...
    for (i = 0; i < NumEvents; i++) {
        if (DataLength >= 1) {
            switch (*pData & TS_INPUT_FASTPATH_EVENT_MASK) {
                case TS_INPUT_FASTPATH_EVENT_KEYBOARD:
                {
                    unsigned CurKbdData;
                    KEYBOARD_INPUT_DATA KbdData[EventBatchLen];

                    MsgLimit = min((NumEvents - i), EventBatchLen);

                    CurKbdData = 0;
                    for (j = 0; j < MsgLimit; j++) {
                        if (DataLength >= 1) {
                            if ((*pData & TS_INPUT_FASTPATH_EVENT_MASK) ==
                                    TS_INPUT_FASTPATH_EVENT_KEYBOARD) {
                                if (DataLength >= 2) {
                                    if (IMConvertFastPathKeyboardToEvent(
                                            pData, &KbdData[CurKbdData]))
                                        CurKbdData++;

                                    pData += 2;
                                    DataLength -= 2;
                                }
                                else {
                                    TRC_ERR((TB,"Ran out of space reading "
                                            "keyboard events"));
                                    goto ShortData;
                                }
                            }
                            else {
                                break;
                            }
                        }
                        else {
                            TRC_ERR((TB,"Ran out of space reading keyboard "
                                    "events"));
                            goto ShortData;
                        }
                    }

                    // Advance past the used messages, taking into account
                    // the outer loop increment.
                    i += j - 1;

                    // Now do the input.
                    if (m_pTSWd->shadowState != SHADOW_CLIENT) {
                        Status = IcaChannelInput(m_pTSWd->pContext,
                                Channel_Keyboard, 0, NULL,
                                (PUCHAR)KbdData,
                                sizeof(KEYBOARD_INPUT_DATA) * CurKbdData);
                        TRC_DBG((TB,"Return from keyboard input injection %lu",
                                Status));
                    }

                    // Else we must be shadowing, so blow the shadow if we
                    // see the hotkey in this set of input.
                    else {
                        Status = IMCheckForShadowHotkey(KbdData,
                                CurKbdData);
                    }

                    break;
                }

                case TS_INPUT_FASTPATH_EVENT_VKPACKET:
                {
                    unsigned CurKbdData;
                    KEYBOARD_INPUT_DATA KbdData[EventBatchLen];

                    MsgLimit = min((NumEvents - i), EventBatchLen);

                    CurKbdData = 0;
                    for (j = 0; j < MsgLimit; j++) {
                        if (DataLength >= 1) {
                            if ((*pData & TS_INPUT_FASTPATH_EVENT_MASK) ==
                                    TS_INPUT_FASTPATH_EVENT_VKPACKET) {
                                if (DataLength >= 3) {
                                    if (IMConvertFastPathKeyboardToEvent(
                                            pData, &KbdData[CurKbdData]))
                                        CurKbdData++;

                                    pData += 3;
                                    DataLength -= 3;
                                }
                                else {
                                    TRC_ERR((TB,"Ran out of space reading "
                                            "keyboard events"));
                                    goto ShortData;
                                }
                            }
                            else {
                                break;
                            }
                        }
                        else {
                            TRC_ERR((TB,"Ran out of space reading keyboard "
                                    "events"));
                            goto ShortData;
                        }
                    }

                    // Advance past the used messages, taking into account
                    // the outer loop increment.
                    i += j - 1;

                    // Now do the input.
                    if (m_pTSWd->shadowState != SHADOW_CLIENT) {
                        Status = IcaChannelInput(m_pTSWd->pContext,
                                Channel_Keyboard, 0, NULL,
                                (PUCHAR)KbdData,
                                sizeof(KEYBOARD_INPUT_DATA) * CurKbdData);
                        TRC_DBG((TB,"Return from keyboard input injection %lu",
                                Status));
                    }
                    break;
                }


                case TS_INPUT_FASTPATH_EVENT_MOUSE:
                case TS_INPUT_FASTPATH_EVENT_MOUSEX:
                {
                    unsigned CurMouseData;
                    MOUSE_INPUT_DATA MouseData[EventBatchLen];

                    // After the 1-byte header the following 6 bytes are
                    // the same format as a regular mouse input.
                    MsgLimit = min((NumEvents - i), EventBatchLen);
                    CurMouseData = 0;
                    for (j = 0; j < MsgLimit; j++) {
                        if (DataLength >= 1) {
                            if ((((*pData & TS_INPUT_FASTPATH_EVENT_MASK) ==
                                    TS_INPUT_FASTPATH_EVENT_MOUSE) ||
                                    (*pData & TS_INPUT_FASTPATH_EVENT_MASK) ==
                                    TS_INPUT_FASTPATH_EVENT_MOUSEX)) {
                                if (DataLength >= 7) {
                                    // Convert the wire packet to a kernel
                                    // mode mouse event. We pack into an
                                    // array of events because an
                                    // IcaChannelInput is expensive.
                                    if (IMConvertMousePacketToEvent(
                                            (TS_POINTER_EVENT UNALIGNED *)
                                            (pData + 1),
                                            &MouseData[CurMouseData],
                                            ((*pData &
                                            TS_INPUT_FASTPATH_EVENT_MASK) ==
                                            TS_INPUT_FASTPATH_EVENT_MOUSEX)))
                                        CurMouseData++;

                                    pData += 7;
                                    DataLength -= 7;
                                }
                                else {
                                    TRC_ERR((TB,"Out of data decoding "
                                            "mouse, i=%u, j=%u, NumEvents=%u, "
                                            "DataLen=%u",
                                            i, j, NumEvents, DataLength));
                                    goto ShortData;
                                }
                            }
                            else {
                                break;
                            }
                        }
                        else {
                            TRC_ERR((TB,"Out of data decoding "
                                    "mouse, i=%u, j=%u, NumEvents=%u, "
                                    "DataLen=%u",
                                    i, j, NumEvents, DataLength));
                            goto ShortData;
                        }
                    }

                    // Advance past the used messages, taking into account
                    // the outer loop increment.
                    i += j - 1;

                    // Now do the input.
                    Status = IcaChannelInput(m_pTSWd->pContext,
                            Channel_Mouse, 0, NULL,
                            (unsigned char *)MouseData,
                            sizeof(MOUSE_INPUT_DATA) * CurMouseData);
                    TRC_DBG((TB,"Return from mouse input injection %lu",
                            Status));

                    break;
                }


                case TS_INPUT_FASTPATH_EVENT_SYNC:
                    Status = IMDoSync(*pData & TS_INPUT_FASTPATH_FLAGS_MASK);
                    pData++;
                    DataLength--;
                    break;


                default:
                    // Unknown event type - log an event and disconnect
                    // the offending Client.
                    TRC_ERR((TB, "Unrecognized imPacket (%d)",
                            *pData & TS_INPUT_FASTPATH_EVENT_MASK));
                    WDW_LogAndDisconnect(m_pTSWd, TRUE, 
                            Log_RDP_InvalidInputPDUType, pData, 1);
                    DC_QUIT;
            }
        }
        else {
            TRC_ERR((TB,"Out of data reading input events"));
            goto ShortData;
        }
    }  // end event loop

    // Go into TURBO scheduling on user input to flush screen deltas
    // faster.
    SCH_ContinueScheduling(SCH_MODE_TURBO);

DC_EXIT_POINT:
    DC_END_FN();
    return;

ShortData:
    WDW_LogAndDisconnect(m_pTSWd, TRUE, Log_RDP_InputPDUBadLength,
            (PBYTE)pData, DataLength);
    DC_END_FN();
}


/****************************************************************************/
// IM_ConvertFastPathToShadow
//
// Inverse of the client IHTranslateInputToFastPath() function -- takes
// a fast-path input stream and converts to the regular encoding. Used
// by a passthru stack to send the resulting regular encoding over the
// cross-server pipe via IcaRawInput().
/****************************************************************************/
#define MaxDefaultEvents 16

void RDPCALL SHCLASS IM_ConvertFastPathToShadow(
        BYTE *pData,
        unsigned DataLength,
        unsigned NumEvents)
{
    unsigned i, j, EventsThisPDU, PDUSize;
    NTSTATUS Status;
    PTS_INPUT_PDU pInput;
    BYTE DefaultBuf[sizeof(TS_INPUT_PDU) + sizeof(TS_INPUT_EVENT) *
            (MaxDefaultEvents - 1)];

    DC_BEGIN_FN("IM_ConvertFastPathToShadow");

    // Make sure we've been given enough data.
    if (NumEvents == 0) {
        if (DataLength >= 1) {
            NumEvents = *pData;
            pData++;
            DataLength--;
        }
        else {
            TRC_ERR((TB,"Len %u too short for DataLength", DataLength));
            goto ShortData;
        }
    }

    // We don't alloc memory, just send multiple input PDUs if we need to.
    if (NumEvents > 0) {
        pInput = (PTS_INPUT_PDU)DefaultBuf;
        // set the input pdu array to 0.
        memset(pInput, 0, sizeof(TS_INPUT_PDU) + sizeof(TS_INPUT_EVENT) *
                (MaxDefaultEvents - 1));

    }
    else {
        DC_QUIT;
    }

    // Set up the input PDU header info that won't be changing.
    // Shadow handling does not care about the following, so we don't go to
    // thr trouble of making up or grabbing values:
    //     shareDataHeader.shareControlHeader.pduSource
    pInput->shareDataHeader.shareControlHeader.pduType = TS_PROTOCOL_VERSION |
            TS_PDUTYPE_DATAPDU;
    pInput->shareDataHeader.shareID = scShareID;
    pInput->shareDataHeader.streamID = TS_STREAM_LOW;
    pInput->shareDataHeader.pduType2 = TS_PDUTYPE2_INPUT;

    // Loop while we need to send more PDUs.
    for (j = 0; j < NumEvents;) {
        // Reset the input PDU info.
        EventsThisPDU = min(NumEvents - j, MaxDefaultEvents);

        pInput->numberEvents = (TSUINT16)EventsThisPDU;
        PDUSize = sizeof(TS_INPUT_PDU) + sizeof(TS_INPUT_EVENT) *
                  (EventsThisPDU - 1);
        pInput->shareDataHeader.shareControlHeader.totalLength =
                (TSUINT16)PDUSize;
        pInput->shareDataHeader.uncompressedLength =
                (TSUINT16)PDUSize;

        // For each event...
        for (i = 0; i < EventsThisPDU; i++) {
            if (DataLength >= 1) {
                switch (*pData & TS_INPUT_FASTPATH_EVENT_MASK) {
                    case TS_INPUT_FASTPATH_EVENT_KEYBOARD:
                        if (DataLength >= 2) {
                            // Use a mask, shift, and OR to avoid branches for the
                            // extended flags.
                            pInput->eventList[i].messageType =
                                    TS_INPUT_EVENT_SCANCODE;
                            pInput->eventList[i].u.key.keyboardFlags =
                                    (*pData & (BYTE)(
                                    TS_INPUT_FASTPATH_KBD_EXTENDED |
                                    TS_INPUT_FASTPATH_KBD_EXTENDED1)) << 7;
                            if (*pData & TS_INPUT_FASTPATH_KBD_RELEASE)
                                pInput->eventList[i].u.key.keyboardFlags |=
                                        TS_KBDFLAGS_RELEASE;

                            pInput->eventList[i].u.key.keyCode = pData[1];
                            pData += 2;
                            DataLength -= 2;
                        }
                        else {
                            goto ShortData;
                        }
                        break;

                    case TS_INPUT_FASTPATH_EVENT_VKPACKET:
                        if (DataLength >= 3) {
                            // Use a mask, shift, and OR to avoid branches for the
                            // extended flags.
                            pInput->eventList[i].messageType =
                                    TS_INPUT_EVENT_VKPACKET;
                            pInput->eventList[i].u.key.keyboardFlags =
                                    (*pData & (BYTE)(
                                    TS_INPUT_FASTPATH_KBD_EXTENDED |
                                    TS_INPUT_FASTPATH_KBD_EXTENDED1)) << 7;
                            if (*pData & TS_INPUT_FASTPATH_KBD_RELEASE)
                                pInput->eventList[i].u.key.keyboardFlags |=
                                        TS_KBDFLAGS_RELEASE;
                            memcpy(&pInput->eventList[i].u.key.keyCode,
                                   &pData[1],
                                   2);

                            TRC_NRM((TB,"Shadow pass: 0x%x flags:0x%x\n",
                                     pInput->eventList[i].u.key.keyCode,
                                     pInput->eventList[i].u.key.keyboardFlags));
    
                            pData += 3;
                            DataLength -= 3;
                        }
                        else {
                            goto ShortData;
                        }
                        break;


                    case TS_INPUT_FASTPATH_EVENT_MOUSE:
                    case TS_INPUT_FASTPATH_EVENT_MOUSEX:
                        if (DataLength >= 7) {
                            pInput->eventList[i].messageType =
                                    ((*pData & TS_INPUT_FASTPATH_EVENT_MASK) ==
                                    TS_INPUT_FASTPATH_EVENT_MOUSE ?
                                    TS_INPUT_EVENT_MOUSE :
                                    TS_INPUT_EVENT_MOUSEX);
                            memcpy(&pInput->eventList[i].u.mouse, pData + 1,
                                    sizeof(TS_POINTER_EVENT));
                            pData += 7;
                            DataLength -= 7;
                        }
                        else {
                            goto ShortData;
                        }

                        break;


                    case TS_INPUT_FASTPATH_EVENT_SYNC:
                        pInput->eventList[i].messageType = TS_INPUT_EVENT_SYNC;
                        pInput->eventList[i].u.sync.toggleFlags =
                                (*pData & (BYTE)TS_INPUT_FASTPATH_FLAGS_MASK);
                        pData++;
                        DataLength--;
                        break;


                    default:
                        TRC_ERR((TB, "Unrecognized imPacket (%d)",
                                *pData & TS_INPUT_FASTPATH_EVENT_MASK));
                        DC_QUIT;
                }
            }
            else {
                TRC_ERR((TB,"Out of data reading input events"));
                goto ShortData;
            }

        }  // end event loop

        j += i;

        // Launch the PDU.
        TRC_NRM((TB, "Forwarding shadow data: %ld", DataLength));
        Status = IcaRawInput(m_pTSWd->pContext, NULL, (BYTE *)pInput,
                PDUSize);
        if (!NT_SUCCESS(Status)) {
            TRC_ERR((TB, "Failed shadow input data [%ld]: %x",
                    DataLength, Status));
        }
    }

DC_EXIT_POINT:
    DC_END_FN();
    return;

ShortData:
    TRC_ERR((TB,"Short PDU during passthru translation"));
    DC_END_FN();
}


/****************************************************************************/
// IM_CheckUpdateCursor
//
// Called during output processing to check to see if we need to send
// a mouse-moved packet to the client.
/****************************************************************************/
void RDPCALL SHCLASS IM_CheckUpdateCursor(
        PPDU_PACKAGE_INFO pPkgInfo,
        UINT32            currentTime)
{
    PPOINTL pCursorPos;
    UINT32 timeDelta;

    DC_BEGIN_FN("IM_CheckUpdateCursor");

    // Check to see if the cursor has moved since last time we came
    // through - if not, then there's no point in doing any of the
    // following tests!
    if (!CM_CursorMoved()) {
        TRC_DBG((TB, "No move since last time through"));
        DC_QUIT;
    }

    // Get the current cursor position - we always need this.
    pCursorPos = CM_GetCursorPos();

    // Check to see if the mouse has been moved at the display driver level
    // yet - don't do anything until it has to avoid the mouse leaping to 0,0
    // on connection
    if (pCursorPos->x != 0xffffffff) {
        // Check to see if the cursor is hidden - we should do nothing
        // here if it is.  In particular, the 'real' cursor is hidden
        // during dragging of a single file and a 'fake' is drawn (by
        // Explorer?). Ignoring the fact that it is hidden causes the
        // 'faked' cursor to keep leaping back to where the drag started!
        if (CM_IsCursorVisible()) {

            timeDelta = currentTime - imLastLowLevelMouseEventTime;
            TRC_NRM((TB, "SetCursorPos (%d:%d) lastEvent:%#lx "
                    "delta:%#lx", pCursorPos->x, pCursorPos->y,
                    imLastLowLevelMouseEventTime, timeDelta));


            CM_SendCursorMovedPacket(pPkgInfo);
        }
        else {
            TRC_NRM((TB, "Cursor hidden - skipping"));
        }
    }
    else {
        TRC_NRM((TB, "No mouse updates rec'd from client - not moving"));
    }

    // Clear the cursor moved flag.
    CM_ClearCursorMoved();

DC_EXIT_POINT:
    DC_END_FN();
}


/****************************************************************************/
/* API FUNCTION: IM_PartyJoiningShare                                       */
/*                                                                          */
/* Called by SC when a new party is joining the share                       */
/*                                                                          */
/* PARAMETERS:                                                              */
/* personID - the local ID of the new party.                                */
/* oldShareSize - the number of the parties which were in the share (ie     */
/*     excludes the joining party).                                         */
/*                                                                          */
/* RETURNS:                                                                 */
/* TRUE - the IM can accept the new party                                   */
/* FALSE - the IM cannot accept the new party                               */
/****************************************************************************/
BOOL RDPCALL SHCLASS IM_PartyJoiningShare(
        LOCALPERSONID personID,
        unsigned      oldShareSize)
{
    BOOL rc = FALSE;
    PTS_INPUT_CAPABILITYSET pIMCaps;

    DC_BEGIN_FN("IM_PartyJoiningShare");

    DC_IGNORE_PARAMETER(oldShareSize)

    // One-time init for each new share.
    if (oldShareSize == 0) {
        KEYBOARD_INDICATOR_PARAMETERS kip = {0};
        SD_IOCTL                      sdIoctl;

        // The keys will initially all be up.
        memset(imKeyStates, 0, sizeof(imKeyStates));

        // Reset when we last saw a low level mouse event.
        COM_GETTICKCOUNT(imLastLowLevelMouseEventTime);

        // Get the toggle key states.
        sdIoctl.IoControlCode      = IOCTL_KEYBOARD_QUERY_INDICATORS;
        sdIoctl.InputBuffer        = NULL;
        sdIoctl.InputBufferLength  = 0;
        sdIoctl.OutputBuffer       = &kip;
        sdIoctl.OutputBufferLength = sizeof(KEYBOARD_INDICATOR_PARAMETERS);
        sdIoctl.BytesReturned      = 0;

        if (WDW_QueryKeyboardIndicators(m_pTSWd, &sdIoctl) ==
                STATUS_SUCCESS) {
            TRC_NRM((TB, "Got toggle key states ok"));
            imKeyStates[IM_SC_CAPITAL] = kip.LedFlags & KEYBOARD_CAPS_LOCK_ON;
            imKeyStates[IM_SC_NUMLOCK] = kip.LedFlags & KEYBOARD_NUM_LOCK_ON;
            imKeyStates[IM_SC_SCROLL]  = kip.LedFlags &
                    KEYBOARD_SCROLL_LOCK_ON;
        }

        TRC_NRM((TB, "Toggle key states: Caps:%s, Num:%s, Scroll:%s",
                 (imKeyStates[IM_SC_CAPITAL] & 0x01) ? "ON" : "OFF",
                 (imKeyStates[IM_SC_NUMLOCK] & 0x01) ? "ON" : "OFF",
                 (imKeyStates[IM_SC_SCROLL]  & 0x01) ? "ON" : "OFF"));
    }

    // Make sure scancodes are supported by client.
    pIMCaps = (PTS_INPUT_CAPABILITYSET)
            CPC_GetCapabilitiesForPerson(personID, TS_CAPSETTYPE_INPUT);
    if (pIMCaps != NULL && pIMCaps->inputFlags & TS_INPUT_FLAG_SCANCODES) {
        rc = TRUE;
    }
    else {
        TRC_ERR((TB, "Rejecting join from [%u]: has no scancode support",
                personID));
    }

    DC_END_FN();
    return rc;
}


/****************************************************************************/
/* API FUNCTION: IM_PartyLeftShare                                          */
/*                                                                          */
/* Called when a party has left the share.                                  */
/*                                                                          */
/* PARAMETERS:                                                              */
/* personID - the local ID of the new party.                                */
/* newShareSize - the number of the parties now in the share (ie excludes   */
/*     the leaving party).                                                  */
/****************************************************************************/
void RDPCALL SHCLASS IM_PartyLeftShare(
        LOCALPERSONID personID,
        unsigned      newShareSize)
{
    DC_BEGIN_FN("IM_PartyLeftShare");

    if (newShareSize == 0) {
        // Need to make sure we set all keys up, just in case we were
        // shadowing a console session.
        if (m_pTSWd->StackClass == Stack_Shadow)
            IMResetKeyStateArray();
    }

    DC_END_FN();
}


/****************************************************************************/
/* FUNCTION: IMConvertMousePacketToEvent                                    */
/*                                                                          */
/* Converts the TS_INPUT_EVENT format to a MOUSE_INPUT_DATA OS format       */
/*                                                                          */
/* PARAMETERS:                                                              */
/* pInputEvent   - the TS_INPUT_EVENT to be converted                       */
/* pMouseData    - the MOUSE_INPUT_DATA to modify                           */
/*                                                                          */
/* RETURNS:                                                                 */
/*   TRUE  if the packet has been recognised and converted                  */
/*   FALSE if the packet was not recognised                                 */
/****************************************************************************/
BOOL __fastcall SHCLASS IMConvertMousePacketToEvent(
        TS_POINTER_EVENT UNALIGNED *pInputEvent,
        MOUSE_INPUT_DATA *pMouseData,
        BOOL bMouseX)
{
    BOOL rc = TRUE;

    DC_BEGIN_FN("IMConvertMousePacketToEvent");

    /************************************************************************/
    /* Set all the fields to zero                                           */
    /************************************************************************/
    memset(pMouseData, 0, sizeof(MOUSE_INPUT_DATA));

    // Check for a wheel rotate, since this is easy to process.
    // (It cannot include any mouse movement as well).
    // MouseX events are not used for wheel events.
    if (!bMouseX && (pInputEvent->pointerFlags & TS_FLAG_MOUSE_WHEEL))
    {
        if (!(pInputEvent->pointerFlags &
                (TS_FLAG_MOUSE_BUTTON1 |
                 TS_FLAG_MOUSE_BUTTON2 |
                 TS_FLAG_MOUSE_BUTTON3)))
        {
            /****************************************************************/
            /* This is a wheel movement.                                    */
            /****************************************************************/
            pMouseData->ButtonFlags = MOUSE_WHEEL;
            pMouseData->ButtonData  = pInputEvent->pointerFlags &
                    TS_FLAG_MOUSE_ROTATION_MASK;

            /****************************************************************/
            /* Sign extend the rotation amount up to the full 32            */
            /* bits                                                         */
            /****************************************************************/
            if (pMouseData->ButtonData & TS_FLAG_MOUSE_DIRECTION)
            {
                pMouseData->ButtonData |= ~TS_FLAG_MOUSE_ROTATION_MASK;
            }
        }

        DC_QUIT;
    }

    /************************************************************************/
    /* We are left now with non wheel-rotate events.  Note that we could be */
    /* dealing with either a TS_INPUT_EVENT_MOUSE or a                      */
    /* TS_INPUT_EVENT_MOUSEX.  Either way we must store the mouse position. */
    /************************************************************************/
    pMouseData->LastX = min( (int)(m_desktopWidth - 1),
                                (int)(max(0, pInputEvent->x)) );
    pMouseData->LastY = min( (int)(m_desktopHeight - 1),
                                (int)(max(0, pInputEvent->y)) );

    /************************************************************************/
    /* Add flags as appropriate.                                            */
    /************************************************************************/
    /************************************************************************/
    /* Make all submitted events absolute moves (both clicks and moves)     */
    /************************************************************************/
    pMouseData->Flags = MOUSE_MOVE_ABSOLUTE | MOUSE_VIRTUAL_DESKTOP;

    //
    // Set the flags to indicate if this move is originating
    // from a shadow client
    //
    if (m_pTSWd->StackClass == Stack_Shadow ) {
        // this event is coming from a shadow client
        pMouseData->Flags |= MOUSE_TERMSRV_SRC_SHADOW;
    }

    /************************************************************************/
    /* Set click flags for click events (i.e. non-move events)              */
    /************************************************************************/
    if (!(!bMouseX && (pInputEvent->pointerFlags & TS_FLAG_MOUSE_MOVE)))
    {
        if (!bMouseX)
        {
            /****************************************************************/
            /* A standard mouse event                                       */
            /****************************************************************/
            switch (pInputEvent->pointerFlags &
                    (TS_FLAG_MOUSE_BUTTON1 | TS_FLAG_MOUSE_BUTTON2 |
                    TS_FLAG_MOUSE_BUTTON3 | TS_FLAG_MOUSE_DOWN))
            {
                case TS_FLAG_MOUSE_BUTTON1 | TS_FLAG_MOUSE_DOWN:
                {
                    pMouseData->ButtonFlags = MOUSE_BUTTON_1_DOWN;

                    // Update the key state array.
                    IM_SET_KEY_DOWN(imKeyStates[IM_SC_LBUTTON]);
                }
                break;

                case TS_FLAG_MOUSE_BUTTON1:
                {
                    pMouseData->ButtonFlags = MOUSE_BUTTON_1_UP;
                    if (IM_KEY_STATE_IS_UP(imKeyStates[IM_SC_LBUTTON]))
                    {
                        /********************************************************/
                        /* Discard unmatched mouse button up event              */
                        /********************************************************/
                        TRC_NRM((TB, "discard mouse up event"));
                        rc = FALSE;
                        DC_QUIT;
                    }

                    // Update the key state array.
                    IM_SET_KEY_UP(imKeyStates[IM_SC_LBUTTON]);
                }
                break;

                case TS_FLAG_MOUSE_BUTTON2 | TS_FLAG_MOUSE_DOWN:
                {
                    pMouseData->ButtonFlags = MOUSE_BUTTON_2_DOWN;

                    // Update the key state array.
                    IM_SET_KEY_DOWN(imKeyStates[IM_SC_RBUTTON]);
                }
                break;

                case TS_FLAG_MOUSE_BUTTON2:
                {
                    pMouseData->ButtonFlags = MOUSE_BUTTON_2_UP;
                    if (IM_KEY_STATE_IS_UP(imKeyStates[IM_SC_RBUTTON]))
                    {
                        /********************************************************/
                        /* Discard unmatched mouse button up event              */
                        /********************************************************/
                        TRC_NRM((TB, "discard mouse up event"));
                        rc = FALSE;
                        DC_QUIT;
                    }

                    // Update the key state array.
                    IM_SET_KEY_UP(imKeyStates[IM_SC_RBUTTON]);
                }
                break;

                case TS_FLAG_MOUSE_BUTTON3 | TS_FLAG_MOUSE_DOWN:
                {
                    pMouseData->ButtonFlags = MOUSE_BUTTON_3_DOWN;

                    IM_SET_KEY_DOWN(imKeyStates[IM_SC_MBUTTON]);
                }
                break;

                case TS_FLAG_MOUSE_BUTTON3:
                {
                    pMouseData->ButtonFlags = MOUSE_BUTTON_3_UP;
                    if (IM_KEY_STATE_IS_UP(imKeyStates[IM_SC_MBUTTON]))
                    {
                        /********************************************************/
                        /* Discard unmatched mouse button up event              */
                        /********************************************************/
                        TRC_NRM((TB, "discard mouse up event"));
                        rc = FALSE;
                        DC_QUIT;
                    }

                    IM_SET_KEY_UP(imKeyStates[IM_SC_MBUTTON]);
                }
                break;

                default:
                {
                    /************************************************************/
                    /* If we don't recognise this then don't play it back. This */
                    /* should not be possible according to the T.128 spec,      */
                    /* which restricts the allowed flag combinations to the     */
                    /* above                                                    */
                    /************************************************************/
                    TRC_ERR((TB, "Unrecognized mouse flags (%04X)",
                            pInputEvent->pointerFlags));
                    WDW_LogAndDisconnect(m_pTSWd, TRUE, 
                                         Log_RDP_InvalidInputPDUMouse,
                                         (PBYTE)pInputEvent,
                                         sizeof(PTS_INPUT_EVENT));
                    rc = FALSE;
                    DC_QUIT;
                }
            }
        }
        else
        {
            /****************************************************************/
            /* An extended mouse event                                      */
            /****************************************************************/
            switch (pInputEvent->pointerFlags &
                    (TS_FLAG_MOUSEX_BUTTON1 | TS_FLAG_MOUSEX_BUTTON2 |
                                                         TS_FLAG_MOUSEX_DOWN))
            {
                case TS_FLAG_MOUSEX_BUTTON1 | TS_FLAG_MOUSEX_DOWN:
                {
                    pMouseData->ButtonFlags = MOUSE_BUTTON_4_DOWN;

                    // Update the key state array.
                    IM_SET_KEY_DOWN(imKeyStates[IM_SC_XBUTTON1]);
                }
                break;

                case TS_FLAG_MOUSEX_BUTTON1:
                {
                    pMouseData->ButtonFlags = MOUSE_BUTTON_4_UP;
                    if (IM_KEY_STATE_IS_UP(imKeyStates[IM_SC_XBUTTON1]))
                    {
                        /********************************************************/
                        /* Discard unmatched mouse button up event              */
                        /********************************************************/
                        TRC_NRM((TB, "discard mouse up event"));
                        rc = FALSE;
                        DC_QUIT;
                    }

                    // Update the key state array.
                    IM_SET_KEY_UP(imKeyStates[IM_SC_XBUTTON1]);
                }
                break;

                case TS_FLAG_MOUSEX_BUTTON2 | TS_FLAG_MOUSEX_DOWN:
                {
                    pMouseData->ButtonFlags = MOUSE_BUTTON_5_DOWN;

                    // Update the key state array.
                    IM_SET_KEY_DOWN(imKeyStates[IM_SC_XBUTTON2]);
                }
                break;

                case TS_FLAG_MOUSEX_BUTTON2:
                {
                    pMouseData->ButtonFlags = MOUSE_BUTTON_5_UP;
                    if (IM_KEY_STATE_IS_UP(imKeyStates[IM_SC_XBUTTON2]))
                    {
                        /********************************************************/
                        /* Discard unmatched mouse button up event              */
                        /********************************************************/
                        TRC_NRM((TB, "discard mouse up event"));
                        rc = FALSE;
                        DC_QUIT;
                    }

                    // Update the key state array.
                    IM_SET_KEY_UP(imKeyStates[IM_SC_XBUTTON2]);
                }
                break;

                default:
                {
                    /********************************************************/
                    /* As for standard button clicks, if we don't recognise */
                    /* this then don't play it back.  Capabilities should   */
                    /* protect us from getting here.                        */
                    /********************************************************/
                    TRC_ERR((TB, "Unrecognized mouseX flags (%04X)",
                            pInputEvent->pointerFlags));
                    WDW_LogAndDisconnect(m_pTSWd, TRUE, 
                                         Log_RDP_InvalidInputPDUMouse,
                                         (PBYTE)pInputEvent,
                                         sizeof(PTS_INPUT_EVENT));
                    rc = FALSE;
                    DC_QUIT;
                }
            }
        }
    }

    /************************************************************************/
    /* Store the injection time for guessing at SetCursorPos calls.         */
    /************************************************************************/
    COM_GETTICKCOUNT(imLastLowLevelMouseEventTime);

    /************************************************************************/
    /* Store the mouse position before conversion.                          */
    /************************************************************************/
    imLastKnownMousePos.x = pMouseData->LastX;
    imLastKnownMousePos.y = pMouseData->LastY;

    /************************************************************************/
    /* Scale the logical screen co-ordinates to the full 16-bit             */
    /* range (0..65535).                                                    */
    /************************************************************************/
    TRC_DBG((TB, "Scale a