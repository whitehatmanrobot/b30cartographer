ace("Error [%#x]: bstrContainerName = szContainerName failed.\n", hr);
       goto ErrorExit;
   }

   //
   // Add the CSP & key container info. This is used by CAPI to load the
   // CSP and find the keyset when the user indicates this certificate.
   //
   ::ZeroMemory((LPVOID) &KeyProvInfo, sizeof(CRYPT_KEY_PROV_INFO));
   KeyProvInfo.pwszContainerName = (LPWSTR) bstrContainerName;
   KeyProvInfo.pwszProvName      = (LPWSTR) bstrCSPName;
   KeyProvInfo.dwProvType        = PROV_RSA_FULL;
   KeyProvInfo.dwFlags           = 0;
   KeyProvInfo.dwKeySpec         = dwKeySpec;

   if (!::CertSetCertificateContextProperty(pCertContext,
                                            CERT_KEY_PROV_INFO_PROP_ID,
                                            0,
                                            (const void *) &KeyProvInfo))
   {
       hr = HRESULT_FROM_WIN32(::GetLastError());

       DebugTrace("Error [%#x]: CertSetCertificateContextProperty() failed.\n", hr);
       goto ErrorExit;
   }

   //
   // Put the cert in the store!
   //
   if (!::CertAddCertificateContextToStore(hCertStore,
                                           pCertContext,
                                           CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES, // or CERT_STORE_ADD_NEW
                                           NULL))
   {
       hr = HRESULT_FROM_WIN32(::GetLastError());

       DebugTrace("Error [%#x]: CertCreateCertificateContext() failed.\n", hr);
       goto ErrorExit;
   }
   
CommonExit:
    //
    // Free resources.
    //
    if (pCertContext != NULL)
    {
       CertFreeCertificateContext(pCertContext);
    }
    
    DebugTrace("Leaving AddCert().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Function : GetCert

 Synopsis : Get the cert from the specified CSP for the specified key type.

 Parameter: - IN HCRYPTPROV hCryptProv

              Crypto context returned by CryptAcquireContext().

            - IN DWORD dwKeySpec

              AT_KEYEXCHANGZE or AT_SIGNATURE.

            - OUT LPBYTE * ppbEncodedCert

              Ponter to pointer to encoded cert data. Upon success, the buffer 
              is automatically allocated and must be later freed by 
              CoTaskMemFree().

            - OUT DWORD * pcbEncodedCert

              Pointer to encoded cert data length. Upon success, receive the 
              length of the encoded cert data.

Remarks  :

------------------------------------------------------------------------------*/

static HRESULT GetCert (IN  HCRYPTPROV hCryptProv,
                        IN  DWORD      dwKeySpec,
                        OUT LPBYTE   * ppbEncodedCert,
                        OUT DWORD    * pcbEncodedCert)
{
    HRESULT   hr            = S_OK;
    HCRYPTKEY hCryptKey     = NULL;
    LPBYTE    pbEncodedCert = NULL;
    DWORD     cbEncodedCert = 0;

    DebugTrace("Entering GetCert().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hCryptProv);
    ATLASSERT(ppbEncodedCert);
    ATLASSERT(pcbEncodedCert);

    //
    // Get key handle.
    //
    if (!::CryptGetUserKey(hCryptProv, dwKeySpec, &hCryptKey))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptGetUserKey() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Query certificate data length.
    //
    if (!::CryptGetKeyParam(hCryptKey,
                            KP_CERTIFICATE,
                            NULL,  // NULL to query certificate data length
                            &cbEncodedCert,
                            0))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptGetKeyParam() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Allocate memory for certificate data.
    //
    if (!(pbEncodedCert = (LPBYTE) ::CoTaskMemAlloc(cbEncodedCert)))
    {
       hr = E_OUTOFMEMORY;
    
       DebugTrace("Error [%#x]: CoTaskMemAlloc() failed.\n", hr);
       goto ErrorExit;
    }

    //
    // Now read the certificate data.
    //
    if (!::CryptGetKeyParam(hCryptKey,
                            KP_CERTIFICATE,
                            pbEncodedCert,
                            &cbEncodedCert,
                            0))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptGetKeyParam() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Return encoded cert to caller.
    //
    *ppbEncodedCert = pbEncodedCert;
    *pcbEncodedCert = cbEncodedCert;

CommonExit:
    //
    // Free resources.
    //
    if (hCryptKey)
    {
        ::CryptDestroyKey(hCryptKey);
    }

    DebugTrace("Leaving GetCert().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    if (pbEncodedCert)
    {
        ::CoTaskMemFree((LPVOID) pbEncodedCert);
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Function : PropCert

 Synopsis : Propagate the digital certificate associated with the specified
            CSP and container name to the soecified store.

 Parameter: - IN LPCSTR szCSPName

              Pointer to Crypto Service Provider name string.
              
            - IN LPCTSTR szContainerName

              Pointer to key container name string.

            - IN HCERTSTORE hCertStore

              Handle of store to add the certificate to.
              
  Remarks  :

------------------------------------------------------------------------------*/

static HRESULT PropCert (IN LPCSTR     szCSPName,
                         IN LPCSTR     szContainerName,
                         IN HCERTSTORE hCertStore)
{
    HRESULT     hr            = S_OK;
    HCRYPTPROV  hCryptProv    = NULL;
    DWORD       rgdwKeys[]    = {AT_KEYEXCHANGE, AT_SIGNATURE};
    DWORD       cbEncodedCert = 0;
    LPBYTE      pbEncodedCert = NULL;
    DWORD       i;

    DebugTrace("Entering PropCert().\n");

    //
    // Sanity check.
    // 
    ATLASSERT(szCSPName);
    ATLASSERT(szContainerName);
    ATLASSERT(hCertStore);

    //
    // Obtain the crypto context.
    //
    // CRYPT_SILENT forces the CSP to raise no UI. The fully qualified
    // container name indicates which reader to connect to, so the
    // user should not be prompted to insert or select a card.
    //
    if (!::CryptAcquireContextA(&hCryptProv,
                                szContainerName,
                                szCSPName,
                                PROV_RSA_FULL,
                                CRYPT_SILENT))
    {
       hr = HRESULT_FROM_WIN32(::GetLastError());

       DebugTrace("Error [%#x]: CryptAcquireContextA() failed.\n", hr);
       goto ErrorExit;
    }

    //
    // For each key pair found in the smart card, store the corresponding
    // digital certificate to the specified store.
    //
    for (i = 0; i < ARRAYSIZE(rgdwKeys); i++)
    {
        //
        // Get the certificate data.
        //
        if (FAILED(hr = ::GetCert(hCryptProv, 
                                  rgdwKeys[i], 
                                  &pbEncodedCert, 
                                  &cbEncodedCert)))
        {
           if (HRESULT_FROM_WIN32(NTE_NO_KEY) == hr)
           {
              //
              // We are OK if there is no key of such type.
              //
              hr = S_OK;
              continue;
           }

           DebugTrace("Error [%#x]: GetCert() failed.\n", hr);
           goto ErrorExit;
        }
    
        //
        // Add the certificate to the specified store.
        //
        if (FAILED(hr = ::AddCert(szCSPName, 
                                  szContainerName, 
                                  rgdwKeys[i], 
                                  pbEncodedCert, 
                                  cbEncodedCert, 
                                  hCertStore)))
        {
            DebugTrace("Error [%#x]: AddCert() failed.\n", hr);
            goto ErrorExit;
        }
        
        //
        // Free resources.
        //
        if (pbEncodedCert)
        {
           ::CoTaskMemFree((LPVOID) pbEncodedCert), pbEncodedCert = NULL;
        }
    }

CommonExit:
    //
    // Free resources.
    //
    if (pbEncodedCert)
    {
       ::CoTaskMemFree((LPVOID) pbEncodedCert);
    }

    if (hCryptProv)
    {
      ::CryptReleaseContext(hCryptProv, 0);
    }
    
    DebugTrace("Leaving PropCert().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : LoadFromSmartCard

  Synopsis : Load all certificates from all smart card readers.
  
  Parameter: HCERTSTORE hCertStore - Certificate store handle of store to 
                                     receive all the certificates.
                                     
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT LoadFromSmartCard (HCERTSTORE hCertStore)
{
    HRESULT             hr              = S_OK;
    LONG                lResult         = 0;
    DWORD               dwNumReaders    = 0;
    DWORD               dwAutoAllocate  = SCARD_AUTOALLOCATE;
    SCARDCONTEXT        hContext        = NULL;
    LPSTR               szReaderName    = NULL;
    LPSTR               mszReaderNames  = NULL;
    LPSTR               szCardName      = NULL;
    LPSTR               szCSPName       = NULL;
    LPSTR               szContainerName = NULL;
    HMODULE             hWinSCardDll    = NULL;
    LPSCARD_READERSTATE lpReaderStates  = NULL;

    DebugTrace("Entering LoadFromSmartCard().\n");
    
    //
    // Sanity check.
    //
    ATLASSERT(hCertStore);

    //
    // Load WinSCard.dll.
    //
    if (!(hWinSCardDll = ::LoadLibrary("WinSCard.dll")))
    {
        hr = CAPICOM_E_NOT_SUPPORTED;

        DebugTrace("Error [%#x]: Smart Card Base Component (WinSCard.dll) not installed.\n", hr);
        goto ErrorExit;
    }

    //
    // Load all SCard APIs used.
    //
    if (!(pfnSCardEstablishContext = (PFNSCARDESTABLISHCONTEXT) 
            ::GetProcAddress(hWinSCardDll, "SCardEstablishContext")))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: GetProcAddress() failed for SCardEstablishContext.\n", hr);
        goto ErrorExit;
    }

    if (!(pfnSCardListReadersA = (PFNSCARDLISTREADERSA) 
            ::GetProcAddress(hWinSCardDll, "SCardListReadersA")))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: GetProcAddress() failed for SCardListReadersA.\n", hr);
        goto ErrorExit;
    }
    
    if (!(pfnSCardGetStatusChangeA = (PFNSCARDGETSTATUSCHANGEA) 
            ::GetProcAddress(hWinSCardDll, "SCardGetStatusChangeA")))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: GetProcAddress() failed for SCardStatusChangeA.\n", hr);
        goto ErrorExit;
    }
    
    if (!(pfnSCardListCardsA = (PFNSCARDLISTCARDSA) 
            ::GetProcAddress(hWinSCardDll, "SCardListCardsA")))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: GetProcAddress() failed for SCardListCardsA.\n", hr);
        goto ErrorExit;
    }
    
    if (!(pfnSCardGetCardTypeProviderNameA = (PFNSCARDGETCARDTYPEPROVIDERNAMEA) 
            ::GetProcAddress(hWinSCardDll, "SCardGetCardTypeProviderNameA")))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: GetProcAddress() failed for SCardGetCardTypeProviderNameA.\n", hr);
        goto ErrorExit;
    }

    if (!(pfnSCardFreeMemory = (PFNSCARDFREEMEMORY) 
            ::GetProcAddress(hWinSCardDll, "SCardFreeMemory")))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: GetProcAddress() failed for SCardFreeMemory.\n", hr);
        goto ErrorExit;
    }

    if (!(pfnSCardReleaseContext = (PFNSCARDRELEASECONTEXT) 
            ::GetProcAddress(hWinSCardDll, "SCardReleaseContext")))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: GetProcAddress() failed for SCardReleaseContext.\n", hr);
        goto ErrorExit;
    }

    //
    // Establish context with the resource manager.
    //
    if (SCARD_S_SUCCESS != (lResult = pfnSCardEstablishContext(SCARD_SCOPE_USER,
                                                               NULL,
                                                               NULL,
                                                               &hContext)))
    {
        hr = HRESULT_FROM_WIN32(lResult);

        DebugTrace("Error [%#x]: SCardEstablishContext() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Get the list of all reader(s).
    // Note: The buffer is automatically allocated and must be freed
    //       by SCardFreeMemory().
    //
    if (SCARD_S_SUCCESS != (lResult = pfnSCardListReadersA(hContext,
                                                           NULL,
                                                           (LPSTR) &mszReaderNames,
                                                           &dwAutoAllocate)))
    {
        hr = HRESULT_FROM_WIN32(lResult);
    
        DebugTrace("Error [%#x]: SCardListReadersA() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Count number of readers.
    //
    for (dwNumReaders = 0, szReaderName = mszReaderNames; *szReaderName; dwNumReaders++)
    {
        szReaderName += ::strlen(szReaderName) + 1;
    }

    //
    // Nothing to do if no reader.
    //
    if (0 < dwNumReaders) 
    {
        DWORD i;

        //
        // Allocate memory for SCARD_READERSTATE array.
        //
        if (!(lpReaderStates = (LPSCARD_READERSTATE) 
                               ::CoTaskMemAlloc(dwNumReaders * sizeof(SCARD_READERSTATE))))
        {
            hr = E_OUTOFMEMORY;
    
            DebugTrace("Error [%#x]: CoTaskMemAlloc() failed.\n", hr);
            goto ErrorExit;
        }
        
        //
        // Prepare state array.
        //
        ::ZeroMemory((LPVOID) lpReaderStates, dwNumReaders * sizeof(SCARD_READERSTATE));
        
        for (i = 0, szReaderName = mszReaderNames; i < dwNumReaders; i++)
        {
            lpReaderStates[i].szReader = (LPCSTR) szReaderName;
            lpReaderStates[i].dwCurrentState = SCARD_STATE_UNAWARE;
        
            szReaderName += ::strlen(szReaderName) + 1;
        }
        
        //
        // Initialize card status.
        //
        if (SCARD_S_SUCCESS != (lResult = pfnSCardGetStatusChangeA(hContext,
                                                                   INFINITE,
                                                                   lpReaderStates,
                                                                   dwNumReaders)))
        {
            hr = HRESULT_FROM_WIN32(lResult);
    
            DebugTrace("Error [%#x]: SCardGetStatusChangeA() failed.\n", hr);
            goto ErrorExit;
        }
        
        //
        // For each card found, find the proper CSP and propagate the
        // certificate(s) to the specified store.
        //
        for (i = 0; i < dwNumReaders; i++)
        {
            //
            // Card in this reader?
            //
            if (!(lpReaderStates[i].dwEventState & SCARD_STATE_PRESENT))
            {
                //
                // No card in this reader.
                //
                continue;
            }
        
            //
            // Get card name.
            //
            dwAutoAllocate = SCARD_AUTOALLOCATE;
            if (SCARD_S_SUCCESS != (lResult = pfnSCardListCardsA(hContext,
                                                                 lpReaderStates[i].rgbAtr,
                                                                 NULL,
                                                                 0,
                                                                 (LPSTR) &szCardName,
                                                                 &dwAutoAllocate)))
            {
                hr = HRESULT_FROM_WIN32(lResult);
        
                DebugTrace("Error [%#x]: SCardListCardsA() failed.\n", hr);
                goto ErrorExit;
            }
        
            //
            // Get card's CSP name.
            //
            dwAutoAllocate = SCARD_AUTOALLOCATE;
            if (SCARD_S_SUCCESS != (lResult = pfnSCardGetCardTypeProviderNameA(hContext,
                                                                               szCardName,
                                                                               SCARD_PROVIDER_CSP,
                                                                               (LPSTR) &szCSPName,
                                                                               &dwAutoAllocate)))
            {
                hr = HRESULT_FROM_WIN32(lResult);
        
                DebugTrace("Error [%#x]: SCardGetCardTypeProviderNameA() failed.\n", hr);
                goto ErrorExit;
            }
        
            //
            // Prepare fully qualified container name.
            //
            if (!(szContainerName = (LPSTR) ::CoTaskMemAlloc(sizeof("\\\\.\\") + 1 +
                                                             ::strlen(lpReaderStates[i].szReader))))
            {
               hr = E_OUTOFMEMORY;
               
               DebugTrace("Error [%#x]: CoTaskMemAlloc() failed.\n", hr);
               goto ErrorExit;
            }
        
            wsprintfA(szContainerName, "\\\\.\\%s\\", lpReaderStates[i].szReader);
        
            //
            // Propagate the cert.
            //
            if (FAILED(hr = ::PropCert(szCSPName, szContainerName, hCertStore)))
            {
                DebugTrace("Error [%#x]: PropCert() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Free resources.
            //
            if (szContainerName)
            {
               ::CoTaskMemFree((LPVOID) szContainerName), szContainerName = NULL;
            }
            if (szCSPName)
            {
               pfnSCardFreeMemory(hContext, (LPVOID) szCSPName), szCSPName = NULL;
            }
            if (szCardName)
            {
               pfnSCardFreeMemory(hContext, (LPVOID) szCardName), szCardName = NULL;
            }
        }
    }

CommonExit:
    //
    // Free resource.
    //
    if (szContainerName)
    {
       ::CoTaskMemFree((LPVOID) szContainerName);
    }
    if (szCSPName)
    {
       pfnSCardFreeMemory(hContext, (LPVOID) szCSPName);
    }
    if (szCardName)
    {
       pfnSCardFreeMemory(hContext, (LPVOID) szCardName);
    }
    if (lpReaderStates)
    {
       ::CoTaskMemFree((LPVOID) lpReaderStates);
    }
    if (mszReaderNames)
    {
       pfnSCardFreeMemory(hContext, (LPVOID) mszReaderNames);
    }
    if (hContext)
    {
       pfnSCardReleaseContext(hContext);
    }
    if (hWinSCardDll)
    {
        ::FreeLibrary(hWinSCardDll);
    }

    DebugTrace("Leaving LoadFromSmartCard().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\template.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows

  Copyright (C) Microsoft Corporation, 1995 - 1999.

  File:    Template.h.

  Content: Declaration of the CTemplate.

  History: 10-02-2001    dsie     created

------------------------------------------------------------------------------*/

#ifndef __TEMPLATE_H_
#define __TEMPLATE_H_

#include "Resource.h"
#include "Error.h"
#include "Lock.h"
#include "Debug.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateTemplateObject

  Synopsis : Create a ITemplate object and populate the porperties with
             data from the key usage extension of the specified certificate.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.

             ITemplate ** ppITemplate - Pointer to pointer to ITemplate object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateTemplateObject (PCCERT_CONTEXT pCertContext,
                              ITemplate   ** ppITemplate);


////////////////////////////////////////////////////////////////////////////////
//
// CTemplate
//
class ATL_NO_VTABLE CTemplate : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CTemplate, &CLSID_Template>,
    public ICAPICOMError<CTemplate, &IID_ITemplate>,
    public IDispatchImpl<ITemplate, &IID_ITemplate, &LIBID_CAPICOM, 
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>
{
public:
    CTemplate()
    {
    }

DECLARE_NO_REGISTRY()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTemplate)
    COM_INTERFACE_ENTRY(ITemplate)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CTemplate)
END_CATEGORY_MAP()

    HRESULT FinalConstruct()
    {
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for Template object.\n", hr);
            return hr;
        }

        m_bIsPresent = VARIANT_FALSE;
        m_bIsCritical = VARIANT_FALSE;
        m_pIOID = NULL;
        m_dwMajorVersion = 0;
        m_dwMinorVersion = 0;

        return S_OK;
    }

    void FinalRelease()
    {
        m_pIOID.Release();
    }

//
// Template
//
public:
    STDMETHOD(get_IsPresent)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

    STDMETHOD(get_IsCritical)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

    STDMETHOD(get_Name)
        (/*[out, retval]*/ BSTR * pVal);

    STDMETHOD(get_OID)
        (/*[out, retval]*/ IOID ** pVal);

    STDMETHOD(get_MajorVersion)
        (/*[out, retval]*/ long * pVal);

    STDMETHOD(get_MinorVersion)
        (/*[out, retval]*/ long * pVal);

    //
    // Non COM functions.
    //
    STDMETHOD(Init)
        (PCCERT_CONTEXT pCertContext);

private:
    CLock           m_Lock;
    VARIANT_BOOL    m_bIsPresent;
    VARIANT_BOOL    m_bIsCritical;
    CComBSTR        m_bstrName;
    CComPtr<IOID>   m_pIOID;
    DWORD           m_dwMajorVersion;
    DWORD           m_dwMinorVersion;
};

#endif //__TEMPLATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\template.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Template.cpp

  Content: Implementation of CTemplate.

  History: 10-02-2001    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "Template.h"

#include "OID.h"
#include "Common.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateTemplateObject

  Synopsis : Create a ITemplate object and populate the porperties with
             data from the key usage extension of the specified certificate.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.

             ITemplate ** ppITemplate - Pointer to pointer to ITemplate object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateTemplateObject (PCCERT_CONTEXT pCertContext,
                              ITemplate   ** ppITemplate)
{
    HRESULT hr = S_OK;
    CComObject<CTemplate> * pCTemplate = NULL;

    DebugTrace("Entering CreateTemplateObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(ppITemplate);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CTemplate>::CreateInstance(&pCTemplate)))
        {
            DebugTrace("Error [%#x]: CComObject<CTemplate>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize object.
        //
        if (FAILED(hr = pCTemplate->Init(pCertContext)))
        {
            DebugTrace("Error [%#x]: pCTemplate::Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = pCTemplate->QueryInterface(ppITemplate)))
        {
            DebugTrace("Error [%#x]: pCTemplate->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Entering CreateTemplateObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (pCTemplate)
    {
        delete pCTemplate;
    }

    goto CommonExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// CTemplate
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CTemplate::get_IsPresent

  Synopsis : Check to see if the template extension is present.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CTemplate::get_IsPresent (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CTemplate::get_IsPresent().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Return result.
        //
          *pVal = m_bIsPresent;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CTemplate::get_IsPresent().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CTemplate::get_IsCritical

  Synopsis : Check to see if the template extension is marked critical.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CTemplate::get_IsCritical (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CTemplate::get_IsCritical().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Return result.
        //
          *pVal = m_bIsCritical;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CTemplate::get_IsCritical().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CTemplate::get_Name

  Synopsis : Get the name of szOID_ENROLL_CERTTYPE_EXTENSION.

  Parameter: BSTR * pVal - Pointer to BSTR to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CTemplate::get_Name (BSTR * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CTemplate::get_Name().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        if (FAILED(hr = m_bstrName.CopyTo(pVal)))
        {
            DebugTrace("Error [%#x]: m_bstrName.CopyTo() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CTemplate::get_Name().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CTemplate::get_OID

  Synopsis : Get the OID for szOID_CERTIFICATE_TEMPLATE.

  Parameter: IOID * pVal - Pointer to IOID to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CTemplate::get_OID (IOID ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CTemplate::get_OID().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Sanity check.
        //
        ATLASSERT(m_pIOID);

        //
        // Return interface pointer to user.
        //
        if (FAILED(hr = m_pIOID->QueryInterface(pVal)))
        {
            DebugTrace("Error [%#x]: m_pIOID->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CTemplate::get_OID().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CTemplate::get_MajorVersion

  Synopsis : Return the major version number of szOID_CERTIFICATE_TEMPLATE.

  Parameter: long * pVal - Pointer to long to receive value.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CTemplate::get_MajorVersion (long * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CTemplate::get_MajorVersion().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Return result.
        //
          *pVal = (long) m_dwMajorVersion;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CTemplate::get_MajorVersion().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CTemplate::get_MinorVersion

  Synopsis : Return the minor version number of szOID_CERTIFICATE_TEMPLATE.

  Parameter: long * pVal - Pointer to long to receive value.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CTemplate::get_MinorVersion (long * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CTemplate::get_MinorVersion().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Return result.
        //
          *pVal = (long) m_dwMinorVersion;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CTemplate::get_MinorVersion().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// Private methods.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CTemplate::Init

  Synopsis : Initialize the object.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us with CERT_CONTEXT.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CTemplate::Init (PCCERT_CONTEXT pCertContext)
{
    HRESULT            hr           = S_OK;
    PCERT_EXTENSION    pExtension   = NULL;
    CRYPT_DATA_BLOB    CertTypeBlob = {0, NULL};
    CRYPT_DATA_BLOB    CertTempBlob = {0, NULL};
    PCERT_NAME_VALUE   pCertType    = NULL;
    PCERT_TEMPLATE_EXT pCertTemp    = NULL;
    CComPtr<IOID>      pIOID        = NULL;
    
    DebugTrace("Entering CTemplate::Init().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);

    //
    // Find the szOID_ENROLL_CERTTYPE_EXTENSION extension.
    //
    if (pExtension = ::CertFindExtension(szOID_ENROLL_CERTTYPE_EXTENSION,
                                         pCertContext->pCertInfo->cExtension,
                                         pCertContext->pCertInfo->rgExtension))
    {
        //
        // Decode the extension.
        //
        if (FAILED(hr = ::DecodeObject(X509_UNICODE_ANY_STRING,
                                       pExtension->Value.pbData,
                                       pExtension->Value.cbData,
                                       &CertTypeBlob)))
        {
            //
            // Downlevel CryptDecodeObject() would return 0x80070002 if it does
            // not know how to decode it. So remap to CAPICOM_E_NOT_SUPPORTED.
            //
            if ((HRESULT) 0x80070002 == hr) 
            {
                hr = CAPICOM_E_NOT_SUPPORTED;
            }

            DebugTrace("Error [%#x]: DecodeObject() failed.\n", hr);
            goto ErrorExit;
        }

        pCertType = (PCERT_NAME_VALUE) CertTypeBlob.pbData;

        //
        // Set values.
        //
        m_bIsPresent = VARIANT_TRUE;
        if (pExtension->fCritical)
        {
            m_bIsCritical = VARIANT_TRUE;
        }
        if (!(m_bstrName = (LPWSTR) pCertType->Value.pbData))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error [%#x]: m_bstrName = (LPWSTR) pCertType->Value.pbData failed.\n", hr);
            goto ErrorExit;
        }
    }

    //
    // Find the szOID_CERTIFICATE_TEMPLATE extension.
    //
    if (pExtension = ::CertFindExtension(szOID_CERTIFICATE_TEMPLATE,
                                         pCertContext->pCertInfo->cExtension,
                                         pCertContext->pCertInfo->rgExtension))
    {
        //
        // Decode the basic constraints extension.
        //
        if (FAILED(hr = ::DecodeObject(szOID_CERTIFICATE_TEMPLATE,
                                       pExtension->Value.pbData,
                                       pExtension->Value.cbData,
                                       &CertTempBlob)))
        {
            DebugTrace("Error [%#x]: DecodeObject() failed.\n", hr);
            goto ErrorExit;
        }

        pCertTemp = (PCERT_TEMPLATE_EXT) CertTempBlob.pbData;

        if (FAILED(hr = ::CreateOIDObject(pCertTemp->pszObjId, TRUE, &pIOID)))
        {
            DebugTrace("Error [%#x]: CreateOIDObject() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Set values.
        //
        m_bIsPresent = VARIANT_TRUE;
        if (pExtension->fCritical)
        {
            m_bIsCritical = VARIANT_TRUE;
        }
        m_dwMajorVersion = pCertTemp->dwMajorVersion;
        if (pCertTemp->fMinorVersion)
        {
            m_dwMinorVersion = pCertTemp->dwMinorVersion;
        }
        if (0 == m_bstrName.Length())
        {
            if (FAILED(hr = pIOID->get_FriendlyName(&m_bstrName)))
            {
                DebugTrace("Error [%#x]: pIOID->get_FriendlyName() failed.\n", hr);
                goto ErrorExit;
            }
        }
    }
    else
    {
        if (FAILED(hr = ::CreateOIDObject(NULL, TRUE, &pIOID)))
        {
            DebugTrace("Error [%#x]: CreateOIDObject() failed.\n", hr);
            goto ErrorExit;
        }
    }

    if (!(m_pIOID = pIOID))
    {
        hr = CAPICOM_E_INTERNAL;

        DebugTrace("Error [%#x]: m_pIOID = pIOID failed.\n", hr);
        goto ErrorExit;
    }

CommonExit:
    //
    // Free resources.
    //
    if (CertTypeBlob.pbData)
    {
        ::CoTaskMemFree((LPVOID) CertTypeBlob.pbData);
    }
    if (CertTempBlob.pbData)
    {
        ::CoTaskMemFree((LPVOID) CertTempBlob.pbData);
    }

    DebugTrace("Leaving CTemplate::Init().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    if (m_pIOID)
    {
        m_pIOID.Release();
    }
    m_bstrName.Empty();

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\utilities.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Utilities.cpp

  Content: Implementation of CUtilities.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#include "stdafx.h"
#include "CAPICOM.h"
#include "Utilities.h"

#include "Common.h"
#include "Base64.h"
#include "Convert.h"

////////////////////////////////////////////////////////////////////////////////
//
// CUtilities
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CUtilities::GetRandom

  Synopsis : Return a secure random number.

  Parameter: long Length - Number of bytes to generate.

             CAPICOM_ENCODING_TYPE EncodingType - Encoding type.
  
             BSTR * pVal - Pointer to BSTR to receive the random value.

  Remark   : 

------------------------------------------------------------------------------*/

STDMETHODIMP CUtilities::GetRandom (long                  Length,
                                    CAPICOM_ENCODING_TYPE EncodingType, 
                                    BSTR                * pVal)
{
    HRESULT    hr         = S_OK;
    DWORD      dwFlags    = 0;
    DATA_BLOB  RandomData = {0, NULL};

    DebugTrace("Entering CUtilities::GetRandom().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameter.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Do we have a cached provider?
        //
        if (!m_hCryptProv)
        {
            if (IsWin2KAndAbove())
            {
                dwFlags = CRYPT_VERIFYCONTEXT;
            }

            //
            // Get a provider.
            //
            if (FAILED(hr = ::AcquireContext((LPSTR) NULL, 
                                             (LPSTR) NULL,
                                             PROV_RSA_FULL,
                                             dwFlags,
                                             TRUE,
                                             &m_hCryptProv)) &&
                FAILED(hr = ::AcquireContext(MS_ENHANCED_PROV_A, 
                                             (LPSTR) NULL,
                                             PROV_RSA_FULL,
                                             dwFlags,
                                             TRUE,
                                             &m_hCryptProv)) &&
                FAILED(hr = ::AcquireContext(MS_STRONG_PROV_A, 
                                             (LPSTR) NULL,
                                             PROV_RSA_FULL,
                                             dwFlags,
                                             TRUE,
                                             &m_hCryptProv)) &&
                FAILED(hr = ::AcquireContext(MS_DEF_PROV_A, 
                                             (LPSTR) NULL,
                                             PROV_RSA_FULL,
                                             dwFlags,
                                             TRUE,
                                             &m_hCryptProv)))
            {
                DebugTrace("Error [%#x]: AcquireContext() failed.\n", hr);
                goto ErrorExit;
            }
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_hCryptProv);

        //
        // Allocate memory.
        //
        RandomData.cbData = (DWORD) Length;
        if (!(RandomData.pbData = (PBYTE) ::CoTaskMemAlloc(RandomData.cbData)))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error [%#x]: CoTaskMemAlloc(RandomData.cbData) failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Now generate the random value.
        //
        if (!::CryptGenRandom(m_hCryptProv, RandomData.cbData, RandomData.pbData))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptGenRandom() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Export the random data.
        //
        if (FAILED(hr = ::ExportData(RandomData, EncodingType, pVal)))
        {
            DebugTrace("Error [%#x]: ExportData() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }


UnlockExit:
    //
    // Free resources.
    //
    if (RandomData.pbData)
    {
        ::CoTaskMemFree(RandomData.pbData);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CUtilities::GetRandom().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : Base64Encode

  Synopsis : Base64 encode the blob.

  Parameter: BSTR SrcString - Source string to be base64 encoded.
  
             BSTR * pVal - Pointer to BSTR to received base64 encoded string.
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CUtilities::Base64Encode (BSTR SrcString, BSTR * pVal)
{
    HRESULT   hr       = S_OK;
    DATA_BLOB DataBlob = {0, NULL};

    DebugTrace("Entering CUtilities::Base64Encode().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameter.
        //
        if ((NULL == (DataBlob.pbData = (LPBYTE) SrcString)) || 
            (0 == (DataBlob.cbData = ::SysStringByteLen(SrcString))))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter SrcString is NULL or empty.\n", hr);
            goto ErrorExit;
        }
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Now base64 encode.
        //
        if (FAILED(hr = ::Base64Encode(DataBlob, pVal)))
        {
            DebugTrace("Error [%#x]: Base64Encode() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }


UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CUtilities::Base64Encode().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : Base64Decode

  Synopsis : Base64 decode the blob.

  Parameter: BSTR EncodedString - Base64 encoded string.
  
             BSTR * pVal - Pointer to BSTR to received base64 decoded string.
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CUtilities::Base64Decode (BSTR EncodedString, BSTR * pVal)
{
    HRESULT   hr       = S_OK;
    DATA_BLOB DataBlob = {0, NULL};

    DebugTrace("Entering CUtilities::Base64Decode().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure parameters are valid.
        //
        if (0 == ::SysStringByteLen(EncodedString))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter EncodedString is NULL or empty.\n", hr);
            goto ErrorExit;
        }
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Now base64 decode.
        //
        if (FAILED(hr = ::Base64Decode(EncodedString, &DataBlob)))
        {
            DebugTrace("Error [%#x]: Base64Decode() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Convert blob to BSTR.
        //
        if (FAILED(hr = ::BlobToBstr(&DataBlob, pVal)))
        {
            DebugTrace("Error [%#x]: BlobToBstr() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resources.
    //
    if (DataBlob.pbData)
    {
        ::CoTaskMemFree((LPVOID) DataBlob.pbData);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CUtilities::Base64Decode().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : BinaryToHex

  Synopsis : Convert binary packed string to hex string.

  Parameter: BSTR BinaryString - Binary string to be converted.
  
             VARIANT * pVal - Pointer to BSTR to receive the converted string.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CUtilities::BinaryToHex (BSTR BinaryString, BSTR * pVal)
{
    HRESULT hr     = S_OK;
    DWORD   cbData = 0;

    DebugTrace("Entering CUtilities::BinaryToHex().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure parameters are valid.
        //
        if (0 == (cbData = ::SysStringByteLen(BinaryString)))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter BinaryString is NULL or empty.\n", hr);
            goto ErrorExit;
        }
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Convert to hex.
        //
        if (FAILED(hr = ::BinaryToHexString((LPBYTE) BinaryString, 
                                            cbData, 
                                            pVal)))
        {
            DebugTrace("Error [%#x]: BinaryToHexString() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CUtilities::BinaryToHex().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;

}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : HexToBinary

  Synopsis : Convert hex string to binary packed string.

  Parameter: BSTR HexString - Hex string to be converted.
  
             VARIANT * pVal - Pointer to BSTR to receive the converted string.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CUtilities::HexToBinary (BSTR HexString, BSTR * pVal)
{
    HRESULT        hr        = S_OK;

    DebugTrace("Entering CUtilities::HexToBinary().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure parameters are valid.
        //
        if (0 == ::SysStringByteLen(HexString))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter HexString is NULL or empty.\n", hr);
            goto ErrorExit;
        }
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Convert to binary.
        //
        if (FAILED(hr = ::HexToBinaryString(HexString, pVal)))
        {
            DebugTrace("Error [%#x]: HexToBinaryString() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CUtilities::HexToBinary().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;

}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : BinaryStringToByteArray

  Synopsis : Convert binary packed string to safearray of bytes.

  Parameter: BSTR BinaryString - Binary string to be converted.
  
             VARIANT * pVal - Pointer to VARIANT to receive the converted array.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CUtilities::BinaryStringToByteArray (BSTR      BinaryString, 
                                                  VARIANT * pVal)
{
    HRESULT        hr        = S_OK;
    DWORD          dwLength  = 0;
    LPBYTE         pbByte    = NULL;
    LPBYTE         pbElement = NULL;
    SAFEARRAY    * psa       = NULL;
    SAFEARRAYBOUND bound[1]  = {0, 0};

    DebugTrace("Entering CUtilities::BinaryStringToByteArray().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure parameters are valid.
        //
        if (0 == (dwLength = ::SysStringByteLen(BinaryString)))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter BinaryString is NULL or empty.\n", hr);
            goto ErrorExit;
        }
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize.
        //
        ::VariantInit(pVal);
        pbByte = (LPBYTE) BinaryString;

        //
        // Create the array.
        //
        bound[0].cElements = dwLength;

        if (!(psa = ::SafeArrayCreate(VT_UI1, 1, bound)))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error [%#x]: SafeArrayCreate() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Now convert each byte in source binary BSTR to variant of byte.
        //
#ifdef _DEBUG
        VARTYPE vt = VT_EMPTY;

        if (S_OK == ::SafeArrayGetVartype(psa, &vt))
        {
            DebugTrace("Info: safearray vartype = %d.\n", vt);
        }
#endif
        //
        // Point to array elements.
        //
        if (FAILED(hr = ::SafeArrayAccessData(psa, (void HUGEP **) &pbElement)))
        {
            DebugTrace("Error [%#x]: SafeArrayAccessData() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Fill the array.
        //
        while (dwLength--)
        {
            *pbElement++ = *pbByte++;
        }

        //
        // Unlock array.
        //
        if (FAILED(hr = ::SafeArrayUnaccessData(psa)))
        {
            DebugTrace("Error [%#x]: SafeArrayUnaccessData() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return array to caller.
        //
        pVal->vt = VT_ARRAY | VT_UI1;
        pVal->parray = psa;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }


UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CUtilities::BinaryStringToByteArray().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    if (psa)
    {
        ::SafeArrayDestroy(psa);
    }

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : ByteArrayToBinaryString

  Synopsis : Convert safearray of bytes to binary packed string.

  Parameter: VARIANT varByteArray - VARIANT byte array.
  
             BSTR * pVal - Pointer to BSTR to receive the converted values.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CUtilities::ByteArrayToBinaryString (VARIANT varByteArray, 
                                                  BSTR  * pVal)
{
    HRESULT     hr         = S_OK;
    VARIANT   * pvarVal    = NULL;
    SAFEARRAY * psa        = NULL;
    LPBYTE      pbElement  = NULL;
    LPBYTE      pbByte     = NULL;
    long        lLoBound   = 0;
    long        lUpBound   = 0;
    BSTR        bstrBinary = NULL;

    DebugTrace("Entering CUtilities::ByteArrayToBinaryString().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Skip over BYREF.
        //
        for (pvarVal = &varByteArray; 
             pvarVal && ((VT_VARIANT | VT_BYREF) == V_VT(pvarVal));
             pvarVal = V_VARIANTREF(pvarVal));

        //
        // Make sure parameters are valid.
        //
        if (!pvarVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter varByteArray is NULL.\n", hr);
            goto ErrorExit;
        }
        if ((VT_ARRAY | VT_UI1) != V_VT(pvarVal))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter varByteArray is not a VT_UI1 array, V_VT(pvarVal) = %d\n",
                        hr, V_VT(pvarVal));
            goto ErrorExit;
        }
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Point to the array.
        //
        psa = V_ARRAY(pvarVal);

        //
        // Check dimension.
        //
        if (1 != ::SafeArrayGetDim(psa))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: varByteArray is not 1 dimension, SafeArrayGetDim(psa) = %d.\n", 
                       hr, ::SafeArrayGetDim(psa));
            goto ErrorExit;
        }

        //
        // Get array bound.
        //
        if (FAILED(hr = ::SafeArrayGetLBound(psa, 1, &lLoBound)))
        {
            DebugTrace("Error [%#x]: SafeArrayGetLBound() failed.\n", hr);
            goto ErrorExit;
        }

        if (FAILED(hr = ::SafeArrayGetUBound(psa, 1, &lUpBound)))
        {
            DebugTrace("Error [%#x]: SafeArrayGetUBound() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Point to array elements.
        //
        if (FAILED(hr = ::SafeArrayAccessData(psa, (void HUGEP **) &pbElement)))
        {
            DebugTrace("Error [%#x]: SafeArrayAccessData() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Allocate memory for the BSTR.
        //
        if (!(bstrBinary = ::SysAllocStringByteLen(NULL, lUpBound - lLoBound + 1)))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error [%#x]: SysAllocStringByteLen() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Fill the BSTR.
        //
        for (pbByte = (LPBYTE) bstrBinary; lLoBound <= lUpBound; lLoBound++)
        {
            *pbByte++ = *pbElement++;
        }

        //
        // Unlock array.
        //
        if (FAILED(hr = ::SafeArrayUnaccessData(psa)))
        {
            DebugTrace("Error [%#x]: SafeArrayUnaccessData() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return converted string to caller.
        //
        *pVal = bstrBinary;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }


UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CUtilities::ByteArrayToBinaryString().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    if (bstrBinary)
    {
        ::SysFreeString(bstrBinary);
    }

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : LocalTimeToUTCTime

  Synopsis : Convert local time to UTC time.

  Parameter: DATE LocalTime - Local time to be converted.
  
             DATE * pVal - Pointer to DATE to receive the converted time.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CUtilities::LocalTimeToUTCTime (DATE LocalTime, DATE * pVal)
{
    HRESULT    hr = S_OK;
    SYSTEMTIME stLocal;
    SYSTEMTIME stUTC;
    FILETIME   ftLocal;
    FILETIME   ftUTC;

    DebugTrace("Entering CUtilities::LocalTimeToUTCTime().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Convert to SYSTEMTIME format.
        //
        if (!::VariantTimeToSystemTime(LocalTime, &stLocal))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: VariantTimeToSystemTime() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Convert to FILETIME format.
        //
        if (!::SystemTimeToFileTime(&stLocal, &ftLocal))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: SystemTimeToFileTime() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Convert to UTC FILETIME.
        //
        if (!::LocalFileTimeToFileTime(&ftLocal, &ftUTC))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: LocalFileTimeToFileTime() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Convert to UTC SYSTEMTIME.
        //
        if (!::FileTimeToSystemTime(&ftUTC, &stUTC))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: FileTimeToSystemTime() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Finally convert it back to DATE format.
        //
        if (!::SystemTimeToVariantTime(&stUTC, pVal))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: SystemTimeToVariantTime() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }


UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CUtilities::LocalTimeToUTCTime().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : UTCTimeToLocalTime

  Synopsis : Convert UTC time to local time.

  Parameter: DATE UTCTime - UTC time to be converted.
  
             DATE * pVal - Pointer to DATE to receive the converted time.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CUtilities::UTCTimeToLocalTime (DATE UTCTime, DATE * pVal)
{
    HRESULT    hr = S_OK;
    SYSTEMTIME stLocal;
    SYSTEMTIME stUTC;
    FILETIME   ftLocal;
    FILETIME   ftUTC;

    DebugTrace("Entering CUtilities::UTCTimeToLocalTime().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Convert to SYSTEMTIME format.
        //
        if (!::VariantTimeToSystemTime(UTCTime, &stUTC))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: VariantTimeToSystemTime() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Convert to FILETIME format.
        //
        if (!::SystemTimeToFileTime(&stUTC, &ftUTC))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: SystemTimeToFileTime() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Convert to local FILETIME.
        //
        if (!::FileTimeToLocalFileTime(&ftUTC, &ftLocal))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: FileTimeToLocalFileTime() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Convert to local SYSTEMTIME.
        //
        if (!::FileTimeToSystemTime(&ftLocal, &stLocal))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: FileTimeToSystemTime() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Finally convert it back to DATE format.
        //
        if (!::SystemTimeToVariantTime(&stLocal, pVal))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: SystemTimeToVariantTime() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }


UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CUtilities::UTCTimeToLocalTime().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\utilities.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Utilities.h

  Content: Declaration of CUtilities.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __UTILITIES_H_
#define __UTILITIES_H_

#include "Resource.h"
#include "Error.h"
#include "Lock.h"
#include "Debug.h"

////////////////////////////////////////////////////////////////////////////////
//
// CUtilities
//
class ATL_NO_VTABLE CUtilities : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CUtilities, &CLSID_Utilities>,
    public ICAPICOMError<CUtilities, &IID_IUtilities>,
    public IDispatchImpl<IUtilities, &IID_IUtilities, &LIBID_CAPICOM,
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>,
    public IObjectSafetyImpl<CUtilities, INTERFACESAFE_FOR_UNTRUSTED_CALLER | 
                                         INTERFACESAFE_FOR_UNTRUSTED_DATA>
{
public:
    CUtilities()
    {
    }

    HRESULT FinalConstruct()
    {
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for Certificate object.\n", hr);
            return hr;
        }

        m_hCryptProv = NULL;

        return S_OK;
    }

    void FinalRelease()
    {
        if (m_hCryptProv)
        {
            ::CryptReleaseContext(m_hCryptProv, 0);
        }
    }

DECLARE_REGISTRY_RESOURCEID(IDR_UTILITIES)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CUtilities)
    COM_INTERFACE_ENTRY(IUtilities)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CUtilities)
    IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
    IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
END_CATEGORY_MAP()

//
// IUtilities
//
public:
    STDMETHOD(GetRandom)
        (/*[in, defaultvalue(8)]*/ long Length,
         /*[in, defaultvalue(CAPICOM_ENCODE_BINARY)]*/ CAPICOM_ENCODING_TYPE EncodingType, 
         /*[out, retval]*/ BSTR * pVal);

    STDMETHOD(Base64Encode)
        (/*[in]*/ BSTR SrcString,
         /*[out, retval]*/ BSTR * pVal);

    STDMETHOD(Base64Decode)
        (/*[in]*/ BSTR EncodedString,
         /*[out, retval]*/ BSTR * pVal);

    STDMETHOD(BinaryToHex)
        (/*[in]*/ BSTR BinaryString,
         /*[out, retval]*/ BSTR * pVal);

    STDMETHOD(HexToBinary)
        (/*[in]*/ BSTR HexString,
         /*[out, retval]*/ BSTR * pVal);

    STDMETHOD(BinaryStringToByteArray)
        (/*[in]*/ BSTR BinaryString, 
         /*[out,retval]*/ VARIANT * pVal);

    STDMETHOD(ByteArrayToBinaryString)
        (/*[in]*/ VARIANT varByteArray, 
         /*[out, retval]*/ BSTR * pVal);

    STDMETHOD(LocalTimeToUTCTime)
        (/*[in]*/ DATE LocalTime, 
         /*[out, retval] */ DATE * pVal);

    STDMETHOD(UTCTimeToLocalTime)
        (/*[in]*/ DATE UTCTime, 
         /*[out, retval]*/ DATE * pVal);


private:
    CLock      m_Lock;
    HCRYPTPROV m_hCryptProv;
};

#endif //__UTILITIES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\release\scrdenrl\makefile.inc ===
$(O)\scrdx86.dll  : i386\scrdenrl.dll
    copy $** $@

w2k\$(O)\scrdw2k.dll  : w2k\scrdenrl.dll
    -mkdir w2k\$(O)
    copy $** $@

$(O)\scrdia64.dll : ia64\scrdenrl.dll
    copy $** $@

$(O)\scrdsign.dll : $(TARGET_DIRECTORY)\scrdenrl.dll
    copy $** $@

$(O)\scrdenrl.pdb : $(TARGET_DIRECTORY)\scrdenrl.pdb
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\release\xenroll\br\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\release\xenroll\ara\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\release\xenroll\el\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\release\xenroll\es\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\release\xenroll\cs\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\release\xenroll\fi\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\release\xenroll\fr\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\release\xenroll\cht\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\release\xenroll\ger\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\release\xenroll\heb\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\release\xenroll\chs\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\release\xenroll\hu\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\release\xenroll\it\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\release\xenroll\jpn\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\release\xenroll\kor\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\release\xenroll\localized\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\release\xenroll\nl\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\release\xenroll\da\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\release\xenroll\no\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\release\xenroll\pl\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\release\xenroll\pt\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\release\xenroll\ru\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\release\xenroll\sv\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\release\xenroll\tr\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\release\xenroll\usa\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\scrdenrl\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by scrdenrl.rc
//
#define IDS_PROJNAME                    100
#define IDR_SCRDENR                     101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\scrdenrl\scenum.h ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    scenlist

Abstract:

    This header file describes the linkages to the smart card helper routines
    provided to Xiaohung Su for use in the smart card enrollment station.

Author:

    Doug Barlow (dbarlow) 11/12/1998

Remarks:

    This header file is hardcoded to UNICODE for backwards compatibility.

Notes:

    ?Notes?

--*/

#ifndef _SCENUM_H_
#define _SCENUM_H_

#ifdef __cplusplus
extern "C" {
#endif

DWORD
CountReaders(
    LPVOID pvHandle);

DWORD
ScanReaders(
    LPVOID *ppvHandle);

BOOL
EnumInsertedCards(
    LPVOID pvHandle,
    LPWSTR szCryptoProvider,
    DWORD cchCryptoProvider,
    LPDWORD pdwProviderType,
    LPCWSTR *pszReaderName);

void
EndReaderScan(
    LPVOID *ppvHandle);

#ifdef __cplusplus
}
#endif
#endif // _SCENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\scrdenrl\scrdenr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       scrdenr.cpp
//
//--------------------------------------------------------------------------

// SCrdEnr.cpp : Implementation of CSCrdEnr


#define SECURITY_WIN32  //Or in the sources file -DSECURITY_WIN32

#include "stdafx.h"
#include <windows.h>
#include <wincrypt.h>
#include <unicode.h>
#include <oleauto.h>
#include <objbase.h>
#include <cryptui.h>
#include "certca.h"
#include "certsrv.h"
#include "security.h"
#include <dbgdef.h>


#include "scrdenrl.h"
#include "SCrdEnr.h"
#include "enrlhelp.h"
#include "xEnroll.h"
#include "wzrdpvk.h"

/////////////////////////////////////////////////////////////////////////////
// CSCrdEnr
CSCrdEnr::CSCrdEnr(void) 
{  
    DWORD                       dwIndex=0;
    DSOP_SCOPE_INIT_INFO        ScopeInit;
    DSOP_INIT_INFO              InitInfo;

    m_dwCTCount=0;
    m_dwCTIndex=0;
    m_rgCTInfo=NULL;
    m_pwszUserUPN=NULL;
    m_pwszUserSAM=NULL;
    m_pEnrolledCert=NULL;

    m_dwCSPCount=0;
    m_dwCSPIndex=0;
    m_rgCSPInfo=NULL;  

    m_lEnrollmentStatus = CR_DISP_INCOMPLETE;
    
    m_pSigningCert=NULL;
    m_fSCardSigningCert=FALSE;     
    m_pszCSPNameSigningCert=NULL;
    m_dwCSPTypeSigningCert=0;  
    m_pszContainerSigningCert=NULL;

    m_pDsObjectPicker=NULL;

    m_pCachedCTEs = NULL; //no need to free
    m_pwszCachedCTEOid = NULL;
    m_pCachedCTE = NULL;

    // track whether our critsec is initialized
    m_fInitializedCriticalSection = FALSE; 

    if(!FAILED(CoInitialize(NULL)))
        m_fInitialize=TRUE;

    // Initialize functions who's loading we've deferred.  
    InitializeThunks(); 

    __try
    {
        InitializeCriticalSection(&m_cSection); 
	m_fInitializedCriticalSection = TRUE; 
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
      
    }

    //we now need to get the CSP list
    InitlializeCSPList(&m_dwCSPCount, &m_rgCSPInfo);


    //we now need to initialize the CA and its cert types
    InitializeCTList(&m_dwCTIndex, &m_dwCTCount, &m_rgCTInfo); 


    //init for the user selection dialogue
    memset(&ScopeInit, 0, sizeof(DSOP_SCOPE_INIT_INFO));
    memset(&InitInfo,  0, sizeof(InitInfo));

    ScopeInit.cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    ScopeInit.flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN|DSOP_SCOPE_TYPE_GLOBAL_CATALOG;
    ScopeInit.flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;            //this will give us the SAM name for the user
    ScopeInit.FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;
    ScopeInit.FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS;

    InitInfo.cbSize = sizeof(InitInfo);
    InitInfo.pwzTargetComputer = NULL;  // NULL == local machine
    InitInfo.cDsScopeInfos = 1;
    InitInfo.aDsScopeInfos = &ScopeInit;
    InitInfo.flOptions = 0;             //we are doing single select

    //create the COM object
     if (S_OK == CoCreateInstance
         (CLSID_DsObjectPicker,
          NULL,
          CLSCTX_INPROC_SERVER,
          IID_IDsObjectPicker,
          (void **) &m_pDsObjectPicker))
     {
         if(S_OK != (m_pDsObjectPicker->Initialize(&InitInfo)))
         {
             m_pDsObjectPicker->Release();
             m_pDsObjectPicker=NULL;
         }
     }
     else 
        m_pDsObjectPicker=NULL;

}


CSCrdEnr::~CSCrdEnr(void) 
{
  
    if(m_pDsObjectPicker)
        m_pDsObjectPicker->Release();

    if(m_rgCTInfo)
        FreeCTInfo(m_dwCTCount, m_rgCTInfo);

    if(m_rgCSPInfo)
        FreeCSPInfo(m_dwCSPCount, m_rgCSPInfo);

    if(m_pwszUserUPN)
        SCrdEnrollFree(m_pwszUserUPN);

    if(m_pwszUserSAM)
        SCrdEnrollFree(m_pwszUserSAM);

    if(m_pSigningCert)
        CertFreeCertificateContext(m_pSigningCert); 

    if(m_pszCSPNameSigningCert)
        SCrdEnrollFree(m_pszCSPNameSigningCert);

    if(m_pszContainerSigningCert)
        SCrdEnrollFree(m_pszContainerSigningCert);

    if(m_pEnrolledCert)
        CertFreeCertificateContext(m_pEnrolledCert);

    if (NULL != m_pwszCachedCTEOid)
    {
        LocalFree(m_pwszCachedCTEOid);
    }

    if (NULL != m_pCachedCTE)
    {
        LocalFree(m_pCachedCTE);
    }

    if(m_fInitialize)
        CoUninitialize();  

    if (m_fInitializedCriticalSection) 
	DeleteCriticalSection(&m_cSection); 
}


STDMETHODIMP CSCrdEnr::get_CSPCount(long * pVal)
{
	if(NULL==pVal)
        return E_INVALIDARG;

    EnterCriticalSection(&m_cSection);
    *pVal = (long)m_dwCSPCount;
    LeaveCriticalSection(&m_cSection);

	return S_OK;
}

STDMETHODIMP CSCrdEnr::get_CSPName(BSTR * pVal)
{
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_cSection);

    if(NULL==m_rgCSPInfo || 0==m_dwCSPCount)
    {
        *pVal=NULL;
        hr=E_INVALIDARG;
    }
    else
    {
        if( NULL == (*pVal = SysAllocString(m_rgCSPInfo[m_dwCSPIndex].pwszCSPName)))
            hr = E_OUTOFMEMORY;
    }

    LeaveCriticalSection(&m_cSection);

    return(hr);
}



STDMETHODIMP CSCrdEnr::put_CSPName(BSTR newVal)
{
    HRESULT            hr= E_FAIL;
    DWORD              errBefore= GetLastError();

    DWORD              dwIndex=0;

    EnterCriticalSection(&m_cSection);

    if(NULL == m_rgCSPInfo || 0 == m_dwCSPCount || NULL == newVal)
        goto InvalidArgErr;

    for(dwIndex=0; dwIndex < m_dwCSPCount; dwIndex++)
    {
        if(0 == _wcsicmp(newVal, m_rgCSPInfo[dwIndex].pwszCSPName))
        {
            m_dwCSPIndex=dwIndex;
            break;
        }
    }

    if(dwIndex == m_dwCSPCount)
        goto InvalidArgErr;
     
    hr=S_OK;

CommonReturn:

    LeaveCriticalSection(&m_cSection);
    
    SetLastError(errBefore);

	return hr;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    hr = CodeToHR(errBefore);

	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}




STDMETHODIMP CSCrdEnr::selectUserName
        (/* [in] */              DWORD dwFlags)
{
    HRESULT                         hr= E_FAIL;
    DWORD                           errBefore= GetLastError();
    LPWSTR                          pwszSelectedUserSAM=NULL;                            
    LPWSTR                          pwszSelectedUserUPN=NULL;

    EnterCriticalSection(&m_cSection);
    
    if(NULL == m_pDsObjectPicker)
        goto InvalidArgErr;


    if(S_OK != (hr = GetSelectedUserName(m_pDsObjectPicker,
                                        &pwszSelectedUserSAM,
                                        &pwszSelectedUserUPN)))
        goto SelectUserErr;

    //we should at least have the UserSAM name
    if(NULL == pwszSelectedUserSAM)
    {
        if(pwszSelectedUserUPN)
            SCrdEnrollFree(pwszSelectedUserUPN);

        goto UnexpectedErr;
    }


    if(m_pwszUserSAM)
    {
        SCrdEnrollFree(m_pwszUserSAM);
        m_pwszUserSAM=NULL;
    }

    if(m_pwszUserUPN)
    {
        SCrdEnrollFree(m_pwszUserUPN);
        m_pwszUserUPN=NULL;
    }

    m_pwszUserSAM=pwszSelectedUserSAM;

    m_pwszUserUPN=pwszSelectedUserUPN;
     
    hr=S_OK;

CommonReturn:

    LeaveCriticalSection(&m_cSection);
    
    SetLastError(errBefore);

	return hr;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    hr = CodeToHR(errBefore);

	goto CommonReturn;

SET_ERROR_VAR(SelectUserErr, hr);
SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(UnexpectedErr, E_UNEXPECTED);
}

STDMETHODIMP CSCrdEnr::enroll

        (/* [in] */                 DWORD   dwFlags)
{
    HRESULT             hr              = E_FAIL;
    DWORD               errBefore       = GetLastError();
    ULONG               cbSize          = 0;
    SCrdEnroll_CA_INFO *pCAInfo         = NULL; 
    SCrdEnroll_CT_INFO *pCertTypeInfo   = NULL;
    BSTR                bstrAttribs     = NULL; 
    BSTR                bstrCA          = NULL;
    BSTR                bstrCertificate = NULL; 
    BSTR                bstrReq         = NULL; 

    LPWSTR              pwszRequesterName = NULL;
    ICertRequest2      *pICertRequest     = NULL;
    IEnroll4           *pIEnroll          = NULL;
    CRYPT_DATA_BLOB     PKCS10Blob;
    CRYPT_DATA_BLOB     PKCS7Request;
    CRYPT_DATA_BLOB     PKCS7Response;
    DWORD               dwDisposition; 
    DWORD               dwRequestID; 
    LPWSTR              pwszNewContainerName=NULL;
    PCCERT_CONTEXT      pArchivalCert     = NULL; 
    LONG lKeySpec = XEKL_KEYSPEC_KEYX;
    LONG lKeyMin, lKeyMax;
    DWORD dwKeyMin, dwKeyMax, dwKeySize;

    //------------------------------------------------------------
    //
    // Define locally scoped utility functions: 
    //
    //------------------------------------------------------------

    LocalScope(EnrollUtilities): 
	BSTR bstrConcat(LPWSTR pwsz1, LPWSTR pwsz2, LPWSTR pwsz3, LPWSTR pwsz4)
	{ 
	    // Note:  assumes valid input parameters!
	    BSTR   bstrResult = NULL;
	    LPWSTR pwszResult = NULL;
	    
	    pwszResult = (LPWSTR)SCrdEnrollAlloc(sizeof(WCHAR) * (wcslen(pwsz1) + wcslen(pwsz2) + wcslen(pwsz3) + wcslen(pwsz4) + 1));
	    if (pwszResult == NULL) { return NULL; }
	    else { 
		wcscpy(pwszResult, pwsz1);
		wcscat(pwszResult, pwsz2);
		wcscat(pwszResult, pwsz3);
		wcscat(pwszResult, pwsz4);
		// Convert the result to a BSTR
		bstrResult = SysAllocString(pwszResult);
		// Free the temporary storage.  
		SCrdEnrollFree(pwszResult);
		// Return the result. 
		return bstrResult; 
	    }
	}

	DWORD ICEnrollDispositionToCryptuiStatus(IN  DWORD  dwDisposition)
	{
	    switch (dwDisposition)
		{
		case CR_DISP_INCOMPLETE:          return CRYPTUI_WIZ_CERT_REQUEST_STATUS_CONNECTION_FAILED;
		case CR_DISP_DENIED:              return CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_DENIED;
		case CR_DISP_ISSUED:              return CRYPTUI_WIZ_CERT_REQUEST_STATUS_CERT_ISSUED;
		case CR_DISP_ISSUED_OUT_OF_BAND:  return CRYPTUI_WIZ_CERT_REQUEST_STATUS_ISSUED_SEPARATELY;
		case CR_DISP_UNDER_SUBMISSION:    return CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNDER_SUBMISSION;
		case CR_DISP_ERROR:               return CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR;

		default: 
		    // Should never happen
		    return CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR;
		}
	}
    EndLocalScope;

    //------------------------------------------------------------
    //
    // Begin procedure body
    //
    //------------------------------------------------------------

    memset(&PKCS10Blob, 0, sizeof(CRYPT_DATA_BLOB));
    memset(&PKCS7Request, 0, sizeof(CRYPT_DATA_BLOB));
    memset(&PKCS7Response, 0, sizeof(CRYPT_DATA_BLOB));

    EnterCriticalSection(&m_cSection);

    //check for the status of the smart cards in the reader.
    //return the fully qualified container name for the new user
    //smart card
    if(S_OK != (hr = ChkSCardStatus(m_fSCardSigningCert,
                            m_pSigningCert,
                            m_pszCSPNameSigningCert,
                            m_dwCSPTypeSigningCert,
                            m_pszContainerSigningCert, 
                            m_rgCSPInfo[m_dwCSPIndex].pwszCSPName,
                            &pwszNewContainerName)))
        goto StatusErr;

    //delete the old certificate
    if(m_pEnrolledCert)
    {
        CertFreeCertificateContext(m_pEnrolledCert);
        m_pEnrolledCert=NULL;
    }

    //init enrollment status
    m_lEnrollmentStatus = CR_DISP_INCOMPLETE;

    //make sure that we have the correct information for processing
    //the enrollment request

    if(0 == m_dwCTCount || NULL == m_rgCTInfo || 0 == m_dwCSPCount ||
        NULL == m_rgCSPInfo || NULL == m_pSigningCert ||
        ((NULL == m_pwszUserSAM) && (NULL == m_pwszUserUPN)))
        goto InvalidArgErr;

    //make sure that we have some CA
    pCertTypeInfo=&(m_rgCTInfo[m_dwCTIndex]);

    if(NULL == pCertTypeInfo->rgCAInfo || 0 == pCertTypeInfo->dwCACount)
        goto InvalidArgErr;

    pCAInfo=&(pCertTypeInfo->rgCAInfo[pCertTypeInfo->dwCAIndex]);

    if(NULL == (pIEnroll=MyPIEnroll4GetNoCOM()))
        goto TraceErr;
    
    //we use our own My store to store the enrolled certificate
    if(S_OK != (hr = pIEnroll->put_MyStoreNameWStr((LPWSTR)g_MyStoreName)))
        goto xEnrollErr;

    //we always use a new key
    if(S_OK != (hr=pIEnroll->put_UseExistingKeySet(FALSE)))
        goto xEnrollErr;

    //we the key container name
    if(S_OK != (hr=pIEnroll->put_ContainerNameWStr(pwszNewContainerName)))
        goto xEnrollErr;

    //set the CSP information
    if(S_OK != (hr=pIEnroll->put_ProviderType(m_rgCSPInfo[m_dwCSPIndex].dwCSPType)))
        goto xEnrollErr;

    if(S_OK !=(hr=pIEnroll->put_ProviderNameWStr(m_rgCSPInfo[m_dwCSPIndex].pwszCSPName)))
        goto xEnrollErr;

    //dwKeySpec
    if(S_OK !=(hr=pIEnroll->put_KeySpec(pCertTypeInfo->dwKeySpec)))
            goto xEnrollErr;

    //private key flags.  Left half-word is the key size. 
    //If the key size is 0, then specify a default key size.  
    if (0 == (pCertTypeInfo->dwGenKeyFlags & 0xFFFF0000))
    {
	// If min key size is not set, use 1024 bits.  
	pCertTypeInfo->dwGenKeyFlags |= (1024 << 16); 
    }

    dwKeySize = (pCertTypeInfo->dwGenKeyFlags & 0xFFFF0000) >> 16;
    if (0x0 != dwKeySize)
    {
        //make sure key size is in the range
        //let's get CSP key size information

        if (AT_SIGNATURE  == pCertTypeInfo->dwKeySpec)
        {
            lKeySpec = XEKL_KEYSPEC_SIG;
        }
        hr = pIEnroll->GetKeyLenEx(XEKL_KEYSIZE_MIN, lKeySpec, &lKeyMin);
        // don't have error check because the CSP may not support it
        if (S_OK == hr)
        {
            hr = pIEnroll->GetKeyLenEx(XEKL_KEYSIZE_MAX, lKeySpec, &lKeyMax);
            if (S_OK != hr)
            {
                goto xEnrollErr;
            }
            dwKeyMin = (DWORD)lKeyMin;
            dwKeyMax = (DWORD)lKeyMax;
            if (dwKeySize < dwKeyMin)
            {
                //reset the current key size
                pCertTypeInfo->dwGenKeyFlags &= 0x0000FFFF;
                //set adjusted size
                pCertTypeInfo->dwGenKeyFlags |= ((dwKeyMin & 0x0000FFFF) << 16);
            }
            if (dwKeySize > dwKeyMax)
            {
                //reset the current key size
                pCertTypeInfo->dwGenKeyFlags &= 0x0000FFFF;
                //set adjusted size
                pCertTypeInfo->dwGenKeyFlags |= ((dwKeyMax & 0x0000FFFF) << 16);
            }
        }
    }

    if (S_OK !=(hr=pIEnroll->put_GenKeyFlags(pCertTypeInfo->dwGenKeyFlags)))
	goto xEnrollErr; 

    // S/MIME supported? 
    if (S_OK !=(hr=pIEnroll->put_EnableSMIMECapabilities
		(pCertTypeInfo->dwEnrollmentFlags & CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS)))
	goto xEnrollErr; 

    // Set archival cert, if one has been specified. 
    // bstrCA <-- CA_location\CA_Name
    //
    bstrCA      = local.bstrConcat
	(pCAInfo->pwszCALocation,
	 L"\\", 
	 pCAInfo->pwszCADisplayName ? pCAInfo->pwszCADisplayName : pCAInfo->pwszCAName, 
	 L"\0"); 
    if (NULL == bstrCA)
	goto MemoryErr; 

    if (pCertTypeInfo->dwPrivateKeyFlags & CT_FLAG_ALLOW_PRIVATE_KEY_ARCHIVAL)
    {
        if (S_OK != (hr = this->GetCAExchangeCertificate(bstrCA, &pArchivalCert)))
	    goto xEnrollErr;
	
	if (S_OK != (hr = pIEnroll->SetPrivateKeyArchiveCertificate(pArchivalCert)))
	    goto xEnrollErr;
    }
    
    //cert Type extensions
    if(pCertTypeInfo->pCertTypeExtensions)
    {
        if(S_OK != (hr=pIEnroll->AddExtensionsToRequest
                                (pCertTypeInfo->pCertTypeExtensions)))
            goto xEnrollErr;
    }

    //no smart card stuff
    if(S_OK != (hr=pIEnroll->put_ReuseHardwareKeyIfUnableToGenNew(FALSE)))
        goto xEnrollErr;

    //create a PKCS10 request
    if(FAILED(hr=pIEnroll->createPKCS10WStr(NULL,
                                NULL,
                                &PKCS10Blob)))
        goto xEnrollErr;


    //add the name value pair of the enroll-on-behalf
    pwszRequesterName=MkWStr(wszPROPREQUESTERNAME);

    if(NULL==pwszRequesterName)
        goto MemoryErr;

    if(S_OK != (hr=pIEnroll->AddNameValuePairToSignatureWStr( 
           pwszRequesterName, m_pwszUserSAM)))
        goto xEnrollErr;


    //sign the request
    if(S_OK != (hr=pIEnroll->CreatePKCS7RequestFromRequest( 
            &PKCS10Blob,
            m_pSigningCert,
            &PKCS7Request)))
        goto xEnrollErr;


    //send the request to the CA
    //we set the purpose to the renew so that the format
    //will be a PKCS7
    
    bstrReq     = SysAllocStringByteLen((LPCSTR)PKCS7Request.pbData, PKCS7Request.cbData);
    if (NULL == bstrReq)
	goto MemoryErr;

    bstrAttribs = NULL;
    // RECALL: bstrCA <-- CA_location\CA_Name    

    if (pICertRequest == NULL)
    {
        if (S_OK != (hr = CoCreateInstance
                     (CLSID_CCertRequest, 
                      NULL, 
                      CLSCTX_INPROC_SERVER,
                      IID_ICertRequest2, 
                      (void**)&pICertRequest)))
	    goto xEnrollErr; 
    }

    if (S_OK != (hr = pICertRequest->Submit	     
		 (CR_IN_BINARY | CR_IN_PKCS7, 
		  bstrReq, 
		  bstrAttribs, 
		  bstrCA, 
		  (long *)&dwDisposition)))
	goto xEnrollErr;

    //use CR_DISP_ as enrollment status
    m_lEnrollmentStatus = dwDisposition;
    
    // check pending and save pending info
    // however, smart card enrollment station don't know how to deal with
    // this pending requests, may not necessary to do that
    if (CR_DISP_UNDER_SUBMISSION == m_lEnrollmentStatus)
    {
        hr = pICertRequest->GetRequestId((long *)&dwRequestID);
        if (S_OK != hr)
        {
            goto xEnrollErr; 
        }
        hr = pIEnroll->setPendingRequestInfoWStr(
                      dwRequestID, 
                      pCAInfo->pwszCALocation, 
                      NULL != pCAInfo->pwszCADisplayName ?
                          pCAInfo->pwszCADisplayName : pCAInfo->pwszCAName, 
                      NULL); 
    }
    if (CR_DISP_ISSUED != m_lEnrollmentStatus)
    {
        //if not issued, return
        goto CommonReturn; 
    }
    
    //must be CR_DISP_ISSUED
    hr = pICertRequest->GetCertificate(
                CR_OUT_BINARY | CR_OUT_CHAIN, &bstrCertificate);
    if (S_OK != hr)
    {
        goto xEnrollErr;
    }

    // Marshal the cert into a CRYPT_DATA_BLOB, and install it: 
    PKCS7Response.pbData = (LPBYTE)bstrCertificate; 
    PKCS7Response.cbData = SysStringByteLen(bstrCertificate); 
     
    m_pEnrolledCert = pIEnroll->getCertContextFromPKCS7(&PKCS7Response);
    if (NULL == m_pEnrolledCert)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto TraceErr;
    }

    hr=pIEnroll->acceptPKCS7Blob(&PKCS7Response);

    //we delete the enrolled certificate from the "My" store since it is added by
    //xEnroll.  No need to check the error
    SearchAndDeleteCert(m_pEnrolledCert);

    if(S_OK != hr)
    {
        goto TraceErr;
    }

    hr=S_OK;

CommonReturn:

    LeaveCriticalSection(&m_cSection);

    if(pwszNewContainerName) 
        LocalFree((HLOCAL)pwszNewContainerName);

    if(pwszRequesterName)
        FreeWStr(pwszRequesterName);

    //the memory from xEnroll is freed via LocalFree
    //since we use the PIEnrollGetNoCOM function
    if(PKCS10Blob.pbData)
        LocalFree(PKCS10Blob.pbData);

    if(PKCS7Request.pbData)
        LocalFree(PKCS7Request.pbData);

    if (NULL != pArchivalCert)            
	CertFreeCertificateContext(pArchivalCert); 

    // PKCS7Respone's data is just an alias to m_pEnrolledCert's data:  we don't need to free it.

    if (NULL != bstrAttribs)     { SysFreeString(bstrAttribs); } 
    if (NULL != bstrCA)          { SysFreeString(bstrCA); } 
    if (NULL != bstrCertificate) { SysFreeString(bstrCertificate); }
    if (NULL != pICertRequest)   { pICertRequest->Release(); } 
       
    if(pIEnroll)
        pIEnroll->Release();
    
    SetLastError(errBefore);

	return hr;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    hr = CodeToHR(errBefore); 

    //if an error has occurred, the free the enrolled certificate
    if(m_pEnrolledCert)
    {
        CertFreeCertificateContext(m_pEnrolledCert);
        m_pEnrolledCert=NULL;
    }

    goto CommonReturn;

TRACE_ERROR(TraceErr);
SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR_VAR(xEnrollErr, hr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
SET_ERROR_VAR(StatusErr, hr);
}

HRESULT CSCrdEnr::GetCAExchangeCertificate(IN  BSTR             bstrCAQualifiedName, 
					   OUT PCCERT_CONTEXT  *ppCert) 
{
    HRESULT         hr                      = S_OK; 
    ICertRequest2  *pICertRequest            = NULL; 
    VARIANT         varExchangeCertificate; 
    
    // Input validation: 
    if (NULL == bstrCAQualifiedName || NULL == ppCert)
	return E_INVALIDARG; 

    // Init: 
    *ppCert                        = NULL; 
    varExchangeCertificate.vt      = VT_EMPTY; 
    varExchangeCertificate.bstrVal = NULL;

    if (S_OK != (hr = CoCreateInstance
                 (CLSID_CCertRequest, 
                  NULL, 
                  CLSCTX_INPROC_SERVER,
                  IID_ICertRequest2, 
                  (void**)&pICertRequest)))
	goto ErrorReturn; 

    if (S_OK != (hr = pICertRequest->GetCAProperty
		 (bstrCAQualifiedName,     // CA Name/CA Location
		  CR_PROP_CAXCHGCERT,      // Get the exchange certificate from the CA. 
		  0,                       // Unused
		  PROPTYPE_BINARY,         // 
		  CR_OUT_BINARY,           // 
		  &varExchangeCertificate  // Variant type representing the certificate. 
		  )))
	goto ErrorReturn;
 
    if (VT_BSTR != varExchangeCertificate.vt || NULL == varExchangeCertificate.bstrVal)
        goto UnexpectedErr; 

    *ppCert = CertCreateCertificateContext
	(X509_ASN_ENCODING, 
	 (LPBYTE)varExchangeCertificate.bstrVal, 
	 SysStringByteLen(varExchangeCertificate.bstrVal)); 
    if (*ppCert == NULL)
        goto CertCliErr; 

 CommonReturn: 
    if (NULL != pICertRequest)                    { pICertRequest->Release(); }
    if (NULL != varExchangeCertificate.bstrVal)  { SysFreeString(varExchangeCertificate.bstrVal); } 
    return hr; 
   
 ErrorReturn:
    if (ppCert != NULL && *ppCert != NULL)
    {
	CertFreeCertificateContext(*ppCert);
	*ppCert = NULL;
    }
    
    goto CommonReturn; 

SET_HRESULT(CertCliErr, HRESULT_FROM_WIN32(GetLastError()));
SET_HRESULT(UnexpectedErr, E_UNEXPECTED);
}


STDMETHODIMP CSCrdEnr::selectSigningCertificate
        (/* [in] */                   DWORD     dwFlags,
         /* [in] */                   BSTR      bstrCertTemplateName)
{
    HRESULT                             hr= E_FAIL;
    DWORD                               errBefore= GetLastError();
    CRYPTUI_SELECTCERTIFICATE_STRUCT    SelCert;
    BOOL                                fSCardSigningCert=FALSE;        
    DWORD                               dwCSPTypeSigningCert=0;     
    DWORD                               dwSize=0;
    DWORD                               dwImpType=0;
    SCrdEnroll_CERT_SELECT_INFO         CertSelectInfo;


    HCRYPTPROV                          hProv=NULL; //no need to free it
    LPSTR                               pszContainerSigningCert=NULL; 
    LPSTR                               pszCSPNameSigningCert=NULL;   
    PCCERT_CONTEXT                      pSigningCert=NULL;
    HCERTSTORE                          hMyStore=NULL;

    CERT_CHAIN_PARA ChainParams;
    CERT_CHAIN_POLICY_PARA ChainPolicy;
    CERT_CHAIN_POLICY_STATUS PolicyStatus;
    CERT_CHAIN_CONTEXT const *pCertChain = NULL;

    memset(&SelCert, 0, sizeof(CRYPTUI_SELECTCERTIFICATE_STRUCT));

    EnterCriticalSection(&m_cSection);

    //select a signing certificate in my store with private key
    hMyStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
							    g_dwMsgAndCertEncodingType,
							    NULL,
							    CERT_SYSTEM_STORE_CURRENT_USER,
							    L"my");

    if(NULL==hMyStore)
        goto TraceErr;

    CertSelectInfo.dwFlags = dwFlags;
    CertSelectInfo.pwszCertTemplateName = bstrCertTemplateName;

    SelCert.dwSize=sizeof(CRYPTUI_SELECTCERTIFICATE_STRUCT);
    SelCert.cDisplayStores=1;
    SelCert.rghDisplayStores=&hMyStore;
    SelCert.pFilterCallback=SelectSignCertCallBack;
    SelCert.pvCallbackData=&CertSelectInfo;

    pSigningCert=CryptUIDlgSelectCertificate(&SelCert);

    if(NULL==pSigningCert)
    {
        //user clicks on the cancel button.  
        hr=S_OK;
        goto CommonReturn;
    }

    //verification on the cert
    ZeroMemory(&ChainParams, sizeof(ChainParams));
    ChainParams.cbSize = sizeof(ChainParams);
    ChainParams.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;

    //get cert chain 1st
    if (!CertGetCertificateChain(
                HCCE_CURRENT_USER,  //enrollment agent
                pSigningCert,   //signing cert
                NULL,   //use current system time
                NULL,   //no additional stores
                &ChainParams,   //chain params
                0,   //no crl check
                NULL,   //reserved
                &pCertChain))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto CertGetCertificateChainError;
    }

    ZeroMemory(&ChainPolicy, sizeof(ChainPolicy));
    ChainPolicy.cbSize = sizeof(ChainPolicy);
    ChainPolicy.dwFlags = CERT_CHAIN_POLICY_IGNORE_NOT_TIME_NESTED_FLAG;
    ZeroMemory(&PolicyStatus, sizeof(PolicyStatus));
    PolicyStatus.cbSize = sizeof(PolicyStatus);
    PolicyStatus.lChainIndex = -1;
    PolicyStatus.lElementIndex = -1;

    //verify the chain
    if (!CertVerifyCertificateChainPolicy(
                CERT_CHAIN_POLICY_BASE,  //basic
                pCertChain,
                &ChainPolicy,
                &PolicyStatus))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto CertVerifyCertificateChainPolicyError;
    }
    if (S_OK != PolicyStatus.dwError)
    {
        hr = PolicyStatus.dwError;
        goto CertVerifyCertificateChainPolicyError;
    }

    //get the hProv 
    if(!CryptAcquireCertificatePrivateKey(
        pSigningCert,
        CRYPT_ACQUIRE_CACHE_FLAG | CRYPT_ACQUIRE_COMPARE_KEY_FLAG,
        NULL,
        &hProv,     //this handle is cached and no need to be freed
        NULL,
        NULL))
        goto TraceErr;

    //get related information  
    //impType
    dwSize = sizeof(dwImpType);

    if(!CryptGetProvParam(hProv,
                PP_IMPTYPE,
                (BYTE *)(&dwImpType),
                &dwSize,
                0))
        goto TraceErr;

    if(CRYPT_IMPL_REMOVABLE & dwImpType)
        fSCardSigningCert=TRUE;

    //CSP Type
    dwSize = sizeof(dwCSPTypeSigningCert);  

    if(!CryptGetProvParam(hProv,
                PP_PROVTYPE,
                (BYTE *)(&dwCSPTypeSigningCert),
                &dwSize,
                0))
    {
            goto TraceErr;   
    }


    //CSP name
    dwSize = 0;

    if(!CryptGetProvParam(hProv,
                            PP_NAME,
                            NULL,
                            &dwSize,
                            0) || (0==dwSize))
        goto TraceErr;

    
    pszCSPNameSigningCert = (LPSTR) SCrdEnrollAlloc(dwSize);

    if(NULL == pszCSPNameSigningCert)
        goto MemoryErr;

    if(!CryptGetProvParam(hProv,
                            PP_NAME,
                            (BYTE *)pszCSPNameSigningCert,
                            &dwSize,
                            0))
        goto TraceErr;

    //Container name
    dwSize = 0;

    if(!CryptGetProvParam(hProv,
                           PP_CONTAINER,
                            NULL,
                            &dwSize,
                            0) || (0==dwSize))
        goto TraceErr;

    
    pszContainerSigningCert = (LPSTR) SCrdEnrollAlloc(dwSize);

    if(NULL == pszContainerSigningCert)
        goto MemoryErr;

    if(!CryptGetProvParam(hProv,
                          PP_CONTAINER,
                            (BYTE *)pszContainerSigningCert,
                            &dwSize,
                            0))
        goto TraceErr;


    //now, we need to perform a signig operation so that we 
    //can invoke the smard card dialogue and cash the reader information
    //to the hProv handle.  This operation is benign if the CSP of the signing
    //certificate is not on a smart card
    if(!SignWithCert(pszCSPNameSigningCert,
                     dwCSPTypeSigningCert,
                     pSigningCert))
        goto TraceErr;


    //the certificate looks good
    if(m_pSigningCert)
        CertFreeCertificateContext(m_pSigningCert);

    if(m_pszContainerSigningCert)
        SCrdEnrollFree(m_pszContainerSigningCert);

    if(m_pszCSPNameSigningCert)
        SCrdEnrollFree(m_pszCSPNameSigningCert);

    m_pSigningCert=pSigningCert;
    m_fSCardSigningCert = fSCardSigningCert;       
    m_pszCSPNameSigningCert = pszCSPNameSigningCert;  
    m_dwCSPTypeSigningCert = dwCSPTypeSigningCert;    
    m_pszContainerSigningCert = pszContainerSigningCert; 
    
    pSigningCert=NULL;
    pszCSPNameSigningCert=NULL;
    pszContainerSigningCert=NULL;

    hr=S_OK;

CommonReturn:

    LeaveCriticalSection(&m_cSection);

    if(pSigningCert)
        CertFreeCertificateContext(pSigningCert);

    if(hMyStore)
        CertCloseStore(hMyStore, 0);

    if(pszContainerSigningCert)
        SCrdEnrollFree(pszContainerSigningCert);

    if(pszCSPNameSigningCert)
        SCrdEnrollFree(pszCSPNameSigningCert);

    if (NULL != pCertChain)
    {
        CertFreeCertificateChain(pCertChain);
    }

    SetLastError(errBefore);

	return hr;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    hr = CodeToHR(errBefore);

	goto CommonReturn;

TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);     
TRACE_ERROR(CertGetCertificateChainError)
TRACE_ERROR(CertVerifyCertificateChainPolicyError)
}


STDMETHODIMP CSCrdEnr::setSigningCertificate
        (/* [in] */                   DWORD     dwFlags, 
         /* [in] */                   BSTR      bstrCertTemplateName)
{
    HRESULT                             hr= E_FAIL;
    DWORD                               errBefore= GetLastError();
    BOOL                                fSCardSigningCert=FALSE;        
    DWORD                               dwCSPTypeSigningCert=0;     
    DWORD                               dwSize=0;
    DWORD                               dwImpType=0;
    SCrdEnroll_CERT_SELECT_INFO         CertSelectInfo;
    BOOL                                fSetCert=FALSE;


    HCRYPTPROV                          hProv=NULL;     //no need to free it
    PCCERT_CONTEXT                      pPreCert=NULL;  //no need to free it
    LPSTR                               pszContainerSigningCert=NULL; 
    LPSTR                               pszCSPNameSigningCert=NULL;   
    PCCERT_CONTEXT                      pSigningCert=NULL;
    HCERTSTORE                          hMyStore=NULL;



    EnterCriticalSection(&m_cSection);

    //mark if the signing cert is set previously
    if(m_pSigningCert)
        fSetCert=TRUE;
 
    //select a signing certificate in my store with private key
    hMyStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
							    g_dwMsgAndCertEncodingType,
							    NULL,
							    CERT_SYSTEM_STORE_CURRENT_USER,
							    L"my");

    if(NULL==hMyStore)
        goto TraceErr;

    CertSelectInfo.dwFlags = dwFlags;
    CertSelectInfo.pwszCertTemplateName = bstrCertTemplateName;


    while(pSigningCert = CertEnumCertificatesInStore(hMyStore, pPreCert))
    {

        //check for the certificate
        if(!SelectSignCertCallBack(pSigningCert, NULL, &CertSelectInfo))
            goto NextCert;

        //this is a detaul NO-UI selection.  We can not handle the case
        //when the signing certificate is on a smart card
        if(SmartCardCSP(pSigningCert))
		   goto NextCert;

        //get the hProv 
        if(!CryptAcquireCertificatePrivateKey(
            pSigningCert,
            CRYPT_ACQUIRE_CACHE_FLAG | CRYPT_ACQUIRE_COMPARE_KEY_FLAG,
            NULL,
            &hProv,     //this handle is cached and no need to be freed
            NULL,
            NULL))
            goto NextCert;

        //get related information  
        //impType
        dwSize = sizeof(dwImpType);

        if(!CryptGetProvParam(hProv,
                    PP_IMPTYPE,
                    (BYTE *)(&dwImpType),
                    &dwSize,
                    0))
            goto NextCert;

        if(CRYPT_IMPL_REMOVABLE & dwImpType)
            fSCardSigningCert=TRUE;

        //CSP Type
        dwSize = sizeof(dwCSPTypeSigningCert);  

        if(!CryptGetProvParam(hProv,
                    PP_PROVTYPE,
                    (BYTE *)(&dwCSPTypeSigningCert),
                    &dwSize,
                    0))
            goto NextCert;


        //CSP name
        dwSize = 0;

        if(!CryptGetProvParam(hProv,
                                PP_NAME,
                                NULL,
                                &dwSize,
                                0) || (0==dwSize))
            goto NextCert;

    
        pszCSPNameSigningCert = (LPSTR) SCrdEnrollAlloc(dwSize);

        if(NULL == pszCSPNameSigningCert)
            goto MemoryErr;

        if(!CryptGetProvParam(hProv,
                                PP_NAME,
                                (BYTE *)pszCSPNameSigningCert,
                                &dwSize,
                                0))
            goto NextCert;

        //Container name
        dwSize = 0;

        if(!CryptGetProvParam(hProv,
                               PP_CONTAINER,
                                NULL,
                                &dwSize,
                                0) || (0==dwSize))
            goto NextCert;

    
        pszContainerSigningCert = (LPSTR) SCrdEnrollAlloc(dwSize);

        if(NULL == pszContainerSigningCert)
            goto MemoryErr;

        if(!CryptGetProvParam(hProv,
                              PP_CONTAINER,
                                (BYTE *)pszContainerSigningCert,
                                &dwSize,
                                0))
            goto NextCert;


        //now, we need to perform a signig operation so that we 
        //can invoke the smard card dialogue and cash the reader information
        //to the hProv handle.  This operation is benign if the CSP of the signing
        //certificate is not on a smart card
        if(!SignWithCert(pszCSPNameSigningCert,
                         dwCSPTypeSigningCert,
                         pSigningCert))
            goto NextCert;

        //the certificate looks good
        if((NULL == m_pSigningCert) || (TRUE == fSetCert) ||
            (IsNewerCert(pSigningCert, m_pSigningCert)))
        {
            fSetCert = FALSE;

            if(m_pSigningCert)
            {
                CertFreeCertificateContext(m_pSigningCert);
                m_pSigningCert = NULL;
            }

            m_pSigningCert=CertDuplicateCertificateContext(pSigningCert);
            if(NULL == m_pSigningCert)
                goto DupErr;

            //copy the data
            if(m_pszContainerSigningCert)
                SCrdEnrollFree(m_pszContainerSigningCert);

            if(m_pszCSPNameSigningCert)
                SCrdEnrollFree(m_pszCSPNameSigningCert);

            m_fSCardSigningCert = fSCardSigningCert;       
            m_pszCSPNameSigningCert = pszCSPNameSigningCert;  
            m_dwCSPTypeSigningCert = dwCSPTypeSigningCert;    
            m_pszContainerSigningCert = pszContainerSigningCert;

            pszCSPNameSigningCert=NULL;
            pszContainerSigningCert=NULL;

            // should select the 1st matched cert
            break; //out of while loop
        }
    
NextCert:

        if(pszContainerSigningCert)
            SCrdEnrollFree(pszContainerSigningCert);

        if(pszCSPNameSigningCert)
            SCrdEnrollFree(pszCSPNameSigningCert);

        pszCSPNameSigningCert=NULL;
        pszContainerSigningCert=NULL;
        fSCardSigningCert=FALSE;        
        dwCSPTypeSigningCert=0;     
        dwSize=0;
        dwImpType=0;

        pPreCert = pSigningCert;
    }

    //we should find a certificate
    if((NULL == m_pSigningCert) || (m_pSigningCert && (TRUE == fSetCert)))
        goto CryptNotFindErr;

    hr=S_OK;

CommonReturn:

    LeaveCriticalSection(&m_cSection);

    if(pSigningCert)
        CertFreeCertificateContext(pSigningCert);

    if(hMyStore)
        CertCloseStore(hMyStore, 0);

    if(pszContainerSigningCert)
        SCrdEnrollFree(pszContainerSigningCert);

    if(pszCSPNameSigningCert)
        SCrdEnrollFree(pszCSPNameSigningCert);

    SetLastError(errBefore);

	return hr;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    hr = CodeToHR(errBefore);

	goto CommonReturn;

TRACE_ERROR(DupErr); 
SET_ERROR(CryptNotFindErr, CRYPT_E_NOT_FOUND);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
TRACE_ERROR(TraceErr);
}


STDMETHODIMP CSCrdEnr::get_EnrollmentStatus
( /* [retval][out] */ LONG * plEnrollmentStatus)
{
    if (plEnrollmentStatus == NULL)
    {
        return E_INVALIDARG; 
    }

    EnterCriticalSection(&m_cSection); 
    *plEnrollmentStatus = m_lEnrollmentStatus; 
    LeaveCriticalSection(&m_cSection); 

    return S_OK;
}



STDMETHODIMP CSCrdEnr::getEnrolledCertificateName
        (/*[in]  */                   DWORD     dwFlags,
        /* [retval][out] */           BSTR      *pBstrCertName)
{
    HRESULT                         hr= E_FAIL;
    DWORD                           errBefore= GetLastError();
    DWORD                           dwChar=0;
    LPWSTR                          pwsz=NULL;    
    CRYPTUI_VIEWCERTIFICATE_STRUCT  CertViewStruct;


    EnterCriticalSection(&m_cSection);

    if(NULL == m_pEnrolledCert)
        goto InvalidArgErr;

    *pBstrCertName=NULL;
    
    if(0 == (SCARD_ENROLL_NO_DISPLAY_CERT & dwFlags))
    {
        //view the certificate
        memset(&CertViewStruct, 0, sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT));   

        CertViewStruct.dwSize=sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT);
        CertViewStruct.pCertContext=m_pEnrolledCert;
        CertViewStruct.dwFlags=CRYPTUI_DISABLE_EDITPROPERTIES | CRYPTUI_DISABLE_ADDTOSTORE;

        CryptUIDlgViewCertificate(&CertViewStruct, NULL);
    }


    dwChar=CertGetNameStringW(
        m_pEnrolledCert,
        CERT_NAME_SIMPLE_DISPLAY_TYPE,
        0,
        NULL,
        NULL,
        0); 

    if ((dwChar != 0) && (NULL != (pwsz = (LPWSTR)SCrdEnrollAlloc(dwChar * sizeof(WCHAR)))))
    {
        CertGetNameStringW(
            m_pEnrolledCert,
            CERT_NAME_SIMPLE_DISPLAY_TYPE,
            0,
            NULL,
            pwsz,
            dwChar);
                 
        if( NULL == (*pBstrCertName = SysAllocString(pwsz)) )
            goto MemoryErr;
    }
     
    hr=S_OK;

CommonReturn: 

    LeaveCriticalSection(&m_cSection);


    if(pwsz)
        SCrdEnrollFree(pwsz);
    
    SetLastError(errBefore);

	return hr;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    hr = CodeToHR(errBefore);

	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}


STDMETHODIMP CSCrdEnr::resetUser()
{
    EnterCriticalSection(&m_cSection);

    if(m_pwszUserUPN)
    {
        SCrdEnrollFree(m_pwszUserUPN);
        m_pwszUserUPN=NULL;
    }

    if(m_pwszUserSAM)
    {
        SCrdEnrollFree(m_pwszUserSAM);
        m_pwszUserSAM=NULL;
    }                


    if(m_pEnrolledCert)
    {
        CertFreeCertificateContext(m_pEnrolledCert);
        m_pEnrolledCert=NULL;
    }
    
    LeaveCriticalSection(&m_cSection);
    
    return S_OK;

}

STDMETHODIMP CSCrdEnr::enumCSPName
       (/* [in] */                    DWORD dwIndex, 
        /* [in] */                    DWORD dwFlags, 
        /* [retval][out] */           BSTR *pbstrCSPName)
{
    HRESULT            hr= E_FAIL;
    DWORD              errBefore= GetLastError();

    EnterCriticalSection(&m_cSection);

    if(NULL == pbstrCSPName)
        goto InvalidArgErr;

    *pbstrCSPName=NULL;

    if(0 == m_dwCSPCount || NULL == m_rgCSPInfo)
        goto InvalidArgErr;

    if(dwIndex >= m_dwCSPCount)
        goto  NoItemErr;

    if( NULL == (*pbstrCSPName = SysAllocString(m_rgCSPInfo[dwIndex].pwszCSPName)))
        goto MemoryErr;
 
    hr=S_OK;

CommonReturn:

    LeaveCriticalSection(&m_cSection);

    SetLastError(errBefore);

	return hr;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    hr = CodeToHR(errBefore);

	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
SET_ERROR(NoItemErr,ERROR_NO_MORE_ITEMS);
}


STDMETHODIMP CSCrdEnr::getUserName
       (/* [in] */                    DWORD dwFlags, 
        /* [retval][out] */           BSTR *pbstrUserName)
{
    HRESULT                             hr= E_FAIL;
    DWORD                               errBefore= GetLastError();

    EnterCriticalSection(&m_cSection);

    if(!pbstrUserName)
        goto InvalidArgErr;

    *pbstrUserName = NULL;

    if((NULL==m_pwszUserUPN) && (NULL==m_pwszUserSAM))
        goto InvalidArgErr;

    if(SCARD_ENROLL_UPN_NAME & dwFlags)
    {
		if(NULL == m_pwszUserUPN)
			goto InvalidArgErr;

        if( NULL == (*pbstrUserName = SysAllocString(m_pwszUserUPN)))
                goto MemoryErr;
    }
	else
	{
		if(NULL == m_pwszUserSAM)
			goto InvalidArgErr;

		if( NULL == (*pbstrUserName = SysAllocString(m_pwszUserSAM)))
				goto MemoryErr;
	}

    hr= S_OK;

CommonReturn:

    LeaveCriticalSection(&m_cSection);

    SetLastError(errBefore);

	return hr;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    hr = CodeToHR(errBefore);

	goto CommonReturn;


SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}

STDMETHODIMP CSCrdEnr::setUserName
       (/* [in] */                    DWORD dwFlags, 
        /* [in] */                    BSTR  bstrUserName)
{
    HRESULT                             hr= E_FAIL;
    DWORD                               errBefore= GetLastError();
    LPWSTR                              pwszSAM=NULL;

    EnterCriticalSection(&m_cSection);

    if(!bstrUserName)
        goto InvalidArgErr;

    if(SCARD_ENROLL_UPN_NAME & dwFlags)
	{
        //the UPN name has to have a corresponding SAM name
        if(!GetName(bstrUserName, NameUserPrincipal, NameSamCompatible, &pwszSAM))
            goto TraceErr;

        if(m_pwszUserUPN)
        {
            SCrdEnrollFree(m_pwszUserUPN);
            m_pwszUserUPN=NULL;
        }

        if(m_pwszUserSAM)
        {
            SCrdEnrollFree(m_pwszUserSAM);
            m_pwszUserSAM=NULL;
        }

        if(NULL == (m_pwszUserUPN=CopyWideString(bstrUserName)))
            goto MemoryErr;

        m_pwszUserSAM=pwszSAM;

        pwszSAM = NULL;
	}
	else
    {
        if(m_pwszUserUPN)
        {
            SCrdEnrollFree(m_pwszUserUPN);
            m_pwszUserUPN=NULL;
        }

        if(m_pwszUserSAM)
        {
            SCrdEnrollFree(m_pwszUserSAM);
            m_pwszUserSAM=NULL;
        }

        if(NULL == (m_pwszUserSAM=CopyWideString(bstrUserName)))
            goto MemoryErr;

        GetName(m_pwszUserSAM,
            NameSamCompatible,
            NameUserPrincipal,
            &m_pwszUserUPN);
    }

    hr= S_OK;

CommonReturn:

    LeaveCriticalSection(&m_cSection);

    if(pwszSAM)
        SCrdEnrollFree(pwszSAM);

    SetLastError(errBefore);

	return hr;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    hr = CodeToHR(errBefore);

	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
TRACE_ERROR(TraceErr);
}

STDMETHODIMP CSCrdEnr::getCertTemplateCount
        (/* [in] */                   DWORD dwFlags, 
         /* [retval][out] */          long *pdwCertTemplateCount)
{
    return CertTemplateCountOrName(
                    0, //index, doesn't matter what it is
                    dwFlags,
                    pdwCertTemplateCount,
                    NULL); //count
}

STDMETHODIMP CSCrdEnr::getCertTemplateName
        (/* [in] */                   DWORD dwFlags, 
		 /* [retval][out] */          BSTR *pbstrCertTemplateName)
{
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_cSection);

    if(NULL==m_rgCTInfo || 0==m_dwCTCount)
    {
        *pbstrCertTemplateName=NULL;
        hr=E_INVALIDARG;
    }
    else
    {
		if(dwFlags & SCARD_ENROLL_CERT_TEMPLATE_DISPLAY_NAME)
		{
			if( NULL == (*pbstrCertTemplateName = SysAllocString(m_rgCTInfo[m_dwCTIndex].pwszCTDisplayName)))
				hr = E_OUTOFMEMORY;
		}
		else
		{
			if( NULL == (*pbstrCertTemplateName = SysAllocString(m_rgCTInfo[m_dwCTIndex].pwszCTName)))
				hr = E_OUTOFMEMORY;
		}
    }

    LeaveCriticalSection(&m_cSection);

    return(hr);  
}

STDMETHODIMP CSCrdEnr::setCertTemplateName
		(/* [in] */                   DWORD dwFlags, 
		 /* [in] */                   BSTR bstrCertTemplateName)
{
    HRESULT            hr= E_FAIL;
    DWORD              errBefore= GetLastError();

    DWORD              dwIndex=0;

    EnterCriticalSection(&m_cSection);

    if(NULL==m_rgCTInfo || 0==m_dwCTCount)
        goto InvalidArgErr;

    for(dwIndex=0; dwIndex < m_dwCTCount; dwIndex++)
    {
		if(dwFlags & SCARD_ENROLL_CERT_TEMPLATE_DISPLAY_NAME)
		{
			if(0 == _wcsicmp(bstrCertTemplateName, m_rgCTInfo[dwIndex].pwszCTDisplayName))
			{
				m_dwCTIndex=dwIndex;
				break;
			}
		}
		else
		{
			if(0 == _wcsicmp(bstrCertTemplateName, m_rgCTInfo[dwIndex].pwszCTName))
			{
				m_dwCTIndex=dwIndex;
				break;
			}
		}
    }

    if(dwIndex == m_dwCTCount)
        goto InvalidArgErr;  

    //we need to get the CA information for the newly selected cert type
    if(FALSE == m_rgCTInfo[m_dwCTIndex].fCAInfo)
    {
       GetCAInfoFromCertType(NULL,
							 m_rgCTInfo[m_dwCTIndex].pwszCTName,
                             &(m_rgCTInfo[m_dwCTIndex].dwCACount),
                             &(m_rgCTInfo[m_dwCTIndex].rgCAInfo));

       m_rgCTInfo[m_dwCTIndex].dwCAIndex=0;

       m_rgCTInfo[m_dwCTIndex].fCAInfo=TRUE;
    }
    
    hr=S_OK;

CommonReturn:

    LeaveCriticalSection(&m_cSection);
    
    SetLastError(errBefore);

	return hr;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    hr = CodeToHR(errBefore);

	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);    
}


HRESULT CSCrdEnr::CertTemplateCountOrName(
    IN  DWORD dwIndex, 
    IN  DWORD dwFlags, 
    OUT long *pdwCertTemplateCount,
    OUT BSTR *pbstrCertTemplateName)
{
    HRESULT hr;
    DWORD   errBefore = GetLastError();
    DWORD   dwIdx = 0;
    DWORD   dwValidCount = 0;
    BOOL    fCount;
    WCHAR  *pwszName;
    DWORD const OFFLINE_SUBJECT_NAME_FLAGS = 
                        CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT |
                        CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT_ALT_NAME;

    EnterCriticalSection(&m_cSection);

    if (NULL == pdwCertTemplateCount && NULL == pbstrCertTemplateName)
    {
        //can't be both
        goto InvalidParamErr;
    }

    //set flag for use of count or enum
    fCount = (NULL != pdwCertTemplateCount);

    if (fCount)
    {
        //init out
        *pdwCertTemplateCount = 0;
    }
    else
    {
        //init out
        *pbstrCertTemplateName = NULL;

        if (0 == m_dwCTCount || NULL == m_rgCTInfo)
        {
            //no templates
            goto InvalidArgErr;
        }

        if (dwIndex >= m_dwCTCount)
        {
            goto NoItemErr;
        }
    }

    //set default flags if not defined by caller
    if (0x0 == (dwFlags & SCARD_ENROLL_USER_CERT_TEMPLATE) &&
        0x0 == (dwFlags & SCARD_ENROLL_MACHINE_CERT_TEMPLATE))
    {
        //assume both machine and user
        dwFlags |= SCARD_ENROLL_USER_CERT_TEMPLATE |
                   SCARD_ENROLL_MACHINE_CERT_TEMPLATE; 
    }

    if (0x0 == (dwFlags & SCARD_ENROLL_ENTERPRISE_CERT_TEMPLATE) &&
        0x0 == (dwFlags & SCARD_ENROLL_OFFLINE_CERT_TEMPLATE)) 
    {
        //assume both enterprise and offline
        dwFlags |= SCARD_ENROLL_ENTERPRISE_CERT_TEMPLATE |
                   SCARD_ENROLL_OFFLINE_CERT_TEMPLATE; 
    }

    for (dwIdx = 0; dwIdx < m_dwCTCount; dwIdx++)
    {
        if (0x0 == (dwFlags & SCARD_ENROLL_CROSS_CERT_TEMPLATE) &&
            0 < m_rgCTInfo[dwIdx].dwRASignature)
        {
            //don't include template require signatures
            continue;
        }

        if((0x0 != (SCARD_ENROLL_USER_CERT_TEMPLATE & dwFlags) &&
            FALSE == m_rgCTInfo[dwIdx].fMachine) ||
           (0x0 != (SCARD_ENROLL_MACHINE_CERT_TEMPLATE & dwFlags) &&
            TRUE == m_rgCTInfo[dwIdx].fMachine))
        {
            if (0 != (SCARD_ENROLL_ENTERPRISE_CERT_TEMPLATE & dwFlags) &&
                0 == (OFFLINE_SUBJECT_NAME_FLAGS &
                      m_rgCTInfo[dwIdx].dwSubjectNameFlags))
            {
                //enterprise user/machine and no subject DN required
                dwValidCount++;  
            }
            else if (0 != (SCARD_ENROLL_OFFLINE_CERT_TEMPLATE & dwFlags) && 
                     0 != (OFFLINE_SUBJECT_NAME_FLAGS &
                           m_rgCTInfo[dwIdx].dwSubjectNameFlags))
            {
                //offline user/machine and subject DN required
                dwValidCount++;
            }
        }

        if (!fCount && dwValidCount == (dwIndex + 1))
        {
            //get name & hit the one by index. get display or real name 
            if (0x0 != (dwFlags & SCARD_ENROLL_CERT_TEMPLATE_DISPLAY_NAME))
            {
                //display name
                pwszName = m_rgCTInfo[dwIdx].pwszCTDisplayName;
            }
            else
            {
                //real name
                pwszName = m_rgCTInfo[dwIdx].pwszCTName;
            }
            *pbstrCertTemplateName = SysAllocString(pwszName);
            if (NULL == *pbstrCertTemplateName)
            {
                goto MemoryErr;
            }
            else
            {
                //done
                break;
            }
        }
    }

    if(!fCount && dwIdx == m_dwCTCount)
    {
        //go beyond
        goto  NoItemErr;
    }

    if (fCount)
    {
        *pdwCertTemplateCount = dwValidCount;
    }
 
    hr = S_OK;
CommonReturn:
    LeaveCriticalSection(&m_cSection);
    SetLastError(errBefore);
	return hr;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;
    hr = CodeToHR(errBefore);
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG)
SET_ERROR(InvalidParamErr, HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER))
SET_ERROR(MemoryErr, E_OUTOFMEMORY)
SET_ERROR(NoItemErr,ERROR_NO_MORE_ITEMS)
}

STDMETHODIMP CSCrdEnr::enumCertTemplateName       
       (/* [in] */                    DWORD dwIndex, 
        /* [in] */                    DWORD dwFlags, 
        /* [retval][out] */           BSTR *pbstrCertTemplateName)
{
    return CertTemplateCountOrName(
                dwIndex,
                dwFlags,
                NULL,  //get name
                pbstrCertTemplateName);
}

HRESULT CSCrdEnr::_getCertTemplateExtensionInfo(
    IN CERT_EXTENSIONS  *pCertTypeExtensions,
    IN LONG              lType,
    OUT VOID            *pExtInfo)
{
    HRESULT  hr;
    DWORD    cwc = 0;
    DWORD    dwCTE;
    DWORD    i;
    BOOL     fV2 = FALSE; //default v1 template
    BOOL     fDword = TRUE;
    DWORD    dwValue;

    EnterCriticalSection(&m_cSection);

    if (NULL == m_pCachedCTEs || m_pCachedCTEs != pCertTypeExtensions)
    {
        //new template, don't use cache
        //free the current cache if any
        if (NULL != m_pwszCachedCTEOid)
        {
            LocalFree(m_pwszCachedCTEOid);
            m_pwszCachedCTEOid = NULL;
        }
        if (NULL != m_pCachedCTE)
        {
            LocalFree(m_pCachedCTE);
            m_pCachedCTE = NULL;
        }
        //reset extension pointer
        m_pCachedCTEs = NULL;

        //loop to find CT extension
        for (i = 0; i < pCertTypeExtensions->cExtension; ++i)
        {
            if (0 == _stricmp(pCertTypeExtensions->rgExtension[i].pszObjId,
                              szOID_CERTIFICATE_TEMPLATE))
            {
                //v2 template
                fV2 = TRUE;
                //cache it
                m_pCachedCTEs = pCertTypeExtensions;
                break;
            }
        }

        if (!fV2)
        {
            //v1 template, return empty string
            m_pwszCachedCTEOid = (WCHAR*)LocalAlloc(LMEM_FIXED, sizeof(WCHAR));
            if (NULL == m_pwszCachedCTEOid)
            {
                hr = E_OUTOFMEMORY;
                goto MemoryErr;
            }
            m_pwszCachedCTEOid[0] = L'\0';
        }
        else
        {
            //decode cert template extension
            if (!CryptDecodeObjectEx(
                        X509_ASN_ENCODING,
                        X509_CERTIFICATE_TEMPLATE,
                        pCertTypeExtensions->rgExtension[i].Value.pbData,
                        pCertTypeExtensions->rgExtension[i].Value.cbData,
                        CRYPT_DECODE_ALLOC_FLAG,
                        NULL,     //use default LocalAlloc
                        (void*)&m_pCachedCTE,
                        &dwCTE))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto CryptDecodeObjectExErr;
            }

            //have to convert asn to wchar
            while (TRUE)
            {
                cwc = MultiByteToWideChar(
                            GetACP(),
                            0,
                            m_pCachedCTE->pszObjId,
                            -1,
                            m_pwszCachedCTEOid,
                            cwc);
                if (0 >= cwc)
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    goto MultiByteToWideCharErr;
                }
                if (NULL != m_pwszCachedCTEOid)
                {
                    //done
                    break;
                }
                m_pwszCachedCTEOid = (WCHAR*)LocalAlloc(LMEM_FIXED,
                                            cwc * sizeof(WCHAR));
                if (NULL == m_pwszCachedCTEOid)
                {
                    hr = E_OUTOFMEMORY;
                    goto MemoryErr;
                }
            }
        }
    }

    //hit here, either from cached or new cache
    switch (lType)
    {
        case SCARD_CTINFO_EXT_OID:
            *(WCHAR**)pExtInfo = m_pwszCachedCTEOid;
        break;
        case SCARD_CTINFO_EXT_MAJOR:
            if (NULL != m_pCachedCTE)
            {
                *(LONG*)pExtInfo = m_pCachedCTE->dwMajorVersion;
            }
            else
            {
                //must be v1
                *(LONG*)pExtInfo = 0;
            }
        break;
        case SCARD_CTINFO_EXT_MINOR:
            if (NULL != m_pCachedCTE)
            {
                *(LONG*)pExtInfo = m_pCachedCTE->dwMinorVersion;
            }
            else
            {
                //must be v1
                *(LONG*)pExtInfo = 0;
            }
        break;
        case SCARD_CTINFO_EXT_MINOR_FLAG:
            if (NULL != m_pCachedCTE)
            {
                *(LONG*)pExtInfo = m_pCachedCTE->fMinorVersion;
            }
            else
            {
                //must be v1
                *(LONG*)pExtInfo = 0;
            }
        break;
        default:
            hr = E_INVALIDARG;
            goto InvalidArgError;
    }

    hr = S_OK;
ErrorReturn:
    LeaveCriticalSection(&m_cSection);
    return hr;

TRACE_ERROR(CryptDecodeObjectExErr)
TRACE_ERROR(MemoryErr)
TRACE_ERROR(MultiByteToWideCharErr)
TRACE_ERROR(InvalidArgError)
}

HRESULT CSCrdEnr::_getStrCertTemplateCSPList(
    IN DWORD             dwIndex,
    IN DWORD             dwFlag,
    OUT WCHAR          **ppwszSupportedCSP)
{
    HRESULT  hr;
    DWORD    i;
    WCHAR  **ppwsz;
    WCHAR   *pwszOut = NULL;

    EnterCriticalSection(&m_cSection);

    //init
    *ppwszSupportedCSP = NULL;

    if (SCARD_CTINFO_CSPLIST_FIRST == dwFlag)
    {
        //reset to first
        m_rgCTInfo[dwIndex].dwCurrentCSP = 0;
    }

    //get it
    ppwsz = m_rgCTInfo[dwIndex].rgpwszSupportedCSPs;
    for (i = 0; i < m_rgCTInfo[dwIndex].dwCurrentCSP && NULL != *ppwsz; ++i)
    {
        ++ppwsz;
    }
    if (NULL == *ppwsz)
    {
        //hit the end
        hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
        goto NoMoreItemsErr;
    }        

    // allocate buffer
    pwszOut = (WCHAR*)LocalAlloc(LMEM_FIXED, (wcslen(*ppwsz) + 1) * sizeof(WCHAR));
    if (NULL == pwszOut)
    {
        hr = E_OUTOFMEMORY;
        goto MemoryErr;
    }

    //copy string
    wcscpy(pwszOut, *ppwsz);
    *ppwszSupportedCSP = pwszOut;
    pwszOut = NULL;
    ++m_rgCTInfo[dwIndex].dwCurrentCSP;

    hr = S_OK;
ErrorReturn:
    LeaveCriticalSection(&m_cSection);
    if (NULL != pwszOut)
    {
        LocalFree(pwszOut);
    }
    return hr;

TRACE_ERROR(MemoryErr)
TRACE_ERROR(NoMoreItemsErr)
}

STDMETHODIMP CSCrdEnr::getCertTemplateInfo(
    /* [in] */                   BSTR     bstrCertTemplateName, 
    /* [in] */                   LONG     lType,
    /* [retval][out] */          VARIANT *pvarCertTemplateInfo)
{
    HRESULT hr;
    DWORD   dwIndex;
    WCHAR  *pwszInfo = NULL;
    BOOL    fFound = FALSE;
    DWORD   dwCSPFlag = SCARD_CTINFO_CSPLIST_NEXT;
    LONG    lInfo;
    BOOL    fStr = FALSE; //default to long
    BOOL    fFree = TRUE;
    VARIANT varInfo;

    ZeroMemory(&varInfo, sizeof(varInfo));

    EnterCriticalSection(&m_cSection);

    if (NULL == bstrCertTemplateName ||
        0 == m_dwCTCount ||
        NULL == m_rgCTInfo)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto InvalidParamErr;
    }

    //get the CT information
    for (dwIndex=0; dwIndex < m_dwCTCount; dwIndex++)
    {
        if (0 == _wcsicmp(bstrCertTemplateName, m_rgCTInfo[dwIndex].pwszCTName))
        {
            // found it
            fFound = TRUE;
            break;
        }
    }

    if (!fFound)
    {
        //likely pass incorrect template name
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto NotFoundErr;
    }

    switch (lType)
    {
        case SCARD_CTINFO_KEYSPEC:
            lInfo = m_rgCTInfo[dwIndex].dwKeySpec;
        break;
        case SCARD_CTINFO_KEYFLAGS:
            lInfo = m_rgCTInfo[dwIndex].dwGenKeyFlags;
            break;
        case SCARD_CTINFO_EXT_OID:
            hr = _getCertTemplateExtensionInfo(
                        m_rgCTInfo[dwIndex].pCertTypeExtensions,
                        lType,
                        &pwszInfo);
            if (S_OK != hr)
            {
                goto _getCertTemplateExtensionInfoErr;
            }
            fStr = TRUE;
            fFree = FALSE; //don't free cache
        break;
        case SCARD_CTINFO_EXT_MAJOR:
        case SCARD_CTINFO_EXT_MINOR:
        case SCARD_CTINFO_EXT_MINOR_FLAG:
            hr = _getCertTemplateExtensionInfo(
                        m_rgCTInfo[dwIndex].pCertTypeExtensions,
                        lType,
                        &lInfo);
            if (S_OK != hr)
            {
                goto _getCertTemplateExtensionInfoErr;
            }
        break;
        case SCARD_CTINFO_CSPLIST_FIRST:
            dwCSPFlag = SCARD_CTINFO_CSPLIST_FIRST;
            //fall through
        case SCARD_CTINFO_CSPLIST_NEXT:
            hr = _getStrCertTemplateCSPList(dwIndex, dwCSPFlag, &pwszInfo);
            if (S_OK != hr)
            {
                goto _getStrCertTemplateCSPListErr;
            }
            fStr = TRUE;
        break;
        case SCARD_CTINFO_SUBJECTFLAG:
            lInfo = m_rgCTInfo[dwIndex].dwSubjectNameFlags;
            break;
        case SCARD_CTINFO_GENERALFLAGS:
            lInfo = m_rgCTInfo[dwIndex].dwGeneralFlags;
            break;
        case SCARD_CTINFO_ENROLLMENTFLAGS:
            lInfo = m_rgCTInfo[dwIndex].dwEnrollmentFlags;
            break;
        case SCARD_CTINFO_PRIVATEKEYFLAGS:
            lInfo = m_rgCTInfo[dwIndex].dwPrivateKeyFlags;
            break;
        case SCARD_CTINFO_RA_SIGNATURES:
            lInfo = m_rgCTInfo[dwIndex].dwRASignature;
            break;
        default:
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
            goto InvalidParamErr;
    }

    if (fStr)
    {
        varInfo.vt = VT_BSTR;
        varInfo.bstrVal = SysAllocString(pwszInfo);
        if (NULL == varInfo.bstrVal)
        {
            hr = E_OUTOFMEMORY;
            goto MemoryErr;
        }
    }
    else
    {
        varInfo.vt = VT_I4;
        varInfo.lVal = lInfo;
    }
    //return
    *pvarCertTemplateInfo = varInfo;

    hr = S_OK;
ErrorReturn:
    LeaveCriticalSection(&m_cSection);
    if (fFree && NULL != pwszInfo)
    {
        LocalFree(pwszInfo);
    }
    return hr;

TRACE_ERROR(InvalidParamErr)
TRACE_ERROR(NotFoundErr)
TRACE_ERROR(MemoryErr)
TRACE_ERROR(_getCertTemplateExtensionInfoErr)
TRACE_ERROR(_getStrCertTemplateCSPListErr)
}

STDMETHODIMP CSCrdEnr::getCACount
       (/* [in] */                    BSTR bstrCertTemplateName, 
        /* [retval][out] */           long *pdwCACount)
{
    HRESULT             hr= E_FAIL;
    DWORD               errBefore= GetLastError();
    DWORD               dwIndex=0;

    EnterCriticalSection(&m_cSection);

    if(NULL == bstrCertTemplateName || NULL == pdwCACount)
        goto InvalidArgErr;

    *pdwCACount=0;

    if(0 == m_dwCTCount || NULL == m_rgCTInfo)
        goto InvalidArgErr;

    //get the CT information
    for(dwIndex=0; dwIndex < m_dwCTCount; dwIndex++)
    {
        if(0 == _wcsicmp(bstrCertTemplateName, m_rgCTInfo[dwIndex].pwszCTName))
            break;
    }

    if(dwIndex == m_dwCTCount)
        goto InvalidArgErr;

    //we need to get the CA information for the newly selected cert type
    if(FALSE == m_rgCTInfo[dwIndex].fCAInfo)
    {
       GetCAInfoFromCertType(NULL,
							 m_rgCTInfo[dwIndex].pwszCTName,
                             &(m_rgCTInfo[dwIndex].dwCACount),
                             &(m_rgCTInfo[dwIndex].rgCAInfo));

       m_rgCTInfo[dwIndex].dwCAIndex=0;

       m_rgCTInfo[dwIndex].fCAInfo=TRUE;
    }

    *pdwCACount = (long)m_rgCTInfo[dwIndex].dwCACount;

    hr=S_OK;

CommonReturn:

    LeaveCriticalSection(&m_cSection);

    
    SetLastError(errBefore);

	return hr;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    hr = CodeToHR(errBefore);

	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}

STDMETHODIMP CSCrdEnr::getCAName
       (/* [in] */                    DWORD dwFlags,
        /* [in] */                    BSTR bstrCertTemplateName, 
        /* [retval][out] */           BSTR *pbstrCAName)
{
    HRESULT             hr= E_FAIL;
    DWORD               errBefore= GetLastError();
    DWORD               dwIndex=0;
	LPWSTR				pwszName=NULL;

    SCrdEnroll_CT_INFO  *pCTInfo=NULL;

    EnterCriticalSection(&m_cSection);

    if(NULL == bstrCertTemplateName || NULL == pbstrCAName)
        goto InvalidArgErr;

    *pbstrCAName=NULL;

    if(0 == m_dwCTCount || NULL == m_rgCTInfo)
        goto InvalidArgErr;

    //get the CT information
    for(dwIndex=0; dwIndex < m_dwCTCount; dwIndex++)
    {
        if(0 == _wcsicmp(bstrCertTemplateName, m_rgCTInfo[dwIndex].pwszCTName))
            break;
    }

    if(dwIndex == m_dwCTCount)
        goto InvalidArgErr;

    //we need to get the CA information for the newly selected cert type
    if(FALSE == m_rgCTInfo[dwIndex].fCAInfo)
    {
       GetCAInfoFromCertType(NULL,
							 m_rgCTInfo[dwIndex].pwszCTName,
                             &(m_rgCTInfo[dwIndex].dwCACount),
                             &(m_rgCTInfo[dwIndex].rgCAInfo));

       m_rgCTInfo[dwIndex].dwCAIndex=0;

       m_rgCTInfo[dwIndex].fCAInfo=TRUE;
    }

    pCTInfo=&(m_rgCTInfo[dwIndex]);

    if(NULL == pCTInfo->rgCAInfo)
        goto InvalidArgErr;


	if(!RetrieveCAName(dwFlags, &(pCTInfo->rgCAInfo[pCTInfo->dwCAIndex]), &pwszName))
		goto TraceErr;					 

    if(NULL == (*pbstrCAName = SysAllocString(pwszName)))
        goto MemoryErr;

    hr=S_OK;

CommonReturn:

    LeaveCriticalSection(&m_cSection);

	if(pwszName)
		SCrdEnrollFree(pwszName);
    
    SetLastError(errBefore);

	return hr;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    hr = CodeToHR(errBefore);

	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
TRACE_ERROR(TraceErr);
}

STDMETHODIMP CSCrdEnr::setCAName
       (/* [in] */                    DWORD dwFlags,
        /* [in] */                    BSTR bstrCertTemplateName, 
        /* [in] */                    BSTR bstrCAName)
{
    HRESULT             hr= E_FAIL;
    DWORD               errBefore= GetLastError();
    DWORD               dwIndex=0;
    DWORD               dwCAIndex=0;
	LPWSTR				pwszName=NULL;

    SCrdEnroll_CT_INFO  *pCTInfo=NULL;

    EnterCriticalSection(&m_cSection);

    if(NULL == bstrCertTemplateName || NULL == bstrCAName)
        goto InvalidArgErr;

    if(0 == m_dwCTCount || NULL == m_rgCTInfo)
        goto InvalidArgErr;

    //get the CT information
    for(dwIndex=0; dwIndex < m_dwCTCount; dwIndex++)
    {
        if(0 == _wcsicmp(bstrCertTemplateName, m_rgCTInfo[dwIndex].pwszCTName))
            break;
    }

    if(dwIndex == m_dwCTCount)
        goto InvalidArgErr;

    //we need to get the CA information for the newly selected cert type
    if(FALSE == m_rgCTInfo[dwIndex].fCAInfo)
    {
       GetCAInfoFromCertType(NULL,
							 m_rgCTInfo[dwIndex].pwszCTName,
                             &(m_rgCTInfo[dwIndex].dwCACount),
                             &(m_rgCTInfo[dwIndex].rgCAInfo));

       m_rgCTInfo[dwIndex].dwCAIndex=0;

       m_rgCTInfo[dwIndex].fCAInfo=TRUE;
    }

    pCTInfo=&(m_rgCTInfo[dwIndex]);

    if(NULL == pCTInfo->rgCAInfo)
        goto InvalidArgErr;


    //search for the CA specified in the input
    for(dwCAIndex=0; dwCAIndex < pCTInfo->dwCACount; dwCAIndex++)
    {

		if(!RetrieveCAName(dwFlags, &(pCTInfo->rgCAInfo[dwCAIndex]), &pwszName))
			continue;

		if(0 == _wcsicmp(pwszName, bstrCAName))
                break;

		SCrdEnrollFree(pwszName);
		pwszName=NULL;
    }

    if(dwCAIndex == pCTInfo->dwCACount)
        goto InvalidArgErr;

    //remember the selected CA by its index
    pCTInfo->dwCAIndex = dwCAIndex;

    hr=S_OK;

CommonReturn:

    LeaveCriticalSection(&m_cSection);

	if(pwszName)
		SCrdEnrollFree(pwszName);
    
    SetLastError(errBefore);

	return hr;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    hr = CodeToHR(errBefore);

	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}

STDMETHODIMP CSCrdEnr::enumCAName
       (/* [in] */                    DWORD dwIndex, 
        /* [in] */                    DWORD dwFlags, 
        /* [in] */                    BSTR  bstrCertTemplateName, 
        /* [retval][out] */           BSTR  *pbstrCAName)
{
    HRESULT             hr= E_FAIL;
    DWORD               errBefore= GetLastError();
    DWORD               dwCTIndex=0;
	LPWSTR				pwszName=NULL;

    SCrdEnroll_CT_INFO  *pCTInfo=NULL;

    EnterCriticalSection(&m_cSection);

    if(NULL == bstrCertTemplateName || NULL == pbstrCAName)
        goto InvalidArgErr;

    *pbstrCAName=NULL;

    if(0 == m_dwCTCount || NULL == m_rgCTInfo)
        goto InvalidArgErr;

    //get the CT information
    for(dwCTIndex=0; dwCTIndex < m_dwCTCount; dwCTIndex++)
    {
        if(0 == _wcsicmp(bstrCertTemplateName, m_rgCTInfo[dwCTIndex].pwszCTName))
            break;
    }

    if(dwCTIndex == m_dwCTCount)
        goto InvalidArgErr;

    //we need to get the CA information for the newly selected cert type
    if(FALSE == m_rgCTInfo[dwCTIndex].fCAInfo)
    {
       GetCAInfoFromCertType(NULL,
							 m_rgCTInfo[dwCTIndex].pwszCTName,
                             &(m_rgCTInfo[dwCTIndex].dwCACount),
                             &(m_rgCTInfo[dwCTIndex].rgCAInfo));

       m_rgCTInfo[dwCTIndex].dwCAIndex=0;

       m_rgCTInfo[dwCTIndex].fCAInfo=TRUE;
    }

    pCTInfo=&(m_rgCTInfo[dwCTIndex]);

    //search for the CA specified in the input
    if(dwIndex >= pCTInfo->dwCACount)
        goto InvalidArgErr;


	if(!RetrieveCAName(dwFlags, &(pCTInfo->rgCAInfo[dwIndex]), &pwszName))
		goto TraceErr;

    if(NULL == (*pbstrCAName = SysAllocString(pwszName)))
        goto MemoryErr;

    hr=S_OK;

CommonReturn:

    LeaveCriticalSection(&m_cSection);

	if(pwszName)
		SCrdEnrollFree(pwszName);
    
    SetLastError(errBefore);

	return hr;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    hr = CodeToHR(errBefore);

	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
TRACE_ERROR(TraceErr);
}

STDMETHODIMP CSCrdEnr::getSigningCertificateName
        (/* [in] */                   DWORD dwFlags, 
         /* [retval][out] */          BSTR  *pbstrSigningCertName)
{
    HRESULT                             hr= E_FAIL;
    DWORD                               errBefore= GetLastError();
    DWORD                               dwChar=0;
    LPWSTR                              pwsz=NULL; 
    CRYPTUI_VIEWCERTIFICATE_STRUCT      CertViewStruct;

    *pbstrSigningCertName=NULL;

    EnterCriticalSection(&m_cSection);

    if(NULL == m_pSigningCert)
        goto InvalidArgErr;
   
    if(0 == (SCARD_ENROLL_NO_DISPLAY_CERT & dwFlags))
    {
        //view the certificate
        memset(&CertViewStruct, 0, sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT));   

        CertViewStruct.dwSize=sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT);
        CertViewStruct.pCertContext=m_pSigningCert;
        CertViewStruct.dwFlags=CRYPTUI_DISABLE_EDITPROPERTIES | CRYPTUI_DISABLE_ADDTOSTORE;

        CryptUIDlgViewCertificate(&CertViewStruct, NULL); 
    }


    dwChar=CertGetNameStringW(
        m_pSigningCert,
        CERT_NAME_SIMPLE_DISPLAY_TYPE,
        0,
        NULL,
        NULL,
        0); 

    if ((dwChar != 0) && (NULL != (pwsz = (LPWSTR)SCrdEnrollAlloc(dwChar * sizeof(WCHAR)))))
    {
        CertGetNameStringW(
            m_pSigningCert,
            CERT_NAME_SIMPLE_DISPLAY_TYPE,
            0,
            NULL,
            pwsz,
            dwChar);
             
        if( NULL == (*pbstrSigningCertName = SysAllocString(pwsz)))
            goto MemoryErr;
    }

    hr= S_OK;

CommonReturn:

    LeaveCriticalSection(&m_cSection);

    if(pwsz)
        SCrdEnrollFree(pwsz);

    SetLastError(errBefore);

	return hr;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    hr = CodeToHR(errBefore);

	goto CommonReturn;

SET_ERROR(MemoryErr, E_OUTOFMEMORY);
SET_ERROR(InvalidArgErr, E_INVALIDARG);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\scrdenrl\enrlhelp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       enrlhelp.h
//
//  Contents:   Headers for the helper functions for smard card enrollment station
//
//----------------------------------------------------------------------------

#ifndef __ENRLHELP_H__
#define __ENRLHELP_H__

#ifdef __cplusplus
extern "C" {
#endif
    
/////////////////////////////////////////////////////////////////////////////
// Contants defines
#define g_dwMsgAndCertEncodingType  PKCS_7_ASN_ENCODING | X509_ASN_ENCODING

const   WCHAR g_MyStoreName[]=L"MY";


/////////////////////////////////////////////////////////////////////////////
// SCrdEnroll_CSP_INFO
typedef struct  _SCrdEnroll_CERT_SELECT_INFO
{
    DWORD   dwFlags;
    LPWSTR  pwszCertTemplateName;
}SCrdEnroll_CERT_SELECT_INFO, *PSCrdEnroll_CERT_SELECT_INFO;

/////////////////////////////////////////////////////////////////////////////
// Function Prototypes
LPWSTR  CopyWideString(LPCWSTR wsz);

BOOL    SearchAndDeleteCert(PCCERT_CONTEXT  pCertContext);

BOOL    InitlializeCSPList(DWORD    *pdwCSPCount, SCrdEnroll_CSP_INFO **prgCSPInfo);

void    FreeCSPInfo(DWORD   dwCSPCount, SCrdEnroll_CSP_INFO *prgCSPInfo);

BOOL    GetCAInfoFromCertType(HANDLE					hToken,
							  LPWSTR                    pwszCTName,
                              DWORD                     *pdwValidCA,
                              SCrdEnroll_CA_INFO        **prgCAInfo);

HRESULT GetCAArchivalCert(LPWSTR           pwszCAName, 
			  PCCERT_CONTEXT  *ppCert);  

BOOL    InitializeCTList(DWORD              *pdwCTIndex,
                         DWORD              *pdwCTCount, 
                         SCrdEnroll_CT_INFO **prgCTInfo);

LPVOID  SCrdEnrollAlloc (
        ULONG cbSize);

LPVOID  SCrdEnrollRealloc (
        LPVOID pv,
        ULONG cbSize);

VOID    SCrdEnrollFree (
        LPVOID pv);


void    FreeCTInfo(DWORD    dwCTCount, SCrdEnroll_CT_INFO *rgCTInfo);

void    FreeCAInfo(DWORD    dwCACount, SCrdEnroll_CA_INFO *rgCAInfo);


HRESULT CodeToHR(HRESULT hr);

HRESULT GetSelectedUserName(IDsObjectPicker     *pDsObjectPicker,
			    LPWSTR              *ppwszSelectedUserSAM,
                            LPWSTR              *ppwszSelectedUserUPN);

BOOL    SignWithCert(LPSTR              pszCSPName,
                     DWORD              dwCSPType,
                     PCCERT_CONTEXT     pSigningCert);



HRESULT ChkSCardStatus(BOOL             fSCardSigningCert,
                       PCCERT_CONTEXT   pSigningCertCertContext,
                       LPSTR            pszCSPNameSigningCert,
                       DWORD            dwCSPTypeSigningCert,
                       LPSTR            pszContainerSigningCert,
                       LPWSTR           pwszSelectedCSP,
                       LPWSTR           *ppwszNewContainerName);


BOOL    ChKInsertedCardSigningCert(LPWSTR           pwszInsertProvider,
                                   DWORD            dwInsertProviderType,
                                   LPWSTR           pwszReaderName,
                                   PCCERT_CONTEXT   pSignCertContext,
                                   LPSTR            pszSignProvider,
                                   DWORD            dwSignProviderType,
                                   LPSTR            pszSignContainer,
                                   BOOL             *pfSame);

BOOL    DecodeBlobW(WCHAR   *pch,
                    DWORD   cch,
                    BYTE    **ppbData,
                    DWORD   *pcbData);


BOOL    EncodeBlobW(BYTE    *pbData,
                    DWORD   cbData,
                    DWORD   dwFlags,
                    WCHAR   **ppch,
                    DWORD   *pcch);


BOOL    GetNameFromPKCS10(BYTE      *pbPKCS10,
                          DWORD     cbPKCS10,
                          DWORD     dwFlags, 
                          LPSTR     pszOID, 
                          LPWSTR    *ppwszName);

BOOL    VerifyCertTemplateName(PCCERT_CONTEXT   pCertContext, 
                               LPWSTR           pwszCertTemplateName);


BOOL    WINAPI SelectSignCertCallBack(
                                PCCERT_CONTEXT  pCertContext,
                                BOOL            *pfInitialSelectedCert,
                                void            *pvCallbackData);

BOOL    VerifyCertChain(PCCERT_CONTEXT      pCertContext);

BOOL    IsNewerCert(PCCERT_CONTEXT  pFirstCert,
                    PCCERT_CONTEXT  pSecondCert);

BOOL    SmartCardCSP(PCCERT_CONTEXT pCertContext);

DWORD   GetEncodeFlag(DWORD dwFlags);

BOOL    GetName(LPWSTR                  pwszName,
                EXTENDED_NAME_FORMAT    NameFormat,
                EXTENDED_NAME_FORMAT    DesiredFormat,
                LPWSTR                  *ppwszDesiredName);	


BOOL	RetrieveCAName(DWORD					dwFlags, 
					   SCrdEnroll_CA_INFO		*pCAInfo, 
					   LPWSTR					*ppwszName);

#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif  //__ENRLHELP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\scrdenrl\scenum.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    scenum.cpp

Abstract:

    This module provides the implementation of the smart card helper functions
    provided to Xiaohung Su for use in the Smart Card Enrollment Station.

Author:

    Doug Barlow (dbarlow) 11/12/1998

Notes:

    Most of these routines use a "context handle", defined as LPVOID.  The
    proper usage of these routines is to declare a context variable in your
    code, and assign it the value 'NULL'.  For example,

        LPVOID pvScEnlistHandle = NULL;

    These routines will use this pointer to establish internal working
    structures.  It's actual value will change between calls, but the value can
    be ignored by the caller.

    These routines assume a Windows 2000 platform.

--*/

#include <windows.h>
#include <wincrypt.h>
#include <winscard.h>
#include "scenum.h"


typedef struct {
    SCARDCONTEXT hCtx;
    LPWSTR mszReaders;
    DWORD dwEnumIndex;
    DWORD dwActiveReaderCount;
    DWORD dwReaderCount;
    LPSCARD_READERSTATEW rgReaderStates;
} scEnlistContext;


/*++

CountReaders:

    This routine returns the number of active smart card readers currently
    installed in the system.

Arguments:

    pvHandle supplies the context handle, if any.  If it is not NULL, then an
        existing context is assumed and used.  Otherwise, a temporary internal
        context is created for use just within this routine.

Return Value:

    The actual number of readers currently installed in the system.

Remarks:

    If an error occurs, this routine returns zero.  The actual error code will
    be available via GetLastError.

Author:

    Doug Barlow (dbarlow) 11/12/1998

--*/

DWORD
CountReaders(
    IN LPVOID pvHandle)
{
    DWORD dwCount = 0;
    DWORD dwErr = ERROR_SUCCESS;
    SCARDCONTEXT hCtx = NULL;
    LPWSTR mszReaders = NULL;
    LPWSTR szRdr;
    DWORD cchReaders;
    scEnlistContext *pscCtx = (scEnlistContext *)pvHandle;


    //
    // See if we can take a shortcut.
    //

    if (NULL != pscCtx)
    {
        if (0 == pscCtx->dwReaderCount)
            SetLastError(ERROR_SUCCESS);
        return pscCtx->dwReaderCount;
    }

    //
    // We have to do things the hard way.
    // Create a temporary context.
    //

    dwErr = SCardEstablishContext(SCARD_SCOPE_USER, NULL, NULL, &hCtx);
    if (SCARD_S_SUCCESS != dwErr)
        goto ErrorExit;


    //
    // Get a list of active readers, and count them.
    //

    cchReaders = SCARD_AUTOALLOCATE;
    dwErr = SCardListReadersW(hCtx, NULL, (LPWSTR)&mszReaders, &cchReaders);
    if (SCARD_S_SUCCESS != dwErr)
        goto ErrorExit;
    for (szRdr = mszReaders; 0 != *szRdr; szRdr += lstrlenW(szRdr) + 1)
        dwCount += 1;
    dwErr = SCardFreeMemory(hCtx, mszReaders);
    mszReaders = NULL;
    if (SCARD_S_SUCCESS != dwErr)
        goto ErrorExit;


    //
    // Eliminate our temporary context.
    //

    dwErr = SCardReleaseContext(hCtx);
    hCtx = NULL;
    if (SCARD_S_SUCCESS != dwErr)
        goto ErrorExit;


    //
    // Inform the caller of our findings.
    //

    if (0 == dwCount)
        SetLastError(ERROR_SUCCESS);
    return dwCount;


    //
    // An error has occurred.  Clean up, and return.
    //

ErrorExit:
    if (NULL != mszReaders)
        SCardFreeMemory(hCtx, mszReaders);
    if ((NULL == pvHandle) && (NULL != hCtx))
        SCardReleaseContext(hCtx);
    SetLastError(dwErr);
    return 0;
}


/*++

ScanReaders:

    This function scans active readers in preparation for future
    EnumInsertedCards calls.  It does not block for changes, but just takes a
    snapshot of the existing environment.

Arguments:

    ppvHandle supplies a pointer to an LPVOID to be used by this and associated
        routines to maintain an internal context.

Return Value:

    The number of readers with cards inserted, or zero if an error occurs.  When
    an error occurs, the actual error code can be obtained from GetLastError.

Remarks:

    Prior to the first call to this service, the value of the LPVOID pointed to
    by ppvHandle should be set to NULL.  When all processing is complete, call
    the EndReaderScan service to clean up the internal working space and reset
    the value to NULL.

Author:

    Doug Barlow (dbarlow) 11/12/1998

--*/

DWORD
ScanReaders(
    IN OUT LPVOID *ppvHandle)
{
    DWORD dwCount = 0;
    DWORD dwErr = SCARD_S_SUCCESS;
    LPWSTR szRdr;
    DWORD cchReaders, cRdrs, dwIndex;
    scEnlistContext *pscCtx = *(scEnlistContext **)ppvHandle;

    if (NULL == pscCtx)
    {

        //
        // Create the context structure.
        //

        pscCtx = (scEnlistContext *)LocalAlloc(LPTR, sizeof(scEnlistContext));
        if (NULL == pscCtx)
        {
            dwErr = SCARD_E_NO_MEMORY;
            goto ErrorExit;
        }
        ZeroMemory(pscCtx, sizeof(scEnlistContext));

        dwErr = SCardEstablishContext(
                    SCARD_SCOPE_USER,
                    NULL,
                    NULL,
                    &pscCtx->hCtx);
        if (SCARD_S_SUCCESS != dwErr)
            goto ErrorExit;
    }


    //
    // Get a list and a count of the readers.
    //

    if (NULL != pscCtx->mszReaders)
    {
        dwErr = SCardFreeMemory(pscCtx->hCtx, pscCtx->mszReaders);
        pscCtx->mszReaders = NULL;
        if (dwErr != SCARD_S_SUCCESS)
            goto ErrorExit;
    }
    cchReaders = SCARD_AUTOALLOCATE;
    dwErr = SCardListReadersW(
                pscCtx->hCtx,
                NULL,
                (LPWSTR)&pscCtx->mszReaders,
                &cchReaders);
    if (SCARD_S_SUCCESS != dwErr)
        goto ErrorExit;
    cRdrs = 0;
    for (szRdr = pscCtx->mszReaders; 0 != *szRdr; szRdr += lstrlenW(szRdr) + 1)
        cRdrs += 1;


    //
    // Enlarge the reader state array if necessary.
    //

    if (cRdrs > pscCtx->dwReaderCount)
    {
        if (NULL != pscCtx->rgReaderStates)
        {
            LocalFree(pscCtx->rgReaderStates);
            pscCtx->dwReaderCount = 0;
        }
        pscCtx->rgReaderStates =
            (LPSCARD_READERSTATEW)LocalAlloc(
                LPTR,
                cRdrs * sizeof(SCARD_READERSTATEW));
        if (NULL == pscCtx->rgReaderStates)
        {
            dwErr = SCARD_E_NO_MEMORY;
            goto ErrorExit;
        }
        pscCtx->dwReaderCount = cRdrs;
    }
    ZeroMemory(pscCtx->rgReaderStates, cRdrs * sizeof(SCARD_READERSTATEW));
    pscCtx->dwActiveReaderCount = cRdrs;


    //
    // Fill in the state array.
    //

    cRdrs = 0;
    for (szRdr = pscCtx->mszReaders; 0 != *szRdr; szRdr += lstrlenW(szRdr) + 1)
    {
        pscCtx->rgReaderStates[cRdrs].szReader = szRdr;
        pscCtx->rgReaderStates[cRdrs].dwCurrentState = SCARD_STATE_UNAWARE;
        cRdrs += 1;
    }
    dwErr = SCardGetStatusChangeW(
                pscCtx->hCtx,
                0,
                pscCtx->rgReaderStates,
                cRdrs);
    if (SCARD_S_SUCCESS != dwErr)
        goto ErrorExit;


    //
    // We're all set for EnumInsertedCard calls.
    // Count the number of readers with cards, and return.
    //

    for (dwIndex = 0; dwIndex < cRdrs; dwIndex += 1)
    {
        if (0 != (
                SCARD_STATE_PRESENT
                & pscCtx->rgReaderStates[dwIndex].dwEventState))
            dwCount += 1;
    }

    pscCtx->dwEnumIndex = 0;
    *ppvHandle = pscCtx;
    if (0 == dwCount)
        SetLastError(SCARD_S_SUCCESS);
    return dwCount;


    //
    // An error has occurred.  Clean up to the last known good state.
    //

ErrorExit:
    if ((NULL == *ppvHandle) && (NULL != pscCtx))
    {
        if (NULL != pscCtx->mszReaders)
        {
            SCardFreeMemory(pscCtx->hCtx, pscCtx->mszReaders);
            pscCtx->mszReaders = NULL;
        }
        if (NULL != pscCtx->hCtx)
            SCardReleaseContext(pscCtx->hCtx);
        if (NULL != pscCtx->rgReaderStates)
            LocalFree(pscCtx->rgReaderStates);
        LocalFree(pscCtx);
    }
    return 0;
}


/*++

EnumInsertedCards:

    This routine is designed to be called repeatedly after first calling the
    ScanReaders service.  It will repeatedly return information about cards
    available for use against CryptoAPI, until all cards have been returned.

Arguments:

    pvHandle supplies the context handle in use.

    szCryptoProvider is a buffer to receive the name of the Cryptographic
        Service Provider associated with the card in the reader.

    cchCryptoProvider supplies the length of the szCryptoProvider buffer, in
        characters.  If this length is not sufficient to hold the name of the
        provider, the routine returns FALSE, and GetLastError will return
        SCARD_E_INSUFFICIENT_BUFFER.

    pdwProviderType receives the type of the smart card provider (this will be
        PROV_RSA_FULL for all known smart card CSPs).

    pszReaderName receives a pointer to the name of the reader being returned.

Return Value:

    TRUE - The output variables have been set to the next available card.

    FALSE - There are no more cards to be returned, or some other error has
        occurred, per the value available from GetLastError.

Remarks:

    The list of cards can be reset using the ScanReaders service.

Author:

    Doug Barlow (dbarlow) 11/12/1998

--*/

BOOL
EnumInsertedCards(
    IN  LPVOID pvHandle,
    OUT LPWSTR szCryptoProvider,
    IN  DWORD cchCryptoProvider,
    OUT LPDWORD pdwProviderType,
    OUT LPCWSTR *pszReaderName)
{
    DWORD dwIndex;
    DWORD dwSts;
    LPWSTR mszCards = NULL;
    DWORD dwLength;
    scEnlistContext *pscCtx = (scEnlistContext *)pvHandle;


    //
    // Run through the remaining readers and see what's left to report.
    //

    for (dwIndex = pscCtx->dwEnumIndex;
         dwIndex < pscCtx->dwActiveReaderCount;
         dwIndex += 1)
    {
        if (   (0 != ( SCARD_STATE_PRESENT
                       & pscCtx->rgReaderStates[dwIndex].dwEventState))
            && (0 == ( SCARD_STATE_MUTE
                       & pscCtx->rgReaderStates[dwIndex].dwEventState)))
        {

            //
            // This card is active.  Try to map it to a CSP.
            //

            dwLength = SCARD_AUTOALLOCATE;
            dwSts = SCardListCardsW(
                        pscCtx->hCtx,
                        pscCtx->rgReaderStates[dwIndex].rgbAtr,
                        NULL,
                        0,
                        (LPWSTR)&mszCards,
                        &dwLength);
            if (SCARD_S_SUCCESS != dwSts)
            {

                //
                // Probably an unregistered card type.  Keep looking.
                //

                goto NextCard;
            }


            //
            // We just use the first returned card name.  We don't
            // have a mechanism to declare, "same card, next provider"
            // yet.  Since there are no cards that have this problem
            // that we know of, we'll limp along for now.
            //

            //
            // Map the card name to a CSP.
            //

            dwLength = cchCryptoProvider;
            dwSts = SCardGetCardTypeProviderNameW(
                        pscCtx->hCtx,
                        mszCards,
                        SCARD_PROVIDER_CSP,
                        szCryptoProvider,
                        &dwLength);
            if (SCARD_S_SUCCESS != dwSts)
            {

                //
                // Probably no mapping.  Keep looking.
                //

                goto NextCard;
            }


            //
            // At this point, we've found a card and mapped it to it's
            // CSP Name.
            //

            //
            // It would be nice to map the CSP Name to a CSP Type.
            // For now, they're all PROV_RSA_FULL.
            //

            *pdwProviderType = PROV_RSA_FULL;


            //
            // Return what we know to the caller, saving state for the
            // next time through.
            //

            SCardFreeMemory(pscCtx->hCtx, mszCards);
            mszCards = NULL;
            pscCtx->dwEnumIndex = dwIndex + 1;
            *pszReaderName = pscCtx->rgReaderStates[dwIndex].szReader;
            return TRUE;
        }


        //
        // The current card was rejected.  Do any clean up, and move on to
        // the next card.
        //

NextCard:
        if (NULL != mszCards)
        {
            SCardFreeMemory(pscCtx->hCtx, mszCards);
            mszCards = NULL;
        }
    }


    //
    // We fell out the bottom of the loop.  This means we didn't find any
    // more readers with cards inserted.  Report that we're done for this
    // scan.
    //

    pscCtx->dwEnumIndex = pscCtx->dwActiveReaderCount;
    SetLastError(SCARD_S_SUCCESS);
    return FALSE;
}


/*++

EndReaderScan:

    This routine is used to clean up internal memory used by other services
    in this module.

Arguments:

    ppvHandle supplies a pointer to an LPVOID being used by this and associated
        routines to maintain an internal context.  Associated memory will be
        freed, and the value reset to NULL.

Return Value:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 11/12/1998

--*/

void
EndReaderScan(
    LPVOID *ppvHandle)
{
    scEnlistContext *pscCtx = *(scEnlistContext **)ppvHandle;

    if (NULL != pscCtx)
    {
        if (NULL != pscCtx->mszReaders)
        {
            SCardFreeMemory(pscCtx->hCtx, pscCtx->mszReaders);
            pscCtx->mszReaders = NULL;
        }
        if (NULL != pscCtx->hCtx)
            SCardReleaseContext(pscCtx->hCtx);
        if (NULL != pscCtx->rgReaderStates)
            LocalFree(pscCtx->rgReaderStates);
        LocalFree(pscCtx);
        *ppvHandle = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\scrdenrl\enrlhelp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       enrlhelp.cpp
//
//  Contents:   Helper functions for smard card enrollment station
//
//----------------------------------------------------------------------------
#define INC_OLE2
#define SECURITY_WIN32  //Or in the sources file -DSECURITY_WIN32

#include "stdafx.h"
#include <windows.h>
#include <wincrypt.h>
#include <oleauto.h>
#include <objbase.h>
#include "security.h"
#include "certca.h"              
#include <dbgdef.h>
#include "unicode.h"

#include "scrdenrl.h"
#include "SCrdEnr.h"
#include "xEnroll.h"
#include "enrlhelp.h"  
#include "scenum.h"
#include "wzrdpvk.h"

UINT g_cfDsObjectPicker = RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);

//-----------------------------------------------------------------------------
//  Memory routines
//
//-----------------------------------------------------------------------------
void*
MIDL_user_allocate(size_t cb)
{
    return(SCrdEnrollAlloc(cb));
}

void
MIDL_user_free(void *pb)
{
    SCrdEnrollFree(pb);
}

LPVOID  SCrdEnrollAlloc (ULONG cbSize)
{
    return CoTaskMemAlloc(cbSize);
}


LPVOID  SCrdEnrollRealloc (
        LPVOID pv,
        ULONG cbSize)
{
    LPVOID  pvTemp=NULL;

    if(NULL==pv)
        return CoTaskMemAlloc(cbSize);

    return CoTaskMemRealloc(pv, cbSize);
}

VOID    SCrdEnrollFree (LPVOID pv)
{
    if (pv)
        CoTaskMemFree(pv);
}


BOOL CertTypeFlagsToGenKeyFlags(IN OPTIONAL DWORD dwEnrollmentFlags,
				IN OPTIONAL DWORD dwSubjectNameFlags,
				IN OPTIONAL DWORD dwPrivateKeyFlags,
				IN OPTIONAL DWORD dwGeneralFlags, 
				OUT DWORD *pdwGenKeyFlags)
{
    // Define a locally scoped helper function.  This allows us to gain the benefits of procedural
    // abstraction without corrupting the global namespace.  
    // 
    LocalScope(CertTypeMap): 
	// Maps cert type flags of one category (enrollment flags, private key flags, etc...)
	// to their corresponding gen key flags.  This function always returns successfully.  
	// 
	DWORD mapOneCertTypeCategory(IN DWORD dwOption, IN DWORD dwCertTypeFlags) 
	{ 
	    static DWORD const rgdwEnrollmentFlags[][2] = { 
		{ 0, 0 } // No enrollment flags mapped. 
	    }; 
	    static DWORD const rgdwSubjectNameFlags[][2] = { 
		{ 0, 0 } // No subject name flags mapped. 
	    }; 
	    static DWORD const rgdwPrivateKeyFlags[][2]   = { 
		{ CT_FLAG_EXPORTABLE_KEY, CRYPT_EXPORTABLE } 
	    }; 
	    static DWORD const rgdwGeneralFlags[][2] = { 
		{ 0, 0 } // No general flags mapped. 
	    }; 
	    
	    static DWORD const dwEnrollmentLen  = sizeof(rgdwEnrollmentFlags)  / sizeof(DWORD[2]); 
	    static DWORD const dwSubjectNameLen = sizeof(rgdwSubjectNameFlags) / sizeof(DWORD[2]); 
	    static DWORD const dwPrivateKeyLen  = sizeof(rgdwPrivateKeyFlags)  / sizeof(DWORD[2]); 
	    static DWORD const dwGeneralLen     = sizeof(rgdwGeneralFlags)     / sizeof(DWORD[2]); 
	    
	    static DWORD const CERT_TYPE_INDEX  = 0; 
	    static DWORD const GEN_KEY_INDEX    = 1;

	    DWORD const  *pdwFlags; 
	    DWORD         dwLen, dwIndex, dwResult = 0; 

	    switch (dwOption)
	    {

	    case CERTTYPE_ENROLLMENT_FLAG:    
		pdwFlags = &rgdwEnrollmentFlags[0][0]; 
		dwLen    = dwEnrollmentLen; 
		break;
	    case CERTTYPE_SUBJECT_NAME_FLAG:  
		pdwFlags = &rgdwSubjectNameFlags[0][0]; 
		dwLen    = dwSubjectNameLen; 
		break;
	    case CERTTYPE_PRIVATE_KEY_FLAG:   
		pdwFlags = &rgdwPrivateKeyFlags[0][0]; 
		dwLen    = dwPrivateKeyLen;
		break;
	    case CERTTYPE_GENERAL_FLAG:       
		pdwFlags = &rgdwGeneralFlags[0][0]; 
		dwLen    = dwGeneralLen;
		break;
	    }
	    
	    for (dwIndex = 0; dwIndex < dwLen; dwIndex++)
	    {
		if (0 != (pdwFlags[CERT_TYPE_INDEX] & dwCertTypeFlags))
		{
		    dwResult |= pdwFlags[GEN_KEY_INDEX]; 
		}
		pdwFlags += 2; 
	    }
	    
	    return dwResult; 
	}
    EndLocalScope; 

    //
    // Begin procedure body: 
    //

    BOOL   fResult; 
    DWORD  dwResult = 0; 
    DWORD  dwErr    = ERROR_SUCCESS; 
	
    // Input parameter validation: 
    _JumpConditionWithExpr(pdwGenKeyFlags == NULL, Error, dwErr = ERROR_INVALID_PARAMETER); 

    // Compute the gen key flags using the locally scope function.  
    dwResult |= local.mapOneCertTypeCategory(CERTTYPE_ENROLLMENT_FLAG, dwEnrollmentFlags);
    dwResult |= local.mapOneCertTypeCategory(CERTTYPE_SUBJECT_NAME_FLAG, dwSubjectNameFlags);
    dwResult |= local.mapOneCertTypeCategory(CERTTYPE_PRIVATE_KEY_FLAG, dwPrivateKeyFlags);
    dwResult |= local.mapOneCertTypeCategory(CERTTYPE_GENERAL_FLAG, dwGeneralFlags); 

    // Assign the out parameter: 
    *pdwGenKeyFlags = dwResult; 

    fResult = TRUE; 

 CommonReturn: 
    return fResult;

 Error: 
    fResult = FALSE; 
    SetLastError(dwErr); 
    goto CommonReturn; 
}

//----------------------------------------------------------------------------
//  CallBack fro cert selection call back
//
//----------------------------------------------------------------------------
BOOL WINAPI SelectSignCertCallBack(
        PCCERT_CONTEXT  pCertContext,
        BOOL            *pfInitialSelectedCert,
        void            *pvCallbackData)
{
    BOOL                            fRet = FALSE;
    DWORD                           cbData=0;
    SCrdEnroll_CERT_SELECT_INFO     *pCertSelectInfo;
    PCERT_ENHKEY_USAGE              pUsage = NULL;
    CHAR                            *pszOID = NULL;
    DWORD                           i;
    BOOL                            fFoundOid;

    if(!pCertContext)
    {
        goto done;
    }

    //the certificate has to have the CERT_KEY_PROV_INFO_PROP_ID
    if(!CertGetCertificateContextProperty(pCertContext,
                                CERT_KEY_PROV_INFO_PROP_ID,
                                NULL,
                                &cbData))
    {
        goto done;
    }

    if(0==cbData)
    {
        goto done;
    }

    pCertSelectInfo = (SCrdEnroll_CERT_SELECT_INFO *)pvCallbackData;
    if(NULL == pCertSelectInfo)
    {
        goto done;
    }

    if (NULL == pCertSelectInfo->pwszCertTemplateName ||
        L'\0' == pCertSelectInfo->pwszCertTemplateName[0])
    {
        goto done;
    }

    switch (pCertSelectInfo->dwFlags)
    {
        case SCARD_SELECT_TEMPLATENAME:
            //ask to check template name
            if(!VerifyCertTemplateName(
                    pCertContext,
                    pCertSelectInfo->pwszCertTemplateName))
            {
                goto done;
            }
        break;
        case SCARD_SELECT_EKU:
            cbData = 0;
            while (TRUE)
            {
                cbData = WideCharToMultiByte(
                                GetACP(),
                                0,
                                pCertSelectInfo->pwszCertTemplateName,
                                -1,
                                pszOID,
                                cbData,
                                NULL,
                                NULL);
                if(0 == cbData)
                {
                    goto done;
                }
                if (NULL != pszOID)
                {
                    break;
                }
                pszOID = (CHAR*)LocalAlloc(LMEM_FIXED, cbData);
                if (NULL == pszOID)
                {
                    goto done;
                }
            }
            cbData = 0;
            while (TRUE)
            {
                if (!CertGetEnhancedKeyUsage(
                        pCertContext,
                        CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
                        pUsage,
                        &cbData))
                {
                    goto done;
                }
                if (NULL != pUsage)
                {
                    //done
                    break;
                }
                pUsage = (PCERT_ENHKEY_USAGE)LocalAlloc(LMEM_FIXED, cbData);
                if (NULL == pUsage)
                {
                    goto done;
                }
            }
            fFoundOid = FALSE;
            for (i = 0 ; i < pUsage->cUsageIdentifier; ++i)
            {
                if (0 == strcmp(pszOID, pUsage->rgpszUsageIdentifier[i]))
                {
                    fFoundOid = TRUE;
                    break;
                }
            }
            if (!fFoundOid)
            {
                //not found
                goto done;
            }
        break;
        default:
            //invalid_parameter
            goto done;
    }

    //make sure the certificate pass the chain building
    if(!VerifyCertChain(pCertContext))
    {
        goto done;
    }

    fRet = TRUE;    
done:
    if (NULL != pUsage)
    {
        LocalFree(pUsage);
    }
    if (NULL != pszOID)
    {
        LocalFree(pszOID);
    }
    return fRet;
}

//-------------------------------------------------------------------------
// GetName
//
//--------------------------------------------------------------------------
BOOL    GetName(LPWSTR                  pwszName,
                EXTENDED_NAME_FORMAT    NameFormat,
                EXTENDED_NAME_FORMAT    DesiredFormat,
                LPWSTR                  *ppwszDesiredName)
{
    BOOL                                fResult = FALSE;
    DWORD                               cbSize = 0;

    *ppwszDesiredName = NULL;

    if(!TranslateNameW(
        pwszName,
        NameFormat,
        DesiredFormat,
        NULL,
        &cbSize))
        goto TraceErr;

    *ppwszDesiredName=(LPWSTR)SCrdEnrollAlloc((cbSize + 1) * sizeof(WCHAR));

    if(NULL == *ppwszDesiredName)
        goto MemoryErr;

    if(!TranslateNameW(
        pwszName,
        NameFormat,
        DesiredFormat,
        *ppwszDesiredName,
        &cbSize))
        goto TraceErr; 

    fResult = TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

    if(*ppwszDesiredName)
    {
        SCrdEnrollFree(*ppwszDesiredName);
        *ppwszDesiredName = NULL;
    }
   
    fResult = FALSE;

	goto CommonReturn;

SET_ERROR(MemoryErr, E_OUTOFMEMORY);
TRACE_ERROR(TraceErr);
}


//-------------------------------------------------------------------------
// VerifyCertChain
//
//--------------------------------------------------------------------------
BOOL    VerifyCertChain(PCCERT_CONTEXT      pCertContext)
{
    
	PCCERT_CHAIN_CONTEXT		pCertChainContext = NULL;
	CERT_CHAIN_PARA				CertChainPara;
	BOOL                        fResult=FALSE;
    DWORD                       dwChainError=CERT_TRUST_IS_NOT_TIME_VALID |        
                                                CERT_TRUST_IS_NOT_TIME_NESTED |     
                                                CERT_TRUST_IS_REVOKED |               
                                                CERT_TRUST_IS_NOT_SIGNATURE_VALID |    
                                                CERT_TRUST_IS_NOT_VALID_FOR_USAGE |   
                                                CERT_TRUST_IS_UNTRUSTED_ROOT |        
                                                CERT_TRUST_IS_CYCLIC |
                                                CERT_TRUST_IS_PARTIAL_CHAIN |          
                                                CERT_TRUST_CTL_IS_NOT_TIME_VALID |     
                                                CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID |
                                                CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE;                

	memset(&CertChainPara, 0, sizeof(CertChainPara));
	CertChainPara.cbSize = sizeof(CertChainPara);

	if (!CertGetCertificateChain(
				HCCE_CURRENT_USER,
				pCertContext,
				NULL,
                NULL,
				&CertChainPara,
				CERT_CHAIN_REVOCATION_CHECK_CHAIN,
				NULL,
				&pCertChainContext))
        goto CLEANUP;
    
	//
	// make sure there is at least 1 simple chain
	//
    if (pCertChainContext->cChain == 0)
        goto CLEANUP;

    // make sure that we have a good simple chain
    if(dwChainError & (pCertChainContext->rgpChain[0]->TrustStatus.dwErrorStatus))
        goto CLEANUP;
    
    fResult = TRUE;
	
CLEANUP:

	if (pCertChainContext != NULL)
		CertFreeCertificateChain(pCertChainContext);

	return fResult;
}

//-------------------------------------------------------------------------
//  VerifyCertTemplateName
//
//--------------------------------------------------------------------------
BOOL    VerifyCertTemplateName(PCCERT_CONTEXT   pCertContext, 
                               LPWSTR           pwszCertTemplateName)
{
    BOOL                    fResult=FALSE;
    PCERT_EXTENSION         pCertTypeExtension=NULL;
    DWORD                   cbCertType=0;
    CERT_NAME_VALUE         *pCertType=NULL;


    if((!pCertContext) || (!pwszCertTemplateName))
        goto CLEANUP;

    //find the extension for cert type
    if(NULL==(pCertTypeExtension=CertFindExtension(
                          szOID_ENROLL_CERTTYPE_EXTENSION,
                          pCertContext->pCertInfo->cExtension,
                          pCertContext->pCertInfo->rgExtension)))
        goto CLEANUP;

    if(!CryptDecodeObject(pCertContext->dwCertEncodingType,
            X509_UNICODE_ANY_STRING,
            pCertTypeExtension->Value.pbData,
            pCertTypeExtension->Value.cbData,
            0,
            NULL,
            &cbCertType) || (0==cbCertType))
        goto CLEANUP;


    pCertType=(CERT_NAME_VALUE *)SCrdEnrollAlloc(cbCertType);

    if(NULL==pCertType)
        goto CLEANUP;

    if(!CryptDecodeObject(pCertContext->dwCertEncodingType,
            X509_UNICODE_ANY_STRING,
            pCertTypeExtension->Value.pbData,
            pCertTypeExtension->Value.cbData,
            0,
            (void *)pCertType,
            &cbCertType))
        goto CLEANUP;

    if(0 != _wcsicmp((LPWSTR)(pCertType->Value.pbData), pwszCertTemplateName))
        goto CLEANUP;

    fResult=TRUE;


CLEANUP:

    if(pCertType)
        SCrdEnrollFree(pCertType);

    return fResult;
}



//----------------------------------------------------------------------------
//
//  CopyWideString
//
//----------------------------------------------------------------------------
LPWSTR CopyWideString(LPCWSTR wsz)
{

    DWORD   cch     = 0;
    LPWSTR  wszOut  = NULL;

    if(wsz == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    cch = wcslen(wsz) + 1;

    if( (wszOut = (LPWSTR) SCrdEnrollAlloc(sizeof(WCHAR) * cch)) == NULL ) {
        SetLastError(ERROR_OUTOFMEMORY);
        return(NULL);
    }

    wcscpy(wszOut, wsz);

    return(wszOut);
}

//----------------------------------------------------------------------------
//
//  CopyWideStrings
//
//----------------------------------------------------------------------------
LPWSTR* CopyWideStrings(LPWSTR* rgpwsz)
{

    DWORD    dwCount = 1;
    DWORD    dwIndex = 0;
    DWORD    cb = 0;
    LPWSTR  *ppwsz;
    LPWSTR  *rgpwszOut = NULL;
    LPWSTR   pwszCur;

    if (NULL != rgpwsz)
    {
        //get count of strings
        for (ppwsz = rgpwsz; NULL != *ppwsz; ppwsz++)
        {
            ++dwCount;
            cb += (wcslen(*ppwsz) + 1) * sizeof(WCHAR);
        }
    }

    // allocate buffer
    rgpwszOut = (LPWSTR*)SCrdEnrollAlloc(dwCount * sizeof(WCHAR*) + cb);
    if (NULL == rgpwszOut)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto error;
    }

    if (NULL != rgpwsz)
    {
        pwszCur = (LPWSTR)(rgpwszOut + dwCount);

        for(ppwsz = rgpwsz; NULL != *ppwsz; ppwsz++)
        {
            rgpwszOut[dwIndex] = pwszCur;
            wcscpy(pwszCur, *ppwsz);
            pwszCur += wcslen(pwszCur) + 1;
            ++dwIndex;
        }
    }
    rgpwszOut[dwIndex] = NULL;

error:
    return(rgpwszOut);
}

//--------------------------------------------------------------------------
//
//	  Decode a generic BLOB
//
//--------------------------------------------------------------------------
BOOL	DecodeGenericBLOB(DWORD dwEncodingType, LPCSTR lpszStructType,
			const BYTE *pbEncoded, DWORD cbEncoded,void **ppStructInfo)
{
	DWORD	cbStructInfo=0;

	//decode the object.  No copying
	if(!CryptDecodeObject(dwEncodingType,lpszStructType,pbEncoded, cbEncoded,
		0,NULL,	&cbStructInfo))
		return FALSE;

	*ppStructInfo=SCrdEnrollAlloc(cbStructInfo);

	if(!(*ppStructInfo))
	{
		SetLastError(E_OUTOFMEMORY);
		return FALSE;
	}

	return CryptDecodeObject(dwEncodingType,lpszStructType,pbEncoded, cbEncoded,
		0,*ppStructInfo,&cbStructInfo);
}



//----------------------------------------------------------------------------
//
// GetNameFromPKCS10
//
//----------------------------------------------------------------------------
BOOL    GetNameFromPKCS10(BYTE      *pbPKCS10,
                          DWORD     cbPKCS10,
                          DWORD     dwFlags, 
                          LPSTR     pszOID, 
                          LPWSTR    *ppwszName)
{
    BOOL                fResult=FALSE;
    DWORD               errBefore= GetLastError();
    DWORD               dwRDNIndex=0;
    DWORD               dwAttrCount=0;
    DWORD               dwAttrIndex=0;
    CERT_RDN_ATTR	    *pCertRDNAttr=NULL;

    CERT_REQUEST_INFO   *pCertRequestInfo=NULL;
    CERT_NAME_INFO      *pCertNameInfo=NULL;

    *ppwszName=NULL;

    if(!DecodeGenericBLOB(PKCS_7_ASN_ENCODING | X509_ASN_ENCODING, 
                          X509_CERT_REQUEST_TO_BE_SIGNED,
			              pbPKCS10, 
                          cbPKCS10,
                          (void **)&pCertRequestInfo))
        goto TraceErr;


    if(!DecodeGenericBLOB(PKCS_7_ASN_ENCODING | X509_ASN_ENCODING, 
                          X509_UNICODE_NAME,
			              (pCertRequestInfo->Subject).pbData, 
                          (pCertRequestInfo->Subject).cbData,
                          (void **)&pCertNameInfo))
        goto TraceErr;

	//search for the OID requested.
    *ppwszName = (LPWSTR)SCrdEnrollAlloc(sizeof(WCHAR));

    if(NULL == (*ppwszName))
        goto MemoryErr;

    *(*ppwszName)=L'\0';

	for(dwRDNIndex=0; dwRDNIndex<pCertNameInfo->cRDN; dwRDNIndex++)
	{
		dwAttrCount=(pCertNameInfo->rgRDN)[dwRDNIndex].cRDNAttr;

		for(dwAttrIndex=0; dwAttrIndex<dwAttrCount; dwAttrIndex++)
		{
            pCertRDNAttr=&((pCertNameInfo->rgRDN)[dwRDNIndex].rgRDNAttr[dwAttrIndex]);

			if(_stricmp(pszOID, pCertRDNAttr->pszObjId)==0)   
			{
                if(0 != wcslen(*ppwszName))
                    wcscat(*ppwszName, L"; ");

                (*ppwszName) = (LPWSTR)SCrdEnrollRealloc
                 (*ppwszName, sizeof(WCHAR) * 
                    (wcslen(*ppwszName) + wcslen(L"; ") +
                     wcslen((LPWSTR)((pCertRDNAttr->Value).pbData))+1));

                if(NULL == *ppwszName)
                    goto MemoryErr;

                wcscat(*ppwszName, (LPWSTR)((pCertRDNAttr->Value).pbData));
            }
        }
    }

    if(0 == wcslen(*ppwszName))
        goto NotFindErr;

    fResult=TRUE;


CommonReturn:

    if(pCertRequestInfo)
        SCrdEnrollFree(pCertRequestInfo);

    if(pCertNameInfo)
        SCrdEnrollFree(pCertNameInfo);

    SetLastError(errBefore);

	return fResult;

ErrorReturn:
    errBefore = GetLastError();

    if(*ppwszName)
    {
        SCrdEnrollFree(*ppwszName);
        *ppwszName=NULL;
    }


	fResult=FALSE;

	goto CommonReturn;

TRACE_ERROR(TraceErr);
SET_ERROR(NotFindErr, CRYPT_E_NOT_FOUND);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}



//----------------------------------------------------------------------------
//
// SearchAndDeleteCert
//
//----------------------------------------------------------------------------
BOOL    SearchAndDeleteCert(PCCERT_CONTEXT  pCertContext)
{
    BOOL                fResult=FALSE;
    DWORD               errBefore= GetLastError();
    HCERTSTORE          hCertStore=NULL;
    PCCERT_CONTEXT      pFoundCert=NULL;
    CERT_BLOB           HashBlob;

    memset(&HashBlob, 0, sizeof(CERT_BLOB));


    if(NULL==pCertContext)
        goto InvalidArgErr;

    //open the temporary store
    hCertStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
							        g_dwMsgAndCertEncodingType,
							        NULL,
							        CERT_SYSTEM_STORE_CURRENT_USER,
							        g_MyStoreName);
                                    
    if(NULL==hCertStore)
        goto TraceErr;

    //get the SHA1 hash
    if(!CertGetCertificateContextProperty(
        pCertContext,	
        CERT_SHA1_HASH_PROP_ID,	
        NULL,	
        &(HashBlob.cbData)))
        goto TraceErr;

    HashBlob.pbData=(BYTE *)SCrdEnrollAlloc(HashBlob.cbData);

    if(NULL==(HashBlob.pbData))
        goto MemoryErr;

    if(!CertGetCertificateContextProperty(
        pCertContext,	
        CERT_SHA1_HASH_PROP_ID,	
        HashBlob.pbData,	
        &(HashBlob.cbData)))
        goto TraceErr;


    pFoundCert=CertFindCertificateInStore(
                    hCertStore,
                    X509_ASN_ENCODING,
                    0,
                    CERT_FIND_SHA1_HASH,
                    &HashBlob,
                    NULL);

    if(pFoundCert)
        CertDeleteCertificateFromStore(pFoundCert);


    fResult=TRUE;


CommonReturn:

    if(hCertStore)
        CertCloseStore(hCertStore, 0);

    if(HashBlob.pbData)
        SCrdEnrollFree(HashBlob.pbData);

    SetLastError(errBefore);

	return fResult;

ErrorReturn:
    errBefore = GetLastError();

	fResult=FALSE;

	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
TRACE_ERROR(TraceErr);
}

//--------------------------------------------------------------------------
//
//	  FormatMessageUnicode
//
//--------------------------------------------------------------------------
BOOL	FormatMessageUnicode(LPWSTR	*ppwszFormat,LPWSTR wszFormat,...)
{
	va_list		argList;
	DWORD		cbMsg=0;
	BOOL		fResult=FALSE;
	HRESULT		hr=S_OK;

    if(NULL == ppwszFormat)
        goto InvalidArgErr;

    // format message into requested buffer
    va_start(argList, wszFormat);

    cbMsg = FormatMessageU(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        wszFormat,
        0,                  // dwMessageId
        0,                  // dwLanguageId
        (LPWSTR) (ppwszFormat),
        0,                  // minimum size to allocate
        &argList);

    va_end(argList);

	if(!cbMsg)
		goto FormatMessageError;

	fResult=TRUE;

CommonReturn:
	
	return fResult;

ErrorReturn:
	fResult=FALSE;

	goto CommonReturn;


TRACE_ERROR(FormatMessageError);
SET_ERROR(InvalidArgErr, E_INVALIDARG);
}

//-----------------------------------------------------------------------
//
// IsNewerCert
//
//      Return TRUE is pFirstCert has a later starting date of pSecondCert
//------------------------------------------------------------------------
BOOL    IsNewerCert(PCCERT_CONTEXT  pFirstCert,
                    PCCERT_CONTEXT  pSecondCert)
{
    if(NULL == pSecondCert)
        return TRUE;

    if(NULL == pFirstCert)
        return FALSE;

    if(1 != CompareFileTime(&(pFirstCert->pCertInfo->NotBefore),
                    &(pSecondCert->pCertInfo->NotBefore)))
        return FALSE;


    return TRUE;
}


//-----------------------------------------------------------------------
//
// SmartCardCSP
//
//  Return TRUE is the CSP is a smart card CSP.  If anything went wrong,
//  we will return TRUE for as a safe guard.
//------------------------------------------------------------------------
BOOL    SmartCardCSP(PCCERT_CONTEXT pCertContext)
{
    BOOL                    fResult = TRUE;
    DWORD                   cbData = 0;
    DWORD                   dwImpType=0;

    CRYPT_KEY_PROV_INFO     *pProvInfo=NULL;
    HCRYPTPROV              hProv = NULL;

    if(NULL == pCertContext)
        goto CLEANUP;


    //the certificate has to have the CERT_KEY_PROV_INFO_PROP_ID
    if(!CertGetCertificateContextProperty(pCertContext,
                                CERT_KEY_PROV_INFO_PROP_ID,
                                NULL,
                                &cbData))
        goto CLEANUP;

    if((cbData == 0) || (NULL == (pProvInfo =(CRYPT_KEY_PROV_INFO *)SCrdEnrollAlloc(cbData))))
        goto CLEANUP;

    if(!CertGetCertificateContextProperty(pCertContext,
                                CERT_KEY_PROV_INFO_PROP_ID,
                                pProvInfo,
                                &cbData))
        goto CLEANUP;

    if(!CryptAcquireContextU(&hProv,
                            NULL,
                            pProvInfo->pwszProvName,
                            pProvInfo->dwProvType,
                            CRYPT_VERIFYCONTEXT))
        goto CLEANUP;

    cbData = sizeof(dwImpType);
         
    if(!CryptGetProvParam(hProv,
                PP_IMPTYPE,
                (BYTE *)(&dwImpType),
                &cbData,
                0))
        goto CLEANUP;

    if(0 == (CRYPT_IMPL_REMOVABLE & dwImpType))
        fResult = FALSE;


CLEANUP:

    if(hProv)
        CryptReleaseContext(hProv, 0);

    if(pProvInfo)
        SCrdEnrollFree(pProvInfo);

    return fResult;

}

//-----------------------------------------------------------------------
//
// ChKInsertedCardSigningCert
//
//  This function checks to see if the inserted smart card matches
//  the signing certificate.  That is, they are actually the same cert
//  with the same public key
//
//------------------------------------------------------------------------
BOOL    ChKInsertedCardSigningCert(LPWSTR           pwszInsertProvider,
                                   DWORD            dwInsertProviderType,
                                   LPWSTR           pwszReaderName,
                                   PCCERT_CONTEXT   pSignCertContext,
                                   LPSTR            pszSignProvider,
                                   DWORD            dwSignProviderType,
                                   LPSTR            pszSignContainer,
                                   BOOL             *pfSame)
{

    BOOL                    fResult=FALSE;
    DWORD                   cbData=0;

    CRYPT_KEY_PROV_INFO     *pKeyProvInfo=NULL;
    CERT_PUBLIC_KEY_INFO    *pPubInfo=NULL;
    HCRYPTPROV              hProv=NULL;
    LPWSTR                  pwszInsertContainer=NULL;
    LPWSTR                  pwszSignProvider=NULL;
    
    if(NULL==pwszInsertProvider || NULL == pwszReaderName ||
       NULL == pSignCertContext || NULL == pszSignProvider ||
       NULL == pszSignContainer || NULL == pfSame)
        goto InvalidArgErr;

    *pfSame=FALSE;

    //get the key specification from the signing cert
    if(!CertGetCertificateContextProperty(
                pSignCertContext,
                CERT_KEY_PROV_INFO_PROP_ID,
                NULL,	
                &cbData) || (0==cbData))
        goto TraceErr;

    pKeyProvInfo=(CRYPT_KEY_PROV_INFO *)SCrdEnrollAlloc(cbData);
    if(NULL==pKeyProvInfo)
        goto MemoryErr;

    if(!CertGetCertificateContextProperty(
            pSignCertContext,
            CERT_KEY_PROV_INFO_PROP_ID,
            pKeyProvInfo,	
            &cbData))
        goto TraceErr;


    //build a default container name with the reader information
    if(!FormatMessageUnicode(&pwszInsertContainer,
                             L"\\\\.\\%1!s!\\",
                             pwszReaderName))
        goto TraceErr;
    

    //get the hProv from the reader's card
    if(!CryptAcquireContextU(&hProv,
                            pwszInsertContainer,
                            pwszInsertProvider,
                            dwInsertProviderType,
                            CRYPT_SILENT))
    {
        //check to see if we have an empty card
        if((GetLastError() == NTE_BAD_KEYSET) ||
           (GetLastError() == NTE_KEYSET_NOT_DEF))
        {
            //we have an empty card
            *pfSame=FALSE;
            fResult=TRUE;
            goto CommonReturn;
        }
        else
            goto TraceErr;
    }

    //get the public key information
    cbData=0;

    if(!CryptExportPublicKeyInfo(hProv,
                        pKeyProvInfo->dwKeySpec,
                        pSignCertContext->dwCertEncodingType,	
                        NULL,	
                        &cbData) || (0 == cbData))
    {
        //the insert card does not have a private key
        *pfSame=FALSE;
        fResult=TRUE;
        goto CommonReturn;
    }

    pPubInfo = (CERT_PUBLIC_KEY_INFO *)SCrdEnrollAlloc(cbData);

    if(NULL == pPubInfo)
        goto MemoryErr;

    if(!CryptExportPublicKeyInfo(hProv,
                        pKeyProvInfo->dwKeySpec,
                        pSignCertContext->dwCertEncodingType,	
                        pPubInfo,	
                        &cbData))
    {
        //the insert card does not have a private key
        *pfSame=FALSE;
        fResult=TRUE;
        goto CommonReturn;
    }
                
    if(CertComparePublicKeyInfo(pSignCertContext->dwCertEncodingType,
                                pPubInfo,                                                
                                &(pSignCertContext->pCertInfo->SubjectPublicKeyInfo)))
    {
        //make sure that we have the same CSP name
        pwszSignProvider=MkWStr(pszSignProvider);

        if(NULL != pwszSignProvider)
        {
            //case insensitive compare of the two csp names
            if(0 == _wcsicmp(pwszSignProvider, pwszInsertProvider))
                *pfSame=TRUE;
            else
                *pfSame=FALSE;
        }
        else
        {       
            //we are out of memory.  Assume same CSP here
            *pfSame=TRUE;
        }
    }
    else
        *pfSame=FALSE;


    fResult=TRUE;


CommonReturn:

    if(pwszSignProvider)
        FreeWStr(pwszSignProvider);

    if(pPubInfo)
        SCrdEnrollFree(pPubInfo);

    if(pKeyProvInfo)
        SCrdEnrollFree(pKeyProvInfo);

    if(hProv)
        CryptReleaseContext(hProv, 0);

    if(pwszInsertContainer)
         LocalFree((HLOCAL)pwszInsertContainer);

	return fResult;

ErrorReturn:

    fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);

}
//-----------------------------------------------------------------------
//
// DeleteKeySet
//
//   If the user's smart card is not empty, we delete the private key
//
//------------------------------------------------------------------------
BOOL    DeleteKeySet(LPWSTR     pwszUserCSPName,
                     DWORD      dwUserCSPType,
                     LPWSTR     pwszReaderName)
{
    BOOL             fResult=FALSE;
    DWORD            dwSize=0;
    HCRYPTPROV       hDeleteProv=NULL;      //no need to free this 

    HCRYPTPROV       hProv=NULL;
    LPWSTR           pwszDefaultContainer=NULL;
    LPSTR            pszContainer=NULL;
    LPWSTR           pwszContainer=NULL;

    if(NULL == pwszUserCSPName || NULL == pwszReaderName)
        goto InvalidArgErr;

    if(!FormatMessageUnicode(&pwszDefaultContainer,
                             L"\\\\.\\%1!s!\\",
                             pwszReaderName))
        goto TraceErr;

    //get the hProv from the reader's card
    if(!CryptAcquireContextU(&hProv,
                            pwszDefaultContainer,
                            pwszUserCSPName,
                            dwUserCSPType,
                            CRYPT_SILENT))
    {
        //check to see if we have an empty card
        if((GetLastError() == NTE_BAD_KEYSET) ||
           (GetLastError() == NTE_KEYSET_NOT_DEF))
        {
            //we have an empty card
            fResult=TRUE;
            goto CommonReturn;
        }
        else
            goto TraceErr;
    }

    //get the container name
    dwSize = 0;

    if(!CryptGetProvParam(hProv,
                           PP_CONTAINER,
                            NULL,
                            &dwSize,
                            0) || (0==dwSize))
        goto TraceErr;

    
    pszContainer = (LPSTR) SCrdEnrollAlloc(dwSize);

    if(NULL == pszContainer)
        goto MemoryErr;

    if(!CryptGetProvParam(hProv,
                          PP_CONTAINER,
                            (BYTE *)pszContainer,
                            &dwSize,
                            0))
        goto TraceErr;

    //release the context
    if(hProv)
    {
        CryptReleaseContext(hProv, 0);
        hProv=NULL;
    }

    //build the fully qualified container name
    if(!FormatMessageUnicode(&pwszContainer,
                             L"\\\\.\\%1!s!\\%2!S!",
                             pwszReaderName,
                             pszContainer))
        goto TraceErr;

    //delete the container
    if(!CryptAcquireContextU(&hDeleteProv,
                            pwszContainer,
                            pwszUserCSPName,
                            dwUserCSPType,
                            CRYPT_DELETEKEYSET))
    {
        //check to see if we have an empty card
        if(GetLastError() == NTE_BAD_KEYSET)
        {
            //we have an empty card
            fResult=TRUE;
            goto CommonReturn;
        }
        else
            goto TraceErr;
    }

    fResult=TRUE;


CommonReturn:

    if(pwszDefaultContainer)
        LocalFree((HLOCAL)pwszDefaultContainer);

    if(pwszContainer)
        LocalFree((HLOCAL)pwszContainer);

    if(pszContainer)
        SCrdEnrollFree(pszContainer);

    if(hProv)
        CryptReleaseContext(hProv, 0);

	return fResult;

ErrorReturn:

    fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}


//-----------------------------------------------------------------------
//
// ChkSCardStatus
//
//  This function makes sure that the smart card enrollment station has the 
//  correct number of readers connected to the station, and the correct number
//  of smart cards inserted into the readers.  If everything looks good,  
//  the user smart card is initialized (old key container deleted) and a fully
//  qualified key container name, in the format of "\\.\ReaderName\ContainerName",
//  will be returned.
//
//------------------------------------------------------------------------
HRESULT ChkSCardStatus(BOOL             fSCardSigningCert,
                       PCCERT_CONTEXT   pSigningCertCertContext,
                       LPSTR            pszCSPNameSigningCert,
                       DWORD            dwCSPTypeSigningCert,
                       LPSTR            pszContainerSigningCert,
                       LPWSTR           pwszSelectedCSP,
                       LPWSTR           *ppwszNewContainerName)
{

    HRESULT     hr=E_FAIL;
    DWORD       dwExpectedReader=0;
    DWORD       dwReader=0;
    DWORD       dwSCard=0;        
    WCHAR       wszProvider[MAX_PATH];
    DWORD       dwProviderType=0;
    DWORD       dwCount=0;
    BOOL        fFindSigningCert=FALSE;
    DWORD       errBefore=0;
    BOOL        fSameCert=FALSE;
    DWORD       dwUserCSPType=0;
    LPCWSTR     pwszReaderName=NULL;        //no need to free.  Point to internal data
    LPWSTR      pwszUserReaderName=NULL;    //no need to free . Point to internal data
    GUID        guidContainerName;

    LPVOID      pvContext = NULL;
    LPWSTR      pwszNewContainerName=NULL;
    LPWSTR      pwszUserCSPName=NULL;
    char *      sz = NULL;
    RPC_STATUS  rpc_status;


    if(NULL == pszCSPNameSigningCert || NULL == pszContainerSigningCert ||
        NULL == ppwszNewContainerName || NULL == pSigningCertCertContext ||
        NULL == pwszSelectedCSP)
        goto CLEANUP;

    *ppwszNewContainerName=NULL;

    if(fSCardSigningCert)
        dwExpectedReader=2;
    else
        dwExpectedReader=1;

    dwReader = CountReaders(NULL);

    //check the # of smart card readers
    if(dwReader < dwExpectedReader)
    {
        hr=SCARD_E_READER_UNAVAILABLE;
        goto CLEANUP;
    }

    dwSCard = ScanReaders(&pvContext);

    //no smart card is inserted
    if( 0 == dwSCard || NULL == pvContext)
    {
        hr=SCARD_E_NO_SMARTCARD;
        goto CLEANUP;
    }

    //we have more than expected # of smart card inserted
    if(dwSCard > dwExpectedReader)
    {
        // seems ERROR_TOO_MANY_OPEN_FILES is closest one for this case
        hr=HRESULT_FROM_WIN32(ERROR_TOO_MANY_OPEN_FILES);
        goto CLEANUP;
    }

    dwCount=0;
    dwProviderType=0;
    wszProvider[0]=L'\0';
    pwszReaderName=NULL;
    fSameCert=FALSE;

    //now, we loop through we all inserted cards and make sure:
    //1. We find the signing certificate if applicable
    //2. We find a valid user certificate
    while (EnumInsertedCards(
                    pvContext, 
                    wszProvider, 
                    sizeof(wszProvider)/sizeof(wszProvider[0]),
                    &dwProviderType,
                    &pwszReaderName))
    {
        if((NULL == pwszReaderName) || (0 == wcslen(wszProvider)))
        {
            //we can not determine the status of the smart card
            hr = SCARD_E_CARD_UNSUPPORTED;
            goto CLEANUP;
        }

        if (!ChKInsertedCardSigningCert(
                                    wszProvider, 
                                    dwProviderType, 
                                    (LPWSTR)pwszReaderName,
                                    pSigningCertCertContext,
                                    pszCSPNameSigningCert,
                                    dwCSPTypeSigningCert,
                                    pszContainerSigningCert,
                                    &fSameCert))
        {
            if(ERROR_SUCCESS == (errBefore = GetLastError()))
                errBefore=E_UNEXPECTED;

            hr = CodeToHR(GetLastError());
            goto CLEANUP;
        }

        if(TRUE == fSameCert)
        {
            if(TRUE == fSCardSigningCert)
            {
                if(TRUE == fFindSigningCert)
                {
                    //too many signing cards.  Not expected
                    hr = SCARD_E_CARD_UNSUPPORTED;
                    goto CLEANUP;
                }
                else
                    fFindSigningCert=TRUE;
            }
            else
            {
                //we should not expect a siging certificate
                hr=SCARD_E_CARD_UNSUPPORTED;
                goto CLEANUP;
            }
        }
        else
        {
            //this is a user card.  
            if(NULL != (pwszUserCSPName))
            {
                //too many user cards.
                // seems ERROR_TOO_MANY_OPEN_FILES is closest one for this case
                hr=HRESULT_FROM_WIN32(ERROR_TOO_MANY_OPEN_FILES);
                goto CLEANUP;
            }

            pwszUserCSPName = CopyWideString(wszProvider);

            if(NULL == pwszUserCSPName)
            {
                hr=E_OUTOFMEMORY;
                goto CLEANUP;
            }

            dwUserCSPType = dwProviderType;    
            pwszUserReaderName = (LPWSTR)pwszReaderName;
        }

        dwCount++;
        if(dwCount >= dwSCard)
            break;

        dwProviderType=0;
        pwszReaderName=NULL;
        wszProvider[0]=L'\0';
        fSameCert=FALSE;
    }    

    if((TRUE == fSCardSigningCert) && (FALSE == fFindSigningCert))
    {
        //we failed to find the signing certificate
        hr=SCARD_E_NO_SUCH_CERTIFICATE;

        goto CLEANUP;
    }
         
    if(NULL == pwszUserCSPName)
    {
        //we failed to find the target user certificate
        hr=SCARD_E_NO_SMARTCARD;
        goto CLEANUP;
    }

    //make sure the pwszUserCSPName matches with the CSP selected by the admin
    if(0 != _wcsicmp(pwszUserCSPName, pwszSelectedCSP))
    {
        hr=SCARD_E_PROTO_MISMATCH;
        goto CLEANUP;
    }

    //delete the key set from the user's certificate
    if(!DeleteKeySet(pwszUserCSPName,
                     dwUserCSPType,
                     pwszUserReaderName))
    {
        if(ERROR_SUCCESS == (errBefore = GetLastError()))
            errBefore=E_UNEXPECTED;

        hr = CodeToHR(GetLastError());
        goto CLEANUP;

    }

    //Build the fully qualified container name with a GUID
   
    // get a container based on a guid
    rpc_status = UuidCreate(&guidContainerName);
    if (RPC_S_OK != rpc_status && RPC_S_UUID_LOCAL_ONLY != rpc_status)
    {
        hr = rpc_status;
        goto CLEANUP;
    }

    rpc_status = UuidToStringA(&guidContainerName, (unsigned char **) &sz);
    if (RPC_S_OK != rpc_status)
    {
        hr = rpc_status;
        goto CLEANUP;
    }


    if(NULL == sz)
    {
        hr=E_OUTOFMEMORY;
        goto CLEANUP;
    }

    //although the chance is VERY low, we could generate a same GUID
    //as the signing cert's container.  
    if(0 == _stricmp(sz,pszContainerSigningCert))
    {
        //we will have to do this again
        RpcStringFree((unsigned char **) &sz);
        sz=NULL;

        rpc_status = UuidCreate(&guidContainerName);
        if (RPC_S_OK != rpc_status && RPC_S_UUID_LOCAL_ONLY != rpc_status)
        {
            hr = rpc_status;
            goto CLEANUP;
        }

        rpc_status = UuidToStringA(&guidContainerName, (unsigned char **) &sz);
        if (RPC_S_OK != rpc_status)
        {
            hr = rpc_status;
            goto CLEANUP;
        }

        if(NULL == sz)
        {
            hr=E_OUTOFMEMORY;
            goto CLEANUP;
        }

        //since we are guaranted a new GUID, we should be fine here
        if(0 == _stricmp(sz,pszContainerSigningCert))
        {
            //can not support this smart card
            hr = SCARD_E_CARD_UNSUPPORTED;
            goto CLEANUP;
        }
    }

    if(!FormatMessageUnicode(&pwszNewContainerName,
                             L"\\\\.\\%1!s!\\%2!S!",
                             pwszUserReaderName,
                             sz))
    {
        if(ERROR_SUCCESS == (errBefore = GetLastError()))
            errBefore=E_UNEXPECTED;

        hr = CodeToHR(GetLastError());
        goto CLEANUP;
    }


    *ppwszNewContainerName = pwszNewContainerName;
    pwszNewContainerName = NULL;

    hr=S_OK;

CLEANUP:

    if(pwszUserCSPName)
        SCrdEnrollFree(pwszUserCSPName);

    if(sz)
        RpcStringFree((unsigned char **) &sz);

    if(pvContext)
        EndReaderScan(&pvContext);

    if(pwszNewContainerName)
        LocalFree((HLOCAL)pwszNewContainerName);


    return hr;

}
     
//-----------------------------------------------------------------------
//
// SignWithCert
//
//  We sign a dummy message with the signing certificate so that 
//  the smart card insert cert dialogue will be prompted
//
//------------------------------------------------------------------------
BOOL    SignWithCert(LPSTR              pszCSPName,
                     DWORD              dwCSPType,
                     PCCERT_CONTEXT     pSigningCert)
{
    BOOL                        fResult=FALSE;
    DWORD                       errBefore= GetLastError();
    HRESULT                     hr=E_FAIL;
	CRYPT_SIGN_MESSAGE_PARA     signMsgPara;
    DWORD                       cbData=0;

    BYTE                        *pbData=NULL;
    IEnroll                     *pIEnroll=NULL;
    LPWSTR                      pwszCSPName=NULL;
    LPWSTR                      pwszOID=NULL;
    LPSTR                       pszOID=NULL;

    char                        szMessage[] = "MyMessage"; 
    LPSTR                       pszMessage = szMessage;          
    BYTE*                       pbMessage = (BYTE*) pszMessage;   
    DWORD                       cbMessage = sizeof(szMessage);    

    memset(&signMsgPara, 0, sizeof(CRYPT_SIGN_MESSAGE_PARA));

    if(NULL == pszCSPName)
        goto InvalidArgErr;

    pwszCSPName = MkWStr(pszCSPName);

    if(NULL == pwszCSPName)
         goto MemoryErr;

    //use xEnroll to get the correct hash algorithm for the 
    //CSP
    if(NULL == (pIEnroll=PIEnrollGetNoCOM()))
        goto TraceErr;

    //set the CSP information
    if(S_OK != (hr=pIEnroll->put_ProviderType(dwCSPType)))
        goto SetErr;

    if(S_OK !=(hr=pIEnroll->put_ProviderNameWStr(pwszCSPName)))
        goto SetErr;

    if(S_OK != (hr=pIEnroll->get_HashAlgorithmWStr(&pwszOID)))
        goto SetErr;

    if(!MkMBStr(NULL, 0, pwszOID, &pszOID))
        goto TraceErr;


    signMsgPara.cbSize                  = sizeof(CRYPT_SIGN_MESSAGE_PARA);
    signMsgPara.dwMsgEncodingType       = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING;
    signMsgPara.pSigningCert            = pSigningCert;
    signMsgPara.HashAlgorithm.pszObjId  = pszOID;
    signMsgPara.cMsgCert                = 1;
    signMsgPara.rgpMsgCert              = &pSigningCert;


    cbData = 0;

    if( !CryptSignMessage(
        &signMsgPara,
        FALSE,
        1,
        (const BYTE **) &(pbMessage),
        &(cbMessage) ,
        NULL,
        &cbData)|| (0 == cbData))
        goto TraceErr;

    pbData = (BYTE *)SCrdEnrollAlloc(cbData);

    if(NULL == pbData)
        goto MemoryErr;

    if( !CryptSignMessage(
        &signMsgPara,
        FALSE,
        1,
        (const BYTE **) &(pbMessage),
        &(cbMessage) ,
        pbData,
        &cbData))
        goto TraceErr;


    fResult=TRUE;


CommonReturn:

    if(pbData)
        SCrdEnrollFree(pbData);

    if(pwszCSPName)
        FreeWStr(pwszCSPName);

    if(pszOID)
        FreeMBStr(NULL,pszOID);

    //the memory from xEnroll is freed via LocalFree
    //since we use the PIEnrollGetNoCOM function
    if(pwszOID)
        LocalFree(pwszOID);

    if(pIEnroll)
        pIEnroll->Release();

    SetLastError(errBefore);

	return fResult;

ErrorReturn:
    errBefore = GetLastError();

	fResult=FALSE;

	goto CommonReturn;

TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR_VAR(SetErr, hr);
}



//-----------------------------------------------------------------------
//
// GetSelectedUserName
//
//------------------------------------------------------------------------
HRESULT GetSelectedUserName(IDsObjectPicker     *pDsObjectPicker,
                            LPWSTR              *ppwszSelectedUserSAM,
                            LPWSTR              *ppwszSelectedUserUPN)
{
    HRESULT                         hr= E_FAIL;
    DWORD                           errBefore= GetLastError();
    BOOL                            fGotStgMedium = FALSE;
    LPWSTR                          pwszPath=NULL;
    DWORD                           dwIndex =0 ;
    DWORD                           dwCount=0;

    IDataObject                     *pdo = NULL;
    PDS_SELECTION_LIST              pDsSelList=NULL;
    WCHAR                           wszWinNT[]=L"WinNT://";

    STGMEDIUM stgmedium =
    {
        TYMED_HGLOBAL,
        NULL,
        NULL
    };

    FORMATETC formatetc =
    {
        (CLIPFORMAT)g_cfDsObjectPicker,
        NULL,
        DVASPECT_CONTENT,
        -1,
        TYMED_HGLOBAL
    };

    //input check
    if((NULL == ppwszSelectedUserSAM) || (NULL == ppwszSelectedUserUPN))
        goto InvalidArgErr;

    *ppwszSelectedUserSAM = NULL;
    *ppwszSelectedUserUPN = NULL;

    if(NULL == pDsObjectPicker)
        goto InvalidArgErr;

    if(S_OK != (hr = pDsObjectPicker->InvokeDialog(NULL, &pdo)))
        goto SetErr;

    if(S_OK != (hr = pdo->GetData(&formatetc, &stgmedium)))
        goto SetErr;

    fGotStgMedium = TRUE;

    pDsSelList = (PDS_SELECTION_LIST)GlobalLock(stgmedium.hGlobal);

    if(!pDsSelList)
        goto TraceErr;

    //Get the SAM name
    if((pDsSelList->aDsSelection[0]).pwzADsPath == NULL)
        goto UnexpectedErr;

    //the ADsPath is in the form of "WinNT://" 
    if(wcslen((pDsSelList->aDsSelection[0]).pwzADsPath) <= wcslen(wszWinNT))
        goto UnexpectedErr;

    if( 0 != _wcsnicmp((pDsSelList->aDsSelection[0]).pwzADsPath, wszWinNT, wcslen(wszWinNT)))
        goto UnexpectedErr;

    pwszPath = ((pDsSelList->aDsSelection[0]).pwzADsPath) + wcslen(wszWinNT);

    *ppwszSelectedUserSAM=CopyWideString(pwszPath);

    if(NULL == (*ppwszSelectedUserSAM))
        goto MemoryErr;

    //search for the "/" and make it "\".  Since the ADsPath is in the form
    //of "WinNT://domain/name".  We need the SAM name in the form of 
    //domain\name
    dwCount = wcslen(*ppwszSelectedUserSAM);

    for(dwIndex = 0; dwIndex < dwCount; dwIndex++)
    {
        if((*ppwszSelectedUserSAM)[dwIndex] == L'/')
        {
            (*ppwszSelectedUserSAM)[dwIndex] = L'\\';
            break;
        }
    }
    
    //get the UPN name
    if((pDsSelList->aDsSelection[0]).pwzUPN != NULL)
    {

        if(0 != _wcsicmp(L"",(pDsSelList->aDsSelection[0]).pwzUPN))
        {

            *ppwszSelectedUserUPN= CopyWideString((pDsSelList->aDsSelection[0]).pwzUPN);

            if(NULL == (*ppwszSelectedUserUPN))
                goto MemoryErr;

            //if we already have a UPN name, get the SAM name from TraslateName
            if(*ppwszSelectedUserSAM)
            {
                SCrdEnrollFree(*ppwszSelectedUserSAM);
                *ppwszSelectedUserSAM=NULL;
            }

            if(!GetName(*ppwszSelectedUserUPN, 
                        NameUserPrincipal,
                        NameSamCompatible,
                        ppwszSelectedUserSAM))
                goto TraceErr;
        }
    }

    hr=S_OK;

CommonReturn:

    if(pDsSelList)
        GlobalUnlock(stgmedium.hGlobal);

    if (TRUE == fGotStgMedium)
        ReleaseStgMedium(&stgmedium);

    if(pdo)
        pdo->Release();

    SetLastError(errBefore);

	return hr;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    hr = CodeToHR(errBefore);

    //we should free the memory for the output
    if(ppwszSelectedUserSAM)
    {
        if(*ppwszSelectedUserSAM)
        {
            SCrdEnrollFree(*ppwszSelectedUserSAM);
            *ppwszSelectedUserSAM=NULL;
        }
    }

    if(ppwszSelectedUserUPN)
    {
        if(*ppwszSelectedUserUPN)
        {
            SCrdEnrollFree(*ppwszSelectedUserUPN);
            *ppwszSelectedUserUPN=NULL;
        }
    }


	goto CommonReturn;

SET_ERROR_VAR(SetErr, hr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
TRACE_ERROR(TraceErr);
SET_ERROR(UnexpectedErr, E_UNEXPECTED);
SET_ERROR(InvalidArgErr, E_INVALIDARG);
}


//-----------------------------------------------------------------------
//
// CodeToHR
//
//------------------------------------------------------------------------
HRESULT CodeToHR(HRESULT hr)
{
    if (S_OK != hr && S_FALSE != hr &&
	    (!FAILED(hr) || 0x0 == (LONG)HRESULT_FACILITY(hr)))
    {
        hr = HRESULT_FROM_WIN32(hr);
	    if (0x0 == (LONG)HRESULT_CODE(hr))
	    {
	        // A call failed without properly setting an error condition!
	        hr = E_UNEXPECTED;
	    }
    }
    return(hr);
}

//-----------------------------------------------------------------------
//
// ValidCSP
//
//------------------------------------------------------------------------
BOOL    ValidCSP(DWORD  dwProviderType, LPWSTR  pwszName)
{
    HCRYPTPROV      hProv=NULL;
    BOOL            fValid=FALSE;
    DWORD           dwImpType=0;
    DWORD           dwSize=sizeof(dwImpType);

    if(CryptAcquireContextU(&hProv,
                NULL,
                pwszName,
                dwProviderType,
                CRYPT_VERIFYCONTEXT))
    {

        if(CryptGetProvParam(hProv,
                    PP_IMPTYPE,
                    (BYTE *)(&dwImpType),
                    &dwSize,
                    0))
        {
            if(CRYPT_IMPL_REMOVABLE & dwImpType)
                fValid=TRUE;
        }
    }

    if(hProv)
        CryptReleaseContext(hProv, 0);

   return fValid;
}

//-----------------------------------------------------------------------
//
// InitlializeCSPList
//
//------------------------------------------------------------------------
BOOL    InitlializeCSPList(DWORD    *pdwCSPCount, SCrdEnroll_CSP_INFO **prgCSPInfo)
{
    BOOL                    fResult=FALSE;
    DWORD                   errBefore= GetLastError();

    DWORD                   dwIndex=0;
    DWORD                   dwProviderType=0;
    DWORD                   cbSize=0;

    SCrdEnroll_CSP_INFO     *rgCSPInfo=NULL;
    LPWSTR                  pwszName=NULL;

    *pdwCSPCount=0;
    *prgCSPInfo=NULL;

    while(CryptEnumProvidersU(
                    dwIndex,
                    0,
                    0,
                    &dwProviderType,
                    NULL,
                    &cbSize))
    {

        pwszName=(LPWSTR)SCrdEnrollAlloc(cbSize);

        if(NULL==pwszName)
            goto MemoryErr;

        if(!CryptEnumProvidersU(
                    dwIndex,
                    0,
                    0,
                    &dwProviderType,
                    pwszName,
                    &cbSize))
            goto TraceErr;

        if(ValidCSP(dwProviderType, pwszName))
        {
            rgCSPInfo=(SCrdEnroll_CSP_INFO *)SCrdEnrollRealloc(*prgCSPInfo,
                ((*pdwCSPCount) + 1) * sizeof(SCrdEnroll_CSP_INFO));

            if(NULL==rgCSPInfo)
                goto MemoryErr;

            *prgCSPInfo=rgCSPInfo;

            memset(&(*prgCSPInfo)[*pdwCSPCount], 0, sizeof(SCrdEnroll_CSP_INFO));

            (*prgCSPInfo)[*pdwCSPCount].pwszCSPName=pwszName;
            pwszName=NULL;

            (*prgCSPInfo)[*pdwCSPCount].dwCSPType=dwProviderType;

            (*pdwCSPCount)++;
        }
        else
        {
            SCrdEnrollFree(pwszName);
            pwszName=NULL;
        }


        dwIndex++;

        dwProviderType=0;
        cbSize=0;
    }


    if((*pdwCSPCount == 0) || (*prgCSPInfo == NULL))
        goto NoItemErr;

    fResult=TRUE;

CommonReturn:

    if(pwszName)
        SCrdEnrollFree(pwszName);

    SetLastError(errBefore);

	return fResult;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    //we need to free all the memory
     FreeCSPInfo(*pdwCSPCount, *prgCSPInfo);

     *pdwCSPCount=0;
     *prgCSPInfo=NULL;

	goto CommonReturn;

SET_ERROR(MemoryErr, E_OUTOFMEMORY);
TRACE_ERROR(TraceErr);
SET_ERROR(NoItemErr,ERROR_NO_MORE_ITEMS);

}

//-----------------------------------------------------------------------
//
// FreeCSPInfo
//
//------------------------------------------------------------------------
void    FreeCSPInfo(DWORD   dwCSPCount, SCrdEnroll_CSP_INFO *prgCSPInfo)
{
    DWORD   dwIndex=0;

    if(prgCSPInfo)
    {
        for(dwIndex=0; dwIndex < dwCSPCount; dwIndex++)
        {
            if(prgCSPInfo[dwIndex].pwszCSPName)
                SCrdEnrollFree(prgCSPInfo[dwIndex].pwszCSPName);
        }

        SCrdEnrollFree(prgCSPInfo);
    }
}


//-----------------------------------------------------------------------
//
// FreeCAInfoElement
//
//------------------------------------------------------------------------
void    FreeCAInfoElement(SCrdEnroll_CA_INFO *pCAInfo)
{
    if(pCAInfo)
    {
        if(pCAInfo->pwszCAName)
            SCrdEnrollFree(pCAInfo->pwszCAName);

        if(pCAInfo->pwszCALocation)
            SCrdEnrollFree(pCAInfo->pwszCALocation);

        if(pCAInfo->pwszCADisplayName)
            SCrdEnrollFree(pCAInfo->pwszCADisplayName);

        memset(pCAInfo, 0, sizeof(SCrdEnroll_CA_INFO));
    }
}

//-----------------------------------------------------------------------
//
// FreeCAInfo
//
//------------------------------------------------------------------------
void    FreeCAInfo(DWORD    dwCACount, SCrdEnroll_CA_INFO *rgCAInfo)
{
    DWORD   dwIndex=0;

    if(rgCAInfo)
    {
        for(dwIndex=0; dwIndex < dwCACount; dwIndex++)
            FreeCAInfoElement(&(rgCAInfo[dwIndex]));

        SCrdEnrollFree(rgCAInfo);
    }
}
//-----------------------------------------------------------------------
//
// FreeCTInfoElement
//
//------------------------------------------------------------------------
void    FreeCTInfoElement(SCrdEnroll_CT_INFO    * pCTInfo)
{

    if(pCTInfo)
    {
        if(pCTInfo->pCertTypeExtensions)
            CAFreeCertTypeExtensions(NULL,pCTInfo->pCertTypeExtensions);

        if(pCTInfo->pwszCTName)
            SCrdEnrollFree(pCTInfo->pwszCTName);

        if(pCTInfo->pwszCTDisplayName)
            SCrdEnrollFree(pCTInfo->pwszCTDisplayName);

        if(pCTInfo->rgCAInfo)
            FreeCAInfo(pCTInfo->dwCACount, pCTInfo->rgCAInfo);

        if (NULL != pCTInfo->rgpwszSupportedCSPs)
        {
            SCrdEnrollFree(pCTInfo->rgpwszSupportedCSPs);
        }
        memset(pCTInfo, 0, sizeof(SCrdEnroll_CT_INFO));
    }
}



//-----------------------------------------------------------------------
//
// FreeCTInfo(DWORD    dwCTCount, SCrdEnroll_CT_INFO *rgCTInfo);
//
//------------------------------------------------------------------------
void    FreeCTInfo(DWORD    dwCTCount, SCrdEnroll_CT_INFO *rgCTInfo)
{
    DWORD   dwIndex=0;

    if(rgCTInfo)
    {
        for(dwIndex=0; dwIndex < dwCTCount; dwIndex++)
            FreeCTInfoElement(&(rgCTInfo[dwIndex]));

        SCrdEnrollFree(rgCTInfo);
    }
}

//-----------------------------------------------------------------------
//
// GetCertTypeProperties
//
//------------------------------------------------------------------------
BOOL    GetCertTypeProperties(HCERTTYPE             hCurCertType,
                              SCrdEnroll_CT_INFO    *pCertInfo)
{

    BOOL                fResult=FALSE;
    DWORD               errBefore= GetLastError();
    HRESULT             hr=S_OK;
    DWORD               dwCertType=0;
    DWORD               dwMinKeySize; 
    DWORD               dwEnrollmentFlags; 
    DWORD               dwSubjectNameFlags;
    DWORD               dwPrivateKeyFlags;
    DWORD               dwGeneralFlags; 
    DWORD               dwGenKeyFlags; 
    LPWSTR             *rgpwszSupportedCSPs = NULL;

    LPWSTR              *ppwszDisplayCertTypeName=NULL;
    LPWSTR              *ppwszCertTypeName=NULL;


    if((NULL==pCertInfo) || (NULL == hCurCertType))
        goto InvalidArgErr;
    
    //
    // Get all of the cert type flags. 
    //
    
    // Get enrollment flags:
    if (S_OK != (hr=MyCAGetCertTypeFlagsEx
		 (hCurCertType,
		  CERTTYPE_ENROLLMENT_FLAG, 
		  &pCertInfo->dwEnrollmentFlags)))
	goto CertCliErr;
	   
    // Get subject name flags: 
    if (S_OK != (hr=MyCAGetCertTypeFlagsEx
		 (hCurCertType,
		  CERTTYPE_SUBJECT_NAME_FLAG, 
		  &pCertInfo->dwSubjectNameFlags)))
	goto CertCliErr;


    // Get private key flags.  
    if(S_OK != (hr = MyCAGetCertTypeFlagsEx
		(hCurCertType, 
		 CERTTYPE_PRIVATE_KEY_FLAG, 
		 &pCertInfo->dwPrivateKeyFlags)))
        goto CertCliErr;

    
    // Get general flags:
    if (S_OK != (hr=MyCAGetCertTypeFlagsEx
		 (hCurCertType,
		  CERTTYPE_GENERAL_FLAG,
		  &pCertInfo->dwGeneralFlags)))
	goto CertCliErr;
    
    //detremine machine boolean flag
    pCertInfo->fMachine = (0x0 != (pCertInfo->dwGeneralFlags & CT_FLAG_MACHINE_TYPE)) ? TRUE : FALSE;

    // Extract gen key flags from the type flags. 
    dwGenKeyFlags = 0;     
    if (!(CertTypeFlagsToGenKeyFlags
	  (pCertInfo->dwEnrollmentFlags,
	   pCertInfo->dwSubjectNameFlags,
	   pCertInfo->dwPrivateKeyFlags,
	   pCertInfo->dwGeneralFlags,
	   &pCertInfo->dwGenKeyFlags)))
	goto CertCliErr; 

    // Get key spec: 
    if(S_OK != (hr= CAGetCertTypeKeySpec(hCurCertType, &(pCertInfo->dwKeySpec))))
        goto CertCliErr;

    //get the display name of the cert type
    hr=CAGetCertTypeProperty(
        hCurCertType,
        CERTTYPE_PROP_FRIENDLY_NAME,
        &ppwszDisplayCertTypeName);

    if(S_OK != hr || NULL==ppwszDisplayCertTypeName)
    {
        if(S_OK == hr)
            hr=E_FAIL;
        goto CertCliErr;
    }

    //copy the name
    pCertInfo->pwszCTDisplayName=CopyWideString(ppwszDisplayCertTypeName[0]);

    if(NULL==(pCertInfo->pwszCTDisplayName))
        goto MemoryErr;


    //get the machine readable name of the cert type
    hr=CAGetCertTypeProperty(
        hCurCertType,
        CERTTYPE_PROP_DN,
        &ppwszCertTypeName);

    if(S_OK != hr || NULL==ppwszCertTypeName)
    {
        if(S_OK == hr)
            hr=E_FAIL;
        goto CertCliErr;
    }

    //copy the name
    pCertInfo->pwszCTName=CopyWideString(ppwszCertTypeName[0]);

    if(NULL==(pCertInfo->pwszCTName))
        goto MemoryErr;

    //copy the certType extensions
    if(S_OK != (hr=CAGetCertTypeExtensions(
            hCurCertType,
            &(pCertInfo->pCertTypeExtensions))))
        goto CertCliErr;

    //copy csp list supported by template
    hr = CAGetCertTypeProperty(
                hCurCertType,
                CERTTYPE_PROP_CSP_LIST,
                &rgpwszSupportedCSPs);
    if (S_OK != hr)
    {
        goto CertCliErr;
    }
    pCertInfo->rgpwszSupportedCSPs = CopyWideStrings(rgpwszSupportedCSPs);
    if (NULL == pCertInfo->rgpwszSupportedCSPs)
    {
        goto MemoryErr;
    }
    pCertInfo->dwCurrentCSP = 0; //first one

    //
    // Set V2 properties. 
    // If we're dealing with a v2 cert type, add v2 properties.
    // Otherwise, insert defaults.  
    // 

    if (S_OK != (hr=MyCAGetCertTypePropertyEx
		 (hCurCertType,
		  CERTTYPE_PROP_SCHEMA_VERSION, 
		  &dwCertType)))
	goto CertCliErr;

    if (dwCertType == CERTTYPE_SCHEMA_VERSION_1)
    {
	// Just a v1 cert type, it won't have v2 properties.  
	// Set left half-word of the type flags to 0.  This means that
	// that the min key size is not specified.  
	pCertInfo->dwGenKeyFlags &= 0x0000FFFF;  
	pCertInfo->dwRASignature = 0; 
    }
    else // We must have a v2 (or greater) cert type.  
    {
	// Get the minimum key size of the cert type
	if (S_OK != (hr=MyCAGetCertTypePropertyEx
		     (hCurCertType,
		      CERTTYPE_PROP_MIN_KEY_SIZE,
		      (LPVOID)&dwMinKeySize)))
	    goto CertCliErr; 

	// store the minimum key size in the left half-word of the 
	// type flags. 
	pCertInfo->dwGenKeyFlags = 
	    (dwMinKeySize << 16) | (pCertInfo->dwGenKeyFlags & 0x0000FFFF) ; 

	// Get the number of RA signatures required for this cert type. 
	if (S_OK != (hr=MyCAGetCertTypePropertyEx
		     (hCurCertType,
		      CERTTYPE_PROP_RA_SIGNATURE,
		      (LPVOID)(&pCertInfo->dwRASignature))))
	    goto CertCliErr; 
    }
    
    fResult=TRUE;

CommonReturn:

    if(ppwszDisplayCertTypeName)
        CAFreeCertTypeProperty(hCurCertType, ppwszDisplayCertTypeName);

    if(ppwszCertTypeName)
        CAFreeCertTypeProperty(hCurCertType, ppwszCertTypeName);
 
    if (NULL != rgpwszSupportedCSPs)
    {
        CAFreeCertTypeProperty(hCurCertType, rgpwszSupportedCSPs);
    }

    SetLastError(errBefore);

	return fResult;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    //in error case, free the memory and memset to 0
    if(pCertInfo)
        FreeCTInfoElement(pCertInfo);

	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR_VAR(CertCliErr, hr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}


//--------------------------------------------------------------------
//
//  IsMachineCertType
//
//--------------------------------------------------------------------
BOOL    IsMachineCertType(HCERTTYPE hCertType)
{
    DWORD   dwCertType=0;

    if(S_OK != CAGetCertTypeFlags(hCertType, &dwCertType))
        return FALSE;

    if(CT_FLAG_MACHINE_TYPE & dwCertType)
        return TRUE;

    return FALSE;
}

//-----------------------------------------------------------------------
//  Get a list of allowed cert types
//
//------------------------------------------------------------------------
/*BOOL    GetAllowedCertTypeName(LPWSTR   **pawszAllowedCertTypes)
{
    DWORD                   dwErr=0;
    KEYSVC_TYPE             dwServiceType=KeySvcMachine;
    DWORD                   cTypes=0;
    DWORD                   dwSize=0;
    CHAR                    szComputerName[MAX_COMPUTERNAME_LENGTH + 1]={0};
    DWORD                   cbArray = 0;
    DWORD                   i=0;
    LPWSTR                  wszCurrentType;
    BOOL                    fResult=FALSE;
        
    KEYSVCC_HANDLE          hKeyService=NULL;
    PKEYSVC_UNICODE_STRING  pCertTypes = NULL;

    dwSize=sizeof(szComputerName);

    if(0==GetComputerNameA(szComputerName, &dwSize))
        goto TraceErr;
       
    dwErr = KeyOpenKeyService(szComputerName,
                                    dwServiceType,
                                    NULL, 
                                    NULL,     // no authentication string right now
                                    NULL,
                                    &hKeyService);

    if(dwErr != ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        goto TraceErr;
    }

    dwErr = KeyEnumerateAvailableCertTypes(hKeyService,
                                          NULL, 
                                          &cTypes,
                                          &pCertTypes);
    if(dwErr != ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        goto TraceErr;
    }

    cbArray = (cTypes+1)*sizeof(LPWSTR);

    // Convert into a simple array
    for(i=0; i < cTypes; i++)
    {
       cbArray += pCertTypes[i].Length;
    }

    *pawszAllowedCertTypes = (LPWSTR *)SCrdEnrollAlloc(cbArray);


    if(*pawszAllowedCertTypes == NULL)
           goto MemoryErr;


    memset(*pawszAllowedCertTypes, 0, cbArray);

    wszCurrentType = (LPWSTR)(&((*pawszAllowedCertTypes)[cTypes + 1]));
    
    for(i=0; i < cTypes; i++)
    {
       (*pawszAllowedCertTypes)[i] = wszCurrentType;

       wcscpy(wszCurrentType, pCertTypes[i].Buffer);

       wszCurrentType += wcslen(wszCurrentType)+1;
    }

    fResult=TRUE;

CommonReturn:

    //memory from the KeyService
    if(pCertTypes)
        LocalFree((HLOCAL)pCertTypes);


    if(hKeyService)
        KeyCloseKeyService(hKeyService, NULL);


    return fResult;


ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}  */


//--------------------------------------------------------------------
//
//  CheckAccessPermission
//
//--------------------------------------------------------------------
BOOL    CheckAccessPermission(HCERTTYPE  hCertType)
{
     //make sure the principal making this call has access to request
    //this cert type, even if he's requesting on behalf of another.
    //
    HRESULT         hr = S_OK;
    HANDLE          hHandle = NULL;
    HANDLE          hClientToken = NULL;

    hHandle = GetCurrentThread();
    if (NULL == hHandle)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {

        if (!OpenThreadToken(hHandle,
                             TOKEN_QUERY,
                             TRUE,  // open as self
                             &hClientToken))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            CloseHandle(hHandle);
            hHandle = NULL;
        }
    }
    if(hr != S_OK)
    {
        hHandle = GetCurrentProcess();
        if (NULL == hHandle)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        else
        {
            HANDLE hProcessToken = NULL;
            hr = S_OK;


            if (!OpenProcessToken(hHandle,
                                 TOKEN_DUPLICATE,
                                 &hProcessToken))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                CloseHandle(hHandle);
                hHandle = NULL;
            }
            else
            {
                if(!DuplicateToken(hProcessToken,
                               SecurityImpersonation,
                               &hClientToken))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    CloseHandle(hHandle);
                    hHandle = NULL;
                }
                CloseHandle(hProcessToken);
            }
        }
    }


    if(hr == S_OK)
    {

        hr = CACertTypeAccessCheck(
            hCertType,
            hClientToken);

        CloseHandle(hClientToken);
    }
    if(hHandle)
    {
        CloseHandle(hHandle);
    }

    return (S_OK == hr);
}

//--------------------------------------------------------------------
//
//  TokenCheckAccessPermission
//
//--------------------------------------------------------------------
BOOL	TokenCheckAccessPermission(HANDLE hToken, HCERTTYPE hCertType)
{
	HRESULT	hr=E_FAIL;

	if(hToken)
	{
		hr = CACertTypeAccessCheck(
            hCertType,
            hToken);

		return (S_OK == hr);

	}

	return CheckAccessPermission(hCertType);
}


//--------------------------------------------------------------------
//
//  CheckCAPermission
//
//--------------------------------------------------------------------
BOOL    CheckCAPermission(HCAINFO hCAInfo)
{
     //make sure the principal making this call has access to request
    //this cert type, even if he's requesting on behalf of another.
    //
    HRESULT         hr = S_OK;
    HANDLE          hHandle = NULL;
    HANDLE          hClientToken = NULL;

    hHandle = GetCurrentThread();
    if (NULL == hHandle)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {

        if (!OpenThreadToken(hHandle,
                             TOKEN_QUERY,
                             TRUE,  // open as self
                             &hClientToken))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            CloseHandle(hHandle);
            hHandle = NULL;
        }
    }
    if(hr != S_OK)
    {
        hHandle = GetCurrentProcess();
        if (NULL == hHandle)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        else
        {
            HANDLE hProcessToken = NULL;
            hr = S_OK;


            if (!OpenProcessToken(hHandle,
                                 TOKEN_DUPLICATE,
                                 &hProcessToken))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                CloseHandle(hHandle);
                hHandle = NULL;
            }
            else
            {
                if(!DuplicateToken(hProcessToken,
                               SecurityImpersonation,
                               &hClientToken))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    CloseHandle(hHandle);
                    hHandle = NULL;
                }
                CloseHandle(hProcessToken);
            }
        }
    }


    if(hr == S_OK)
    {

        hr = CAAccessCheck(
            hCAInfo,
            hClientToken);

        CloseHandle(hClientToken);
    }
    if(hHandle)
    {
        CloseHandle(hHandle);
    }

    return (S_OK == hr);
}

//--------------------------------------------------------------------
//
//  TokenCheckCAPermission
//
//--------------------------------------------------------------------
BOOL	TokenCheckCAPermission(HANDLE hToken, HCAINFO hCAInfo)
{
	HRESULT	hr=E_FAIL;

	if(hToken)
	{
		hr = CAAccessCheck(
            hCAInfo,
            hToken);

		return (S_OK == hr);

	}

	return CheckCAPermission(hCAInfo);
}


//--------------------------------------------------------------------
//
//   CheckSubjectRequirement
//
//--------------------------------------------------------------------
/*BOOL    CheckSubjectRequirement(HCERTTYPE    hCurCertType)
{
    DWORD   dwFlags=0;

    //check the subject requirement of the cert type
    if(S_OK != CAGetCertTypeFlags(hCurCertType, &dwFlags))
        return FALSE;

    if(CT_FLAG_IS_SUBJECT_REQ & dwFlags)
        return FALSE;

    return  TRUE;
} */

//-----------------------------------------------------------------------
//
// GetCAProperties
//
//------------------------------------------------------------------------
BOOL    GetCAProperties(HCAINFO                 hCurCAInfo,
                        SCrdEnroll_CA_INFO      *pCAInfo)
{
    BOOL                fResult=FALSE;
    DWORD               errBefore= GetLastError();
    HRESULT             hr=S_OK;

    LPWSTR              *ppwszNameProp=NULL;
    LPWSTR              *ppwszLocationProp=NULL;
	LPWSTR				*ppwszDisplayNameProp=NULL;


    //get the CAName
    hr=CAGetCAProperty(
                hCurCAInfo,
                CA_PROP_NAME,
                &ppwszNameProp);

    if((S_OK != hr) || (NULL==ppwszNameProp))
    {
        if(!FAILED(hr))
            hr=E_FAIL;

        goto CertCliErr;
    }

    pCAInfo->pwszCAName=CopyWideString(ppwszNameProp[0]);

    if(NULL == pCAInfo->pwszCAName)
        goto MemoryErr;

	//get the CADisplayName
    hr=CAGetCAProperty(
                hCurCAInfo,
                CA_PROP_DISPLAY_NAME,
                &ppwszDisplayNameProp);

    if((S_OK != hr) || (NULL==ppwszDisplayNameProp))
    {
        if(!FAILED(hr))
            hr=E_FAIL;

        goto CertCliErr;
    }

    pCAInfo->pwszCADisplayName=CopyWideString(ppwszDisplayNameProp[0]);

    if(NULL == pCAInfo->pwszCADisplayName)
        goto MemoryErr;


    //get the CA location
    hr=CAGetCAProperty(
        hCurCAInfo,
        CA_PROP_DNSNAME,
        &ppwszLocationProp);

    if((S_OK != hr) || (NULL==ppwszLocationProp))
    {
        if(!FAILED(hr))
            hr=E_FAIL;

        goto CertCliErr;
    }

    //copy the name
    pCAInfo->pwszCALocation=CopyWideString(ppwszLocationProp[0]);

    if(NULL == pCAInfo->pwszCALocation)
        goto MemoryErr;

    fResult=TRUE;

CommonReturn:

    if(ppwszNameProp)
        CAFreeCAProperty(hCurCAInfo, ppwszNameProp);

    if(ppwszLocationProp)
        CAFreeCAProperty(hCurCAInfo, ppwszLocationProp);

	if(ppwszDisplayNameProp)
		CAFreeCAProperty(hCurCAInfo, ppwszDisplayNameProp);

    SetLastError(errBefore);

	return fResult;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    //in error case, free the memory and memset to 0
    if(pCAInfo)
        FreeCAInfoElement(pCAInfo);

	goto CommonReturn;

SET_ERROR(MemoryErr, E_OUTOFMEMORY);
SET_ERROR_VAR(CertCliErr, hr);
}

//-----------------------------------------------------------------------
//
// GetCAInfoFromCertType
//
//------------------------------------------------------------------------
BOOL    GetCAInfoFromCertType(HANDLE					hToken,
							  LPWSTR                    pwszCTName,
                              DWORD                     *pdwValidCA,
                              SCrdEnroll_CA_INFO        **prgCAInfo)
{

    BOOL                        fResult=FALSE;
    HRESULT                     hr=S_OK;
    DWORD                       errBefore= GetLastError();

    DWORD                       dwCACount=0;
    DWORD                       dwValidCA=0;
    SCrdEnroll_CA_INFO          *rgCAInfo=NULL;

    HCAINFO                     hCurCAInfo=NULL;
    HCAINFO                     hPreCAInfo=NULL;


    //init
    *pdwValidCA=0;
    *prgCAInfo=NULL;


    if(NULL == pwszCTName)
        goto InvalidArgErr;

    hr = CAFindByCertType(
        pwszCTName,
        NULL,
        0,
        &hCurCAInfo);

    if( hr!=S_OK || NULL==hCurCAInfo)
    {
        if(S_OK == hr)
            hr=E_FAIL;

        goto CertCliErr;
    }

    //get the CA count
    dwCACount=CACountCAs(hCurCAInfo);

    if(0==dwCACount)
    {
        hr=E_FAIL;
        goto CertCliErr;

    }

    //allocate memory
    rgCAInfo=(SCrdEnroll_CA_INFO *)SCrdEnrollAlloc(dwCACount *
                sizeof(SCrdEnroll_CA_INFO));

    if(NULL == rgCAInfo)
        goto MemoryErr;

    memset(rgCAInfo, 0, dwCACount * sizeof(SCrdEnroll_CA_INFO));

    dwValidCA=0;

    while(hCurCAInfo)
    {

        //get the CA information
		if(TokenCheckCAPermission(hToken, hCurCAInfo))
		{
			if(GetCAProperties(hCurCAInfo, &(rgCAInfo[dwValidCA])))
			{
				//increment the count
				dwValidCA++;
			}
		}

        //enum for the CA
        hPreCAInfo=hCurCAInfo;

        hr=CAEnumNextCA(
                hPreCAInfo,
                &hCurCAInfo);

        //free the old CA Info
        CACloseCA(hPreCAInfo);
        hPreCAInfo=NULL;

        if((S_OK != hr) || (NULL==hCurCAInfo))
            break;
    }

    if( (0 == dwValidCA) || (NULL == rgCAInfo))
    {
        hr=E_FAIL;
        goto CertCliErr;
    }

    //copy the output data
    *pdwValidCA=dwValidCA;
    *prgCAInfo=rgCAInfo;

    fResult=TRUE;

CommonReturn:

    if(hPreCAInfo)
        CACloseCA(hPreCAInfo);

    if(hCurCAInfo)
        CACloseCA(hCurCAInfo);

    SetLastError(errBefore);

	return fResult;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    if(rgCAInfo)
        FreeCAInfo(dwValidCA, rgCAInfo);

    //NULL the output
    *pdwValidCA=0;
    *prgCAInfo=NULL;

	goto CommonReturn;

SET_ERROR(MemoryErr, E_OUTOFMEMORY);
SET_ERROR_VAR(CertCliErr, hr);
SET_ERROR(InvalidArgErr, E_INVALIDARG);

}

//-----------------------------------------------------------------------
//
// InitializeCTList
//
//------------------------------------------------------------------------
BOOL    InitializeCTList(DWORD  *pdwCTIndex,
                         DWORD  *pdwCTCount,
                         SCrdEnroll_CT_INFO **prgCTInfo)
{

    BOOL                        fResult=FALSE;
    HRESULT                     hr=S_OK;
    DWORD                       errBefore= GetLastError();

    HCERTTYPE                   hCurCertType=NULL;
    HCERTTYPE                   hPreCertType=NULL;
    DWORD                       dwCertTypeCount=0;
    DWORD                       dwIndex=0;

    DWORD                       dwValidCertType=0;
    SCrdEnroll_CT_INFO *        rgCTInfo=NULL;

	HANDLE						hThread=NULL;	//no need to close
	HANDLE						hToken=NULL;



    *pdwCTIndex=0;
    *pdwCTCount=0;
    *prgCTInfo=NULL;

	//first of all, we need to revert to ourselves if we are under impersonation
	hThread=GetCurrentThread();
	
	if(NULL != hThread)
	{
		if(OpenThreadToken(hThread,
							TOKEN_IMPERSONATE | TOKEN_QUERY,
							FALSE,
							&hToken))
		{
			if(hToken)
			{
				//no need to check for return here.  If this failed, just go on
				RevertToSelf();
			}
		}
	}

    //get the 1st CT, including both machine and user cert types
    hr=CAEnumCertTypes(CT_ENUM_USER_TYPES | CT_ENUM_MACHINE_TYPES, &hCurCertType);

    if((S_OK != hr) || (NULL==hCurCertType))
    {
        if(S_OK != hr)
            hr=E_FAIL;

        goto CertCliErr;
    }

    //get the count of the cert types supported by this CA
    dwCertTypeCount=CACountCertTypes(hCurCertType);

    if(0==dwCertTypeCount)
    {
        hr=E_FAIL;

        goto CertCliErr;
    }

    //allocate memory
    rgCTInfo=(SCrdEnroll_CT_INFO *)SCrdEnrollAlloc(dwCertTypeCount *
                sizeof(SCrdEnroll_CT_INFO));

    if(NULL == rgCTInfo)
        goto MemoryErr;

    memset(rgCTInfo, 0, dwCertTypeCount * sizeof(SCrdEnroll_CT_INFO));

    dwValidCertType = 0;


    while(hCurCertType)
    {

        if(TokenCheckAccessPermission(hToken, hCurCertType) &&
           GetCertTypeProperties(hCurCertType, &(rgCTInfo[dwValidCertType]))
          )
        {
            dwValidCertType++;
        }

        //enum for the next cert types
        hPreCertType=hCurCertType;

        hr=CAEnumNextCertType(
                hPreCertType,
                &hCurCertType);

        //free the old cert type
        CACloseCertType(hPreCertType);
        hPreCertType=NULL;

        if((S_OK != hr) || (NULL==hCurCertType))
            break;
    }

    //now that we have find all the cert types, we need to find one cert
    //that has the associated CA information

    //if hToken, we are running as the certserv's ASP pages.  We need to retrieve all the 
    // CA's information since we are in the revert to self mode.
    if(NULL == hToken)
    {
	for(dwIndex=0; dwIndex < dwValidCertType; dwIndex++)
	{
	    //we do not consider the machine cert types
	    if(TRUE == rgCTInfo[dwIndex].fMachine)
		continue;
	    
	    //mark that we have queried the CA information of the
	    //certType
	    rgCTInfo[dwIndex].fCAInfo=TRUE;
	    
	    if(GetCAInfoFromCertType(NULL,
				     rgCTInfo[dwIndex].pwszCTName,
				     &(rgCTInfo[dwIndex].dwCACount),
				     &(rgCTInfo[dwIndex].rgCAInfo)))
		break;
	}
	
	if(dwIndex == dwValidCertType)
	{
	    hr=E_FAIL;
	    goto CertCliErr;
	}
    }
    else
    {
	for(dwIndex=0; dwIndex < dwValidCertType; dwIndex++)
	{
	    //mark that we have queried the CA information of the
	    //certType
	    rgCTInfo[dwIndex].fCAInfo=TRUE;
	    
	    GetCAInfoFromCertType( hToken,
				   rgCTInfo[dwIndex].pwszCTName,
				   &(rgCTInfo[dwIndex].dwCACount),
				   &(rgCTInfo[dwIndex].rgCAInfo));
	}
    }


    if((0 == dwValidCertType) || (NULL == rgCTInfo))
    {
        hr=E_FAIL;
        goto CertCliErr;
    }

    *pdwCTIndex=dwIndex;
    *pdwCTCount=dwValidCertType;
    *prgCTInfo=rgCTInfo;

    fResult=TRUE;

CommonReturn:

    if(hPreCertType)
        CACloseCertType(hPreCertType);

    if(hCurCertType)
        CACloseCertType(hCurCertType);

	//if hToken is valid, we reverted to ourselves.
	if(hToken)
	{
		SetThreadToken(&hThread, hToken);
		CloseHandle(hToken); 
	}

    SetLastError(errBefore);

	return fResult;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    //free all the memory
    if(rgCTInfo)
        FreeCTInfo(dwValidCertType, rgCTInfo);

    //NULL the output
    *pdwCTIndex=0;
    *pdwCTCount=0;
    *prgCTInfo=NULL;


	goto CommonReturn;

SET_ERROR(MemoryErr, E_OUTOFMEMORY);
SET_ERROR_VAR(CertCliErr, hr);
}


//-----------------------------------------------------------------------
//
// RetrieveCAName
//
//------------------------------------------------------------------------
BOOL	RetrieveCAName(DWORD					dwFlags, 
					   SCrdEnroll_CA_INFO		*pCAInfo, 
					   LPWSTR					*ppwszName)
{
	DWORD	dwSize = 0;
	BOOL	fResult=FALSE;

	if(NULL == ppwszName)
		goto InvalidArgErr;

	if(dwFlags == SCARD_ENROLL_CA_MACHINE_NAME)
		*ppwszName = CopyWideString(pCAInfo->pwszCALocation);
	else
	{
		if(dwFlags == SCARD_ENROLL_CA_DISPLAY_NAME)
			*ppwszName = CopyWideString(pCAInfo->pwszCADisplayName);
		else
		{
			if(dwFlags == SCARD_ENROLL_CA_UNIQUE_NAME)
			{
				dwSize = wcslen(pCAInfo->pwszCALocation) + wcslen(pCAInfo->pwszCADisplayName) + wcslen(L"\\") + 2;

				*ppwszName = (LPWSTR)SCrdEnrollAlloc(sizeof(WCHAR) * dwSize);
				if(NULL == (*ppwszName))
					goto MemoryErr;

				wcscpy(*ppwszName, pCAInfo->pwszCALocation);
				wcscat(*ppwszName, L"\\");
				wcscat(*ppwszName, pCAInfo->pwszCADisplayName);
			}
			else
				*ppwszName = CopyWideString(pCAInfo->pwszCAName);

		}
	}

	if(NULL == (*ppwszName))
		goto MemoryErr;

    fResult=TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;

	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\scrdenrl\scrdenr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       scrdenr.h
//
//--------------------------------------------------------------------------

// SCrdEnr.h : Declaration of the CSCrdEnr

#ifndef __SCRDENR_H_
#define __SCRDENR_H_

#include <certca.h>
#include "xenroll.h"
#include "resource.h"       // main symbols
#include "objsel.h"


/////////////////////////////////////////////////////////////////////////////
// SCrdEnroll_CSP_INFO
typedef struct  _SCrdEnroll_CSP_INFO
{
    DWORD   dwCSPType;
    LPWSTR  pwszCSPName;
}SCrdEnroll_CSP_INFO, *PSCrdEnroll_CSP_INFO;


/////////////////////////////////////////////////////////////////////////////
// SCrdEnroll_CA_INFO
typedef struct  _SCrdEnroll_CA_INFO
{
    LPWSTR              pwszCAName;
    LPWSTR              pwszCALocation;
	LPWSTR				pwszCADisplayName;
}SCrdEnroll_CA_INFO, *PSCrdEnroll_CA_INFO;


/////////////////////////////////////////////////////////////////////////////
// SCrdEnroll_CT_INFO
typedef struct  _SCrdEnroll_CT_INFO
{
    LPWSTR              pwszCTName;
    LPWSTR              pwszCTDisplayName;
    PCERT_EXTENSIONS    pCertTypeExtensions;
    DWORD               dwKeySpec;
    DWORD               dwGenKeyFlags; 
    DWORD               dwRASignature; 
    BOOL                fCAInfo;
    DWORD               dwCAIndex;
    DWORD               dwCACount;
    SCrdEnroll_CA_INFO  *rgCAInfo;
    BOOL                fMachine;
    DWORD               dwEnrollmentFlags;
    DWORD               dwSubjectNameFlags;
    DWORD               dwPrivateKeyFlags;
    DWORD               dwGeneralFlags; 
    LPWSTR             *rgpwszSupportedCSPs;
    DWORD               dwCurrentCSP;
} SCrdEnroll_CT_INFO, *PSCrdEnroll_CT_INFO;


////////////////////////////////////////////////////////////////////////
// 
// Prototypes for functions loaded at runtime. 
//
////////////////////////////////////////////////////////////////////////
HRESULT WINAPI MyCAGetCertTypeFlagsEx
(IN  HCERTTYPE           hCertType,
 IN  DWORD               dwOption,
 OUT DWORD *             pdwFlags);

HRESULT WINAPI MyCAGetCertTypePropertyEx
(IN  HCERTTYPE   hCertType,
 IN  LPCWSTR     wszPropertyName,
 OUT LPVOID      pPropertyValue);

IEnroll4 * WINAPI MyPIEnroll4GetNoCOM();

void InitializeThunks(); 

/////////////////////////////////////////////////////////////////////////////
// CSCrdEnr
class ATL_NO_VTABLE CSCrdEnr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSCrdEnr, &CLSID_SCrdEnr>,
	public IDispatchImpl<ISCrdEnr, &IID_ISCrdEnr, &LIBID_SCRDENRLLib>
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_SCRDENR)

BEGIN_COM_MAP(CSCrdEnr)
	COM_INTERFACE_ENTRY(ISCrdEnr)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ISCrdEnr
public:

    CSCrdEnr();

    virtual ~CSCrdEnr();


    STDMETHOD(getCertTemplateCount)
        (/* [in] */                   DWORD dwFlags, 
         /* [retval][out] */          long *pdwCertTemplateCount);


    STDMETHOD(setCertTemplateName)
	(/* [in] */                   DWORD dwFlags, 
	 /* [in] */                   BSTR bstrCertTemplateName);

    STDMETHOD(getCertTemplateName)
	(/* [in] */                   DWORD dwFlags, 
	 /* [retval][out] */          BSTR *pbstrCertTemplateName);


    STDMETHOD(enumCSPName)
	(/* [in] */                    DWORD dwIndex, 
	 /* [in] */                    DWORD dwFlags, 
	 /* [retval][out] */           BSTR *pbstrCSPName);

    STDMETHOD(enumCertTemplateName)
	(/* [in] */                    DWORD dwIndex, 
	 /* [in] */                    DWORD dwFlags, 
	 /* [retval][out] */           BSTR *pbstrCertTemplateName);


    STDMETHOD(getCertTemplateInfo)
	(/* [in] */                   BSTR     bstrCertTemplateName, 
	 /* [in] */                   LONG     lType,
     /* [retval][out] */          VARIANT *pvarCertTemplateInfo);


    STDMETHOD(setUserName)
	(/* [in] */                    DWORD dwFlags, 
	 /* [in] */                    BSTR bstrUserName);


    STDMETHOD(getUserName)
	(/* [in] */                    DWORD dwFlags, 
	 /* [retval][out] */           BSTR *pbstrUserName);

    STDMETHOD(getCACount)
	(/* [in] */                    BSTR bstrCertTemplateName, 
	 /* [retval][out] */           long *pdwCACount);

    STDMETHOD(setCAName)
	(/* [in] */                    DWORD dwFlags,
	 /* [in] */                    BSTR bstrCertTemplateName, 
	 /* [in] */                    BSTR bstrCAName);

    STDMETHOD(getCAName)
	(/* [in] */                    DWORD dwFlags,
	 /* [in] */                    BSTR bstrCertTemplateName, 
	 /* [retval][out] */           BSTR *pbstrCAName);

    STDMETHOD(enumCAName)
	(/* [in] */                    DWORD dwIndex, 
	 /* [in] */                    DWORD dwFlags, 
	 /* [in] */                    BSTR bstrCertTemplateName, 
	 /* [retval][out] */           BSTR *pbstrCAName);

    STDMETHOD(resetUser)();

    STDMETHOD(selectSigningCertificate)
        (/* [in] */                   DWORD     dwFlags,
         /* [in] */                   BSTR      bstrCertTemplateName);

    STDMETHOD(setSigningCertificate)
        (/* [in] */                   DWORD     dwFlags, 
         /* [in] */                   BSTR      bstrCertTemplateName);

    STDMETHOD(getSigningCertificateName)
        (/* [in] */                   DWORD     dwFlags, 
         /* [retval][out] */          BSTR      *pbstrSigningCertName);

    STDMETHOD(getEnrolledCertificateName)
        (/*[in]  */                   DWORD     dwFlags,
	 /* [retval][out] */           BSTR      *pBstrCertName);

    STDMETHOD(enroll)
        (/* [in] */                 DWORD   dwFlags);

    STDMETHOD(selectUserName)
        (/* [in] */                 DWORD   dwFlags);

    STDMETHOD(get_CSPName)
        (/*[out, retval]*/ BSTR *pVal);

    STDMETHOD(put_CSPName)
        (/*[in]*/ BSTR newVal);

    STDMETHOD(get_CSPCount)
        (/*[out, retval]*/ long *pVal);

    STDMETHOD(get_EnrollmentStatus)
      (/*[retval][out] */ LONG * plEnrollmentStatus); 


 private:
    HRESULT GetCAExchangeCertificate(IN BSTR bstrCAQualifiedName, PCCERT_CONTEXT *ppCert); 
    HRESULT _getCertTemplateExtensionInfo(
        IN CERT_EXTENSIONS  *pCertTypeExtensions,
        IN LONG              lType,
        OUT VOID            *pExtInfo);
    HRESULT _getStrCertTemplateCSPList(
        IN DWORD             dwIndex,
        IN DWORD             dwFlag,
        OUT WCHAR          **ppwszSupportedCSP);
    
    HRESULT CertTemplateCountOrName(
	    IN  DWORD dwIndex, 
	    IN  DWORD dwFlags, 
        OUT long *pdwCertTemplateCount,
	    OUT BSTR *pbstrCertTemplateName);

     DWORD                   m_dwCTCount;
    DWORD                   m_dwCTIndex;
    SCrdEnroll_CT_INFO      *m_rgCTInfo;
    DWORD                   m_dwCSPCount;
    DWORD                   m_dwCSPIndex;
    SCrdEnroll_CSP_INFO     *m_rgCSPInfo;
    LPWSTR                  m_pwszUserUPN;              //the UPN name of the user
    LPWSTR                  m_pwszUserSAM;              //the SAM name of the user
    PCCERT_CONTEXT          m_pSigningCert;
    PCCERT_CONTEXT          m_pEnrolledCert;
    CRITICAL_SECTION	    m_cSection;
    BOOL                    m_fInitializedCriticalSection;  // true if m_cSection is initialized, otherwise false
    BOOL                    m_fInitialize;
    LONG                    m_lEnrollmentStatus;
    BOOL                    m_fSCardSigningCert;        //whether the signing certificate is on a smart card
    LPSTR                   m_pszCSPNameSigningCert;    //the CSP name of the signing certificate
    DWORD                   m_dwCSPTypeSigningCert;     //the CSP type of the signing certificate
    LPSTR                   m_pszContainerSigningCert;  //the container name of the signing certificate 
    IDsObjectPicker        *m_pDsObjectPicker;         //pointer to the object selection dialogue
    CERT_EXTENSIONS        *m_pCachedCTEs;  //point to cert extensions
    WCHAR                  *m_pwszCachedCTEOid;
    CERT_TEMPLATE_EXT      *m_pCachedCTE;
};

#endif //__SCRDENR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\scrdenrl\scrdenrl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       scrdenrl.cpp
//
//--------------------------------------------------------------------------

// scrdenrl.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To merge the proxy/stub code into the object DLL, add the file 
//		dlldatax.c to the project.  Make sure precompiled headers 
//		are turned off for this file, and add _MERGE_PROXYSTUB to the 
//		defines for the project.  
//
//		If you are not running WinNT4.0 or Win95 with DCOM, then you
//		need to remove the following define from dlldatax.c
//		#define _WIN32_WINNT 0x0400
//
//		Further, if you are running MIDL without /Oicf switch, you also 
//		need to remove the following define from dlldatax.c.
//		#define USE_STUBLESS_PROXY
//
//		Modify the custom build rule for scrdenrl.idl by adding the following 
//		files to the Outputs.
//			scrdenrl_p.c
//			dlldata.c
//		To build a separate proxy/stub DLL, 
//		run nmake -f scrdenrlps.mk in the project directory.

#include <stdafx.h>
#include <comcat.h>
#include <objsafe.h>
#include "resource.h"
#include "initguid.h"
#include "scrdenrl.h"



#include "SCrdEnr.h"

/*#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif*/

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_SCrdEnr, CSCrdEnr)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	lpReserved;
/*#ifdef _MERGE_PROXYSTUB
	if (!PrxDllMain(hInstance, dwReason, lpReserved))
		return FALSE;
#endif  */
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
/*#ifdef _MERGE_PROXYSTUB
	if (PrxDllCanUnloadNow() != S_OK)
		return S_FALSE;
#endif */
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
/*#ifdef _MERGE_PROXYSTUB
	if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
		return S_OK;
#endif */
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
/*#ifdef _MERGE_PROXYSTUB
	HRESULT hRes = PrxDllRegisterServer();
	if (FAILED(hRes))
		return hRes;
#endif*/

    HRESULT hRes=S_OK;
    BOOL    fInitialize=FALSE;

    hRes= _Module.RegisterServer(TRUE);

    if(!FAILED(CoInitialize(NULL)))
        fInitialize=TRUE;

    if(fInitialize)
        CoUninitialize();  

    return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
/*#ifdef _MERGE_PROXYSTUB
	PrxDllUnregisterServer();
#endif  */

    BOOL    fInitialize=FALSE;

    if(!FAILED(CoInitialize(NULL)))
        fInitialize=TRUE;

    if(fInitialize)
        CoUninitialize();  

    _Module.UnregisterServer();
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\scrdenrl\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\scrdenrl\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__80CB787B_20DE_11D2_8D5C_00C04FC29D45__INCLUDED_)
#define AFX_STDAFX_H__80CB787B_20DE_11D2_8D5C_00C04FC29D45__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


//#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__80CB787B_20DE_11D2_8D5C_00C04FC29D45__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xaddroot\instres.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       instres.h
//
//--------------------------------------------------------------------------
#define IDS_PROJNAME                    7000
#define IDS_LEGALDISCLAIMER             7005
#define IDR_CADDROOT			        7006
#define IDR_CDELROOT			        7007
#define IDS_INSTALLCA			        7008
#define IDS_JUST_SAY_YES		        7009
#define IDS_TOO_MANY_CA_CERTS		    7010
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\scrdenrl\thunks.cpp ===
#include <windows.h>
#include <certca.h>
#include "xenroll.h"

typedef HRESULT (WINAPI * PFNCAGetCertTypeFlagsEx) 
    (IN  HCERTTYPE           hCertType,
     IN  DWORD               dwOption,
     OUT DWORD *             pdwFlags);

typedef HRESULT (WINAPI * PFNCAGetCertTypePropertyEx) 
    (IN  HCERTTYPE   hCertType,
     IN  LPCWSTR     wszPropertyName,
     OUT LPVOID      pPropertyValue);

typedef IEnroll4 * (WINAPI * PFNPIEnroll4GetNoCOM)(); 

PFNCAGetCertTypeFlagsEx     g_pfnCAGetCertTypeFlagsEx     = NULL; 
PFNCAGetCertTypePropertyEx  g_pfnCAGetCertTypePropertyEx  = NULL; 
PFNPIEnroll4GetNoCOM        g_pfnPIEnroll4GetNoCOM        = NULL; 

//////////////////////////////////////////////////////////////////////
//
// Initializes the thunked procedures.  Should be called before calling
// any other function in this file. 
//
//////////////////////////////////////////////////////////////////////
void InitializeThunks() 
{ 
    HINSTANCE hCertCliDll = NULL; 
    HINSTANCE hXenroll   = NULL; 

    hCertCliDll = LoadLibraryW(L"certcli.dll"); 
    if (NULL != hCertCliDll) {
        g_pfnCAGetCertTypeFlagsEx     = (PFNCAGetCertTypeFlagsEx)GetProcAddress(hCertCliDll, "CAGetCertTypeFlagsEx"); 
        g_pfnCAGetCertTypePropertyEx  = (PFNCAGetCertTypePropertyEx)GetProcAddress(hCertCliDll, "CAGetCertTypePropertyEx"); 
    }
     
    hXenroll = LoadLibraryW(L"xenroll.dll"); 
    if (NULL != hXenroll) { 
        g_pfnPIEnroll4GetNoCOM  = (PFNPIEnroll4GetNoCOM)GetProcAddress(hXenroll, "PIEnroll4GetNoCOM"); 
    }
}

HRESULT WINAPI MyCAGetCertTypeFlagsEx
(IN  HCERTTYPE           hCertType,
 IN  DWORD               dwOption,
 OUT DWORD *             pdwFlags)
{
    if (NULL != g_pfnCAGetCertTypeFlagsEx) { 
        return g_pfnCAGetCertTypeFlagsEx(hCertType, dwOption, pdwFlags); 
    } else { 
        return HRESULT_FROM_WIN32(ERROR_CALL_NOT_IMPLEMENTED); 
    }
}

HRESULT WINAPI MyCAGetCertTypePropertyEx
(IN  HCERTTYPE   hCertType,
 IN  LPCWSTR     wszPropertyName,
 OUT LPVOID      pPropertyValue)
{
    if (NULL != g_pfnCAGetCertTypePropertyEx) { 
        return g_pfnCAGetCertTypePropertyEx(hCertType, wszPropertyName, pPropertyValue); 
    } else { 
        return HRESULT_FROM_WIN32(ERROR_CALL_NOT_IMPLEMENTED); 
    }
}

IEnroll4 * WINAPI MyPIEnroll4GetNoCOM()
{
    if (NULL != g_pfnPIEnroll4GetNoCOM) { 
        return g_pfnPIEnroll4GetNoCOM(); 
    } else { 
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED); 
        return NULL; 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xaddroot\cobjsaf.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cobjsaf.cpp
//
//--------------------------------------------------------------------------


#include "cobjsaf.h"

// This class provides a simple implementation for IObjectSafety for
// for object that are either always safe or always unsafe for scripting
// and/or initializing with persistent data.
//
// The constructor takes an IUnknown interface on an outer object and delegates
// all IUnknown calls through that object.  Because of this, the object must
// be explicitly destroyed using C++ (rather than COM) mechanisms, either by
// using "delete" or by making the object an embedded member of some other class.
//
// The constructor also takes two booleans telling whether the object is safe
// for scripting and initializing from persistent data.

#if 0
// Return the interface setting options on this object
STDMETHODIMP CObjectSafety::GetInterfaceSafetyOptions(
    /*IN */  REFIID iid,                    // Interface that we want options for
    /*OUT*/ DWORD   *   pdwSupportedOptions,    // Options meaningful on this interface
    /*OUT*/ DWORD * pdwEnabledOptions)      // current option values on this interface
{
    *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER || INTERFACESAFE_FOR_UNTRUSTED_DATA;
    if (iid==IID_IDispatch)
    {
        *pdwEnabledOptions = m_fSafeForScripting ?
            INTERFACESAFE_FOR_UNTRUSTED_CALLER :
            0;
        return S_OK;
    }
    else if (iid==IID_IPersistStorage || iid==IID_IPersistStream)
    {
        *pdwEnabledOptions = m_fSafeForInitializing ?
            INTERFACESAFE_FOR_UNTRUSTED_DATA :
            0;
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

// Attempt to set the interface setting options on this object.
// Since these are assumed to be fixed, we basically just check
// that the attempted settings are valid.
STDMETHODIMP CObjectSafety::SetInterfaceSafetyOptions(
    /*IN */  REFIID iid,                    // Interface to set options for
    /*IN */  DWORD      dwOptionsSetMask,       // Options to change
    /*IN */  DWORD      dwEnabledOptions)       // New option values

{
    // If they haven't asked for anything, we can certainly provide that
    if ((dwOptionsSetMask & dwEnabledOptions) == 0)
        return S_OK;

    if (iid==IID_IDispatch)
    {
        // Make sure they haven't asked for an option we don't support
        if ((dwEnabledOptions & dwOptionsSetMask) != INTERFACESAFE_FOR_UNTRUSTED_CALLER)
            return E_FAIL;

        return m_fSafeForScripting ? S_OK : E_FAIL;
    }
    else if (iid==IID_IPersistStorage || iid==IID_IPersistStream)
    {
        if ((dwEnabledOptions & dwOptionsSetMask) != INTERFACESAFE_FOR_UNTRUSTED_DATA)
            return E_FAIL;
        return m_fSafeForInitializing ? S_OK : E_FAIL;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

// Helper function to create a component category and associated description
HRESULT CreateComponentCategory(CATID catid, WCHAR* catDescription)
    {

    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;

    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
            NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (FAILED(hr))
        return hr;

    // Make sure the HKCR\Component Categories\{..catid...}
    // key is registered
    CATEGORYINFO catinfo;
    catinfo.catid = catid;
    catinfo.lcid = 0x0409 ; // english

    // Make sure the provided description is not too long.
    // Only copy the first 127 characters if it is
    int len = wcslen(catDescription);
    if (len>127)
        len = 127;
    wcsncpy(catinfo.szDescription, catDescription, len);
    // Make sure the description is null terminated
    catinfo.szDescription[len] = '\0';

    hr = pcr->RegisterCategories(1, &catinfo);
    pcr->Release();

    return hr;
    }

#endif


// Helper function to register a CLSID as belonging to a component category
HRESULT RegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
    {
// Register your component categories information.
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
            NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Register this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->RegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();

    return hr;
    }

// Helper function to unregister a CLSID as belonging to a component category
HRESULT UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
    {
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
            NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Unregister this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->UnRegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();

    return hr;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xaddroot\caddroot.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:	caddroot.cpp
//
//--------------------------------------------------------------------------

// caddroot.cpp : Implementation of Ccaddroot

#include "stdafx.h"
#include "cobjsaf.h"
#include "Xaddroot.h"
#include "caddroot.h"
#include "rootlist.h"
#include "assert.h"

#include "wincrypt.h"
#include "unicode.h"
#include "ui.h"

BOOL FAnyCertUpdates(HCERTSTORE hStore, HCERTSTORE hStoreCertsToCheck) {

    BOOL            fSomeNotInStore = FALSE;
    PCCERT_CONTEXT  pCertContext    = NULL;
    PCCERT_CONTEXT  pCertTemp       = NULL;
    BYTE            arHashBytes[20];
    CRYPT_HASH_BLOB blobHash        = {sizeof(arHashBytes), arHashBytes};

    while(NULL != (pCertContext = CertEnumCertificatesInStore(hStoreCertsToCheck, pCertContext))) {

        if( CryptHashCertificate(
            NULL,
            0,
            X509_ASN_ENCODING,
            pCertContext->pbCertEncoded,
            pCertContext->cbCertEncoded,
            blobHash.pbData,
            &blobHash.cbData) ) {

            pCertTemp = CertFindCertificateInStore(
                    hStore,
                    X509_ASN_ENCODING,
                    0,
                    CERT_FIND_HASH,
                    &blobHash,
                    NULL);

            fSomeNotInStore = (fSomeNotInStore || (pCertTemp == NULL));

            if(pCertTemp != NULL)
                CertFreeCertificateContext(pCertTemp);

        }
    }

    return(fSomeNotInStore);
}

BOOL MyCryptInstallSignedListOfTrustedRoots(
    DWORD       dwMsgAndCertEncodeingType,
    LPCWSTR     wszCTL,
    DWORD       dwFlags,
    void *      pvReserved
    ) {

    BOOL            fIsProtected        = TRUE;
    BOOL            fRet                = TRUE;
    DWORD           cb                  = 0;
    BYTE *          pb                  = NULL;
    BOOL            fRemoveRoots        = FALSE;
    HCERTSTORE      hStore              = NULL;
    HCERTSTORE      hStoreRoot          = NULL;
    PCCERT_CONTEXT  pCertContext        = NULL;
    PCCERT_CONTEXT  pCertContextInStore = NULL;
    PCCERT_CONTEXT  pCertContextSigner  = NULL;
    HINSTANCE       hCryptUI            = NULL;
    INT_PTR         iDlgRet             = 0;
    HKEY            hKeyStores          = NULL;
    DWORD           err;
    DWORD           dwVer               = 0;
    CRYPT_DATA_BLOB dataBlob            = {0, NULL};
    MDI             mdi;
    WCHAR           wrgInstallCA[MAX_MSG_LEN];
    WCHAR           wrgJustSayYes[MAX_MSG_LEN];

    BYTE            arHashBytes[20];
    CRYPT_HASH_BLOB blobHash                = {sizeof(arHashBytes), arHashBytes};

    BOOL fAnyCertUpdates;

     if(NULL == (pb = HTTPGet(wszCTL, &cb)))
        goto ErrorReturn;

    // get the certs to add or delete
    if(!I_CertVerifySignedListOfTrustedRoots(
        pb,
        cb,
        &fRemoveRoots,  
        &hStore,
        &pCertContextSigner
        ))
        goto ErrorReturn;

    if(fRemoveRoots) {
        SetLastError(E_NOTIMPL);
        goto ErrorReturn;
    }

    dwVer = GetVersion();

    // see if this is NT5 or higher
    if((dwVer < 0x80000000) && ((dwVer & 0xFF) >= 5)) {

        if(NULL == (hStoreRoot = CertOpenStore(
                  CERT_STORE_PROV_SYSTEM,
                  X509_ASN_ENCODING,
                  NULL,
                  CERT_SYSTEM_STORE_CURRENT_USER | CERT_STORE_MAXIMUM_ALLOWED_FLAG,
                  L"Root" 
                  )) ) 
            goto ErrorReturn;

    // else it is before NT5 or Win9x and does not have a protected store.
    } else {

        if(ERROR_SUCCESS != (err = RegOpenKeyA(
            HKEY_CURRENT_USER,
            "Software\\Microsoft\\SystemCertificates\\Root",
            &hKeyStores
            ))) {
            SetLastError(err);
            hKeyStores = NULL;
            goto ErrorReturn;
        }
            
        // open the root store
        // must be current user
        if( NULL == (hStoreRoot = CertOpenStore(
                  CERT_STORE_PROV_REG,
                  X509_ASN_ENCODING,
                  NULL,
                  CERT_SYSTEM_STORE_CURRENT_USER,
                  (void *) hKeyStores 
                  )) )
            goto ErrorReturn;

        fIsProtected = FALSE;            
    }


    // prepare the data for the dialog
    memset(&mdi, 0, sizeof(mdi));
    if( NULL != (hCryptUI = LoadLibraryA("cryptui.dll")) )
        mdi.pfnCryptUIDlgViewCertificateW = (PFNCryptUIDlgViewCertificateW)
                            GetProcAddress(hCryptUI, "CryptUIDlgViewCertificateW");
    mdi.hStore = hStore;
    mdi.pCertSigner = pCertContextSigner;
    mdi.hInstance = _Module.GetResourceInstance();

    fAnyCertUpdates = FAnyCertUpdates(hStoreRoot, hStore);
    if (fAnyCertUpdates) {
      // put the dialog up
      iDlgRet = DialogBoxParam(
        _Module.GetResourceInstance(),  
        (LPSTR) MAKEINTRESOURCE(IDD_MAINDLG),
        NULL,      
        MainDialogProc,
        (LPARAM) &mdi);
    }
    else
    {
       iDlgRet = IDYES;
    }

   
    if(hCryptUI != NULL)
        FreeLibrary(hCryptUI);
    hCryptUI = NULL;

    // only take it if the user said OK
    if(iDlgRet != IDYES)
        goto ErrorReturn;

    // throw UI if we are on a protected system
    if(fIsProtected && fAnyCertUpdates) {
    
        // put up the Just Say Yes to install the CA dialog
        LoadStringU(_Module.GetResourceInstance(), IDS_INSTALLCA, wrgInstallCA, sizeof(wrgInstallCA)/sizeof(WCHAR));
        LoadStringU(_Module.GetResourceInstance(), IDS_JUST_SAY_YES, wrgJustSayYes, sizeof(wrgJustSayYes)/sizeof(WCHAR));
        MessageBoxU(NULL, wrgJustSayYes, wrgInstallCA, MB_OK);
    }
 
    while(NULL != (pCertContext = CertEnumCertificatesInStore(hStore, pCertContext))) {

        // add the cert to the store
        assert(pCertContextInStore == NULL);
        CertAddCertificateContextToStore(
            hStoreRoot,
            pCertContext,
            CERT_STORE_ADD_USE_EXISTING,
            &pCertContextInStore
            );

        // move the EKU property in case the cert already existed
        if(pCertContextInStore != NULL) {

            assert(dataBlob.cbData == 0);

            // Attempt to delete the old EKU, if we succeed we will put
            // the new EKU on it, otherwise if we fail we know we don't
            // have access to HKLM and we should just add the cert to the HKCU
            if(!CertSetCertificateContextProperty(
                  pCertContextInStore,
                  CERT_ENHKEY_USAGE_PROP_ID,
                  0,
                  NULL
                  )) {

                // just add the cert, should go to HKCU, if it fails, what am I going
                // to do about it, just continue
                CertAddCertificateContextToStore(
                    hStoreRoot,
                    pCertContext,
                    CERT_STORE_ADD_ALWAYS,
                    NULL
                    );

                // at this point I know I have access to the cert and I know the
                // EKU have been removed, only add the EKU if the new one has some EKU's
            } else if( CertGetCertificateContextProperty(
                    pCertContext,
                    CERT_ENHKEY_USAGE_PROP_ID,
                    NULL, 
                    &dataBlob.cbData  
                    )                    
                &&
                (NULL != (dataBlob.pbData = (PBYTE) malloc(dataBlob.cbData)))
                &&
                CertGetCertificateContextProperty(
                    pCertContext,
                    CERT_ENHKEY_USAGE_PROP_ID,
                    dataBlob.pbData, 
                    &dataBlob.cbData  
                    )
                ) {

                // set EKU on the cert, what am I going to do if it fails, just continue
                CertSetCertificateContextProperty(
                    pCertContextInStore,
                    CERT_ENHKEY_USAGE_PROP_ID,
                    0,
                    &dataBlob
                    );
            }

            // free context and memory
            CertFreeCertificateContext(pCertContextInStore);
            pCertContextInStore = NULL;

            if(dataBlob.pbData != NULL)
                free(dataBlob.pbData);
            memset(&dataBlob, 0, sizeof(CRYPT_DATA_BLOB));
        }
    }

CommonReturn:    

    if(pCertContextSigner != NULL)
        CertFreeCertificateContext(pCertContextSigner);
        
    if(pCertContext != NULL)
        CertFreeCertificateContext(pCertContext);

    if(pCertContextInStore != NULL)
        CertFreeCertificateContext(pCertContextInStore);

    if(hStore != NULL) 
        CertCloseStore(hStore, CERT_CLOSE_STORE_FORCE_FLAG);  // clean up from dialog box dups

    if(hStoreRoot != NULL) 
        CertCloseStore(hStoreRoot, 0);

    if(hKeyStores != NULL)
        RegCloseKey(hKeyStores);
        
    if(pb != NULL)
        free(pb);

    return(fRet);

ErrorReturn: 

    fRet = FALSE;

    goto CommonReturn;

}    

HRESULT STDMETHODCALLTYPE Ccaddroot::AddRoots(BSTR wszCTL) {

    HRESULT                                 hr;
    DWORD                                   fRet                                        = TRUE;


        fRet =  MyCryptInstallSignedListOfTrustedRoots(
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            wszCTL,
            0,
            NULL);


    if(fRet)
        hr = S_OK;
    else
        hr = MY_HRESULT_FROM_WIN32(GetLastError());


    return hr;

}

BOOL MyCryptInstallIntermediateCAs(
    DWORD       dwMsgAndCertEncodeingType,
    LPCWSTR     wszX509,
    DWORD       dwFlags,
    void *      pvReserved
    ) {

    DWORD           cb              = 0;
    DWORD           cCerts          = 0;
    BYTE *          pb              = NULL;
    PCCERT_CONTEXT  pCertContext    = NULL;
    PCCERT_CONTEXT  pCertContextT   = NULL;
    HCERTSTORE      hStore          = NULL;
    BOOL            fOK             = FALSE;

    pb = HTTPGet(wszX509, &cb);

    if(pb != NULL) {

        pCertContext = CertCreateCertificateContext(
            X509_ASN_ENCODING,
            pb,
            cb
            );
 
        if(pCertContext != NULL) {

            hStore = CertOpenStore(
              CERT_STORE_PROV_SYSTEM,
              X509_ASN_ENCODING,
              NULL,
              CERT_SYSTEM_STORE_CURRENT_USER,
              L"CA" 
              );

            if(hStore != NULL) {

                // count the number of certs in the store
                cCerts = 0;
                while(NULL != (pCertContextT = CertEnumCertificatesInStore(hStore, pCertContextT)))
                    cCerts++;

                if(FIsTooManyCertsOK(cCerts, _Module.GetResourceInstance())) {

                    CertAddCertificateContextToStore(
                        hStore,
                        pCertContext,
                        CERT_STORE_ADD_USE_EXISTING,
                        NULL
                        );

                    CertCloseStore(hStore, 0);
                    fOK = TRUE;
                }
            }
 
            CertFreeCertificateContext(pCertContext);
        }
        free(pb);
    }

    return(fOK);
}

HRESULT STDMETHODCALLTYPE Ccaddroot::AddCA(BSTR wszX509) {

    HRESULT                                 hr;
    DWORD                                   fRet                                        = TRUE;

        fRet =  MyCryptInstallIntermediateCAs(
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            wszX509,
            0,
            NULL);

    if(fRet)
        hr = S_OK;
    else
        hr = MY_HRESULT_FROM_WIN32(GetLastError());


    return hr;
}

HRESULT __stdcall Ccaddroot::GetInterfaceSafetyOptions( 
            /* [in]  */ REFIID riid,
            /* [out] */ DWORD __RPC_FAR *pdwSupportedOptions,
            /* [out] */ DWORD __RPC_FAR *pdwEnabledOptions) {

    RPC_STATUS rpcStatus;          

    if(0 != UuidCompare((GUID *) &riid, (GUID *) &IID_IDispatch, &rpcStatus) )
        return(E_NOINTERFACE);

    *pdwEnabledOptions   = dwEnabledSafteyOptions;
    *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA;


    return(S_OK);
}


HRESULT __stdcall Ccaddroot::SetInterfaceSafetyOptions( 
            /* [in] */ REFIID riid,
            /* [in] */ DWORD dwOptionSetMask,
            /* [in] */ DWORD dwEnabledOptions) {

    RPC_STATUS rpcStatus;          
    DWORD dwSupport = 0;            

    if(0 != UuidCompare((GUID *) &riid, (GUID *) &IID_IDispatch, &rpcStatus) )
        return(E_NOINTERFACE);

    dwSupport = dwOptionSetMask & ~(INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA);        
    if(dwSupport != 0)
        return(E_FAIL);

    dwEnabledSafteyOptions &= ~dwOptionSetMask;
    dwEnabledSafteyOptions |= dwEnabledOptions; 
            
return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xaddroot\caddroot.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:	caddroot.h
//
//--------------------------------------------------------------------------

// caddroot.h : Declaration of the Ccaddroot

#ifndef __CADDROOT_H_
#define __CADDROOT_H_

#include "instres.h"       // main symbols
#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// Ccaddroot
class ATL_NO_VTABLE Ccaddroot : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<Ccaddroot, &CLSID_caddroot>,
	public IDispatchImpl<Icaddroot, &IID_Icaddroot, &LIBID_XADDROOTLib>,
	public IObjectSafety
{
public:
	Ccaddroot()
	{
	    dwEnabledSafteyOptions = 0;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_CADDROOT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(Ccaddroot)
	COM_INTERFACE_ENTRY(Icaddroot)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IObjectSafety)
END_COM_MAP()

// Icaddroot
public:

DWORD   dwEnabledSafteyOptions;

HRESULT virtual STDMETHODCALLTYPE AddRoots(BSTR wszCTL);

HRESULT virtual STDMETHODCALLTYPE AddCA(BSTR wszX509);


virtual HRESULT __stdcall Ccaddroot::GetInterfaceSafetyOptions( 
            /* [in]  */ REFIID riid,
            /* [out] */ DWORD __RPC_FAR *pdwSupportedOptions,
            /* [out] */ DWORD __RPC_FAR *pdwEnabledOptions);


virtual HRESULT __stdcall Ccaddroot::SetInterfaceSafetyOptions( 
            /* [in] */ REFIID riid,
            /* [in] */ DWORD dwOptionSetMask,
            /* [in] */ DWORD dwEnabledOptions);

};



BYTE * HTTPGet(const WCHAR * wszURL, DWORD * pcbReceiveBuff);

#endif //__CADDROOT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xaddroot\httpget.cpp ===
#include <windows.h>
#include <stdlib.h>
#include <assert.h> 
#include <memory.h>
#include <wininet.h>
#include "unicode.h"


BYTE * HTTPGet(const WCHAR * wszURL, DWORD * pcbReceiveBuff) {

    HINTERNET	hIOpen      = NULL;
	HINTERNET	hIConnect   = NULL;
	HINTERNET	hIHttp      = NULL;
    BYTE *      pbRecBuf    = NULL;
    char *	szPartURL	= NULL;
    char	szBuff[1024];
    char        szLong[16];
    char	szDomanName[_MAX_PATH];
    char	szPort[12];
    char *	pch;
    DWORD       cch;
    DWORD       dwService = INTERNET_SERVICE_HTTP;
    char *	pchT;
    DWORD       cbBuff, cbBuffRead, cbBuffT;
    DWORD	dwPort	= INTERNET_INVALID_PORT_NUMBER;
    char  *	szURL = NULL;


    assert(wszURL != NULL);
    assert(pcbReceiveBuff != NULL);

    *pcbReceiveBuff = 0;

    // figure out the protocol
    if( !MkMBStr(NULL, 0, wszURL, &szURL)) {
	SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto ErrorReturn;
    }

    //
    // DSIE: Fix bug 112117
    //
    if (NULL == szURL) {
        return NULL;
    }

    cch = strlen(szURL);
    if(cch >= 7  &&  _strnicmp(szURL, "http://", 7) == 0) {
        dwService = INTERNET_SERVICE_HTTP;
	pch = (char *) &szURL[7];

    } else if(cch >= 6	&&  _strnicmp(szURL, "ftp://", 6) == 0) {
        dwService = INTERNET_SERVICE_FTP ;
	pch = (char *) &szURL[6];
        
    } else {
        dwService = INTERNET_SERVICE_HTTP;
	pch = (char *) &szURL[0];
    }

    // if none of the above, assump http;
   
    // copy the Doman Name
    pchT = szDomanName;
    while(*pch != '/'  && *pch != ':' &&  *pch != 0)
        *pchT++ = *pch++;
    *pchT = 0;

    // parse out the port number
    szPort[0] = 0;
    if(*pch == ':') {
	pchT = szPort;
        pch++; // get past the :
	while(*pch != '/' && *pch != 0)
            *pchT++ = *pch++;
        *pchT = 0;
    }

    // Get port #, zero is INTERNET_INVALID_PORT_NUMBER
    if(szPort[0] != 0)
	dwPort = atol(szPort);
 
    // save away what to look up.
    if(NULL == (szPartURL = (char *) malloc(sizeof(char) * (strlen(pch) + 1)))) {
	SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto ErrorReturn;
        }

    strcpy(szPartURL, pch);

    //                        INTERNET_OPENLYPE_DIRECT,
    if( (hIOpen = InternetOpenA( "Transport",
                            INTERNET_OPEN_TYPE_PRECONFIG,
                            NULL,
                            NULL,
                            0)) == NULL                 ||

	(hIConnect = InternetConnectA(hIOpen,
				    szDomanName,
                                    (INTERNET_PORT) dwPort,
                                    NULL,
                                    NULL,
                                    dwService,
                                    0,
                                    0)) == NULL     ) {
        goto ErrorReturn;                                    
        }

    // If this is a GET, do a dummy send
    if( ((hIHttp = HttpOpenRequestA(hIConnect,
				    "GET",
				    szPartURL,
				    HTTP_VERSION,
                                    NULL,
                                    NULL,
                                    INTERNET_FLAG_DONT_CACHE,
                                    0)) == NULL     ||
	HttpSendRequestA(hIHttp, "Accept: */*\r\n", (DWORD) -1, NULL, 0) == FALSE) ) {
        goto ErrorReturn;
        }

    cbBuff = sizeof(szBuff);
    if(HttpQueryInfoA(	hIHttp,
                        HTTP_QUERY_CONTENT_TYPE,
			szBuff,
                        &cbBuff,
                        NULL) == FALSE)
        goto ErrorReturn;

    assert(cbBuff > 0);
 
    // now get the length of the buffer returned
    cbBuff = sizeof(szLong);
    if(HttpQueryInfo(   hIHttp,
                        HTTP_QUERY_CONTENT_LENGTH,
                        szLong,
                        &cbBuff,
                        NULL) == FALSE)
        goto ErrorReturn;

    assert(cbBuff > 0);
    // always appears to be in ascii
    cbBuff = atol(szLong);

    // allocate a buffer
    if( (pbRecBuf = (BYTE *) malloc(cbBuff)) == NULL ) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto ErrorReturn;
        }

    // read the data
    cbBuffRead = 0;
    while(cbBuffRead < cbBuff) {
        cbBuffT = 0;
        if(InternetReadFile(hIHttp, &pbRecBuf[cbBuffRead], (cbBuff - cbBuffRead), &cbBuffT)  == FALSE  ) 
            goto ErrorReturn;
         cbBuffRead += cbBuffT;
    }

    // close out the handle
    InternetCloseHandle(hIHttp);
    hIHttp = NULL;

    // pass back the info
    *pcbReceiveBuff = cbBuff;

CommonReturn:

    if(szPartURL != NULL)
	free(szPartURL);

    if(szURL != NULL)
	FreeMBStr(NULL, szURL);

    return(pbRecBuf);
    
ErrorReturn:

    if(pbRecBuf != NULL)
        free(pbRecBuf);
    pbRecBuf = NULL;

    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xaddroot\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xaddroot\cobjsaf.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cobjsaf.h
//
//--------------------------------------------------------------------------

#ifndef __COBJSAF_H
#define __COBJSAF_H

#include "objsafe.h"
#include "comcat.h"

// This class provides a simple implementation for IObjectSafety for
// for object that are either always safe or always unsafe for scripting
// and/or initializing with persistent data.
//
// The constructor takes an IUnknown interface on an outer object and delegates
// all IUnknown calls through that object.  Because of this, the object must
// be explicitly destroyed using C++ (rather than COM) mechanisms, either by
// using "delete" or by making the object an embedded member of some other class.
//
// The constructor also takes two booleans telling whether the object is safe
// for scripting and initializing from persistent data.

#if 0
class CObjectSafety : public IObjectSafety
{
	public:
	CObjectSafety::CObjectSafety
	(
	IUnknown *punkOuter,				// outer (controlling object)
	BOOL fSafeForScripting = TRUE,		// whether the object is safe for scripting
	BOOL fSafeForInitializing = TRUE	// whether the object is safe for initializing
	)	
	{
		m_punkOuter = punkOuter;
		m_fSafeForScripting = fSafeForScripting;
		m_fSafeForInitializing = fSafeForInitializing;
	}

	// Delegating versions of IUnknown functions
	STDMETHODIMP_(ULONG) AddRef() {
		return m_punkOuter->AddRef();
	}

	STDMETHODIMP_(ULONG) Release()	{
		return m_punkOuter->Release();
	}

	STDMETHODIMP QueryInterface(REFIID iid, LPVOID* ppv)	{
		return m_punkOuter->QueryInterface(iid, ppv);
	}

	// Return the interface setting options on this object
	STDMETHODIMP GetInterfaceSafetyOptions(
		/*IN */  REFIID	iid,					// Interface that we want options for
		/*OUT*/ DWORD	*	pdwSupportedOptions,	// Options meaningful on this interface
		/*OUT*/ DWORD *	pdwEnabledOptions)		// current option values on this interface
		;

	// Attempt to set the interface setting options on this object.
	// Since these are assumed to be fixed, we basically just check
	// that the attempted settings are valid.
	STDMETHODIMP SetInterfaceSafetyOptions(
		/*IN */  REFIID	iid,					// Interface to set options for
		/*IN */  DWORD		dwOptionsSetMask,		// Options to change
		/*IN */  DWORD		dwEnabledOptions)		// New option values
		;

	protected:
	IUnknown *m_punkOuter;
	BOOL	m_fSafeForScripting;
	BOOL	m_fSafeForInitializing;
};

// Helper function to create a component category and associated description
HRESULT CreateComponentCategory(CATID catid, WCHAR* catDescription);
#endif

// Helper function to register a CLSID as belonging to a component category
HRESULT RegisterCLSIDInCategory(REFCLSID clsid, CATID catid);

// Helper function to unregister a CLSID as belonging to a component category
HRESULT UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xaddroot\makefile.inc ===
xaddroot_i.c : $(PROJECT_ROOT)\published\xaddroot\xaddroot_i.c
    copy $** $@

$(O)\xaddroot.tlb : $(PROJECT_ROOT)\published\xaddroot\$(O)\xaddroot.tlb
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xaddroot\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cactl2.rc
//
#define IDD_MAINDLG			270
#define IDD_CAINFO			271
#define IDI_INSTALL_CERT			3490
#define IDC_INSTALLCA_CALIST		1010
#define IDC_INSTALLCA_VERIFIER		1011
#define IDC_INSTALLCA_MOREINFO		1012
#define IDC_INSTALLCA_LEGALDISCLAIMER	1014
#define IDC_CAINFO_THUMBPRINT		1015
#define IDC_CAINFO_THUMBPRINT_ALGORITHM 1016
#define IDC_CAINFO_VIEWCERT		1018
#define IDC_CAINFO_NAME 		1019
#define IDC_CAINFO_EXPIRATION_DATE	1020
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        106
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1011
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xaddroot\rootlist.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       rootlist.h
//
//  Contents:   Signed List of Trusted Roots Helper Functions
//
//  History:    01-Aug-99   philh   created
//--------------------------------------------------------------------------

#ifndef __ROOT_LIST_INCLUDED__
#define __ROOT_LIST_INCLUDED__

#include "wincrypt.h"


//+-------------------------------------------------------------------------
//  Verify that the encoded CTL contains a signed list of roots. For success,
//  return certificate store containing the trusted roots to add or
//  remove. Also for success, return certificate context of the signer.
//
//  The signature of the CTL is verified. The signer of the CTL is verified
//  up to a trusted root containing the predefined Microsoft public key.
//  The signer and intermediate certificates must have the
//  szOID_ROOT_LIST_SIGNER enhanced key usage extension.
//
//  The CTL fields are validated as follows:
//   - There is at least one SubjectUsage (really the roots enhanced key usage)
//   - If NextUpdate isn't NULL, that the CTL is still time valid
//   - Only allow roots identified by their sha1 hash
//
//  The following CTL extensions are processed:
//   - szOID_ENHANCED_KEY_USAGE - if present, must contain
//     szOID_ROOT_LIST_SIGNER usage
//   - szOID_REMOVE_CERTIFICATE - integer value, 0 => FALSE (add)
//     1 => TRUE (remove), all other values are invalid
//   - szOID_CERT_POLICIES - ignored
//
//  If the CTL contains any other critical extensions, then, the
//  CTL verification fails.
//
//  For a successfully verified CTL:
//   - TRUE is returned
//   - *pfRemoveRoots is set to FALSE to add roots and is set to TRUE to
//     remove roots.
//   - *phRootListStore is a certificate store containing only the roots to
//     add or remove. *phRootListStore must be closed by calling
//     CertCloseStore(). For added roots, the CTL's SubjectUsage field is
//     set as CERT_ENHKEY_USAGE_PROP_ID on all of the certificates in the
//     store.
//   - *ppSignerCert is a pointer to the certificate context of the signer.
//     *ppSignerCert must be freed by calling CertFreeCertificateContext().
//
//   Otherwise, FALSE is returned with *phRootListStore and *ppSignerCert
//   set to NULL.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertVerifySignedListOfTrustedRoots(
    IN const BYTE               *pbCtlEncoded,
    IN DWORD                    cbCtlEncoded,
    OUT BOOL                    *pfRemoveRoots,     // FALSE: add, TRUE: remove
    OUT HCERTSTORE              *phRootListStore,
    OUT PCCERT_CONTEXT          *ppSignerCert
    );





#endif  // __ROOT_LIST_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xaddroot\ui.h ===
#include "cryptui.h"

#define MY_HRESULT_FROM_WIN32(a) ((a >= 0x80000000) ? a : HRESULT_FROM_WIN32(a))
#define MAX_HASH_LEN                20
#define MAX_MSG_LEN                 256
#define CACERTWARNINGLEVEL          500

typedef BOOL (WINAPI * PFNCryptUIDlgViewCertificateW) (
        IN  PCCRYPTUI_VIEWCERTIFICATE_STRUCTW   pCertViewInfo,
        OUT BOOL                                *pfPropertiesChanged
        );

typedef struct _MDI {
    HCERTSTORE                      hStore;
    PCCERT_CONTEXT                  pCertSigner;
    HINSTANCE                       hInstance;
    PFNCryptUIDlgViewCertificateW   pfnCryptUIDlgViewCertificateW;
} MDI, * PMDI;  // Main Dialog Init

typedef struct _MIU {
    PCCERT_CONTEXT                  pCertContext;
    HINSTANCE                       hInstance;
    PFNCryptUIDlgViewCertificateW   pfnCryptUIDlgViewCertificateW;
} MIU, *PMIU; // More Info User data

INT_PTR CALLBACK MainDialogProc(
  HWND hwndDlg,  // handle to dialog box
  UINT uMsg,     // message
  WPARAM wParam, // first message parameter
  LPARAM lParam  // second message parameter
); 

BOOL FIsTooManyCertsOK(DWORD cCerts, HINSTANCE hInstanceUI);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xaddroot\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A8B640FA_461D_442D_8E72_6C9824635647__INCLUDED_)
#define AFX_STDAFX_H__A8B640FA_461D_442D_8E72_6C9824635647__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A8B640FA_461D_442D_8E72_6C9824635647__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xaddroot\rootlist.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       rootlist.cpp
//
//  Contents:   Signed List of Trusted Roots Helper Functions
//
//
//  Functions:  I_CertVerifySignedListOfTrustedRoots
//
//  History:    01-Aug-99   philh   created
//--------------------------------------------------------------------------

#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "wintrust.h"
#include "softpub.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

#include "dbgdef.h"
#include "rootlist.h"

#ifdef STATIC
#undef STATIC
#endif
#define STATIC


#define SHA1_HASH_LEN       20

//+-------------------------------------------------------------------------
//  SHA1 Key Identifier of the signer's root
//--------------------------------------------------------------------------
STATIC BYTE rgbSignerRootKeyId[SHA1_HASH_LEN] = {
#if 1
    // The following is the sha1 key identifier for the Microsoft root
    0x4A, 0x5C, 0x75, 0x22, 0xAA, 0x46, 0xBF, 0xA4, 0x08, 0x9D,
    0x39, 0x97, 0x4E, 0xBD, 0xB4, 0xA3, 0x60, 0xF7, 0xA0, 0x1D
#else
    // The following is the sha1 key identifier for the test root
    0x9A, 0xA6, 0x58, 0x7F, 0x94, 0xDD, 0x91, 0xD9, 0x1E, 0x63,
    0xDF, 0xD3, 0xF0, 0xCE, 0x5F, 0xAE, 0x18, 0x93, 0xAA, 0xB7
#endif
};

//+-------------------------------------------------------------------------
// If the certificate has an EKU extension, returns an allocated and
// decoded EKU. Otherwise, returns NULL.
//
// LocalFree() must be called to free the returned EKU.
//--------------------------------------------------------------------------
STATIC
PCERT_ENHKEY_USAGE
WINAPI
GetAndAllocCertEKUExt(
    IN PCCERT_CONTEXT pCert
    )
{
    PCERT_ENHKEY_USAGE pUsage = NULL;
    DWORD cbUsage;

    cbUsage = 0;
    if (!CertGetEnhancedKeyUsage(
            pCert,
            CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
            NULL,                                   // pUsage
            &cbUsage) || 0 == cbUsage)
        goto GetEnhancedKeyUsageError;
    if (NULL == (pUsage = (PCERT_ENHKEY_USAGE) LocalAlloc(LPTR, cbUsage)))
        goto OutOfMemory;
    if (!CertGetEnhancedKeyUsage(
            pCert,
            CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
            pUsage,
            &cbUsage))
        goto GetEnhancedKeyUsageError;

CommonReturn:
    return pUsage;
ErrorReturn:
    if (pUsage) {
        LocalFree(pUsage);
        pUsage = NULL;
    }
    goto CommonReturn;

SET_ERROR(GetEnhancedKeyUsageError, CERT_E_WRONG_USAGE)
SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
}

//+-------------------------------------------------------------------------
//  The signature of the CTL is verified. The signer of the CTL is verified
//  up to a trusted root containing the predefined Microsoft public key.
//  The signer and intermediate certificates must have the
//  szOID_ROOT_LIST_SIGNER enhanced key usage extension.
//
//  For success, *ppSignerCert is updated with certificate context of the
//  signer.
//--------------------------------------------------------------------------
STATIC
BOOL
WINAPI
GetAndVerifyTrustedRootsSigner(
    IN HCRYPTMSG hCryptMsg,
    IN HCERTSTORE hMsgStore,
    OUT PCCERT_CONTEXT *ppSignerCert
    )
{
    BOOL fResult;
    LONG lStatus;
    PCCERT_CONTEXT pSignerCert = NULL;
    GUID wvtCertActionID = WINTRUST_ACTION_GENERIC_CERT_VERIFY;
    WINTRUST_CERT_INFO wvtCertInfo;
    WINTRUST_DATA wvtData;
    BOOL fCloseWVT = FALSE;
    DWORD dwLastError = 0;

    CRYPT_PROVIDER_DATA *pProvData;     // not allocated
    CRYPT_PROVIDER_SGNR *pProvSigner;   // not allocated
    CRYPT_PROVIDER_CERT *pProvCert;     // not allocated
    DWORD idxCert;
    PCCERT_CONTEXT pCert;               // not refCount'ed

    PCERT_ENHKEY_USAGE pUsage = NULL;

    BYTE rgbKeyId[SHA1_HASH_LEN];
    DWORD cbKeyId;

    if (!CryptMsgGetAndVerifySigner(
            hCryptMsg,
            0,                      // cSignerStore
            NULL,                   // rghSignerStore
            0,                      // dwFlags
            &pSignerCert,
            NULL                    // pdwSignerIndex
            ))
        goto CryptMsgGetAndVerifySignerError;

    memset(&wvtCertInfo, 0, sizeof(wvtCertInfo));
    wvtCertInfo.cbStruct = sizeof(wvtCertInfo);
    wvtCertInfo.psCertContext = (PCERT_CONTEXT) pSignerCert;
    wvtCertInfo.chStores = 1;
    wvtCertInfo.pahStores = &hMsgStore;
    wvtCertInfo.dwFlags = 0;
    wvtCertInfo.pcwszDisplayName = L"";

    memset(&wvtData, 0, sizeof(wvtData));
    wvtData.cbStruct = sizeof(wvtData);
    wvtData.pPolicyCallbackData = (void *) szOID_ROOT_LIST_SIGNER;
    wvtData.dwUIChoice = WTD_UI_NONE;
    wvtData.fdwRevocationChecks = WTD_REVOKE_NONE;
    wvtData.dwUnionChoice = WTD_CHOICE_CERT;
    wvtData.pCert = &wvtCertInfo;
    wvtData.dwStateAction = WTD_STATEACTION_VERIFY;
    wvtData.hWVTStateData = NULL;
    wvtData.dwProvFlags = 0;

    lStatus = WinVerifyTrust(
                NULL,               // hwnd
                &wvtCertActionID,
                &wvtData
                );

#if (0) // DSIE
    if (ERROR_SUCCESS != lStatus)
        goto WinVerifyTrustError;
    else
        fCloseWVT = TRUE;
#else
    if (ERROR_SUCCESS != lStatus  && CERT_E_REVOCATION_FAILURE != lStatus)
        goto WinVerifyTrustError;
    else
        fCloseWVT = TRUE;
#endif
    if (NULL == (pProvData = WTHelperProvDataFromStateData(
            wvtData.hWVTStateData)))
        goto NoProvDataError;
    if (0 == pProvData->csSigners)
        goto NoProvSignerError;
    if (NULL == (pProvSigner = WTHelperGetProvSignerFromChain(
            pProvData,
            0,              // idxSigner
            FALSE,          // fCounterSigner
            0               // idxCounterSigner
            )))
        goto NoProvSignerError;

    if (2 > pProvSigner->csCertChain)
        goto MissingSignerCertsError;

    // Check that the top level certificate contains the public
    // key for the Microsoft root.
    pProvCert = WTHelperGetProvCertFromChain(pProvSigner,
        pProvSigner->csCertChain - 1);
    if (NULL == pProvCert)
        goto UnexpectedError;
    pCert = pProvCert->pCert;

    cbKeyId = SHA1_HASH_LEN;
    if (!CryptHashPublicKeyInfo(
            NULL,               // hCryptProv
            CALG_SHA1,
            0,                  // dwFlags
            X509_ASN_ENCODING,
            &pCert->pCertInfo->SubjectPublicKeyInfo,
            rgbKeyId,
            &cbKeyId
            ))
        goto HashPublicKeyInfoError;

    if (SHA1_HASH_LEN != cbKeyId ||
            0 != memcmp(rgbSignerRootKeyId, rgbKeyId, SHA1_HASH_LEN))
        goto InvalidSignerRootError;

    // Check that the signer and intermediate certs have the RootListSigner
    // Usage extension
    for (idxCert = 0; idxCert < pProvSigner->csCertChain - 1; idxCert++) {
        DWORD i;

        pProvCert = WTHelperGetProvCertFromChain(pProvSigner, idxCert);
        if (NULL == pProvCert)
            goto UnexpectedError;
        pCert = pProvCert->pCert;

        pUsage = GetAndAllocCertEKUExt(pCert);
        if (NULL == pUsage)
            goto GetAndAllocCertEKUExtError;

        for (i = 0; i < pUsage->cUsageIdentifier; i++) {
            if (0 == strcmp(szOID_ROOT_LIST_SIGNER,
                    pUsage->rgpszUsageIdentifier[i]))
                break;
        }

        if (i == pUsage->cUsageIdentifier)
            goto MissingTrustListSignerUsageError;

        LocalFree(pUsage);
        pUsage = NULL;

    }

    fResult = TRUE;

CommonReturn:
    if (fCloseWVT) {
        wvtData.dwStateAction = WTD_STATEACTION_CLOSE;
        lStatus = WinVerifyTrust(
                    NULL,               // hwnd
                    &wvtCertActionID,
                    &wvtData
                    );
    }
    if (pUsage)
        LocalFree(pUsage);

    SetLastError(dwLastError);
    *ppSignerCert = pSignerCert;
    return fResult;
ErrorReturn:
    dwLastError = GetLastError();
    if (pSignerCert) {
        CertFreeCertificateContext(pSignerCert);
        pSignerCert = NULL;
    }
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(CryptMsgGetAndVerifySignerError)
SET_ERROR_VAR(WinVerifyTrustError, lStatus)
SET_ERROR(NoProvDataError, E_UNEXPECTED)
SET_ERROR(NoProvSignerError, TRUST_E_NO_SIGNER_CERT)
SET_ERROR(MissingSignerCertsError, CERT_E_CHAINING)
SET_ERROR(UnexpectedError, E_UNEXPECTED)
TRACE_ERROR(HashPublicKeyInfoError)
SET_ERROR(InvalidSignerRootError, CERT_E_UNTRUSTEDROOT)
TRACE_ERROR(GetAndAllocCertEKUExtError)
SET_ERROR(MissingTrustListSignerUsageError, CERT_E_WRONG_USAGE)
}

//+-------------------------------------------------------------------------
// Returns TRUE if all the CTL fields are valid. Checks for the following:
//  - There is at least one SubjectUsage (really the roots enhanced key usage)
//  - If NextUpdate isn't NULL, that the CTL is still time valid
//  - Only allow roots identified by their sha1 hash
//--------------------------------------------------------------------------
STATIC
BOOL
WINAPI
VerifyTrustedRootsCtlFields(
    IN PCTL_INFO pCtlInfo
    )
{
    BOOL fResult;

    // Must have a least one usage
    if (0 == pCtlInfo->SubjectUsage.cUsageIdentifier)
        goto NoSubjectUsageError;


    // If NextUpdate is present, verify that the CTL hasn't expired.
    if (pCtlInfo->NextUpdate.dwLowDateTime ||
                pCtlInfo->NextUpdate.dwHighDateTime) {
        SYSTEMTIME SystemTime;
        FILETIME FileTime;

        GetSystemTime(&SystemTime);
        SystemTimeToFileTime(&SystemTime, &FileTime);

        if (CompareFileTime(&FileTime, &pCtlInfo->NextUpdate) > 0)
            goto ExpiredCtlError;
    }

    // Only allow roots identified by their sha1 hash
    if (0 != strcmp(szOID_OIWSEC_sha1,
            pCtlInfo->SubjectAlgorithm.pszObjId))
        goto InvalidSubjectAlgorithm;

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(NoSubjectUsageError, ERROR_INVALID_DATA)
SET_ERROR(ExpiredCtlError, CERT_E_EXPIRED)
SET_ERROR(InvalidSubjectAlgorithm, ERROR_INVALID_DATA)
}

//+-------------------------------------------------------------------------
// Returns TRUE if all the known extensions are valid and there aren't any
// unknown critical extensions.
//
// We know about the following extensions:
//  - szOID_ENHANCED_KEY_USAGE - if present, must contain
//      szOID_ROOT_LIST_SIGNER usage
//  - szOID_REMOVE_CERTIFICATE - integer value, 0 => FALSE (add)
//      1 => TRUE (remove), all other values are invalid
//  - szOID_CERT_POLICIES - ignored
//
// If szOID_REMOVE_CERTIFICATE is present, then, *pfRemoveRoots is updated.
// Otherwise, *pfRemoveRoots defaults to FALSE.
//--------------------------------------------------------------------------
STATIC
BOOL
WINAPI
VerifyTrustedRootsCtlExtensions(
    IN PCTL_INFO pCtlInfo,
    OUT BOOL *pfRemoveRoots
    )
{
    BOOL fResult;
    PCERT_EXTENSION pExt;
    DWORD cExt;
    PCERT_ENHKEY_USAGE pUsage = NULL;
    DWORD cbRemoveRoots;

    *pfRemoveRoots = FALSE;

    // Verify the extensions
    for (cExt = pCtlInfo->cExtension,
         pExt = pCtlInfo->rgExtension; 0 < cExt; cExt--, pExt++) {
        if (0 == strcmp(szOID_ENHANCED_KEY_USAGE, pExt->pszObjId)) {
            DWORD cbUsage;
            DWORD i;

            // Check for szOID_ROOT_LIST_SIGNER usage

            if (!CryptDecodeObject(
                    X509_ASN_ENCODING,
                    X509_ENHANCED_KEY_USAGE,
                    pExt->Value.pbData,
                    pExt->Value.cbData,
                    0,                          // dwFlags
                    NULL,                       // pvStructInfo
                    &cbUsage
                    ))
                goto DecodeEnhancedKeyUsageExtError;
            if (NULL == (pUsage = (PCERT_ENHKEY_USAGE) LocalAlloc(
                    LPTR, cbUsage)))
                goto OutOfMemory;
            if (!CryptDecodeObject(
                    X509_ASN_ENCODING,
                    X509_ENHANCED_KEY_USAGE,
                    pExt->Value.pbData,
                    pExt->Value.cbData,
                    0,                          // dwFlags
                    pUsage,
                    &cbUsage
                    ))
                goto DecodeEnhancedKeyUsageExtError;
            for (i = 0; i < pUsage->cUsageIdentifier; i++) {
                if (0 == strcmp(szOID_ROOT_LIST_SIGNER,
                        pUsage->rgpszUsageIdentifier[i]))
                    break;
            }

            if (i == pUsage->cUsageIdentifier)
                goto MissingTrustListSignerUsageInExtError;

            LocalFree(pUsage);
            pUsage = NULL;
        } else if (0 == strcmp(szOID_REMOVE_CERTIFICATE, pExt->pszObjId)) {
            int iVal;
            DWORD cbVal;

            cbVal = sizeof(iVal);
            iVal = 0;
            if (!CryptDecodeObject(
                    X509_ASN_ENCODING,
                    X509_INTEGER,
                    pExt->Value.pbData,
                    pExt->Value.cbData,
                    0,                          // dwFlags
                    &iVal,
                    &cbVal
                    ))
                goto DecodeRemoveCertificateExtError;

            switch(iVal) {
                case 0:
                    *pfRemoveRoots = FALSE;
                    break;
                case 1:
                    *pfRemoveRoots = TRUE;
                    break;
                default:
                    goto InvalidRemoveCertificateExtValueError;
            }
        } else if (0 == strcmp(szOID_CERT_POLICIES, pExt->pszObjId)) {
            ;
        } else if (pExt->fCritical) {
            goto UnknownCriticalExtensionError;
        }
    }

    fResult = TRUE;

CommonReturn:
    if (pUsage)
        LocalFree(pUsage);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(DecodeEnhancedKeyUsageExtError)
SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
SET_ERROR(MissingTrustListSignerUsageInExtError, ERROR_INVALID_DATA)
TRACE_ERROR(DecodeRemoveCertificateExtError)
SET_ERROR(InvalidRemoveCertificateExtValueError, ERROR_INVALID_DATA)
SET_ERROR(UnknownCriticalExtensionError, ERROR_INVALID_DATA)
}


//+-------------------------------------------------------------------------
// Returns TRUE, if a sha1 entry exists in the CTL for the certificate
//--------------------------------------------------------------------------
STATIC
BOOL
WINAPI
IsTrustedRoot(
    IN PCTL_INFO pCtlInfo,
    IN PCCERT_CONTEXT pCert
    )
{
    BOOL fResult = FALSE;
    BYTE rgbSha1Hash[SHA1_HASH_LEN];
    DWORD cbSha1Hash;
    DWORD cEntry;
    PCTL_ENTRY pEntry;          // not allocated

    cbSha1Hash = SHA1_HASH_LEN;
    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_SHA1_HASH_PROP_ID,
            rgbSha1Hash,
            &cbSha1Hash
            ))
        goto GetSha1HashError;

    for (cEntry = pCtlInfo->cCTLEntry,
         pEntry = pCtlInfo->rgCTLEntry; 0 < cEntry; cEntry--, pEntry++) {
        if (SHA1_HASH_LEN == pEntry->SubjectIdentifier.cbData &&
                0 == memcmp(rgbSha1Hash, pEntry->SubjectIdentifier.pbData,
                    SHA1_HASH_LEN)) {
            fResult = TRUE;
            break;
        }
    }

CommonReturn:
    return fResult;
ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(GetSha1HashError)
}

//+-------------------------------------------------------------------------
// Checks if the certificate has an EKU extension and if all of the
// cert's usages are within the specified list of usages.
//
// Returns TRUE if the above two conditions are satisfied.
//--------------------------------------------------------------------------
STATIC
BOOL
WINAPI
IsValidCertEKUExtSubset(
    IN PCCERT_CONTEXT pCert,
    PCERT_ENHKEY_USAGE pValidUsage
    )
{
    PCERT_ENHKEY_USAGE pCertUsage = NULL;
    BOOL fResult = FALSE;
    DWORD i, j;

    pCertUsage = GetAndAllocCertEKUExt(pCert);
    if (NULL == pCertUsage || 0 == pCertUsage->cUsageIdentifier)
        goto CommonReturn;

    for (i = 0; i < pCertUsage->cUsageIdentifier; i++) {
        for (j = 0; j < pValidUsage->cUsageIdentifier; j++) {
            if (0 == strcmp(pCertUsage->rgpszUsageIdentifier[i],
                    pValidUsage->rgpszUsageIdentifier[j]))
                break;
        }
        if (j == pValidUsage->cUsageIdentifier)
            // No Match
            goto CommonReturn;
    }

    fResult = TRUE;

CommonReturn:
    if (pCertUsage)
        LocalFree(pCertUsage);
    return fResult;
}

//+-------------------------------------------------------------------------
// Removes all certificates from the store not having a sha1 hash
// entry in the CTL.
//
// For added certificates, sets the CERT_ENHKEY_USAGE_PROP_ID
//--------------------------------------------------------------------------
STATIC
BOOL
WINAPI
FilterAndUpdateTrustedRootsInStore(
    IN PCTL_INFO pCtlInfo,
    IN BOOL fRemoveRoots,
    IN OUT HCERTSTORE hMsgStore
    )
{
    BOOL fResult;
    PCCERT_CONTEXT pCert = NULL;
    CRYPT_DATA_BLOB EncodedUsage = {0, NULL};   // pbData is allocated

    if (!fRemoveRoots) {
        // Re-encode the decoded SubjectUsage field. It will be added as
        // a CERT_ENHKEY_USAGE_PROP_ID to each of the certs in the list

        if (!CryptEncodeObject(
                X509_ASN_ENCODING,
                X509_ENHANCED_KEY_USAGE,
                &pCtlInfo->SubjectUsage,
                NULL,                   // pbEncoded
                &EncodedUsage.cbData
                ))
            goto EncodeUsageError;
        if (NULL == (EncodedUsage.pbData = (BYTE *) LocalAlloc(
            LPTR, EncodedUsage.cbData)))
                goto OutOfMemory;
        if (!CryptEncodeObject(
                X509_ASN_ENCODING,
                X509_ENHANCED_KEY_USAGE,
                &pCtlInfo->SubjectUsage,
                EncodedUsage.pbData,
                &EncodedUsage.cbData
                ))
            goto EncodeUsageError;
    }

    // Iterate through the certificates in the message store.
    // Remove certificates not in the signed CTL entry list
    pCert = NULL;
    while (pCert = CertEnumCertificatesInStore(hMsgStore, pCert)) {
        if (IsTrustedRoot(pCtlInfo, pCert)) {
            // Add the enhanced key usage property if the certificate
            // doesn't already have an EKU extension that's a subset
            // of the SubjectUsage
            if (!fRemoveRoots && !IsValidCertEKUExtSubset(
                    pCert, &pCtlInfo->SubjectUsage)) {
                if (!CertSetCertificateContextProperty(
                        pCert,
                        CERT_ENHKEY_USAGE_PROP_ID,
                        0,                          // dwFlags
                        &EncodedUsage
                        ))
                    goto SetEnhancedKeyUsagePropertyError;
            }
        } else {
            PCCERT_CONTEXT pCertDup;

            pCertDup = CertDuplicateCertificateContext(pCert);
            CertDeleteCertificateFromStore(pCertDup);
        }
    }

    fResult = TRUE;
CommonReturn:
    if (EncodedUsage.pbData)
        LocalFree(EncodedUsage.pbData);
    if (pCert)
        CertFreeCertificateContext(pCert);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(EncodeUsageError)
SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
TRACE_ERROR(SetEnhancedKeyUsagePropertyError)
}

//+-------------------------------------------------------------------------
//  Verify that the encoded CTL contains a signed list of roots. For success,
//  return certificate store containing the trusted roots to add or
//  remove. Also for success, return certificate context of the signer.
//
//  The signature of the CTL is verified. The signer of the CTL is verified
//  up to a trusted root containing the predefined Microsoft public key.
//  The signer and intermediate certificates must have the
//  szOID_ROOT_LIST_SIGNER enhanced key usage extension.
//
//  The CTL fields are validated as follows:
//   - There is at least one SubjectUsage (really the roots enhanced key usage)
//   - If NextUpdate isn't NULL, that the CTL is still time valid
//   - Only allow roots identified by their sha1 hash
//
//  The following CTL extensions are processed:
//   - szOID_ENHANCED_KEY_USAGE - if present, must contain
//     szOID_ROOT_LIST_SIGNER usage
//   - szOID_REMOVE_CERTIFICATE - integer value, 0 => FALSE (add)
//     1 => TRUE (remove), all other values are invalid
//   - szOID_CERT_POLICIES - ignored
//
//  If the CTL contains any other critical extensions, then, the
//  CTL verification fails.
//
//  For a successfully verified CTL:
//   - TRUE is returned
//   - *pfRemoveRoots is set to FALSE to add roots and is set to TRUE to
//     remove roots.
//   - *phRootListStore is a certificate store containing only the roots to
//     add or remove. *phRootListStore must be closed by calling
//     CertCloseStore(). For added roots, the CTL's SubjectUsage field is
//     set as CERT_ENHKEY_USAGE_PROP_ID on all of the certificates in the
//     store.
//   - *ppSignerCert is a pointer to the certificate context of the signer.
//     *ppSignerCert must be freed by calling CertFreeCertificateContext().
//
//   Otherwise, FALSE is returned with *phRootListStore and *ppSignerCert
//   set to NULL.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertVerifySignedListOfTrustedRoots(
    IN const BYTE               *pbCtlEncoded,
    IN DWORD                    cbCtlEncoded,
    OUT BOOL                    *pfRemoveRoots,     // FALSE: add, TRUE: remove
    OUT HCERTSTORE              *phRootListStore,
    OUT PCCERT_CONTEXT          *ppSignerCert
    )
{
    BOOL fResult;
    PCCTL_CONTEXT pCtl = NULL;
    HCERTSTORE hMsgStore = NULL;
    PCCERT_CONTEXT pSignerCert = NULL;
    BOOL fRemoveRoots = FALSE;
    PCTL_INFO pCtlInfo;                 // not allocated

    if (NULL == (pCtl = CertCreateCTLContext(
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            pbCtlEncoded,
            cbCtlEncoded)))
        goto CreateCtlContextError;

    if (NULL == (hMsgStore = CertOpenStore(
            CERT_STORE_PROV_MSG,
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            0,                      // hCryptProv
            0,                      // dwFlags
            pCtl->hCryptMsg         // pvPara
            )))
        goto OpenMsgStoreError;

    if (!GetAndVerifyTrustedRootsSigner(
            pCtl->hCryptMsg, hMsgStore, &pSignerCert))
        goto GetAndVerifyTrustedRootsSignerError;

    pCtlInfo = pCtl->pCtlInfo;

    if (!VerifyTrustedRootsCtlFields(pCtlInfo))
        goto VerifyCtlFieldsError;
    if (!VerifyTrustedRootsCtlExtensions(pCtlInfo, &fRemoveRoots))
        goto VerifyCtlExtensionsError;
    if (!FilterAndUpdateTrustedRootsInStore(pCtlInfo, fRemoveRoots, hMsgStore))
        goto FilterAndUpdateTrustedRootsError;

    fResult = TRUE;
CommonReturn:
    if (pCtl)
        CertFreeCTLContext(pCtl);
    *pfRemoveRoots = fRemoveRoots;
    *phRootListStore = hMsgStore;
    *ppSignerCert = pSignerCert;
    return fResult;
ErrorReturn:
    if (pSignerCert) {
        CertFreeCertificateContext(pSignerCert);
        pSignerCert = NULL;
    }

    if (hMsgStore) {
        CertCloseStore(hMsgStore, 0);
        hMsgStore = NULL;
    }
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(CreateCtlContextError)
TRACE_ERROR(OpenMsgStoreError)
TRACE_ERROR(GetAndVerifyTrustedRootsSignerError)
TRACE_ERROR(VerifyCtlFieldsError)
TRACE_ERROR(VerifyCtlExtensionsError)
TRACE_ERROR(FilterAndUpdateTrustedRootsError)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xaddroot\xaddroot.cpp ===
// xaddroot.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f xaddrootps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "xaddroot.h"
#include "cobjsaf.h"

#include "caddroot.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_caddroot, Ccaddroot)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
	_Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
//    RegisterCLSIDInCategory(CLSID_caddroot, CATID_SafeForScripting);
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{

//    UnRegisterCLSIDInCategory(CLSID_caddroot, CATID_SafeForScripting);
    return _Module.UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xelib\cmc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       cmc.cpp
//
//  Contents:   CMC request creation code shared between xenroll and CA
//
//  History:    03-2000   vich   created
//              03-2000   xtan   moved from ca
//              05-2000   xtan   moved from xenroll\xcertlib
//--------------------------------------------------------------------------
#define CMSG_SIGNER_ENCODE_INFO_HAS_CMS_FIELDS
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <assert.h>
#include <wincrypt.h>
#include <dbgdef.h>
#include <unicode.h>

#include "xelib.h"
#include "xenroll.h"

//#define USE_OLD_DUMMY_SIGNER

#ifndef SAVE_DUMMY_SIGNER
#  define SAVE_DUMMY_SIGNER	FALSE
#endif


#ifdef _XENROLL_SRC_
#define CryptAcquireContextW CryptAcquireContextU
#endif //_XENROLL_SRC_

HRESULT
GenerateKeys(
    IN  WCHAR const   *pwszContainer,
    IN  DWORD          dwProvType,
    OUT HCRYPTPROV    *phProv)
{
    HRESULT hr;
    HCRYPTKEY hKey = NULL;

    *phProv = NULL;

    // see if the container already exists

//    if (CryptAcquireContext(
    if (CryptAcquireContextW(
			phProv,
			pwszContainer,
			NULL,		// pwszProvName
			dwProvType,
			0))		// dwFlags
    {
	if (NULL != *phProv)
	{
	    CryptReleaseContext(*phProv, 0);
	    *phProv = NULL;
	}

        // container exists -- remove old keys and generate new ones.

//        if (!CryptAcquireContext(
        if (!CryptAcquireContextW(
			    phProv,
			    pwszContainer,
			    NULL,		// pwszProvName
			    dwProvType,
			    CRYPT_DELETEKEYSET))
        {
            hr = myHLastError();
            _JumpError(hr, error, "CryptAcquireContext");
        }
    }

    // create new container

//    if (!CryptAcquireContext(
    if (!CryptAcquireContextW(
                        phProv,
                        pwszContainer,
			NULL,			// pwszProvName
                        dwProvType,
                        CRYPT_NEWKEYSET))	// force new container
    {
        hr = myHLastError();
	_JumpError(hr, error, "CryptAcquireContext");
    }
 
    // create signature keys 

    if (!CryptGenKey(*phProv, AT_SIGNATURE, 0, &hKey))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptGenKey");
    }
    hr = S_OK;

error:
    if (NULL != hKey)
    {
        CryptDestroyKey(hKey);
    }
    return(hr);
}


#define wszDUMMYSIGNER	L"Dummy Signer"

#ifdef USE_OLD_DUMMY_SIGNER

HRESULT
CreateDummySignerNameInfo(
    OUT BYTE  **ppbEncodedName,
    OUT DWORD *pcbEncodedName)
{
    HRESULT hr;
    CERT_RDN_ATTR rgRDNAttr[2];
    CERT_RDN rgRDN[2];
    CERT_NAME_INFO NameInfo;
    DWORD i;

    CSASSERT(NULL != ppbEncodedName && NULL != pcbEncodedName);

    NameInfo.cRDN = ARRAYSIZE(rgRDN);
    NameInfo.rgRDN = rgRDN;

    for (i = 0; i < ARRAYSIZE(rgRDN); i++)
    {
	rgRDN[i].cRDNAttr = 1;
	rgRDN[i].rgRDNAttr = &rgRDNAttr[i];

	rgRDNAttr[i].pszObjId = (0 == i)?
	    szOID_RDN_DUMMY_SIGNER : szOID_COMMON_NAME;

	rgRDNAttr[i].dwValueType = 0;
	rgRDNAttr[i].Value.pbData = (BYTE *) wszDUMMYSIGNER;
	rgRDNAttr[i].Value.cbData = 0;
    }

//    if (!myEncodeName(
    if (!myEncodeObject(
		 X509_ASN_ENCODING,
                 X509_UNICODE_NAME,
		 &NameInfo,
		 0,
		 CERTLIB_USE_LOCALALLOC,
		 ppbEncodedName,
		 pcbEncodedName))
    {
        hr = myHLastError();
//        _JumpError(hr, error, "myEncodeName");
        _JumpError(hr, error, "myEncodeObject");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
EncodeCertAndSign(
    IN HCRYPTPROV hProv,
    IN CERT_INFO *pCert,
    IN char const *pszAlgId,
    OUT BYTE **ppbSigned,
    OUT DWORD *pcbSigned)
{
    HRESULT hr;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    
    *ppbSigned = NULL;
//    if (!myEncodeToBeSigned(
    if (!myEncodeObject(
		    X509_ASN_ENCODING,
                    X509_CERT_TO_BE_SIGNED,
		    pCert,
                    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pbEncoded,
		    &cbEncoded))
    {
        hr = myHLastError();
//	_JumpError(hr, error, "myEncodeToBeSigned");
	_JumpError(hr, error, "myEncodeObject");
    }

    hr = myEncodeSignedContent(
			hProv,
			X509_ASN_ENCODING,
			pszAlgId,
			pbEncoded,
			cbEncoded,
			CERTLIB_USE_LOCALALLOC,
			ppbSigned,
			pcbSigned);
    _JumpIfError(hr, error, "myEncodeSignedContent");

error:
    if (NULL != pbEncoded)
    {
        LocalFree(pbEncoded);
    }
    return(hr);
}


VOID
GenerateSerialNumber(
    UUID *puuidSerialNumber)
{
    HRESULT hr;
    BYTE *pb;

    ZeroMemory(puuidSerialNumber, sizeof(*puuidSerialNumber));
    hr = UuidCreate(puuidSerialNumber);
    if (S_OK != hr)
    {
	BYTE *pbEnd;
	
	CSASSERT(RPC_S_UUID_LOCAL_ONLY == hr);

	// No net card?  Fake up a GUID:

	pb = (BYTE *) puuidSerialNumber;
	pbEnd = (BYTE *) pb + sizeof(*puuidSerialNumber);

	GetSystemTimeAsFileTime((FILETIME *) pb);
	pb += sizeof(FILETIME);

	while (pb < pbEnd)
	{
	    *(DWORD *) pb = GetTickCount();
	    pb += sizeof(DWORD);
	}
	CSASSERT(pb == pbEnd);
    }
    pb = &((BYTE *) puuidSerialNumber)[sizeof(*puuidSerialNumber) - 1];

    // make sure the last byte is never zero
    if (0 == *pb)
    {
	*pb = 'z';
    }

    // Some clients can't handle negative serial numbers:
    *pb &= 0x7f;
}

HRESULT
CreateKPI(
    IN CERT_CONTEXT const *pCert,
    IN BSTR strKeyContainer)
{
    HRESULT hr;
    HCERTSTORE hStore = NULL;
    CRYPT_KEY_PROV_INFO kpi;
    CERT_CONTEXT const *pCertStore = NULL;

    hStore = CertOpenStore(
		CERT_STORE_PROV_SYSTEM_W,
		X509_ASN_ENCODING,
		NULL,		// hProv
		CERT_STORE_OPEN_EXISTING_FLAG | CERT_SYSTEM_STORE_CURRENT_USER,
		L"My");
    if (NULL == hStore)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertOpenStore");
    }

    if (!CertAddCertificateContextToStore(
				    hStore,
				    pCert,
				    CERT_STORE_ADD_REPLACE_EXISTING,
				    &pCertStore))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertAddCertificateContextToStore");
    }

    ZeroMemory(&kpi, sizeof(kpi));
    kpi.pwszContainerName = strKeyContainer;
    kpi.pwszProvName = MS_DEF_PROV_W;
    kpi.dwProvType = PROV_RSA_FULL;
    kpi.dwKeySpec = AT_SIGNATURE;

    if (!CertSetCertificateContextProperty(
					pCertStore,
					CERT_KEY_PROV_INFO_PROP_ID,
					0,
					&kpi))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertSetCertificateContextProperty");
    }
    hr = S_OK;

error:
    if (NULL != pCertStore)
    {
	CertFreeCertificateContext(pCertStore);
    }
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}

VOID
DestroyDummyCert(
    IN HCRYPTPROV hProv,
    IN BSTR strKeyContainer,
    IN CERT_CONTEXT const *pCert,
    IN BOOL fSaveDummySignerCert)
{
    HRESULT hr;
    
    if (NULL != hProv)
    {
	CryptReleaseContext(hProv, 0);
    }
    if (NULL != strKeyContainer)
    {
	if (fSaveDummySignerCert && NULL != pCert)
	{
	    CreateKPI(pCert, strKeyContainer);
	}
	else
	{
//	    if (!CryptAcquireContext(
	    if (!CryptAcquireContextW(
				&hProv,
				strKeyContainer,
				NULL,		// pwszProvName
				PROV_RSA_FULL,
				CRYPT_DELETEKEYSET))
	    {
		hr = myHLastError();
		_PrintError(hr, "CryptAcquireContext");
	    }
	}
	SysFreeString(strKeyContainer);
    }
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
}


HRESULT
EncodeDummyCert(
    OUT HCRYPTPROV *phProv,
    OUT BSTR *pstrKeyContainer,
    OUT CERT_CONTEXT const **ppCert)
{
    HRESULT hr;
    HCRYPTPROV hProv = NULL;
    CERT_PUBLIC_KEY_INFO *pPubKey = NULL;
    DWORD cbPubKey;
    CERT_NAME_BLOB NameBlob;
    CERT_INFO Cert;
    char *pszAlgId = szOID_RSA_SHA1RSA;
    UUID uuidSerialNumber;
    BSTR strKeyContainer = NULL;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    //ZeroMemory(aext, sizeof(aext));
    NameBlob.pbData = NULL;

    *phProv = NULL;
    *pstrKeyContainer = NULL;
    *ppCert = NULL;

    // Use a GUID for the serial number and the key container name

    GenerateSerialNumber(&uuidSerialNumber);

    hr = MultiByteIntegerToBstr(
			    FALSE,
			    sizeof(uuidSerialNumber),
			    (BYTE const *) &uuidSerialNumber,
			    &strKeyContainer);
    _JumpIfError(hr, error, "MultiByteIntegerToBstr");


    hr = GenerateKeys(strKeyContainer, PROV_RSA_FULL, &hProv);
    _JumpIfError(hr, error, "GenerateKeys");

    // SUBJECT & ISSUER:

    hr = CreateDummySignerNameInfo(&NameBlob.pbData, &NameBlob.cbData);
    _JumpIfError(hr, error, "CreateDummySignerNameInfo");

    if (!myCryptExportPublicKeyInfo(
				hProv,
				AT_SIGNATURE,
				CERTLIB_USE_LOCALALLOC,
				&pPubKey,
				&cbPubKey))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myCryptExportPublicKeyInfo");
    }

    // CERT:

    ZeroMemory(&Cert, sizeof(Cert));
    Cert.dwVersion = CERT_V1;

    Cert.SerialNumber.pbData = (BYTE *) &uuidSerialNumber;
    Cert.SerialNumber.cbData = sizeof(uuidSerialNumber);
    Cert.SignatureAlgorithm.pszObjId = pszAlgId;
    Cert.Issuer = NameBlob;			// Structure assignment

    GetSystemTimeAsFileTime(&Cert.NotBefore);
    Cert.NotAfter = Cert.NotBefore;
    myMakeExprDateTime(
		&Cert.NotBefore,
		-CCLOCKSKEWMINUTESDEFAULT,
		ENUM_PERIOD_MINUTES);
    myMakeExprDateTime(&Cert.NotAfter, 1, ENUM_PERIOD_MONTHS);

    Cert.Subject = NameBlob;			// Structure assignment
    Cert.SubjectPublicKeyInfo = *pPubKey;	// Structure assignment

    //Cert.cExtension = 0;
    //Cert.rgExtension = NULL;

    hr = EncodeCertAndSign(
		    hProv,
		    &Cert,
		    pszAlgId,
		    &pbEncoded,
		    &cbEncoded);
    _JumpIfError(hr, error, "EncodeCertAndSign");

    *ppCert = CertCreateCertificateContext(
				    X509_ASN_ENCODING,
				    pbEncoded,
				    cbEncoded);
    if (NULL == *ppCert)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCertificateContext");
    }

    *phProv = hProv;
    hProv = NULL;

    *pstrKeyContainer = strKeyContainer;
    strKeyContainer = NULL;

error:
    if (NULL != hProv)
    {
	CryptReleaseContext(hProv, 0);
    }
    if (NULL != strKeyContainer)
    {
	SysFreeString(strKeyContainer);
    }
    if (NULL != pbEncoded)
    {
        LocalFree(pbEncoded);
    }
    if (NULL != NameBlob.pbData)
    {
        LocalFree(NameBlob.pbData);
    }
    if (NULL != pPubKey)
    {
        LocalFree(pPubKey);
    }
    return(hr);
}
#endif // USE_OLD_DUMMY_SIGNER


HRESULT
BuildCMCExtensions(
    IN DWORD cExt,
    IN CERT_EXTENSION const *rgExt,
    IN DWORD dwCMCDataReference,
    IN DWORD dwBodyPartIdOfRequest,
    IN DWORD dwBodyPartId,
    OUT CMC_TAGGED_ATTRIBUTE *pTaggedAttribute,
    OUT CRYPT_ATTR_BLOB *pBlob)
{
    HRESULT hr;
    CMC_ADD_EXTENSIONS_INFO cmcExt;

    ZeroMemory(&cmcExt, sizeof(cmcExt));
    cmcExt.dwCmcDataReference = dwCMCDataReference;
    if (0 != dwBodyPartIdOfRequest)
    {
	cmcExt.cCertReference = 1;
	cmcExt.rgdwCertReference = &dwBodyPartIdOfRequest;
    }
    cmcExt.cExtension = cExt;
    cmcExt.rgExtension = const_cast<CERT_EXTENSION *>(rgExt);
    pTaggedAttribute->dwBodyPartID = dwBodyPartId;
    pTaggedAttribute->Attribute.pszObjId = szOID_CMC_ADD_EXTENSIONS;
    pTaggedAttribute->Attribute.cValue = 1;
    pTaggedAttribute->Attribute.rgValue = pBlob;

    // Encode CMC_ADD_EXTENSIONS_INFO --> Extensions Blob

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    CMC_ADD_EXTENSIONS,
		    &cmcExt,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pBlob->pbData,
		    &pBlob->cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
BuildCMCAttributes(
    IN DWORD cAttribute,
    IN CRYPT_ATTRIBUTE const *rgAttribute,
    IN DWORD dwCMCDataReference,
    IN DWORD dwBodyPartIdOfRequest,
    IN DWORD dwBodyPartId,
    OUT CMC_TAGGED_ATTRIBUTE *pTaggedAttribute,
    OUT CRYPT_ATTR_BLOB *pBlob)
{
    HRESULT hr;
    CMC_ADD_ATTRIBUTES_INFO cmcAttrib;

    ZeroMemory(&cmcAttrib, sizeof(cmcAttrib));
    cmcAttrib.dwCmcDataReference = dwCMCDataReference;
    if (0 != dwBodyPartIdOfRequest)
    {
	cmcAttrib.cCertReference = 1;
	cmcAttrib.rgdwCertReference = &dwBodyPartIdOfRequest;
    }
    cmcAttrib.cAttribute = cAttribute;
    cmcAttrib.rgAttribute = const_cast<CRYPT_ATTRIBUTE *>(rgAttribute);

    //for (DWORD i = 0; i < cAttribute; i++)
    //{
	//DBGPRINT((DBG_SS_CERTLIBI, "Attr[%d]: %d values\n", i, rgAttribute[i].cValue));
    //}

    pTaggedAttribute->dwBodyPartID = dwBodyPartId;

    // MS proprietary OID: encoded attribute name, value pairs

    pTaggedAttribute->Attribute.pszObjId = szOID_CMC_ADD_ATTRIBUTES;
    pTaggedAttribute->Attribute.cValue = 1;
    pTaggedAttribute->Attribute.rgValue = pBlob;

    // Encode CMC_ADD_ATTRIBUTES_INFO --> Attribute Blob

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    CMC_ADD_ATTRIBUTES,
		    &cmcAttrib,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pBlob->pbData,
		    &pBlob->cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
BuildCMCRegInfo(
    IN CHAR const *pszNameValuePairs,
    //IN DWORD dwCMCDataReference,
    //IN DWORD dwBodyPartIdOfRequest,
    IN DWORD dwBodyPartId,
    OUT CMC_TAGGED_ATTRIBUTE *pTaggedAttribute,
    OUT CRYPT_ATTR_BLOB *pBlob)
{
    HRESULT hr;
    BYTE *pbOctet = NULL;
    CRYPT_DATA_BLOB Blob;
    
    pTaggedAttribute->dwBodyPartID = dwBodyPartId;
    pTaggedAttribute->Attribute.pszObjId = szOID_CMC_REG_INFO;
    pTaggedAttribute->Attribute.cValue = 1;
    pTaggedAttribute->Attribute.rgValue = pBlob;

    // Encode CMC_REG_INFO --> Octet string Blob

    Blob.pbData = (BYTE *) pszNameValuePairs;
    Blob.cbData = strlen(pszNameValuePairs);

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_OCTET_STRING,
		    &Blob,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pBlob->pbData,
		    &pBlob->cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
    hr = S_OK;

error:
    if (NULL != pbOctet)
    {
	LocalFree(pbOctet);
    }
    return(hr);
}


#ifndef WSZARRAYSIZE
#define WSZARRAYSIZE(a)	((sizeof(a)/sizeof((a)[0])) - 1)
#endif

HRESULT
CanonicalizeURLParm(
    IN WCHAR const *pwszParmIn,
    OUT WCHAR **ppwszParmOut)
{
    HRESULT hr;
    WCHAR *pwszUncanon = NULL;
    WCHAR *pwszCanon = NULL;
    static const WCHAR s_wszLdap[] = L"ldap:///";

    *ppwszParmOut = NULL;

    pwszUncanon = (WCHAR *) LocalAlloc(
	LMEM_FIXED,
	(WSZARRAYSIZE(s_wszLdap) + wcslen(pwszParmIn) + 1) * sizeof(WCHAR));
    if (NULL == pwszUncanon)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(pwszUncanon, s_wszLdap);
    wcscat(pwszUncanon, pwszParmIn);

    hr = myInternetCanonicalizeUrl(pwszUncanon, &pwszCanon);
    _JumpIfError(hr, error, "myInternetCanonicalizeUrl");

    hr = myDupString(&pwszCanon[WSZARRAYSIZE(s_wszLdap)], ppwszParmOut);
    _JumpIfError(hr, error, "myDupString");

error:
    if (NULL != pwszUncanon)
    {
	LocalFree(pwszUncanon);
    }
    if (NULL != pwszCanon)
    {
	LocalFree(pwszCanon);
    }
    return(hr);
}


// SeparateNameValuePairs
//
// Separate szOID_ENROLLMENT_NAME_VALUE_PAIR attributes from the rest,
// and construct a URL-style, UTF8-encoded parameter string.

HRESULT
SeparateNameValuePairs(
    IN CRYPT_ATTRIBUTES const *rgAttributes,
    IN DWORD cAttributes,
    OUT CRYPT_ATTRIBUTE **prgAttr,
    OUT DWORD *pcAttr,
    OUT CHAR **ppszNameValuePairs)
{
    HRESULT hr;
    DWORD i;
    DWORD j;
    DWORD k;
    DWORD cAttr;
    DWORD iAttr;
    CRYPT_ATTRIBUTE *rgAttr = NULL;
    CRYPT_ATTRIBUTE *pAttr;
    DWORD cNameValuePair;
    DWORD iNameValuePair;
    CRYPT_ENROLLMENT_NAME_VALUE_PAIR *pNameValuePair = NULL;
    CRYPT_ENROLLMENT_NAME_VALUE_PAIR *rgNameValuePair = NULL;
    CRYPT_ENROLLMENT_NAME_VALUE_PAIR *pnvp;
    DWORD cb;
    WCHAR *pwszNameValuePairs = NULL;
    CHAR *pszNameValuePairs = NULL;
    DWORD cwc;
    
    *prgAttr = NULL;
    *ppszNameValuePairs = NULL;

    // Count the name/value pairs, as well as the rest of the attributes

    cAttr = 0;
    cNameValuePair = 0;
    for (i = 0; i < cAttributes; i++)
    {
	for (j = 0; j < rgAttributes[i].cAttr; j++)
	{
	    pAttr = &rgAttributes[i].rgAttr[j];
	    if (0 == strcmp(szOID_ENROLLMENT_NAME_VALUE_PAIR, pAttr->pszObjId))
	    {
		cNameValuePair += pAttr->cValue;
	    }
	    else
	    {
		cAttr++;
	    }
	}
    }

    // Allocate an array of name/value pair pointers, and an array for the rest
    // of the attributes.

    if (0 != cAttr)
    {
	rgAttr = (CRYPT_ATTRIBUTE *) LocalAlloc(
					LMEM_FIXED,
					cAttr * sizeof(rgAttr[0]));
	if (NULL == rgAttr)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }
    if (0 != cNameValuePair)
    {
	rgNameValuePair = (CRYPT_ENROLLMENT_NAME_VALUE_PAIR *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				cNameValuePair * sizeof(rgNameValuePair[0]));
	if (NULL == rgNameValuePair)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }

    // Decode name/values pairs, canonicalize each URL token, and compute
    // total string length.  Copy other attributes to the allocated array.

    iAttr = 0;
    iNameValuePair = 0;
    cwc = 0;
    for (i = 0; i < cAttributes; i++)
    {
	for (j = 0; j < rgAttributes[i].cAttr; j++)
	{
	    pAttr = &rgAttributes[i].rgAttr[j];
	    if (0 == strcmp(szOID_ENROLLMENT_NAME_VALUE_PAIR, pAttr->pszObjId))
	    {
		for (k = 0; k < pAttr->cValue; k++)
		{
		    if (NULL != pNameValuePair)
		    {
			LocalFree(pNameValuePair);
			pNameValuePair = NULL;
		    }
		    cb = 0;
		    if (!myDecodeObject(
				X509_ASN_ENCODING,
				szOID_ENROLLMENT_NAME_VALUE_PAIR,
				pAttr->rgValue[k].pbData,
				pAttr->rgValue[k].cbData,
				CERTLIB_USE_LOCALALLOC,
				(VOID **) &pNameValuePair,
				&cb))
		    {
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
			_JumpError(hr, error, "myDecodeObject");
		    }
		    if (NULL != pNameValuePair->pwszName &&
			L'\0' != pNameValuePair->pwszName &&
			NULL != pNameValuePair->pwszValue &&
			L'\0' != pNameValuePair->pwszValue)
		    {
			pnvp = &rgNameValuePair[iNameValuePair];

			hr = CanonicalizeURLParm(
				    pNameValuePair->pwszName,
				    &pnvp->pwszName);
			_JumpIfError(hr, error, "CanonicalizeURLParm");

			hr = CanonicalizeURLParm(
				    pNameValuePair->pwszValue,
				    &pnvp->pwszValue);
			_JumpIfError(hr, error, "CanonicalizeURLParm");

			cwc +=
			    wcslen(pnvp->pwszName) +
			    1 +
			    wcslen(pnvp->pwszValue) +
			    1;
			iNameValuePair++;
		    }
		}
	    }
	    else	// copy other attributes
	    {
		rgAttr[iAttr++] = *pAttr;
	    }
	}
    }
    CSASSERT(cAttr == iAttr);
    CSASSERT(cNameValuePair >= iNameValuePair);
    cNameValuePair = iNameValuePair;
    if (0 != cwc)
    {
	pwszNameValuePairs = (WCHAR *) LocalAlloc(
					    LMEM_FIXED,
					    (cwc + 1) * sizeof(WCHAR));
	if (NULL == pwszNameValuePairs)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	*pwszNameValuePairs = L'\0';
	for (i = 0; i < cNameValuePair; i++)
	{
	    pnvp = &rgNameValuePair[i];

	    wcscat(pwszNameValuePairs, pnvp->pwszName);
	    wcscat(pwszNameValuePairs, L"=");
	    wcscat(pwszNameValuePairs, pnvp->pwszValue);
	    wcscat(pwszNameValuePairs, L"&");
	}
	CSASSERT(wcslen(pwszNameValuePairs) == cwc);

	// and construct a URL-style, UTF8-encoded parameter string.

	if (!myConvertWszToUTF8(&pszNameValuePairs, pwszNameValuePairs, -1))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myConvertWszToUTF8");
	}
    }

    *prgAttr = rgAttr;
    rgAttr = NULL;
    *pcAttr = cAttr;

    *ppszNameValuePairs = pszNameValuePairs;
    pszNameValuePairs = NULL;

    hr = S_OK;

error:
    if (NULL != pszNameValuePairs)
    {
	LocalFree(pszNameValuePairs);
    }
    if (NULL != pwszNameValuePairs)
    {
	LocalFree(pwszNameValuePairs);
    }
    if (NULL != rgAttr)
    {
	LocalFree(rgAttr);
    }
    if (NULL != pNameValuePair)
    {
	LocalFree(pNameValuePair);
    }
    if (NULL != rgNameValuePair)
    {
	for (i = 0; i < cNameValuePair; i++)
	{
	    if (NULL != rgNameValuePair[i].pwszName)
	    {
		LocalFree(rgNameValuePair[i].pwszName);
	    }
	    if (NULL != rgNameValuePair[i].pwszValue)
	    {
		LocalFree(rgNameValuePair[i].pwszValue);
	    }
	}
	LocalFree(rgNameValuePair);
    }
    return(hr);
}


HRESULT
BuildCMCRequest(
    IN DWORD dwClientId,
    IN BOOL fNestedCMCRequest,
    IN BYTE const *pbReq,
    IN DWORD cbReq,
    OPTIONAL IN CERT_EXTENSION const *rgExt,
    IN DWORD cExt,
    OPTIONAL IN CRYPT_ATTRIBUTES const *rgAttributes,
    IN DWORD cAttributes,
    OPTIONAL IN CRYPT_ATTRIBUTE const *rgAttributeUnauth,
    IN DWORD cAttributeUnauth,
    OPTIONAL IN BYTE const *pbKeyIdRequest,
    IN DWORD cbKeyIdRequest,
    OPTIONAL IN HCRYPTPROV hProvRequest,
    IN DWORD dwKeySpecRequest,
    OPTIONAL IN LPCSTR pszObjIdHashRequest,
    OPTIONAL IN CERT_CONTEXT const *pCertSigner,
    OPTIONAL IN HCRYPTPROV hProvSigner,
    IN DWORD dwKeySpecSigner,
    OPTIONAL IN LPCSTR pszObjIdHashSigner,
    OUT BYTE **ppbReqCMC,
    OUT DWORD *pcbReqCMC)
{
    HRESULT hr;
    CMC_DATA_INFO cmcData;
    CRYPT_ATTRIBUTE *rgAttr = NULL;
    DWORD cAttr;
    CHAR *pszNameValuePairs = NULL;
    CMC_TAGGED_ATTRIBUTE *rgTaggedAttribute = NULL;
    CMC_TAGGED_ATTRIBUTE *pTaggedAttribute;
    CRYPT_ATTR_BLOB *rgBlob = NULL;
    CRYPT_ATTR_BLOB *pBlob;
    CMC_TAGGED_CERT_REQUEST cmcTaggedCertRequest;
    CMC_TAGGED_REQUEST cmcTaggedRequest;
    CMC_TAGGED_CONTENT_INFO cmcTaggedContentInfo;
    DWORD dwBodyPartId = 1;
    DWORD dwBodyPartIdOfRequest = 0;
    DWORD dwCMCDataReference = 0;
    BYTE *pbCMCContent = NULL;
    DWORD cbCMCContent;
    DWORD i;
    CMSG_SIGNER_ENCODE_INFO aSignerEncodeInfo[2];
    CMSG_SIGNED_ENCODE_INFO SignedMsgEncodeInfo;
    CERT_BLOB aSignerCertBlob[2];
    HCRYPTMSG hMsg = NULL;
    HCRYPTPROV hProvVerify = NULL;

    CRYPT_ATTRIBUTE AttributeRequestClient;
    CRYPT_ATTR_BLOB BlobRequestClient;

    CERT_ISSUER_SERIAL_NUMBER IssuerSerial;
    ZeroMemory(&IssuerSerial, sizeof(IssuerSerial));
    BYTE Zero = 0;
#define BCR_CTAGGEDATTR		3
#define BCR_CBLOB		3

#ifdef USE_OLD_DUMMY_SIGNER
    HCRYPTPROV hProvDummy = NULL;
    BSTR strContainerDummy = NULL;
    CERT_CONTEXT const *pCertDummy = NULL;
    BOOL fSaveDummySignerCert = SAVE_DUMMY_SIGNER;
#endif // USE_OLD_DUMMY_SIGNER
    CERT_CONTEXT const *pCert;
    HCRYPTPROV hProv;
    DWORD dwKeySpec;
    CHAR const *pszObjIdHash;
    CERT_PUBLIC_KEY_INFO *pPubKey = NULL;
    DWORD cbPubKey;

    *ppbReqCMC = NULL;
    ZeroMemory(&cmcData, sizeof(cmcData));
    BlobRequestClient.pbData = NULL;

    if ((NULL == pbKeyIdRequest) ^
	(0 == cbKeyIdRequest) ^
	(NULL == hProvRequest) ^
	(0 == dwKeySpecRequest))
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "request parms inconsistent");
    }
    if (NULL != pszObjIdHashRequest && NULL == hProvRequest)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "request signing OID parm inconsistent");
    }
    if ((NULL == pCertSigner) ^ (NULL == hProvSigner))
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "signer parms inconsistent");
    }

    rgTaggedAttribute = (CMC_TAGGED_ATTRIBUTE *) LocalAlloc(
			    LMEM_FIXED,
			    BCR_CTAGGEDATTR * sizeof(rgTaggedAttribute[0]));
    if (NULL == rgTaggedAttribute)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    cmcData.rgTaggedAttribute = rgTaggedAttribute;
    pTaggedAttribute = rgTaggedAttribute;

    rgBlob = (CRYPT_ATTR_BLOB *) LocalAlloc(
				    LMEM_FIXED | LMEM_ZEROINIT,
				    BCR_CBLOB * sizeof(rgBlob[0]));
    if (NULL == rgBlob)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    pBlob = rgBlob;

    if (fNestedCMCRequest)
    {
	dwCMCDataReference = dwBodyPartId++;

	// cmcData.rgTaggedContentInfo[0] = Nested CMC request 

	ZeroMemory(&cmcTaggedContentInfo, sizeof(cmcTaggedContentInfo));
	cmcData.cTaggedContentInfo = 1;
	cmcData.rgTaggedContentInfo = &cmcTaggedContentInfo;

	cmcTaggedContentInfo.dwBodyPartID = dwCMCDataReference;
	cmcTaggedContentInfo.EncodedContentInfo.pbData = const_cast<BYTE *>(pbReq);
	cmcTaggedContentInfo.EncodedContentInfo.cbData = cbReq;
    }
    else
    {
	// possibly unsigned PKCS10

	dwBodyPartIdOfRequest = dwBodyPartId++;

	// cmcData.rgTaggedRequest[0] = PKCS10 request

	ZeroMemory(&cmcTaggedRequest, sizeof(cmcTaggedRequest));
	ZeroMemory(&cmcTaggedCertRequest, sizeof(cmcTaggedCertRequest));

	cmcData.cTaggedRequest = 1;
	cmcData.rgTaggedRequest = &cmcTaggedRequest;
	cmcTaggedRequest.dwTaggedRequestChoice = CMC_TAGGED_CERT_REQUEST_CHOICE;
	cmcTaggedRequest.pTaggedCertRequest = &cmcTaggedCertRequest;

	cmcTaggedCertRequest.dwBodyPartID = dwBodyPartIdOfRequest;
	cmcTaggedCertRequest.SignedCertRequest.pbData = const_cast<BYTE *>(pbReq);
	cmcTaggedCertRequest.SignedCertRequest.cbData = cbReq;
    }

    // *pTaggedAttribute++ = Collected Extensions

    if (0 != cExt)
    {
	CSASSERT(
	    pTaggedAttribute <
	    &rgTaggedAttribute[BCR_CTAGGEDATTR + cAttributes);
	CSASSERT(pBlob < &rgBlob[BCR_CBLOB + cAttributes);

	hr = BuildCMCExtensions(
			cExt,
			rgExt,
			dwCMCDataReference,
			dwBodyPartIdOfRequest,
			dwBodyPartId,
			pTaggedAttribute,
			pBlob);
	_JumpIfError(hr, error, "BuildCMCExtensions");

	dwBodyPartId++;
	cmcData.cTaggedAttribute++;
	pTaggedAttribute++;
	pBlob++;
    }

    // *pTaggedAttribute++ = Collected Request Attributes

    if (0 != cAttributes)
    {
	hr = SeparateNameValuePairs(
			    rgAttributes,
			    cAttributes,
			    &rgAttr,
			    &cAttr,
			    &pszNameValuePairs);
	_JumpIfError(hr, error, "SeparateNameValuePairs");

	if (0 != cAttr)
	{
	    CSASSERT(
		pTaggedAttribute <
		&rgTaggedAttribute[BCR_CTAGGEDATTR + cAttributes);
	    CSASSERT(pBlob < &rgBlob[BCR_CBLOB + cAttributes);

	    hr = BuildCMCAttributes(
			    cAttr,
			    rgAttr,
			    dwCMCDataReference,
			    dwBodyPartIdOfRequest,
			    dwBodyPartId,
			    pTaggedAttribute,
			    pBlob);
	    _JumpIfError(hr, error, "BuildCMCAttributes");

	    dwBodyPartId++;
	    cmcData.cTaggedAttribute++;
	    pTaggedAttribute++;
	    pBlob++;
	}
	if (NULL != pszNameValuePairs)
	{
	    CSASSERT(
		pTaggedAttribute <
		&rgTaggedAttribute[BCR_CTAGGEDATTR + cAttributes);
	    CSASSERT(pBlob < &rgBlob[BCR_CBLOB + cAttributes);

	    hr = BuildCMCRegInfo(
			    pszNameValuePairs,
			    //dwCMCDataReference,
			    //dwBodyPartIdOfRequest,
			    dwBodyPartId,
			    pTaggedAttribute,
			    pBlob);
	    _JumpIfError(hr, error, "BuildCMCRegInfo");

	    dwBodyPartId++;
	    cmcData.cTaggedAttribute++;
	    pTaggedAttribute++;
	    pBlob++;
	}
    }

    // Encode CMC_DATA_INFO --> CMC Request Blob

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    CMC_DATA,
		    &cmcData,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pbCMCContent,
		    &cbCMCContent))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
    if (XECI_DISABLE != dwClientId)
    {
	hr = myEncodeRequestClientAttributeFromClientId(
					    dwClientId,
					    &BlobRequestClient.pbData,
					    &BlobRequestClient.cbData);
	_JumpIfError(hr, error, "myEncodeRequestClientAttributeFromClientId");

	AttributeRequestClient.pszObjId = szOID_REQUEST_CLIENT_INFO;
	AttributeRequestClient.cValue = 1;
	AttributeRequestClient.rgValue = &BlobRequestClient;
    }

    pCert = NULL;
    hProv = hProvRequest;
    dwKeySpec = dwKeySpecRequest;
    pszObjIdHash = pszObjIdHashRequest;

    if (NULL == hProvRequest && NULL == pbKeyIdRequest)
    {
#ifdef USE_OLD_DUMMY_SIGNER
	hr = EncodeDummyCert(&hProvDummy, &strContainerDummy, &pCertDummy);
	_JumpIfError(hr, error, "EncodeDummyCert");

	pCert = pCertDummy;
	hProv = hProvDummy;
	dwKeySpec = AT_SIGNATURE;
	pszObjIdHash = pszObjIdHashSigner;
#else
	// Fake up the NULL signature Signer info

	CERT_RDN_ATTR rdnAttr;
	CERT_RDN rdn;
	CERT_NAME_INFO NameInfo;
	
	NameInfo.cRDN = 1;
	NameInfo.rgRDN = &rdn;
	rdn.cRDNAttr = 1;
	rdn.rgRDNAttr = &rdnAttr;
	rdnAttr.pszObjId = szOID_RDN_DUMMY_SIGNER;
	rdnAttr.dwValueType = 0;
	rdnAttr.Value.pbData = (BYTE *) wszDUMMYSIGNER;
	rdnAttr.Value.cbData = 0;

	if (!myEncodeObject(
			X509_ASN_ENCODING,
			X509_UNICODE_NAME,
			&NameInfo,
			0,
			CERTLIB_USE_LOCALALLOC,
			&IssuerSerial.Issuer.pbData,
			&IssuerSerial.Issuer.cbData))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myEncodeObject");
	}
	IssuerSerial.SerialNumber.pbData = &Zero;
	IssuerSerial.SerialNumber.cbData = sizeof(Zero);
#endif // USE_OLD_DUMMY_SIGNER
    }

    ZeroMemory(aSignerEncodeInfo, sizeof(aSignerEncodeInfo));
    ZeroMemory(&SignedMsgEncodeInfo, sizeof(SignedMsgEncodeInfo));
    SignedMsgEncodeInfo.cbSize = sizeof(SignedMsgEncodeInfo);
    SignedMsgEncodeInfo.rgSigners = aSignerEncodeInfo;
    //SignedMsgEncodeInfo.cCrlEncoded = 0;
    //SignedMsgEncodeInfo.rgCrlEncoded = NULL;

    // Encode CMC content into a PKCS 7, signed by the request's private key
    // if available, otherwise use a NULL signature.
    // Initialize the CMSG_SIGNER_ENCODE_INFO structure for one signer.
    // If the optional pCertSigner is non-NULL, add a second signature.

    for (i = 0; i < 2; i++)
    {
	CMSG_SIGNER_ENCODE_INFO *pSignerEncodeInfo = &aSignerEncodeInfo[i];
	CRYPT_OID_INFO const *pOIDInfo;
	CHAR const *pszObjIdPubKey;
	BOOL fDSSKey;
	
	pSignerEncodeInfo->cbSize = sizeof(*pSignerEncodeInfo);
	if (NULL != pCert)
	{
	    pSignerEncodeInfo->pCertInfo = pCert->pCertInfo;

	    aSignerCertBlob[SignedMsgEncodeInfo.cCertEncoded].cbData = pCert->cbCertEncoded;
	    aSignerCertBlob[SignedMsgEncodeInfo.cCertEncoded].pbData = pCert->pbCertEncoded;

	    SignedMsgEncodeInfo.rgCertEncoded = aSignerCertBlob;
	    SignedMsgEncodeInfo.cCertEncoded++;
	}
	if (XECI_DISABLE != dwClientId)
	{
	    pSignerEncodeInfo->cAuthAttr = 1;
	    pSignerEncodeInfo->rgAuthAttr = &AttributeRequestClient;
	}
	pSignerEncodeInfo->HashAlgorithm.pszObjId =
		NULL != pszObjIdHash?
		    const_cast<CHAR *>(pszObjIdHash) : szOID_OIWSEC_sha1;

	if (NULL != pCert)
	{
	    pszObjIdPubKey = pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId;
	}
	else if (NULL != hProv)
	{
	    CSASSERT(0 == i);
	    CSASSERT(NULL == pPubKey);
	    if (!myCryptExportPublicKeyInfo(
				    hProv,
				    dwKeySpec,
				    CERTLIB_USE_LOCALALLOC,
				    &pPubKey,
				    &cbPubKey))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "myCryptExportPublicKeyInfo");
	    }
	    pszObjIdPubKey = pPubKey->Algorithm.pszObjId;
	}
	else
	{
	    pszObjIdPubKey = szOID_PKIX_NO_SIGNATURE;
	    if (NULL == hProvVerify)
	    {
		if (!CryptAcquireContextW(
				    &hProvVerify,
				    NULL,	// pwszContainer
				    NULL,	// pwszProvName
				    PROV_RSA_FULL,
				    CRYPT_VERIFYCONTEXT)) // dwFlags
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "CryptAcquireContextW");
		}
	    }
	    hProv = hProvVerify;
	    dwKeySpec = AT_SIGNATURE;
	}
	pSignerEncodeInfo->hCryptProv = hProv;
	pSignerEncodeInfo->dwKeySpec = dwKeySpec;

	fDSSKey = FALSE;
#ifdef _XENROLL_SRC_
	pOIDInfo = xeCryptFindOIDInfo(
#else
	pOIDInfo = CryptFindOIDInfo(
#endif
				CRYPT_OID_INFO_OID_KEY,
				const_cast<CHAR *>(pszObjIdPubKey),
				CRYPT_PUBKEY_ALG_OID_GROUP_ID);
	if (NULL != pOIDInfo && CALG_DSS_SIGN == pOIDInfo->Algid)
	{
	    pszObjIdPubKey = szOID_X957_SHA1DSA;
	    fDSSKey = TRUE;
	}

	if (NULL == pCert || fDSSKey)
	{
	    pSignerEncodeInfo->HashEncryptionAlgorithm.pszObjId = const_cast<CHAR *>(pszObjIdPubKey);
	}
	if (NULL == pCert)
	{
	    if (NULL == pbKeyIdRequest)
	    {
		pSignerEncodeInfo->SignerId.dwIdChoice = CERT_ID_ISSUER_SERIAL_NUMBER;
		pSignerEncodeInfo->SignerId.IssuerSerialNumber = IssuerSerial;
	    }
	    else
	    {
		pSignerEncodeInfo->SignerId.dwIdChoice = CERT_ID_KEY_IDENTIFIER;
		pSignerEncodeInfo->SignerId.KeyId.cbData = cbKeyIdRequest;
		pSignerEncodeInfo->SignerId.KeyId.pbData = const_cast<BYTE *>(pbKeyIdRequest);
	    }
	}
	SignedMsgEncodeInfo.cSigners++;

	if (NULL == pCertSigner)
	{
	    break;
	}
	pCert = pCertSigner;
	hProv = hProvSigner;
	dwKeySpec = dwKeySpecSigner;
	pszObjIdHash = pszObjIdHashSigner;
    }

    // Unauthenticated attributes are attached to the first signature ONLY!

    aSignerEncodeInfo[0].cUnauthAttr = cAttributeUnauth;
    aSignerEncodeInfo[0].rgUnauthAttr = const_cast<CRYPT_ATTRIBUTE *>(rgAttributeUnauth);

    hMsg = CryptMsgOpenToEncode(
		PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
		CMSG_CMS_ENCAPSULATED_CONTENT_FLAG,	// dwFlags
		CMSG_SIGNED,
		&SignedMsgEncodeInfo,
		szOID_CT_PKI_DATA,
		NULL);				// pStreamInfo
    if (NULL == hMsg)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptMsgOpenToEncode");
    }

    // Update the message with the CMC content

    if (!CryptMsgUpdate(hMsg, pbCMCContent, cbCMCContent, TRUE))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptMsgUpdate");
    }

    // Return the encoded and signed content.
    // Use CMSG_CONTENT_PARAM to get the signed message.

    hr = myCryptMsgGetParam(
		    hMsg,
		    CMSG_CONTENT_PARAM,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) ppbReqCMC,
		    pcbReqCMC);
    _JumpIfError(hr, error, "myCryptMsgGetParam");

error:
    if (NULL != hMsg)
    {
	CryptMsgClose(hMsg); //make sure close before hProv release
    }
    if (NULL != rgAttr)
    {
	LocalFree(rgAttr);
    }
    if (NULL != pszNameValuePairs)
    {
	LocalFree(pszNameValuePairs);
    }
    if (NULL != IssuerSerial.Issuer.pbData)
    {
	LocalFree(IssuerSerial.Issuer.pbData);
    }
    if (NULL != hProvVerify)
    {
	CryptReleaseContext(hProvVerify, 0);
    }
    if (NULL != BlobRequestClient.pbData)
    {
	LocalFree(BlobRequestClient.pbData);
    }
#ifdef USE_OLD_DUMMY_SIGNER
    DestroyDummyCert(
		hProvDummy,
		strContainerDummy,
		pCertDummy,
		fSaveDummySignerCert);
#endif // USE_OLD_DUMMY_SIGNER
    if (NULL != rgBlob)
    {
	for (i = 0; i < BCR_CBLOB; i++)
	{
	    if (NULL != rgBlob[i].pbData)
	    {
		LocalFree(rgBlob[i].pbData);
	    }
	}
	LocalFree(rgBlob);
    }
    if (NULL != rgTaggedAttribute)
    {
	LocalFree(rgTaggedAttribute);
    }
    if (NULL != pbCMCContent)
    {
	LocalFree(pbCMCContent);
    }
    if (NULL != pPubKey)
    {
	LocalFree(pPubKey);
    }
    return(hr);
}


VOID
FreeCMCResponse(
    IN XCMCRESPONSE *rgResponse,
    IN DWORD cResponse)
{
    DWORD i;
    
    if (NULL != rgResponse)
    {
	for (i = 0; i < cResponse; i++)
	{
	    XCMCRESPONSE *pResponse = &rgResponse[i];

	    if (CMC_OTHER_INFO_PEND_CHOICE ==
		pResponse->StatusInfo.dwOtherInfoChoice &&
		NULL != pResponse->StatusInfo.pPendInfo)
	    {
		if (NULL != pResponse->StatusInfo.pPendInfo->PendToken.pbData)
		{
		    LocalFree(pResponse->StatusInfo.pPendInfo->PendToken.pbData);
		}
		LocalFree(pResponse->StatusInfo.pPendInfo);
	    }
	    if (NULL != pResponse->StatusInfo.pwszStatusString)
	    {
		LocalFree(pResponse->StatusInfo.pwszStatusString);
	    }
	    if (NULL != pResponse->pbCertHash)
	    {
		LocalFree(pResponse->pbCertHash);
	    }
	    if (NULL != pResponse->pbEncryptedKeyHash)
	    {
		LocalFree(pResponse->pbEncryptedKeyHash);
	    }
	    if (NULL != pResponse->pwszBodyPart)
	    {
		LocalFree(pResponse->pwszBodyPart);
	    }
	}
	LocalFree(rgResponse);
    }
}


HRESULT
_AppendBodyPart(
    IN OUT WCHAR *pwszBodyPartBuffer,
    IN DWORD cwcBodyPartBuffer,
    IN DWORD cwcPrefix,
    IN DWORD dwBodyPart)
{
    HRESULT hr;
    WCHAR awc[14];	// L".%u"

    if (cwcBodyPartBuffer <=
	cwcPrefix +
	wsprintfW(awc, L".%u", dwBodyPart))
//	wsprintf(awc, L".%u", dwBodyPart))
    {
	hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
	_JumpError(hr, error, "pwszBodyPartBuffer");
    }
    wcscpy(&pwszBodyPartBuffer[cwcPrefix], awc);
//    DBGPRINT((DBG_SS_CERTLIBI, "BodyPartString: %ws\n", &pwszBodyPartBuffer[1]));
    hr = S_OK;

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// _SaveCMCStatus -- Save CMC Status Info
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
_SaveCMCStatus(
    IN BYTE *pbIn,
    IN DWORD cbIn,
    IN OUT WCHAR *pwszBodyPartBuffer,
    IN DWORD cwcBodyPartBuffer,
    IN OUT XCMCRESPONSE **prgResponse,
    IN OUT DWORD *pcResponse)
{
    HRESULT hr;
    DWORD i;
    DWORD cwcPrefix;
    CMC_STATUS_INFO *pcmcStatus = NULL;
    XCMCRESPONSE *pResponse;
    DWORD cb;
    WCHAR *pwszBodyPartT = NULL;
    WCHAR *pwszStatusStringT = NULL;
    BYTE *pbToken = NULL;

    cwcPrefix = wcslen(pwszBodyPartBuffer);
    
    // Decode CMC_STATUS_INFO from Attribute Blob

    CSASSERT(NULL == pcmcStatus);
    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    CMC_STATUS,
		    pbIn,
		    cbIn,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pcmcStatus,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }

    for (i = 0; i < pcmcStatus->cBodyList; i++)
    {
	hr = _AppendBodyPart(
			pwszBodyPartBuffer,
			cwcBodyPartBuffer,
			cwcPrefix,
			pcmcStatus->rgdwBodyList[i]);
	_JumpIfError(hr, error, "_AppendBodyPart");

#if 0
	DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "  Status: %u\n",
	    pcmcStatus->dwStatus));

	if (NULL != pcmcStatus->pwszStatusString)
	{
	    DBGPRINT((
		DBG_SS_CERTLIBI,
		"  StatusString: %ws\n",
		pcmcStatus->pwszStatusString));
	}

	DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "  OtherInfoChoice: %u\n",
	    pcmcStatus->dwOtherInfoChoice));
#endif //0

	if (CMC_OTHER_INFO_PEND_CHOICE == pcmcStatus->dwOtherInfoChoice)
	{
	    //pcmcStatus->pPendInfo->PendToken.pbData
	    //pcmcStatus->pPendInfo->PendToken.cbData
	    //pcmcStatus->pPendInfo->PendTime
	}
	if (0 == *pcResponse)
	{
	    pResponse = (XCMCRESPONSE *) LocalAlloc(
				    LMEM_FIXED | LMEM_ZEROINIT,
				    sizeof(**prgResponse));
	}
	else
	{
	    pResponse = (XCMCRESPONSE *) LocalReAlloc(
				    *prgResponse,
				    (1 + *pcResponse) * sizeof(**prgResponse),
				    LMEM_MOVEABLE | LMEM_ZEROINIT);
	}
	if (NULL == pResponse)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, 0 == *pcResponse? "LocalAlloc" : "LocalReAlloc");
	}
	*prgResponse = pResponse;
	pResponse += *pcResponse;

	pResponse->StatusInfo.dwStatus = pcmcStatus->dwStatus;
	pResponse->StatusInfo.cBodyList = pcmcStatus->rgdwBodyList[i];
	pResponse->StatusInfo.dwOtherInfoChoice = pcmcStatus->dwOtherInfoChoice;

	if (CMC_OTHER_INFO_FAIL_CHOICE == pcmcStatus->dwOtherInfoChoice)
	{
	    pResponse->StatusInfo.dwFailInfo = pcmcStatus->dwFailInfo;
	}

	hr = myDupString(&pwszBodyPartBuffer[1], &pwszBodyPartT);
	_JumpIfError(hr, error, "myDupString");

	if (NULL != pcmcStatus->pwszStatusString)
	{
	    hr = myDupString(pcmcStatus->pwszStatusString, &pwszStatusStringT);
	    _JumpIfError(hr, error, "myDupString");
	}

	if (CMC_OTHER_INFO_PEND_CHOICE == pcmcStatus->dwOtherInfoChoice &&
	    NULL != pcmcStatus->pPendInfo)
	{
	    if (NULL != pcmcStatus->pPendInfo->PendToken.pbData &&
		0 != pcmcStatus->pPendInfo->PendToken.cbData)
	    {
		pbToken = (BYTE *) LocalAlloc(
				    LMEM_FIXED,
				    pcmcStatus->pPendInfo->PendToken.cbData);
		if (NULL == pbToken)
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "LocalAlloc");
		}
		CopyMemory(
			pbToken,
			pcmcStatus->pPendInfo->PendToken.pbData,
			pcmcStatus->pPendInfo->PendToken.cbData);
	    }
	    pResponse->StatusInfo.pPendInfo = (CMC_PEND_INFO *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				sizeof(*pResponse->StatusInfo.pPendInfo));
	    if (NULL == pResponse->StatusInfo.pPendInfo)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }

	    // Can't fail now.

	    pResponse->StatusInfo.pPendInfo->PendTime =
		pcmcStatus->pPendInfo->PendTime;

	    if (NULL != pbToken)
	    {
		pResponse->StatusInfo.pPendInfo->PendToken.pbData = pbToken;
		pResponse->StatusInfo.pPendInfo->PendToken.cbData =
		    pcmcStatus->pPendInfo->PendToken.cbData;
		pbToken = NULL;
	    }
	}
	pResponse->pwszBodyPart = pwszBodyPartT;
	pwszBodyPartT = NULL;

	pResponse->StatusInfo.pwszStatusString = pwszStatusStringT;
	pwszStatusStringT = NULL;

	(*pcResponse)++;
    }
    hr = S_OK;

error:
    pwszBodyPartBuffer[cwcPrefix] = L'\0';
    if (NULL != pwszBodyPartT)
    {
	LocalFree(pwszBodyPartT);
    }
    if (NULL != pwszStatusStringT)
    {
	LocalFree(pwszStatusStringT);
    }
    if (NULL != pbToken)
    {
	LocalFree(pbToken);
    }
    if (NULL != pcmcStatus)
    {
	LocalFree(pcmcStatus);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// _SaveCertHashInResponse -- Save cert hash to response array
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
_SaveCertHashInResponse(
    IN BYTE const *pbCertHash,
    IN DWORD cbCertHash,
    IN WCHAR const *pwszBodyPart,
    IN OUT XCMCRESPONSE *rgResponse,
    IN DWORD cResponse,
    IN BOOL fCertHash)
{
    HRESULT hr;
    DWORD i;
    
    for (i = 0; i < cResponse; i++)
    {
	XCMCRESPONSE *pResponse = &rgResponse[i];

	if (0 == lstrcmpW(pwszBodyPart, pResponse->pwszBodyPart))
	{
	    BYTE **ppbHash = fCertHash?
		    &pResponse->pbCertHash : &pResponse->pbEncryptedKeyHash;
	    DWORD *pcbHash = fCertHash?
		    &pResponse->cbCertHash : &pResponse->cbEncryptedKeyHash;

	    if (NULL != *ppbHash)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpError(hr, error, "hash already set");
	    }
	    *ppbHash = (BYTE *) LocalAlloc(LMEM_FIXED, cbCertHash);
	    if (NULL == *ppbHash)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    *pcbHash = cbCertHash;
	    CopyMemory(*ppbHash, pbCertHash, cbCertHash);
	    break;
	}
    }
    if (i >= cResponse)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "unknown hash");
    }
    hr = S_OK;

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// _SaveCMCCertHash -- Save CMC cert hash from attributes
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

#define BLOB_ROUND(cb) \
	(((cb) + sizeof(CRYPT_DATA_BLOB) - 1) / sizeof(CRYPT_DATA_BLOB))

HRESULT
_SaveCMCCertHash(
    IN BYTE *pbIn,
    IN DWORD cbIn,
    IN OUT WCHAR *pwszBodyPartBuffer,
    IN DWORD cwcBodyPartBuffer,
    IN OUT XCMCRESPONSE *rgResponse,
    IN OUT DWORD cResponse)
{
    HRESULT hr;
    CMC_ADD_ATTRIBUTES_INFO *pcmcAttrib = NULL;
    CRYPT_ATTRIBUTE const *pAttr;
    CRYPT_ATTRIBUTE const *pAttrEnd;
    CRYPT_DATA_BLOB aBlob[1 + BLOB_ROUND(CBMAX_CRYPT_HASH_LEN)];
    DWORD cb;
    DWORD cwcPrefix;

    cwcPrefix = wcslen(pwszBodyPartBuffer);

    // Decode CMC_ADD_ATTRIBUTES_INFO from Attribute Blob

    CSASSERT(NULL == pcmcAttrib);
    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    CMC_ADD_ATTRIBUTES,
		    pbIn,
		    cbIn,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pcmcAttrib,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }
    if (0 != pcmcAttrib->dwCmcDataReference)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "pcmcAttrib->dwCmcDataReference");
    }

    pAttrEnd = &pcmcAttrib->rgAttribute[pcmcAttrib->cAttribute];
    for (pAttr = pcmcAttrib->rgAttribute; pAttr < pAttrEnd; pAttr++)
    {
	BOOL fCertHash = 0 == strcmp(pAttr->pszObjId, szOID_ISSUED_CERT_HASH);

	if (fCertHash ||
	    0 == strcmp(pAttr->pszObjId, szOID_ENCRYPTED_KEY_HASH))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    if (1 != pAttr->cValue)
	    {
		_JumpError(hr, error, "pAttr->cValue");
	    }
	    if (1 != pcmcAttrib->cCertReference)
	    {
		_JumpError(hr, error, "pcmcAttrib->dwCmcDataReference");
	    }
	    hr = _AppendBodyPart(
			    pwszBodyPartBuffer,
			    cwcBodyPartBuffer,
			    cwcPrefix,
			    pcmcAttrib->rgdwCertReference[0]);
	    _JumpIfError(hr, error, "_AppendBodyPart");

	    cb = sizeof(aBlob);
	    if (!CryptDecodeObject(
			    X509_ASN_ENCODING,
			    X509_OCTET_STRING,
			    pAttr->rgValue[0].pbData,
			    pAttr->rgValue[0].cbData,
			    0,
			    aBlob,
			    &cb))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "myDecodeObject");
	    }
	    hr = _SaveCertHashInResponse(
			    aBlob[0].pbData,
			    aBlob[0].cbData,
			    &pwszBodyPartBuffer[1],
			    rgResponse,
			    cResponse,
			    fCertHash);
	    _JumpIfError(hr, error, "SaveCertHashInResponse");
	}
    }
    hr = S_OK;

error:
    pwszBodyPartBuffer[cwcPrefix] = L'\0';
    if (NULL != pcmcAttrib)
    {
	LocalFree(pcmcAttrib);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// _DecodeCMCTaggedAttributes -- Decode CMC Tagged Attributes
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
_DecodeCMCTaggedAttributes(
    IN DWORD cTaggedAttribute,
    IN CMC_TAGGED_ATTRIBUTE const *rgTaggedAttribute,
    IN OUT WCHAR *pwszBodyPartBuffer,
    IN DWORD cwcBodyPartBuffer,
    IN OUT XCMCRESPONSE **prgResponse,
    IN OUT DWORD *pcResponse)
{
    HRESULT hr;
    DWORD i;
    CRYPT_ATTRIBUTE const *pAttribute;
    DWORD j;

    for (i = 0; i < cTaggedAttribute; i++)
    {
	pAttribute = &rgTaggedAttribute[i].Attribute;

	for (j = 0; j < pAttribute->cValue; j++)
	{
	    if (0 == strcmp(szOID_CMC_STATUS_INFO, pAttribute->pszObjId))
	    {
		hr = _SaveCMCStatus(
			    pAttribute->rgValue[j].pbData,
			    pAttribute->rgValue[j].cbData,
			    pwszBodyPartBuffer,
			    cwcBodyPartBuffer,
			    prgResponse,
			    pcResponse);
		_JumpIfError(hr, error, "_SaveCMCStatus");
	    }
	}
    }
    for (i = 0; i < cTaggedAttribute; i++)
    {
	pAttribute = &rgTaggedAttribute[i].Attribute;

	for (j = 0; j < pAttribute->cValue; j++)
	{
	    if (0 == strcmp(szOID_CMC_ADD_ATTRIBUTES, pAttribute->pszObjId))
	    {
		hr = _SaveCMCCertHash(
			    pAttribute->rgValue[j].pbData,
			    pAttribute->rgValue[j].cbData,
			    pwszBodyPartBuffer,
			    cwcBodyPartBuffer,
			    *prgResponse,
			    *pcResponse);
		_JumpIfError(hr, error, "_SaveCMCCertHash");
	    }
	}
    }
    hr = S_OK;

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// _DecodeCMCResponse -- Decode a CMC Response Message
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
_DecodeCMCResponse(
    IN BYTE *pbIn,
    IN DWORD cbIn,
    IN OUT WCHAR *pwszBodyPartBuffer,
    IN DWORD cwcBodyPartBuffer,
    IN OUT XCMCRESPONSE **prgResponse,
    IN OUT DWORD *pcResponse)
{
    HRESULT hr;
    CMC_RESPONSE_INFO *pcmcResponse = NULL;
    DWORD cbcmcResponse;

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    CMC_RESPONSE,
		    pbIn,
		    cbIn,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pcmcResponse,
		    &cbcmcResponse))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }

    hr = _DecodeCMCTaggedAttributes(
			pcmcResponse->cTaggedAttribute,
			pcmcResponse->rgTaggedAttribute,
			pwszBodyPartBuffer,
			cwcBodyPartBuffer,
			prgResponse,
			pcResponse);
    _JumpIfError(hr, error, "_DecodeTaggedAttributes");

#if 0
    hr = _DecodeTaggedContent(
			pcmcResponse->cTaggedContentInfo,
			pcmcResponse->rgTaggedContentInfo);
    _JumpIfError(hr, error, "_DecodeTaggedContent");

    hr = _DecodeTaggedOther(
			pcmcResponse->cTaggedOtherMsg,
			pcmcResponse->rgTaggedOtherMsg);
    _JumpIfError(hr, error, "_DecodeTaggedOther");
#endif

error:
    if (NULL != pcmcResponse)
    {
        LocalFree(pcmcResponse);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// ParseCMCResponse -- Decode a Full Response Message
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
ParseCMCResponse(
    IN BYTE *pbResponse,
    IN DWORD cbResponse,
    OPTIONAL OUT HCERTSTORE *phStoreResponse,
    OUT XCMCRESPONSE **prgResponse,
    OUT DWORD *pcResponse)
{
    HRESULT hr;
    DWORD dwMsgType;
    char *pszInnerContentObjId = NULL;
    BYTE *pbContents = NULL;
    DWORD cbContents;
    HCERTSTORE hStore = NULL;
    WCHAR awcBodyPartBuffer[MAX_PATH];

    if (NULL != phStoreResponse)
    {
	*phStoreResponse = NULL;
    }
    *prgResponse = NULL;
    *pcResponse = 0;

    // Decode outer PKCS 7 signed message, which contains all of the certs.

    hr = myDecodePKCS7(
		    pbResponse,
		    cbResponse,
		    &pbContents,
		    &cbContents,
		    &dwMsgType,
		    &pszInnerContentObjId,
		    NULL,		// &cSigner,
		    NULL,		// &cRecipient,
		    &hStore,
		    NULL);		// phMsg
    _JumpIfError(hr, error, "myDecodePKCS7(outer)");

    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    if (CMSG_SIGNED != dwMsgType)
    {
	_JumpError(hr, error, "dwMsgType");
    }
    if (NULL == pszInnerContentObjId ||
	0 != strcmp(pszInnerContentObjId, szOID_CT_PKI_RESPONSE))
    {
	_JumpError(hr, error, "pszInnerContentObjId");
    }
    awcBodyPartBuffer[0] = L'\0';
    hr = _DecodeCMCResponse(
		    pbContents,
		    cbContents,
		    awcBodyPartBuffer,
		    ARRAYSIZE(awcBodyPartBuffer),
		    prgResponse,
		    pcResponse);
    _JumpIfError(hr, error, "_DecodeCMCResponse");

    if (NULL != phStoreResponse)
    {
	*phStoreResponse = hStore;
	hStore = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pbContents)
    {
        LocalFree(pbContents);
    }
    if (NULL != pszInnerContentObjId)
    {
        LocalFree(pszInnerContentObjId);
    }
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


HRESULT
myCryptMsgGetParam(
    IN HCRYPTMSG hMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    IN CERTLIB_ALLOCATOR allocType,
    OUT VOID **ppvData,
    OUT DWORD *pcbData)
{
    HRESULT hr;
    VOID *pvData = NULL;

    *ppvData = NULL;
    *pcbData = 0;
    if (!CryptMsgGetParam(
		    hMsg,
		    dwParamType,
		    dwIndex,
		    NULL,
		    pcbData))
    {
	hr = myHLastError();
	if (CRYPT_E_ATTRIBUTES_MISSING == hr || CRYPT_E_INVALID_INDEX == hr)
	{
	    hr = S_FALSE;
	}
//	_JumpError2(hr, error, "CryptMsgGetParam", S_FALSE);
	_JumpError(hr, error, "CryptMsgGetParam");
    }

    pvData = myAlloc(*pcbData, allocType);
    if (NULL == pvData)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    ZeroMemory(pvData, *pcbData);

    if (!CryptMsgGetParam(
		    hMsg,
		    dwParamType,
		    dwIndex,
		    pvData,
		    pcbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptMsgGetParam");
    }

    *ppvData = pvData;
    pvData = NULL;
    hr = S_OK;

error:
    if (NULL != pvData)
    {
	LocalFree(pvData);
    }
    return(hr);
}


HRESULT
myEncodeUTF8String(
    IN WCHAR const *pwszIn,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut)
{
    HRESULT hr;
    CERT_NAME_VALUE cnv;

    *ppbOut = NULL;

    cnv.dwValueType = CERT_RDN_UTF8_STRING;
    cnv.Value.pbData = (BYTE *) pwszIn;
    cnv.Value.cbData = 0;

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_UNICODE_ANY_STRING,
		    &cnv,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    ppbOut,
		    pcbOut))
    {
	hr = myHLastError();
	_JumpIfError(hr, error, "myEncodeObject");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myDecodeUTF8String(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT WCHAR **ppwszOut)
{
    HRESULT hr;
    CERT_NAME_VALUE *pNameValue = NULL;
    DWORD cb;

    *ppwszOut = NULL;

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_UNICODE_ANY_STRING,
		    pbIn,
		    cbIn,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pNameValue,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }
    if (NULL != pNameValue->Value.pbData)
    {
	hr = myDupString((WCHAR *) pNameValue->Value.pbData, ppwszOut);
	_JumpIfError(hr, error, "myDupString");
    }
    hr = S_OK;

error:
    if (NULL != pNameValue)
    {
	LocalFree(pNameValue);
    }
    return(hr);
}


HRESULT
myEncodeRequestClientAttribute(
    IN CRYPT_REQUEST_CLIENT_INFO const *pcrci,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut)
{
    HRESULT hr;
    CRYPT_DER_BLOB aBlob[4];
    CRYPT_SEQUENCE_OF_ANY Sequence;
    DWORD i;

    ZeroMemory(aBlob, sizeof(aBlob));

    Sequence.cValue = ARRAYSIZE(aBlob);
    Sequence.rgValue = aBlob;

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_INTEGER,
		    &pcrci->dwClientId,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &aBlob[0].pbData,
		    &aBlob[0].cbData))
    {
	hr = myHLastError();
	_JumpIfError(hr, error, "myEncodeObject");
    }
    hr = myEncodeUTF8String(
		    pcrci->pwszMachine,
		    &aBlob[1].pbData,
		    &aBlob[1].cbData);
    _JumpIfError(hr, error, "myEncodeUTF8String");

    hr = myEncodeUTF8String(
		    pcrci->pwszUser,
		    &aBlob[2].pbData,
		    &aBlob[2].cbData);
    _JumpIfError(hr, error, "myEncodeUTF8String");

    hr = myEncodeUTF8String(
		    pcrci->pwszProcess,
		    &aBlob[3].pbData,
		    &aBlob[3].cbData);
    _JumpIfError(hr, error, "myEncodeUTF8String");

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_SEQUENCE_OF_ANY,
		    &Sequence,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    ppbOut,
		    pcbOut))
    {
	hr = myHLastError();
	_JumpIfError(hr, error, "myEncodeObject");
    }
    hr = S_OK;

error:
    for (i = 0; i < ARRAYSIZE(aBlob); i++)
    {
	if (NULL != aBlob[i].pbData)
	{
	    LocalFree(aBlob[i].pbData);
	}
    }
    return(hr);
}


HRESULT
myDecodeRequestClientAttribute(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT CRYPT_REQUEST_CLIENT_INFO **ppcrci)
{
    HRESULT hr;
    CRYPT_SEQUENCE_OF_ANY *pSequence = NULL;
    CRYPT_REQUEST_CLIENT_INFO crci;
    DWORD cb;
    BYTE *pb;

    ZeroMemory(&crci, sizeof(crci));
    *ppcrci = NULL;

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_SEQUENCE_OF_ANY,
		    pbIn,
		    cbIn,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pSequence,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }
    if (4 != pSequence->cValue)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "incomplete structure");
    }
    cb = sizeof(crci.dwClientId);
    if (!CryptDecodeObject(
		    X509_ASN_ENCODING,
		    X509_INTEGER,
		    pSequence->rgValue[0].pbData,
		    pSequence->rgValue[0].cbData,
		    0,		// dwFlags
		    (VOID *) &crci.dwClientId,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }
    hr = myDecodeUTF8String(
		    pSequence->rgValue[1].pbData,
		    pSequence->rgValue[1].cbData,
		    &crci.pwszMachine);
    _JumpIfError(hr, error, "myDecodeUTF8String");

    hr = myDecodeUTF8String(
		    pSequence->rgValue[2].pbData,
		    pSequence->rgValue[2].cbData,
		    &crci.pwszUser);
    _JumpIfError(hr, error, "myDecodeUTF8String");

    hr = myDecodeUTF8String(
		    pSequence->rgValue[3].pbData,
		    pSequence->rgValue[3].cbData,
		    &crci.pwszProcess);
    _JumpIfError(hr, error, "myDecodeUTF8String");

    cb = sizeof(crci);
    if (NULL != crci.pwszMachine)
    {
	cb += DWORDROUND(sizeof(WCHAR) * (wcslen(crci.pwszMachine) + 1));
    }
    if (NULL != crci.pwszUser)
    {
	cb += DWORDROUND(sizeof(WCHAR) * (wcslen(crci.pwszUser) + 1));
    }
    if (NULL != crci.pwszProcess)
    {
	cb += DWORDROUND(sizeof(WCHAR) * (wcslen(crci.pwszProcess) + 1));
    }
    *ppcrci = (CRYPT_REQUEST_CLIENT_INFO *) LocalAlloc(
						LMEM_FIXED | LMEM_ZEROINIT,
						cb);
    if (NULL == *ppcrci)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    pb = (BYTE *) (*ppcrci + 1);
    (*ppcrci)->dwClientId = crci.dwClientId;
    if (NULL != crci.pwszMachine)
    {
	(*ppcrci)->pwszMachine = (WCHAR *) pb;
	wcscpy((*ppcrci)->pwszMachine, crci.pwszMachine);
	pb += DWORDROUND(sizeof(WCHAR) * (wcslen(crci.pwszMachine) + 1));
    }
    if (NULL != crci.pwszUser)
    {
	(*ppcrci)->pwszUser = (WCHAR *) pb;
	wcscpy((*ppcrci)->pwszUser, crci.pwszUser);
	pb += DWORDROUND(sizeof(WCHAR) * (wcslen(crci.pwszUser) + 1));
    }
    if (NULL != crci.pwszProcess)
    {
	(*ppcrci)->pwszProcess = (WCHAR *) pb;
	wcscpy((*ppcrci)->pwszProcess, crci.pwszProcess);
	pb += DWORDROUND(sizeof(WCHAR) * (wcslen(crci.pwszProcess) + 1));
    }
    hr = S_OK;

error:
    if (NULL != pSequence)
    {
	LocalFree(pSequence);
    }
    if (NULL != crci.pwszMachine)
    {
	LocalFree(crci.pwszMachine);
    }
    if (NULL != crci.pwszUser)
    {
	LocalFree(crci.pwszUser);
    }
    if (NULL != crci.pwszProcess)
    {
	LocalFree(crci.pwszProcess);
    }
    return(hr);
}



HRESULT
myEncodeRequestClientAttributeFromClientId(
    IN DWORD dwClientId,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut)
{
    HRESULT hr;
    CRYPT_REQUEST_CLIENT_INFO crci;

    *ppbOut = NULL;
    ZeroMemory(&crci, sizeof(crci));
    crci.dwClientId = dwClientId;
    //crci.pwszMachine = NULL;
    //crci.pwszUser = NULL;
    //crci.pwszProcess = NULL;

    hr = myGetMachineDnsName(&crci.pwszMachine);
    _PrintIfError(hr, "myGetMachineDnsName");

    hr = myGetUserNameEx(NameSamCompatible, &crci.pwszUser);
    _PrintIfError(hr, "myGetUserNameEx");

    hr = myGetProcessName(&crci.pwszProcess);
    _PrintIfError(hr, "myGetProcessName");

    hr = myEncodeRequestClientAttribute(&crci, ppbOut, pcbOut);
    _JumpIfError(hr, error, "myEncodeRequestClientAttribute");

error:
    if (NULL != crci.pwszProcess)
    {
	LocalFree(crci.pwszProcess);
    }
    if (NULL != crci.pwszUser)
    {
	LocalFree(crci.pwszUser);
    }
    if (NULL != crci.pwszMachine)
    {
	LocalFree(crci.pwszMachine);
    }
    return(hr);
}

#ifdef _XENROLL_SRC_
typedef BOOL
(WINAPI * PFNGetComputerNameExW) (
  COMPUTER_NAME_FORMAT NameType,  // name type
  WCHAR *lpBuffer,                // name buffer
  LPDWORD lpnSize                 // size of name buffer
);

typedef BOOL
(WINAPI * PFNGetUserNameExW)(
  EXTENDED_NAME_FORMAT NameFormat,  // name format
  WCHAR *lpNameBuffer,              // name buffer
  PULONG nSize                      // size of name buffer
);

typedef WCHAR*
(WINAPI * PFNGetCommandLineW)(
    VOID
);
#endif //_XENROLL_SRC_

BOOL
xeGetUserNameExW(
    IN EXTENDED_NAME_FORMAT NameFormat,
    IN WCHAR *pwszUserName,
    IN PULONG pcwc)
{
#ifdef _XENROLL_SRC_
    BOOL   b = FALSE;
    PFNGetUserNameExW pfnGetUserNameExW = NULL;
    HMODULE hModule = GetModuleHandle("secur32.dll");
    if (NULL != hModule)
    {
        pfnGetUserNameExW = (PFNGetUserNameExW)
                GetProcAddress(hModule, "GetUserNameExW");
        if (NULL != pfnGetUserNameExW)
        {
            return pfnGetUserNameExW(NameFormat, pwszUserName, pcwc);
        }
        //downlevel clients, do the hard work
        if (NULL == pwszUserName)
        {
            //just get size
            return GetUserName(NULL, pcwc);
        }

        CHAR *pszUserName = (CHAR*)LocalAlloc(LMEM_FIXED, *pcwc * sizeof(CHAR));
        if (NULL == pszUserName)
        {
            return FALSE;
        }
        if (GetUserName(pszUserName, pcwc))
        {
            //convert to wide string
            if (0 != MultiByteToWideChar(
                            CP_ACP,
                            0,
                            pszUserName,
                            -1,
                            pwszUserName,
                            *pcwc))
            {
                b = TRUE;
            }
        }
        LocalFree(pszUserName);
    }
    return b;
#else
    return GetUserNameExW(NameFormat, pwszUserName, pcwc);
#endif //_XENROLL_SRC_
}

BOOL
xeGetComputerNameExW(
    IN     COMPUTER_NAME_FORMAT NameFormat,  // name format
    IN     WCHAR               *pwszComputerName,    // name buffer
    IN OUT DWORD                *pcwc)       // size of name buffer
{
#ifdef _XENROLL_SRC_
    BOOL b = FALSE;
    PFNGetComputerNameExW pfnGetComputerNameExW = NULL;
    HMODULE hModule = GetModuleHandle("kernel32.dll");
    if (NULL != hModule)
    {
        pfnGetComputerNameExW = (PFNGetComputerNameExW)
                GetProcAddress(hModule, "GetComputerNameExW");
        if (NULL != pfnGetComputerNameExW)
        {
            return pfnGetComputerNameExW(NameFormat, pwszComputerName, pcwc);
        }
        //downlevel clients, do the hard work
        if (NULL == pwszComputerName)
        {
            //just get size, donwlevel machine has max size
            *pcwc = MAX_COMPUTERNAME_LENGTH + 1;
            SetLastError(ERROR_MORE_DATA); // caller check on
            return FALSE;
        }

        CHAR *pszComputerName = (CHAR*)
                        LocalAlloc(LMEM_FIXED, *pcwc * sizeof(CHAR));
        if (NULL == pszComputerName)
        {
            return FALSE;
        }
        if (GetComputerName(pszComputerName, pcwc))
        {
            //convert to wide string
            if (0 != MultiByteToWideChar(
                            CP_ACP,
                            0,
                            pszComputerName,
                            -1,
                            pwszComputerName,
                            *pcwc + 1))
            {
                b = TRUE;
            }
        }
        LocalFree(pszComputerName);
    }
    return b;
#else
    return GetComputerNameExW(NameFormat, pwszComputerName, pcwc);
#endif // _XENROLL_SRC_
}

WCHAR*
xeGetCommandLineW(
    OUT BOOL  *pfNeedFree)
{
    //init
    *pfNeedFree = FALSE;

#ifdef _XENROLL_SRC_
    WCHAR *pwszCommandLine = NULL;
    PFNGetCommandLineW pfnGetCommandLineW = NULL;
    HMODULE hModule = GetModuleHandle("kernel32.dll");
    CHAR *pszCommandLine;
    int  cch;

    if (NULL != hModule)
    {
        pfnGetCommandLineW = (PFNGetCommandLineW)
                GetProcAddress(hModule, "GetCommandLineW");
        if (NULL != pfnGetCommandLineW)
        {
            return pfnGetCommandLineW();
        }
        //downlevel clients, do the hard work
        pszCommandLine = GetCommandLine();
        if (NULL == pszCommandLine)
        {
            //error
            return NULL;
        }
        cch = strlen(pszCommandLine) + 1;
        pwszCommandLine = (WCHAR*)LocalAlloc(LMEM_FIXED, cch * sizeof(WCHAR));
        if (NULL != pwszCommandLine)
        {
            //convert to wide string
            if (0 == MultiByteToWideChar(
                            CP_ACP,
                            0,
                            pszCommandLine,
                            -1,
                            pwszCommandLine,
                            cch))
            {
                LocalFree(pwszCommandLine);
                pwszCommandLine = NULL;
            }
            else
            {
                //caller to free
                *pfNeedFree = TRUE;
            }
        }
    }
    return pwszCommandLine;
#else
    return GetCommandLineW();
#endif // _XENROLL_SRC_
}

HRESULT
myGetUserNameEx(
    IN EXTENDED_NAME_FORMAT NameFormat,
    OUT WCHAR **ppwszUserName)
{
    HRESULT hr;
    DWORD cwc = 0;
    WCHAR *pwszUserName = NULL;

    for (;;)
    {
	if (!xeGetUserNameExW(NameFormat, pwszUserName, &cwc))
	{
	    hr = myHLastError();
	    if (NULL != pwszUserName ||
		HRESULT_FROM_WIN32(ERROR_MORE_DATA) != hr)
	    {
		_JumpError(hr, error, "GetUserNameEx");
	    }
	}
	if (NULL != pwszUserName)
	{
	    break;
	}
	pwszUserName = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
	if (NULL == pwszUserName)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }
    *ppwszUserName = pwszUserName;
    pwszUserName = NULL;
    hr = S_OK;

error:
    if (NULL != pwszUserName)
    {
	LocalFree(pwszUserName);
    }
    return(hr);
}


HRESULT
myGetMachineDnsName(
    OUT WCHAR **ppwszDnsName)
{
    HRESULT hr;
    WCHAR *pwszDnsName = NULL;
    DWORD cwc;
    COMPUTER_NAME_FORMAT NameType = ComputerNameDnsFullyQualified;

    *ppwszDnsName = NULL;
    for (;;)
    {
	cwc = 0;
	if (!xeGetComputerNameExW(NameType, NULL, &cwc))
	{
	    hr = myHLastError();
	    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr &&
		ComputerNameDnsFullyQualified == NameType)
	    {
		_PrintError(hr, "GetComputerNameExW(DnsFullyQualified) -- switching to NetBIOS");
		NameType = ComputerNameNetBIOS;
		continue;
	    }
	    if (HRESULT_FROM_WIN32(ERROR_MORE_DATA) != hr)
	    {
		_JumpError(hr, error, "GetComputerNameEx");
	    }
	}
	else
	{
	    cwc++;
	}
	break;
    }
    pwszDnsName = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwszDnsName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    if (!xeGetComputerNameExW(NameType, pwszDnsName, &cwc))
    {
	hr = myHLastError();
	_JumpError(hr, error, "GetComputerNameEx");
    }

    *ppwszDnsName = pwszDnsName;
    pwszDnsName = NULL;
    hr = S_OK;

error:
    if (NULL != pwszDnsName)
    {
	LocalFree(pwszDnsName);
    }
    return(hr);
}

HRESULT
myGetProcessName(
    OUT WCHAR **ppwszProcessName)
{
    HRESULT hr;
    WCHAR *pwszCommandLine;
    WCHAR const *pwsz;
    WCHAR const *pwszStart;
    WCHAR *pwszAlloc;
    DWORD cwc;
    WCHAR wc;
    BOOL  fNeedFree;
    
    *ppwszProcessName = NULL;
    pwszCommandLine = xeGetCommandLineW(&fNeedFree);
    if (NULL == pwszCommandLine)
    {
	pwszCommandLine = L"";
    }
    wc = L' ';
    pwsz = pwszCommandLine;
    if ('"' == *pwsz)
    {
	wc = '"';
	pwsz++;
    }
    pwszStart = pwsz;
    while (L'\0' != *pwsz && wc != *pwsz)
    {
	if (L'\\' == *pwsz++)
	{
	    pwszStart = pwsz;
	}
    }
    cwc = SAFE_SUBTRACT_POINTERS(pwsz, pwszStart);

    pwszAlloc = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
    if (NULL == pwszAlloc)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(pwszAlloc, pwszStart, cwc * sizeof(WCHAR));
    pwszAlloc[cwc] = L'\0';
    *ppwszProcessName = pwszAlloc;
    hr = S_OK;

error:
    if (fNeedFree && NULL != pwszCommandLine)
    {    
        LocalFree(pwszCommandLine);        
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xaddroot\ui.cpp ===
#include <windows.h>
#include <wincrypt.h>
#include <unicode.h>
#include "ui.h"
#include "instres.h"
#include "resource.h"

#include <malloc.h>
#include <assert.h>


//+-------------------------------------------------------------------------
//  Formats multi bytes into WCHAR hex. Includes a space after every 4 bytes.
//
//  Needs (cb * 2 + cb/4 + 1) characters in wsz
//--------------------------------------------------------------------------
static void FormatMsgBoxMultiBytes(DWORD cb, BYTE *pb, LPWSTR wsz)
{
    for (DWORD i = 0; i<cb; i++) {
        int b;
        if (i && 0 == (i & 1))
            *wsz++ = L' ';
        b = (*pb & 0xF0) >> 4;
        *wsz++ = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        b = *pb & 0x0F;
        *wsz++ = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        pb++;
    }
    *wsz++ = 0;
}


INT_PTR CALLBACK MoreInfoDialogProc(
  HWND hwndDlg,  // handle to dialog box
  UINT uMsg,     // message
  WPARAM wParam, // first message parameter
  LPARAM lParam  // second message parameter
) {

    PMIU                                pmiu            = NULL;
    FILETIME                            ftLocal;
    SYSTEMTIME                          stLocal;
    DWORD                               dwChar;
    LPWSTR                              wszName;
    BYTE                                rgbHash[MAX_HASH_LEN];
    DWORD                               cbHash = MAX_HASH_LEN;
    HWND                                hwnd;
    CRYPTUI_VIEWCERTIFICATE_STRUCTW     cryptUI;
    WCHAR                               wsz[128];

    switch(uMsg) {

        case WM_CLOSE:
            EndDialog(hwndDlg, 0);
            return(0);
            break;
     
        case WM_INITDIALOG:

            // remember my imput data
            SetWindowLongPtr(hwndDlg, DWLP_USER, lParam);
            pmiu = (PMIU) lParam;

            // hide the window if we don't have a cryptUI dll
            if(NULL == pmiu->pfnCryptUIDlgViewCertificateW  &&
               NULL != (hwnd = GetDlgItem(hwndDlg, IDC_CAINFO_VIEWCERT)) )
                   ShowWindow(hwnd, SW_HIDE);
 
            // put in the name
	    if(0 != (dwChar=CertNameToStrW(
		X509_ASN_ENCODING,
		&pmiu->pCertContext->pCertInfo->Subject,
        CERT_SIMPLE_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
                NULL,
                0
                ) )) {
                
                wszName = (LPWSTR) _alloca(sizeof(WCHAR) * dwChar); 
            
		if(dwChar == CertNameToStrW(
		    X509_ASN_ENCODING,
		    &pmiu->pCertContext->pCertInfo->Subject,
		    CERT_SIMPLE_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
		    wszName,
                    dwChar
                    ) ) {
                    
                    SendDlgItemMessageU( 
                        hwndDlg, 
                        IDC_CAINFO_NAME, 
                        WM_SETTEXT, 
                        0, 
                        (LPARAM) wszName);
                }
            }

            wsz[0] = 0;
            FileTimeToLocalFileTime(&pmiu->pCertContext->pCertInfo->NotAfter, &ftLocal);
            FileTimeToSystemTime(&ftLocal, &stLocal);
            GetDateFormatU(LOCALE_USER_DEFAULT, DATE_LONGDATE, &stLocal, NULL, wsz, 128);
            
            // put not after date
            SendDlgItemMessageU( 
                hwndDlg, 
                IDC_CAINFO_EXPIRATION_DATE,
                WM_SETTEXT, 
                0, 
                (LPARAM) wsz);
 
            // get the sha1 thumbprint
            if (CertGetCertificateContextProperty(
                    pmiu->pCertContext,
                    CERT_SHA1_HASH_PROP_ID,
                    rgbHash,
                    &cbHash)) {
                FormatMsgBoxMultiBytes(cbHash, rgbHash, wsz);
                SendDlgItemMessageU( 
                    hwndDlg, 
                    IDC_CAINFO_THUMBPRINT, 
                    WM_SETTEXT, 
                    0, 
                    (LPARAM) wsz);
            }

            // put in the thumbprint alg
            // no localization needed
            SendDlgItemMessageU( 
                hwndDlg, 
                IDC_CAINFO_THUMBPRINT_ALGORITHM, 
                WM_SETTEXT, 
                0, 
                (LPARAM) L"SHA1");

            return(TRUE);
            break;

        case WM_COMMAND:

            switch(HIWORD(wParam)) {

                case BN_CLICKED:

                    switch(LOWORD(wParam)) {
                        case IDOK:
                        case IDCANCEL:
                            EndDialog(hwndDlg, LOWORD(wParam));
                            return(TRUE);
                            break;

                        case IDC_CAINFO_VIEWCERT:

                        GetWindowLongPtr(hwndDlg, DWLP_USER);

                            if(NULL != (pmiu = (PMIU) GetWindowLongPtr(hwndDlg, DWLP_USER))     &&
                               NULL != pmiu->pfnCryptUIDlgViewCertificateW                      ) {
                            
                                memset(&cryptUI, 0, sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCTW));
                                cryptUI.dwSize = sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCTW);
                                cryptUI.pCertContext = pmiu->pCertContext;
                                cryptUI.hwndParent = hwndDlg;
                                cryptUI.dwFlags = 
                                    CRYPTUI_DISABLE_ADDTOSTORE | CRYPTUI_IGNORE_UNTRUSTED_ROOT;
                                pmiu->pfnCryptUIDlgViewCertificateW(&cryptUI, NULL);
                                return(TRUE);
                            }
                            break;
                    }
                    break;
            }
            break;
    }

    return(FALSE);
}

int MoreInfoDlg(
    HWND            hDlgBox,
    int             idLB
) {
    PCCERT_CONTEXT  pCertContext;
    PMDI            pmdi    = (PMDI) GetWindowLongPtr(hDlgBox, DWLP_USER);
    INT_PTR         iItem;
    MIU             miu;

    // What is currently selected
    iItem = SendDlgItemMessageA( 
      hDlgBox,
      idLB, 
      LB_GETCURSEL, 
      0,
      0
      );

    if(iItem == LB_ERR)
      return(LB_ERR);


    // get the pCertContext
    pCertContext = (PCCERT_CONTEXT) SendDlgItemMessageA( 
      hDlgBox,
      idLB, 
      LB_GETITEMDATA, 
      (WPARAM) iItem,
      0
      );

    if(pCertContext == (PCCERT_CONTEXT) LB_ERR  ||  pCertContext == NULL)
      return(LB_ERR);

    // set up the parameters for the more info dialog
    miu.pCertContext                    = pCertContext;
    miu.hInstance                       = pmdi->hInstance;
    miu.pfnCryptUIDlgViewCertificateW   = pmdi->pfnCryptUIDlgViewCertificateW;

    // put the dialog up
    DialogBoxParam(
      pmdi->hInstance,  
      (LPSTR) MAKEINTRESOURCE(IDD_CAINFO),
      hDlgBox,      
      MoreInfoDialogProc,
      (LPARAM) &miu);

    return(0);
}

int AddCertNameToListBox(
    PCCERT_CONTEXT  pCertContext, 
    HWND            hDlgBox,
    int             idLB
) {

    int     itemIndex;
    DWORD   dwChar;
    LPWSTR  wszName;

    if(0 == (dwChar=CertNameToStrW(
	X509_ASN_ENCODING,
	&pCertContext->pCertInfo->Subject,
    CERT_SIMPLE_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
	NULL,
        0
        ) ))
        return(LB_ERR);

    wszName = (LPWSTR) _alloca(sizeof(WCHAR) * dwChar); // no error checking, will stack fault, not return NULL
    
    if(dwChar != CertNameToStrW(
	X509_ASN_ENCODING,
	&pCertContext->pCertInfo->Subject,
    CERT_SIMPLE_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
	wszName,
        dwChar
        ) )
         return(LB_ERR);

    itemIndex = (int) SendDlgItemMessageU( 
        hDlgBox, 
        idLB, 
        LB_ADDSTRING, 
        0, 
        (LPARAM) wszName) ;

    if(LB_ERR == itemIndex || LB_ERRSPACE == itemIndex)
        return(itemIndex);

    if(LB_ERR ==  SendDlgItemMessageA( 
      hDlgBox,
      idLB, 
      LB_SETITEMDATA, 
      (WPARAM) itemIndex,
      (LPARAM) CertDuplicateCertificateContext(pCertContext)
      ) )
      return(LB_ERR);
      
       
return(0);
}


INT_PTR CALLBACK MainDialogProc(
  HWND hwndDlg,  // handle to dialog box
  UINT uMsg,     // message
  WPARAM wParam, // first message parameter
  LPARAM lParam  // second message parameter
) {

    PMDI            pmdi            = NULL;
    PCCERT_CONTEXT  pCertContext    = NULL;
    WCHAR           wrgDisclaimer[4096];  // because legal stuff is long
    DWORD           dwChar;
    LPWSTR          wszName;

    switch(uMsg) {

        case WM_CLOSE:
            EndDialog(hwndDlg, IDNO);
            return(0);
            break;
     
        case WM_INITDIALOG:

            pmdi = (PMDI) lParam;
            SetWindowLongPtr(hwndDlg, DWLP_USER, lParam);

            // put in the signer name
	    if(0 != (dwChar=CertNameToStrW(
		X509_ASN_ENCODING,
		&pmdi->pCertSigner->pCertInfo->Subject,
        CERT_SIMPLE_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
		NULL,
                0
                ) )) {
                
                wszName = (LPWSTR) _alloca(sizeof(WCHAR) * dwChar); 
            
		if(dwChar == CertNameToStrW(
		    X509_ASN_ENCODING,
		    &pmdi->pCertSigner->pCertInfo->Subject,
		    CERT_SIMPLE_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
		    wszName,
                    dwChar
                    ) ) {
                    
                    SendDlgItemMessageU( 
                        hwndDlg, 
                        IDC_INSTALLCA_VERIFIER, 
                        WM_SETTEXT, 
                        0, 
                        (LPARAM) wszName);
                }
            }

            // set legal disclaimer
            LoadStringU(pmdi->hInstance, IDS_LEGALDISCLAIMER, wrgDisclaimer, sizeof(wrgDisclaimer)/sizeof(WCHAR));
            SendDlgItemMessageU( 
                hwndDlg, 
                IDC_INSTALLCA_LEGALDISCLAIMER, 
                WM_SETTEXT, 
                0, 
                (LPARAM) wrgDisclaimer) ;

            // add each cert to the list box
            while(NULL != (pCertContext = CertEnumCertificatesInStore(pmdi->hStore, pCertContext)))
                AddCertNameToListBox(pCertContext, hwndDlg, IDC_INSTALLCA_CALIST);

            // set the selection to the first item, don't worry about errors
            SendDlgItemMessageU( 
                hwndDlg, 
                IDC_INSTALLCA_CALIST, 
                LB_SETCURSEL, 
                0, 
                0);

            return(TRUE);
            break;

        case WM_COMMAND:

            switch(HIWORD(wParam)) {

                case BN_CLICKED:

                    switch(LOWORD(wParam)) {
                        case IDYES:
                        case IDNO:
                        case IDCANCEL:
                            EndDialog(hwndDlg, LOWORD(wParam));
                            return(TRUE);

                        case IDC_INSTALLCA_MOREINFO:
                            MoreInfoDlg(hwndDlg, IDC_INSTALLCA_CALIST);
                            return(TRUE);
                    }
                    break;

                case LBN_DBLCLK:

                    switch(LOWORD(wParam)) {
                        case IDC_INSTALLCA_CALIST:
                            MoreInfoDlg(hwndDlg, IDC_INSTALLCA_CALIST);
                            return(TRUE);
                    }
                    break;
            }
    }

    return(FALSE);
}


BOOL FIsTooManyCertsOK(DWORD cCerts, HINSTANCE hInstanceUI) {

    WCHAR           wszT[MAX_MSG_LEN];
    WCHAR           wszT1[MAX_MSG_LEN];

    // if too many, ask the user if you wan to continue
    if(cCerts > CACERTWARNINGLEVEL) {
        LoadStringU(hInstanceUI, IDS_INSTALLCA, wszT1, sizeof(wszT1)/sizeof(WCHAR));
        LoadStringU(hInstanceUI, IDS_TOO_MANY_CA_CERTS, wszT, sizeof(wszT)/sizeof(WCHAR));
        return(IDYES == MessageBoxU(NULL, wszT, wszT1, MB_YESNO));
    }
    
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xelib\xelib.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       xcertlib.cpp
//
//  Contents:   most functions are moved and modofied from certsrv library
//
//  History:    03-2000   xtan   created
//--------------------------------------------------------------------------
#include <windows.h>
#include <assert.h>
#include <dbgdef.h>
#include <wininet.h>

#include "xelib.h"


// Crypt callback versions: must have certain signatures
LPVOID myCryptAlloc_LocalAlloc(size_t cbSize)  { return myAlloc(cbSize, CERTLIB_USE_LOCALALLOC); }
VOID myCryptAlloc_LocalFree(VOID* pv)  { myFree(pv, CERTLIB_USE_LOCALALLOC); }

LPVOID myCryptAlloc_CoTaskMemAlloc(size_t cbSize)  { return myAlloc(cbSize, CERTLIB_USE_COTASKMEMALLOC); }
VOID myCryptAlloc_CoTaskMemFree(VOID* pv)  { myFree(pv, CERTLIB_USE_COTASKMEMALLOC); }

// give callers an easy way to choose what to call: pick allocator based on allocation type
PFN_CRYPT_ALLOC PickAlloc(CERTLIB_ALLOCATOR allocType) 
{ 
    if (allocType == CERTLIB_USE_LOCALALLOC) 
       return myCryptAlloc_LocalAlloc;
    else if (allocType == CERTLIB_USE_COTASKMEMALLOC)
       return myCryptAlloc_CoTaskMemAlloc;

    CSASSERT(!"Bad allocType");
    return NULL;
}

PFN_CRYPT_FREE PickFree(CERTLIB_ALLOCATOR allocType)
{
    if (allocType == CERTLIB_USE_LOCALALLOC) 
       return myCryptAlloc_LocalFree;
    else if (allocType == CERTLIB_USE_COTASKMEMALLOC)
       return myCryptAlloc_CoTaskMemFree;

    CSASSERT(!"Bad allocType");
    return NULL;
}

VOID *
myAlloc(IN size_t cbBytes, IN CERTLIB_ALLOCATOR allocType)
{
    void *pv;

    switch (allocType)
    {
    case CERTLIB_USE_LOCALALLOC:
        pv = LocalAlloc(LMEM_FIXED, cbBytes);
        break;
    case CERTLIB_USE_COTASKMEMALLOC:
        pv = CoTaskMemAlloc(cbBytes);
        break;
    default:
        CSASSERT(FALSE);
        pv = NULL;
        break;
    }

    if (NULL == pv)
    {
	_PrintError(E_OUTOFMEMORY, "myAlloc");
        SetLastError((DWORD) E_OUTOFMEMORY);
    }
    return(pv);
}

VOID
myFree(IN void *pv, IN CERTLIB_ALLOCATOR allocType)
{
    switch(allocType)
    {
    case CERTLIB_USE_LOCALALLOC:
        LocalFree(pv);
        break;
    case CERTLIB_USE_COTASKMEMALLOC:
        CoTaskMemFree(pv);
        break;
    default:
        CSASSERT(FALSE);
        break;
    }
}

HRESULT
myHError(HRESULT hr)
{
    CSASSERT(S_FALSE != hr);

    if (S_OK != hr && S_FALSE != hr && !FAILED(hr))
    {
        hr = HRESULT_FROM_WIN32(hr);
        if (0 == HRESULT_CODE(hr))
        {
            // A call failed without properly setting an error condition!
            hr = E_UNEXPECTED;
        }
        CSASSERT(FAILED(hr));
    }
    return(hr);
}

HRESULT
myHLastError(VOID)
{
    return(myHError(GetLastError()));
}

#ifdef _XENROLL_SRC_

typedef BOOL
(WINAPI * PFNCryptEncodeObjectEx)
   (IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const void *pvStructInfo,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
    OUT void *pvEncoded,
    IN OUT DWORD *pcbEncoded);

typedef BOOL
(WINAPI * PFNCryptDecodeObjectEx)
   (IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
    OUT OPTIONAL void *pvStructInfo,
    IN OUT DWORD *pcbStructInfo);

#endif //_XENROLL_SRC_

BOOL
myEncodeObject(
    DWORD dwEncodingType,
    IN LPCSTR lpszStructType,
    IN VOID const *pvStructInfo,
    IN DWORD dwFlags,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded)
{
    BOOL b = FALSE;

    CSASSERT(NULL != ppbEncoded);
        CRYPT_ENCODE_PARA sAllocator;
        sAllocator.cbSize = sizeof(sAllocator);
        sAllocator.pfnAlloc = PickAlloc(allocType);
        sAllocator.pfnFree = PickFree(allocType);

#ifdef _XENROLL_SRC_
    PFNCryptEncodeObjectEx pfnCryptEncodeObjectEx = NULL;
    HMODULE hModule = GetModuleHandle("crypt32.dll");
    if (NULL != hModule)
    {
        pfnCryptEncodeObjectEx = (PFNCryptEncodeObjectEx)
                GetProcAddress(hModule, "CryptEncodeObjectEx");
        if (NULL != pfnCryptEncodeObjectEx)
        {
            b = pfnCryptEncodeObjectEx(
                    dwEncodingType,
                    lpszStructType,
                    const_cast<VOID *>(pvStructInfo),
                    dwFlags|CRYPT_ENCODE_ALLOC_FLAG,
                    &sAllocator,
                    ppbEncoded,
                    pcbEncoded);
        }
    }
#else
	b = CryptEncodeObjectEx(
		    dwEncodingType,
		    lpszStructType,
		    const_cast<VOID *>(pvStructInfo),
		    dwFlags|CRYPT_ENCODE_ALLOC_FLAG,
		    &sAllocator,
		    ppbEncoded,
		    pcbEncoded);
	if (b && 0 == *pcbEncoded)
	{
	    SetLastError((DWORD) HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
	    b = FALSE;
	}
#endif //_XENROLL_SRC_

    return(b);
}

BOOL
myDecodeObject(
    IN DWORD dwEncodingType,
    IN LPCSTR lpszStructType,
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN CERTLIB_ALLOCATOR allocType,
    OUT VOID **ppvStructInfo,
    OUT DWORD *pcbStructInfo)
{
    BOOL b = FALSE;

        CRYPT_DECODE_PARA sAllocator;
        sAllocator.cbSize = sizeof(sAllocator);
        sAllocator.pfnAlloc = PickAlloc(allocType);
        sAllocator.pfnFree = PickFree(allocType);

#ifdef _XENROLL_SRC_
    PFNCryptDecodeObjectEx pfnCryptDecodeObjectEx = NULL;
    HMODULE hModule = GetModuleHandle("crypt32.dll");
    if (NULL != hModule)
    {
        pfnCryptDecodeObjectEx = (PFNCryptDecodeObjectEx)
                GetProcAddress(hModule, "CryptDecodeObjectEx");
        if (NULL != pfnCryptDecodeObjectEx)
        {
            b = pfnCryptDecodeObjectEx(
		    dwEncodingType,
		    lpszStructType,
		    pbEncoded,
		    cbEncoded,
		    CRYPT_DECODE_ALLOC_FLAG,                  // dwFlags
                    &sAllocator,
		    ppvStructInfo,
		    pcbStructInfo);
        }
    }
#else
	b = CryptDecodeObjectEx(
		    dwEncodingType,
		    lpszStructType,
		    pbEncoded,
		    cbEncoded,
		    CRYPT_DECODE_ALLOC_FLAG,                  // dwFlags
                    &sAllocator,
		    ppvStructInfo,
		    pcbStructInfo);
	if (b && 0 == *pcbStructInfo)
	{
	    SetLastError((DWORD) HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
	    b = FALSE;
	}
#endif //_XENROLL_SRC_

    return(b);
}

HRESULT
myDecodePKCS7(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OPTIONAL OUT BYTE **ppbContents,
    OPTIONAL OUT DWORD *pcbContents,
    OPTIONAL OUT DWORD *pdwMsgType,
    OPTIONAL OUT char **ppszInnerContentObjId,
    OPTIONAL OUT DWORD *pcSigner,
    OPTIONAL OUT DWORD *pcRecipient,
    OPTIONAL OUT HCERTSTORE *phStore,
    OPTIONAL OUT HCRYPTMSG *phMsg)
{
    HRESULT hr;
    BYTE *pbContents = NULL;
    HCERTSTORE hStore = NULL;
    HCRYPTMSG hMsg = NULL;
    DWORD cbContents;
    char *pszInnerContentObjId = NULL;
    DWORD cb;

    if (NULL != ppszInnerContentObjId)
    {
	*ppszInnerContentObjId = NULL;
    }
    if (NULL != pcSigner)
    {
	*pcSigner = 0;
    }
    if (NULL != pcRecipient)
    {
	*pcRecipient = 0;
    }
    if (NULL != ppbContents)
    {
	*ppbContents = NULL;
    }
    if (NULL != phStore)
    {
	*phStore = NULL;
    }
    if (NULL != phMsg)
    {
	*phMsg = NULL;
    }
    if (NULL != phStore)
    {
	CRYPT_DATA_BLOB blobPKCS7;

	blobPKCS7.pbData = (BYTE *) pbIn;
	blobPKCS7.cbData = cbIn;

	hStore = CertOpenStore(
			    CERT_STORE_PROV_PKCS7,
			    PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
			    NULL,		// hCryptProv
			    0,			// dwFlags
			    &blobPKCS7);
	if (NULL == hStore)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertOpenStore");
//	    _JumpError2(hr, error, "CertOpenStore", CRYPT_E_ASN1_BADTAG);
	}
    }

    hMsg = CryptMsgOpenToDecode(
			    PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
			    0,			// dwFlags
			    0,			// dwMsgType
			    NULL,		// hCryptProv
			    NULL,		// pRecipientInfo
			    NULL);		// pStreamInfo
    if (NULL == hMsg)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptMsgOpenToDecode");
    }

    if (!CryptMsgUpdate(hMsg, pbIn, cbIn, TRUE))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptMsgUpdate");
    }
    hr = myCryptMsgGetParam(
		    hMsg,
		    CMSG_INNER_CONTENT_TYPE_PARAM,
		    0, 		// dwIndex
                    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pszInnerContentObjId,
		    &cb);
    _PrintIfError(hr, "myCryptMsgGetParam(inner content type)");

#if 0
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"pszInnerContentObjId = %hs\n",
	pszInnerContentObjId));
#endif //0

    cbContents = 0;
    hr = myCryptMsgGetParam(
			hMsg,
			CMSG_CONTENT_PARAM,
			0, 		// dwIndex
                        CERTLIB_USE_LOCALALLOC,
			(VOID **) &pbContents,
			&cbContents);
    _JumpIfError(hr, error, "myCryptMsgGetParam(content)");

    if (NULL != pdwMsgType)
    {
	cb = sizeof(*pdwMsgType);
	if (!CryptMsgGetParam(
			hMsg,
			CMSG_TYPE_PARAM,
			0,
			pdwMsgType,
			&cb))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptMsgGetParam(type)");
	}
    }
    if (NULL != pcSigner)
    {
	cb = sizeof(*pcSigner);
	if (!CryptMsgGetParam(
			hMsg,
			CMSG_SIGNER_COUNT_PARAM,
			0,
			pcSigner,
			&cb))
	{
	    hr = myHLastError();
	    *pcSigner = 0;
	    if (CRYPT_E_INVALID_MSG_TYPE != hr)
	    {
		_JumpError(hr, error, "CryptMsgGetParam(signer count)");
	    }
	}
    }
    if (NULL != pcRecipient)
    {
	cb = sizeof(*pcRecipient);
	if (!CryptMsgGetParam(
			hMsg,
			CMSG_RECIPIENT_COUNT_PARAM,
			0,
			pcRecipient,
			&cb))
	{
	    hr = myHLastError();
	    *pcRecipient = 0;
	    if (CRYPT_E_INVALID_MSG_TYPE != hr)
	    {
		_JumpError(hr, error, "CryptMsgGetParam(recipient count)");
	    }
	}
    }
    if (NULL != phMsg)
    {
	*phMsg = hMsg;
	hMsg = NULL;
    }
    if (NULL != phStore)
    {
	*phStore = hStore;
	hStore = NULL;
    }
    if (NULL != ppszInnerContentObjId)
    {
	*ppszInnerContentObjId = pszInnerContentObjId;
	pszInnerContentObjId = NULL;
    }
    if (NULL != pcbContents)
    {
	*pcbContents = cbContents;
    }
    if (NULL != ppbContents && 0 != cbContents)
    {
	*ppbContents = pbContents;
	pbContents = NULL;
    }
    hr = S_OK;

error:
    if (NULL != hMsg)
    {
	CryptMsgClose(hMsg);
    }
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != pbContents)
    {
	LocalFree(pbContents);
    }
    if (NULL != pszInnerContentObjId)
    {
	LocalFree(pszInnerContentObjId);
    }
    return(hr);
}

HRESULT
myDupString(
    IN WCHAR const *pwszIn,
    IN WCHAR **ppwszOut)
{
    DWORD cb;
    HRESULT hr;

    cb = (wcslen(pwszIn) + 1) * sizeof(WCHAR);
    *ppwszOut = (WCHAR *) LocalAlloc(LMEM_FIXED, cb);
    if (NULL == *ppwszOut)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(*ppwszOut, pwszIn, cb);
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myAddNameSuffix(
    IN WCHAR const *pwszValue,
    IN WCHAR const *pwszSuffix,
    IN DWORD cwcNameMax,
    OUT WCHAR **ppwszOut)
{
    HRESULT hr;
    DWORD cwcValue = wcslen(pwszValue);
    DWORD cwcSuffix = wcslen(pwszSuffix);
    WCHAR *pwszOut;

    *ppwszOut = NULL;
    pwszOut = (WCHAR *) LocalAlloc(
		    LMEM_FIXED,
		    sizeof(WCHAR) * (1 + cwcValue + cwcSuffix));
    if (NULL == pwszOut)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CSASSERT(cwcNameMax > cwcSuffix);
    if (cwcValue > cwcNameMax - cwcSuffix)
    {
	cwcValue = cwcNameMax - cwcSuffix;
    }
    wcscpy(pwszOut, pwszValue);
    wcscpy(&pwszOut[cwcValue], pwszSuffix);
    *ppwszOut = pwszOut;
    hr = S_OK;

error:
    return(hr);
}


#define OCTECTSPACES

VOID
MultiByteStringSize(
    IN BOOL fOctetString,
    IN BYTE const *pbIn,
    IN OUT DWORD *pcbIn,
    OUT DWORD *pcbString)
{
    DWORD cbIn = *pcbIn;
    DWORD cbString;

    if (!fOctetString)
    {
	while (1 < cbIn && 0 == pbIn[cbIn - 1])
	{
	    cbIn--;
	}
    }

    // Two ascii-hex characters per byte, plus the null terminator:
    cbString = ((2 * cbIn) + 1) * sizeof(WCHAR);

#ifdef OCTECTSPACES
    // Allow for separating spaces after each byte except the last:
    if (fOctetString && 1 < cbIn)
    {
	cbString += (cbIn - 1) * sizeof(WCHAR);
    }
#endif // OCTECTSPACES
    *pcbIn = cbIn;
    *pcbString = cbString;
}

__inline WCHAR
NibbleToAscii(
    IN BYTE b)
{
    return(L"0123456789abcdef"[b & 0x0f]);
}


// MultiByteIntegerToWszBuf - convert a little-endian integer blob to
// a big endian null-terminated ascii-hex encoded WCHAR string of even length.

HRESULT
MultiByteIntegerToWszBuf(
    IN BOOL fOctetString,
    IN DWORD cbIn,
    IN BYTE const *pbIn,
    IN OUT DWORD *pcbOut,
    OPTIONAL OUT WCHAR *pwszOut)
{
    HRESULT hr = S_OK;
    DWORD cbOut;
    BYTE const *pbEnd = &pbIn[cbIn];

    MultiByteStringSize(fOctetString, pbIn, &cbIn, &cbOut);

    if (NULL != pwszOut)
    {
	BYTE const *pb;

	if (cbOut > *pcbOut)
	{
	    hr = TYPE_E_BUFFERTOOSMALL;
	    _JumpError(hr, error, "MultiByteIntegerToWsz: buffer overflow");
	}
	if (fOctetString)
	{
	    for (pb = pbIn; pb < pbEnd; pb++)
	    {
		*pwszOut++ = NibbleToAscii(*pb >> 4);
		*pwszOut++ = NibbleToAscii(*pb);
#ifdef OCTECTSPACES
		if (pb + 1 < pbEnd)
		{
		    *pwszOut++ = L' ';
		}
#endif // OCTECTSPACES
	    }
	}
	else
	{
	    for (pb = pbEnd; pb-- > pbIn; )
	    {
		*pwszOut++ = NibbleToAscii(*pb >> 4);
		*pwszOut++ = NibbleToAscii(*pb);
	    }
	}
	*pwszOut = L'\0';
	CSASSERT(
	    (SAFE_SUBTRACT_POINTERS(pwszOut, pwsz) + 1) * sizeof(WCHAR) ==
	    cbOut);
    }
    *pcbOut = cbOut;

error:
    return(hr);
}


// MultiByteIntegerToBstr - convert a little-endian integer blob to
// a big endian null-terminated ascii-hex encoded BSTR of even length.
// If fOctetString is TRUE, preserve endian order, as in a hex dump

HRESULT
MultiByteIntegerToBstr(
    IN BOOL fOctetString,
    IN DWORD cbIn,
    IN BYTE const *pbIn,
    OUT BSTR *pstrOut)
{
    HRESULT hr = S_OK;
    BSTR str = NULL;
    DWORD cbOut;

    MultiByteStringSize(fOctetString, pbIn, &cbIn, &cbOut);

    str = SysAllocStringByteLen(NULL, cbOut - sizeof(WCHAR));
    if (NULL == str)
    {
	hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "SysAllocStringLen");
    }

    hr = MultiByteIntegerToWszBuf(fOctetString, cbIn, pbIn, &cbOut, str);
    _JumpIfError(hr, error, "MultiByteIntegerToWszBuf");

    CSASSERT((wcslen(str) + 1) * sizeof(WCHAR) == cbOut);
    CSASSERT(SysStringByteLen(str) + sizeof(WCHAR) == cbOut);

    if (NULL != *pstrOut)
    {
	SysFreeString(*pstrOut);
    }
    *pstrOut = str;
    str = NULL;

error:
    if (NULL != str)
    {
	SysFreeString(str);
    }
    return(hr);
}


BOOL
myCryptExportPublicKeyInfo(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec,            // AT_SIGNATURE | AT_KEYEXCHANGE
    IN CERTLIB_ALLOCATOR allocType,
    OUT CERT_PUBLIC_KEY_INFO **ppPubKey,
    OUT DWORD *pcbPubKey)
{
    BOOL b;

    *ppPubKey = NULL;
    *pcbPubKey = 0;
    for (;;)
    {
	b = CryptExportPublicKeyInfo(
				hCryptProv,
				dwKeySpec,
				X509_ASN_ENCODING,
				*ppPubKey,
				pcbPubKey);
	if (b && 0 == *pcbPubKey)
	{
	    SetLastError((DWORD) HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
	    b = FALSE;
	}
	if (!b)
	{
	    if (NULL != *ppPubKey)
	    {
		myFree(*ppPubKey, allocType);
		*ppPubKey = NULL;
	    }
	    break;
	}
	if (NULL != *ppPubKey)
	{
	    break;
	}
	*ppPubKey = (CERT_PUBLIC_KEY_INFO *) myAlloc(*pcbPubKey, allocType);
	if (NULL == *ppPubKey)
	{
	    b = FALSE;
	    break;
	}
    }
    return(b);
}

VOID
myMakeExprDateTime(
    IN OUT FILETIME *pft,
    IN LONG lDelta,
    IN enum ENUM_PERIOD enumPeriod)
{
    LONGLONG llDelta;
    BOOL fSysTimeDelta;

    llDelta = lDelta;
    fSysTimeDelta = FALSE;
    switch (enumPeriod)
    {
	case ENUM_PERIOD_WEEKS:   llDelta *= CVT_WEEKS;    break;
	case ENUM_PERIOD_DAYS:    llDelta *= CVT_DAYS;     break;
	case ENUM_PERIOD_HOURS:   llDelta *= CVT_HOURS;    break;
	case ENUM_PERIOD_MINUTES: llDelta *= CVT_MINUTES;  break;
	case ENUM_PERIOD_SECONDS: 			   break;

	//case ENUM_PERIOD_MONTHS:
	//case ENUM_PERIOD_YEARS:
	default:

	    // Avoid side effect of round trip SYSTEMTIME conversion
	    // (avoid truncating microseconds) if lDelta is zero.

	    if (0 != lDelta)
	    {
		fSysTimeDelta = TRUE;
	    }
	    break;
    }
    if (fSysTimeDelta)
    {
	SYSTEMTIME SystemTime;

	FileTimeToSystemTime(pft, &SystemTime);
	switch (enumPeriod)
	{
	    case ENUM_PERIOD_MONTHS:
		if (0 > lDelta)
		{
		    DWORD dwDelta = (DWORD) -lDelta;

		    SystemTime.wYear -= (WORD) (dwDelta / 12) + 1;
		    SystemTime.wMonth += 12 - (WORD) (dwDelta % 12);
		}
		else
		{
		    SystemTime.wMonth = (WORD) (SystemTime.wMonth + lDelta);
		}
		if (12 < SystemTime.wMonth)
		{
		    SystemTime.wYear += (SystemTime.wMonth - 1) / 12;
		    SystemTime.wMonth = ((SystemTime.wMonth - 1) % 12) + 1;
		}
		break;

	    case ENUM_PERIOD_YEARS:
		SystemTime.wYear = (WORD) (SystemTime.wYear + lDelta);
		break;

	    default:
		SystemTime.wYear += 1;
		break;
	}

DoConvert:
        if (!SystemTimeToFileTime(&SystemTime, pft))
        {
            if (GetLastError() != ERROR_INVALID_PARAMETER)
            {
                CSASSERT(!"Unable to do time conversion");
                return;
            }

            // In some cases we'll convert to an invalid month-end

            // only one month changes length from year to year
            if (SystemTime.wMonth == 2)
            {
                // > 29? try leap year
                if (SystemTime.wDay > 29)
                {
                    SystemTime.wDay = 29;
                    goto DoConvert;
                }
                // == 29? try non-leap year
                else if (SystemTime.wDay == 29)
                {
                    SystemTime.wDay = 28;
                    goto DoConvert;
                }
            }
            // sept (9), apr(4), jun(6), nov(11) all have 30 days
            else if ((SystemTime.wMonth == 9) ||
                     (SystemTime.wMonth == 4) ||
                     (SystemTime.wMonth == 6) ||
                     (SystemTime.wMonth == 11))
            {
                if (SystemTime.wDay > 30)
                {
                    SystemTime.wDay = 30;
                    goto DoConvert;
                }
            }

            // should never get here
            CSASSERT(!"Month/year processing: inaccessible code");
            return;
        }
    }
    else
    {
	*(LONGLONG UNALIGNED *) pft += llDelta * CVT_BASE;
    }
}


BOOL
myCryptSignCertificate(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec,
    IN DWORD dwEncodingType,
    IN BYTE const *pbEncodedToBeSigned,
    IN DWORD cbEncodedToBeSigned,
    IN CRYPT_ALGORITHM_IDENTIFIER const *pSignatureAlgorithm,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbSignature,
    OUT DWORD *pcbSignature)
{
    BOOL b;

    *ppbSignature = NULL;
    *pcbSignature = 0;
    for (;;)
    {
        b = CryptSignCertificate(
		hCryptProv,
		dwKeySpec,
		dwEncodingType,
		pbEncodedToBeSigned,
		cbEncodedToBeSigned,
		const_cast<CRYPT_ALGORITHM_IDENTIFIER *>(pSignatureAlgorithm),
		NULL,		// pvHashAuxInfo
		*ppbSignature,
		pcbSignature);
	if (b && 0 == *pcbSignature)
	{
	    SetLastError((DWORD) HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
	    b = FALSE;
	}
	if (!b)
	{
	    if (NULL != *ppbSignature)
	    {
		myFree(*ppbSignature, allocType);
		*ppbSignature = NULL;
	    }
	    break;
	}
	if (NULL != *ppbSignature)
	{
	    break;
	}
	*ppbSignature = (BYTE *) myAlloc(*pcbSignature, allocType);
	if (NULL == *ppbSignature)
	{
	    b = FALSE;
	    break;
	}
    }
    return(b);
}

HRESULT
myEncodeSignedContent(
    IN HCRYPTPROV hProv,
    IN DWORD dwCertEncodingType,
    IN char const *pszObjIdSignatureAlgorithm,
    IN BYTE *pbToBeSigned,
    IN DWORD cbToBeSigned,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbSigned,
    OUT DWORD *pcbSigned)
{
    HRESULT hr;
    CERT_SIGNED_CONTENT_INFO csci;

    ZeroMemory(&csci, sizeof(csci));
    csci.SignatureAlgorithm.pszObjId = (char *) pszObjIdSignatureAlgorithm;
    csci.ToBeSigned.cbData = cbToBeSigned;
    csci.ToBeSigned.pbData = pbToBeSigned;

    *ppbSigned = NULL;

    if (!myCryptSignCertificate(
			    hProv,
			    AT_SIGNATURE,
			    dwCertEncodingType,
			    csci.ToBeSigned.pbData,
			    csci.ToBeSigned.cbData,
			    &csci.SignatureAlgorithm,
			    CERTLIB_USE_LOCALALLOC,
			    &csci.Signature.pbData,
			    &csci.Signature.cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myCryptSignCertificate");
    }

//    if (!myEncodeCert(
    if (!myEncodeObject(
		dwCertEncodingType,
                X509_CERT,
		&csci,
                0,
		allocType,
		ppbSigned,
		pcbSigned))
    {
	hr = myHLastError();
//	_JumpError(hr, error, "myEncodeCert");
	_JumpError(hr, error, "myEncodeObject");
    }
    hr = S_OK;

error:
    if (NULL != csci.Signature.pbData)
    {
        LocalFree(csci.Signature.pbData);
    }
    return(hr);
}

HRESULT
myGetPublicKeyHash(
    OPTIONAL IN CERT_INFO const *pCertInfo,
    IN CERT_PUBLIC_KEY_INFO const *pPublicKeyInfo,
    OUT BYTE **ppbData,
    OUT DWORD *pcbData)
{
    HRESULT hr;
    CRYPT_DATA_BLOB *pBlob = NULL;
    DWORD cb;
    BYTE const *pb;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];

    *ppbData = NULL;

    if (NULL == pPublicKeyInfo)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "parm NULL");
    }

    pb = NULL;
    cb = 0;
    if (NULL != pCertInfo)
    {
	CERT_EXTENSION const *pExt;
	CERT_EXTENSION const *pExtEnd;

	pExtEnd = &pCertInfo->rgExtension[pCertInfo->cExtension];
	for (pExt = pCertInfo->rgExtension; pExt < pExtEnd; pExt++)
	{
	    if (0 == strcmp(szOID_SUBJECT_KEY_IDENTIFIER, pExt->pszObjId))
	    {
		if (!myDecodeObject(
				X509_ASN_ENCODING,
				X509_OCTET_STRING,
				pExt->Value.pbData,
				pExt->Value.cbData,
				CERTLIB_USE_LOCALALLOC,
				(VOID **) &pBlob,
				&cb))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "myDecodeObject");
		}
		pb = pBlob->pbData;
		cb = pBlob->cbData;
		break;
	    }
	}
    }
    if (NULL == pb)
    {
	cb = sizeof(abHash);
	if (!CryptHashPublicKeyInfo(
			    NULL,		// hCryptProv
			    CALG_SHA1,
			    0,                  // dwFlags,
			    X509_ASN_ENCODING,
			    const_cast<CERT_PUBLIC_KEY_INFO *>(pPublicKeyInfo),
			    abHash,
			    &cb))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptHashPublicKeyInfo");
	}
	pb = abHash;
    }

    *ppbData = (BYTE *) LocalAlloc(LMEM_FIXED, cb);
    if (NULL == *ppbData)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    *pcbData = cb;
    CopyMemory(*ppbData, pb, cb);
    hr = S_OK;

error:
    if (NULL != pBlob)
    {
	LocalFree(pBlob);
    }
    return(hr);
}

HRESULT
myCreateSubjectKeyIdentifierExtension(
    IN CERT_PUBLIC_KEY_INFO const *pPubKey,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded)
{
    HRESULT hr;
    CRYPT_DATA_BLOB KeyIdentifier;

    KeyIdentifier.pbData = NULL;
    hr = myGetPublicKeyHash(
			NULL,		// pCertInfo
			pPubKey,
			&KeyIdentifier.pbData,
			&KeyIdentifier.cbData);
    _JumpIfError(hr, error, "myGetPublicKeyHash");

    // Issuer's KeyId:

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_OCTET_STRING,
		    &KeyIdentifier,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    ppbEncoded,
		    pcbEncoded))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
    hr = S_OK;

error:
    if (NULL != KeyIdentifier.pbData)
    {
	LocalFree(KeyIdentifier.pbData);
    }
    return(hr);
}


HRESULT
myCalculateKeyArchivalHash(
    IN const BYTE     *pbEncryptedKey,
    IN DWORD           cbEncryptedKey,
    OUT BYTE         **ppbHash,
    OUT DWORD         *pcbHash)
{
    HRESULT    hr;
    HCRYPTPROV hProv = NULL;
    HCRYPTHASH hHash = NULL;
    BYTE*      pbHash = NULL;
    DWORD      cbHash = 0;
    DWORD      dwSize;

    if (NULL == pbEncryptedKey ||
        NULL == ppbHash ||
        NULL == pcbHash)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        _JumpError(hr, error, "Invalid parameters");
    }

    //init
    *ppbHash = NULL;
    *pcbHash = 0;

    if (!CryptAcquireContext(
            &hProv,
            NULL,       // pszContainer
            NULL,       // pszProvider
            PROV_RSA_FULL,
            CRYPT_VERIFYCONTEXT))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptAcquireContext");
    }

    //create a hash object
    if (!CryptCreateHash(hProv, CALG_SHA1, 0, 0, &hHash))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptCreateHash");
    }

    //hash the data
    if (!CryptHashData(
            hHash,
            pbEncryptedKey,
            cbEncryptedKey,
            0))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptHashData");
    }

    //get the hash size
    dwSize = sizeof(cbHash);
    if (!CryptGetHashParam(
            hHash,
            HP_HASHSIZE,
            (BYTE*)&cbHash,
            &dwSize,
            0))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptGetHashParam");
    }

    //allocate for hash buffer
    pbHash = (BYTE*)LocalAlloc(LMEM_FIXED, cbHash);
    if (NULL == pbHash)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    dwSize = cbHash;
    //get the hash
    if (!CryptGetHashParam(
            hHash,
            HP_HASHVAL,
            (BYTE*)pbHash,
            &dwSize,
            0))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptGetHashParam");
    }

    //should be the same
    CSASSERT(dwSize == cbHash);

    //return
    *ppbHash = pbHash;
    *pcbHash = cbHash;
    pbHash = NULL;

    hr = S_OK;
error:
    if (NULL != hHash)
    {
        CryptDestroyHash(hHash);
    }
    if (NULL != hProv)
    {
        CryptReleaseContext(hProv, 0);
    }
    if (NULL != pbHash)
    {
        LocalFree(pbHash);
    }
    return hr;
}


//--------------------------------------------------------------------
// Escapes any characters unsuitable for a URL.  Returns a new string.

HRESULT
myInternetCanonicalizeUrl(
    IN WCHAR const *pwszIn,
    OUT WCHAR **ppwszOut)
{
    HRESULT hr;
    WCHAR *pwsz = NULL;

    CSASSERT(NULL != pwszIn);

    if (0 == _wcsnicmp(L"file:", pwszIn, 5))
    {
	hr = myDupString(pwszIn, &pwsz);
        _JumpIfError(hr, error, "myDupString");
    }
    else
    {
	// Calculate required buffer size by passing a very small buffer
	// The call will fail, and tell us how big the buffer should be.

	WCHAR wszPlaceHolder[1];
	DWORD cwc = ARRAYSIZE(wszPlaceHolder);
	BOOL bResult;

	bResult = InternetCanonicalizeUrlW(
				    pwszIn,		// lpszUrl
				    wszPlaceHolder,	// lpszBuffer
				    &cwc,		// lpdwBufferLength
				    0);		// dwFlags
	CSASSERT(!bResult);	// This will always fail

	hr = myHLastError();
	if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != hr)
	{
	    // unexpected error

	    _JumpError(hr, error, "InternetCanonicalizeUrl");
	}

	// NOTE: InternetCanonicalizeUrl counts characters, not bytes as doc'd
	// cwc includes trailing L'0'

	pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
	if (NULL == pwsz)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}

	// canonicalize
	if (!InternetCanonicalizeUrlW(
				pwszIn,		// lpszUrl
				pwsz,		// lpszBuffer
				&cwc,		// lpdwBufferLength
				0))		// dwFlags
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "InternetCanonicalizeUrl");
	}
    }
    *ppwszOut = pwsz;
    pwsz = NULL;
    hr = S_OK;

error:
    if (NULL != pwsz)
    {
        LocalFree(pwsz);
    }
    return(hr);
}


// Inverse of InternetCanonicalizeUrl -- Convert "%20" sequences to " ", etc.

HRESULT
myInternetUncanonicalizeURL(
    IN WCHAR const *pwszURLIn,
    OUT WCHAR **ppwszURLOut)
{
    HRESULT hr;
    URL_COMPONENTSW urlcomp;
    WCHAR wszScheme[10];	// L"ldap"
    WCHAR wszHost[MAX_PATH];
    WCHAR wszURL[MAX_PATH];
    WCHAR wszExtra[MAX_PATH];
    WCHAR *pwszURL = NULL;
    DWORD cURL;
    DWORD cwcURLAlloc;

    *ppwszURLOut = NULL;
    ZeroMemory(&urlcomp, sizeof(urlcomp));
    urlcomp.dwStructSize = sizeof(urlcomp);

    urlcomp.lpszScheme = wszScheme;
    urlcomp.dwSchemeLength = ARRAYSIZE(wszScheme);

    urlcomp.lpszHostName = wszHost;
    urlcomp.dwHostNameLength = ARRAYSIZE(wszHost);

    urlcomp.lpszUrlPath = wszURL;
    urlcomp.dwUrlPathLength = ARRAYSIZE(wszURL);

    urlcomp.lpszExtraInfo = wszExtra;
    urlcomp.dwExtraInfoLength = ARRAYSIZE(wszExtra);

    // Decode escape sequemces

    if (!InternetCrackUrlW(pwszURLIn, 0, ICU_ESCAPE, &urlcomp))
    {
	hr = myHLastError();
	_JumpError(hr, error, "InternetCrackUrl");
    }

    cURL = 0;
    for (;;)
    {
	// InternetCreateUrl is spec'd strangely:
	//
	// When called with a NULL input pointer or an insufficient buffer
	// size, the returned count is the number of bytes required, including
	// the trailing L'\0'.
	//
	// When called with a non-NULL input pointer of adequate size, the
	// returned count is the count of chars, excluding the trailing L'\0'.
	//
	// This is just so wierd!

	if (!InternetCreateUrlW(&urlcomp, 0, pwszURL, &cURL))
	{
	    hr = myHLastError();
	    if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != hr ||
		NULL != pwszURL)
	    {
		_JumpError(hr, error, "InternetCreatUrl");
	    }
	}
	if (NULL != pwszURL)
	{
	    CSASSERT(wcslen(pwszURL) == cURL);
	    CSASSERT(cwcURLAlloc == cURL + 1);
	    break;
	}
	pwszURL = (WCHAR *) LocalAlloc(LMEM_FIXED, cURL);
	if (NULL == pwszURL)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	cURL /= sizeof(WCHAR);
	cwcURLAlloc = cURL;
    }
    *ppwszURLOut = pwszURL;
    pwszURL = NULL;
    hr = S_OK;

error:
    if (NULL != pwszURL)
    {
	LocalFree(pwszURL);
    }
    return(hr);
}


BOOL
ConvertWszToMultiByte(
    OUT CHAR **ppsz,
    IN UINT CodePage,
    IN WCHAR const *pwc,
    IN LONG cwc)
{
    HRESULT hr;
    LONG cch = 0;

    *ppsz = NULL;
    for (;;)
    {
	cch = WideCharToMultiByte(
			CodePage,
			0,          // dwFlags
			pwc,
			cwc,        // cchWideChar, -1 => null terminated
			*ppsz,
			cch,
			NULL,
			NULL);
	if (0 >= cch && 
	    (0 != cch || (0 != cwc && (MAXLONG != cwc || L'\0' != *pwc))))
	{
	    hr = myHLastError();
	    _PrintError(hr, "WideCharToMultiByte");

	    if (NULL != *ppsz)
	    {
		LocalFree(*ppsz);
		*ppsz = NULL;
	    }
	    break;
	}
	if (NULL != *ppsz)
	{
	    (*ppsz)[cch] = '\0';
	    hr = S_OK;
	    break;
	}
	*ppsz = (CHAR *) LocalAlloc(LMEM_FIXED, cch + 1);
	if (NULL == *ppsz)
	{
	    hr = E_OUTOFMEMORY;
	    break;
	}
    }
    if (S_OK != hr)
    {
	SetLastError(hr);
    }
    return(S_OK == hr);
}


BOOL
myConvertWszToUTF8(
    OUT CHAR **ppsz,
    IN WCHAR const *pwc,
    IN LONG cwc)
{
    return(ConvertWszToMultiByte(ppsz, CP_UTF8, pwc, cwc));
}


BOOL
myConvertWszToSz(
    OUT CHAR **ppsz,
    IN WCHAR const *pwc,
    IN LONG cwc)
{
    return(ConvertWszToMultiByte(ppsz, GetACP(), pwc, cwc));
}


BOOL
myConvertMultiByteToWsz(
    OUT WCHAR **ppwsz,
    IN UINT CodePage,
    IN CHAR const *pch,
    IN LONG cch)
{
    HRESULT hr;
    LONG cwc = 0;

    *ppwsz = NULL;
    for (;;)
    {
	cwc = MultiByteToWideChar(CodePage, 0, pch, cch, *ppwsz, cwc);
	if (0 >= cwc)
	{
	    hr = myHLastError();
	    _PrintError(hr, "MultiByteToWideChar");

	    if (NULL != *ppwsz)
	    {
		LocalFree(*ppwsz);
		*ppwsz = NULL;
	    }
	    break;
	}
	if (NULL != *ppwsz)
	{
	    (*ppwsz)[cwc] = L'\0';
	    hr = S_OK;
	    break;
	}
	*ppwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
	if (NULL == *ppwsz)
	{
	    hr = E_OUTOFMEMORY;
	    break;
	}
    }
    if (S_OK != hr)
    {
	SetLastError(hr);
    }
    return(S_OK == hr);
}


BOOL
myConvertUTF8ToWsz(
    OUT WCHAR **ppwsz,
    IN CHAR const *pch,
    IN LONG cch)
{
    return(myConvertMultiByteToWsz(ppwsz, CP_UTF8, pch, cch));
}


BOOL
myConvertSzToWsz(
    OUT WCHAR **ppwsz,
    IN CHAR const *pch,
    IN LONG cch)
{
    return(myConvertMultiByteToWsz(ppwsz, GetACP(), pch, cch));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xenroll\cenroll.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cenroll.h
//
//--------------------------------------------------------------------------

// CEnroll.h : Declaration of the CCEnroll

#ifndef __CENROLL_H_
#define __CENROLL_H_

#include <objsafe.h>
#include "resource.h"	    // main symbols

extern HINSTANCE hInstanceXEnroll;
#define MAX_SAFE_FOR_SCRIPTING_REQUEST_STORE_COUNT  500

typedef enum _StoreType {
	StoreNONE,
	StoreMY,
	StoreCA,
	StoreROOT,
	StoreREQUEST
} StoreType;

typedef struct _StoreInfo {
    LPWSTR  	wszName;
    LPSTR  		szType;
    DWORD   	dwFlags;
    HCERTSTORE	hStore;
} STOREINFO, *PSTOREINFO;

typedef struct _EXT_STACK {
    CERT_EXTENSION  	ext;
    struct _EXT_STACK *	pNext;
} EXT_STACK, * PEXT_STACK;

typedef struct _ATTR_STACK {
    CRYPT_ATTRIBUTE  		attr;
    struct _ATTR_STACK *	pNext;
} ATTR_STACK, * PATTR_STACK;

typedef struct _PROP_STACK {
    LONG                    lPropId;
    LONG                    lFlags;
    CRYPT_DATA_BLOB  		prop;
    struct _PROP_STACK *	pNext;
} PROP_STACK, * PPROP_STACK;

// Interface for a generic certificate context filter, currently used 
// filter enumerations of the certificate store.  
class CertContextFilter { 

 public:
    // Returns S_OK on success, and assigns the out parameter. 
    // The out parameter is TRUE if the cert context should be present in its enumeration,
    // FALSE if it should be filtered out.  On error, the value of the out parameter is
    // undefined.  
    virtual HRESULT accept(IN PCCERT_CONTEXT pCertContext, OUT BOOL * fResult) = 0; 
}; 

class CompositeCertContextFilter : public CertContextFilter { 
    CertContextFilter * filter1, * filter2; 
 public: 
    CompositeCertContextFilter(CertContextFilter * _filter1, CertContextFilter * _filter2) { 
	filter1 = _filter1; 
	filter2 = _filter2; 
    }
      
    virtual HRESULT accept(IN PCCERT_CONTEXT pCertContext, OUT BOOL * fResult) 
    { 
	HRESULT hr = S_OK;
	*fResult = TRUE; 

	// Note:  do not do input validation, as that could lead to a change in the behavior
	//        of the filters composed.  

	if (filter1 == NULL || S_OK == (hr = filter1->accept(pCertContext, fResult)))
	{ 
	    if (*fResult && (filter2 != NULL) )
		{ hr = filter2->accept(pCertContext, fResult); }
	}
	return hr; 
    }
}; 

// Extension of the base certificate context filter.  Filters out all certificate contexts
// with different hash values.  
class EquivalentHashCertContextFilter : public CertContextFilter { 
 public: 
    EquivalentHashCertContextFilter(CRYPT_DATA_BLOB hashBlob) : m_hashBlob(hashBlob) { }

    virtual HRESULT accept(IN PCCERT_CONTEXT pCertContext, OUT BOOL * fResult) 
    {
	BOOL            fFreeBuffer = FALSE, fDone = FALSE; 
	BYTE            buffer[30]; 
	CRYPT_DATA_BLOB hashBlob; 
	HRESULT         hr          = S_OK; 

	// Input validation: 
	if (pCertContext == NULL) { return E_INVALIDARG; }

	hashBlob.cbData = 30;
	hashBlob.pbData = buffer; 

	do { 
	    if (!CertGetCertificateContextProperty
		(pCertContext, 
		 CERT_HASH_PROP_ID, 
		 (LPVOID)(hashBlob.pbData),
		 &(hashBlob.cbData)))
	    {
		// We need to allocate a bigger buffer for our OUT param: 
		if (ERROR_MORE_DATA == GetLastError())
		{
		    hashBlob.pbData = (LPBYTE)LocalAlloc(LPTR, hashBlob.cbData);
		    if (NULL == hashBlob.pbData)
		    {
			hr = E_OUTOFMEMORY; 
			goto ErrorReturn; 
		    }
		    fFreeBuffer = TRUE;
		}
		else
		{
		    hr = HRESULT_FROM_WIN32(GetLastError());
		    goto ErrorReturn; 
		}
	    }
	    else
	    {
		fDone = TRUE;
	    }
	} while (!fDone); 

	// We have the same hashes if they are the same size and contain the same data. 
	*fResult = (hashBlob.cbData == m_hashBlob.cbData &&
		    0               == memcmp(hashBlob.pbData, m_hashBlob.pbData, hashBlob.cbData)); 

    CommonReturn:
	if (fFreeBuffer) { LocalFree(hashBlob.pbData); } 
	return hr; 

    ErrorReturn: 
	goto CommonReturn; 
    }   

 private: 
    CRYPT_DATA_BLOB m_hashBlob; 
}; 

// Extension of the base certificate context filter.  Filters out all certificate contexts
// which are not pending. 
class PendingCertContextFilter : public CertContextFilter { 
 public:
    virtual HRESULT accept(IN PCCERT_CONTEXT pCertContext, OUT BOOL * fResult)
    {
	BOOL            fFreeBuffer = FALSE, fDone = FALSE; 
	BYTE            buffer[100]; 
	CRYPT_DATA_BLOB pendingInfoBlob;  
	HRESULT         hr          = S_OK; 

	// Input validation: 
	if (pCertContext == NULL) { return E_INVALIDARG; }

	pendingInfoBlob.cbData = 100; 
	pendingInfoBlob.pbData = buffer; 

	do { 
	    if (!CertGetCertificateContextProperty
		(pCertContext,
		 CERT_ENROLLMENT_PROP_ID,
		 (LPVOID)(pendingInfoBlob.pbData),
		 &(pendingInfoBlob.cbData)))
	    {
		switch (GetLastError()) { 
		case CRYPT_E_NOT_FOUND: 
		    // The cert doesn't have this property, it can't be pending. 
		    *fResult = FALSE; 
		    fDone    = TRUE;
		    break;
		case ERROR_MORE_DATA: 
		    // Our output buffer wasn't big enough.  Reallocate and try again...
		    pendingInfoBlob.pbData = (LPBYTE)LocalAlloc(LPTR, pendingInfoBlob.cbData); 
		    if (NULL == pendingInfoBlob.pbData)
		    {
			hr = E_OUTOFMEMORY;
			goto ErrorReturn; 
		    }
		    fFreeBuffer = TRUE; 
		    break; 
		default: 
		    // Oops, an error
		    hr = HRESULT_FROM_WIN32(GetLastError()); 
		    goto ErrorReturn; 
		}
	    }
	    else
	    {
	    // No error, cert must have this property.
		*fResult = TRUE;
		fDone    = TRUE; 
	    }
	} while (!fDone); 

    CommonReturn:
	if (fFreeBuffer) { LocalFree(pendingInfoBlob.pbData); } 
	return hr;

    ErrorReturn:
	goto CommonReturn; 
    }
};


class PendingRequestTable { 

private:
    //
    // Auxiliary class definitions: 
    // 
    typedef struct _TableElem { 
	PCCERT_CONTEXT pCertContext; 
    } TableElem; 

public:
    //
    // Public interface: 
    //
    PendingRequestTable(); 
    ~PendingRequestTable(); 

    HRESULT construct(HCERTSTORE hStore); 

    DWORD            size()                    { return this->dwElemCount; } 
    PCCERT_CONTEXT & operator[] (DWORD dwElem) { return this->table[dwElem].pCertContext; } 

private:
    HRESULT add    (TableElem   tePendingRequest); 
    HRESULT resize (DWORD       dwNewSize);

    DWORD        dwElemCount; 
    DWORD        dwElemSize; 
    TableElem   *table; 
};


// General procedure for providing a filtered iteration of certificates in a store. 
// Excepting its ability to filter, behaves in the same manner as 
// CertEnumCertificatesInStore(). 
HRESULT FilteredCertEnumCertificatesInStore(HCERTSTORE           hStore, 
					    PCCERT_CONTEXT       pCertContext, 
					    CertContextFilter   *pFilter,
					    PCCERT_CONTEXT      *pCertContextNext); 

#define XENROLL_PASS_THRU_PROP_ID   (CERT_FIRST_USER_PROP_ID + 0x100)
#define XENROLL_RENEWAL_CERTIFICATE_PROP_ID (CERT_FIRST_USER_PROP_ID + 0x101)
#define XENROLL_REQUEST_INFO ((LPCSTR) 400)


/////////////////////////////////////////////////////////////////////////////
// CCEnroll
class ATL_NO_VTABLE CCEnroll : IEnroll4,
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CCEnroll, &CLSID_CEnroll2>,
	public IDispatchImpl<ICEnroll4, &IID_ICEnroll4, &LIBID_XENROLLLib>,
	public IObjectSafety
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_CENROLL)

BEGIN_COM_MAP(CCEnroll)
	COM_INTERFACE_ENTRY(IEnroll)
	COM_INTERFACE_ENTRY(IEnroll2)
	COM_INTERFACE_ENTRY(IEnroll4)
	COM_INTERFACE_ENTRY(ICEnroll)
	COM_INTERFACE_ENTRY(ICEnroll2)
	COM_INTERFACE_ENTRY(ICEnroll3)
	COM_INTERFACE_ENTRY(ICEnroll4)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IObjectSafety)
END_COM_MAP()

// ICEnroll
public:

		CCEnroll();

		virtual ~CCEnroll();
		
        virtual HRESULT __stdcall GetInterfaceSafetyOptions( 
                    /* [in]  */ REFIID riid,
                    /* [out] */ DWORD __RPC_FAR *pdwSupportedOptions,
                    /* [out] */ DWORD __RPC_FAR *pdwEnabledOptions);


        virtual HRESULT __stdcall SetInterfaceSafetyOptions( 
                    /* [in] */ REFIID riid,
                    /* [in] */ DWORD dwOptionSetMask,
                    /* [in] */ DWORD dwEnabledOptions);
           
        virtual HRESULT STDMETHODCALLTYPE createFilePKCS10( 
            /* [in] */ BSTR DNName,
            /* [in] */ BSTR Usage,
            /* [in] */ BSTR wszPKCS10FileName);
        
        virtual HRESULT STDMETHODCALLTYPE acceptFilePKCS7( 
            /* [in] */ BSTR wszPKCS7FileName);
            
        virtual HRESULT STDMETHODCALLTYPE getCertFromPKCS7( 
			/* [in] */ BSTR wszPKCS7,
			/* [retval][out] */ BSTR __RPC_FAR *pbstrCert);
            
        virtual HRESULT STDMETHODCALLTYPE createPKCS10( 
            /* [in] */ BSTR DNName,
            /* [in] */ BSTR Usage,
            /* [retval][out] */ BSTR __RPC_FAR *pPKCS10);
        
        virtual HRESULT STDMETHODCALLTYPE acceptPKCS7( 
            /* [in] */ BSTR PKCS7);

		virtual HRESULT STDMETHODCALLTYPE enumProviders(
            /* [in] */ LONG  dwIndex,
            /* [in] */ LONG  dwFlags,
            /* [out][retval] */ BSTR __RPC_FAR *pbstrProvName);
            
       	virtual HRESULT STDMETHODCALLTYPE enumContainers(
            /* [in] */ LONG                     dwIndex,
            /* [out][retval] */ BSTR __RPC_FAR *pbstr);
            
        virtual HRESULT STDMETHODCALLTYPE addCertTypeToRequest( 
            /* [in] */ BSTR CertType);
            
        virtual HRESULT STDMETHODCALLTYPE addNameValuePairToSignature( 
            /* [in] */ BSTR Name,
            /* [in] */ BSTR Value);
     
        virtual HRESULT STDMETHODCALLTYPE freeRequestInfo( 
            /* [in] */ BSTR PKCS7OrPKCS10);

        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MyStoreName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MyStoreName( 
            /* [in] */ BSTR bstrName);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MyStoreType( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrType);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MyStoreType( 
            /* [in] */ BSTR bstrType);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MyStoreFlags( 
            /* [retval][out] */ LONG __RPC_FAR *pdwFlags);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MyStoreFlags( 
            /* [in] */ LONG dwFlags);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CAStoreName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CAStoreName( 
            /* [in] */ BSTR bstrName);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CAStoreType( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrType);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CAStoreType( 
            /* [in] */ BSTR bstrType);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CAStoreFlags( 
            /* [retval][out] */ LONG __RPC_FAR *pdwFlags);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CAStoreFlags( 
            /* [in] */ LONG dwFlags);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RootStoreName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RootStoreName( 
            /* [in] */ BSTR bstrName);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RootStoreType( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrType);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RootStoreType( 
            /* [in] */ BSTR bstrType);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RootStoreFlags( 
            /* [retval][out] */ LONG __RPC_FAR *pdwFlags);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RootStoreFlags( 
            /* [in] */ LONG dwFlags);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RequestStoreName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RequestStoreName( 
            /* [in] */ BSTR bstrName);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RequestStoreType( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrType);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RequestStoreType( 
            /* [in] */ BSTR bstrType);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RequestStoreFlags( 
            /* [retval][out] */ LONG __RPC_FAR *pdwFlags);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RequestStoreFlags( 
            /* [in] */ LONG dwFlags);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ContainerName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrContainer);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ContainerName( 
            /* [in] */ BSTR bstrContainer);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ProviderName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrProvider);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ProviderName( 
            /* [in] */ BSTR bstrProvider);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ProviderType( 
            /* [retval][out] */ LONG __RPC_FAR *pdwType);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ProviderType( 
            /* [in] */ LONG dwType);
            
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_KeySpec( 
            /* [retval][out] */ LONG __RPC_FAR *pdw);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_KeySpec( 
            /* [in] */ LONG dw);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ProviderFlags( 
            /* [retval][out] */ LONG __RPC_FAR *pdwFlags);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ProviderFlags( 
            /* [in] */ LONG dwFlags);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_UseExistingKeySet( 
            /* [retval][out] */ BOOL __RPC_FAR *fUseExistingKeys);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_UseExistingKeySet( 
            /* [in] */ BOOL fUseExistingKeys);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_GenKeyFlags( 
            /* [retval][out] */ LONG __RPC_FAR *pdwFlags);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_GenKeyFlags( 
            /* [in] */ LONG dwFlags);
            
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DeleteRequestCert( 
            /* [retval][out] */ BOOL __RPC_FAR *fBool);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DeleteRequestCert( 
            /* [in] */ BOOL fBool);
            
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_WriteCertToCSP( 
            /* [retval][out] */ BOOL __RPC_FAR *fBool);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_WriteCertToCSP( 
            /* [in] */ BOOL fBool);
            
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_WriteCertToUserDS( 
            /* [retval][out] */ BOOL __RPC_FAR *fBool);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_WriteCertToUserDS( 
            /* [in] */ BOOL fBool);

        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EnableT61DNEncoding( 
            /* [retval][out] */ BOOL __RPC_FAR *fBool);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_EnableT61DNEncoding( 
            /* [in] */ BOOL fBool);
            
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SPCFileName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SPCFileName( 
            /* [in] */ BSTR bstr);
            
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PVKFileName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_PVKFileName( 
            /* [in] */ BSTR bstr);
            
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_HashAlgorithm( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_HashAlgorithm( 
            /* [in] */ BSTR bstr);
	
	virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ThumbPrint(
	    /* [in] */ BSTR bstrThumbPrint); 
     
	virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ThumbPrint(
	    /* [out, retval] */  BSTR *pbstrThumbPrint);     

	virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ThumbPrintWStr(
	    /* [in] */ CRYPT_DATA_BLOB thumbPrintBlob); 
     
	virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ThumbPrintWStr(
	    /* [out, retval] */  PCRYPT_DATA_BLOB thumbPrintBlob);     

        virtual HRESULT STDMETHODCALLTYPE InstallPKCS7( 
            /* [in] */ BSTR PKCS7);

        virtual HRESULT STDMETHODCALLTYPE createFilePKCS10WStr( 
            /* [in] */ LPCWSTR DNName,
            /* [in] */ LPCWSTR Usage,
            /* [in] */ LPCWSTR wszPKCS10FileName);
        
        virtual HRESULT STDMETHODCALLTYPE acceptFilePKCS7WStr( 
            /* [in] */ LPCWSTR wszPKCS7FileName);
        
        virtual HRESULT STDMETHODCALLTYPE createPKCS10WStr( 
            /* [in] */ LPCWSTR DNName,
            /* [in] */ LPCWSTR Usage,
            /* [out] */ PCRYPT_DATA_BLOB pPkcs10Blob);
        
        virtual HRESULT STDMETHODCALLTYPE acceptPKCS7Blob( 
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7);
        
        virtual PCCERT_CONTEXT STDMETHODCALLTYPE getCertContextFromPKCS7( 
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7);

        virtual HCERTSTORE STDMETHODCALLTYPE getMyStore( void);
        
        virtual HCERTSTORE STDMETHODCALLTYPE getCAStore( void);
        
        virtual HCERTSTORE STDMETHODCALLTYPE getROOTHStore( void);
        
        virtual HRESULT STDMETHODCALLTYPE enumProvidersWStr( 
            /* [in] */ LONG  dwIndex,
            /* [in] */ LONG  dwFlags,
            /* [out] */ LPWSTR __RPC_FAR *pbstrProvName);
        
        virtual HRESULT STDMETHODCALLTYPE enumContainersWStr( 
            /* [in] */ LONG  dwIndex,
            /* [out] */ LPWSTR __RPC_FAR *pbstr);

        virtual HRESULT STDMETHODCALLTYPE freeRequestInfoBlob( 
            /* [in] */ CRYPT_DATA_BLOB pkcs7OrPkcs10);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MyStoreNameWStr( 
            /* [out] */ LPWSTR __RPC_FAR *szwName);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MyStoreNameWStr( 
            /* [in] */ LPWSTR szwName);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MyStoreTypeWStr( 
            /* [out] */ LPWSTR __RPC_FAR *szwType);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MyStoreTypeWStr( 
            /* [in] */ LPWSTR szwType);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CAStoreNameWStr( 
            /* [out] */ LPWSTR __RPC_FAR *szwName);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CAStoreNameWStr( 
            /* [in] */ LPWSTR szwName);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CAStoreTypeWStr( 
            /* [out] */ LPWSTR __RPC_FAR *szwType);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CAStoreTypeWStr( 
            /* [in] */ LPWSTR szwType);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RootStoreNameWStr( 
            /* [out] */ LPWSTR __RPC_FAR *szwName);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RootStoreNameWStr( 
            /* [in] */ LPWSTR szwName);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RootStoreTypeWStr( 
            /* [out] */ LPWSTR __RPC_FAR *szwType);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RootStoreTypeWStr( 
            /* [in] */ LPWSTR szwType);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RequestStoreNameWStr( 
            /* [out] */ LPWSTR __RPC_FAR *szwName);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RequestStoreNameWStr( 
            /* [in] */ LPWSTR szwName);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RequestStoreTypeWStr( 
            /* [out] */ LPWSTR __RPC_FAR *szwType);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RequestStoreTypeWStr( 
            /* [in] */ LPWSTR szwType);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ContainerNameWStr( 
            /* [out] */ LPWSTR __RPC_FAR *szwContainer);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ContainerNameWStr( 
            /* [in] */ LPWSTR szwContainer);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ProviderNameWStr( 
            /* [out] */ LPWSTR __RPC_FAR *szwProvider);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ProviderNameWStr( 
            /* [in] */ LPWSTR szwProvider);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SPCFileNameWStr( 
            /* [out] */ LPWSTR __RPC_FAR *szw);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SPCFileNameWStr( 
            /* [in] */ LPWSTR szw);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PVKFileNameWStr( 
            /* [out] */ LPWSTR __RPC_FAR *szw);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_PVKFileNameWStr( 
            /* [in] */ LPWSTR szw);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_HashAlgorithmWStr( 
            /* [out] */ LPWSTR __RPC_FAR *szw);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_HashAlgorithmWStr( 
            /* [in] */ LPWSTR szw);
            
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RenewalCertificate( 
            /* [out] */ PCCERT_CONTEXT __RPC_FAR *ppCertContext);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RenewalCertificate( 
            /* [in] */ PCCERT_CONTEXT pCertContext);
            
        virtual HRESULT STDMETHODCALLTYPE AddCertTypeToRequestWStr( 
            LPWSTR szw);
            
        virtual HRESULT STDMETHODCALLTYPE AddNameValuePairToSignatureWStr( 
            /* [in] */ LPWSTR Name,
            /* [in] */ LPWSTR Value);
     
        virtual HRESULT STDMETHODCALLTYPE AddExtensionsToRequest( 
            PCERT_EXTENSIONS pCertExtensions);
        
        virtual HRESULT STDMETHODCALLTYPE AddAuthenticatedAttributesToPKCS7Request( 
            PCRYPT_ATTRIBUTES pAttributes);
        
        virtual HRESULT STDMETHODCALLTYPE CreatePKCS7RequestFromRequest( 
            PCRYPT_DATA_BLOB pRequest,
            PCCERT_CONTEXT pSigningCertContext,
            PCRYPT_DATA_BLOB pPkcs7Blob);

        virtual HRESULT STDMETHODCALLTYPE Reset(void);

        virtual HRESULT STDMETHODCALLTYPE GetSupportedKeySpec(
            LONG __RPC_FAR *pdwKeySpec);

        virtual HRESULT STDMETHODCALLTYPE InstallPKCS7Blob( 
            PCRYPT_DATA_BLOB pBlobPKCS7);

        virtual HRESULT STDMETHODCALLTYPE GetKeyLen(
            BOOL    fMin,
            BOOL    fExchange,
            LONG __RPC_FAR *pdwKeySize);

        virtual HRESULT STDMETHODCALLTYPE EnumAlgs(
            LONG dwIndex,
            LONG algMask,
            LONG __RPC_FAR *pdwAlgID);

        virtual HRESULT STDMETHODCALLTYPE GetAlgNameWStr(
            LONG  algID,
            LPWSTR __RPC_FAR *ppwsz);

        virtual HRESULT STDMETHODCALLTYPE GetAlgName(
            LONG algID,
            BSTR __RPC_FAR *pbstr);

        virtual HRESULT STDMETHODCALLTYPE put_ReuseHardwareKeyIfUnableToGenNew( 
            BOOL fReuseHardwareKeyIfUnableToGenNew);
        
        virtual HRESULT STDMETHODCALLTYPE get_ReuseHardwareKeyIfUnableToGenNew( 
            BOOL __RPC_FAR *fReuseHardwareKeyIfUnableToGenNew);

        virtual HRESULT STDMETHODCALLTYPE put_HashAlgID(
            LONG    hashAlgID);

        virtual HRESULT STDMETHODCALLTYPE get_HashAlgID(
            LONG *   hashAlgID);

        virtual HRESULT STDMETHODCALLTYPE SetHStoreMy(
            HCERTSTORE   hStore
            );
       
        virtual HRESULT STDMETHODCALLTYPE SetHStoreCA(
            HCERTSTORE   hStore
            );
       
        virtual HRESULT STDMETHODCALLTYPE SetHStoreROOT(
            HCERTSTORE   hStore
            );
       
        virtual HRESULT STDMETHODCALLTYPE SetHStoreRequest(
            HCERTSTORE   hStore
            );

        virtual HRESULT STDMETHODCALLTYPE  put_LimitExchangeKeyToEncipherment(
            BOOL    fLimitExchangeKeyToEncipherment
            );

        virtual HRESULT STDMETHODCALLTYPE  get_LimitExchangeKeyToEncipherment(
            BOOL * fLimitExchangeKeyToEncipherment
            );

        virtual HRESULT STDMETHODCALLTYPE  put_EnableSMIMECapabilities(
            BOOL fEnableSMIMECapabilities
            );

        virtual HRESULT STDMETHODCALLTYPE  get_EnableSMIMECapabilities(
            BOOL * fEnableSMIMECapabilities
            );

//ICEnroll4

        virtual HRESULT STDMETHODCALLTYPE put_PrivateKeyArchiveCertificate(
            IN  BSTR  bstrCert
            );

        virtual HRESULT STDMETHODCALLTYPE get_PrivateKeyArchiveCertificate(
            OUT BSTR __RPC_FAR *pbstrCert
            );

        virtual HRESULT STDMETHODCALLTYPE binaryToString(
            IN  LONG  Flags,
            IN  BSTR  strBinary,
            OUT BSTR *pstrEncoded
            );

        virtual HRESULT STDMETHODCALLTYPE stringToBinary(
            IN  LONG  Flags,
            IN  BSTR  strEncoded,
            OUT BSTR *pstrBinary
            );

        virtual HRESULT STDMETHODCALLTYPE addExtensionToRequest(
            IN  LONG  Flags,
            IN  BSTR  strName,
            IN  BSTR  strValue
            );

        virtual HRESULT STDMETHODCALLTYPE addAttributeToRequest(
            IN  LONG  Flags,
            IN  BSTR  strName,
            IN  BSTR  strValue
            );

        virtual HRESULT STDMETHODCALLTYPE addNameValuePairToRequest(
            IN  LONG  Flags,
            IN  BSTR  strName,
            IN  BSTR  strValue
            );

        virtual HRESULT STDMETHODCALLTYPE createRequest(
            IN  LONG  Flags,
            IN  BSTR  strDNName,
            IN  BSTR  strUsage,
            OUT BSTR *pstrRequest    
            );

        virtual HRESULT STDMETHODCALLTYPE createFileRequest(
            IN  LONG  Flags,
            IN  BSTR  strDNName,
            IN  BSTR  strUsage,
            IN  BSTR  strRequestFileName
            );

        virtual HRESULT STDMETHODCALLTYPE acceptResponse(
            IN  BSTR  strResponse
            );

        virtual HRESULT STDMETHODCALLTYPE acceptFileResponse(
            IN  BSTR  strResponseFileName
            );

        virtual HRESULT STDMETHODCALLTYPE getCertFromResponse(
            IN  BSTR  strResponse,
            OUT BSTR *pstrCert
            );

        virtual HRESULT STDMETHODCALLTYPE getCertFromFileResponse(
            IN  BSTR  strResponseFileName,
            OUT BSTR *pstrCert
            );

        virtual HRESULT STDMETHODCALLTYPE createPFX(
            IN  BSTR  strPassword,
            OUT BSTR *pstrPFX
            );

        virtual HRESULT STDMETHODCALLTYPE createFilePFX(
            IN  BSTR  strPassword,
            IN  BSTR  strPFXFileName
            );

        virtual HRESULT STDMETHODCALLTYPE setPendingRequestInfo(
            IN  LONG  lRequestID,
            IN  BSTR  strCADNS,
            IN  BSTR  strCAName,
            IN  BSTR  strFriendlyName
            );

        virtual HRESULT STDMETHODCALLTYPE enumPendingRequest(
            IN  LONG  lIndex,
            IN  LONG  lDesiredProperty,
            OUT VARIANT *pvarProperty
            );

        virtual HRESULT STDMETHODCALLTYPE removePendingRequest(
            IN  BSTR  strThumbprint
            );

        virtual HRESULT STDMETHODCALLTYPE InstallPKCS7Ex(
            IN  BSTR        PKCS7,
            OUT LONG __RPC_FAR *plCertInstalled
            );

        virtual HRESULT STDMETHODCALLTYPE addBlobPropertyToCertificate(
            IN  LONG   lPropertyId,
            IN  LONG   lFlags,
            IN  BSTR   strProperty
        );
        virtual HRESULT STDMETHODCALLTYPE put_SignerCertificate(
            IN  BSTR  bstrCert
            );

//IEnroll4

        virtual HRESULT STDMETHODCALLTYPE SetPrivateKeyArchiveCertificate(
	        IN PCCERT_CONTEXT  pPrivateKeyArchiveCert
            );
    		
        virtual PCCERT_CONTEXT STDMETHODCALLTYPE GetPrivateKeyArchiveCertificate(
            void
            );
    
        virtual HRESULT STDMETHODCALLTYPE binaryBlobToString(
            IN   LONG               Flags,
            IN   PCRYPT_DATA_BLOB   pblobBinary,
            OUT  LPWSTR            *ppwszString
            );

        virtual HRESULT STDMETHODCALLTYPE stringToBinaryBlob(
            IN   LONG               Flags,
            IN   LPCWSTR            pwszString,
            OUT  PCRYPT_DATA_BLOB   pblobBinary,
            OUT  LONG              *pdwSkip,
            OUT  LONG              *pdwFlags
            );

        virtual HRESULT STDMETHODCALLTYPE addExtensionToRequestWStr(
            IN   LONG               Flags,
            IN   LPCWSTR            pwszName,
            IN   PCRYPT_DATA_BLOB   pblobValue
            );

        virtual HRESULT STDMETHODCALLTYPE addAttributeToRequestWStr(
            IN   LONG               Flags,
            IN   LPCWSTR            pwszName,
            IN   PCRYPT_DATA_BLOB   pblobValue
            );

        virtual HRESULT STDMETHODCALLTYPE addNameValuePairToRequestWStr(
            IN   LONG         Flags,
            IN   LPCWSTR      pwszName,
            IN   LPCWSTR      pwszValue
            );

        virtual HRESULT STDMETHODCALLTYPE createRequestWStr(
            IN   LONG              Flags,
            IN   LPCWSTR           pwszDNName,
            IN   LPCWSTR           pwszUsage,
            OUT  PCRYPT_DATA_BLOB  pblobRequest
            );

        virtual HRESULT STDMETHODCALLTYPE createFileRequestWStr(
            IN   LONG        Flags,
            IN   LPCWSTR     pwszDNName,
            IN   LPCWSTR     pwszUsage,
            IN   LPCWSTR     pwszRequestFileName
            );

        virtual HRESULT STDMETHODCALLTYPE acceptResponseBlob(
            IN   PCRYPT_DATA_BLOB   pblobResponse
            );

        virtual HRESULT STDMETHODCALLTYPE acceptFileResponseWStr(
            IN   LPCWSTR     pwszResponseFileName
            );

        virtual HRESULT STDMETHODCALLTYPE getCertContextFromResponseBlob(
            IN   PCRYPT_DATA_BLOB   pblobResponse,
            OUT  PCCERT_CONTEXT    *ppCertContext
            );

        virtual HRESULT STDMETHODCALLTYPE getCertContextFromFileResponseWStr(
            IN   LPCWSTR          pwszResponseFileName,
            OUT  PCCERT_CONTEXT  *ppCertContext
            );

        virtual HRESULT STDMETHODCALLTYPE createPFXWStr(
            IN   LPCWSTR           pwszPassword,
            OUT  PCRYPT_DATA_BLOB  pblobPFX
            );

        virtual HRESULT STDMETHODCALLTYPE createFilePFXWStr(
            IN   LPCWSTR     pwszPassword,
            IN   LPCWSTR     pwszPFXFileName
            );

        virtual HRESULT STDMETHODCALLTYPE setPendingRequestInfoWStr(
            IN   LONG     lRequestID,
            IN   LPCWSTR  pwszCADNS,
            IN   LPCWSTR  pwszCAName,
            IN   LPCWSTR  pwszFriendlyName
            );

        virtual HRESULT STDMETHODCALLTYPE removePendingRequestWStr(
            IN  CRYPT_DATA_BLOB thumbPrintBlob
            );

        virtual HRESULT STDMETHODCALLTYPE enumPendingRequestWStr(
            IN  LONG  lIndex,
            IN  LONG  lDesiredProperty,
            OUT LPVOID ppProperty
            );


        virtual HRESULT STDMETHODCALLTYPE InstallPKCS7BlobEx( 
            IN PCRYPT_DATA_BLOB pBlobPKCS7,
            OPTIONAL OUT LONG  *plCertInstalled);

        virtual HRESULT STDMETHODCALLTYPE addCertTypeToRequestEx( 
            IN  LONG            lType,
            IN  BSTR            bstrOIDOrName,
            IN  LONG            lMajorVersion,
            IN  BOOL            fMinorVersion,
            IN  LONG            lMinorVersion
            );
            
        virtual HRESULT STDMETHODCALLTYPE AddCertTypeToRequestWStrEx( 
            IN  LONG            lType,
            IN  LPCWSTR         pwszOIDOrName,
            IN  LONG            lMajorVersion,
            IN  BOOL            fMinorVersion,
            IN  LONG            lMinorVersion
            );

        virtual HRESULT STDMETHODCALLTYPE getProviderType(
            IN  BSTR            strProvName,
            OUT LONG           *lpProvType
            );

        virtual HRESULT STDMETHODCALLTYPE getProviderTypeWStr(
            IN  LPCWSTR         pwszProvName,
            OUT LONG           *lpProvType
            );

        virtual HRESULT STDMETHODCALLTYPE addBlobPropertyToCertificateWStr(
            IN  LONG               lPropertyId,
            IN  LONG               lFlags,
            IN  PCRYPT_DATA_BLOB   pBlobProperty
        );

        virtual HRESULT STDMETHODCALLTYPE SetSignerCertificate(
	        IN PCCERT_CONTEXT  pSignerCert
            );
    		
        
//both ICEnroll4 and IEnroll4
        virtual HRESULT STDMETHODCALLTYPE resetExtensions(
            void
            );

        virtual HRESULT STDMETHODCALLTYPE resetAttributes(
            void
            );

        virtual HRESULT STDMETHODCALLTYPE resetBlobProperties(
            void
            );

        virtual HRESULT STDMETHODCALLTYPE GetKeyLenEx(
            IN  LONG    lSizeSpec,
            IN  LONG    lKeySpec,
            OUT LONG __RPC_FAR *plKeySize
            );

        virtual HRESULT STDMETHODCALLTYPE get_ClientId( 
            OUT LONG __RPC_FAR *plClientId);
        
        virtual HRESULT STDMETHODCALLTYPE put_ClientId( 
            IN  LONG lClientId);
        
        virtual HRESULT STDMETHODCALLTYPE get_IncludeSubjectKeyID( 
            OUT BOOL __RPC_FAR *pfInclude);
        
        virtual HRESULT STDMETHODCALLTYPE put_IncludeSubjectKeyID( 
            IN  BOOL lfInclude);
        
 private:

        HRESULT Init(void);
        void Destruct(void);

		HCERTSTORE GetStore(
			StoreType storeType
			);
			
		void FlushStore(
			StoreType storeType
			);
			
		HCRYPTPROV GetProv(
			DWORD dwFlags
			);
			
		BOOL SetKeyParams(
    		PCRYPT_KEY_PROV_INFO pKeyProvInfo
    		);

        HRESULT AddCertsToStores(
            HCERTSTORE    hStoreMsg,
            LONG         *plCertInstalled
            );

		HRESULT GetEndEntityCert(
		    PCRYPT_DATA_BLOB    pBlobPKCS7,
		    BOOL                fSaveToStores,
		    PCCERT_CONTEXT     *ppCert
		    );

        HRESULT BStringToFile(
            IN BSTR         bString,
            IN LPCWSTR      pwszFileName);

        HRESULT BlobToBstring(
            IN   CRYPT_DATA_BLOB   *pBlob,
            IN   DWORD              dwFlag,
            OUT  BSTR              *pBString);

        HRESULT BstringToBlob(
            IN  BSTR              bString,
            OUT CRYPT_DATA_BLOB  *pBlob);

        HRESULT GetCertFromResponseBlobToBStr(
            IN  CRYPT_DATA_BLOB  *pBlobResponse,
            OUT BSTR             *pstrCert);

		HRESULT createPKCS10WStrBStr( 
            LPCWSTR DNName,
            LPCWSTR wszPurpose,
            BSTR __RPC_FAR *pPKCS10);

		HRESULT createPFXWStrBStr( 
            IN  LPCWSTR         pwszPassword,
            OUT BSTR __RPC_FAR *pbstrPFX);

        HRESULT createRequestWStrBStr(
            IN   LONG              Flags,
            IN   LPCWSTR           pwszDNName,
            IN   LPCWSTR           pwszUsage,
            IN   DWORD             dwFlag,
            OUT  BSTR __RPC_FAR   *pbstrRequest);

       	BOOL GetCapiHashAndSigAlgId(ALG_ID rgAlg[2]);
       	
       	DWORD GetKeySizeInfo(
            LONG    lKeySizeSpec,
            DWORD   algClass
            );

        HRESULT GetKeyArchivePKCS7(CRYPT_ATTR_BLOB *pBlobKeyArchivePKCS7);

        BOOL CopyAndPushStackExtension(PCERT_EXTENSION pExt, BOOL fNewRequestMethod);
        PCERT_EXTENSION PopStackExtension(BOOL fNewRequestMethod);
        DWORD CountStackExtension(BOOL fNewRequestMethod);
        void FreeStackExtension(PCERT_EXTENSION pExt);
        PCERT_EXTENSION EnumStackExtension(PCERT_EXTENSION pExtLast, BOOL fNewRequestMethod);
        void FreeAllStackExtension(void);
 
        BOOL CopyAndPushStackAttribute(PCRYPT_ATTRIBUTE pAttr, BOOL fNewRequestMethod);
        PCRYPT_ATTRIBUTE PopStackAttribute(BOOL fNewRequestMethod);
        DWORD CountStackAttribute(BOOL fNewRequestMethod);
        void FreeStackAttribute(PCRYPT_ATTRIBUTE pAttr);
        PCRYPT_ATTRIBUTE EnumStackAttribute(PCRYPT_ATTRIBUTE pAttrLast, BOOL fNewRequestMethod);
        void FreeAllStackAttribute(void);

        HANDLE CreateOpenFileSafely(
            LPCWSTR wsz,
            BOOL    fCreate);
        HANDLE CreateFileSafely(
            LPCWSTR wsz);
        HANDLE OpenFileSafely(
            LPCWSTR wsz);
        HANDLE CreateOpenFileSafely2(
            LPCWSTR wsz,
            DWORD idsCreate,
            DWORD idsOverwrite);
        BOOL fIsRequestStoreSafeForScripting(void);

        HRESULT
        xeStringToBinaryFromFile(
            IN  WCHAR const *pwszfn,
            OUT BYTE       **ppbOut,
            OUT DWORD       *pcbOut,
            IN  DWORD        Flags);

        HRESULT PKCS7ToCert(IN   HCERTSTORE        hCertStore,
			    IN   CRYPT_DATA_BLOB   pkcs10Blob, 
			    OUT  PCCERT_CONTEXT   *ppCertContext);

        HRESULT PKCS10ToCert(IN   HCERTSTORE        hCertStore,
			     IN   CRYPT_DATA_BLOB   pkcs10Blob, 
			     OUT  PCCERT_CONTEXT   *ppCertContext);

        PPROP_STACK EnumStackProperty(PPROP_STACK pProp);
 
        HRESULT GetGoodCertContext(
            IN PCCERT_CONTEXT pCertContext,
            OUT PCCERT_CONTEXT *ppGoodCertContext);

        HRESULT GetVerifyProv();

private:


	PCCERT_CONTEXT			m_PrivateKeyArchiveCertificate;
	PCCERT_CONTEXT			m_pCertContextRenewal;
	PCCERT_CONTEXT			m_pCertContextSigner;
	PCCERT_CONTEXT			m_pCertContextStatic;

	PendingRequestTable            *m_pPendingRequestTable; 
	
	// The cert last created through createPKCS10().  This is used as the target
	// of setPendingRequestInfo() if no other target is specified by the client. 
	PCCERT_CONTEXT                  m_pCertContextPendingRequest; 

	// The HASH of the current request created with the xenroll instance. 
	// This value is set through the put_ThumbPrint() method, and is used to 
	// determine the target cert of the setPendingRequestInfo() operation. 
	// If this value is not set through the put_ThumbPrint() method, it will be 
	// NULL, and m_pCertContextPendingRequest will contain the target cert.  
	CRYPT_DATA_BLOB                 m_hashBlobPendingRequest; 
	
	// Used to keep track of last enumerated element in enumPendingRequestWStr
	PCCERT_CONTEXT                  m_pCertContextLastEnumerated; 
	DWORD                           m_dwCurrentPendingRequestIndex; 

	BYTE                    m_arHashBytesNewCert[20];
	BYTE                    m_arHashBytesOldCert[20];
	BOOL                    m_fArchiveOldCert;
	CRYPT_KEY_PROV_INFO		m_keyProvInfo;
	HCRYPTPROV				m_hProv;
	HCRYPTPROV				m_hVerifyProv;
	CRITICAL_SECTION		m_csXEnroll;
	BOOL					m_fWriteCertToUserDS;
	BOOL					m_fWriteCertToUserDSModified;
	BOOL					m_fWriteCertToCSP;
	BOOL					m_fWriteCertToCSPModified;
	BOOL					m_fDeleteRequestCert;
	BOOL					m_fUseExistingKey;
	BOOL					m_fMyStoreOpenFlagsModified;
	BOOL					m_fCAStoreOpenFlagsModified;
	BOOL					m_fRootStoreOpenFlagsModified;
	BOOL					m_fRequestStoreOpenFlagsModified;
	BOOL                    m_fReuseHardwareKeyIfUnableToGenNew;
	BOOL                    m_fLimitExchangeKeyToEncipherment;
	BOOL                    m_fEnableSMIMECapabilities;
	BOOL                    m_fSMIMESetByClient;
	BOOL                    m_fKeySpecSetByClient;
	DWORD					m_dwT61DNEncoding;
	DWORD const                   m_dwEnabledSafteyOptions;
	DWORD					m_dwGenKeyFlags;
	STOREINFO				m_MyStore;
	STOREINFO				m_CAStore;
	STOREINFO				m_RootStore;
	STOREINFO				m_RequestStore;
	LPWSTR					m_wszSPCFileName;
	LPWSTR					m_wszPVKFileName;
	DWORD					m_HashAlgId;

	PEXT_STACK				m_pExtStack;
	DWORD					m_cExtStack;
	PATTR_STACK				m_pAttrStack;
	DWORD					m_cAttrStack;

    PEXT_STACK              m_pExtStackNew;
	DWORD					m_cExtStackNew;
	PATTR_STACK				m_pAttrStackNew;
	DWORD					m_cAttrStackNew;
    BOOL                    m_fNewRequestMethod;
    BOOL                    m_fHonorRenew;
    BOOL                    m_fOID_V2;
    HCRYPTKEY               m_hCachedKey;
    BOOL                    m_fUseClientKeyUsage;
    BOOL                    m_fCMCFormat;
	PPROP_STACK             m_pPropStack;
	DWORD                   m_cPropStack;
    LONG                    m_lClientId;
    DWORD                   m_dwLastAlgIndex;
    BOOL                    m_fIncludeSubjectKeyID;
    BOOL                    m_fHonorIncludeSubjectKeyID;
    PCERT_PUBLIC_KEY_INFO   m_pPublicKeyInfo;
	CRYPT_HASH_BLOB         m_blobResponseKAHash;
    DWORD                   m_dwSigKeyLenMax;
    DWORD                   m_dwSigKeyLenMin;
    DWORD                   m_dwSigKeyLenDef;
    DWORD                   m_dwSigKeyLenInc;
    DWORD                   m_dwXhgKeyLenMax;
    DWORD                   m_dwXhgKeyLenMin;
    DWORD                   m_dwXhgKeyLenDef;
    DWORD                   m_dwXhgKeyLenInc;
};

BOOL GetSignatureFromHPROV(
                           IN HCRYPTPROV hProv,
                           OUT BYTE **ppbSignature,
                           DWORD *pcbSignature
                           );

PCCERT_CONTEXT
WINAPI
MyCertCreateSelfSignCertificate(
    IN          HCRYPTPROV                  hProv,          
    IN          PCERT_NAME_BLOB             pSubjectIssuerBlob,
    IN          DWORD                       dwFlags,
    OPTIONAL    PCRYPT_KEY_PROV_INFO        pKeyProvInfo,
    OPTIONAL    PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
    OPTIONAL    PSYSTEMTIME                 pStartTime,
    OPTIONAL    PSYSTEMTIME                 pEndTime,
    OPTIONAL    PCERT_EXTENSIONS            pExtensions
    ) ;

BOOL
WINAPI
MyCryptQueryObject(DWORD                dwObjectType,
                       const void       *pvObject,
                       DWORD            dwExpectedContentTypeFlags,
                       DWORD            dwExpectedFormatTypeFlags,
                       DWORD            dwFlags,
                       DWORD            *pdwMsgAndCertEncodingType,
                       DWORD            *pdwContentType,
                       DWORD            *pdwFormatType,
                       HCERTSTORE       *phCertStore,
                       HCRYPTMSG        *phMsg,
                       const void       **ppvContext);

BOOL
WINAPI
MyCertStrToNameW(
    IN DWORD                dwCertEncodingType,
    IN LPCWSTR              pwszX500,
    IN DWORD                dwStrType,
    IN OPTIONAL void *      pvReserved,
    OUT BYTE *              pbEncoded,
    IN OUT DWORD *          pcbEncoded,
    OUT OPTIONAL LPCWSTR *  ppwszError
    );

BOOL
WINAPI
MyCryptVerifyMessageSignature
(IN            PCRYPT_VERIFY_MESSAGE_PARA   pVerifyPara,
 IN            DWORD                        dwSignerIndex,
 IN            BYTE const                  *pbSignedBlob,
 IN            DWORD                        cbSignedBlob,
 OUT           BYTE                        *pbDecoded,
 IN OUT        DWORD                       *pcbDecoded,
 OUT OPTIONAL  PCCERT_CONTEXT              *ppSignerCert);


extern "C" BOOL WINAPI InitIE302UpdThunks(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved);


BOOL
MyCryptStringToBinaryA(
    IN     LPCSTR  pszString,
    IN     DWORD     cchString,
    IN     DWORD     dwFlags,
    IN     BYTE     *pbBinary,
    IN OUT DWORD    *pcbBinary,
    OUT    DWORD    *pdwSkip,    //OPTIONAL
    OUT    DWORD    *pdwFlags    //OPTIONAL
    );

BOOL
MyCryptStringToBinaryW(
    IN     LPCWSTR  pszString,
    IN     DWORD     cchString,
    IN     DWORD     dwFlags,
    IN     BYTE     *pbBinary,
    IN OUT DWORD    *pcbBinary,
    OUT    DWORD    *pdwSkip,    //OPTIONAL
    OUT    DWORD    *pdwFlags    //OPTIONAL
    );

BOOL
MyCryptBinaryToStringA(
    IN     CONST BYTE  *pbBinary,
    IN     DWORD        cbBinary,
    IN     DWORD        dwFlags,
    IN     LPSTR      pszString,
    IN OUT DWORD       *pcchString
    );

BOOL
MyCryptBinaryToStringW(
    IN     CONST BYTE  *pbBinary,
    IN     DWORD        cbBinary,
    IN     DWORD        dwFlags,
    IN     LPWSTR      pszString,
    IN OUT DWORD       *pcchString
    );

HRESULT
xeLoadRCString(
    HINSTANCE      hInstance,
    IN int         iRCId,
    OUT WCHAR    **ppwsz);

#endif //__CENROLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xenroll\getsig.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : getsig.cpp                                             //
//  DESCRIPTION   : Crypto API interface                                   //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Mar  5 1998 jeffspel                                                //
//                                                                         //
//  Copyright (C) Microsoft Corporation, 1996 - 1999All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <wincrypt.h>
#include <stdlib.h>
#include <stddef.h>
#include <stdio.h>

// designatred resource for in file signatures
#define CRYPT_SIG_RESOURCE_NUMBER   "#666"      

/*++

GetCryptSigResourcePtr:

    Given hInst, allocs and returns pointers to signature pulled from
    resource

Arguments:

    IN  hInst - Handle to the loaded file
    OUT ppbRsrcSig - Signature from the resource
    OUT pcbRsrcSig- Length of the signature from the resource

Return Value:

    TRUE - Success
    FALSE - Error

--*/
BOOL GetCryptSigResourcePtr(
                            HMODULE hInst,
                            BYTE **ppbRsrcSig,
                            DWORD *pcbRsrcSig
                            )
{
    HRSRC   hRsrc;
    BOOL    fRet = FALSE;

    // Nab resource handle for our signature
    if (NULL == (hRsrc = FindResource(hInst, CRYPT_SIG_RESOURCE_NUMBER,
                                      RT_RCDATA)))
        goto Ret;
    
    // get a pointer to the actual signature data
    if (NULL == (*ppbRsrcSig = (PBYTE)LoadResource(hInst, hRsrc)))
        goto Ret;

    // determine the size of the resource
    if (0 == (*pcbRsrcSig = SizeofResource(hInst, hRsrc)))
        goto Ret;

    fRet = TRUE;
Ret:
    return fRet;
}

/*++

GetCryptSignatureResource:

    Gets the signature from the file resource.

Arguments:

    IN  szFile - Name of the file to get the signature from
    OUT ppbSignature - Signature of the specified provider
    OUT pcbSignature- Length of the signature of the specified provider

Return Value:

    TRUE - Success
    FALSE - Error

--*/
BOOL GetCryptSignatureResource(
                               IN LPCSTR pszFile,
                               OUT BYTE **ppbSig,
                               OUT DWORD *pcbSig
                               )
{
    HMODULE hInst = NULL;
    BYTE    *pbSig;
    DWORD   cbTemp = 0;
    LPSTR   pszDest = NULL;
    DWORD   cbSig;
    BOOL    fRet = FALSE;

    // expand the path if necessary
    if (0 == (cbTemp = ExpandEnvironmentStrings(pszFile, (CHAR *) &pszDest,
                                                cbTemp)))
    {
        goto Ret;
    }
    if (NULL == (pszDest = (LPSTR)LocalAlloc(LMEM_ZEROINIT,
                                             (UINT)cbTemp)))
    {
        goto Ret;
    }
    if (0 == (cbTemp = ExpandEnvironmentStrings(pszFile, pszDest,
                                                cbTemp)))
    {
        goto Ret;
    }

    // Load the file as a datafile
    if (NULL == (hInst = LoadLibraryEx(pszDest, NULL, LOAD_LIBRARY_AS_DATAFILE)))
    {
        goto Ret;
    }
    if (!GetCryptSigResourcePtr(hInst, &pbSig, &cbSig))
    {
        goto Ret;
    }

    *pcbSig = cbSig - (sizeof(DWORD) * 2);
    if (NULL == (*ppbSig = (BYTE*)LocalAlloc(LMEM_ZEROINIT, *pcbSig)))
        goto Ret;

    memcpy(*ppbSig, pbSig + (sizeof(DWORD) * 2), *pcbSig);

    fRet = TRUE;
Ret:
    if (pszDest)
        LocalFree(pszDest);
    if (hInst)
        FreeLibrary(hInst);
    return fRet;
}

#define PROV_INITIAL_REG_PATH  "Software\\Microsoft\\Cryptography\\Defaults\\Provider\\"

/*++

CheckForSignatureInRegistry:

    Check if signature is in the registry, if so then get it
    if it isn't then get the filename for the provider

Arguments:

    IN  hProv - Handle to the provider to get the signature of
    OUT ppbSignature - Signature of the specified provider if in registry
    OUT pcbSignature - Length of the signature of the specified provider
                       if in the registry
    OUT pszProvFile - Provider file name if signature is not in registry
    OUT pfSigInReg - TRUE if signature is in the registry

Return Value:

    TRUE - Success
    FALSE - Error

--*/
BOOL CheckForSignatureInRegistry(
                                 IN HCRYPTPROV hProv,
                                 OUT BYTE **ppbSignature,
                                 OUT DWORD *pcbSignature,
                                 OUT LPSTR *ppszProvFile,
                                 OUT BOOL *pfSigInReg
                                 )
{
    HKEY    hRegKey = 0;
    LPSTR   pszProvName = NULL;
    DWORD   cbProvName;
    LPSTR   pszFullRegPath = NULL;
    DWORD   cbFullRegPath;
    DWORD   dwType;
    DWORD   cbData;
    BOOL    fRet = FALSE;

    *pfSigInReg = TRUE;

    // get the provider name
    if (!CryptGetProvParam(hProv, PP_NAME, NULL, &cbProvName, 0))
        goto Ret;
    if (NULL == (pszProvName = (LPSTR)LocalAlloc(LMEM_ZEROINIT, cbProvName)))
        goto Ret;
    if (!CryptGetProvParam(hProv, PP_NAME, (BYTE*)pszProvName,
                           &cbProvName, 0))
    {
        goto Ret;
    }

    // open the registry key of the provider
    cbFullRegPath = sizeof(PROV_INITIAL_REG_PATH) + (DWORD)strlen(pszProvName) + 1;
    if (NULL == (pszFullRegPath = (LPSTR)LocalAlloc(LMEM_ZEROINIT,
                                                    cbFullRegPath)))
    {
        goto Ret;
    }
    strcpy(pszFullRegPath, PROV_INITIAL_REG_PATH);
    strcat(pszFullRegPath, pszProvName);
    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                      pszFullRegPath, 0,
                                      KEY_READ, &hRegKey))
        goto Ret; 

    // Check if SigInFile entry is there
    // NOTE : this may change in the next couple weeks
    if (ERROR_SUCCESS == RegQueryValueEx(hRegKey, "SigInFile", NULL, &dwType,
                                         NULL, &cbData))
    {
        // get the file name
        if (ERROR_SUCCESS != RegQueryValueEx(hRegKey, "Image Path",
                                             NULL, &dwType,
                                             NULL, &cbData))
            goto Ret;
        if (NULL == (*ppszProvFile = (LPSTR)LocalAlloc(LMEM_ZEROINIT, cbData)))
            goto Ret;
        if (ERROR_SUCCESS != RegQueryValueEx(hRegKey, "Image Path",
                                             NULL, &dwType,
                                             (BYTE*)*ppszProvFile, &cbData))
            goto Ret;

        *pfSigInReg = FALSE;
    }
    else
    {
        // get signature from registry
        if (ERROR_SUCCESS != RegQueryValueEx(hRegKey, "Signature",
                                             NULL, &dwType,
                                             NULL, pcbSignature))
            goto Ret;
        if (NULL == (*ppbSignature = (BYTE*)LocalAlloc(LMEM_ZEROINIT,
                                                       *pcbSignature)))
            goto Ret;
        if (ERROR_SUCCESS != RegQueryValueEx(hRegKey, "Signature",
                                             NULL, &dwType,
                                             *ppbSignature, pcbSignature))
            goto Ret;
    }

    fRet = TRUE;
Ret:
    if (pszProvName)
        LocalFree(pszProvName);
    if (pszFullRegPath)
        LocalFree(pszFullRegPath);
    if (hRegKey)
        RegCloseKey(hRegKey);
    return fRet;
}

/*++

GetSignatureFromHPROV:

    Gets the signature of a provider associated with the passed in
    HCRYPTPROV.

Arguments:

    IN  hProv - Handle to the provider to get the signature of
    OUT ppbSignature - Signature of the specified provider
    OUT pcbSignature- Length of the signature of the specified provider

Return Value:

    TRUE - Success
    FALSE - Error

--*/
BOOL GetSignatureFromHPROV(
                           IN HCRYPTPROV hProv,
                           OUT BYTE **ppbSignature,
                           DWORD *pcbSignature
                           )
{
    LPSTR   pszProvFile = NULL;
    BOOL    fSigInReg;
    BOOL    fRet = FALSE;

    // Check if signature is in the registry, if so then get it
    // if it isn't then get the filename for the provider
    if (!CheckForSignatureInRegistry(hProv, ppbSignature, pcbSignature,
                                     &pszProvFile, &fSigInReg))
        goto Ret;

    if (!fSigInReg)
    {
        //
        // Get the signature from the resource in the file
        //

        if (!GetCryptSignatureResource(pszProvFile, ppbSignature,
                                       pcbSignature))
        {
            goto Ret;
        }
    }

    fRet = TRUE;
Ret:
    if (pszProvFile)
        LocalFree(pszProvFile);
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xenroll\makefile.inc ===
xenroll_i.c : $(PROJECT_ROOT)\published\xenroll\xenroll_i.c
    copy $** $@

$(O)\xenroll.tlb : $(PROJECT_ROOT)\published\xenroll\$(O)\xenroll.tlb
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xenroll\cenroll.cpp ===
//depot/Lab03_DEV/Ds/security/cryptoapi/pki/activex/xenroll/cenroll.cpp#4 - edit change 19979 (text)
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cenroll.cpp
//
//--------------------------------------------------------------------------

// CEnroll.cpp : Implementation of CCEnroll


#include "stdafx.h"

#include <windows.h>
#include <wincrypt.h>
#include <unicode.h>
#define SECURITY_WIN32
#include <security.h>
#include <aclapi.h>
#include <pvk.h>
#include <wintrust.h>
#include <xasn.h>
#include <autoenr.h>
#include <sddl.h>

#include "xenroll.h"
#include "cenroll.h"
#include "xelib.h"
#include "sfscript.h"

#define NO_OSS_DEBUG
#include <dbgdef.h>

#include <string.h>

#include <assert.h>

static LPVOID (* MyCoTaskMemAlloc)(ULONG) = NULL;
static LPVOID (* MyCoTaskMemRealloc)(LPVOID, ULONG) = NULL;
static void (* MyCoTaskMemFree)(LPVOID) = NULL;

#define MY_HRESULT_FROM_WIN32(a) ((a >= 0x80000000) ? a : HRESULT_FROM_WIN32(a))

#ifndef NTE_TOKEN_KEYSET_STORAGE_FULL
#define NTE_TOKEN_KEYSET_STORAGE_FULL _HRESULT_TYPEDEF_(0x80090023L)
#endif

#define CEnrollLocalScope(ScopeName) struct ScopeName##TheLocalScope { public
#define CEnrollEndLocalScope } local

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

#pragma warning(disable:4213) // nonstandard extension used : cast on l-value


static LPSTR MBFromWide(LPCWSTR wsz) {

    LPSTR   sz = NULL;
    DWORD   cb = 0;

    assert(wsz != NULL);
    if(wsz == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    if( (cb = WideCharToMultiByte(0, 0, wsz, -1, NULL, 0, NULL, NULL)) == 0   ||
        (sz = (char *) MyCoTaskMemAlloc(cb)) == NULL  ||
        (cb = WideCharToMultiByte(0, 0, wsz, -1, sz, cb, NULL, NULL)) == 0 ) {

        if(GetLastError() == ERROR_SUCCESS)
            SetLastError(ERROR_OUTOFMEMORY);

        return(NULL);
    }

    return(sz);
}

static LPWSTR WideFromMB(LPCSTR sz) {

    DWORD   cch     = 0;
    LPWSTR  wsz     = NULL;

    assert(sz != NULL);
    if(sz == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    if( (cch = MultiByteToWideChar(0, 0, sz, -1, NULL, 0)) == 0   ||
        (wsz = (WCHAR *) MyCoTaskMemAlloc(cch * sizeof(WCHAR))) == NULL  ||
        (cch = MultiByteToWideChar(0, 0, sz, -1, wsz, cch)) == 0) {

        if(GetLastError() == ERROR_SUCCESS)
            SetLastError(ERROR_OUTOFMEMORY);

        return(NULL);
    }

    return(wsz);
}

static BSTR
BSTRFromMB(LPCSTR sz)
{
    BSTR    bstr    = NULL;
    DWORD   cch     = 0;
    WCHAR  *pwsz     = NULL;
    BOOL    fFail = FALSE;

    assert(sz != NULL);
    if(sz == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }
 
    while (TRUE)
    {
        if(0 == (cch = MultiByteToWideChar(0, 0, sz, -1, pwsz, cch)))
        {
            //error
            fFail = TRUE;
            break;
        }
        if (NULL != pwsz)
        {
            //done
            break;
        }
        pwsz = (WCHAR *)LocalAlloc(LMEM_FIXED, cch * sizeof(WCHAR));
        if (NULL == pwsz)
        {
            //error
            if(GetLastError() == ERROR_SUCCESS)
                SetLastError(ERROR_OUTOFMEMORY);
            break;
        }
    }

    if (!fFail && NULL != pwsz)
    {
        bstr = SysAllocString(pwsz);
        if (NULL == bstr)
        {
            if(GetLastError() == ERROR_SUCCESS)
                SetLastError(ERROR_OUTOFMEMORY);
        }
    }

    if (NULL != pwsz)
    {
        LocalFree(pwsz);
    }
    return(bstr);
}

static LPWSTR CopyWideString(LPCWSTR wsz) {

    size_t  cch     = 0;
    LPWSTR  wszOut  = NULL;

    // shouldn't send in a NULL
    assert(wsz != NULL);
    if(wsz == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    cch = wcslen(wsz) + 1;
    if (cch*sizeof(WCHAR) > (ULONG)-1) { 
	// prevent errors caused by conversion from size_t --> ULONG
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }
	

    if( (wszOut = (LPWSTR) MyCoTaskMemAlloc((ULONG)(sizeof(WCHAR) * cch))) == NULL ) {
        SetLastError(ERROR_OUTOFMEMORY);
        return(NULL);
    }

    wcscpy(wszOut, wsz);

    return(wszOut);
}

static LPSTR CopyAsciiString(LPCSTR sz) {

    size_t  cch     = 0;
    LPSTR   szOut   = NULL;

    // shouldn't send in a NULL
    assert(sz != NULL);
    if(sz == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    cch = strlen(sz) + 1;
    if (cch > (ULONG)-1) { 
	// prevent errors caused by conversion from size_t --> ULONG
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }
	

    if( (szOut = (LPSTR) MyCoTaskMemAlloc((ULONG)cch)) == NULL ) {
        SetLastError(ERROR_OUTOFMEMORY);
        return(NULL);
    }

    strcpy(szOut, sz);

    return(szOut);
}

static DWORD KeyLocationFromStoreLocation(DWORD dwStoreFlags) {

    if(
        ((CERT_SYSTEM_STORE_LOCATION_MASK & dwStoreFlags) == CERT_SYSTEM_STORE_CURRENT_USER) ||
        ((CERT_SYSTEM_STORE_LOCATION_MASK & dwStoreFlags) == CERT_SYSTEM_STORE_USERS) ||
        ((CERT_SYSTEM_STORE_LOCATION_MASK & dwStoreFlags) == CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY)
      ) {
        return(0);
    }

    // CERT_SYSTEM_STORE_LOCAL_MACHINE
    // CERT_SYSTEM_STORE_DOMAIN_POLICY
    // CERT_SYSTEM_STORE_CURRENT_SERVICE
    // CERT_SYSTEM_STORE_SERVICES
    // CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY

    return(CRYPT_MACHINE_KEYSET);
}

//modified from myLoadRCString from ca
HRESULT
xeLoadRCString(
    IN HINSTANCE   hInstance,
    IN int         iRCId,
    OUT WCHAR    **ppwsz)
{
#define REALLOCATEBLOCK 512
    HRESULT   hr;
    WCHAR    *pwszTemp = NULL;
    int       sizeTemp;
    int       size = 0;
    int       cBlocks = 1;

    *ppwsz = NULL;

    while (NULL == pwszTemp)
    {
        sizeTemp = cBlocks * REALLOCATEBLOCK;
        pwszTemp = (WCHAR*)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                        sizeTemp * sizeof(WCHAR));
        if (NULL == pwszTemp)
        {
            hr = E_OUTOFMEMORY;
            goto LocalAllocError;
        }

        size = LoadStringU(
                   hInstance,
                   iRCId,
                   pwszTemp,
                   sizeTemp);
        if (0 == size)
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto LoadStringError;
        }

        if (size < sizeTemp - 1)
        {
            // ok, size is big enough
            break;
        }
        ++cBlocks;
        LocalFree(pwszTemp);
        pwszTemp = NULL;
    }

    *ppwsz = (WCHAR*) LocalAlloc(LPTR, (size+1) * sizeof(WCHAR));
    if (NULL == *ppwsz)
    {
        hr = E_OUTOFMEMORY;
        goto LocalAllocError;
    }
    // copy it
    wcscpy(*ppwsz, pwszTemp);

    hr = S_OK;
ErrorReturn:
    if (NULL != pwszTemp)
    {
        LocalFree(pwszTemp);
    }
    return hr;

TRACE_ERROR(LocalAllocError)
TRACE_ERROR(LoadStringError)
}

HANDLE CCEnroll::CreateOpenFileSafely2(
    LPCWSTR pwszFileName,
    DWORD   idsCreate,
    DWORD   idsOverwrite)
{
    HANDLE      hFile = NULL;
    WCHAR      *pwszMsg = NULL;
    WCHAR      *pwszFormat = NULL;
    WCHAR      *pwszTitle = NULL;
    WCHAR      *pwszSafety = NULL;
    DWORD       dwAttribs = 0;
    BOOL        fNotProperFile;
    
    LPCWSTR     apwszInsertArray[2];
    BOOL        fNo;
    BOOL        fMsgBox;
    int         idPrefix = IDS_NOTSAFE_WRITE_PREFIX; //default to write prefix
    BOOL        fCreate = (0xFFFFFFFF != idsCreate) &&
                          (0xFFFFFFFF != idsOverwrite);
    HRESULT hr;

    EnterCriticalSection(&m_csXEnroll);

    fMsgBox = (m_dwEnabledSafteyOptions != 0);
    dwAttribs = GetFileAttributesU(pwszFileName);

    if(0xFFFFFFFF == dwAttribs)
    {
        //file doesn't exist
        if (!fCreate)
        {
            //try to read a non-existing file
            //for safety reasons, don't return system error
            SetLastError(ERROR_ACCESS_DENIED);
            goto InvalidFileError;
        }
        //if got here, write a new file
        if (fMsgBox)
        {
            hr = xeLoadRCString(hInstanceXEnroll, idsCreate, &pwszFormat);
            if (S_OK != hr)
            {
                goto xeLoadRCStringError;
            }
        }
    }
    else
    {
        //file exists, check if a proper file to write or read
        //in either write or read, the following file attrib not proper
        fNotProperFile = 
              (dwAttribs & FILE_ATTRIBUTE_DIRECTORY) ||
              (dwAttribs & FILE_ATTRIBUTE_HIDDEN)    ||
              (dwAttribs & FILE_ATTRIBUTE_SYSTEM);

        if (!fNotProperFile)
        {
            //so far so good
            if (fCreate)
            {
                //write a file
                if (0x0 != (dwAttribs & FILE_ATTRIBUTE_READONLY))
                {
                    //don't take read-only and archive
                    fNotProperFile = TRUE;
                }
                else
                {
                    //try to overwrite existing file
                    hr = xeLoadRCString(hInstanceXEnroll, idsOverwrite, &pwszFormat);
                    if (S_OK != hr)
                    {
                        goto xeLoadRCStringError;
                    }
                    //enforce popup if overwrite
                    fMsgBox = TRUE;
                }
            }
            else
            {
		//read an existing file always violate scripting safety
		//it allows detecting file existence
		//put out a warning
		fMsgBox = TRUE;
		hr = xeLoadRCString(hInstanceXEnroll, IDS_NOTSAFE_OPEN, &pwszFormat);
		if (S_OK != hr)
                {
		    goto xeLoadRCStringError;
		}
		idPrefix = IDS_NOTSAFE_OPEN_PREFIX;
            }
        }

        if (fNotProperFile)
        {
            //for safety reasons, don't return system error
            SetLastError(ERROR_ACCESS_DENIED);
            goto InvalidFileError;
        }
    }

    if (fMsgBox)
    {
        hr = xeLoadRCString(hInstanceXEnroll, IDS_NOTSAFEACTION, &pwszTitle);
        if (S_OK != hr)
        {
            goto xeLoadRCStringError;
        }
        hr = xeLoadRCString(hInstanceXEnroll, idPrefix, &pwszSafety);
        if (S_OK != hr)
        {
            goto xeLoadRCStringError;
        }

        apwszInsertArray[0] = pwszSafety;
        apwszInsertArray[1] = pwszFileName;

        if (!FormatMessageU(
            FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_FROM_STRING |
            FORMAT_MESSAGE_ARGUMENT_ARRAY,
            pwszFormat,
            0,
            0,
            (LPWSTR) &pwszMsg,
            0,
            (va_list *)apwszInsertArray)) 
	{ 
	    goto FormatMessageError; 
	}

        fNo = (MessageBoxU(
                    NULL,
                    pwszMsg,
                    pwszTitle,
                    MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2) != IDYES);
                
        if(fNo)
        {
            SetLastError(ERROR_CANCELLED);
            goto CancelError;
        }
    }
    
    hFile = CreateFileU(
            pwszFileName,
            fCreate ? GENERIC_WRITE : GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            fCreate ? CREATE_ALWAYS : OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

    if (hFile == INVALID_HANDLE_VALUE  ||  hFile == NULL)
    {
        //don't return system error so keep xenroll relative safe for scripting
        SetLastError(ERROR_ACCESS_DENIED);
        hFile = NULL;
        goto CreateFileUError;
    }

ErrorReturn:
    LeaveCriticalSection(&m_csXEnroll);

    if(NULL != pwszMsg)
    {
        LocalFree(pwszMsg);
    }
    if(NULL != pwszFormat)
    {
        LocalFree(pwszFormat);
    }
    if(NULL != pwszTitle)
    {
        LocalFree(pwszTitle);
    }
    if(NULL != pwszSafety)
    {
        LocalFree(pwszSafety);
    }
    return(hFile);

TRACE_ERROR(CreateFileUError)
TRACE_ERROR(FormatMessageError);
TRACE_ERROR(CancelError)
TRACE_ERROR(InvalidFileError)
TRACE_ERROR(xeLoadRCStringError)
}

HANDLE CCEnroll::CreateOpenFileSafely(
    LPCWSTR pwszFileName,
    BOOL    fCreate)
{
    HANDLE      hFile = NULL;
    WCHAR      *pwszMsg = NULL;
    DWORD       dwAttribs = 0;
    BOOL        fNotProperFile;
    
    WCHAR      *pwszFormat = NULL;
    WCHAR      *pwszTitle = NULL;
    LPCWSTR     apwszInsertArray[] = {pwszFileName};
    BOOL        fNo;
    BOOL        fMsgBox = 0 != m_dwEnabledSafteyOptions;
    BOOL        fOverWrite = FALSE;
    HRESULT     hr;

    EnterCriticalSection(&m_csXEnroll);

    dwAttribs = GetFileAttributesU(pwszFileName);
    if(0xFFFFFFFF == dwAttribs)
    {
        //file doesn't exist
        if (!fCreate)
        {
            //try to read a non-existing file
            //for safety reasons, don't return system error
            SetLastError(ERROR_ACCESS_DENIED);
            goto InvalidFileError;
        }
    }
    else
    {
        //file exists, check if a proper file to write or read
        //in either write or read, the following file attrib not proper
        fNotProperFile = 
              (dwAttribs & FILE_ATTRIBUTE_DIRECTORY) ||
              (dwAttribs & FILE_ATTRIBUTE_HIDDEN)    ||
              (dwAttribs & FILE_ATTRIBUTE_SYSTEM);

        if (!fNotProperFile)
        {
            //so far so good
            if (fCreate)
            {
                //write a file
                if (0x0 != (dwAttribs & FILE_ATTRIBUTE_READONLY))
                {
                    //don't take read-only and archive
                    fNotProperFile = TRUE;
                }
                else
                {
                    //try to overwrite existing file
                    fOverWrite = TRUE;
                }
            }
        }

        if (fNotProperFile)
        {
            //for safety reasons, don't return system error
            SetLastError(ERROR_ACCESS_DENIED);
            goto InvalidFileError;
        }
    }

    if (fMsgBox)
    {
        hr = xeLoadRCString(hInstanceXEnroll, IDS_CERTENROLL, &pwszTitle);
        if (S_OK != hr)
        {
            goto xeLoadRCStringError;
        }
        hr = xeLoadRCString(
                hInstanceXEnroll,
                fCreate ? IDS_NOTSAFE_WRITE_FORMAT : IDS_NOTSAFE_OPEN_FORMAT,
                &pwszFormat);
        if (S_OK != hr)
        {
            goto xeLoadRCStringError;
        }

        if (!FormatMessageU(
            FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_FROM_STRING |
            FORMAT_MESSAGE_ARGUMENT_ARRAY,
            pwszFormat,
            0,
            0,
            (LPWSTR) &pwszMsg,
            0,
            (va_list *)apwszInsertArray))
	{
	    goto FormatMessageUError;
	}

        fNo = (MessageBoxU(
                    NULL,
                    pwszMsg,
                    pwszTitle,
                    MB_DEFBUTTON2 | MB_YESNO | MB_ICONWARNING) == IDNO);
        if(fNo)
        {
            SetLastError(ERROR_CANCELLED);
            goto CancelError;
        }
    }

    if (fCreate && fOverWrite)
    {
        if (!fMsgBox)
        {
            hr = xeLoadRCString(hInstanceXEnroll, IDS_CERTENROLL, &pwszTitle);
            if (S_OK != hr)
            {
                goto xeLoadRCStringError;
            }
        }

        //popup overwrite confirmation
        hr = xeLoadRCString(hInstanceXEnroll, IDS_OVERWRITE_FORMAT, &pwszFormat);
        if (S_OK != hr)
        {
            goto xeLoadRCStringError;
        }

        //make sure free before alloc again
        if (NULL != pwszMsg)
        {
            LocalFree(pwszMsg);
            pwszMsg = NULL;
        }
        FormatMessageU(
            FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_FROM_STRING |
            FORMAT_MESSAGE_ARGUMENT_ARRAY,
            pwszFormat,
            0,
            0,
            (LPWSTR) &pwszMsg,
            0,
            (va_list *)apwszInsertArray);

        fNo = (MessageBoxU(
                    NULL,
                    pwszMsg,
                    pwszTitle,
                    MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2) != IDYES);
        if(fNo)
        {
            SetLastError(ERROR_CANCELLED);
            goto CancelError;
        }
    }
    
    hFile = CreateFileU(
            pwszFileName,
            fCreate ? GENERIC_WRITE : GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            fCreate ? CREATE_ALWAYS : OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

    if (hFile == INVALID_HANDLE_VALUE  ||  hFile == NULL)
    {
        //don't return system error so keep xenroll relative safe for scripting
        SetLastError(ERROR_ACCESS_DENIED);
        hFile = NULL;
        goto CreateFileUError;
    }

ErrorReturn:
    if(NULL != pwszMsg)
    {
        LocalFree(pwszMsg);
    }
    if(NULL != pwszTitle)
    {
        LocalFree(pwszTitle);
    }
    if(NULL != pwszFormat)
    {
        LocalFree(pwszFormat);
    }
    LeaveCriticalSection(&m_csXEnroll);

    return(hFile);

TRACE_ERROR(CreateFileUError)
TRACE_ERROR(CancelError)
TRACE_ERROR(FormatMessageUError);
TRACE_ERROR(InvalidFileError)
TRACE_ERROR(xeLoadRCStringError)
}

HANDLE CCEnroll::CreateFileSafely(
    LPCWSTR pwszFileName)
{
    return CreateOpenFileSafely(pwszFileName, TRUE); //write
}

HANDLE CCEnroll::OpenFileSafely(
    LPCWSTR pwszFileName)
{
    return CreateOpenFileSafely(pwszFileName, FALSE); //open
}

void DwordToWide(DWORD dw, LPWSTR lpwstr) {

    DWORD   i = 0;
    DWORD   j;
    WCHAR   wch;

    while(dw > 0) {
        j = dw % 10;
        dw /= 10;
        lpwstr[i++] = (WCHAR) (j + L'\0');
    }

    if( i == 0 )
        lpwstr[i++] = L'\0';

    lpwstr[i] = 0;

    for(j=0, i--; i > j; i--, j++) {
        wch = lpwstr[i];
        lpwstr[i] = lpwstr[j];
        lpwstr[j] = wch;
    }
}

//take a name value pair info and return encoded value
HRESULT
xeEncodeNameValuePair(
    IN PCRYPT_ENROLLMENT_NAME_VALUE_PAIR pNameValuePair,
    OUT BYTE                           **ppbData,
    OUT DWORD                           *pcbData)
{
    HRESULT hr = S_OK;

    //init
    *ppbData = NULL;
    *pcbData = 0;

    while (TRUE)
    {
        if(!CryptEncodeObject(
                CRYPT_ASN_ENCODING,
                szOID_ENROLLMENT_NAME_VALUE_PAIR,
                pNameValuePair,
                *ppbData,
                pcbData))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto error;
        }

        if (NULL != *ppbData)
        {
            break;
        }

        *ppbData = (BYTE*)MyCoTaskMemAlloc(*pcbData);
        if (NULL == *ppbData)
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }
    }

error:
    if (S_OK != hr && NULL != *ppbData)
    {
        MyCoTaskMemFree(*ppbData);
	*ppbData = NULL; 
    }
    return hr;
}

//convert wsz to sz and allocate mem
HRESULT
xeWSZToSZ(
    IN LPCWSTR    pwsz,
    OUT LPSTR    *ppsz)
{
    HRESULT hr = S_OK;
    LONG    cc = 0;

    //init
    *ppsz = NULL;

    while (TRUE)
    {
        cc = WideCharToMultiByte(
                    GetACP(),
                    0,
                    pwsz,
                    -1,
                    *ppsz,
                    cc,
                    NULL,
                    NULL);
        if (0 >= cc)
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto error;
        }

        if (NULL != *ppsz)
        {
            break;
        }
        *ppsz= (CHAR*)MyCoTaskMemAlloc(cc);
        if (NULL == *ppsz)
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }
    }
error:
    if (S_OK != hr && NULL != *ppsz)
    {
        MyCoTaskMemFree(*ppsz);
	*ppsz = NULL; 
    }
    return hr;
}

//modified from DecodeFile on certsrv
HRESULT
CCEnroll::xeStringToBinaryFromFile(
    IN  WCHAR const *pwszfn,
    OUT BYTE       **ppbOut,
    OUT DWORD       *pcbOut,
    IN  DWORD        Flags)
{
    HANDLE hFile;
    HRESULT hr;
    CHAR *pchFile = NULL;
    BYTE *pbOut = NULL;
    DWORD cchFile;
    DWORD cbRead;
    DWORD cbOut = 0;

    hFile = OpenFileSafely(pwszfn);
    if (NULL == hFile)
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto OpenFileSafelyError;
    }

    cchFile = GetFileSize(hFile, NULL);
    if ((DWORD) -1 == cchFile)
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto GetFileSizeError;
    }

    pchFile = (CHAR *) LocalAlloc(LMEM_FIXED, cchFile);
    if (NULL == pchFile)
    {
        hr = E_OUTOFMEMORY;
        goto LocalAllocError;
    }

    if (!ReadFile(hFile, pchFile, cchFile, &cbRead, NULL))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto ReadFileError;
    }

    assert(cbRead <= cchFile);
    if (cbRead != cchFile)
    {
        hr = MY_HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);
        goto ReadFileError;
    }

    if (CRYPT_STRING_BINARY == Flags)
    {
        pbOut = (BYTE *) pchFile;
        cbOut = cchFile;
        pchFile = NULL;
    }
    else
    {
        // Decode file contents.
        while (TRUE)
        {
            if (!MyCryptStringToBinaryA(
                        pchFile,
                        cchFile,
                        Flags,
                        pbOut,
                        &cbOut,
                        NULL,
                        NULL))
            {
                hr = MY_HRESULT_FROM_WIN32(GetLastError());
                goto CyrptStringToBinaryError;
            }
            if (NULL != pbOut)
            {
                //done
                break;
            }
            pbOut = (BYTE*)LocalAlloc(LMEM_FIXED, cbOut);
            if (NULL == pbOut)
            {
                hr = E_OUTOFMEMORY;
                goto LocalAllocError;
            }
        }
    }
    *pcbOut = cbOut;
    *ppbOut = pbOut;
    pbOut = NULL;

    hr = S_OK;
error:
    if (INVALID_HANDLE_VALUE != hFile)
    {
        CloseHandle(hFile);
    }
    if (NULL != pchFile)
    {
        LocalFree(pchFile);
    }
    if (NULL != pbOut)
    {
        LocalFree(pbOut);
    }
    return(hr);

ErrorReturn:
    goto error;

TRACE_ERROR(CyrptStringToBinaryError)
TRACE_ERROR(ReadFileError)
TRACE_ERROR(LocalAllocError)
TRACE_ERROR(GetFileSizeError)
TRACE_ERROR(OpenFileSafelyError)
}

//following two functions handle some APIs not available
//in downlevel client crypt32.dll
typedef VOID
(WINAPI * PFNCertFreeCertificateChain)
   (IN PCCERT_CHAIN_CONTEXT pChainContext);

typedef BOOL
(WINAPI * PFNCertGetCertificateChain)
   (IN OPTIONAL HCERTCHAINENGINE hChainEngine,
    IN PCCERT_CONTEXT pCertContext,
    IN OPTIONAL LPFILETIME pTime,
    IN OPTIONAL HCERTSTORE hAdditionalStore,
    IN PCERT_CHAIN_PARA pChainPara,
    IN DWORD dwFlags,
    IN LPVOID pvReserved,
    OUT PCCERT_CHAIN_CONTEXT* ppChainContext);

typedef BOOL (WINAPI *PFNCertVerifyCertificateChainPolicy) (
  LPCSTR pszPolicyOID,
  PCCERT_CHAIN_CONTEXT pChainContext,
  PCERT_CHAIN_POLICY_PARA pPolicyPara,
  PCERT_CHAIN_POLICY_STATUS pPolicyStatus
);

typedef BOOL (*PFNCheckTokenMembership) (
  HANDLE TokenHandle,  // handle to access token
  PSID SidToCheck,     // SID
  PBOOL IsMember       // result
);

typedef BOOL (*PFNSetSecurityDescriptorControl) (
  PSECURITY_DESCRIPTOR pSecurityDescriptor,          // SD
  SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest, // control bits
  SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet       // new control bits
);

VOID
MyCertFreeCertificateChain (
    IN PCCERT_CHAIN_CONTEXT pChainContext
    )
{
    PFNCertFreeCertificateChain pfnCertFreeCertificateChain = NULL;
    HMODULE  hModule = NULL;

    hModule = GetModuleHandle("crypt32.dll");
    if (NULL != hModule)
    {
        pfnCertFreeCertificateChain = (PFNCertFreeCertificateChain)
                GetProcAddress(hModule,
                               "CertFreeCertificateChain");
        if (NULL != pfnCertFreeCertificateChain)
        {
            pfnCertFreeCertificateChain(pChainContext);
        }
    }
}

BOOL
MyCertGetCertificateChain (
    IN OPTIONAL HCERTCHAINENGINE hChainEngine,
    IN PCCERT_CONTEXT pCertContext,
    IN OPTIONAL LPFILETIME pTime,
    IN OPTIONAL HCERTSTORE hAdditionalStore,
    IN PCERT_CHAIN_PARA pChainPara,
    IN DWORD dwFlags,
    IN LPVOID pvReserved,
    OUT PCCERT_CHAIN_CONTEXT* ppChainContext
    )
{
    PFNCertGetCertificateChain pfnCertGetCertificateChain = NULL;
    HMODULE hModule = NULL;

    hModule = GetModuleHandle("crypt32.dll");
    if (NULL != hModule)
    {
        pfnCertGetCertificateChain = (PFNCertGetCertificateChain)
                GetProcAddress(hModule,
                               "CertGetCertificateChain");
        if (NULL != pfnCertGetCertificateChain)
        {
            return pfnCertGetCertificateChain(
                hChainEngine,
                pCertContext,
                pTime,
                hAdditionalStore,
                pChainPara,
                dwFlags,
                pvReserved,
                ppChainContext);
        }
    }
    return FALSE;
}

BOOL
MyCertVerifyCertificateChainPolicy(
  LPCSTR pszPolicyOID,
  PCCERT_CHAIN_CONTEXT pChainContext,
  PCERT_CHAIN_POLICY_PARA pPolicyPara,
  PCERT_CHAIN_POLICY_STATUS pPolicyStatus
)
{
    PFNCertVerifyCertificateChainPolicy pfnCertVerifyCertificateChainPolicy = NULL;
    HMODULE hModule = NULL;

    hModule = GetModuleHandle("crypt32.dll");
    if (NULL != hModule)
    {
        pfnCertVerifyCertificateChainPolicy = (PFNCertVerifyCertificateChainPolicy)
                GetProcAddress(hModule,
                               "CertVerifyCertificateChainPolicy");
        if (NULL != pfnCertVerifyCertificateChainPolicy)
        {
            return pfnCertVerifyCertificateChainPolicy(
                            pszPolicyOID,
                            pChainContext,
                            pPolicyPara,
                            pPolicyStatus);
        }
    }
    return FALSE;
}

BOOL
MyCheckTokenMembership(
  HANDLE TokenHandle,  // handle to access token
  PSID SidToCheck,     // SID
  PBOOL IsMember       // result
)
{
    PFNCheckTokenMembership pfnCheckTokenMembership = NULL;
    HMODULE hModule = NULL;

    hModule = GetModuleHandle("advapi32.dll");
    if (NULL != hModule)
    {
        pfnCheckTokenMembership = (PFNCheckTokenMembership)
                GetProcAddress(hModule,
                               "CheckTokenMembership");
        if (NULL != pfnCheckTokenMembership)
        {
            return pfnCheckTokenMembership(
                        TokenHandle,
                        SidToCheck,
                        IsMember);
        }
    }
    return FALSE;
}

BOOL
MySetSecurityDescriptorControl(
  PSECURITY_DESCRIPTOR pSecurityDescriptor,          // SD
  SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest, // control bits
  SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet       // new control bits
)
{
    PFNSetSecurityDescriptorControl pfnSetSecurityDescriptorControl = NULL;
    HMODULE hModule = NULL;

    hModule = GetModuleHandle("advapi32.dll");
    if (NULL != hModule)
    {
        pfnSetSecurityDescriptorControl = (PFNSetSecurityDescriptorControl)
                GetProcAddress(hModule,
                               "SetSecurityDescriptorControl");
        if (NULL != pfnSetSecurityDescriptorControl)
        {
            return pfnSetSecurityDescriptorControl(
                        pSecurityDescriptor,
                        ControlBitsOfInterest,
                        ControlBitsToSet);
        }
    }
    return FALSE;
}

HRESULT __stdcall CCEnroll::GetInterfaceSafetyOptions( 
            /* [in]  */ REFIID riid,
            /* [out] */ DWORD __RPC_FAR *pdwSupportedOptions,
            /* [out] */ DWORD __RPC_FAR *pdwEnabledOptions) {

    RPC_STATUS rpcStatus;          

    if(0 != UuidCompare((GUID *) &riid, (GUID *) &IID_IDispatch, &rpcStatus) )
        return(E_NOINTERFACE);

    *pdwEnabledOptions   = m_dwEnabledSafteyOptions;
    *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA;


    return(S_OK);
}

HRESULT __stdcall CCEnroll::SetInterfaceSafetyOptions( 
            /* [in] */ REFIID riid,
            /* [in] */ DWORD dwOptionSetMask,
            /* [in] */ DWORD dwEnabledOptions) {

    RPC_STATUS rpcStatus;          
    DWORD dwSupport = 0;            

    if(0 != UuidCompare((GUID *) &riid, (GUID *) &IID_IDispatch, &rpcStatus) )
        return(E_NOINTERFACE);

    dwSupport = dwOptionSetMask & ~(INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA);        
    if(dwSupport != 0)
        return(E_FAIL);

    (DWORD)m_dwEnabledSafteyOptions &= ~dwOptionSetMask;
    (DWORD)m_dwEnabledSafteyOptions |= dwEnabledOptions; 
            
return(S_OK);
}


HRESULT
CCEnroll::GetVerifyProv()
{
    HRESULT hr;

    EnterCriticalSection(&m_csXEnroll);

    if (NULL == m_hVerifyProv)
    {
        if (!CryptAcquireContextU(
                    &m_hVerifyProv,
                    NULL,
                    m_keyProvInfo.pwszProvName,
                    m_keyProvInfo.dwProvType,
                    CRYPT_VERIFYCONTEXT))
        {
#if DBG
            assert(NULL == m_hVerifyProv);
#endif //DBG
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto CryptAcquireContextUError;
        }
    }

    hr = S_OK;
ErrorReturn:
    LeaveCriticalSection(&m_csXEnroll);
    return hr;

TRACE_ERROR(CryptAcquireContextUError)
}

BOOL CCEnroll::GetCapiHashAndSigAlgId(ALG_ID rgAlg[2]) {


    DWORD   iHashBest       = 0;
    ALG_ID  arDefaultHash[] = {m_HashAlgId, CALG_SHA1, CALG_MD5};
    DWORD   cDefaultHash    = sizeof(arDefaultHash) / sizeof(DWORD);

    HCRYPTPROV  hProvU      = NULL;

    DWORD       dwFlags     = CRYPT_FIRST;

    DWORD       i;
    PROV_ENUMALGS               enumAlgs;
    DWORD       cb          = sizeof(enumAlgs);

    BOOL        fRet        = TRUE;

    rgAlg[0] = 0;
    rgAlg[1] = 0;

    EnterCriticalSection(&m_csXEnroll);

    // only get a prov if one wasn't passed in.
    if(m_hProv == NULL)
    {
        HRESULT hr;
        hr = GetVerifyProv();
        if (S_OK != hr)
        {
            goto GetVerifyProvError;
        }
        hProvU = m_hVerifyProv;
    }
    else
    {
        // otherwise use the current m_hProv, SCard only likes on
        // CryptAcquireContext to be used.
        hProvU = m_hProv;
    }

    cb = sizeof(enumAlgs);
    while( CryptGetProvParam(
        hProvU,
            PP_ENUMALGS,
        (BYTE *) &enumAlgs,
        &cb,
        dwFlags
        ) ) {

        cb = sizeof(enumAlgs);

        // not first pass anymore
        dwFlags = 0;

        // see if this is a hash alg
        if( ALG_CLASS_HASH == GET_ALG_CLASS(enumAlgs.aiAlgid) ) {

            // get things init with the first hash alg
            if(rgAlg[0] == 0) {
                rgAlg[0] = enumAlgs.aiAlgid;
                iHashBest = cDefaultHash;
            }

            // pick the best one
            for(i=0; i<iHashBest; i++) {

                if(arDefaultHash[i] == enumAlgs.aiAlgid) {
                    rgAlg[0] = enumAlgs.aiAlgid;
                    iHashBest   = i;
                    break;
                }
            }
        }

        // we will only pick up the first signature type
        // in general there is only 1 per csp (Ref: JeffSpel)
        else if( ALG_CLASS_SIGNATURE == GET_ALG_CLASS(enumAlgs.aiAlgid) ) {

            if(rgAlg[1] == 0)
                rgAlg[1] = enumAlgs.aiAlgid;
        }
    }

ErrorReturn:
    LeaveCriticalSection(&m_csXEnroll);

    // some CSPs say they can't sign, but they really can
    // so if we have not hashalg or sigalg we will put a default
    // in and if the CSP really can't do it, it will error
    // this is for backwards compatibility

    // default hash to sha1
    if(rgAlg[0] == 0)
        rgAlg[0] = CALG_SHA1;

    // default sig to RSA
    if(rgAlg[1] == 0)
        rgAlg[1] = CALG_RSA_SIGN;

#if 0
    if(rgAlg[0] == 0 || rgAlg[1] == 0) {
        SetLastError((DWORD)NTE_BAD_ALGID);
        fRet = FALSE;
    }
#endif

    return(fRet);

TRACE_ERROR(GetVerifyProvError)
}

BOOL CreatePvkProperty(
    CRYPT_KEY_PROV_INFO *pKeyProvInfo,
    PCRYPT_DATA_BLOB    pBlob)
{
    WCHAR   wszKeySpec[11];
    WCHAR   wszProvType[11];
    DWORD   cbContainer;
    DWORD   cbKeySpec;
    DWORD   cbProvType;
    DWORD   cbProvName;

    assert(pBlob != NULL);
    assert(pKeyProvInfo != NULL);

    // convert dwords to strings
    DwordToWide(pKeyProvInfo->dwKeySpec, wszKeySpec);
    DwordToWide(pKeyProvInfo->dwProvType, wszProvType);

    // get total length of string
    cbContainer = (DWORD)(wcslen(pKeyProvInfo->pwszContainerName) + 1) * sizeof(WCHAR);
    cbKeySpec   = (DWORD)(wcslen(wszKeySpec) + 1) * sizeof(WCHAR);
    cbProvType  = (DWORD)(wcslen(wszProvType) + 1) * sizeof(WCHAR);

    cbProvName  = (DWORD)(wcslen(pKeyProvInfo->pwszProvName) + 1) * sizeof(WCHAR);

    pBlob->cbData =
        cbContainer +
        cbKeySpec   +
        cbProvType  +
        cbProvName  +
        sizeof(WCHAR);

    // allocate the string
    if( (pBlob->pbData = (BYTE *) MyCoTaskMemAlloc(pBlob->cbData)) == NULL) {
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }

    // copy the strings
    memset(pBlob->pbData, 0, pBlob->cbData);
    memcpy(pBlob->pbData, pKeyProvInfo->pwszContainerName, cbContainer);
    memcpy(&pBlob->pbData[cbContainer], wszKeySpec, cbKeySpec);
    memcpy(&pBlob->pbData[cbContainer + cbKeySpec], wszProvType, cbProvType);
    memcpy(&pBlob->pbData[cbContainer + cbKeySpec + cbProvType], pKeyProvInfo->pwszProvName, cbProvName);

    return(TRUE);
}

static LPWSTR wszEmpty      = L"";
static LPWSTR wszMY         = L"MY";
static LPWSTR wszCA         = L"CA";
static LPWSTR wszROOT       = L"ROOT";
static LPWSTR wszREQUEST    = L"REQUEST";
static LPSTR  szSystemStore = sz_CERT_STORE_PROV_SYSTEM;
// static LPSTR  szSystemStore = sz_CERT_STORE_PROV_SYSTEM_REGISTRY;
/////////////////////////////////////////////////////////////////////////////
// CCEnroll


CCEnroll::~CCEnroll(void) {
    Destruct();
    DeleteCriticalSection(&m_csXEnroll);
}

void CCEnroll::Destruct(void) {

    if(NULL != m_PrivateKeyArchiveCertificate)
    {
        CertFreeCertificateContext(m_PrivateKeyArchiveCertificate);
    }
    if(NULL != m_pCertContextSigner)
    {
        CertFreeCertificateContext(m_pCertContextSigner);
    }
    if(m_pCertContextRenewal != NULL)
        CertFreeCertificateContext(m_pCertContextRenewal);
    if(m_pCertContextStatic != NULL)
        CertFreeCertificateContext(m_pCertContextStatic);

    if(m_keyProvInfo.pwszContainerName != wszEmpty)
        MyCoTaskMemFree(m_keyProvInfo.pwszContainerName);

    if(m_keyProvInfo.pwszProvName != wszEmpty)
        MyCoTaskMemFree(m_keyProvInfo.pwszProvName);

    if(m_MyStore.wszName != wszMY)
        MyCoTaskMemFree(m_MyStore.wszName);

    if(m_CAStore.wszName != wszCA)
        MyCoTaskMemFree(m_CAStore.wszName);

    if(m_RootStore.wszName != wszROOT && m_RootStore.wszName != wszCA)
        MyCoTaskMemFree(m_RootStore.wszName);

    if(m_RequestStore.wszName != wszREQUEST)
        MyCoTaskMemFree(m_RequestStore.wszName);

    if(m_MyStore.szType  != szSystemStore)
        MyCoTaskMemFree(m_MyStore.szType);

    if(m_CAStore.szType != szSystemStore)
        MyCoTaskMemFree(m_CAStore.szType);

    if(m_RootStore.szType != szSystemStore)
        MyCoTaskMemFree(m_RootStore.szType);

    if(m_RequestStore.szType != szSystemStore)
        MyCoTaskMemFree(m_RequestStore.szType);

    if(m_wszSPCFileName != wszEmpty)
        MyCoTaskMemFree(m_wszSPCFileName);

    if(m_wszPVKFileName != wszEmpty)
        MyCoTaskMemFree(m_wszPVKFileName);

    if (NULL != m_pCertContextPendingRequest)
        CertFreeCertificateContext(m_pCertContextPendingRequest);

    if (NULL != m_pPendingRequestTable)
        delete m_pPendingRequestTable; 

    // store handles
    if(m_RootStore.hStore != NULL)
        CertCloseStore(m_RootStore.hStore, 0);
    m_RootStore.hStore = NULL;

    if(m_CAStore.hStore != NULL)
        CertCloseStore(m_CAStore.hStore, 0);
    m_CAStore.hStore = NULL;

    if(m_MyStore.hStore != NULL)
        CertCloseStore(m_MyStore.hStore, 0);
    m_MyStore.hStore = NULL;

    if(m_RequestStore.hStore != NULL)
        CertCloseStore(m_RequestStore.hStore, 0);
    m_RequestStore.hStore = NULL;

    // remove provider handles
    if(m_hProv != NULL)
        CryptReleaseContext(m_hProv, 0);
    m_hProv = NULL;

    if(m_hVerifyProv != NULL)
        CryptReleaseContext(m_hVerifyProv, 0);
    m_hVerifyProv = NULL;

    if (NULL != m_hCachedKey)
    {
        //this should be destroyed early but just in case
        CryptDestroyKey(m_hCachedKey);
    }

    if (NULL != m_pPublicKeyInfo)
    {
        LocalFree(m_pPublicKeyInfo);
        m_pPublicKeyInfo = NULL;
    }

    FreeAllStackExtension();
    FreeAllStackAttribute();
    resetBlobProperties();
}

static LPVOID CoTaskMemAllocTrap(ULONG cb) {

    __try {
        return(CoTaskMemAlloc(cb));

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_DLL_NOT_FOUND);
        return(NULL);
    }
}

static LPVOID CoTaskMemReallocTrap(LPVOID ptr, ULONG cb) {
    __try {
        return(CoTaskMemRealloc(ptr, cb));
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_DLL_NOT_FOUND);
        return(NULL);
    }
}

static void CoTaskMemFreeTrap(LPVOID ptr) {
    __try {
        CoTaskMemFree(ptr);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_DLL_NOT_FOUND);
    }
    return;
}


// Initialize the safety options in the constructor, so they won't
// be clobbered when we do a reset(). 
CCEnroll::CCEnroll(void) : m_dwEnabledSafteyOptions(0) {
    __try
    {
        InitializeCriticalSection(&m_csXEnroll);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }
    Init();
}

HRESULT
CCEnroll::Init(void)
{
    HRESULT hr;
    GUID    guidContainerName;
    char *  sz = NULL;
    RPC_STATUS  rpc_status;

    // set default mem allocators
    if(MyCoTaskMemAlloc == NULL)
    {

        MyCoTaskMemAlloc    = CoTaskMemAllocTrap;
        MyCoTaskMemRealloc  = CoTaskMemReallocTrap;
        MyCoTaskMemFree     = CoTaskMemFreeTrap;
    }

    // get a container based on a guid
    rpc_status = UuidCreate(&guidContainerName);
    if (RPC_S_OK != rpc_status && RPC_S_UUID_LOCAL_ONLY != rpc_status)
    {
        hr = rpc_status;
        goto UuidCreateError;
    }
    rpc_status = UuidToStringA(&guidContainerName, (unsigned char **) &sz);
    if (RPC_S_OK != rpc_status)
    {
        hr = rpc_status;
        goto UuidToStringAError;
    }
    assert(sz != NULL);
    m_keyProvInfo.pwszContainerName = WideFromMB(sz);
    RpcStringFree((unsigned char **) &sz);

    m_keyProvInfo.pwszProvName        = wszEmpty;
    m_keyProvInfo.dwProvType          = PROV_RSA_FULL;
    m_keyProvInfo.dwFlags             = 0;
    m_keyProvInfo.cProvParam          = 0;
    m_keyProvInfo.rgProvParam         = NULL;
    m_keyProvInfo.dwKeySpec           = AT_SIGNATURE;
    m_fEnableSMIMECapabilities =
                    (m_keyProvInfo.dwKeySpec == AT_KEYEXCHANGE);
    m_fSMIMESetByClient               = FALSE;
    m_fKeySpecSetByClient             = FALSE;
    m_hProv                           = NULL;
    m_hVerifyProv                     = NULL;

    m_fDeleteRequestCert              = TRUE;
    m_fUseExistingKey                 = FALSE;
    m_fWriteCertToCSPModified         = FALSE;
    m_fWriteCertToCSP                 = TRUE;     // always want to try
    m_fWriteCertToUserDSModified      = FALSE;
    m_fWriteCertToUserDS              = FALSE;
    m_fReuseHardwareKeyIfUnableToGenNew = TRUE;
    m_fLimitExchangeKeyToEncipherment = FALSE;
    m_dwT61DNEncoding                 = 0;        // or CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG
    m_dwGenKeyFlags                   = 0;
    m_wszSPCFileName                  = wszEmpty;
    m_wszPVKFileName                  = wszEmpty;
    m_HashAlgId                       = 0;

    m_fMyStoreOpenFlagsModified   = FALSE;
    m_MyStore.wszName             = wszMY;
    m_MyStore.szType              = szSystemStore;
    m_MyStore.dwFlags             = CERT_SYSTEM_STORE_CURRENT_USER;
    m_MyStore.hStore              = NULL;

    m_fCAStoreOpenFlagsModified   = FALSE;
    m_CAStore.wszName             = wszCA;
    m_CAStore.szType              = szSystemStore;
    m_CAStore.dwFlags             = CERT_SYSTEM_STORE_CURRENT_USER;
    m_CAStore.hStore              = NULL;

    m_fRootStoreOpenFlagsModified = FALSE;
    m_RootStore.wszName           = wszROOT;
    m_RootStore.szType            = szSystemStore;
    m_RootStore.dwFlags           = CERT_SYSTEM_STORE_CURRENT_USER;
    m_RootStore.hStore            = NULL;

    m_fRequestStoreOpenFlagsModified = FALSE;
    m_RequestStore.wszName        = wszREQUEST ;
    m_RequestStore.szType         = szSystemStore;
    m_RequestStore.dwFlags        = CERT_SYSTEM_STORE_CURRENT_USER;
    m_RequestStore.hStore         = NULL;

    m_PrivateKeyArchiveCertificate= NULL;
    m_pCertContextRenewal         = NULL;
    m_pCertContextSigner         = NULL;
    m_pCertContextStatic          = NULL;
    memset(m_arHashBytesNewCert, 0, sizeof(m_arHashBytesNewCert));
    memset(m_arHashBytesOldCert, 0, sizeof(m_arHashBytesOldCert));
    m_fArchiveOldCert             = FALSE;

    m_pExtStack                 = NULL;
    m_cExtStack                 = 0;

    m_pAttrStack                = NULL;
    m_cAttrStack                = 0;

    m_pExtStackNew              = NULL;
    m_cExtStackNew              = 0;

    m_pAttrStackNew             = NULL;
    m_cAttrStackNew             = 0;

    m_pPropStack                = NULL;
    m_cPropStack                = 0;

    m_fNewRequestMethod         = FALSE;
    m_fCMCFormat                = FALSE;
    m_fHonorRenew               = TRUE; //critical, if passing XECR_PKCS10*
    m_fOID_V2                   = FALSE; //critical
    m_hCachedKey                = NULL;
    m_fUseClientKeyUsage        = FALSE;
    m_lClientId                 = XECI_XENROLL;
    m_dwLastAlgIndex            = MAXDWORD;
    m_fIncludeSubjectKeyID      = TRUE;
    m_fHonorIncludeSubjectKeyID = FALSE;
    m_pPublicKeyInfo            = NULL;

    m_dwSigKeyLenMax = 0;
    m_dwSigKeyLenMin = 0;
    m_dwSigKeyLenDef = 0;
    m_dwSigKeyLenInc = 0;
    m_dwXhgKeyLenMax = 0;
    m_dwXhgKeyLenMin = 0;
    m_dwXhgKeyLenDef = 0;
    m_dwXhgKeyLenInc = 0;

    // Initialize pending info data:
    m_pCertContextPendingRequest       = NULL;
    m_pCertContextLastEnumerated       = NULL;
    m_dwCurrentPendingRequestIndex     = 0; 
    m_pPendingRequestTable             = NULL; 
    memset(&m_hashBlobPendingRequest, 0, sizeof(CRYPT_DATA_BLOB)); 
    ZeroMemory(&m_blobResponseKAHash, sizeof(m_blobResponseKAHash));

    hr = S_OK;
ErrorReturn:
    return hr;
TRACE_ERROR(UuidToStringAError)
TRACE_ERROR(UuidCreateError)
}

void CCEnroll::FlushStore(StoreType storeType) {
    PSTOREINFO   pStoreInfo = NULL;

    // get store struct
    switch(storeType) {

        case StoreMY:
            pStoreInfo = &m_MyStore;
            break;

        case StoreCA:
            pStoreInfo = &m_CAStore;
            break;

        case StoreROOT:
            pStoreInfo = &m_RootStore;
            break;

        case StoreREQUEST:
            pStoreInfo = &m_RequestStore;
            break;
    }

    EnterCriticalSection(&m_csXEnroll);

    // if store already open, return it
    if(pStoreInfo->hStore != NULL) {

        CertCloseStore(pStoreInfo->hStore, 0);
        pStoreInfo->hStore = NULL;
    }

    // we may have something or not, but return it
    // the errors will be correct.
    LeaveCriticalSection(&m_csXEnroll);
}

HCERTSTORE CCEnroll::GetStore(StoreType storeType) {

    PSTOREINFO   pStoreInfo = NULL;
    HCERTSTORE   hStore     = NULL;

    // get store struct
    switch(storeType) {

        case StoreMY:
            pStoreInfo = &m_MyStore;
            break;

        case StoreCA:
            pStoreInfo = &m_CAStore;
            break;

        case StoreROOT:
            pStoreInfo = &m_RootStore;
            break;

        case StoreREQUEST:
            pStoreInfo = &m_RequestStore;
            break;

        default:
            SetLastError(ERROR_BAD_ARGUMENTS);
            return(NULL);
            break;
    }

    EnterCriticalSection(&m_csXEnroll);

    // if store already open, return it
    if(pStoreInfo->hStore == NULL) {

        // otherwise attempt to open the store
        pStoreInfo->hStore = CertOpenStore(
                pStoreInfo->szType,
                PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                NULL,
                pStoreInfo->dwFlags,
                pStoreInfo->wszName);
    }

    // we may have something or not, but return it
    // the errors will be correct.
    hStore = pStoreInfo->hStore;
    LeaveCriticalSection(&m_csXEnroll);

    return(hStore);
}

HCRYPTPROV CCEnroll::GetProv(DWORD dwFlags) {

    HCRYPTPROV  hProvT          = NULL;
    DWORD       cb              = 0;
    char *      pszProvName     = NULL;
    char *      pszContainerName = NULL;

    EnterCriticalSection(&m_csXEnroll);
    DWORD       dwProvType      = m_keyProvInfo.dwProvType;

    switch(dwFlags) {

        case CRYPT_NEWKEYSET:
            dwFlags = dwFlags | m_keyProvInfo.dwFlags;
            break;

        case CRYPT_DELETEKEYSET:
            if( m_hProv != NULL ) {

                CryptReleaseContext(m_hProv, 0);
                m_hProv = NULL;

                CryptAcquireContextU(&m_hProv,
                     m_keyProvInfo.pwszContainerName,
                     m_keyProvInfo.pwszProvName,
                     m_keyProvInfo.dwProvType,
                     CRYPT_DELETEKEYSET);
            }
            m_hProv = NULL;
            goto CommonReturn;
            break;

        default:
            dwFlags = m_keyProvInfo.dwFlags;
            break;
   }

    if(m_hProv == NULL) {

            if( CryptAcquireContextU(&m_hProv,
             m_keyProvInfo.pwszContainerName,
             m_keyProvInfo.pwszProvName,
             m_keyProvInfo.dwProvType,
             dwFlags) ) {

                // we have the m_hProv, now set the provider name
                // Since this is secondary to the task, don't do error checking
                // nothing here should really fail anyway
                pszProvName = NULL;
                while (TRUE)
                {
                    if(!CryptGetProvParam( m_hProv,
                                    PP_NAME,
                                    (BYTE*)pszProvName,
                                    &cb,
                                    0))
                    {
                        break;
                    }
                    if (NULL != pszProvName)
                    {
                        if(m_keyProvInfo.pwszProvName != wszEmpty)
                            MyCoTaskMemFree(m_keyProvInfo.pwszProvName);
                        m_keyProvInfo.pwszProvName = WideFromMB(pszProvName);
                        break;
                    }
                    pszProvName = (char *)LocalAlloc(LMEM_FIXED, cb);
                    if (NULL == pszProvName)
                    {
                        goto CommonReturn;
                    }
                }

                // Here we just try and get the unique container name
                // If not, just go on

                BOOL fTryAnother = FALSE;
                cb = 0;
                pszContainerName = NULL;
                while (TRUE)
                {
                    if(!CryptGetProvParam( m_hProv,
                                    PP_UNIQUE_CONTAINER,
                                    (BYTE*)pszContainerName,
                                    &cb,
                                    0))
                    {
                        if (NULL == pszContainerName)
                        {
			    fTryAnother = TRUE;
                        }
                        else
                        {
			    LocalFree(pszContainerName); 
			    pszContainerName = NULL;
                        }
                        break;
                    }
                    else
                    {
                        if (NULL != pszContainerName)
                        {
                            //got it, done
                            break;
                        }
                    }
                    pszContainerName = (char *)LocalAlloc(LMEM_FIXED, cb);
                    if (NULL == pszContainerName)
                    {
                        goto CommonReturn;
                    }
                }

                if (fTryAnother)
                {
                    // so we can't get the unique container name,
                    // lets just go for the container name (may not be unique).
                    cb = 0;
                    pszContainerName = NULL;
                    while (TRUE)
                    {
                        if(!CryptGetProvParam(m_hProv,
                                    PP_CONTAINER,
                                    (BYTE*)pszContainerName,
                                    &cb,
                                    0))
                        {
                            if (NULL != pszContainerName)
                            {
				LocalFree(pszContainerName); 
                                pszContainerName = NULL;
                            }
                            break;
                        }
                        else
                        {
                            if (NULL != pszContainerName)
                            {
                                //got it, done
                                break;
                            }
                            pszContainerName = (char *)LocalAlloc(LMEM_FIXED, cb);
                            if (NULL == pszContainerName)
                            {
                                goto CommonReturn;
                            }
                        }
                    }
                }

                // set the container, otherwise use what was there
                if(pszContainerName != NULL) {
                    if( m_keyProvInfo.pwszContainerName != wszEmpty )
                        MyCoTaskMemFree(m_keyProvInfo.pwszContainerName);
                    m_keyProvInfo.pwszContainerName = WideFromMB(pszContainerName);
                }

                // now because some providers double duty for provider types
                // get what the the provider thinks its type is
                cb = sizeof(DWORD);
                if(CryptGetProvParam(   m_hProv,
                                        PP_PROVTYPE,
                                        (BYTE *) &dwProvType,
                                        &cb,
                                        0) ) {
                    m_keyProvInfo.dwProvType = dwProvType;
                }
                
        } else {
            m_hProv = NULL;
        }

    }

CommonReturn:
    hProvT = m_hProv;
    LeaveCriticalSection(&m_csXEnroll);
    if (NULL != pszProvName)
    {
        LocalFree(pszProvName);
    }
    if (NULL != pszContainerName)
    {
        LocalFree(pszContainerName);
    }
    return(hProvT);
}


BOOL CCEnroll::SetKeyParams(
    PCRYPT_KEY_PROV_INFO pKeyProvInfo
) {

    EnterCriticalSection(&m_csXEnroll);

    // remove provider handles
    if(m_hProv != NULL)
        CryptReleaseContext(m_hProv, 0);
    m_hProv = NULL;

    if(m_hVerifyProv != NULL)
        CryptReleaseContext(m_hVerifyProv, 0);
    m_hVerifyProv = NULL;

    put_ContainerNameWStr(pKeyProvInfo->pwszContainerName);
    put_ProviderNameWStr(pKeyProvInfo->pwszProvName);
    put_ProviderFlags(pKeyProvInfo->dwFlags);
    put_KeySpec(pKeyProvInfo->dwKeySpec);
    put_ProviderType(pKeyProvInfo->dwProvType);

    // someday we will have to pay attention to this too.
    m_keyProvInfo.cProvParam          = 0;
    m_keyProvInfo.rgProvParam         = NULL;

    LeaveCriticalSection(&m_csXEnroll);

    return(TRUE);
}

HRESULT STDMETHODCALLTYPE CCEnroll::createPKCS10(
            /* [in] */ BSTR DNName,
            /* [in] */ BSTR wszPurpose,
            /* [retval][out] */ BSTR __RPC_FAR *pPKCS10) {

    return(createPKCS10WStrBStr(DNName, wszPurpose, pPKCS10));
}

HRESULT  CCEnroll::createPKCS10WStrBStr(
            LPCWSTR DNName,
            LPCWSTR wszPurpose,
            BSTR __RPC_FAR *pPKCS10) {

    HRESULT                     hr              = S_OK;
    CRYPT_DATA_BLOB             blobPKCS10;

    memset(&blobPKCS10, 0, sizeof(CRYPT_DATA_BLOB));

    hr = createPKCS10WStr(DNName, wszPurpose, &blobPKCS10);
    if(S_OK != hr)
    {
        goto createPKCS10Error;
    }

    // BASE64 encode pkcs 10, no header for backward compatible
    hr = BlobToBstring(&blobPKCS10, CRYPT_STRING_BASE64, pPKCS10);
    if (S_OK != hr)
    {
        goto BlobToBstringError;
    }

CommonReturn:

    if(NULL != blobPKCS10.pbData)
    {
        MyCoTaskMemFree(blobPKCS10.pbData);
    }
    return(hr);

ErrorReturn:
    if(*pPKCS10 != NULL)
        SysFreeString(*pPKCS10);
    *pPKCS10 = NULL;

    goto CommonReturn;

TRACE_ERROR(createPKCS10Error);
TRACE_ERROR(BlobToBstringError);
}

HRESULT CCEnroll::AddCertsToStores(
    HCERTSTORE    hStoreMsg,
    LONG         *plCertInstalled
    ) {

    HCERTSTORE                  hStoreRoot              = NULL;
    HCERTSTORE                  hStoreCA                = NULL;
    PCCERT_CONTEXT              pCertContext            = NULL;
    PCCERT_CONTEXT              pCertContextLast        = NULL;
    LONG                        lCertInstalled = 0;
    HRESULT hr = S_OK;

    //init
    if (NULL != plCertInstalled)
    {
        *plCertInstalled = 0;
    }

    EnterCriticalSection(&m_csXEnroll);

    if( (hStoreCA = GetStore(StoreCA)) == NULL )
        goto ErrorCertOpenCAStore;

    if( (hStoreRoot = GetStore(StoreROOT)) == NULL )
        goto ErrorCertOpenRootStore;

    // now just place the rest of the cert in either the ROOT or CA store
    // we know we removed the end-entity cert from the msg store already
    // put all certs that came in the message into the appropriate store
    while( (pCertContext = CertEnumCertificatesInStore(
                        hStoreMsg,
                        pCertContextLast)) != NULL ) {

        // if it is a self sign, it is a ROOT
        if( CertCompareCertificateName(
                CRYPT_ASN_ENCODING,
                &pCertContext->pCertInfo->Subject,
                &pCertContext->pCertInfo->Issuer) ) {

            // to root store could invoke a pop up, check cancel button
            // but don't error out from any fail
            if (MySafeCertAddCertificateContextToStore(
                    hStoreRoot,
                    pCertContext,
                    CERT_STORE_ADD_USE_EXISTING,
                    NULL, 
		    m_dwEnabledSafteyOptions))
            {
                ++lCertInstalled;
            }
            else
            {
                if (S_OK == hr)
                {
                    //save the 1st error as return
                    hr = MY_HRESULT_FROM_WIN32(GetLastError());
                    if (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == hr)
                    {
                        //map generic access deny to xenroll error
                        hr = XENROLL_E_CANNOT_ADD_ROOT_CERT;
                    }
                }
                //don't goto error here and finish the loop
            }
        }

        // if it is not the MY cert, it must go in the CA store
        // do nothing with the MY cert as we already handled it
        else  {

            // likewise we don't care if these get added to the
            // CA store
            if (MySafeCertAddCertificateContextToStore(
                    hStoreCA,
                    pCertContext,
                    CERT_STORE_ADD_USE_EXISTING,
                    NULL, 
		    m_dwEnabledSafteyOptions))
            {
                //no error code check
                ++lCertInstalled;
            }
        }

        pCertContextLast = pCertContext;
    }
    pCertContextLast = NULL;
    if (NULL != plCertInstalled)
    {
        *plCertInstalled = lCertInstalled;
    }

CommonReturn:

    LeaveCriticalSection(&m_csXEnroll);
    return(hr);

ErrorReturn:

    hr = MY_HRESULT_FROM_WIN32(GetLastError());

    if(GetLastError() == ERROR_SUCCESS)
        SetLastError((DWORD)E_UNEXPECTED);

    goto CommonReturn;

TRACE_ERROR(ErrorCertOpenCAStore);
TRACE_ERROR(ErrorCertOpenRootStore);
}

BOOL
IsDesiredProperty(DWORD  dwPropertyId)
{
    DWORD  DesiredIds[] = {
        CERT_PVK_FILE_PROP_ID,
        CERT_FRIENDLY_NAME_PROP_ID,
        CERT_DESCRIPTION_PROP_ID,
        CERT_RENEWAL_PROP_ID,
    };
    DWORD i;

    for (i = 0; i < ARRAYSIZE(DesiredIds); ++i)
    {
        if (dwPropertyId == DesiredIds[i])
        {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
IsFilteredOutProperty(DWORD  dwPropertyId)
{
    DWORD  FilteredIds[] = {
        XENROLL_RENEWAL_CERTIFICATE_PROP_ID,
        XENROLL_PASS_THRU_PROP_ID,
        CERT_KEY_PROV_INFO_PROP_ID,
        CERT_ENROLLMENT_PROP_ID, //pending property
    };
    DWORD i;

    for (i = 0; i < ARRAYSIZE(FilteredIds); ++i)
    {
        if (dwPropertyId == FilteredIds[i])
        {
            return TRUE;
        }
    }
    return FALSE;
}

HRESULT CCEnroll::GetEndEntityCert(
    PCRYPT_DATA_BLOB    pBlobPKCS7,
    BOOL                fSaveToStores,
    PCCERT_CONTEXT     *ppCert
    )
{
    HRESULT                     hr = S_OK;
    HCERTSTORE                  hStoreMsg               = NULL;
    HCERTSTORE                  hStoreMy                = NULL;
    HCERTSTORE                  hStoreRequest           = NULL;

    PCCERT_CONTEXT              pCertContextLast        = NULL;
    PCCERT_CONTEXT              pCertContextRequest     = NULL;
    PCCERT_CONTEXT              pCertContextMsg         = NULL;
    PCCERT_CONTEXT              pCertContextArchive     = NULL;

    PCRYPT_KEY_PROV_INFO                pKeyProvInfo            = NULL;
    DWORD                       cb                      = 0;
    CRYPT_DATA_BLOB             blobData;

    CRYPT_HASH_BLOB             blobHash                = {sizeof(m_arHashBytesNewCert), m_arHashBytesNewCert};
    CRYPT_HASH_BLOB             blobHashRenew           = {sizeof(m_arHashBytesOldCert), m_arHashBytesOldCert};

    RequestFlags                requestFlags;
    CRYPT_HASH_BLOB             requestFlagsBlob;

    CRYPT_HASH_BLOB             renewalCertBlob;

    //Bug #202557 for IE3.02 upd clients (xiaohs)
    HCRYPTPROV                  hProv=NULL;
    BOOL  fSetting;
    DWORD                       dwPropertyId;
    CRYPT_DATA_BLOB             blobProp;
    BYTE                        *pbArchivedKeyHash = NULL;
    DWORD                        cbArchivedKeyHash = 0;

    EnterCriticalSection(&m_csXEnroll);

    memset(&requestFlags, 0, sizeof(RequestFlags));
    memset(&blobData, 0, sizeof(CRYPT_DATA_BLOB));
    memset(&requestFlagsBlob, 0, sizeof(CRYPT_DATA_BLOB));
    memset(&renewalCertBlob, 0, sizeof(CRYPT_DATA_BLOB));
    ZeroMemory(&blobProp, sizeof(blobProp));

    if (NULL == ppCert)
    {
        hr = MY_HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto InvalidParameterError;
    }

    //init return
    *ppCert = NULL;

    if(!MyCryptQueryObject(CERT_QUERY_OBJECT_BLOB,
                       pBlobPKCS7,
                       (CERT_QUERY_CONTENT_FLAG_CERT |
                       CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED |
                       CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE |
                       CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED) ,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       NULL,
                       NULL,
                       &hStoreMsg,
                       NULL,
                       NULL))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto ErrorCryptQueryObject;
    }

    // check to see if this hash is in the message
    if (m_pCertContextStatic == NULL  ||
        (NULL == (pCertContextMsg = CertFindCertificateInStore(
                                hStoreMsg,
                                X509_ASN_ENCODING,
                                0,
                                CERT_FIND_HASH,
                                &blobHash,
                                NULL))))
    {
        // open the request store
        if (NULL == (hStoreRequest = GetStore(StoreREQUEST)))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto ErrorCertOpenRequestStore;
        }
        // find cert in request store that matches cert
        // in message, by public key
        while (NULL != (pCertContextMsg = CertEnumCertificatesInStore(
                            hStoreMsg,
                            pCertContextLast)))
        {
            // check to see if this is in the request store
            if (NULL != (pCertContextRequest = CertFindCertificateInStore(
                    hStoreRequest,
                    CRYPT_ASN_ENCODING,
                    0,
                    CERT_FIND_PUBLIC_KEY,
                    (void *) &pCertContextMsg->pCertInfo->SubjectPublicKeyInfo,
                    NULL)))
            {
                // found a match, get out
                break;
            }

            pCertContextLast = pCertContextMsg;
        }
        pCertContextLast = NULL;

        // if we didn't find one, then GetLastError was set either
        // by CertEnumCerificatesInStore or CertEnumCerificatesInStore
        if (NULL == pCertContextRequest)
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto ErrorNoCertFound;
        }

        if (fSaveToStores)
        {
        // check archived key hash property first
        // if the property exists, means key archival was in the request
        cb = 0;
        while (TRUE)
        {
            if(!CertGetCertificateContextProperty(
                    pCertContextRequest,
                    CERT_ARCHIVED_KEY_HASH_PROP_ID,
                    pbArchivedKeyHash,
                    &cbArchivedKeyHash))
            {
                if (NULL == pbArchivedKeyHash)
                {
                    hr = MY_HRESULT_FROM_WIN32(GetLastError());
                    if (MY_HRESULT_FROM_WIN32(CRYPT_E_NOT_FOUND) == hr)
                    {
                        //no such property, so we are done
                        break;
                    }
                    // some other error
                    goto ErrorCertGetCertificateContextProperty;
                }
                else
                {
                    //if pbArchivedKeyHash non-null, error
                    hr = MY_HRESULT_FROM_WIN32(GetLastError());
                    goto ErrorCertGetCertificateContextProperty;
                }
            }
            if (NULL != pbArchivedKeyHash)
            {
                //got it, done
                break;
            }
            pbArchivedKeyHash = (BYTE*)LocalAlloc(
                                    LMEM_FIXED, cbArchivedKeyHash);
            if (NULL == pbArchivedKeyHash)
            {
                hr = E_OUTOFMEMORY;
                goto OutOfMemoryError;
            }
        }

        if (NULL != pbArchivedKeyHash && NULL == m_blobResponseKAHash.pbData)
        {
            //request cert has archived key hash but response
            //doesn't contain key hash for verification. maybe
            //a spoofing response?
            hr = XENROLL_E_RESPONSE_KA_HASH_NOT_FOUND;
            goto ResponseKAHashNotFoundError;
        }
        if (NULL == pbArchivedKeyHash && NULL != m_blobResponseKAHash.pbData)
        {
            //request cert doesn't have archived key hash but
            //response does. confliciting. seems no security harm
            hr = XENROLL_E_RESPONSE_UNEXPECTED_KA_HASH;
            goto ResponseUnexpectedKAHashError;
        }
        if (NULL != pbArchivedKeyHash && NULL != m_blobResponseKAHash.pbData)
        {
            //now we should check if they match
            //compare size and hash
            if (cbArchivedKeyHash != m_blobResponseKAHash.cbData ||
                0 != memcmp(pbArchivedKeyHash,
                            m_blobResponseKAHash.pbData,
                            cbArchivedKeyHash))
            {
                //oh, potential attack
                hr = XENROLL_E_RESPONSE_KA_HASH_MISMATCH;
                //should remove the request cert?
                goto ResponseKAMismatchError;
            }
        }
        }

        // get those request cert properties that are,
        // either the property not blob property
        // or blob property needs special handling
        // Important: remember to add these Ids in IsFilteredOutProperty
        fSetting = TRUE;
        cb = 0;
        while (TRUE)
        {
            if(!CertGetCertificateContextProperty(
                    pCertContextRequest,
                    CERT_KEY_PROV_INFO_PROP_ID,
                    pKeyProvInfo,
                    &cb))
            {
                if (NULL == pKeyProvInfo)
                {
                    //skip setting
                    fSetting = FALSE;
                    break;
                }
                else
                {
                    hr = MY_HRESULT_FROM_WIN32(GetLastError());
                    goto ErrorCertGetCertificateContextProperty;
                }
            }
            if (NULL != pKeyProvInfo)
            {
                //got it, done
                break;
            }
            pKeyProvInfo = (PCRYPT_KEY_PROV_INFO)LocalAlloc(LMEM_FIXED, cb);
            if (NULL == pKeyProvInfo)
            {
                hr = E_OUTOFMEMORY;
                goto OutOfMemoryError;
            }
        }
        if (fSetting)
        {
            // put the property on the returned cert
            if( !CertSetCertificateContextProperty(
                    pCertContextMsg,
                    CERT_KEY_PROV_INFO_PROP_ID,
                    0,
                    pKeyProvInfo) )
            {
                hr = MY_HRESULT_FROM_WIN32(GetLastError());
                goto ErrorSetMyCertPropError;
            }

            // Set the provider info
            SetKeyParams(pKeyProvInfo);
        }

        fSetting = TRUE;
        while (TRUE)
        {
            if(!CertGetCertificateContextProperty(
                    pCertContextRequest,
                    XENROLL_PASS_THRU_PROP_ID,
                    requestFlagsBlob.pbData,
                    &requestFlagsBlob.cbData) )
            {
                if (NULL == requestFlagsBlob.pbData)
                {
                    //do nothing
                    fSetting = FALSE;
                    break;
                }
                else
                {
                    hr = MY_HRESULT_FROM_WIN32(GetLastError());
                    goto ErrorDecodeRequestFlags;
                }
            }
            if (NULL != requestFlagsBlob.pbData)
            {
                //got it, done
                break;
            }
            requestFlagsBlob.pbData = (BYTE *)LocalAlloc(LMEM_FIXED,
                                                requestFlagsBlob.cbData);
            if (NULL == requestFlagsBlob.pbData)
            {
                hr = E_OUTOFMEMORY;
                goto OutOfMemoryError;
            }
        }

        if (fSetting)
        {
            // get the encoded blob
            cb = sizeof(requestFlags);
            // since this is a private data structure, its size should be
            // known and this should aways pass
            if (!CryptDecodeObject(
                    CRYPT_ASN_ENCODING,
                    XENROLL_REQUEST_INFO,
                    requestFlagsBlob.pbData,
                    requestFlagsBlob.cbData,
                    0,
                    &requestFlags,
                    &cb))
            {
                hr = MY_HRESULT_FROM_WIN32(GetLastError());
                goto ErrorDecodeRequestFlags;
            }
            // now set the flags
            if(!m_fWriteCertToCSPModified)
                m_fWriteCertToCSP     = requestFlags.fWriteToCSP;
            if(!m_fWriteCertToUserDSModified)
                m_fWriteCertToUserDS  = requestFlags.fWriteToDS;
            if(!m_fRequestStoreOpenFlagsModified)
                m_RequestStore.dwFlags = requestFlags.openFlags;
            if(!m_fMyStoreOpenFlagsModified)
                m_MyStore.dwFlags =   (m_MyStore.dwFlags & ~CERT_SYSTEM_STORE_LOCATION_MASK) |
                                    (requestFlags.openFlags & CERT_SYSTEM_STORE_LOCATION_MASK);
            if(!m_fCAStoreOpenFlagsModified)
                m_CAStore.dwFlags =   (m_CAStore.dwFlags & ~CERT_SYSTEM_STORE_LOCATION_MASK) |
                                    (requestFlags.openFlags & CERT_SYSTEM_STORE_LOCATION_MASK);
            if(!m_fRootStoreOpenFlagsModified) { 
		//
		// POTENTIAL SCRIPTING VIOLATION: we're mapping request store flags directly to root store flags. 
		// If they have set request store flags to local machine, propagate this setting to the root store flags, 
		// but set the root store name to "CA". 
		// 
		if (0 != m_dwEnabledSafteyOptions) { 
		    if (requestFlags.openFlags & CERT_SYSTEM_STORE_LOCAL_MACHINE) { 
			m_RootStore.wszName = wszCA; 
		    }
		}
                m_RootStore.dwFlags = (m_RootStore.dwFlags & ~CERT_SYSTEM_STORE_LOCATION_MASK) |
		    (requestFlags.openFlags & CERT_SYSTEM_STORE_LOCATION_MASK);
	    }
        }

        // see if this is a renewal request
        m_fArchiveOldCert = FALSE;
        fSetting = TRUE;
        while (TRUE)
        {
            // get the encoded blob
            if (!CertGetCertificateContextProperty(
                    pCertContextRequest,
                    XENROLL_RENEWAL_CERTIFICATE_PROP_ID,
                    renewalCertBlob.pbData,
                    &renewalCertBlob.cbData))
            {
                if (NULL == renewalCertBlob.pbData)
                {
                    fSetting = FALSE;
                    break;
                }
                else
                {
                    hr = MY_HRESULT_FROM_WIN32(GetLastError());
                    goto ErrorCertGetCertificateContextProperty;
                }
            }
            if (NULL != renewalCertBlob.pbData)
            {
                //got it, done
                break;
            }
            renewalCertBlob.pbData = (BYTE *)LocalAlloc(LMEM_FIXED,
                                                renewalCertBlob.cbData);
            if (NULL == renewalCertBlob.pbData)
            {
                hr = E_OUTOFMEMORY;
                goto OutOfMemoryError;
            }
        }
        if (fSetting)
        {
            //Bug #202557 for IE3.02 upd clients (xiaohs)
            if (NULL==hProv)
            {
                if(!CryptAcquireContext(
                        &hProv,
                        NULL,
                        MS_DEF_PROV,
                        PROV_RSA_FULL,
                        CRYPT_VERIFYCONTEXT))
                {
                    hr = MY_HRESULT_FROM_WIN32(GetLastError());
                    goto ErrorAcquireContext;
                }
            }

            if (!CryptHashCertificate(
                hProv,  //NULL,         Bug #202557 for IE3.02 upd clients (xiaohs)
                0,      //alg
                X509_ASN_ENCODING,      //0 dwFlags
                renewalCertBlob.pbData,
                renewalCertBlob.cbData,
                blobHashRenew.pbData,
                &blobHashRenew.cbData))
            {
                hr = MY_HRESULT_FROM_WIN32(GetLastError());
                goto ErrorCryptHashCertificate;
            }
            m_fArchiveOldCert = TRUE;
        }

        //get rest of blob properties from request store and set to the cert
        dwPropertyId = CertEnumCertificateContextProperties(
                            pCertContextRequest, 0);  //enum from 1st
        while (0 != dwPropertyId)
        {
//            if (!IsFilteredOutProperty(dwPropertyId))
//because iis cert install doesn't like to copy all properties from
//request cert to install cert we just copy selected properties for now
            if (IsDesiredProperty(dwPropertyId))
            {
                fSetting = TRUE;
                while (TRUE)
                {
                    if (!CertGetCertificateContextProperty(
                            pCertContextRequest,
                            dwPropertyId,
                            blobProp.pbData,
                            &blobProp.cbData))
                    {
                        //no get, no set, go on
                        fSetting = FALSE;
                        break;
                    }
                    if (NULL != blobProp.pbData)
                    {
                        //done
                        break;
                    }
                    blobProp.pbData = (BYTE*)LocalAlloc(LMEM_FIXED, 
                                                        blobProp.cbData);
                    if (NULL == blobProp.pbData)
                    {
                        goto OutOfMemoryError;
                    }
                }
                if (fSetting)
                {
                    //should get the property from the request cert
                    if (!CertSetCertificateContextProperty(
                                pCertContextMsg,
                                dwPropertyId,
                                0,
                                &blobProp))
                    {
                        hr = MY_HRESULT_FROM_WIN32(GetLastError());
                        goto ErrorSetMyCertPropError;
                    }
                }
                if (NULL != blobProp.pbData)
                {
                    //set for the next enum
                    LocalFree(blobProp.pbData);
                    blobProp.pbData = NULL;
                }
            }
            dwPropertyId = CertEnumCertificateContextProperties(
                                  pCertContextRequest,
                                  dwPropertyId);
        }

        // save this away in the cache
        if(m_pCertContextStatic != NULL)
            CertFreeCertificateContext(m_pCertContextStatic);

        m_pCertContextStatic = CertDuplicateCertificateContext(pCertContextMsg);

        //Bug #202557 for IE3.02 upd clients (xiaohs)
        if(NULL==hProv)
        {
            if(!CryptAcquireContext(
                &hProv,
                NULL,
                MS_DEF_PROV,
                PROV_RSA_FULL,
                CRYPT_VERIFYCONTEXT))
            {
                hr = MY_HRESULT_FROM_WIN32(GetLastError());
                goto ErrorAcquireContext;
            }
        }

        if( !CryptHashCertificate(
            hProv,             //NULL Bug #202557 for IE3.02 upd clients (xiaohs)
            0,
            X509_ASN_ENCODING,
            pCertContextMsg->pbCertEncoded,
            pCertContextMsg->cbCertEncoded,
            blobHash.pbData,
            &blobHash.cbData) )
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto ErrorCryptHashCertificate;
        }
    }

    // at this point we have 2 context m_pCertContextStatic which we want to return to the user
    // and pCertContextMsg which we want to delete from the Msg store
    assert(pCertContextMsg != NULL);
    CertDeleteCertificateFromStore(pCertContextMsg);
    pCertContextMsg = NULL; // freed by the delete

    // we want to return our static, so make a dup and this is what we will return
    assert(m_pCertContextStatic != NULL);
    pCertContextMsg = CertDuplicateCertificateContext(m_pCertContextStatic);

    // put these in the stores if asked
    if(fSaveToStores) {

        // open the stores
        if( (hStoreMy = GetStore(StoreMY)) == NULL)
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto ErrorCertOpenMYStore;
        }

        // we know that the pCertContextMsg is a dup of the end-entity cert in m_pCertContextStatic
        // and we want to put this in the MY store
        assert(pCertContextMsg != NULL);
        if( !MySafeCertAddCertificateContextToStore(
                hStoreMy,
                pCertContextMsg,
                CERT_STORE_ADD_USE_EXISTING,
                NULL,
		m_dwEnabledSafteyOptions) )
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto ErrorCertAddToMyStore;
        }

        // If we have renewal, then mark the old cert as an archive
        if(m_fArchiveOldCert &&
            ((pCertContextArchive = CertFindCertificateInStore(
                    hStoreMy,
                    X509_ASN_ENCODING,
                    0,
                    CERT_FIND_HASH,
                    &blobHashRenew,
                    NULL)) != NULL) ) {

            // Set the Archive property on the cert.
            // crypt32 in IE3.02upd does not support this prop, so don't fail on error
            CertSetCertificateContextProperty(
                                pCertContextArchive,
                                CERT_ARCHIVED_PROP_ID,
                                0,
                                &blobData);

            //set new cert hash on old archived cert
            //ignore error if it fails
            CertSetCertificateContextProperty(
                                pCertContextArchive,
                                CERT_RENEWAL_PROP_ID,
                                0,
                                &blobHash);
        }

        // add the rest of the certs to the stores
        hr = AddCertsToStores(hStoreMsg, NULL);
        //ignore cancel error since it from root cert install
        //ignore XENROLL_E_CANNOT_ADD_ROOT_CERT also
        if (S_OK != hr &&
            MY_HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr &&
            XENROLL_E_CANNOT_ADD_ROOT_CERT != hr)
        {
            goto ErrorAddCertsToStores;
        }
    }

    *ppCert = pCertContextMsg;

CommonReturn:

    //Bug #202557 for IE3.02 upd clients (xiaohs)
    if(hProv)
        CryptReleaseContext(hProv, 0);

    if(pCertContextRequest != NULL)
        CertFreeCertificateContext(pCertContextRequest);

    if(pCertContextArchive != NULL)
        CertFreeCertificateContext(pCertContextArchive);

    // it really should be NULL
    assert(pCertContextLast == NULL);

    if(hStoreMsg != NULL)
        CertCloseStore(hStoreMsg, 0);

    // we need to do this because the store that may be opened is the systemstore, but
    // the store we may need is the local machine store, but we don't know that until the
    // system store finds the request cert in the local machine physical store.
    // Later when we do the delete, we want the local machine store open.
    FlushStore(StoreREQUEST);

    if (NULL != requestFlagsBlob.pbData)
    {
        LocalFree(requestFlagsBlob.pbData);
    }
    if (NULL != renewalCertBlob.pbData)
    {
        LocalFree(renewalCertBlob.pbData);
    }
    if (NULL != blobProp.pbData)
    {
        LocalFree(blobProp.pbData);
    }
    if (NULL != pKeyProvInfo)
    {
        LocalFree(pKeyProvInfo);
    }
    if (NULL != pbArchivedKeyHash)
    {
        LocalFree(pbArchivedKeyHash);
    }

    LeaveCriticalSection(&m_csXEnroll);

    return (hr);

ErrorReturn:
    if(NULL != pCertContextMsg)
    {
        CertFreeCertificateContext(pCertContextMsg);
    }
    goto CommonReturn;

TRACE_ERROR(ErrorCryptHashCertificate);
TRACE_ERROR(ErrorCertOpenMYStore);
TRACE_ERROR(ErrorCertAddToMyStore);
TRACE_ERROR(ErrorCryptQueryObject);
TRACE_ERROR(ErrorCertOpenRequestStore);
TRACE_ERROR(ErrorNoCertFound);
TRACE_ERROR(ErrorCertGetCertificateContextProperty);
TRACE_ERROR(ErrorSetMyCertPropError);
TRACE_ERROR(ErrorDecodeRequestFlags);
TRACE_ERROR(ErrorAcquireContext);      //Bug #202557 for IE3.02 upd clients (xiaohs)
TRACE_ERROR(ErrorAddCertsToStores);
TRACE_ERROR(OutOfMemoryError);
TRACE_ERROR(InvalidParameterError);
TRACE_ERROR(ResponseKAMismatchError)
TRACE_ERROR(ResponseUnexpectedKAHashError)
TRACE_ERROR(ResponseKAHashNotFoundError)
}

HRESULT STDMETHODCALLTYPE CCEnroll::getCertFromPKCS7(
                        /* [in] */ BSTR wszPKCS7,
                        /* [retval][out] */ BSTR __RPC_FAR *pbstrCert
) {

    HRESULT     hr;                     
    CRYPT_DATA_BLOB             blobPKCS7;
    CRYPT_DATA_BLOB             blobX509;
    PCCERT_CONTEXT              pCertContextMy          = NULL;

    assert(wszPKCS7 != NULL && pbstrCert != NULL);
    if (NULL == wszPKCS7 || NULL == pbstrCert)
	goto PointerError; 

    // just put into a blob
    memset(&blobPKCS7, 0, sizeof(CRYPT_DATA_BLOB));
    blobPKCS7.cbData = SysStringByteLen(wszPKCS7);
    blobPKCS7.pbData = (PBYTE) wszPKCS7;

    // Get a Cert Context for the end-entity
    if( (pCertContextMy = getCertContextFromPKCS7(&blobPKCS7)) == NULL)
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto getCertContextFromPKCS7Error;
    }

    blobX509.pbData = pCertContextMy->pbCertEncoded;
    blobX509.cbData = pCertContextMy->cbCertEncoded;
    //base64 with no header for backward compatible
    hr = BlobToBstring(&blobX509, CRYPT_STRING_BASE64, pbstrCert);
    if (S_OK != hr)
    {
        goto BlobToBstringError;
    }

    hr = S_OK;
ErrorReturn:
    if(pCertContextMy != NULL)
        CertFreeCertificateContext(pCertContextMy);

    return(hr);

SET_HRESULT(PointerError, E_POINTER); 
TRACE_ERROR(getCertContextFromPKCS7Error);
TRACE_ERROR(BlobToBstringError);
}

HRESULT STDMETHODCALLTYPE CCEnroll::acceptPKCS7(
                        /* [in] */ BSTR wszPKCS7) {

    CRYPT_DATA_BLOB             blobPKCS7;
    HRESULT                     hr; 

    assert(wszPKCS7 != NULL);
    if (NULL == wszPKCS7) 
	goto PointerError; 

    // just put into a blob
    memset(&blobPKCS7, 0, sizeof(CRYPT_DATA_BLOB));
    blobPKCS7.cbData = SysStringByteLen(wszPKCS7);
    blobPKCS7.pbData = (PBYTE) wszPKCS7;

    // accept the blob
    hr = acceptPKCS7Blob(&blobPKCS7);
 ErrorReturn:
    return hr; 

SET_HRESULT(PointerError, E_POINTER); 
}

HRESULT STDMETHODCALLTYPE CCEnroll::createFilePKCS10(
    /* [in] */ BSTR DNName,
    /* [in] */ BSTR Usage,
    /* [in] */ BSTR wszPKCS10FileName) {
    return(createFilePKCS10WStr(DNName, Usage, wszPKCS10FileName));
}

HRESULT STDMETHODCALLTYPE CCEnroll::addCertTypeToRequest(
            /* [in] */ BSTR CertType) {
    return(AddCertTypeToRequestWStr(CertType));
}


HRESULT STDMETHODCALLTYPE CCEnroll::addCertTypeToRequestEx( 
    IN  LONG            lType,
    IN  BSTR            bstrOIDOrName,
    IN  LONG            lMajorVersion,
    IN  BOOL            fMinorVersion,
    IN  LONG            lMinorVersion)
{
    return AddCertTypeToRequestWStrEx(
                        lType,
                        bstrOIDOrName,
                        lMajorVersion,
                        fMinorVersion,
                        lMinorVersion);
                    
}

HRESULT STDMETHODCALLTYPE CCEnroll::getProviderType( 
    IN  BSTR  strProvName,
    OUT LONG *plProvType)
{
    return getProviderTypeWStr(strProvName, plProvType);
}

HRESULT STDMETHODCALLTYPE CCEnroll::addNameValuePairToSignature(
    /* [in] */ BSTR Name,
    /* [in] */ BSTR Value) {
    return(AddNameValuePairToSignatureWStr(Name, Value));
}

HRESULT STDMETHODCALLTYPE CCEnroll::acceptFilePKCS7(
    /* [in] */ BSTR wszPKCS7FileName) {
    return(acceptFilePKCS7WStr(wszPKCS7FileName));
}

HRESULT STDMETHODCALLTYPE CCEnroll::freeRequestInfo(
    /* [in] */ BSTR bstrPKCS7OrPKCS10)
{
    HRESULT  hr;
    CRYPT_DATA_BLOB blob; 
    BYTE *pbData = NULL;
    DWORD cbData = 0;

    // could be base64
    while (TRUE)
    {
        if (!MyCryptStringToBinaryW(
                        (WCHAR*)bstrPKCS7OrPKCS10,
                        SysStringLen(bstrPKCS7OrPKCS10),
                        CRYPT_STRING_ANY,
                        pbData,
                        &cbData,
                        NULL,
                        NULL))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto MyCryptStringToBinaryWError;
        }
        if (NULL != pbData)
        {
            break; //done
        }
        pbData = (BYTE*)LocalAlloc(LMEM_FIXED, cbData);
        if (NULL == pbData)
        {
            hr = E_OUTOFMEMORY;
            goto OutOfMemoryError;
        }
    }

    blob.cbData = cbData;
    blob.pbData = pbData;

    hr = freeRequestInfoBlob(blob); 
    if (S_OK != hr)
    {
        goto freeRequestInfoBlobError;
    }

    hr = S_OK;
ErrorReturn:
    if (NULL != pbData)
    {
        LocalFree(pbData);
    }
    return hr;

TRACE_ERROR(MyCryptStringToBinaryWError)
TRACE_ERROR(OutOfMemoryError)
TRACE_ERROR(freeRequestInfoBlobError)
}


//
// MY STORE
//
HCERTSTORE STDMETHODCALLTYPE CCEnroll::getMyStore( void)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED); 
    return NULL; 
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_MyStoreName(
    /* [retval][out] */ BSTR __RPC_FAR *pbstrName) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    
    if(m_MyStore.wszName == NULL) 
        return(ERROR_UNKNOWN_PROPERTY);
        
    if( (*pbstrName = SysAllocString(m_MyStore.wszName)) == NULL )
        hr = E_OUTOFMEMORY;
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_MyStoreName(
    /* [in] */ BSTR bstrName) {
    return(put_MyStoreNameWStr(bstrName));
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_MyStoreType(
    /* [retval][out] */ BSTR __RPC_FAR *pbstrType) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if( (*pbstrType = BSTRFromMB(m_MyStore.szType)) == NULL )
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_MyStoreType(
    /* [in] */ BSTR bstrType) {
    return(put_MyStoreTypeWStr(bstrType));
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_MyStoreFlags(
    /* [retval][out] */ LONG __RPC_FAR *pdwFlags) {
    EnterCriticalSection(&m_csXEnroll);
    *pdwFlags = m_MyStore.dwFlags;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

//--------------------------------------------------------------------------------
//
// This method is only safe for scripting if it's parameter is safe. 
// See VerifyStoreFlagsSafeForScripting(). 
//
//--------------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CCEnroll::put_MyStoreFlags(
    /* [in] */ LONG dwFlags) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);

    // If we're marked as safe for scripting, see if the flags passed in are safe:
    if (0 != m_dwEnabledSafteyOptions && !VerifyStoreFlagsSafeForScripting(dwFlags))
	goto AccessDeniedError; 

    if(m_MyStore.hStore != NULL)
        hr = E_ACCESSDENIED;
    else {

        // set the my store flags
        m_MyStore.dwFlags = dwFlags;
        m_fMyStoreOpenFlagsModified = TRUE;
        m_keyProvInfo.dwFlags |= KeyLocationFromStoreLocation(dwFlags);

        // track the request store location to the my store, only if the request store has not been modified
        // do NOT set the modify bit for the request store, this is a default
        if(!m_fRequestStoreOpenFlagsModified) {
            m_RequestStore.dwFlags &= ~CERT_SYSTEM_STORE_LOCATION_MASK;
            m_RequestStore.dwFlags |= (dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK);
        }
    }

 ErrorReturn:
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);

SET_HRESULT(AccessDeniedError, E_ACCESSDENIED); 
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_MyStoreNameWStr(
    /* [out] */ LPWSTR __RPC_FAR *szwName) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    
    if(m_MyStore.wszName == NULL) 
        return(ERROR_UNKNOWN_PROPERTY);
        
    if( (*szwName = CopyWideString(m_MyStore.wszName)) == NULL )
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

//--------------------------------------------------------------------------------
//
// THIS METHOD IS NOT SAFE FOR SCRIPTING
//
//--------------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CCEnroll::put_MyStoreNameWStr(
    /* [in] */ LPWSTR szwName) {
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_csXEnroll);
     
    if (0 != m_dwEnabledSafteyOptions) // not safe for scripting
	goto AccessDeniedError;

    if(m_MyStore.hStore != NULL)
        hr = E_ACCESSDENIED;
    else {
        if(m_MyStore.wszName != wszMY)
            MyCoTaskMemFree(m_MyStore.wszName);
        if( (m_MyStore.wszName = CopyWideString(szwName)) == NULL )
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
    }
   
 ErrorReturn:
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);

SET_HRESULT(AccessDeniedError, E_ACCESSDENIED); 
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_MyStoreTypeWStr(
    /* [out] */ LPWSTR __RPC_FAR *szwType) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if( (*szwType = WideFromMB(m_MyStore.szType)) == NULL )
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}


//--------------------------------------------------------------------------------
//
// THIS METHOD IS NOT SAFE FOR SCRIPTING
//
//--------------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CCEnroll::put_MyStoreTypeWStr(
    /* [in] */ LPWSTR szwType) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);

    if (0 != m_dwEnabledSafteyOptions) // not safe for scripting
	goto AccessDeniedError;

    if(m_MyStore.hStore != NULL)
        hr = E_ACCESSDENIED;
    else {
        if(m_MyStore.szType != szSystemStore)
            MyCoTaskMemFree(m_MyStore.szType);
        if( (m_MyStore.szType = MBFromWide(szwType)) == NULL )
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
    }

 ErrorReturn:
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);

SET_HRESULT(AccessDeniedError, E_ACCESSDENIED); 
}

//
// CA STORE
//
HCERTSTORE STDMETHODCALLTYPE CCEnroll::getCAStore( void)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED); 
    return NULL; 
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_CAStoreName(
    /* [retval][out] */ BSTR __RPC_FAR *pbstrName) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    
    if(m_CAStore.wszName == NULL) 
        return(ERROR_UNKNOWN_PROPERTY);
        
    if( (*pbstrName = SysAllocString(m_CAStore.wszName)) == NULL )
        hr = E_OUTOFMEMORY;
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_CAStoreName(
    /* [in] */ BSTR bstrName) {
    return(put_CAStoreNameWStr(bstrName));
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_CAStoreType(
    /* [retval][out] */ BSTR __RPC_FAR *pbstrType) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if( (*pbstrType = BSTRFromMB(m_CAStore.szType)) == NULL )
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_CAStoreType(
    /* [in] */ BSTR bstrType) {
    return(put_CAStoreTypeWStr(bstrType));
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_CAStoreFlags(
    /* [retval][out] */ LONG __RPC_FAR *pdwFlags) {
    EnterCriticalSection(&m_csXEnroll);
    *pdwFlags = m_CAStore.dwFlags;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

//--------------------------------------------------------------------------------
//
// This method is only safe for scripting if it's parameter is safe. 
// See VerifyStoreFlagsSafeForScripting(). 
//
//--------------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CCEnroll::put_CAStoreFlags(
    /* [in] */ LONG dwFlags) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);

    // If we're marked as safe for scripting, see if the flags passed in are safe:
    if (0 != m_dwEnabledSafteyOptions && !VerifyStoreFlagsSafeForScripting(dwFlags))
	goto AccessDeniedError; 

    if(m_CAStore.hStore != NULL)
        hr = E_ACCESSDENIED;
    else {
        m_fCAStoreOpenFlagsModified = TRUE;
        m_CAStore.dwFlags = dwFlags;
    }

 ErrorReturn:
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
SET_HRESULT(AccessDeniedError, E_ACCESSDENIED); 
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_CAStoreNameWStr(
    /* [out] */ LPWSTR __RPC_FAR *szwName) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    
    if(m_CAStore.wszName == NULL) 
        return(ERROR_UNKNOWN_PROPERTY);
        
    if( (*szwName = CopyWideString(m_CAStore.wszName)) == NULL )
         hr = MY_HRESULT_FROM_WIN32(GetLastError());
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

//--------------------------------------------------------------------------------
//
// THIS METHOD IS NOT SAFE FOR SCRIPTING
//
//--------------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CCEnroll::put_CAStoreNameWStr(
    /* [in] */ LPWSTR szwName) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);

    if (0 != m_dwEnabledSafteyOptions) // not safe for scripting
	goto AccessDeniedError;

    if(m_CAStore.hStore != NULL)
        hr = E_ACCESSDENIED;
    else {
        if(m_CAStore.wszName != wszCA)
            MyCoTaskMemFree(m_CAStore.wszName);
        if( (m_CAStore.wszName = CopyWideString(szwName)) == NULL )
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
    }

 ErrorReturn:
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);

SET_HRESULT(AccessDeniedError, E_ACCESSDENIED); 
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_CAStoreTypeWStr(
    /* [out] */ LPWSTR __RPC_FAR *szwType) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if( (*szwType = WideFromMB(m_CAStore.szType)) == NULL )
         hr = MY_HRESULT_FROM_WIN32(GetLastError());
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

//--------------------------------------------------------------------------------
//
// THIS METHOD IS NOT SAFE FOR SCRIPTING
//
//--------------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CCEnroll::put_CAStoreTypeWStr(
    /* [in] */ LPWSTR szwType) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);

    if (0 != m_dwEnabledSafteyOptions) // not safe for scripting
	goto AccessDeniedError;

    if(m_CAStore.hStore != NULL)
        hr = E_ACCESSDENIED;
    else {
        if(m_CAStore.szType != szSystemStore)
            MyCoTaskMemFree(m_CAStore.szType);
        if( (m_CAStore.szType = MBFromWide(szwType)) == NULL )
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
    }

 ErrorReturn:
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);

SET_HRESULT(AccessDeniedError, E_ACCESSDENIED); 
}

//
// ROOT STORE
//
HCERTSTORE STDMETHODCALLTYPE CCEnroll::getROOTHStore( void)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED); 
    return NULL; 
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_RootStoreName(
    /* [retval][out] */ BSTR __RPC_FAR *pbstrName) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    
    if(m_RootStore.wszName == NULL) 
        return(ERROR_UNKNOWN_PROPERTY);
        
    if( (*pbstrName = SysAllocString(m_RootStore.wszName)) == NULL )
        hr = E_OUTOFMEMORY;
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_RootStoreName(
    /* [in] */ BSTR bstrName) {
    return(put_RootStoreNameWStr(bstrName));
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_RootStoreType(
    /* [retval][out] */ BSTR __RPC_FAR *pbstrType) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if( (*pbstrType = BSTRFromMB(m_RootStore.szType)) == NULL )
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_RootStoreType(
    /* [in] */ BSTR bstrType) {
    return(put_RootStoreTypeWStr(bstrType));
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_RootStoreFlags(
    /* [retval][out] */ LONG __RPC_FAR *pdwFlags) {
    EnterCriticalSection(&m_csXEnroll);
    *pdwFlags = m_RootStore.dwFlags;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

//--------------------------------------------------------------------------------
//
// This method is only safe for scripting if it's parameter is safe. 
// See VerifyStoreFlagsSafeForScripting(). 
//
//--------------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CCEnroll::put_RootStoreFlags(
    /* [in] */ LONG dwFlags) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);

    // If we're marked as safe for scripting, see if the flags passed in are safe:
    if (0 != m_dwEnabledSafteyOptions) { 
	// see if the caller passed safe flags:
	if (!VerifyStoreFlagsSafeForScripting(dwFlags))
	    goto AccessDeniedError; 

	// extra check for root store:  don't allow CERT_SYSTEM_STORE_LOCAL_MACHINE for the root store. 
	// if they want to install a machine cert through script, it'll go to the CA store:
	// NOTE: we don't modify the store name if m_RootStore.hStore is NULL, as we'll return E_ACCESSDENIED
	// anyway, and we shouldn't modify this on error. 
	if (NULL == m_RootStore.hStore) { 
	    if (dwFlags & CERT_SYSTEM_STORE_LOCAL_MACHINE) { 
		m_RootStore.wszName = wszCA; 
	    } else { 
		m_RootStore.wszName = wszROOT; 
	    }
	}
    }

    if(m_RootStore.hStore != NULL)
        hr = E_ACCESSDENIED;
    else {
        m_fRootStoreOpenFlagsModified = TRUE;
        m_RootStore.dwFlags = dwFlags;
    }

 ErrorReturn:
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);

SET_HRESULT(AccessDeniedError, E_ACCESSDENIED); 
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_RootStoreNameWStr(
    /* [out] */ LPWSTR __RPC_FAR *szwName) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
   
    if(m_RootStore.wszName == NULL) 
        return(ERROR_UNKNOWN_PROPERTY);
        
    if( (*szwName = CopyWideString(m_RootStore.wszName)) == NULL )
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

//--------------------------------------------------------------------------------
//
// THIS METHOD IS NOT SAFE FOR SCRIPTING
//
//--------------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CCEnroll::put_RootStoreNameWStr(
    /* [in] */ LPWSTR szwName) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);

    if (0 != m_dwEnabledSafteyOptions) // not safe for scripting
	goto AccessDeniedError;

    if(m_RootStore.hStore != NULL)
        hr = E_ACCESSDENIED;
    else {
        if(m_RootStore.wszName != wszROOT && m_RootStore.wszName != wszCA)
            MyCoTaskMemFree(m_RootStore.wszName);
        if( (m_RootStore.wszName = CopyWideString(szwName)) == NULL )
             hr = MY_HRESULT_FROM_WIN32(GetLastError());
    }

 ErrorReturn:
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);

SET_HRESULT(AccessDeniedError, E_ACCESSDENIED); 
}


HRESULT STDMETHODCALLTYPE CCEnroll::get_RootStoreTypeWStr(
    /* [out] */ LPWSTR __RPC_FAR *szwType) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if( (*szwType = WideFromMB(m_RootStore.szType)) == NULL )
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

//--------------------------------------------------------------------------------
//
// THIS METHOD IS NOT SAFE FOR SCRIPTING
//
//--------------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CCEnroll::put_RootStoreTypeWStr(
    /* [in] */ LPWSTR szwType) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);

    if (0 != m_dwEnabledSafteyOptions) // not safe for scripting
	goto AccessDeniedError;

    if(m_RootStore.hStore != NULL)
        hr = E_ACCESSDENIED;
    else {
        if(m_RootStore.szType != szSystemStore)
            MyCoTaskMemFree(m_RootStore.szType);
        if( (m_RootStore.szType = MBFromWide(szwType)) == NULL )
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
    }

 ErrorReturn:
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);

SET_HRESULT(AccessDeniedError, E_ACCESSDENIED); 
}

//
// REQUEST STORE
//
HRESULT STDMETHODCALLTYPE CCEnroll::get_RequestStoreName(
    /* [retval][out] */ BSTR __RPC_FAR *pbstrName) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    
    if(m_RequestStore.wszName == NULL) 
        return(ERROR_UNKNOWN_PROPERTY);
        
    if( (*pbstrName = SysAllocString(m_RequestStore.wszName)) == NULL )
        hr = E_OUTOFMEMORY;
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_RequestStoreName(
    /* [in] */ BSTR bstrName) {
    return(put_RequestStoreNameWStr(bstrName));
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_RequestStoreType(
    /* [retval][out] */ BSTR __RPC_FAR *pbstrType) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if( (*pbstrType = BSTRFromMB(m_RequestStore.szType)) == NULL )
         hr = MY_HRESULT_FROM_WIN32(GetLastError());
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_RequestStoreType(
    /* [in] */ BSTR bstrType) {
    return(put_RequestStoreTypeWStr(bstrType));
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_RequestStoreFlags(
    /* [retval][out] */ LONG __RPC_FAR *pdwFlags) {
    EnterCriticalSection(&m_csXEnroll);
    *pdwFlags = m_RequestStore.dwFlags;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

//--------------------------------------------------------------------------------
//
// This method is only safe for scripting if it's parameter is safe. 
// See VerifyStoreFlagsSafeForScripting(). 
//
//--------------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CCEnroll::put_RequestStoreFlags(
    /* [in] */ LONG dwFlags) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);

    // If we're marked as safe for scripting, see if the flags passed in are safe:
    if (0 != m_dwEnabledSafteyOptions && !VerifyStoreFlagsSafeForScripting(dwFlags))
	goto AccessDeniedError; 

    if(m_RequestStore.hStore != NULL)
        hr = E_ACCESSDENIED;
    else {

        // set the request store flags
        m_RequestStore.dwFlags = dwFlags;
        m_fRequestStoreOpenFlagsModified = TRUE;

        // track the My store location to the request store, only if the my store has not been modified
        // do NOT set the modify bit for the my store, this is a default
        if(!m_fMyStoreOpenFlagsModified) {
            m_MyStore.dwFlags &= ~CERT_SYSTEM_STORE_LOCATION_MASK;
            m_MyStore.dwFlags |= (dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK);
            m_keyProvInfo.dwFlags |= KeyLocationFromStoreLocation(m_MyStore.dwFlags);
        }
    }

 ErrorReturn:
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);

SET_HRESULT(AccessDeniedError, E_ACCESSDENIED); 
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_RequestStoreNameWStr(
    /* [out] */ LPWSTR __RPC_FAR *szwName) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    
    if(m_RequestStore.wszName == NULL) 
        return(ERROR_UNKNOWN_PROPERTY);
        
    if( (*szwName = CopyWideString(m_RequestStore.wszName)) == NULL )
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

//--------------------------------------------------------------------------------
//
// THIS METHOD IS NOT SAFE FOR SCRIPTING
//
//--------------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CCEnroll::put_RequestStoreNameWStr(
    /* [in] */ LPWSTR szwType) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);

    if (0 != m_dwEnabledSafteyOptions) // not safe for scripting
	goto AccessDeniedError;

    if(m_RequestStore.hStore != NULL)
        hr = E_ACCESSDENIED;
    else {
        if(m_RequestStore.wszName != wszREQUEST)
            MyCoTaskMemFree(m_RequestStore.wszName);
        if( (m_RequestStore.wszName = CopyWideString(szwType)) == NULL )
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
    }

 ErrorReturn:
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);

SET_HRESULT(AccessDeniedError, E_ACCESSDENIED); 
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_RequestStoreTypeWStr(
    /* [out] */ LPWSTR __RPC_FAR *szwType) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if( (*szwType = WideFromMB(m_RequestStore.szType)) == NULL )
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

//--------------------------------------------------------------------------------
//
// THIS METHOD IS NOT SAFE FOR SCRIPTING
//
//--------------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CCEnroll::put_RequestStoreTypeWStr(
    /* [in] */ LPWSTR szwType) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);

    if (0 != m_dwEnabledSafteyOptions) // not safe for scripting
	goto AccessDeniedError;

    if(m_RequestStore.hStore != NULL)
        hr = E_ACCESSDENIED;
    else {
        if(m_RequestStore.szType != szSystemStore)
            MyCoTaskMemFree(m_RequestStore.szType);
        if( (m_RequestStore.szType = MBFromWide(szwType)) == NULL )
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
    }

 ErrorReturn:
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);

SET_HRESULT(AccessDeniedError, E_ACCESSDENIED); 
}

//
// Provider Stuff
//

HRESULT STDMETHODCALLTYPE CCEnroll::get_ContainerName(
    /* [retval][out] */ BSTR __RPC_FAR *pbstrContainer) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if( (*pbstrContainer = SysAllocString(m_keyProvInfo.pwszContainerName)) == NULL )
        hr = E_OUTOFMEMORY;
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_ContainerName(
    /* [in] */ BSTR bstrContainer) {
    return(put_ContainerNameWStr(bstrContainer));
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_ProviderName(
    /* [retval][out] */ BSTR __RPC_FAR *pbstrProvider) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if( (*pbstrProvider = SysAllocString(m_keyProvInfo.pwszProvName)) == NULL )
         hr = E_OUTOFMEMORY;
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_ProviderName(
    /* [in] */ BSTR bstrProvider) {
    return(put_ProviderNameWStr(bstrProvider));
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_ProviderType(
    /* [retval][out] */ LONG __RPC_FAR *pdwType) {
    EnterCriticalSection(&m_csXEnroll);
    *pdwType = m_keyProvInfo.dwProvType;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_ProviderType(
    /* [in] */ LONG dwType) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if(m_hProv != NULL)
        hr = E_ACCESSDENIED;
    else
        m_keyProvInfo.dwProvType = dwType;
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_KeySpec(
    /* [retval][out] */ LONG __RPC_FAR *pdw) {
    EnterCriticalSection(&m_csXEnroll);
    *pdw = m_keyProvInfo.dwKeySpec;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_KeySpec(
    /* [in] */ LONG dwKeySpec) {
    HRESULT hr;
    EnterCriticalSection(&m_csXEnroll);

    if(m_hProv != NULL)
    {
        hr = E_ACCESSDENIED;
        goto NullProvError;
    }

    if (m_fSMIMESetByClient)
    {
        //SMIME is set by the client
        if (m_fEnableSMIMECapabilities && AT_SIGNATURE == dwKeySpec)
        {
            //try to set signature key spec also SMIME
            hr = XENROLL_E_KEYSPEC_SMIME_MISMATCH;
            goto MismatchError;
        }
    }
    else
    {
        //currently smime is not set by user
        //turn on SMIME for according to key spec
        m_fEnableSMIMECapabilities = (dwKeySpec == AT_KEYEXCHANGE);
    }
    m_keyProvInfo.dwKeySpec = dwKeySpec;
    m_fKeySpecSetByClient = TRUE;

    hr = S_OK;
ErrorReturn:
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);

TRACE_ERROR(NullProvError)
TRACE_ERROR(MismatchError)
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_ClientId(
    /* [retval][out] */ LONG __RPC_FAR *pdw) {
    EnterCriticalSection(&m_csXEnroll);
    *pdw = m_lClientId;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_ClientId(
    /* [in] */ LONG dw) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    m_lClientId = dw;
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_IncludeSubjectKeyID(
    /* [retval][out] */ BOOL __RPC_FAR *pfInclude) {
    EnterCriticalSection(&m_csXEnroll);
    *pfInclude = m_fIncludeSubjectKeyID;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_IncludeSubjectKeyID(
    /* [in] */ BOOL fInclude) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    m_fIncludeSubjectKeyID = fInclude;
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_ProviderFlags(
    /* [retval][out] */ LONG __RPC_FAR *pdwFlags) {
    EnterCriticalSection(&m_csXEnroll);
    *pdwFlags = m_keyProvInfo.dwFlags;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

//--------------------------------------------------------------------------------
//
// This method is only safe for scripting if it's parameter is safe. 
// See VerifyProviderFlagsSafeForScripting(). 
//
//--------------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CCEnroll::put_ProviderFlags(
    /* [in] */ LONG dwFlags) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    
    // If we're marked as safe for scripting, see if the flags passed in are safe:
    if (0 != m_dwEnabledSafteyOptions && !VerifyProviderFlagsSafeForScripting(dwFlags))
	goto AccessDeniedError;

    if(m_hProv != NULL)
        hr = E_ACCESSDENIED;
    else
       m_keyProvInfo.dwFlags = dwFlags;

ErrorReturn:
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);

SET_HRESULT(AccessDeniedError, E_ACCESSDENIED);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_ContainerNameWStr(
    /* [out] */ LPWSTR __RPC_FAR *szwContainer) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if( (*szwContainer = CopyWideString(m_keyProvInfo.pwszContainerName)) == NULL )
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_ContainerNameWStr(
    /* [in] */ LPWSTR szwContainer) {
    HRESULT hr = S_OK;

    if(szwContainer == NULL)
        return(MY_HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
        
    EnterCriticalSection(&m_csXEnroll);
    
    if(m_hProv != NULL)
        hr = E_ACCESSDENIED;
    else {
        if( m_keyProvInfo.pwszContainerName != wszEmpty)
            MyCoTaskMemFree(m_keyProvInfo.pwszContainerName);
        if( (m_keyProvInfo.pwszContainerName = CopyWideString(szwContainer)) == NULL )
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
    }
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_ProviderNameWStr(
    /* [out] */ LPWSTR __RPC_FAR *szwProvider) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if( (*szwProvider = CopyWideString(m_keyProvInfo.pwszProvName)) == NULL )
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_ProviderNameWStr(
    /* [in] */ LPWSTR szwProvider) {
    HRESULT hr = S_OK;
    
    if(szwProvider == NULL)
        return(MY_HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
        
    EnterCriticalSection(&m_csXEnroll);
        
    if(m_hProv != NULL)
        hr = E_ACCESSDENIED;
    else {
        if (0 != wcscmp(m_keyProvInfo.pwszProvName, szwProvider))
        {
            if( m_keyProvInfo.pwszProvName != wszEmpty )
                MyCoTaskMemFree(m_keyProvInfo.pwszProvName);
            if( (m_keyProvInfo.pwszProvName = CopyWideString(szwProvider)) == NULL )
                hr = MY_HRESULT_FROM_WIN32(GetLastError());

            //one last thing, free/null cached prov handle
            if (NULL != m_hVerifyProv)
            {
                CryptReleaseContext(m_hVerifyProv, 0);
                m_hVerifyProv = NULL;
            }
            // csp is changed, reset key size cache
            m_dwXhgKeyLenMax = 0;
            m_dwXhgKeyLenMin = 0;
            m_dwXhgKeyLenDef = 0;
            m_dwXhgKeyLenInc = 0;
            m_dwSigKeyLenMax = 0;
            m_dwSigKeyLenMin = 0;
            m_dwSigKeyLenDef = 0;
            m_dwSigKeyLenInc = 0;
        }
    }
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

//
// Other Stuff
//

HRESULT STDMETHODCALLTYPE CCEnroll::get_UseExistingKeySet(
    /* [retval][out] */ BOOL __RPC_FAR *fUseExistingKeys) {

    EnterCriticalSection(&m_csXEnroll);
    *fUseExistingKeys = m_fUseExistingKey;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_UseExistingKeySet(
    /* [in] */ BOOL fUseExistingKeys) {

    EnterCriticalSection(&m_csXEnroll);
    m_fUseExistingKey = fUseExistingKeys;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_GenKeyFlags(
    /* [retval][out] */ LONG __RPC_FAR * pdwFlags) {
    EnterCriticalSection(&m_csXEnroll);
    *pdwFlags = m_dwGenKeyFlags;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_GenKeyFlags(
    /* [in] */ LONG dwFlags) {
    EnterCriticalSection(&m_csXEnroll);
    m_dwGenKeyFlags = dwFlags;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_DeleteRequestCert(
    /* [retval][out] */ BOOL __RPC_FAR *fBool) {
    EnterCriticalSection(&m_csXEnroll);
    *fBool = m_fDeleteRequestCert;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_DeleteRequestCert(
    /* [in] */ BOOL fBool) {
    EnterCriticalSection(&m_csXEnroll);
    m_fDeleteRequestCert = fBool;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_WriteCertToCSP(
    /* [retval][out] */ BOOL __RPC_FAR *fBool) {
    EnterCriticalSection(&m_csXEnroll);
    *fBool = m_fWriteCertToCSP;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_WriteCertToCSP(
    /* [in] */ BOOL fBool) {
    EnterCriticalSection(&m_csXEnroll);
    m_fWriteCertToCSP = fBool;
    m_fWriteCertToCSPModified = TRUE;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_WriteCertToUserDS(
    /* [retval][out] */ BOOL __RPC_FAR *fBool) {

    EnterCriticalSection(&m_csXEnroll);
    *fBool = m_fWriteCertToUserDS;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

//--------------------------------------------------------------------------------
//
// THIS METHOD IS NOT SAFE FOR SCRIPTING
//
//--------------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CCEnroll::put_WriteCertToUserDS(
    /* [in] */ BOOL fBool) {
    if (0 != m_dwEnabledSafteyOptions) // not safe for scripting
	return E_ACCESSDENIED;

    EnterCriticalSection(&m_csXEnroll);
    m_fWriteCertToUserDS = fBool;
    m_fWriteCertToUserDSModified = TRUE;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_EnableT61DNEncoding(
    /* [retval][out] */ BOOL __RPC_FAR *fBool) {
    EnterCriticalSection(&m_csXEnroll);
    *fBool = (m_dwT61DNEncoding == CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG);
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_EnableT61DNEncoding(
    /* [in] */ BOOL fBool) {

    EnterCriticalSection(&m_csXEnroll);
    if(fBool)
        m_dwT61DNEncoding = CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG;
    else
        m_dwT61DNEncoding = 0;
        
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_SPCFileName(
    /* [retval][out] */ BSTR __RPC_FAR *pbstr) {

    HRESULT hr = S_OK;

    EnterCriticalSection(&m_csXEnroll);
    if( (*pbstr = SysAllocString(m_wszSPCFileName)) == NULL )
        hr = E_OUTOFMEMORY;
        
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_SPCFileName(
    /* [in] */ BSTR bstr) {
    return(put_SPCFileNameWStr(bstr));
}


HRESULT STDMETHODCALLTYPE CCEnroll::get_PVKFileName(
    /* [retval][out] */ BSTR __RPC_FAR *pbstr) {

    HRESULT hr = S_OK;

    EnterCriticalSection(&m_csXEnroll);
    if( (*pbstr = SysAllocString(m_wszPVKFileName)) == NULL )
        hr = E_OUTOFMEMORY;
    LeaveCriticalSection(&m_csXEnroll);
    
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_PVKFileName(
    /* [in] */ BSTR bstr) {
    return(put_PVKFileNameWStr(bstr));
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_HashAlgorithm(
    /* [retval][out] */ BSTR __RPC_FAR *pbstr) {

    LPWSTR  wszAlg  = NULL;
    HRESULT hr      = S_OK;

    assert(pbstr != NULL);
    *pbstr          = NULL;

    if( (hr = get_HashAlgorithmWStr(&wszAlg)) == S_OK ) {

        if( (*pbstr = SysAllocString(wszAlg)) == NULL )
            hr = E_OUTOFMEMORY;
    }

    if(wszAlg != NULL)
        MyCoTaskMemFree(wszAlg);

    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_HashAlgorithm(
    /* [in] */ BSTR bstr) {
    return(put_HashAlgorithmWStr(bstr));
}

HRESULT STDMETHODCALLTYPE CCEnroll::enumContainers(
            /* [in] */ LONG                     dwIndex,
            /* [out][retval] */ BSTR __RPC_FAR *pbstr) {

    LPWSTR      pwsz        = NULL;
    HRESULT     hr;

    assert(pbstr != NULL);

    if((hr = enumContainersWStr(dwIndex, &pwsz)) != S_OK)
        goto EnumContainerError;

    if( (*pbstr = SysAllocString(pwsz)) == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto ErrorSysAllocString;
    }

    hr = S_OK;
ErrorReturn:
    if(pwsz != NULL)
        MyCoTaskMemFree(pwsz);
    return(hr);

TRACE_ERROR(EnumContainerError);
TRACE_ERROR(ErrorSysAllocString);
}


HRESULT STDMETHODCALLTYPE CCEnroll::enumProviders(
            /* [in] */ LONG  dwIndex,
            /* [in] */ LONG  dwFlags,
            /* [out][retval] */ BSTR __RPC_FAR *pbstrProvName) {
    HRESULT hr;
    LPWSTR pwszProvName  = NULL;

    assert(pbstrProvName != NULL);
    *pbstrProvName = NULL;

    if( (hr = enumProvidersWStr(dwIndex, dwFlags, &pwszProvName)) != S_OK)
        goto EnumProvidersError;

    if( (*pbstrProvName = SysAllocString(pwszProvName)) == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto ErrorSysAllocString;
    }

    hr = S_OK;
ErrorReturn:

    if(pwszProvName != NULL)
        MyCoTaskMemFree(pwszProvName);

    return(hr);

TRACE_ERROR(EnumProvidersError);
TRACE_ERROR(ErrorSysAllocString);
}

HRESULT STDMETHODCALLTYPE CCEnroll::createFilePKCS10WStr(
    /* [in] */ LPCWSTR DNName,
    /* [in] */ LPCWSTR Usage,
    /* [in] */ LPCWSTR wszPKCS10FileName) {

    HRESULT     hr;                     
    BSTR        bstrPKCS10  = NULL;

    // get the pkcs 10
    if( (hr = createPKCS10WStrBStr(
            DNName,
            Usage,
            &bstrPKCS10)) != S_OK)
    {
        goto ErrorCreatePKCS10;
    }

    // save it to file
    hr = BStringToFile(bstrPKCS10, wszPKCS10FileName);
    if (S_OK != hr)
    {
        goto ErrorBStringToFile;
    }

    hr = S_OK;
ErrorReturn:
    if(bstrPKCS10 != NULL)
        SysFreeString(bstrPKCS10);

    return(hr);


TRACE_ERROR(ErrorBStringToFile);
TRACE_ERROR(ErrorCreatePKCS10);
}

HRESULT STDMETHODCALLTYPE CCEnroll::acceptFilePKCS7WStr(
    /* [in] */ LPCWSTR wszPKCS7FileName)
{
    HRESULT     hr;
    CRYPT_DATA_BLOB  blob;

    ZeroMemory(&blob, sizeof(blob));

    hr = xeStringToBinaryFromFile(
                wszPKCS7FileName,
                &blob.pbData,
                &blob.cbData,
                CRYPT_STRING_ANY);
    if (S_OK != hr)
    {
        goto xeStringToBinaryFromFileError;
    }

    // accept the blob
    hr = acceptPKCS7Blob(&blob);

ErrorReturn:
    if (NULL != blob.pbData)
    {
        MyCoTaskMemFree(blob.pbData);
    }
    return(hr);

TRACE_ERROR(xeStringToBinaryFromFileError)
}

BOOL GetAlgAndBitLen(
    HCRYPTPROV hProv,
    ALG_ID *    pAlg,
    DWORD  *    pdwBitLen,
    DWORD       dwFlags)
{
    static BOOL fNew = TRUE;
    PROV_ENUMALGS_EX    enumAlgsEx;
    PROV_ENUMALGS       enumAlgs;
    DWORD               cb = 0;

    *pAlg = 0;
    *pdwBitLen = 0;

    if(fNew) {

        cb = sizeof(enumAlgsEx);
        if(CryptGetProvParam(
            hProv,
            PP_ENUMALGS_EX,
            (BYTE *) &enumAlgsEx,
            &cb,
            dwFlags)) {

            *pAlg       = enumAlgsEx.aiAlgid;
            *pdwBitLen  = enumAlgsEx.dwMaxLen;

            return(TRUE);        

        } else if(dwFlags != 0)
            fNew = FALSE;
        else
            return(FALSE);
    }

    // otherwise do the old stuff
    cb = sizeof(PROV_ENUMALGS);
    if(CryptGetProvParam(
        hProv,
            PP_ENUMALGS,
        (BYTE *) &enumAlgs,
        &cb,
        dwFlags) ) {

        *pAlg       = enumAlgs.aiAlgid;
        *pdwBitLen  = enumAlgs.dwBitLen;

        return(TRUE);

    }

    return(FALSE);
}    

HRESULT
CreateSMimeExtension(
    IN  HCRYPTPROV   hProv, 
    OUT BYTE       **ppbSMime,
    OUT DWORD       *pcbSMime)
{
#define                     CINCSMIMECAP    20
    HRESULT  hr;

    DWORD                      dwBitLen;
    DWORD                      i;
    DWORD                      cbE;
    BYTE                      *pbE = NULL;
    DWORD                      dwFlags;
    PCCRYPT_OID_INFO           pOidInfo = NULL;
    CRYPT_SMIME_CAPABILITIES   smimeCaps;
    DWORD                      crgsmimeCap = 0;
    ALG_ID                     AlgID;
    BYTE                      *pb = NULL;
    DWORD                      cb = 0;

    memset(&smimeCaps, 0, sizeof(CRYPT_SMIME_CAPABILITIES));

    smimeCaps.rgCapability = (PCRYPT_SMIME_CAPABILITY) LocalAlloc(LPTR, CINCSMIMECAP * sizeof(CRYPT_SMIME_CAPABILITY));
    if (NULL == smimeCaps.rgCapability)
    {
        hr = E_OUTOFMEMORY;
        goto OutOfMemoryError;
    }
    crgsmimeCap = CINCSMIMECAP;

    dwFlags = CRYPT_FIRST; //first item
    while (GetAlgAndBitLen(hProv, &AlgID, &dwBitLen, dwFlags))
    {
        pbE = NULL;
        cbE = 0;
        dwFlags = 0; //next item

        if(ALG_CLASS_DATA_ENCRYPT == GET_ALG_CLASS(AlgID))
        {
            if(AlgID == CALG_RC2  || AlgID == CALG_RC4)
            {
                // encode the usage
                while (TRUE)
                {
                    if(!CryptEncodeObject(
                            CRYPT_ASN_ENCODING,
                            X509_INTEGER,
                            &dwBitLen,
                            pbE,           // pbEncoded
                            &cbE))
                    {
                        hr = MY_HRESULT_FROM_WIN32(GetLastError());
                        goto CryptEncodeObjectError;
                    }
                    if (NULL != pbE)
                    {
                        break;
                    }
                    pbE = (BYTE *)LocalAlloc(LPTR, cbE);
                    if (NULL == pbE)
                    {
                        hr = E_OUTOFMEMORY;
                        goto OutOfMemoryError;
                    }
                }
            }
        } else {
            continue;
        }
        // convert to an oid,
        pOidInfo = xeCryptFindOIDInfo(
                        CRYPT_OID_INFO_ALGID_KEY,
                        (void *) &AlgID,
                        CRYPT_ENCRYPT_ALG_OID_GROUP_ID);
        if(NULL == pOidInfo)
        {
            // don't crash on an error, just say we don't known it.
	    if (NULL != pbE) { 
		LocalFree(pbE); 
	    }
	    pbE = NULL; 
            continue;
        }
      
        // make sure we have enough room
        if(smimeCaps.cCapability >= crgsmimeCap)
        {
	    PCRYPT_SMIME_CAPABILITY pSmimeCapsTmp; 

            //increment the size
            crgsmimeCap += CINCSMIMECAP;
	    pSmimeCapsTmp = (PCRYPT_SMIME_CAPABILITY)LocalReAlloc(
                                smimeCaps.rgCapability,
                                crgsmimeCap * sizeof(CRYPT_SMIME_CAPABILITY),
                                LMEM_MOVEABLE | LMEM_ZEROINIT);
            if(NULL == pSmimeCapsTmp)
            {
                hr = E_OUTOFMEMORY;
                goto OutOfMemoryError;
            }
	    smimeCaps.rgCapability = pSmimeCapsTmp; 
        }

        smimeCaps.rgCapability[smimeCaps.cCapability].pszObjId = (char *) pOidInfo->pszOID;
        smimeCaps.rgCapability[smimeCaps.cCapability].Parameters.pbData = pbE;
        smimeCaps.rgCapability[smimeCaps.cCapability].Parameters.cbData = cbE;
        smimeCaps.cCapability++;
	pbE = NULL;  // We'll free pbE through the struct we just assigned.  NULL out so we don't double-free. 
    }

    // encode the capabilities
    while (TRUE)
    {
        if (!CryptEncodeObject(
                        CRYPT_ASN_ENCODING,
                        PKCS_SMIME_CAPABILITIES,
                        &smimeCaps,
                        pb,
                        &cb)) 
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto CryptEncodeObjectError;
        }
        if (NULL != pb)
        {
            break;
        }
        pb = (BYTE *)LocalAlloc(LPTR, cb);
    }
    *ppbSMime = pb;
    *pcbSMime = cb;
    pb = NULL;

    hr = S_OK;

ErrorReturn:
    if(NULL != smimeCaps.rgCapability)
    {
        for (i = 0; i < smimeCaps.cCapability; ++i)
        {
            if (NULL != smimeCaps.rgCapability[i].Parameters.pbData)
            {
                LocalFree(smimeCaps.rgCapability[i].Parameters.pbData);
            }
        }
        LocalFree(smimeCaps.rgCapability);
    }
    if(NULL != pb)
    {
        LocalFree(pb);
    }
    if (NULL != pbE) 
    { 
	LocalFree(pbE); 
    }
    return hr;

TRACE_ERROR(CryptEncodeObjectError)
TRACE_ERROR(OutOfMemoryError)
}


#if DBG
void DebugGetContainerSD(HCRYPTPROV hProv)
{
    PSECURITY_DESCRIPTOR  pSD = NULL;
    DWORD                 cbSD;

    while (TRUE)
    {
        if (!CryptGetProvParam(
                hProv,
                PP_KEYSET_SEC_DESCR,
                (BYTE*)pSD,
                &cbSD,
                DACL_SECURITY_INFORMATION))
        {
            break;
        }
        if (NULL != pSD)
        {
            break;
        }
        pSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, cbSD);
        if (NULL == pSD)
        {
            break;
        }
    }
    if (NULL != pSD)
    {
	LocalFree(pSD);
    }
}
#endif //DBG

//get the current user sids
HRESULT
GetCurrentUserInfo(
    OUT PTOKEN_USER *ppUserInfo,
    OUT BOOL        *pfAdmin)
{
    HRESULT  hr;
    PTOKEN_USER   pUserInfo = NULL;
    DWORD         dwSize = 0;
    HANDLE        hToken = NULL;
    HANDLE        hDupToken = NULL;
    PSID          psidAdministrators = NULL;
    SID_IDENTIFIER_AUTHORITY    siaNtAuthority = SECURITY_NT_AUTHORITY;
    HANDLE hThread;
    HANDLE hProcess;

    //init
    *pfAdmin = FALSE;

    if (!AllocateAndInitializeSid(
                            &siaNtAuthority,
                            2,
                            SECURITY_BUILTIN_DOMAIN_RID,
                            DOMAIN_ALIAS_RID_ADMINS,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            &psidAdministrators))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto AllocateAndInitializeSidError;
    }

    hThread = GetCurrentThread();
    if (NULL == hThread)
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto GetCurrentThreadError;
    }

    // Get the access token for current thread
    if (!OpenThreadToken(
            hThread, 
            TOKEN_QUERY | TOKEN_DUPLICATE, 
            FALSE,
            &hToken))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        if(HRESULT_FROM_WIN32(ERROR_NO_TOKEN) != hr)
        {
            goto OpenThreadTokenError;
        }
        //get process token instead
        hProcess = GetCurrentProcess();
        if (NULL == hProcess)
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto GetCurrentProcessError;
        }

        hToken = NULL;
        if (!OpenProcessToken(hProcess, TOKEN_QUERY | TOKEN_DUPLICATE, &hToken))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto OpenProcessTokenError;
        }
    }

    // CheckTokenMembership must operate on impersonation token, so make one
    if (!DuplicateToken(hToken, SecurityIdentification, &hDupToken))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto DuplicateTokenError;
    }

    if (!MyCheckTokenMembership(hDupToken, psidAdministrators, pfAdmin))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto CheckTokenMembershipError;
    }

    //get current user sid
    while (TRUE)
    {
        if (!GetTokenInformation(
                hToken,
                TokenUser,
                pUserInfo,
                dwSize,
                &dwSize))
        {
            if (NULL != pUserInfo ||
                ERROR_INSUFFICIENT_BUFFER != GetLastError())
            {
                hr = MY_HRESULT_FROM_WIN32(GetLastError());
                goto GetTokenInformationError;
            }
        }

        if (NULL != pUserInfo)
        {
            //done
            break;
        }
        pUserInfo = (PTOKEN_USER)LocalAlloc(LMEM_FIXED, dwSize);
        if (NULL == pUserInfo)
        {
            hr = E_OUTOFMEMORY;
            goto LocalAllocError;
        }
    }

    if (NULL != ppUserInfo)
    {
        *ppUserInfo = pUserInfo;
        pUserInfo = NULL;
    }

    hr = S_OK;
ErrorReturn:
    if (NULL != pUserInfo)
    {
        LocalFree(pUserInfo);
    }
    if (NULL != hToken)
    {
        CloseHandle(hToken);
    }
    if (NULL != hDupToken)
    {
        CloseHandle(hDupToken);
    }
    if (NULL != psidAdministrators)
    {
        FreeSid(psidAdministrators);
    }

    return hr;

TRACE_ERROR(LocalAllocError)
TRACE_ERROR(GetTokenInformationError)
TRACE_ERROR(OpenProcessTokenError)
TRACE_ERROR(GetCurrentProcessError)
TRACE_ERROR(CheckTokenMembershipError)
TRACE_ERROR(DuplicateTokenError)
TRACE_ERROR(OpenThreadTokenError)
TRACE_ERROR(GetCurrentThreadError)
TRACE_ERROR(AllocateAndInitializeSidError)
}


HRESULT
SetKeyContainerSecurityForNULLDacl(
    HCRYPTPROV   hProv,
    DWORD        dwFlags, 
    PTOKEN_USER  pUserInfo)
{
    DWORD                 ccNeeded; 
    HRESULT               hr;
    LPWSTR                wszSD       = NULL; 
    LPWSTR                wszUserSid  = NULL;
    PSECURITY_DESCRIPTOR  pSD         = NULL;

    UNREFERENCED_PARAMETER(dwFlags);

    // We want the security descriptor for the new keyset to look like so:
    //
    // ACES: 
    // NT AUTHORITY\SYSTEM:F
    // BUILTIN\Administrators:F
    // 
    // 
#define SDDL_NEW_KEYSET_START L"D:(A;;GA;;;SY)(A;;GA;;;BA)(A;;GA;;;"
#define SDDL_NEW_KEYSET_END   L")"

    if (!ConvertSidToStringSidW(pUserInfo->User.Sid, &wszUserSid)) { 
	goto ConvertSidToStringSidError; 
    }
	
    ccNeeded = (DWORD)(wcslen(SDDL_NEW_KEYSET_START) + wcslen(wszUserSid) + wcslen(SDDL_NEW_KEYSET_END) + 1); 
    wszSD = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*ccNeeded);
    if (NULL == wszSD) { 
	goto MemoryError;
    }
    
    wcscpy(wszSD, SDDL_NEW_KEYSET_START); 
    wcscat(wszSD, wszUserSid);
    wcscat(wszSD, SDDL_NEW_KEYSET_END); 
    

    if (!ConvertStringSecurityDescriptorToSecurityDescriptorW(wszSD, SDDL_REVISION_1, &pSD, NULL)) { 
	goto ConvertStringSecurityDescriptorToSecurityDescriptorWError; 
    }

    if (!IsValidSecurityDescriptor(pSD)) { 
	goto IsValidSecurityDescriptorError;
    }

#if DBG
    DebugGetContainerSD(hProv); //just for ntsd debug
#endif

    if (!CryptSetProvParam(hProv, PP_KEYSET_SEC_DESCR, (BYTE*)pSD, DACL_SECURITY_INFORMATION)) { 
        goto CryptSetProvParamError;
    }

#if DBG
    DebugGetContainerSD(hProv); //just for ntsd debug
#endif

    hr = S_OK;
ErrorReturn:
    if (NULL != wszSD)
    {
	LocalFree(wszSD);
    }
    if (NULL != wszUserSid)
    {
	LocalFree(wszUserSid); 
    }
    if (NULL != pSD)
    {
        LocalFree(pSD);
    }
    return hr;


SET_HRESULT(ConvertSidToStringSidError,                                 HRESULT_FROM_WIN32(GetLastError())); 
SET_HRESULT(ConvertStringSecurityDescriptorToSecurityDescriptorWError,  HRESULT_FROM_WIN32(GetLastError())); 
SET_HRESULT(CryptSetProvParamError,                                     HRESULT_FROM_WIN32(GetLastError())); 
SET_HRESULT(IsValidSecurityDescriptorError,                             HRESULT_FROM_WIN32(ERROR_INVALID_SECURITY_DESCR)); 
SET_HRESULT(MemoryError,                                                E_OUTOFMEMORY); 
}


// This function ACLs new keysets (as 3rd party CSPs and downlevel CSPs may not do this correctly.  
// Should *not* call this function on existing keysets (as ACLs may have been set differently by admins)
// 
HRESULT
SetKeyContainerSecurity(
    HCRYPTPROV hProv,
    DWORD      dwFlags)
{
    HRESULT               hr;
    PSECURITY_DESCRIPTOR  pNewSD = NULL;
    PSECURITY_DESCRIPTOR  pSD = NULL;

    DWORD                 cbSD;
    ACL_SIZE_INFORMATION  AclInfo;

    PTOKEN_USER           pUserInfo = NULL;
    PACL                  pNewAcl = NULL;
    LPVOID pAce;
    DWORD  dwIndex;
    BYTE   AceType;
    PACL   pAcl;
    BOOL   fDacl = TRUE;
    BOOL   fDef = FALSE;
    BOOL   fAdmin;
    BOOL   fKeepSystemSid;
    BOOL   fMachineKeySet = (0x0 != (dwFlags & CRYPT_MACHINE_KEYSET)) ?
                            TRUE : FALSE;

    PSID                      pSidSystem = NULL;
    PSID                      pSidAdministrators = NULL; 
    SID_IDENTIFIER_AUTHORITY  siaNtAuthority = SECURITY_NT_AUTHORITY;

    //get the current user info
    hr = GetCurrentUserInfo(&pUserInfo, &fAdmin);
    if (S_OK != hr)
    {
        goto GetCurrentUserInfoError;
    }

    //get the current sd from key container
    while (TRUE)
    {
        if (!CryptGetProvParam(
                hProv,
                PP_KEYSET_SEC_DESCR,
                (BYTE*)pSD,
                &cbSD,
                DACL_SECURITY_INFORMATION))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto CryptGetProvParamError;
        }
        if (NULL != pSD)
        {
            break;
        }
        pSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, cbSD);
        if (NULL == pSD)
        {
            hr = E_OUTOFMEMORY;
            goto OutOfMemoryError;
        }
    }

    //get acl from sd
    if (!GetSecurityDescriptorDacl(
            pSD,
            &fDacl,
            &pAcl,
            &fDef))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto GetSecurityDescriptorDaclError;
    }
    if (!fDacl)
    {
        //if no dacl, quit
        hr = MY_HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto GetSecurityDescriptorDaclError;
    }
    if (NULL == pAcl)
    {
#if 0
        //this means allow everyone access the key which is unexpected,
	hr = SetKeyContainerSecurityForNULLDacl(hProv, dwFlags, pUserInfo); 
#endif
	// BUGBUG: The NULL DACL stuff doesn't work on downlevels because it requires SDDL.  We don't
	// have time to fix for windows update, but we should revisit this later
	hr = S_OK; 
	goto done; 
    }

    //get acl info
    if (!GetAclInformation(
            pAcl,
            &AclInfo,
            sizeof(AclInfo),
            AclSizeInformation))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto GetAclInformationError;
    }

    //allocate enough for new dacl since we just remove aces
    pNewAcl = (PACL)LocalAlloc(LMEM_ZEROINIT, AclInfo.AclBytesInUse);
    if (NULL == pNewAcl)
    {
        hr = E_OUTOFMEMORY;
        goto LocalAllocError;
    }
    if (!InitializeAcl(pNewAcl, AclInfo.AclBytesInUse, ACL_REVISION))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto InitializeAclError;
    }

    fKeepSystemSid = fAdmin && fMachineKeySet;
    if (fKeepSystemSid)
    {
        //get system sid to later use
        if (!AllocateAndInitializeSid(
                            &siaNtAuthority,
                            1,
                            SECURITY_LOCAL_SYSTEM_RID,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            &pSidSystem))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto AllocateAndInitializeSidError;
        }
    }

    if (!AllocateAndInitializeSid(&siaNtAuthority,
				  2,
				  SECURITY_BUILTIN_DOMAIN_RID,
				  DOMAIN_ALIAS_RID_ADMINS,
				  0, 0, 0, 0, 0, 0,
				  &pSidAdministrators
				  ))
    {
	hr = MY_HRESULT_FROM_WIN32(GetLastError());
	goto AllocateAndInitializeSidError;
    }
	
    //go through each ace, get only current user aces
    for (dwIndex = 0; dwIndex < AclInfo.AceCount; ++dwIndex)
    {
        if (!GetAce(pAcl, dwIndex, &pAce))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto GetAceError;
        }
        AceType = ((ACCESS_ALLOWED_ACE*)pAce)->Header.AceType;
        if (ACCESS_ALLOWED_ACE_TYPE == AceType)
        {
            if (EqualSid(pUserInfo->User.Sid, (PSID)&(((PACCESS_ALLOWED_ACE)pAce)->SidStart)) 
		|| (fKeepSystemSid && EqualSid(pSidSystem, (PSID)&(((PACCESS_ALLOWED_ACE)pAce)->SidStart)))
		|| EqualSid(pSidAdministrators, (PSID)&(((PACCESS_ALLOWED_ACE)pAce)->SidStart)))
            {
                //add current user ace or system ace into new acl
                if (!AddAccessAllowedAce(
                        pNewAcl,
                        ACL_REVISION,
                        ((PACCESS_ALLOWED_ACE)pAce)->Mask,
                        (PSID)&(((PACCESS_ALLOWED_ACE)pAce)->SidStart)))
                {
                    hr = MY_HRESULT_FROM_WIN32(GetLastError());
                    goto AddAccessAllowedAceError;
                }
            }
        }
        else if (ACCESS_DENIED_ACE_TYPE == AceType)
        {
            //add all deny ace into new acl
            if (!AddAccessDeniedAce(
                    pNewAcl,
                    ACL_REVISION,
                    ((PACCESS_ALLOWED_ACE)pAce)->Mask,
                    (PSID)&(((PACCESS_DENIED_ACE)pAce)->SidStart)))
            {
                hr = MY_HRESULT_FROM_WIN32(GetLastError());
                goto AddAccessDeniedAceError;
            }
        }
    }

    // initialize a security descriptor.  
    pNewSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, 
                         SECURITY_DESCRIPTOR_MIN_LENGTH); 
    if (pNewSD == NULL)
    { 
        hr = E_OUTOFMEMORY;
        goto LocalAllocError;
    } 
 
    if (!InitializeSecurityDescriptor(pNewSD, SECURITY_DESCRIPTOR_REVISION))
    {  
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto InitializeSecurityDescriptorError;
    } 
 
    // add the ACL to the security descriptor. 
    if (!SetSecurityDescriptorDacl(
            pNewSD, 
            TRUE,     // fDaclPresent flag   
            pNewAcl, 
            FALSE))   // not a default DACL 
    {  
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto SetSecurityDescriptorDaclError;
    } 

    //ok, set sd to be protected
    if (!MySetSecurityDescriptorControl(
            pNewSD,
            SE_DACL_PROTECTED,
            SE_DACL_PROTECTED))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto SetSecurityDescriptorControlError;
    }

    if (!IsValidSecurityDescriptor(pNewSD))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
	goto IsValidSecurityDescriptorError;
    }

#if DBG
    DebugGetContainerSD(hProv); //just for ntsd debug
#endif

    //now we just set it
    if (!CryptSetProvParam(
            hProv,
            PP_KEYSET_SEC_DESCR,
            (BYTE*)pNewSD,
            DACL_SECURITY_INFORMATION))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto CryptSetProvParamError;
    }

#if DBG
    DebugGetContainerSD(hProv); //just for ntsd debug
#endif

done:
    hr = S_OK;
ErrorReturn:
    if (NULL != pSD)
    {
        LocalFree(pSD);
    }
    if (NULL != pUserInfo) 
    {
        LocalFree(pUserInfo);
    }
    if (NULL != pNewAcl) 
    {
        LocalFree(pNewAcl);
    }
    if (NULL != pNewSD) 
    {
        LocalFree(pNewSD);
    }
    if (NULL != pSidSystem)
    {
        FreeSid(pSidSystem);
    }
    if (NULL != pSidAdministrators)
    {
	FreeSid(pSidAdministrators);
    }
    return hr;

TRACE_ERROR(CryptSetProvParamError)
TRACE_ERROR(SetSecurityDescriptorDaclError)
TRACE_ERROR(InitializeSecurityDescriptorError)
TRACE_ERROR(LocalAllocError)
TRACE_ERROR(AddAccessAllowedAceError)
TRACE_ERROR(AddAccessDeniedAceError)
TRACE_ERROR(GetAceError)
TRACE_ERROR(GetCurrentUserInfoError)
TRACE_ERROR(InitializeAclError)
TRACE_ERROR(GetAclInformationError)
TRACE_ERROR(GetSecurityDescriptorDaclError)
TRACE_ERROR(OutOfMemoryError)
TRACE_ERROR(CryptGetProvParamError)
TRACE_ERROR(SetSecurityDescriptorControlError)
TRACE_ERROR(IsValidSecurityDescriptorError)
TRACE_ERROR(AllocateAndInitializeSidError)
}

HRESULT STDMETHODCALLTYPE CCEnroll::createPKCS10WStr(
    /* [in] */ LPCWSTR DNName,
    /* [in] */ LPCWSTR wszPurpose,
    /* [out] */ PCRYPT_DATA_BLOB pPkcs10Blob)
{
    #define EndExt      5

    #define EndAttr     6

    HCRYPTPROV                  hProv           = NULL;
    HCRYPTKEY                   hKey            = NULL;

    CERT_REQUEST_INFO           reqInfo;

    CERT_EXTENSIONS             Extensions;
    PCERT_EXTENSION             pExtCur         = NULL;
    PCERT_EXTENSION             rgExtension     = NULL;
    CRYPT_ATTRIBUTE             rgAttribute[EndAttr];
    CRYPT_ATTR_BLOB             blobExt;
    CRYPT_ATTR_BLOB             blobCSPAttr;
    CRYPT_CSP_PROVIDER          CSPProvider;
    CRYPT_ATTR_BLOB             blobOSVAttr;
    CRYPT_ATTR_BLOB             blobSMIMEPKCS7;
    CERT_NAME_VALUE             cnvOSVer;
    OSVERSIONINFO               osvInfo;

    DWORD                       iExt            = 0;
    CRYPT_BIT_BLOB              bbKeyUsage;
    BYTE                        bKeyUsage;

    CERT_SIGNED_CONTENT_INFO    SignatureInfo;

    HRESULT                     hr              = S_OK;
    DWORD                       errBefore       = GetLastError();

    PCCERT_CONTEXT              pCertContext    = NULL;
    HCERTSTORE                  hStore          = NULL;
    DWORD                       ssFlags         = 0;

    HANDLE                      hFile           = NULL;
    CRYPT_DATA_BLOB             blobData;

    DWORD                       cb              = 0;
    char *                      pszPurpose       = NULL;
    char *                      szStart         = NULL;
    char *                      szEnd           = NULL;
    char                        szVersion[45]   = {0};

    BOOL                        fAddCodeSign    = FALSE;
    DWORD                       cPassedEKU      = 0;
    DWORD                       i               = 0;
    BOOL                        fRet;
    BYTE                       *pbSMime = NULL;
    BYTE                       *pbKU = NULL;
    BYTE                       *pbEKU = NULL;
    PPROP_STACK                 pProp;
    CRYPT_ATTR_BLOB             blobClientId;
    DWORD                       cPublicKeyInfo = 0;
    BYTE                       *pbSubjectKeyHashExtension = NULL;
    DWORD                       cbSubjectKeyHashExtension = 0;
    DWORD                       dwErr;

    LPWSTR                      pwszNotSafeRequesting     = NULL; 
    LPWSTR                      pwszTitle                 = NULL; 

    //
    // Declaration of extensions we need.  The extensions with matching OIDs will be added
    // to the temporary cert context created by this method. 
    // 
    LPSTR rgszExtensionOIDs[] = { 
        szOID_ENROLL_CERTTYPE_EXTENSION,
        szOID_CERTIFICATE_TEMPLATE
    }; 

    // An array of the extensions we need to add to the certificate 
    CERT_EXTENSION  rgNeededExtensions[sizeof(rgszExtensionOIDs) / sizeof(LPSTR)]; 

    // Need to put the array in a CERT_EXTENSIONS struct. 
    CERT_EXTENSIONS ceExtensions; 
    ceExtensions.rgExtension = &rgNeededExtensions[0]; 
    ceExtensions.cExtension  = 0; 

    CRYPT_KEY_PROV_INFO         keyProvInfoT;
        CERT_ENHKEY_USAGE                   enhKeyUsage;

        CRYPT_DATA_BLOB             blobPKCS7;
        CRYPT_DATA_BLOB             blobRenewAttr;
        RequestFlags                requestFlags;
        CRYPT_DATA_BLOB             requestInfoBlob;
        CRYPT_DATA_BLOB             blobRenewalCert;

        ALG_ID                      rgAlg[2];
        PCCRYPT_OID_INFO            pOidInfo        = NULL;

    EnterCriticalSection(&m_csXEnroll);

    // for the life of our procedure.
    SetLastError(ERROR_SUCCESS);

    assert(pPkcs10Blob != NULL);

    // clean out the PKCS 10
    memset(&Extensions, 0, sizeof(CERT_EXTENSIONS));
    memset(&rgAttribute, 0, sizeof(rgAttribute));
    memset(&reqInfo, 0, sizeof(CERT_REQUEST_INFO));
    memset(&SignatureInfo, 0, sizeof(SignatureInfo));
    memset(&blobData, 0, sizeof(CRYPT_DATA_BLOB));
    memset(&enhKeyUsage, 0, sizeof(CERT_ENHKEY_USAGE ));
    memset(pPkcs10Blob, 0, sizeof(CRYPT_DATA_BLOB));
    memset(&blobPKCS7, 0, sizeof(CRYPT_DATA_BLOB));
    memset(&blobRenewAttr, 0, sizeof(CRYPT_DATA_BLOB));
    memset(&requestFlags, 0, sizeof(RequestFlags));
    memset(&requestInfoBlob, 0, sizeof(CRYPT_DATA_BLOB));
    memset(&CSPProvider, 0, sizeof(CRYPT_CSP_PROVIDER));
    memset(&cnvOSVer, 0, sizeof(CERT_NAME_VALUE));
    memset(&osvInfo, 0, sizeof(OSVERSIONINFO));
    memset(&blobSMIMEPKCS7, 0, sizeof(CRYPT_ATTR_BLOB));
    memset(&rgNeededExtensions[0], 0, sizeof(rgNeededExtensions)); 
    ZeroMemory(&blobExt, sizeof(blobExt));
    memset(&blobCSPAttr, 0, sizeof(CRYPT_ATTR_BLOB));
    memset(&blobOSVAttr, 0, sizeof(CRYPT_ATTR_BLOB));
    memset(&blobClientId, 0, sizeof(CRYPT_ATTR_BLOB));

    reqInfo.dwVersion = CERT_REQUEST_V1;

    // Creating a request is not safe for scripting:  pop up a warning dialog if called from script
    if (0 != m_dwEnabledSafteyOptions) { 
	hr = xeLoadRCString(hInstanceXEnroll, IDS_NOTSAFEACTION, &pwszTitle);
	if (S_OK != hr) { 
	    SetLastError(hr);
	    goto xeLoadRCStringError;
	}
	
	hr = xeLoadRCString(hInstanceXEnroll, IDS_NOTSAFE_REQUESTING_CERT, &pwszNotSafeRequesting);
	if (S_OK != hr) { 
	    SetLastError(hr);
	    goto xeLoadRCStringError;
	}
	
	if (IDYES != MessageBoxU(NULL, pwszNotSafeRequesting, pwszTitle, MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2)) { 
	    hr = HRESULT_FROM_WIN32(ERROR_CANCELLED); 
	    SetLastError(hr); 
	    goto CancelledError; 
	}
    }

    if(!m_fUseExistingKey)
    {
        // attempt to get a new keyset
        if((hProv = GetProv(CRYPT_NEWKEYSET)) == NULL) {

            // in the hardware token case, there may only be a finite number of containers
            // if you run out, then use the default container. The Default container can
            // be specified by either a NULL or empty container name.
            // this is behavior requested by the smart cards, in particular smart card enrollment.
            if( m_fReuseHardwareKeyIfUnableToGenNew &&
                GetLastError() == NTE_TOKEN_KEYSET_STORAGE_FULL) {

                    // set it to the default container name
                    if( m_keyProvInfo.pwszContainerName != wszEmpty )
                        MyCoTaskMemFree(m_keyProvInfo.pwszContainerName);
                    m_keyProvInfo.pwszContainerName = wszEmpty;

                    // say we want to use an exiting key.
                    m_fUseExistingKey = TRUE;
            }
            else
                goto ErrorCryptAcquireContext;
        }
    }

    // if we are to use an existing key
    if(m_fUseExistingKey) {

        if((hProv = GetProv(0)) == NULL)
            goto ErrorCryptAcquireContext;
    }

    // we have the keyset, now make sure we have the key gen'ed
    if(!CryptGetUserKey(
                hProv,
                m_keyProvInfo.dwKeySpec,
                &hKey))
    {
        //in case of smartcard csp, above call could be failed from
        //PIN Cancel button, don't go next to try genkey
        //also notice different csp could return different cancel errors
        dwErr = GetLastError();
        if (SCARD_W_CANCELLED_BY_USER == dwErr ||
            ERROR_CANCELLED == dwErr ||
            ERROR_ACCESS_DENIED == dwErr)
        {
            goto CryptGetUserKeyCancelError;
        }
            
        // doesn't exist so gen it
        assert(hKey == NULL);

	// if the cached key is non-NULL, free it to prevent memory leaks
	if (NULL != m_hCachedKey)
	{
	    CryptDestroyKey(m_hCachedKey); 
	    m_hCachedKey = NULL; 
	}

        if(!CryptGenKey(    hProv,
                            m_keyProvInfo.dwKeySpec,
                            m_dwGenKeyFlags | CRYPT_ARCHIVABLE,
                            &m_hCachedKey) )
        {
            //could be cancelled by user? don't make next try
            dwErr = GetLastError();
            if (SCARD_W_CANCELLED_BY_USER == dwErr ||
                ERROR_CANCELLED == dwErr ||
                ERROR_ACCESS_DENIED == dwErr)
            {
		goto ErrorCryptGenKey;
            }

            //this error may be caused by not supporting CRYPT_ARCHIVABLE
            //we should check against error NTE_BAD_FLAGS but I doubt all
            //csps return consistent error code
            //let's try one more time without archivable flag
            assert(NULL == m_hCachedKey);
            DWORD dwGenKeyFlags = m_dwGenKeyFlags;
            if (NULL != m_PrivateKeyArchiveCertificate && m_fNewRequestMethod && (0 == (dwGenKeyFlags & CRYPT_EXPORTABLE)))
            {
		// We want ARCHIVABLE but not EXPORTABLE, so we needed the CRYPT_ARCHIVAL bit.  Give up.  
		goto ErrorCryptGenKey;
            }

            if (!CryptGenKey(
                        hProv,
                        m_keyProvInfo.dwKeySpec,
                        dwGenKeyFlags,
                        &hKey))
            {
                goto ErrorCryptGenKey;
            }
	}

	//try to set key container ACL with owner ACE only (NOTE: only do this for creation!)
	hr = SetKeyContainerSecurity(hProv, m_keyProvInfo.dwFlags);
#if DBG
	if (S_OK != hr)
	{
	    goto SetKeyContainerSecurityError;
	}
#endif //DBG
	hr = S_OK; //free build, no error checking here, if fails, live with it
    }


    if (NULL != hKey)
    {
        // don't need the hKey on existing key, so get rid of it
        CryptDestroyKey(hKey);
    }
    if ((NULL == m_PrivateKeyArchiveCertificate || !m_fNewRequestMethod) &&
        NULL != m_hCachedKey)
    {
        //we don't need cache it, destroy it as soon as key is gen(ed)
        CryptDestroyKey(m_hCachedKey);
        m_hCachedKey = NULL;
    }

    // now get the public key out into m_pPublicKeyInfo
    // m_pPublicKeyInfo is internal use for cache
    if (NULL != m_pPublicKeyInfo)
    {
        LocalFree(m_pPublicKeyInfo);
        m_pPublicKeyInfo = NULL;
    }
    while (TRUE)
    {
        if(!CryptExportPublicKeyInfo(hProv,
                            m_keyProvInfo.dwKeySpec,
                            X509_ASN_ENCODING,
                            m_pPublicKeyInfo,
                            &cPublicKeyInfo))
        {
            goto ErrorCryptExportPublicKeyInfo;
        }
        if (NULL != m_pPublicKeyInfo)
        {
            break;
        }
        m_pPublicKeyInfo = (PCERT_PUBLIC_KEY_INFO)LocalAlloc(
                                LMEM_FIXED, cPublicKeyInfo);
        if (NULL == m_pPublicKeyInfo)
        {
            hr = E_OUTOFMEMORY;
            goto OutOfMemoryError;
        }
    }
    reqInfo.SubjectPublicKeyInfo = *m_pPublicKeyInfo;

    // get the Subject DN only if one is specified
    reqInfo.Subject.pbData = NULL;
    while (TRUE)
    {
        if( !MyCertStrToNameW(
                CRYPT_ASN_ENCODING,
                DNName,
                0 | m_dwT61DNEncoding,
                NULL,
                reqInfo.Subject.pbData,
                &reqInfo.Subject.cbData,
                NULL))
        {
            if (CRYPT_E_INVALID_X500_STRING == GetLastError() &&
                L'\0' == DNName[0])
            {
                //this is likely on W95, W98, or NT4 with some IEs
                //crypt32 doesn't support empty DN conversion
                //hard code here
                reqInfo.Subject.cbData = 2;
                reqInfo.Subject.pbData = (BYTE *)LocalAlloc(LMEM_FIXED,
                                                reqInfo.Subject.cbData);
                if (NULL == reqInfo.Subject.pbData)
                {        
                    hr = E_OUTOFMEMORY;
                    goto OutOfMemoryError;
                }
                reqInfo.Subject.pbData[0] = 0x30;
                reqInfo.Subject.pbData[1] = 0x0;
                //done
                break;
            }
            else
            {
               goto ErrorCertStrToNameW;
            }
        }
        if (NULL != reqInfo.Subject.pbData)
        {
            break;
        }
        reqInfo.Subject.pbData = (BYTE *)LocalAlloc(LMEM_FIXED,
                                            reqInfo.Subject.cbData);
        if (NULL == reqInfo.Subject.pbData)
        {
            hr = E_OUTOFMEMORY;
            goto OutOfMemoryError;
        }
    }

    // allocate room for the extensions
    cb = (CountStackExtension(m_fNewRequestMethod) + EndExt) * sizeof(CERT_EXTENSION);
    rgExtension = (PCERT_EXTENSION)LocalAlloc(LMEM_FIXED, cb);
    if (NULL == rgExtension)
    {
        hr = E_OUTOFMEMORY;
        goto OutOfMemoryError;
    }
    memset(rgExtension, 0, cb);
    cb = 0;

    if (!m_fUseClientKeyUsage)
    {
        // Make Key Usage
        rgExtension[iExt].pszObjId = szOID_KEY_USAGE;
        rgExtension[iExt].fCritical = TRUE;

        // AT_SIGNATURE
        if( m_keyProvInfo.dwKeySpec == AT_SIGNATURE)
            bKeyUsage =
                CERT_DIGITAL_SIGNATURE_KEY_USAGE |
                CERT_NON_REPUDIATION_KEY_USAGE;

        //AT_KEYEXCHANGE, limited for EMAIL single use
        // email may not work if signature is present
        else if(m_fLimitExchangeKeyToEncipherment)
	    bKeyUsage =
                CERT_KEY_ENCIPHERMENT_KEY_USAGE |
                CERT_DATA_ENCIPHERMENT_KEY_USAGE;

        // AT_KEYEXCHANGE and AT_SIGNATURE dual key 
        // This is the normal case for AT_KEYEXCHANGE since CAPI will sign with this.
        else 
            bKeyUsage =
                CERT_KEY_ENCIPHERMENT_KEY_USAGE     |
                CERT_DATA_ENCIPHERMENT_KEY_USAGE    |
                CERT_DIGITAL_SIGNATURE_KEY_USAGE    |
                CERT_NON_REPUDIATION_KEY_USAGE;

        bbKeyUsage.pbData = &bKeyUsage;
        bbKeyUsage.cbData = 1;
        bbKeyUsage.cUnusedBits = 1;

        // encode the usage
        rgExtension[iExt].Value.pbData = NULL;
        while (TRUE)
        {
            if(!CryptEncodeObject(
                    CRYPT_ASN_ENCODING,
                    X509_KEY_USAGE,
                    &bbKeyUsage,
                    pbKU,
                    &rgExtension[iExt].Value.cbData))
            {
                goto ErrorEncodeKeyUsage;
            }
            if (NULL != pbKU)
            {
                rgExtension[iExt].Value.pbData = pbKU;
                //done
                break;
            }
            pbKU = (BYTE *)LocalAlloc(LMEM_FIXED, rgExtension[iExt].Value.cbData);
            if (NULL == pbKU)
            {
                hr = E_OUTOFMEMORY;
                goto OutOfMemoryError;
            }
        }
        iExt++;
    }

    if(m_fEnableSMIMECapabilities)
    {
        // add SMIME extension for symmetric algorithms
        rgExtension[iExt].pszObjId = szOID_RSA_SMIMECapabilities;
        rgExtension[iExt].fCritical = FALSE;
        hr = CreateSMimeExtension(
                    hProv,
                    &pbSMime,
                    &rgExtension[iExt].Value.cbData);
        if (S_OK != hr)
        {
            goto CreateSMimeExtensionError;
        }
        rgExtension[iExt].Value.pbData = pbSMime;
        iExt++;
    }

    if (m_fHonorIncludeSubjectKeyID && m_fIncludeSubjectKeyID)
    {
        hr = myCreateSubjectKeyIdentifierExtension(
                    m_pPublicKeyInfo,
                    &pbSubjectKeyHashExtension,
                    &cbSubjectKeyHashExtension);
        if (S_OK != hr)
        {
            goto myCreateSubjectKeyIdentifierExtensionError;
        }
        //add subject key ID hash extension into PKCS10
        rgExtension[iExt].pszObjId = szOID_SUBJECT_KEY_IDENTIFIER;
        rgExtension[iExt].fCritical = FALSE;
        rgExtension[iExt].Value.pbData = pbSubjectKeyHashExtension;
        rgExtension[iExt].Value.cbData = cbSubjectKeyHashExtension;
        iExt++;
    }

    if(wszPurpose != NULL) {
        cb = 0;
        while (TRUE)
	{
            if(0 == (cb = WideCharToMultiByte(
                            0, 0, wszPurpose, -1, pszPurpose, cb, NULL, NULL)))
            {
                SetLastError(ERROR_OUTOFMEMORY);
                goto ErrorCantConvertPurpose;
            }
            if (NULL != pszPurpose)
            {
                break;
            }
            pszPurpose = (CHAR*)LocalAlloc(LMEM_FIXED, cb);
            if (NULL == pszPurpose)
            {
                hr = E_OUTOFMEMORY;
                goto OutOfMemoryError;
            }
        }
        szStart = pszPurpose;

        // remove leading blanks
        while(*szStart == ',' || *szStart == ' ')
            *szStart++ = '\0';

        while( szStart[0] != '\0' ) {

            // find the next string
            szEnd = szStart;
            while(*szEnd != ',' && *szEnd != ' ' && *szEnd != '\0')
                szEnd++;

            // remove trailing blanks
            while(*szEnd == ',' || *szEnd == ' ')
                *szEnd++ = '\0';

            enhKeyUsage.cUsageIdentifier++;

            // see if this implies codesigning
            fAddCodeSign |= !strcmp(szStart, SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID) ||
                            !strcmp(szStart, SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID);

            // go to next string
            szStart = szEnd;
        }

        // count the codesign EKU once
        cPassedEKU = enhKeyUsage.cUsageIdentifier;
        if(fAddCodeSign)
            enhKeyUsage.cUsageIdentifier++;

        // encode the extension
        if(enhKeyUsage.cUsageIdentifier != 0) {

            // allocate the EKU array
            enhKeyUsage.rgpszUsageIdentifier = (LPSTR *)LocalAlloc(LMEM_FIXED,
                            enhKeyUsage.cUsageIdentifier * sizeof(LPSTR));
            if (NULL == enhKeyUsage.rgpszUsageIdentifier)
            {
                hr = E_OUTOFMEMORY;
                goto OutOfMemoryError;
            }

            // add the EKU's
            szStart = pszPurpose;
            for(i=0; i<cPassedEKU; i++) {

                while(*szStart == '\0')
                    szStart++;

                enhKeyUsage.rgpszUsageIdentifier[i] = szStart;

                while(*szStart != '\0')
                    szStart++;

            }

            // add the code sign EKU
            if(fAddCodeSign)
                enhKeyUsage.rgpszUsageIdentifier[enhKeyUsage.cUsageIdentifier - 1] = szOID_PKIX_KP_CODE_SIGNING;

            // Deal with the policy, or purpose
            rgExtension[iExt].pszObjId = szOID_ENHANCED_KEY_USAGE ;
            rgExtension[iExt].fCritical = FALSE;

            // encode the enhanced key usage
            rgExtension[iExt].Value.cbData = 0;
            while (TRUE)
            {
                if(!CryptEncodeObject(
                        CRYPT_ASN_ENCODING, X509_ENHANCED_KEY_USAGE,
                        &enhKeyUsage,
                        pbEKU,           // pbEncoded
                        &rgExtension[iExt].Value.cbData))
                {
                    goto ErrorEncodeEnhKeyUsage;
                }
                if (NULL != pbEKU)
                {
                    //got it, done
                    rgExtension[iExt].Value.pbData = pbEKU;
                    break;
                }
                pbEKU = (BYTE *)LocalAlloc(LMEM_FIXED,
                                           rgExtension[iExt].Value.cbData);
                if (NULL == pbEKU)
                {
                    hr = E_OUTOFMEMORY;
                    goto OutOfMemoryError;
                }
            }
            iExt++;
        }
    }

    assert(EndExt >= iExt);

    // now add all of the user defined extensions
    pExtCur = NULL;
    while(NULL != (pExtCur =  EnumStackExtension(pExtCur, m_fNewRequestMethod)) ) {
        rgExtension[iExt] = *pExtCur;
        iExt++;
    }

    // fill in the extensions structure
    Extensions.cExtension = iExt;
    Extensions.rgExtension = rgExtension;

    // encode the extensions
    reqInfo.cAttribute = 0;
    reqInfo.rgAttribute = rgAttribute;

    while (TRUE)
    {
        if(!CryptEncodeObject(
                CRYPT_ASN_ENCODING, X509_EXTENSIONS,
                &Extensions,
                blobExt.pbData,           // pbEncoded
                &blobExt.cbData))
        {
            goto ErrorEncodeExtensions;
        }
        if (NULL != blobExt.pbData)
        {
            //got it, done
            break;
        }
        blobExt.pbData = (BYTE *)LocalAlloc(LMEM_FIXED, blobExt.cbData);
        if (NULL == blobExt.pbData)
        {
            hr = E_OUTOFMEMORY;
            goto OutOfMemoryError;
        }
    }
    
    if (m_fOID_V2)
    {
        //use new rsa oid
        rgAttribute[reqInfo.cAttribute].pszObjId = szOID_RSA_certExtensions;
    }
    else
    {
        //use microsoft oid for w2k clients
        rgAttribute[reqInfo.cAttribute].pszObjId = szOID_CERT_EXTENSIONS;
    }
    rgAttribute[reqInfo.cAttribute].cValue = 1;
    rgAttribute[reqInfo.cAttribute].rgValue = &blobExt;

    // put in the CSP attribute
    if( !GetSignatureFromHPROV(
       hProv,
       &CSPProvider.Signature.pbData,
       &CSPProvider.Signature.cbData
       ) )
        goto ErrorGetSignatureFromHPROV;

    CSPProvider.pwszProviderName    = m_keyProvInfo.pwszProvName;
    CSPProvider.dwKeySpec           = m_keyProvInfo.dwKeySpec;

    while (TRUE)
    {
        if( !CryptEncodeObject(
                CRYPT_ASN_ENCODING,
                szOID_ENROLLMENT_CSP_PROVIDER,
                &CSPProvider,
                blobCSPAttr.pbData,           // pbEncoded
                &blobCSPAttr.cbData))
        {
            goto ErrorEncodeCSPAttr;
        }
        if (NULL != blobCSPAttr.pbData)
        {
            //got it, done
            break;
        }
        blobCSPAttr.pbData = (BYTE *)LocalAlloc(LMEM_FIXED, blobCSPAttr.cbData);
        if (NULL == blobCSPAttr.pbData)
        {
            hr = E_OUTOFMEMORY;
            goto OutOfMemoryError;
        }
    }

    reqInfo.cAttribute++;
    rgAttribute[reqInfo.cAttribute].pszObjId = szOID_ENROLLMENT_CSP_PROVIDER;
    rgAttribute[reqInfo.cAttribute].cValue = 1;
    rgAttribute[reqInfo.cAttribute].rgValue = &blobCSPAttr;

    // get the OSVersion
    osvInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionExA(&osvInfo))
        goto ErrorGetVersionEx;
        
    wsprintfA(szVersion, "%d.%d.%d.%d", 
 	      osvInfo.dwMajorVersion,
        osvInfo.dwMinorVersion,
        osvInfo.dwBuildNumber,
        osvInfo.dwPlatformId);

    cnvOSVer.dwValueType = CERT_RDN_IA5_STRING;
    cnvOSVer.Value.cbData = (DWORD)strlen(szVersion);
    cnvOSVer.Value.pbData = (BYTE *) szVersion;

    while (TRUE)
    {
        if(!CryptEncodeObject(
                CRYPT_ASN_ENCODING,
                X509_ANY_STRING,
                &cnvOSVer,
                blobOSVAttr.pbData,           // pbEncoded
                &blobOSVAttr.cbData))
        {
            goto ErrorEncodeOSVAttr;
        }
        if (NULL != blobOSVAttr.pbData)
        {
            //got it, done
            break;
        }
        blobOSVAttr.pbData = (BYTE *)LocalAlloc(LMEM_FIXED, blobOSVAttr.cbData);
        if (NULL == blobOSVAttr.pbData)
        {
            hr = E_OUTOFMEMORY;
            goto OutOfMemoryError;
        }
    }

    reqInfo.cAttribute++;
    rgAttribute[reqInfo.cAttribute].pszObjId = szOID_OS_VERSION;
    rgAttribute[reqInfo.cAttribute].cValue = 1;
    rgAttribute[reqInfo.cAttribute].rgValue = &blobOSVAttr;

    // put in the renewal cert if present
    if(m_pCertContextRenewal != NULL && m_fHonorRenew) {

        reqInfo.cAttribute++;

        blobRenewAttr.pbData = m_pCertContextRenewal->pbCertEncoded;
        blobRenewAttr.cbData = m_pCertContextRenewal->cbCertEncoded;

        rgAttribute[reqInfo.cAttribute].pszObjId = szOID_RENEWAL_CERTIFICATE;
        rgAttribute[reqInfo.cAttribute].cValue = 1;
        rgAttribute[reqInfo.cAttribute].rgValue = &blobRenewAttr;
    }

    if (m_fNewRequestMethod && XECI_DISABLE != m_lClientId)
    {
        //put client id as attribute
        hr = myEncodeRequestClientAttributeFromClientId(
                    m_lClientId,
                    &blobClientId.pbData,
                    &blobClientId.cbData);
        if (S_OK != hr)
        {
            //for any reasons, don't include client ID
            hr = put_ClientId(XECI_DISABLE);
            if (S_OK != hr)
            {
                goto putClientIdError;
            }
        }
        else
        {
            reqInfo.cAttribute++;
            rgAttribute[reqInfo.cAttribute].pszObjId = szOID_REQUEST_CLIENT_INFO;
            rgAttribute[reqInfo.cAttribute].cValue = 1;
            rgAttribute[reqInfo.cAttribute].rgValue = &blobClientId;
        }
    }

    // NOTE: On error we always return BAD ALGID
    // this is because sometimes we get an no more data enum error
    // that doesn't help.
    // get the signature oid
    if( !GetCapiHashAndSigAlgId(rgAlg) ) {
        SetLastError((DWORD)NTE_BAD_ALGID);
        goto ErrorGetCapiHashAndSigAlgId;
    }

    // Convert to an oid
    if( (NULL == (pOidInfo = xeCryptFindOIDInfo(
        CRYPT_OID_INFO_SIGN_KEY,
        (void *) rgAlg,
        CRYPT_SIGN_ALG_OID_GROUP_ID)) ) ) {
        SetLastError((DWORD)NTE_BAD_ALGID);
        goto ErrorCryptFindOIDInfo;
    }

    // we always know we have at least 1 attribute, and we have been zero based, now go to 1 based.
    reqInfo.cAttribute++;
    SignatureInfo.SignatureAlgorithm.pszObjId = (char *) pOidInfo->pszOID;
#if DBG
    //SignatureInfo.ToBeSigned.pbData should be null at the first
    assert(NULL == SignatureInfo.ToBeSigned.pbData);
#endif
    // encode PKCS10
    while (TRUE)
    {
        if(!CryptEncodeObject(
                CRYPT_ASN_ENCODING, X509_CERT_REQUEST_TO_BE_SIGNED,
                &reqInfo,
                SignatureInfo.ToBeSigned.pbData,           // pbEncoded
                &SignatureInfo.ToBeSigned.cbData))
        {
            goto ErrorEncodePKCS10ToBeSigned;
        }
        if (NULL != SignatureInfo.ToBeSigned.pbData)
        {
            //done
            break;
        }
        SignatureInfo.ToBeSigned.pbData = (BYTE *)
            LocalAlloc(LMEM_FIXED, SignatureInfo.ToBeSigned.cbData);
        if (NULL == SignatureInfo.ToBeSigned.pbData)
        {
            hr = E_OUTOFMEMORY;
            goto OutOfMemoryError;
        }
    }

    // create the signature Info
    // Don't care if xchange or signature key in dwkeySpec because
    // we are signing with the key that is in the PKCS10
#if DBG
    assert(NULL == SignatureInfo.Signature.pbData);
#endif
    while (TRUE)
    {
        if(!CryptSignCertificate(
                hProv,
                m_keyProvInfo.dwKeySpec,
                CRYPT_ASN_ENCODING,
                SignatureInfo.ToBeSigned.pbData,
                SignatureInfo.ToBeSigned.cbData,
                &SignatureInfo.SignatureAlgorithm,
                NULL,                   // reserved
                SignatureInfo.Signature.pbData, // pbSignature
                &SignatureInfo.Signature.cbData))
        {
            goto ErrorCryptSignCertificatePKCS10;
        }
        if (NULL != SignatureInfo.Signature.pbData)
        {
            //done
            break;
        }
        SignatureInfo.Signature.pbData = (BYTE *)
            LocalAlloc(LMEM_FIXED, SignatureInfo.Signature.cbData);
        if (NULL == SignatureInfo.Signature.pbData)
        {
            hr = E_OUTOFMEMORY;
            goto OutOfMemoryError;
        }
    }

    // encode the final signed request
    if( !CryptEncodeObject(
            CRYPT_ASN_ENCODING,
            X509_CERT,
            &SignatureInfo,
            NULL,
            &pPkcs10Blob->cbData
            )                               ||
        (pPkcs10Blob->pbData = (BYTE *)
            MyCoTaskMemAlloc(pPkcs10Blob->cbData)) == NULL     ||
        !CryptEncodeObject(
            CRYPT_ASN_ENCODING,
            X509_CERT,
            &SignatureInfo,
            pPkcs10Blob->pbData,
            &pPkcs10Blob->cbData
            ) ) {
        goto ErrorEncodePKCS10Request;
    }

    // go ahead and make the pkcs 7
    if((m_pCertContextRenewal != NULL ||
        m_pCertContextSigner  != NULL) &&
       m_fHonorRenew &&
       !m_fCMCFormat) //if CMC, don't make pkcs7
    {

        // create a pkcs7 signed by the old cert
        if(S_OK != CreatePKCS7RequestFromRequest(
            pPkcs10Blob,
            (NULL != m_pCertContextRenewal) ? m_pCertContextRenewal :
                                              m_pCertContextSigner,
            &blobPKCS7) )
            goto ErrorCreatePKCS7RARequestFromPKCS10;

        assert(pPkcs10Blob->pbData != NULL);
        MyCoTaskMemFree(pPkcs10Blob->pbData);
        *pPkcs10Blob = blobPKCS7;
        memset(&blobPKCS7, 0, sizeof(CRYPT_DATA_BLOB));

    }
 
    ssFlags = CERT_CREATE_SELFSIGN_NO_SIGN;
    if(m_wszPVKFileName[0] != 0)
        ssFlags |= CERT_CREATE_SELFSIGN_NO_KEY_INFO;

    // Get the cert extensions we wish to add to the certificate. 
    // Search for the extensions we need.  
    {
        PCERT_EXTENSION pCertExtCertTypeName = NULL; 
        while(NULL != (pCertExtCertTypeName =  EnumStackExtension(pCertExtCertTypeName, m_fNewRequestMethod)) ) {
            for (DWORD dTmp = 0; dTmp < sizeof(rgszExtensionOIDs) / sizeof(LPSTR); dTmp++) { 
                if (0 == strcmp(rgszExtensionOIDs[dTmp], pCertExtCertTypeName->pszObjId))
                    rgNeededExtensions[(ceExtensions.cExtension)++] = *pCertExtCertTypeName; 
            }
        }

        // Even if we didn't find all of the extensions we wanted, continue ... 
    }

    assert(pCertContext == NULL);
    pCertContext = MyCertCreateSelfSignCertificate(
        hProv,
        &reqInfo.Subject,
        ssFlags,
        &m_keyProvInfo,
        NULL,
        NULL,
        NULL,
        (ceExtensions.cExtension > 0) ? &ceExtensions : NULL
        );
    if (NULL == pCertContext)
        goto ErrorCertCreateSelfSignCertificate;

    // now put the pass thru data on the cert
    requestFlags.fWriteToCSP    =   (m_fWriteCertToCSP != 0);
    requestFlags.fWriteToDS     =   (m_fWriteCertToUserDS != 0);
    requestFlags.openFlags      =   m_RequestStore.dwFlags;

#if DBG
    assert(NULL == requestInfoBlob.pbData);
#endif
    while (TRUE)
    {
        if(!CryptEncodeObject(
                CRYPT_ASN_ENCODING,
                XENROLL_REQUEST_INFO,
                &requestFlags,
                requestInfoBlob.pbData,
                &requestInfoBlob.cbData))
        {
            goto ErrorEncodeRequestInfoBlob;
        }
        if (NULL != requestInfoBlob.pbData)
        {
            //done
            break;
        }
        requestInfoBlob.pbData = (BYTE *)LocalAlloc(LMEM_FIXED, requestInfoBlob.cbData);
        if (NULL == requestInfoBlob.pbData)
        {
            hr = E_OUTOFMEMORY;
            goto OutOfMemoryError;
        }
    }

    // set the property on the dummy request cert.
    if( !CertSetCertificateContextProperty(
            pCertContext,
            XENROLL_PASS_THRU_PROP_ID,
            0,
            &requestInfoBlob) )
        goto ErrorCertSetCertificateContextProperty;

    if(m_pCertContextRenewal != NULL && m_fHonorRenew) {

        blobRenewalCert.pbData = m_pCertContextRenewal->pbCertEncoded;
        blobRenewalCert.cbData = m_pCertContextRenewal->cbCertEncoded;

        // set the renewal property if any
        if( !CertSetCertificateContextProperty(
                pCertContext,
                XENROLL_RENEWAL_CERTIFICATE_PROP_ID,
                0,
                &blobRenewalCert) )
            goto ErrorCertSetCertificateContextProperty;
    }

    // save the private key away if needed
    if(m_wszPVKFileName[0] != 0) {

        // open the PVK File
        if( (hFile = CreateOpenFileSafely2(m_wszPVKFileName, IDS_PVK_C, IDS_PVK_O)) == NULL )
            goto ErrorCreatePVKFile;

        assert(m_keyProvInfo.dwKeySpec == AT_SIGNATURE || m_keyProvInfo.dwKeySpec == AT_KEYEXCHANGE);

        // write out the private key
        if( !PrivateKeySave(
            hProv,
            hFile,
            m_keyProvInfo.dwKeySpec,
            NULL,
            m_wszPVKFileName,
            0
            ) )  {
            goto ErrorPrivateKeySave;
        }

        // put a different kind of propery in the store that just points to the pvk file
        keyProvInfoT = m_keyProvInfo;
        keyProvInfoT.pwszContainerName = m_wszPVKFileName;
        if( !CreatePvkProperty(&keyProvInfoT, &blobData) )
            goto ErrorCreatePvkProperty;

        // This is really not needed, it is only nice for other tools
        // like makecert or signcode to be able to look at a cert without
        // specifying a .PVK file if the cert points to the .pvk file.
        // So we don't care if this actually fail, which it will on Auth2 and
        // SP3 Crypt32.dll since Phil was so kind as to not allow any unknown property
        // to be set on the cert --- BAD PHIL!
        CertSetCertificateContextProperty(
                pCertContext,
                CERT_PVK_FILE_PROP_ID,
                0,
                &blobData);

        // only delete the keyset if the key was not pre-existing
        // this is if we write it out to a PVK file only
        // This is safe for scripting since we just generated this and we are putting it to
        // a pvk file. We really aren't deleting the key.
        if (!m_fNewRequestMethod)
        {
            //keep old behavior for createPKCS10 call
            if(!m_fUseExistingKey)
                GetProv(CRYPT_DELETEKEYSET);
        }
    }

    //set all properties from the caller
    pProp = EnumStackProperty(NULL);
    while (NULL != pProp)
    {
        //goto request cert
        if (!CertSetCertificateContextProperty(
                        pCertContext,
                        pProp->lPropId,
                        0,
                        &pProp->prop))
        {
            goto ErrorCertSetCertificateContextProperty;
        }
        pProp = EnumStackProperty(pProp);
    }

    // open the request cert store
    if( (hStore = GetStore(StoreREQUEST)) == NULL)
        goto ErrorCertOpenRequestStore;

    //if old pending request exists, free it first
    fRet = CertFreeCertificateContext(m_pCertContextPendingRequest);
#if DBG
    assert(fRet);
#endif //DBG
    m_pCertContextPendingRequest = NULL;

    // save the temp cert
    if( !MySafeCertAddCertificateContextToStore(
            hStore,
            pCertContext,
            CERT_STORE_ADD_NEW,
            &m_pCertContextPendingRequest, 
	    m_dwEnabledSafteyOptions) ) {
        goto ErrorCertAddToRequestStore;
    }

    // Remove the cached HASH. 
    if (m_hashBlobPendingRequest.pbData != NULL)
    {
        LocalFree(m_hashBlobPendingRequest.pbData);
        m_hashBlobPendingRequest.pbData = NULL;
    }

CommonReturn:

    if(pCertContext != NULL)
        CertFreeCertificateContext(pCertContext);
    if(hFile != NULL)
        CloseHandle(hFile);
    if(blobData.pbData != NULL)
        MyCoTaskMemFree(blobData.pbData);
    if(blobPKCS7.pbData != NULL)
        MyCoTaskMemFree(blobPKCS7.pbData);
    if(CSPProvider.Signature.pbData)
        LocalFree(CSPProvider.Signature.pbData);
    if (NULL != pbSMime)
    {
        LocalFree(pbSMime);
    }
    if (NULL != reqInfo.Subject.pbData)
    {
        LocalFree(reqInfo.Subject.pbData);
    }
    if (NULL != rgExtension)
    {
        LocalFree(rgExtension);
    }
    if (NULL != pbKU)
    {
        LocalFree(pbKU);
    }
    if (NULL != pbEKU)
    {
        LocalFree(pbEKU);
    }
    if (NULL != pszPurpose)
    {
        LocalFree(pszPurpose);
    }
    if (NULL != enhKeyUsage.rgpszUsageIdentifier)
    {
        LocalFree(enhKeyUsage.rgpszUsageIdentifier);
    }
    if (NULL != blobExt.pbData)
    {
        LocalFree(blobExt.pbData);
    }
    if (NULL != blobCSPAttr.pbData)
    {
        LocalFree(blobCSPAttr.pbData);
    }
    if (NULL != blobOSVAttr.pbData)
    {
        LocalFree(blobOSVAttr.pbData);
    }
    if (NULL != SignatureInfo.ToBeSigned.pbData)
    {
        LocalFree(SignatureInfo.ToBeSigned.pbData);
    }
    if (NULL != SignatureInfo.Signature.pbData)
    {
        LocalFree(SignatureInfo.Signature.pbData);
    }
    if (NULL != requestInfoBlob.pbData)
    {
        LocalFree(requestInfoBlob.pbData);
    }
    if (NULL != blobClientId.pbData)
    {
        LocalFree(blobClientId.pbData);
    }
    if (NULL != pbSubjectKeyHashExtension)
    {
        LocalFree(pbSubjectKeyHashExtension);
    }
    if (NULL != pwszNotSafeRequesting)
    {
	LocalFree(pwszNotSafeRequesting);
    }
    if (NULL != pwszTitle)
    {
	LocalFree(pwszTitle);
    }

    // don't know if we have an error or not
    // but I do know the errBefore is set properly
    SetLastError(errBefore);

    LeaveCriticalSection(&m_csXEnroll);
    return(hr);

ErrorReturn:

    if(GetLastError() == ERROR_SUCCESS)
        SetLastError((DWORD)E_UNEXPECTED);
    hr = MY_HRESULT_FROM_WIN32(GetLastError());

    // We have an error, make sure we set it.
    errBefore = GetLastError();

    // on error return a NULL
    if(pPkcs10Blob->pbData != NULL)
        MyCoTaskMemFree(pPkcs10Blob->pbData);
    memset(pPkcs10Blob, 0, sizeof(CRYPT_DATA_BLOB));


    goto CommonReturn;

TRACE_ERROR(ErrorGetSignatureFromHPROV);
TRACE_ERROR(ErrorEncodeCSPAttr);
TRACE_ERROR(ErrorCertSetCertificateContextProperty);
TRACE_ERROR(ErrorCryptAcquireContext);
TRACE_ERROR(ErrorCryptGenKey);
TRACE_ERROR(ErrorCryptExportPublicKeyInfo);
TRACE_ERROR(ErrorCertStrToNameW);
TRACE_ERROR(ErrorEncodeKeyUsage);
TRACE_ERROR(ErrorEncodeEnhKeyUsage);
TRACE_ERROR(ErrorEncodeExtensions);
TRACE_ERROR(ErrorEncodePKCS10ToBeSigned);
TRACE_ERROR(ErrorCryptSignCertificatePKCS10);
TRACE_ERROR(ErrorEncodePKCS10Request);
TRACE_ERROR(ErrorCantConvertPurpose);
TRACE_ERROR(ErrorCertOpenRequestStore);
TRACE_ERROR(ErrorCertAddToRequestStore);
TRACE_ERROR(ErrorCreatePVKFile);
TRACE_ERROR(ErrorPrivateKeySave);
TRACE_ERROR(ErrorCreatePvkProperty);
TRACE_ERROR(ErrorCertCreateSelfSignCertificate);
TRACE_ERROR(ErrorEncodeRequestInfoBlob);
TRACE_ERROR(ErrorCreatePKCS7RARequestFromPKCS10);
TRACE_ERROR(ErrorGetCapiHashAndSigAlgId);
TRACE_ERROR(ErrorCryptFindOIDInfo);
TRACE_ERROR(ErrorEncodeOSVAttr);
TRACE_ERROR(ErrorGetVersionEx);
TRACE_ERROR(CancelledError);
TRACE_ERROR(CreateSMimeExtensionError);
TRACE_ERROR(OutOfMemoryError);
TRACE_ERROR(putClientIdError);
TRACE_ERROR(myCreateSubjectKeyIdentifierExtensionError)
TRACE_ERROR(xeLoadRCStringError);
TRACE_ERROR(CryptGetUserKeyCancelError)
#if DBG
TRACE_ERROR(SetKeyContainerSecurityError)
#endif //DBG
}

HRESULT STDMETHODCALLTYPE CCEnroll::acceptPKCS7Blob(
    /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7) {

    HRESULT     hr;
    HRESULT     hr2 = S_OK;
    LONG                       dwKeySpec               = 0;
    PCCERT_CONTEXT              pCertContextMy          = NULL;
    PCCERT_CONTEXT              pCertContextRequest     = NULL;
    PCCERT_CONTEXT              pCertContextEnd         = NULL;
    HANDLE                      hFile                   = NULL;
    DWORD                       cb                      = 0;
    HCRYPTPROV                  hProv                   = NULL;
    HCRYPTKEY                   hKey                    = NULL;
    HCERTSTORE                  hStoreDS                = NULL;
    HCERTSTORE                  hStoreRequest           = NULL;
    HCERTSTORE                  hStoreMy                = NULL;
    LPWSTR                      pwszTitle               = NULL; 
    LPWSTR                      pwszNotSafeAccepting    = NULL; 

    EnterCriticalSection(&m_csXEnroll);
    
    // Accepting a request is not safe for scripting:  pop up a warning dialog if called from script
    if (0 != m_dwEnabledSafteyOptions) { 
	hr = xeLoadRCString(hInstanceXEnroll, IDS_NOTSAFEACTION, &pwszTitle);
	if (S_OK != hr)
	    goto xeLoadRCStringError;
	
	hr = xeLoadRCString(hInstanceXEnroll, IDS_NOTSAFE_ACCEPTING_CERT, &pwszNotSafeAccepting);
	if (S_OK != hr)
	    goto xeLoadRCStringError;
	
	if (IDYES != MessageBoxU(NULL, pwszNotSafeAccepting, pwszTitle, MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2)) { 
	    hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
	    goto CancelledError; 
	}
    }

    // get the end entity cert
    hr2 = GetEndEntityCert(pBlobPKCS7, TRUE, &pCertContextEnd);
    if (S_OK != hr2 && XENROLL_E_CANNOT_ADD_ROOT_CERT != hr2)
    {
        hr = hr2;
        goto ErrorGetEndEntityCert;
    }

    if(m_fDeleteRequestCert)
    {
        if ((hStoreRequest = GetStore(StoreREQUEST)) == NULL)
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto ErrorCertOpenRequestStore;
        }

        // check to see if this is in the request store
        if ((pCertContextRequest = CertFindCertificateInStore(
                hStoreRequest,
                CRYPT_ASN_ENCODING,
                0,
                CERT_FIND_PUBLIC_KEY,
                (void *) &pCertContextEnd->pCertInfo->SubjectPublicKeyInfo,
                NULL)) != NULL)
        {
            CertDeleteCertificateFromStore(pCertContextRequest);
            pCertContextRequest = NULL;
        }
    }

    cb = 0;
    // if the cert is to be written to the CSP,
    // put it there but only if we have keys
    if (m_fWriteCertToCSP  &&
        CertGetCertificateContextProperty(
            pCertContextEnd,
            CERT_KEY_PROV_INFO_PROP_ID, NULL, &cb))
    {
        if ((hProv = GetProv(0)) == NULL)
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto ErrorCryptAcquireContext;
        }

        // This can't fail
        get_KeySpec(&dwKeySpec);

        if (!CryptGetUserKey(
                hProv,
                dwKeySpec,
                &hKey))
        {
            hKey = NULL;
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto ErrorCryptGetUserKey;
        }

        // always attempt to write the cert to the csp
        if (!CryptSetKeyParam(
                hKey,
                KP_CERTIFICATE,
                pCertContextEnd->pbCertEncoded,
                0))
        {
            // only return an error if it is a smart card error
            // otherwise ignore the error
            if (SCODE_FACILITY(GetLastError()) == FACILITY_SCARD)
            {
                //return error code from writing cert to csp
                //important to save the error code before following clean up
                hr = MY_HRESULT_FROM_WIN32(GetLastError());

                //if can't write cert back to smartcard, remove the cert from my store
                if ((hStoreMy = GetStore(StoreMY)) == NULL)
                {
                    hr = MY_HRESULT_FROM_WIN32(GetLastError());
                    goto ErrorCertOpenMyStore;
                }

                // check to see if this is in the MY store
                if ((pCertContextMy = CertFindCertificateInStore(
                        hStoreMy,
                        CRYPT_ASN_ENCODING,
                        0,
                        CERT_FIND_PUBLIC_KEY,
                        (void *) &pCertContextEnd->pCertInfo->SubjectPublicKeyInfo,
                        NULL)) != NULL)
                {
                    //try to remove it
                    CertDeleteCertificateFromStore(pCertContextMy);
                    pCertContextMy = NULL;
                }
                if (!m_fUseExistingKey)
                {
                        GetProv(CRYPT_DELETEKEYSET);
                }
                //error any way
                goto ErrorWriteToCSP;
            }
        }
    }

    if(m_fWriteCertToUserDS)
    {
        // otherwise attempt to open the store
        if ((hStoreDS = CertOpenStore(
                CERT_STORE_PROV_SYSTEM,
                X509_ASN_ENCODING,
                NULL,
                CERT_SYSTEM_STORE_CURRENT_USER,
                L"UserDS")) == NULL)
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto ErrorCertOpenDSStore;
        }

        if (!CertAddCertificateContextToStore(
                    hStoreDS,
                    pCertContextEnd,
                    CERT_STORE_ADD_NEW,
                    NULL))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto ErrorAddCertificateContextToDSStore;
        }

        CertCloseStore(hStoreDS, 0);
        hStoreDS = NULL;

    }

    // determine if he wants to save the spc file
    if (m_wszSPCFileName[0] != 0)
    {
        // open the spc file
        hFile = CreateOpenFileSafely2(m_wszSPCFileName, IDS_SPC_C, IDS_SPC_O);
        if (NULL == hFile)
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto ErrorCreateSPCFile;
        }

        // write the spc
        assert(pBlobPKCS7->pbData != NULL);
        cb = 0;
        if (!WriteFile(
            hFile,
            pBlobPKCS7->pbData,
            pBlobPKCS7->cbData,
            &cb,
            NULL))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto ErrorWriteSPCFile;
        }
    }

    if (S_OK != hr2)
    {
        //return hr2 error
        hr = hr2;
    }
    else
    {
        hr = S_OK;
    }
ErrorReturn:

    if(hKey != NULL)
        CryptDestroyKey(hKey);
    if(hFile != NULL)
        CloseHandle(hFile);

    if(pCertContextEnd != NULL)
        CertFreeCertificateContext(pCertContextEnd);
    if(hStoreDS != NULL)
        CertCloseStore(hStoreDS, 0);
    if (NULL != pwszNotSafeAccepting)
	LocalFree(pwszNotSafeAccepting);
    if (NULL != pwszTitle)
	LocalFree(pwszTitle);

    LeaveCriticalSection(&m_csXEnroll);
    return(hr);

TRACE_ERROR(ErrorWriteToCSP);
TRACE_ERROR(ErrorCreateSPCFile);
TRACE_ERROR(ErrorWriteSPCFile);
TRACE_ERROR(ErrorGetEndEntityCert);
TRACE_ERROR(ErrorCryptAcquireContext);
TRACE_ERROR(ErrorCryptGetUserKey);
TRACE_ERROR(ErrorCertOpenDSStore);
TRACE_ERROR(ErrorAddCertificateContextToDSStore);
TRACE_ERROR(ErrorCertOpenRequestStore);
TRACE_ERROR(ErrorCertOpenMyStore);
TRACE_ERROR(CancelledError);
TRACE_ERROR(xeLoadRCStringError);
}

PCCERT_CONTEXT STDMETHODCALLTYPE CCEnroll::getCertContextFromPKCS7(
    /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7) {
    HRESULT hr;
    PCCERT_CONTEXT pCert;

    // get the end entity cert
    hr = GetEndEntityCert(pBlobPKCS7, FALSE, &pCert);
#if DBG
    if (S_OK != hr)
    {
        assert(NULL == pCert);
    }
#endif //DBG
    return pCert;
}

HRESULT STDMETHODCALLTYPE CCEnroll::enumProvidersWStr(
    /* [in] */ LONG dwIndex,
    /* [in] */ LONG dwFlags,
    /* [out] */ LPWSTR __RPC_FAR *ppwsz) {

    DWORD   iLast = 0;
    LONG    i;
    DWORD   dwProvType = 0;
    DWORD   cb = 0;
    HRESULT hr = S_OK;
    DWORD errBefore = GetLastError();

    assert(ppwsz != NULL);
    *ppwsz = NULL;
    SetLastError(ERROR_SUCCESS);

    EnterCriticalSection(&m_csXEnroll);

    for(i=0; i<=dwIndex; i++) {

        do {

            cb = 0;
            if( !CryptEnumProvidersU(
                           iLast,
                           0,
                           0,
                           &dwProvType,
                           NULL,
                           &cb
                           ) ) {

                // only skip if entry is bad
                if( GetLastError() != NTE_PROV_TYPE_ENTRY_BAD)
                    goto ErrorCryptEnumProvidersU;
            }
            iLast++;
        } while((CRYPT_ENUM_ALL_PROVIDERS & dwFlags) != CRYPT_ENUM_ALL_PROVIDERS  &&
                    dwProvType != m_keyProvInfo.dwProvType);
    }

    iLast--;
    if( (*ppwsz = (LPWSTR) MyCoTaskMemAlloc(cb)) == NULL  ||
        !CryptEnumProvidersU(
                       iLast,
                       0,
                       0,
                       &dwProvType,
                       *ppwsz,
                       &cb
                       )                        ) {
        goto ErrorCryptEnumProvidersU;
    }

CommonReturn:

    SetLastError(errBefore);

    LeaveCriticalSection(&m_csXEnroll);
    return(hr);

ErrorReturn:

    if(GetLastError() == ERROR_SUCCESS)
        SetLastError((DWORD)E_UNEXPECTED);
    hr = MY_HRESULT_FROM_WIN32(GetLastError());

    // We have an error, make sure we set it.
    errBefore = GetLastError();

    if(*ppwsz != NULL)
    {
        MyCoTaskMemFree(*ppwsz);
	*ppwsz = NULL;
    }

    goto CommonReturn;

TRACE_ERROR(ErrorCryptEnumProvidersU);
}


//--------------------------------------------------------------------------------
//
// THIS METHOD IS NOT SAFE FOR SCRIPTING
//
//--------------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CCEnroll::enumContainersWStr(
    /* [in] */ LONG               dwIndex,
    /* [out] */ LPWSTR __RPC_FAR *ppwsz) {

    DWORD       errBefore   = GetLastError();
    DWORD       cb          = 0;
    LONG        i           = 0;
    char *      psz         = NULL;
    HRESULT     hr          = S_OK;

    EnterCriticalSection(&m_csXEnroll);

    SetLastError(ERROR_SUCCESS);

    assert(ppwsz != NULL);
    *ppwsz = NULL;

    if (0 != m_dwEnabledSafteyOptions) // not safe for scripting
	goto AccessDeniedError;

    hr = GetVerifyProv();
    if (S_OK != hr)
    {
        goto GetVerifyProvError;
    }

    while (TRUE)
    {
        if(!CryptGetProvParam(
                m_hVerifyProv,
                PP_ENUMCONTAINERS,
                (BYTE*)psz,
                &cb,
                CRYPT_FIRST))
        {
            goto ErrorCryptGetProvParam;
        }
        if (NULL != psz)
        {
            //done
            break;
        }
        psz = (char*)LocalAlloc(LMEM_FIXED, cb);
        if (NULL == psz)
        {
            goto ErrorOutOfMem;
        }
    }

    for(i=1; i<=dwIndex; i++) {
        //assume 1st enum buffer size is big enough for all?
        if( !CryptGetProvParam(
            m_hVerifyProv,
            PP_ENUMCONTAINERS,
            (BYTE *) psz,
            &cb,
            0) )
            goto ErrorCryptGetProvParam;
    }

    if( (*ppwsz = WideFromMB(psz)) == NULL )
        goto ErrorOutOfMem;


CommonReturn:
    if (NULL != psz)
    {
        LocalFree(psz);
    }

    SetLastError(errBefore);

    LeaveCriticalSection(&m_csXEnroll);
    return(hr);

ErrorReturn:

    if(GetLastError() == ERROR_SUCCESS)
        SetLastError((DWORD)E_UNEXPECTED);
    hr = MY_HRESULT_FROM_WIN32(GetLastError());

    // We have an error, make sure we set it.
    errBefore = GetLastError();

    if(*ppwsz != NULL)
        MyCoTaskMemFree(*ppwsz);
    *ppwsz = NULL;

    goto CommonReturn;


SET_ERROR(AccessDeniedError, E_ACCESSDENIED);
TRACE_ERROR(GetVerifyProvError);
TRACE_ERROR(ErrorCryptGetProvParam);
TRACE_ERROR(ErrorOutOfMem);
}


HRESULT CCEnroll::PKCS10ToCert(IN   HCERTSTORE        hCertStore,
                               IN   CRYPT_DATA_BLOB   pkcs10Blob, 
                               OUT  PCCERT_CONTEXT   *ppCertContext)
{
    HRESULT            hr       = E_FAIL; 
    PCERT_REQUEST_INFO pReqInfo = NULL; 

    // Input validation: 
    if (NULL == hCertStore || NULL == pkcs10Blob.pbData || NULL == ppCertContext)
        return E_INVALIDARG;

    if( !MyCryptQueryObject(CERT_QUERY_OBJECT_BLOB,
                            &pkcs10Blob, 
                            CERT_QUERY_CONTENT_FLAG_PKCS10,
                            CERT_QUERY_FORMAT_FLAG_ALL,
                            CRYPT_DECODE_ALLOC_FLAG,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            (const void **) &pReqInfo) )
        goto MyCryptQueryObjectError;

    if ( NULL == (*ppCertContext = CertFindCertificateInStore
                  (hCertStore,
                   CRYPT_ASN_ENCODING, 
                   0, 
                   CERT_FIND_PUBLIC_KEY, 
                   (void *) &pReqInfo->SubjectPublicKeyInfo, 
                   NULL)) )
        goto CertFindCertificateInStoreError;

    hr = S_OK; 

CommonReturn:
    if (NULL != pReqInfo) { LocalFree(pReqInfo); } // Allocated in CryptQueryObject(). 
    return hr; 

 ErrorReturn:
    goto CommonReturn; 

SET_HRESULT(CertFindCertificateInStoreError,  MY_HRESULT_FROM_WIN32(GetLastError()));
SET_HRESULT(MyCryptQueryObjectError,          MY_HRESULT_FROM_WIN32(GetLastError())); 
}

HRESULT CCEnroll::PKCS7ToCert(IN  HCERTSTORE       hCertStore,
                              IN  CRYPT_DATA_BLOB  pkcs7Blob, 
                              OUT PCCERT_CONTEXT  *ppCertContext)
{
    CRYPT_DATA_BLOB            pkcs10Blob;
    CRYPT_VERIFY_MESSAGE_PARA  VerifyPara; 
    HRESULT                    hr           = E_FAIL; 

    // Init locals:
    ZeroMemory(&pkcs10Blob, sizeof(pkcs10Blob)); 
    ZeroMemory(&VerifyPara, sizeof(VerifyPara)); 

    VerifyPara.cbSize                   = sizeof(VerifyPara); 
    VerifyPara.dwMsgAndCertEncodingType = PKCS_7_ASN_ENCODING | X509_ASN_ENCODING; 

    if (!MyCryptVerifyMessageSignature
        (&VerifyPara,
         0,                  // dwSignerIndex
         pkcs7Blob.pbData,
         pkcs7Blob.cbData,
         pkcs10Blob.pbData,
         &(pkcs10Blob.cbData),
         NULL                // ppSignerCert
         ) || 0 == pkcs10Blob.cbData)
        goto MyCryptVerifyMessageSignatureError;

    if (NULL == (pkcs10Blob.pbData = (PBYTE)LocalAlloc(LPTR, pkcs10Blob.cbData)))
        goto MemoryError; 

    if (!MyCryptVerifyMessageSignature
        (&VerifyPara,
         0,                  // dwSignerIndex
         pkcs7Blob.pbData,
         pkcs7Blob.cbData,
         pkcs10Blob.pbData,
         &pkcs10Blob.cbData,
         NULL                // ppSignerCert
         ))
        goto MyCryptVerifyMessageSignatureError;

    hr = this->PKCS10ToCert(hCertStore, pkcs10Blob, ppCertContext); 

CommonReturn:
    if (NULL != pkcs10Blob.pbData) { LocalFree(pkcs10Blob.pbData); } 
    return hr; 

ErrorReturn:
    goto CommonReturn;

SET_HRESULT(MemoryError,                        E_OUTOFMEMORY); 
SET_HRESULT(MyCryptVerifyMessageSignatureError, MY_HRESULT_FROM_WIN32(GetLastError()));
}

HRESULT STDMETHODCALLTYPE CCEnroll::freeRequestInfoBlob(
    /* [in] */ CRYPT_DATA_BLOB pkcs7OrPkcs10) {

    DWORD            dwContentType   = NULL;
    HCERTSTORE       hStoreRequest   = NULL;
    HRESULT          hr              = E_FAIL;
    PCCERT_CONTEXT   pCertContext    = NULL; 

    // We're not supposed to delete the cert anyway, so we're done!
    if (!m_fDeleteRequestCert)
        return S_OK; 

    if (NULL == pkcs7OrPkcs10.pbData)
        return E_INVALIDARG;

    EnterCriticalSection(&m_csXEnroll);

    // Step 1)  Determine if we have a PKCS7 or a PKCS10:
    //
    if( !MyCryptQueryObject(CERT_QUERY_OBJECT_BLOB,
                            &pkcs7OrPkcs10,
                            (CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED | CERT_QUERY_CONTENT_FLAG_PKCS10),
                            CERT_QUERY_FORMAT_FLAG_ALL,
                            0,
                            NULL,
                            &dwContentType,  // OUT:  PKCS10 or PKCS7
                            NULL,
                            NULL, 
                            NULL,
                            NULL) )
        goto MyCryptQueryObjectError;
    
    // Step 2)  Find a cert context with a matching public key in the request store: 
    // 

    if (NULL == (hStoreRequest = GetStore(StoreREQUEST)))
        goto UnexpectedError; 

    switch (dwContentType) 
    {
    case CERT_QUERY_CONTENT_PKCS7_SIGNED:
        hr = this->PKCS7ToCert(hStoreRequest, pkcs7OrPkcs10, &pCertContext);
        if (S_OK != hr)
        {
            if (CRYPT_E_NOT_FOUND == hr)
            {
                //freeRequestInfo could be called when cert is not issued
                //PKCS7 could be CMC which is signed by request key and
                //cert is not in local store yet. We try cached cert
                if (NULL != m_pCertContextPendingRequest)
                {
                    //looks we still have cached request cert handle
                    pCertContext = CertDuplicateCertificateContext(
                                        m_pCertContextPendingRequest);
                    if (NULL == pCertContext)
                    {
                        hr = MY_HRESULT_FROM_WIN32(GetLastError());
                        goto CertDuplicateCertificateContextError;
                    }
                }
                else if (NULL != m_hashBlobPendingRequest.pbData &&
                         0 < m_hashBlobPendingRequest.cbData)
                {
                    //don't have cached request handle but thumbprint exists
                    //retrieve the request cert handle from store
                    pCertContext = CertFindCertificateInStore(
                                hStoreRequest,  //request store
                                X509_ASN_ENCODING,
                                0,
                                CERT_FIND_HASH,
                                &m_hashBlobPendingRequest,
                                NULL);
                    if (NULL == pCertContext)
                    {
                        hr = MY_HRESULT_FROM_WIN32(GetLastError());
                        goto CertFindCertificateInStoreError;
                    }
                }
                else
                {
                    //sorry, don't know which cert to be free
                    //however, can try to find public key from PKCS7
                    goto PKCS7ToCertError; 
                }
            }
            else
            {
                //other errors
                goto PKCS7ToCertError; 
            }
        }
        break;
    case CERT_QUERY_CONTENT_PKCS10:
        if (S_OK != (hr = this->PKCS10ToCert(hStoreRequest, pkcs7OrPkcs10, &pCertContext)))
            goto PKCS10ToCertError; 
        break;
    default:
        goto InvalidContentTypeError; 
    }

    if (!CertDeleteCertificateFromStore(pCertContext))
    {
        // pCertContext is freed even when CertDeleteCertificateFromStore() returns an error. 
        pCertContext = NULL; 
        goto CertDeleteCertificateFromStoreError; 
    }

    hr = S_OK; 
CommonReturn:
    LeaveCriticalSection(&m_csXEnroll);
    return hr;

ErrorReturn:
    if (NULL != pCertContext) { CertFreeCertificateContext(pCertContext); } 
    goto CommonReturn;

SET_HRESULT(CertDeleteCertificateFromStoreError,  MY_HRESULT_FROM_WIN32(GetLastError())); 
SET_HRESULT(PKCS7ToCertError,                     hr);
SET_HRESULT(PKCS10ToCertError,                    hr);
SET_HRESULT(InvalidContentTypeError,              E_INVALIDARG);
SET_HRESULT(MyCryptQueryObjectError,              MY_HRESULT_FROM_WIN32(GetLastError()));
SET_HRESULT(UnexpectedError,                      E_UNEXPECTED);
TRACE_ERROR(CertDuplicateCertificateContextError)
TRACE_ERROR(CertFindCertificateInStoreError)
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_SPCFileNameWStr(
    /* [out] */ LPWSTR __RPC_FAR *szw) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if( (*szw = CopyWideString(m_wszSPCFileName)) == NULL )
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_SPCFileNameWStr(
    /* [in] */ LPWSTR pwsz) {

    HRESULT hr = S_OK;
 
    if(pwsz == NULL)
        return(MY_HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
        
    EnterCriticalSection(&m_csXEnroll);
        
    if( m_wszSPCFileName != wszEmpty)
        MyCoTaskMemFree(m_wszSPCFileName);
    if( (m_wszSPCFileName = CopyWideString(pwsz)) == NULL )
        hr = MY_HRESULT_FROM_WIN32(GetLastError());

    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_PVKFileNameWStr(
    /* [out] */ LPWSTR __RPC_FAR *szw) {

    HRESULT hr = S_OK;
    
    EnterCriticalSection(&m_csXEnroll);
    
    if( (*szw = CopyWideString(m_wszPVKFileName)) == NULL )
        hr = MY_HRESULT_FROM_WIN32(GetLastError());

    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_PVKFileNameWStr(
    /* [in] */ LPWSTR pwsz) {

    HRESULT hr = S_OK;
        
    if(pwsz == NULL)
        return(MY_HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
        
    EnterCriticalSection(&m_csXEnroll);
        
    if( m_wszPVKFileName != wszEmpty)
        MyCoTaskMemFree(m_wszPVKFileName);
    if( (m_wszPVKFileName = CopyWideString(pwsz)) == NULL )
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
    else
        m_dwGenKeyFlags |= CRYPT_EXPORTABLE; //why???

    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
  }

HRESULT STDMETHODCALLTYPE CCEnroll::get_HashAlgorithmWStr(
    /* [out] */ LPWSTR __RPC_FAR *ppwsz) {

    PCCRYPT_OID_INFO            pOidInfo        = NULL;
    ALG_ID                      rgAlg[2];
    HRESULT                     hr              = S_OK;

    EnterCriticalSection(&m_csXEnroll);

    assert(ppwsz != NULL);
    *ppwsz  = NULL;

    if( !GetCapiHashAndSigAlgId(rgAlg) )
        hr = MY_HRESULT_FROM_WIN32(GetLastError());

    // Convert to an oid
    else if( (NULL == (pOidInfo = xeCryptFindOIDInfo(
        CRYPT_OID_INFO_ALGID_KEY,
        (void *) &rgAlg[0],
        CRYPT_HASH_ALG_OID_GROUP_ID)) ) ) {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
    }

    else if( (*ppwsz = WideFromMB(pOidInfo->pszOID)) == NULL)
            hr = MY_HRESULT_FROM_WIN32(GetLastError());

    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_HashAlgorithmWStr(
    /* [in] */ LPWSTR pwsz) {

    HRESULT             hr          = S_OK;
    char *              szObjId     = NULL;
    PCCRYPT_OID_INFO    pOidInfo    = NULL;

    if(pwsz == NULL) {
        return(MY_HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    if(!_wcsicmp(L"SHA1", pwsz))
        szObjId = CopyAsciiString(szOID_OIWSEC_sha1);
    else if(!_wcsicmp(L"MD5", pwsz))
        szObjId = CopyAsciiString(szOID_RSA_MD5RSA);
    else if(!_wcsicmp(L"MD2", pwsz))
        szObjId = CopyAsciiString(szOID_RSA_MD2RSA);
    else
        szObjId = MBFromWide(pwsz);

    // something went wrong
    if(szObjId == NULL)
        return(MY_HRESULT_FROM_WIN32(GetLastError()));

    // find the hashing algid
    if( (NULL == (pOidInfo = xeCryptFindOIDInfo(
        CRYPT_OID_INFO_OID_KEY,
        szObjId,
        0)) ) )
    {
        //XIAOHS: CryptFindOIDInfo does not set the LastError in this case.
        //AV in xEnroll.  See bug# 189320
        //hr = MY_HRESULT_FROM_WIN32(GetLastError());
        hr=NTE_BAD_ALGID;
    }

    assert(szObjId != NULL);
    MyCoTaskMemFree(szObjId);

    EnterCriticalSection(&m_csXEnroll);

    if(hr == S_OK) {
        if( pOidInfo->dwGroupId == CRYPT_HASH_ALG_OID_GROUP_ID ||
            pOidInfo->dwGroupId == CRYPT_SIGN_ALG_OID_GROUP_ID )
            m_HashAlgId = pOidInfo->Algid;
        else
            hr = CRYPT_E_NOT_FOUND;
    }

    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_HashAlgID(
    LONG    hashAlgID
    ) {

    EnterCriticalSection(&m_csXEnroll);
    m_HashAlgId = hashAlgID;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_HashAlgID(
    LONG *   hashAlgID
    ) {
    EnterCriticalSection(&m_csXEnroll);
    *hashAlgID = m_HashAlgId;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_RenewalCertificate(
            /* [out] */ PCCERT_CONTEXT __RPC_FAR *ppCertContext) {

    HRESULT     hr      = S_OK;

    *ppCertContext = NULL;

    if( m_pCertContextRenewal == NULL)
        return(MY_HRESULT_FROM_WIN32(CRYPT_E_NOT_FOUND));

    EnterCriticalSection(&m_csXEnroll);
    if( NULL == (*ppCertContext = CertDuplicateCertificateContext(m_pCertContextRenewal)) )
        hr = MY_HRESULT_FROM_WIN32(GetLastError());

    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_RenewalCertificate(
            /* [in] */ PCCERT_CONTEXT pCertContext)
{
    HRESULT  hr;
    PCCERT_CONTEXT  pGoodCertContext= NULL;

    EnterCriticalSection(&m_csXEnroll);

    hr = GetGoodCertContext(pCertContext, &pGoodCertContext);
    if (S_OK != hr)
    {
        goto GetGoodCertContextError;
    }

    if(m_pCertContextRenewal != NULL)
    {
        CertFreeCertificateContext(m_pCertContextRenewal);
    }
    m_pCertContextRenewal = pGoodCertContext;

    hr = S_OK;
ErrorReturn:
    LeaveCriticalSection(&m_csXEnroll);
    return hr;

TRACE_ERROR(GetGoodCertContextError);
}

BOOL
CCEnroll::CopyAndPushStackExtension(
    PCERT_EXTENSION pExt,
    BOOL            fCMC)
{

    DWORD       cb              = 0;
    DWORD       cbOid           = 0;
    PEXT_STACK  pExtStackEle    = NULL;
    PBYTE       pb              = NULL;
    PEXT_STACK  *ppExtStack = NULL;
    DWORD       *pcExtStack = NULL;

    assert(pExt != NULL);

    // allocate the space
    cbOid = POINTERROUND((DWORD)strlen(pExt->pszObjId) + 1); //ia64 align
    cb = sizeof(EXT_STACK) + cbOid + pExt->Value.cbData;
    if(NULL == (pb = (PBYTE) malloc(cb))) {
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }

    // set my pointers
    pExtStackEle = (PEXT_STACK) pb;
    pb += sizeof(EXT_STACK);
    pExtStackEle->ext.pszObjId = (LPSTR) pb;
    pb += cbOid;
    pExtStackEle->ext.Value.pbData = pb;

    // set the values
    strcpy(pExtStackEle->ext.pszObjId, pExt->pszObjId);
    pExtStackEle->ext.fCritical     = pExt->fCritical;
    pExtStackEle->ext.Value.cbData  = pExt->Value.cbData;
    memcpy(pExtStackEle->ext.Value.pbData, pExt->Value.pbData, pExt->Value.cbData);

    // insert on the list
    EnterCriticalSection(&m_csXEnroll);
    
    ppExtStack = fCMC ? &m_pExtStackNew : &m_pExtStack;
    pcExtStack = fCMC ? &m_cExtStackNew : &m_cExtStack;
    pExtStackEle->pNext = *ppExtStack;
    *ppExtStack = pExtStackEle;
    (*pcExtStack)++;

    LeaveCriticalSection(&m_csXEnroll);

    return(TRUE);
}

PCERT_EXTENSION
CCEnroll::PopStackExtension(
    BOOL fCMC)
{

    PEXT_STACK  pExtStackEle = NULL;
    PEXT_STACK *ppExtStack = NULL;
    DWORD      *pcExtStack = NULL;

    EnterCriticalSection(&m_csXEnroll);

    ppExtStack = fCMC ? &m_pExtStackNew : &m_pExtStack;
    if(NULL != *ppExtStack)
    {
        pExtStackEle = *ppExtStack;
        *ppExtStack = (*ppExtStack)->pNext;
        pcExtStack = fCMC ? &m_cExtStackNew : &m_cExtStack;
        (*pcExtStack)--;
    }

    LeaveCriticalSection(&m_csXEnroll);

    return((PCERT_EXTENSION) pExtStackEle);
}

DWORD
CCEnroll::CountStackExtension(BOOL fCMC)
{
    DWORD   cExt = 0;

    EnterCriticalSection(&m_csXEnroll);
    cExt = fCMC ? m_cExtStackNew : m_cExtStack;
    LeaveCriticalSection(&m_csXEnroll);

    return(cExt);
}

PCERT_EXTENSION
CCEnroll::EnumStackExtension(
    PCERT_EXTENSION pExtLast,
    BOOL            fCMC)
{
    PEXT_STACK pExtStackEle    = (PEXT_STACK)pExtLast;

    EnterCriticalSection(&m_csXEnroll);

    if(NULL == pExtStackEle)
    {
        pExtStackEle = fCMC ? m_pExtStackNew : m_pExtStack;
    }
    else
    {
        pExtStackEle = pExtStackEle->pNext;
    }

    LeaveCriticalSection(&m_csXEnroll);

    return((PCERT_EXTENSION) pExtStackEle);
}

void
CCEnroll::FreeAllStackExtension(void)
{
    EnterCriticalSection(&m_csXEnroll);

    //free cmc extensions
    while(0 != m_cExtStackNew)
    {
        FreeStackExtension(PopStackExtension(TRUE));
    }

    //free old client extensions
    while(0 != m_cExtStack)
    {
        FreeStackExtension(PopStackExtension(FALSE));
    }

    LeaveCriticalSection(&m_csXEnroll);
}

void CCEnroll::FreeStackExtension(PCERT_EXTENSION pExt) {
    if(pExt != NULL)
        free(pExt);
}

//obselete call for new client
HRESULT STDMETHODCALLTYPE
CCEnroll::AddExtensionsToRequest(
    /* [in] */ PCERT_EXTENSIONS pCertExtensions)
{

    HRESULT hr  = S_OK;
    DWORD   i   = 0;

    assert(pCertExtensions != NULL);

    for(i = 0; i < pCertExtensions->cExtension; i++)
    {
        //push into old extension stack
        if(!CopyAndPushStackExtension(&pCertExtensions->rgExtension[i], FALSE))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            break;
        }
    }

    return(hr);
}

BOOL
CCEnroll::CopyAndPushStackAttribute(
    PCRYPT_ATTRIBUTE pAttr,
    BOOL             fCMC)
{
    DWORD       i               = 0;
    DWORD       cb              = 0;
    DWORD       cbOid           = 0;
    PATTR_STACK pAttrStackEle   = NULL;
    PBYTE       pb              = NULL;
    PATTR_STACK *ppAttrStack = NULL;
    DWORD       *pcAttrStack = NULL;

    assert(pAttr != NULL);

     // allocate the space
    cb = sizeof(ATTR_STACK);
    //make sure aligned for ia64
    cbOid = POINTERROUND((DWORD)strlen(pAttr->pszObjId) + 1);
    cb += cbOid;
    cb += sizeof(CRYPT_ATTR_BLOB) * pAttr->cValue;
    for(i=0; i<pAttr->cValue; i++)
        cb += POINTERROUND(pAttr->rgValue[i].cbData); //pointer align

    if(NULL == (pb = (PBYTE) malloc(cb))) {
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }

    // set my pointers
    pAttrStackEle = (PATTR_STACK) pb;
    pb += sizeof(ATTR_STACK);
    pAttrStackEle->attr.pszObjId = (LPSTR) pb;
    pb += cbOid;
    strcpy(pAttrStackEle->attr.pszObjId, pAttr->pszObjId);

    pAttrStackEle->attr.cValue = pAttr->cValue;
    pAttrStackEle->attr.rgValue = (PCRYPT_ATTR_BLOB) pb;
    pb += sizeof(CRYPT_ATTR_BLOB) * pAttr->cValue;
    for(i=0; i<pAttr->cValue; i++) {
        pAttrStackEle->attr.rgValue[i].pbData = pb;
        pAttrStackEle->attr.rgValue[i].cbData = pAttr->rgValue[i].cbData;
        memcpy(pAttrStackEle->attr.rgValue[i].pbData, pAttr->rgValue[i].pbData, pAttr->rgValue[i].cbData);
        pb += POINTERROUND(pAttr->rgValue[i].cbData);
    }
    assert( pb == ((BYTE *) pAttrStackEle) + cb );

    // insert on the list
    EnterCriticalSection(&m_csXEnroll);

    ppAttrStack = fCMC ? &m_pAttrStackNew : &m_pAttrStack;
    pcAttrStack = fCMC ? &m_cAttrStackNew : &m_cAttrStack;
    pAttrStackEle->pNext = *ppAttrStack;
    *ppAttrStack = pAttrStackEle;
    (*pcAttrStack)++;

    LeaveCriticalSection(&m_csXEnroll);

    return(TRUE);
}

PCRYPT_ATTRIBUTE
CCEnroll::PopStackAttribute(BOOL fCMC)
{
    PATTR_STACK pAttrStackEle = NULL;
    PATTR_STACK *ppAttrStack = NULL;
    DWORD       *pcAttrStack = NULL;

    EnterCriticalSection(&m_csXEnroll);

    ppAttrStack = fCMC ? &m_pAttrStackNew : &m_pAttrStack;

    if(NULL != *ppAttrStack)
    {
        pAttrStackEle = *ppAttrStack;
        *ppAttrStack = (*ppAttrStack)->pNext;
        pcAttrStack = fCMC ? &m_cAttrStackNew : &m_cAttrStack;
        (*pcAttrStack)--;
    }

    LeaveCriticalSection(&m_csXEnroll);

    return((PCRYPT_ATTRIBUTE) pAttrStackEle);
}

DWORD
CCEnroll::CountStackAttribute(BOOL fCMC)
{
    DWORD   cAttr = 0;

    EnterCriticalSection(&m_csXEnroll);
    cAttr = fCMC ? m_cAttrStackNew : m_cAttrStack;
    LeaveCriticalSection(&m_csXEnroll);

    return(cAttr);
}

PCRYPT_ATTRIBUTE
CCEnroll::EnumStackAttribute(
    PCRYPT_ATTRIBUTE pAttrLast,
    BOOL             fCMC)
{
    PATTR_STACK pAttrStackEle    = (PATTR_STACK) pAttrLast;

    EnterCriticalSection(&m_csXEnroll);

    if(NULL == pAttrLast)
    {
        pAttrStackEle = fCMC ? m_pAttrStackNew : m_pAttrStack;
    }
    else
    {
        pAttrStackEle = pAttrStackEle->pNext;
    }

    LeaveCriticalSection(&m_csXEnroll);

    return((PCRYPT_ATTRIBUTE) pAttrStackEle);
}

void CCEnroll::FreeAllStackAttribute(void)
{
    EnterCriticalSection(&m_csXEnroll);

    while(0 != m_cAttrStackNew)
    {
        FreeStackAttribute(PopStackAttribute(TRUE));
    }

    while(0 != m_cAttrStack)
    {
        FreeStackAttribute(PopStackAttribute(FALSE));
    }

    LeaveCriticalSection(&m_csXEnroll);
}

void CCEnroll::FreeStackAttribute(PCRYPT_ATTRIBUTE pAttr) {
    if(pAttr != NULL)
        free(pAttr);
}

HRESULT STDMETHODCALLTYPE
CCEnroll::AddAuthenticatedAttributesToPKCS7Request(
    /* [in] */ PCRYPT_ATTRIBUTES pAttributes)
{
    HRESULT hr = S_OK;
    DWORD i;

    for(i = 0; i < pAttributes->cAttr; i++)
    {
        if(!CopyAndPushStackAttribute(&pAttributes->rgAttr[i], FALSE))
        {
            hr = (MY_HRESULT_FROM_WIN32(GetLastError()));
            break;
        }
        //put into cmc stack too
        if(!CopyAndPushStackAttribute(&pAttributes->rgAttr[i], TRUE))
        {
            hr = (MY_HRESULT_FROM_WIN32(GetLastError()));
            break;
        }
    }

    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::CreatePKCS7RequestFromRequest(
    /* [in] */  PCRYPT_DATA_BLOB pRequest,
    /* [in] */  PCCERT_CONTEXT pSigningRACertContext,
    /* [out] */ PCRYPT_DATA_BLOB pPkcs7Blob) {

    HRESULT                     hr              = S_OK;
    DWORD                       errBefore       = GetLastError();
    CRYPT_SIGN_MESSAGE_PARA     signMsgPara;
    PCCRYPT_OID_INFO            pOidInfo        = NULL;
    PCRYPT_ATTRIBUTE            pAttrCur        = NULL;
    DWORD                       i;
    ALG_ID                      rgAlg[2];
    CRYPT_KEY_PROV_INFO *pKeyProvInfo = NULL;
    DWORD                cb = 0;

    assert(pSigningRACertContext != NULL);
    assert(pRequest != NULL);
    assert(pPkcs7Blob != NULL);

    memset(&signMsgPara, 0, sizeof(CRYPT_SIGN_MESSAGE_PARA));
    memset(pPkcs7Blob, 0, sizeof(CRYPT_DATA_BLOB));

    if( !GetCapiHashAndSigAlgId(rgAlg) )
        goto ErrorGetCapiHashAndSigAlgId;

    // find out what the oid is
    if( (NULL == (pOidInfo = xeCryptFindOIDInfo(
        CRYPT_OID_INFO_ALGID_KEY,
        (void *) &rgAlg[0],
        CRYPT_HASH_ALG_OID_GROUP_ID)) ) )
    {
        SetLastError((DWORD)NTE_BAD_ALGID);
        goto ErrorCryptFindOIDInfo;
    }

    // now add all of the user defined extensions
    EnterCriticalSection(&m_csXEnroll);
    signMsgPara.cAuthAttr = CountStackAttribute(m_fNewRequestMethod);

    signMsgPara.rgAuthAttr = (PCRYPT_ATTRIBUTE)LocalAlloc(LMEM_FIXED,
                    signMsgPara.cAuthAttr * sizeof(CRYPT_ATTRIBUTE));
    if( NULL == signMsgPara.rgAuthAttr)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        LeaveCriticalSection(&m_csXEnroll);
        goto ErrorOutOfMemory;
    }

    i = 0;
    pAttrCur = NULL;
    while(NULL != (pAttrCur = EnumStackAttribute(pAttrCur, m_fNewRequestMethod)) ) {
        signMsgPara.rgAuthAttr[i] = *pAttrCur;
        i++;
    }
    LeaveCriticalSection(&m_csXEnroll);

    signMsgPara.cbSize                  = sizeof(CRYPT_SIGN_MESSAGE_PARA);
    signMsgPara.dwMsgEncodingType       = PKCS_7_ASN_ENCODING;
    signMsgPara.pSigningCert            = pSigningRACertContext;
    signMsgPara.HashAlgorithm.pszObjId  = (char *) pOidInfo->pszOID;
    signMsgPara.cMsgCert                = 1;
    signMsgPara.rgpMsgCert              = &pSigningRACertContext;

    //get key prov info
    while (TRUE)
    {
        if(!CertGetCertificateContextProperty(
                pSigningRACertContext,
                CERT_KEY_PROV_INFO_PROP_ID,
                pKeyProvInfo,
                &cb))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto CertGetCertificateContextPropertyError;
        }
        if (NULL != pKeyProvInfo)
        {
            //got it, done
            break;
        }
        pKeyProvInfo = (CRYPT_KEY_PROV_INFO*)LocalAlloc(LMEM_FIXED, cb);
        if (NULL == pKeyProvInfo)
        {
            hr = E_OUTOFMEMORY;
            goto ErrorOutOfMemory;
        }
    }
    if (0x0 != (pKeyProvInfo->dwFlags & CRYPT_SILENT))
    {
        //have to set silent through msg param
        signMsgPara.dwFlags |= CRYPT_MESSAGE_SILENT_KEYSET_FLAG;
    }


    if( !CryptSignMessage(
        &signMsgPara,
        FALSE,
        1,
        (const BYTE **) &pRequest->pbData,
        &pRequest->cbData ,
        NULL,
        &pPkcs7Blob->cbData)                          ||
    (pPkcs7Blob->pbData = (BYTE *)
        MyCoTaskMemAlloc(pPkcs7Blob->cbData)) == NULL ||
    !CryptSignMessage(
        &signMsgPara,
        FALSE,
        1,
        (const BYTE **) &pRequest->pbData,
        &pRequest->cbData ,
        pPkcs7Blob->pbData,
        &pPkcs7Blob->cbData) )
        goto ErrorCryptSignMessage;

CommonReturn:
    if (NULL != pKeyProvInfo)
    {
        LocalFree(pKeyProvInfo);
    }
    if (NULL != signMsgPara.rgAuthAttr)
    {
        LocalFree(signMsgPara.rgAuthAttr);
    }

    // don't know if we have an error or not
    // but I do know the errBefore is set properly
    SetLastError(errBefore);
    return(hr);

ErrorReturn:

    if(GetLastError() == ERROR_SUCCESS)
        SetLastError((DWORD)E_UNEXPECTED);
    hr = MY_HRESULT_FROM_WIN32(GetLastError());

    // We have an error, make sure we set it.
    errBefore = GetLastError();


    // on error return a NULL
    if(pPkcs7Blob->pbData != NULL)
        MyCoTaskMemFree(pPkcs7Blob->pbData);
    memset(pPkcs7Blob, 0, sizeof(CRYPT_DATA_BLOB));

    goto CommonReturn;

TRACE_ERROR(ErrorGetCapiHashAndSigAlgId);
TRACE_ERROR(ErrorCryptSignMessage);
TRACE_ERROR(ErrorCryptFindOIDInfo);
TRACE_ERROR(ErrorOutOfMemory);
TRACE_ERROR(CertGetCertificateContextPropertyError)
}

HRESULT STDMETHODCALLTYPE
CCEnroll::AddNameValuePairToSignatureWStr(
    /* [in] */ LPWSTR pwszName,
    /* [in] */ LPWSTR pwszValue)
{
    HRESULT hr = S_OK;

    assert(pwszName != NULL && pwszValue != NULL);

    CRYPT_ENROLLMENT_NAME_VALUE_PAIR nameValuePair = {pwszName, pwszValue};
    CRYPT_ATTR_BLOB blobAttr;
    CRYPT_ATTRIBUTE attr = {szOID_ENROLLMENT_NAME_VALUE_PAIR, 1, &blobAttr};
    CRYPT_ATTRIBUTES attrs = {1, &attr};

    memset(&blobAttr, 0, sizeof(CRYPT_ATTR_BLOB));

    hr = xeEncodeNameValuePair(
                &nameValuePair,
                &blobAttr.pbData,
                &blobAttr.cbData);
    if (S_OK != hr)
    {
        goto error;
    }

    hr = AddAuthenticatedAttributesToPKCS7Request(&attrs);

error:
    if (NULL != blobAttr.pbData)
    {
        MyCoTaskMemFree(blobAttr.pbData);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE CCEnroll::AddCertTypeToRequestWStr(
            LPWSTR szw) {

    HRESULT                     hr              = S_OK;
    DWORD                       errBefore       = GetLastError();

    CERT_NAME_VALUE  nameValue;
    CERT_EXTENSION  ext;
    CERT_EXTENSIONS exts = {1, &ext};

    memset(&ext, 0, sizeof(CERT_EXTENSION));

    nameValue.dwValueType = CERT_RDN_BMP_STRING;
    nameValue.Value.cbData = 0;
    nameValue.Value.pbData = (PBYTE) szw;

    ext.pszObjId = szOID_ENROLL_CERTTYPE_EXTENSION;

    if( !CryptEncodeObject(
            CRYPT_ASN_ENCODING,
            X509_UNICODE_ANY_STRING,
            &nameValue,
            NULL,
            &ext.Value.cbData
            ) )
        goto ErrorCryptEncodeObject;

    ext.Value.pbData = (PBYTE)LocalAlloc(LMEM_FIXED, ext.Value.cbData);
    if(NULL == ext.Value.pbData)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto ErrorOutOfMemory;
    }

    if( !CryptEncodeObject(
            CRYPT_ASN_ENCODING,
            X509_UNICODE_ANY_STRING,
            &nameValue,
            ext.Value.pbData,
            &ext.Value.cbData
            ) )
        goto ErrorCryptEncodeObject;

    if(S_OK != AddExtensionsToRequest(&exts))
        goto ErrorAddExtensionsToRequest;

    //put cert template extension into CMC stack
    if(!CopyAndPushStackExtension(&ext, TRUE))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto CopyAndPushStackExtensionError;
    }

CommonReturn:
    if (NULL != ext.Value.pbData)
    {
        LocalFree(ext.Value.pbData);
    }

    // don't know if we have an error or not
    // but I do know the errBefore is set properly
    SetLastError(errBefore);
    return(hr);

ErrorReturn:
    if(GetLastError() == ERROR_SUCCESS)
        SetLastError((DWORD)E_UNEXPECTED);
    hr = MY_HRESULT_FROM_WIN32(GetLastError());

    // We have an error, make sure we set it.
    errBefore = GetLastError();

    goto CommonReturn;

TRACE_ERROR(ErrorCryptEncodeObject);
TRACE_ERROR(ErrorAddExtensionsToRequest);
TRACE_ERROR(ErrorOutOfMemory);
TRACE_ERROR(CopyAndPushStackExtensionError);
}


HRESULT STDMETHODCALLTYPE CCEnroll::AddCertTypeToRequestWStrEx(
            IN  LONG            lType,
            IN  LPCWSTR         pwszOIDOrName,
            IN  LONG            lMajorVersion,
            IN  BOOL            fMinorVersion,
            IN  LONG            lMinorVersion)
{
    HRESULT hr;
    LPCSTR            lpszStructType;
    CERT_NAME_VALUE   nameValue;
    CERT_TEMPLATE_EXT Template;
    VOID             *pv;
    CERT_EXTENSION    ext; //free pbData
    DWORD             cb = 0;
    CHAR             *pszOID = NULL;

    //init
    ZeroMemory(&ext, sizeof(ext));
    ext.fCritical = FALSE;

    if (NULL == pwszOIDOrName)
    {
        hr = E_INVALIDARG;
        goto InvalidArgError;
    }

    switch (lType)
    {
        case XECT_EXTENSION_V1:
            ext.pszObjId = szOID_ENROLL_CERTTYPE_EXTENSION;
            nameValue.dwValueType = CERT_RDN_BMP_STRING;
            nameValue.Value.cbData = 0;
            nameValue.Value.pbData = (BYTE*)pwszOIDOrName;
            pv = (VOID*)&nameValue;
            lpszStructType = X509_UNICODE_ANY_STRING;
        break;
        case XECT_EXTENSION_V2:
            ext.pszObjId = szOID_CERTIFICATE_TEMPLATE;
            //convert wsz OID to ansi
            while (TRUE)
            {
                cb = WideCharToMultiByte(
                            GetACP(),
                            0,
                            pwszOIDOrName,
                            -1,
                            pszOID,
                            cb,
                            NULL,
                            NULL);
                if (0 == cb)
                {
                    hr = MY_HRESULT_FROM_WIN32(GetLastError());
                    goto WideCharToMultiByteError;
                }
                if (NULL != pszOID)
                {
                    //done
                    break;
                }
                pszOID = (CHAR*)LocalAlloc(LMEM_FIXED, cb);
                if (NULL == pszOID)
                {
                    hr = E_OUTOFMEMORY;
                    goto OutOfMemoryError;
                }
            }

            ZeroMemory(&Template, sizeof(Template));
            Template.pszObjId = pszOID;
            Template.dwMajorVersion = lMajorVersion;
            Template.fMinorVersion =  fMinorVersion;
            Template.dwMinorVersion = lMinorVersion;
            pv = (VOID*)&Template;
            lpszStructType = X509_CERTIFICATE_TEMPLATE;
        break;
        default:
            hr = E_INVALIDARG;
            goto InvalidArgError;
        break;
    }

    while (TRUE)
    {
        if (!CryptEncodeObject(
                    X509_ASN_ENCODING,
                    lpszStructType,
                    pv,
                    ext.Value.pbData,
                    &ext.Value.cbData))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto CryptEncodeObjectError;
        }
        if (NULL != ext.Value.pbData)
        {
            //done
            break;
        }
        ext.Value.pbData = (BYTE*)LocalAlloc(LMEM_FIXED, ext.Value.cbData);
        if (NULL == ext.Value.pbData)
        {
            hr = E_OUTOFMEMORY;
            goto OutOfMemoryError;
        }
    }

    //put cert template extension into CMC stack
    if(!CopyAndPushStackExtension(&ext, TRUE))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto CopyAndPushStackExtensionError;
    }

    hr = S_OK;
ErrorReturn:
    if (NULL != pszOID)
    {
        LocalFree(pszOID);
    }
    if (NULL != ext.Value.pbData)
    {
        LocalFree(ext.Value.pbData);
    }
    return hr;

TRACE_ERROR(InvalidArgError)
TRACE_ERROR(CopyAndPushStackExtensionError)
TRACE_ERROR(OutOfMemoryError)
TRACE_ERROR(CryptEncodeObjectError)
TRACE_ERROR(WideCharToMultiByteError)
}

HRESULT STDMETHODCALLTYPE CCEnroll::getProviderTypeWStr( 
    IN  LPCWSTR  pwszProvName,
    OUT LONG *   plProvType)
{
    HRESULT  hr;
    DWORD    i = 0;
    DWORD    cb;
    DWORD    dwProvType;
    WCHAR   *pwszEnumProvName = NULL;

    if (NULL == pwszProvName)
    {
        hr = E_INVALIDARG;
        goto InvalidArgError;
    }

    //init
    *plProvType = -1;

    while (TRUE)
    {
        while (TRUE)
        {
            if (!CryptEnumProvidersU(
                    i,
                    NULL,
                    0,
                    &dwProvType,
                    pwszEnumProvName,
                    &cb))
            {
                hr = MY_HRESULT_FROM_WIN32(GetLastError());
                if (MY_HRESULT_FROM_WIN32(NTE_PROV_TYPE_ENTRY_BAD) == hr)
                {
                    //skip bad one and goto next
                    assert(NULL == pwszEnumProvName);
                    break; //skip this one
                }
                //error
                goto CryptEnumProvidersUError;
            }
            if (NULL != pwszEnumProvName)
            {
                //get the current csp name
                break;
            }
            pwszEnumProvName = (WCHAR*)LocalAlloc(LMEM_FIXED, cb);
            if (NULL == pwszEnumProvName)
            {
                hr = E_OUTOFMEMORY;
                goto OutOfMemoryError;
            }
        }
        if (NULL != pwszEnumProvName)
        {
            if (0 == _wcsicmp(pwszProvName, pwszEnumProvName))
            {
                //found matched name
                *plProvType = (LONG)dwProvType;
                break; //out of outer loop
            }
        }
        //not mached, go to next one
        ++i;
        if (NULL != pwszEnumProvName)
        {
            LocalFree(pwszEnumProvName);
            pwszEnumProvName = NULL;
        }
    }

    hr = S_OK;
ErrorReturn:
    if (NULL != pwszEnumProvName)
    {
        LocalFree(pwszEnumProvName);
    }
    return hr;

TRACE_ERROR(InvalidArgError)
TRACE_ERROR(OutOfMemoryError)
TRACE_ERROR(CryptEnumProvidersUError)
}

HRESULT STDMETHODCALLTYPE CCEnroll::InstallPKCS7Blob( 
    /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7)
{
    return InstallPKCS7BlobEx(pBlobPKCS7, NULL);
}

HRESULT CCEnroll::InstallPKCS7BlobEx( 
    /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7,
    /* [out] */ LONG           *plCertInstalled)
{

    HRESULT                     hr                      = S_OK;
    DWORD                       errBefore               = GetLastError();
    HCERTSTORE                  hStoreMsg               = NULL;
    LPWSTR                      pwszTitle               = NULL; 
    LPWSTR                      pwszNotSafeAccepting    = NULL; 
 
    EnterCriticalSection(&m_csXEnroll);

    // Accepting a request is not safe for scripting:  pop up a warning dialog if called from script
    if (0 != m_dwEnabledSafteyOptions) { 
	hr = xeLoadRCString(hInstanceXEnroll, IDS_NOTSAFEACTION, &pwszTitle);
	if (S_OK != hr) { 
	    SetLastError(hr); 
	    goto xeLoadRCStringError;
	}
	
	hr = xeLoadRCString(hInstanceXEnroll, IDS_NOTSAFE_ACCEPTING_CERT, &pwszNotSafeAccepting);
	if (S_OK != hr) { 
	    SetLastError(hr); 
	    goto xeLoadRCStringError;
	}
	
	if (IDYES != MessageBoxU(NULL, pwszNotSafeAccepting, pwszTitle, MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2)) { 
	    hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
	    SetLastError(hr); 
	    goto CancelledError; 
	}
    }

    if( !MyCryptQueryObject(CERT_QUERY_OBJECT_BLOB,
                       pBlobPKCS7,
                       (CERT_QUERY_CONTENT_FLAG_CERT |
                       CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED |
                       CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE |
                       CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED) ,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       NULL,
                       NULL,
                       &hStoreMsg,
                       NULL,
                       NULL) )
        goto ErrorCryptQueryObject;

    hr = AddCertsToStores(hStoreMsg, plCertInstalled);
    //don't treat cancel as error but return the err code
    if (S_OK != hr && MY_HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr)
    {
        goto ErrorAddCertsToStores;
    }

CommonReturn:

    if(hStoreMsg != NULL)
        CertCloseStore(hStoreMsg, 0);
    if (NULL != pwszNotSafeAccepting)
	LocalFree(pwszNotSafeAccepting);
    if (NULL != pwszTitle)
	LocalFree(pwszTitle);

    // don't know if we have an error or not
    // but I do know the errBefore is set properly
    SetLastError(errBefore);
    LeaveCriticalSection(&m_csXEnroll);

    return(hr);

ErrorReturn:

    if(GetLastError() == ERROR_SUCCESS)
        SetLastError((DWORD)E_UNEXPECTED);
    hr = MY_HRESULT_FROM_WIN32(GetLastError());

    // We have an error, make sure we set it.
    errBefore = GetLastError();

    goto CommonReturn;

TRACE_ERROR(ErrorCryptQueryObject);
TRACE_ERROR(ErrorAddCertsToStores);
TRACE_ERROR(CancelledError);
TRACE_ERROR(xeLoadRCStringError);
}

HRESULT STDMETHODCALLTYPE CCEnroll::InstallPKCS7( 
    /* [in] */ BSTR wszPKCS7)
{
    CRYPT_DATA_BLOB             blobPKCS7;

    assert(wszPKCS7 != NULL);

    // just put into a blob
    memset(&blobPKCS7, 0, sizeof(CRYPT_DATA_BLOB));
    blobPKCS7.cbData = SysStringByteLen(wszPKCS7);
    blobPKCS7.pbData = (PBYTE) wszPKCS7;

    // install the blob
    return(InstallPKCS7Blob(&blobPKCS7));
}

HRESULT STDMETHODCALLTYPE CCEnroll::InstallPKCS7Ex( 
    /* [in] */ BSTR   wszPKCS7,
    /* [out] */ LONG __RPC_FAR *plCertInstalled)
{
    CRYPT_DATA_BLOB             blobPKCS7;

    assert(wszPKCS7 != NULL);

    // just put into a blob
    memset(&blobPKCS7, 0, sizeof(CRYPT_DATA_BLOB));
    blobPKCS7.cbData = SysStringByteLen(wszPKCS7);
    blobPKCS7.pbData = (PBYTE) wszPKCS7;

    // install the blob
    return(InstallPKCS7BlobEx(&blobPKCS7, plCertInstalled));
}


// this is a scary routine. Put in for louis, use at your own risk.
HRESULT STDMETHODCALLTYPE CCEnroll::Reset(void)
{
    HRESULT hr;

    EnterCriticalSection(&m_csXEnroll);
    Destruct();
    hr = Init();
    LeaveCriticalSection(&m_csXEnroll);

    return hr;
}

HRESULT STDMETHODCALLTYPE CCEnroll::GetSupportedKeySpec(
    LONG __RPC_FAR *pdwKeySpec) {

    DWORD               errBefore   = GetLastError();
    DWORD               hr          = S_OK;
    DWORD               cb          = sizeof(DWORD);

    SetLastError(ERROR_SUCCESS);

    assert(pdwKeySpec != NULL);
    *pdwKeySpec = 0;

    EnterCriticalSection(&m_csXEnroll);

    hr = GetVerifyProv();
    if (S_OK != hr)
    {
        goto GetVerifyProvError;
    }

    if( !CryptGetProvParam(
            m_hVerifyProv,
            PP_KEYSPEC,
            (BYTE *) pdwKeySpec,
            &cb,
            0
            ) ) 
        goto ErrorCryptGetProvParam;

CommonReturn:

    SetLastError(errBefore);

    LeaveCriticalSection(&m_csXEnroll);
    return(hr);

ErrorReturn:

    if(GetLastError() == ERROR_SUCCESS)
        SetLastError((DWORD)E_UNEXPECTED);
 
    // We have an error, make sure we set it.
    errBefore = GetLastError();

    goto CommonReturn;

TRACE_ERROR(ErrorCryptGetProvParam);
TRACE_ERROR(GetVerifyProvError);
}

HRESULT STDMETHODCALLTYPE CCEnroll::GetKeyLenEx(
    LONG    lSizeSpec,
    LONG    lKeySpec,
    LONG __RPC_FAR *pdwKeySize)
{
    BOOL        fKeyX;
    BOOL        fKeyInc = FALSE;
    DWORD       dwKeySize = 0xFFFFFFFF;
    DWORD       cb;
    HRESULT     hr = S_OK;

    EnterCriticalSection(&m_csXEnroll);

    switch (lKeySpec)
    {
        case XEKL_KEYSPEC_KEYX:
            fKeyX = TRUE;
            break;
        case XEKL_KEYSPEC_SIG:
            fKeyX = FALSE;
            break;
        default:
            //invalid parameter
            hr = E_INVALIDARG;
            goto InvalidArgError;
    }

    switch (lSizeSpec)
    {
        case XEKL_KEYSIZE_MIN:
        case XEKL_KEYSIZE_MAX:
        case XEKL_KEYSIZE_DEFAULT:
            break;
        case XEKL_KEYSIZE_INC:
            fKeyInc = TRUE;
            break;
        default:
            //invalid parameter
            hr = E_INVALIDARG;
            goto InvalidArgError;
    }

    if (!fKeyInc)
    {
        DWORD dwAlg = (fKeyX ? ALG_CLASS_KEY_EXCHANGE : ALG_CLASS_SIGNATURE);

        *pdwKeySize = GetKeySizeInfo(lSizeSpec, dwAlg);
    
        if(0xFFFFFFFF == *pdwKeySize)
        {
            *pdwKeySize = 0;
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto GetKeySizeInfoError;
        }
    }
    else
    {
        if ((fKeyX && (0 != m_dwXhgKeyLenInc)) ||
            (!fKeyX && (0 != m_dwSigKeyLenInc)))
        {
            //we got the cached inc size
            if (fKeyX)
            {
                *pdwKeySize = m_dwXhgKeyLenInc;
            }
            else
            {
                *pdwKeySize = m_dwSigKeyLenInc;
            }
        }
        else
        {
            hr = GetVerifyProv();
            if (S_OK != hr)
            {
                goto GetVerifyProvError;
            }

            //init
            *pdwKeySize = 0;
            cb = sizeof(dwKeySize);
            if (!CryptGetProvParam(
                    m_hVerifyProv,
                    fKeyX ? PP_KEYX_KEYSIZE_INC : PP_SIG_KEYSIZE_INC,
                    (BYTE*)&dwKeySize,
                    &cb,
                    0))
            {
                hr = MY_HRESULT_FROM_WIN32(GetLastError());
                goto CryptGetProvParamError;
            }            
            else
            {
                *pdwKeySize = dwKeySize;
                //cache it
                if (fKeyX)
                {
                    m_dwXhgKeyLenInc = dwKeySize;
                }
                else
                {
                    m_dwSigKeyLenInc = dwKeySize;
                }
            }
        }
    }

ErrorReturn:
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);

TRACE_ERROR(GetVerifyProvError);
TRACE_ERROR(CryptGetProvParamError)
TRACE_ERROR(InvalidArgError)
TRACE_ERROR(GetKeySizeInfoError)
}

HRESULT STDMETHODCALLTYPE CCEnroll::GetKeyLen(
    BOOL    fMin,
    BOOL    fExchange,
    LONG __RPC_FAR *pdwKeySize) {

    DWORD   hr = S_OK;
    LONG    lKeySizeSpec = (fMin ? XEKL_KEYSIZE_MIN : XEKL_KEYSIZE_MAX);

    if(fExchange)
        *pdwKeySize = GetKeySizeInfo(lKeySizeSpec, ALG_CLASS_KEY_EXCHANGE);
    else
        *pdwKeySize = GetKeySizeInfo(lKeySizeSpec, ALG_CLASS_SIGNATURE);
    
    if(*pdwKeySize == 0xFFFFFFFF) {
        *pdwKeySize = 0;
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
    }

    return(hr);
}

DWORD CCEnroll::GetKeySizeInfo(
    LONG    lKeySizeSpec,
    DWORD   algClass) {

    DWORD               cb = sizeof(PROV_ENUMALGS_EX);
    HRESULT             hr = S_OK;
    DWORD               errBefore   = GetLastError();
    DWORD               dwFlags     = CRYPT_FIRST;
    PROV_ENUMALGS_EX    algInfo;
    DWORD               dwKeySize   = 0xFFFFFFFF;
    DWORD               err         = ERROR_SUCCESS;

#ifdef DBG
    //only accept two flags
    assert(ALG_CLASS_KEY_EXCHANGE == algClass ||
           ALG_CLASS_SIGNATURE == algClass);
#endif //DBG

    SetLastError(ERROR_SUCCESS);

    memset(&algInfo, 0, sizeof(algInfo));

    EnterCriticalSection(&m_csXEnroll);

    if ((ALG_CLASS_KEY_EXCHANGE == algClass && 0 != m_dwXhgKeyLenMax) ||
        (ALG_CLASS_SIGNATURE == algClass && 0 != m_dwSigKeyLenMax))
    {
        //got cached sizes, use only KeyLenMax as check
#if DBG
        if (ALG_CLASS_KEY_EXCHANGE == algClass)
        {
            assert(0 != m_dwXhgKeyLenMin);
            assert(0 != m_dwXhgKeyLenDef);
        }
        if (ALG_CLASS_SIGNATURE == algClass)
        {
            assert(0 != m_dwSigKeyLenMin);
            assert(0 != m_dwSigKeyLenDef);
        }
#endif //DBG
        //OK, cached, easy
    }
    else
    {
#if DBG
        if (ALG_CLASS_KEY_EXCHANGE == algClass)
        {
            assert(0 == m_dwXhgKeyLenMin);
            assert(0 == m_dwXhgKeyLenDef);
        }
        if (ALG_CLASS_SIGNATURE == algClass)
        {
            assert(0 == m_dwSigKeyLenMin);
            assert(0 == m_dwSigKeyLenDef);
        }
#endif //DBG
        hr = GetVerifyProv();
        if (S_OK != hr)
        {
            goto GetVerifyProvError;
        }

        while (CryptGetProvParam(
                m_hVerifyProv,
                PP_ENUMALGS_EX,
                (BYTE *) &algInfo,
                &cb,
                dwFlags))
        {
            // get rid of CRYPT_FIRST flag
            dwFlags = 0;

            if (ALG_CLASS_KEY_EXCHANGE == GET_ALG_CLASS(algInfo.aiAlgid))
            {
                //cache them
                m_dwXhgKeyLenMax = algInfo.dwMaxLen;
                m_dwXhgKeyLenMin = algInfo.dwMinLen;
                m_dwXhgKeyLenDef = algInfo.dwDefaultLen;
            }
            else if (ALG_CLASS_SIGNATURE == GET_ALG_CLASS(algInfo.aiAlgid))
            {
                m_dwSigKeyLenMax = algInfo.dwMaxLen;
                m_dwSigKeyLenMin = algInfo.dwMinLen;
                m_dwSigKeyLenDef = algInfo.dwDefaultLen;
            }

            //see if we cache all sizes through single enum loop
            if (0 != m_dwXhgKeyLenMax &&
                0 != m_dwXhgKeyLenMin &&
                0 != m_dwXhgKeyLenDef &&
                0 != m_dwSigKeyLenMax &&
                0 != m_dwSigKeyLenMin &&
                0 != m_dwSigKeyLenDef)
            {
                //looks we cached all
                break;
            }
        }
    }

    // if we got here,
    // either PP_ENUMALGS_EX is not supported by CSP , should return error
    // or csp doesn't support specified algorithm, should ERROR_NO_MORE_ITEMS

    err = GetLastError();

    if (err != ERROR_SUCCESS)
    {
        if (err != ERROR_NO_MORE_ITEMS) 
        {
            goto ErrorCryptGetProvParam;
        }
        // should be ERROR_NO_MORE_ITEMS
        if ((ALG_CLASS_KEY_EXCHANGE == algClass && 0 != m_dwXhgKeyLenMax) ||
            (ALG_CLASS_SIGNATURE == algClass && 0 != m_dwSigKeyLenMax))
        {
            //we may get here because the csp is signature or exchange only
            //so we cannot cache both once
            SetLastError(ERROR_SUCCESS);
        }
        else
        {
            SetLastError((DWORD)NTE_BAD_ALGID);
        }
    }
            
    //should have all sizes
    if(XEKL_KEYSIZE_MIN == lKeySizeSpec)
    {
        if (ALG_CLASS_KEY_EXCHANGE == algClass)
        {
            dwKeySize = m_dwXhgKeyLenMin;
        }
        else
        {
            dwKeySize = m_dwSigKeyLenMin;
        }
    }
    else if (XEKL_KEYSIZE_MAX == lKeySizeSpec)
    {
        if (ALG_CLASS_KEY_EXCHANGE == algClass)
        {
            dwKeySize = m_dwXhgKeyLenMax;
        }
        else
        {
            dwKeySize = m_dwSigKeyLenMax;
        }
    }
    else if (XEKL_KEYSIZE_DEFAULT == lKeySizeSpec)
    {
        if (ALG_CLASS_KEY_EXCHANGE == algClass)
        {
            dwKeySize = m_dwXhgKeyLenDef;
        }
        else
        {
            dwKeySize = m_dwSigKeyLenDef;
        }
    }

CommonReturn:

    SetLastError(errBefore);

    LeaveCriticalSection(&m_csXEnroll);
    return(dwKeySize);

ErrorReturn:

    if(GetLastError() == ERROR_SUCCESS)
        SetLastError((DWORD)E_UNEXPECTED);
 
    // We have an error, make sure we set it.
    errBefore = GetLastError();

    goto CommonReturn;

TRACE_ERROR(GetVerifyProvError);
TRACE_ERROR(ErrorCryptGetProvParam);
}


HRESULT STDMETHODCALLTYPE CCEnroll::EnumAlgs(
    /* [in] */ LONG  dwIndex,
    /* [in] */ LONG  algMask,
    /* [out] */ LONG  __RPC_FAR *pdwAlgID) {

    DWORD           errBefore   = GetLastError();
    PROV_ENUMALGS       enumAlgs;
    DWORD           cb          = sizeof(enumAlgs);
    LONG            i           = 0;
    HRESULT         hr          = S_OK;
    DWORD           dwFlags;
    BOOL            f1st = TRUE;

    SetLastError(ERROR_SUCCESS);

    memset(&enumAlgs, 0, sizeof(enumAlgs));
    assert(pdwAlgID != NULL);
    *pdwAlgID = 0;

    EnterCriticalSection(&m_csXEnroll);

    hr = GetVerifyProv();
    if (S_OK != hr)
    {
        goto GetVerifyProvError;
    }

    if (MAXDWORD != m_dwLastAlgIndex &&
        ((DWORD)dwIndex) == m_dwLastAlgIndex + 1)
    {
        //continue enum
        dwFlags = 0;
        while (f1st || (DWORD)algMask != GET_ALG_CLASS(enumAlgs.aiAlgid))
        {
            if(!CryptGetProvParam(
                        m_hVerifyProv,
                        PP_ENUMALGS,
                        (BYTE*)&enumAlgs,
                        &cb,
                        dwFlags))
            {
                goto ErrorCryptGetProvParam;
            }
            f1st = FALSE;
        }
    }
    else
    {
        dwFlags = CRYPT_FIRST;
        for (i = 0; i <= dwIndex; i++)
        {
            if(!CryptGetProvParam(
                   m_hVerifyProv,
                   PP_ENUMALGS,
                   (BYTE*)&enumAlgs,
                   &cb,
                   dwFlags))
            {
                    goto ErrorCryptGetProvParam;
            }
            dwFlags = 0; 

            // if we have not hit something we are counting, do it again
            if ((DWORD)algMask != GET_ALG_CLASS(enumAlgs.aiAlgid)) 
            {
                i--;
            }
        }
    }
    //update cached index
    m_dwLastAlgIndex = dwIndex;

    *pdwAlgID = enumAlgs.aiAlgid;
    
CommonReturn:
    SetLastError(errBefore);

    LeaveCriticalSection(&m_csXEnroll);
    return(hr);

ErrorReturn:

    if(GetLastError() == ERROR_SUCCESS)
        SetLastError((DWORD)E_UNEXPECTED);
    hr = MY_HRESULT_FROM_WIN32(GetLastError());

    // We have an error, make sure we set it.
    errBefore = GetLastError();

    //error, reset index
    m_dwLastAlgIndex = MAXDWORD;

    goto CommonReturn;

TRACE_ERROR(GetVerifyProvError);
TRACE_ERROR(ErrorCryptGetProvParam);
}


HRESULT STDMETHODCALLTYPE CCEnroll::GetAlgNameWStr(
    /* [in] */ LONG               algID,
    /* [out] */ LPWSTR __RPC_FAR *ppwsz) {

    DWORD           errBefore   = GetLastError();
    PROV_ENUMALGS       enumAlgs;
    DWORD           cb          = sizeof(enumAlgs);
    HRESULT         hr          = S_OK;
    DWORD           dwFlags     = CRYPT_FIRST;

    SetLastError(ERROR_SUCCESS);

    memset(&enumAlgs, 0, sizeof(enumAlgs));
    
    EnterCriticalSection(&m_csXEnroll);

    hr = GetVerifyProv();
    if (S_OK != hr)
    {
        goto GetVerifyProvError;
    }

    do {
   
        if( !CryptGetProvParam(
            m_hVerifyProv,
            PP_ENUMALGS,
            (BYTE *) &enumAlgs,
            &cb,
            dwFlags) )
            goto ErrorCryptGetProvParam;

        dwFlags = 0; 
        
   } while((DWORD)algID != enumAlgs.aiAlgid);

   if( (*ppwsz = WideFromMB(enumAlgs.szName)) == NULL )
        goto ErrorOutOfMem;
    
CommonReturn:

    SetLastError(errBefore);

    LeaveCriticalSection(&m_csXEnroll);
    return(hr);

ErrorReturn:

    if(GetLastError() == ERROR_SUCCESS)
        SetLastError((DWORD)E_UNEXPECTED);
    hr = MY_HRESULT_FROM_WIN32(GetLastError());

    // We have an error, make sure we set it.
    errBefore = GetLastError();

    goto CommonReturn;

TRACE_ERROR(GetVerifyProvError);
TRACE_ERROR(ErrorCryptGetProvParam);
TRACE_ERROR(ErrorOutOfMem);
}

HRESULT STDMETHODCALLTYPE CCEnroll::GetAlgName(
            /* [in] */ LONG                     algID,
            /* [out][retval] */ BSTR __RPC_FAR *pbstr) {

    DWORD       errBefore   = GetLastError();
    LPWSTR      pwsz        = NULL;
    HRESULT     hr          = S_OK;

    SetLastError(ERROR_SUCCESS);

    assert(pbstr != NULL);

    if((hr = GetAlgNameWStr(algID, &pwsz)) != S_OK)
        goto ErrorgetAlgNameWStr;

    if( (*pbstr = SysAllocString(pwsz)) == NULL )
        goto ErrorSysAllocString;

CommonReturn:

    if(pwsz != NULL)
        MyCoTaskMemFree(pwsz);

    SetLastError(errBefore);
    return(hr);

ErrorReturn:

    if(GetLastError() == ERROR_SUCCESS)
        SetLastError((DWORD)E_UNEXPECTED);
    hr = MY_HRESULT_FROM_WIN32(GetLastError());

    // We have an error, make sure we set it.
    errBefore = GetLastError();

    goto CommonReturn;

TRACE_ERROR(ErrorgetAlgNameWStr);
TRACE_ERROR(ErrorSysAllocString);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_ReuseHardwareKeyIfUnableToGenNew(
    /* [retval][out] */ BOOL __RPC_FAR *fBool) {

    EnterCriticalSection(&m_csXEnroll);
    *fBool = m_fReuseHardwareKeyIfUnableToGenNew;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_ReuseHardwareKeyIfUnableToGenNew(
    /* [in] */ BOOL fBool) {
    EnterCriticalSection(&m_csXEnroll);
    m_fReuseHardwareKeyIfUnableToGenNew = fBool;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::SetHStoreMy(
    HCERTSTORE   hStore
    ) {
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_csXEnroll);

    if(m_MyStore.hStore != NULL)
        hr = E_ACCESSDENIED;
        
    else {
        if(m_MyStore.wszName != wszMY)
            MyCoTaskMemFree(m_MyStore.wszName);
            
        m_MyStore.wszName = NULL;
        m_MyStore.hStore = CertDuplicateStore(hStore);
    }

    LeaveCriticalSection(&m_csXEnroll);
    
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::SetHStoreCA(
    HCERTSTORE   hStore
    ) {
    HRESULT hr = S_OK;
    
    EnterCriticalSection(&m_csXEnroll);
    
    if(m_CAStore.hStore != NULL)
        hr = E_ACCESSDENIED;
    else {
        if(m_CAStore.wszName != wszCA)
            MyCoTaskMemFree(m_CAStore.wszName);
            
        m_CAStore.wszName = NULL;
        m_CAStore.hStore = CertDuplicateStore(hStore);
    }

    LeaveCriticalSection(&m_csXEnroll);

    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::SetHStoreROOT(
    HCERTSTORE   hStore
    ) {
    HRESULT hr = S_OK;
    
    EnterCriticalSection(&m_csXEnroll);
    
    if(m_RootStore.hStore != NULL)
        hr = E_ACCESSDENIED;
    else {
        if(m_RootStore.wszName != wszROOT && m_RootStore.wszName != wszCA)
            MyCoTaskMemFree(m_RootStore.wszName);
            
        m_RootStore.wszName = NULL;
        m_RootStore.hStore = CertDuplicateStore(hStore);
    }

    LeaveCriticalSection(&m_csXEnroll);
    
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::SetHStoreRequest(
    HCERTSTORE   hStore
    ) {
    HRESULT hr = S_OK;
    
    EnterCriticalSection(&m_csXEnroll);
    
    if(m_RequestStore.hStore != NULL)
        hr = E_ACCESSDENIED;
    else {
        if(m_RequestStore.wszName != wszREQUEST)
            MyCoTaskMemFree(m_RequestStore.wszName);
            
        m_RequestStore.wszName = NULL;
        m_RequestStore.hStore = CertDuplicateStore(hStore);
    }

    LeaveCriticalSection(&m_csXEnroll);
    
    return(hr);
}

HRESULT STDMETHODCALLTYPE  CCEnroll::put_LimitExchangeKeyToEncipherment(
    BOOL    fBool
    ) {
    
    EnterCriticalSection(&m_csXEnroll);
    m_fLimitExchangeKeyToEncipherment = fBool;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
    }

HRESULT STDMETHODCALLTYPE  CCEnroll::get_LimitExchangeKeyToEncipherment(
    BOOL * fBool
    ) {

    EnterCriticalSection(&m_csXEnroll);
    *fBool = m_fLimitExchangeKeyToEncipherment;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
    }

HRESULT STDMETHODCALLTYPE  CCEnroll::put_EnableSMIMECapabilities(
    BOOL fSMIME
    )
{
    HRESULT hr;
    
    EnterCriticalSection(&m_csXEnroll);

    if (m_fKeySpecSetByClient)
    {
        //SMIME is set by the client
        if (AT_SIGNATURE == m_keyProvInfo.dwKeySpec && fSMIME)
        {
            //try to set signature key spec also SMIME
            hr = XENROLL_E_KEYSPEC_SMIME_MISMATCH;
            goto MismatchError;
        }
    }
    else
    {
        //user didn't set key spec
        //determine the spec accordingly
        m_keyProvInfo.dwKeySpec = fSMIME ? AT_KEYEXCHANGE : AT_SIGNATURE;
    }
    m_fEnableSMIMECapabilities = fSMIME;
    m_fSMIMESetByClient = TRUE;

    hr = S_OK;
ErrorReturn:
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);

TRACE_ERROR(MismatchError)
}

HRESULT STDMETHODCALLTYPE  CCEnroll::get_EnableSMIMECapabilities(
    BOOL * fBool
    ) {

    EnterCriticalSection(&m_csXEnroll);
    *fBool = m_fEnableSMIMECapabilities;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
    }

//ICEnroll4

HRESULT
GetCertificateContextFromBStr(
    IN  BSTR  bstrCert,
    OUT PCCERT_CONTEXT *ppCert)
{
    HRESULT hr;
    PCCERT_CONTEXT pCert = NULL;
    BYTE    *pbCert = NULL;
    DWORD    cbCert = 0;

    // could be any form, binary or base64
    while (TRUE)
    {
        if (!MyCryptStringToBinaryW(
                        (WCHAR*)bstrCert,
                        SysStringLen(bstrCert),
                        CRYPT_STRING_ANY,
                        pbCert,
                        &cbCert,
                        NULL,
                        NULL))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto MyCryptStringToBinaryWError;
        }
        if (NULL != pbCert)
        {
            break; //done
        }
        pbCert = (BYTE*)LocalAlloc(LMEM_FIXED, cbCert);
        if (NULL == pbCert)
        {
            hr = E_OUTOFMEMORY;
            goto OutOfMemoryError;
        }
    }
    pCert = CertCreateCertificateContext(
                                X509_ASN_ENCODING,
                                pbCert,
                                cbCert);
    if (NULL == pCert)
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto CertCreateCertificateContextError;
    }
    *ppCert = pCert;
    pCert = NULL;

    hr = S_OK;
ErrorReturn:
    if (NULL != pbCert)
    {
        LocalFree(pbCert);
    }
    if (NULL != pCert)
    {
        CertFreeCertificateContext(pCert);
    }
    return (hr);

TRACE_ERROR(CertCreateCertificateContextError)
TRACE_ERROR(MyCryptStringToBinaryWError)
TRACE_ERROR(OutOfMemoryError)
}


HRESULT STDMETHODCALLTYPE
CCEnroll::put_PrivateKeyArchiveCertificate(
    IN  BSTR  bstrCert)
{
    HRESULT hr;
    PCCERT_CONTEXT pPrivateKeyArchiveCert = NULL;

    if (NULL != bstrCert)
    {
        hr = GetCertificateContextFromBStr(bstrCert, &pPrivateKeyArchiveCert);
        if (S_OK != hr)
        {
            goto GetCertificateContextFromBStrError;
        }
    }

    // set key archive certificate
    hr = SetPrivateKeyArchiveCertificate(pPrivateKeyArchiveCert);
    if (S_OK != hr)
    {
        goto SetPrivateKeyArchiveCertificateError;
    }

    hr = S_OK;
ErrorReturn:
    if (NULL != pPrivateKeyArchiveCert)
    {
        CertFreeCertificateContext(pPrivateKeyArchiveCert);
    }
    return hr;

TRACE_ERROR(GetCertificateContextFromBStrError)
TRACE_ERROR(SetPrivateKeyArchiveCertificateError)
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::get_PrivateKeyArchiveCertificate(
    OUT BSTR __RPC_FAR *pbstrCert)
{
    HRESULT hr;
    PCCERT_CONTEXT pPrivateKeyArchiveCert = NULL;
    CRYPT_DATA_BLOB blobCert;

    //init
    *pbstrCert = NULL;

    pPrivateKeyArchiveCert = GetPrivateKeyArchiveCertificate();

    if (NULL != pPrivateKeyArchiveCert)
    {
        blobCert.pbData = pPrivateKeyArchiveCert->pbCertEncoded;
        blobCert.cbData = pPrivateKeyArchiveCert->cbCertEncoded;
        hr = BlobToBstring(&blobCert, CRYPT_STRING_BASE64HEADER, pbstrCert);
        if (S_OK != hr)
        {
            goto BlobToBstringError;
        }
    }

    hr = S_OK;
ErrorReturn:
    if (NULL != pPrivateKeyArchiveCert)
    {
        CertFreeCertificateContext(pPrivateKeyArchiveCert);
    }
    return hr;

TRACE_ERROR(BlobToBstringError)
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::put_ThumbPrint(IN BSTR bstrThumbPrint) 
{ 
    CRYPT_DATA_BLOB hashBlob; 
    HRESULT         hr; 

    if (bstrThumbPrint == NULL)
        return E_INVALIDARG; 

    hashBlob.cbData = 0; 
    hashBlob.pbData = NULL;

    if (!MyCryptStringToBinaryW
        ((WCHAR*)bstrThumbPrint,
         SysStringLen(bstrThumbPrint),
         CRYPT_STRING_BASE64,
         hashBlob.pbData, 
         &hashBlob.cbData, 
         NULL,
         NULL))
      goto MyCryptToBinaryErr; 

    hashBlob.pbData = (LPBYTE)LocalAlloc(LPTR, hashBlob.cbData); 
    if (NULL == hashBlob.pbData)
      goto MemoryErr; 

    if (!MyCryptStringToBinaryW
        ((WCHAR*)bstrThumbPrint,
         SysStringLen(bstrThumbPrint),
         CRYPT_STRING_BASE64,
         hashBlob.pbData, 
         &hashBlob.cbData, 
         NULL,
         NULL))
      goto MyCryptToBinaryErr; 

    hr = this->put_ThumbPrintWStr(hashBlob); 

 ErrorReturn: 
    if (NULL != hashBlob.pbData) { LocalFree(hashBlob.pbData); } 
    return hr; 

SET_HRESULT(MyCryptToBinaryErr, MY_HRESULT_FROM_WIN32(GetLastError())); 
SET_HRESULT(MemoryErr,          E_OUTOFMEMORY); 
} 

HRESULT STDMETHODCALLTYPE
CCEnroll::put_ThumbPrintWStr(IN CRYPT_DATA_BLOB  hashBlob)
{
    if (hashBlob.pbData == NULL)
        return E_INVALIDARG; 
    
    if (m_hashBlobPendingRequest.pbData != NULL)
    {
        LocalFree(m_hashBlobPendingRequest.pbData); 
        m_hashBlobPendingRequest.pbData = NULL; 
    }

    m_hashBlobPendingRequest.cbData = hashBlob.cbData; 
    m_hashBlobPendingRequest.pbData = (LPBYTE)LocalAlloc(LPTR, m_hashBlobPendingRequest.cbData);
    
    if (m_hashBlobPendingRequest.pbData == NULL)
        return E_OUTOFMEMORY; 

    CopyMemory(m_hashBlobPendingRequest.pbData, hashBlob.pbData, hashBlob.cbData); 
    return S_OK; 
}
     
HRESULT STDMETHODCALLTYPE 
CCEnroll::get_ThumbPrint(OUT BSTR __RPC_FAR *pbstrThumbPrint) 
{ 
    CRYPT_DATA_BLOB hashBlob; 
    DWORD           cchThumbPrintStr; 
    HRESULT         hr; 
    WCHAR          *pwszThumbPrint = NULL; 
    int             i, n; 

   // Input validation: 
    if (pbstrThumbPrint == NULL)
        return E_INVALIDARG; 

    // Initialize locals: 
    ZeroMemory(&hashBlob, sizeof(hashBlob));
    *pbstrThumbPrint  = NULL; 
     
    if (S_OK != (hr = this->get_ThumbPrintWStr(&hashBlob)))
        goto ErrorReturn; 
    
    hashBlob.pbData = (LPBYTE)LocalAlloc(LPTR, hashBlob.cbData); 
    if (NULL == hashBlob.pbData)
        goto MemoryErr; 
        
    if (S_OK != (hr = this->get_ThumbPrintWStr(&hashBlob)))
        goto ErrorReturn; 

    // Now we have a binary thumbprint.  Convert this to base64:
    while (TRUE)
    {
        if (!MyCryptBinaryToStringW(
                        hashBlob.pbData, 
                        hashBlob.cbData, 
                        CRYPT_STRING_BASE64 | CRYPT_STRING_NOCR,
                        pwszThumbPrint,
                        &cchThumbPrintStr))
        {
            goto MyCryptToStringErr; 
        }
        if (NULL != pwszThumbPrint)
        {
            //done
            break;
        }
        pwszThumbPrint = (WCHAR*)LocalAlloc(LMEM_FIXED,
                                          cchThumbPrintStr * sizeof(WCHAR)); 
        if (NULL == pwszThumbPrint)
        {
            goto MemoryErr; 
        }
    }

    //make sure no new line and CR
    n = (int)wcslen(pwszThumbPrint);
    for (i = n - 1; i > -1; --i)
    {
        if (L'\r' != pwszThumbPrint[i] &&
            L'\n' != pwszThumbPrint[i])
        {
            break; //done
        }
        pwszThumbPrint[i] = L'\0'; //null it
    }

    // Ok, we've acquired the HASH.  Now copy it to the out parameter: 
    *pbstrThumbPrint = SysAllocString(pwszThumbPrint); 
    if (NULL == *pbstrThumbPrint)
    {
        goto MemoryErr; 
    }

    hr = S_OK; 
ErrorReturn:
    if (NULL != hashBlob.pbData)
    {
        LocalFree(hashBlob.pbData);
    }
    if (NULL != pwszThumbPrint)
    {
        LocalFree(pwszThumbPrint);
    } 
    return hr; 

SET_HRESULT(MyCryptToStringErr, MY_HRESULT_FROM_WIN32(GetLastError())) 
SET_HRESULT(MemoryErr, E_OUTOFMEMORY) 
} 

HRESULT STDMETHODCALLTYPE
CCEnroll::get_ThumbPrintWStr(IN OUT PCRYPT_DATA_BLOB pHashBlob) { 
    HRESULT hr = S_OK; 

    // Input validation: 
    if (NULL == pHashBlob)
        return E_INVALIDARG; 

    // TWO CASES: 
    // 
    // 1)  the thumbprint has been explicitly set by an external caller. 
    // 2)  the thumbprint _wasn't_ explicitly set.  In this case, use the thumbprint
    //     of the request generated by the last call to createPKCS10().
    //
    // CASE 1: 
    //
    if (NULL != m_hashBlobPendingRequest.pbData)
    {
        if (NULL != pHashBlob->pbData)
        {
            if (pHashBlob->cbData < m_hashBlobPendingRequest.cbData) { 
                hr = MY_HRESULT_FROM_WIN32(ERROR_MORE_DATA); 
            }
            else { 
                CopyMemory(pHashBlob->pbData, m_hashBlobPendingRequest.pbData, m_hashBlobPendingRequest.cbData);
                hr = S_OK;
            }
        }

        pHashBlob->cbData = m_hashBlobPendingRequest.cbData; 
        return hr; 
    }
    // CASE 2: 
    // 
    else
    {
        if (NULL == m_pCertContextPendingRequest)
            return E_POINTER; 
     
        // Executes at most twice.  
        if (!CertGetCertificateContextProperty
            (m_pCertContextPendingRequest, 
             CERT_HASH_PROP_ID, 
             (LPVOID)(pHashBlob->pbData), 
             &(pHashBlob->cbData)))
        {
            return MY_HRESULT_FROM_WIN32(GetLastError()); 
        }

        return S_OK; 
    }
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::binaryToString(
    IN  LONG  Flags,
    IN  BSTR  strBinary,
    OUT BSTR *pstrEncoded)
{
    HRESULT hr;
    CRYPT_DATA_BLOB   blobBinary;
    WCHAR            *pwszEncoded = NULL;

    blobBinary.pbData = (BYTE*)strBinary;
    blobBinary.cbData = SysStringByteLen(strBinary);

    hr = binaryBlobToString(Flags, &blobBinary, &pwszEncoded);
    if (S_OK != hr)
    {
        goto binaryBlobToStringError;
    }

    *pstrEncoded = SysAllocString(pwszEncoded);
    if (NULL == pstrEncoded)
    {
        hr = E_OUTOFMEMORY;
        goto SysAllocStringLenError;
    }

    hr = S_OK;
ErrorReturn:
    if (NULL != pwszEncoded)
    {
        MyCoTaskMemFree(pwszEncoded);
    }
    return hr;

TRACE_ERROR(binaryBlobToStringError);
TRACE_ERROR(SysAllocStringLenError);
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::stringToBinary(
    IN  LONG  Flags,
    IN  BSTR  strEncoded,
    OUT BSTR *pstrBinary)
{
    HRESULT hr;
    CRYPT_DATA_BLOB   blobBinary;

    ZeroMemory(&blobBinary, sizeof(blobBinary));

    hr = stringToBinaryBlob(Flags, (LPCWSTR)strEncoded, &blobBinary, NULL, NULL);
    if (S_OK != hr)
    {
        goto stringToBinaryBlobError;
    }
    *pstrBinary = SysAllocStringLen(
            (OLECHAR*)blobBinary.pbData, blobBinary.cbData);
    if (NULL == *pstrBinary)
    {
        hr = E_OUTOFMEMORY;
        goto SysAllocStringLenError;
    }

    hr = S_OK;
ErrorReturn:
    if (NULL != blobBinary.pbData)
    {
        MyCoTaskMemFree(blobBinary.pbData);
    }
    return hr;

TRACE_ERROR(stringToBinaryBlobError);
TRACE_ERROR(SysAllocStringLenError);
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::addExtensionToRequest(
    IN  LONG  Flags,
    IN  BSTR  strName,
    IN  BSTR  strValue)
{
    HRESULT hr;
    CRYPT_DATA_BLOB   blobValue;
    DWORD  cchStrValue = SysStringLen(strValue);
    BYTE   *pbExtVal = NULL;
    DWORD  cbExtVal = 0;

    //convert to binary in case base64 etc.
    while (TRUE)
    {
        if (!MyCryptStringToBinaryW(
                    (WCHAR*)strValue,
                    cchStrValue,
                    CRYPT_STRING_ANY,
                    pbExtVal,
                    &cbExtVal,
                    NULL,
                    NULL))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto MyCryptStringToBinaryWError;
        }
        if (NULL != pbExtVal)
        {
            //done
            break;
        }
        pbExtVal = (BYTE*)LocalAlloc(LMEM_FIXED, cbExtVal);
        if (NULL == pbExtVal)
        {
            hr = E_OUTOFMEMORY;
            goto LocalAllocError;
        }
    }

    blobValue.pbData = pbExtVal;
    blobValue.cbData = cbExtVal;

    hr = addExtensionToRequestWStr(Flags, strName, &blobValue);
    if (S_OK != hr)
    {
        goto addExtensionToRequestWStrError;
    }

    hr = S_OK;
ErrorReturn:
    if (NULL != pbExtVal)
    {
        LocalFree(pbExtVal);
    }
    return hr;

TRACE_ERROR(MyCryptStringToBinaryWError)
TRACE_ERROR(LocalAllocError)
TRACE_ERROR(addExtensionToRequestWStrError)
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::addAttributeToRequest(
    IN  LONG  Flags,
    IN  BSTR  strName,
    IN  BSTR  strValue)
{
    HRESULT hr;
    CRYPT_DATA_BLOB   blobValue;
    DWORD  cchStrValue = SysStringLen(strValue);
    BYTE   *pbAttVal = NULL;
    DWORD  cbAttVal = 0;

    //convert to binary in case base64 etc.
    while (TRUE)
    {
        if (!MyCryptStringToBinaryW(
                    (WCHAR*)strValue,
                    cchStrValue,
                    CRYPT_STRING_ANY,
                    pbAttVal,
                    &cbAttVal,
                    NULL,
                    NULL))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto MyCryptStringToBinaryWError;
        }
        if (NULL != pbAttVal)
        {
            //done
            break;
        }
        pbAttVal = (BYTE*)LocalAlloc(LMEM_FIXED, cbAttVal);
        if (NULL == pbAttVal)
        {
            hr = E_OUTOFMEMORY;
            goto LocalAllocError;
        }
    }

    blobValue.pbData = pbAttVal;
    blobValue.cbData = cbAttVal;

    hr = addAttributeToRequestWStr(Flags, strName, &blobValue);
    if (S_OK != hr)
    {
        goto addAttributeToRequestWStrError;
    }

    hr = S_OK;
ErrorReturn:
    if (NULL != pbAttVal)
    {
        LocalFree(pbAttVal);
    }
    return hr;

TRACE_ERROR(MyCryptStringToBinaryWError)
TRACE_ERROR(LocalAllocError)
TRACE_ERROR(addAttributeToRequestWStrError)
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::addNameValuePairToRequest(
    IN  LONG  Flags, //not used
    IN  BSTR  strName,
    IN  BSTR  strValue)
{
    return addNameValuePairToRequestWStr(Flags, strName, strValue);
}

HRESULT STDMETHODCALLTYPE CCEnroll::addBlobPropertyToCertificate(
    IN  LONG   lPropertyId,
    IN  LONG   lFlags,
    IN  BSTR   strProperty)
{
    CRYPT_DATA_BLOB  blob;

    blob.pbData = (BYTE*)strProperty;
    blob.cbData = SysStringByteLen(strProperty);
    if (0x0 != (XECP_STRING_PROPERTY & lFlags))
    {
        //this is a string property, including null
        blob.cbData += sizeof(WCHAR);
    }

    return addBlobPropertyToCertificateWStr(lPropertyId, lFlags, &blob);
}

HRESULT STDMETHODCALLTYPE
CCEnroll::put_SignerCertificate(
    IN  BSTR  bstrCert)
{
    HRESULT hr;
    PCCERT_CONTEXT pSignerCert = NULL;

    if (NULL != bstrCert)
    {
        hr = GetCertificateContextFromBStr(bstrCert, &pSignerCert);
        if (S_OK != hr)
        {
            goto GetCertificateContextFromBStrError;
        }
    }

    // set key archive certificate
    hr = SetSignerCertificate(pSignerCert);
    if (S_OK != hr)
    {
        goto SetSignerCertificateError;
    }

    hr = S_OK;
ErrorReturn:
    if (NULL != pSignerCert)
    {
        CertFreeCertificateContext(pSignerCert);
    }
    return hr;

TRACE_ERROR(GetCertificateContextFromBStrError)
TRACE_ERROR(SetSignerCertificateError)
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::resetExtensions()
{
    HRESULT hr = S_OK;

    FreeAllStackExtension();

    return hr;
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::resetAttributes()
{
    HRESULT hr = S_OK;

    FreeAllStackAttribute();

    return hr;
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::createRequest(
    IN  LONG  Flags,
    IN  BSTR  strDNName,
    IN  BSTR  strUsage,
    OUT BSTR *pstrRequest)
{
    return createRequestWStrBStr(
                Flags,
                (LPCWSTR)strDNName,
                (LPCWSTR)strUsage,
                CRYPT_STRING_BASE64REQUESTHEADER,
                pstrRequest);
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::createFileRequest(
    IN  LONG  Flags,
    IN  BSTR  strDNName,
    IN  BSTR  strUsage,
    IN  BSTR  strRequestFileName)
{
    return createFileRequestWStr(Flags, (LPCWSTR)strDNName, (LPCWSTR)strUsage, (LPCWSTR)strRequestFileName);
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::acceptResponse(
    IN  BSTR  bstrResponse)
{
    HRESULT hr;
    CRYPT_DATA_BLOB blobResponse;
    DWORD  cchStrResponse;

    ZeroMemory(&blobResponse, sizeof(blobResponse));

    if (NULL == bstrResponse)
    {
        hr = MY_HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto InvalidParameterError;
    }

    //assume a string
    cchStrResponse = SysStringLen(bstrResponse);

    //convert to binary in case base64 etc.
    while (TRUE)
    {
        if (!MyCryptStringToBinaryW(
                    (WCHAR*)bstrResponse,
                    cchStrResponse,
                    CRYPT_STRING_ANY,
                    blobResponse.pbData,
                    &blobResponse.cbData,
                    NULL,
                    NULL))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto MyCryptStringToBinaryWError;
        }
        if (NULL != blobResponse.pbData)
        {
            //done
            break;
        }
        blobResponse.pbData = (BYTE*)LocalAlloc(
                                        LMEM_FIXED, blobResponse.cbData);
        if (NULL == blobResponse.pbData)
        {
            hr = E_OUTOFMEMORY;
            goto LocalAllocError;
        }
    }

    // accept the blob
    hr = acceptResponseBlob(&blobResponse);
    if (S_OK != hr)
    {
        goto acceptResponseBlobError;
    }

    hr = S_OK;
ErrorReturn:
    if (NULL != blobResponse.pbData)
    {
        LocalFree(blobResponse.pbData);
    }
    return (hr);

TRACE_ERROR(acceptResponseBlobError)
TRACE_ERROR(InvalidParameterError)
TRACE_ERROR(MyCryptStringToBinaryWError)
TRACE_ERROR(LocalAllocError)
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::acceptFileResponse(
    IN  BSTR  bstrResponseFileName)
{
    return acceptFileResponseWStr((LPCWSTR)bstrResponseFileName);
}

HRESULT
CCEnroll::GetCertFromResponseBlobToBStr(
    IN  CRYPT_DATA_BLOB  *pBlobResponse,
    OUT BSTR *pstrCert)
{
    HRESULT hr;
    CRYPT_DATA_BLOB blobCert;
    PCCERT_CONTEXT pCert = NULL;

    hr = getCertContextFromResponseBlob(
                pBlobResponse,
                &pCert);
    if (S_OK != hr)
    {
        goto getCertContextFromResponseBlobError;
    }

    assert(NULL != pCert);

    blobCert.pbData = pCert->pbCertEncoded;
    blobCert.cbData = pCert->cbCertEncoded;
    hr = BlobToBstring(&blobCert, CRYPT_STRING_BASE64HEADER, pstrCert);
    if (S_OK != hr)
    {
        goto BlobToBstringError;
    }

    hr = S_OK;
ErrorReturn:
    if (NULL != pCert)
    {
        CertFreeCertificateContext(pCert);
    }
    return hr;

TRACE_ERROR(getCertContextFromResponseBlobError)
TRACE_ERROR(BlobToBstringError)
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::getCertFromResponse(
    IN  BSTR  strResponse,
    OUT BSTR *pstrCert)
{
    HRESULT hr;
    CRYPT_DATA_BLOB blobResponse;

    ZeroMemory(&blobResponse, sizeof(blobResponse));

    if (NULL == strResponse)
    {
        hr = E_POINTER;
        goto NullPointerError;
    }

    hr = BstringToBlob(strResponse, &blobResponse);
    if (S_OK != hr)
    {
        goto BstringToBlobError;
    }

    hr = GetCertFromResponseBlobToBStr(
                &blobResponse,
                pstrCert);
    if (S_OK != hr)
    {
        goto GetCertFromResponseBlobToBStrError;
    }

    hr = S_OK;
ErrorReturn:
    return hr;

TRACE_ERROR(NullPointerError)
TRACE_ERROR(BstringToBlobError)
TRACE_ERROR(GetCertFromResponseBlobToBStrError)
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::getCertFromFileResponse(
    IN  BSTR  strResponseFileName,
    OUT BSTR *pstrCert)
{
    HRESULT hr;
    CRYPT_DATA_BLOB blobResponse;

    ZeroMemory(&blobResponse, sizeof(blobResponse));

    hr = xeStringToBinaryFromFile(
                (LPCWSTR)strResponseFileName,
                &blobResponse.pbData,
                &blobResponse.cbData,
                CRYPT_STRING_ANY);
    if (S_OK != hr)
    {
        goto xeStringToBinaryFromFileError;
    }

    hr = GetCertFromResponseBlobToBStr(
                &blobResponse,
                pstrCert);
    if (S_OK != hr)
    {
        goto GetCertFromResponseBlobToBStrError;
    }

    hr = S_OK;
ErrorReturn:
    if (NULL != blobResponse.pbData)
    {
        LocalFree(blobResponse.pbData);
    }
    return hr;

TRACE_ERROR(xeStringToBinaryFromFileError)
TRACE_ERROR(GetCertFromResponseBlobToBStrError)
}

//--------------------------------------------------------------------------------
//
// THIS METHOD IS NOT SAFE FOR SCRIPTING
//
//--------------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE 
CCEnroll::createPFX(
    IN  BSTR  strPassword,
    OUT BSTR *pstrPFX)
{
    if (0 != m_dwEnabledSafteyOptions) // not safe for scripting
	return E_ACCESSDENIED; 
    return createPFXWStrBStr((LPCWSTR)strPassword, pstrPFX);
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::createFilePFX(
    IN  BSTR  strPassword,
    IN  BSTR  strPFXFileName)
{
    return createFilePFXWStr((LPCWSTR)strPassword, (LPCWSTR)strPFXFileName);
}

HRESULT STDMETHODCALLTYPE
CCEnroll::setPendingRequestInfo(
    IN  LONG  lRequestID,
    IN  BSTR  strCADNS,
    IN  BSTR  strCAName,
    IN  BSTR  strFriendlyName
    )
{
    return setPendingRequestInfoWStr(
                lRequestID,
                (LPCWSTR)strCADNS,
                (LPCWSTR)strCAName,
                (LPCWSTR)strFriendlyName);
}

HRESULT STDMETHODCALLTYPE
CCEnroll::enumPendingRequest(
    IN  LONG     lIndex,
    IN  LONG     lDesiredProperty,
    OUT VARIANT *pvarProperty
    )
{
    CRYPT_DATA_BLOB  dataBlobProperty; 
    HRESULT          hr; 
    LONG             lProperty; 
    VARIANT          varProperty; 

    // See if we're initializing an enumeration.  If so, just dispatch to
    // enumPendingRequestWStr: 
    if (XEPR_ENUM_FIRST == lIndex) { 
        return enumPendingRequestWStr(XEPR_ENUM_FIRST, 0, NULL); 
    }

    // Input validation: 
    if (lIndex < 0 || NULL == pvarProperty)
        return E_INVALIDARG; 

    // Initialize locals: 
    memset(&varProperty,      0, sizeof(VARIANT));
    memset(&dataBlobProperty, 0, sizeof(CRYPT_DATA_BLOB)); 

    switch (lDesiredProperty) 
        { 
        case XEPR_REQUESTID: 
        case XEPR_VERSION:
            if (S_OK != (hr = enumPendingRequestWStr(lIndex, lDesiredProperty, &lProperty)))
                goto ErrorReturn;

            varProperty.vt   = VT_I4; 
            varProperty.lVal = lProperty; 
            *pvarProperty    = varProperty; 
            goto CommonReturn; 

        case XEPR_CANAME:       
        case XEPR_CAFRIENDLYNAME: 
        case XEPR_CADNS:          
        case XEPR_HASH:            
        case XEPR_V1TEMPLATENAME:  
        case XEPR_V2TEMPLATEOID:   
            dataBlobProperty.cbData = 0; 
            dataBlobProperty.pbData = NULL;

            // Determine the size of the property we desire. 
            hr = enumPendingRequestWStr(lIndex, lDesiredProperty, (LPVOID)&dataBlobProperty);
            if (S_OK != hr || 0 == dataBlobProperty.cbData)
                goto ErrorReturn; 

            dataBlobProperty.pbData = (LPBYTE)LocalAlloc(LPTR, dataBlobProperty.cbData); 
            if (NULL == dataBlobProperty.pbData)
                goto MemoryErr; 

            // Request the property, using our newly allocated buffer. 
            hr = enumPendingRequestWStr(lIndex, lDesiredProperty, (LPVOID)&dataBlobProperty);
            if (hr != S_OK)
                goto ErrorReturn; 

            varProperty.vt      = VT_BSTR; 
            varProperty.bstrVal = SysAllocStringByteLen((LPCSTR)dataBlobProperty.pbData, dataBlobProperty.cbData); 
            if (NULL == varProperty.bstrVal)
                goto MemoryErr; 

            *pvarProperty = varProperty; 
            goto CommonReturn; 

        case XEPR_DATE:            
            goto NotImplErr; 

        default: 
            goto InvalidArgErr; 
    }

 CommonReturn: 
    if (NULL != dataBlobProperty.pbData) { LocalFree(dataBlobProperty.pbData); } 
    return hr; 

 ErrorReturn:
    if (NULL != varProperty.bstrVal) { SysFreeString(varProperty.bstrVal); } 
    goto CommonReturn; 

SET_HRESULT(InvalidArgErr, E_INVALIDARG); 
SET_HRESULT(MemoryErr,     E_OUTOFMEMORY); 
SET_HRESULT(NotImplErr,    E_NOTIMPL); 
}

HRESULT STDMETHODCALLTYPE
CCEnroll::removePendingRequest(
    IN  BSTR bstrThumbPrint
    )
{
    CRYPT_DATA_BLOB hashBlob; 
    HRESULT         hr; 

    if (bstrThumbPrint == NULL)
        return E_INVALIDARG; 

    hashBlob.cbData = 0; 
    hashBlob.pbData = NULL;

    if (!MyCryptStringToBinaryW
        ((WCHAR*)bstrThumbPrint,
         SysStringLen(bstrThumbPrint),
         CRYPT_STRING_ANY,
         hashBlob.pbData, 
         &hashBlob.cbData, 
         NULL,
         NULL))
      goto MyCryptToBinaryErr; 

    hashBlob.pbData = (LPBYTE)LocalAlloc(LPTR, hashBlob.cbData); 
    if (NULL == hashBlob.pbData)
      goto MemoryErr; 

    if (!MyCryptStringToBinaryW
        ((WCHAR*)bstrThumbPrint,
         SysStringLen(bstrThumbPrint),
         CRYPT_STRING_ANY,
         hashBlob.pbData, 
         &hashBlob.cbData, 
         NULL,
         NULL))
      goto MyCryptToBinaryErr; 

    hr = this->removePendingRequestWStr(hashBlob); 

 CommonReturn: 
    if (NULL != hashBlob.pbData) { LocalFree(hashBlob.pbData); } 
    return hr; 

 ErrorReturn: 
    goto CommonReturn; 

SET_HRESULT(MyCryptToBinaryErr, MY_HRESULT_FROM_WIN32(GetLastError())); 
SET_HRESULT(MemoryErr,          E_OUTOFMEMORY); 
}

//IEnroll4

HRESULT
myCertGetNameString(
    IN  PCCERT_CONTEXT pCert,
    IN  BOOL           fIssuer,
    OUT WCHAR        **ppwszName)
{
    HRESULT  hr;
    DWORD    dwFlags = fIssuer ? CERT_NAME_ISSUER_FLAG : 0;
    DWORD    dwTypePara;
    WCHAR   *pwszName = NULL;
    DWORD    cch = 0;

    while (TRUE)
    {
        cch = CertGetNameStringW(
                pCert,
                CERT_NAME_SIMPLE_DISPLAY_TYPE,
                dwFlags,
                (void*)&dwTypePara,
                pwszName,
                cch);
        if (0 == cch)
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto CertGetNameStringError;
        }
        if (NULL != pwszName)
        {
            //done
            break;
        }
        pwszName = (WCHAR*)LocalAlloc(LMEM_FIXED, cch * sizeof(WCHAR));
        if (NULL == pwszName)
        {
            hr = E_OUTOFMEMORY;
            goto OutOfMemoryError;
        }
    }
    *ppwszName = pwszName;
    pwszName = NULL;

    hr = S_OK;
ErrorReturn:
    if (NULL != pwszName)
    {
        LocalFree(pwszName);
    }
    return hr;

TRACE_ERROR(CertGetNameStringError)
TRACE_ERROR(OutOfMemoryError)
}

HRESULT CCEnroll::GetGoodCertContext(
    IN PCCERT_CONTEXT pCertContext,
    OUT PCCERT_CONTEXT *ppGoodCertContext)
{
    HRESULT hr;
    PCCERT_CONTEXT  pGoodCertContext = NULL;
    DWORD           cb;

    //init
    *ppGoodCertContext = NULL;

    if(pCertContext == NULL)
    {
        hr = MY_HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto InvalidParameterError;
    }

    //see if the passed cert has kpi
    if(CertGetCertificateContextProperty(
                pCertContext,
                CERT_KEY_PROV_INFO_PROP_ID,
                NULL,
                &cb))
    {
        //this means kpi exists, passed cert is good
        pGoodCertContext = CertDuplicateCertificateContext(pCertContext);
        if (NULL == pGoodCertContext)
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto CertDuplicateCertificateContextError;
        }
    }

    *ppGoodCertContext = pGoodCertContext;
    pGoodCertContext = NULL;

    hr = S_OK;
ErrorReturn:
    if (NULL != pGoodCertContext)
    {
        CertFreeCertificateContext(pGoodCertContext);
    }
    return hr;

TRACE_ERROR(InvalidParameterError)
TRACE_ERROR(CertDuplicateCertificateContextError)
}

HRESULT STDMETHODCALLTYPE CCEnroll::SetSignerCertificate(
    IN PCCERT_CONTEXT pCertContext)
{
    HRESULT hr;
    PCCERT_CONTEXT  pCertGoodContext = NULL;

    EnterCriticalSection(&m_csXEnroll);

    hr = GetGoodCertContext(pCertContext, &pCertGoodContext);
    if (S_OK != hr)
    {
        goto GetGoodCertContextError;
    }
    if(NULL != m_pCertContextSigner)
    {
        CertFreeCertificateContext(m_pCertContextSigner);
    }
    m_pCertContextSigner = pCertGoodContext;

    hr = S_OK;
ErrorReturn:
    LeaveCriticalSection(&m_csXEnroll);
    return hr;

TRACE_ERROR(GetGoodCertContextError)
}

HRESULT
VerifyPrivateKeyArchiveCertificate(
    IN PCCERT_CONTEXT pCert)
{
    HRESULT  hr;
    CERT_CHAIN_PARA ChainParams;
    CERT_CHAIN_POLICY_PARA ChainPolicy;
    CERT_CHAIN_POLICY_STATUS PolicyStatus;
    CERT_CHAIN_CONTEXT const *pCertChain = NULL;
    char *apszCAXchgOids[] = {szOID_KP_CA_EXCHANGE};
    WCHAR               *pwszSubject = NULL;
    WCHAR               *pwszIssuer = NULL;
    WCHAR               *pwszDesignedSubject = NULL;

    //easy check to make sure ca exchange cert issuer and subject
    //names are in convention
    hr = myCertGetNameString(
                pCert,
                FALSE,
                &pwszSubject);
    if (S_OK != hr)
    {
        goto myCertGetNameStringError;
    }

    hr = myCertGetNameString(
                pCert,
                TRUE,
                &pwszIssuer);
    if (S_OK != hr)
    {
        goto myCertGetNameStringError;
    }

    hr = myAddNameSuffix(
                pwszIssuer,
                wszCNXCHGSUFFIX,
                cchCOMMONNAMEMAX_XELIB,
                &pwszDesignedSubject);
    if (S_OK != hr)
    {
        goto myAddNameSuffixError;
    }

    if (0 != wcscmp(pwszSubject, pwszDesignedSubject))
    {
        //unexpected, they should match
        hr = E_INVALIDARG;
        goto InvalidArgError;
    }

    ZeroMemory(&ChainParams, sizeof(ChainParams));
    ChainParams.cbSize = sizeof(ChainParams);
    ChainParams.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
    ChainParams.RequestedUsage.Usage.rgpszUsageIdentifier = apszCAXchgOids;
    ChainParams.RequestedUsage.Usage.cUsageIdentifier = ARRAYSIZE(apszCAXchgOids);

    //get cert chain 1st
    if (!MyCertGetCertificateChain(
                NULL,   //HHCE_CURRENT_USER
                pCert,   //ca exchange cert
                NULL,   //use current system time
                NULL,   //no additional stores
                &ChainParams,   //chain params
                CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT,  // Make sure that none of the certs in the chain were revoked
                NULL,   //reserved
                &pCertChain))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto CertGetCertificateChainError;
    }

    ZeroMemory(&ChainPolicy, sizeof(ChainPolicy));
    ChainPolicy.cbSize = sizeof(ChainPolicy);
    ChainPolicy.dwFlags = CERT_CHAIN_POLICY_IGNORE_NOT_TIME_NESTED_FLAG;

    ZeroMemory(&PolicyStatus, sizeof(PolicyStatus));
    PolicyStatus.cbSize = sizeof(PolicyStatus);
    PolicyStatus.lChainIndex = -1;
    PolicyStatus.lElementIndex = -1;

    //verify the chain
    if (!MyCertVerifyCertificateChainPolicy(
                CERT_CHAIN_POLICY_BASE,
                pCertChain,
                &ChainPolicy,
                &PolicyStatus))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto CertVerifyCertificateChainPolicyError;
    }

    if (S_OK != PolicyStatus.dwError)
    {
        //chain back to root fails
        hr = PolicyStatus.dwError;
        goto CertVerifyCertificateChainPolicyError;
    }

    hr = S_OK;
ErrorReturn:
    if (NULL != pCertChain)
    {
        MyCertFreeCertificateChain(pCertChain);
    }
    if (NULL != pwszSubject)
    {
        LocalFree(pwszSubject);
    }
    if (NULL != pwszDesignedSubject)
    {
        LocalFree(pwszDesignedSubject);
    }
    if (NULL != pwszIssuer)
    {
        LocalFree(pwszIssuer);
    }
    return hr;

TRACE_ERROR(CertGetCertificateChainError)
TRACE_ERROR(CertVerifyCertificateChainPolicyError)
TRACE_ERROR(InvalidArgError)
TRACE_ERROR(myCertGetNameStringError)
TRACE_ERROR(myAddNameSuffixError)
}

HRESULT STDMETHODCALLTYPE
CCEnroll::SetPrivateKeyArchiveCertificate(
    IN PCCERT_CONTEXT  pPrivateKeyArchiveCert)
{
    HRESULT hr;
    PCCERT_CONTEXT pCert = NULL;

    if (NULL != pPrivateKeyArchiveCert)
    {
        //duplicate the cert
        pCert = CertDuplicateCertificateContext(pPrivateKeyArchiveCert);
        if (NULL == pCert)
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto CertDuplicateCertificateContextError;
        }

        //verify ca exchange cert
        hr = VerifyPrivateKeyArchiveCertificate(pCert);
        if (S_OK != hr)
        {
            goto VerifyPrivateKeyArchiveCertificateError;
        }
    }

    EnterCriticalSection(&m_csXEnroll);

    if (NULL != m_PrivateKeyArchiveCertificate)
    {
        CertFreeCertificateContext(m_PrivateKeyArchiveCertificate);
    }
    m_PrivateKeyArchiveCertificate = pCert;
    pCert = NULL; 

    LeaveCriticalSection(&m_csXEnroll);

    hr = S_OK;
ErrorReturn:
    if (NULL != pCert)
    {
        CertFreeCertificateContext(pCert);
    }
    return (hr);

TRACE_ERROR(CertDuplicateCertificateContextError)
TRACE_ERROR(VerifyPrivateKeyArchiveCertificateError)
}
                
PCCERT_CONTEXT STDMETHODCALLTYPE
CCEnroll::GetPrivateKeyArchiveCertificate(void)
{
    PCCERT_CONTEXT pCert = NULL;

    EnterCriticalSection(&m_csXEnroll);

    if (NULL != m_PrivateKeyArchiveCertificate)
    {
        pCert = CertDuplicateCertificateContext(m_PrivateKeyArchiveCertificate);
    }
    LeaveCriticalSection(&m_csXEnroll);

    return pCert;
}
    
HRESULT STDMETHODCALLTYPE
CCEnroll::binaryBlobToString(
    IN   LONG               Flags,
    IN   PCRYPT_DATA_BLOB   pblobBinary,
    OUT  LPWSTR            *ppwszString)
{
    HRESULT hr;
    WCHAR  *pwszEncoded = NULL;
    DWORD   dwEncoded = 0;

    while (TRUE)
    {
        if (!MyCryptBinaryToStringW(
                    pblobBinary->pbData,
                    pblobBinary->cbData,
                    Flags,
                    pwszEncoded,
                    &dwEncoded))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto MyCryptBinaryToStringError;
        }
        if (NULL != pwszEncoded)
        {
            //done
            break;
        }
        //dwEncoded includes null terminator
        pwszEncoded = (WCHAR*)MyCoTaskMemAlloc(dwEncoded * sizeof(WCHAR));
        if (NULL == pwszEncoded)
        {
            hr = E_OUTOFMEMORY;
            goto MyCoTaskMemAllocError;
        }
    }

    *ppwszString = pwszEncoded;
    pwszEncoded = NULL;

    hr = S_OK;
ErrorReturn:
    if (NULL != pwszEncoded)
    {
        MyCoTaskMemFree(pwszEncoded);
    }
    return hr;

TRACE_ERROR(MyCoTaskMemAllocError)
TRACE_ERROR(MyCryptBinaryToStringError)
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::stringToBinaryBlob(
    IN   LONG               Flags,
    IN   LPCWSTR            pwszString,
    OUT  PCRYPT_DATA_BLOB   pblobBinary,
    OUT  LONG              *pdwSkip,
    OUT  LONG              *pdwFlags)
{
    HRESULT  hr;
    size_t   nLength = wcslen(pwszString); 

    if (nLength*sizeof(WCHAR) > (DWORD)-1)
	goto InvalidArgError; 

    //init
    pblobBinary->pbData = NULL;
    pblobBinary->cbData = 0;

    while (TRUE)
    {
        if (!MyCryptStringToBinaryW(
                    pwszString,
                    (DWORD)nLength, 
                    Flags,
                    pblobBinary->pbData,
                    &pblobBinary->cbData,
                    (DWORD*)pdwSkip,
                    (DWORD*)pdwFlags))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto MyCryptStringToBinaryWError;
        }
        if (NULL != pblobBinary->pbData)
        {
            //done
            break;
        }
        pblobBinary->pbData = (BYTE*)MyCoTaskMemAlloc(pblobBinary->cbData);
        if (NULL == pblobBinary->pbData)
        {
            hr = E_OUTOFMEMORY;
            goto MyCoTaskMemAllocError;
        }
    }

    hr = S_OK;
ErrorReturn:
    return hr;

SET_HRESULT(InvalidArgError, E_INVALIDARG);
TRACE_ERROR(MyCryptStringToBinaryWError)
TRACE_ERROR(MyCoTaskMemAllocError)
}


HRESULT STDMETHODCALLTYPE 
CCEnroll::addExtensionToRequestWStr(
    IN   LONG               Flags,
    IN   LPCWSTR            pwszName,
    IN   PCRYPT_DATA_BLOB   pblobValue)
{
    HRESULT hr = S_OK;
    CERT_EXTENSION ext;
    CERT_EXTENSION *pExt = NULL; //enum 1st
    CHAR   *pszName = NULL;

    //convert wsz oid to sz oid
    hr = xeWSZToSZ(pwszName, &pszName);
    if (S_OK != hr)
    {
        goto error;
    }

    while (NULL != (pExt = EnumStackExtension(pExt, TRUE)))
    {
	if (0 == strcmp(pszName, pExt->pszObjId))
	{
	    //already had the extension, can't have more than 1
	    hr = MY_HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
	    goto error;
	}
    }

    //check to see if it is key usage extension
    if (0 == strcmp(pszName, szOID_KEY_USAGE))
    {
	EnterCriticalSection(&m_csXEnroll);
	m_fUseClientKeyUsage = TRUE;
	LeaveCriticalSection(&m_csXEnroll);
    }
    
    ZeroMemory(&ext, sizeof(ext));
    ext.fCritical = Flags;
    ext.pszObjId = pszName;
    ext.Value = *pblobValue;
    
    if(!CopyAndPushStackExtension(&ext, TRUE))
    {
	hr = MY_HRESULT_FROM_WIN32(GetLastError());
    }

error:
    if (NULL != pszName)
    {
        MyCoTaskMemFree(pszName);
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::addAttributeToRequestWStr(
    IN   LONG               /*Flags*/, 
    IN   LPCWSTR            pwszName,
    IN   PCRYPT_DATA_BLOB   pblobValue)
{
    HRESULT hr = S_OK;
    CRYPT_ATTR_BLOB attrBlob;
    CRYPT_ATTRIBUTE attr;
    CHAR   *pszName = NULL;

    //convert wsz oid to sz oid
    hr = xeWSZToSZ(pwszName, &pszName);
    if (S_OK != hr)
    {
        goto error;
    }

    ZeroMemory(&attr, sizeof(attr));
    attrBlob = *pblobValue;
    attr.pszObjId = pszName;
    attr.cValue = 1;
    attr.rgValue = &attrBlob;

    if(!CopyAndPushStackAttribute(&attr, TRUE))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
    }

error:
    if (NULL != pszName)
    {
        MyCoTaskMemFree(pszName);
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::addNameValuePairToRequestWStr(
    IN   LONG         /*Flags*/, 
    IN   LPCWSTR      pwszName,
    IN   LPCWSTR      pwszValue)
{
    HRESULT hr = S_OK;

    assert(pwszName != NULL && pwszValue != NULL);

    CRYPT_ENROLLMENT_NAME_VALUE_PAIR nameValuePair =
            {const_cast<LPWSTR>(pwszName), const_cast<LPWSTR>(pwszValue)};
    CRYPT_ATTR_BLOB blobAttr;
    CRYPT_ATTRIBUTE attr = {szOID_ENROLLMENT_NAME_VALUE_PAIR, 1, &blobAttr};

    memset(&blobAttr, 0, sizeof(CRYPT_ATTR_BLOB));

    hr = xeEncodeNameValuePair(
                &nameValuePair,
                &blobAttr.pbData,
                &blobAttr.cbData);
    if (S_OK != hr)
    {
        goto error;
    }

    if(!CopyAndPushStackAttribute(&attr, TRUE))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
    }

error:
    if (NULL != blobAttr.pbData)
    {
        MyCoTaskMemFree(blobAttr.pbData);
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CCEnroll::addBlobPropertyToCertificateWStr(
    IN  LONG               lPropertyId,
    IN  LONG               lFlags,
    IN  PCRYPT_DATA_BLOB   pBlobProp)
{
    HRESULT      hr;
    PPROP_STACK  pProp;
    PPROP_STACK  pPropEle = NULL;

    EnterCriticalSection(&m_csXEnroll);

    if (NULL == pBlobProp ||
        NULL == pBlobProp->pbData ||
        0 == pBlobProp->cbData)
    {
        hr = MY_HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto InvalidParameterError;
    }

    // Don't allow arbitrary properties to be set on the request from a script
    // (could be a security risk, we should only allow a small set)
    if (0 != m_dwEnabledSafteyOptions && !IsDesiredProperty(lPropertyId))
    {
        hr = MY_HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto InvalidParameterError;
    }

    //check if the same property exists
    pProp = EnumStackProperty(NULL);
    while (NULL != pProp)
    {
        if (pProp->lPropId == lPropertyId)
        {
            //exists already
            hr = MY_HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
            goto PropertyExistError;
        }
        pProp = EnumStackProperty(pProp);
    }

    pPropEle = (PPROP_STACK)LocalAlloc(LMEM_ZEROINIT, sizeof(PROP_STACK));
    if (NULL == pPropEle)
    {
        hr = E_OUTOFMEMORY;
        goto OutOfMemoryError;
    }
    
    pPropEle->lPropId = lPropertyId;
    pPropEle->lFlags = lFlags;
    pPropEle->prop.pbData = (BYTE*)LocalAlloc(LMEM_FIXED, pBlobProp->cbData);
    if (NULL == pPropEle->prop.pbData)
    {
        hr = E_OUTOFMEMORY;
        goto OutOfMemoryError;
    }
    CopyMemory(pPropEle->prop.pbData, pBlobProp->pbData, pBlobProp->cbData);
    pPropEle->prop.cbData = pBlobProp->cbData;

    //put into stack
    pPropEle->pNext = m_pPropStack;
    m_pPropStack = pPropEle; //assign m_pPropStack
    m_cPropStack++; //increment of m_cPropStack
    pPropEle = NULL;

    hr = S_OK;
ErrorReturn:
    if (NULL != pPropEle)
    {
        if (NULL != pPropEle->prop.pbData)
        {
            LocalFree(pPropEle->prop.pbData);
        }
        LocalFree(pPropEle);
    }

    LeaveCriticalSection(&m_csXEnroll);
    return hr;

TRACE_ERROR(InvalidParameterError)
TRACE_ERROR(PropertyExistError)
TRACE_ERROR(OutOfMemoryError)
}

PPROP_STACK
CCEnroll::EnumStackProperty(PPROP_STACK pProp)
{
    EnterCriticalSection(&m_csXEnroll);

    if(NULL == pProp)
    {
        //1st one
        pProp = m_pPropStack;
    }
    else
    {
        pProp = pProp->pNext;
    }

    LeaveCriticalSection(&m_csXEnroll);

    return pProp;
}

HRESULT STDMETHODCALLTYPE CCEnroll::resetBlobProperties()
{
    PPROP_STACK  pPropEle;
    PPROP_STACK  pPropNext;

    EnterCriticalSection(&m_csXEnroll);

    pPropEle = m_pPropStack;
    while (NULL != pPropEle)
    {
        //save it to temp
        pPropNext = EnumStackProperty(pPropEle);
        //free the current ele
        if (NULL != pPropEle->prop.pbData)
        {
            LocalFree(pPropEle->prop.pbData);
        }
        LocalFree(pPropEle);
        pPropEle = pPropNext;
    }
    m_pPropStack = NULL;
    m_cPropStack = 0;
    
    LeaveCriticalSection(&m_csXEnroll);
    return S_OK;
}

HRESULT
CCEnroll::GetKeyArchivePKCS7(
    OUT CRYPT_ATTR_BLOB *pBlobKeyArchivePKCS7)
{
    HRESULT    hr;
    HCRYPTPROV hProv;
    HCRYPTKEY  hKey = NULL;
    BYTE      *pBlobPrivateKey = NULL;
    DWORD      cBlobPrivateKey = 0;
    CRYPT_ENCRYPT_MESSAGE_PARA cemp;
    ALG_ID  algId[] = {CALG_3DES, CALG_RC4, CALG_RC2, ALG_TYPE_ANY};
    CRYPT_OID_INFO const *pOidInfo = NULL;
    DWORD i = 0;

    //init
    pBlobKeyArchivePKCS7->pbData = NULL;
    pBlobKeyArchivePKCS7->cbData = 0;

    EnterCriticalSection(&m_csXEnroll);

    //make sure key archival cert is set
    assert(NULL != m_PrivateKeyArchiveCertificate);

    PCCERT_CONTEXT apCert[] = {m_PrivateKeyArchiveCertificate};

    //get user private key
    hProv = GetProv(0); //existing key container handle
    if (NULL == hProv)
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto CryptAcquireContextError;
    }

    if (NULL == m_hCachedKey)
    {
        //likely used existing key
        if(!CryptGetUserKey(
                    hProv,
                    m_keyProvInfo.dwKeySpec,
                    &hKey))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto CryptGetUserKeyError;
        }
    }

    //export private key
    while (TRUE)
    {
        if (!CryptExportKey(
                NULL != hKey ? hKey : m_hCachedKey,
                NULL, //don't encrypt
                PRIVATEKEYBLOB,
                0,
                pBlobPrivateKey,
                &cBlobPrivateKey))
        {
            //map to xenroll error
            hr = XENROLL_E_KEY_NOT_EXPORTABLE;
            goto CryptExportKeyError;
        }
        if (NULL != pBlobPrivateKey)
        {
            //done
            break;
        }
        pBlobPrivateKey = (BYTE*)MyCoTaskMemAlloc(cBlobPrivateKey);
        if (NULL == pBlobPrivateKey)
        {
            hr = E_OUTOFMEMORY;
            goto OutOfMemoryError;
        }
    }

    if (NULL == m_hCachedKey)
    {
        //it could be csp not supporting CRYPT_ARCHIVABLE
        //got private key, now let's take care of key permission
        if (0x0 == (m_dwGenKeyFlags & CRYPT_EXPORTABLE))
        {
            // user didn't ask exportable, turn it off
            DWORD dwFlags = 0;
            DWORD dwSize = sizeof(dwFlags);
            if (!CryptGetKeyParam(
                    hKey,
                    KP_PERMISSIONS,
                    (BYTE*)&dwFlags,
                    &dwSize,
                    0))
            {
                hr = MY_HRESULT_FROM_WIN32(GetLastError());
                goto CryptGetKeyParamError;
            }
#if DBG
            assert(dwSize = sizeof(dwFlags));
            // make sure was on
            assert(0x0 != (dwFlags & CRYPT_EXPORT));
#endif
            //turn off exportable
            dwFlags = dwFlags & (~CRYPT_EXPORT);
            if (!CryptSetKeyParam(
                    hKey,
                    KP_PERMISSIONS,
                    (BYTE*)&dwFlags,
                    0))
            {
                //hr = MY_HRESULT_FROM_WIN32(GetLastError());
                //goto CryptSetKeyParamError;
                hr = S_OK; //UNDONE, even ms csps have problem with this
            }
        }
    }

    //prepare for encryption
    ZeroMemory(&cemp, sizeof(cemp)); //avoid 0 assignment
    cemp.cbSize = sizeof(cemp);
    cemp.dwMsgEncodingType = PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;
    hr = S_OK; //critical init for double while loop

    while (ALG_TYPE_ANY != algId[i])
    {
        pOidInfo = xeCryptFindOIDInfo(
                        CRYPT_OID_INFO_ALGID_KEY,
                        &algId[i],
                        CRYPT_ENCRYPT_ALG_OID_GROUP_ID);
        if (NULL != pOidInfo)
        {
            cemp.ContentEncryptionAlgorithm.pszObjId = 
                                const_cast<char *>(pOidInfo->pszOID);
            //encryt into pkcs7
            while (TRUE)
            {
                if (!CryptEncryptMessage(
                        &cemp,
                        sizeof(apCert)/sizeof(apCert[0]),
                        apCert,
                        pBlobPrivateKey,
                        cBlobPrivateKey,
                        pBlobKeyArchivePKCS7->pbData,
                        &pBlobKeyArchivePKCS7->cbData))
                {
                    //save the 1st error code
                    hr = MY_HRESULT_FROM_WIN32(GetLastError());
#ifdef DBG
                    assert(NULL == pBlobKeyArchivePKCS7->pbData);
#endif
                    break; //break inner while loop
                }
                if (NULL != pBlobKeyArchivePKCS7->pbData)
                {
                    //done, got encrypted blob
                    //ignore error from previous alg tries
                    hr = S_OK;
                    break;
                }
                pBlobKeyArchivePKCS7->pbData = (BYTE*)MyCoTaskMemAlloc(
                                        pBlobKeyArchivePKCS7->cbData);
                if (NULL == pBlobKeyArchivePKCS7->pbData)
                {
                    hr = E_OUTOFMEMORY;
                    goto OutOfMemoryError;
                }
            }
            if (S_OK == hr)
            {
                //done, out of outer while loop
                break;
            }
        }
        ++i;
    }
    if (NULL == pOidInfo)
    {
        hr = CRYPT_E_NOT_FOUND;
        goto CryptElemNotFoundError;
    }

    if (S_OK != hr)
    {
        goto CryptEncryptMessageError;
    }

    hr = S_OK;
ErrorReturn:
    //now let's destroy cached key handle
    if (NULL != m_hCachedKey)
    {
        CryptDestroyKey(m_hCachedKey);
        m_hCachedKey = NULL; //critical to reset
    }
    //note, do above before leaving critical section
    LeaveCriticalSection(&m_csXEnroll);
    if (NULL != pBlobPrivateKey)
    {
	SecureZeroMemory(pBlobPrivateKey, cBlobPrivateKey);
        MyCoTaskMemFree(pBlobPrivateKey);
    }
    if (NULL != hKey)
    {
        CryptDestroyKey(hKey);
    }
    return hr;

TRACE_ERROR(CryptEncryptMessageError)
TRACE_ERROR(CryptAcquireContextError)
TRACE_ERROR(CryptGetUserKeyError)
TRACE_ERROR(CryptExportKeyError)
TRACE_ERROR(OutOfMemoryError)
TRACE_ERROR(CryptElemNotFoundError)
//TRACE_ERROR(CryptSetKeyParamError)
TRACE_ERROR(CryptGetKeyParamError)
}

HRESULT
GetKeyProvInfoFromCert(
    IN  PCCERT_CONTEXT    pCert,
    OUT DWORD            *pdwKeySpec,
    OUT HCRYPTPROV       *phProv)
{
    HRESULT hr;
    CRYPT_KEY_PROV_INFO *pKeyProvInfo = NULL;
    DWORD                cb = 0;
    HCRYPTPROV           hProv = NULL;

    if (NULL == pCert || NULL == phProv || NULL == pdwKeySpec)
    {
        hr = E_INVALIDARG;
        goto InvalidArgError;
    }

    while (TRUE)
    {
        if(!CertGetCertificateContextProperty(
                pCert,
                CERT_KEY_PROV_INFO_PROP_ID,
                pKeyProvInfo,
                &cb))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto CertGetCertificateContextPropertyError;
        }
        if (NULL != pKeyProvInfo)
        {
            //got it, done
            break;
        }
        pKeyProvInfo = (CRYPT_KEY_PROV_INFO*)LocalAlloc(LMEM_FIXED, cb);
        if (NULL == pKeyProvInfo)
        {
            hr = E_OUTOFMEMORY;
            goto OutOfMemoryError;
        }
    }

    if (!CryptAcquireContextU(
            &hProv,
            pKeyProvInfo->pwszContainerName,
            pKeyProvInfo->pwszProvName,
            pKeyProvInfo->dwProvType,
            pKeyProvInfo->dwFlags))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto CryptAcquireContextUError;
    }
    *phProv = hProv;
    hProv = NULL;
    *pdwKeySpec = pKeyProvInfo->dwKeySpec;

    hr = S_OK;
ErrorReturn:
    if (NULL != pKeyProvInfo)
    {
        LocalFree(pKeyProvInfo);
    }
    if (NULL != hProv)
    {
        CryptReleaseContext(hProv, 0);
    }
    return hr;

TRACE_ERROR(CryptAcquireContextUError)
TRACE_ERROR(OutOfMemoryError)
TRACE_ERROR(CertGetCertificateContextPropertyError)
TRACE_ERROR(InvalidArgError)
}

HRESULT
xeCreateKeyArchivalHashAttribute(
    IN  CRYPT_HASH_BLOB     *pBlobKAHash,
    OUT CRYPT_ATTR_BLOB     *pBlobKAAttr)
{
    HRESULT hr;
    BYTE   *pbData = NULL;
    DWORD   cbData = 0;

    while (TRUE)
    {
        if(!CryptEncodeObject(
                CRYPT_ASN_ENCODING,
                X509_OCTET_STRING,
                (void*)pBlobKAHash,
                pbData,
                &cbData))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto CryptEncodeObjectError;
        }

        if (NULL != pbData)
        {
            //done
            break;
        }

        pbData = (BYTE*)LocalAlloc(LMEM_FIXED, cbData);
        if (NULL == pbData)
        {
            hr = E_OUTOFMEMORY;
            goto LocalAllocError;
        }
    }
    pBlobKAAttr->pbData = pbData;
    pBlobKAAttr->cbData = cbData;
    pbData = NULL;

    hr = S_OK;
ErrorReturn:
    if (NULL != pbData)
    {
        LocalFree(pbData);
    }
    return hr;

TRACE_ERROR(CryptEncodeObjectError)
TRACE_ERROR(LocalAllocError)
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::createRequestWStr(
    IN   LONG              Flags,
    IN   LPCWSTR           pwszDNName,
    IN   LPCWSTR           pwszUsage,
    OUT  PCRYPT_DATA_BLOB  pblobRequest)
{
    HRESULT hr;
    CRYPT_DATA_BLOB  blobPKCS10;
    CRYPT_ATTR_BLOB  blobKeyArchivePKCS7;
    ALG_ID           rgAlg[2];
    PCCRYPT_OID_INFO pOidInfo;
    CERT_EXTENSION  *rgExt = NULL;
    DWORD            cExt = 0;
    CERT_EXTENSION  *pExt = NULL; //for enum 1st
    CRYPT_ATTRIBUTE  *rgAttr = NULL;
    DWORD            cAttr = 0;
    CRYPT_ATTRIBUTE  *pAttr = NULL; //for enum 1st
    CRYPT_ATTRIBUTES rgAttributes;
    CRYPT_ATTRIBUTE  *rgUnauthAttr = NULL; //init
    DWORD            cUnauthAttr = 0; //init
    DWORD            cb;
    HCRYPTPROV       hProvSigner = NULL;
    DWORD            dwKeySpecSigner = 0;
    PCCERT_CONTEXT   pCertSigner = NULL; //just init, no free
    HCRYPTPROV       hRequestProv = NULL;
    BYTE            *pbSubjectKeyHash = NULL;
    DWORD            cbSubjectKeyHash = 0;
    CRYPT_HASH_BLOB  blobKAHash;
    CRYPT_ATTR_BLOB  blobKAHashAttr;
    CRYPT_ATTRIBUTE  attrKAHash =
        {szOID_ENCRYPTED_KEY_HASH, 1, &blobKAHashAttr};

    ZeroMemory(&blobPKCS10, sizeof(blobPKCS10));
    ZeroMemory(&blobKeyArchivePKCS7, sizeof(blobKeyArchivePKCS7));
    ZeroMemory(&blobKAHash, sizeof(blobKAHash));
    ZeroMemory(&blobKAHashAttr, sizeof(blobKAHashAttr));

    EnterCriticalSection(&m_csXEnroll);
    
    // BUG 533202: should block key archival when re-using key (from script)
    if (0 != m_dwEnabledSafteyOptions && NULL != m_PrivateKeyArchiveCertificate && m_fUseExistingKey) { 
	hr = E_ACCESSDENIED; 
	goto AccessDeniedError; 
    }

    m_fNewRequestMethod = TRUE;  //critical
    m_fOID_V2 = TRUE;
    m_fCMCFormat = FALSE;
    m_fHonorIncludeSubjectKeyID = FALSE;

    switch (Flags)
    {
        case XECR_CMC:
        {
            if (NULL != m_pCertContextRenewal &&
                NULL != m_pCertContextSigner)
            {
                //don't support both on yet
                hr = MY_HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
                goto NotSupportedError;
            }

            m_fCMCFormat = TRUE;
            m_fHonorIncludeSubjectKeyID = TRUE;
            // create pkcs 10 first
            hr = createPKCS10WStr(
                        pwszDNName,
                        pwszUsage,     //wszPurpose,
                        &blobPKCS10);
            if(S_OK != hr)
            {
                goto createPKCS10WStrError;
            }
            //set it back
            m_fCMCFormat = FALSE;

            //get all extensions
            cb = CountStackExtension(TRUE) * sizeof(CERT_EXTENSION);
            if (0 < cb)
            {
                rgExt = (CERT_EXTENSION*)LocalAlloc(LMEM_FIXED, cb);
                if (NULL == rgExt)
                {    
                    hr = E_OUTOFMEMORY;
                    goto OutOfMemoryError;
                }
                ZeroMemory(rgExt, cb);
                while(NULL != (pExt = EnumStackExtension(pExt, TRUE)))
                {
                    rgExt[cExt] = *pExt;
                    cExt++;
                }
            }

            //get all attributes including namevalue pair
            cb = CountStackAttribute(TRUE) * sizeof(CRYPT_ATTRIBUTE);
            if (NULL != m_PrivateKeyArchiveCertificate)
            {
                //add one more attribute to hold encrypted key hash
                cb += sizeof(CRYPT_ATTRIBUTE);
            }
            if (0 < cb)
            {
                rgAttr = (CRYPT_ATTRIBUTE*)LocalAlloc(LMEM_FIXED, cb);
                if (NULL == rgAttr)
                {
                    hr = E_OUTOFMEMORY;
                    goto OutOfMemoryError;
                }
                ZeroMemory(rgAttr, cb);
                while(NULL != (pAttr = EnumStackAttribute(pAttr, TRUE)))
                {
                    rgAttr[cAttr] = *pAttr;
                    cAttr++;
                }
                rgAttributes.rgAttr = rgAttr;
                rgAttributes.cAttr = cAttr;
            }

            if (NULL != m_PrivateKeyArchiveCertificate)
            {
                hr = GetKeyArchivePKCS7(&blobKeyArchivePKCS7);
                if (S_OK != hr)
                {
                    goto GetKeyArchivePKCS7Error;
                }
                rgUnauthAttr = (CRYPT_ATTRIBUTE*)LocalAlloc(LMEM_FIXED,
                                        sizeof(CRYPT_ATTRIBUTE));
                if (NULL == rgUnauthAttr)
                {
                    hr = E_OUTOFMEMORY;
                    goto OutOfMemoryError;
                }
                rgUnauthAttr->pszObjId = szOID_ARCHIVED_KEY_ATTR;
                rgUnauthAttr->cValue = 1;
                rgUnauthAttr->rgValue = &blobKeyArchivePKCS7;
                ++cUnauthAttr;

                //if key archival cert is set, should save the hash
                //of the encrypted private key

                hr = myCalculateKeyArchivalHash(
                            blobKeyArchivePKCS7.pbData,
                            blobKeyArchivePKCS7.cbData,
                            &blobKAHash.pbData,
                            &blobKAHash.cbData);
                if (S_OK != hr)
                {
                    goto myCalculateKeyArchivalHashError;
                }

                if (!CertSetCertificateContextProperty(
                        m_pCertContextPendingRequest, //use pending cert
                        CERT_ARCHIVED_KEY_HASH_PROP_ID,
                        0,
                        &blobKAHash))
                {
                    hr = MY_HRESULT_FROM_WIN32(GetLastError());
                    goto CertSetCertificateContextPropertyError;
                }

                hr = xeCreateKeyArchivalHashAttribute(
                            &blobKAHash,
                            &blobKAHashAttr);
                if (S_OK != hr)
                {
                    goto xeCreateKeyArchivalHashAttributeError;
                }

                //add this attribute into the array
                rgAttr[cAttr] = attrKAHash;
                cAttr++;
                rgAttributes.rgAttr = rgAttr;
                rgAttributes.cAttr = cAttr;
            }

            //client may set m_HashAlgId but it is not guaranteed
            //GetCapiHashAndSigAlgId will determine which one
            //is actually used
            if (!GetCapiHashAndSigAlgId(rgAlg))
            {
                hr = NTE_BAD_ALGID;
                goto GetCapiHashAndSigAlgIdError;
            }
            pOidInfo = xeCryptFindOIDInfo(
                            CRYPT_OID_INFO_ALGID_KEY,
                            (void*)rgAlg, //point to rgAlg[0]
                            CRYPT_HASH_ALG_OID_GROUP_ID);
            if (NULL == pOidInfo)
            {
                goto xeCryptFindOIDInfoError;
            }

            if (NULL != m_pCertContextRenewal)
            {
                pCertSigner = m_pCertContextRenewal;
            }
            if (NULL != m_pCertContextSigner)
            {
                pCertSigner = m_pCertContextSigner;
            }
            if (NULL != pCertSigner)
            {
                //get signer key prov info
                hr = GetKeyProvInfoFromCert(
                                pCertSigner,
                                &dwKeySpecSigner,
                                &hProvSigner);
                if (S_OK != hr)
                {
                    goto GetKeyProvInfoFromCertError;
                }
            }

            //this is CMC, honor anyway
            if (m_fIncludeSubjectKeyID)
            {
                hr = myGetPublicKeyHash(
                            NULL,
                            m_pPublicKeyInfo,
                            &pbSubjectKeyHash,
                            &cbSubjectKeyHash);
                if (S_OK != hr)
                {
                    goto myGetPublicKeyHashError;
                }
            }
            hRequestProv = GetProv(0);
            if (NULL == hRequestProv)
            {
                hr = MY_HRESULT_FROM_WIN32(GetLastError());
                goto GetProvError;
            }

            //ok, now call cmc create
            hr = BuildCMCRequest(
                        m_lClientId,
                        FALSE,       //fNestedCMCRequest
                        blobPKCS10.pbData,
                        blobPKCS10.cbData,
                        rgExt,
                        cExt,
                        (0 != cAttr) ? &rgAttributes : NULL,
                        (0 != cAttr) ? 1 : 0,
                        rgUnauthAttr,
                        cUnauthAttr,
                        pbSubjectKeyHash,
                        cbSubjectKeyHash,
                        hRequestProv,
                        m_keyProvInfo.dwKeySpec,
                        pOidInfo->pszOID,
                        pCertSigner,
                        hProvSigner,
                        dwKeySpecSigner,
                        NULL, //pOidInfo->pszOID, //this seems to me not necessary because we passed the cert context
                        &pblobRequest->pbData,
                        &pblobRequest->cbData);
            if (S_OK != hr)
            {
                goto BuildCMCRequestError;
            }
        }
        break;

        case XECR_PKCS7:
            if ((NULL == m_pCertContextRenewal &&
                 NULL == m_pCertContextSigner) ||
                NULL != m_PrivateKeyArchiveCertificate)
            {
                //renew cert is not set, can't make it pkcs7
                //pkcs7 can't support key archival
                hr = E_INVALIDARG;
                goto InvalidArgError;
            }
            // old method will return pkcs7
            hr = createPKCS10WStr(
                        pwszDNName,
                        pwszUsage,     //wszPurpose,
                        pblobRequest);
            if(S_OK != hr)
            {
                goto createPKCS10WStrError;
            }
        break;

        case XECR_PKCS10_V1_5:
            m_fOID_V2 = FALSE;
            //fall through
        case XECR_PKCS10_V2_0:

            if (NULL != m_PrivateKeyArchiveCertificate)
            {
                //pkcs10 can't support key archival
                hr = E_INVALIDARG;
                goto InvalidArgError;
            }
            m_fHonorRenew = FALSE; //avoid return pkcs7
            //for new PKCS10 we allow include subject key id extension
            m_fHonorIncludeSubjectKeyID = TRUE;
            // call old method
            hr = createPKCS10WStr(
                        pwszDNName,
                        pwszUsage,     //wszPurpose,
                        pblobRequest);
            if(S_OK != hr)
            {
                goto createPKCS10WStrError;
            }
        break;

        default:
            hr = E_INVALIDARG;
            goto InvalidArgError;
        break;
    }

    //in all cases, we called createPKCS10WStr
    if(m_wszPVKFileName[0] != 0 && !m_fUseExistingKey)
    {
        //we hold on this until possible cmc is created
        GetProv(CRYPT_DELETEKEYSET);
    }

    hr = S_OK;
ErrorReturn:
    m_fNewRequestMethod = FALSE; //critical
    m_fOID_V2 = FALSE; //critical for backward compatiability
    m_fHonorRenew = TRUE; //critical
    m_fHonorIncludeSubjectKeyID = TRUE; //critical for backward compt.
    LeaveCriticalSection(&m_csXEnroll);

    if (NULL != rgExt)
    {
        LocalFree(rgExt);
    }
    if (NULL != rgAttr)
    {
        LocalFree(rgAttr);
    }
    if (NULL != rgUnauthAttr)
    {
        LocalFree(rgUnauthAttr);
    }
    if (NULL != blobKeyArchivePKCS7.pbData)
    {
        MyCoTaskMemFree(blobKeyArchivePKCS7.pbData);
    }
    if (NULL != blobPKCS10.pbData)
    {
        MyCoTaskMemFree(blobPKCS10.pbData);
    }
    if (NULL != hProvSigner)
    {
        CryptReleaseContext(hProvSigner, 0);
    }
    if (NULL != pbSubjectKeyHash)
    {
        LocalFree(pbSubjectKeyHash);
    }
    if (NULL != blobKAHash.pbData)
    {
        LocalFree(blobKAHash.pbData);
    }
    if (NULL != blobKAHashAttr.pbData)
    {
        LocalFree(blobKAHashAttr.pbData);
    }
    return hr;

TRACE_ERROR(AccessDeniedError);
TRACE_ERROR(createPKCS10WStrError)
TRACE_ERROR(BuildCMCRequestError)
TRACE_ERROR(InvalidArgError)
TRACE_ERROR(GetCapiHashAndSigAlgIdError)
TRACE_ERROR(GetKeyArchivePKCS7Error)
TRACE_ERROR(xeCryptFindOIDInfoError)
TRACE_ERROR(OutOfMemoryError)
TRACE_ERROR(GetKeyProvInfoFromCertError)
TRACE_ERROR(NotSupportedError)
TRACE_ERROR(GetProvError)
TRACE_ERROR(myGetPublicKeyHashError)
TRACE_ERROR(CertSetCertificateContextPropertyError)
TRACE_ERROR(myCalculateKeyArchivalHashError)
TRACE_ERROR(xeCreateKeyArchivalHashAttributeError)
}

HRESULT
CCEnroll::BlobToBstring(
    IN   CRYPT_DATA_BLOB   *pBlob,
    IN   DWORD              dwFlag,
    OUT  BSTR              *pBString)
{
    HRESULT           hr;
    WCHAR            *pwszB64;
    DWORD             cch;

    //init
    *pBString = NULL;

    // BASE64 encode blob
    pwszB64 = NULL;
    cch = 0;
    while (TRUE)
    {
        if (!MyCryptBinaryToStringW(
                pBlob->pbData,
                pBlob->cbData,
                dwFlag,
                pwszB64,
                &cch))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto MyCryptBinaryToStringWError;
        }
        if (NULL != pwszB64)
        {
            //got it, done
            break;
        }
        pwszB64 = (WCHAR *)LocalAlloc(LMEM_FIXED, cch * sizeof(WCHAR));
        if (NULL == pwszB64)
        {
            hr = E_OUTOFMEMORY;
            goto OutOfMemoryError;
        }
    }

    // SysAllocStringLen
    *pBString = SysAllocStringLen(pwszB64, cch);
    if(NULL == *pBString)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        hr = E_OUTOFMEMORY;
        goto SysAllocStringLenError;
    }

    hr = S_OK;
ErrorReturn:
    if (NULL != pwszB64)
    {
        LocalFree(pwszB64);
    }
    return(hr);

TRACE_ERROR(MyCryptBinaryToStringWError)
TRACE_ERROR(SysAllocStringLenError)
TRACE_ERROR(OutOfMemoryError)
}

HRESULT
CCEnroll::BstringToBlob(
    IN  BSTR               bString,
    OUT CRYPT_DATA_BLOB   *pBlob)
{
    HRESULT  hr;

    assert(NULL != pBlob);

    //init
    pBlob->pbData = NULL;
    pBlob->cbData = 0;

    while (TRUE)
    {
        if (!MyCryptStringToBinaryW(
                    (LPCWSTR)bString,
                    SysStringLen(bString),
                    CRYPT_STRING_ANY,
                    pBlob->pbData,
                    &pBlob->cbData,
                    NULL,
                    NULL))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto MyCryptStringToBinaryWError;
        }
        if (NULL != pBlob->pbData)
        {
            break; //done
        }
        pBlob->pbData = (BYTE*)MyCoTaskMemAlloc(pBlob->cbData);
        if (NULL == pBlob->pbData)
        {
            hr = E_OUTOFMEMORY;
            goto MyCoTaskMemAllocError;
        }
    }

    hr = S_OK;
ErrorReturn:
    return(hr);

TRACE_ERROR(MyCoTaskMemAllocError)
TRACE_ERROR(MyCryptStringToBinaryWError)
}

HRESULT
CCEnroll::createRequestWStrBStr(
    IN   LONG              Flags,
    IN   LPCWSTR           pwszDNName,
    IN   LPCWSTR           pwszUsage,
    IN   DWORD             dwFlag,
    OUT  BSTR __RPC_FAR   *pbstrRequest)
{
    HRESULT           hr;
    CRYPT_DATA_BLOB   blobRequest;

    memset(&blobRequest, 0, sizeof(blobRequest));

    hr = createRequestWStr(Flags, pwszDNName, pwszUsage, &blobRequest);
    if (S_OK != hr)
    {
        goto createRequestWStrError;
    }

    // convert to bstr
    hr = BlobToBstring(&blobRequest, dwFlag, pbstrRequest);
    if (S_OK != hr)
    {
        goto BlobToBstringError;
    }

    hr = S_OK;
ErrorReturn:
    if(NULL != blobRequest.pbData)
    {
        MyCoTaskMemFree(blobRequest.pbData);
    }
    return(hr);

TRACE_ERROR(createRequestWStrError)
TRACE_ERROR(BlobToBstringError)
}

HRESULT
CCEnroll::BStringToFile(
    IN BSTR         bString,
    IN LPCWSTR      pwszFileName)
{
    HRESULT hr;
    HANDLE  hFile = NULL;
    DWORD   cb = 0;
    LPSTR   sz = NULL;
    size_t  nLength; 

    sz = MBFromWide(bString);
    if(NULL == sz)
    {
        hr = E_OUTOFMEMORY;
        goto MBFromWideError;
    }
    
    nLength = strlen(sz); 
    if (nLength > (DWORD)-1)
	goto InvalidArgError; 

    
    // open the file
    hFile = CreateFileSafely(pwszFileName);
    if (NULL == hFile)
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto CreateFileFileSafelyError;
    }

    // write the pkcs10
    if(!WriteFile(
        hFile,
        sz,
	(DWORD)nLength, 
        &cb,
        NULL))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto WriteFileError;
    }

    hr = S_OK;
ErrorReturn:
    if(NULL != hFile)
    {
        CloseHandle(hFile);
    }
    if(NULL != sz)
    {
        MyCoTaskMemFree(sz);
    }
    return(hr);

TRACE_ERROR(CreateFileFileSafelyError)
SET_HRESULT(InvalidArgError, E_INVALIDARG);
TRACE_ERROR(MBFromWideError)
TRACE_ERROR(WriteFileError)
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::createFileRequestWStr(
    IN   LONG        Flags,
    IN   LPCWSTR     pwszDNName,
    IN   LPCWSTR     pwszUsage,
    IN   LPCWSTR     pwszRequestFileName)
{
    HRESULT hr;
    BSTR    bstrRequest = NULL;

    // get the Request
    hr = createRequestWStrBStr(
                Flags,
                pwszDNName,
                pwszUsage,
                CRYPT_STRING_BASE64REQUESTHEADER,
                &bstrRequest);
    if(S_OK != hr)
    {
        goto createRequestWStrBStrError;
    }

    // save it to file
    hr = BStringToFile(bstrRequest, pwszRequestFileName);
    if (S_OK != hr)
    {
        goto BStringToFileError;
    }

    hr = S_OK;
ErrorReturn:
    if(NULL != bstrRequest)
    {
        SysFreeString(bstrRequest);
    }
    return(hr);

TRACE_ERROR(createRequestWStrBStrError)
TRACE_ERROR(BStringToFileError)
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::acceptResponseBlob(
    IN   PCRYPT_DATA_BLOB   pblobResponse)
{
    HRESULT hr_old = S_OK;
    HRESULT hr;
    XCMCRESPONSE *prgResponse = NULL;
    DWORD         cResponse = 0;

    EnterCriticalSection(&m_csXEnroll);

    //check in parameter
    if (NULL == pblobResponse)
    {
        hr = E_POINTER;
        goto NullPointerError;
    }
    if (NULL == pblobResponse->pbData ||
        0 == pblobResponse->cbData)
    {
        hr = E_INVALIDARG;
        goto InvalidArgError;
    }

    //make sure init archived key hash
    ZeroMemory(&m_blobResponseKAHash, sizeof(m_blobResponseKAHash));

    hr_old = ParseCMCResponse(
                pblobResponse->pbData,
                pblobResponse->cbData,
                NULL,
                &prgResponse,
                &cResponse);
    //note, if for any reasons above failed, try pkcs7
    if (S_OK == hr_old)
    {
        if (1 < cResponse)
        {
            //not supported yet
            hr = MY_HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
            goto NotSupportedError;
        }
#if DBG
        //make sure not zero, should be 1
        assert(1 == cResponse);
#endif //DBG

        //check response status
        if (CMC_STATUS_SUCCESS != prgResponse->StatusInfo.dwStatus)
        {
            hr = prgResponse->StatusInfo.dwStatus; //take status error
            goto CMCResponseStatusError;
        }

        //some code here to get encrypted archived key hash from the response
        //and make m_blobResponseKAHash point to the hash data
        if (NULL != prgResponse->pbEncryptedKeyHash)
        {
            m_blobResponseKAHash.pbData = prgResponse->pbEncryptedKeyHash;
            m_blobResponseKAHash.cbData = prgResponse->cbEncryptedKeyHash;
        }
    }

    //note, hr_old may not be S_OK, accept the response as pkcs7
    hr = acceptPKCS7Blob(pblobResponse);
    if (S_OK != hr)
    {
        if (S_OK != hr_old)
        {
            //return old error instead of new one
            hr = hr_old;
        }
        goto acceptPKCS7BlobError;
    }

    hr = S_OK;
ErrorReturn:
    //reset hash to zero
    ZeroMemory(&m_blobResponseKAHash, sizeof(m_blobResponseKAHash));
    LeaveCriticalSection(&m_csXEnroll);
    if (NULL != prgResponse)
    {
        FreeCMCResponse(prgResponse, cResponse);
    }
    return hr;

TRACE_ERROR(acceptPKCS7BlobError)
TRACE_ERROR(CMCResponseStatusError)
TRACE_ERROR(NotSupportedError)
TRACE_ERROR(InvalidArgError)
TRACE_ERROR(NullPointerError)
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::acceptFileResponseWStr(
    IN   LPCWSTR     pwszResponseFileName)
{
    HRESULT     hr;
    CRYPT_DATA_BLOB  blob;

    ZeroMemory(&blob, sizeof(blob));

    hr = xeStringToBinaryFromFile(
                pwszResponseFileName,
                &blob.pbData,
                &blob.cbData,
                CRYPT_STRING_ANY);
    if (S_OK != hr)
    {
        goto xeStringToBinaryFromFileError;
    }

    // accept the blob
    hr = acceptResponseBlob(&blob);

ErrorReturn:
    if (NULL != blob.pbData)
    {
        LocalFree(blob.pbData);
    }
    return(hr);

TRACE_ERROR(xeStringToBinaryFromFileError)
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::getCertContextFromResponseBlob(
    IN   PCRYPT_DATA_BLOB   pblobResponse,
    OUT  PCCERT_CONTEXT    *ppCertContext)
{
    HRESULT hr;

    if (NULL == ppCertContext)
    {
        hr = E_POINTER;
        goto NullPointerError;
    }

    //???should check response status?

    //response is already in pkcs7
    hr = GetEndEntityCert(pblobResponse, FALSE, ppCertContext);
    if (S_OK != hr)
    {
        goto GetEndEntityCertError;
    }

    hr = S_OK;
ErrorReturn:
    return hr;

TRACE_ERROR(NullPointerError)
TRACE_ERROR(GetEndEntityCertError)
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::getCertContextFromFileResponseWStr(
    IN   LPCWSTR          pwszResponseFileName,
    OUT  PCCERT_CONTEXT  *ppCertContext)
{
    HRESULT hr;
    CRYPT_DATA_BLOB blobResponse;

    ZeroMemory(&blobResponse, sizeof(blobResponse));

    // could be any form, binary or base64
    hr = xeStringToBinaryFromFile(
                pwszResponseFileName,
                &blobResponse.pbData,
                &blobResponse.cbData,
                CRYPT_STRING_ANY);
    if (S_OK != hr)
    {
        goto xeStringToBinaryFromFileError;
    }

    hr = getCertContextFromResponseBlob(
                &blobResponse,
                ppCertContext);
    if (S_OK != hr)
    {
        goto getCertContextFromResponseBlobError;
    }

    hr = S_OK;
ErrorReturn:
    if (NULL != blobResponse.pbData)
    {
        LocalFree(blobResponse.pbData);
    }
    return hr;

TRACE_ERROR(xeStringToBinaryFromFileError)
TRACE_ERROR(getCertContextFromResponseBlobError)
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::createPFXWStr(
    IN   LPCWSTR           pwszPassword,
    OUT  PCRYPT_DATA_BLOB  pblobPFX)
{
    HRESULT hr;
    HCERTSTORE hMemStore = NULL;
    DWORD i;
    CERT_CHAIN_CONTEXT const *pCertChainContext = NULL;
    CERT_CHAIN_PARA CertChainPara;
    CERT_SIMPLE_CHAIN *pSimpleChain;

    EnterCriticalSection(&m_csXEnroll);

    if (NULL == pblobPFX)
    {
        goto EPointerError;
    }

    if (NULL == m_pCertContextStatic)
    {
        hr = E_UNEXPECTED;
        goto UnexpectedError;
    }

    // create a memory store for cert and chain
    hMemStore = CertOpenStore(
                    CERT_STORE_PROV_MEMORY,
                    X509_ASN_ENCODING,
                    NULL,
                    0,
                    NULL);
    if (NULL == hMemStore)
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto CertOpenStoreError;
    }

    ZeroMemory(&CertChainPara, sizeof(CertChainPara));
    CertChainPara.cbSize = sizeof(CertChainPara);

    // try to build cert and chain
    if (!MyCertGetCertificateChain(
                HCCE_CURRENT_USER,
                m_pCertContextStatic,
                NULL,
                NULL,
                &CertChainPara,
                0,
                NULL,
                &pCertChainContext))
    {
        //use 1st hr error
        hr = MY_HRESULT_FROM_WIN32(GetLastError());

        //try local machine
        if (!MyCertGetCertificateChain(
                    HCCE_LOCAL_MACHINE,
                    m_pCertContextStatic,
                    NULL,
                    NULL,
                    &CertChainPara,
                    0,
                    NULL,
                    &pCertChainContext))
        {
            //still use 1st hr
            goto MyCertGetCertificateChainError;
        }
    }

    // make sure there is at least 1 simple chain
    if (0 == pCertChainContext->cChain)
    {
        hr = MY_HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto NoCertificateChainError;
    }

    //add chain to memory store
    pSimpleChain = pCertChainContext->rgpChain[0];
    for (i = 0; i < pSimpleChain->cElement; i++)
    {
        if (!CertAddCertificateContextToStore(
                hMemStore,
                pSimpleChain->rgpElement[i]->pCertContext,
                CERT_STORE_ADD_REPLACE_EXISTING,
                NULL))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto CertAddCertificateContextToStoreError;
        }
    }

    pblobPFX->pbData = NULL;
    while (TRUE)
    {
        if (!PFXExportCertStore(
                hMemStore,
                pblobPFX,
                pwszPassword,
                EXPORT_PRIVATE_KEYS | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto PFXExportCertStoreError;
        }
        if (NULL != pblobPFX->pbData)
        {
            //got it, done
            break;
        }
        pblobPFX->pbData = (BYTE*)MyCoTaskMemAlloc(pblobPFX->cbData);
        if (NULL == pblobPFX->pbData)
        {
            hr = E_OUTOFMEMORY;
            goto MyCoTaskMemAllocError;
        }
    }

    hr = S_OK;
ErrorReturn:
    LeaveCriticalSection(&m_csXEnroll);
    if (pCertChainContext != NULL)
    {
        MyCertFreeCertificateChain(pCertChainContext);
    }
    if (NULL != hMemStore)
    {
        CertCloseStore(hMemStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return hr;


TRACE_ERROR(UnexpectedError)
TRACE_ERROR(CertOpenStoreError)
TRACE_ERROR(PFXExportCertStoreError)
TRACE_ERROR(MyCoTaskMemAllocError)
TRACE_ERROR(CertAddCertificateContextToStoreError)
TRACE_ERROR(NoCertificateChainError)
TRACE_ERROR(MyCertGetCertificateChainError)
SET_HRESULT(EPointerError, E_POINTER)
}

HRESULT
CCEnroll::createPFXWStrBStr( 
    IN  LPCWSTR         pwszPassword,
    OUT BSTR __RPC_FAR *pbstrPFX)
{
    HRESULT           hr;
    CRYPT_DATA_BLOB   blobPFX;

    memset(&blobPFX, 0, sizeof(CRYPT_DATA_BLOB));

    hr = createPFXWStr(pwszPassword, &blobPFX);
    if (S_OK != hr)
    {
        goto createPFXWStrError;
    }

    // convert pfx to bstr
    hr = BlobToBstring(&blobPFX, CRYPT_STRING_BASE64, pbstrPFX);
    if (S_OK != hr)
    {
        goto BlobToBstringError;
    }

    hr = S_OK;
ErrorReturn:
    if(NULL != blobPFX.pbData)
    {
        MyCoTaskMemFree(blobPFX.pbData);
    }
    return(hr);

TRACE_ERROR(createPFXWStrError)
TRACE_ERROR(BlobToBstringError)
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::createFilePFXWStr(
    IN   LPCWSTR     pwszPassword,
    IN   LPCWSTR     pwszPFXFileName)
{
    HRESULT hr;
    HANDLE  hFile = NULL;
    DWORD   cb = 0;
    CRYPT_DATA_BLOB   blobPFX;

    memset(&blobPFX, 0, sizeof(CRYPT_DATA_BLOB));

    hr = createPFXWStr(pwszPassword, &blobPFX);
    if (S_OK != hr)
    {
        goto createPFXWStrError;
    }

    // open the file
    hFile = CreateFileSafely(pwszPFXFileName);
    if (NULL == hFile)
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto CreateFileFileSafelyError;
    }

    // write the pkcs10
    if(!WriteFile(
        hFile,
        blobPFX.pbData,
        blobPFX.cbData,
        &cb,
        NULL))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto WriteFileError;
    }

    hr = S_OK;
ErrorReturn:
    if(NULL != hFile)
    {
        CloseHandle(hFile);
    }
    if(NULL != blobPFX.pbData)
    {
        MyCoTaskMemFree(blobPFX.pbData);
    }
    return(hr);

TRACE_ERROR(createPFXWStrError)
TRACE_ERROR(CreateFileFileSafelyError)
TRACE_ERROR(WriteFileError)
}

HRESULT STDMETHODCALLTYPE
CCEnroll::setPendingRequestInfoWStr(
    IN   LONG     lRequestID,
    IN   LPCWSTR  pwszCADNS,
    IN   LPCWSTR  pwszCAName,
    IN   LPCWSTR  pwszFriendlyName
    )
{

    //------------------------------------------------------------
    //
    // Define locally-scoped helper functions: 
    //
    //------------------------------------------------------------

    CEnrollLocalScope(SetPendingRequestInfoHelper): 
        // Finds the appropriate cert context to set pending info on using the following algorithm:
        //   1) If a hash value HAS NOT been specified, use the cached cert request.  
        //   2) If a hash value HAS been specified, search the request store for a cert with an equivalent
        //      hash value and return it.  If no such cert can be found, return an error code. 
        HRESULT GetPendingRequestCertContext(IN  HCERTSTORE       hStoreRequest,
                                             IN  CRYPT_DATA_BLOB  hashBlob, 
                                             IN  PCCERT_CONTEXT   pCertContextCachedPendingRequest,
                                             OUT PCCERT_CONTEXT  *pCertContextPendingRequest)
        {
            EquivalentHashCertContextFilter filter(hashBlob); 
            
            if (hashBlob.pbData == NULL)
            {
                // We haven't specified a particular context, use the one we've cached. 
                *pCertContextPendingRequest = CertDuplicateCertificateContext(pCertContextCachedPendingRequest); 
                return S_OK; 
            }
            else
            {
                // Returns the first certificate in the request store with a hash matching 
                // pHashBlob.  
                return FilteredCertEnumCertificatesInStore
                    (hStoreRequest, NULL, &filter, pCertContextPendingRequest); 
            }
        }


        DWORD   GetPendingInfoBlobSize(IN  LONG              lRequestID,
                                       IN  LPCWSTR           pwszCADNS,
                                       IN  LPCWSTR           pwszCAName, 
                                       IN  LPCWSTR           pwszFriendlyName)
        {
            assert(pwszCADNS != NULL && pwszCAName != NULL && pwszFriendlyName != NULL); 
            
            return  (DWORD)(sizeof(lRequestID) +                            // Request ID
                     sizeof(DWORD) +                                 // wcslen(pwszCADNS)
                     sizeof(WCHAR) * (wcslen(pwszCADNS) + 1) +       // pwszCADNS
                     sizeof(DWORD) +                                 // wcslen(pwszCAName)
                     sizeof(WCHAR) * (wcslen(pwszCAName) + 1) +      // pwszCAName
                     sizeof(DWORD) +                                 // wcslen(pwszFriendlyName)
                     sizeof(WCHAR) * (wcslen(pwszFriendlyName) + 1)  // pwszFriendlyName
                     ); 
        }


        // Combines the supplied pending request information into a CRYPT_DATA_BLOB 
        // See wincrypt.h for the format.  
        void MakePendingInfoBlob(IN  LONG              lRequestID,
                                 IN  LPCWSTR           pwszCADNS,
                                 IN  LPCWSTR           pwszCAName, 
                                 IN  LPCWSTR           pwszFriendlyName, 
                                 OUT CRYPT_DATA_BLOB   pendingInfoBlob)
        {
            LPBYTE  pbBlob; 

            // None of the inputs should be NULL. 
            assert(pwszCADNS != NULL && pwszCAName != NULL && pwszFriendlyName != NULL); 

            // Declare an array of the strings we wish to write to the pending info blob
            struct StringsToWrite { 
                DWORD    cc; 
                LPCWSTR  pwsz;
            } rgStrings[] = { 
                { (DWORD)wcslen(pwszCADNS)        + 1, pwszCADNS         }, 
                { (DWORD)wcslen(pwszCAName)       + 1, pwszCAName        }, 
                { (DWORD)wcslen(pwszFriendlyName) + 1, pwszFriendlyName  }
            }; 

            // Write the request ID to the blob
            pbBlob = pendingInfoBlob.pbData; 
            memcpy(pbBlob, &lRequestID, sizeof(lRequestID)); 
            pbBlob += sizeof(lRequestID); 

            // Write all strings to the blob
            for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(rgStrings); dwIndex++) 
            { 
                memcpy(pbBlob, &rgStrings[dwIndex].cc, sizeof(rgStrings[dwIndex].cc)); 
                pbBlob += sizeof(rgStrings[dwIndex].cc);
                memcpy(pbBlob, rgStrings[dwIndex].pwsz, rgStrings[dwIndex].cc * sizeof(WCHAR)); 
                pbBlob += rgStrings[dwIndex].cc * sizeof(WCHAR); 
            }

            assert(pbBlob == (pendingInfoBlob.pbData + pendingInfoBlob.cbData)); 
        }
    CEnrollEndLocalScope; 

    //------------------------------------------------------------ 
    //
    // Begin procedure body.
    //
    //------------------------------------------------------------

    CRYPT_DATA_BLOB  pendingInfoBlob;
    HCERTSTORE       hStoreRequest; 
    HRESULT          hr                         = S_OK; 
    PCCERT_CONTEXT   pCertContextPendingRequest = NULL; 

    ZeroMemory(&pendingInfoBlob, sizeof(pendingInfoBlob)); 

    EnterCriticalSection(&m_csXEnroll); 

    // Input validation: 
    if (lRequestID < 0 || pwszCADNS == NULL || pwszCAName == NULL)
        goto InvalidArgErr; 

    // NULL is a valid value for pwszFriendlyName.  If friendly name is NULL, replace with the empty string: 
    if (pwszFriendlyName == NULL) { pwszFriendlyName = L""; }

    if (NULL == (hStoreRequest = GetStore(StoreREQUEST)) )
        goto GetStoreErr; 

    // Use our locally-scoped helper function to acquire the appropriate certificate context. 
    if (S_OK != (hr = local.GetPendingRequestCertContext
                 (hStoreRequest,
                  m_hashBlobPendingRequest, 
                  m_pCertContextPendingRequest,
                  &pCertContextPendingRequest)))
        goto GetPendingRequestCertContextErr; 

    // Allocate memory for our pending info blob: 
    pendingInfoBlob.cbData  = local.GetPendingInfoBlobSize
        (lRequestID,
         pwszCADNS,
         pwszCAName,
         pwszFriendlyName); 
    pendingInfoBlob.pbData  = (LPBYTE)LocalAlloc(LPTR, pendingInfoBlob.cbData); 
    if (NULL == pendingInfoBlob.pbData)
        goto MemoryErr; 

    // Combine our arguments into a "pending info" blob.
    local.MakePendingInfoBlob
        (lRequestID, 
         pwszCADNS, 
         pwszCAName,
         pwszFriendlyName,
         pendingInfoBlob);
                  
    // Use our pending info blob to assign the certificate context property. 
    if (!CertSetCertificateContextProperty
        (pCertContextPendingRequest, 
         CERT_ENROLLMENT_PROP_ID, 
         0,
         &pendingInfoBlob))
    {
        // Failed to set the context property. 
        goto CertSetCertificateContextPropertyErr; 
    }

    // We've completed successfully. 
    hr = S_OK;   

 CommonReturn: 
    if (NULL != pendingInfoBlob.pbData)      { LocalFree(pendingInfoBlob.pbData); }
    if (NULL != pCertContextPendingRequest)  { CertFreeCertificateContext(pCertContextPendingRequest); } 

    LeaveCriticalSection(&m_csXEnroll); 
    return hr; 

 ErrorReturn:
    goto CommonReturn; 

SET_HRESULT(CertSetCertificateContextPropertyErr,  MY_HRESULT_FROM_WIN32(GetLastError())); 
SET_HRESULT(GetPendingRequestCertContextErr,       hr); 
SET_HRESULT(GetStoreErr,                           MY_HRESULT_FROM_WIN32(GetLastError())); 
SET_HRESULT(InvalidArgErr,                         E_INVALIDARG); 
SET_HRESULT(MemoryErr,                             E_OUTOFMEMORY); 
} 

//--------------------------------------------------------------------------------
//
// THIS METHOD IS NOT SAFE FOR SCRIPTING
//
//--------------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CCEnroll::enumPendingRequestWStr(
    IN  LONG   lIndex,
    IN  LONG   lDesiredProperty,
    OUT LPVOID ppProperty
    )
{

    //------------------------------------------------------------
    //
    // Define locally scoped helper functions.
    //
    //------------------------------------------------------------

    CEnrollLocalScope(EnumPendingRequestHelper): 
        CRYPT_DATA_BLOB dataBlob;
    
        HRESULT GetContextPropertySimple(PCCERT_CONTEXT pCertContext, DWORD dwPropID)
        {
            BOOL fDone = FALSE;
            dataBlob.pbData = NULL; 
            dataBlob.cbData = 0x150; 

            do { 
                if (dataBlob.pbData != NULL) { LocalFree(dataBlob.pbData); } 

                dataBlob.pbData = (LPBYTE)LocalAlloc(LPTR, dataBlob.cbData);
                if (dataBlob.pbData == NULL) { return E_OUTOFMEMORY; } 

                if (!CertGetCertificateContextProperty
                    (pCertContext, 
                     dwPropID, 
                     (LPVOID)dataBlob.pbData, 
                     &(dataBlob.cbData)))
                {
                    if (GetLastError() != ERROR_MORE_DATA)
                        return MY_HRESULT_FROM_WIN32(GetLastError());
                }
                else 
                {
                    fDone = TRUE;
                }
            } while (!fDone); 
                
            return S_OK;
        }

        // Extracts the next packed string from our pending info blob. 
        // If pbString is non-NULL, it must be large enough to hold the entire string.  
        LPBYTE GetNextString(IN LPBYTE pbBlob, OUT DWORD *pcbSize, OUT LPBYTE pbString) { 
            DWORD dwSize; 

            memcpy(&dwSize, pbBlob, sizeof(DWORD)); 
            dwSize *= sizeof(WCHAR); // Convert to count in bytes. 
            if (NULL != pcbSize) { 
                *pcbSize = dwSize; 
            }
            pbBlob += sizeof(DWORD); 

            if (NULL != pbString) { 
                memcpy(pbString, pbBlob, dwSize); 
            }
            pbBlob += dwSize;

            return pbBlob; 
        }

    
        HRESULT getRequestID(PCCERT_CONTEXT pCertContext, long *pplProperty) {
            HRESULT hr; 
            if (S_OK == (hr = GetContextPropertySimple(pCertContext, CERT_ENROLLMENT_PROP_ID))) 
                *pplProperty = *((long *)dataBlob.pbData); 
            return hr;
        }
        
        HRESULT getCAName(PCCERT_CONTEXT pCertContext, PCRYPT_DATA_BLOB pDataBlobProperty) { 
            DWORD    dwSize; 
            HRESULT  hr; 
            LPBYTE   pb;
            
            if (S_OK == (hr = GetContextPropertySimple(pCertContext, CERT_ENROLLMENT_PROP_ID))) 
            { 
                pb =  dataBlob.pbData + sizeof(DWORD);  // pb points to DNS Name blob
                pb =  GetNextString(pb, NULL, NULL);    // pb points to CA Name blob
                GetNextString(pb, &dwSize, NULL);       // dwSize = size in chars of CA Name
                
                // If pbData is NULL, we're just doing a size check. 
                if (pDataBlobProperty->pbData != NULL)
                {
                    if (pDataBlobProperty->cbData < dwSize)
                    {
                        hr = MY_HRESULT_FROM_WIN32(ERROR_MORE_DATA); 
                    }
                    else
                    {
                        GetNextString(pb, NULL, pDataBlobProperty->pbData); 
                    }   
                }

                pDataBlobProperty->cbData = dwSize; 
            }
            
            return hr; 
        }
        
        HRESULT getCADNSName(PCCERT_CONTEXT pCertContext, PCRYPT_DATA_BLOB pDataBlobProperty) { 
            DWORD    dwSize; 
            HRESULT  hr; 
            LPBYTE   pb;
            
            if (S_OK == (hr = GetContextPropertySimple(pCertContext, CERT_ENROLLMENT_PROP_ID))) 
            { 
                pb = dataBlob.pbData + sizeof(DWORD); // pb points to DNS Name blob
                GetNextString(pb, &dwSize, NULL);     // dwSize = size in chars of CA Name
                
                // If pbData is NULL, we're just doing a size check. 
                if (pDataBlobProperty->pbData != NULL)
                {
                    if (pDataBlobProperty->cbData < dwSize)
                    {
                        hr = MY_HRESULT_FROM_WIN32(ERROR_MORE_DATA); 
                    }
                    else
                    {
                        GetNextString(pb, NULL, pDataBlobProperty->pbData); 
                    }   
                }

                pDataBlobProperty->cbData = dwSize; 
            }
            
            return hr; 
        }
        
        HRESULT getCAFriendlyName(PCCERT_CONTEXT pCertContext, PCRYPT_DATA_BLOB pDataBlobProperty) { 
            DWORD    dwSize; 
            HRESULT  hr; 
            LPBYTE   pb;
            
            if (S_OK == (hr = GetContextPropertySimple(pCertContext, CERT_ENROLLMENT_PROP_ID))) 
            { 
                // Set pb to point to the start of the CA name blob
                pb =  dataBlob.pbData + sizeof(DWORD);        // pb points to DNS Name blob
                pb =  GetNextString(pb, NULL, NULL);          // pb points to CA Name blob
                pb =  GetNextString(pb, NULL, NULL);          // pb points to Friendly Name blob

                // dwSize <-- size in chars of CA Name
                GetNextString(pb, &dwSize, NULL);
                
                // If pbData is NULL, we're just doing a size check. 
                if (pDataBlobProperty->pbData != NULL)
                {
                    if (pDataBlobProperty->cbData < dwSize)
                    {
                        hr = MY_HRESULT_FROM_WIN32(ERROR_MORE_DATA); 
                    }
                    else
                    {
                        GetNextString(pb, NULL, pDataBlobProperty->pbData); 
                    }   
                }

                pDataBlobProperty->cbData = dwSize; 
            }

            return hr; 
        }

        HRESULT getHash(PCCERT_CONTEXT pCertContext, PCRYPT_DATA_BLOB pDataBlobProperty) { 
            HRESULT hr;

            if (S_OK == (hr = GetContextPropertySimple(pCertContext, CERT_HASH_PROP_ID)))
            {
                // If pbData is NULL, we're just doing a size check. 
                if (pDataBlobProperty->pbData != NULL)
                {
                    if (pDataBlobProperty->cbData < dataBlob.cbData)
                    {
                        hr = MY_HRESULT_FROM_WIN32(ERROR_MORE_DATA); 
                    }
                    else
                    {
                        memcpy(pDataBlobProperty->pbData, dataBlob.pbData, dataBlob.cbData); 
                    }
                }
                
                pDataBlobProperty->cbData = dataBlob.cbData; 
            }

            return hr; 
        }
        
        HRESULT getDate(PCCERT_CONTEXT pCertContext, PFILETIME pftProperty) { 
            *pftProperty = pCertContext->pCertInfo->NotAfter; 
            return S_OK; 
        } 

        HRESULT getTemplateName(PCCERT_CONTEXT pCertContext, PCRYPT_DATA_BLOB pDataBlobProperty)   { 
            CERT_NAME_VALUE   *pCertTemplateNameValue = NULL;
            DWORD             cbCertTemplateNameValue; 
            DWORD             cbRequired = 0; 
            HRESULT           hr                      = S_OK; 
            PCERT_EXTENSION   pCertTemplateExtension  = NULL; 

            if (NULL == (pCertTemplateExtension = CertFindExtension
                         (szOID_ENROLL_CERTTYPE_EXTENSION,
                          pCertContext->pCertInfo->cExtension,
                          pCertContext->pCertInfo->rgExtension)))
                return E_INVALIDARG; 

            if (!CryptDecodeObject
                (pCertContext->dwCertEncodingType,
                 X509_UNICODE_ANY_STRING,
                 pCertTemplateExtension->Value.pbData,
                 pCertTemplateExtension->Value.cbData,
                 0,
                 NULL, 
                 &cbCertTemplateNameValue) || (cbCertTemplateNameValue == 0))
                goto CryptDecodeObjectErr; 
                
            pCertTemplateNameValue = (CERT_NAME_VALUE *)LocalAlloc(LPTR, cbCertTemplateNameValue); 
            if (NULL == pCertTemplateNameValue)
                goto MemoryErr; 

            if (!CryptDecodeObject
                (pCertContext->dwCertEncodingType,
                 X509_UNICODE_ANY_STRING,
                 pCertTemplateExtension->Value.pbData,
                 pCertTemplateExtension->Value.cbData,
                 0,
                 (void *)(pCertTemplateNameValue), 
                 &cbCertTemplateNameValue))
                goto CryptDecodeObjectErr; 

            cbRequired = sizeof(WCHAR) * (DWORD)(wcslen((LPWSTR)(pCertTemplateNameValue->Value.pbData)) + 1);
            if (NULL != pDataBlobProperty->pbData)
            {
                // Make sure we've allocated a large enough buffer: 
                if (pDataBlobProperty->cbData < cbRequired) { goto MoreDataErr; } 

                // Write the template name to the OUT param: 
                wcscpy((LPWSTR)pDataBlobProperty->pbData, (LPWSTR)(pCertTemplateNameValue->Value.pbData)); 
            }
                    
            hr = S_OK;
        CommonReturn: 
            // Assign the size of the template name to the cb of the OUT param.  
            // This should be done for all code paths.
            pDataBlobProperty->cbData = cbRequired; 
            
            // Free resources: 
            if (NULL != pCertTemplateNameValue) { LocalFree(pCertTemplateNameValue); }
            return hr; 

        ErrorReturn: 
            goto CommonReturn; 

        SET_HRESULT(CryptDecodeObjectErr, MY_HRESULT_FROM_WIN32(GetLastError())); 
        SET_HRESULT(MoreDataErr,   MY_HRESULT_FROM_WIN32(ERROR_MORE_DATA)); 
        SET_HRESULT(MemoryErr,     E_OUTOFMEMORY); 
        }

	HRESULT getTemplateOID(PCCERT_CONTEXT pCertContext, PCRYPT_DATA_BLOB pDataBlobProperty)    { 
            CERT_TEMPLATE_EXT  *pCertTemplateExt    = NULL; 
	    DWORD               cbCertTemplateExt   = 0; 
            DWORD               cbRequired = 0; 
	    HRESULT             hr;
            LPWSTR              pwszOID             = NULL; 
	    PCERT_EXTENSION     pCertExtension      = NULL; 
            
 	    if (NULL == (pCertExtension = CertFindExtension
			 (szOID_CERTIFICATE_TEMPLATE, 
			  pCertContext->pCertInfo->cExtension,
			  pCertContext->pCertInfo->rgExtension)))
		return E_INVALIDARG; 

            if (FALSE == CryptDecodeObject
		(pCertContext->dwCertEncodingType,
		 X509_CERTIFICATE_TEMPLATE,
		 pCertExtension->Value.pbData,
		 pCertExtension->Value.cbData,
		 0,
		 NULL, 
		 &cbCertTemplateExt) || (cbCertTemplateExt == 0))
                goto CryptDecodeObjectErr;
            
	    pCertTemplateExt = (CERT_TEMPLATE_EXT *)LocalAlloc(LPTR, cbCertTemplateExt); 
	    if (NULL == pCertTemplateExt)
		goto MemoryErr; 

	    if (FALSE == CryptDecodeObject
		(pCertContext->dwCertEncodingType,
		 X509_CERTIFICATE_TEMPLATE,
		 pCertExtension->Value.pbData,
		 pCertExtension->Value.cbData,
		 0,
		 (void *)(pCertTemplateExt), 
		 &cbCertTemplateExt))
		goto CryptDecodeObjectErr;

            cbRequired = sizeof(WCHAR) * (DWORD)(strlen(pCertTemplateExt->pszObjId) + 1); 

	    // See if we're just doing a size check: 
	    if (NULL != pDataBlobProperty->pbData) 
            {
                // Make sure we've allocated a large enough buffer: 
                if (pDataBlobProperty->cbData < cbRequired) { goto MoreDataErr; }
                
                // Convert the OID to a LPWSTR:
                pwszOID = WideFromMB(pCertTemplateExt->pszObjId); 
                if (NULL == pwszOID) 
                    goto WideFromMBErr; 

                // Write the template OID to the OUT param: 
                wcscpy((LPWSTR)pDataBlobProperty->pbData, pwszOID); 
            }

            hr = S_OK; 
        CommonReturn:
            // Assign the size of the OID to the cb of the OUT param.  
            // This should be done for all code paths.
            pDataBlobProperty->cbData = cbRequired; 

            // Free resources: 
            if (NULL != pCertTemplateExt) { LocalFree(pCertTemplateExt); } 
            if (NULL != pwszOID)          { MyCoTaskMemFree(pwszOID); }

            return hr; 
        ErrorReturn:
            goto CommonReturn;

	SET_HRESULT(CryptDecodeObjectErr, MY_HRESULT_FROM_WIN32(GetLastError())); 
        SET_HRESULT(MemoryErr,            E_OUTOFMEMORY); 
        SET_HRESULT(MoreDataErr,          MY_HRESULT_FROM_WIN32(ERROR_MORE_DATA)); 
        SET_HRESULT(WideFromMBErr,        MY_HRESULT_FROM_WIN32(GetLastError())); 
        } 
        
        HRESULT getVersion(PCCERT_CONTEXT pCertContext, long *plVersion) {
            CERT_TEMPLATE_EXT  *pCertTemplateExt    = NULL; 
	    DWORD               cbCertTemplateExt   = 0; 
	    HRESULT             hr;
	    PCERT_EXTENSION     pCertExtension      = NULL; 
            
 	    if (NULL == (pCertExtension = CertFindExtension
			 (szOID_CERTIFICATE_TEMPLATE, 
			  pCertContext->pCertInfo->cExtension,
			  pCertContext->pCertInfo->rgExtension)))
		return E_INVALIDARG; 

            if (FALSE == CryptDecodeObject
		(pCertContext->dwCertEncodingType,
		 X509_CERTIFICATE_TEMPLATE,
		 pCertExtension->Value.pbData,
		 pCertExtension->Value.cbData,
		 0,
		 NULL, 
		 &cbCertTemplateExt) || (cbCertTemplateExt == 0))
		goto CryptDecodeObjectErr;
            
	    pCertTemplateExt = (CERT_TEMPLATE_EXT *)LocalAlloc(LPTR, cbCertTemplateExt); 
	    if (NULL == pCertTemplateExt)
		goto MemoryErr; 

	    if (FALSE == CryptDecodeObject
		(pCertContext->dwCertEncodingType,
		 X509_CERTIFICATE_TEMPLATE,
		 pCertExtension->Value.pbData,
		 pCertExtension->Value.cbData,
		 0,
		 (void *)(pCertTemplateExt), 
		 &cbCertTemplateExt))
		goto CryptDecodeObjectErr;

            *plVersion = (long)pCertTemplateExt->dwMajorVersion; 
            hr = S_OK; 
        CommonReturn:
            // Free resources: 
            if (NULL != pCertTemplateExt) { LocalFree(pCertTemplateExt); } 

            return hr; 
        ErrorReturn:
            goto CommonReturn;

	SET_HRESULT(CryptDecodeObjectErr, MY_HRESULT_FROM_WIN32(GetLastError())); 
        SET_HRESULT(MemoryErr,            E_OUTOFMEMORY); 
        }

        void InitLocalScope() { 
            dataBlob.cbData = 0;
            dataBlob.pbData = NULL;
        }

        void FreeLocalScope() { if (dataBlob.pbData != NULL) { LocalFree(dataBlob.pbData); } }

    CEnrollEndLocalScope;
        
    //------------------------------------------------------------
    //
    // Begin procedure body.
    //
    //------------------------------------------------------------

    // FIXME: index is 0 based, correct?
    // m_dwLastPendingRequestIndex = 0; 
    // m_pCertContextLastEnumerated

    HCERTSTORE                hStoreRequest     = NULL;
    HRESULT                   hr                = S_OK; 
    PCCERT_CONTEXT            pCertContext      = NULL;

    // Input validiation:
    if (lIndex != XEPR_ENUM_FIRST && (lIndex < 0 || (ppProperty == NULL)))
        return E_INVALIDARG; 

    if (0 != m_dwEnabledSafteyOptions) // not safe for scripting
	return E_ACCESSDENIED; 

    // Init: 
    local.InitLocalScope(); 

    EnterCriticalSection(&m_csXEnroll);
    
    if ( NULL == (hStoreRequest = GetStore(StoreREQUEST)) )
        goto ErrorCertOpenRequestStore; 

    // If we're passed the ENUM_FIRST flag, reconstruct a snapshot of the request store. 
    // 
    if (lIndex == XEPR_ENUM_FIRST)
    {
        if (NULL != this->m_pPendingRequestTable) { delete this->m_pPendingRequestTable; } 

        this->m_pPendingRequestTable = new PendingRequestTable; 
        if (NULL == this->m_pPendingRequestTable)
            goto MemoryErr; 

        if (S_OK != (hr = this->m_pPendingRequestTable->construct(hStoreRequest)))
            goto ErrorConstructPendingTable; 
        
        // All done, return.  
        goto CommonReturn; 
    }

    // We want the lIndex'th element the request store.  
    // First, ensure that the enumeration is initialized: 
    if (NULL == m_pPendingRequestTable)
        goto PointerErr; 

    // Index past the end of the table.  
    if (this->m_pPendingRequestTable->size() <= (DWORD)lIndex)
    { 
        hr = MY_HRESULT_FROM_WIN32(CRYPT_E_NOT_FOUND);
        goto ErrorReturn; 
    }

    pCertContext = (*this->m_pPendingRequestTable)[(DWORD)lIndex]; 

    switch (lDesiredProperty)
        {
        case XEPR_REQUESTID:       hr = local.getRequestID      (pCertContext, (long *)ppProperty);             break; 
        case XEPR_CANAME:          hr = local.getCAName         (pCertContext, (PCRYPT_DATA_BLOB)ppProperty);   break; 
        case XEPR_CAFRIENDLYNAME:  hr = local.getCAFriendlyName (pCertContext, (PCRYPT_DATA_BLOB)ppProperty);   break; 
        case XEPR_CADNS:           hr = local.getCADNSName      (pCertContext, (PCRYPT_DATA_BLOB)ppProperty);   break; 
        case XEPR_DATE:            hr = local.getDate           (pCertContext, (PFILETIME)ppProperty);          break; 
        case XEPR_V1TEMPLATENAME:  hr = local.getTemplateName   (pCertContext, (PCRYPT_DATA_BLOB)ppProperty);   break; 
        case XEPR_V2TEMPLATEOID:   hr = local.getTemplateOID    (pCertContext, (PCRYPT_DATA_BLOB)ppProperty);   break; 
        case XEPR_VERSION:         hr = local.getVersion        (pCertContext, (long *)ppProperty);             break; 
        case XEPR_HASH:            hr = local.getHash           (pCertContext, (PCRYPT_DATA_BLOB)ppProperty);   break; 
        default: 
            hr = E_INVALIDARG; 
        }

 CommonReturn: 
    local.FreeLocalScope(); 

    LeaveCriticalSection(&m_csXEnroll); 
    return hr; 

 ErrorReturn:
    goto CommonReturn; 

SET_HRESULT(MemoryErr, E_OUTOFMEMORY); 
SET_HRESULT(PointerErr, E_POINTER);
TRACE_ERROR(ErrorCertOpenRequestStore); 
TRACE_ERROR(ErrorConstructPendingTable);
}


HRESULT STDMETHODCALLTYPE
CCEnroll::removePendingRequestWStr
  (IN CRYPT_DATA_BLOB thumbPrintBlob
   )
{
    EquivalentHashCertContextFilter equivHashFilter(thumbPrintBlob); 
    PendingCertContextFilter        pendingCertFilter; 
    // combinedFilter now only allows PENDING requests which match the specified thumbprint. 
    CompositeCertContextFilter      combinedFilter(&equivHashFilter, &pendingCertFilter); 

    HCERTSTORE                      hStoreRequest = NULL;
    HRESULT                         hr;
    PCCERT_CONTEXT                  pCertContext  = NULL;

    EnterCriticalSection(&m_csXEnroll); 
    
    // Input validation. 
    if (NULL == thumbPrintBlob.pbData)
    {
        hr = E_INVALIDARG; 
        goto ErrorReturn; 
    }


    if ( NULL == (hStoreRequest = GetStore(StoreREQUEST)) )
    {
        hr = E_UNEXPECTED; 
        goto ErrorReturn;
    }
    
    if (S_OK != (hr = FilteredCertEnumCertificatesInStore
                 (hStoreRequest, 
                  NULL, 
                  &combinedFilter, 
                  &pCertContext))) 
        goto ErrorReturn; 

    if (!CertDeleteCertificateFromStore(pCertContext))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError()); 
        // CertDeleteCertificateFromStore *always* deletes the cert context. 
        pCertContext = NULL; 
        goto ErrorReturn;
    }
    
    pCertContext = NULL; 
    hr = S_OK; 
    
 CommonReturn:
    LeaveCriticalSection(&m_csXEnroll); 

    return hr; 

 ErrorReturn:
    if (pCertContext != NULL) { CertFreeCertificateContext(pCertContext); } 
    goto CommonReturn; 
}


HRESULT FilteredCertEnumCertificatesInStore(IN  HCERTSTORE          hStore, 
                                            IN  PCCERT_CONTEXT      pCertContext, 
                                            IN  CertContextFilter  *pFilter, 
                                            OUT PCCERT_CONTEXT     *pCertContextNext)
{
    BOOL           fFilterResult; 
    HRESULT        hr = S_OK; 
    PCCERT_CONTEXT pCertContextPrev = pCertContext; 

    while (NULL != (pCertContext = CertEnumCertificatesInStore(hStore, pCertContextPrev)))
    {
        if (S_OK != (hr = pFilter->accept(pCertContext, &fFilterResult)))
            return hr;

        if (fFilterResult) // We've found the next cert context in the filtered enumeration.  
        {
            *pCertContextNext = pCertContext; 
            return S_OK; 
        }
        pCertContextPrev = pCertContext; 
    }

    return MY_HRESULT_FROM_WIN32(CRYPT_E_NOT_FOUND); 
}

static LPVOID MyLocalAlloc(ULONG cb) {
    return((LPVOID) LocalAlloc(LPTR, (UINT) cb));
}

static LPVOID MyLocalRealloc(LPVOID ptr, ULONG cb) {
    return((LPVOID) LocalReAlloc((HLOCAL) ptr, (UINT) cb, LMEM_MOVEABLE));
}

static void MyLocalFree(LPVOID ptr) {
    LocalFree((HLOCAL) ptr);
}


//
// From xtan, an explanation of the "no-COM" APIs:  
//   "In early time xenroll interface IDs were not in uuid.lib so this
//   was a convenient C interface for people to get xenroll COM interfaces without 
//   call CoCreateInstance. It is not in MSDN but it is in SDK headers. 
//   I created the same API for consistency when I created ICEnroll4."
//
void * WINAPI PGetIEnrollNoCOM(const IID &iid) {

        void *      pvoid               = NULL;
        IClassFactory * pIClassFactory  = NULL;
        HRESULT         hr                                  = S_OK;

        MyCoTaskMemAlloc        = MyLocalAlloc;
        MyCoTaskMemFree         = MyLocalFree;
        MyCoTaskMemRealloc      = MyLocalRealloc;

        if( S_OK != (hr = DllGetClassObject(CLSID_CEnroll2, IID_IClassFactory,  (void **) &pIClassFactory)) ) {
                pIClassFactory = NULL;
        }
        else if( S_OK != (hr = pIClassFactory->CreateInstance(NULL, iid, &pvoid)) ) {
        pvoid = NULL;
    }

        if(pIClassFactory != NULL) {
            pIClassFactory->Release();
            pIClassFactory = NULL;
        }

    SetLastError(hr);
        return(pvoid);
}

IEnroll * WINAPI PIEnrollGetNoCOM(void) 
{
    return( (IEnroll *) PGetIEnrollNoCOM(IID_IEnroll) );
}

IEnroll2 * WINAPI PIEnroll2GetNoCOM(void) 
{
    return( (IEnroll2 *) PGetIEnrollNoCOM(IID_IEnroll2) );
}

IEnroll4 * WINAPI PIEnroll4GetNoCOM(void) 
{
    return( (IEnroll4 *) PGetIEnrollNoCOM(IID_IEnroll4) );
}

HRESULT PendingRequestTable::resize(DWORD dwNewSize)
{
    TableElem * newTable = NULL;

    if (dwNewSize <= 0)
        return E_INVALIDARG; 

    newTable = (TableElem *)LocalAlloc(LPTR, sizeof(TableElem) * dwNewSize); 
    if (NULL == newTable)
        return E_OUTOFMEMORY; 

    if (NULL != this->table)
    {
        memcpy(newTable, this->table, this->dwElemSize * sizeof(TableElem)); 
        LocalFree(this->table);
    }

    this->dwElemSize = dwNewSize; 
    this->table      = newTable; 

    return S_OK; 
}

HRESULT PendingRequestTable::add(TableElem tePendingRequest)
{
    HRESULT hr; 

    if        (this->dwElemCount >  this->dwElemSize) { return E_UNEXPECTED; } 
    else if   (this->dwElemCount == this->dwElemSize) 
    { 
        // Need to allocate more memory: 
        DWORD dwNewSize = this->dwElemSize < 100 ? 100 : this->dwElemSize * 2; 

        if (S_OK != (hr = this->resize(dwNewSize)))
            return hr; 
    }
        
    this->table[this->dwElemCount++] = tePendingRequest; 
    return S_OK; 
}

PendingRequestTable::PendingRequestTable() : table(NULL), dwElemSize(0), dwElemCount(0)
{ }

PendingRequestTable::~PendingRequestTable()
{
    if (NULL != this->table)
    {
        for (DWORD dwIndex = 0; dwIndex < dwElemCount; dwIndex++)
        {
            CertFreeCertificateContext(this->table[dwIndex].pCertContext); 
        }

        LocalFree(this->table);
    }
}
        
        

HRESULT PendingRequestTable::construct(HCERTSTORE hStore)
{
    HRESULT                  hr                 = S_OK; 
    PendingCertContextFilter pendingFilter; 
    PCCERT_CONTEXT           pCertContext       = NULL;
    PCCERT_CONTEXT           pCertContextPrev   = NULL;
    TableElem                tePendingRequest; 

    // Enumerate all pending cert contexts, and add them to our table: 
    for (DWORD dwIndex = 0; TRUE; dwIndex++)
    {
        if (S_OK != (hr = FilteredCertEnumCertificatesInStore
                     (hStore, 
                      pCertContextPrev, 
                      &pendingFilter, 
                      &pCertContext)))
            break; 

        tePendingRequest.pCertContext = CertDuplicateCertificateContext(pCertContext); 
        this->add(tePendingRequest); 

        pCertContextPrev = pCertContext; 
    }

    return hr == MY_HRESULT_FROM_WIN32(CRYPT_E_NOT_FOUND) ? S_OK : hr; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xenroll\ossload.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ossload.cpp
//
//  Contents:   On demand loading of msoss.dll
//
//  Functions:  OssLoad
//              OssUnload
//
//  Forwarders: ossEncode
//              ossDecode
//              ossFreePDU
//              ossFreeBuf
//              ossLinkBer
//              ossSetEncodingRules
//
//  History:    24-Mar-99       philh   created
//
//--------------------------------------------------------------------------
#include <windows.h>
#include <asn1code.h>
#include <ossglobl.h>

#define OSS_ENCODE_PROC_IDX                 0
#define OSS_DECODE_PROC_IDX                 1
#define OSS_FREE_PDU_PROC_IDX               2
#define OSS_FREE_BUF_PROC_IDX               3
#define OSS_LINK_BER_PROC_IDX               4
#define OSS_SET_ENCODING_RULES_PROC_IDX     5
#define OSS_PROC_CNT                        6

LPSTR rgpszOssProc[OSS_PROC_CNT] = {
    "ossEncode",                // 0
    "ossDecode",                // 1
    "ossFreePDU",               // 2
    "ossFreeBuf",               // 3
    "ossLinkBer",               // 4
    "ossSetEncodingRules"       // 5
};

void *rgpvOssProc[OSS_PROC_CNT];
HMODULE hmsossDll = NULL;

void OssUnload()
{
    if (hmsossDll) {
        FreeLibrary(hmsossDll);
        hmsossDll = NULL;
    }
}

BOOL OssLoad()
{
    BOOL fRet;
    DWORD i;

    if (NULL == (hmsossDll = LoadLibraryA("msoss.dll")))
        goto ErrorReturn;

    for (i = 0; i < OSS_PROC_CNT; i++) {
        if (NULL == (rgpvOssProc[i] = GetProcAddress(
                hmsossDll, rgpszOssProc[i])))
            goto ErrorReturn;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    OssUnload();
    fRet = FALSE;
    goto CommonReturn;
}

typedef int (DLL_ENTRY* pfnossEncode)(struct ossGlobal *world,
                              int              pdunum,
                              void            *input,
                              OssBuf          *output);

int  DLL_ENTRY ossEncode(struct ossGlobal *world,
				int              pdunum,
				void            *input,
				OssBuf          *output)
{
    if (hmsossDll)
        return ((pfnossEncode) rgpvOssProc[OSS_ENCODE_PROC_IDX])(
            world,
			pdunum,
			input,
			output);
    else
        return API_DLL_NOT_LINKED;
}

typedef int (DLL_ENTRY* pfnossDecode)(struct ossGlobal *world,
                              int             *pdunum,
                              OssBuf          *input,
                              void           **output);

int  DLL_ENTRY ossDecode(struct ossGlobal *world,
				int             *pdunum,
				OssBuf          *input,
				void           **output)
{
    if (hmsossDll)
        return ((pfnossDecode) rgpvOssProc[OSS_DECODE_PROC_IDX])(
            world,
			pdunum,
			input,
			output);
    else
        return API_DLL_NOT_LINKED;
}

typedef int (DLL_ENTRY* pfnossFreePDU)(struct ossGlobal *world,
                               int               pdunum,
                               void             *data);

int  DLL_ENTRY ossFreePDU(struct ossGlobal *world,
				int               pdunum,
				void             *data)
{
    if (hmsossDll)
        return ((pfnossFreePDU) rgpvOssProc[OSS_FREE_PDU_PROC_IDX])(
            world,
			pdunum,
            data);
    else
        return API_DLL_NOT_LINKED;
}

typedef void (DLL_ENTRY* pfnossFreeBuf)(struct ossGlobal *world,
                                void              *data);

void DLL_ENTRY ossFreeBuf(struct ossGlobal *world,
				void              *data)
{
    if (hmsossDll)
        ((pfnossFreeBuf) rgpvOssProc[OSS_FREE_BUF_PROC_IDX])(
            world,
            data);
}

typedef void (DLL_ENTRY* pfnossLinkBer)(OssGlobal *world);

void DLL_ENTRY ossLinkBer(OssGlobal *world)
{
    if (hmsossDll)
        ((pfnossLinkBer) rgpvOssProc[OSS_LINK_BER_PROC_IDX])(world);
}


typedef int (DLL_ENTRY* pfnossSetEncodingRules)(struct ossGlobal *world,
                    ossEncodingRules rules);

int              DLL_ENTRY ossSetEncodingRules(struct ossGlobal *world,
						ossEncodingRules rules)
{
    if (hmsossDll)
        return ((pfnossSetEncodingRules)
            rgpvOssProc[OSS_SET_ENCODING_RULES_PROC_IDX])(
                world,
                rules);
    else
        return API_DLL_NOT_LINKED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xenroll\crtstr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       crtstr.cpp
//
//--------------------------------------------------------------------------

#if !DBG

// Only build for retail

#include "windows.h"
#include "malloc.h"


int __cdecl _wcsicmp(const wchar_t * wsz1, const wchar_t * wsz2)
//
// REVIEW: Who calls this function, and should they be doing so?
//
// Return:
//       <0 if wsz1 < wsz2
//        0 if wsz1 = wsz2
//       >0 if wsz1 > wsz2
{
    //
    // Convert to multibyte and let the system do it
    //
    int cch1 = lstrlenW(wsz1);
    int cch2 = lstrlenW(wsz2);
    int cb1 = (cch1+1) * sizeof(WCHAR);
    int cb2 = (cch2+1) * sizeof(WCHAR);
    char* sz1= NULL;
    char* sz2= NULL;

    __try {

    sz1= (char*) _alloca(cb1);
    sz2= (char*) _alloca(cb2);
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        //xiaohs: We return a non-zero value to
        //signal a falture case because all the calls to this
        //function compare the return value with 0
        SetLastError(GetExceptionCode());
        return -1;
    }

    WideCharToMultiByte(CP_ACP, 0, wsz1, -1, sz1, cb1, NULL, NULL);
    WideCharToMultiByte(CP_ACP, 0, wsz2, -1, sz2, cb2, NULL, NULL);

    return lstrcmpiA(sz1, sz2);
}

#endif // !DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xenroll\pvkdlgs.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pvkdlgs.h
//
//--------------------------------------------------------------------------

#define IDC_PASSWORD0               501
#define IDC_PASSWORD1               502
#define IDC_KEY                     504
#define IDC_NONE                    505
#define IDD_ENTERKEYPASSWORD        530
#define IDD_CREATEKEYPASSWORD       540
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xenroll\pvk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pvk.h
//
//  Contents:   Shared types and functions
//              
//  APIs:
//
//  History:    12-May-96   philh   created
//--------------------------------------------------------------------------

#ifndef __PVK_H__
#define __PVK_H__

#include "pvkhlpr.h"
#include "pvkdlgs.h"

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  Pvk allocation and free routines
//--------------------------------------------------------------------------
void *PvkAlloc(
    IN size_t cbBytes
    );
void PvkFree(
    IN void *pv
    );


//+-------------------------------------------------------------------------
//  Enter or Create Private Key Password Dialog Box
//--------------------------------------------------------------------------
enum PASSWORD_TYPE {
    ENTER_PASSWORD = 0,
    CREATE_PASSWORD
};

BOOL WINAPI PvkDllMain(
                HMODULE hInstDLL,
                DWORD fdwReason,
                LPVOID lpvReserved
		);

BOOL
WINAPI
PrivateKeySave(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hFile,
    IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags
    );

BOOL
WINAPI
PrivateKeyLoad(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hFile,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec
    );


int PvkDlgGetKeyPassword(
            IN PASSWORD_TYPE PasswordType,
            IN HWND hwndOwner,
            IN LPCWSTR pwszKeyName,
            OUT BYTE **ppbPassword,
            OUT DWORD *pcbPassword
            );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xenroll\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by xenroll.rc
//
#define IDS_PROJNAME                    100
#define IDR_CENROLL			101
#define IDS_NOTSAFEACTION		120
#define IDS_REQ_STORE_FULL		121
#define IDS_SPC_C			122
#define IDS_SPC_O			123
#define IDS_PVK_O			124	 // not a bug, same as PVK_C
#define IDS_NOTSAFE_OPEN_FORMAT        125
#define IDS_NOTSAFE_WRITE_FORMAT       126
#define IDS_WITHOUTPASSWORD		127
#define IDS_CONFIRMPASSWORD		128
#define IDS_NOTSAFE_OPEN            129
#define IDS_NOTSAFE_OPEN_PREFIX     130
#define IDS_NOTSAFE_WRITE_PREFIX    131
#define IDS_CERTENROLL              132
#define IDS_OVERWRITE_FORMAT        133
#define IDS_NOTSAFE_REQUESTING_CERT 134
#define IDS_NOTSAFE_ACCEPTING_CERT  135
#define IDS_PVK_C		    136

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xenroll\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// the ATL stuff doesn't compile at wl4.  Disable the warnings they generate: 
#pragma warning(disable:4100) // 'var' : unreferenced formal parameter
#pragma warning(disable:4189) // 'var' : local variable is initialized but not referenced
#pragma warning(disable:4505) // 'func' : unreferenced local function has been removed

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xenroll\pvkdlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       pvkdlg.cpp
//
//  Contents:   Private Key Dialog Box APIs.
//
//  Functions:  PvkDlgGetKeyPassword
//
//  History:    12-May-96   philh created
//
//--------------------------------------------------------------------------

#include "stdafx.h"

#include <windows.h>
#include <wincrypt.h>
#include <unicode.h>
#include <assert.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

#include "pvk.h"

#include "xenroll.h"
#include "cenroll.h"

// ENTER_PASSWORD:
//  IDC_PASSWORD0 - Password

// CREATE_PASSWORD:
//  IDC_PASSWORD0 - Password
//  IDC_PASSWORD1 - Confirm Password


typedef struct _KEY_PASSWORD_PARAM {
    PASSWORD_TYPE   PasswordType;
    LPWSTR          pwszKey;           // IDC_KEY
    LPSTR           *ppszPassword;
} KEY_PASSWORD_PARAM, *PKEY_PASSWORD_PARAM;


// Where to get the dialog resources from
static HINSTANCE hPvkInst;

// Forward reference to local functions
static int GetPassword(
            IN HWND hwndDlg,
            IN PASSWORD_TYPE PasswordType,
            OUT LPSTR *ppszPassword
            );

static INT_PTR CALLBACK KeyPasswordDlgProc(
            IN HWND hwndDlg,
            IN UINT uMsg,
            IN WPARAM wParam,
            IN LPARAM lParam
            );

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL WINAPI PvkDllMain(
                HMODULE hInstDLL,
                DWORD fdwReason,
                LPVOID /*lpvReserved*/
                )
{

    switch (fdwReason) {
    case DLL_PROCESS_ATTACH:
        hPvkInst = hInstDLL;
        break;
    case DLL_PROCESS_DETACH:
        break;
    }

    return(TRUE);
}

//+-------------------------------------------------------------------------
//  Enter or Create Private Key Password Dialog Box
//--------------------------------------------------------------------------
int PvkDlgGetKeyPassword(
            IN PASSWORD_TYPE PasswordType,
            IN HWND hwndOwner,
            IN LPCWSTR pwszKeyName,
            OUT BYTE **ppbPassword,
            OUT DWORD *pcbPassword
            )
{
    int nResult;
    LPSTR pszPassword = NULL;
    KEY_PASSWORD_PARAM KeyPasswordParam = {
        PasswordType,
        (LPWSTR) pwszKeyName,
        &pszPassword
    };

    LPCSTR pszTemplate = PasswordType == ENTER_PASSWORD ?
        MAKEINTRESOURCE(IDD_ENTERKEYPASSWORD) :
        MAKEINTRESOURCE(IDD_CREATEKEYPASSWORD);

    nResult = (BOOL)DialogBoxParam(
        hPvkInst,
        pszTemplate,
        hwndOwner,
        KeyPasswordDlgProc,
        (LPARAM) &KeyPasswordParam
        );

    *ppbPassword = (BYTE *) pszPassword;
    if (pszPassword)
        *pcbPassword = (DWORD)strlen(pszPassword);
    else
        *pcbPassword = 0;

    return nResult;
}

//+-------------------------------------------------------------------------
//  Allocate and get the password(s) from the dialog box
//
//  For no password input, returns NULL
//  pointer for the password. Otherwise, the password is PvkAlloc'ed.
//--------------------------------------------------------------------------
static int GetPassword(
            IN HWND hwndDlg,
            IN PASSWORD_TYPE PasswordType,
            OUT LPSTR *ppszPassword
            )
{
    WCHAR         *pwszString = NULL;
    LPSTR rgpszPassword[2] = {NULL, NULL};

    *ppszPassword = NULL;

    // Get the entered password(s)
    assert(PasswordType < 2);
    int i;
    for (i = 0; i <= PasswordType; i++) {
        LONG cchPassword;
        cchPassword = (LONG)SendDlgItemMessage(
            hwndDlg,
            IDC_PASSWORD0 + i,
            EM_LINELENGTH,
            (WPARAM) 0,
            (LPARAM) 0
            );
        if (cchPassword > 0) {
            rgpszPassword[i] = (LPSTR) PvkAlloc(cchPassword + 1);
            assert(rgpszPassword[i]);
            if (rgpszPassword[i])
                GetDlgItemText(
                    hwndDlg,
                    IDC_PASSWORD0 + i,
                    rgpszPassword[i],
                    cchPassword + 1
                    );
        }
    }

    if (PasswordType == ENTER_PASSWORD) {
        *ppszPassword = rgpszPassword[0];
        return IDOK;
    }

    int nResult = IDOK;
#define MSG_BOX_TITLE_LEN 128
    WCHAR wszMsgBoxTitle[MSG_BOX_TITLE_LEN];
    GetWindowTextU(hwndDlg, wszMsgBoxTitle, MSG_BOX_TITLE_LEN);

    if (rgpszPassword[0] == NULL && rgpszPassword[1] == NULL) {
        // Didn't enter a password

        xeLoadRCString(hPvkInst, IDS_WITHOUTPASSWORD, &pwszString);
        nResult = MessageBoxU(
            hwndDlg,
            pwszString,
            wszMsgBoxTitle,
            MB_YESNOCANCEL | MB_ICONQUESTION | MB_DEFBUTTON2
            );
        if (NULL != pwszString)
        {
            LocalFree(pwszString);
        }
        if (nResult == IDYES)
            nResult = IDOK;
        else if (nResult == IDNO)
            nResult = IDRETRY;
    } else if (rgpszPassword[0] == NULL || rgpszPassword[1] == NULL ||
               strcmp(rgpszPassword[0], rgpszPassword[1]) != 0) {
               
        // Confirmed password didn't match
        xeLoadRCString(hPvkInst, IDS_CONFIRMPASSWORD, &pwszString);
        nResult = MessageBoxU(
            hwndDlg,
            pwszString,
            wszMsgBoxTitle,
            MB_RETRYCANCEL | MB_ICONEXCLAMATION
            );
        if (NULL != pwszString)
        {
            LocalFree(pwszString);
        }
        if (nResult == IDRETRY) {
            SetDlgItemText(hwndDlg, IDC_PASSWORD0 + 0, "");
            SetDlgItemText(hwndDlg, IDC_PASSWORD0 + 1, "");
        }
    }

    if (nResult == IDOK)
        *ppszPassword = rgpszPassword[0];
    else if (rgpszPassword[0])
        PvkFree(rgpszPassword[0]);
    if (rgpszPassword[1])
        PvkFree(rgpszPassword[1]);

    if (nResult == IDRETRY)
        SetFocus(GetDlgItem(hwndDlg, IDC_PASSWORD0));
    return nResult;
}

//+-------------------------------------------------------------------------
//  Enter or Create Private Key Password DialogProc
//--------------------------------------------------------------------------
static INT_PTR CALLBACK KeyPasswordDlgProc(
            IN HWND hwndDlg,
            IN UINT uMsg,
            IN WPARAM wParam,
            IN LPARAM lParam
            )
{
    switch (uMsg) {
        case WM_INITDIALOG:
        {
            PKEY_PASSWORD_PARAM pKeyPasswordParam =
                (PKEY_PASSWORD_PARAM) lParam;

            char sz[128];
            WideCharToMultiByte(CP_ACP, 0, pKeyPasswordParam->pwszKey, -1,
                (LPSTR) sz, 128, NULL, NULL);

            SetDlgItemText(hwndDlg, IDC_KEY, sz);
            SetWindowLongPtr(hwndDlg, DWLP_USER, (INT_PTR) pKeyPasswordParam);
            return TRUE;
        }
        case WM_COMMAND:
            int nResult = LOWORD(wParam);
            switch (nResult) {
                case IDOK:
                {
                    PKEY_PASSWORD_PARAM pKeyPasswordParam =
                        (PKEY_PASSWORD_PARAM) GetWindowLongPtr(hwndDlg, DWLP_USER);

                    nResult = GetPassword(
                        hwndDlg,
                        pKeyPasswordParam->PasswordType,
                        pKeyPasswordParam->ppszPassword
                        );
                    if (nResult != IDRETRY)
                        EndDialog(hwndDlg, nResult);
                    return TRUE;
                }
                    break;
                case IDC_NONE:
                    nResult = IDOK;     // *ppszPassword == NULL
                    // Fall through
                case IDCANCEL:
                    EndDialog(hwndDlg, nResult);
                    return TRUE;
            }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xenroll\sfscript.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2002
//
//  File:       sfscript.h
//
//--------------------------------------------------------------------------

#ifndef __SFSCRIPT_H__
#define __SFSCRIPT_H__ 1

// Our design is to allow 500 certificates in a store through script
#define MAX_SAFE_FOR_SCRIPTING_REQUEST_STORE_COUNT 500


BOOL WINAPI MySafeCertAddCertificateContextToStore(HCERTSTORE       hCertStore, 
						   PCCERT_CONTEXT   pCertContext, 
						   DWORD            dwAddDisposition, 
						   PCCERT_CONTEXT  *ppStoreContext, 
						   DWORD            dwSafetyOptions);
BOOL VerifyProviderFlagsSafeForScripting(DWORD dwFlags);
BOOL VerifyStoreFlagsSafeForScripting(DWORD dwFlags);
BOOL VerifyStoreSafeForScripting(HCERTSTORE hStore);

#endif // #ifndef __SFSCRIPT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xenroll\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__43F8F27F_7A20_11D0_8F06_00C04FC295E1__INCLUDED_)
#define AFX_STDAFX_H__43F8F27F_7A20_11D0_8F06_00C04FC295E1__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


// #define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__43F8F27F_7A20_11D0_8F06_00C04FC295E1__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xenroll\pvkhlpr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       pvkhlpr.cpp
//
//  Contents:   Private Key Helper APIs
//
//  Functions:  PrivateKeyLoad
//              PrivateKeySave
//              PrivateKeyLoadFromMemory
//              PrivateKeySaveToMemory
//              PrivateKeyAcquireContextFromMemory
//              PrivateKeyReleaseContext
//
//  Note:       Base CSP also exports/imports the public key with the
//              private key.
//
//  History:    10-May-96   philh   created
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>

#include "wincrypt.h"
#include "pvk.h"
#include "unicode.h"

#include <string.h>
#include <memory.h>

//+-------------------------------------------------------------------------
//  Private Key file definitions
//
//  The file consists of the FILE_HDR followed by cbEncryptData optional
//  bytes used to encrypt the private key and then the private key.
//  The private key is encrypted according to dwEncryptType.
//
//  The public key is included with the private key.
//--------------------------------------------------------------------------
typedef struct _FILE_HDR {
    DWORD               dwMagic;
    DWORD               dwVersion;
    DWORD               dwKeySpec;
    DWORD               dwEncryptType;
    DWORD               cbEncryptData;
    DWORD               cbPvk;
} FILE_HDR, *PFILE_HDR;

#define PVK_FILE_VERSION_0          0
#define PVK_MAGIC                   0xb0b5f11e

// Private key encrypt types
#define PVK_NO_ENCRYPT                  0
#define PVK_RC4_PASSWORD_ENCRYPT        1
#define PVK_RC2_CBC_PASSWORD_ENCRYPT    2

#define MAX_PVK_FILE_LEN            4096
#define MAX_BOB_FILE_LEN            (4096*4)

typedef BOOL (* PFNWRITE)(HANDLE h, void * p, DWORD cb);
typedef BOOL (* PFNREAD)(HANDLE h, void * p, DWORD cb);



//+-------------------------------------------------------------------------
//  Private key helper allocation and free functions
//--------------------------------------------------------------------------
void *PvkAlloc(
    IN size_t cbBytes
    )
{
    void *pv;
    pv = malloc(cbBytes);
    if (pv == NULL)
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    return pv;
}
void PvkFree(
    IN void *pv
    )
{
    free(pv);
}

//+-------------------------------------------------------------------------
//  Read  & Write to file function
//--------------------------------------------------------------------------
static BOOL WriteToFile(HANDLE h, void * p, DWORD cb) {

    DWORD   cbBytesWritten;

    return(WriteFile(h, p, cb, &cbBytesWritten, NULL));
}

static BOOL ReadFromFile(
    IN HANDLE h,
    IN void * p,
    IN DWORD cb
    )
{
    DWORD   cbBytesRead;

    return(ReadFile(h, p, cb, &cbBytesRead, NULL) && cbBytesRead == cb);
}


//+-------------------------------------------------------------------------
//  Read & Write to memory fucntion
//--------------------------------------------------------------------------
typedef struct _MEMINFO {
    BYTE *  pb;
    DWORD   cb;
    DWORD   cbSeek;
} MEMINFO, * PMEMINFO;

static BOOL WriteToMemory(HANDLE h, void * p, DWORD cb) {

    PMEMINFO pMemInfo = (PMEMINFO) h;

    // See if we have room. The caller will detect an error after the final
    // write
    if(pMemInfo->cbSeek + cb <= pMemInfo->cb)
        // copy the bytes
        memcpy(&pMemInfo->pb[pMemInfo->cbSeek], p, cb);

    pMemInfo->cbSeek += cb;

    return(TRUE);
}

static BOOL ReadFromMemory(
    IN HANDLE h,
    IN void * p,
    IN DWORD cb
    )
{
    PMEMINFO pMemInfo = (PMEMINFO) h;

    if (pMemInfo->cbSeek + cb <= pMemInfo->cb) {
        // copy the bytes
        memcpy(p, &pMemInfo->pb[pMemInfo->cbSeek], cb);
        pMemInfo->cbSeek += cb;
        return TRUE;
    } else {
        SetLastError(ERROR_END_OF_MEDIA);
        return FALSE;
    }
}

static BOOL GetPasswordKey(
    IN HCRYPTPROV hProv,
    IN ALG_ID Algid,
    IN PASSWORD_TYPE PasswordType,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN BOOL fNoPassDlg,
    IN BYTE *pbSalt,
    IN DWORD cbSalt,
    OUT HCRYPTKEY *phEncryptKey
    )
{
    BOOL fResult;
    BYTE *pbAllocPassword = NULL;
    BYTE *pbPassword;
    DWORD cbPassword;
    HCRYPTHASH hHash = 0;
    HCRYPTKEY hEncryptKey = 0;
    BYTE rgbPwdBuffer[] = {67, 82, 65, 80};

    if (fNoPassDlg) {
        pbPassword = rgbPwdBuffer;
        cbPassword = sizeof(rgbPwdBuffer);
    } else {
        if (IDOK != PvkDlgGetKeyPassword(
                PasswordType,
                hwndOwner,
                pwszKeyName,
                &pbAllocPassword,
                &cbPassword
                )) {
            SetLastError(PVK_HELPER_PASSWORD_CANCEL);
            goto ErrorReturn;
        }
        pbPassword = pbAllocPassword;
    }

    if (cbPassword) {
        if (!CryptCreateHash(hProv, CALG_SHA, 0, 0, &hHash))
            goto ErrorReturn;
        if (cbSalt) {
            if (!CryptHashData(hHash, pbSalt, cbSalt, 0))
                goto ErrorReturn;
        }
        if (!CryptHashData(hHash, pbPassword, cbPassword, 0))
            goto ErrorReturn;
        if (!CryptDeriveKey(hProv, Algid, hHash, 0, &hEncryptKey))
            goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
    if (hEncryptKey) {
        CryptDestroyKey(hEncryptKey);
        hEncryptKey = 0;
    }
CommonReturn:
    if (pbAllocPassword)
        PvkFree(pbAllocPassword);
    if (hHash)
        CryptDestroyHash(hHash);
    *phEncryptKey = hEncryptKey;
    return fResult;
}

// Support backwards compatibility with Bob's storage file which contains
// a snap shot of the keys as they are stored in the registry. Note, for
// win95, the registry values are decrypted before being written to the file.
static BOOL LoadBobKey(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hRead,
    IN PFNREAD pfnRead,
    IN DWORD cbBobKey,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    IN PFILE_HDR pHdr                   // header has already been read
    );

static BOOL LoadKey(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hRead,
    IN PFNREAD pfnRead,
    IN DWORD cbKeyData,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec
    )
{
    BOOL fResult;
    FILE_HDR Hdr;
    HCRYPTKEY hDecryptKey = 0;
    HCRYPTKEY hKey = 0;
    BYTE *pbEncryptData = NULL;
    BYTE *pbPvk = NULL;
    DWORD cbPvk;

    // Read the file header and verify
    if (!pfnRead(hRead, &Hdr, sizeof(Hdr))) goto BadPvkFile;
    if (Hdr.dwMagic != PVK_MAGIC)
        // Try to load as Bob's storage file containing streams for the
        // private and public keys. Bob made a copy of the cryptography
        // registry key values.
        //
        // Note, Bob now has two different formats for storing the private
        // key information. See LoadBobKey for details.
        fResult = LoadBobKey(hCryptProv, hRead, pfnRead, cbKeyData, hwndOwner,
            pwszKeyName, dwFlags, pdwKeySpec, &Hdr);
    else {
        // Treat as a "normal" private key file
        cbPvk = Hdr.cbPvk;
        if (Hdr.dwVersion != PVK_FILE_VERSION_0 ||
            Hdr.cbEncryptData > MAX_PVK_FILE_LEN ||
            cbPvk == 0 || cbPvk > MAX_PVK_FILE_LEN)
        goto BadPvkFile;
    
        if (pdwKeySpec) {
            DWORD dwKeySpec = *pdwKeySpec;
            *pdwKeySpec = Hdr.dwKeySpec;
            if (dwKeySpec && dwKeySpec != Hdr.dwKeySpec) {
                SetLastError(PVK_HELPER_WRONG_KEY_TYPE);
                goto ErrorReturn;
            }
        }
    
        if (Hdr.cbEncryptData) {
            // Read the encrypt data
            if (NULL == (pbEncryptData = (BYTE *) PvkAlloc(Hdr.cbEncryptData)))
                goto ErrorReturn;
            if (!pfnRead(hRead, pbEncryptData, Hdr.cbEncryptData))
                goto BadPvkFile;
        }
    
        // Allocate and read the private key
        if (NULL == (pbPvk = (BYTE *) PvkAlloc(cbPvk)))
            goto ErrorReturn;
        if (!pfnRead(hRead, pbPvk, cbPvk))
            goto BadPvkFile;
    
    
        // Get symmetric key to decrypt the private key
        switch (Hdr.dwEncryptType) {
            case PVK_NO_ENCRYPT:
                break;
            case PVK_RC4_PASSWORD_ENCRYPT:
                if (!GetPasswordKey(hCryptProv, CALG_RC4,
                        ENTER_PASSWORD, hwndOwner,
                        pwszKeyName, FALSE, pbEncryptData, Hdr.cbEncryptData,
                        &hDecryptKey))
                    goto ErrorReturn;
                break;
            case PVK_RC2_CBC_PASSWORD_ENCRYPT:
                if (!GetPasswordKey(hCryptProv, CALG_RC2,
                        ENTER_PASSWORD, hwndOwner,
                        pwszKeyName, FALSE, pbEncryptData, Hdr.cbEncryptData,
                        &hDecryptKey))
                    goto ErrorReturn;
                break;
            default:
                goto BadPvkFile;
        }

        // Decrypt and import the private key
        if (!CryptImportKey(hCryptProv, pbPvk, cbPvk, hDecryptKey, dwFlags,
                &hKey))
            goto ErrorReturn;

        fResult = TRUE;
    }
    goto CommonReturn;

BadPvkFile:
    SetLastError(PVK_HELPER_BAD_PVK_FILE);
    if (pdwKeySpec)
        *pdwKeySpec = 0;
ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pbEncryptData)
        PvkFree(pbEncryptData);
    if (pbPvk)
        PvkFree(pbPvk);
    if (hDecryptKey)
        CryptDestroyKey(hDecryptKey);
    if (hKey)
        CryptDestroyKey(hKey);
    return fResult;
}

static BOOL SaveKey(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hWrite,
    IN PFNREAD pfnWrite,
    IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN BOOL fNoPassDlg
    )
{
    BOOL fResult;
    FILE_HDR Hdr;
    HCRYPTKEY hEncryptKey = 0;
    HCRYPTKEY hKey = 0;
    BYTE *pbEncryptData = NULL;     // Not allocated
    BYTE *pbPvk = NULL;
    DWORD cbPvk;

    BYTE rgbSalt[16];

    // Initialize the header record
    memset(&Hdr, 0, sizeof(Hdr));
    Hdr.dwMagic = PVK_MAGIC;
    Hdr.dwVersion = PVK_FILE_VERSION_0;
    Hdr.dwKeySpec = dwKeySpec;

    // Generate random salt
    if (!CryptGenRandom(hCryptProv, sizeof(rgbSalt), rgbSalt))
        goto ErrorReturn;

    // Get symmetric key to use to encrypt the private key
#if 1
    if (!GetPasswordKey(hCryptProv, CALG_RC4,
#else
    if (!GetPasswordKey(hCryptProv, CALG_RC2,
#endif
            CREATE_PASSWORD, hwndOwner, pwszKeyName,
            fNoPassDlg, rgbSalt, sizeof(rgbSalt), &hEncryptKey))
        goto ErrorReturn;
    if (hEncryptKey) {
#if 1
        Hdr.dwEncryptType = PVK_RC4_PASSWORD_ENCRYPT;
#else
        Hdr.dwEncryptType = PVK_RC2_CBC_PASSWORD_ENCRYPT;
#endif
        Hdr.cbEncryptData = sizeof(rgbSalt);
        pbEncryptData = rgbSalt;
    } else
        Hdr.dwEncryptType = PVK_NO_ENCRYPT;

    // Allocate, encrypt and export the private key
    if (!CryptGetUserKey(hCryptProv, dwKeySpec, &hKey))
        goto ErrorReturn;
    cbPvk = 0;
    if (!CryptExportKey(hKey, hEncryptKey, PRIVATEKEYBLOB, dwFlags, NULL,
            &cbPvk))
        goto ErrorReturn;
    if (NULL == (pbPvk = (BYTE *) PvkAlloc(cbPvk)))
        goto ErrorReturn;
    if (!CryptExportKey(hKey, hEncryptKey, PRIVATEKEYBLOB, dwFlags, pbPvk,
            &cbPvk))
        goto ErrorReturn;
    Hdr.cbPvk = cbPvk;


    // Write the header, optional encrypt data, and private key to the file
    if (!pfnWrite(hWrite, &Hdr, sizeof(Hdr)))
        goto ErrorReturn;
    if (Hdr.cbEncryptData) {
        if (!pfnWrite(hWrite, pbEncryptData, Hdr.cbEncryptData))
            goto ErrorReturn;
    }
    if (!pfnWrite(hWrite, pbPvk, cbPvk))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pbPvk)
        PvkFree(pbPvk);
    if (hEncryptKey)
        CryptDestroyKey(hEncryptKey);
    if (hKey)
        CryptDestroyKey(hKey);
    return fResult;
}


//+-------------------------------------------------------------------------
//  Load the AT_SIGNATURE or AT_KEYEXCHANGE private key (and its public key)
//  from the file into the cryptographic provider.
//
//  If the private key was password encrypted, then, the user is first
//  presented with a dialog box to enter the password.
//
//  If pdwKeySpec is non-Null, then, if *pdwKeySpec is nonzero, verifies the
//  key type before loading. Sets LastError to PVK_HELPER_WRONG_KEY_TYPE for
//  a mismatch. *pdwKeySpec is updated with the key type.
//
//  dwFlags is passed through to CryptImportKey.
//--------------------------------------------------------------------------
BOOL
WINAPI
PrivateKeyLoad(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hFile,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec
    )
{
    return LoadKey(
        hCryptProv,
        hFile,
        ReadFromFile,
        GetFileSize(hFile, NULL),
        hwndOwner,
        pwszKeyName,
        dwFlags,
        pdwKeySpec
        );
}

//+-------------------------------------------------------------------------
//  Save the AT_SIGNATURE or AT_KEYEXCHANGE private key (and its public key)
//  to the specified file.
//
//  The user is presented with a dialog box to enter an optional password to
//  encrypt the private key.
//
//  dwFlags is passed through to CryptExportKey.
//--------------------------------------------------------------------------
BOOL
WINAPI
PrivateKeySave(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hFile,
    IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags
    )
{
    return SaveKey(
        hCryptProv,
        hFile,
        WriteToFile,
        dwKeySpec,
        hwndOwner,
        pwszKeyName,
        dwFlags,
        FALSE           // fNoPassDlg
        );
}

//+-------------------------------------------------------------------------
//  Load the AT_SIGNATURE or AT_KEYEXCHANGE private key (and its public key)
//  from memory into the cryptographic provider.
//
//  Except for the key being loaded from memory, identical to PrivateKeyLoad.
//--------------------------------------------------------------------------
BOOL
WINAPI
PrivateKeyLoadFromMemory(
    IN HCRYPTPROV hCryptProv,
    IN BYTE *pbData,
    IN DWORD cbData,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec
    )
{
    MEMINFO MemInfo;

    MemInfo.pb = pbData;
    MemInfo.cb = cbData;
    MemInfo.cbSeek = 0;
    return LoadKey(
        hCryptProv,
        (HANDLE) &MemInfo,
        ReadFromMemory,
        cbData,
        hwndOwner,
        pwszKeyName,
        dwFlags,
        pdwKeySpec
        );
}

//+-------------------------------------------------------------------------
//  Save the AT_SIGNATURE or AT_KEYEXCHANGE private key (and its public key)
//  to memory.
//
//  If pbData == NULL || *pcbData == 0, calculates the length and doesn't
//  return an error (also, the user isn't prompted for a password).
//
//  Except for the key being saved to memory, identical to PrivateKeySave.
//--------------------------------------------------------------------------
BOOL
WINAPI
PrivateKeySaveToMemory(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    OUT BYTE *pbData,
    IN OUT DWORD *pcbData
    )
{
    BOOL fResult;
    MEMINFO MemInfo;

    MemInfo.pb = pbData;
    if (pbData == NULL)
        *pcbData = 0;
    MemInfo.cb = *pcbData;
    MemInfo.cbSeek = 0;

    fResult = SaveKey(
            hCryptProv,
            (HANDLE) &MemInfo,
            WriteToMemory,
            dwKeySpec,
            hwndOwner,
            pwszKeyName,
            dwFlags,
            *pcbData == 0           // fNoPassDlg
            ); 
    if (fResult) {
        if (MemInfo.cbSeek > MemInfo.cb && *pcbData) {
            fResult = FALSE;
            SetLastError(ERROR_END_OF_MEDIA);
        }
        *pcbData = MemInfo.cbSeek;
    } else
        *pcbData = 0;
    return fResult;
}


//+-------------------------------------------------------------------------
//  Converts the bytes into WCHAR hex
//
//  Needs (cb * 2 + 1) * sizeof(WCHAR) bytes of space in wsz
//--------------------------------------------------------------------------
static void BytesToWStr(ULONG cb, void* pv, LPWSTR wsz)
{
    BYTE* pb = (BYTE*) pv;
    for (ULONG i = 0; i<cb; i++) {
        BYTE b;
        b = (*pb & 0xF0) >> 4;
        *wsz++ = (WCHAR)((b <= 9) ? b + L'0' : (b - 10) + L'A');
        b = *pb & 0x0F;
        *wsz++ = (WCHAR)((b <= 9) ? b + L'0' : (b - 10) + L'A');
        pb++;
    }
    *wsz++ = 0;
}

#define UUID_WSTR_BYTES ((sizeof(UUID) * 2 + 1) * sizeof(WCHAR))


static BOOL AcquireKeyContext(
    IN LPCWSTR pwszProvName,
    IN DWORD dwProvType,
    IN HANDLE hRead,
    IN PFNREAD pfnRead,
    IN DWORD cbKeyData,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    OUT HCRYPTPROV *phCryptProv,
    OUT LPWSTR *ppwszTmpContainer
    )
{
    BOOL fResult;
    HCRYPTPROV hProv = 0;
    UUID TmpContainerUuid;
    LPWSTR pwszTmpContainer = NULL;
    RPC_STATUS  rpc_status;

    // Create a temporary keyset to load the private key into
    rpc_status = UuidCreate(&TmpContainerUuid);
    if (RPC_S_OK != rpc_status && RPC_S_UUID_LOCAL_ONLY != rpc_status)
    {
        //hr = rpc_status;
        goto ErrorReturn;
    }
    if (NULL == (pwszTmpContainer = (LPWSTR) PvkAlloc(
            6 * sizeof(WCHAR) + UUID_WSTR_BYTES)))
        goto ErrorReturn;
    wcscpy(pwszTmpContainer, L"TmpKey");
    BytesToWStr(sizeof(UUID), &TmpContainerUuid, pwszTmpContainer + 6);

    if (!CryptAcquireContextU(
            &hProv,
            pwszTmpContainer,
            pwszProvName,
            dwProvType,
            CRYPT_NEWKEYSET
            ))
        goto ErrorReturn;

    if (!LoadKey(
            hProv,
            hRead,
            pfnRead,
            cbKeyData,
            hwndOwner,
            pwszKeyName,
            0,              // dwFlags
            pdwKeySpec
            ))
        goto DeleteKeySetReturn;

    fResult = TRUE;
    goto CommonReturn;

DeleteKeySetReturn:
    CryptReleaseContext(hProv, 0);
    CryptAcquireContextU(
        &hProv,
        pwszTmpContainer,
        pwszProvName,
        dwProvType,
        CRYPT_DELETEKEYSET
        );
    hProv = 0;
ErrorReturn:
    if (hProv) {
        CryptReleaseContext(hProv, 0);
        hProv = 0;
    }
    if (pwszTmpContainer) {
        PvkFree(pwszTmpContainer);
        pwszTmpContainer = NULL;
    }
    fResult = FALSE;

CommonReturn:
    *ppwszTmpContainer = pwszTmpContainer;
    *phCryptProv = hProv;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Creates a temporary container in the provider and loads the private key
//  from the specified file.
//  For success, returns a handle to a cryptographic provider for the private
//  key and the name of the temporary container. PrivateKeyReleaseContext must
//  be called to release the hCryptProv and delete the temporary container.
//
//  PrivateKeyLoad is called to load the private key into the temporary
//  container.
//--------------------------------------------------------------------------
BOOL
WINAPI
PrivateKeyAcquireContext(
    IN LPCWSTR pwszProvName,
    IN DWORD dwProvType,
    IN HANDLE hFile,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    OUT HCRYPTPROV *phCryptProv,
    OUT LPWSTR *ppwszTmpContainer
    )
{
    return AcquireKeyContext(
        pwszProvName,
        dwProvType,
        hFile,
        ReadFromFile,
        GetFileSize(hFile, NULL),
        hwndOwner,
        pwszKeyName,
        pdwKeySpec,
        phCryptProv,
        ppwszTmpContainer
        );
}

//+-------------------------------------------------------------------------
//  Creates a temporary container in the provider and loads the private key
//  from memory.
//  For success, returns a handle to a cryptographic provider for the private
//  key and the name of the temporary container. PrivateKeyReleaseContext must
//  be called to release the hCryptProv and delete the temporary container.
//
//  PrivateKeyLoadFromMemory is called to load the private key into the
//  temporary container.
//--------------------------------------------------------------------------
BOOL
WINAPI
PrivateKeyAcquireContextFromMemory(
    IN LPCWSTR pwszProvName,
    IN DWORD dwProvType,
    IN BYTE *pbData,
    IN DWORD cbData,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    OUT HCRYPTPROV *phCryptProv,
    OUT LPWSTR *ppwszTmpContainer
    )
{
    MEMINFO MemInfo;

    MemInfo.pb = pbData;
    MemInfo.cb = cbData;
    MemInfo.cbSeek = 0;
    return AcquireKeyContext(
        pwszProvName,
        dwProvType,
        (HANDLE) &MemInfo,
        ReadFromMemory,
        cbData,
        hwndOwner,
        pwszKeyName,
        pdwKeySpec,
        phCryptProv,
        ppwszTmpContainer
        );
}

//+-------------------------------------------------------------------------
//  Releases the cryptographic provider and deletes the temporary container
//  created by PrivateKeyAcquireContext or PrivateKeyAcquireContextFromMemory.
//--------------------------------------------------------------------------
BOOL
WINAPI
PrivateKeyReleaseContext(
    IN HCRYPTPROV hCryptProv,
    IN LPCWSTR pwszProvName,
    IN DWORD dwProvType,
    IN LPWSTR pwszTmpContainer
    )
{
    if (hCryptProv)
        CryptReleaseContext(hCryptProv, 0);

    if (pwszTmpContainer) {
        // Delete the temporary container for the private key from
        // the provider
        //
        // Note: for CRYPT_DELETEKEYSET, the returned hCryptProv is undefined
        // and must not be released.
        CryptAcquireContextU(
                &hCryptProv,
                pwszTmpContainer,
                pwszProvName,
                dwProvType,
                CRYPT_DELETEKEYSET
                );
        PvkFree(pwszTmpContainer);
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Functions supporting backwards compatibility with Bob's storage file
//  containing a snap shot of the keys as they are stored in the registry.
//  Note, for win95, the registry values are decrypted before being written to
//  the file.
//--------------------------------------------------------------------------

// Return the size of this stream; return 0 if an error
static DWORD CbBobSize(IStream *pStm)
{
    STATSTG stat;
    if (FAILED(pStm->Stat(&stat, STATFLAG_NONAME)))
        return 0;
    return stat.cbSize.LowPart;
}

// Allocate and read this value which has the indicated stream name from the
// storage
static BOOL LoadBobStream(
    IStorage *pStg,
    LPCWSTR pwszStm,
    BYTE **ppbValue,
    DWORD *pcbValue
    )
{
    BOOL fResult;
    HRESULT hr;
    IStream *pStm = NULL;
    BYTE *pbValue = NULL;
    DWORD cbValue;
    DWORD cbRead;

    if (FAILED(hr = pStg->OpenStream(pwszStm, 0,
            STGM_READ | STGM_SHARE_EXCLUSIVE, 0, &pStm)))
        goto HrError;

    if (0 == (cbValue = CbBobSize(pStm))) goto BadBobFile;

    if (NULL == (pbValue = (BYTE *) PvkAlloc(cbValue))) goto ErrorReturn;

    pStm->Read(pbValue, cbValue, &cbRead);
    if (cbRead != cbValue) goto BadBobFile;

    fResult = TRUE;
    goto CommonReturn;

HrError:
    SetLastError((DWORD) hr);
    goto ErrorReturn;
BadBobFile:
    SetLastError(PVK_HELPER_BAD_PVK_FILE);
ErrorReturn:
    if (pbValue) {
        PvkFree(pbValue);
        pbValue = NULL;
    }
    cbValue = 0;
    fResult = FALSE;
CommonReturn:
    if (pStm)
        pStm->Release();
    *ppbValue = pbValue;
    *pcbValue = cbValue;
    return fResult;
}

// New "Bob" format::
//
// Allocate and read either the Exported Signature or Exchange Private 
// key stream from the storage
static BOOL LoadBobExportedPvk(
    IStorage *pStg,
    DWORD dwKeySpec,
    BYTE **ppbPvkValue,
    DWORD *pcbPvkValue
    )
{
    BOOL fResult;
    LPCWSTR pwszPvk;

    switch (dwKeySpec) {
    case AT_SIGNATURE:
        pwszPvk = L"Exported Signature Private Key";
        break;
    case AT_KEYEXCHANGE:
        pwszPvk = L"Exported Exchange Private Key";
        break;
    default:
        SetLastError(PVK_HELPER_BAD_PARAMETER);
        goto ErrorReturn;
    }

    fResult = LoadBobStream(pStg, pwszPvk, ppbPvkValue, pcbPvkValue);
    if (fResult) goto CommonReturn;

ErrorReturn:
    *ppbPvkValue = NULL;
    *pcbPvkValue = 0;
    fResult = FALSE;
CommonReturn:
    return fResult;
}

// Old "Bob" format::
//
// Allocate and read either the Signature or Exchange Private
// key streams from the storage
static BOOL LoadBobOldPvk(
    IStorage *pStg,
    DWORD dwKeySpec,
    BYTE **ppbPvkValue,
    DWORD *pcbPvkValue
    )
{
    BOOL fResult;
    LPCWSTR pwszPvk;

    switch (dwKeySpec) {
    case AT_SIGNATURE:
        pwszPvk = L"SPvk";
        break;
    case AT_KEYEXCHANGE:
        pwszPvk = L"EPvk";
        break;
    default:
        SetLastError(PVK_HELPER_BAD_PARAMETER);
        goto ErrorReturn;
    }

    fResult = LoadBobStream(pStg, pwszPvk, ppbPvkValue, pcbPvkValue);
    if (fResult) goto CommonReturn;

ErrorReturn:
    *ppbPvkValue = NULL;
    *pcbPvkValue = 0;
    fResult = FALSE;
CommonReturn:
    return fResult;
}

///////////////////////////////////////////////////////////////////////////////////////
//
// Key header structures for private key construction
//
//    These structs define the fixed data at the beginning of an RSA key.
//    They are followed by a variable length of data, sized by the stlen
//    field.
//
//    For more info see Jeff Spellman in the crypto team or look in the
//    source to RsaBase.Dll
//

typedef struct {
    DWORD       magic;                  /* Should always be RSA2 */
    DWORD       keylen;                 // size of modulus buffer
    DWORD       bitlen;                 // bit size of key
    DWORD       datalen;                // max number of bytes to be encoded
    DWORD       pubexp;                 // public exponent
} BSAFE_PRV_KEY, FAR *LPBSAFE_PRV_KEY;

typedef struct {
    BYTE    *modulus;
    BYTE    *prvexp;
    BYTE    *prime1;
    BYTE    *prime2;
    BYTE    *exp1;
    BYTE    *exp2;
    BYTE    *coef;
    BYTE    *invmod;
    BYTE    *invpr1;
    BYTE    *invpr2;
} BSAFE_KEY_PARTS, FAR *LPBSAFE_KEY_PARTS;

typedef struct {
    DWORD       magic;                  /* Should always be RSA2 */
    DWORD       bitlen;                 // bit size of key
    DWORD       pubexp;                 // public exponent
} EXPORT_PRV_KEY, FAR *PEXPORT_PRV_KEY;

///////////////////////////////////////////////////////////////////////////////////////
//
//  Take a raw exported unshrowded private key from the registry and turn it
//  into a private key export blob.
//
//  This is based on the PreparePrivateKeyForExport routine from rsabase.dll
//
static BOOL ConstructPrivateKeyExportBlob(
        IN DWORD            dwKeySpec,
        IN BSAFE_PRV_KEY *  pPrvKey,            
        IN DWORD            /*PrvKeyLen*/,
        OUT PBYTE           *ppbBlob,
        OUT DWORD           *pcbBlob
        )
{
    BOOL fResult;
    PEXPORT_PRV_KEY pExportKey;
    DWORD           cbHalfModLen;
    PBYTE           pbBlob = NULL;
    DWORD           cbBlob;
    PBYTE           pbIn;
    PBYTE           pbOut;

    cbHalfModLen = pPrvKey->bitlen / 16;
    cbBlob = sizeof(EXPORT_PRV_KEY) + 9 * cbHalfModLen +
        sizeof(PUBLICKEYSTRUC);

    if (NULL == (pbBlob = (BYTE *) PvkAlloc(cbBlob))) {
        fResult = FALSE;
        cbBlob = 0;
    } else {
        BYTE* pb = pbBlob;
        PUBLICKEYSTRUC *pPubKeyStruc = (PUBLICKEYSTRUC *) pb;
        pPubKeyStruc->bType         = PRIVATEKEYBLOB;
        pPubKeyStruc->bVersion      = 2;
        pPubKeyStruc->reserved      = 0;
        if (dwKeySpec == AT_KEYEXCHANGE)
            pPubKeyStruc->aiKeyAlg = CALG_RSA_KEYX;
        else if (dwKeySpec == AT_SIGNATURE)
            pPubKeyStruc->aiKeyAlg = CALG_RSA_SIGN;
        else
            pPubKeyStruc->aiKeyAlg = 0;

        pb = pbBlob + sizeof(PUBLICKEYSTRUC);

        // take most of the header info
        pExportKey = (PEXPORT_PRV_KEY)pb;
        pExportKey->magic  = pPrvKey->magic;
        pExportKey->bitlen = pPrvKey->bitlen;
        pExportKey->pubexp = pPrvKey->pubexp;

        pbIn = (PBYTE)pPrvKey + sizeof(BSAFE_PRV_KEY);
        pbOut = pb + sizeof(EXPORT_PRV_KEY);

        // copy all the private key info
        memcpy(pbOut, pbIn, cbHalfModLen * 2);
        pbIn += (cbHalfModLen + sizeof(DWORD)) * 2;
        pbOut += cbHalfModLen * 2;
        memcpy(pbOut, pbIn, cbHalfModLen);
        pbIn += cbHalfModLen + sizeof(DWORD);
        pbOut += cbHalfModLen;
        memcpy(pbOut, pbIn, cbHalfModLen);
        pbIn += cbHalfModLen + sizeof(DWORD);
        pbOut += cbHalfModLen;
        memcpy(pbOut, pbIn, cbHalfModLen);
        pbIn += cbHalfModLen + sizeof(DWORD);
        pbOut += cbHalfModLen;
        memcpy(pbOut, pbIn, cbHalfModLen);
        pbIn += cbHalfModLen + sizeof(DWORD);
        pbOut += cbHalfModLen;
        memcpy(pbOut, pbIn, cbHalfModLen);
        pbIn += cbHalfModLen + sizeof(DWORD);
        pbOut += cbHalfModLen;
        memcpy(pbOut, pbIn, cbHalfModLen * 2);

        fResult = TRUE;
    }
    *ppbBlob = pbBlob;
    *pcbBlob = cbBlob;
    return fResult;
}

static BOOL LoadBobKey(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hRead,
    IN PFNREAD pfnRead,
    IN DWORD cbBobKey,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    IN PFILE_HDR pHdr                   // header has already been read
    )
{
    BOOL fResult;
    DWORD dwErr = 0;
    HRESULT hr;
    HGLOBAL hGlobal = NULL;
    BYTE *pbBobKey;         // not allocated
    ILockBytes *pLkByt = NULL;
    IStorage *pStg = NULL;
    IStorage *pPrivStg = NULL;
    BYTE *pbPvkValue = NULL;
    DWORD cbPvkValue;
    DWORD dwKeySpec;

    if (cbBobKey > MAX_BOB_FILE_LEN) goto BadBobFile;

    if (NULL == (hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_DISCARDABLE,
            cbBobKey)))
        goto ErrorReturn;

    if (NULL == (pbBobKey = (BYTE *) GlobalLock(hGlobal)))
        goto ErrorReturn;
    memcpy(pbBobKey, (BYTE *) pHdr, sizeof(FILE_HDR));
    if (cbBobKey > sizeof(FILE_HDR))
        fResult = pfnRead(hRead, pbBobKey + sizeof(FILE_HDR),
            cbBobKey - sizeof(FILE_HDR));
    else
        fResult = TRUE;
    GlobalUnlock(hGlobal);
    if (!fResult) goto ErrorReturn;

    // FALSE => don't DeleteOnRelease
    if (FAILED(hr = CreateILockBytesOnHGlobal(hGlobal, FALSE, &pLkByt)))
        goto HrError;

    if (FAILED(hr = StgOpenStorageOnILockBytes(
            pLkByt,
            NULL,       // pStgPriority
            STGM_DIRECT | STGM_READ | STGM_SHARE_DENY_WRITE,
            NULL,    // snbExclude
            0,       // dwReserved
            &pStg
            ))) goto HrError;

    if (FAILED(pStg->OpenStorage(
            L"Plain Private Key",
            0,
            STGM_READ | STGM_SHARE_EXCLUSIVE,
            NULL,
            0,
            &pPrivStg))) goto BadBobFile;

    if (pdwKeySpec && *pdwKeySpec)
        dwKeySpec = *pdwKeySpec;
    else
        dwKeySpec = AT_SIGNATURE;

    // First, attempt to read the new format where the keys are stored in
    // the private key export format
    fResult = LoadBobExportedPvk(pPrivStg, dwKeySpec, &pbPvkValue,
        &cbPvkValue);
    if (!fResult && (pdwKeySpec == NULL || *pdwKeySpec == 0)) {
        dwKeySpec = AT_KEYEXCHANGE;
        fResult = LoadBobExportedPvk(pPrivStg, dwKeySpec,
            &pbPvkValue, &cbPvkValue);
    }
    if (fResult)
        fResult =  PrivateKeyLoadFromMemory(
            hCryptProv,
            pbPvkValue,
            cbPvkValue,
            hwndOwner,
            pwszKeyName,
            dwFlags,
            &dwKeySpec
            );
    else {
        // Try "old" format

        if (pdwKeySpec && *pdwKeySpec)
            dwKeySpec = *pdwKeySpec;
        else
            dwKeySpec = AT_SIGNATURE;

        fResult = LoadBobOldPvk(pPrivStg, dwKeySpec, &pbPvkValue, &cbPvkValue);
        if (!fResult && (pdwKeySpec == NULL || *pdwKeySpec == 0)) {
            dwKeySpec = AT_KEYEXCHANGE;
            fResult = LoadBobOldPvk(pPrivStg, dwKeySpec,
                &pbPvkValue, &cbPvkValue);
        }
        if (fResult) {
            BYTE *pbExportPvk;
            DWORD cbExportPvk;
            // Convert Bob's old private key format to the new export private
            // key format
            fResult = ConstructPrivateKeyExportBlob(
                    dwKeySpec,
                    (BSAFE_PRV_KEY *) pbPvkValue,
                    cbPvkValue,
                    &pbExportPvk,
                    &cbExportPvk
                    ); 
	    if (fResult) { 
                HCRYPTKEY hKey = 0;
                // Import the private key
                fResult = CryptImportKey(hCryptProv, pbExportPvk, cbExportPvk,
                    0, dwFlags, &hKey);
                if (hKey)
                    CryptDestroyKey(hKey);
                PvkFree(pbExportPvk);
            }
        }
    }
    
    if (fResult) goto CommonReturn;
    goto ErrorReturn;

HrError:
    SetLastError((DWORD) hr);
    goto ErrorReturn;

BadBobFile:
    SetLastError(PVK_HELPER_BAD_PVK_FILE);
ErrorReturn:
    dwKeySpec = 0;
    fResult = FALSE;

    // One of the following Releases may clear it out
    dwErr = GetLastError();
CommonReturn:
    if (pbPvkValue)
        PvkFree(pbPvkValue);
    if (pPrivStg)
        pPrivStg->Release();
    if (pStg)
        pStg->Release();
    if (pLkByt)
        pLkByt->Release();
    if (hGlobal)
        GlobalFree(hGlobal);

    if (pdwKeySpec)
        *pdwKeySpec = dwKeySpec;
    if (dwErr)
        SetLastError(dwErr);
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xenroll\thunks.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       thunks.cpp
//
//--------------------------------------------------------------------------

#define _CRYPT32_
#include <windows.h>
#include "unicode.h"
#include "crypthlp.h"

#include <stdlib.h>
#include <assert.h>

typedef PCCERT_CONTEXT
(WINAPI * PFNCertCreateSelfSignCertificate) (
    IN          HCRYPTPROV                  hProv,
    IN          PCERT_NAME_BLOB             pSubjectIssuerBlob,
    IN          DWORD                       dwFlags,
    OPTIONAL    PCRYPT_KEY_PROV_INFO        pKeyProvInfo,
    OPTIONAL    PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
    OPTIONAL    PSYSTEMTIME                 pStartTime,
    OPTIONAL    PSYSTEMTIME                 pEndTime,
    OPTIONAL    PCERT_EXTENSIONS            pExtensions
    );
PFNCertCreateSelfSignCertificate pfnCertCreateSelfSignCertificate = CertCreateSelfSignCertificate;

typedef PCCRYPT_OID_INFO
(WINAPI * PFNCryptFindOIDInfo) (
    IN DWORD dwKeyType,
    IN void *pvKey,
    IN DWORD dwGroupId      // 0 => any group
    );
PFNCryptFindOIDInfo pfnCryptFindOIDInfo = CryptFindOIDInfo;

typedef BOOL
(WINAPI * PFNCryptQueryObject) (DWORD            dwObjectType,
                       const void       *pvObject,
                       DWORD            dwExpectedContentTypeFlags,
                       DWORD            dwExpectedFormatTypeFlags,
                       DWORD            dwFlags,
                       DWORD            *pdwMsgAndCertEncodingType,
                       DWORD            *pdwContentType,
                       DWORD            *pdwFormatType,
                       HCERTSTORE       *phCertStore,
                       HCRYPTMSG        *phMsg,
                       const void       **ppvContext);
PFNCryptQueryObject pfnCryptQueryObject = CryptQueryObject;

typedef BOOL
(WINAPI * PFNCertStrToNameW) (
    IN DWORD dwCertEncodingType,
    IN LPCWSTR pwszX500,
    IN DWORD dwStrType,
    IN OPTIONAL void *pvReserved,
    OUT BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded,
    OUT OPTIONAL LPCWSTR *ppwszError
    );
PFNCertStrToNameW pfnCertStrToNameW = CertStrToNameW;

typedef BOOL
(WINAPI * PFNCryptVerifyMessageSignature)
    (IN            PCRYPT_VERIFY_MESSAGE_PARA   pVerifyPara,
     IN            DWORD                        dwSignerIndex,
     IN            BYTE const                  *pbSignedBlob,
     IN            DWORD                        cbSignedBlob,
     OUT           BYTE                        *pbDecoded,
     IN OUT        DWORD                       *pcbDecoded,
     OUT OPTIONAL  PCCERT_CONTEXT              *ppSignerCert);
PFNCryptVerifyMessageSignature pfnCryptVerifyMessageSignature = CryptVerifyMessageSignature;



BOOL
WINAPI
PFXIsPFXBlob(
CRYPT_DATA_BLOB* /*pPFX*/)
{

    return FALSE;
}

// Stubs to functions called from oidinfo.cpp
BOOL WINAPI
ChainIsConnected()
{
    return(FALSE);
}

BOOL WINAPI
ChainRetrieveObjectByUrlW (
     IN LPCWSTR /*pszUrl*/,
     IN LPCSTR /*pszObjectOid*/,
     IN DWORD /*dwRetrievalFlags*/,
     IN DWORD /*dwTimeout*/,
     OUT LPVOID* /*ppvObject*/,
     IN HCRYPTASYNC /*hAsyncRetrieve*/,
     IN PCRYPT_CREDENTIALS /*pCredentials*/,
     IN LPVOID /*pvVerify*/,
     IN OPTIONAL PCRYPT_RETRIEVE_AUX_INFO /*pAuxInfo*/
     )
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}

extern "C" {

BOOL
WINAPI
CertAddEncodedCTLToStore(
    IN HCERTSTORE /*hCertStore*/,
    IN DWORD /*dwMsgAndCertEncodingType*/,
    IN const BYTE * /*pbCtlEncoded*/,
    IN DWORD /*cbCtlEncoded*/,
    IN DWORD /*dwAddDisposition*/,
    OUT OPTIONAL PCCTL_CONTEXT * /*ppCtlContext*/
    ) {
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}

BOOL
WINAPI
CertFreeCTLContext(
IN PCCTL_CONTEXT /*pCtlContext*/
    )
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}

BOOL
WINAPI
CryptSIPLoad(
const GUID * /*pgSubject*/,
DWORD /*dwFlags*/,
void * /*psSipTable*/
)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}

BOOL
WINAPI
CryptSIPRetrieveSubjectGuid(
    IN LPCWSTR /*FileName*/,
    IN OPTIONAL HANDLE /*hFileIn*/,
    OUT GUID * /*pgSubject*/)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}



}       // end of extern C



// Thunk routines for function not in IE3.02Upd

PCCERT_CONTEXT
WINAPI
MyCertCreateSelfSignCertificate(
    IN          HCRYPTPROV                  hProv,
    IN          PCERT_NAME_BLOB             pSubjectIssuerBlob,
    IN          DWORD                       dwFlags,
    OPTIONAL    PCRYPT_KEY_PROV_INFO        pKeyProvInfo,
    OPTIONAL    PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
    OPTIONAL    PSYSTEMTIME                 pStartTime,
    OPTIONAL    PSYSTEMTIME                 pEndTime,
    OPTIONAL    PCERT_EXTENSIONS            pExtensions
    )
{

    return(pfnCertCreateSelfSignCertificate(
                hProv,
                pSubjectIssuerBlob,
                dwFlags,
                pKeyProvInfo,
                pSignatureAlgorithm,
                pStartTime,
                pEndTime,
                pExtensions));
}

PCCRYPT_OID_INFO
WINAPI
xeCryptFindOIDInfo(
    IN DWORD dwKeyType,
    IN void *pvKey,
    IN DWORD dwGroupId      // 0 => any group
    )
{
    return(pfnCryptFindOIDInfo(
                dwKeyType,
                pvKey,
                dwGroupId));
}

BOOL
WINAPI
MyCryptQueryObject(DWORD                dwObjectType,
                       const void       *pvObject,
                       DWORD            dwExpectedContentTypeFlags,
                       DWORD            dwExpectedFormatTypeFlags,
                       DWORD            dwFlags,
                       DWORD            *pdwMsgAndCertEncodingType,
                       DWORD            *pdwContentType,
                       DWORD            *pdwFormatType,
                       HCERTSTORE       *phCertStore,
                       HCRYPTMSG        *phMsg,
                       const void       **ppvContext)
{
    return(pfnCryptQueryObject(
                dwObjectType,
                pvObject,
                dwExpectedContentTypeFlags,
                dwExpectedFormatTypeFlags,
                dwFlags,
                pdwMsgAndCertEncodingType,
                pdwContentType,
                pdwFormatType,
                phCertStore,
                phMsg,
                ppvContext));
}

BOOL
WINAPI
MyCertStrToNameW(
    IN DWORD                dwCertEncodingType,
    IN LPCWSTR              pwszX500,
    IN DWORD                dwStrType,
    IN OPTIONAL void *      pvReserved,
    OUT BYTE *              pbEncoded,
    IN OUT DWORD *          pcbEncoded,
    OUT OPTIONAL LPCWSTR *  ppwszError
    )
{

    return(pfnCertStrToNameW(
                dwCertEncodingType,
                pwszX500,
                dwStrType,
                pvReserved,
                pbEncoded,
                pcbEncoded,
                ppwszError));
}

BOOL
WINAPI
MyCryptVerifyMessageSignature
(IN            PCRYPT_VERIFY_MESSAGE_PARA   pVerifyPara,
 IN            DWORD                        dwSignerIndex,
 IN            BYTE const                  *pbSignedBlob,
 IN            DWORD                        cbSignedBlob,
 OUT           BYTE                        *pbDecoded,
 IN OUT        DWORD                       *pcbDecoded,
 OUT OPTIONAL  PCCERT_CONTEXT              *ppSignerCert)
{
    return pfnCryptVerifyMessageSignature
        (pVerifyPara,
         dwSignerIndex,
         pbSignedBlob,
         cbSignedBlob,
         pbDecoded,
         pcbDecoded,
         ppSignerCert);
}

extern "C"
BOOL WINAPI InitIE302UpdThunks(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{

HMODULE hModCrypt32 = NULL;
FARPROC fproc;
DWORD   verCrypt32MS;
DWORD   verCrypt32LS;
DWORD   verXEnrollMS;
DWORD   verXEnrollLS;
char    szFileName[_MAX_PATH];
LPWSTR  wszFilePathCrypt32  = NULL;
LPWSTR  wszFilePathXEnroll  = NULL;

    if (dwReason == DLL_PROCESS_ATTACH) {

        // this can't fail because it is already loaded
        hModCrypt32 = GetModuleHandleA("Crypt32.dll");
        assert(hModCrypt32);

        // Get Filever of crypt32 and XEnroll, only copy go to crypt32 if it is newer than xenroll
        if( 0 != GetModuleFileNameA(hModCrypt32, szFileName, sizeof(szFileName))  &&
            NULL != (wszFilePathCrypt32 = MkWStr(szFileName))                       &&
            I_CryptGetFileVersion(wszFilePathCrypt32, &verCrypt32MS, &verCrypt32LS) &&
            0 != GetModuleFileNameA(hInstance, szFileName, sizeof(szFileName))    &&
            NULL != (wszFilePathXEnroll = MkWStr(szFileName))                       &&
            I_CryptGetFileVersion(wszFilePathXEnroll, &verXEnrollMS, &verXEnrollLS) &&
            (   (verCrypt32MS > verXEnrollMS)  ||
               ((verCrypt32MS == verXEnrollMS)  &&  verCrypt32LS >= verXEnrollLS) ) ) {

            // crypt32 must be newer, use his functions
            if(NULL != (fproc = GetProcAddress(hModCrypt32, "CertCreateSelfSignCertificate")))
                pfnCertCreateSelfSignCertificate = (PFNCertCreateSelfSignCertificate) fproc;

            if(NULL != (fproc = GetProcAddress(hModCrypt32, "CryptFindOIDInfo")))
                pfnCryptFindOIDInfo = (PFNCryptFindOIDInfo) fproc;

            if(NULL != (fproc = GetProcAddress(hModCrypt32, "CryptQueryObject")))
                pfnCryptQueryObject = (PFNCryptQueryObject) fproc;

            if(NULL != (fproc = GetProcAddress(hModCrypt32, "CertStrToNameW")))
                pfnCertStrToNameW = (PFNCertStrToNameW) fproc;

            if(NULL != (fproc = GetProcAddress(hModCrypt32, "CryptVerifyMessageSignature")))
                pfnCryptVerifyMessageSignature = (PFNCryptVerifyMessageSignature) fproc;
        }

        // free allocated handles
        if(wszFilePathCrypt32 != NULL)
            FreeWStr(wszFilePathCrypt32);

        if(wszFilePathXEnroll != NULL)
            FreeWStr(wszFilePathXEnroll);
    }


return(TRUE);
}


BOOL
MyCryptStringToBinaryA(
    IN     LPCSTR  pszString,
    IN     DWORD     cchString,
    IN     DWORD     dwFlags,
    IN     BYTE     *pbBinary,
    IN OUT DWORD    *pcbBinary,
    OUT    DWORD    *pdwSkip,    //OPTIONAL
    OUT    DWORD    *pdwFlags    //OPTIONAL
    )
{
    return CryptStringToBinaryA(
                pszString,
                cchString,
                dwFlags,
                pbBinary,
                pcbBinary,
                pdwSkip,
                pdwFlags);
}

BOOL
MyCryptStringToBinaryW(
    IN     LPCWSTR  pszString,
    IN     DWORD     cchString,
    IN     DWORD     dwFlags,
    IN     BYTE     *pbBinary,
    IN OUT DWORD    *pcbBinary,
    OUT    DWORD    *pdwSkip,    //OPTIONAL
    OUT    DWORD    *pdwFlags    //OPTIONAL
    )
{
    return CryptStringToBinaryW(
                pszString,
                cchString,
                dwFlags,
                pbBinary,
                pcbBinary,
                pdwSkip,
                pdwFlags);
}

BOOL
MyCryptBinaryToStringA(
    IN     CONST BYTE  *pbBinary,
    IN     DWORD        cbBinary,
    IN     DWORD        dwFlags,
    IN     LPSTR      pszString,
    IN OUT DWORD       *pcchString
    )
{
    return CryptBinaryToStringA(
                pbBinary,
                cbBinary,
                dwFlags,
                pszString,
                pcchString);
}

BOOL
MyCryptBinaryToStringW(
    IN     CONST BYTE  *pbBinary,
    IN     DWORD        cbBinary,
    IN     DWORD        dwFlags,
    IN     LPWSTR      pszString,
    IN OUT DWORD       *pcchString
    )
{
    return CryptBinaryToStringW(
                pbBinary,
                cbBinary,
                dwFlags,
                pszString,
                pcchString);
}

#ifdef _X86_

#define ASN1C
#include "msber.h"

static HMODULE hmsasn1=NULL;

typedef ASN1module_t (__stdcall * ASN1_CREATEMODULE)(
    ASN1uint32_t            version,
    ASN1encodingrule_e      eEncodingRule,
    ASN1uint32_t            dwFlags,
    ASN1uint32_t            cPDUs,
    const ASN1GenericFun_t  apfnEncoder[],
    const ASN1GenericFun_t  apfnDecoder[],
    const ASN1FreeFun_t     apfnFreeMemory[],
    const ASN1uint32_t      acbStructSize[],
    ASN1magic_t             nModuleName
    );
typedef void (__stdcall * ASN1_CLOSEMODULE)( ASN1module_t pModule );
typedef int (__stdcall * ASN1BERENCENDOFCONTENTS)( ASN1encoding_t enc, ASN1uint32_t nLenOff );
typedef int (__stdcall * ASN1BERENCOBJECTIDENTIFIER2)( ASN1encoding_t enc, ASN1uint32_t tag, ASN1objectidentifier2_t *val );
typedef int (__stdcall * ASN1BERENCEXPLICITTAG)( ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t *pnLenOff );
typedef int (__stdcall * ASN1BERDECENDOFCONTENTS)( ASN1decoding_t dec, ASN1decoding_t dd, ASN1octet_t *pBufEnd );
typedef int (__stdcall * ASN1BERDECOBJECTIDENTIFIER2)( ASN1decoding_t dec, ASN1uint32_t tag, ASN1objectidentifier2_t *val );
typedef LPVOID (__stdcall * ASN1DECREALLOC)( ASN1decoding_t dec, LPVOID ptr, ASN1uint32_t size );
typedef int (__stdcall * ASN1BERDECPEEKTAG)( ASN1decoding_t dec, ASN1uint32_t *tag );
typedef int (__stdcall * ASN1BERDECNOTENDOFCONTENTS)( ASN1decoding_t dec, ASN1octet_t *pBufEnd );
typedef int (__stdcall * ASN1BERDECEXPLICITTAG)( ASN1decoding_t dec, ASN1uint32_t tag, ASN1decoding_t *dd, ASN1octet_t **ppBufEnd );
typedef void (__stdcall * ASN1FREE)( LPVOID ptr );
typedef int (__stdcall * ASN1BERENCS32)( ASN1encoding_t enc, ASN1uint32_t tag, ASN1int32_t val );
typedef int (__stdcall * ASN1BERENCBOOL)( ASN1encoding_t enc, ASN1uint32_t tag, ASN1bool_t val );
typedef int (__stdcall * ASN1BERDECS32VAL)( ASN1decoding_t dec, ASN1uint32_t tag, ASN1int32_t *val );
typedef int (__stdcall * ASN1BERDECBOOL)( ASN1decoding_t dec, ASN1uint32_t tag, ASN1bool_t *val );
typedef int (__stdcall * ASN1BERENCCHAR16STRING)( ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char16_t *val );
typedef int (__stdcall * ASN1BERENCBITSTRING)( ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val );
typedef int (__stdcall * ASN1BERDECBITSTRING2)( ASN1decoding_t dec, ASN1uint32_t tag, ASN1bitstring_t *val );
typedef int (__stdcall * ASN1BERDECCHAR16STRING)( ASN1decoding_t dec, ASN1uint32_t tag, ASN1char16string_t *val );
typedef void (__stdcall * ASN1CHAR16STRING_FREE)( ASN1char16string_t *val );
typedef int (__stdcall * ASN1BERENCU32)( ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t val );
typedef int (__stdcall * ASN1BERENCOCTETSTRING)( ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val );
typedef int (__stdcall * ASN1BERDECU32VAL)( ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint32_t *val );
typedef int (__stdcall * ASN1BERDECOCTETSTRING2)( ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val );
typedef int (__stdcall * ASN1CERENCBEGINBLK)( ASN1encoding_t enc, ASN1blocktype_e eBlkType, void **ppBlk_ );
typedef int (__stdcall * ASN1CERENCNEWBLKELEMENT)( void *pBlk_, ASN1encoding_t *enc2 );
typedef int (__stdcall * ASN1CERENCFLUSHBLKELEMENT)( void *pBlk_ );
typedef int (__stdcall * ASN1CERENCENDBLK)( void *pBlk_ );
typedef int (__stdcall * ASN1BERENCOPENTYPE)( ASN1encoding_t enc, ASN1open_t *val );
typedef int (__stdcall * ASN1BERDECOPENTYPE2)( ASN1decoding_t dec, ASN1open_t *val );
typedef ASN1error_e (__stdcall * ASN1DECSETERROR)( ASN1decoding_t dec, ASN1error_e err );
typedef int (__stdcall * ASN1BERENCUTF8STRING)( ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t length, WCHAR *value );
typedef int (__stdcall * ASN1BERDECGENERALIZEDTIME)( ASN1decoding_t dec, ASN1uint32_t tag, ASN1generalizedtime_t *val );
typedef void (__stdcall * ASN1UTF8STRING_FREE)( ASN1wstring_t *val );
typedef void (__stdcall * ASN1_FREEDECODED)( ASN1decoding_t dec, void *val, ASN1uint32_t id );
typedef ASN1error_e (__stdcall * ASN1_ENCODE)(
    ASN1encoding_t      enc,
    void               *value,
    ASN1uint32_t        id,
    ASN1uint32_t        flags,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize
    );
typedef ASN1error_e (__stdcall * ASN1_DECODE)(
    ASN1decoding_t dec,
    void              **valref,
    ASN1uint32_t        id,
    ASN1uint32_t        flags,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize
    );
typedef ASN1error_e (__stdcall * ASN1_SETENCODEROPTION)( ASN1encoding_t enc, ASN1optionparam_t *pOptParam );
typedef ASN1error_e (__stdcall * ASN1_GETENCODEROPTION)( ASN1encoding_t enc, ASN1optionparam_t *pOptParam );
typedef void (__stdcall * ASN1_FREEENCODED)( ASN1encoding_t enc, void *val );
typedef int (__stdcall * ASN1BERDECUTF8STRING)( ASN1decoding_t dec, ASN1uint32_t tag, ASN1wstring_t *val );
typedef int (__stdcall * ASN1CERENCGENERALIZEDTIME)( ASN1encoding_t enc, ASN1uint32_t tag, ASN1generalizedtime_t *val );

static ASN1_CREATEMODULE pfnASN1_CreateModule = NULL;
static ASN1_CLOSEMODULE pfnASN1_CloseModule = NULL;
static ASN1BERENCENDOFCONTENTS pfnASN1BEREncEndOfContents = NULL;
static ASN1BERENCOBJECTIDENTIFIER2 pfnASN1BEREncObjectIdentifier2 = NULL;
static ASN1BERENCEXPLICITTAG pfnASN1BEREncExplicitTag = NULL;
static ASN1BERDECENDOFCONTENTS pfnASN1BERDecEndOfContents = NULL;
static ASN1BERDECOBJECTIDENTIFIER2 pfnASN1BERDecObjectIdentifier2 = NULL;
static ASN1DECREALLOC pfnASN1DecRealloc = NULL;
static ASN1BERDECPEEKTAG pfnASN1BERDecPeekTag = NULL;
static ASN1BERDECNOTENDOFCONTENTS pfnASN1BERDecNotEndOfContents = NULL;
static ASN1BERDECEXPLICITTAG pfnASN1BERDecExplicitTag = NULL;
static ASN1FREE pfnASN1Free = NULL;
static ASN1BERENCS32 pfnASN1BEREncS32 = NULL;
static ASN1BERENCBOOL pfnASN1BEREncBool = NULL;
static ASN1BERDECS32VAL pfnASN1BERDecS32Val = NULL;
static ASN1BERDECBOOL pfnASN1BERDecBool = NULL;
static ASN1BERENCCHAR16STRING pfnASN1BEREncChar16String = NULL;
static ASN1BERENCBITSTRING pfnASN1BEREncBitString = NULL;
static ASN1BERDECBITSTRING2 pfnASN1BERDecBitString2 = NULL;
static ASN1BERDECCHAR16STRING pfnASN1BERDecChar16String = NULL;
static ASN1CHAR16STRING_FREE pfnASN1char16string_free = NULL;
static ASN1BERENCU32 pfnASN1BEREncU32 = NULL;
static ASN1BERENCOCTETSTRING pfnASN1BEREncOctetString = NULL;
static ASN1BERDECU32VAL pfnASN1BERDecU32Val = NULL;
static ASN1BERDECOCTETSTRING2 pfnASN1BERDecOctetString2 = NULL;
static ASN1CERENCBEGINBLK pfnASN1CEREncBeginBlk = NULL;
static ASN1CERENCNEWBLKELEMENT pfnASN1CEREncNewBlkElement = NULL;
static ASN1CERENCFLUSHBLKELEMENT pfnASN1CEREncFlushBlkElement = NULL;
static ASN1CERENCENDBLK pfnASN1CEREncEndBlk = NULL;
static ASN1BERENCOPENTYPE pfnASN1BEREncOpenType = NULL;
static ASN1BERDECOPENTYPE2 pfnASN1BERDecOpenType2 = NULL;
static ASN1DECSETERROR pfnASN1DecSetError = NULL;
static ASN1BERENCUTF8STRING pfnASN1BEREncUTF8String = NULL;
static ASN1BERDECGENERALIZEDTIME pfnASN1BERDecGeneralizedTime = NULL;
static ASN1UTF8STRING_FREE pfnASN1utf8string_free = NULL;
static ASN1_FREEDECODED pfnASN1_FreeDecoded = NULL;
static ASN1_ENCODE pfnASN1_Encode = NULL;
static ASN1_DECODE pfnASN1_Decode = NULL;
static ASN1_SETENCODEROPTION pfnASN1_SetEncoderOption = NULL;
static ASN1_GETENCODEROPTION pfnASN1_GetEncoderOption = NULL;
static ASN1_FREEENCODED pfnASN1_FreeEncoded = NULL;
static ASN1BERDECUTF8STRING pfnASN1BERDecUTF8String = NULL;
static ASN1CERENCGENERALIZEDTIME pfnASN1CEREncGeneralizedTime = NULL;

#define LOAD_ASN1_THUNK_PROC( _pfn, _procType, _proc ) \
{ \
\
  if ( !hmsasn1 ) { \
       hmsasn1 = LoadLibrary( "msasn1.dll" ); \
  } \
  \
  if ( hmsasn1 && !_pfn ) { \
      (_pfn) = (_procType) GetProcAddress( hmsasn1, _proc ); \
  } \
}

extern ASN1module_t __stdcall ASN1_CreateModule(
    ASN1uint32_t            version,
    ASN1encodingrule_e      eEncodingRule,
    ASN1uint32_t            dwFlags,
    ASN1uint32_t            cPDUs,
    const ASN1GenericFun_t  apfnEncoder[],
    const ASN1GenericFun_t  apfnDecoder[],
    const ASN1FreeFun_t     apfnFreeMemory[],
    const ASN1uint32_t      acbStructSize[],
    ASN1magic_t             nModuleName
    ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1_CreateModule, ASN1_CREATEMODULE, "ASN1_CreateModule" );

    if ( hmsasn1 && pfnASN1_CreateModule ) {
        return pfnASN1_CreateModule(
            version, eEncodingRule, dwFlags, cPDUs, apfnEncoder, apfnDecoder, apfnFreeMemory, acbStructSize, nModuleName );
    }

    return NULL;
}

extern void __stdcall ASN1_CloseModule( ASN1module_t pModule ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1_CloseModule, ASN1_CLOSEMODULE, "ASN1_CloseModule" );

    if ( hmsasn1 && pfnASN1_CloseModule ) {
        return pfnASN1_CloseModule( pModule );
    }

    return ;
}

extern int __stdcall ASN1BEREncEndOfContents( ASN1encoding_t enc, ASN1uint32_t nLenOff ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1BEREncEndOfContents, ASN1BERENCENDOFCONTENTS, "ASN1BEREncEndOfContents" );

    if ( hmsasn1 && pfnASN1BEREncEndOfContents ) {
        return pfnASN1BEREncEndOfContents( enc, nLenOff);
    }

    return 0;
}

extern int __stdcall ASN1BEREncObjectIdentifier2( ASN1encoding_t enc, ASN1uint32_t tag, ASN1objectidentifier2_t *val ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1BEREncObjectIdentifier2, ASN1BERENCOBJECTIDENTIFIER2, "ASN1BEREncObjectIdentifier2" );

    if ( hmsasn1 && pfnASN1BEREncObjectIdentifier2 ) {
        return pfnASN1BEREncObjectIdentifier2( enc, tag, val );
    }

    return 0;
}

extern int __stdcall ASN1BEREncExplicitTag( ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t *pnLenOff ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1BEREncExplicitTag, ASN1BERENCEXPLICITTAG, "ASN1BEREncExplicitTag" );

    if ( hmsasn1 && pfnASN1BEREncExplicitTag ) {
        return pfnASN1BEREncExplicitTag( enc, tag, pnLenOff );
    }

    return 0;
}

extern int __stdcall ASN1BERDecEndOfContents( ASN1decoding_t dec, ASN1decoding_t dd, ASN1octet_t *pBufEnd ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1BERDecEndOfContents, ASN1BERDECENDOFCONTENTS, "ASN1BERDecEndOfContents" );

    if ( hmsasn1 && pfnASN1BERDecEndOfContents ) {
        return pfnASN1BERDecEndOfContents( dec, dd, pBufEnd );
    }

    return 0;
}

extern int __stdcall ASN1BERDecObjectIdentifier2( ASN1decoding_t dec, ASN1uint32_t tag, ASN1objectidentifier2_t *val ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1BERDecObjectIdentifier2, ASN1BERDECOBJECTIDENTIFIER2, "ASN1BERDecObjectIdentifier2" );

    if ( hmsasn1 && pfnASN1BERDecObjectIdentifier2 ) {
        return pfnASN1BERDecObjectIdentifier2( dec, tag, val );
    }

    return 0;
}

extern LPVOID __stdcall ASN1DecRealloc( ASN1decoding_t dec, LPVOID ptr, ASN1uint32_t size ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1DecRealloc, ASN1DECREALLOC, "ASN1DecRealloc" );

    if ( hmsasn1 && pfnASN1DecRealloc ) {
        return pfnASN1DecRealloc( dec, ptr, size );
    }

    return NULL;
}

extern int __stdcall ASN1BERDecPeekTag( ASN1decoding_t dec, ASN1uint32_t *tag ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1BERDecPeekTag, ASN1BERDECPEEKTAG, "ASN1BERDecPeekTag" );

    if ( hmsasn1 && pfnASN1BERDecPeekTag ) {
        return pfnASN1BERDecPeekTag( dec, tag );
    }

    return 0;
}

extern int __stdcall ASN1BERDecNotEndOfContents( ASN1decoding_t dec, ASN1octet_t *pBufEnd ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1BERDecNotEndOfContents, ASN1BERDECNOTENDOFCONTENTS, "ASN1BERDecNotEndOfContents" );

    if ( hmsasn1 && pfnASN1BERDecNotEndOfContents ) {
        return pfnASN1BERDecNotEndOfContents( dec, pBufEnd );
    }

    return 0;
}

extern int __stdcall ASN1BERDecExplicitTag( ASN1decoding_t dec, ASN1uint32_t tag, ASN1decoding_t *dd, ASN1octet_t **ppBufEnd ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1BERDecExplicitTag, ASN1BERDECEXPLICITTAG, "ASN1BERDecExplicitTag" );

    if ( hmsasn1 && pfnASN1BERDecExplicitTag ) {
        return pfnASN1BERDecExplicitTag( dec, tag, dd, ppBufEnd );
    }

    return 0;
}

extern void __stdcall ASN1Free( LPVOID ptr ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1Free, ASN1FREE, "ASN1Free" );

    if ( hmsasn1 && pfnASN1Free ) {
        return pfnASN1Free( ptr );
    }

    return ;
}

extern int __stdcall ASN1BEREncS32( ASN1encoding_t enc, ASN1uint32_t tag, ASN1int32_t val ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1BEREncS32, ASN1BERENCS32, "ASN1BEREncS32" );

    if ( hmsasn1 && pfnASN1BEREncS32 ) {
        return pfnASN1BEREncS32( enc, tag, val );
    }

    return 0;
}

extern int __stdcall ASN1BEREncBool( ASN1encoding_t enc, ASN1uint32_t tag, ASN1bool_t val ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1BEREncBool, ASN1BERENCBOOL, "ASN1BEREncBool" );

    if ( hmsasn1 && pfnASN1BEREncBool ) {
        return pfnASN1BEREncBool( enc, tag, val );
    }

    return 0;
}

extern int __stdcall ASN1BERDecS32Val( ASN1decoding_t dec, ASN1uint32_t tag, ASN1int32_t *val ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1BERDecS32Val, ASN1BERDECS32VAL, "ASN1BERDecS32Val" );

    if ( hmsasn1 && pfnASN1BERDecS32Val ) {
        return pfnASN1BERDecS32Val( dec, tag, val);
    }

    return 0;
}

extern int __stdcall ASN1BERDecBool( ASN1decoding_t dec, ASN1uint32_t tag, ASN1bool_t *val ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1BERDecBool, ASN1BERDECBOOL, "ASN1BERDecBool" );

    if ( hmsasn1 && pfnASN1BERDecBool ) {
        return pfnASN1BERDecBool( dec, tag, val);
    }

    return 0;
}

extern int __stdcall ASN1BEREncChar16String( ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char16_t *val ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1BEREncChar16String, ASN1BERENCCHAR16STRING, "ASN1BEREncChar16String" );

    if ( hmsasn1 && pfnASN1BEREncChar16String ) {
        return pfnASN1BEREncChar16String( enc, tag, len, val );
    }

    return 0;
}

extern int __stdcall ASN1BEREncBitString( ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1BEREncBitString, ASN1BERENCBITSTRING, "ASN1BEREncBitString" );

    if ( hmsasn1 && pfnASN1BEREncBitString ) {
        return pfnASN1BEREncBitString( enc, tag, len, val );
    }

    return 0;
}

extern int __stdcall ASN1BERDecBitString2( ASN1decoding_t dec, ASN1uint32_t tag, ASN1bitstring_t *val ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1BERDecBitString2, ASN1BERDECBITSTRING2, "ASN1BERDecBitString2" );

    if ( hmsasn1 && pfnASN1BERDecBitString2 ) {
        return pfnASN1BERDecBitString2( dec, tag, val );
    }

    return 0;
}

extern int __stdcall ASN1BERDecChar16String( ASN1decoding_t dec, ASN1uint32_t tag, ASN1char16string_t *val ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1BERDecChar16String, ASN1BERDECCHAR16STRING, "ASN1BERDecChar16String" );

    if ( hmsasn1 && pfnASN1BERDecChar16String ) {
        return pfnASN1BERDecChar16String( dec, tag, val );
    }

    return 0;
}

extern void __stdcall ASN1char16string_free( ASN1char16string_t *val ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1char16string_free, ASN1CHAR16STRING_FREE, "ASN1char16string_free" );

    if ( hmsasn1 && pfnASN1char16string_free ) {
        return pfnASN1char16string_free( val );
    }

    return ;
}

extern int __stdcall ASN1BEREncU32( ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t val ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1BEREncU32, ASN1BERENCU32, "ASN1BEREncU32" );

    if ( hmsasn1 && pfnASN1BEREncU32 ) {
        return pfnASN1BEREncU32( enc, tag, val );
    }

    return 0;
}

extern int __stdcall ASN1BEREncOctetString( ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1BEREncOctetString, ASN1BERENCOCTETSTRING, "ASN1BEREncOctetString" );

    if ( hmsasn1 && pfnASN1BEREncOctetString ) {
        return pfnASN1BEREncOctetString( enc, tag, len, val );
    }

    return 0;
}

extern int __stdcall ASN1BERDecU32Val( ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint32_t *val ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1BERDecU32Val, ASN1BERDECU32VAL, "ASN1BERDecU32Val" );

    if ( hmsasn1 && pfnASN1BERDecU32Val ) {
        return pfnASN1BERDecU32Val( dec, tag, val );
    }

    return 0;
}

extern int __stdcall ASN1BERDecOctetString2( ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1BERDecOctetString2, ASN1BERDECOCTETSTRING2, "ASN1BERDecOctetString2" );

    if ( hmsasn1 && pfnASN1BERDecOctetString2 ) {
        return pfnASN1BERDecOctetString2( dec, tag, val );
    }

    return 0;
}

extern int __stdcall ASN1CEREncBeginBlk( ASN1encoding_t enc, ASN1blocktype_e eBlkType, void **ppBlk_ ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1CEREncBeginBlk, ASN1CERENCBEGINBLK, "ASN1CEREncBeginBlk" );

    if ( hmsasn1 && pfnASN1CEREncBeginBlk ) {
        return pfnASN1CEREncBeginBlk( enc, eBlkType, ppBlk_ );
    }

    return 0;
}

extern int __stdcall ASN1CEREncNewBlkElement( void *pBlk_, ASN1encoding_t *enc2 ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1CEREncNewBlkElement, ASN1CERENCNEWBLKELEMENT, "ASN1CEREncNewBlkElement" );

    if ( hmsasn1 && pfnASN1CEREncNewBlkElement ) {
        return pfnASN1CEREncNewBlkElement( pBlk_, enc2 );
    }

    return 0;
}

extern int __stdcall ASN1CEREncFlushBlkElement( void *pBlk_ ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1CEREncFlushBlkElement, ASN1CERENCFLUSHBLKELEMENT, "ASN1CEREncFlushBlkElement" );

    if ( hmsasn1 && pfnASN1CEREncFlushBlkElement ) {
        return pfnASN1CEREncFlushBlkElement( pBlk_ );
    }

    return 0;
}

extern int __stdcall ASN1CEREncEndBlk( void *pBlk_ ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1CEREncEndBlk, ASN1CERENCENDBLK, "ASN1CEREncEndBlk" );

    if ( hmsasn1 && pfnASN1CEREncEndBlk ) {
        return pfnASN1CEREncEndBlk( pBlk_ );
    }

    return 0;
}

extern int __stdcall ASN1BEREncOpenType( ASN1encoding_t enc, ASN1open_t *val ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1BEREncOpenType, ASN1BERENCOPENTYPE, "ASN1BEREncOpenType" );

    if ( hmsasn1 && pfnASN1BEREncOpenType ) {
        return pfnASN1BEREncOpenType( enc, val );
    }

    return 0;
}

extern int __stdcall ASN1BERDecOpenType2( ASN1decoding_t dec, ASN1open_t *val ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1BERDecOpenType2, ASN1BERDECOPENTYPE2, "ASN1BERDecOpenType2" );

    if ( hmsasn1 && pfnASN1BERDecOpenType2 ) {
        return pfnASN1BERDecOpenType2( dec, val );
    }

    return 0;
}

extern ASN1error_e __stdcall ASN1DecSetError( ASN1decoding_t dec, ASN1error_e err ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1DecSetError, ASN1DECSETERROR, "ASN1DecSetError" );

    if ( hmsasn1 && pfnASN1DecSetError ) {
        return pfnASN1DecSetError( dec, err );
    }

    return ASN1_ERR_INTERNAL;
}

extern int __stdcall ASN1BEREncUTF8String( ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t length, WCHAR *value ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1BEREncUTF8String, ASN1BERENCUTF8STRING, "ASN1BEREncUTF8String" );

    if ( hmsasn1 && pfnASN1BEREncUTF8String ) {
        return pfnASN1BEREncUTF8String( enc, tag, length, value );
    }

    return 0;
}

extern int __stdcall ASN1BERDecGeneralizedTime( ASN1decoding_t dec, ASN1uint32_t tag, ASN1generalizedtime_t *val ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1BERDecGeneralizedTime, ASN1BERDECGENERALIZEDTIME, "ASN1BERDecGeneralizedTime" );

    if ( hmsasn1 && pfnASN1BERDecGeneralizedTime ) {
        return pfnASN1BERDecGeneralizedTime( dec, tag, val );
    }

    return 0;
}

extern void __stdcall ASN1utf8string_free( ASN1wstring_t *val ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1utf8string_free, ASN1UTF8STRING_FREE, "ASN1utf8string_free" );

    if ( hmsasn1 && pfnASN1utf8string_free ) {
        return pfnASN1utf8string_free( val );
    }

    return ;
}

extern void __stdcall ASN1_FreeDecoded( ASN1decoding_t dec, void *val, ASN1uint32_t id ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1_FreeDecoded, ASN1_FREEDECODED, "ASN1_FreeDecoded" );

    if ( hmsasn1&& pfnASN1_FreeDecoded ) {
        return pfnASN1_FreeDecoded( dec, val, id );
    }

    return ;
}

extern ASN1error_e __stdcall ASN1_Encode(
    ASN1encoding_t      enc,
    void               *value,
    ASN1uint32_t        id,
    ASN1uint32_t        flags,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize
    ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1_Encode, ASN1_ENCODE, "ASN1_Encode" );

    if ( hmsasn1 && pfnASN1_Encode ) {
        return pfnASN1_Encode( enc, value, id, flags, pbBuf, cbBufSize );
    }

    return ASN1_ERR_INTERNAL;
}

extern ASN1error_e __stdcall ASN1_Decode(
    ASN1decoding_t dec,
    void           **valref,
    ASN1uint32_t   id,
    ASN1uint32_t   flags,
    ASN1octet_t    *pbBuf,
    ASN1uint32_t   cbBufSize
    ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1_Decode, ASN1_DECODE, "ASN1_Decode" );

    if ( hmsasn1 && pfnASN1_Decode ) {
        return pfnASN1_Decode( dec, valref, id, flags, pbBuf, cbBufSize );
    }

    return ASN1_ERR_INTERNAL;
}

extern ASN1error_e __stdcall ASN1_SetEncoderOption( ASN1encoding_t enc, ASN1optionparam_t *pOptParam ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1_SetEncoderOption, ASN1_SETENCODEROPTION, "ASN1_SetEncoderOption" );

    if ( hmsasn1 && pfnASN1_SetEncoderOption ) {
        return pfnASN1_SetEncoderOption( enc, pOptParam );
    }

    return ASN1_ERR_INTERNAL;
}

extern ASN1error_e __stdcall ASN1_GetEncoderOption( ASN1encoding_t enc, ASN1optionparam_t *pOptParam) {

    LOAD_ASN1_THUNK_PROC( pfnASN1_GetEncoderOption, ASN1_GETENCODEROPTION, "ASN1_GetEncoderOption" );

    if ( hmsasn1 && pfnASN1_GetEncoderOption ) {
        return pfnASN1_GetEncoderOption( enc, pOptParam );
    }

    return ASN1_ERR_INTERNAL;
}

extern void __stdcall ASN1_FreeEncoded( ASN1encoding_t enc, void *val ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1_FreeEncoded, ASN1_FREEENCODED, "ASN1_FreeEncoded" );

    if ( hmsasn1 && pfnASN1_FreeEncoded ) {
        return pfnASN1_FreeEncoded( enc, val );
    }

    return ;
}

extern int __stdcall ASN1BERDecUTF8String( ASN1decoding_t dec, ASN1uint32_t tag, ASN1wstring_t *val ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1BERDecUTF8String, ASN1BERDECUTF8STRING, "ASN1BERDecUTF8String" );

    if ( hmsasn1 && pfnASN1BERDecUTF8String ) {
        return pfnASN1BERDecUTF8String( dec, tag, val );
    }

    return 0;
}

extern int __stdcall ASN1CEREncGeneralizedTime( ASN1encoding_t enc, ASN1uint32_t tag, ASN1generalizedtime_t *val ) {

    LOAD_ASN1_THUNK_PROC( pfnASN1CEREncGeneralizedTime, ASN1CERENCGENERALIZEDTIME, "ASN1CEREncGeneralizedTime" );

    if ( hmsasn1 && pfnASN1CEREncGeneralizedTime ) {
        return pfnASN1CEREncGeneralizedTime( enc, tag, val );
    }

    return 0;
}

#endif // _X86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xenroll\sfscript.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2002
//
//  File:       sfscript.cpp
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <wincrypt.h>
#include <dbgdef.h>
#include "unicode.h"
#include "resource.h"
#include "sfscript.h"

// handle to xenroll initalized in DllMain
extern HINSTANCE hInstanceXEnroll;

// implemented in cenroll.cpp
HRESULT xeLoadRCString(IN HINSTANCE  hInstance, 
		       IN int        iRCId, 
		       OUT WCHAR    **ppwsz);


BOOL VerifyProviderFlagsSafeForScripting(DWORD dwFlags) { 
    DWORD dwSafeFlags = CRYPT_MACHINE_KEYSET;

    // Return FALSE if the flag contains an unsafe flag. 
    return 0 == (dwFlags & ~dwSafeFlags); 
}

BOOL VerifyStoreFlagsSafeForScripting(DWORD dwFlags) { 
    DWORD dwSafeFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE | CERT_SYSTEM_STORE_CURRENT_USER;

    // Return FALSE if the flag contains an unsafe flag. 
    return 0 == (dwFlags & ~dwSafeFlags); 
}

BOOL VerifyStoreSafeForScripting(HCERTSTORE hStore) {

    DWORD           fRet            = FALSE;
    PCCERT_CONTEXT  pCertContext    = NULL;
    DWORD           dwCertCnt       = 0;
    WCHAR          *pwszSafety      = NULL;
    WCHAR          *pwszMsg         = NULL;
    HRESULT         hr;

    // count how many requests in the store
    while(NULL != (pCertContext =  CertEnumCertificatesInStore(
							       hStore,    
							       pCertContext)))
	dwCertCnt++;                                                                
    
    if(dwCertCnt >= MAX_SAFE_FOR_SCRIPTING_REQUEST_STORE_COUNT)
    {
	hr = xeLoadRCString(hInstanceXEnroll, IDS_NOTSAFEACTION, &pwszSafety);
	if (S_OK != hr)
	{
	    goto xeLoadRCStringError;
	}
	hr = xeLoadRCString(hInstanceXEnroll, IDS_REQ_STORE_FULL, &pwszMsg);
	if (S_OK != hr)
	{
	    goto xeLoadRCStringError;
	}
     
	switch(MessageBoxU(NULL, pwszMsg, pwszSafety, MB_YESNO | MB_ICONWARNING)) {

	case IDYES:
	    break;

	case IDNO:
	default:
	    SetLastError(ERROR_CANCELLED);
	    goto ErrorCancelled;
	    break;

	}
    }

    fRet = TRUE;
ErrorReturn:
    if (NULL != pwszMsg)
    {
        LocalFree(pwszMsg);
    }
    if (NULL != pwszSafety)
    {
        LocalFree(pwszSafety);
    }
    return(fRet);

TRACE_ERROR(ErrorCancelled);
TRACE_ERROR(xeLoadRCStringError);
}

BOOL WINAPI MySafeCertAddCertificateContextToStore(HCERTSTORE       hCertStore, 
						   PCCERT_CONTEXT   pCertContext, 
						   DWORD            dwAddDisposition, 
						   PCCERT_CONTEXT  *ppStoreContext, 
						   DWORD            dwSafetyOptions)
{
    BOOL fResult; 

    if (0 != dwSafetyOptions) { 
	fResult = VerifyStoreSafeForScripting(hCertStore);
	if (!fResult)
	    goto AccessDeniedError;
    }

    fResult = CertAddCertificateContextToStore(hCertStore, pCertContext, dwAddDisposition, ppStoreContext); 
    if (!fResult)
	goto CertAddCertificateContextToStoreError;

    fResult = TRUE; 
 ErrorReturn:
    return fResult; 

SET_ERROR(AccessDeniedError, ERROR_ACCESS_DENIED); 
TRACE_ERROR(CertAddCertificateContextToStoreError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xenroll\xasn.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       xasn.c
//
//--------------------------------------------------------------------------

/************************************************************************/
/* Copyright (C) 1998 Open Systems Solutions, Inc.  All rights reserved.*/
/************************************************************************/
/* Generated for: Microsoft Corporation */
/* Abstract syntax: xasn */
/* Created: Tue Mar 17 17:07:17 1998 */
/* ASN.1 compiler version: 4.2.6 */
/* Target operating system: Windows NT 3.5 or later/Windows 95 */
/* Target machine type: Intel x86 */
/* C compiler options required: -Zp8 (Microsoft) */
/* ASN.1 compiler options and file names specified:
 * -listingfile xasn.lst -noshortennames -1990 -noconstraints
 * ..\..\..\tools\ossasn1\ASN1DFLT.ZP8 xasn.asn
 */

#pragma warning(disable:4115) // 'ossGlobal' : named type definition in parentheses
#pragma warning(disable:4121) // 'tagPDA' : alignment of a member was sensitive to packing

#include   <stddef.h>
#include   "etype.h"
#include   "xasn.h"

#pragma warning(default:4115)
#pragma warning(default:4121)

void DLL_ENTRY_FDEF _ossinit_xasn(struct ossGlobal *world) {
    ossLinkBer(world);
}

static unsigned short _pduarray[] = {
    4, 7, 8, 9
};

static struct etype _etypearray[] = {
    {16, 0, 0, NULL, 4, 4, 4, 4, 56, 0, 26, 0},
    {-1, 2, 0, NULL, 8, 0, 4, 4, 10, 0, 3, 0},
    {-1, 4, 30, NULL, 8, 0, 4, 4, 8, 0, 53, 0},
    {16, 0, 0, NULL, 4, 4, 4, 4, 24, 0, 26, 0},
    {-1, 6, 0, NULL, 8, 68, 4, 4, 8, 3, 19, 0},
    {-1, 8, 0, NULL, 1, 0, 0, 0, 8, 0, 8, 0},
    {-1, 10, 0, NULL, 4, 0, 4, 0, 8, 0, 0, 0},
    {-1, 12, 14, NULL, 8, 3, 0, 0, 8, 0, 12, 0},
    {-1, 26, 28, NULL, 20, 3, 0, 0, 8, 3, 12, 0},
    {-1, 40, 42, NULL, 16, 2, 0, 0, 8, 6, 12, 0}
};

static struct efield _efieldarray[] = {
    {0, 5, -1, 0, 0},
    {1, 5, -1, 0, 0},
    {4, 6, -1, 0, 0},
    {0, 6, -1, 0, 0},
    {4, 2, -1, 0, 0},
    {12, 1, -1, 0, 0},
    {0, 2, -1, 0, 0},
    {8, 2, -1, 0, 0}
};

static Etag _tagarray[] = {
    1, 0x0006, 1, 0x0003, 1, 0x001e, 1, 0x0010, 1, 0x0001,
    1, 0x0002, 1, 0x0010, 17, 20, 23, 1, 0x0001, 1,
    1, 0x0001, 2, 1, 0x0002, 3, 1, 0x0010, 31, 34,
    37, 1, 0x0002, 1, 1, 0x001e, 2, 1, 0x0003, 3,
    1, 0x0010, 44, 47, 1, 0x001e, 1, 1, 0x001e, 2
};

static struct eheader _head = {_ossinit_xasn, -1, 15, 772, 4, 10,
    _pduarray, _etypearray, _efieldarray, NULL, _tagarray,
    NULL, NULL, NULL, 0};

#ifdef _OSSGETHEADER
void *DLL_ENTRY_FDEF ossGetHeader()
{
    return &_head;
}
#endif /* _OSSGETHEADER */

void *xasn = &_head;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xenroll\xasn.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       xasn.h
//
//--------------------------------------------------------------------------

/************************************************************************/
/* Copyright (C) 1998 Open Systems Solutions, Inc.  All rights reserved.*/
/************************************************************************/
/* Generated for: Microsoft Corporation */
/* Abstract syntax: xasn */
/* Created: Tue Mar 17 17:07:17 1998 */
/* ASN.1 compiler version: 4.2.6 */
/* Target operating system: Windows NT 3.5 or later/Windows 95 */
/* Target machine type: Intel x86 */
/* C compiler options required: -Zp8 (Microsoft) */
/* ASN.1 compiler options and file names specified:
 * -listingfile xasn.lst -noshortennames -1990 -noconstraints
 * ..\..\..\tools\ossasn1\ASN1DFLT.ZP8 xasn.asn
 */

#ifndef OSS_xasn
#define OSS_xasn

#include "asn1hdr.h"
#include "asn1code.h"

#define          EnhancedKeyUsage_PDU 1
#define          RequestFlags_PDU 2
#define          CSPProvider_PDU 3
#define          EnrollmentNameValuePair_PDU 4

typedef struct ObjectID {
    unsigned short  count;
    unsigned long   value[16];
} ObjectID;

typedef struct BITSTRING {
    unsigned int    length;  /* number of significant bits */
    unsigned char   *value;
} BITSTRING;

typedef struct BMPSTRING {
    unsigned int    length;
    unsigned short  *value;
} BMPSTRING;

typedef ObjectID        UsageIdentifier;

typedef struct EnhancedKeyUsage {
    unsigned int    count;
    UsageIdentifier *value;
} EnhancedKeyUsage;

typedef struct RequestFlags {
    ossBoolean      fWriteToCSP;
    ossBoolean      fWriteToDS;
    int             openFlags;
} RequestFlags;

typedef struct CSPProvider {
    int             keySpec;
    BMPSTRING       cspName;
    BITSTRING       signature;
} CSPProvider;

typedef struct EnrollmentNameValuePair {
    BMPSTRING       name;
    BMPSTRING       value;
} EnrollmentNameValuePair;


extern void *xasn;    /* encoder-decoder control table */
#endif /* OSS_xasn */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xenroll\xasnx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:           attrbute.cpp
//
//  Contents:   
//              Encode/Decode APIs
//
//              ASN.1 implementation uses the OSS compiler.
//
//  Functions:  CryptEncodeObject
//              CryptDecodeObject
//
//  History:    29-Feb-96       philh   created
//
//--------------------------------------------------------------------------
#include "stdafx.h"

#include <windows.h>
#include <wincrypt.h>
#include <malloc.h>

#include "xenroll.h"
#include "cenroll.h"

#include "ossconv.h"      
#include "ossutil.h"
#include "asn1util.h"
#include "crypttls.h"


extern "C" 
{              
#include "xasn.h"
}  


// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)


HCRYPTOSSGLOBAL hX509OssGlobal;


//+-------------------------------------------------------------------------
//  Function:  GetPog
//
//  Synopsis:  Initialize thread local storage for the asn libs
//
//  Returns:   pointer to an initialized OssGlobal data structure
//--------------------------------------------------------------------------
static inline POssGlobal GetPog(void)
{
    return I_CryptGetOssGlobal(hX509OssGlobal);
}


//+-------------------------------------------------------------------------
//  Cert allocation and free functions
//--------------------------------------------------------------------------
static void *CertAlloc(
    IN size_t cbBytes
    )
{
    void *pv;
    pv = malloc(cbBytes);
    if (pv == NULL)
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}
static void CertFree(
    IN void *pv
    )
{
    free(pv);
}

//+-------------------------------------------------------------------------
//  Encode an OSS formatted info structure
//
//  Called by the OssX509*Encode() functions.
//--------------------------------------------------------------------------
static BOOL OssInfoEncode(
        IN int pdunum,
        IN void *pOssInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return OssUtilEncodeInfo(
        GetPog(),
        pdunum,
        pOssInfo,
        pbEncoded,
        pcbEncoded);
}


//+-------------------------------------------------------------------------
//  Decode into an allocated, OSS formatted info structure
//
//  Called by the OssX509*Decode() functions.
//--------------------------------------------------------------------------
static BOOL OssInfoDecodeAndAlloc(
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppOssInfo
        )
{
    return OssUtilDecodeAndAllocInfo(
        GetPog(),
        pdunum,
        pbEncoded,
        cbEncoded,
        ppOssInfo);
}

//+-------------------------------------------------------------------------
//  Free an allocated, OSS formatted info structure
//
//  Called by the OssX509*Decode() functions.
//--------------------------------------------------------------------------
static void OssInfoFree(
        IN int pdunum,
        IN void *pOssInfo
        )
{
    if (pOssInfo) {
        DWORD dwErr = GetLastError();

        // TlsGetValue globbers LastError
        OssUtilFreeInfo(GetPog(), pdunum, pOssInfo);

        SetLastError(dwErr);
    }
}

//+-------------------------------------------------------------------------
//  OSS X509 v3 ASN.1 Set / Get functions
//
//  Called by the OSS X509 encode/decode functions.
//
//  Assumption: all types are UNBOUNDED.
//
//  The Get functions decrement *plRemainExtra and advance
//  *ppbExtra. When *plRemainExtra becomes negative, the functions continue
//  with the length calculation but stop doing any copies.
//  The functions don't return an error for a negative *plRemainExtra.
//--------------------------------------------------------------------------


//+-------------------------------------------------------------------------
//  Set/Get Object Identifier string
//--------------------------------------------------------------------------
static BOOL OssX509SetObjId(
        IN LPSTR pszObjId,
        OUT ObjectID *pOss
        )
{
    pOss->count = sizeof(pOss->value) / sizeof(pOss->value[0]);
    if (OssConvToObjectIdentifier(pszObjId, &pOss->count, pOss->value))
        return TRUE;
    else {
        SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
        return FALSE;
    }
}

static void OssX509GetObjId(
        IN ObjectID *pOss,
        IN DWORD /*dwFlags*/,
        OUT LPSTR *ppszObjId,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    DWORD cbObjId;

    cbObjId = lRemainExtra > 0 ? lRemainExtra : 0;
    OssConvFromObjectIdentifier(
        pOss->count,
        pOss->value,
        (LPSTR) pbExtra,
        &cbObjId
        );

    lAlignExtra = INFO_LEN_ALIGN(cbObjId);
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if(cbObjId) {
            *ppszObjId = (LPSTR) pbExtra;
        } else
            *ppszObjId = NULL;
        pbExtra += lAlignExtra;
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

static BOOL WINAPI OssX509CtlUsageEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCTL_USAGE pInfo,
        OUT BYTE *pbEncoded,
	    IN OUT DWORD *pcbEncoded
	);

static BOOL WINAPI OssX509CtlUsageDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCTL_USAGE pInfo,
        IN OUT DWORD *pcbInfo
	);

static BOOL WINAPI OssRequestInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT RequestFlags * pInfo,
        IN OUT DWORD *pcbInfo
        );

static BOOL WINAPI OssRequestInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
	    IN RequestFlags *  pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
        
static BOOL WINAPI OssCSPProviderEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
	    IN PCRYPT_CSP_PROVIDER pCSPProvider,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );

static BOOL WINAPI OssNameValueEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_ENROLLMENT_NAME_VALUE_PAIR pNameValue,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );

static const CRYPT_OID_FUNC_ENTRY X509EncodeFuncTable[] = {
    X509_ENHANCED_KEY_USAGE, OssX509CtlUsageEncode,
    XENROLL_REQUEST_INFO,    OssRequestInfoEncode,
    szOID_ENROLLMENT_CSP_PROVIDER,  OssCSPProviderEncode,
    szOID_ENROLLMENT_NAME_VALUE_PAIR, OssNameValueEncode,
};

#define X509_ENCODE_FUNC_COUNT (sizeof(X509EncodeFuncTable) / \
                                    sizeof(X509EncodeFuncTable[0]))

static const CRYPT_OID_FUNC_ENTRY X509DecodeFuncTable[] = {
    X509_ENHANCED_KEY_USAGE, OssX509CtlUsageDecode,
    XENROLL_REQUEST_INFO,    OssRequestInfoDecode
};

#define X509_DECODE_FUNC_COUNT (sizeof(X509DecodeFuncTable) / \
                                    sizeof(X509DecodeFuncTable[0]))

extern BOOL OssLoad();
extern void OssUnload();

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL AsnInit(
        HMODULE hInst)
{
	if (0 == (hX509OssGlobal = I_CryptInstallOssGlobal(xasn, 0, NULL)))
            goto Error;

    if (!OssLoad())
        goto Error;

        if (!CryptInstallOIDFunctionAddress(
                hInst,
                X509_ASN_ENCODING,
                CRYPT_OID_ENCODE_OBJECT_FUNC,
                X509_ENCODE_FUNC_COUNT,
                X509EncodeFuncTable,
                0))                         // dwFlags
            goto Error;
        if (!CryptInstallOIDFunctionAddress(
                hInst,
                X509_ASN_ENCODING,
                CRYPT_OID_DECODE_OBJECT_FUNC,
                X509_DECODE_FUNC_COUNT,
                X509DecodeFuncTable,
                0))                         // dwFlags
            goto Error;


    return TRUE;

Error:
    return FALSE;
}

typedef BOOL (WINAPI *PFN_CRYPT_UNINSTALL_OSS_GLOBAL)(
    IN HCRYPTOSSGLOBAL hOssGlobal
    );

void AsnTerm()
{
    HMODULE hDll = NULL;

    OssUnload();

    hDll = GetModuleHandleA("crypt32.dll"); 
    if (NULL != hDll) {
        PFN_CRYPT_UNINSTALL_OSS_GLOBAL pfnCryptUninstallOssGlobal;
        pfnCryptUninstallOssGlobal = (PFN_CRYPT_UNINSTALL_OSS_GLOBAL) GetProcAddress(hDll, "I_CryptUninstallOssGlobal"); 
	if (NULL != pfnCryptUninstallOssGlobal) { 
	    pfnCryptUninstallOssGlobal(hX509OssGlobal);
	}
    }
}

//+-------------------------------------------------------------------------
//  OSS X509 v3 ASN.1 Set / Get functions
//
//  Called by the OSS X509 encode/decode functions.
//
//  Assumption: all types are UNBOUNDED.
//
//  The Get functions decrement *plRemainExtra and advance
//  *ppbExtra. When *plRemainExtra becomes negative, the functions continue
//  with the length calculation but stop doing any copies.
//  The functions don't return an error for a negative *plRemainExtra.
//--------------------------------------------------------------------------


//+-------------------------------------------------------------------------
//  Set/Free/Get CTL Usage object identifiers
//--------------------------------------------------------------------------
static BOOL OssX509SetCtlUsage(
        IN PCTL_USAGE pUsage,
        OUT EnhancedKeyUsage *pOss
        )
{
    DWORD cId;
    LPSTR *ppszId;
    UsageIdentifier *pOssId;

    pOss->count = 0;
    pOss->value = NULL;
    cId = pUsage->cUsageIdentifier;
    if (0 == cId)
        return TRUE;

    pOssId = (UsageIdentifier *) CertAlloc(cId * sizeof(UsageIdentifier));
    if (pOssId == NULL)
        return FALSE;

    pOss->count = cId;
    pOss->value = pOssId;
    ppszId = pUsage->rgpszUsageIdentifier;
    for ( ; cId > 0; cId--, ppszId++, pOssId++) {
        if (!OssX509SetObjId(*ppszId, pOssId))
            return FALSE;
    }

    return TRUE;
}

static void OssX509FreeCtlUsage(
        IN EnhancedKeyUsage *pOss)
{
    if (pOss->value) {
        CertFree(pOss->value);
        pOss->value = NULL;
    }
}

static void OssX509GetCtlUsage(
        IN EnhancedKeyUsage *pOss,
        IN DWORD dwFlags,
        OUT PCTL_USAGE pUsage,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cId;
    UsageIdentifier *pOssId;
    LPSTR *ppszId;

    cId = pOss->count;
    lAlignExtra = INFO_LEN_ALIGN(cId * sizeof(LPSTR));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        pUsage->cUsageIdentifier = cId;
        ppszId = (LPSTR *) pbExtra;
        pUsage->rgpszUsageIdentifier = ppszId;
        pbExtra += lAlignExtra;
    } else
        ppszId = NULL;

    pOssId = pOss->value;
    for ( ; cId > 0; cId--, pOssId++, ppszId++)
        OssX509GetObjId(pOssId, dwFlags, ppszId, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  CTL Usage (Enhanced Key Usage) Encode (OSS X509)
//--------------------------------------------------------------------------
static BOOL WINAPI OssX509CtlUsageEncode(
        IN DWORD /*dwCertEncodingType*/,
        IN LPCSTR /*lpszStructType*/,
        IN PCTL_USAGE pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    EnhancedKeyUsage OssInfo;

    if (!OssX509SetCtlUsage(pInfo, &OssInfo)) {
        *pcbEncoded = 0;
        fResult = FALSE;
    } else
        fResult = OssInfoEncode(
            EnhancedKeyUsage_PDU,
            &OssInfo,
            pbEncoded,
            pcbEncoded
            );
    OssX509FreeCtlUsage(&OssInfo);
    return fResult;
}

//+-------------------------------------------------------------------------
//  CTL Usage (Enhanced Key Usage) Decode (OSS X509)
//--------------------------------------------------------------------------
static BOOL WINAPI OssX509CtlUsageDecode(
        IN DWORD /*dwCertEncodingType*/,
        IN LPCSTR /*lpszStructType*/,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCTL_USAGE pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    BOOL fResult;
    EnhancedKeyUsage *pOssInfo = NULL;
    BYTE *pbExtra;
    LONG lRemainExtra;

    if (pInfo == NULL)
        *pcbInfo = 0;

    if (!OssInfoDecodeAndAlloc(
            EnhancedKeyUsage_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &pOssInfo))
        goto ErrorReturn;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbInfo - sizeof(CTL_USAGE);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CTL_USAGE);

    OssX509GetCtlUsage(pOssInfo, dwFlags, pInfo, &pbExtra, &lRemainExtra);

    if (lRemainExtra >= 0)
        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    else {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (pInfo) goto LengthError;
    }

    fResult = TRUE;
    goto CommonReturn;

LengthError:
    SetLastError((DWORD) ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;
ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;
CommonReturn:
    OssInfoFree(EnhancedKeyUsage_PDU, pOssInfo);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Request Info Encode
//--------------------------------------------------------------------------
static BOOL WINAPI OssRequestInfoEncode(
        IN DWORD /*dwCertEncodingType*/,
        IN LPCSTR /*lpszStructType*/,
	    IN RequestFlags *  pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;

    fResult = OssInfoEncode(
	        RequestFlags_PDU,
	        pInfo,
            pbEncoded,
            pcbEncoded
            );
            
    return fResult;
}



//+-------------------------------------------------------------------------
//  Request Info Decode
//--------------------------------------------------------------------------
static BOOL WINAPI OssRequestInfoDecode(
        IN DWORD /*dwCertEncodingType*/,
        IN LPCSTR /*lpszStructType*/,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD /*dwFlags*/,
	    OUT RequestFlags * pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    BOOL fResult;
    RequestFlags *  pOss = NULL;

    if (NULL == pInfo || NULL == pcbInfo)
        goto ParamError;

    if(*pcbInfo < sizeof(RequestFlags))
	    goto LengthError;

    else if (!OssInfoDecodeAndAlloc(
	    RequestFlags_PDU,
        pbEncoded,
        cbEncoded,
	    (void **) &pOss) || NULL == pOss)
        goto ErrorReturn;

    memcpy(pInfo, pOss, sizeof(RequestFlags));
    fResult = TRUE;
    goto CommonReturn;

ParamError:
    SetLastError((DWORD)ERROR_INVALID_PARAMETER);
    fResult = FALSE;
    goto CommonReturn;
LengthError:
    SetLastError((DWORD) ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;
ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;
CommonReturn:
    if (NULL != pOss)
    {
        OssInfoFree(RequestFlags_PDU, pOss);
    }
    return fResult;
}

static BOOL WINAPI OssCSPProviderEncode(
        IN DWORD /*dwCertEncodingType*/,
        IN LPCSTR /*lpszStructType*/,
	    IN PCRYPT_CSP_PROVIDER pCSPProvider,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CSPProvider CspProvider;

    CspProvider.keySpec = (int) pCSPProvider->dwKeySpec;
    CspProvider.cspName.length = (DWORD)wcslen(pCSPProvider->pwszProviderName);
    CspProvider.cspName.value  = pCSPProvider->pwszProviderName;

    OssUtilSetBitString(&pCSPProvider->Signature, &CspProvider.signature.length, &CspProvider.signature.value);

    fResult = OssInfoEncode(
	        CSPProvider_PDU,
	        &CspProvider,
            pbEncoded,
            pcbEncoded
            );
 
    return fResult;
}

static BOOL WINAPI OssNameValueEncode(
        IN DWORD /*dwCertEncodingType*/,
        IN LPCSTR /*lpszStructType*/,
        IN PCRYPT_ENROLLMENT_NAME_VALUE_PAIR pNameValue,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    EnrollmentNameValuePair NameValue;

    NameValue.name.length = (DWORD)wcslen(pNameValue->pwszName);
    NameValue.name.value  = pNameValue->pwszName;
    
    NameValue.value.length = (DWORD)wcslen(pNameValue->pwszValue);
    NameValue.value.value  = pNameValue->pwszValue;

    fResult = OssInfoEncode(
	        EnrollmentNameValuePair_PDU,
	        &NameValue,
            pbEncoded,
            pcbEncoded
            );
 
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xenroll\xenroll.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       xenroll.cpp
//
//--------------------------------------------------------------------------

#if _MSC_VER < 1200
#pragma comment(linker,"/merge:.CRT=.data")
#endif

// xenroll.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f xenrollps.mk in the project directory.


#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "xenroll.h"
#include "CEnroll.h"
#include <pvk.h>

extern BOOL MSAsnInit(HMODULE hInst);
extern void MSAsnTerm();
extern BOOL AsnInit(HMODULE hInst);
extern void AsnTerm();
extern BOOL WINAPI I_CryptOIDInfoDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved);

CComModule _Module;
HINSTANCE hInstanceXEnroll = NULL;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CEnroll2, CCEnroll)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern BOOL WINAPI UnicodeDllMain(HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
        if (!MSAsnInit(hInstance))
            AsnInit(hInstance);
		hInstanceXEnroll = hInstance;
	}
	else if (dwReason == DLL_PROCESS_DETACH)
    {
        MSAsnTerm();
        AsnTerm();
		_Module.Term();
    }

    return( 
	    I_CryptOIDInfoDllMain(hInstance, dwReason, lpReserved)  &&
	    PvkDllMain(hInstance, dwReason, lpReserved)             &&
	    UnicodeDllMain(hInstance, dwReason, lpReserved)         &&
	    InitIE302UpdThunks(hInstance, dwReason, lpReserved));    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
   HRESULT hRes;
   
   // registers object, typelib and all interfaces in typelib
   hRes = _Module.RegisterServer(TRUE);
   if (SUCCEEDED(hRes)) { 
       // set up emulation for the old xenroll interface (allows legacy callers to call us)
       hRes = CoTreatAsClass(CLSID_CEnroll, CLSID_CEnroll2); 
   }

    return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT  hr = S_OK;
    
    CoTreatAsClass(CLSID_CEnroll, CLSID_NULL); // remove emulation
    _Module.UnregisterServer();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xenroll\xmsasn.h ===
/* Copyright (C) Microsoft Corporation, 1996-1999. All rights reserved. */
/* ASN.1 definitions for X509 v3 certificates */

#ifndef _XMSASN_Module_H_
#define _XMSASN_Module_H_

#include "msber.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef ASN1bitstring_t BITSTRING;

typedef ASN1char16string_t BMPSTRING;

typedef ASN1objectidentifier2_t ObjectID;

typedef ObjectID UsageIdentifier;

typedef ASN1wstring_t UTF8STRING;

typedef ASN1octetstring_t OCTETSTRING;

typedef ASN1open_t NOCOPYANY;

typedef ASN1uint32_t BodyPartID;

typedef struct EnhancedKeyUsage {
    ASN1uint32_t count;
    UsageIdentifier *value;
} EnhancedKeyUsage;
#define EnhancedKeyUsage_PDU 0
#define SIZE_XMSASN_Module_PDU_0 sizeof(EnhancedKeyUsage)

typedef struct RequestFlags {
    ASN1bool_t fWriteToCSP;
    ASN1bool_t fWriteToDS;
    ASN1int32_t openFlags;
} RequestFlags;
#define RequestFlags_PDU 1
#define SIZE_XMSASN_Module_PDU_1 sizeof(RequestFlags)

typedef struct CSPProvider {
    ASN1int32_t keySpec;
    BMPSTRING cspName;
    BITSTRING signature;
} CSPProvider;
#define CSPProvider_PDU 2
#define SIZE_XMSASN_Module_PDU_2 sizeof(CSPProvider)

typedef struct EnrollmentNameValuePair {
    BMPSTRING name;
    BMPSTRING value;
} EnrollmentNameValuePair;
#define EnrollmentNameValuePair_PDU 3
#define SIZE_XMSASN_Module_PDU_3 sizeof(EnrollmentNameValuePair)

typedef struct Extensions {
    ASN1uint32_t count;
    struct Extension *value;
} Extensions;

typedef struct Extension {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ObjectID extnId;
#   define critical_present 0x80
    ASN1bool_t critical;
    OCTETSTRING extnValue;
} Extension;

typedef struct AttributeSetValue {
    ASN1uint32_t count;
    NOCOPYANY *value;
} AttributeSetValue;

typedef struct Attributes {
    ASN1uint32_t count;
    struct Attribute *value;
} Attributes;

typedef struct ControlSequence {
    ASN1uint32_t count;
    struct TaggedAttribute *value;
} ControlSequence;

typedef struct ReqSequence {
    ASN1uint32_t count;
    struct TaggedRequest *value;
} ReqSequence;

typedef struct CmsSequence {
    ASN1uint32_t count;
    struct TaggedContentInfo *value;
} CmsSequence;

typedef struct OtherMsgSequence {
    ASN1uint32_t count;
    struct TaggedOtherMsg *value;
} OtherMsgSequence;

typedef struct BodyPartIDSequence {
    ASN1uint32_t count;
    BodyPartID *value;
} BodyPartIDSequence;

typedef struct TaggedAttribute {
    BodyPartID bodyPartID;
    ObjectID type;
    AttributeSetValue values;
} TaggedAttribute;

typedef struct TaggedCertificationRequest {
    BodyPartID bodyPartID;
    NOCOPYANY certificationRequest;
} TaggedCertificationRequest;

typedef struct TaggedContentInfo {
    BodyPartID bodyPartID;
    NOCOPYANY contentInfo;
} TaggedContentInfo;

typedef struct TaggedOtherMsg {
    BodyPartID bodyPartID;
    ObjectID otherMsgType;
    NOCOPYANY otherMsgValue;
} TaggedOtherMsg;

typedef struct PendInfo {
    OCTETSTRING pendToken;
    ASN1generalizedtime_t pendTime;
} PendInfo;

typedef struct CmcAddExtensions {
    BodyPartID pkiDataReference;
    BodyPartIDSequence certReferences;
    Extensions extensions;
} CmcAddExtensions;
#define CmcAddExtensions_PDU 4
#define SIZE_XMSASN_Module_PDU_4 sizeof(CmcAddExtensions)

typedef struct CmcAddAttributes {
    BodyPartID pkiDataReference;
    BodyPartIDSequence certReferences;
    Attributes attributes;
} CmcAddAttributes;
#define CmcAddAttributes_PDU 5
#define SIZE_XMSASN_Module_PDU_5 sizeof(CmcAddAttributes)

typedef struct CmcStatusInfo_otherInfo {
    ASN1choice_t choice;
    union {
#	define failInfo_chosen 1
	ASN1uint32_t failInfo;
#	define pendInfo_chosen 2
	PendInfo pendInfo;
    } u;
} CmcStatusInfo_otherInfo;

typedef struct Attribute {
    ObjectID type;
    AttributeSetValue values;
} Attribute;

typedef struct CmcData {
    ControlSequence controlSequence;
    ReqSequence reqSequence;
    CmsSequence cmsSequence;
    OtherMsgSequence otherMsgSequence;
} CmcData;
#define CmcData_PDU 6
#define SIZE_XMSASN_Module_PDU_6 sizeof(CmcData)

typedef struct CmcResponseBody {
    ControlSequence controlSequence;
    CmsSequence cmsSequence;
    OtherMsgSequence otherMsgSequence;
} CmcResponseBody;
#define CmcResponseBody_PDU 7
#define SIZE_XMSASN_Module_PDU_7 sizeof(CmcResponseBody)

typedef struct TaggedRequest {
    ASN1choice_t choice;
    union {
#	define tcr_chosen 1
	TaggedCertificationRequest tcr;
    } u;
} TaggedRequest;

typedef struct CmcStatusInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint32_t cmcStatus;
    BodyPartIDSequence bodyList;
#   define statusString_present 0x80
    UTF8STRING statusString;
#   define otherInfo_present 0x40
    CmcStatusInfo_otherInfo otherInfo;
} CmcStatusInfo;
#define CmcStatusInfo_PDU 8
#define SIZE_XMSASN_Module_PDU_8 sizeof(CmcStatusInfo)

extern ASN1bool_t Extension_critical_default;

extern ASN1module_t XMSASN_Module;
extern void ASN1CALL XMSASN_Module_Startup(void);
extern void ASN1CALL XMSASN_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _XMSASN_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certexts\certextp.h ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    certextp.h

Abstract:

    Common header file for NTSDEXTS component source files.
    Modified version of ntsdextp.h

Author:

    Steve Wood (stevewo) 21-Feb-1995 (original ntsdextp.h)
    Phil Hallin (philh)  08-Jun-1998 (modified for certextp.h)

Revision History:

--*/

#include <windows.h>
//#include <ntsdexts.h>

#define NOEXTAPI
#include <wdbgexts.h>
#undef DECLARE_API

#define move(dst, src)\
__try {\
    ReadMemory((LPVOID) (src), &(dst), sizeof(dst), NULL);\
} __except (EXCEPTION_EXECUTE_HANDLER) {\
    return;\
}
#define moveBlock(dst, src, size)\
__try {\
    ReadMemory((LPVOID) (src), &(dst), (size), NULL);\
} __except (EXCEPTION_EXECUTE_HANDLER) {\
    return;\
}


#ifdef __cplusplus
#define CPPMOD extern "C"
#else
#define CPPMOD
#endif

#define DECLARE_API(s)                          \
    CPPMOD VOID                                 \
    s(                                          \
        HANDLE hCurrentProcess,                 \
        HANDLE hCurrentThread,                  \
        DWORD dwCurrentPc,                      \
        PWINDBG_EXTENSION_APIS lpExtensionApis,   \
        LPSTR lpArgumentString                  \
     )

#define INIT_API() {                            \
    ExtensionApis = *lpExtensionApis;           \
    ExtensionCurrentProcess = hCurrentProcess;  \
    }

#define dprintf                 (ExtensionApis.lpOutputRoutine)
#define GetExpression           (ExtensionApis.lpGetExpressionRoutine)
#define GetSymbol               (ExtensionApis.lpGetSymbolRoutine)
#define Disassm                 (ExtensionApis.lpDisasmRoutine)
#define CheckControlC           (ExtensionApis.lpCheckControlCRoutine)
//#define ReadMemory(a,b,c,d)     ReadProcessMemory( ExtensionCurrentProcess, (LPCVOID)(a), (b), (c), (d) )
#define ReadMemory(a,b,c,d) \
    ((ExtensionApis.nSize == sizeof(WINDBG_OLD_EXTENSION_APIS)) ? \
    ReadProcessMemory( ExtensionCurrentProcess, (LPCVOID)(a), (b), (c), (d) ) \
  : ExtensionApis.lpReadProcessMemoryRoutine( (ULONG)(ULONG_PTR)(a), (b), (c), (d) ))

//#define WriteMemory(a,b,c,d)    WriteProcessMemory( ExtensionCurrentProcess, (LPVOID)(a), (LPVOID)(b), (c), (d) )
#define WriteMemory(a,b,c,d) \
    ((ExtensionApis.nSize == sizeof(WINDBG_OLD_EXTENSION_APIS)) ? \
    WriteProcessMemory( ExtensionCurrentProcess, (LPVOID)(a), (LPVOID)(b), (c), (d) ) \
  : ExtensionApis.lpWriteProcessMemoryRoutine( (ULONG)(a), (LPVOID)(b), (c), (d) ))

extern WINDBG_EXTENSION_APIS ExtensionApis;
extern HANDLE ExtensionCurrentProcess;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xenroll\xmsasn.c ===
/* Copyright (C) Microsoft Corporation, 1996-1999. All rights reserved. */
/* ASN.1 definitions for X509 v3 certificates */

//
// ASN1C needs to be defined so that the compiler does not pickup the ASN1 routines from
// the import table
//
#ifdef _X86_
#define ASN1C
#endif

#pragma warning(disable:4201) // nonstandard extension used : nameless struct/union

#include <windows.h>
#include "xmsasn.h"

ASN1module_t XMSASN_Module = NULL;

static int ASN1CALL ASN1Enc_EnhancedKeyUsage(ASN1encoding_t enc, ASN1uint32_t tag, EnhancedKeyUsage *val);
static int ASN1CALL ASN1Enc_RequestFlags(ASN1encoding_t enc, ASN1uint32_t tag, RequestFlags *val);
static int ASN1CALL ASN1Enc_CSPProvider(ASN1encoding_t enc, ASN1uint32_t tag, CSPProvider *val);
static int ASN1CALL ASN1Enc_EnrollmentNameValuePair(ASN1encoding_t enc, ASN1uint32_t tag, EnrollmentNameValuePair *val);
static int ASN1CALL ASN1Enc_Extensions(ASN1encoding_t enc, ASN1uint32_t tag, Extensions *val);
static int ASN1CALL ASN1Enc_Extension(ASN1encoding_t enc, ASN1uint32_t tag, Extension *val);
static int ASN1CALL ASN1Enc_AttributeSetValue(ASN1encoding_t enc, ASN1uint32_t tag, AttributeSetValue *val);
static int ASN1CALL ASN1Enc_Attributes(ASN1encoding_t enc, ASN1uint32_t tag, Attributes *val);
static int ASN1CALL ASN1Enc_ControlSequence(ASN1encoding_t enc, ASN1uint32_t tag, ControlSequence *val);
static int ASN1CALL ASN1Enc_ReqSequence(ASN1encoding_t enc, ASN1uint32_t tag, ReqSequence *val);
static int ASN1CALL ASN1Enc_CmsSequence(ASN1encoding_t enc, ASN1uint32_t tag, CmsSequence *val);
static int ASN1CALL ASN1Enc_OtherMsgSequence(ASN1encoding_t enc, ASN1uint32_t tag, OtherMsgSequence *val);
static int ASN1CALL ASN1Enc_BodyPartIDSequence(ASN1encoding_t enc, ASN1uint32_t tag, BodyPartIDSequence *val);
static int ASN1CALL ASN1Enc_TaggedAttribute(ASN1encoding_t enc, ASN1uint32_t tag, TaggedAttribute *val);
static int ASN1CALL ASN1Enc_TaggedCertificationRequest(ASN1encoding_t enc, ASN1uint32_t tag, TaggedCertificationRequest *val);
static int ASN1CALL ASN1Enc_TaggedContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, TaggedContentInfo *val);
static int ASN1CALL ASN1Enc_TaggedOtherMsg(ASN1encoding_t enc, ASN1uint32_t tag, TaggedOtherMsg *val);
static int ASN1CALL ASN1Enc_PendInfo(ASN1encoding_t enc, ASN1uint32_t tag, PendInfo *val);
static int ASN1CALL ASN1Enc_CmcAddExtensions(ASN1encoding_t enc, ASN1uint32_t tag, CmcAddExtensions *val);
static int ASN1CALL ASN1Enc_CmcAddAttributes(ASN1encoding_t enc, ASN1uint32_t tag, CmcAddAttributes *val);
static int ASN1CALL ASN1Enc_CmcStatusInfo_otherInfo(ASN1encoding_t enc, ASN1uint32_t tag, CmcStatusInfo_otherInfo *val);
static int ASN1CALL ASN1Enc_Attribute(ASN1encoding_t enc, ASN1uint32_t tag, Attribute *val);
static int ASN1CALL ASN1Enc_CmcData(ASN1encoding_t enc, ASN1uint32_t tag, CmcData *val);
static int ASN1CALL ASN1Enc_CmcResponseBody(ASN1encoding_t enc, ASN1uint32_t tag, CmcResponseBody *val);
static int ASN1CALL ASN1Enc_TaggedRequest(ASN1encoding_t enc, ASN1uint32_t tag, TaggedRequest *val);
static int ASN1CALL ASN1Enc_CmcStatusInfo(ASN1encoding_t enc, ASN1uint32_t tag, CmcStatusInfo *val);
static int ASN1CALL ASN1Dec_EnhancedKeyUsage(ASN1decoding_t dec, ASN1uint32_t tag, EnhancedKeyUsage *val);
static int ASN1CALL ASN1Dec_RequestFlags(ASN1decoding_t dec, ASN1uint32_t tag, RequestFlags *val);
static int ASN1CALL ASN1Dec_CSPProvider(ASN1decoding_t dec, ASN1uint32_t tag, CSPProvider *val);
static int ASN1CALL ASN1Dec_EnrollmentNameValuePair(ASN1decoding_t dec, ASN1uint32_t tag, EnrollmentNameValuePair *val);
static int ASN1CALL ASN1Dec_Extensions(ASN1decoding_t dec, ASN1uint32_t tag, Extensions *val);
static int ASN1CALL ASN1Dec_Extension(ASN1decoding_t dec, ASN1uint32_t tag, Extension *val);
static int ASN1CALL ASN1Dec_AttributeSetValue(ASN1decoding_t dec, ASN1uint32_t tag, AttributeSetValue *val);
static int ASN1CALL ASN1Dec_Attributes(ASN1decoding_t dec, ASN1uint32_t tag, Attributes *val);
static int ASN1CALL ASN1Dec_ControlSequence(ASN1decoding_t dec, ASN1uint32_t tag, ControlSequence *val);
static int ASN1CALL ASN1Dec_ReqSequence(ASN1decoding_t dec, ASN1uint32_t tag, ReqSequence *val);
static int ASN1CALL ASN1Dec_CmsSequence(ASN1decoding_t dec, ASN1uint32_t tag, CmsSequence *val);
static int ASN1CALL ASN1Dec_OtherMsgSequence(ASN1decoding_t dec, ASN1uint32_t tag, OtherMsgSequence *val);
static int ASN1CALL ASN1Dec_BodyPartIDSequence(ASN1decoding_t dec, ASN1uint32_t tag, BodyPartIDSequence *val);
static int ASN1CALL ASN1Dec_TaggedAttribute(ASN1decoding_t dec, ASN1uint32_t tag, TaggedAttribute *val);
static int ASN1CALL ASN1Dec_TaggedCertificationRequest(ASN1decoding_t dec, ASN1uint32_t tag, TaggedCertificationRequest *val);
static int ASN1CALL ASN1Dec_TaggedContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, TaggedContentInfo *val);
static int ASN1CALL ASN1Dec_TaggedOtherMsg(ASN1decoding_t dec, ASN1uint32_t tag, TaggedOtherMsg *val);
static int ASN1CALL ASN1Dec_PendInfo(ASN1decoding_t dec, ASN1uint32_t tag, PendInfo *val);
static int ASN1CALL ASN1Dec_CmcAddExtensions(ASN1decoding_t dec, ASN1uint32_t tag, CmcAddExtensions *val);
static int ASN1CALL ASN1Dec_CmcAddAttributes(ASN1decoding_t dec, ASN1uint32_t tag, CmcAddAttributes *val);
static int ASN1CALL ASN1Dec_CmcStatusInfo_otherInfo(ASN1decoding_t dec, ASN1uint32_t tag, CmcStatusInfo_otherInfo *val);
static int ASN1CALL ASN1Dec_Attribute(ASN1decoding_t dec, ASN1uint32_t tag, Attribute *val);
static int ASN1CALL ASN1Dec_CmcData(ASN1decoding_t dec, ASN1uint32_t tag, CmcData *val);
static int ASN1CALL ASN1Dec_CmcResponseBody(ASN1decoding_t dec, ASN1uint32_t tag, CmcResponseBody *val);
static int ASN1CALL ASN1Dec_TaggedRequest(ASN1decoding_t dec, ASN1uint32_t tag, TaggedRequest *val);
static int ASN1CALL ASN1Dec_CmcStatusInfo(ASN1decoding_t dec, ASN1uint32_t tag, CmcStatusInfo *val);
static void ASN1CALL ASN1Free_EnhancedKeyUsage(EnhancedKeyUsage *val);
static void ASN1CALL ASN1Free_CSPProvider(CSPProvider *val);
static void ASN1CALL ASN1Free_EnrollmentNameValuePair(EnrollmentNameValuePair *val);
static void ASN1CALL ASN1Free_Extensions(Extensions *val);
static void ASN1CALL ASN1Free_Extension(Extension *val);
static void ASN1CALL ASN1Free_AttributeSetValue(AttributeSetValue *val);
static void ASN1CALL ASN1Free_Attributes(Attributes *val);
static void ASN1CALL ASN1Free_ControlSequence(ControlSequence *val);
static void ASN1CALL ASN1Free_ReqSequence(ReqSequence *val);
static void ASN1CALL ASN1Free_CmsSequence(CmsSequence *val);
static void ASN1CALL ASN1Free_OtherMsgSequence(OtherMsgSequence *val);
static void ASN1CALL ASN1Free_BodyPartIDSequence(BodyPartIDSequence *val);
static void ASN1CALL ASN1Free_TaggedAttribute(TaggedAttribute *val);
static void ASN1CALL ASN1Free_TaggedCertificationRequest(TaggedCertificationRequest *val);
static void ASN1CALL ASN1Free_TaggedContentInfo(TaggedContentInfo *val);
static void ASN1CALL ASN1Free_TaggedOtherMsg(TaggedOtherMsg *val);
static void ASN1CALL ASN1Free_PendInfo(PendInfo *val);
static void ASN1CALL ASN1Free_CmcAddExtensions(CmcAddExtensions *val);
static void ASN1CALL ASN1Free_CmcAddAttributes(CmcAddAttributes *val);
static void ASN1CALL ASN1Free_CmcStatusInfo_otherInfo(CmcStatusInfo_otherInfo *val);
static void ASN1CALL ASN1Free_Attribute(Attribute *val);
static void ASN1CALL ASN1Free_CmcData(CmcData *val);
static void ASN1CALL ASN1Free_CmcResponseBody(CmcResponseBody *val);
static void ASN1CALL ASN1Free_TaggedRequest(TaggedRequest *val);
static void ASN1CALL ASN1Free_CmcStatusInfo(CmcStatusInfo *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[9] = {
    (ASN1EncFun_t) ASN1Enc_EnhancedKeyUsage,
    (ASN1EncFun_t) ASN1Enc_RequestFlags,
    (ASN1EncFun_t) ASN1Enc_CSPProvider,
    (ASN1EncFun_t) ASN1Enc_EnrollmentNameValuePair,
    (ASN1EncFun_t) ASN1Enc_CmcAddExtensions,
    (ASN1EncFun_t) ASN1Enc_CmcAddAttributes,
    (ASN1EncFun_t) ASN1Enc_CmcData,
    (ASN1EncFun_t) ASN1Enc_CmcResponseBody,
    (ASN1EncFun_t) ASN1Enc_CmcStatusInfo,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[9] = {
    (ASN1DecFun_t) ASN1Dec_EnhancedKeyUsage,
    (ASN1DecFun_t) ASN1Dec_RequestFlags,
    (ASN1DecFun_t) ASN1Dec_CSPProvider,
    (ASN1DecFun_t) ASN1Dec_EnrollmentNameValuePair,
    (ASN1DecFun_t) ASN1Dec_CmcAddExtensions,
    (ASN1DecFun_t) ASN1Dec_CmcAddAttributes,
    (ASN1DecFun_t) ASN1Dec_CmcData,
    (ASN1DecFun_t) ASN1Dec_CmcResponseBody,
    (ASN1DecFun_t) ASN1Dec_CmcStatusInfo,
};
static const ASN1FreeFun_t freefntab[9] = {
    (ASN1FreeFun_t) ASN1Free_EnhancedKeyUsage,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_CSPProvider,
    (ASN1FreeFun_t) ASN1Free_EnrollmentNameValuePair,
    (ASN1FreeFun_t) ASN1Free_CmcAddExtensions,
    (ASN1FreeFun_t) ASN1Free_CmcAddAttributes,
    (ASN1FreeFun_t) ASN1Free_CmcData,
    (ASN1FreeFun_t) ASN1Free_CmcResponseBody,
    (ASN1FreeFun_t) ASN1Free_CmcStatusInfo,
};
static const ULONG sizetab[9] = {
    SIZE_XMSASN_Module_PDU_0,
    SIZE_XMSASN_Module_PDU_1,
    SIZE_XMSASN_Module_PDU_2,
    SIZE_XMSASN_Module_PDU_3,
    SIZE_XMSASN_Module_PDU_4,
    SIZE_XMSASN_Module_PDU_5,
    SIZE_XMSASN_Module_PDU_6,
    SIZE_XMSASN_Module_PDU_7,
    SIZE_XMSASN_Module_PDU_8,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */
ASN1bool_t Extension_critical_default = 0;

void ASN1CALL XMSASN_Module_Startup(void)
{
    XMSASN_Module = ASN1_CreateModule(0x10000, ASN1_BER_RULE_DER, ASN1FLAGS_NOASSERT, 9, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x726e6578);
}

void ASN1CALL XMSASN_Module_Cleanup(void)
{
    ASN1_CloseModule(XMSASN_Module);
    XMSASN_Module = NULL;
}

static int ASN1CALL ASN1Enc_EnhancedKeyUsage(ASN1encoding_t enc, ASN1uint32_t tag, EnhancedKeyUsage *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
        return 0;
    for (i = 0; i < (val)->count; i++) {
        if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &((val)->value)[i]))
            return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
        return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EnhancedKeyUsage(ASN1decoding_t dec, ASN1uint32_t tag, EnhancedKeyUsage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
        return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
        if (!ASN1BERDecPeekTag(dd, &t))
            return 0;
        if ((val)->count >= n) {
            n = n ? (n << 1) : 16;
            (val)->value = (UsageIdentifier *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value));
            if (!(val)->value)
                return 0;
        }
        if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &((val)->value)[(val)->count]))
            return 0;
        ((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
        return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EnhancedKeyUsage(EnhancedKeyUsage *val)
{
    ASN1uint32_t i;
    if (val) {
        for (i = 1; i < (val)->count; i++) {
        }
        ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_RequestFlags(ASN1encoding_t enc, ASN1uint32_t tag, RequestFlags *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
        return 0;
    if (!ASN1BEREncBool(enc, 0x1, (val)->fWriteToCSP))
        return 0;
    if (!ASN1BEREncBool(enc, 0x1, (val)->fWriteToDS))
        return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->openFlags))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
        return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestFlags(ASN1decoding_t dec, ASN1uint32_t tag, RequestFlags *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
        return 0;
    if (!ASN1BERDecBool(dd, 0x1, &(val)->fWriteToCSP))
        return 0;
    if (!ASN1BERDecBool(dd, 0x1, &(val)->fWriteToDS))
        return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->openFlags))
        return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
        return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_CSPProvider(ASN1encoding_t enc, ASN1uint32_t tag, CSPProvider *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
        return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->keySpec))
        return 0;
    if (!ASN1DEREncChar16String(enc, 0x1e, ((val)->cspName).length, ((val)->cspName).value))
        return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->signature).length, ((val)->signature).value))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
        return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CSPProvider(ASN1decoding_t dec, ASN1uint32_t tag, CSPProvider *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
        return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->keySpec))
        return 0;
    if (!ASN1BERDecChar16String(dd, 0x1e, &(val)->cspName))
        return 0;
    if (!ASN1BERDecBitString2(dd, 0x3, &(val)->signature))
        return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
        return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CSPProvider(CSPProvider *val)
{
    if (val) {
        ASN1char16string_free(&(val)->cspName);
    }
}

static int ASN1CALL ASN1Enc_EnrollmentNameValuePair(ASN1encoding_t enc, ASN1uint32_t tag, EnrollmentNameValuePair *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
        return 0;
    if (!ASN1DEREncChar16String(enc, 0x1e, ((val)->name).length, ((val)->name).value))
        return 0;
    if (!ASN1DEREncChar16String(enc, 0x1e, ((val)->value).length, ((val)->value).value))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
        return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EnrollmentNameValuePair(ASN1decoding_t dec, ASN1uint32_t tag, EnrollmentNameValuePair *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
        return 0;
    if (!ASN1BERDecChar16String(dd, 0x1e, &(val)->name))
        return 0;
    if (!ASN1BERDecChar16String(dd, 0x1e, &(val)->value))
        return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
        return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EnrollmentNameValuePair(EnrollmentNameValuePair *val)
{
    if (val) {
        ASN1char16string_free(&(val)->name);
        ASN1char16string_free(&(val)->value);
    }
}

static int ASN1CALL ASN1Enc_Extensions(ASN1encoding_t enc, ASN1uint32_t tag, Extensions *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
        return 0;
    for (i = 0; i < (val)->count; i++) {
        if (!ASN1Enc_Extension(enc, 0, &((val)->value)[i]))
            return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
        return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Extensions(ASN1decoding_t dec, ASN1uint32_t tag, Extensions *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
        return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
        if (!ASN1BERDecPeekTag(dd, &t))
            return 0;
        if ((val)->count >= n) {
            n = n ? (n << 1) : 16;
            (val)->value = (Extension *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value));
            if (!(val)->value)
                return 0;
        }
        if (!ASN1Dec_Extension(dd, 0, &((val)->value)[(val)->count]))
            return 0;
        ((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
        return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Extensions(Extensions *val)
{
    ASN1uint32_t i;
    if (val) {
        ASN1Free_Extension(&(val)->value[0]);
        for (i = 1; i < (val)->count; i++) {
            ASN1Free_Extension(&(val)->value[i]);
        }
        ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_Extension(ASN1encoding_t enc, ASN1uint32_t tag, Extension *val)
{
    ASN1uint32_t nLenOff;
    ASN1octet_t o[1];
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
        return 0;
    CopyMemory(o, (val)->o, 1);
    if (!(val)->critical)
        o[0] &= ~0x80;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->extnId))
        return 0;
    if (o[0] & 0x80) {
        if (!ASN1BEREncBool(enc, 0x1, (val)->critical))
            return 0;
    }
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->extnValue).length, ((val)->extnValue).value))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
        return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Extension(ASN1decoding_t dec, ASN1uint32_t tag, Extension *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
        return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->extnId))
        return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x1) {
        (val)->o[0] |= 0x80;
        if (!ASN1BERDecBool(dd, 0x1, &(val)->critical))
            return 0;
    }
    if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->extnValue))
        return 0;
    if (!((val)->o[0] & 0x80))
        (val)->critical = 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
        return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Extension(Extension *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_AttributeSetValue(ASN1encoding_t enc, ASN1uint32_t tag, AttributeSetValue *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
        return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
        return 0;
    for (i = 0; i < (val)->count; i++) {
        if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
            return 0;
        if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
            return 0;
        if (!ASN1DEREncFlushBlkElement(pBlk))
            return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
        return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AttributeSetValue(ASN1decoding_t dec, ASN1uint32_t tag, AttributeSetValue *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
        return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
        if (!ASN1BERDecPeekTag(dd, &t))
            return 0;
        if ((val)->count >= n) {
            n = n ? (n << 1) : 16;
            (val)->value = (NOCOPYANY *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value));
            if (!(val)->value)
                return 0;
        }
        if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
            return 0;
        ((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
        return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AttributeSetValue(AttributeSetValue *val)
{
    ASN1uint32_t i;
    if (val) {
        for (i = 1; i < (val)->count; i++) {
        }
        ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_Attributes(ASN1encoding_t enc, ASN1uint32_t tag, Attributes *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
        return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
        return 0;
    for (i = 0; i < (val)->count; i++) {
        if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
            return 0;
        if (!ASN1Enc_Attribute(enc2, 0, &((val)->value)[i]))
            return 0;
        if (!ASN1DEREncFlushBlkElement(pBlk))
            return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
        return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Attributes(ASN1decoding_t dec, ASN1uint32_t tag, Attributes *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
        return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
        if (!ASN1BERDecPeekTag(dd, &t))
            return 0;
        if ((val)->count >= n) {
            n = n ? (n << 1) : 16;
            (val)->value = (Attribute *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value));
            if (!(val)->value)
                return 0;
        }
        if (!ASN1Dec_Attribute(dd, 0, &((val)->value)[(val)->count]))
            return 0;
        ((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
        return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Attributes(Attributes *val)
{
    ASN1uint32_t i;
    if (val) {
        ASN1Free_Attribute(&(val)->value[0]);
        for (i = 1; i < (val)->count; i++) {
            ASN1Free_Attribute(&(val)->value[i]);
        }
        ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_ControlSequence(ASN1encoding_t enc, ASN1uint32_t tag, ControlSequence *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
        return 0;
    for (i = 0; i < (val)->count; i++) {
        if (!ASN1Enc_TaggedAttribute(enc, 0, &((val)->value)[i]))
            return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
        return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ControlSequence(ASN1decoding_t dec, ASN1uint32_t tag, ControlSequence *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
        return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
        if (!ASN1BERDecPeekTag(dd, &t))
            return 0;
        if ((val)->count >= n) {
            n = n ? (n << 1) : 16;
            (val)->value = (TaggedAttribute *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value));
            if (!(val)->value)
                return 0;
        }
        if (!ASN1Dec_TaggedAttribute(dd, 0, &((val)->value)[(val)->count]))
            return 0;
        ((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
        return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ControlSequence(ControlSequence *val)
{
    ASN1uint32_t i;
    if (val) {
        ASN1Free_TaggedAttribute(&(val)->value[0]);
        for (i = 1; i < (val)->count; i++) {
            ASN1Free_TaggedAttribute(&(val)->value[i]);
        }
        ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_ReqSequence(ASN1encoding_t enc, ASN1uint32_t tag, ReqSequence *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
        return 0;
    for (i = 0; i < (val)->count; i++) {
        if (!ASN1Enc_TaggedRequest(enc, 0, &((val)->value)[i]))
            return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
        return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ReqSequence(ASN1decoding_t dec, ASN1uint32_t tag, ReqSequence *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
        return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
        if (!ASN1BERDecPeekTag(dd, &t))
            return 0;
        if ((val)->count >= n) {
            n = n ? (n << 1) : 16;
            (val)->value = (TaggedRequest *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value));
            if (!(val)->value)
                return 0;
        }
        if (!ASN1Dec_TaggedRequest(dd, 0, &((val)->value)[(val)->count]))
            return 0;
        ((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
        return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ReqSequence(ReqSequence *val)
{
    ASN1uint32_t i;
    if (val) {
        ASN1Free_TaggedRequest(&(val)->value[0]);
        for (i = 1; i < (val)->count; i++) {
            ASN1Free_TaggedRequest(&(val)->value[i]);
        }
        ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_CmsSequence(ASN1encoding_t enc, ASN1uint32_t tag, CmsSequence *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
        return 0;
    for (i = 0; i < (val)->count; i++) {
        if (!ASN1Enc_TaggedContentInfo(enc, 0, &((val)->value)[i]))
            return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
        return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CmsSequence(ASN1decoding_t dec, ASN1uint32_t tag, CmsSequence *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
        return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
        if (!ASN1BERDecPeekTag(dd, &t))
            return 0;
        if ((val)->count >= n) {
            n = n ? (n << 1) : 16;
            (val)->value = (TaggedContentInfo *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value));
            if (!(val)->value)
                return 0;
        }
        if (!ASN1Dec_TaggedContentInfo(dd, 0, &((val)->value)[(val)->count]))
            return 0;
        ((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
        return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CmsSequence(CmsSequence *val)
{
    ASN1uint32_t i;
    if (val) {
        ASN1Free_TaggedContentInfo(&(val)->value[0]);
        for (i = 1; i < (val)->count; i++) {
            ASN1Free_TaggedContentInfo(&(val)->value[i]);
        }
        ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_OtherMsgSequence(ASN1encoding_t enc, ASN1uint32_t tag, OtherMsgSequence *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
        return 0;
    for (i = 0; i < (val)->count; i++) {
        if (!ASN1Enc_TaggedOtherMsg(enc, 0, &((val)->value)[i]))
            return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
        return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OtherMsgSequence(ASN1decoding_t dec, ASN1uint32_t tag, OtherMsgSequence *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
        return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
        if (!ASN1BERDecPeekTag(dd, &t))
            return 0;
        if ((val)->count >= n) {
            n = n ? (n << 1) : 16;
            (val)->value = (TaggedOtherMsg *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value));
            if (!(val)->value)
                return 0;
        }
        if (!ASN1Dec_TaggedOtherMsg(dd, 0, &((val)->value)[(val)->count]))
            return 0;
        ((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
        return 0;
    return 1;
}

static void ASN1CALL ASN1Free_OtherMsgSequence(OtherMsgSequence *val)
{
    ASN1uint32_t i;
    if (val) {
        ASN1Free_TaggedOtherMsg(&(val)->value[0]);
        for (i = 1; i < (val)->count; i++) {
            ASN1Free_TaggedOtherMsg(&(val)->value[i]);
        }
        ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_BodyPartIDSequence(ASN1encoding_t enc, ASN1uint32_t tag, BodyPartIDSequence *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
        return 0;
    for (i = 0; i < (val)->count; i++) {
        if (!ASN1BEREncU32(enc, 0x2, ((val)->value)[i]))
            return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
        return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BodyPartIDSequence(ASN1decoding_t dec, ASN1uint32_t tag, BodyPartIDSequence *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
        return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
        if (!ASN1BERDecPeekTag(dd, &t))
            return 0;
        if ((val)->count >= n) {
            n = n ? (n << 1) : 16;
            (val)->value = (BodyPartID *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value));
            if (!(val)->value)
                return 0;
        }
        if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &((val)->value)[(val)->count]))
            return 0;
        ((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
        return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BodyPartIDSequence(BodyPartIDSequence *val)
{
    if (val) {
        ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_TaggedAttribute(ASN1encoding_t enc, ASN1uint32_t tag, TaggedAttribute *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
        return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->bodyPartID))
        return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->type))
        return 0;
    if (!ASN1Enc_AttributeSetValue(enc, 0, &(val)->values))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
        return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TaggedAttribute(ASN1decoding_t dec, ASN1uint32_t tag, TaggedAttribute *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
        return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->bodyPartID))
        return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->type))
        return 0;
    if (!ASN1Dec_AttributeSetValue(dd, 0, &(val)->values))
        return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
        return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TaggedAttribute(TaggedAttribute *val)
{
    if (val) {
        ASN1Free_AttributeSetValue(&(val)->values);
    }
}

static int ASN1CALL ASN1Enc_TaggedCertificationRequest(ASN1encoding_t enc, ASN1uint32_t tag, TaggedCertificationRequest *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
        return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->bodyPartID))
        return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->certificationRequest))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
        return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TaggedCertificationRequest(ASN1decoding_t dec, ASN1uint32_t tag, TaggedCertificationRequest *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
        return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->bodyPartID))
        return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->certificationRequest))
        return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
        return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TaggedCertificationRequest(TaggedCertificationRequest *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_TaggedContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, TaggedContentInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
        return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->bodyPartID))
        return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->contentInfo))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
        return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TaggedContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, TaggedContentInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
        return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->bodyPartID))
        return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->contentInfo))
        return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
        return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TaggedContentInfo(TaggedContentInfo *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_TaggedOtherMsg(ASN1encoding_t enc, ASN1uint32_t tag, TaggedOtherMsg *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
        return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->bodyPartID))
        return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->otherMsgType))
        return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->otherMsgValue))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
        return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TaggedOtherMsg(ASN1decoding_t dec, ASN1uint32_t tag, TaggedOtherMsg *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
        return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->bodyPartID))
        return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->otherMsgType))
        return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->otherMsgValue))
        return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
        return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TaggedOtherMsg(TaggedOtherMsg *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_PendInfo(ASN1encoding_t enc, ASN1uint32_t tag, PendInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
        return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->pendToken).length, ((val)->pendToken).value))
        return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->pendTime))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
        return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PendInfo(ASN1decoding_t dec, ASN1uint32_t tag, PendInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
        return 0;
    if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->pendToken))
        return 0;
    if (!ASN1BERDecGeneralizedTime(dd, 0x18, &(val)->pendTime))
        return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
        return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PendInfo(PendInfo *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_CmcAddExtensions(ASN1encoding_t enc, ASN1uint32_t tag, CmcAddExtensions *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
        return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->pkiDataReference))
        return 0;
    if (!ASN1Enc_BodyPartIDSequence(enc, 0, &(val)->certReferences))
        return 0;
    if (!ASN1Enc_Extensions(enc, 0, &(val)->extensions))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
        return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CmcAddExtensions(ASN1decoding_t dec, ASN1uint32_t tag, CmcAddExtensions *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
        return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->pkiDataReference))
        return 0;
    if (!ASN1Dec_BodyPartIDSequence(dd, 0, &(val)->certReferences))
        return 0;
    if (!ASN1Dec_Extensions(dd, 0, &(val)->extensions))
        return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
        return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CmcAddExtensions(CmcAddExtensions *val)
{
    if (val) {
        ASN1Free_BodyPartIDSequence(&(val)->certReferences);
        ASN1Free_Extensions(&(val)->extensions);
    }
}

static int ASN1CALL ASN1Enc_CmcAddAttributes(ASN1encoding_t enc, ASN1uint32_t tag, CmcAddAttributes *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
        return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->pkiDataReference))
        return 0;
    if (!ASN1Enc_BodyPartIDSequence(enc, 0, &(val)->certReferences))
        return 0;
    if (!ASN1Enc_Attributes(enc, 0, &(val)->attributes))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
        return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CmcAddAttributes(ASN1decoding_t dec, ASN1uint32_t tag, CmcAddAttributes *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
        return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->pkiDataReference))
        return 0;
    if (!ASN1Dec_BodyPartIDSequence(dd, 0, &(val)->certReferences))
        return 0;
    if (!ASN1Dec_Attributes(dd, 0, &(val)->attributes))
        return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
        return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CmcAddAttributes(CmcAddAttributes *val)
{
    if (val) {
        ASN1Free_BodyPartIDSequence(&(val)->certReferences);
        ASN1Free_Attributes(&(val)->attributes);
    }
}

static int ASN1CALL ASN1Enc_CmcStatusInfo_otherInfo(ASN1encoding_t enc, ASN1uint32_t tag, CmcStatusInfo_otherInfo *val)
{
    switch ((val)->choice) {
    case 1:
        if (!ASN1BEREncU32(enc, 0x2, (val)->u.failInfo))
            return 0;
        break;
    case 2:
        if (!ASN1Enc_PendInfo(enc, 0, &(val)->u.pendInfo))
            return 0;
        break;
    }
    return 1;

UNREFERENCED_PARAMETER(tag);
}

static int ASN1CALL ASN1Dec_CmcStatusInfo_otherInfo(ASN1decoding_t dec, ASN1uint32_t tag, CmcStatusInfo_otherInfo *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
        return 0;
    switch (t) {
    case 0x2:
        (val)->choice = 1;
        if (!ASN1BERDecU32Val(dec, 0x2, (ASN1uint32_t *) &(val)->u.failInfo))
            return 0;
        break;
    case 0x10:
        (val)->choice = 2;
        if (!ASN1Dec_PendInfo(dec, 0, &(val)->u.pendInfo))
            return 0;
        break;
    default:
        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
        return 0;
    }
    return 1;

UNREFERENCED_PARAMETER(tag);
}

static void ASN1CALL ASN1Free_CmcStatusInfo_otherInfo(CmcStatusInfo_otherInfo *val)
{
    if (val) {
        switch ((val)->choice) {
        case 2:
            ASN1Free_PendInfo(&(val)->u.pendInfo);
            break;
        }
    }
}

static int ASN1CALL ASN1Enc_Attribute(ASN1encoding_t enc, ASN1uint32_t tag, Attribute *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
        return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->type))
        return 0;
    if (!ASN1Enc_AttributeSetValue(enc, 0, &(val)->values))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
        return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Attribute(ASN1decoding_t dec, ASN1uint32_t tag, Attribute *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
        return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->type))
        return 0;
    if (!ASN1Dec_AttributeSetValue(dd, 0, &(val)->values))
        return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
        return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Attribute(Attribute *val)
{
    if (val) {
        ASN1Free_AttributeSetValue(&(val)->values);
    }
}

static int ASN1CALL ASN1Enc_CmcData(ASN1encoding_t enc, ASN1uint32_t tag, CmcData *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
        return 0;
    if (!ASN1Enc_ControlSequence(enc, 0, &(val)->controlSequence))
        return 0;
    if (!ASN1Enc_ReqSequence(enc, 0, &(val)->reqSequence))
        return 0;
    if (!ASN1Enc_CmsSequence(enc, 0, &(val)->cmsSequence))
        return 0;
    if (!ASN1Enc_OtherMsgSequence(enc, 0, &(val)->otherMsgSequence))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
        return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CmcData(ASN1decoding_t dec, ASN1uint32_t tag, CmcData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
        return 0;
    if (!ASN1Dec_ControlSequence(dd, 0, &(val)->controlSequence))
        return 0;
    if (!ASN1Dec_ReqSequence(dd, 0, &(val)->reqSequence))
        return 0;
    if (!ASN1Dec_CmsSequence(dd, 0, &(val)->cmsSequence))
        return 0;
    if (!ASN1Dec_OtherMsgSequence(dd, 0, &(val)->otherMsgSequence))
        return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
        return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CmcData(CmcData *val)
{
    if (val) {
        ASN1Free_ControlSequence(&(val)->controlSequence);
        ASN1Free_ReqSequence(&(val)->reqSequence);
        ASN1Free_CmsSequence(&(val)->cmsSequence);
        ASN1Free_OtherMsgSequence(&(val)->otherMsgSequence);
    }
}

static int ASN1CALL ASN1Enc_CmcResponseBody(ASN1encoding_t enc, ASN1uint32_t tag, CmcResponseBody *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
        return 0;
    if (!ASN1Enc_ControlSequence(enc, 0, &(val)->controlSequence))
        return 0;
    if (!ASN1Enc_CmsSequence(enc, 0, &(val)->cmsSequence))
        return 0;
    if (!ASN1Enc_OtherMsgSequence(enc, 0, &(val)->otherMsgSequence))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
        return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CmcResponseBody(ASN1decoding_t dec, ASN1uint32_t tag, CmcResponseBody *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
        return 0;
    if (!ASN1Dec_ControlSequence(dd, 0, &(val)->controlSequence))
        return 0;
    if (!ASN1Dec_CmsSequence(dd, 0, &(val)->cmsSequence))
        return 0;
    if (!ASN1Dec_OtherMsgSequence(dd, 0, &(val)->otherMsgSequence))
        return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
        return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CmcResponseBody(CmcResponseBody *val)
{
    if (val) {
        ASN1Free_ControlSequence(&(val)->controlSequence);
        ASN1Free_CmsSequence(&(val)->cmsSequence);
        ASN1Free_OtherMsgSequence(&(val)->otherMsgSequence);
    }
}

static int ASN1CALL ASN1Enc_TaggedRequest(ASN1encoding_t enc, ASN1uint32_t tag, TaggedRequest *val)
{
    switch ((val)->choice) {
    case 1:
        if (!ASN1Enc_TaggedCertificationRequest(enc, 0x80000000, &(val)->u.tcr))
            return 0;
        break;
    }
    return 1;

UNREFERENCED_PARAMETER(tag);
}

static int ASN1CALL ASN1Dec_TaggedRequest(ASN1decoding_t dec, ASN1uint32_t tag, TaggedRequest *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
        return 0;
    switch (t) {
    case 0x80000000:
        (val)->choice = 1;
        if (!ASN1Dec_TaggedCertificationRequest(dec, 0x80000000, &(val)->u.tcr))
            return 0;
        break;
    default:
        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
        return 0;
    }
    return 1;

UNREFERENCED_PARAMETER(tag);
}

static void ASN1CALL ASN1Free_TaggedRequest(TaggedRequest *val)
{
    if (val) {
        switch ((val)->choice) {
        case 1:
            ASN1Free_TaggedCertificationRequest(&(val)->u.tcr);
            break;
        }
    }
}

static int ASN1CALL ASN1Enc_CmcStatusInfo(ASN1encoding_t enc, ASN1uint32_t tag, CmcStatusInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
        return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->cmcStatus))
        return 0;
    if (!ASN1Enc_BodyPartIDSequence(enc, 0, &(val)->bodyList))
        return 0;
    if ((val)->o[0] & 0x80) {
        if (!ASN1DEREncUTF8String(enc, 0xc, ((val)->statusString).length, ((val)->statusString).value))
            return 0;
    }
    if ((val)->o[0] & 0x40) {
        if (!ASN1Enc_CmcStatusInfo_otherInfo(enc, 0, &(val)->otherInfo))
            return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
        return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CmcStatusInfo(ASN1decoding_t dec, ASN1uint32_t tag, CmcStatusInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
        return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->cmcStatus))
        return 0;
    if (!ASN1Dec_BodyPartIDSequence(dd, 0, &(val)->bodyList))
        return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0xc) {
        (val)->o[0] |= 0x80;
        if (!ASN1BERDecUTF8String(dd, 0xc, &(val)->statusString))
            return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x2 || t == 0x10) {
        (val)->o[0] |= 0x40;
        if (!ASN1Dec_CmcStatusInfo_otherInfo(dd, 0, &(val)->otherInfo))
            return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
        return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CmcStatusInfo(CmcStatusInfo *val)
{
    if (val) {
        ASN1Free_BodyPartIDSequence(&(val)->bodyList);
        if ((val)->o[0] & 0x80) {
            ASN1utf8string_free(&(val)->statusString);
        }
        if ((val)->o[0] & 0x40) {
            ASN1Free_CmcStatusInfo_otherInfo(&(val)->otherInfo);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\xenroll\xmsasnx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       xmsasnx.cpp
//
//  Contents:
//              Encode/Decode APIs
//
//              Implementation using the MS ASN1 compiler / RTS.
//
//  Functions:  CryptEncodeObject
//              CryptDecodeObject
//
//  History:    02-Nov-98       philh   created
//
//--------------------------------------------------------------------------

//
// ASN1C needs to be defined so that the compiler does not pickup the ASN1 routines from
// the import table
//
#ifdef _X86_
#define ASN1C
#endif

#include "stdafx.h"

#include <windows.h>
#include <wincrypt.h>
#include <malloc.h>

#include "xenroll.h"
#include "cenroll.h"
#pragma warning(disable:4100) // 'var' : unreferenced formal parameter
#include "pkiasn1.h"
#pragma warning(default:4100) // re-enable 4100
#include "pkialloc.h"
#include "crypttls.h"


extern "C"
{
#include "xmsasn.h"
}

#define NO_OSS_DEBUG
#include <dbgdef.h>


// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)


HCRYPTASN1MODULE hAsn1Module = NULL;
HMODULE hCrypt32Dll = NULL;

typedef HCRYPTASN1MODULE (WINAPI *PFN_CRYPT_INSTALL_ASN1_MODULE) (
    IN ASN1module_t pMod,
    IN DWORD dwFlags,
    IN void *pvReserved
    );
typedef BOOL (WINAPI *PFN_CRYPT_UNINSTALL_ASN1_MODULE) (
    IN HCRYPTASN1MODULE hAsn1Module
    );

typedef ASN1encoding_t (WINAPI *PFN_CRYPT_GET_ASN1_ENCODER)(
    IN HCRYPTASN1MODULE hAsn1Module
    );
typedef ASN1decoding_t (WINAPI *PFN_CRYPT_GET_ASN1_DECODER)(
    IN HCRYPTASN1MODULE hAsn1Module
    );

PFN_CRYPT_INSTALL_ASN1_MODULE pfnCryptInstallAsn1Module = NULL;
PFN_CRYPT_UNINSTALL_ASN1_MODULE pfnCryptUninstallAsn1Module = NULL;
PFN_CRYPT_GET_ASN1_ENCODER pfnCryptGetAsn1Encoder = NULL;
PFN_CRYPT_GET_ASN1_DECODER pfnCryptGetAsn1Decoder = NULL;


//+-------------------------------------------------------------------------
//  Function:  GetEncoder/GetDecoder
//
//  Synopsis:  Initialize thread local storage for the asn libs
//
//  Returns:   pointer to an initialized Asn1 encoder/decoder data
//             structures
//--------------------------------------------------------------------------
static ASN1encoding_t GetEncoder(void)
{
    if (hAsn1Module)
        return pfnCryptGetAsn1Encoder(hAsn1Module);
    else
        return NULL;
}

static ASN1decoding_t GetDecoder(void)
{
    if (hAsn1Module)
        return pfnCryptGetAsn1Decoder(hAsn1Module);
    else
        return NULL;
}


//+-------------------------------------------------------------------------
//  Cert allocation and free functions
//--------------------------------------------------------------------------
static void *CertAlloc(
    IN size_t cbBytes
    )
{
    void *pv;
    pv = malloc(cbBytes);
    if (pv == NULL)
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}
static void CertFree(
    IN void *pv
    )
{
    free(pv);
}

//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure
//
//  Called by the Asn1X509*Encode() functions.
//--------------------------------------------------------------------------
static BOOL Asn1InfoEncode(
        IN int pdunum,
        IN void *pAsn1Info,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    ASN1encoding_t ge = GetEncoder();

    if (NULL == ge)
        return FALSE;

    return PkiAsn1EncodeInfo(
        ge,
        pdunum,
        pAsn1Info,
        pbEncoded,
        pcbEncoded);
}


//+-------------------------------------------------------------------------
//  Decode into an allocated, ASN1 formatted info structure
//
//  Called by the Asn1X509*Decode() functions.
//--------------------------------------------------------------------------
static BOOL Asn1InfoDecodeAndAlloc(
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppAsn1Info
        )
{
    return PkiAsn1DecodeAndAllocInfo(
        GetDecoder(),
        pdunum,
        pbEncoded,
        cbEncoded,
        ppAsn1Info);
}

//+-------------------------------------------------------------------------
//  Free an allocated, ASN1 formatted info structure
//
//  Called by the Asn1X509*Decode() functions.
//--------------------------------------------------------------------------
static void Asn1InfoFree(
        IN int pdunum,
        IN void *pAsn1Info
        )
{
    if (pAsn1Info) {
        DWORD dwErr = GetLastError();

        // TlsGetValue globbers LastError
        PkiAsn1FreeInfo(GetDecoder(), pdunum, pAsn1Info);

        SetLastError(dwErr);
    }
}

//+-------------------------------------------------------------------------
//  ASN1 X509 v3 ASN.1 Set / Get functions
//
//  Called by the ASN1 X509 encode/decode functions.
//
//  Assumption: all types are UNBOUNDED.
//
//  The Get functions decrement *plRemainExtra and advance
//  *ppbExtra. When *plRemainExtra becomes negative, the functions continue
//  with the length calculation but stop doing any copies.
//  The functions don't return an error for a negative *plRemainExtra.
//--------------------------------------------------------------------------


//+-------------------------------------------------------------------------
//  Set/Get Object Identifier string
//--------------------------------------------------------------------------
static BOOL Asn1X509SetObjId(
        IN LPSTR pszObjId,
        OUT ObjectID *pAsn1
        )
{
    pAsn1->count = sizeof(pAsn1->value) / sizeof(pAsn1->value[0]);
    if (PkiAsn1ToObjectIdentifier(pszObjId, &pAsn1->count, pAsn1->value))
        return TRUE;
    else {
        SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
        return FALSE;
    }
}

static void Asn1X509GetObjId(
        IN ObjectID *pAsn1,
        IN DWORD /*dwFlags*/,
        OUT LPSTR *ppszObjId,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    DWORD cbObjId;

    cbObjId = lRemainExtra > 0 ? lRemainExtra : 0;
    PkiAsn1FromObjectIdentifier(
        pAsn1->count,
        pAsn1->value,
        (LPSTR) pbExtra,
        &cbObjId
        );

    lAlignExtra = INFO_LEN_ALIGN(cbObjId);
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if(cbObjId) {
            *ppszObjId = (LPSTR) pbExtra;
        } else
            *ppszObjId = NULL;
        pbExtra += lAlignExtra;
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

static BOOL WINAPI Asn1X509CtlUsageEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCTL_USAGE pInfo,
        OUT BYTE *pbEncoded,
            IN OUT DWORD *pcbEncoded
        );

static BOOL WINAPI Asn1X509CtlUsageDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCTL_USAGE pInfo,
        IN OUT DWORD *pcbInfo
        );

static BOOL WINAPI Asn1RequestInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT RequestFlags * pInfo,
        IN OUT DWORD *pcbInfo
        );

static BOOL WINAPI Asn1RequestInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
            IN RequestFlags *  pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );

static BOOL WINAPI Asn1CSPProviderEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
            IN PCRYPT_CSP_PROVIDER pCSPProvider,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );

static BOOL WINAPI Asn1NameValueEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_ENROLLMENT_NAME_VALUE_PAIR pNameValue,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );

static const CRYPT_OID_FUNC_ENTRY X509EncodeFuncTable[] = {
    X509_ENHANCED_KEY_USAGE, Asn1X509CtlUsageEncode,
    XENROLL_REQUEST_INFO,    Asn1RequestInfoEncode,
    szOID_ENROLLMENT_CSP_PROVIDER,  Asn1CSPProviderEncode,
    szOID_ENROLLMENT_NAME_VALUE_PAIR, Asn1NameValueEncode,
};

#define X509_ENCODE_FUNC_COUNT (sizeof(X509EncodeFuncTable) / \
                                    sizeof(X509EncodeFuncTable[0]))

static const CRYPT_OID_FUNC_ENTRY X509DecodeFuncTable[] = {
    X509_ENHANCED_KEY_USAGE, Asn1X509CtlUsageDecode,
    XENROLL_REQUEST_INFO,    Asn1RequestInfoDecode
};

#define X509_DECODE_FUNC_COUNT (sizeof(X509DecodeFuncTable) / \
                                    sizeof(X509DecodeFuncTable[0]))


//+=========================================================================
//  Certificate Management Messages over CMS (CMC) Encode/Decode Functions
//==========================================================================
BOOL WINAPI Asn1CmcDataEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCMC_DATA_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1CmcDataDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1CmcResponseEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCMC_RESPONSE_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1CmcResponseDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1CmcStatusEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCMC_STATUS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1CmcStatusDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1CmcAddExtensionsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCMC_ADD_EXTENSIONS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1CmcAddExtensionsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1CmcAddAttributesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCMC_ADD_ATTRIBUTES_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1CmcAddAttributesDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

static const CRYPT_OID_FUNC_ENTRY CmcEncodeExFuncTable[] = {
    CMC_DATA, Asn1CmcDataEncodeEx,
    CMC_RESPONSE, Asn1CmcResponseEncodeEx,
    CMC_STATUS, Asn1CmcStatusEncodeEx,
    CMC_ADD_EXTENSIONS, Asn1CmcAddExtensionsEncodeEx,
    CMC_ADD_ATTRIBUTES, Asn1CmcAddAttributesEncodeEx,
};
#define CMC_ENCODE_EX_FUNC_COUNT (sizeof(CmcEncodeExFuncTable) / \
                                    sizeof(CmcEncodeExFuncTable[0]))

static const CRYPT_OID_FUNC_ENTRY CmcDecodeExFuncTable[] = {
    CMC_DATA, Asn1CmcDataDecodeEx,
    CMC_RESPONSE, Asn1CmcResponseDecodeEx,
    CMC_STATUS, Asn1CmcStatusDecodeEx,
    CMC_ADD_EXTENSIONS, Asn1CmcAddExtensionsDecodeEx,
    CMC_ADD_ATTRIBUTES, Asn1CmcAddAttributesDecodeEx,
};
#define CMC_DECODE_EX_FUNC_COUNT (sizeof(CmcDecodeExFuncTable) / \
                                    sizeof(CmcDecodeExFuncTable[0]))


//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL MSAsnInit(
        HMODULE hInst)
{
    BOOL fRet;
    DWORD dwExceptionCode;


    if (NULL == (hCrypt32Dll = LoadLibraryA("crypt32.dll")))
        goto LoadCrypt32DllError;

    if (NULL == (pfnCryptInstallAsn1Module =
            (PFN_CRYPT_INSTALL_ASN1_MODULE) GetProcAddress(
                hCrypt32Dll, "I_CryptInstallAsn1Module")))
        goto I_CryptInstallAsn1ModuleProcAddressError;
    if (NULL == (pfnCryptUninstallAsn1Module =
            (PFN_CRYPT_UNINSTALL_ASN1_MODULE) GetProcAddress(
                hCrypt32Dll, "I_CryptUninstallAsn1Module")))
        goto I_CryptUninstallAsn1ModuleProcAddressError;
    if (NULL == (pfnCryptGetAsn1Encoder =
            (PFN_CRYPT_GET_ASN1_ENCODER) GetProcAddress(
                hCrypt32Dll, "I_CryptGetAsn1Encoder")))
        goto I_CryptGetAsn1EncoderProcAddressError;
    if (NULL == (pfnCryptGetAsn1Decoder =
            (PFN_CRYPT_GET_ASN1_DECODER) GetProcAddress(
                hCrypt32Dll, "I_CryptGetAsn1Decoder")))
        goto I_CryptGetAsn1DecoderProcAddressError;


    __try {
        XMSASN_Module_Startup();
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwExceptionCode = GetExceptionCode();
        goto MSAsn1DllException;
    }
    if (0 == (hAsn1Module = pfnCryptInstallAsn1Module(XMSASN_Module, 0, NULL)))
        goto InstallAsn1ModuleError;

    if (!CryptInstallOIDFunctionAddress(
            hInst,
            X509_ASN_ENCODING,
            CRYPT_OID_ENCODE_OBJECT_FUNC,
            X509_ENCODE_FUNC_COUNT,
            X509EncodeFuncTable,
            0))                         // dwFlags
        goto InstallOidFuncError;
    if (!CryptInstallOIDFunctionAddress(
            hInst,
            X509_ASN_ENCODING,
            CRYPT_OID_DECODE_OBJECT_FUNC,
            X509_DECODE_FUNC_COUNT,
            X509DecodeFuncTable,
            0))                         // dwFlags
        goto InstallOidFuncError;

    if (!CryptInstallOIDFunctionAddress(
            hInst,
            X509_ASN_ENCODING,
            CRYPT_OID_ENCODE_OBJECT_EX_FUNC,
            CMC_ENCODE_EX_FUNC_COUNT,
            CmcEncodeExFuncTable,
            0))                         // dwFlags
        goto InstallOidFuncError;
    if (!CryptInstallOIDFunctionAddress(
            hInst,
            X509_ASN_ENCODING,
            CRYPT_OID_DECODE_OBJECT_EX_FUNC,
            CMC_DECODE_EX_FUNC_COUNT,
            CmcDecodeExFuncTable,
            0))                         // dwFlags
        goto InstallOidFuncError;

    fRet = TRUE;

CommonReturn:
    return fRet;

InstallOidFuncError:
    fRet = FALSE;
    goto CommonReturn;

ErrorReturn:
    fRet = FALSE;

    if (hCrypt32Dll) {
        FreeLibrary(hCrypt32Dll);
        hCrypt32Dll = NULL;
    }

    pfnCryptInstallAsn1Module = NULL;
    pfnCryptUninstallAsn1Module = NULL;
    pfnCryptGetAsn1Encoder = NULL;
    pfnCryptGetAsn1Decoder = NULL;
    hAsn1Module = NULL;

    goto CommonReturn;

TRACE_ERROR(LoadCrypt32DllError)
TRACE_ERROR(I_CryptInstallAsn1ModuleProcAddressError)
TRACE_ERROR(I_CryptUninstallAsn1ModuleProcAddressError)
TRACE_ERROR(I_CryptGetAsn1EncoderProcAddressError)
TRACE_ERROR(I_CryptGetAsn1DecoderProcAddressError)
SET_ERROR_VAR(MSAsn1DllException, dwExceptionCode)
TRACE_ERROR(InstallAsn1ModuleError)
}

void MSAsnTerm()
{
    if (hAsn1Module) {
        pfnCryptUninstallAsn1Module(hAsn1Module);
        __try {
            XMSASN_Module_Cleanup();
        } __except(EXCEPTION_EXECUTE_HANDLER) {
        }

        hAsn1Module = NULL;
    }

    if (hCrypt32Dll) {
        FreeLibrary(hCrypt32Dll);
        hCrypt32Dll = NULL;
    }
}

//+-------------------------------------------------------------------------
//  ASN1 X509 v3 ASN.1 Set / Get functions
//
//  Called by the ASN1 X509 encode/decode functions.
//
//  Assumption: all types are UNBOUNDED.
//
//  The Get functions decrement *plRemainExtra and advance
//  *ppbExtra. When *plRemainExtra becomes negative, the functions continue
//  with the length calculation but stop doing any copies.
//  The functions don't return an error for a negative *plRemainExtra.
//--------------------------------------------------------------------------


//+-------------------------------------------------------------------------
//  Set/Free/Get CTL Usage object identifiers
//--------------------------------------------------------------------------
static BOOL Asn1X509SetCtlUsage(
        IN PCTL_USAGE pUsage,
        OUT EnhancedKeyUsage *pAsn1
        )
{
    DWORD cId;
    LPSTR *ppszId;
    UsageIdentifier *pAsn1Id;

    pAsn1->count = 0;
    pAsn1->value = NULL;
    cId = pUsage->cUsageIdentifier;
    if (0 == cId)
        return TRUE;

    pAsn1Id = (UsageIdentifier *) CertAlloc(cId * sizeof(UsageIdentifier));
    if (pAsn1Id == NULL)
        return FALSE;

    pAsn1->count = cId;
    pAsn1->value = pAsn1Id;
    ppszId = pUsage->rgpszUsageIdentifier;
    for ( ; cId > 0; cId--, ppszId++, pAsn1Id++) {
        if (!Asn1X509SetObjId(*ppszId, pAsn1Id))
            return FALSE;
    }

    return TRUE;
}

static void Asn1X509FreeCtlUsage(
        IN EnhancedKeyUsage *pAsn1)
{
    if (pAsn1->value) {
        CertFree(pAsn1->value);
        pAsn1->value = NULL;
    }
}

static void Asn1X509GetCtlUsage(
        IN EnhancedKeyUsage *pAsn1,
        IN DWORD dwFlags,
        OUT PCTL_USAGE pUsage,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cId;
    UsageIdentifier *pAsn1Id;
    LPSTR *ppszId;

    cId = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cId * sizeof(LPSTR));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        pUsage->cUsageIdentifier = cId;
        ppszId = (LPSTR *) pbExtra;
        pUsage->rgpszUsageIdentifier = ppszId;
        pbExtra += lAlignExtra;
    } else
        ppszId = NULL;

    pAsn1Id = pAsn1->value;
    for ( ; cId > 0; cId--, pAsn1Id++, ppszId++)
        Asn1X509GetObjId(pAsn1Id, dwFlags, ppszId, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  CTL Usage (Enhanced Key Usage) Encode (ASN1 X509)
//--------------------------------------------------------------------------
static BOOL WINAPI Asn1X509CtlUsageEncode(
        IN DWORD /*dwCertEncodingType*/,
        IN LPCSTR /*lpszStructType*/,
        IN PCTL_USAGE pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    EnhancedKeyUsage Asn1Info;

    if (!Asn1X509SetCtlUsage(pInfo, &Asn1Info)) {
        *pcbEncoded = 0;
        fResult = FALSE;
    } else
        fResult = Asn1InfoEncode(
            EnhancedKeyUsage_PDU,
            &Asn1Info,
            pbEncoded,
            pcbEncoded
            );
    Asn1X509FreeCtlUsage(&Asn1Info);
    return fResult;
}

//+-------------------------------------------------------------------------
//  CTL Usage (Enhanced Key Usage) Decode (ASN1 X509)
//--------------------------------------------------------------------------
static BOOL WINAPI Asn1X509CtlUsageDecode(
        IN DWORD /*dwCertEncodingType*/,
        IN LPCSTR /*lpszStructType*/,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCTL_USAGE pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    BOOL fResult;
    EnhancedKeyUsage *pAsn1Info = NULL;
    BYTE *pbExtra;
    LONG lRemainExtra;

    if (pInfo == NULL)
        *pcbInfo = 0;

    if (!Asn1InfoDecodeAndAlloc(
            EnhancedKeyUsage_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &pAsn1Info))
        goto ErrorReturn;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbInfo - sizeof(CTL_USAGE);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CTL_USAGE);

    Asn1X509GetCtlUsage(pAsn1Info, dwFlags, pInfo, &pbExtra, &lRemainExtra);

    if (lRemainExtra >= 0)
        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    else {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (pInfo) goto LengthError;
    }

    fResult = TRUE;
    goto CommonReturn;

LengthError:
    SetLastError((DWORD) ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;
ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;
CommonReturn:
    Asn1InfoFree(EnhancedKeyUsage_PDU, pAsn1Info);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Request Info Encode
//--------------------------------------------------------------------------
static BOOL WINAPI Asn1RequestInfoEncode(
        IN DWORD /*dwCertEncodingType*/,
        IN LPCSTR /*lpszStructType*/,
            IN RequestFlags *  pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;

    fResult = Asn1InfoEncode(
                RequestFlags_PDU,
                pInfo,
            pbEncoded,
            pcbEncoded
            );

    return fResult;
}



//+-------------------------------------------------------------------------
//  Request Info Decode
//--------------------------------------------------------------------------
static BOOL WINAPI Asn1RequestInfoDecode(
        IN DWORD /*dwCertEncodingType*/,
        IN LPCSTR /*lpszStructType*/,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD /*dwFlags*/,
            OUT RequestFlags * pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    BOOL fResult;
    RequestFlags *  pAsn1 = NULL;

    if (NULL == pInfo || NULL == pcbInfo)
        goto ParamError;

    if( *pcbInfo < sizeof(RequestFlags) )
        goto LengthError;

    else if (!Asn1InfoDecodeAndAlloc(
            RequestFlags_PDU,
        pbEncoded,
        cbEncoded,
            (void **) &pAsn1) || NULL == pAsn1)
        goto ErrorReturn;

    memcpy(pInfo, pAsn1, sizeof(RequestFlags));
    fResult = TRUE;
    goto CommonReturn;

ParamError:
    SetLastError((DWORD)ERROR_INVALID_PARAMETER);
    fResult = FALSE;
    goto CommonReturn;
LengthError:
    SetLastError((DWORD) ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;
ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;
CommonReturn:
    if (NULL != pAsn1)
    {
        Asn1InfoFree(RequestFlags_PDU, pAsn1);
    }
    return fResult;
}

static BOOL WINAPI Asn1CSPProviderEncode(
        IN DWORD /*dwCertEncodingType*/,
        IN LPCSTR /*lpszStructType*/,
            IN PCRYPT_CSP_PROVIDER pCSPProvider,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CSPProvider CspProvider;

    CspProvider.keySpec = (int) pCSPProvider->dwKeySpec;
    CspProvider.cspName.length = (DWORD)wcslen(pCSPProvider->pwszProviderName);
    CspProvider.cspName.value  = pCSPProvider->pwszProviderName;

    PkiAsn1SetBitString(&pCSPProvider->Signature, &CspProvider.signature.length, &CspProvider.signature.value);

    fResult = Asn1InfoEncode(
                CSPProvider_PDU,
                &CspProvider,
            pbEncoded,
            pcbEncoded
            );

    return fResult;
}

static BOOL WINAPI Asn1NameValueEncode(
        IN DWORD /*dwCertEncodingType*/,
        IN LPCSTR /*lpszStructType*/,
        IN PCRYPT_ENROLLMENT_NAME_VALUE_PAIR pNameValue,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    EnrollmentNameValuePair NameValue;

    NameValue.name.length = (DWORD)wcslen(pNameValue->pwszName);
    NameValue.name.value  = pNameValue->pwszName;

    NameValue.value.length = (DWORD)wcslen(pNameValue->pwszValue);
    NameValue.value.value  = pNameValue->pwszValue;

    fResult = Asn1InfoEncode(
                EnrollmentNameValuePair_PDU,
                &NameValue,
            pbEncoded,
            pcbEncoded
            );

    return fResult;
}


//+=========================================================================
//  Certificate Management Messages over CMS (CMC) Encode/Decode Functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure
//
//  Called by the Asn1X509*Encode() functions.
//--------------------------------------------------------------------------
static BOOL Asn1InfoEncodeEx(
        IN int pdunum,
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return PkiAsn1EncodeInfoEx(
        GetEncoder(),
        pdunum,
        pvAsn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded);
}

//+-------------------------------------------------------------------------
//  Decode into an ASN1 formatted info structure. Call the callback
//  function to convert into the 'C' data structure. If
//  CRYPT_DECODE_ALLOC_FLAG is set, call the callback twice. First,
//  to get the length of the 'C' data structure. Then after allocating,
//  call again to update the 'C' data structure.
//
//  Called by the Asn1X509*Decode() functions.
//--------------------------------------------------------------------------
static BOOL Asn1InfoDecodeAndAllocEx(
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return PkiAsn1DecodeAndAllocInfoEx(
        GetDecoder(),
        pdunum,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        pfnDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  Set/Get CRYPT_DATA_BLOB (Octet String)
//--------------------------------------------------------------------------
inline void Asn1X509SetOctetString(
        IN PCRYPT_DATA_BLOB pInfo,
        OUT OCTETSTRING *pAsn1
        )
{
    pAsn1->value = pInfo->pbData;
    pAsn1->length = pInfo->cbData;
}
inline void Asn1X509GetOctetString(
        IN OCTETSTRING *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetOctetString(pAsn1->length, pAsn1->value, dwFlags,
        pInfo, ppbExtra, plRemainExtra);
}


//+-------------------------------------------------------------------------
//  Set/Get "Any" DER BLOB
//--------------------------------------------------------------------------
inline void Asn1X509SetAny(
        IN PCRYPT_OBJID_BLOB pInfo,
        OUT NOCOPYANY *pAsn1
        )
{
    PkiAsn1SetAny(pInfo, pAsn1);
}
inline void Asn1X509GetAny(
        IN NOCOPYANY *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_OBJID_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetAny(pAsn1, dwFlags, pInfo, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get SeqOfAny
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509SetSeqOfAny(
        IN DWORD cValue,
        IN PCRYPT_DER_BLOB pValue,
        OUT ASN1uint32_t *pAsn1Count,
        OUT NOCOPYANY **ppAsn1Value
        )
{

    *pAsn1Count = 0;
    *ppAsn1Value = NULL;
    if (cValue > 0) {
        NOCOPYANY *pAsn1Value;

        pAsn1Value = (NOCOPYANY *) PkiZeroAlloc(cValue * sizeof(NOCOPYANY));
        if (pAsn1Value == NULL)
            return FALSE;
        *pAsn1Count = cValue;
        *ppAsn1Value = pAsn1Value;
        for ( ; cValue > 0; cValue--, pValue++, pAsn1Value++)
            Asn1X509SetAny(pValue, pAsn1Value);
    }
    return TRUE;
}

void Asn1X509FreeSeqOfAny(
        IN NOCOPYANY *pAsn1Value
        )
{
    if (pAsn1Value)
        PkiFree(pAsn1Value);
}

void Asn1X509GetSeqOfAny(
        IN unsigned int Asn1Count,
        IN NOCOPYANY *pAsn1Value,
        IN DWORD dwFlags,
        OUT DWORD *pcValue,
        OUT PCRYPT_DER_BLOB *ppValue,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lAlignExtra;
    PCRYPT_ATTR_BLOB pValue;

    lAlignExtra = INFO_LEN_ALIGN(Asn1Count * sizeof(CRYPT_DER_BLOB));
    *plRemainExtra -= lAlignExtra;
    if (*plRemainExtra >= 0) {
        *pcValue = Asn1Count;
        pValue = (PCRYPT_DER_BLOB) *ppbExtra;
        *ppValue = pValue;
        *ppbExtra += lAlignExtra;
    } else
        pValue = NULL;

    for (; Asn1Count > 0; Asn1Count--, pAsn1Value++, pValue++)
        Asn1X509GetAny(pAsn1Value, dwFlags, pValue, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get Extensions
//--------------------------------------------------------------------------
BOOL Asn1X509SetExtensions(
        IN DWORD cExtension,
        IN PCERT_EXTENSION pExtension,
        OUT Extensions *pAsn1
        )
{
    Extension *pAsn1Ext;

    pAsn1->value = NULL;
    pAsn1->count = 0;
    if (cExtension == 0)
        return TRUE;

    pAsn1Ext = (Extension *) PkiZeroAlloc(cExtension * sizeof(Extension));
    if (pAsn1Ext == NULL)
        return FALSE;
    pAsn1->value = pAsn1Ext;
    pAsn1->count = cExtension;

    for ( ; cExtension > 0; cExtension--, pExtension++, pAsn1Ext++) {
        if (!Asn1X509SetObjId(pExtension->pszObjId, &pAsn1Ext->extnId))
            return FALSE;
        if (pExtension->fCritical) {
            pAsn1Ext->critical = TRUE;
            pAsn1Ext->bit_mask |= critical_present;
        }
        Asn1X509SetOctetString(&pExtension->Value, &pAsn1Ext->extnValue);
    }
    return TRUE;
}

void Asn1X509FreeExtensions(
        IN Extensions *pAsn1)
{
    if (pAsn1->value) {
        PkiFree(pAsn1->value);
        pAsn1->value = NULL;
    }
    pAsn1->count = 0;
}

void Asn1X509GetExtensions(
        IN Extensions *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pcExtension,
        OUT PCERT_EXTENSION *ppExtension,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cExt;
    Extension *pAsn1Ext;
    PCERT_EXTENSION pGetExt;

    cExt = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cExt * sizeof(CERT_EXTENSION));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        *pcExtension = cExt;
        pGetExt = (PCERT_EXTENSION) pbExtra;
        *ppExtension = pGetExt;
        pbExtra += lAlignExtra;
    } else
        pGetExt = NULL;

    pAsn1Ext = pAsn1->value;
    for ( ; cExt > 0; cExt--, pAsn1Ext++, pGetExt++) {
        Asn1X509GetObjId(&pAsn1Ext->extnId, dwFlags, &pGetExt->pszObjId,
                &pbExtra, &lRemainExtra);
        if (lRemainExtra >= 0) {
            pGetExt->fCritical = FALSE;
            if (pAsn1Ext->bit_mask & critical_present)
                pGetExt->fCritical = (BOOLEAN) pAsn1Ext->critical;
        }

        Asn1X509GetOctetString(&pAsn1Ext->extnValue, dwFlags, &pGetExt->Value,
                &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CRYPT_ATTRIBUTE
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509SetAttribute(
        IN PCRYPT_ATTRIBUTE pInfo,
        OUT Attribute *pAsn1
        )
{
    memset(pAsn1, 0, sizeof(*pAsn1));
    if (!Asn1X509SetObjId(pInfo->pszObjId, &pAsn1->type))
        return FALSE;

    return Asn1X509SetSeqOfAny(
            pInfo->cValue,
            pInfo->rgValue,
            &pAsn1->values.count,
            &pAsn1->values.value);
}

void Asn1X509FreeAttribute(
        IN OUT Attribute *pAsn1
        )
{
    Asn1X509FreeSeqOfAny(pAsn1->values.value);
}

void Asn1X509GetAttribute(
        IN Attribute *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_ATTRIBUTE pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    Asn1X509GetObjId(&pAsn1->type, dwFlags,
        &pInfo->pszObjId, ppbExtra, plRemainExtra);
    Asn1X509GetSeqOfAny(pAsn1->values.count, pAsn1->values.value, dwFlags,
        &pInfo->cValue, &pInfo->rgValue, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get Attributes
//--------------------------------------------------------------------------
BOOL Asn1X509SetAttributes(
        IN DWORD cAttribute,
        IN PCRYPT_ATTRIBUTE pAttribute,
        OUT Attributes *pAsn1
        )
{
    Attribute *pAsn1Attr;

    pAsn1->value = NULL;
    pAsn1->count = 0;
    if (cAttribute == 0)
        return TRUE;

    pAsn1Attr = (Attribute *) PkiZeroAlloc(cAttribute * sizeof(Attribute));
    if (pAsn1Attr == NULL)
        return FALSE;
    pAsn1->value = pAsn1Attr;
    pAsn1->count = cAttribute;

    for ( ; cAttribute > 0; cAttribute--, pAttribute++, pAsn1Attr++) {
        if (!Asn1X509SetAttribute(pAttribute, pAsn1Attr))
            return FALSE;
    }
    return TRUE;
}

void Asn1X509FreeAttributes(
        IN Attributes *pAsn1
        )
{
    if (pAsn1->value) {
        DWORD cAttr = pAsn1->count;
        Attribute *pAsn1Attr = pAsn1->value;

        for ( ; cAttr > 0; cAttr--, pAsn1Attr++)
            Asn1X509FreeAttribute(pAsn1Attr);

        PkiFree(pAsn1->value);
        pAsn1->value = NULL;
    }
    pAsn1->count = 0;
}

void Asn1X509GetAttributes(
        IN Attributes *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pcAttribute,
        OUT PCRYPT_ATTRIBUTE *ppAttribute,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cAttr;
    Attribute *pAsn1Attr;
    PCRYPT_ATTRIBUTE pGetAttr;

    cAttr = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cAttr * sizeof(CRYPT_ATTRIBUTE));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        *pcAttribute = cAttr;
        pGetAttr = (PCRYPT_ATTRIBUTE) pbExtra;
        *ppAttribute = pGetAttr;
        pbExtra += lAlignExtra;
    } else
        pGetAttr = NULL;

    pAsn1Attr = pAsn1->value;
    for ( ; cAttr > 0; cAttr--, pAsn1Attr++, pGetAttr++) {
        Asn1X509GetAttribute(pAsn1Attr, dwFlags, pGetAttr,
                &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CMC Tagged Attributes
//--------------------------------------------------------------------------
BOOL Asn1CmcSetTaggedAttributes(
        IN DWORD cTaggedAttr,
        IN PCMC_TAGGED_ATTRIBUTE pTaggedAttr,
        OUT ControlSequence *pAsn1
        )
{
    TaggedAttribute *pAsn1Attr;

    pAsn1->value = NULL;
    pAsn1->count = 0;
    if (cTaggedAttr == 0)
        return TRUE;

    pAsn1Attr = (TaggedAttribute *) PkiZeroAlloc(
        cTaggedAttr * sizeof(TaggedAttribute));
    if (pAsn1Attr == NULL)
        return FALSE;
    pAsn1->value = pAsn1Attr;
    pAsn1->count = cTaggedAttr;

    for ( ; cTaggedAttr > 0; cTaggedAttr--, pTaggedAttr++, pAsn1Attr++) {
        pAsn1Attr->bodyPartID = pTaggedAttr->dwBodyPartID;
        if (!Asn1X509SetObjId(pTaggedAttr->Attribute.pszObjId,
                &pAsn1Attr->type))
            return FALSE;

        if (!Asn1X509SetSeqOfAny(
                pTaggedAttr->Attribute.cValue,
                pTaggedAttr->Attribute.rgValue,
                &pAsn1Attr->values.count,
                &pAsn1Attr->values.value))
            return FALSE;
    }
    return TRUE;
}

void Asn1CmcFreeTaggedAttributes(
        IN OUT ControlSequence *pAsn1
        )
{
    if (pAsn1->value) {
        TaggedAttribute *pAsn1Attr = pAsn1->value;
        DWORD cTaggedAttr = pAsn1->count;

        for ( ; cTaggedAttr > 0; cTaggedAttr--, pAsn1Attr++) {
            Asn1X509FreeSeqOfAny(pAsn1Attr->values.value);
        }
        PkiFree(pAsn1->value);
        pAsn1->value = NULL;
    }
    pAsn1->count = 0;
}

void Asn1CmcGetTaggedAttributes(
        IN ControlSequence *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pcTaggedAttr,
        OUT PCMC_TAGGED_ATTRIBUTE *ppTaggedAttr,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cTaggedAttr;
    TaggedAttribute *pAsn1Attr;
    PCMC_TAGGED_ATTRIBUTE pTaggedAttr;

    cTaggedAttr = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cTaggedAttr * sizeof(CMC_TAGGED_ATTRIBUTE));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        *pcTaggedAttr = cTaggedAttr;
        pTaggedAttr = (PCMC_TAGGED_ATTRIBUTE) pbExtra;
        *ppTaggedAttr = pTaggedAttr;
        pbExtra += lAlignExtra;
    } else
        pTaggedAttr = NULL;

    pAsn1Attr = pAsn1->value;
    for ( ; cTaggedAttr > 0; cTaggedAttr--, pAsn1Attr++, pTaggedAttr++) {
        if (lRemainExtra >= 0) {
            pTaggedAttr->dwBodyPartID = pAsn1Attr->bodyPartID;
        }
        Asn1X509GetObjId(&pAsn1Attr->type, dwFlags,
            &pTaggedAttr->Attribute.pszObjId, &pbExtra, &lRemainExtra);
        Asn1X509GetSeqOfAny(
            pAsn1Attr->values.count, pAsn1Attr->values.value, dwFlags,
            &pTaggedAttr->Attribute.cValue, &pTaggedAttr->Attribute.rgValue,
            &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CMC Tagged Requests
//--------------------------------------------------------------------------
BOOL Asn1CmcSetTaggedRequests(
        IN DWORD cTaggedReq,
        IN PCMC_TAGGED_REQUEST pTaggedReq,
        OUT ReqSequence *pAsn1
        )
{
    TaggedRequest *pAsn1Req;

    pAsn1->value = NULL;
    pAsn1->count = 0;
    if (cTaggedReq == 0)
        return TRUE;

    pAsn1Req = (TaggedRequest *) PkiZeroAlloc(
        cTaggedReq * sizeof(TaggedRequest));
    if (pAsn1Req == NULL)
        return FALSE;
    pAsn1->value = pAsn1Req;
    pAsn1->count = cTaggedReq;

    for ( ; cTaggedReq > 0; cTaggedReq--, pTaggedReq++, pAsn1Req++) {
        PCMC_TAGGED_CERT_REQUEST pTaggedCertReq;
        TaggedCertificationRequest *ptcr;

        if (CMC_TAGGED_CERT_REQUEST_CHOICE !=
                pTaggedReq->dwTaggedRequestChoice) {
            SetLastError((DWORD) E_INVALIDARG);
            return FALSE;
        }

        pAsn1Req->choice = tcr_chosen;
        ptcr = &pAsn1Req->u.tcr;
        pTaggedCertReq = pTaggedReq->pTaggedCertRequest;

        ptcr->bodyPartID = pTaggedCertReq->dwBodyPartID;
        Asn1X509SetAny(&pTaggedCertReq->SignedCertRequest,
            &ptcr->certificationRequest);
    }
    return TRUE;
}

void Asn1CmcFreeTaggedRequests(
        IN OUT ReqSequence *pAsn1
        )
{
    if (pAsn1->value) {
        PkiFree(pAsn1->value);
        pAsn1->value = NULL;
    }
    pAsn1->count = 0;
}

BOOL Asn1CmcGetTaggedRequests(
        IN ReqSequence *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pcTaggedReq,
        OUT PCMC_TAGGED_REQUEST *ppTaggedReq,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cTaggedReq;
    TaggedRequest *pAsn1Req;
    PCMC_TAGGED_REQUEST pTaggedReq;

    cTaggedReq = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cTaggedReq * sizeof(CMC_TAGGED_REQUEST));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        *pcTaggedReq = cTaggedReq;
        pTaggedReq = (PCMC_TAGGED_REQUEST) pbExtra;
        *ppTaggedReq = pTaggedReq;
        pbExtra += lAlignExtra;
    } else
        pTaggedReq = NULL;

    pAsn1Req = pAsn1->value;
    for ( ; cTaggedReq > 0; cTaggedReq--, pAsn1Req++, pTaggedReq++) {
        PCMC_TAGGED_CERT_REQUEST pTaggedCertReq;
        TaggedCertificationRequest *ptcr;

        if (tcr_chosen != pAsn1Req->choice) {
            SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
            goto ErrorReturn;
        }

        ptcr = &pAsn1Req->u.tcr;

        lAlignExtra = INFO_LEN_ALIGN(sizeof(CMC_TAGGED_CERT_REQUEST));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            pTaggedReq->dwTaggedRequestChoice =
                CMC_TAGGED_CERT_REQUEST_CHOICE;

            pTaggedCertReq = (PCMC_TAGGED_CERT_REQUEST) pbExtra;
            pbExtra += lAlignExtra;

            pTaggedReq->pTaggedCertRequest = pTaggedCertReq;
            pTaggedCertReq->dwBodyPartID = ptcr->bodyPartID;
        } else
            pTaggedCertReq = NULL;

        Asn1X509GetAny(&ptcr->certificationRequest, dwFlags,
            &pTaggedCertReq->SignedCertRequest, &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CMC Tagged ContentInfo
//--------------------------------------------------------------------------
BOOL Asn1CmcSetTaggedContentInfos(
        IN DWORD cTaggedCI,
        IN PCMC_TAGGED_CONTENT_INFO pTaggedCI,
        OUT CmsSequence *pAsn1
        )
{
    TaggedContentInfo *pAsn1CI;

    pAsn1->value = NULL;
    pAsn1->count = 0;
    if (cTaggedCI == 0)
        return TRUE;

    pAsn1CI = (TaggedContentInfo *) PkiZeroAlloc(
        cTaggedCI * sizeof(TaggedContentInfo));
    if (pAsn1CI == NULL)
        return FALSE;
    pAsn1->value = pAsn1CI;
    pAsn1->count = cTaggedCI;

    for ( ; cTaggedCI > 0; cTaggedCI--, pTaggedCI++, pAsn1CI++) {
        pAsn1CI->bodyPartID = pTaggedCI->dwBodyPartID;
        Asn1X509SetAny(&pTaggedCI->EncodedContentInfo, &pAsn1CI->contentInfo);
    }

    return TRUE;
}

void Asn1CmcFreeTaggedContentInfos(
        IN OUT CmsSequence *pAsn1
        )
{
    if (pAsn1->value) {
        PkiFree(pAsn1->value);
        pAsn1->value = NULL;
    }
    pAsn1->count = 0;
}

void Asn1CmcGetTaggedContentInfos(
        IN CmsSequence *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pcTaggedCI,
        OUT PCMC_TAGGED_CONTENT_INFO *ppTaggedCI,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cTaggedCI;
    TaggedContentInfo *pAsn1CI;
    PCMC_TAGGED_CONTENT_INFO pTaggedCI;

    cTaggedCI = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cTaggedCI * sizeof(CMC_TAGGED_CONTENT_INFO));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        *pcTaggedCI = cTaggedCI;
        pTaggedCI = (PCMC_TAGGED_CONTENT_INFO) pbExtra;
        *ppTaggedCI = pTaggedCI;
        pbExtra += lAlignExtra;
    } else
        pTaggedCI = NULL;

    pAsn1CI = pAsn1->value;
    for ( ; cTaggedCI > 0; cTaggedCI--, pAsn1CI++, pTaggedCI++) {
        if (lRemainExtra >= 0) {
            pTaggedCI->dwBodyPartID = pAsn1CI->bodyPartID;
        }

        Asn1X509GetAny(&pAsn1CI->contentInfo, dwFlags,
            &pTaggedCI->EncodedContentInfo, &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CMC Tagged OtherMsg
//--------------------------------------------------------------------------
BOOL Asn1CmcSetTaggedOtherMsgs(
        IN DWORD cTaggedOM,
        IN PCMC_TAGGED_OTHER_MSG pTaggedOM,
        OUT OtherMsgSequence *pAsn1
        )
{
    TaggedOtherMsg *pAsn1OM;

    pAsn1->value = NULL;
    pAsn1->count = 0;
    if (cTaggedOM == 0)
        return TRUE;

    pAsn1OM = (TaggedOtherMsg *) PkiZeroAlloc(
        cTaggedOM * sizeof(TaggedOtherMsg));
    if (pAsn1OM == NULL)
        return FALSE;
    pAsn1->value = pAsn1OM;
    pAsn1->count = cTaggedOM;

    for ( ; cTaggedOM > 0; cTaggedOM--, pTaggedOM++, pAsn1OM++) {
        pAsn1OM->bodyPartID = pTaggedOM->dwBodyPartID;

        if (!Asn1X509SetObjId(pTaggedOM->pszObjId,
                &pAsn1OM->otherMsgType))
            return FALSE;

        Asn1X509SetAny(&pTaggedOM->Value, &pAsn1OM->otherMsgValue);
    }

    return TRUE;
}

void Asn1CmcFreeTaggedOtherMsgs(
        IN OUT OtherMsgSequence *pAsn1
        )
{
    if (pAsn1->value) {
        PkiFree(pAsn1->value);
        pAsn1->value = NULL;
    }
    pAsn1->count = 0;
}

void Asn1CmcGetTaggedOtherMsgs(
        IN OtherMsgSequence *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pcTaggedOM,
        OUT PCMC_TAGGED_OTHER_MSG *ppTaggedOM,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cTaggedOM;
    TaggedOtherMsg *pAsn1OM;
    PCMC_TAGGED_OTHER_MSG pTaggedOM;

    cTaggedOM = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cTaggedOM * sizeof(CMC_TAGGED_OTHER_MSG));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        *pcTaggedOM = cTaggedOM;
        pTaggedOM = (PCMC_TAGGED_OTHER_MSG) pbExtra;
        *ppTaggedOM = pTaggedOM;
        pbExtra += lAlignExtra;
    } else
        pTaggedOM = NULL;

    pAsn1OM = pAsn1->value;
    for ( ; cTaggedOM > 0; cTaggedOM--, pAsn1OM++, pTaggedOM++) {
        if (lRemainExtra >= 0) {
            pTaggedOM->dwBodyPartID = pAsn1OM->bodyPartID;
        }

        Asn1X509GetObjId(&pAsn1OM->otherMsgType, dwFlags,
            &pTaggedOM->pszObjId, &pbExtra, &lRemainExtra);

        Asn1X509GetAny(&pAsn1OM->otherMsgValue, dwFlags,
            &pTaggedOM->Value, &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  CMC Data Encode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcDataEncodeEx(
        IN DWORD /*dwCertEncodingType*/,
        IN LPCSTR /*lpszStructType*/,
        IN PCMC_DATA_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CmcData Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (!Asn1CmcSetTaggedAttributes(pInfo->cTaggedAttribute,
            pInfo->rgTaggedAttribute, &Asn1Info.controlSequence))
        goto ErrorReturn;
    if (!Asn1CmcSetTaggedRequests(pInfo->cTaggedRequest,
            pInfo->rgTaggedRequest, &Asn1Info.reqSequence))
        goto ErrorReturn;
    if (!Asn1CmcSetTaggedContentInfos(pInfo->cTaggedContentInfo,
            pInfo->rgTaggedContentInfo, &Asn1Info.cmsSequence))
        goto ErrorReturn;
    if (!Asn1CmcSetTaggedOtherMsgs(pInfo->cTaggedOtherMsg,
            pInfo->rgTaggedOtherMsg, &Asn1Info.otherMsgSequence))
        goto ErrorReturn;

    fResult = Asn1InfoEncodeEx(
        CmcData_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

CommonReturn:
    Asn1CmcFreeTaggedAttributes(&Asn1Info.controlSequence);
    Asn1CmcFreeTaggedRequests(&Asn1Info.reqSequence);
    Asn1CmcFreeTaggedContentInfos(&Asn1Info.cmsSequence);
    Asn1CmcFreeTaggedOtherMsgs(&Asn1Info.otherMsgSequence);
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  CMC Data Decode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcDataDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA /*pDecodePara*/,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    CmcData *pAsn1 = (CmcData *) pvAsn1Info;
    PCMC_DATA_INFO pInfo = (PCMC_DATA_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CMC_DATA_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CMC_DATA_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CMC_DATA_INFO);
    }

    Asn1CmcGetTaggedAttributes(&pAsn1->controlSequence,
        dwFlags,
        &pInfo->cTaggedAttribute,
        &pInfo->rgTaggedAttribute,
        &pbExtra,
        &lRemainExtra
        );

    if (!Asn1CmcGetTaggedRequests(&pAsn1->reqSequence,
            dwFlags,
            &pInfo->cTaggedRequest,
            &pInfo->rgTaggedRequest,
            &pbExtra,
            &lRemainExtra
            ))
        goto ErrorReturn;

    Asn1CmcGetTaggedContentInfos(&pAsn1->cmsSequence,
        dwFlags,
        &pInfo->cTaggedContentInfo,
        &pInfo->rgTaggedContentInfo,
        &pbExtra,
        &lRemainExtra
        );

    Asn1CmcGetTaggedOtherMsgs(&pAsn1->otherMsgSequence,
        dwFlags,
        &pInfo->cTaggedOtherMsg,
        &pInfo->rgTaggedOtherMsg,
        &pbExtra,
        &lRemainExtra
        );

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

BOOL WINAPI Asn1CmcDataDecodeEx(
        IN DWORD /*dwCertEncodingType*/,
        IN LPCSTR /*lpszStructType*/,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        CmcData_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1CmcDataDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  CMC Response Encode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcResponseEncodeEx(
        IN DWORD /*dwCertEncodingType*/,
        IN LPCSTR /*lpszStructType*/,
        IN PCMC_RESPONSE_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CmcResponseBody Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (!Asn1CmcSetTaggedAttributes(pInfo->cTaggedAttribute,
            pInfo->rgTaggedAttribute, &Asn1Info.controlSequence))
        goto ErrorReturn;
    if (!Asn1CmcSetTaggedContentInfos(pInfo->cTaggedContentInfo,
            pInfo->rgTaggedContentInfo, &Asn1Info.cmsSequence))
        goto ErrorReturn;
    if (!Asn1CmcSetTaggedOtherMsgs(pInfo->cTaggedOtherMsg,
            pInfo->rgTaggedOtherMsg, &Asn1Info.otherMsgSequence))
        goto ErrorReturn;

    fResult = Asn1InfoEncodeEx(
        CmcResponseBody_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
CommonReturn:
    Asn1CmcFreeTaggedAttributes(&Asn1Info.controlSequence);
    Asn1CmcFreeTaggedContentInfos(&Asn1Info.cmsSequence);
    Asn1CmcFreeTaggedOtherMsgs(&Asn1Info.otherMsgSequence);
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  CMC Response Decode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcResponseDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA /*pDecodePara*/,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    CmcResponseBody *pAsn1 = (CmcResponseBody *) pvAsn1Info;
    PCMC_RESPONSE_INFO pInfo = (PCMC_RESPONSE_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CMC_RESPONSE_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CMC_RESPONSE_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CMC_RESPONSE_INFO);
    }

    Asn1CmcGetTaggedAttributes(&pAsn1->controlSequence,
        dwFlags,
        &pInfo->cTaggedAttribute,
        &pInfo->rgTaggedAttribute,
        &pbExtra,
        &lRemainExtra
        );

    Asn1CmcGetTaggedContentInfos(&pAsn1->cmsSequence,
        dwFlags,
        &pInfo->cTaggedContentInfo,
        &pInfo->rgTaggedContentInfo,
        &pbExtra,
        &lRemainExtra
        );

    Asn1CmcGetTaggedOtherMsgs(&pAsn1->otherMsgSequence,
        dwFlags,
        &pInfo->cTaggedOtherMsg,
        &pInfo->rgTaggedOtherMsg,
        &pbExtra,
        &lRemainExtra
        );

    fResult = TRUE;
    *plRemainExtra = lRemainExtra;
    return fResult;
}

BOOL WINAPI Asn1CmcResponseDecodeEx(
        IN DWORD /*dwCertEncodingType*/,
        IN LPCSTR /*lpszStructType*/,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        CmcResponseBody_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1CmcResponseDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  CMC Status Encode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcStatusEncodeEx(
        IN DWORD /*dwCertEncodingType*/,
        IN LPCSTR /*lpszStructType*/,
        IN PCMC_STATUS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CmcStatusInfo Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    Asn1Info.cmcStatus = pInfo->dwStatus;
    if (pInfo->cBodyList) {
        Asn1Info.bodyList.count = pInfo->cBodyList;
        Asn1Info.bodyList.value = pInfo->rgdwBodyList;
    }

    if (pInfo->pwszStatusString && L'\0' != *pInfo->pwszStatusString) {
        Asn1Info.bit_mask |= statusString_present;
        Asn1Info.statusString.length = (DWORD)wcslen(pInfo->pwszStatusString);
        Asn1Info.statusString.value = pInfo->pwszStatusString;
    }

    if (CMC_OTHER_INFO_NO_CHOICE != pInfo->dwOtherInfoChoice) {
        Asn1Info.bit_mask |= otherInfo_present;

        switch (pInfo->dwOtherInfoChoice) {
            case CMC_OTHER_INFO_FAIL_CHOICE:
                Asn1Info.otherInfo.choice = failInfo_chosen;
                Asn1Info.otherInfo.u.failInfo = pInfo->dwFailInfo;
                break;
            case CMC_OTHER_INFO_PEND_CHOICE:
                Asn1Info.otherInfo.choice = pendInfo_chosen;
                Asn1X509SetOctetString(&pInfo->pPendInfo->PendToken,
                    &Asn1Info.otherInfo.u.pendInfo.pendToken);
                if (!PkiAsn1ToGeneralizedTime(
                        &pInfo->pPendInfo->PendTime,
                        &Asn1Info.otherInfo.u.pendInfo.pendTime))
                    goto GeneralizedTimeError;
                break;
            default:
                goto InvalidOtherInfoChoiceError;
        }
    }


    fResult = Asn1InfoEncodeEx(
        CmcStatusInfo_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

CommonReturn:
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidOtherInfoChoiceError, E_INVALIDARG)
SET_ERROR(GeneralizedTimeError, CRYPT_E_BAD_ENCODE)
}

//+-------------------------------------------------------------------------
//  CMC Status Decode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcStatusDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA /*pDecodePara*/,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    CmcStatusInfo *pAsn1 = (CmcStatusInfo *) pvAsn1Info;
    PCMC_STATUS_INFO pInfo = (PCMC_STATUS_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    LONG lAlignExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CMC_STATUS_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CMC_STATUS_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CMC_STATUS_INFO);

        pInfo->dwStatus = pAsn1->cmcStatus;
    }

    if (pAsn1->bodyList.count > 0) {
        ASN1uint32_t count = pAsn1->bodyList.count;

        lAlignExtra = INFO_LEN_ALIGN(count * sizeof(DWORD));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            BodyPartID *value;
            DWORD *pdwBodyList;

            value = pAsn1->bodyList.value;
            pdwBodyList = (DWORD *) pbExtra;
            pbExtra += lAlignExtra;

            pInfo->cBodyList = count;
            pInfo->rgdwBodyList = pdwBodyList;

            for ( ; count > 0; count--, value++, pdwBodyList++)
                *pdwBodyList = *value;
        }
    }


    if (pAsn1->bit_mask & statusString_present) {
        ASN1uint32_t length = pAsn1->statusString.length;

        lAlignExtra = INFO_LEN_ALIGN((length + 1) * sizeof(WCHAR));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            memcpy(pbExtra, pAsn1->statusString.value, length * sizeof(WCHAR));
            memset(pbExtra + (length * sizeof(WCHAR)), 0, sizeof(WCHAR));

            pInfo->pwszStatusString = (LPWSTR) pbExtra;
            pbExtra += lAlignExtra;
        }
    }

    if (pAsn1->bit_mask & otherInfo_present) {
        switch (pAsn1->otherInfo.choice) {
            case failInfo_chosen:
                if (lRemainExtra >= 0) {
                    pInfo->dwOtherInfoChoice = CMC_OTHER_INFO_FAIL_CHOICE;
                    pInfo->dwFailInfo = pAsn1->otherInfo.u.failInfo;
                }
                break;
            case pendInfo_chosen:
                {
                    PCMC_PEND_INFO pPendInfo;

                    lAlignExtra = INFO_LEN_ALIGN(sizeof(CMC_PEND_INFO));
                    lRemainExtra -= lAlignExtra;
                    if (lRemainExtra >= 0) {
                        pInfo->dwOtherInfoChoice = CMC_OTHER_INFO_PEND_CHOICE;
                        pPendInfo = (PCMC_PEND_INFO) pbExtra;
                        pInfo->pPendInfo = pPendInfo;
                        pbExtra += lAlignExtra;

                        if (!PkiAsn1FromGeneralizedTime(
                                &pAsn1->otherInfo.u.pendInfo.pendTime,
                                &pPendInfo->PendTime))
                            goto GeneralizedTimeDecodeError;
                    } else
                        pPendInfo = NULL;

                    Asn1X509GetOctetString(
                        &pAsn1->otherInfo.u.pendInfo.pendToken, dwFlags,
                        &pPendInfo->PendToken, &pbExtra, &lRemainExtra);
                }
                break;
            default:
                goto InvalidOtherInfoChoiceError;
        }
    }

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidOtherInfoChoiceError, CRYPT_E_BAD_ENCODE)
SET_ERROR(GeneralizedTimeDecodeError, CRYPT_E_BAD_ENCODE)
}

BOOL WINAPI Asn1CmcStatusDecodeEx(
        IN DWORD /*dwCertEncodingType*/,
        IN LPCSTR /*lpszStructType*/,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        CmcStatusInfo_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1CmcStatusDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  CMC Add Extensions Encode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcAddExtensionsEncodeEx(
        IN DWORD /*dwCertEncodingType*/,
        IN LPCSTR /*lpszStructType*/,
        IN PCMC_ADD_EXTENSIONS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CmcAddExtensions Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    Asn1Info.pkiDataReference = pInfo->dwCmcDataReference;
    if (pInfo->cCertReference) {
        Asn1Info.certReferences.count = pInfo->cCertReference;
        Asn1Info.certReferences.value = pInfo->rgdwCertReference;
    }

    if (!Asn1X509SetExtensions(pInfo->cExtension, pInfo->rgExtension,
            &Asn1Info.extensions))
        goto ErrorReturn;

    fResult = Asn1InfoEncodeEx(
        CmcAddExtensions_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

CommonReturn:
    Asn1X509FreeExtensions(&Asn1Info.extensions);
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  CMC Add Extensions Decode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcAddExtensionsDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA /*pDecodePara*/,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    CmcAddExtensions *pAsn1 = (CmcAddExtensions *) pvAsn1Info;
    PCMC_ADD_EXTENSIONS_INFO pInfo = (PCMC_ADD_EXTENSIONS_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    LONG lAlignExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CMC_ADD_EXTENSIONS_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CMC_ADD_EXTENSIONS_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CMC_ADD_EXTENSIONS_INFO);

        pInfo->dwCmcDataReference = pAsn1->pkiDataReference;
    }

    if (pAsn1->certReferences.count > 0) {
        ASN1uint32_t count = pAsn1->certReferences.count;

        lAlignExtra = INFO_LEN_ALIGN(count * sizeof(DWORD));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            BodyPartID *value;
            DWORD *pdwCertReference;

            value = pAsn1->certReferences.value;
            pdwCertReference = (DWORD *) pbExtra;
            pbExtra += lAlignExtra;

            pInfo->cCertReference = count;
            pInfo->rgdwCertReference = pdwCertReference;

            for ( ; count > 0; count--, value++, pdwCertReference++)
                *pdwCertReference = *value;
        }
    }

    Asn1X509GetExtensions(&pAsn1->extensions, dwFlags,
        &pInfo->cExtension, &pInfo->rgExtension, &pbExtra, &lRemainExtra);

    fResult = TRUE;
    *plRemainExtra = lRemainExtra;
    return fResult;
}

BOOL WINAPI Asn1CmcAddExtensionsDecodeEx(
        IN DWORD /*dwCertEncodingType*/,
        IN LPCSTR /*lpszStructType*/,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        CmcAddExtensions_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1CmcAddExtensionsDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  CMC Add Attributes Encode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcAddAttributesEncodeEx(
        IN DWORD /*dwCertEncodingType*/,
        IN LPCSTR /*lpszStructType*/,
        IN PCMC_ADD_ATTRIBUTES_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CmcAddAttributes Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    Asn1Info.pkiDataReference = pInfo->dwCmcDataReference;
    if (pInfo->cCertReference) {
        Asn1Info.certReferences.count = pInfo->cCertReference;
        Asn1Info.certReferences.value = pInfo->rgdwCertReference;
    }

    if (!Asn1X509SetAttributes(pInfo->cAttribute, pInfo->rgAttribute,
            &Asn1Info.attributes))
        goto ErrorReturn;

    fResult = Asn1InfoEncodeEx(
        CmcAddAttributes_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

CommonReturn:
    Asn1X509FreeAttributes(&Asn1Info.attributes);
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  CMC Add Attributes Decode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcAddAttributesDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA /*pDecodePara*/,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    CmcAddAttributes *pAsn1 = (CmcAddAttributes *) pvAsn1Info;
    PCMC_ADD_ATTRIBUTES_INFO pInfo = (PCMC_ADD_ATTRIBUTES_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    LONG lAlignExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CMC_ADD_ATTRIBUTES_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CMC_ADD_ATTRIBUTES_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CMC_ADD_ATTRIBUTES_INFO);

        pInfo->dwCmcDataReference = pAsn1->pkiDataReference;
    }

    if (pAsn1->certReferences.count > 0) {
        ASN1uint32_t count = pAsn1->certReferences.count;

        lAlignExtra = INFO_LEN_ALIGN(count * sizeof(DWORD));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            BodyPartID *value;
            DWORD *pdwCertReference;

            value = pAsn1->certReferences.value;
            pdwCertReference = (DWORD *) pbExtra;
            pbExtra += lAlignExtra;

            pInfo->cCertReference = count;
            pInfo->rgdwCertReference = pdwCertReference;

            for ( ; count > 0; count--, value++, pdwCertReference++)
                *pdwCertReference = *value;
        }
    }

    Asn1X509GetAttributes(&pAsn1->attributes, dwFlags,
        &pInfo->cAttribute, &pInfo->rgAttribute, &pbExtra, &lRemainExtra);

    fResult = TRUE;
    *plRemainExtra = lRemainExtra;
    return fResult;
}

BOOL WINAPI Asn1CmcAddAttributesDecodeEx(
        IN DWORD /*dwCertEncodingType*/,
        IN LPCSTR /*lpszStructType*/,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        CmcAddAttributes_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1CmcAddAttributesDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certperf\certctr.h ===
//
//  certctr.h
//
//  Offset definition file for exensible counter objects and counters
//
//  These "relative" offsets must start at 0 and be multiples of 2 (i.e.
//  even numbers). In the Open Procedure, they will be added to the 
//  "First Counter" and "First Help" values fo the device they belong to, 
//  in order to determine the  absolute location of the counter and 
//  object names and corresponding help text in the registry.
//
//  this file is used by the extensible counter DLL code as well as the 
//  counter name and help text definition file (.INI) file that is used
//  by LODCTR to load the names into the registry.
//
#define CERT_OBJ                                    0
#define CERT_CHAIN_CNT                              2
#define CERT_CHAIN_ELEMENT_CNT                      4
#define CERT_CHAIN_ENGINE_CURRENT_CNT               6
#define CERT_CHAIN_ENGINE_TOTAL_CNT                 8
#define CERT_CHAIN_ENGINE_RESYNC_CNT                10
#define CERT_CHAIN_CERT_CACHE_CNT                   12
#define CERT_CHAIN_CTL_CACHE_CNT                    14
#define CERT_CHAIN_END_CERT_IN_CACHE_CNT            16
#define CERT_CHAIN_CACHE_END_CERT_CNT               18
#define CERT_CHAIN_REVOCATION_CNT                   20
#define CERT_CHAIN_REVOKED_CNT                      22
#define CERT_CHAIN_REVOCATION_OFFLINE_CNT           24
#define CERT_CHAIN_NO_REVOCATION_CHECK_CNT          26
#define CERT_CHAIN_VERIFY_CERT_SIGNATURE_CNT        28
#define CERT_CHAIN_COMPARE_ISSUER_PUBLIC_KEY_CNT    30
#define CERT_CHAIN_VERIFY_CTL_SIGNATURE_CNT         32
#define CERT_CHAIN_BEEN_VERIFIED_CTL_SIGNATURE_CNT  34
#define CERT_CHAIN_URL_ISSUER_CNT                   36
#define CERT_CHAIN_CACHE_ONLY_URL_ISSUER_CNT        38
#define CERT_CHAIN_REQUESTED_ENGINE_RESYNC_CNT      40
#define CERT_CHANGE_NOTIFY_CNT                      42
#define CERT_CHANGE_NOTIFY_LM_GP_CNT                44
#define CERT_CHANGE_NOTIFY_CU_GP_CNT                46
#define CERT_CHANGE_NOTIFY_CU_MY_CNT                48
#define CERT_CHANGE_NOTIFY_REG_CNT                  50
#define CERT_STORE_CURRENT_CNT                      52
#define CERT_STORE_TOTAL_CNT                        54
#define CERT_STORE_REG_CURRENT_CNT                  56
#define CERT_STORE_REG_TOTAL_CNT                    58
#define CERT_REG_ELEMENT_READ_CNT                   60
#define CERT_REG_ELEMENT_WRITE_CNT                  62
#define CERT_REG_ELEMENT_DELETE_CNT                 64
#define CERT_CERT_ELEMENT_CURRENT_CNT               66
#define CERT_CERT_ELEMENT_TOTAL_CNT                 68
#define CERT_CRL_ELEMENT_CURRENT_CNT                70
#define CERT_CRL_ELEMENT_TOTAL_CNT                  72
#define CERT_CTL_ELEMENT_CURRENT_CNT                74
#define CERT_CTL_ELEMENT_TOTAL_CNT                  76
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certperf\certperf.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       certperf.cpp
//
//  Contents:   Certificate Performance Counter Functions
//
//  Functions:
//              OpenCertPerformanceData
//              CollectCertPerformanceData
//              CloseCertPerformanceData
//              CertPerfDllMain
//
//              CertPerfGetCertificateChainBefore
//              CertPerfGetCertificateChainAfter
//
//  History:    04-May-99    philh   created
//--------------------------------------------------------------------------


#include "global.hxx"
#include <dbgdef.h>

#ifdef STATIC
#undef STATIC
#endif
#define STATIC

#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))


#define CERT_PERF_REGPATH                   \
            L"SYSTEM\\CurrentControlSet\\Services\\crypt32\\Performance"

#define CERT_PERF_SHARED_MEMORY_FILE_NAME       \
            L"crypt32CertPerfFile"
#define CERT_PERF_SHARED_MEMORY_MUTEX_NAME      \
            L"crypt32CertPerfMutex"

#define CERT_PERF_TS_GLOBAL_PREFIX              \
            L"Global\\"
#define CERT_PERF_TS_SHARED_MEMORY_FILE_NAME    \
        CERT_PERF_TS_GLOBAL_PREFIX CERT_PERF_SHARED_MEMORY_FILE_NAME
#define CERT_PERF_TS_SHARED_MEMORY_MUTEX_NAME    \
        CERT_PERF_TS_GLOBAL_PREFIX CERT_PERF_SHARED_MEMORY_MUTEX_NAME



#define CERT_PERF_SHARED_MEMORY_MUTEX_TIMEOUT   ((DWORD) 5000L)
#define CERT_PERF_MAX_PROCESS_NAME_LEN      32
#define CERT_PERF_MAX_PROCESS_CNT           50

#include <pshpack8.h>


// Note, a dwIndex >= CERT_PERF_MAX_PROCESS_CNT indicates an empty or
// the end of a list
typedef struct _CERT_PERF_PROCESS_DATA {
    DWORD           dwNextIndex;
    DWORD           dwPrevIndex;
    DWORD           dwProcessId;
    DWORD           dwReserved;
    WCHAR           wcszProcessName[CERT_PERF_MAX_PROCESS_NAME_LEN];
    CERT_PERF_PROCESS_COUNTERS Counters;
} CERT_PERF_PROCESS_DATA, *PCERT_PERF_PROCESS_DATA;

typedef struct _CERT_PERF_SHARED_MEMORY {
    DWORD                   dwProcessCnt;
    DWORD                   dwFirstInUseIndex;
    DWORD                   dwFirstFreeIndex;
    DWORD                   dwReserved;
    CERT_PERF_PROCESS_DATA  rgProcessData[CERT_PERF_MAX_PROCESS_CNT];
} CERT_PERF_SHARED_MEMORY, *PCERT_PERF_SHARED_MEMORY;


//  Certificate performance counters
typedef struct _CERT_PERF_DATA_DEFINITION {
    PERF_OBJECT_TYPE            ObjectType;
    PERF_COUNTER_DEFINITION     ChainCnt;
    PERF_COUNTER_DEFINITION     ChainElementCnt;
    PERF_COUNTER_DEFINITION     ChainEngineCurrentCnt;
    PERF_COUNTER_DEFINITION     ChainEngineTotalCnt;
    PERF_COUNTER_DEFINITION     ChainEngineResyncCnt;
    PERF_COUNTER_DEFINITION     ChainCertCacheCnt;
    PERF_COUNTER_DEFINITION     ChainCtlCacheCnt;
    PERF_COUNTER_DEFINITION     ChainEndCertInCacheCnt;
    PERF_COUNTER_DEFINITION     ChainCacheEndCertCnt;
    PERF_COUNTER_DEFINITION     ChainRevocationCnt;
    PERF_COUNTER_DEFINITION     ChainRevokedCnt;
    PERF_COUNTER_DEFINITION     ChainRevocationOfflineCnt;
    PERF_COUNTER_DEFINITION     ChainNoRevocationCheckCnt;
    PERF_COUNTER_DEFINITION     ChainVerifyCertSignatureCnt;
    PERF_COUNTER_DEFINITION     ChainCompareIssuerPublicKeyCnt;
    PERF_COUNTER_DEFINITION     ChainVerifyCtlSignatureCnt;
    PERF_COUNTER_DEFINITION     ChainBeenVerifiedCtlSignatureCnt;
    PERF_COUNTER_DEFINITION     ChainUrlIssuerCnt;
    PERF_COUNTER_DEFINITION     ChainCacheOnlyUrlIssuerCnt;
    PERF_COUNTER_DEFINITION     ChainRequestedEngineResyncCnt;
    PERF_COUNTER_DEFINITION     ChangeNotifyCnt;
    PERF_COUNTER_DEFINITION     ChangeNotifyLmGpCnt;
    PERF_COUNTER_DEFINITION     ChangeNotifyCuGpCnt;
    PERF_COUNTER_DEFINITION     ChangeNotifyCuMyCnt;
    PERF_COUNTER_DEFINITION     ChangeNotifyRegCnt;
    PERF_COUNTER_DEFINITION     StoreCurrentCnt;
    PERF_COUNTER_DEFINITION     StoreTotalCnt;
    PERF_COUNTER_DEFINITION     StoreRegCurrentCnt;
    PERF_COUNTER_DEFINITION     StoreRegTotalCnt;
    PERF_COUNTER_DEFINITION     RegElementReadCnt;
    PERF_COUNTER_DEFINITION     RegElementWriteCnt;
    PERF_COUNTER_DEFINITION     RegElementDeleteCnt;
    PERF_COUNTER_DEFINITION     CertElementCurrentCnt;
    PERF_COUNTER_DEFINITION     CertElementTotalCnt;
    PERF_COUNTER_DEFINITION     CrlElementCurrentCnt;
    PERF_COUNTER_DEFINITION     CrlElementTotalCnt;
    PERF_COUNTER_DEFINITION     CtlElementCurrentCnt;
    PERF_COUNTER_DEFINITION     CtlElementTotalCnt;


    //--###  Add New Counters  ###--
} CERT_PERF_DATA_DEFINITION, *PCERT_PERF_DATA_DEFINITION;

typedef struct _CERT_PERF_COUNTERS {
    PERF_COUNTER_BLOCK          CounterBlock;
    DWORD                       dwChainCnt;
    DWORD                       dwChainElementCnt;
    DWORD                       dwChainEngineCurrentCnt;
    DWORD                       dwChainEngineTotalCnt;
    DWORD                       dwChainEngineResyncCnt;
    DWORD                       dwChainCertCacheCnt;
    DWORD                       dwChainCtlCacheCnt;
    DWORD                       dwChainEndCertInCacheCnt;
    DWORD                       dwChainCacheEndCertCnt;
    DWORD                       dwChainRevocationCnt;
    DWORD                       dwChainRevokedCnt;
    DWORD                       dwChainRevocationOfflineCnt;
    DWORD                       dwChainNoRevocationCheckCnt;
    DWORD                       dwChainVerifyCertSignatureCnt;
    DWORD                       dwChainCompareIssuerPublicKeyCnt;
    DWORD                       dwChainVerifyCtlSignatureCnt;
    DWORD                       dwChainBeenVerifiedCtlSignatureCnt;
    DWORD                       dwChainUrlIssuerCnt;
    DWORD                       dwChainCacheOnlyUrlIssuerCnt;
    DWORD                       dwChainRequestedEngineResyncCnt;
    DWORD                       dwChangeNotifyCnt;
    DWORD                       dwChangeNotifyLmGpCnt;
    DWORD                       dwChangeNotifyCuGpCnt;
    DWORD                       dwChangeNotifyCuMyCnt;
    DWORD                       dwChangeNotifyRegCnt;
    DWORD                       dwStoreCurrentCnt;
    DWORD                       dwStoreTotalCnt;
    DWORD                       dwStoreRegCurrentCnt;
    DWORD                       dwStoreRegTotalCnt;
    DWORD                       dwRegElementReadCnt;
    DWORD                       dwRegElementWriteCnt;
    DWORD                       dwRegElementDeleteCnt;
    DWORD                       dwCertElementCurrentCnt;
    DWORD                       dwCertElementTotalCnt;
    DWORD                       dwCrlElementCurrentCnt;
    DWORD                       dwCrlElementTotalCnt;
    DWORD                       dwCtlElementCurrentCnt;
    DWORD                       dwCtlElementTotalCnt;

    //--###  Add New Counters  ###--
} CERT_PERF_COUNTERS, *PCERT_PERF_COUNTERS;

#include <poppack.h>


//+----------------------------------------------------------------------
// The following are set at DLL_PROCESS_ATTACH if certperf.reg has been
// regedit'ed and certperf.ini has been lodctr'ed. Otherwise, they remain
// NULL.
//-----------------------------------------------------------------------
HANDLE hCertPerfSharedMemoryMutex;
HANDLE hCertPerfSharedMemoryFile;
PCERT_PERF_SHARED_MEMORY pCertPerfSharedMemory;
PCERT_PERF_PROCESS_DATA pCertPerfProcessData;
PCERT_PERF_PROCESS_COUNTERS pCertPerfProcessCounters;

// Always initialized
CRITICAL_SECTION CertPerfProcessCriticalSection;

#define IMPURE  0

CERT_PERF_DATA_DEFINITION CertPerfDataDefinition = {
    // PERF_OBJECT_TYPE ObjectType
    {
        IMPURE,             // TotalByteLength
        sizeof(CERT_PERF_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        IMPURE,             // ObjectNameTitleIndex: dwFirstCounter + CERT_OBJ
        0,
        IMPURE,             // ObjectHelpTitleIndex: dwFirstHelp + CERT_OBJ
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(CERT_PERF_DATA_DEFINITION) - sizeof(PERF_OBJECT_TYPE))/
            sizeof(PERF_COUNTER_DEFINITION),
        0,  // ChainCnt is the default counter
        IMPURE,             // NumInstances
        0,  // unicode instance names
        {0,0},
        {0,0}
    },

    // 0 - PERF_COUNTER_DEFINITION ChainCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainCnt),
    },

    // 1 - PERF_COUNTER_DEFINITION ChainElementCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainElementCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainElementCnt),
    },

    // 2 - PERF_COUNTER_DEFINITION ChainEngineCurrentCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainEngineCurrentCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainEngineCurrentCnt),
    },

    // 3 - PERF_COUNTER_DEFINITION ChainEngineTotalCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainEngineTotalCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainEngineTotalCnt),
    },

    // 4 - PERF_COUNTER_DEFINITION ChainEngineResyncCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainEngineResyncCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainEngineResyncCnt),
    },

    // 5 - PERF_COUNTER_DEFINITION ChainCertCacheCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainCertCacheCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainCertCacheCnt),
    },

    // 6 - PERF_COUNTER_DEFINITION ChainCtlCacheCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainCtlCacheCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainCtlCacheCnt),
    },

    // 7 - PERF_COUNTER_DEFINITION ChainEndCertInCacheCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainEndCertInCacheCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainEndCertInCacheCnt),
    },

    // 8 - PERF_COUNTER_DEFINITION ChainCacheEndCertCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainCacheEndCertCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainCacheEndCertCnt),
    },

    // 9 - PERF_COUNTER_DEFINITION ChainRevocationCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainRevocationCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainRevocationCnt),
    },

    // 10 - PERF_COUNTER_DEFINITION ChainRevokedCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainRevokedCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainRevokedCnt),
    },

    // 11 - PERF_COUNTER_DEFINITION ChainRevocationOfflineCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainRevocationOfflineCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainRevocationOfflineCnt),
    },

    // 12 - PERF_COUNTER_DEFINITION ChainNoRevocationCheckCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainNoRevocationCheckCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainNoRevocationCheckCnt),
    },

    // 13 - PERF_COUNTER_DEFINITION ChainVerifyCertSignatureCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainVerifyCertSignatureCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainVerifyCertSignatureCnt),
    },

    // 14 - PERF_COUNTER_DEFINITION ChainCompareIssuerPublicKeyCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainCompareIssuerPublicKeyCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainCompareIssuerPublicKeyCnt),
    },

    // 15 - PERF_COUNTER_DEFINITION ChainVerifyCtlSignatureCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainVerifyCtlSignatureCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainVerifyCtlSignatureCnt),
    },

    // 16 - PERF_COUNTER_DEFINITION ChainBeenVerifiedCtlSignatureCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainBeenVerifiedCtlSignatureCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainBeenVerifiedCtlSignatureCnt),
    },

    // 17 - PERF_COUNTER_DEFINITION ChainUrlIssuerCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainUrlIssuerCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainUrlIssuerCnt),
    },

    // 18 - PERF_COUNTER_DEFINITION ChainCacheOnlyUrlIssuerCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainCacheOnlyUrlIssuerCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainCacheOnlyUrlIssuerCnt),
    },

    // 19 - PERF_COUNTER_DEFINITION ChainRequestedEngineResyncCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainRequestedEngineResyncCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainRequestedEngineResyncCnt),
    },

    // 20 - PERF_COUNTER_DEFINITION ChangeNotifyCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChangeNotifyCnt),
        offsetof(CERT_PERF_COUNTERS, dwChangeNotifyCnt),
    },

    // 21 - PERF_COUNTER_DEFINITION ChangeNotifyLmGpCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChangeNotifyLmGpCnt),
        offsetof(CERT_PERF_COUNTERS, dwChangeNotifyLmGpCnt),
    },

    // 22 - PERF_COUNTER_DEFINITION ChangeNotifyCuGpCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChangeNotifyCuGpCnt),
        offsetof(CERT_PERF_COUNTERS, dwChangeNotifyCuGpCnt),
    },

    // 23 - PERF_COUNTER_DEFINITION ChangeNotifyCuMyCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChangeNotifyCuMyCnt),
        offsetof(CERT_PERF_COUNTERS, dwChangeNotifyCuMyCnt),
    },

    // 24 - PERF_COUNTER_DEFINITION ChangeNotifyRegCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChangeNotifyRegCnt),
        offsetof(CERT_PERF_COUNTERS, dwChangeNotifyRegCnt),
    },

    // 25 - PERF_COUNTER_DEFINITION StoreCurrentCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwStoreCurrentCnt),
        offsetof(CERT_PERF_COUNTERS, dwStoreCurrentCnt),
    },

    // 26 - PERF_COUNTER_DEFINITION StoreTotalCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwStoreTotalCnt),
        offsetof(CERT_PERF_COUNTERS, dwStoreTotalCnt),
    },

    // 27 - PERF_COUNTER_DEFINITION StoreRegCurrentCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwStoreRegCurrentCnt),
        offsetof(CERT_PERF_COUNTERS, dwStoreRegCurrentCnt),
    },

    // 28 - PERF_COUNTER_DEFINITION StoreRegTotalCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwStoreRegTotalCnt),
        offsetof(CERT_PERF_COUNTERS, dwStoreRegTotalCnt),
    },

    // 29 - PERF_COUNTER_DEFINITION RegElementReadCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwRegElementReadCnt),
        offsetof(CERT_PERF_COUNTERS, dwRegElementReadCnt),
    },

    // 30 - PERF_COUNTER_DEFINITION RegElementWriteCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwRegElementWriteCnt),
        offsetof(CERT_PERF_COUNTERS, dwRegElementWriteCnt),
    },

    // 31 - PERF_COUNTER_DEFINITION RegElementDeleteCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwRegElementDeleteCnt),
        offsetof(CERT_PERF_COUNTERS, dwRegElementDeleteCnt),
    },

    // 32 - PERF_COUNTER_DEFINITION CertElementCurrentCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwCertElementCurrentCnt),
        offsetof(CERT_PERF_COUNTERS, dwCertElementCurrentCnt),
    },

    // 33 - PERF_COUNTER_DEFINITION CertElementTotalCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwCertElementTotalCnt),
        offsetof(CERT_PERF_COUNTERS, dwCertElementTotalCnt),
    },

    // 34 - PERF_COUNTER_DEFINITION CrlElementCurrentCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwCrlElementCurrentCnt),
        offsetof(CERT_PERF_COUNTERS, dwCrlElementCurrentCnt),
    },

    // 35 - PERF_COUNTER_DEFINITION CrlElementTotalCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwCrlElementTotalCnt),
        offsetof(CERT_PERF_COUNTERS, dwCrlElementTotalCnt),
    },

    // 36 - PERF_COUNTER_DEFINITION CtlElementCurrentCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwCtlElementCurrentCnt),
        offsetof(CERT_PERF_COUNTERS, dwCtlElementCurrentCnt),
    },

    // 37 - PERF_COUNTER_DEFINITION CtlElementTotalCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwCtlElementTotalCnt),
        offsetof(CERT_PERF_COUNTERS, dwCtlElementTotalCnt),
    },


    //--###  Add New Counters  ###--
};


STATIC
BOOL
I_CertPerfSetNameAndHelpIndices()
{
    BOOL fResult;
    HKEY hKey = NULL;
    DWORD dwType;
    DWORD cbValue;
    DWORD dwFirstCounter;
    DWORD dwFirstHelp;

    if (!FIsWinNT())
        return FALSE;

    if (ERROR_SUCCESS != RegOpenKeyExW(
            HKEY_LOCAL_MACHINE,
            CERT_PERF_REGPATH,
            0,                      // dwReserved
            KEY_READ,
            &hKey))
        goto ErrorReturn;

    cbValue = sizeof(DWORD);
    if (ERROR_SUCCESS != RegQueryValueExW(
            hKey,
            L"First Counter",
            NULL,       // pdwReserved
            &dwType,
            (PBYTE) &dwFirstCounter,
            &cbValue))
        goto ErrorReturn;
    cbValue = sizeof(DWORD);
    if (ERROR_SUCCESS != RegQueryValueExW(
            hKey,
            L"First Help",
            NULL,       // pdwReserved
            &dwType,
            (PBYTE) &dwFirstHelp,
            &cbValue))
        goto ErrorReturn;


    // Update CertPerfDataDefinitions' counter and help name indices
    CertPerfDataDefinition.ObjectType.ObjectNameTitleIndex =
        dwFirstCounter + CERT_OBJ;
    CertPerfDataDefinition.ObjectType.ObjectHelpTitleIndex =
        dwFirstHelp + CERT_OBJ;

    CertPerfDataDefinition.ChainCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_CNT;
    CertPerfDataDefinition.ChainCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_CNT;

    CertPerfDataDefinition.ChainElementCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_ELEMENT_CNT;
    CertPerfDataDefinition.ChainElementCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_ELEMENT_CNT;

    CertPerfDataDefinition.ChainEngineCurrentCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_ENGINE_CURRENT_CNT;
    CertPerfDataDefinition.ChainEngineCurrentCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_ENGINE_CURRENT_CNT;

    CertPerfDataDefinition.ChainEngineTotalCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_ENGINE_TOTAL_CNT;
    CertPerfDataDefinition.ChainEngineTotalCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_ENGINE_TOTAL_CNT;

    CertPerfDataDefinition.ChainEngineResyncCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_ENGINE_RESYNC_CNT;
    CertPerfDataDefinition.ChainEngineResyncCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_ENGINE_RESYNC_CNT;

    CertPerfDataDefinition.ChainCertCacheCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_CERT_CACHE_CNT;
    CertPerfDataDefinition.ChainCertCacheCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_CERT_CACHE_CNT;

    CertPerfDataDefinition.ChainCtlCacheCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_CTL_CACHE_CNT;
    CertPerfDataDefinition.ChainCtlCacheCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_CTL_CACHE_CNT;

    CertPerfDataDefinition.ChainEndCertInCacheCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_END_CERT_IN_CACHE_CNT;
    CertPerfDataDefinition.ChainEndCertInCacheCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_END_CERT_IN_CACHE_CNT;

    CertPerfDataDefinition.ChainCacheEndCertCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_CACHE_END_CERT_CNT;
    CertPerfDataDefinition.ChainCacheEndCertCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_CACHE_END_CERT_CNT;

    CertPerfDataDefinition.ChainRevocationCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_REVOCATION_CNT;
    CertPerfDataDefinition.ChainRevocationCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_REVOCATION_CNT;

    CertPerfDataDefinition.ChainRevokedCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_REVOKED_CNT;
    CertPerfDataDefinition.ChainRevokedCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_REVOKED_CNT;

    CertPerfDataDefinition.ChainRevocationOfflineCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_REVOCATION_OFFLINE_CNT;
    CertPerfDataDefinition.ChainRevocationOfflineCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_REVOCATION_OFFLINE_CNT;

    CertPerfDataDefinition.ChainNoRevocationCheckCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_NO_REVOCATION_CHECK_CNT;
    CertPerfDataDefinition.ChainNoRevocationCheckCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_NO_REVOCATION_CHECK_CNT;

    CertPerfDataDefinition.ChainVerifyCertSignatureCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_VERIFY_CERT_SIGNATURE_CNT;
    CertPerfDataDefinition.ChainVerifyCertSignatureCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_VERIFY_CERT_SIGNATURE_CNT;

    CertPerfDataDefinition.ChainCompareIssuerPublicKeyCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_COMPARE_ISSUER_PUBLIC_KEY_CNT;
    CertPerfDataDefinition.ChainCompareIssuerPublicKeyCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_COMPARE_ISSUER_PUBLIC_KEY_CNT;

    CertPerfDataDefinition.ChainVerifyCtlSignatureCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_VERIFY_CTL_SIGNATURE_CNT;
    CertPerfDataDefinition.ChainVerifyCtlSignatureCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_VERIFY_CTL_SIGNATURE_CNT;

    CertPerfDataDefinition.ChainBeenVerifiedCtlSignatureCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_BEEN_VERIFIED_CTL_SIGNATURE_CNT;
    CertPerfDataDefinition.ChainBeenVerifiedCtlSignatureCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_BEEN_VERIFIED_CTL_SIGNATURE_CNT;

    CertPerfDataDefinition.ChainUrlIssuerCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_URL_ISSUER_CNT;
    CertPerfDataDefinition.ChainUrlIssuerCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_URL_ISSUER_CNT;

    CertPerfDataDefinition.ChainCacheOnlyUrlIssuerCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_CACHE_ONLY_URL_ISSUER_CNT;
    CertPerfDataDefinition.ChainCacheOnlyUrlIssuerCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_CACHE_ONLY_URL_ISSUER_CNT;

    CertPerfDataDefinition.ChainRequestedEngineResyncCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_REQUESTED_ENGINE_RESYNC_CNT;
    CertPerfDataDefinition.ChainRequestedEngineResyncCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_REQUESTED_ENGINE_RESYNC_CNT;

    CertPerfDataDefinition.ChangeNotifyCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHANGE_NOTIFY_CNT;
    CertPerfDataDefinition.ChangeNotifyCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHANGE_NOTIFY_CNT;

    CertPerfDataDefinition.ChangeNotifyLmGpCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHANGE_NOTIFY_LM_GP_CNT;
    CertPerfDataDefinition.ChangeNotifyLmGpCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHANGE_NOTIFY_LM_GP_CNT;

    CertPerfDataDefinition.ChangeNotifyCuGpCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHANGE_NOTIFY_CU_GP_CNT;
    CertPerfDataDefinition.ChangeNotifyCuGpCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHANGE_NOTIFY_CU_GP_CNT;

    CertPerfDataDefinition.ChangeNotifyCuMyCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHANGE_NOTIFY_CU_MY_CNT;
    CertPerfDataDefinition.ChangeNotifyCuMyCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHANGE_NOTIFY_CU_MY_CNT;

    CertPerfDataDefinition.ChangeNotifyRegCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHANGE_NOTIFY_REG_CNT;
    CertPerfDataDefinition.ChangeNotifyRegCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHANGE_NOTIFY_REG_CNT;

    CertPerfDataDefinition.StoreCurrentCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_STORE_CURRENT_CNT;
    CertPerfDataDefinition.StoreCurrentCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_STORE_CURRENT_CNT;

    CertPerfDataDefinition.StoreTotalCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_STORE_TOTAL_CNT;
    CertPerfDataDefinition.StoreTotalCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_STORE_TOTAL_CNT;

    CertPerfDataDefinition.StoreRegCurrentCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_STORE_REG_CURRENT_CNT;
    CertPerfDataDefinition.StoreRegCurrentCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_STORE_REG_CURRENT_CNT;

    CertPerfDataDefinition.StoreRegTotalCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_STORE_REG_TOTAL_CNT;
    CertPerfDataDefinition.StoreRegTotalCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_STORE_REG_TOTAL_CNT;

    CertPerfDataDefinition.RegElementReadCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_REG_ELEMENT_READ_CNT;
    CertPerfDataDefinition.RegElementReadCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_REG_ELEMENT_READ_CNT;

    CertPerfDataDefinition.RegElementWriteCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_REG_ELEMENT_WRITE_CNT;
    CertPerfDataDefinition.RegElementWriteCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_REG_ELEMENT_WRITE_CNT;

    CertPerfDataDefinition.RegElementDeleteCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_REG_ELEMENT_DELETE_CNT;
    CertPerfDataDefinition.RegElementDeleteCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_REG_ELEMENT_DELETE_CNT;

    CertPerfDataDefinition.CertElementCurrentCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CERT_ELEMENT_CURRENT_CNT;
    CertPerfDataDefinition.CertElementCurrentCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CERT_ELEMENT_CURRENT_CNT;

    CertPerfDataDefinition.CertElementTotalCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CERT_ELEMENT_TOTAL_CNT;
    CertPerfDataDefinition.CertElementTotalCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CERT_ELEMENT_TOTAL_CNT;

    CertPerfDataDefinition.CrlElementCurrentCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CRL_ELEMENT_CURRENT_CNT;
    CertPerfDataDefinition.CrlElementCurrentCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CRL_ELEMENT_CURRENT_CNT;

    CertPerfDataDefinition.CrlElementTotalCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CRL_ELEMENT_TOTAL_CNT;
    CertPerfDataDefinition.CrlElementTotalCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CRL_ELEMENT_TOTAL_CNT;

    CertPerfDataDefinition.CtlElementCurrentCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CTL_ELEMENT_CURRENT_CNT;
    CertPerfDataDefinition.CtlElementCurrentCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CTL_ELEMENT_CURRENT_CNT;

    CertPerfDataDefinition.CtlElementTotalCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CTL_ELEMENT_TOTAL_CNT;
    CertPerfDataDefinition.CtlElementTotalCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CTL_ELEMENT_TOTAL_CNT;

    //--###  Add New Counters  ###--

    fResult = TRUE;

CommonReturn:
    if (hKey)
        RegCloseKey(hKey);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

STATIC
void
I_CertPerfGetProcessName(
    OUT WCHAR wcszProcessName[CERT_PERF_MAX_PROCESS_NAME_LEN]
    )
{
    WCHAR wszModule[MAX_PATH + 1];
    LPWSTR pwsz;
    LPWSTR pwszSlash;
    LPWSTR pwszPeriod;
    WCHAR wc;
    DWORD cchProcessName;

    wszModule[MAX_PATH] = L'\0';
    if (0 == GetModuleFileNameW(NULL, wszModule, MAX_PATH))
        goto GetModuleFileNameError;

    // Go from beginning to end and find last backslash and
    // last period in name
    pwszPeriod = NULL;
    pwszSlash = NULL;
    for (pwsz = wszModule; L'\0' != (wc = *pwsz); pwsz++) {
        if (L'\\' == wc)
            pwszSlash = pwsz;
        else if (L'.' == wc)
            pwszPeriod = pwsz;
    }

    // If present, the process name is between the last \ and the last period.
    // Otherwise, between beginning and/or end of entire module name
    if (pwszSlash)
        pwszSlash++;
    else
        pwszSlash = wszModule;

    if (NULL == pwszPeriod)
        pwszPeriod = pwsz;

    if (pwszSlash >= pwszPeriod)
        goto InvalidModuleName;
    cchProcessName = (DWORD) (pwszPeriod - pwszSlash);
    if (cchProcessName > (CERT_PERF_MAX_PROCESS_NAME_LEN - 1))
        cchProcessName = CERT_PERF_MAX_PROCESS_NAME_LEN - 1;

    memcpy(wcszProcessName, pwszSlash, cchProcessName * sizeof(WCHAR));
    wcszProcessName[cchProcessName] = L'\0';

CommonReturn:
    return;
ErrorReturn:
    wcscpy(wcszProcessName, L"???");
    goto CommonReturn;
TRACE_ERROR(GetModuleFileNameError)
TRACE_ERROR(InvalidModuleName)
}

// The returnd ACL must be freed via PkiFree()
STATIC
PACL
CreateEveryoneAcl(
    IN DWORD dwAccessMask
    )
{
    DWORD dwLastErr = 0;
    PACL pEveryoneAcl = NULL;
    PSID psidEveryone = NULL;
    DWORD dwAclSize;

    SID_IDENTIFIER_AUTHORITY siaWorldSidAuthority =
        SECURITY_WORLD_SID_AUTHORITY;

    if (!AllocateAndInitializeSid(
            &siaWorldSidAuthority,
            1,
            SECURITY_WORLD_RID,
            0, 0, 0, 0, 0, 0, 0,
            &psidEveryone
            ))
        goto AllocateAndInitializeSidError;

    //
    // compute size of ACL
    //
    dwAclSize =
        sizeof(ACL) +
        ( sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) ) +
        GetLengthSid(psidEveryone);

    //
    // allocate storage for Acl
    //
    if (NULL == (pEveryoneAcl = (PACL) PkiNonzeroAlloc(dwAclSize)))
        goto OutOfMemory;

    if (!InitializeAcl(pEveryoneAcl, dwAclSize, ACL_REVISION))
        goto InitializeAclError;

    if (!AddAccessAllowedAce(
            pEveryoneAcl,
            ACL_REVISION,
            dwAccessMask,
            psidEveryone
            ))
        goto AddAceError;

CommonReturn:
    if (psidEveryone)
        FreeSid(psidEveryone);
    if (dwLastErr)
        SetLastError(dwLastErr);

    return pEveryoneAcl;

ErrorReturn:
    dwLastErr = GetLastError();
    if (pEveryoneAcl) {
        PkiFree(pEveryoneAcl);
        pEveryoneAcl = NULL;
    }
    goto CommonReturn;

TRACE_ERROR(AllocateAndInitializeSidError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(InitializeAclError)
TRACE_ERROR(AddAceError)
}

STATIC
BOOL
InitializeSecurityDescriptorAndAttributes(
    IN PACL pAcl,
    OUT SECURITY_DESCRIPTOR *psd,
    OUT SECURITY_ATTRIBUTES *psa
    )
{
    BOOL fResult;

    if (!InitializeSecurityDescriptor(psd, SECURITY_DESCRIPTOR_REVISION))
        goto InitializeSecurityDescriptorError;
    if (!SetSecurityDescriptorDacl(psd, TRUE, pAcl, FALSE))
        goto SetSecurityDescriptorDaclError;

    psa->nLength = sizeof(SECURITY_ATTRIBUTES);
    psa->lpSecurityDescriptor = psd;
    psa->bInheritHandle = FALSE;

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(InitializeSecurityDescriptorError)
TRACE_ERROR(SetSecurityDescriptorDaclError)
}

STATIC
HANDLE
CreateMutexWithSynchronizeAccess(
    IN LPWSTR pwszMutexName
    )
{
    HANDLE hMutex = NULL;
    PACL pEveryoneAcl = NULL;
    SECURITY_DESCRIPTOR sd;
    SECURITY_ATTRIBUTES sa;
    DWORD i;

    if (NULL == (pEveryoneAcl = CreateEveryoneAcl(SYNCHRONIZE)))
        goto CreateEveryoneAclError;
    if (!InitializeSecurityDescriptorAndAttributes(pEveryoneAcl, &sd, &sa))
        goto InitializeSecurityDescriptorAndAttributesError;

    // Retry a couple of times. There is a small window between the
    // CreateMutex and OpenMutex where the mutex is deleted.
    for (i = 0; i < 5; i++) {
        hMutex = CreateMutexU(
            &sa,
            FALSE,      // fInitialOwner
            pwszMutexName
            );
        if (NULL != hMutex)
            goto CommonReturn;

        hMutex = OpenMutexU(
            SYNCHRONIZE,
            FALSE,      // bInheritHandle
            pwszMutexName
            );
        if (NULL != hMutex) {
            SetLastError(ERROR_ALREADY_EXISTS);
            goto CommonReturn;
        }

        if (ERROR_FILE_NOT_FOUND != GetLastError())
            break;
    }

    assert(NULL == hMutex);
    goto OpenMutexError;

CommonReturn:
    if (pEveryoneAcl)
        PkiFree(pEveryoneAcl);

    return hMutex;

ErrorReturn:
    assert(NULL == hMutex);
    goto CommonReturn;

TRACE_ERROR(CreateEveryoneAclError)
TRACE_ERROR(InitializeSecurityDescriptorAndAttributesError)
TRACE_ERROR(OpenMutexError)
}

STATIC
HANDLE
CreateFileMappingWithWriteAccess(
    IN DWORD dwMaximumSizeLow,
    IN LPWSTR pwszFileName
    )
{
    HANDLE hFile = NULL;
    PACL pEveryoneAcl = NULL;
    SECURITY_DESCRIPTOR sd;
    SECURITY_ATTRIBUTES sa;
    DWORD i;

    if (NULL == (pEveryoneAcl = CreateEveryoneAcl(FILE_MAP_WRITE)))
        goto CreateEveryoneAclError;
    if (!InitializeSecurityDescriptorAndAttributes(pEveryoneAcl, &sd, &sa))
        goto InitializeSecurityDescriptorAndAttributesError;

    // Retry a couple of times. There is a small window between the
    // CreateFileMapping and OpenFileMapping where the file is closed.
    for (i = 0; i < 5; i++) {
        hFile = CreateFileMappingW(
            INVALID_HANDLE_VALUE,
            &sa,
            PAGE_READWRITE,
            0,                  // dwMaximumSizeHigh
            dwMaximumSizeLow,
            pwszFileName
            );

        if (NULL != hFile)
            goto CommonReturn;

        hFile = OpenFileMappingW(
            FILE_MAP_WRITE,
            FALSE,      // bInheritHandle
            pwszFileName
            );
        if (NULL != hFile) {
            SetLastError(ERROR_ALREADY_EXISTS);
            goto CommonReturn;
        }

        if (ERROR_FILE_NOT_FOUND != GetLastError())
            break;
    }

    assert(NULL == hFile);
    goto OpenFileError;

CommonReturn:
    if (pEveryoneAcl)
        PkiFree(pEveryoneAcl);

    return hFile;

ErrorReturn:
    assert(NULL == hFile);
    goto CommonReturn;

TRACE_ERROR(CreateEveryoneAclError)
TRACE_ERROR(InitializeSecurityDescriptorAndAttributesError)
TRACE_ERROR(OpenFileError)
}

STATIC
void
I_CertPerfGetSharedMemory()
{
    DWORD dwFileMappingStatus;
    BOOL fReleaseMutex = FALSE;
    DWORD dwIndex;
    DWORD dwNextIndex;
    BOOL fTerminalServerGlobalName;

    if (!I_CertPerfSetNameAndHelpIndices())
        return;

    // First try with W2K Terminal Server "Global\" prefix
    if (NULL == (hCertPerfSharedMemoryMutex = CreateMutexWithSynchronizeAccess(
            CERT_PERF_TS_SHARED_MEMORY_MUTEX_NAME
            ))) {
        if (NULL == (hCertPerfSharedMemoryMutex =
                CreateMutexWithSynchronizeAccess(
                    CERT_PERF_SHARED_MEMORY_MUTEX_NAME
                    )))
            goto CreateMutexError;
        else
            fTerminalServerGlobalName = FALSE;
    } else
        fTerminalServerGlobalName = TRUE;
    if (WAIT_OBJECT_0 != WaitForSingleObject(
            hCertPerfSharedMemoryMutex,
            CERT_PERF_SHARED_MEMORY_MUTEX_TIMEOUT
            ))
        goto WaitForMutexError;
    else
        fReleaseMutex = TRUE;

    if (NULL == (hCertPerfSharedMemoryFile = CreateFileMappingWithWriteAccess(
            sizeof(CERT_PERF_SHARED_MEMORY),
            fTerminalServerGlobalName ?
                CERT_PERF_TS_SHARED_MEMORY_FILE_NAME :
                CERT_PERF_SHARED_MEMORY_FILE_NAME
            )))
        goto CreateFileMappingError;
    dwFileMappingStatus = GetLastError();

    if (NULL == (pCertPerfSharedMemory =
           (PCERT_PERF_SHARED_MEMORY) MapViewOfFile(
                hCertPerfSharedMemoryFile,
                FILE_MAP_WRITE,
                0,                  // dwOffsetHigh
                0,                  // dwOffsetLow
                sizeof(CERT_PERF_SHARED_MEMORY)
                )))
        goto MapViewOfFileError;

    if (ERROR_ALREADY_EXISTS != dwFileMappingStatus) {
        DWORD i;

        assert(ERROR_SUCCESS == dwFileMappingStatus);

        // Need to initialize the shared memory
        memset(pCertPerfSharedMemory, 0, sizeof(CERT_PERF_SHARED_MEMORY));

        // Create linked list of process free elements.
        //
        // Only need forward indices for the free list
        for (i = 0; i < CERT_PERF_MAX_PROCESS_CNT; i++) {
            // An index >= CERT_PERF_MAX_PROCESS_CNT indicates end of list
            pCertPerfSharedMemory->rgProcessData[i].dwNextIndex = i + 1;

        }
        pCertPerfSharedMemory->dwFirstFreeIndex = 0;

        // An index >= CERT_PERF_MAX_PROCESS_CNT indicates an empty list
        pCertPerfSharedMemory->dwFirstInUseIndex = CERT_PERF_MAX_PROCESS_CNT;
    }

    if (CERT_PERF_MAX_PROCESS_CNT <=
            (dwIndex = pCertPerfSharedMemory->dwFirstFreeIndex))
        goto OutOfSharedMemoryProcessData;
    pCertPerfProcessData = &pCertPerfSharedMemory->rgProcessData[dwIndex];

    // Remove process data element from the free list
    pCertPerfSharedMemory->dwFirstFreeIndex =
        pCertPerfProcessData->dwNextIndex;

    // Add process data element to the in use list
    dwNextIndex = pCertPerfSharedMemory->dwFirstInUseIndex;
    if (CERT_PERF_MAX_PROCESS_CNT > dwNextIndex)
        pCertPerfSharedMemory->rgProcessData[dwNextIndex].dwPrevIndex =
            dwIndex;
    pCertPerfProcessData->dwNextIndex = dwNextIndex;
    pCertPerfProcessData->dwPrevIndex = CERT_PERF_MAX_PROCESS_CNT;
    pCertPerfSharedMemory->dwFirstInUseIndex = dwIndex;
    pCertPerfSharedMemory->dwProcessCnt++;

    pCertPerfProcessData->dwProcessId = GetCurrentProcessId();
    I_CertPerfGetProcessName(pCertPerfProcessData->wcszProcessName);
    memset(&pCertPerfProcessData->Counters, 0,
        sizeof(pCertPerfProcessData->Counters));

    ReleaseMutex(hCertPerfSharedMemoryMutex);

    pCertPerfProcessCounters = &pCertPerfProcessData->Counters;

CommonReturn:
    return;

ErrorReturn:
    assert(NULL == pCertPerfProcessData);

    if (pCertPerfSharedMemory) {
        UnmapViewOfFile(pCertPerfSharedMemory);
        pCertPerfSharedMemory = NULL;
    }

    if (hCertPerfSharedMemoryFile) {
        CloseHandle(hCertPerfSharedMemoryFile);
        hCertPerfSharedMemoryFile = NULL;
    }

    if (hCertPerfSharedMemoryMutex) {
        if (fReleaseMutex)
            ReleaseMutex(hCertPerfSharedMemoryMutex);

        CloseHandle(hCertPerfSharedMemoryMutex);
        hCertPerfSharedMemoryMutex = NULL;
    }
    goto CommonReturn;

TRACE_ERROR(CreateMutexError)
TRACE_ERROR(WaitForMutexError)
TRACE_ERROR(CreateFileMappingError)
TRACE_ERROR(MapViewOfFileError)
TRACE_ERROR(OutOfSharedMemoryProcessData)
}


STATIC
void
I_CertPerfFreeSharedMemory()
{
    if (NULL == pCertPerfProcessData)
        return;

    pCertPerfProcessData->dwProcessId = 0;
    if (WAIT_OBJECT_0 == WaitForSingleObject(
            hCertPerfSharedMemoryMutex,
            CERT_PERF_SHARED_MEMORY_MUTEX_TIMEOUT
            )) {
        DWORD dwIndex;
        DWORD dwPrevIndex;
        DWORD dwNextIndex;

        // Remove process data element from the in use list
        dwIndex = (DWORD)(pCertPerfProcessData -
            pCertPerfSharedMemory->rgProcessData);
        assert(CERT_PERF_MAX_PROCESS_CNT > dwIndex);

        dwPrevIndex = pCertPerfProcessData->dwPrevIndex;
        dwNextIndex = pCertPerfProcessData->dwNextIndex;

        if (CERT_PERF_MAX_PROCESS_CNT > dwNextIndex)
            pCertPerfSharedMemory->rgProcessData[dwNextIndex].dwPrevIndex =
                dwPrevIndex;
        if (CERT_PERF_MAX_PROCESS_CNT > dwPrevIndex)
            pCertPerfSharedMemory->rgProcessData[dwPrevIndex].dwNextIndex =
                dwNextIndex;
        else
            pCertPerfSharedMemory->dwFirstInUseIndex = dwNextIndex;


        if (pCertPerfSharedMemory->dwProcessCnt)
            pCertPerfSharedMemory->dwProcessCnt--;

        // Add to the free list
        pCertPerfProcessData->dwNextIndex =
            pCertPerfSharedMemory->dwFirstFreeIndex;
        pCertPerfSharedMemory->dwFirstFreeIndex = dwIndex;

        ReleaseMutex(hCertPerfSharedMemoryMutex);
    }

    assert(pCertPerfSharedMemory);
    UnmapViewOfFile(pCertPerfSharedMemory);
    pCertPerfSharedMemory = NULL;

    assert(hCertPerfSharedMemoryFile);
    CloseHandle(hCertPerfSharedMemoryFile);
    hCertPerfSharedMemoryFile = NULL;

    assert(hCertPerfSharedMemoryMutex);
    CloseHandle(hCertPerfSharedMemoryMutex);
    hCertPerfSharedMemoryMutex = NULL;

    pCertPerfProcessCounters = NULL;
    pCertPerfProcessData = NULL;
}



BOOL
WINAPI
CertPerfDllMain(
    HMODULE hInst,
    ULONG  ulReason,
    LPVOID lpReserved
    )
{
    BOOL fRet = TRUE;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        fRet = Pki_InitializeCriticalSection(&CertPerfProcessCriticalSection);
        if (fRet)
            I_CertPerfGetSharedMemory();
        break;
    case DLL_PROCESS_DETACH:
        I_CertPerfFreeSharedMemory();
        DeleteCriticalSection(&CertPerfProcessCriticalSection);
        break;
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    return fRet;
}


//
//  Function Prototypes
//
//      these are used to insure that the data collection functions
//      accessed by Perflib will have the correct calling format.
//

PM_OPEN_PROC    OpenCertPerformanceData;
PM_COLLECT_PROC CollectCertPerformanceData;
PM_CLOSE_PROC   CloseCertPerformanceData;

DWORD
APIENTRY
OpenCertPerformanceData(
    IN LPWSTR lpDeviceNames
    )
{
    if (NULL == pCertPerfProcessData)
        return ERROR_FILE_NOT_FOUND;

    return ERROR_SUCCESS;
}

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

#define GLOBAL_STRING   L"Global"
#define FOREIGN_STRING  L"Foreign"
#define COSTLY_STRING   L"Costly"

// test for delimiter, end of line and non-digit characters
// used by I_CertPerfIsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)


DWORD
I_CertPerfGetQueryType(
     IN LPWSTR pwszValue
     )
/*++

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN pwszValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if pwszValue == 0 (null pointer)
           pwszValue == pointer to Null string
           pwszValue == pointer to "Global" string

    QUERY_FOREIGN
        if pwszValue == pointer to "Foreign" string

    QUERY_COSTLY
        if pwszValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    DWORD dwQueryType;
    if (NULL == pwszValue || L'\0' == *pwszValue ||
            0 == _wcsnicmp(pwszValue, GLOBAL_STRING, wcslen(GLOBAL_STRING)))
        dwQueryType = QUERY_GLOBAL;
    else if (0 == _wcsnicmp(pwszValue, COSTLY_STRING, wcslen(COSTLY_STRING)))
        dwQueryType = QUERY_COSTLY;
    else if (0 == _wcsnicmp(pwszValue, FOREIGN_STRING, wcslen(FOREIGN_STRING)))
        dwQueryType = QUERY_FOREIGN;
    else
        dwQueryType = QUERY_ITEMS;

    return dwQueryType;
}

BOOL
I_CertPerfIsNumberInUnicodeList (
                      IN DWORD   dwNumber,
                      IN LPWSTR  lpwszUnicodeList
                      )
/*++

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
   DWORD   dwThisNumber;
   WCHAR   *pwcThisChar;
   BOOL    bValidNumber;
   BOOL    bNewItem;
   WCHAR   wcDelimiter;    // could be an argument to be more flexible

   if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not found

   pwcThisChar = lpwszUnicodeList;
   dwThisNumber = 0;
   wcDelimiter = (WCHAR)' ';
   bValidNumber = FALSE;
   bNewItem = TRUE;

   while (TRUE)
   {
      switch (EvalThisChar (*pwcThisChar, wcDelimiter))
      {
      case DIGIT:
         // if this is the first digit after a delimiter, then
         // set flags to start computing the new number
         if (bNewItem)
         {
            bNewItem = FALSE;
            bValidNumber = TRUE;
         }
         if (bValidNumber)
         {
            dwThisNumber *= 10;
            dwThisNumber += (*pwcThisChar - (WCHAR)'0');
         }
         break;

      case DELIMITER:
         // a delimter is either the delimiter character or the
         // end of the string ('\0') if when the delimiter has been
         // reached a valid number was found, then compare it to the
         // number from the argument list. if this is the end of the
         // string and no match was found, then return.
         //
         if (bValidNumber)
         {
            if (dwThisNumber == dwNumber) return TRUE;
            bValidNumber = FALSE;
         }
         if (*pwcThisChar == 0)
         {
            return FALSE;
         }
         else
         {
            bNewItem = TRUE;
            dwThisNumber = 0;
         }
         break;

      case INVALID:
         // if an invalid character was encountered, ignore all
         // characters up to the next delimiter and then start fresh.
         // the invalid number is not compared.
         bValidNumber = FALSE;
         break;

      default:
         break;

      }
      pwcThisChar++;
   }

    return FALSE;
}

DWORD
APIENTRY
CollectCertPerformanceData(
    IN      LPWSTR  pwszValueName,
    IN OUT  LPVOID  *ppvData,
    IN OUT  LPDWORD pcbTotalBytes,
    IN OUT  LPDWORD pNumObjectTypes
    )
{
    DWORD dwErr = ERROR_SUCCESS;
    BOOL fReleaseMutex = FALSE;
    PCERT_PERF_DATA_DEFINITION pDataDef;
    PERF_INSTANCE_DEFINITION *pInstanceDef;
    DWORD cbNeededBytes;
    DWORD dwProcessCnt;
    DWORD dwInUseIndex;
    LONG NumInstances;
    DWORD dwQueryType;

    if (NULL == pCertPerfProcessData)
        goto NoProcessDataError;

    dwQueryType = I_CertPerfGetQueryType(pwszValueName);
    if (QUERY_FOREIGN == dwQueryType)
        goto ForeignQueryNotSupported;

    if (QUERY_ITEMS == dwQueryType) {
        if (!(I_CertPerfIsNumberInUnicodeList(
                CertPerfDataDefinition.ObjectType.ObjectNameTitleIndex,
                pwszValueName)))
            goto ObjectTypeQueryNotSupported;
    }

    if (WAIT_OBJECT_0 != WaitForSingleObject(
            hCertPerfSharedMemoryMutex,
            CERT_PERF_SHARED_MEMORY_MUTEX_TIMEOUT
            ))
        goto WaitForMutexError;
    else
        fReleaseMutex = TRUE;

    pDataDef = (PCERT_PERF_DATA_DEFINITION) *ppvData;

    // always return an "instance sized" buffer after the definition blocks
    // to prevent perfmon from reading bogus data. This is strictly a hack
    // to accomodate how PERFMON handles the "0" instance case.
    // By doing this, perfmon won't choke when there are no instances
    // and the counter object & counters will be displayed in the
    // list boxes, even though no instances will be listed.

    dwProcessCnt = pCertPerfSharedMemory->dwProcessCnt;
    if (CERT_PERF_MAX_PROCESS_CNT < dwProcessCnt)
        goto InvalidProcessData;

    cbNeededBytes = (DWORD)( sizeof(CERT_PERF_DATA_DEFINITION) +
        (dwProcessCnt > 0 ? dwProcessCnt : 1 ) * (
            sizeof(PERF_INSTANCE_DEFINITION) +
            CERT_PERF_MAX_PROCESS_NAME_LEN +
            sizeof(CERT_PERF_COUNTERS)) );
    if (*pcbTotalBytes < cbNeededBytes) {
        dwErr = ERROR_MORE_DATA;
        goto MoreDataError;
    }

    // copy the object & counter definition information
    memcpy(pDataDef, &CertPerfDataDefinition,
        sizeof(CERT_PERF_DATA_DEFINITION));

    // Update the instance data for each InUse process.
    pInstanceDef = (PERF_INSTANCE_DEFINITION *) &pDataDef[1];
    dwInUseIndex = pCertPerfSharedMemory->dwFirstInUseIndex;
    NumInstances = 0;
    while (NumInstances < (LONG) dwProcessCnt &&
            CERT_PERF_MAX_PROCESS_CNT > dwInUseIndex) {
        PCERT_PERF_PROCESS_DATA pInUseData;
        PCERT_PERF_COUNTERS pCtr;
        DWORD cchProcessName;
        DWORD NameLength;
        DWORD ByteLength;

        pInUseData = &pCertPerfSharedMemory->rgProcessData[dwInUseIndex];
        dwInUseIndex = pInUseData->dwNextIndex;

        if (0 == pInUseData->dwProcessId)
            continue;

        // The following is updated for each InUse process:
        //  - PERF_INSTANCE_DEFINITION
        //  - wcszProcessName
        //  - optional padding for DWORD alignment
        //  - CERT_PERF_COUNTERS

        // Get process name and instance definition byte lengths
        for (cchProcessName = 0;
                cchProcessName < CERT_PERF_MAX_PROCESS_NAME_LEN &&
                    L'\0' != pInUseData->wcszProcessName[cchProcessName];
                                        cchProcessName++)
            ;
        if (CERT_PERF_MAX_PROCESS_NAME_LEN <= cchProcessName)
            goto InvalidProcessData;

        // Include trailing null in name length
        NameLength = cchProcessName * sizeof(WCHAR) + sizeof(WCHAR);
        ByteLength = sizeof(PERF_INSTANCE_DEFINITION) +
            DWORD_MULTIPLE(NameLength);


        // Update the instance definition fields
        pInstanceDef->ByteLength = ByteLength;
        pInstanceDef->ParentObjectTitleIndex = 0;   // no parent
        pInstanceDef->ParentObjectInstance = 0;     // "    "
        pInstanceDef->UniqueID = PERF_NO_UNIQUE_ID;
        pInstanceDef->NameOffset = sizeof(PERF_INSTANCE_DEFINITION);
        pInstanceDef->NameLength = NameLength;

        // Update the process name that immediately follows the
        // instance definition
        memcpy(&pInstanceDef[1], pInUseData->wcszProcessName,
            NameLength);

        // Update the performance counters immediately following the
        // above process name. Note, start of counters is DWORD aligned
        pCtr = (PCERT_PERF_COUNTERS) (((PBYTE) pInstanceDef) + ByteLength);
        pCtr->CounterBlock.ByteLength = sizeof(CERT_PERF_COUNTERS);
        pCtr->dwChainCnt = (DWORD) pInUseData->Counters.lChainCnt;
        pCtr->dwChainElementCnt = (DWORD) pInUseData->Counters.lChainElementCnt;
        pCtr->dwChainEngineCurrentCnt =
            (DWORD) pInUseData->Counters.lChainEngineCurrentCnt;
        pCtr->dwChainEngineTotalCnt =
            (DWORD) pInUseData->Counters.lChainEngineTotalCnt;
        pCtr->dwChainEngineResyncCnt =
            (DWORD) pInUseData->Counters.lChainEngineResyncCnt;
        pCtr->dwChainCertCacheCnt =
            (DWORD) pInUseData->Counters.lChainCertCacheCnt;
        pCtr->dwChainCtlCacheCnt =
            (DWORD) pInUseData->Counters.lChainCtlCacheCnt;
        pCtr->dwChainEndCertInCacheCnt =
            (DWORD) pInUseData->Counters.lChainEndCertInCacheCnt;
        pCtr->dwChainCacheEndCertCnt =
            (DWORD) pInUseData->Counters.lChainCacheEndCertCnt;
        pCtr->dwChainRevocationCnt =
            (DWORD) pInUseData->Counters.lChainRevocationCnt;
        pCtr->dwChainRevokedCnt =
            (DWORD) pInUseData->Counters.lChainRevokedCnt;
        pCtr->dwChainRevocationOfflineCnt =
            (DWORD) pInUseData->Counters.lChainRevocationOfflineCnt;
        pCtr->dwChainNoRevocationCheckCnt =
            (DWORD) pInUseData->Counters.lChainNoRevocationCheckCnt;
        pCtr->dwChainVerifyCertSignatureCnt =
            (DWORD) pInUseData->Counters.lChainVerifyCertSignatureCnt;
        pCtr->dwChainCompareIssuerPublicKeyCnt =
            (DWORD) pInUseData->Counters.lChainCompareIssuerPublicKeyCnt;
        pCtr->dwChainVerifyCtlSignatureCnt =
            (DWORD) pInUseData->Counters.lChainVerifyCtlSignatureCnt;
        pCtr->dwChainBeenVerifiedCtlSignatureCnt =
            (DWORD) pInUseData->Counters.lChainBeenVerifiedCtlSignatureCnt;
        pCtr->dwChainUrlIssuerCnt =
            (DWORD) pInUseData->Counters.lChainUrlIssuerCnt;
        pCtr->dwChainCacheOnlyUrlIssuerCnt =
            (DWORD) pInUseData->Counters.lChainCacheOnlyUrlIssuerCnt;
        pCtr->dwChainRequestedEngineResyncCnt =
            (DWORD) pInUseData->Counters.lChainRequestedEngineResyncCnt;
        pCtr->dwChangeNotifyCnt =
            (DWORD) pInUseData->Counters.lChangeNotifyCnt;
        pCtr->dwChangeNotifyLmGpCnt =
            (DWORD) pInUseData->Counters.lChangeNotifyLmGpCnt;
        pCtr->dwChangeNotifyCuGpCnt =
            (DWORD) pInUseData->Counters.lChangeNotifyCuGpCnt;
        pCtr->dwChangeNotifyCuMyCnt =
            (DWORD) pInUseData->Counters.lChangeNotifyCuMyCnt;
        pCtr->dwChangeNotifyRegCnt =
            (DWORD) pInUseData->Counters.lChangeNotifyRegCnt;
        pCtr->dwStoreCurrentCnt =
            (DWORD) pInUseData->Counters.lStoreCurrentCnt;
        pCtr->dwStoreTotalCnt =
            (DWORD) pInUseData->Counters.lStoreTotalCnt;
        pCtr->dwStoreRegCurrentCnt =
            (DWORD) pInUseData->Counters.lStoreRegCurrentCnt;
        pCtr->dwStoreRegTotalCnt =
            (DWORD) pInUseData->Counters.lStoreRegTotalCnt;
        pCtr->dwRegElementReadCnt =
            (DWORD) pInUseData->Counters.lRegElementReadCnt;
        pCtr->dwRegElementWriteCnt =
            (DWORD) pInUseData->Counters.lRegElementWriteCnt;
        pCtr->dwRegElementDeleteCnt =
            (DWORD) pInUseData->Counters.lRegElementDeleteCnt;
        pCtr->dwCertElementCurrentCnt =
            (DWORD) pInUseData->Counters.lCertElementCurrentCnt;
        pCtr->dwCertElementTotalCnt =
            (DWORD) pInUseData->Counters.lCertElementTotalCnt;
        pCtr->dwCrlElementCurrentCnt =
            (DWORD) pInUseData->Counters.lCrlElementCurrentCnt;
        pCtr->dwCrlElementTotalCnt =
            (DWORD) pInUseData->Counters.lCrlElementTotalCnt;
        pCtr->dwCtlElementCurrentCnt =
            (DWORD) pInUseData->Counters.lCtlElementCurrentCnt;
        pCtr->dwCtlElementTotalCnt =
            (DWORD) pInUseData->Counters.lCtlElementTotalCnt;


        //--###  Add New Counters  ###--

        NumInstances++;

        // setup for the next instance
        // Next instance starts immediately after the counters
        pInstanceDef = (PERF_INSTANCE_DEFINITION *) &pCtr[1];
    }

    if (0 == NumInstances) {
        // zero fill one instance sized block of data if there are no
        // data instances

        memset(pInstanceDef, 0, sizeof(PERF_INSTANCE_DEFINITION) +
            CERT_PERF_MAX_PROCESS_NAME_LEN +
            sizeof(CERT_PERF_COUNTERS));

        // Advance past the zero'ed instance
        pInstanceDef = (PERF_INSTANCE_DEFINITION *) ((PBYTE) pInstanceDef +
            sizeof(PERF_INSTANCE_DEFINITION) +
            CERT_PERF_MAX_PROCESS_NAME_LEN +
            sizeof(CERT_PERF_COUNTERS));
    }

    // update arguments for return
    *ppvData = (LPVOID) pInstanceDef;
    *pNumObjectTypes = 1;

    pDataDef->ObjectType.NumInstances = NumInstances;
    pDataDef->ObjectType.TotalByteLength = *pcbTotalBytes =
        (DWORD)((PBYTE) pInstanceDef - (PBYTE) pDataDef);

    assert(*pcbTotalBytes <= cbNeededBytes);


CommonReturn:
    if (fReleaseMutex)
        ReleaseMutex(hCertPerfSharedMemoryMutex);
    return dwErr;
ErrorReturn:
    *pcbTotalBytes = 0;
    *pNumObjectTypes = 0;
    goto CommonReturn;

TRACE_ERROR(NoProcessDataError)
TRACE_ERROR(ForeignQueryNotSupported)
TRACE_ERROR(ObjectTypeQueryNotSupported)
TRACE_ERROR(WaitForMutexError)
TRACE_ERROR(InvalidProcessData)
TRACE_ERROR(MoreDataError)
}

DWORD
APIENTRY
CloseCertPerformanceData()
{
    return ERROR_SUCCESS;
}



#if 0

// Example of timing the CertGetCertificateChain API

typedef struct _CERT_PERF_CHAIN_DATA {
    union {
        SYSTEMTIME          stBefore;
        LARGE_INTEGER       liBefore;
    };
} CERT_PERF_CHAIN_DATA, *PCERT_PERF_CHAIN_DATA;


void
WINAPI
CertPerfGetCertificateChainBefore(
    OUT PCERT_PERF_CHAIN_DATA pData
    )
{
    if (pCertPerfProcessData) {
        if (fCertPerfHighFreq)
            QueryPerformanceCounter(&pData->liBefore);
        else
            GetSystemTime(&pData->stBefore);
    }
}

void
WINAPI
CertPerfGetCertificateChainAfter(
    IN PCERT_PERF_CHAIN_DATA pData,
    IN PCCERT_CHAIN_CONTEXT pChainContext
    )
{
    if (pCertPerfProcessData) {
        if (fCertPerfHighFreq) {
            LARGE_INTEGER liAfter;
            _int64 i64DeltaTime;

            QueryPerformanceCounter(&liAfter);
            i64DeltaTime = liAfter.QuadPart - pData->liBefore.QuadPart;

            EnterCriticalSection(&CertPerfProcessCriticalSection);

            pCertPerfProcessData->Counters.dwChainCnt++;
            pCertPerfProcessData->Counters.i64TotalChainTime =
                pCertPerfProcessData->Counters.i64TotalChainTime +
                i64DeltaTime;

            if (0 == pCertPerfProcessData->Counters.i64MinChainTime ||
                    i64DeltaTime <
                        pCertPerfProcessData->Counters.i64MinChainTime)
                pCertPerfProcessData->Counters.i64MinChainTime =
                    i64DeltaTime;

            if (i64DeltaTime > pCertPerfProcessData->Counters.i64MaxChainTime)
                pCertPerfProcessData->Counters.i64MaxChainTime =
                    i64DeltaTime;

            LeaveCriticalSection(&CertPerfProcessCriticalSection);
        } else {
            SYSTEMTIME stAfter;
            FILETIME ftBefore;
            FILETIME ftAfter;
            _int64 i64DeltaTime;

            GetSystemTime(&stAfter);
            SystemTimeToFileTime(&pData->stBefore, &ftBefore);
            SystemTimeToFileTime(&stAfter, &ftAfter);

            i64DeltaTime = *((_int64 *) &ftAfter) - *((_int64 *) &ftBefore);

            EnterCriticalSection(&CertPerfProcessCriticalSection);

            pCertPerfProcessData->Counters.dwChainCnt++;
            pCertPerfProcessData->Counters.i64TotalChainTime =
                pCertPerfProcessData->Counters.i64TotalChainTime +
                i64DeltaTime;

            if (0 == pCertPerfProcessData->Counters.i64MinChainTime ||
                    i64DeltaTime <
                        pCertPerfProcessData->Counters.i64MinChainTime)
                pCertPerfProcessData->Counters.i64MinChainTime =
                    i64DeltaTime;

            if (i64DeltaTime > pCertPerfProcessData->Counters.i64MaxChainTime)
                pCertPerfProcessData->Counters.i64MaxChainTime =
                    i64DeltaTime;

            LeaveCriticalSection(&CertPerfProcessCriticalSection);
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certexts\certexts.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       certexts.cpp
//
//  Contents:   NTSD/WINDBG certificate extensions dll
//
//              See DECLARE_API( help ) for a list of extensions
//
//
//  Functions:  help
//              store
//              context
//              ele
//              cert
//              crl
//              ctl
//              chain
//
//  History:    06-Jun-98   philh   created
//--------------------------------------------------------------------------

#include "global.hxx"

#define MAX_HASH_LEN  20
#define SHA1_HASH_LEN 20

#define MAX_PROP_CNT            100
#define MAX_CONTEXT_CNT         1000
#define MAX_STORE_SIBLING_CNT   100
#define MAX_STORE_NEST_CNT      100

#define MAX_SIMPLE_CHAIN_CNT    50
#define MAX_CHAIN_ELEMENT_CNT   50


WINDBG_EXTENSION_APIS ExtensionApis;
HANDLE ExtensionCurrentProcess;

// Display flags
#define DISPLAY_SHORT_FLAG          0x00000001
#define DISPLAY_VERBOSE_FLAG        0x00000002
#define DISPLAY_UI_FLAG             0x00000004
#define DISPLAY_EXT_FLAG            0x00000008
#define DISPLAY_PROP_FLAG           0x00000010

// ATTENTION: the following were lifted from newstor.cpp. Should be moved
// to a shared .h file

//+-------------------------------------------------------------------------
//  Store data structure definitions
//--------------------------------------------------------------------------

// Assumes
//  0 - Certificates
//  1 - CRLs
//  2 - CTLs
#define CONTEXT_COUNT       3

typedef struct _CONTEXT_ELEMENT CONTEXT_ELEMENT, *PCONTEXT_ELEMENT;
typedef struct _PROP_ELEMENT PROP_ELEMENT, *PPROP_ELEMENT;

typedef struct _CERT_STORE CERT_STORE, *PCERT_STORE;
typedef struct _CERT_STORE_LINK CERT_STORE_LINK, *PCERT_STORE_LINK;

typedef struct _COLLECTION_STACK_ENTRY COLLECTION_STACK_ENTRY,
    *PCOLLECTION_STACK_ENTRY;

// Used to maintain collection state across context find next calls.
//
// Ref count on pStoreLink. No ref count on pCollection.
// pStoreLink may be NULL.
struct _COLLECTION_STACK_ENTRY {
    PCERT_STORE                 pCollection;
    PCERT_STORE_LINK            pStoreLink;
    PCOLLECTION_STACK_ENTRY     pPrev;
};

typedef struct _CONTEXT_CACHE_INFO {
    PPROP_ELEMENT               pPropHead;
} CONTEXT_CACHE_INFO;

typedef struct _CONTEXT_EXTERNAL_INFO {
    // For ELEMENT_FIND_NEXT_FLAG
    void                        *pvProvInfo;
} CONTEXT_EXTERNAL_INFO;

typedef struct _CONTEXT_COLLECTION_INFO {
    // For Find
    PCOLLECTION_STACK_ENTRY     pCollectionStack;
} CONTEXT_COLLECTION_INFO;

#define ELEMENT_DELETED_FLAG                    0x00010000

// Only set for external elements
#define ELEMENT_FIND_NEXT_FLAG                  0x00020000

// Set during CertCloseStore if ELEMENT_FIND_NEXT_FLAG was set.
#define ELEMENT_CLOSE_FIND_NEXT_FLAG            0x00040000

// Set if the element has a CERT_ARCHIVED_PROP_ID
#define ELEMENT_ARCHIVED_FLAG                   0x00080000

#define ELEMENT_TYPE_CACHE                      1
#define ELEMENT_TYPE_LINK_CONTEXT               2
#define ELEMENT_TYPE_EXTERNAL                   3
#define ELEMENT_TYPE_COLLECTION                 4

typedef struct _CONTEXT_NOCOPY_INFO {
    PFN_CRYPT_FREE      pfnFree;
    void                *pvFree;
} CONTEXT_NOCOPY_INFO, *PCONTEXT_NOCOPY_INFO;

// Identical contexts (having the same SHA1 hash) can share the same encoded
// byte array and decoded info data structure.
//
// CreateShareElement() creates with dwRefCnt of 1. FindShareElement() finds
// an existing and increments dwRefCnt. ReleaseShareElement() decrements
// dwRefCnt and frees when 0.
typedef struct _SHARE_ELEMENT SHARE_ELEMENT, *PSHARE_ELEMENT;
struct _SHARE_ELEMENT {
    BYTE                rgbSha1Hash[SHA1_HASH_LEN];
    DWORD               dwContextType;
    BYTE                *pbEncoded;         // allocated
    DWORD               cbEncoded;
    void                *pvInfo;            // allocated

    DWORD               dwRefCnt;
    PSHARE_ELEMENT      pNext;
    PSHARE_ELEMENT      pPrev;
};

// The CONTEXT_ELEMENT is inserted before the CERT_CONTEXT, CRL_CONTEXT or
// CTL_CONTEXT. The dwContextType used is 0 based and not 1 based. For
// example, dwContextType = CERT_STORE_CERTIFICATE_CONTEXT - 1.
struct _CONTEXT_ELEMENT {
    DWORD               dwElementType;
    DWORD               dwContextType;
    DWORD               dwFlags;
    LONG                lRefCnt;

    // For ELEMENT_TYPE_CACHE, pEle points to itself. Otherwise, pEle points
    // to the element being linked to and the pEle is addRef'ed. The
    // cached element is found by iterating through the pEle's until pEle
    // points to itself.
    PCONTEXT_ELEMENT    pEle;
    PCERT_STORE         pStore;
    PCONTEXT_ELEMENT    pNext;
    PCONTEXT_ELEMENT    pPrev;
    PCERT_STORE         pProvStore;
    PCONTEXT_NOCOPY_INFO pNoCopyInfo;

    // When nonNULL, the context's pbEncoded and pInfo aren't allocated.
    // Instead, use the shared element's pbEncoded and pInfo. When
    // context element is freed, the pSharedEle is ReleaseShareElement()'ed.
    PSHARE_ELEMENT      pShareEle;          // RefCnt'ed

    union {
        CONTEXT_CACHE_INFO      Cache;      // ELEMENT_TYPE_CACHE
        CONTEXT_EXTERNAL_INFO   External;   // ELEMENT_TYPE_EXTERNAL
        CONTEXT_COLLECTION_INFO Collection; // ELEMENT_TYPE_COLLECTION
    };
};


struct _PROP_ELEMENT {
    DWORD               dwPropId;
    DWORD               dwFlags;
    BYTE                *pbData;
    DWORD               cbData;
    PPROP_ELEMENT       pNext;
    PPROP_ELEMENT       pPrev;
};


#define STORE_LINK_DELETED_FLAG        0x00010000
struct _CERT_STORE_LINK {
    DWORD               dwFlags;
    LONG                lRefCnt;

    // Whatever is passed to CertAddStoreToCollection
    DWORD               dwUpdateFlags;
    DWORD               dwPriority;

    PCERT_STORE         pCollection;
    PCERT_STORE         pSibling;       // CertStoreDuplicate'd.
    PCERT_STORE_LINK    pNext;
    PCERT_STORE_LINK    pPrev;
};


// Store types
#define STORE_TYPE_CACHE            1
#define STORE_TYPE_EXTERNAL         2
#define STORE_TYPE_COLLECTION       3

// CACHE store may have CACHE or LINK_CONTEXT elements. Until deleted,
// the store has a reference count to.

// EXTERNAL store only has EXTERNAL elements. These elements are always
// deleted, wherein, the store doesn't hold a refCnt.

// COLLECTION store has COLLECTION elements. These elements
// are always deleted, wherein, the store doesn't hold a refCnt.


struct _CERT_STORE {
    DWORD               dwStoreType;
    LONG                lRefCnt;
    HCRYPTPROV          hCryptProv;
    DWORD               dwFlags;
    DWORD               dwState;
    CRITICAL_SECTION    CriticalSection;
    PCONTEXT_ELEMENT    rgpContextListHead[CONTEXT_COUNT];
    PCERT_STORE_LINK    pStoreListHead;                     // COLLECTION
    PPROP_ELEMENT       pPropHead;      // properties for entire store

    // For CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG
    // Incremented for each context duplicated
    LONG                lDeferCloseRefCnt;

    // Event handle set by CertControlStore(CERT_STORE_CTRL_AUTO_RESYNC)
    HANDLE              hAutoResyncEvent;

    // Store provider info
    LONG                lStoreProvRefCnt;
    HANDLE              hStoreProvWait;
    HCRYPTOIDFUNCADDR   hStoreProvFuncAddr;
    CERT_STORE_PROV_INFO StoreProvInfo;
};

//+-------------------------------------------------------------------------
//  Store states
//--------------------------------------------------------------------------
#define STORE_STATE_DELETED         0
#define STORE_STATE_NULL            1
#define STORE_STATE_OPENING         2
#define STORE_STATE_OPEN            3
#define STORE_STATE_DEFER_CLOSING   4
#define STORE_STATE_CLOSING         5
#define STORE_STATE_CLOSED          6

inline PCONTEXT_ELEMENT ToContextElement(
    IN PCCERT_CONTEXT pCertContext
    )
{
    if (pCertContext)
        return (PCONTEXT_ELEMENT)
            (((BYTE *) pCertContext) - sizeof(CONTEXT_ELEMENT));
    else
        return NULL;
}

inline PCCERT_CONTEXT ToCertContext(
    IN PCONTEXT_ELEMENT pEle
    )
{
    if (pEle)
        return (PCCERT_CONTEXT)
            (((BYTE *) pEle) + sizeof(CONTEXT_ELEMENT));
    else
        return NULL;
}


DECLARE_API( help )
{
    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if (*lpArgumentString == '\0') {
        dprintf("certexts help:\n\n");
        dprintf("!context {[s|v|u|x|p]} address - Dump cert, CRL or CTL context\n");
        dprintf("!ele {[s|v|u|x|p]} address     - Dump cert, CRL or CTL element\n");
        dprintf("!cert {[s|v|u|x|p]} address    - Dump encoded cert\n");
        dprintf("!crl {[s|v|u|x|p]} address     - Dump encoded crl\n");
        dprintf("!ctl {[s|v|u|x|p]} address     - Dump encoded ctl\n");
        dprintf("!store {[s|v|x|p]} address     - Dump certificate store\n");
        dprintf("!chain {[s|v|x|p]} address     - Dump certificate chain context\n");
        dprintf("!help [cmd]                    - Displays this list or gives details on command\n");
        dprintf("\n");
        dprintf("Options:\n");
        dprintf(" s - Short, brief display\n");
        dprintf(" v - Verbose display\n");
        dprintf(" u - UI display\n");
        dprintf(" x - Display eXtensions\n");
        dprintf(" p - Display Properties\n");
    } else {
        if (*lpArgumentString == '!')
            lpArgumentString++;
        if (strcmp(lpArgumentString, "xyz") == 0) {
            dprintf("!xyz      - Invalid command\n");
        } else {
            dprintf("Invalid command and/or no help available\n");
        }
    }
}

//+-------------------------------------------------------------------------
//  Error output routines
//--------------------------------------------------------------------------
void PrintError(LPCSTR pszMsg)
{
    dprintf("%s\n", pszMsg);
}
void PrintLastError(LPCSTR pszMsg)
{
    DWORD dwErr = GetLastError();
    dprintf("%s failed => 0x%x (%d) \n", pszMsg, dwErr, dwErr);
}

//+-------------------------------------------------------------------------
//  CertExts allocation and free routines
//--------------------------------------------------------------------------
LPVOID
WINAPI
CertExtsAlloc(
    IN UINT cbBytes
    )
{
    LPVOID pv;
    if (NULL == (pv = (LPVOID) LocalAlloc(LPTR, cbBytes))) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        PrintLastError("CertExtsAlloc");
    }
    return pv;
}

LPVOID
WINAPI
CertExtsRealloc(
    IN LPVOID pvOrg,
    IN UINT cbBytes
    )
{
    LPVOID pv;
    if (NULL == (pv = pvOrg ?
            (LPVOID) LocalReAlloc((HLOCAL)pvOrg, cbBytes, LMEM_MOVEABLE) :
            (LPVOID) LocalAlloc(NONZEROLPTR, cbBytes))) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        PrintLastError("CertExtsRealloc");
    }
    return pv;
}

VOID
WINAPI
CertExtsFree(
    IN LPVOID pv
    )
{
    if (pv)
        LocalFree((HLOCAL)pv);
}

LPCSTR FileTimeText(FILETIME *pft)
{
    static char buf[80];
    FILETIME ftLocal;
    struct tm ctm;
    SYSTEMTIME st;

    FileTimeToLocalFileTime(pft, &ftLocal);
    if (FileTimeToSystemTime(&ftLocal, &st))
    {
        ctm.tm_sec = st.wSecond;
        ctm.tm_min = st.wMinute;
        ctm.tm_hour = st.wHour;
        ctm.tm_mday = st.wDay;
        ctm.tm_mon = st.wMonth-1;
        ctm.tm_year = st.wYear-1900;
        ctm.tm_wday = st.wDayOfWeek;
        ctm.tm_yday  = 0;
        ctm.tm_isdst = 0;
        strcpy(buf, asctime(&ctm));
        buf[strlen(buf)-1] = 0;

        if (st.wMilliseconds) {
            char *pch = buf + strlen(buf);
            sprintf(pch, " <milliseconds:: %03d>", st.wMilliseconds);
        }
    }
    else
        sprintf(buf, "<FILETIME %08lX:%08lX>", pft->dwHighDateTime,
                pft->dwLowDateTime);
    return buf;
}

#define CROW 16
void PrintBytes(LPCSTR pszHdr, BYTE *pb, DWORD cbSize)
{
    ULONG cb, i;

    if (cbSize == 0) {
        dprintf("%s NO Value Bytes\n", pszHdr);
        return;
    }

    while (cbSize > 0)
    {
        dprintf("%s", pszHdr);
        cb = min(CROW, cbSize);
        cbSize -= cb;
        for (i = 0; i<cb; i++)
            dprintf(" %02X", pb[i]);
        for (i = cb; i<CROW; i++)
            dprintf("   ");
        dprintf("    '");
        for (i = 0; i<cb; i++)
            if (pb[i] >= 0x20 && pb[i] <= 0x7f)
                dprintf("%c", pb[i]);
            else
                dprintf(".");
        pb += cb;
        dprintf("'\n");
    }
}


BOOL GetEncodedBlob(
    IN LPVOID pvAddr,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    )
{
    BOOL fResult;
    BYTE rgbTagLength[6];
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded = 0;

    LONG lLen;
    DWORD cbLen;
    DWORD cbContent;
    const BYTE *pbContent;

    __try {
        memset(rgbTagLength, 0, sizeof(rgbTagLength));
        ReadMemory(pvAddr, rgbTagLength, sizeof(rgbTagLength), NULL);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        dprintf("Unable to read encoded blob at 0x%p\n", pvAddr);
        goto ErrorReturn;
    }

    lLen = Asn1UtilExtractContent(rgbTagLength, sizeof(rgbTagLength),
        &cbContent, &pbContent);
    if (lLen <= 0 || cbContent == CMSG_INDEFINITE_LENGTH) {
        dprintf("Unable to decode ASN1 tag/length at 0x%p\n", pvAddr);
        goto ErrorReturn;
    }

    cbEncoded = (DWORD)lLen + cbContent;
    if (NULL == (pbEncoded = (BYTE *) CertExtsAlloc(cbEncoded)))
        goto ErrorReturn;

    __try {
        memset(pbEncoded, 0, cbEncoded);
        ReadMemory(pvAddr, pbEncoded, cbEncoded, NULL);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        dprintf("Unable to read encoded blob at 0x%p .. 0x%p\n", pvAddr,
            ((BYTE *) pvAddr) + cbEncoded - 1);
        goto ErrorReturn;
    }

    fResult = TRUE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;

ErrorReturn:
    CertExtsFree(pbEncoded);
    pbEncoded = NULL;
    cbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
}

void DisplaySerialNumber(
    PCRYPT_INTEGER_BLOB pSerialNumber
    )
{
    DWORD cb;
    BYTE *pb;
    for (cb = pSerialNumber->cbData,
         pb = pSerialNumber->pbData + (cb - 1); cb > 0; cb--, pb--) {
        dprintf(" %02X", *pb);
    }
    dprintf("\n");
}

void DisplayThumbprint(
    LPCSTR pszHash,
    BYTE *pbHash,
    DWORD cbHash
    )
{
    dprintf("%s Thumbprint:: ", pszHash);
    if (cbHash == 0)
        dprintf("???");
    else {
        ULONG cb;

        while (cbHash > 0) {
            cb = min(4, cbHash);
            cbHash -= cb;
            for (; cb > 0; cb--, pbHash++)
                dprintf("%02X", *pbHash);
            dprintf(" ");
        }
    }
    dprintf("\n");
}

void DisplayName(
    IN PCERT_NAME_BLOB pName
    )
{
    DWORD csz;
    LPSTR psz;

    csz = CertNameToStrA(
        X509_ASN_ENCODING,
        pName,
        CERT_X500_NAME_STR + CERT_NAME_STR_REVERSE_FLAG,
        NULL,                   // psz
        0);                     // csz
    if (psz = (LPSTR) CertExtsAlloc(csz)) {
        CertNameToStrA(
            X509_ASN_ENCODING,
            pName,
            CERT_X500_NAME_STR + CERT_NAME_STR_REVERSE_FLAG,
            psz,
            csz);
        dprintf("  %s\n", psz);
        CertExtsFree(psz);
    } else
        dprintf("  ???\n");
}

//+-------------------------------------------------------------------------
//  Returns OID's name string. If not found returns L"???".
//--------------------------------------------------------------------------
LPCWSTR GetOIDName(LPCSTR pszOID, DWORD dwGroupId = 0)
{
    PCCRYPT_OID_INFO pInfo;

    if (pInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            (void *) pszOID,
            dwGroupId
            )) {
        if (L'\0' != pInfo->pwszName[0])
            return pInfo->pwszName;
    }

    return L"???";
}

ALG_ID GetAlgid(LPCSTR pszOID, DWORD dwGroupId = 0)
{
    PCCRYPT_OID_INFO pInfo;

    if (pInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            (void *) pszOID,
            dwGroupId
            ))
        return pInfo->Algid;
    return 0;
}

void PrintExtensions(
    IN DWORD cExt,
    IN PCERT_EXTENSION pExt,
    IN DWORD dwDisplayFlags
    )
{
    DWORD i;

    if (0 == (dwDisplayFlags & (DISPLAY_VERBOSE_FLAG | DISPLAY_EXT_FLAG)))
        return;

    for (i = 0; i < cExt; i++, pExt++) {
        DWORD cbFormat;

        LPSTR pszObjId = pExt->pszObjId;
        if (pszObjId == NULL)
            pszObjId = "<NULL OBJID>";
        LPSTR pszCritical = pExt->fCritical ? "TRUE" : "FALSE";
        dprintf("Extension[%d] %s (%S) Critical: %s::\n",
            i, pszObjId, GetOIDName(pszObjId), pszCritical);
        PrintBytes("    ", pExt->Value.pbData, pExt->Value.cbData);

        cbFormat = 0;
        if (CryptFormatObject(
                X509_ASN_ENCODING,
                0,                  // dwFormatType
                CRYPT_FORMAT_STR_MULTI_LINE | CRYPT_FORMAT_STR_NO_HEX,
                NULL,               // pFormatStruct,
                pszObjId,
                pExt->Value.pbData,
                pExt->Value.cbData,
                NULL,
                &cbFormat
                ) && cbFormat) {
            BYTE *pbFormat = NULL;
            if (pbFormat = (BYTE *) CertExtsAlloc(cbFormat)) {
                if (CryptFormatObject(
                        X509_ASN_ENCODING,
                        0,                  // dwFormatType
                        CRYPT_FORMAT_STR_MULTI_LINE | CRYPT_FORMAT_STR_NO_HEX,
                        NULL,               // pFormatStruct,
                        pszObjId,
                        pExt->Value.pbData,
                        pExt->Value.cbData,
                        pbFormat,
                        &cbFormat
                        )) {
                    dprintf("--- Decoded ---\n");
                    dprintf("%S\n", pbFormat);
                }

                CertExtsFree(pbFormat);
            }
        }
    }
}

typedef struct _PROP_INFO {
    DWORD       dwPropId;
    LPCSTR      pszPropName;
} PROP_INFO, *PPROP_INFO;

const PROP_INFO rgPropInfo[] = {
    CERT_KEY_PROV_HANDLE_PROP_ID, "KeyProvHandle",
    CERT_KEY_PROV_INFO_PROP_ID, "KeyProvInfo",
    CERT_SHA1_HASH_PROP_ID, "Sha1Hash",
    CERT_MD5_HASH_PROP_ID, "MD5Hash",
    CERT_KEY_CONTEXT_PROP_ID, "KeyContext",
    CERT_KEY_SPEC_PROP_ID, "KeySpec",
    CERT_IE30_RESERVED_PROP_ID, "IE30Reserved",
    CERT_PUBKEY_HASH_RESERVED_PROP_ID, "PubKeyHashReserved",
    CERT_ENHKEY_USAGE_PROP_ID, "EnhKeyUsage",
    CERT_NEXT_UPDATE_LOCATION_PROP_ID, "NextUpdateLocation",
    CERT_FRIENDLY_NAME_PROP_ID, "FriendlyName",
    CERT_PVK_FILE_PROP_ID, "PvkFile",
    CERT_DESCRIPTION_PROP_ID, "Description",
    CERT_ACCESS_STATE_PROP_ID, "AccessState",
    CERT_SIGNATURE_HASH_PROP_ID, "SignatureHash",
    CERT_SMART_CARD_DATA_PROP_ID, "SmartCartData",
    CERT_EFS_PROP_ID, "EFS",
    CERT_FORTEZZA_DATA_PROP_ID, "FortezzaData",
    CERT_ARCHIVED_PROP_ID, "Archived",
    CERT_KEY_IDENTIFIER_PROP_ID, "KeyIdentifier",
    CERT_AUTO_ENROLL_PROP_ID, "AutoEnroll",
    CERT_STORE_LOCALIZED_NAME_PROP_ID, "LocalizedName",
    0, "???"
};

LPCSTR GetPropName(
    IN DWORD dwPropId
    )
{
    const PROP_INFO *pInfo;

    for (pInfo = rgPropInfo; pInfo->dwPropId; pInfo++) {
        if (dwPropId == pInfo->dwPropId)
            return pInfo->pszPropName;
    }

    return "???";
}

void PrintProperties(
    IN PPROP_ELEMENT pProp,
    IN DWORD dwDisplayFlags
    )
{
    DWORD i;

    if (0 == (dwDisplayFlags & (DISPLAY_VERBOSE_FLAG | DISPLAY_PROP_FLAG)))
        return;

    i = 0;
    while (pProp) {
        PROP_ELEMENT Prop;

        __try {
            memset(&Prop, 0, sizeof(Prop));
            ReadMemory((LPVOID) pProp, &Prop, sizeof(Prop), NULL);
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            dprintf("Unable to read Property Element at 0x%p\n", pProp);
            goto ErrorReturn;
        }

        dprintf("PropId %ld (0x%lx) %s ::\n", Prop.dwPropId, Prop.dwPropId,
            GetPropName(Prop.dwPropId));
        if (Prop.dwFlags)
            dprintf("     Property dwFlags: 0x%lx\n", Prop.dwFlags);

        if (Prop.cbData) {
            BYTE *pbData;

            if (pbData = (BYTE *) CertExtsAlloc(Prop.cbData)) {
                __try {
                    memset(pbData, 0, Prop.cbData);
                    ReadMemory((LPVOID) Prop.pbData, pbData, Prop.cbData, NULL);
                    PrintBytes("    ", pbData, Prop.cbData);
                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    dprintf("Unable to read Property at 0x%p .. 0x%p\n",
                        Prop.pbData, Prop.pbData + Prop.cbData - 1);
                }

                CertExtsFree(pbData);
            }
        } else
            dprintf("     NO Property Bytes\n");

        pProp = Prop.pNext;
        if (i++ > MAX_PROP_CNT) {
            dprintf("Exceeded maximum prop count of %d\n", MAX_PROP_CNT);
            break;
        }
    }

CommonReturn:
    return;
ErrorReturn:
    goto CommonReturn;
}

void DisplayCert(
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwDisplayFlags
    )
{
    dprintf("Version:: %d\n", pCert->pCertInfo->dwVersion);
    dprintf("Subject::");
    DisplayName(&pCert->pCertInfo->Subject);
    dprintf("Issuer::");
    DisplayName(&pCert->pCertInfo->Issuer);
    dprintf("SerialNumber::");
    DisplaySerialNumber(&pCert->pCertInfo->SerialNumber);
    dprintf("NotBefore:: %s\n", FileTimeText(&pCert->pCertInfo->NotBefore));
    dprintf("NotAfter:: %s\n", FileTimeText(&pCert->pCertInfo->NotAfter));

    {
        BYTE rgbHash[MAX_HASH_LEN];
        DWORD cbHash = MAX_HASH_LEN;

        CertGetCertificateContextProperty(
            pCert,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &cbHash
            );
        DisplayThumbprint("SHA1", rgbHash, cbHash);
    }

    if (dwDisplayFlags & DISPLAY_VERBOSE_FLAG) {
        LPSTR pszObjId;
        ALG_ID aiPubKey;
        DWORD dwBitLen;

        pszObjId = pCert->pCertInfo->SignatureAlgorithm.pszObjId;
        if (pszObjId == NULL)
            pszObjId = "<NULL OBJID>";
        dprintf("SignatureAlgorithm:: %s (%S)\n",
            pszObjId, GetOIDName(pszObjId, CRYPT_SIGN_ALG_OID_GROUP_ID));
        if (pCert->pCertInfo->SignatureAlgorithm.Parameters.cbData) {
            dprintf("SignatureAlgorithm.Parameters::\n");
            PrintBytes("    ",
                pCert->pCertInfo->SignatureAlgorithm.Parameters.pbData,
                pCert->pCertInfo->SignatureAlgorithm.Parameters.cbData);
        }

        pszObjId = pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId;
        if (pszObjId == NULL)
            pszObjId = "<NULL OBJID>";
        dprintf("SubjectPublicKeyInfo.Algorithm:: %s (%S)\n",
            pszObjId, GetOIDName(pszObjId, CRYPT_PUBKEY_ALG_OID_GROUP_ID));
        aiPubKey = GetAlgid(pszObjId, CRYPT_PUBKEY_ALG_OID_GROUP_ID);

        if (pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData)
        {
            dprintf("SubjectPublicKeyInfo.Algorithm.Parameters::\n");
            PrintBytes("    ",
                pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.pbData,
                pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData);
        }
        dprintf("SubjectPublicKeyInfo.PublicKey");
        if (0 != (dwBitLen = CertGetPublicKeyLength(
                X509_ASN_ENCODING,
                &pCert->pCertInfo->SubjectPublicKeyInfo)))
            dprintf(" (BitLength: %d)", dwBitLen);
        if (pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cUnusedBits)
            dprintf(" (UnusedBits: %d)",
                pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cUnusedBits);
        dprintf("::\n");
        if (pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData) {
            PrintBytes("    ",
                pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
                pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData);

        } else
           dprintf("  No public key\n");
    }

    PrintExtensions(pCert->pCertInfo->cExtension,
        pCert->pCertInfo->rgExtension, dwDisplayFlags);

    if (dwDisplayFlags & DISPLAY_UI_FLAG) {
        CRYPTUI_VIEWCERTIFICATE_STRUCTW CertViewInfo;

        memset(&CertViewInfo, 0, sizeof(CertViewInfo));
        CertViewInfo.pCertContext = pCert;
        CertViewInfo.dwSize = sizeof(CertViewInfo);

        if (!CryptUIDlgViewCertificateW(
                &CertViewInfo,
                NULL                        // pfPropertiesChanged
                ))
            PrintLastError("CryptUIDlgViewCertificateW");
    }
}

void PrintCrlEntries(DWORD cEntry, PCRL_ENTRY pEntry, DWORD dwDisplayFlags)
{
    DWORD i;

    for (i = 0; i < cEntry; i++, pEntry++) {
        {
            dprintf(" [%d] SerialNumber::", i);
            DisplaySerialNumber(&pEntry->SerialNumber);
        }

        dprintf(" [%d] RevocationDate:: %s\n", i,
            FileTimeText(&pEntry->RevocationDate));

        if (dwDisplayFlags & (DISPLAY_VERBOSE_FLAG | DISPLAY_EXT_FLAG)) {
            if (pEntry->cExtension == 0)
                dprintf(" [%d] Extensions:: NONE\n", i);
            else {
                dprintf(" [%d] Extensions::\n", i);
                PrintExtensions(pEntry->cExtension, pEntry->rgExtension,
                    dwDisplayFlags);
            }
        }
    }
}

void DisplayCrl(
    IN PCCRL_CONTEXT pCrl,
    IN DWORD dwDisplayFlags
    )
{
    dprintf("Issuer::\n");
    DisplayName(&pCrl->pCrlInfo->Issuer);
    dprintf("ThisUpdate:: %s\n", FileTimeText(&pCrl->pCrlInfo->ThisUpdate));
    dprintf("NextUpdate:: %s\n", FileTimeText(&pCrl->pCrlInfo->NextUpdate));

    {
        BYTE rgbHash[MAX_HASH_LEN];
        DWORD cbHash = MAX_HASH_LEN;

        CertGetCRLContextProperty(
            pCrl,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &cbHash
            );
        DisplayThumbprint("SHA1", rgbHash, cbHash);
    }

    PrintExtensions(pCrl->pCrlInfo->cExtension, pCrl->pCrlInfo->rgExtension,
        dwDisplayFlags);

    if (dwDisplayFlags & DISPLAY_VERBOSE_FLAG) {
        if (pCrl->pCrlInfo->cCRLEntry == 0)
            dprintf("Entries:: NONE\n");
        else {
            dprintf("Entries::\n");
            PrintCrlEntries(pCrl->pCrlInfo->cCRLEntry,
                pCrl->pCrlInfo->rgCRLEntry, dwDisplayFlags);
        }
    }

    if (dwDisplayFlags & DISPLAY_UI_FLAG) {
        CRYPTUI_VIEWCRL_STRUCTW CrlViewInfo;

        memset(&CrlViewInfo, 0, sizeof(CrlViewInfo));
        CrlViewInfo.pCRLContext = pCrl;
        CrlViewInfo.dwSize = sizeof(CrlViewInfo);

        if (!CryptUIDlgViewCRLW(
                &CrlViewInfo
                ))
            PrintLastError("CryptUIDlgViewCRLW");
    }
}

static void PrintCtlEntries(
    IN PCCTL_CONTEXT pCtl,
    IN DWORD dwDisplayFlags
    )
{
    PCTL_INFO pInfo = pCtl->pCtlInfo;
    DWORD cEntry = pInfo->cCTLEntry;
    PCTL_ENTRY pEntry = pInfo->rgCTLEntry;
    DWORD i;

    for (i = 0; i < cEntry; i++, pEntry++) {
        dprintf(" [%d] SubjectIdentifier::\n", i);
        PrintBytes("      ",
            pEntry->SubjectIdentifier.pbData,
            pEntry->SubjectIdentifier.cbData);

    }
}

void DisplayCtl(
    IN PCCTL_CONTEXT pCtl,
    IN DWORD dwDisplayFlags
    )
{
    PCTL_INFO pInfo = pCtl->pCtlInfo;

    dprintf("Version:: %d\n", pInfo->dwVersion);

    {
        DWORD cId;
        LPSTR *ppszId;
        DWORD i;

        dprintf("SubjectUsage::\n");
        cId = pInfo->SubjectUsage.cUsageIdentifier;
        ppszId = pInfo->SubjectUsage.rgpszUsageIdentifier;
        if (cId == 0)
            dprintf("  No Usage Identifiers\n");
        for (i = 0; i < cId; i++, ppszId++)
            dprintf("  [%d] %s\n", i, *ppszId);
    }

    if (pInfo->ListIdentifier.cbData) {
        dprintf("ListIdentifier::\n");
        PrintBytes("    ",
            pInfo->ListIdentifier.pbData,
            pInfo->ListIdentifier.cbData);
    }
    if (pInfo->SequenceNumber.cbData) {
        dprintf("SequenceNumber::");
        DisplaySerialNumber(&pInfo->SequenceNumber);
    }

    dprintf("ThisUpdate:: %s\n", FileTimeText(&pCtl->pCtlInfo->ThisUpdate));
    dprintf("NextUpdate:: %s\n", FileTimeText(&pCtl->pCtlInfo->NextUpdate));

    {
        BYTE rgbHash[MAX_HASH_LEN];
        DWORD cbHash = MAX_HASH_LEN;
        CertGetCTLContextProperty(
            pCtl,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &cbHash
            );
        DisplayThumbprint("SHA1", rgbHash, cbHash);
    }

    if (dwDisplayFlags & DISPLAY_VERBOSE_FLAG) {
        LPSTR pszObjId;

        pszObjId = pInfo->SubjectAlgorithm.pszObjId;
        if (pszObjId == NULL)
            pszObjId = "<NULL OBJID>";
        dprintf("SubjectAlgorithm:: %s\n", pszObjId);
        if (pInfo->SubjectAlgorithm.Parameters.cbData) {
            dprintf("SubjectAlgorithm.Parameters::\n");
            PrintBytes("    ",
                pInfo->SubjectAlgorithm.Parameters.pbData,
                pInfo->SubjectAlgorithm.Parameters.cbData);
        }

    }
    PrintExtensions(pInfo->cExtension, pInfo->rgExtension, dwDisplayFlags);

    if (dwDisplayFlags & DISPLAY_VERBOSE_FLAG) {
        DWORD dwSignerCount;
        DWORD cbData;

        cbData = sizeof(dwSignerCount);
        if (!CryptMsgGetParam(
                pCtl->hCryptMsg,
                CMSG_SIGNER_COUNT_PARAM,
                0,                      // dwIndex
                &dwSignerCount,
                &cbData)) {
            dprintf("-----  Signer  -----\n");
            PrintLastError("CryptMsgGetParam(SIGNER_COUNT)");
        } else if (0 == dwSignerCount)
            dprintf("-----  No Signers  -----\n");
        else {
            DWORD dwSignerIndex;
            for (dwSignerIndex = 0; dwSignerIndex < dwSignerCount;
                                                            dwSignerIndex++) {
                DWORD dwFlags;
                PCCERT_CONTEXT pSigner;

                dwFlags = CMSG_USE_SIGNER_INDEX_FLAG;
                if (CryptMsgGetAndVerifySigner(
                        pCtl->hCryptMsg,
                        0,                  // cSignerStore
                        NULL,               // rghSignerStore
                        dwFlags,
                        &pSigner,
                        &dwSignerIndex
                        )) {
                    dprintf("-----  Signer [%d]  -----\n", dwSignerIndex);
                    DisplayCert(pSigner, 0);
                    CertFreeCertificateContext(pSigner);
                } else {
                    DWORD dwErr = GetLastError();
                    if (CRYPT_E_NO_TRUSTED_SIGNER == dwErr)
                        dprintf("-----  No Trusted Signer [%d]  -----\n",
                            dwSignerIndex);
                    else {
                        dprintf("-----  Signer [%d]  -----\n", dwSignerIndex);
                        PrintLastError("CryptMsgGetAndVerifySigner");
                    }
                }

            }
        }
    }

    if (dwDisplayFlags & DISPLAY_VERBOSE_FLAG) {
        if (pInfo->cCTLEntry == 0)
            dprintf("-----  No Entries  -----\n");
        else {
            dprintf("-----  Entries  -----\n");
            PrintCtlEntries(pCtl, dwDisplayFlags);
        }
    }

    if (dwDisplayFlags & DISPLAY_UI_FLAG) {
        CRYPTUI_VIEWCTL_STRUCTW CtlViewInfo;

        memset(&CtlViewInfo, 0, sizeof(CtlViewInfo));
        CtlViewInfo.pCTLContext = pCtl;
        CtlViewInfo.dwSize = sizeof(CtlViewInfo);

        if (!CryptUIDlgViewCTLW(
                &CtlViewInfo
                ))
            PrintLastError("CryptUIDlgViewCTLW");
    }
}

#define MAX_LINK_DEPTH  20

PPROP_ELEMENT GetCachePropHead(
    IN PCONTEXT_ELEMENT pEle
    )
{
    DWORD dwInnerDepth;

    if (ELEMENT_TYPE_CACHE == pEle->dwElementType)
        return pEle->Cache.pPropHead;

    pEle = pEle->pEle;

    // Skip past any links to get to the cache element
    dwInnerDepth = 0;
    while (pEle && dwInnerDepth++ < MAX_LINK_DEPTH) {
        CONTEXT_ELEMENT Ele;

        __try {
            memset(&Ele, 0, sizeof(Ele));
            ReadMemory((LPVOID) pEle, &Ele, sizeof(Ele), NULL);
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            dprintf("Unable to read Context Element at 0x%p\n", pEle);
            return NULL;
        }

        if (ELEMENT_TYPE_CACHE == Ele.dwElementType)
            return Ele.Cache.pPropHead;

        pEle = Ele.pEle;
    }

    return NULL;
}


void DisplayContextElement(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwDisplayFlags,
    IN BOOL fNext = FALSE
    )
{
    DWORD i;

    i = 0;
    while (pEle) {
        CONTEXT_ELEMENT Ele;
        const void *pvContext = (const void *) ((BYTE *) pEle +
            sizeof(CONTEXT_ELEMENT));

        __try {
            memset(&Ele, 0, sizeof(Ele));
            ReadMemory((LPVOID) pEle, &Ele, sizeof(Ele), NULL);
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            dprintf("Unable to read Context Element at 0x%p\n", pEle);
            goto ErrorReturn;
        }

        dprintf("====  ");

        switch (Ele.dwContextType + 1) {
            case CERT_STORE_CERTIFICATE_CONTEXT:
                dprintf("Certificate");
                break;
            case CERT_STORE_CRL_CONTEXT:
                dprintf("CRL");
                break;
            case CERT_STORE_CTL_CONTEXT:
                dprintf("CTL");
                break;
            default:
                dprintf("ContextType[%ld]", Ele.dwContextType);
        }

        dprintf("[");

        if (fNext)
            dprintf("%ld : ", i);
        dprintf("0x%p]  ====\n", pvContext);


        if (0 == (dwDisplayFlags & DISPLAY_SHORT_FLAG)) {
            dprintf("Element[0x%p]:: Type: ", pEle);
            switch (Ele.dwElementType) {
                case ELEMENT_TYPE_CACHE:
                    dprintf("CACHE");
                    break;
                case ELEMENT_TYPE_LINK_CONTEXT:
                    dprintf("LINK");
                    break;
                case ELEMENT_TYPE_EXTERNAL:
                    dprintf("EXTERNAL");
                    break;
                case ELEMENT_TYPE_COLLECTION:
                    dprintf("COLLECTION");
                    break;
                default:
                    dprintf("%ld", Ele.dwElementType);
            }

            dprintf(" RefCnt: %ld", Ele.lRefCnt);
            dprintf(" Flags: 0x%lx", Ele.dwFlags);
            if (Ele.pEle != pEle)
                dprintf(" pEle: 0x%p", Ele.pEle);
            dprintf(" NextContext: 0x%p", ToCertContext(Ele.pNext));
            dprintf(" PrevContext: 0x%p", ToCertContext(Ele.pPrev));
            dprintf(" Store: 0x%p", Ele.pStore);
            dprintf(" ProvStore: 0x%p", Ele.pProvStore);
            dprintf("\n");

            switch (Ele.dwContextType + 1) {
                case CERT_STORE_CERTIFICATE_CONTEXT:
                    {
                        CERT_CONTEXT CertContext;
                        BYTE *pbEncoded;
                        DWORD cbEncoded;
                        PCCERT_CONTEXT pCert;

                        __try {
                            memset(&CertContext, 0, sizeof(CertContext));
                            ReadMemory(pvContext, &CertContext,
                                sizeof(CertContext), NULL);
                        } __except (EXCEPTION_EXECUTE_HANDLER) {
                            dprintf("Unable to read CertContext at 0x%p\n",
                                pvContext);
                            break;
                        }
                        if (!GetEncodedBlob(CertContext.pbCertEncoded,
                                &pbEncoded, &cbEncoded))
                            break;
                        pCert = CertCreateCertificateContext(
                            X509_ASN_ENCODING,
                            pbEncoded,
                            cbEncoded
                            );
                        if (pCert) {
                            DisplayCert(pCert, dwDisplayFlags);
                            CertFreeCertificateContext(pCert);
                        } else 
                            PrintLastError("CertCreateCertificateContext");
                        CertExtsFree(pbEncoded);
                    }
                    break;
                case CERT_STORE_CRL_CONTEXT:
                    {
                        CRL_CONTEXT CrlContext;
                        BYTE *pbEncoded;
                        DWORD cbEncoded;
                        PCCRL_CONTEXT pCrl;

                        __try {
                            memset(&CrlContext, 0, sizeof(CrlContext));
                            ReadMemory(pvContext, &CrlContext,
                                sizeof(CrlContext), NULL);
                        } __except (EXCEPTION_EXECUTE_HANDLER) {
                            dprintf("Unable to read CrlContext at 0x%p\n",
                                pvContext);
                            break;
                        }
                        if (!GetEncodedBlob(CrlContext.pbCrlEncoded,
                                &pbEncoded, &cbEncoded))
                            break;
                        pCrl = CertCreateCRLContext(
                            X509_ASN_ENCODING,
                            pbEncoded,
                            cbEncoded
                            );
                        if (pCrl) {
                            DisplayCrl(pCrl, dwDisplayFlags);
                            CertFreeCRLContext(pCrl);
                        } else 
                            PrintLastError("CertCreateCRLContext");
                        CertExtsFree(pbEncoded);
                    }
                    break;
                case CERT_STORE_CTL_CONTEXT:
                    {
                        CTL_CONTEXT CtlContext;
                        BYTE *pbEncoded;
                        DWORD cbEncoded;
                        PCCTL_CONTEXT pCtl;

                        __try {
                            memset(&CtlContext, 0, sizeof(CtlContext));
                            ReadMemory(pvContext, &CtlContext,
                                sizeof(CtlContext), NULL);
                        } __except (EXCEPTION_EXECUTE_HANDLER) {
                            dprintf("Unable to read CtlContext at 0x%p\n",
                                pvContext);
                            break;
                        }
                        if (!GetEncodedBlob(CtlContext.pbCtlEncoded,
                                &pbEncoded, &cbEncoded))
                            break;
                        pCtl = CertCreateCTLContext(
                            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                            pbEncoded,
                            cbEncoded
                            );
                        if (pCtl) {
                            DisplayCtl(pCtl, dwDisplayFlags);
                            CertFreeCTLContext(pCtl);
                        } else 
                            PrintLastError("CertCreateCTLContext");
                        CertExtsFree(pbEncoded);
                    }
                    break;
            }

            PrintProperties(GetCachePropHead(&Ele), dwDisplayFlags);
        }


        if (!fNext)
            break;

        pEle = Ele.pNext;
        if (i++ > MAX_CONTEXT_CNT) {
            dprintf("Exceeded maximum context count of %d\n", MAX_CONTEXT_CNT);
            break;
        }
    }


CommonReturn:
    return;
ErrorReturn:
    goto CommonReturn;

}

void DisplayContext(
    IN const void *pvContext,
    IN DWORD dwDisplayFlags
    )
{
    if (((const void *)(UINT_PTR) sizeof(CONTEXT_ELEMENT)) > pvContext) {
        dprintf("Invalid, NULL Context address\n");
        return;
    }

    DisplayContextElement(
        ToContextElement((PCCERT_CONTEXT) pvContext),
        dwDisplayFlags
        );
}
    

void DisplayStore(
    IN PCERT_STORE pStore,
    IN DWORD dwDisplayFlags,
    IN DWORD dwNest
    )
{
    CERT_STORE Store;
    PCERT_STORE_LINK pStoreLink;
    DWORD i;

    __try {
        memset(&Store, 0, sizeof(Store));
        ReadMemory((LPVOID) pStore, &Store, sizeof(Store), NULL);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        dprintf("Unable to read Store at 0x%p\n", pStore);
        goto ErrorReturn;
    }

    dprintf("Store[0x%p]:: Type: ", pStore);
    switch (Store.dwStoreType) {
        case STORE_TYPE_CACHE:
            dprintf("CACHE");
            break;
        case STORE_TYPE_EXTERNAL:
            dprintf("EXTERNAL");
            break;
        case STORE_TYPE_COLLECTION:
            dprintf("COLLECTION");
            break;
        default:
            dprintf("%ld", Store.dwStoreType);
    }
    dprintf(" RefCnt: %ld", Store.lRefCnt);
    dprintf(" Flags: 0x%lx", Store.dwFlags);
    dprintf(" State: ");
    switch (Store.dwState) {
        case STORE_STATE_DELETED:
            dprintf("DELETED");
            break;
        case STORE_STATE_NULL:
            dprintf("NULL");
            break;
        case STORE_STATE_OPENING:
            dprintf("OPENING");
            break;
        case STORE_STATE_OPEN:
            dprintf("OPEN");
            break;
        case STORE_STATE_DEFER_CLOSING:
            dprintf("DEFER_CLOSING");
            break;
        case STORE_STATE_CLOSING:
            dprintf("CLOSING");
            break;
        case STORE_STATE_CLOSED:
            dprintf("CLOSED");
            break;
        default:
            dprintf("%ld", Store.dwState);
    }
    dprintf("\n");

    PrintProperties(Store.pPropHead, dwDisplayFlags | DISPLAY_PROP_FLAG);

    for (i = 0; i < CONTEXT_COUNT; i++)
        DisplayContextElement(Store.rgpContextListHead[i], dwDisplayFlags,
            TRUE);

    i = 0;
    pStoreLink = Store.pStoreListHead;
    while (pStoreLink) {
        CERT_STORE_LINK StoreLink;
        DWORD j;

        __try {
            memset(&StoreLink, 0, sizeof(StoreLink));
            ReadMemory((LPVOID) pStoreLink, &StoreLink, sizeof(StoreLink),
                NULL);
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            dprintf("Unable to read StoreLink at 0x%p\n", pStoreLink);
            goto ErrorReturn;
        }

        dprintf("######  SiblingStore[%ld, %ld]  ######\n", dwNest, i);
        dprintf("Link[0x%p]:: Flags: 0x%lx", pStoreLink, StoreLink.dwFlags);
        dprintf(" RefCnt: %ld", StoreLink.lRefCnt);
        dprintf(" UpdateFlags: 0x%lx", StoreLink.dwUpdateFlags);
        dprintf(" Priority: %ld", StoreLink.dwPriority);
        dprintf("\n");
        if (dwNest > MAX_STORE_NEST_CNT) {
            dprintf("Exceeded maximum store nest count of %d\n",
                MAX_STORE_NEST_CNT);
            break;
        }
        DisplayStore(StoreLink.pSibling, dwDisplayFlags, dwNest + 1);

        pStoreLink = StoreLink.pNext;
        if (i++ > MAX_STORE_SIBLING_CNT) {
            dprintf("Exceeded maximum store sibling count of %d\n",
                MAX_STORE_SIBLING_CNT);
            break;
        }
    }

CommonReturn:
    return;
ErrorReturn:
    goto CommonReturn;
}

DWORD GetDisplayFlags(
    IN OUT LPSTR *lppArgumentString
    )
{
    DWORD dwDisplayFlags = 0;
    LPSTR lpArgumentString = *lppArgumentString;

    while (TRUE) {
        while (*lpArgumentString == ' ')
            lpArgumentString++;

        if (*lpArgumentString == 's') {
            dwDisplayFlags |= DISPLAY_SHORT_FLAG;
            lpArgumentString++;
        } else if (*lpArgumentString == 'v') {
            dwDisplayFlags |= DISPLAY_VERBOSE_FLAG;
            lpArgumentString++;
        } else if (*lpArgumentString == 'u') {
            dwDisplayFlags |= DISPLAY_UI_FLAG;
            lpArgumentString++;
        } else if (*lpArgumentString == 'x') {
            dwDisplayFlags |= DISPLAY_EXT_FLAG;
            lpArgumentString++;
        } else if (*lpArgumentString == 'p') {
            dwDisplayFlags |= DISPLAY_PROP_FLAG;
            lpArgumentString++;
        } else
            break;
    }

    *lppArgumentString = lpArgumentString;

    return dwDisplayFlags;
}

//
// context {[s|v|u|x|p]} address
//

DECLARE_API( context )
{
    DWORD dwDisplayFlags;
    const void *pvContext;

    INIT_API();

    dwDisplayFlags = GetDisplayFlags(&lpArgumentString);

    pvContext = (const void *)(ULONG_PTR) GetExpression(lpArgumentString);
    if (NULL == pvContext) {
        dprintf("Invalid, NULL address\n");
        return;
    }

    DisplayContext(
        pvContext,
        dwDisplayFlags
        );
}

//
// ele {[s|v|u|x|p]} address
//

DECLARE_API( ele )
{
    DWORD dwDisplayFlags;
    PCONTEXT_ELEMENT pEle;

    INIT_API();

    dwDisplayFlags = GetDisplayFlags(&lpArgumentString);

    pEle = (PCONTEXT_ELEMENT)(ULONG_PTR) GetExpression(lpArgumentString);
    if (NULL == pEle) {
        dprintf("Invalid, NULL address\n");
        return;
    }

    DisplayContextElement(
        pEle,
        dwDisplayFlags
        );
}

//
// store {[s|v|x|p]} address
//

DECLARE_API( store )
{
    DWORD dwDisplayFlags;
    PCERT_STORE pStore;

    INIT_API();

    dwDisplayFlags = GetDisplayFlags(&lpArgumentString);
    dwDisplayFlags &= ~DISPLAY_UI_FLAG;

    pStore = (PCERT_STORE)(ULONG_PTR) GetExpression(lpArgumentString);
    if (NULL == pStore) {
        dprintf("Invalid, NULL address\n");
        return;
    }

    dprintf("######  Parent Store  ######\n");
    DisplayStore(
        pStore,
        dwDisplayFlags,
        0                   // dwNest
        );
}

//
// cert {[s|v|u|x|p]} address
//

DECLARE_API( cert )
{
    DWORD dwDisplayFlags;
    LPVOID pvAddr;

    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCCERT_CONTEXT pCert = NULL;

    INIT_API();

    dwDisplayFlags = GetDisplayFlags(&lpArgumentString);

    pvAddr = (LPVOID)(ULONG_PTR) GetExpression(lpArgumentString);
    if (NULL == pvAddr) {
        dprintf("Invalid, NULL address\n");
        goto ErrorReturn;
    }

    //dprintf("Expression:: 0x%p\n", pvAddr);

    if (!GetEncodedBlob(pvAddr, &pbEncoded, &cbEncoded))
        goto ErrorReturn;

    pCert = CertCreateCertificateContext(
        X509_ASN_ENCODING,
        pbEncoded,
        cbEncoded
        );
    if (pCert == NULL) {
        PrintLastError("CertCreateCertificateContext");
        goto ErrorReturn;
    }

    dprintf("=====  Certificate  =====\n");
    DisplayCert(pCert, dwDisplayFlags);

CommonReturn:
    CertExtsFree(pbEncoded);
    CertFreeCertificateContext(pCert);
    return;
ErrorReturn:
    goto CommonReturn;

}

//
// crl {[s|v|u|x|p]} address
//

DECLARE_API( crl )
{
    DWORD dwDisplayFlags;
    LPVOID pvAddr;

    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCCRL_CONTEXT pCrl = NULL;

    INIT_API();

    dwDisplayFlags = GetDisplayFlags(&lpArgumentString);

    pvAddr = (LPVOID)(ULONG_PTR) GetExpression(lpArgumentString);
    if (NULL == pvAddr) {
        dprintf("Invalid, NULL address\n");
        goto ErrorReturn;
    }

    //dprintf("Expression:: 0x%p\n", pvAddr);

    if (!GetEncodedBlob(pvAddr, &pbEncoded, &cbEncoded))
        goto ErrorReturn;

    pCrl = CertCreateCRLContext(
        X509_ASN_ENCODING,
        pbEncoded,
        cbEncoded
        );
    if (pCrl == NULL) {
        PrintLastError("CertCreateCRLContext");
        goto ErrorReturn;
    }

    dprintf("=====  CRL  =====\n");
    DisplayCrl(pCrl, dwDisplayFlags);

CommonReturn:
    CertExtsFree(pbEncoded);
    CertFreeCRLContext(pCrl);
    return;
ErrorReturn:
    goto CommonReturn;

}

//
// ctl {[s|v|u|x|p]} address
//

DECLARE_API( ctl )
{
    DWORD dwDisplayFlags;
    LPVOID pvAddr;

    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCCTL_CONTEXT pCtl = NULL;

    INIT_API();

    dwDisplayFlags = GetDisplayFlags(&lpArgumentString);

    pvAddr = (LPVOID)(ULONG_PTR) GetExpression(lpArgumentString);
    if (NULL == pvAddr) {
        dprintf("Invalid, NULL address\n");
        goto ErrorReturn;
    }

    //dprintf("Expression:: 0x%p\n", pvAddr);

    if (!GetEncodedBlob(pvAddr, &pbEncoded, &cbEncoded))
        goto ErrorReturn;

    pCtl = CertCreateCTLContext(
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        pbEncoded,
        cbEncoded
        );
    if (pCtl == NULL) {
        PrintLastError("CertCreateCTLContext");
        goto ErrorReturn;
    }

    dprintf("=====  CTL  =====\n");
    DisplayCtl(pCtl, dwDisplayFlags);

CommonReturn:
    CertExtsFree(pbEncoded);
    CertFreeCTLContext(pCtl);
    return;
ErrorReturn:
    goto CommonReturn;

}


//+---------------------------------------------------------------------------
//
//  Synopsis:   Chain Display Functions
//
//----------------------------------------------------------------------------
LPCSTR rgszErrorStatus[] = {

    "CERT_TRUST_IS_NOT_TIME_VALID",             // 0x00000001
    "CERT_TRUST_IS_NOT_TIME_NESTED",            // 0x00000002
    "CERT_TRUST_IS_REVOKED",                    // 0x00000004
    "CERT_TRUST_IS_NOT_SIGNATURE_VALID",        // 0x00000008
    "CERT_TRUST_IS_NOT_VALID_FOR_USAGE",        // 0x00000010
    "CERT_TRUST_IS_UNTRUSTED_ROOT",             // 0x00000020
    "CERT_TRUST_REVOCATION_STATUS_UNKNOWN",     // 0x00000040
    "CERT_TRUST_IS_CYCLIC",                     // 0x00000080
    "Unknown Error Status",                     // 0x00000100
    "Unknown Error Status",                     // 0x00000200
    "Unknown Error Status",                     // 0x00000400
    "Unknown Error Status",                     // 0x00000800
    "Unknown Error Status",                     // 0x00001000
    "Unknown Error Status",                     // 0x00002000
    "Unknown Error Status",                     // 0x00004000
    "Unknown Error Status",                     // 0x00008000
    "CERT_TRUST_IS_PARTIAL_CHAIN",              // 0x00010000
    "CERT_TRUST_CTL_IS_NOT_TIME_VALID",         // 0x00020000
    "CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID",    // 0x00040000
    "CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE",    // 0x00080000
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status"
};

LPCSTR rgszInfoStatus[] = {

    "CERT_TRUST_HAS_EXACT_MATCH_ISSUER",// 0x00000001
    "CERT_TRUST_HAS_KEY_MATCH_ISSUER",  // 0x00000002
    "CERT_TRUST_HAS_NAME_MATCH_ISSUER", // 0x00000004
    "CERT_TRUST_IS_SELF_SIGNED",        // 0x00000008
    "Unknown Info Status",              // 0x00000010
    "Unknown Info Status",              // 0x00000020
    "Unknown Info Status",              // 0x00000040
    "Unknown Info Status",              // 0x00000080
    "Unknown Info Status",              // 0x00000100
    "Unknown Info Status",              // 0x00000200
    "Unknown Info Status",              // 0x00000400
    "Unknown Info Status",              // 0x00000800
    "Unknown Info Status",              // 0x00001000
    "Unknown Info Status",              // 0x00002000
    "Unknown Info Status",              // 0x00004000
    "Unknown Info Status",              // 0x00008000
    "CERT_TRUST_IS_COMPLEX_CHAIN",      // 0x00010000
    "Unknown Info Status",              // 0x00020000
    "Unknown Info Status",              // 0x00040000
    "Unknown Info Status",              // 0x00080000
    "Unknown Info Status",              // 0x00100000
    "Unknown Info Status",              // 0x00200000
    "Unknown Info Status",              // 0x00400000
    "Unknown Info Status",              // 0x00800000
    "Unknown Info Status",              // 0x01000000
    "Unknown Info Status",              // 0x02000000
    "Unknown Info Status",              // 0x04000000
    "Unknown Info Status",              // 0x08000000
    "Unknown Info Status",              // 0x10000000
    "Unknown Info Status",              // 0x20000000
    "Unknown Info Status",              // 0x40000000
    "Unknown Info Status"               // 0x80000000
};

void DisplayTrustStatus(
    IN PCERT_TRUST_STATUS pStatus
    )
{
    DWORD dwMask;
    DWORD cCount;

    dprintf(
       "Trust Status (E=0x%lx,I=0x%lx)\n\n",
       pStatus->dwErrorStatus,
       pStatus->dwInfoStatus
       );

    dwMask = 1;
    for ( cCount = 0; cCount < 32; cCount++ )
    {
        if ( pStatus->dwErrorStatus & dwMask )
        {
            if ( strcmp( rgszErrorStatus[ cCount ], "Unknown Error Status" ) != 0 )
            {
                dprintf("%s\n", rgszErrorStatus[ cCount ]);
            }
        }

        dwMask = dwMask << 1;
    }

    dwMask = 1;
    for ( cCount = 0; cCount < 32; cCount++ )
    {
        if ( pStatus->dwInfoStatus & dwMask )
        {
            if ( strcmp( rgszInfoStatus[ cCount ], "Unknown Info Status" ) != 0 )
            {
                dprintf("%s\n", rgszInfoStatus[ cCount ]);
            }
        }

        dwMask = dwMask << 1;
    }

    dprintf("\n");
}

void DisplayChainElement(
    IN PCERT_CHAIN_ELEMENT pElement,
    IN DWORD dwDisplayFlags
    )
{
    CERT_CHAIN_ELEMENT Element;

    __try {
        memset(&Element, 0, sizeof(Element));
        ReadMemory((LPVOID) pElement, &Element, sizeof(Element), NULL);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        dprintf("Unable to read Chain Element at 0x%p\n", pElement);
        return;
    }
    DisplayContext( Element.pCertContext, dwDisplayFlags );
    dprintf("\n");
    DisplayTrustStatus( &Element.TrustStatus );
}

void DisplaySimpleChain(
    IN PCERT_SIMPLE_CHAIN pChain,
    IN DWORD dwDisplayFlags
    )
{
    CERT_SIMPLE_CHAIN Chain;
    DWORD cElement;
    PCERT_CHAIN_ELEMENT *ppElement = NULL;

    if (NULL == pChain)
        return;

    __try {
        memset(&Chain, 0, sizeof(Chain));
        ReadMemory((LPVOID) pChain, &Chain, sizeof(Chain), NULL);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        dprintf("Unable to read Simple Chain at 0x%p\n", pChain);
        goto ErrorReturn;
    }

    DisplayTrustStatus( &Chain.TrustStatus );
    dprintf("Chain Element Count = %d\n", Chain.cElement);

    if (MAX_CHAIN_ELEMENT_CNT < Chain.cElement) {
        dprintf("Exceeded maximum chain element count of %d\n",
            MAX_CHAIN_ELEMENT_CNT);
        goto ErrorReturn;
    }

    if (Chain.cElement) {
        if (NULL == (ppElement = (PCERT_CHAIN_ELEMENT *) CertExtsAlloc(
                Chain.cElement * sizeof(PCERT_CHAIN_ELEMENT))))
            goto ErrorReturn;

        __try {
            memset(ppElement, 0, Chain.cElement * sizeof(PCERT_CHAIN_ELEMENT));
            ReadMemory((LPVOID) Chain.rgpElement, ppElement,
                 Chain.cElement * sizeof(PCERT_CHAIN_ELEMENT), NULL);
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            dprintf("Unable to read ChainElement pointers at 0x%p\n",
                Chain.rgpElement);
            goto ErrorReturn;
        }
    }

    for ( cElement = 0; cElement < Chain.cElement; cElement++ )
    {
        dprintf("Chain Element [%d]\n", cElement);
        DisplayChainElement( ppElement[ cElement ], dwDisplayFlags );
    }
CommonReturn:
    CertExtsFree(ppElement);
    return;
ErrorReturn:
    goto CommonReturn;
}

void DisplayChain(
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN DWORD dwDisplayFlags
    )
{
    CERT_CHAIN_CONTEXT ChainContext;
    DWORD cChain;
    PCERT_SIMPLE_CHAIN *ppChain = NULL;

    if (NULL == pChainContext)
        return;

    __try {
        memset(&ChainContext, 0, sizeof(ChainContext));
        ReadMemory((LPVOID) pChainContext, &ChainContext,
            sizeof(ChainContext), NULL);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        dprintf("Unable to read ChainContext at 0x%p\n", pChainContext);
        goto ErrorReturn;
    }

    dprintf("Chain Context\n\n");
    DisplayTrustStatus( (PCERT_TRUST_STATUS)&ChainContext.TrustStatus );
    dprintf("Simple Chain Count = %d\n\n", ChainContext.cChain );

    if (MAX_SIMPLE_CHAIN_CNT < ChainContext.cChain) {
        dprintf("Exceeded maximum simple chain count of %d\n",
            MAX_SIMPLE_CHAIN_CNT);
        goto ErrorReturn;
    }

    if (ChainContext.cChain) {
        if (NULL == (ppChain = (PCERT_SIMPLE_CHAIN *) CertExtsAlloc(
                ChainContext.cChain * sizeof(PCERT_SIMPLE_CHAIN))))
            goto ErrorReturn;

        __try {
            memset(ppChain, 0,
                ChainContext.cChain * sizeof(PCERT_SIMPLE_CHAIN));
            ReadMemory((LPVOID) ChainContext.rgpChain, ppChain,
                 ChainContext.cChain * sizeof(PCERT_SIMPLE_CHAIN), NULL);
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            dprintf("Unable to read SimpleChain pointers at 0x%p\n",
                ChainContext.rgpChain);
            goto ErrorReturn;
        }
    }

    for ( cChain = 0; cChain < ChainContext.cChain; cChain++ )
    {
        dprintf("Simple Chain [%d]\n", cChain);
        DisplaySimpleChain( ppChain[ cChain ], dwDisplayFlags );
    }

CommonReturn:
    CertExtsFree(ppChain);
    return;
ErrorReturn:
    goto CommonReturn;
}

//
// chain {[s|v|x|p]} address
//

DECLARE_API( chain )
{
    DWORD dwDisplayFlags;
    PCCERT_CHAIN_CONTEXT pChainContext;

    INIT_API();

    dwDisplayFlags = GetDisplayFlags(&lpArgumentString);
    dwDisplayFlags &= ~DISPLAY_UI_FLAG;

    pChainContext = (PCCERT_CHAIN_CONTEXT)(ULONG_PTR) GetExpression(lpArgumentString);
    if (NULL == pChainContext) {
        dprintf("Invalid, NULL address\n");
        return;
    }

    DisplayChain(
        pChainContext,
        dwDisplayFlags
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\async.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       async.h
//
//  Contents:   Async Parameter Management definitions
//
//  History:    05-Aug-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__ASYNC_H__)
#define __ASYNC_H__

//
// CCryptAsyncHandle.  Async parameter handle class, a list of OID
// specified parameters.
//

typedef struct _CRYPT_ASYNC_PARAM {

    LPSTR pszOid;
    LPVOID pvParam;
    PFN_CRYPT_ASYNC_PARAM_FREE_FUNC pfnFree;
    struct _CRYPT_ASYNC_PARAM* pPrev;
    struct _CRYPT_ASYNC_PARAM* pNext;

} CRYPT_ASYNC_PARAM, *PCRYPT_ASYNC_PARAM;

class CCryptAsyncHandle
{
public:

    //
    // Construction
    //

    CCryptAsyncHandle (DWORD dwFlags);
    ~CCryptAsyncHandle ();

    //
    // Management methods
    //

    BOOL SetAsyncParam (
            LPSTR pszParamOid,
            LPVOID pvParam,
            PFN_CRYPT_ASYNC_PARAM_FREE_FUNC pfnFree
            );

    BOOL GetAsyncParam (
            LPSTR pszParamOid,
            LPVOID* ppvParam,
            PFN_CRYPT_ASYNC_PARAM_FREE_FUNC* ppfnFree
            );

private:

    //
    // Lock
    //

    CRITICAL_SECTION   m_AsyncLock;

    //
    // Parameter lists
    //

    PCRYPT_ASYNC_PARAM m_pConstOidList;
    PCRYPT_ASYNC_PARAM m_pStrOidList;

    //
    // Private methods
    //

    BOOL AllocAsyncParam (
              LPSTR pszParamOid,
              BOOL fConstOid,
              LPVOID pvParam,
              PFN_CRYPT_ASYNC_PARAM_FREE_FUNC pfnFree,
              PCRYPT_ASYNC_PARAM* ppParam
              );

    VOID FreeAsyncParam (
             PCRYPT_ASYNC_PARAM pParam,
             BOOL fConstOid
             );

    VOID AddAsyncParam (
            PCRYPT_ASYNC_PARAM pParam,
            BOOL fConstOid
            );

    VOID RemoveAsyncParam (
            PCRYPT_ASYNC_PARAM pParam
            );

    PCRYPT_ASYNC_PARAM FindAsyncParam (
                           LPSTR pszParamOid,
                           BOOL fConstOid
                           );

    VOID FreeOidList (
             PCRYPT_ASYNC_PARAM pOidList,
             BOOL fConstOidList
             );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\certhlpr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       certhlpr.cpp
//
//  Contents:   Certificate and CRL Helper APIs
//
//  Functions:  CertHelperDllMain
//              I_CryptGetDefaultCryptProv
//              I_CryptGetDefaultCryptProvForEncrypt
//              CertCompareIntegerBlob
//              CertCompareCertificate
//              CertCompareCertificateName
//              CertIsRDNAttrsInCertificateName
//              CertComparePublicKeyInfo
//              CryptVerifyCertificateSignature
//              CryptHashCertificate
//              CryptHashToBeSigned
//              CryptSignCertificate
//              CryptSignAndEncodeCertificate
//              CertVerifyTimeValidity
//              CertVerifyCRLTimeValidity
//              CertVerifyValidityNesting
//              CertVerifyCRLRevocation
//              CertAlgIdToOID
//              CertOIDToAlgId
//              CertFindExtension
//              CertFindAttribute
//              CertFindRDNAttr
//              CertGetIntendedKeyUsage
//              CertGetPublicKeyLength
//              CryptHashPublicKeyInfo
//
//              I_CertCompareCertAndProviderPublicKey
//              CryptFindCertificateKeyProvInfo
//
//              CryptCreatePublicKeyInfo
//              CryptConvertPublicKeyInfo
//              CryptExportPublicKeyInfo
//              CryptExportPublicKeyInfoEx
//              CryptImportPublicKeyInfo
//              CryptImportPublicKeyInfoEx
//              CryptCreateKeyIdentifierFromCSP
//
//              CryptInstallDefaultContext
//              CryptUninstallDefaultContext
//
//  History:    23-Feb-96   philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)

#define NULL_ASN_TAG        0x05

//+=========================================================================
//  CryptCreatePublicKeyInfo, EncodePublicKeyAndParameters
//  and CryptConvertPublicKeyInfo functions
//-=========================================================================

// The following should be moved to wincrypt.x

// If CRYPT_ALLOC_FLAG is set, *pvPubKeyInfo is updated with a LocalAlloc'ed
// pointer to a CERT_PUBLIC_KEY_INFO data structure which must be freed by
// calling LocalFree. Otherwise, pvPubKeyInfo points to a user allocated
// CERT_PUBLIC_KEY_INFO data structure which is updated.
WINCRYPT32API
BOOL
WINAPI
CryptCreatePublicKeyInfo(
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPCSTR pszPubKeyOID,
    IN const PUBLICKEYSTRUC *pPubKeyStruc,
    IN DWORD cbPubKeyStruc,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT void *pvPubKeyInfo,
    IN OUT DWORD *pcbPubKeyInfo
    );

#define CRYPT_ALLOC_FLAG            0x8000


#define CRYPT_OID_ENCODE_PUBLIC_KEY_AND_PARAMETERS_FUNC  \
    "CryptDllEncodePublicKeyAndParameters"

// The returned encoded public keys and parameters are LocalAlloc'ed.
typedef BOOL (WINAPI *PFN_CRYPT_ENCODE_PUBLIC_KEY_AND_PARAMETERS)(
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPCSTR pszPubKeyOID,
    IN const PUBLICKEYSTRUC *pPubKeyStruc,
    IN DWORD cbPubKeyStruc,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT BYTE **ppbEncodedPubKey,
    OUT DWORD *pcbEncodedPubKey,
    OUT BYTE **ppbEncodedParameters,
    OUT DWORD *pcbEncodedParameters
    );

// If CRYPT_ALLOC_FLAG is set, *pvPubKeyStruc is updated with a LocalAlloc'ed
// pointer to a PUBLICKEYSTRUC data structure which must be freed by calling
// LocalFree. Otherwise, pvPubKeyStruc points to a user allocated
// PUBLICKEYSTRUC data structure which is updated.
WINCRYPT32API
BOOL
WINAPI
CryptConvertPublicKeyInfo(
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pPubKeyInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT void *pvPubKeyStruc,
    IN OUT DWORD *pcbPubKeyStruc
    );


#define CRYPT_OID_CONVERT_PUBLIC_KEY_INFO_FUNC  "CryptDllConvertPublicKeyInfo"

typedef BOOL (WINAPI *PFN_CRYPT_CONVERT_PUBLIC_KEY_INFO)(
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pPubKeyInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT void *pvPubKeyStruc,
    IN OUT DWORD *pcbPubKeyStruc
    );

// End of what should be moved to wincrypt.x

static HCRYPTOIDFUNCSET hEncodePubKeyFuncSet;
static HCRYPTOIDFUNCSET hConvertPubKeyFuncSet;

//+-------------------------------------------------------------------------
//  Encode the RSA public key and parameters
//--------------------------------------------------------------------------
static BOOL WINAPI EncodeRSAPublicKeyAndParameters(
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPCSTR pszPubKeyOID,
    IN const PUBLICKEYSTRUC *pPubKeyStruc,
    IN DWORD cbPubKeyStruc,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT BYTE **ppbEncodedPubKey,
    OUT DWORD *pcbEncodedPubKey,
    OUT BYTE **ppbEncodedParameters,
    OUT DWORD *pcbEncodedParameters
    );

//+-------------------------------------------------------------------------
//  Convert as an RSA public key
//--------------------------------------------------------------------------
static BOOL WINAPI ConvertRSAPublicKeyInfo(
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pPubKeyInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT void *pvPubKeyStruc,
    IN OUT DWORD *pcbPubKeyStruc
    );

//+-------------------------------------------------------------------------
//  Encode the DSS public key and parameters
//--------------------------------------------------------------------------
static BOOL WINAPI EncodeDSSPublicKeyAndParameters(
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPCSTR pszPubKeyOID,
    IN const PUBLICKEYSTRUC *pPubKeyStruc,
    IN DWORD cbPubKeyStruc,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT BYTE **ppbEncodedPubKey,
    OUT DWORD *pcbEncodedPubKey,
    OUT BYTE **ppbEncodedParameters,
    OUT DWORD *pcbEncodedParameters
    );

//+-------------------------------------------------------------------------
//  Convert as an DSS public key
//--------------------------------------------------------------------------
static BOOL WINAPI ConvertDSSPublicKeyInfo(
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pPubKeyInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT void *pvPubKeyStruc,
    IN OUT DWORD *pcbPubKeyStruc
    );

//+-------------------------------------------------------------------------
//  Encode the RSA DH public key and parameters
//--------------------------------------------------------------------------
static BOOL WINAPI EncodeRSADHPublicKeyAndParameters(
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPCSTR pszPubKeyOID,
    IN const PUBLICKEYSTRUC *pPubKeyStruc,
    IN DWORD cbPubKeyStruc,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT BYTE **ppbEncodedPubKey,
    OUT DWORD *pcbEncodedPubKey,
    OUT BYTE **ppbEncodedParameters,
    OUT DWORD *pcbEncodedParameters
    );

//+-------------------------------------------------------------------------
//  Encode the X942 DH public key and parameters
//--------------------------------------------------------------------------
static BOOL WINAPI EncodeX942DHPublicKeyAndParameters(
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPCSTR pszPubKeyOID,
    IN const PUBLICKEYSTRUC *pPubKeyStruc,
    IN DWORD cbPubKeyStruc,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT BYTE **ppbEncodedPubKey,
    OUT DWORD *pcbEncodedPubKey,
    OUT BYTE **ppbEncodedParameters,
    OUT DWORD *pcbEncodedParameters
    );

static const CRYPT_OID_FUNC_ENTRY EncodePubKeyFuncTable[] = {
    szOID_RSA_RSA, EncodeRSAPublicKeyAndParameters,
    szOID_OIWSEC_rsaXchg, EncodeRSAPublicKeyAndParameters,
    szOID_OIWSEC_dsa, EncodeDSSPublicKeyAndParameters,
    szOID_X957_DSA, EncodeDSSPublicKeyAndParameters,
    szOID_ANSI_X942_DH, EncodeX942DHPublicKeyAndParameters,
    szOID_RSA_DH, EncodeRSADHPublicKeyAndParameters,
};
#define ENCODE_PUB_KEY_FUNC_COUNT (sizeof(EncodePubKeyFuncTable) / \
                                    sizeof(EncodePubKeyFuncTable[0]))

static const CRYPT_OID_FUNC_ENTRY ConvertPubKeyFuncTable[] = {
    szOID_RSA_RSA, ConvertRSAPublicKeyInfo,
    szOID_OIWSEC_rsaXchg, ConvertRSAPublicKeyInfo,
    szOID_OIWSEC_dsa, ConvertDSSPublicKeyInfo,
    szOID_X957_DSA, ConvertDSSPublicKeyInfo,
};
#define CONVERT_PUB_KEY_FUNC_COUNT (sizeof(ConvertPubKeyFuncTable) / \
                                    sizeof(ConvertPubKeyFuncTable[0]))


//+=========================================================================
//  CryptExportPublicKeyInfoEx and CryptImportPublicKeyInfoEx OID
//  installable functions.
//-=========================================================================

typedef BOOL (WINAPI *PFN_EXPORT_PUB_KEY_FUNC) (
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec,
    IN DWORD dwCertEncodingType,
    IN LPSTR pszPublicKeyObjId,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvAuxInfo,
    OUT PCERT_PUBLIC_KEY_INFO pInfo,
    IN OUT DWORD *pcbInfo
    );

typedef BOOL (WINAPI *PFN_IMPORT_PUB_KEY_FUNC) (
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pInfo,
    IN ALG_ID aiKeyAlg,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvAuxInfo,
    OUT HCRYPTKEY *phKey
    );

static HCRYPTOIDFUNCSET hExportPubKeyFuncSet;
static HCRYPTOIDFUNCSET hImportPubKeyFuncSet;


//+-------------------------------------------------------------------------
//  Default CryptProvs. Once acquired, not released until ProcessDetach.
//--------------------------------------------------------------------------
#define DEFAULT_RSA_CRYPT_PROV                  0
#define DEFAULT_DSS_CRYPT_PROV                  1
#define DEFAULT_ENCRYPT_BASE_RSA_CRYPT_PROV     2
#define DEFAULT_ENCRYPT_ENH_RSA_CRYPT_PROV      3
#define DEFAULT_ENCRYPT_DH_CRYPT_PROV           4
#define DEFAULT_CRYPT_PROV_CNT                  5

static HCRYPTPROV rghDefaultCryptProv[DEFAULT_CRYPT_PROV_CNT];
static CRITICAL_SECTION DefaultCryptProvCriticalSection;

typedef struct _ENCRYPT_ALG_INFO ENCRYPT_ALG_INFO, *PENCRYPT_ALG_INFO;
struct _ENCRYPT_ALG_INFO {
    ALG_ID              aiAlgid;
    DWORD               dwMinLen;
    DWORD               dwMaxLen;
    PENCRYPT_ALG_INFO   pNext;
};

static BOOL fLoadedRSAEncryptAlgInfo = FALSE;
static PENCRYPT_ALG_INFO pRSAEncryptAlgInfoHead = NULL;

//+=========================================================================
//  DefaultContext Function Forward References and Data Structures
//-=========================================================================

//
// dwDefaultTypes:
//  CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID (pvDefaultPara :== pszOID)
BOOL
WINAPI
I_CryptGetDefaultContext(
    IN DWORD dwDefaultType,
    IN const void *pvDefaultPara,
    OUT HCRYPTPROV *phCryptProv,
    OUT HCRYPTDEFAULTCONTEXT *phDefaultContext
    );

// hDefaultContext is only NON-null for Process default context
void
WINAPI
I_CryptFreeDefaultContext(
    HCRYPTDEFAULTCONTEXT hDefaultContext
    );

typedef struct _DEFAULT_CONTEXT DEFAULT_CONTEXT, *PDEFAULT_CONTEXT;
struct _DEFAULT_CONTEXT {
    HCRYPTPROV                              hCryptProv;
    DWORD                                   dwDefaultType;
    union   {
        // CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID (note, converted to MULTI_)
        // CRYPT_DEFAULT_CONTEXT_MULTI_CERT_SIGN_OID
        PCRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA   pOIDDefaultPara;
    };

    DWORD                                   dwFlags;
    PDEFAULT_CONTEXT                        pNext;
    PDEFAULT_CONTEXT                        pPrev;

    // Following applicable to Process DefaultContext
    LONG                                    lRefCnt;
    HANDLE                                  hWait;
};

static BOOL fHasThreadDefaultContext;
static HCRYPTTLS hTlsDefaultContext;

static BOOL fHasProcessDefaultContext;
static CRITICAL_SECTION DefaultContextCriticalSection;
static PDEFAULT_CONTEXT pProcessDefaultContextHead;


//+-------------------------------------------------------------------------
//  Default CryptProv: initialization and free
//--------------------------------------------------------------------------
static BOOL InitDefaultCryptProv()
{
    return Pki_InitializeCriticalSection(&DefaultCryptProvCriticalSection);
}
static void FreeDefaultCryptProv()
{
    PENCRYPT_ALG_INFO pAlgInfo;

    DWORD cProv = DEFAULT_CRYPT_PROV_CNT;
    while (cProv--) {
        HCRYPTPROV hProv = rghDefaultCryptProv[cProv];
        if (hProv)
            CryptReleaseContext(hProv, 0);
    }

    pAlgInfo = pRSAEncryptAlgInfoHead;
    while (pAlgInfo) {
        PENCRYPT_ALG_INFO pDeleteAlgInfo = pAlgInfo;
        pAlgInfo = pAlgInfo->pNext;
        PkiFree(pDeleteAlgInfo);
    }

    DeleteCriticalSection(&DefaultCryptProvCriticalSection);
}

static
VOID
WINAPI
DetachDefaultContext(
    IN LPVOID pv
    )
{
    PDEFAULT_CONTEXT pDefaultContext = (PDEFAULT_CONTEXT) pv;

    while (pDefaultContext) {
        PDEFAULT_CONTEXT pFree = pDefaultContext;
        pDefaultContext = pDefaultContext->pNext;
        if (pFree->dwFlags & CRYPT_DEFAULT_CONTEXT_AUTO_RELEASE_FLAG)
            CryptReleaseContext(pFree->hCryptProv, 0);
        PkiFree(pFree);
    }
}

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
CertHelperDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL    fRet;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
		// Public key function setup
        if (NULL == (hExportPubKeyFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_EXPORT_PUBLIC_KEY_INFO_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
        if (NULL == (hImportPubKeyFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_IMPORT_PUBLIC_KEY_INFO_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;

        if (NULL == (hEncodePubKeyFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_ENCODE_PUBLIC_KEY_AND_PARAMETERS_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
        if (NULL == (hConvertPubKeyFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_CONVERT_PUBLIC_KEY_INFO_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;

        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CRYPT_OID_ENCODE_PUBLIC_KEY_AND_PARAMETERS_FUNC,
                ENCODE_PUB_KEY_FUNC_COUNT,
                EncodePubKeyFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError;
        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CRYPT_OID_CONVERT_PUBLIC_KEY_INFO_FUNC,
                CONVERT_PUB_KEY_FUNC_COUNT,
                ConvertPubKeyFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError;

        if (!InitDefaultCryptProv())
            goto InitDefaultCryptProvError;

        if (!Pki_InitializeCriticalSection(&DefaultContextCriticalSection))
            goto InitCritSectionError;

        if (NULL == (hTlsDefaultContext = I_CryptAllocTls()))
            goto CryptAllocTlsError;
        break;


    case DLL_PROCESS_DETACH:
        FreeDefaultCryptProv();

        while (pProcessDefaultContextHead) {
            PDEFAULT_CONTEXT pFree = pProcessDefaultContextHead;
            pProcessDefaultContextHead = pProcessDefaultContextHead->pNext;
            if (pFree->dwFlags & CRYPT_DEFAULT_CONTEXT_AUTO_RELEASE_FLAG)
                CryptReleaseContext(pFree->hCryptProv, 0);
            PkiFree(pFree);
        }
        DeleteCriticalSection(&DefaultContextCriticalSection);
        I_CryptFreeTls(hTlsDefaultContext, DetachDefaultContext);
        break;

    case DLL_THREAD_DETACH:
        DetachDefaultContext(I_CryptDetachTls(hTlsDefaultContext));
        break;

    default:
        break;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

CryptAllocTlsError:
    DeleteCriticalSection(&DefaultContextCriticalSection);
InitCritSectionError:
    FreeDefaultCryptProv();
ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(InitDefaultCryptProvError)
TRACE_ERROR(CryptInitOIDFunctionSetError)
TRACE_ERROR(CryptInstallOIDFunctionAddressError)

}


//+-------------------------------------------------------------------------
//  Acquire default CryptProv according to the public key algorithm supported
//  by the provider type. The provider is acquired with only
//  CRYPT_VERIFYCONTEXT.
//
//  Setting aiPubKey to 0, gets the default provider for RSA_FULL.
//
//  Note, the returned CryptProv must not be released. Once acquired, the
//  CryptProv isn't released until ProcessDetach. This allows the returned 
//  CryptProvs to be shared.
//--------------------------------------------------------------------------
HCRYPTPROV
WINAPI
I_CryptGetDefaultCryptProv(
    IN ALG_ID aiPubKey
    )
{
    HCRYPTPROV hProv;
    DWORD dwProvType;
    DWORD dwDefaultProvIndex;

    switch (aiPubKey) {
        case 0:
        case CALG_RSA_SIGN:
        case CALG_RSA_KEYX:
        case CALG_NO_SIGN:
            dwProvType = PROV_RSA_FULL;
            dwDefaultProvIndex = DEFAULT_RSA_CRYPT_PROV;
            break;
        case CALG_DSS_SIGN:
            dwProvType = PROV_DSS_DH;
            dwDefaultProvIndex = DEFAULT_DSS_CRYPT_PROV;
            break;
        default:
            SetLastError((DWORD) E_INVALIDARG);
            return 0;
    }

    hProv = rghDefaultCryptProv[dwDefaultProvIndex];

    if (0 == hProv) {
        EnterCriticalSection(&DefaultCryptProvCriticalSection);
        hProv = rghDefaultCryptProv[dwDefaultProvIndex];
        if (0 == hProv) {
            if (!CryptAcquireContext(
                    &hProv,
                    NULL,               // pszContainer
                    NULL,               // pszProvider,
                    dwProvType,
                    CRYPT_VERIFYCONTEXT // dwFlags
                    )) {
                hProv = 0;   // CAPI bug, sets hCryptProv to nonzero
                if (DEFAULT_DSS_CRYPT_PROV == dwDefaultProvIndex) {
                    if (!CryptAcquireContext(
                            &hProv,
                            NULL,               // pszContainer
                            NULL,               // pszProvider,
                            PROV_DSS,
                            CRYPT_VERIFYCONTEXT // dwFlags
                            ))
                        hProv = 0;   // CAPI bug, sets hCryptProv to nonzero
                }
            }
            rghDefaultCryptProv[dwDefaultProvIndex] = hProv;
        }
        LeaveCriticalSection(&DefaultCryptProvCriticalSection);
    }
    return hProv;
}


// Note, PP_ENUMALGS_EX returns the bit range. However, this parameter type
// may not be supported by all CSPs. If this fails, try PP_ENUMALGS which only
// returns a single, default bit length.
static void LoadRSAEncryptAlgInfo()
{
    EnterCriticalSection(&DefaultCryptProvCriticalSection);

    if (!fLoadedRSAEncryptAlgInfo) {
        HCRYPTPROV hProv;
        if (hProv = I_CryptGetDefaultCryptProv(CALG_RSA_KEYX)) {
            DWORD dwFlags = CRYPT_FIRST;
            BOOL fEx = TRUE;

            while (TRUE) {
                ENCRYPT_ALG_INFO AlgInfo;
                PENCRYPT_ALG_INFO pAllocAlgInfo;

                if (fEx) {
                    PROV_ENUMALGS_EX Data;
                    DWORD cbData = sizeof(Data);

                    if (!CryptGetProvParam(
                            hProv,
                            PP_ENUMALGS_EX,
                            (BYTE *) &Data,
                            &cbData,
                            dwFlags
                            )) {
                        if (0 != dwFlags) {
                            // Try PP_ENUMALGS
                            fEx = FALSE;
                            continue;
                        } else
                            break;
                    }
                    AlgInfo.aiAlgid = Data.aiAlgid;
                    AlgInfo.dwMinLen = Data.dwMinLen;
                    AlgInfo.dwMaxLen = Data.dwMaxLen;
                } else {
                    PROV_ENUMALGS Data;
                    DWORD cbData = sizeof(Data);

                    if (!CryptGetProvParam(
                            hProv,
                            PP_ENUMALGS,
                            (BYTE *) &Data,
                            &cbData,
                            dwFlags
                            ))
                        break;
                    // Only know about a single length
                    AlgInfo.aiAlgid = Data.aiAlgid;
                    AlgInfo.dwMinLen = Data.dwBitLen;
                    AlgInfo.dwMaxLen = Data.dwBitLen;
                }

                dwFlags = 0;    // CRYPT_NEXT

                // Only interested in encrypt algorithms
                if (ALG_CLASS_DATA_ENCRYPT != GET_ALG_CLASS(AlgInfo.aiAlgid))
                    continue;

                if (NULL == (pAllocAlgInfo = (PENCRYPT_ALG_INFO)
                        PkiNonzeroAlloc(sizeof(ENCRYPT_ALG_INFO))))
                    break;
                AlgInfo.pNext = pRSAEncryptAlgInfoHead;
                memcpy(pAllocAlgInfo, &AlgInfo, sizeof(*pAllocAlgInfo));
                pRSAEncryptAlgInfoHead = pAllocAlgInfo;
            }
        }

        fLoadedRSAEncryptAlgInfo = TRUE;
    }
    LeaveCriticalSection(&DefaultCryptProvCriticalSection);
}

static BOOL IsDefaultRSACryptProvForEncrypt(
    IN ALG_ID aiEncrypt,
    IN DWORD dwBitLen
    )
{
    PENCRYPT_ALG_INFO pInfo;
    if (!fLoadedRSAEncryptAlgInfo)
        LoadRSAEncryptAlgInfo();

    if (0 == dwBitLen && (CALG_RC2 == aiEncrypt || CALG_RC4 == aiEncrypt))
        dwBitLen = 40;

    for (pInfo = pRSAEncryptAlgInfoHead; pInfo; pInfo = pInfo->pNext) {
        if (aiEncrypt == pInfo->aiAlgid) {
            if (0 == dwBitLen || (pInfo->dwMinLen <= dwBitLen &&
                    dwBitLen <= pInfo->dwMaxLen))
                return TRUE;
        }
    }

    return FALSE;
}


//+-------------------------------------------------------------------------
//  Acquire default CryptProv according to the public key algorithm, encrypt
//  key algorithm and encrypt key length supported by the provider type.
//
//  dwBitLen = 0, assumes the aiEncrypt's default bit length. For example,
//  CALG_RC2 has a default bit length of 40.
//
//  Note, the returned CryptProv must not be released. Once acquired, the
//  CryptProv isn't released until ProcessDetach. This allows the returned 
//  CryptProvs to be shared.
//--------------------------------------------------------------------------
HCRYPTPROV
WINAPI
I_CryptGetDefaultCryptProvForEncrypt(
    IN ALG_ID aiPubKey,
    IN ALG_ID aiEncrypt,
    IN DWORD dwBitLen
    )
{
    HCRYPTPROV hProv;
    DWORD dwProvType;
    DWORD dwDefaultProvIndex;
    LPCSTR pszProvider;

    if (CALG_DH_SF == aiPubKey || CALG_DH_EPHEM == aiPubKey) {
        dwProvType = PROV_DSS_DH;
        dwDefaultProvIndex = DEFAULT_ENCRYPT_DH_CRYPT_PROV;
        pszProvider = NULL;
    } else {
        dwProvType = PROV_RSA_FULL;

        if (IsDefaultRSACryptProvForEncrypt(
                aiEncrypt,
                dwBitLen
                ))
            // Set to fall through to the default case
            aiEncrypt = 0;

        switch (aiEncrypt) {
            case CALG_DES:
            case CALG_3DES:
            case CALG_3DES_112:
                dwDefaultProvIndex = DEFAULT_ENCRYPT_ENH_RSA_CRYPT_PROV;
                pszProvider = MS_ENHANCED_PROV_A;
                break;
            case CALG_RC2:
            case CALG_RC4:
                if (40 >= dwBitLen) {
                    dwDefaultProvIndex = DEFAULT_ENCRYPT_BASE_RSA_CRYPT_PROV;
                    pszProvider = MS_DEF_PROV_A;
                } else {
                    dwDefaultProvIndex = DEFAULT_ENCRYPT_ENH_RSA_CRYPT_PROV;
                    pszProvider = MS_ENHANCED_PROV_A;
                }
                break;
            case 0:
            default:
                dwDefaultProvIndex = DEFAULT_RSA_CRYPT_PROV;
                pszProvider = NULL;
                break;
        }
    }

    hProv = rghDefaultCryptProv[dwDefaultProvIndex];

    if (0 == hProv) {
        EnterCriticalSection(&DefaultCryptProvCriticalSection);
        hProv = rghDefaultCryptProv[dwDefaultProvIndex];
        if (0 == hProv) {
            if (!CryptAcquireContext(
                    &hProv,
                    NULL,               // pszContainer
                    pszProvider,
                    dwProvType,
                    CRYPT_VERIFYCONTEXT // dwFlags
                    ))
                hProv = 0;   // CAPI bug, sets hCryptProv to nonzero
            else
                rghDefaultCryptProv[dwDefaultProvIndex] = hProv;
        }
        LeaveCriticalSection(&DefaultCryptProvCriticalSection);
    }
    return hProv;
}


//+-------------------------------------------------------------------------
//  Cert helper allocation and free functions
//--------------------------------------------------------------------------
static void *AllocAndDecodeObject(
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT OPTIONAL DWORD *pcbStructInfo = NULL
    )
{
    DWORD cbStructInfo;
    void *pvStructInfo;

    if (!CryptDecodeObjectEx(
            dwCertEncodingType,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            CRYPT_DECODE_NOCOPY_FLAG | CRYPT_DECODE_ALLOC_FLAG,
            &PkiDecodePara,
            (void *) &pvStructInfo,
            &cbStructInfo
            ))
        goto ErrorReturn;

CommonReturn:
    if (pcbStructInfo)
        *pcbStructInfo = cbStructInfo;
    return pvStructInfo;
ErrorReturn:
    pvStructInfo = NULL;
    goto CommonReturn;
}

static BOOL AllocAndEncodeObject(
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const void *pvStructInfo,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    )
{
    return CryptEncodeObjectEx(
        dwCertEncodingType,
        lpszStructType,
        pvStructInfo,
        CRYPT_ENCODE_ALLOC_FLAG,
        &PkiEncodePara,
        (void *) ppbEncoded,
        pcbEncoded
        );
}

#if 0
//+-------------------------------------------------------------------------
//  For an authority key identifier extension, compare the extension's optional
//  fields with the specified issuer certificate.
//
//  Returns TRUE for no authority key identifier extension or an issuer
//  certificate match.
//--------------------------------------------------------------------------
static BOOL CompareAuthorityKeyIdentifier(
    IN DWORD dwCertEncodingType,
    IN DWORD cExtensions,
    IN CERT_EXTENSION rgExtensions[],
    IN PCERT_INFO pIssuerInfo
    )
{
    BOOL fResult;
    PCERT_EXTENSION pExt;
    PCERT_AUTHORITY_KEY_ID_INFO pKeyIdInfo = NULL;

    pExt = CertFindExtension(
            szOID_AUTHORITY_KEY_IDENTIFIER,
            cExtensions,
            rgExtensions
            );
    if (pExt == NULL)
        return TRUE;
    
    if (NULL == (pKeyIdInfo =
        (PCERT_AUTHORITY_KEY_ID_INFO) AllocAndDecodeObject(
            dwCertEncodingType,
            X509_AUTHORITY_KEY_ID,
            pExt->Value.pbData,
            pExt->Value.cbData
            ))) goto DecodeError;

    if (pKeyIdInfo->CertIssuer.cbData) {
        // Issuer certificate's issuer name must match
        if (!CertCompareCertificateName(
                dwCertEncodingType,
                &pKeyIdInfo->CertIssuer,
                &pIssuerInfo->Issuer
                )) goto ErrorReturn;
    }

    if (pKeyIdInfo->CertSerialNumber.cbData) {
        // Issuer certificate's serial number must match
        if (!CertCompareIntegerBlob(
                &pKeyIdInfo->CertSerialNumber,
                &pIssuerInfo->SerialNumber))
            goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;

DecodeError:
    fResult = TRUE;
    goto CommonReturn;
ErrorReturn:
    fResult = FALSE;
CommonReturn:
    PkiFree(pKeyIdInfo);
    return fResult;
}
#endif


//+-------------------------------------------------------------------------
//  Compare two multiple byte integer blobs to see if they are identical.
//
//  Before doing the comparison, leading zero bytes are removed from a
//  positive number and leading 0xFF bytes are removed from a negative
//  number.
//
//  The multiple byte integers are treated as Little Endian. pbData[0] is the
//  least significant byte and pbData[cbData - 1] is the most significant
//  byte.
//
//  Returns TRUE if the integer blobs are identical after removing leading
//  0 or 0xFF bytes.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertCompareIntegerBlob(
    IN PCRYPT_INTEGER_BLOB pInt1,
    IN PCRYPT_INTEGER_BLOB pInt2
    )
{
    BYTE *pb1 = pInt1->pbData;
    DWORD cb1 = pInt1->cbData;
    BYTE *pb2 = pInt2->pbData;
    DWORD cb2 = pInt2->cbData;

    // Assumption: normally don't have leading 0 or 0xFF bytes.

    while (cb1 > 1) {
        BYTE bEnd = pb1[cb1 - 1];
        BYTE bPrev = pb1[cb1 - 2];
        if ((0 == bEnd && 0 == (bPrev & 0x80)) ||
                (0xFF == bEnd && 0 != (bPrev & 0x80)))
            cb1--;
        else
            break;
    }

    while (cb2 > 1) {
        BYTE bEnd = pb2[cb2 - 1];
        BYTE bPrev = pb2[cb2 - 2];
        if ((0 == bEnd && 0 == (bPrev & 0x80)) ||
                (0xFF == bEnd && 0 != (bPrev & 0x80)))
            cb2--;
        else
            break;
    }

    if (cb1 == cb2 && (0 == cb1 || 0 == memcmp(pb1, pb2, cb1)))
        return TRUE;
    else
        return FALSE;
}

//+-------------------------------------------------------------------------
//  Compare two certificates to see if they are identical.
//
//  Since a certificate is uniquely identified by its Issuer and SerialNumber,
//  these are the only fields needing to be compared.
//
//  Returns TRUE if the certificates are identical.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertCompareCertificate(
    IN DWORD dwCertEncodingType,
    IN PCERT_INFO pCertId1,
    IN PCERT_INFO pCertId2
    )
{
    if (CertCompareIntegerBlob(&pCertId1->SerialNumber,
            &pCertId2->SerialNumber) &&
        pCertId1->Issuer.cbData == pCertId2->Issuer.cbData &&
        memcmp(pCertId1->Issuer.pbData, pCertId2->Issuer.pbData,
            pCertId1->Issuer.cbData) == 0)
        return TRUE;
    else
        return FALSE;
}

//+-------------------------------------------------------------------------
//  Compare two certificate names to see if they are identical.
//
//  Returns TRUE if the names are identical.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertCompareCertificateName(
    IN DWORD dwCertEncodingType,
    IN PCERT_NAME_BLOB pCertName1,
    IN PCERT_NAME_BLOB pCertName2
    )
{
    if (pCertName1->cbData == pCertName2->cbData &&
        memcmp(pCertName1->pbData, pCertName2->pbData,
            pCertName1->cbData) == 0)
        return TRUE;
    else
        return FALSE;
}

//+-------------------------------------------------------------------------
//  Compare the attributes in the certificate name with the specified 
//  Relative Distinguished Name's (CERT_RDN) array of attributes.
//  The comparison iterates through the CERT_RDN attributes and looks for an
//  attribute match in any of the certificate's RDNs. Returns TRUE if all the
//  attributes are found and match. 
//
//  The CERT_RDN_ATTR fields can have the following special values:
//    pszObjId == NULL              - ignore the attribute object identifier
//    dwValueType == CERT_RDN_ANY_TYPE   - ignore the value type
//    Value.pbData == NULL          - match any value
//   
//  CERT_CASE_INSENSITIVE_IS_RDN_ATTRS_FLAG should be set to do
//  a case insensitive match. Otherwise, defaults to an exact, case sensitive
//  match.
//
//  CERT_UNICODE_IS_RDN_ATTRS_FLAG should be set if the pRDN was initialized
//  with unicode strings as for CryptEncodeObject(X509_UNICODE_NAME).
//--------------------------------------------------------------------------
BOOL
WINAPI
CertIsRDNAttrsInCertificateName(
    IN DWORD dwCertEncodingType,
    IN DWORD dwFlags,
    IN PCERT_NAME_BLOB pCertName,
    IN PCERT_RDN pRDN
    )
{
    BOOL fResult;
    PCERT_NAME_INFO pNameInfo = NULL;

    DWORD cCmpAttr;
    PCERT_RDN_ATTR pCmpAttr;
    BOOL fMatch;

    if (NULL == (pNameInfo =
        (PCERT_NAME_INFO) AllocAndDecodeObject(
            dwCertEncodingType,
            CERT_UNICODE_IS_RDN_ATTRS_FLAG & dwFlags ? X509_UNICODE_NAME :
                X509_NAME,
            pCertName->pbData,
            pCertName->cbData
            ))) goto ErrorReturn;

    cCmpAttr = pRDN->cRDNAttr;
    pCmpAttr = pRDN->rgRDNAttr;
    fMatch = TRUE;
    // Iterate through list of attributes to be compared against
    for ( ; cCmpAttr > 0; cCmpAttr--, pCmpAttr++) {
        fMatch = FALSE;
        DWORD cNameRDN = pNameInfo->cRDN;
        PCERT_RDN pNameRDN = pNameInfo->rgRDN;
        // Iterate through name's list of RDNs
        for ( ; cNameRDN > 0; cNameRDN--, pNameRDN++) {
            DWORD cNameAttr = pNameRDN->cRDNAttr;
            PCERT_RDN_ATTR pNameAttr = pNameRDN->rgRDNAttr;
            // Iterate through name's CERT_RDN's list of attributes
            for ( ; cNameAttr > 0; cNameAttr--, pNameAttr++) {
                if (pCmpAttr->pszObjId && 
                        (pNameAttr->pszObjId == NULL ||
                         strcmp(pCmpAttr->pszObjId, pNameAttr->pszObjId) != 0))
                    continue;
                if (pCmpAttr->dwValueType != CERT_RDN_ANY_TYPE &&
                        pCmpAttr->dwValueType != pNameAttr->dwValueType)
                    continue;

                if (pCmpAttr->Value.pbData == NULL) {
                    fMatch = TRUE;
                    break;
                }

                if (CERT_CASE_INSENSITIVE_IS_RDN_ATTRS_FLAG & dwFlags) {
                    DWORD cch;

                    if (CERT_UNICODE_IS_RDN_ATTRS_FLAG & dwFlags) {
                        if (0 == pCmpAttr->Value.cbData)
                            cch = wcslen((LPWSTR) pCmpAttr->Value.pbData);
                        else
                            cch = pCmpAttr->Value.cbData / sizeof(WCHAR);
                        if (cch == (pNameAttr->Value.cbData / sizeof(WCHAR))
                                            &&
                                CSTR_EQUAL == CompareStringU(
                                    LOCALE_USER_DEFAULT,
                                    NORM_IGNORECASE,
                                    (LPWSTR) pCmpAttr->Value.pbData,
                                    cch,
                                    (LPWSTR) pNameAttr->Value.pbData,
                                    cch)) {
                            fMatch = TRUE;
                            break;
                        }
                    } else {
                        cch = pCmpAttr->Value.cbData;
                        if (cch == (pNameAttr->Value.cbData)
                                            &&
                                CSTR_EQUAL == CompareStringA(
                                    LOCALE_USER_DEFAULT,
                                    NORM_IGNORECASE,
                                    (LPSTR) pCmpAttr->Value.pbData,
                                    cch,
                                    (LPSTR) pNameAttr->Value.pbData,
                                    cch)) {
                            fMatch = TRUE;
                            break;
                        }
                    }
                } else {
                    DWORD cbCmpData = pCmpAttr->Value.cbData;

                    if ((CERT_UNICODE_IS_RDN_ATTRS_FLAG & dwFlags) &&
                            0 == cbCmpData)
                        cbCmpData = wcslen((LPWSTR) pCmpAttr->Value.pbData) *
                            sizeof(WCHAR);

                    if (cbCmpData == pNameAttr->Value.cbData &&
                            (cbCmpData == 0 ||
                             memcmp(pCmpAttr->Value.pbData,
                                pNameAttr->Value.pbData,
                                cbCmpData) == 0)) {
                        fMatch = TRUE;
                        break;
                    }
                }
            }
            if (fMatch) break;
        }
        if (!fMatch) break;
    }

    if (!fMatch) {
        SetLastError((DWORD) CRYPT_E_NO_MATCH);
        goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;


ErrorReturn:
    fResult = FALSE;
CommonReturn:
    PkiFree(pNameInfo);
    return fResult;
}

#if 0
#ifndef RSA1
#define RSA1 ((DWORD)'R'+((DWORD)'S'<<8)+((DWORD)'A'<<16)+((DWORD)'1'<<24))
#endif

//+-------------------------------------------------------------------------
//  Compare two public keys to see if they are identical.
//
//  Returns TRUE if the keys are identical.
//
//  Note: ignores CAPI's reserved and aiKeyAlg fields in the comparison.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertComparePublicKeyBitBlob(
    IN DWORD dwCertEncodingType,
    IN PCRYPT_BIT_BLOB pPublicKey1,
    IN PCRYPT_BIT_BLOB pPublicKey2
    )
{
    BYTE *pb1, *pb2;
    PUBLICKEYSTRUC *pPubKeyStruc1, *pPubKeyStruc2;
    RSAPUBKEY *pRsaPubKey1, *pRsaPubKey2;
    BYTE *pbModulus1, *pbModulus2;
    DWORD cbModulus1, cbModulus2;


    // The CAPI public key representation consists of the following sequence:
    //  - PUBLICKEYSTRUC
    //  - RSAPUBKEY
    //  - rgbModulus[]
    pb1 = pPublicKey1->pbData;
    pPubKeyStruc1 = (PUBLICKEYSTRUC *) pb1;
    pRsaPubKey1 = (RSAPUBKEY *) (pb1 + sizeof(PUBLICKEYSTRUC));
    pbModulus1 = pb1 + sizeof(PUBLICKEYSTRUC) + sizeof(RSAPUBKEY);
    cbModulus1 = pRsaPubKey1->bitlen / 8;

    assert(cbModulus1 > 0);
    assert(sizeof(PUBLICKEYSTRUC) + sizeof(RSAPUBKEY) + cbModulus1 <=
        pPublicKey1->cbData);
    assert(pPubKeyStruc1->bType == PUBLICKEYBLOB);
    assert(pPubKeyStruc1->bVersion == CUR_BLOB_VERSION);
    assert(pPubKeyStruc1->aiKeyAlg == CALG_RSA_SIGN ||
           pPubKeyStruc1->aiKeyAlg == CALG_RSA_KEYX);
    assert(pRsaPubKey1->magic == RSA1);
    assert(pRsaPubKey1->bitlen % 8 == 0);

    pb2 = pPublicKey2->pbData;
    pPubKeyStruc2 = (PUBLICKEYSTRUC *) pb2;
    pRsaPubKey2 = (RSAPUBKEY *) (pb2 + sizeof(PUBLICKEYSTRUC));
    pbModulus2 = pb2 + sizeof(PUBLICKEYSTRUC) + sizeof(RSAPUBKEY);
    cbModulus2 = pRsaPubKey2->bitlen / 8;

    assert(cbModulus2 > 0);
    assert(sizeof(PUBLICKEYSTRUC) + sizeof(RSAPUBKEY) + cbModulus2 <=
        pPublicKey2->cbData);
    assert(pPubKeyStruc2->bType == PUBLICKEYBLOB);
    assert(pPubKeyStruc2->bVersion == CUR_BLOB_VERSION);
    assert(pPubKeyStruc2->aiKeyAlg == CALG_RSA_SIGN ||
           pPubKeyStruc2->aiKeyAlg == CALG_RSA_KEYX);
    assert(pRsaPubKey2->magic == RSA1);
    assert(pRsaPubKey2->bitlen % 8 == 0);

    if (pRsaPubKey1->pubexp == pRsaPubKey2->pubexp &&
            cbModulus1 == cbModulus2 &&
            memcmp(pbModulus1, pbModulus2, cbModulus1) == 0)
        return TRUE;
    else
        return FALSE;

}
#endif

//+-------------------------------------------------------------------------
//  Compare two public keys to see if they are identical.
//
//  Returns TRUE if the keys are identical.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertComparePublicKeyInfo(
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pPublicKey1,
    IN PCERT_PUBLIC_KEY_INFO pPublicKey2
    )
{
    DWORD  cbData;
    DWORD  cb1;
    BYTE * pb1;
    DWORD  cb2;
    BYTE * pb2;
    BOOL   fResult = FALSE;
    PUBLICKEYSTRUC * pBlob1 = NULL;
    PUBLICKEYSTRUC * pBlob2 = NULL;

    if (!((cbData = pPublicKey1->PublicKey.cbData) ==
                    pPublicKey2->PublicKey.cbData
                            &&
          (cbData == 0 || memcmp(pPublicKey1->PublicKey.pbData,
                            pPublicKey2->PublicKey.pbData, cbData) == 0)))
    {
        // DSIE: Bug 402662.
        // Encoded compare failed, try decoded compare.
        if (NULL == (pBlob1 = (PUBLICKEYSTRUC *) AllocAndDecodeObject(
                dwCertEncodingType,
                RSA_CSP_PUBLICKEYBLOB,
                pPublicKey1->PublicKey.pbData,
                pPublicKey1->PublicKey.cbData,
                &cb1)))
        {
            goto CLEANUP;
        }

        if (NULL == (pBlob2 = (PUBLICKEYSTRUC *) AllocAndDecodeObject(
                dwCertEncodingType,
                RSA_CSP_PUBLICKEYBLOB,
                pPublicKey2->PublicKey.pbData,
                pPublicKey2->PublicKey.cbData,
                &cb2))) 
        {
            goto CLEANUP;
        }

        if (!((cb1 == cb2) &&
              (cb1 == 0 || memcmp(pBlob1, pBlob2, cb1) == 0)))
        {
            goto CLEANUP;
        }
    }
    
    // Compare algorithm parameters
    cb1 = pPublicKey1->Algorithm.Parameters.cbData;
    pb1 = pPublicKey1->Algorithm.Parameters.pbData;
    cb2 = pPublicKey2->Algorithm.Parameters.cbData;
    pb2 = pPublicKey2->Algorithm.Parameters.pbData;

    if (X509_ASN_ENCODING == GET_CERT_ENCODING_TYPE(dwCertEncodingType)) 
    {
        // Check if either has NO or NULL parameters
        if (0 == cb1 || *pb1 == NULL_ASN_TAG ||
            0 == cb2 || *pb2 == NULL_ASN_TAG)
        {
            fResult = TRUE;
            goto CLEANUP;
        }
    }

    if (cb1 == cb2) 
    {
        if (0 == cb1 || 0 == memcmp(pb1, pb2, cb1))
        {
            fResult = TRUE;
        }
    }

CLEANUP:
    if (pBlob1)
        PkiFree(pBlob1);

    if (pBlob2)
        PkiFree(pBlob2);

    return fResult;
}

static BOOL GetSignOIDInfo(
    IN LPCSTR pszObjId,
    OUT ALG_ID *paiHash,
    OUT ALG_ID *paiPubKey,
    OUT DWORD *pdwFlags,
    OUT DWORD *pdwProvType = NULL
    )
{
    BOOL fResult;
    PCCRYPT_OID_INFO pInfo;

    *paiPubKey = 0;
    *pdwFlags = 0;
    if (pdwProvType)
        *pdwProvType = 0;
    if (pInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            (void *) pszObjId,
            CRYPT_SIGN_ALG_OID_GROUP_ID
            )) {
        DWORD cExtra = pInfo->ExtraInfo.cbData / sizeof(DWORD);
        DWORD *pdwExtra = (DWORD *) pInfo->ExtraInfo.pbData;

        *paiHash = pInfo->Algid;
        if (1 <= cExtra) {
            *paiPubKey = pdwExtra[0];
            if (2 <= cExtra) {
                *pdwFlags = pdwExtra[1];
                if (3 <= cExtra && pdwProvType) {
                    *pdwProvType = pdwExtra[2];
                }
            }
        }
        fResult = TRUE;
    } else if (pInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            (void *) pszObjId,
            CRYPT_HASH_ALG_OID_GROUP_ID
            )) {
        *paiHash = pInfo->Algid;
        *paiPubKey = CALG_NO_SIGN;
        fResult = TRUE;
    } else {
        *paiHash = 0;
        fResult = FALSE;
        SetLastError((DWORD) NTE_BAD_ALGID);
    }
    return fResult;
}


#ifndef CMS_PKCS7

//+-------------------------------------------------------------------------
//  Verify the signature of a subject certificate or a CRL using the
//  specified public key.
//
//  Returns TRUE for a valid signature.
//
//  hCryptProv specifies the crypto provider to use to verify the signature.
//  It doesn't need to use a private key.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptVerifyCertificateSignature(
    IN HCRYPTPROV   hCryptProv,
    IN DWORD        dwCertEncodingType,
    IN const BYTE * pbEncoded,
    IN DWORD        cbEncoded,
    IN PCERT_PUBLIC_KEY_INFO pPublicKey
    )
{
    BOOL fResult;
    PCERT_SIGNED_CONTENT_INFO pSignedInfo = NULL;
    HCRYPTDEFAULTCONTEXT hDefaultContext = NULL;
    HCRYPTKEY hSignKey = 0;
    HCRYPTHASH hHash = 0;
    BYTE *pbSignature;      // not allocated
    DWORD cbSignature;
    BYTE rgbDssSignature[CERT_DSS_SIGNATURE_LEN];
    ALG_ID aiHash;
    ALG_ID aiPubKey;
    DWORD dwSignFlags;
    DWORD dwErr;
    
    if (NULL == (pSignedInfo =
        (PCERT_SIGNED_CONTENT_INFO) AllocAndDecodeObject(
            dwCertEncodingType,
            X509_CERT,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    if (!GetSignOIDInfo(pSignedInfo->SignatureAlgorithm.pszObjId,
            &aiHash, &aiPubKey, &dwSignFlags))
        goto ErrorReturn;

    if (0 == hCryptProv) {
        if (!I_CryptGetDefaultContext(
                CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID,
                (const void *) pSignedInfo->SignatureAlgorithm.pszObjId,
                &hCryptProv,
                &hDefaultContext
                )) {
            if (0 == (hCryptProv = I_CryptGetDefaultCryptProv(aiPubKey)))
                goto ErrorReturn;
        }
    }

#if 0
    // Slow down the signature verify while holding the default context
    // reference count
    if (hDefaultContext)
        Sleep(5000);
#endif

    if (!CryptImportPublicKeyInfo(
                hCryptProv,
                dwCertEncodingType,
                pPublicKey,
                &hSignKey
                )) goto ErrorReturn;
    if (!CryptCreateHash(
                hCryptProv,
                aiHash,
                NULL,               // hKey - optional for MAC
                0,                  // dwFlags
                &hHash
                )) goto ErrorReturn;
    if (!CryptHashData(
                hHash,
                pSignedInfo->ToBeSigned.pbData,
                pSignedInfo->ToBeSigned.cbData,
                0                   // dwFlags
                )) goto ErrorReturn;


    pbSignature = pSignedInfo->Signature.pbData;
    cbSignature = pSignedInfo->Signature.cbData;
    if (CALG_DSS_SIGN == aiPubKey &&
            0 == (dwSignFlags & CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG)) {
        DWORD cbData;

        // Undo the reversal done by CryptDecodeObject(X509_CERT)
        PkiAsn1ReverseBytes(pbSignature, cbSignature);
        // Convert from ASN.1 sequence of two integers to the CSP signature
        // format.
        cbData = sizeof(rgbDssSignature);
        if (!CryptDecodeObject(
                dwCertEncodingType,
                X509_DSS_SIGNATURE,
                pbSignature,
                cbSignature,
                0,                                  // dwFlags
                rgbDssSignature,
                &cbData
                ))
            goto ErrorReturn;
        pbSignature = rgbDssSignature;
        assert(cbData == sizeof(rgbDssSignature));
        cbSignature = sizeof(rgbDssSignature);
    }

    if (!CryptVerifySignature(
                hHash,
                pbSignature,
                cbSignature,
                hSignKey,
                NULL,               // sDescription
                0                   // dwFlags
                )) goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    dwErr = GetLastError();
    if (hSignKey)
        CryptDestroyKey(hSignKey);
    if (hHash)
        CryptDestroyHash(hHash);
    I_CryptFreeDefaultContext(hDefaultContext);
    PkiFree(pSignedInfo);

    SetLastError(dwErr);
    return fResult;
}

#endif  // CMS_PKCS7

BOOL
WINAPI
DefaultHashCertificate(
    IN ALG_ID Algid,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT BYTE *pbHash,
    IN OUT DWORD *pcbHash
    )
{
    DWORD cbInHash;
    DWORD cbOutHash;

    if (NULL == pbHash)
        cbInHash = 0;
    else
        cbInHash = *pcbHash;

    switch (Algid) {
        case CALG_MD5:
            cbOutHash = MD5DIGESTLEN;
            if (MD5DIGESTLEN <= cbInHash) {
                MD5_CTX md5ctx;

                MD5Init(&md5ctx);
                if (cbEncoded)
                    MD5Update(&md5ctx, pbEncoded, cbEncoded);
                MD5Final(&md5ctx);
                memcpy(pbHash, md5ctx.digest, MD5DIGESTLEN);
            }
            break;

        case CALG_SHA1:
        default:
            assert(CALG_SHA1 == Algid);
            assert(CALG_SHA == Algid);
            cbOutHash = A_SHA_DIGEST_LEN;
            if (A_SHA_DIGEST_LEN <= cbInHash) {
                A_SHA_CTX shactx;

                A_SHAInit(&shactx);
                if (cbEncoded)
                    A_SHAUpdate(&shactx, (BYTE *) pbEncoded, cbEncoded);
                A_SHAFinal(&shactx, pbHash);
            }
            break;
    }

    *pcbHash = cbOutHash;
    if (cbInHash < cbOutHash && pbHash) {
        SetLastError((DWORD) ERROR_MORE_DATA);
        return FALSE;
    } else
        return TRUE;
}

//+-------------------------------------------------------------------------
//  Hash the encoded content.
//
//  hCryptProv specifies the crypto provider to use to compute the hash.
//  It doesn't need to use a private key.
//
//  Algid specifies the CAPI hash algorithm to use. If Algid is 0, then, the
//  default hash algorithm (currently SHA1) is used.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptHashCertificate(
    IN HCRYPTPROV hCryptProv,
    IN ALG_ID Algid,
    IN DWORD dwFlags,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT BYTE *pbComputedHash,
    IN OUT DWORD *pcbComputedHash
    )
{
    BOOL fResult;
    HCRYPTHASH hHash = 0;
    DWORD dwErr;

    if (Algid == 0) {
        Algid = CALG_SHA;
        dwFlags = 0;
    }

    if (0 == hCryptProv) {
        if (CALG_SHA1 == Algid || CALG_MD5 == Algid)
            return DefaultHashCertificate(
                Algid,
                pbEncoded,
                cbEncoded,
                pbComputedHash,
                pcbComputedHash
                );
        if (0 == (hCryptProv = I_CryptGetDefaultCryptProv(0)))
            goto ErrorReturn;
    }

    if (!CryptCreateHash(
                hCryptProv,
                Algid,
                NULL,               // hKey - optional for MAC
                dwFlags,
                &hHash
                ))
        goto ErrorReturn;
    if (!CryptHashData(
                hHash,
                pbEncoded,
                cbEncoded,
                0                   // dwFlags
                ))
        goto ErrorReturn;

    fResult = CryptGetHashParam(
                hHash,
                HP_HASHVAL,
                pbComputedHash,
                pcbComputedHash,
                0                   // dwFlags
                );
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
    *pcbComputedHash = 0;
CommonReturn:
    dwErr = GetLastError();
    if (hHash)
        CryptDestroyHash(hHash);
    SetLastError(dwErr);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Compute the hash of the "to be signed" information in the encoded
//  signed content.
//
//  hCryptProv specifies the crypto provider to use to compute the hash.
//  It doesn't need to use a private key.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptHashToBeSigned(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT BYTE *pbComputedHash,
    IN OUT DWORD *pcbComputedHash
    )
{
    BOOL fResult;
    PCERT_SIGNED_CONTENT_INFO pSignedInfo = NULL;
    HCRYPTHASH hHash = 0;
    DWORD dwErr;
    ALG_ID aiHash;
    ALG_ID aiPubKey;
    DWORD dwSignFlags;
    
    if (NULL == (pSignedInfo =
        (PCERT_SIGNED_CONTENT_INFO) AllocAndDecodeObject(
            dwCertEncodingType,
            X509_CERT,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    if (!GetSignOIDInfo(pSignedInfo->SignatureAlgorithm.pszObjId,
            &aiHash, &aiPubKey, &dwSignFlags))
        goto ErrorReturn;

    if (0 == hCryptProv) {
        if (CALG_SHA1 == aiHash || CALG_MD5 == aiHash) {
            fResult = DefaultHashCertificate(
                aiHash,
                pSignedInfo->ToBeSigned.pbData,
                pSignedInfo->ToBeSigned.cbData,
                pbComputedHash,
                pcbComputedHash
                );
            goto CommonReturn;
        }
        if (0 == (hCryptProv = I_CryptGetDefaultCryptProv(0)))
            goto ErrorReturn;
    }

    if (!CryptCreateHash(
                hCryptProv,
                aiHash,
                NULL,               // hKey - optional for MAC
                0,                  // dwFlags
                &hHash
                ))
        goto ErrorReturn;
    if (!CryptHashData(
                hHash,
                pSignedInfo->ToBeSigned.pbData,
                pSignedInfo->ToBeSigned.cbData,
                0                   // dwFlags
                ))
        goto ErrorReturn;

    fResult = CryptGetHashParam(
                hHash,
                HP_HASHVAL,
                pbComputedHash,
                pcbComputedHash,
                0                   // dwFlags
                );
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
    *pcbComputedHash = 0;
CommonReturn:
    dwErr = GetLastError();
    if (hHash)
        CryptDestroyHash(hHash);
    PkiFree(pSignedInfo);
    SetLastError(dwErr);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Sign the "to be signed" information in the encoded signed content.
//
//  hCryptProv specifies the crypto provider to use to do the signature.
//  It needs to use the provider's signature private key.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptSignCertificate(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec,
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbEncodedToBeSigned,
    IN DWORD cbEncodedToBeSigned,
    IN PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
    IN OPTIONAL const void *pvHashAuxInfo,
    OUT BYTE *pbSignature,
    IN OUT DWORD *pcbSignature
    )
{
    BOOL fResult;
    ALG_ID aiHash;
    ALG_ID aiPubKey;
    DWORD dwSignFlags;
    HCRYPTHASH hHash = 0;
    DWORD dwErr;

    if (!GetSignOIDInfo(pSignatureAlgorithm->pszObjId,
            &aiHash, &aiPubKey, &dwSignFlags))
        goto ErrorReturn;

    if (CALG_NO_SIGN == aiPubKey) {
        fResult = CryptHashCertificate(
            hCryptProv,
            aiHash,
            0,                  // dwFlags
            pbEncodedToBeSigned,
            cbEncodedToBeSigned,
            pbSignature,
            pcbSignature
            );
        if (fResult && pbSignature)
            // A subsequent CryptEncodeObject(X509_CERT) will reverse
            // the signature bytes
            PkiAsn1ReverseBytes(pbSignature, *pcbSignature);
        return fResult;
    }

    if (CALG_DSS_SIGN == aiPubKey &&
            0 == (dwSignFlags & CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG)) {
        if (NULL == pbSignature) {
            *pcbSignature = CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN;
            return TRUE;
        }
    }

    if (!CryptCreateHash(
                hCryptProv,
                aiHash,
                NULL,               // hKey - optional for MAC
                0,                  // dwFlags,
                &hHash
                ))
        goto ErrorReturn;

    if (!CryptHashData(
                hHash,
                pbEncodedToBeSigned,
                cbEncodedToBeSigned,
                0                   // dwFlags
                ))
        goto ErrorReturn;

    if (CALG_DSS_SIGN == aiPubKey &&
            0 == (dwSignFlags & CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG)) {
        DWORD cbData;
        BYTE rgbDssSignature[CERT_DSS_SIGNATURE_LEN];

        cbData = sizeof(rgbDssSignature);
        if (!CryptSignHash(
                hHash,
                dwKeySpec,
                NULL,               // sDescription
                0,                  // dwFlags
                rgbDssSignature,
                &cbData
                )) goto ErrorReturn;
        assert(cbData == sizeof(rgbDssSignature));
        // Convert from the CSP signature format to an ASN.1 sequence of
        // two integers
        fResult = CryptEncodeObject(
                    dwCertEncodingType,
                    X509_DSS_SIGNATURE,
                    rgbDssSignature,
                    pbSignature,
                    pcbSignature
                    );
        if (fResult)
            // A subsequent CryptEncodeObject(X509_CERT) will reverse
            // the signature bytes
            PkiAsn1ReverseBytes(pbSignature, *pcbSignature);
        else if (0 != *pcbSignature)
            // Since a random number is used in each CryptSignHash invocation,
            // the generated signature will be different. In particular
            // different signatures may have different leading 0x00's or
            // 0xFF's which get removed when converted to the ASN.1 sequence
            // of integers.
            *pcbSignature = CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN;
    } else
        fResult = CryptSignHash(
                    hHash,
                    dwKeySpec,
                    NULL,               // sDescription
                    0,                  // dwFlags
                    pbSignature,        // pbData
                    pcbSignature
                    );
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
    *pcbSignature = 0;
CommonReturn:
    dwErr = GetLastError();
    if (hHash)
        CryptDestroyHash(hHash);
    SetLastError(dwErr);
    return fResult;
}

static DWORD AdjustForMaximumEncodedSignatureLength(
    IN PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
    IN DWORD cbOrig
    )
{
    DWORD cbAdjust;
    ALG_ID aiHash;
    ALG_ID aiPubKey;
    DWORD dwSignFlags;

    cbAdjust = 0;
    if (GetSignOIDInfo(pSignatureAlgorithm->pszObjId,
            &aiHash, &aiPubKey, &dwSignFlags)) {
        if (CALG_DSS_SIGN == aiPubKey &&
                0 == (dwSignFlags & CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG)) {
            assert(CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN >= cbOrig);
            if (CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN > cbOrig)
                // the +1 is for adjusting the number of length octets in
                // the outer SEQUENCE. Note, the number of length octets in
                // the signature's BITSTRING will always be 1, ie,
                // CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN <= 0x7F.
                cbAdjust =
                    (CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN - cbOrig) + 1;
        }
    }
    return cbAdjust;
}

//+-------------------------------------------------------------------------
//  Encode the "to be signed" information. Sign the encoded "to be signed".
//  Encode the "to be signed" and the signature.
//
//  hCryptProv specifies the crypto provider to use to do the signature.
//  It uses the specified private key.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptSignAndEncodeCertificate(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec,
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const void *pvStructInfo,
    IN PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
    IN OPTIONAL const void *pvHashAuxInfo,
    OUT BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    BOOL fResult;
    CERT_SIGNED_CONTENT_INFO SignedInfo;
    memset(&SignedInfo, 0, sizeof(SignedInfo));

    SignedInfo.SignatureAlgorithm = *pSignatureAlgorithm;

    if (!AllocAndEncodeObject(
            dwCertEncodingType,
            lpszStructType,
            pvStructInfo,
            &SignedInfo.ToBeSigned.pbData,
            &SignedInfo.ToBeSigned.cbData
            )) goto ErrorReturn;

    CryptSignCertificate(
            hCryptProv,
            dwKeySpec,
            dwCertEncodingType,
            SignedInfo.ToBeSigned.pbData,
            SignedInfo.ToBeSigned.cbData,
            &SignedInfo.SignatureAlgorithm,
            pvHashAuxInfo,
            NULL,                   // pbSignature
            &SignedInfo.Signature.cbData
            );
    if (SignedInfo.Signature.cbData == 0) goto ErrorReturn;
    SignedInfo.Signature.pbData =
        (BYTE *) PkiNonzeroAlloc(SignedInfo.Signature.cbData);
    if (SignedInfo.Signature.pbData == NULL) goto ErrorReturn;
    if (pbEncoded) {
        if (!CryptSignCertificate(
                hCryptProv,
                dwKeySpec,
                dwCertEncodingType,
                SignedInfo.ToBeSigned.pbData,
                SignedInfo.ToBeSigned.cbData,
                &SignedInfo.SignatureAlgorithm,
                pvHashAuxInfo,
                SignedInfo.Signature.pbData,
                &SignedInfo.Signature.cbData
                )) goto ErrorReturn;
    }

    fResult = CryptEncodeObject(
            dwCertEncodingType,
            X509_CERT,
            &SignedInfo,
            pbEncoded,
            pcbEncoded
            );
    if (!fResult && *pcbEncoded) {
        *pcbEncoded += AdjustForMaximumEncodedSignatureLength(
            &SignedInfo.SignatureAlgorithm,
            SignedInfo.Signature.cbData
            );
    }

CommonReturn:
    PkiFree(SignedInfo.ToBeSigned.pbData);
    PkiFree(SignedInfo.Signature.pbData);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    *pcbEncoded = 0;
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  Verify the time validity of a certificate.
//
//  Returns -1 if before NotBefore, +1 if after NotAfter and otherwise 0 for
//  a valid certificate
//
//  If pTimeToVerify is NULL, uses the current time.
//--------------------------------------------------------------------------
LONG
WINAPI
CertVerifyTimeValidity(
    IN LPFILETIME pTimeToVerify,
    IN PCERT_INFO pCertInfo
    )
{
    SYSTEMTIME SystemTime;
    FILETIME FileTime;
    LPFILETIME pFileTime;

    if (pTimeToVerify)
        pFileTime = pTimeToVerify;
    else {
        GetSystemTime(&SystemTime);
        SystemTimeToFileTime(&SystemTime, &FileTime);
        pFileTime = &FileTime;
    }

    if (CompareFileTime(pFileTime, &pCertInfo->NotBefore) < 0)
        return -1;
    else if (CompareFileTime(pFileTime, &pCertInfo->NotAfter) > 0)
        return 1;
    else
        return 0;
}


//+-------------------------------------------------------------------------
//  Verify the time validity of a CRL.
//
//  Returns -1 if before ThisUpdate, +1 if after NextUpdate and otherwise 0 for
//  a valid CRL
//
//  If pTimeToVerify is NULL, uses the current time.
//--------------------------------------------------------------------------
LONG
WINAPI
CertVerifyCRLTimeValidity(
    IN LPFILETIME pTimeToVerify,
    IN PCRL_INFO pCrlInfo
    )
{
    SYSTEMTIME SystemTime;
    FILETIME FileTime;
    LPFILETIME pFileTime;

    if (pTimeToVerify)
        pFileTime = pTimeToVerify;
    else {
        GetSystemTime(&SystemTime);
        SystemTimeToFileTime(&SystemTime, &FileTime);
        pFileTime = &FileTime;
    }

    // Note, NextUpdate is optional. When not present, set to 0
    if (CompareFileTime(pFileTime, &pCrlInfo->ThisUpdate) < 0)
        return -1;
    else if ((pCrlInfo->NextUpdate.dwLowDateTime ||
                pCrlInfo->NextUpdate.dwHighDateTime) &&
            CompareFileTime(pFileTime, &pCrlInfo->NextUpdate) > 0)
        return 1;
    else
        return 0;
}

//+-------------------------------------------------------------------------
//  Verify that the subject's time validity nests within the issuer's time
//  validity.
//
//  Returns TRUE if it nests. Otherwise, returns FALSE.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertVerifyValidityNesting(
    IN PCERT_INFO pSubjectInfo,
    IN PCERT_INFO pIssuerInfo
    )
{
    if ((CompareFileTime(&pSubjectInfo->NotBefore,
                &pIssuerInfo->NotBefore) >= 0) &&
            (CompareFileTime(&pSubjectInfo->NotAfter,
                &pIssuerInfo->NotAfter) <= 0))
        return TRUE;
    else
        return FALSE;
}

//+-------------------------------------------------------------------------
//  Verify that the subject certificate isn't on its issuer CRL.
//
//  Returns true if the certificate isn't on the CRL.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertVerifyCRLRevocation(
    IN DWORD dwCertEncodingType,
    IN PCERT_INFO pCertId,          // Only the Issuer and SerialNumber
                                    // fields are used
    IN DWORD cCrlInfo,
    IN PCRL_INFO rgpCrlInfo[]
    )
{
    DWORD InfoIdx;

    for (InfoIdx = 0; InfoIdx < cCrlInfo; InfoIdx++) {
        DWORD cEntry = rgpCrlInfo[InfoIdx]->cCRLEntry;
        PCRL_ENTRY rgEntry = rgpCrlInfo[InfoIdx]->rgCRLEntry;
        DWORD EntryIdx;

        for (EntryIdx = 0; EntryIdx < cEntry; EntryIdx++) {
            if (CertCompareIntegerBlob(&rgEntry[EntryIdx].SerialNumber,
                    &pCertId->SerialNumber))
                // It has been revoked!!!
                return FALSE;
        }
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Convert the CAPI AlgId to the ASN.1 Object Identifier string
//
//  Returns NULL if there isn't an ObjId corresponding to the AlgId.
//--------------------------------------------------------------------------
LPCSTR
WINAPI
CertAlgIdToOID(
    IN DWORD dwAlgId
    )
{
    DWORD dwGroupId;

    for (dwGroupId = CRYPT_FIRST_ALG_OID_GROUP_ID;
            dwGroupId <= CRYPT_LAST_ALG_OID_GROUP_ID; dwGroupId++) {
        PCCRYPT_OID_INFO pInfo;
        if (pInfo = CryptFindOIDInfo(
                CRYPT_OID_INFO_ALGID_KEY,
                &dwAlgId,
                dwGroupId
                ))
            return pInfo->pszOID;
    }
    return NULL;
}

//+-------------------------------------------------------------------------
//  Convert the ASN.1 Object Identifier string to the CAPI AlgId.
//
//  Returns 0 if there isn't an AlgId corresponding to the ObjId.
//--------------------------------------------------------------------------
DWORD
WINAPI
CertOIDToAlgId(
    IN LPCSTR pszObjId
    )
{
    DWORD dwGroupId;

    for (dwGroupId = CRYPT_FIRST_ALG_OID_GROUP_ID;
            dwGroupId <= CRYPT_LAST_ALG_OID_GROUP_ID; dwGroupId++) {
        PCCRYPT_OID_INFO pInfo;
        if (pInfo = CryptFindOIDInfo(
                CRYPT_OID_INFO_OID_KEY,
                (void *) pszObjId,
                dwGroupId
                ))
            return pInfo->Algid;
    }
    return 0;
}

//+-------------------------------------------------------------------------
//  Find an extension identified by its Object Identifier.
//
//  If found, returns pointer to the extension. Otherwise, returns NULL.
//--------------------------------------------------------------------------
PCERT_EXTENSION
WINAPI
CertFindExtension(
    IN LPCSTR pszObjId,
    IN DWORD cExtensions,
    IN CERT_EXTENSION rgExtensions[]
    )
{
    for (; cExtensions > 0; cExtensions--, rgExtensions++) {
        if (strcmp(pszObjId, rgExtensions->pszObjId) == 0)
            return rgExtensions;
    }
    return NULL;
}

//+-------------------------------------------------------------------------
//  Find the first attribute identified by its Object Identifier.
//
//  If found, returns pointer to the attribute. Otherwise, returns NULL.
//--------------------------------------------------------------------------
PCRYPT_ATTRIBUTE
WINAPI
CertFindAttribute(
    IN LPCSTR pszObjId,
    IN DWORD cAttr,
    IN CRYPT_ATTRIBUTE rgAttr[]
    )
{
    for (; cAttr > 0; cAttr--, rgAttr++) {
        if (strcmp(pszObjId, rgAttr->pszObjId) == 0)
            return rgAttr;
    }
    return NULL;
}

//+-------------------------------------------------------------------------
//  Find the first CERT_RDN attribute identified by its Object Identifier in
//  the name's list of Relative Distinguished Names.
//
//  If found, returns pointer to the attribute. Otherwise, returns NULL.
//--------------------------------------------------------------------------
PCERT_RDN_ATTR
WINAPI
CertFindRDNAttr(
    IN LPCSTR pszObjId,
    IN PCERT_NAME_INFO pName
    )
{
    DWORD cRDN = pName->cRDN;
    PCERT_RDN pRDN = pName->rgRDN;
    for ( ; cRDN > 0; cRDN--, pRDN++) {
        DWORD cRDNAttr = pRDN->cRDNAttr;
        PCERT_RDN_ATTR pRDNAttr = pRDN->rgRDNAttr;
        for (; cRDNAttr > 0; cRDNAttr--, pRDNAttr++) {
            if (strcmp(pszObjId, pRDNAttr->pszObjId) == 0)
                return pRDNAttr;
        }
    }
    return NULL;
}

//+-------------------------------------------------------------------------
//  Get the intended key usage bytes from the certificate.
//
//  If the certificate doesn't have any intended key usage bytes, returns FALSE
//  and *pbKeyUsage is zeroed. Otherwise, returns TRUE and up through
//  cbKeyUsage bytes are copied into *pbKeyUsage. Any remaining uncopied
//  bytes are zeroed.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertGetIntendedKeyUsage(
    IN DWORD dwCertEncodingType,
    IN PCERT_INFO pCertInfo,
    OUT BYTE *pbKeyUsage,
    IN DWORD cbKeyUsage
    )
{
    BOOL fResult;
    DWORD cbData;
    PCERT_EXTENSION pExt;
    PCERT_KEY_ATTRIBUTES_INFO pKeyAttrInfo = NULL;
    PCRYPT_BIT_BLOB pAllocKeyUsage = NULL;
    PCRYPT_BIT_BLOB pKeyUsage = NULL;          // not allocated

    // First see if the certificate has the simple Key Usage Extension
    if (NULL != (pExt = CertFindExtension(
            szOID_KEY_USAGE,
            pCertInfo->cExtension,
            pCertInfo->rgExtension
            ))  &&
        NULL != (pAllocKeyUsage =
            (PCRYPT_BIT_BLOB) AllocAndDecodeObject(
                dwCertEncodingType,
                X509_KEY_USAGE,
                pExt->Value.pbData,
                pExt->Value.cbData
                )))
        pKeyUsage = pAllocKeyUsage;
    else {
        pExt = CertFindExtension(
                szOID_KEY_ATTRIBUTES,
                pCertInfo->cExtension,
                pCertInfo->rgExtension
                );
        if (pExt == NULL) goto GetError;
    
        if (NULL == (pKeyAttrInfo =
            (PCERT_KEY_ATTRIBUTES_INFO) AllocAndDecodeObject(
                dwCertEncodingType,
                X509_KEY_ATTRIBUTES,
                pExt->Value.pbData,
                pExt->Value.cbData
                ))) goto ErrorReturn;
        pKeyUsage = &pKeyAttrInfo->IntendedKeyUsage;
    }

    if (pKeyUsage->cbData == 0 || cbKeyUsage == 0)
        goto GetError;

    cbData = min(pKeyUsage->cbData, cbKeyUsage);
    memcpy(pbKeyUsage, pKeyUsage->pbData, cbData);
    fResult = TRUE;
    goto CommonReturn;

GetError:
    SetLastError(0);
ErrorReturn:
    fResult = FALSE;
    cbData = 0;
CommonReturn:
    PkiFree(pAllocKeyUsage);
    PkiFree(pKeyAttrInfo);
    if (cbData < cbKeyUsage)
        memset(pbKeyUsage + cbData, 0, cbKeyUsage - cbData);
    return fResult;
}

static DWORD GetYPublicKeyLength(
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pPublicKeyInfo
    )
{
    PCRYPT_UINT_BLOB pY = NULL;
    DWORD dwBitLen;

    if (NULL == (pY = (PCRYPT_UINT_BLOB) AllocAndDecodeObject(
            dwCertEncodingType,
            X509_MULTI_BYTE_UINT,
            pPublicKeyInfo->PublicKey.pbData,
            pPublicKeyInfo->PublicKey.cbData
            ))) goto DecodePubKeyError;

    dwBitLen = pY->cbData * 8;

CommonReturn:
    PkiFree(pY);
    return dwBitLen;
ErrorReturn:
    dwBitLen = 0;
    goto CommonReturn;

TRACE_ERROR(DecodePubKeyError)
}

// If there are parameters, use the length of the 'P' parameter. Otherwise,
// use the length of Y. Note, P's MSB must be set. Y's MSB may not be set.
static DWORD GetDHPublicKeyLength(
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pPublicKey
    )
{
    PCERT_X942_DH_PARAMETERS pDhParameters = NULL;
    DWORD dwBitLen;

    if (0 == pPublicKey->Algorithm.Parameters.cbData)
        goto NoDhParametersError;
    if (NULL == (pDhParameters =
                    (PCERT_X942_DH_PARAMETERS) AllocAndDecodeObject(
            dwCertEncodingType,
            X942_DH_PARAMETERS,
            pPublicKey->Algorithm.Parameters.pbData,
            pPublicKey->Algorithm.Parameters.cbData
            ))) goto DecodeParametersError;

    dwBitLen = pDhParameters->p.cbData * 8;

CommonReturn:
    PkiFree(pDhParameters);
    return dwBitLen;
ErrorReturn:
    dwBitLen = GetYPublicKeyLength(dwCertEncodingType, pPublicKey);
    goto CommonReturn;

TRACE_ERROR(NoDhParametersError)
TRACE_ERROR(DecodeParametersError)
}

// If there are parameters, use the length of the 'P' parameter. Otherwise,
// use the length of Y. Note, P's MSB must be set. Y's MSB may not be set.
static DWORD GetDSSPublicKeyLength(
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pPublicKey
    )
{
    PCERT_DSS_PARAMETERS pDssParameters = NULL;
    DWORD dwBitLen;

    if (0 == pPublicKey->Algorithm.Parameters.cbData)
        goto NoDssParametersError;
    if (NULL == (pDssParameters = (PCERT_DSS_PARAMETERS) AllocAndDecodeObject(
            dwCertEncodingType,
            X509_DSS_PARAMETERS,
            pPublicKey->Algorithm.Parameters.pbData,
            pPublicKey->Algorithm.Parameters.cbData
            ))) goto DecodeParametersError;

    dwBitLen = pDssParameters->p.cbData * 8;

CommonReturn:
    PkiFree(pDssParameters);
    return dwBitLen;
ErrorReturn:
    dwBitLen = GetYPublicKeyLength(dwCertEncodingType, pPublicKey);
    goto CommonReturn;

TRACE_ERROR(NoDssParametersError)
TRACE_ERROR(DecodeParametersError)
}

//+-------------------------------------------------------------------------
//  Get the public/private key's bit length.
//
//  Returns 0 if unable to determine the key's length.
//--------------------------------------------------------------------------
DWORD
WINAPI
CertGetPublicKeyLength(
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pPublicKey
    )
{
    DWORD dwErr = 0;
    DWORD dwBitLen;
    ALG_ID aiPubKey;
    PCCRYPT_OID_INFO pOIDInfo;
    HCRYPTPROV hCryptProv;          // don't need to release
    HCRYPTKEY hPubKey = 0;
    DWORD cbData;

    if (pOIDInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            pPublicKey->Algorithm.pszObjId,
            CRYPT_PUBKEY_ALG_OID_GROUP_ID))
        aiPubKey = pOIDInfo->Algid;
    else
        aiPubKey = 0;

    if (aiPubKey == CALG_DH_SF || aiPubKey == CALG_DH_EPHEM)
        return GetDHPublicKeyLength(
            dwCertEncodingType,
            pPublicKey
            );

    if (aiPubKey == CALG_DSS_SIGN)
        return GetDSSPublicKeyLength(
            dwCertEncodingType,
            pPublicKey
            );

    if (0 == (hCryptProv = I_CryptGetDefaultCryptProv(aiPubKey)))
        goto GetDefaultCryptProvError;
    if (!CryptImportPublicKeyInfo(
            hCryptProv,
            dwCertEncodingType,
            pPublicKey,
            &hPubKey
            )) goto ImportPublicKeyError;

    cbData = sizeof(dwBitLen);
    if (CryptGetKeyParam(
            hPubKey,
            KP_KEYLEN,
            (BYTE *) &dwBitLen,
            &cbData,
            0))                 // dwFlags
        goto CommonReturn;

    cbData = sizeof(dwBitLen);
    if (CryptGetKeyParam(
            hPubKey,
            KP_BLOCKLEN,
            (BYTE *) &dwBitLen,
            &cbData,
            0))                 // dwFlags
        goto CommonReturn;


    {
        // The CSP should have supported one of the above

        // Export the public key and look at the bitlen field.
        // The CAPI public key representation consists of the following
        //  sequence:
        //  - PUBLICKEYSTRUC
        //  - DSSPUBKEY | RSAPUBKEY (DSSPUBKEY is subset of RSAPUBKEY)
        //  ...

        BYTE *pbPubKey = NULL;
        DWORD cbPubKey;

        dwBitLen = 0;
        dwErr = GetLastError();
        cbPubKey = 0;
        if (CryptExportKey(
                    hPubKey,
                    0,              // hPubKey
                    PUBLICKEYBLOB,
                    0,              // dwFlags
                    NULL,           // pbData
                    &cbPubKey
                    ) &&
                cbPubKey >= (sizeof(PUBLICKEYSTRUC) + sizeof(DSSPUBKEY)) &&
                NULL != (pbPubKey = (BYTE *) PkiNonzeroAlloc(cbPubKey))) {
            if (CryptExportKey(
                    hPubKey,
                    0,              // hPubKey
                    PUBLICKEYBLOB,
                    0,              // dwFlags
                    pbPubKey,
                    &cbPubKey
                    )) {
                DSSPUBKEY *pPubKey =
                    (DSSPUBKEY *) (pbPubKey + sizeof(PUBLICKEYSTRUC));
                dwBitLen = pPubKey->bitlen;
            }
            PkiFree(pbPubKey);
        }
        if (0 != dwBitLen)
            goto CommonReturn;
        SetLastError(dwErr);
        goto GetKeyParamError;
    }

CommonReturn:
    if (hPubKey)
        CryptDestroyKey(hPubKey);
    SetLastError(dwErr);
    return dwBitLen;
ErrorReturn:
    dwBitLen = 0;
    dwErr = GetLastError();
    goto CommonReturn;
TRACE_ERROR(GetDefaultCryptProvError)
TRACE_ERROR(ImportPublicKeyError)
TRACE_ERROR(GetKeyParamError)
}

//+-------------------------------------------------------------------------
//  Compute the hash of the encoded public key info.
//
//  The public key info is encoded and then hashed.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptHashPublicKeyInfo(
    IN HCRYPTPROV hCryptProv,
    IN ALG_ID Algid,
    IN DWORD dwFlags,
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pInfo,
    OUT BYTE *pbComputedHash,
    IN OUT DWORD *pcbComputedHash
    )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    if (!AllocAndEncodeObject(
            dwCertEncodingType,
            X509_PUBLIC_KEY_INFO,
            pInfo,
            &pbEncoded,
            &cbEncoded
            ))
        goto ErrorReturn;

    fResult = CryptHashCertificate(
            hCryptProv,
            Algid ? Algid : CALG_MD5,
            dwFlags,
            pbEncoded,
            cbEncoded,
            pbComputedHash,
            pcbComputedHash
            );
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
    *pcbComputedHash = 0;
    
CommonReturn:
    PkiFree(pbEncoded);
    return fResult;
}



//+-------------------------------------------------------------------------
//  Compares the certificate's public key with the provider's public key
//  to see if they are identical.
//
//  Returns TRUE if the keys are identical.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertCompareCertAndProviderPublicKey(
    IN PCCERT_CONTEXT pCert,
    IN HCRYPTPROV hProv,
    IN DWORD dwKeySpec
    )
{
    BOOL fResult;
    PCERT_PUBLIC_KEY_INFO pProvPubKeyInfo = NULL;
    DWORD cbProvPubKeyInfo;
    DWORD dwCertEncodingType = pCert->dwCertEncodingType;

    // Get provider's public key
    if (!CryptExportPublicKeyInfo(
            hProv,
            dwKeySpec,
            dwCertEncodingType,
            NULL,               // pProvPubKeyInfo
            &cbProvPubKeyInfo
            ))
        goto ExportPublicKeyInfoError;
    assert(cbProvPubKeyInfo);
    if (NULL == (pProvPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) PkiNonzeroAlloc(
            cbProvPubKeyInfo)))
        goto OutOfMemory;
    if (!CryptExportPublicKeyInfo(
            hProv,
            dwKeySpec,
            dwCertEncodingType,
            pProvPubKeyInfo,
            &cbProvPubKeyInfo
            ))
        goto ExportPublicKeyInfoError;

    if (!CertComparePublicKeyInfo(
            dwCertEncodingType,
            &pCert->pCertInfo->SubjectPublicKeyInfo,
            pProvPubKeyInfo
            ))
        goto ComparePublicKeyError;

    fResult = TRUE;
CommonReturn:
    PkiFree(pProvPubKeyInfo);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(ExportPublicKeyInfoError)
TRACE_ERROR(OutOfMemory)
SET_ERROR(ComparePublicKeyError, NTE_BAD_PUBLIC_KEY)
}

//+=========================================================================
//  CryptFindCertificateKeyProvInfo Support Functions
//-=========================================================================
static BOOL HasValidKeyProvInfo(
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwFindKeySetFlags
    )
{
    BOOL fResult;
    PCRYPT_KEY_PROV_INFO pKeyProvInfo = NULL;
    HCRYPTPROV hProv = 0;
    DWORD cbData;
    DWORD dwAcquireFlags;

    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_KEY_PROV_INFO_PROP_ID,
            NULL,                       // pvData
            &cbData
            ))
        return FALSE;
    if (NULL == (pKeyProvInfo = (PCRYPT_KEY_PROV_INFO) PkiNonzeroAlloc(
            cbData)))
        goto OutOfMemory;
    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_KEY_PROV_INFO_PROP_ID,
            pKeyProvInfo,
            &cbData
            ))
        goto GetKeyProvInfoPropertyError;

    if (pKeyProvInfo->dwFlags & CRYPT_MACHINE_KEYSET) {
        if (0 == (dwFindKeySetFlags & CRYPT_FIND_MACHINE_KEYSET_FLAG))
            goto NotUserContainer;
    } else {
        if (0 == (dwFindKeySetFlags & CRYPT_FIND_USER_KEYSET_FLAG))
            goto NotMachineContainer;
    }

    dwAcquireFlags = CRYPT_ACQUIRE_COMPARE_KEY_FLAG;
    if (dwFindKeySetFlags & CRYPT_FIND_SILENT_KEYSET_FLAG)
        dwAcquireFlags |= CRYPT_ACQUIRE_SILENT_FLAG;

    if (!CryptAcquireCertificatePrivateKey(
            pCert,
            dwAcquireFlags,
            NULL,                   // pvReserved
            &hProv,
            NULL,                   // pdwKeySpec
            NULL                    // pfCallerFreeProv
            ))
        goto AcquireCertPrivateKeyError;

    fResult = TRUE;
CommonReturn:
    PkiFree(pKeyProvInfo);
    if (hProv) {
        DWORD dwErr = GetLastError();
        CryptReleaseContext(hProv, 0);
        SetLastError(dwErr);
    }
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
TRACE_ERROR(GetKeyProvInfoPropertyError)
SET_ERROR(NotUserContainer, NTE_NOT_FOUND)
SET_ERROR(NotMachineContainer, NTE_NOT_FOUND)
TRACE_ERROR(AcquireCertPrivateKeyError)
}


// Default to Algid being supported. Only return FALSE if successfully
// enumerated all the provider algorithms and didn't find a match.
static BOOL IsPublicKeyAlgidSupported(
    IN PCCERT_CONTEXT pCert,
    IN HCRYPTPROV hProv,
    IN ALG_ID aiPubKey
    )
{
    BOOL fResult;
    DWORD dwErr;
    BYTE *pbData = NULL;
    DWORD cbMaxData;
    DWORD cbData;
    DWORD dwFlags;

    if (0 == aiPubKey)
        return TRUE;

    // Get maximum length of provider algorithm parameter data
    cbMaxData = 0;
    if (!CryptGetProvParam(
            hProv,
            PP_ENUMALGS,
            NULL,           // pbData
            &cbMaxData,
            CRYPT_FIRST     // dwFlags
            )) {
        dwErr = GetLastError();
        if (ERROR_MORE_DATA != dwErr)
            goto GetProvAlgParamError;
    }
    if (0 == cbMaxData)
        goto NoProvAlgParamError;
    if (NULL == (pbData = (BYTE *) PkiNonzeroAlloc(cbMaxData)))
        goto OutOfMemory;

    dwFlags = CRYPT_FIRST;
    while (TRUE) {
        ALG_ID aiProv;

        cbData = cbMaxData;
        if (!CryptGetProvParam(
                hProv,
                PP_ENUMALGS,
                pbData,
                &cbData,
                dwFlags
                )) {
            dwErr = GetLastError();
            if (ERROR_NO_MORE_ITEMS == dwErr) {
                fResult = FALSE;
                goto PublicKeyAlgidNotSupported;
            } else
                goto GetProvAlgParamError;
        }
        assert(cbData >= sizeof(ALG_ID));
        aiProv = *(ALG_ID *) pbData;
        // Don't distinguish between exchange or signature
        if (GET_ALG_TYPE(aiPubKey) == GET_ALG_TYPE(aiProv))
            break;

        dwFlags = 0;    // CRYPT_NEXT
    }
    fResult = TRUE;

PublicKeyAlgidNotSupported:
CommonReturn:
    PkiFree(pbData);
    return fResult;
ErrorReturn:
    // For an error, assume the public key algorithm is supported.
    fResult = TRUE;
    goto CommonReturn;

SET_ERROR_VAR(GetProvAlgParamError, dwErr)
SET_ERROR(NoProvAlgParamError, NTE_NOT_FOUND)
TRACE_ERROR(OutOfMemory)
}

// For success, updates the certificate's KEY_PROV_INFO property
//
// If container isn't found, LastError is set to ERROR_NO_MORE_ITEMS.
//
static BOOL FindContainerAndSetKeyProvInfo(
    IN PCCERT_CONTEXT pCert,
    IN HCRYPTPROV hProv,
    IN LPWSTR pwszProvName,
    IN DWORD dwProvType,
    IN DWORD dwProvFlags        // CRYPT_MACHINE_KEYSET and/or CRYPT_SILENT
    )
{
    BOOL fResult;
    DWORD dwEnumFlags;
    DWORD dwEnumErr = 0;
    DWORD dwAcquireErr = 0;
    LPSTR pszContainerName = NULL;
    DWORD cchContainerName;
    DWORD cchMaxContainerName;
    LPWSTR pwszContainerName = NULL;

    // Get maximum container name length
    cchMaxContainerName = 0;
    if (!CryptGetProvParam(
            hProv,
            PP_ENUMCONTAINERS,
            NULL,           // pbData
            &cchMaxContainerName,
            CRYPT_FIRST
            )) {
        dwEnumErr = GetLastError();
        if (ERROR_FILE_NOT_FOUND == dwEnumErr ||
                ERROR_INVALID_PARAMETER == dwEnumErr)
            goto PublicKeyContainerNotFound;
        else if (ERROR_MORE_DATA != dwEnumErr)
            goto EnumContainersError;
    }
    if (0 == cchMaxContainerName)
        goto PublicKeyContainerNotFound;
    if (NULL == (pszContainerName = (LPSTR) PkiNonzeroAlloc(
            cchMaxContainerName + 1)))
        goto OutOfMemory;

    dwEnumFlags = CRYPT_FIRST;
    while (TRUE) {
        HCRYPTPROV hContainerProv = 0;
        LPWSTR pwszAcquireProvName = pwszProvName;

        cchContainerName = cchMaxContainerName;
        if (!CryptGetProvParam(
                hProv,
                PP_ENUMCONTAINERS,
                (BYTE *) pszContainerName,
                &cchContainerName,
                dwEnumFlags
                )) {
            dwEnumErr = GetLastError();
            if (ERROR_NO_MORE_ITEMS == dwEnumErr ||
                    ERROR_FILE_NOT_FOUND == dwEnumErr) {
                if (0 != dwAcquireErr)
                    goto CryptAcquireContextError;
                else
                    goto PublicKeyContainerNotFound;
            } else
                goto EnumContainersError;
        }
        dwEnumFlags = 0;        // CRYPT_NEXT

        if (NULL == (pwszContainerName = MkWStr(pszContainerName)))
            goto OutOfMemory;

        // First try using enhanced providers for the base guys
        if (PROV_RSA_FULL == dwProvType &&
                0 == _wcsicmp(pwszProvName, MS_DEF_PROV_W)) {
            fResult = CryptAcquireContextU(
                    &hContainerProv,
                    pwszContainerName,
                    MS_ENHANCED_PROV_W,
                    PROV_RSA_FULL,
                    dwProvFlags
                    );
            if (fResult)
                pwszAcquireProvName = MS_ENHANCED_PROV_W;
        } else if (PROV_DSS_DH == dwProvType &&
                0 == _wcsicmp(pwszProvName, MS_DEF_DSS_DH_PROV_W)) {
            fResult = CryptAcquireContextU(
                &hContainerProv,
                pwszContainerName,
                MS_ENH_DSS_DH_PROV_W,
                PROV_DSS_DH,
                dwProvFlags
                );
            if (fResult)
                pwszAcquireProvName = MS_ENH_DSS_DH_PROV_W;
        } else
            fResult = FALSE;

        if (!fResult)
            fResult = CryptAcquireContextU(
                &hContainerProv,
                pwszContainerName,
                pwszAcquireProvName,
                dwProvType,
                dwProvFlags
                );

        if (!fResult)
            dwAcquireErr = GetLastError();
        else {
            DWORD dwKeySpec;

            dwKeySpec = AT_KEYEXCHANGE;
            fResult = FALSE;
            while (TRUE) {
                if (I_CertCompareCertAndProviderPublicKey(
                        pCert,
                        hContainerProv,
                        dwKeySpec
                        )) {
                    fResult = TRUE;
                    break;
                } else if (AT_SIGNATURE == dwKeySpec)
                    break;
                else
                    dwKeySpec = AT_SIGNATURE;
            }
            CryptReleaseContext(hContainerProv, 0);

            if (fResult) {
                CRYPT_KEY_PROV_INFO KeyProvInfo;

                memset(&KeyProvInfo, 0, sizeof(KeyProvInfo));
                KeyProvInfo.pwszContainerName = pwszContainerName;
                KeyProvInfo.pwszProvName = pwszAcquireProvName;
                KeyProvInfo.dwProvType = dwProvType;
                KeyProvInfo.dwFlags = dwProvFlags & ~CRYPT_SILENT;
                KeyProvInfo.dwKeySpec = dwKeySpec;

                if (!CertSetCertificateContextProperty(
                        pCert,
                        CERT_KEY_PROV_INFO_PROP_ID,
                        0,                              // dwFlags
                        &KeyProvInfo
                        ))
                    goto SetKeyProvInfoPropertyError;
                else
                    goto SuccessReturn;
            }
        }

        FreeWStr(pwszContainerName);
        pwszContainerName = NULL;
    }

    goto UnexpectedError;

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    PkiFree(pszContainerName);
    FreeWStr(pwszContainerName);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR_VAR(EnumContainersError, dwEnumErr)
TRACE_ERROR(OutOfMemory)
SET_ERROR_VAR(CryptAcquireContextError, dwAcquireErr)
SET_ERROR(PublicKeyContainerNotFound, ERROR_NO_MORE_ITEMS)
TRACE_ERROR(SetKeyProvInfoPropertyError)
SET_ERROR(UnexpectedError, E_UNEXPECTED)
}

//+-------------------------------------------------------------------------
//  Enumerates the cryptographic providers and their containers to find the
//  private key corresponding to the certificate's public key. For a match,
//  the certificate's CERT_KEY_PROV_INFO_PROP_ID property is updated.
//
//  If the CERT_KEY_PROV_INFO_PROP_ID is already set, then, its checked to
//  see if it matches the provider's public key. For a match, the above
//  enumeration is skipped.
//
//  By default both the user and machine key containers are searched.
//  The CRYPT_FIND_USER_KEYSET_FLAG or CRYPT_FIND_MACHINE_KEYSET_FLAG
//  can be set in dwFlags to restrict the search to either of the containers.
//
//  The CRYPT_FIND_SILENT_KEYSET_FLAG can be set to suppress any UI by the CSP.
//  See CryptAcquireContext's CRYPT_SILENT flag for more details.
//
//  If a container isn't found, returns FALSE with LastError set to
//  NTE_NO_KEY.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptFindCertificateKeyProvInfo(
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwFlags,
    IN void *pvReserved
    )
{
    BOOL fResult;
    DWORD dwFindContainerErr = ERROR_NO_MORE_ITEMS;
    DWORD dwAcquireErr = 0;
    DWORD dwProvIndex;
    PCCRYPT_OID_INFO pOIDInfo;
    ALG_ID aiPubKey;

    if (0 == (dwFlags &
            (CRYPT_FIND_USER_KEYSET_FLAG | CRYPT_FIND_MACHINE_KEYSET_FLAG)))
        dwFlags |=
            CRYPT_FIND_USER_KEYSET_FLAG | CRYPT_FIND_MACHINE_KEYSET_FLAG;

    if (HasValidKeyProvInfo(pCert, dwFlags))
        return TRUE;

    if (pOIDInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId,
            CRYPT_PUBKEY_ALG_OID_GROUP_ID
            ))
        aiPubKey = pOIDInfo->Algid;
    else
        aiPubKey = 0;
    

    for (dwProvIndex = 0; TRUE; dwProvIndex++) {
        LPWSTR pwszProvName;
        DWORD cbProvName;
        HCRYPTPROV hProv;
        DWORD dwProvType;

        cbProvName = 0;
        dwProvType = 0;
        if (!CryptEnumProvidersU(
                dwProvIndex,
                NULL,               // pdwReserved
                0,                  // dwFlags
                &dwProvType,
                NULL,               // pwszProvName,
                &cbProvName
                ) || 0 == cbProvName) {
            if (0 == dwProvIndex)
                goto EnumProvidersError;
            else if (ERROR_NO_MORE_ITEMS != dwFindContainerErr)
                goto FindContainerError;
            else if (0 != dwAcquireErr)
                goto CryptAcquireContextError;
            else
                goto KeyContainerNotFound;
        }
        if (NULL == (pwszProvName = (LPWSTR) PkiNonzeroAlloc(
                (cbProvName + 1) * sizeof(WCHAR))))
            goto OutOfMemory;
        if (!CryptEnumProvidersU(
                dwProvIndex,
                NULL,               // pdwReserved
                0,                  // dwFlags
                &dwProvType,
                pwszProvName,
                &cbProvName
                )) {
            PkiFree(pwszProvName);
            goto EnumProvidersError;
        }

        fResult = FALSE;
        if (!CryptAcquireContextU(
                &hProv,
                NULL,               // pwszContainerName,
                pwszProvName,
                dwProvType,
                CRYPT_VERIFYCONTEXT // dwFlags
                )) {
            dwAcquireErr = GetLastError();
            hProv = 0;   // CAPI bug, sets hCryptProv to nonzero
        } else if (IsPublicKeyAlgidSupported(
                pCert,
                hProv,
                aiPubKey
                )) {
            DWORD dwSetProvFlags;
            if (dwFlags & CRYPT_FIND_SILENT_KEYSET_FLAG)
                dwSetProvFlags = CRYPT_SILENT;
            else
                dwSetProvFlags = 0;

            if (dwFlags & CRYPT_FIND_USER_KEYSET_FLAG) {
                if (FindContainerAndSetKeyProvInfo(
                        pCert,
                        hProv,
                        pwszProvName,
                        dwProvType,
                        dwSetProvFlags
                        ))
                    fResult = TRUE;
                else if (ERROR_NO_MORE_ITEMS == dwFindContainerErr)
                    dwFindContainerErr = GetLastError();
            }

            if (!fResult && (dwFlags & CRYPT_FIND_MACHINE_KEYSET_FLAG)) {
                CryptReleaseContext(hProv, 0);

                if (!CryptAcquireContextU(
                        &hProv,
                        NULL,               // pwszContainerName,
                        pwszProvName,
                        dwProvType,
                        CRYPT_VERIFYCONTEXT | CRYPT_MACHINE_KEYSET  // dwFlags
                        )) {
                    dwAcquireErr = GetLastError();
                    hProv = 0;   // CAPI bug, sets hCryptProv to nonzero
                } else {
                    if (FindContainerAndSetKeyProvInfo(
                            pCert,
                            hProv,
                            pwszProvName,
                            dwProvType,
                            dwSetProvFlags | CRYPT_MACHINE_KEYSET
                            ))
                        fResult = TRUE;
                    else if (ERROR_NO_MORE_ITEMS == dwFindContainerErr)
                        dwFindContainerErr = GetLastError();
                }
            }
        }

        if (hProv)
            CryptReleaseContext(hProv, 0);
        PkiFree(pwszProvName);
        if (fResult)
            goto CommonReturn;
    }

    goto UnexpectedError;

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(EnumProvidersError)
SET_ERROR(KeyContainerNotFound, NTE_NO_KEY)
SET_ERROR_VAR(FindContainerError, dwFindContainerErr)
SET_ERROR_VAR(CryptAcquireContextError, dwAcquireErr)
TRACE_ERROR(OutOfMemory)
SET_ERROR(UnexpectedError, E_UNEXPECTED)
}



//+=========================================================================
//  CryptCreatePublicKeyInfo, EncodePublicKeyAndParameters
//  and CryptConvertPublicKeyInfo functions
//-=========================================================================

static BOOL EncodePublicKeyInfo(
    IN LPCSTR pszPubKeyOID,
    IN BYTE *pbEncodedPubKey,
    IN DWORD cbEncodedPubKey,
    IN BYTE *pbEncodedParameters,
    IN DWORD cbEncodedParameters,
    OUT PCERT_PUBLIC_KEY_INFO pInfo,
    IN OUT DWORD *pcbInfo
    )
{
    BOOL fResult;
    BYTE *pbExtra;
    LONG lRemainExtra;
    DWORD cbOID;

    if (pInfo == NULL)
        *pcbInfo = 0;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbInfo - sizeof(CERT_PUBLIC_KEY_INFO);
    if (lRemainExtra < 0)
        pbExtra = NULL;
    else
        pbExtra = (BYTE *) pInfo + sizeof(CERT_PUBLIC_KEY_INFO);

    cbOID = strlen(pszPubKeyOID) + 1;
    lRemainExtra -= INFO_LEN_ALIGN(cbOID) +
        INFO_LEN_ALIGN(cbEncodedParameters) + cbEncodedPubKey;
    if (lRemainExtra >= 0) {
        memset(pInfo, 0, sizeof(CERT_PUBLIC_KEY_INFO));
        pInfo->Algorithm.pszObjId = (LPSTR) pbExtra;
        memcpy(pbExtra, pszPubKeyOID, cbOID);
        pbExtra += INFO_LEN_ALIGN(cbOID);
        if (cbEncodedParameters) {
            pInfo->Algorithm.Parameters.cbData = cbEncodedParameters;
            pInfo->Algorithm.Parameters.pbData = pbExtra;
            memcpy(pbExtra, pbEncodedParameters, cbEncodedParameters);
            pbExtra += INFO_LEN_ALIGN(cbEncodedParameters);
        }

        pInfo->PublicKey.pbData = pbExtra;
        pInfo->PublicKey.cbData = cbEncodedPubKey;
        memcpy(pbExtra, pbEncodedPubKey, cbEncodedPubKey);

        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    } else {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (pInfo) goto LengthError;
    }
    fResult = TRUE;

CommonReturn:
    return fResult;

LengthError:
    SetLastError((DWORD) ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;
}

//  By default, the pPubKeyStruc->aiKeyAlg is used to find the appropriate
//  public key Object Identifier. pszPubKeyOID can be set to override
//  the default OID obtained from the aiKeyAlg.
BOOL
WINAPI
CryptCreatePublicKeyInfo(
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPCSTR pszPubKeyOID,
    IN const PUBLICKEYSTRUC *pPubKeyStruc,
    IN DWORD cbPubKeyStruc,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT void *pvPubKeyInfo,
    IN OUT DWORD *pcbPubKeyInfo
    )
{
    BOOL fResult;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;
    LPCSTR pszEncodePubKeyOID;

    BYTE *pbEncodedPubKey = NULL;
    DWORD cbEncodedPubKey = 0;
    BYTE *pbEncodedParameters = NULL;
    DWORD cbEncodedParameters = 0;

    PCERT_PUBLIC_KEY_INFO pPubKeyInfo = NULL;
    DWORD cbPubKeyInfo;

    if (NULL == pszPubKeyOID) {
        PCCRYPT_OID_INFO pInfo;
        if (NULL == (pInfo = CryptFindOIDInfo(
                CRYPT_OID_INFO_ALGID_KEY,
                (void *) &pPubKeyStruc->aiKeyAlg,
                CRYPT_PUBKEY_ALG_OID_GROUP_ID
                )))
            goto NoPubKeyOIDInfo;
         pszEncodePubKeyOID = pInfo->pszOID;
    } else
        pszEncodePubKeyOID = pszPubKeyOID;

    if (!CryptGetOIDFunctionAddress(
            hEncodePubKeyFuncSet,
            dwCertEncodingType,
            pszEncodePubKeyOID,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        PCCRYPT_OID_INFO pInfo;

        if (NULL == pszPubKeyOID)
            goto NoEncodePubKeyFunction;

        if (NULL == (pInfo = CryptFindOIDInfo(
                CRYPT_OID_INFO_ALGID_KEY,
                (void *) &pPubKeyStruc->aiKeyAlg,
                CRYPT_PUBKEY_ALG_OID_GROUP_ID
                )))
            goto NoPubKeyOIDInfo;
         pszEncodePubKeyOID = pInfo->pszOID;

        if (!CryptGetOIDFunctionAddress(
                hEncodePubKeyFuncSet,
                dwCertEncodingType,
                pszEncodePubKeyOID,
                0,                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr))
            goto NoEncodePubKeyFunction;
    }

    if (NULL == pszPubKeyOID)
        pszPubKeyOID = pszEncodePubKeyOID;

    fResult = ((PFN_CRYPT_ENCODE_PUBLIC_KEY_AND_PARAMETERS) pvFuncAddr)(
        dwCertEncodingType,
        pszPubKeyOID,
        pPubKeyStruc,
        cbPubKeyStruc,
        dwFlags,
        pvReserved,
        &pbEncodedPubKey,
        &cbEncodedPubKey,
        &pbEncodedParameters,
        &cbEncodedParameters
        );
    CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    if (!fResult)
        goto EncodePubKeyAndParametersError;

    if (dwFlags & CRYPT_ALLOC_FLAG) {
        if (!EncodePublicKeyInfo(
                pszPubKeyOID,
                pbEncodedPubKey,
                cbEncodedPubKey,
                pbEncodedParameters,
                cbEncodedParameters,
                NULL,                   // pPubKeyInfo
                &cbPubKeyInfo
                ))
            goto EncodePublicKeyInfoError;
        if (NULL == (pPubKeyInfo =
                (PCERT_PUBLIC_KEY_INFO) PkiDefaultCryptAlloc(cbPubKeyInfo)))
            goto OutOfMemory;
        *((PCERT_PUBLIC_KEY_INFO *) pvPubKeyInfo) = pPubKeyInfo;
    } else {
        pPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) pvPubKeyInfo;
        cbPubKeyInfo = *pcbPubKeyInfo;
    }

    fResult = EncodePublicKeyInfo(
        pszPubKeyOID,
        pbEncodedPubKey,
        cbEncodedPubKey,
        pbEncodedParameters,
        cbEncodedParameters,
        pPubKeyInfo,
        &cbPubKeyInfo
        );

    if (!fResult && (dwFlags & CRYPT_ALLOC_FLAG))
        goto ErrorReturn;

CommonReturn:
    PkiDefaultCryptFree(pbEncodedPubKey);
    PkiDefaultCryptFree(pbEncodedParameters);

    *pcbPubKeyInfo = cbPubKeyInfo;
    return fResult;
ErrorReturn:
    if (dwFlags & CRYPT_ALLOC_FLAG) {
        PkiDefaultCryptFree(pPubKeyInfo);
        *((void **) pvPubKeyInfo) = NULL;
    }
    cbPubKeyInfo = 0;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(NoPubKeyOIDInfo, ERROR_FILE_NOT_FOUND)
TRACE_ERROR(NoEncodePubKeyFunction)
TRACE_ERROR(EncodePubKeyAndParametersError)
TRACE_ERROR(EncodePublicKeyInfoError)
TRACE_ERROR(OutOfMemory)
}

BOOL
WINAPI
CryptConvertPublicKeyInfo(
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pPubKeyInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT void *pvPubKeyStruc,
    IN OUT DWORD *pcbPubKeyStruc
    )
{
    BOOL fResult;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;

    if (CryptGetOIDFunctionAddress(
            hConvertPubKeyFuncSet,
            dwCertEncodingType,
            pPubKeyInfo->Algorithm.pszObjId,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        fResult = ((PFN_CRYPT_CONVERT_PUBLIC_KEY_INFO) pvFuncAddr)(
            dwCertEncodingType,
            pPubKeyInfo,
            dwFlags,
            pvReserved,
            pvPubKeyStruc,
            pcbPubKeyStruc
            );
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    } else {
        ALG_ID aiPubKey;
        PCCRYPT_OID_INFO pOIDInfo;

        if (pOIDInfo = CryptFindOIDInfo(
                CRYPT_OID_INFO_OID_KEY,
                pPubKeyInfo->Algorithm.pszObjId,
                CRYPT_PUBKEY_ALG_OID_GROUP_ID
                ))
            aiPubKey = pOIDInfo->Algid;
        else
            aiPubKey = 0;

        switch (aiPubKey) {
            case CALG_DSS_SIGN:
                fResult = ConvertDSSPublicKeyInfo(
                    dwCertEncodingType,
                    pPubKeyInfo,
                    dwFlags,
                    pvReserved,
                    pvPubKeyStruc,
                    pcbPubKeyStruc
                    );
                break;
            default:
                // Attempt to decode as a PKCS #1 RSA public key
                fResult = ConvertRSAPublicKeyInfo(
                    dwCertEncodingType,
                    pPubKeyInfo,
                    dwFlags,
                    pvReserved,
                    pvPubKeyStruc,
                    pcbPubKeyStruc
                    );
                break;
        }
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Encode the RSA public key and parameters
//--------------------------------------------------------------------------
static BOOL WINAPI EncodeRSAPublicKeyAndParameters(
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPCSTR pszPubKeyOID,
    IN const PUBLICKEYSTRUC *pPubKeyStruc,
    IN DWORD cbPubKeyStruc,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT BYTE **ppbEncodedPubKey,
    OUT DWORD *pcbEncodedPubKey,
    OUT BYTE **ppbEncodedParameters,
    OUT DWORD *pcbEncodedParameters
    )
{
    *ppbEncodedParameters = NULL;
    *pcbEncodedParameters = 0;

    return CryptEncodeObjectEx(
        dwCertEncodingType,
        RSA_CSP_PUBLICKEYBLOB,
        pPubKeyStruc,
        CRYPT_ENCODE_ALLOC_FLAG,
        NULL,                       // pEncodePara
        (void *) ppbEncodedPubKey,
        pcbEncodedPubKey
        );
}

//+-------------------------------------------------------------------------
//  Convert as an RSA public key
//--------------------------------------------------------------------------
static BOOL WINAPI ConvertRSAPublicKeyInfo(
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pPubKeyInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT void *pvPubKeyStruc,
    IN OUT DWORD *pcbPubKeyStruc
    )
{
    return CryptDecodeObjectEx(
        dwCertEncodingType,
        RSA_CSP_PUBLICKEYBLOB,
        pPubKeyInfo->PublicKey.pbData,
        pPubKeyInfo->PublicKey.cbData,
        (dwFlags & CRYPT_ALLOC_FLAG) ? CRYPT_DECODE_ALLOC_FLAG : 0,
        NULL,                               // pDecodePara,
        pvPubKeyStruc,
        pcbPubKeyStruc
        );
}

#ifndef DSS1
#define DSS1 ((DWORD)'D'+((DWORD)'S'<<8)+((DWORD)'S'<<16)+((DWORD)'1'<<24))
#endif

#define DSS_Q_LEN   20

//+-------------------------------------------------------------------------
//  Encode the DSS public key and parameters
//--------------------------------------------------------------------------
static BOOL WINAPI EncodeDSSPublicKeyAndParameters(
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPCSTR pszPubKeyOID,
    IN const PUBLICKEYSTRUC *pPubKeyStruc,
    IN DWORD cbPubKeyStruc,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT BYTE **ppbEncodedPubKey,
    OUT DWORD *pcbEncodedPubKey,
    OUT BYTE **ppbEncodedParameters,
    OUT DWORD *pcbEncodedParameters
    )
{
    BOOL fResult;
    BYTE *pbKeyBlob;
    DSSPUBKEY *pCspPubKey;
    DWORD cbKey;
    BYTE *pbKey;

    CERT_DSS_PARAMETERS DssParameters;
    CRYPT_UINT_BLOB DssPubKey;

    *ppbEncodedPubKey = NULL;
    *ppbEncodedParameters = NULL;

    // The CAPI public key representation consists of the following sequence:
    //  - PUBLICKEYSTRUC
    //  - DSSPUBKEY
    //  - rgbP[cbKey]
    //  - rgbQ[20]
    //  - rgbG[cbKey]
    //  - rgbY[cbKey]
    //  - DSSSEED
    pbKeyBlob = (BYTE *) pPubKeyStruc;
    pCspPubKey = (DSSPUBKEY *) (pbKeyBlob + sizeof(PUBLICKEYSTRUC));
    pbKey = pbKeyBlob + sizeof(PUBLICKEYSTRUC) + sizeof(DSSPUBKEY);
    cbKey = pCspPubKey->bitlen / 8;

    assert(cbKey > 0);
    assert(cbPubKeyStruc >= sizeof(PUBLICKEYSTRUC) + sizeof(DSSPUBKEY) +
        cbKey + DSS_Q_LEN + cbKey + cbKey + sizeof(DSSSEED));
    assert(pPubKeyStruc->bType == PUBLICKEYBLOB);
    assert(pPubKeyStruc->bVersion == CUR_BLOB_VERSION);
    assert(pPubKeyStruc->aiKeyAlg == CALG_DSS_SIGN);
    assert(pCspPubKey->magic == DSS1);
    assert(pCspPubKey->bitlen % 8 == 0);

    if (pPubKeyStruc->bType != PUBLICKEYBLOB)
        goto InvalidArg;

    // Initialize DSS parameters from CSP data structure
    DssParameters.p.cbData = cbKey;
    DssParameters.p.pbData = pbKey;
    pbKey += cbKey;
    DssParameters.q.cbData = DSS_Q_LEN;
    DssParameters.q.pbData = pbKey;
    pbKey += DSS_Q_LEN;
    DssParameters.g.cbData = cbKey;
    DssParameters.g.pbData = pbKey;
    pbKey += cbKey;

    // Initialize DSS public key from CSP data structure
    DssPubKey.cbData = cbKey;
    DssPubKey.pbData = pbKey;

    // Encode the parameters and public key
    if (!CryptEncodeObjectEx(
            dwCertEncodingType,
            X509_DSS_PARAMETERS,
            &DssParameters,
            CRYPT_ENCODE_ALLOC_FLAG,
            NULL,                       // pEncodePara
            (void *) ppbEncodedParameters,
            pcbEncodedParameters
            )) goto ErrorReturn;

    if (!CryptEncodeObjectEx(
            dwCertEncodingType,
            X509_DSS_PUBLICKEY,
            &DssPubKey,
            CRYPT_ENCODE_ALLOC_FLAG,
            NULL,                       // pEncodePara
            (void *) ppbEncodedPubKey,
            pcbEncodedPubKey
            )) goto ErrorReturn;

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    PkiDefaultCryptFree(*ppbEncodedParameters);
    PkiDefaultCryptFree(*ppbEncodedPubKey);
    *ppbEncodedParameters = NULL;
    *ppbEncodedPubKey = NULL;
    *pcbEncodedParameters = 0;
    *pcbEncodedPubKey = 0;
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
}

//+-------------------------------------------------------------------------
//  Convert as an DSS public key
//--------------------------------------------------------------------------
static BOOL WINAPI ConvertDSSPublicKeyInfo(
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pPubKeyInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT void *pvPubKeyStruc,
    IN OUT DWORD *pcbPubKeyStruc
    )
{
    BOOL fResult;
    PCERT_DSS_PARAMETERS pDssParameters = NULL;
    PCRYPT_UINT_BLOB pDssPubKey = NULL;
    PUBLICKEYSTRUC *pPubKeyStruc = NULL;
    DWORD cbPubKeyStruc;
    BYTE *pbKeyBlob;
    DSSPUBKEY *pCspPubKey;
    DSSSEED *pCspSeed;
    DWORD cbKey;
    BYTE *pbKey;
    DWORD cb;

    if (0 == pPubKeyInfo->Algorithm.Parameters.cbData ||
            NULL_ASN_TAG == *pPubKeyInfo->Algorithm.Parameters.pbData)
        goto NoDssParametersError;
    if (NULL == (pDssParameters = (PCERT_DSS_PARAMETERS) AllocAndDecodeObject(
            dwCertEncodingType,
            X509_DSS_PARAMETERS,
            pPubKeyInfo->Algorithm.Parameters.pbData,
            pPubKeyInfo->Algorithm.Parameters.cbData
            ))) goto DecodeParametersError;

    if (NULL == (pDssPubKey = (PCRYPT_UINT_BLOB) AllocAndDecodeObject(
            dwCertEncodingType,
            X509_DSS_PUBLICKEY,
            pPubKeyInfo->PublicKey.pbData,
            pPubKeyInfo->PublicKey.cbData
            ))) goto DecodePubKeyError;

    // The CAPI public key representation consists of the following sequence:
    //  - PUBLICKEYSTRUC
    //  - DSSPUBKEY
    //  - rgbP[cbKey]
    //  - rgbQ[20]
    //  - rgbG[cbKey]
    //  - rgbY[cbKey]
    //  - DSSSEED

    cbKey = pDssParameters->p.cbData;
    if (0 == cbKey)
        goto InvalidDssParametersError;

    cbPubKeyStruc = sizeof(PUBLICKEYSTRUC) + sizeof(DSSPUBKEY) +
        cbKey + DSS_Q_LEN + cbKey + cbKey + sizeof(DSSSEED);

    if (dwFlags & CRYPT_ALLOC_FLAG) {
        if (NULL == (pPubKeyStruc =
                (PUBLICKEYSTRUC *) PkiDefaultCryptAlloc(cbPubKeyStruc)))
            goto OutOfMemory;
        *((PUBLICKEYSTRUC **) pvPubKeyStruc) = pPubKeyStruc;
    } else
        pPubKeyStruc = (PUBLICKEYSTRUC *) pvPubKeyStruc;

    fResult = TRUE;
    if (pPubKeyStruc) {
        if (0 == (dwFlags & CRYPT_ALLOC_FLAG) &&
                *pcbPubKeyStruc < cbPubKeyStruc) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
        } else {
            pbKeyBlob = (BYTE *) pPubKeyStruc;
            pCspPubKey = (DSSPUBKEY *) (pbKeyBlob + sizeof(PUBLICKEYSTRUC));
            pbKey = pbKeyBlob + sizeof(PUBLICKEYSTRUC) + sizeof(DSSPUBKEY);

            // NOTE, the length of G and Y can be less than the length of P.
            // The CSP requires G and Y to be padded out with 0x00 bytes if it
            // is less and in little endian form
            
            // PUBLICKEYSTRUC
            pPubKeyStruc->bType = PUBLICKEYBLOB;
            pPubKeyStruc->bVersion = CUR_BLOB_VERSION;
            pPubKeyStruc->reserved = 0;
            pPubKeyStruc->aiKeyAlg = CALG_DSS_SIGN;
            // DSSPUBKEY
            pCspPubKey->magic = DSS1;
            pCspPubKey->bitlen = cbKey * 8;

            // rgbP[cbKey]
            memcpy(pbKey, pDssParameters->p.pbData, cbKey);
            pbKey += cbKey;

            // rgbQ[20]
            cb = pDssParameters->q.cbData;
            if (0 == cb || cb > DSS_Q_LEN)
                goto InvalidDssParametersError;
            memcpy(pbKey, pDssParameters->q.pbData, cb);
            if (DSS_Q_LEN > cb)
                memset(pbKey + cb, 0, DSS_Q_LEN - cb);
            pbKey += DSS_Q_LEN;

            // rgbG[cbKey]
            cb = pDssParameters->g.cbData;
            if (0 == cb || cb > cbKey)
                goto InvalidDssParametersError;
            memcpy(pbKey, pDssParameters->g.pbData, cb);
            if (cbKey > cb)
                memset(pbKey + cb, 0, cbKey - cb);
            pbKey += cbKey;

            // rgbY[cbKey]
            cb = pDssPubKey->cbData;
            if (0 == cb || cb > cbKey)
                goto InvalidDssPubKeyError;
            memcpy(pbKey, pDssPubKey->pbData, cb);
            if (cbKey > cb)
                memset(pbKey + cb, 0, cbKey - cb);
            pbKey += cbKey;

            // DSSSEED: set counter to 0xFFFFFFFF to indicate not available
            pCspSeed = (DSSSEED *) pbKey;
            memset(&pCspSeed->counter, 0xFF, sizeof(pCspSeed->counter));
        }
    }

CommonReturn:
    *pcbPubKeyStruc = cbPubKeyStruc;
    PkiFree(pDssParameters);
    PkiFree(pDssPubKey);
    return fResult;
            
ErrorReturn:
    if (dwFlags & CRYPT_ALLOC_FLAG) {
        PkiDefaultCryptFree(pPubKeyStruc);
        *((PUBLICKEYSTRUC **) pvPubKeyStruc) = NULL;
    }
    cbPubKeyStruc = 0;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(DecodeParametersError)
TRACE_ERROR(DecodePubKeyError)
#ifdef CMS_PKCS7
SET_ERROR(NoDssParametersError, CRYPT_E_MISSING_PUBKEY_PARA)
#else
SET_ERROR(NoDssParametersError, E_INVALIDARG)
#endif  // CMS_PKCS7
SET_ERROR(InvalidDssParametersError, E_INVALIDARG)
SET_ERROR(InvalidDssPubKeyError, E_INVALIDARG)
}

#ifndef DH3
#define DH3 (((DWORD)'D'<<8)+((DWORD)'H'<<16)+((DWORD)'3'<<24))
#endif

//+-------------------------------------------------------------------------
//  Encode the RSA DH public key and parameters
//--------------------------------------------------------------------------
static BOOL WINAPI EncodeRSADHPublicKeyAndParameters(
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPCSTR pszPubKeyOID,
    IN const PUBLICKEYSTRUC *pPubKeyStruc,
    IN DWORD cbPubKeyStruc,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT BYTE **ppbEncodedPubKey,
    OUT DWORD *pcbEncodedPubKey,
    OUT BYTE **ppbEncodedParameters,
    OUT DWORD *pcbEncodedParameters
    )
{
    BOOL fResult;
    BYTE *pbKeyBlob;
    DHPUBKEY_VER3 *pCspPubKey;
    DWORD cbP;
    DWORD cbQ;
    DWORD cbJ;
    BYTE *pbKey;

    CERT_DH_PARAMETERS DhParameters;
    CRYPT_UINT_BLOB DhPubKey;

    *ppbEncodedPubKey = NULL;
    *ppbEncodedParameters = NULL;

    // The CAPI public key representation consists of the following sequence:
    //  - PUBLICKEYSTRUC
    //  - DHPUBKEY_VER3
    //  - rgbP[cbP]
    //  - rgbQ[cbQ]     -- not used in RSA_DH
    //  - rgbG[cbP]
    //  - rgbJ[cbJ]     -- not used in RSA_DH
    //  - rgbY[cbP]
    pbKeyBlob = (BYTE *) pPubKeyStruc;
    pCspPubKey = (DHPUBKEY_VER3 *) (pbKeyBlob + sizeof(PUBLICKEYSTRUC));
    pbKey = pbKeyBlob + sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY_VER3);

    cbP = pCspPubKey->bitlenP / 8;
    cbQ = pCspPubKey->bitlenQ / 8;
    cbJ = pCspPubKey->bitlenJ / 8;

    if (cbPubKeyStruc < sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY_VER3) +
            cbP * 3 + cbQ + cbJ)
        goto InvalidArg;
    if (pPubKeyStruc->bType != PUBLICKEYBLOB)
        goto InvalidArg;
    if (pCspPubKey->magic != DH3)
        goto InvalidArg;

    assert(cbP > 0);
    assert(cbPubKeyStruc >= sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY_VER3) +
        cbP * 3 + cbQ + cbJ);
    assert(pPubKeyStruc->bType == PUBLICKEYBLOB);

    //assert(pPubKeyStruc->bVersion == 3);
    assert(pPubKeyStruc->aiKeyAlg == CALG_DH_SF ||
        pPubKeyStruc->aiKeyAlg == CALG_DH_EPHEM);
    assert(pCspPubKey->magic == DH3);
    assert(pCspPubKey->bitlenP % 8 == 0);
    assert(pCspPubKey->bitlenQ % 8 == 0);
    assert(pCspPubKey->bitlenJ % 8 == 0);

    // Initialize the RSA DH Parameters from CSP data structure
    DhParameters.p.pbData = pbKey;
    DhParameters.p.cbData = cbP;
    pbKey += cbP;

    // No RSA DH Q parameter
    pbKey += cbQ;

    DhParameters.g.pbData = pbKey;
    DhParameters.g.cbData = cbP;
    pbKey += cbP;

    // No RSA DH J parameter
    pbKey += cbJ;

    // Initialize DH public key from CSP data structure
    DhPubKey.cbData = cbP;
    DhPubKey.pbData = pbKey;

    // Encode the parameters and public key
    if (!CryptEncodeObjectEx(
            dwCertEncodingType,
            X509_DH_PARAMETERS,
            &DhParameters,
            CRYPT_ENCODE_ALLOC_FLAG,
            NULL,                       // pEncodePara
            (void *) ppbEncodedParameters,
            pcbEncodedParameters
            )) goto ErrorReturn;

    if (!CryptEncodeObjectEx(
            dwCertEncodingType,
            X509_DH_PUBLICKEY,
            &DhPubKey,
            CRYPT_ENCODE_ALLOC_FLAG,
            NULL,                       // pEncodePara
            (void *) ppbEncodedPubKey,
            pcbEncodedPubKey
            )) goto ErrorReturn;

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    PkiDefaultCryptFree(*ppbEncodedParameters);
    PkiDefaultCryptFree(*ppbEncodedPubKey);
    *ppbEncodedParameters = NULL;
    *ppbEncodedPubKey = NULL;
    *pcbEncodedParameters = 0;
    *pcbEncodedPubKey = 0;
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
}

//+-------------------------------------------------------------------------
//  Encode the X942 DH public key and parameters
//--------------------------------------------------------------------------
static BOOL WINAPI EncodeX942DHPublicKeyAndParameters(
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPCSTR pszPubKeyOID,
    IN const PUBLICKEYSTRUC *pPubKeyStruc,
    IN DWORD cbPubKeyStruc,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT BYTE **ppbEncodedPubKey,
    OUT DWORD *pcbEncodedPubKey,
    OUT BYTE **ppbEncodedParameters,
    OUT DWORD *pcbEncodedParameters
    )
{
    BOOL fResult;
    BYTE *pbKeyBlob;
    DHPUBKEY_VER3 *pCspPubKey;
    DWORD cbP;
    DWORD cbQ;
    DWORD cbJ;
    BYTE *pbKey;

    CERT_X942_DH_PARAMETERS DhParameters;
    CERT_X942_DH_VALIDATION_PARAMS DhValidationParams;
    CRYPT_UINT_BLOB DhPubKey;

    *ppbEncodedPubKey = NULL;
    *ppbEncodedParameters = NULL;

    // The CAPI public key representation consists of the following sequence:
    //  - PUBLICKEYSTRUC
    //  - DHPUBKEY_VER3
    //  - rgbP[cbP]
    //  - rgbQ[cbQ]
    //  - rgbG[cbP]
    //  - rgbJ[cbJ]
    //  - rgbY[cbP]
    pbKeyBlob = (BYTE *) pPubKeyStruc;
    pCspPubKey = (DHPUBKEY_VER3 *) (pbKeyBlob + sizeof(PUBLICKEYSTRUC));
    pbKey = pbKeyBlob + sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY_VER3);

    cbP = pCspPubKey->bitlenP / 8;
    cbQ = pCspPubKey->bitlenQ / 8;
    cbJ = pCspPubKey->bitlenJ / 8;

    if (0 == cbQ)
        return EncodeRSADHPublicKeyAndParameters(
            dwCertEncodingType,
            pszPubKeyOID,
            pPubKeyStruc,
            cbPubKeyStruc,
            dwFlags,
            pvReserved,
            ppbEncodedPubKey,
            pcbEncodedPubKey,
            ppbEncodedParameters,
            pcbEncodedParameters
            );

    if (cbPubKeyStruc < sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY_VER3) +
            cbP * 3 + cbQ + cbJ)
        goto InvalidArg;
    if (pPubKeyStruc->bType != PUBLICKEYBLOB)
        goto InvalidArg;
    if (pCspPubKey->magic != DH3)
        goto InvalidArg;

    assert(cbP > 0);
    assert(cbPubKeyStruc >= sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY_VER3) +
        cbP * 3 + cbQ + cbJ);
    assert(pPubKeyStruc->bType == PUBLICKEYBLOB);

    //assert(pPubKeyStruc->bVersion == 3);
    assert(pPubKeyStruc->aiKeyAlg == CALG_DH_SF ||
        pPubKeyStruc->aiKeyAlg == CALG_DH_EPHEM);
    assert(pCspPubKey->magic == DH3);
    assert(pCspPubKey->bitlenP % 8 == 0);
    assert(pCspPubKey->bitlenQ % 8 == 0);
    assert(pCspPubKey->bitlenJ % 8 == 0);

    // Initialize the X942 DH Parameters from CSP data structure
    DhParameters.p.pbData = pbKey;
    DhParameters.p.cbData = cbP;
    pbKey += cbP;

    DhParameters.q.pbData = pbKey;
    DhParameters.q.cbData = cbQ;
    pbKey += cbQ;

    DhParameters.g.pbData = pbKey;
    DhParameters.g.cbData = cbP;
    pbKey += cbP;

    DhParameters.j.pbData = pbKey;
    DhParameters.j.cbData = cbJ;
    pbKey += cbJ;

    if (0xFFFFFFFF == pCspPubKey->DSSSeed.counter ||
            0 == pCspPubKey->DSSSeed.counter)
        DhParameters.pValidationParams = NULL;
    else {
        DhParameters.pValidationParams = &DhValidationParams;
        DhValidationParams.pgenCounter = pCspPubKey->DSSSeed.counter;
        DhValidationParams.seed.pbData = pCspPubKey->DSSSeed.seed;
        DhValidationParams.seed.cbData = sizeof(pCspPubKey->DSSSeed.seed);
        DhValidationParams.seed.cUnusedBits = 0;
    }

    // Initialize DH public key from CSP data structure
    DhPubKey.cbData = cbP;
    DhPubKey.pbData = pbKey;

    // Encode the parameters and public key
    if (!CryptEncodeObjectEx(
            dwCertEncodingType,
            X942_DH_PARAMETERS,
            &DhParameters,
            CRYPT_ENCODE_ALLOC_FLAG,
            NULL,                       // pEncodePara
            (void *) ppbEncodedParameters,
            pcbEncodedParameters
            )) goto ErrorReturn;

    if (!CryptEncodeObjectEx(
            dwCertEncodingType,
            X509_DH_PUBLICKEY,
            &DhPubKey,
            CRYPT_ENCODE_ALLOC_FLAG,
            NULL,                       // pEncodePara
            (void *) ppbEncodedPubKey,
            pcbEncodedPubKey
            )) goto ErrorReturn;

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    PkiDefaultCryptFree(*ppbEncodedParameters);
    PkiDefaultCryptFree(*ppbEncodedPubKey);
    *ppbEncodedParameters = NULL;
    *ppbEncodedPubKey = NULL;
    *pcbEncodedParameters = 0;
    *pcbEncodedPubKey = 0;
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
}


#ifndef DH1
#define DH1 (((DWORD)'D'<<8)+((DWORD)'H'<<16)+((DWORD)'1'<<24))
#endif

// Convert a DH1 PublicKey Struc, to a DH3 PublicKey Struc by getting
// the P and G parameters from the hPubKey.
static BOOL ConvertDh1ToDh3PublicKeyStruc(
    IN HCRYPTKEY hPubKey,
    IN OUT PUBLICKEYSTRUC **ppPubKeyStruc,
    IN OUT DWORD *pcbPubKeyStruc
    )
{
    BOOL fResult;
    PUBLICKEYSTRUC *pDh1PubKeyStruc = *ppPubKeyStruc;
    BYTE *pbDh1KeyBlob;
    DHPUBKEY *pDh1CspPubKey;
    BYTE *pbDh1Key;

    PUBLICKEYSTRUC *pDh3PubKeyStruc = NULL;
    DWORD cbDh3PubKeyStruc;
    BYTE *pbDh3KeyBlob;
    DHPUBKEY_VER3 *pDh3CspPubKey;
    BYTE *pbDh3Key;
    DWORD cbP;
    DWORD cbData;

    // The DH1 CAPI public key representation consists of the following
    // sequence:
    //  - PUBLICKEYSTRUC
    //  - DHPUBKEY
    //  - rgbY[cbP]
    pbDh1KeyBlob = (BYTE *) pDh1PubKeyStruc;
    pDh1CspPubKey = (DHPUBKEY *) (pbDh1KeyBlob + sizeof(PUBLICKEYSTRUC));
    pbDh1Key = pbDh1KeyBlob + sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY);

    if (pDh1CspPubKey->magic != DH1)
        return TRUE;
    cbP = pDh1CspPubKey->bitlen / 8;
    if (*pcbPubKeyStruc < sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY) + cbP)
        goto InvalidArg;

    // The DH3 CAPI public key representation consists of the following
    // sequence:
    //  - PUBLICKEYSTRUC
    //  - DHPUBKEY_VER3
    //  - rgbP[cbP]
    //  - rgbQ[cbQ]     -- will be omitted here
    //  - rgbG[cbP]
    //  - rgbJ[cbJ]     -- will be omitted here
    //  - rgbY[cbP]
    cbDh3PubKeyStruc = sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY_VER3) +
            cbP * 3;
    if (NULL == (pDh3PubKeyStruc = (PUBLICKEYSTRUC *) PkiZeroAlloc(
            cbDh3PubKeyStruc)))
        goto OutOfMemory;

    pbDh3KeyBlob = (BYTE *) pDh3PubKeyStruc;
    pDh3CspPubKey = (DHPUBKEY_VER3 *) (pbDh3KeyBlob + sizeof(PUBLICKEYSTRUC));
    pbDh3Key = pbDh3KeyBlob + sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY_VER3);

    pDh3PubKeyStruc->bType = PUBLICKEYBLOB;
    pDh3PubKeyStruc->bVersion = 3;
    pDh3PubKeyStruc->aiKeyAlg = CALG_DH_SF;
    pDh3CspPubKey->magic = DH3;
    pDh3CspPubKey->bitlenP = cbP * 8;
    //pDh3CspPubKey->bitlenQ = 0;
    //pDh3CspPubKey->bitlenJ  = 0;

    // Get the P parameter from the public key
    cbData = cbP;
    if (!CryptGetKeyParam(
            hPubKey,
            KP_P,
            pbDh3Key,
            &cbData,
            0                   // dwFlags
            ) || cbData != cbP)
        goto GetPError;
    pbDh3Key += cbP;

    // No Q parameter

    // Get G parameter from the public key
    cbData = cbP;
    if (!CryptGetKeyParam(
            hPubKey,
            KP_G,
            pbDh3Key,
            &cbData,
            0                   // dwFlags
            ) || cbData != cbP)
        goto GetGError;
    pbDh3Key += cbP;

    // No J parameter

    // Y
    memcpy(pbDh3Key, pbDh1Key, cbP);

    assert(pbDh3Key - pbDh3KeyBlob + cbP == cbDh3PubKeyStruc);

    PkiFree(pDh1PubKeyStruc);
    *ppPubKeyStruc = pDh3PubKeyStruc;
    *pcbPubKeyStruc = cbDh3PubKeyStruc;
    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    PkiFree(pDh3PubKeyStruc);
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(GetPError)
TRACE_ERROR(GetGError)
}

//+=========================================================================
//  CryptExportPublicKeyInfo functions
//-=========================================================================

//+-------------------------------------------------------------------------
//  Use the aiKeyAlg in the public key structure exported by the CSP to
//  determine how to encode the public key.
//
//  The dwFlags and pvAuxInfo aren't used.
//--------------------------------------------------------------------------
static BOOL WINAPI ExportCspPublicKeyInfoEx(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec,
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPSTR pszPublicKeyObjId,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvAuxInfo,
    OUT PCERT_PUBLIC_KEY_INFO pInfo,
    IN OUT DWORD *pcbInfo
    )
{
    BOOL fResult;
    DWORD dwErr;
    HCRYPTKEY hPubKey = 0;
    PUBLICKEYSTRUC *pPubKeyStruc = NULL;
    DWORD cbPubKeyStruc;

    if (!CryptGetUserKey(
            hCryptProv,
            dwKeySpec,
            &hPubKey
            )) {
        hPubKey = 0;
        goto GetUserKeyError;
    }

    cbPubKeyStruc = 0;
    if (!CryptExportKey(
            hPubKey,
            0,              // hPubKey
            PUBLICKEYBLOB,
            0,              // dwFlags
            NULL,           // pbData
            &cbPubKeyStruc
            ) || (cbPubKeyStruc == 0))
        goto ExportPublicKeyBlobError;
    if (NULL == (pPubKeyStruc = (PUBLICKEYSTRUC *) PkiNonzeroAlloc(
            cbPubKeyStruc)))
        goto OutOfMemory;
    if (!CryptExportKey(
            hPubKey,
            0,              // hPubKey
            PUBLICKEYBLOB,
            0,              // dwFlags
            (BYTE *) pPubKeyStruc,
            &cbPubKeyStruc
            ))
        goto ExportPublicKeyBlobError;

    if (CALG_DH_SF == pPubKeyStruc->aiKeyAlg ||
            CALG_DH_EPHEM == pPubKeyStruc->aiKeyAlg) {
        DWORD cbDh3PubKeyStruc;
        PUBLICKEYSTRUC *pDh3PubKeyStruc;

        // Check if the CSP supports DH3
        cbDh3PubKeyStruc = 0;
        if (!CryptExportKey(
                hPubKey,
                0,              // hPubKey
                PUBLICKEYBLOB,
                CRYPT_BLOB_VER3,
                NULL,           // pbData
                &cbDh3PubKeyStruc
                ) || (cbDh3PubKeyStruc == 0)) {
            // Convert DH1 to DH3 by getting and adding the P and G
            // parameters
            if (!ConvertDh1ToDh3PublicKeyStruc(
                    hPubKey,
                    &pPubKeyStruc,
                    &cbPubKeyStruc
                    ))
                goto ConvertDh1ToDh3PublicKeyStrucError;
        } else {
            if (NULL == (pDh3PubKeyStruc = (PUBLICKEYSTRUC *) PkiNonzeroAlloc(
                    cbDh3PubKeyStruc)))
                goto OutOfMemory;
            if (!CryptExportKey(
                    hPubKey,
                    0,              // hPubKey
                    PUBLICKEYBLOB,
                    CRYPT_BLOB_VER3,
                    (BYTE *) pDh3PubKeyStruc,
                    &cbDh3PubKeyStruc
                    )) {
                PkiFree(pDh3PubKeyStruc);
                goto ExportPublicKeyBlobError;
            }

            PkiFree(pPubKeyStruc);
            pPubKeyStruc = pDh3PubKeyStruc;
            cbPubKeyStruc = cbDh3PubKeyStruc;
        }

        if (NULL == pszPublicKeyObjId) {
            DHPUBKEY_VER3 *pDh3CspPubKey;

            // The CAPI public key representation consists of the
            // following sequence:
            //  - PUBLICKEYSTRUC
            //  - DHPUBKEY_VER3
            //  - rgbP[cbP]
            //  - rgbQ[cbQ]     -- not used in szOID_RSA_DH
            //  - rgbG[cbP]
            //  - rgbJ[cbJ]     -- not used in szOID_RSA_DH
            //  - rgbY[cbP]
            pDh3CspPubKey = (DHPUBKEY_VER3 *)
                ((BYTE*) pPubKeyStruc + sizeof(PUBLICKEYSTRUC));

            if (DH3 == pDh3CspPubKey->magic && 0 == pDh3CspPubKey->bitlenQ)
                // szOID_RSA_DH indicates no Q parameter
                pszPublicKeyObjId = szOID_RSA_DH;
        }
    }

    fResult = CryptCreatePublicKeyInfo(
        dwCertEncodingType,
        pszPublicKeyObjId,
        pPubKeyStruc,
        cbPubKeyStruc,
        0,                      // dwFlags
        NULL,                   // pvAuxInfo
        pInfo,
        pcbInfo
        );

CommonReturn:
    dwErr = GetLastError();
    if (hPubKey)
        CryptDestroyKey(hPubKey);
    PkiFree(pPubKeyStruc);
    SetLastError(dwErr);
    return fResult;

ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetUserKeyError)
TRACE_ERROR(ExportPublicKeyBlobError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(ConvertDh1ToDh3PublicKeyStrucError)
}

//+-------------------------------------------------------------------------
//  Export the public key info associated with the provider's corresponding
//  private key.
//
//  Uses the dwCertEncodingType and pszPublicKeyObjId to call the
//  installable CRYPT_OID_EXPORT_PUBLIC_KEY_INFO_FUNC. The called function
//  has the same signature as CryptExportPublicKeyInfoEx.
//
//  If unable to find an installable OID function for the pszPublicKeyObjId,
//  attempts to export via the default export function.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptExportPublicKeyInfoEx(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec,
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPSTR pszPublicKeyObjId,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvAuxInfo,
    OUT PCERT_PUBLIC_KEY_INFO pInfo,
    IN OUT DWORD *pcbInfo
    )
{
    BOOL fResult;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;

    if (pszPublicKeyObjId && CryptGetOIDFunctionAddress(
            hExportPubKeyFuncSet,
            dwCertEncodingType,
            pszPublicKeyObjId,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        fResult = ((PFN_EXPORT_PUB_KEY_FUNC) pvFuncAddr)(
            hCryptProv,
            dwKeySpec,
            dwCertEncodingType,
            pszPublicKeyObjId,
            dwFlags,
            pvAuxInfo,
            pInfo,
            pcbInfo
            );
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    } else
        // Attempt to export via the default function that looks at the
        // public key algorithm in the public key struc exported by the CSP.
        fResult = ExportCspPublicKeyInfoEx(
            hCryptProv,
            dwKeySpec,
            dwCertEncodingType,
            pszPublicKeyObjId,
            dwFlags,
            pvAuxInfo,
            pInfo,
            pcbInfo
            );
    return fResult;
}

//+-------------------------------------------------------------------------
//  Export the public key info associated with the provider's corresponding
//  private key.
//
//  Calls CryptExportPublicKeyInfoEx with pszPublicKeyObjId = NULL,
//  dwFlags = 0 and pvAuxInfo = NULL.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptExportPublicKeyInfo(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec,
    IN DWORD dwCertEncodingType,
    OUT PCERT_PUBLIC_KEY_INFO pInfo,
    IN OUT DWORD *pcbInfo
    )
{
    return CryptExportPublicKeyInfoEx(
        hCryptProv,
        dwKeySpec,
        dwCertEncodingType,
        NULL,                           // pszPublicKeyObjId
        0,                              // dwFlags
        NULL,                           // pvAuxInfo
        pInfo,
        pcbInfo
        );
}

//+=========================================================================
//  CryptImportPublicKeyInfo functions
//-=========================================================================

//+-------------------------------------------------------------------------
//  Convert and import the public key info into the provider and return a
//  handle to the public key.
//
//  Uses the dwCertEncodingType and pInfo->Algorithm.pszObjId to call the
//  installable CRYPT_OID_IMPORT_PUBLIC_KEY_INFO_FUNC. The called function
//  has the same signature as CryptImportPublicKeyInfoEx.
//
//  If unable to find an installable OID function for the pszObjId,
//  decodes the PublicKeyInfo into a CSP PublicKey Blob and imports.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptImportPublicKeyInfoEx(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pInfo,
    IN ALG_ID aiKeyAlg,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvAuxInfo,
    OUT HCRYPTKEY *phKey
    )
{
    BOOL fResult;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;
    PUBLICKEYSTRUC *pPubKeyStruc = NULL;
    DWORD cbPubKeyStruc;

    if (CryptGetOIDFunctionAddress(
            hImportPubKeyFuncSet,
            dwCertEncodingType,
            pInfo->Algorithm.pszObjId,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        fResult = ((PFN_IMPORT_PUB_KEY_FUNC) pvFuncAddr)(
            hCryptProv,
            dwCertEncodingType,
            pInfo,
            aiKeyAlg,
            dwFlags,
            pvAuxInfo,
            phKey
            );
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    } else {
        if (!CryptConvertPublicKeyInfo(
                dwCertEncodingType,
                pInfo,
                CRYPT_ALLOC_FLAG,
                NULL,                   // pvReserved
                (void *) &pPubKeyStruc,
                &cbPubKeyStruc
                ))
            goto ConvertPublicKeyInfoError;

        if (aiKeyAlg)
            pPubKeyStruc->aiKeyAlg = aiKeyAlg;

        if (!CryptImportKey(
                hCryptProv,
                (BYTE *) pPubKeyStruc,
                cbPubKeyStruc,
                NULL,           // hImpKey
                0,              // dwFlags
                phKey
                ))
            goto ImportKeyError;
        fResult = TRUE;
    }

CommonReturn:
    PkiDefaultCryptFree(pPubKeyStruc);
    return fResult;
ErrorReturn:
    *phKey = NULL;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(ConvertPublicKeyInfoError)
TRACE_ERROR(ImportKeyError)
}

//+-------------------------------------------------------------------------
//  Convert and import the public key info into the provider and return a
//  handle to the public key.
//
//  Calls CryptImportPublicKeyInfoEx with aiKeyAlg = 0, dwFlags = 0 and
//  pvAuxInfo = NULL.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptImportPublicKeyInfo(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pInfo,
    OUT HCRYPTKEY *phKey
    )
{
    return CryptImportPublicKeyInfoEx(
        hCryptProv,
        dwCertEncodingType,
        pInfo,
        0,                      // aiKeyAlg
        0,                      // dwFlags
        NULL,                   // pvAuxInfo
        phKey
        );
}

//+-------------------------------------------------------------------------
//  Create a KeyIdentifier from the CSP Public Key Blob.
//
//  Converts the CSP PUBLICKEYSTRUC into a X.509 CERT_PUBLIC_KEY_INFO and
//  encodes. The encoded CERT_PUBLIC_KEY_INFO is SHA1 hashed to obtain
//  the Key Identifier.
//
//  By default, the pPubKeyStruc->aiKeyAlg is used to find the appropriate
//  public key Object Identifier. pszPubKeyOID can be set to override
//  the default OID obtained from the aiKeyAlg.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptCreateKeyIdentifierFromCSP(
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPCSTR pszPubKeyOID,
    IN const PUBLICKEYSTRUC *pPubKeyStruc,
    IN DWORD cbPubKeyStruc,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT BYTE *pbHash,
    IN OUT DWORD *pcbHash
    )
{
    BOOL fResult;
    PCERT_PUBLIC_KEY_INFO pInfo = NULL;
    DWORD cbInfo;

    if (!CryptCreatePublicKeyInfo(
            dwCertEncodingType,
            pszPubKeyOID,
            pPubKeyStruc,
            cbPubKeyStruc,
            CRYPT_ALLOC_FLAG,
            NULL,                   // pvReserved
            (void *) &pInfo,
            &cbInfo
            ))
        goto CreatePublicKeyInfoError;

    fResult = CryptHashPublicKeyInfo(
            NULL,                   // hCryptProv
            CALG_SHA1,
            0,                      // dwFlags
            dwCertEncodingType,
            pInfo,
            pbHash,
            pcbHash
            );

CommonReturn:
    PkiDefaultCryptFree(pInfo);
    return fResult;

ErrorReturn:
    *pcbHash = 0;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(CreatePublicKeyInfoError)
}


//+=========================================================================
//  DefaultContext APIs and Data Structures
//-=========================================================================

static BOOL InstallThreadDefaultContext(
    IN PDEFAULT_CONTEXT pDefaultContext
    )
{
    PDEFAULT_CONTEXT pNext;
    pNext = (PDEFAULT_CONTEXT) I_CryptGetTls(hTlsDefaultContext);
    if (pNext) {
        pDefaultContext->pNext = pNext;
        pNext->pPrev = pDefaultContext;
    }

    fHasThreadDefaultContext = TRUE;
    return I_CryptSetTls(hTlsDefaultContext, pDefaultContext);
}

static BOOL InstallProcessDefaultContext(
    IN PDEFAULT_CONTEXT pDefaultContext
    )
{
    EnterCriticalSection(&DefaultContextCriticalSection);

    if (pProcessDefaultContextHead) {
        pDefaultContext->pNext = pProcessDefaultContextHead;
        pProcessDefaultContextHead->pPrev = pDefaultContext;
    }
    pProcessDefaultContextHead = pDefaultContext;

    fHasProcessDefaultContext = TRUE;

    LeaveCriticalSection(&DefaultContextCriticalSection);

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Install a previously CryptAcquiredContext'ed HCRYPTPROV to be used as
//  a default context.
//
//  dwDefaultType and pvDefaultPara specify where the default context is used.
//  For example, install the HCRYPTPROV to be used to verify certificate's
//  having szOID_OIWSEC_md5RSA signatures.
//
//  By default, the installed HCRYPTPROV is only applicable to the current
//  thread. Set CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG to allow the HCRYPTPROV 
//  to be used by all threads in the current process.
//
//  For a successful install, TRUE is returned and *phDefaultContext is
//  updated with the HANDLE to be passed to CryptUninstallDefaultContext.
//
//  The installed HCRYPTPROVs are stack ordered (the last installed
//  HCRYPTPROV is checked first). All thread installed HCRYPTPROVs are
//  checked before any process HCRYPTPROVs.
//
//  The installed HCRYPTPROV remains available for default usage until
//  CryptUninstallDefaultContext is called or the thread or process exits.
//
//  If CRYPT_DEFAULT_CONTEXT_AUTO_RELEASE_FLAG is set, then, the HCRYPTPROV
//  is CryptReleaseContext'ed at thread or process exit. However,
//  not CryptReleaseContext'ed if CryptUninstallDefaultContext is
//  called.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptInstallDefaultContext(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwDefaultType,
    IN const void *pvDefaultPara,
    IN DWORD dwFlags,
    IN void *pvReserved,
    OUT HCRYPTDEFAULTCONTEXT *phDefaultContext
    )
{
    BOOL fResult;
    CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA MultiOIDPara;
    LPSTR rgpszOID[1];
    PCRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA pMultiOIDPara;

    PDEFAULT_CONTEXT pDefaultContext = NULL;
    DWORD cbDefaultContext;
    BYTE *pbExtra;
    DWORD cbExtra;
    
    if (CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID == dwDefaultType) {
        dwDefaultType = CRYPT_DEFAULT_CONTEXT_MULTI_CERT_SIGN_OID;
        if (pvDefaultPara) {
            rgpszOID[0] = (LPSTR) pvDefaultPara;
            MultiOIDPara.cOID = 1;
            MultiOIDPara.rgpszOID = rgpszOID;
            pvDefaultPara = (const void *) &MultiOIDPara;
        }
    }

    if (CRYPT_DEFAULT_CONTEXT_MULTI_CERT_SIGN_OID != dwDefaultType)
        goto InvalidArg;

    pMultiOIDPara = (PCRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA) pvDefaultPara;
    if (pMultiOIDPara) {
        DWORD cOID = pMultiOIDPara->cOID;
        LPSTR *ppszOID = pMultiOIDPara->rgpszOID;

        if (0 == cOID)
            goto InvalidArg;
        cbExtra = INFO_LEN_ALIGN(sizeof(CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA)) +
            cOID * sizeof(LPSTR);

        for ( ; cOID; cOID--, ppszOID++)
            cbExtra += strlen(*ppszOID) + 1;
    } else {
        if (dwFlags & CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG)
            goto InvalidArg;
        cbExtra = 0;
    }

    cbDefaultContext = INFO_LEN_ALIGN(sizeof(DEFAULT_CONTEXT)) + cbExtra;

    if (NULL == (pDefaultContext = (PDEFAULT_CONTEXT) PkiZeroAlloc(
            cbDefaultContext)))
        goto OutOfMemory;

    pDefaultContext->hCryptProv = hCryptProv;
    pDefaultContext->dwDefaultType = dwDefaultType;
    pDefaultContext->dwFlags = dwFlags;

    pbExtra = ((BYTE *) pDefaultContext) +
        INFO_LEN_ALIGN(sizeof(DEFAULT_CONTEXT));

    if (cbExtra) {
        DWORD cOID = pMultiOIDPara->cOID;
        LPSTR *ppszOID = pMultiOIDPara->rgpszOID;

        PCRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA pOIDDefaultPara;
        LPSTR *ppszOIDDefault;

        assert(cOID);

        pOIDDefaultPara = (PCRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA) pbExtra;
        pDefaultContext->pOIDDefaultPara = pOIDDefaultPara;
        pbExtra += INFO_LEN_ALIGN(sizeof(CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA));

        ppszOIDDefault = (LPSTR *) pbExtra;
        pbExtra += cOID * sizeof(LPSTR);
        pOIDDefaultPara->cOID = cOID;
        pOIDDefaultPara->rgpszOID = ppszOIDDefault;

        for ( ; cOID; cOID--, ppszOID++, ppszOIDDefault++) {
            DWORD cch = strlen(*ppszOID) + 1;

            memcpy(pbExtra, *ppszOID, cch);
            *ppszOIDDefault = (LPSTR) pbExtra;
            pbExtra += cch;
        }
    }
    assert(pbExtra == ((BYTE *) pDefaultContext) + cbDefaultContext);

    if (dwFlags & CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG)
        fResult = InstallProcessDefaultContext(pDefaultContext);
    else
        fResult = InstallThreadDefaultContext(pDefaultContext);
    if (!fResult)
        goto ErrorReturn;

CommonReturn:
    *phDefaultContext = (HCRYPTDEFAULTCONTEXT) pDefaultContext;
    return fResult;

ErrorReturn:
    PkiFree(pDefaultContext);
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  Uninstall a default context previously installed by
//  CryptInstallDefaultContext.
//
//  For a default context installed with CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG
//  set, if any other threads are currently using this context,
//  this function will block until they finish.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptUninstallDefaultContext(
    HCRYPTDEFAULTCONTEXT hDefaultContext,
    IN DWORD dwFlags,
    IN void *pvReserved
    )
{
    BOOL fResult;
    PDEFAULT_CONTEXT pDefaultContext = (PDEFAULT_CONTEXT) hDefaultContext;
    PDEFAULT_CONTEXT pDefaultContextHead;
    BOOL fProcess;

    if (NULL == pDefaultContext)
        return TRUE;

    fProcess = (pDefaultContext->dwFlags & CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG);
    if (fProcess) {
        EnterCriticalSection(&DefaultContextCriticalSection);
        pDefaultContextHead = pProcessDefaultContextHead;
    } else { 
        pDefaultContextHead = (PDEFAULT_CONTEXT) I_CryptGetTls(
            hTlsDefaultContext);
    }

    if (NULL == pDefaultContextHead)
        goto InvalidArg;

    // Remove context from the list
    if (pDefaultContext->pNext)
        pDefaultContext->pNext->pPrev = pDefaultContext->pPrev;
    if (pDefaultContext->pPrev)
        pDefaultContext->pPrev->pNext = pDefaultContext->pNext;
    else if (pDefaultContext == pDefaultContextHead) {
        pDefaultContextHead = pDefaultContext->pNext;
        if (fProcess)
            pProcessDefaultContextHead = pDefaultContextHead;
        else
            I_CryptSetTls(hTlsDefaultContext, pDefaultContextHead);
    } else
        goto InvalidArg;

    if (fProcess) {
        if (pDefaultContext->lRefCnt) {
            // Wait for all uses of the hCryptProv handle to finish
            if (NULL == (pDefaultContext->hWait = CreateEvent(
                    NULL,       // lpsa
                    FALSE,      // fManualReset
                    FALSE,      // fInitialState
                    NULL))) {   // lpszEventName
                assert(pDefaultContext->hWait);
                goto UnexpectedError;
            }
                
            while (pDefaultContext->lRefCnt) {
                LeaveCriticalSection(&DefaultContextCriticalSection);
                WaitForSingleObject(pDefaultContext->hWait, INFINITE);
                EnterCriticalSection(&DefaultContextCriticalSection);
            }
            CloseHandle(pDefaultContext->hWait);
            pDefaultContext->hWait = NULL;
        }
    }

    PkiFree(pDefaultContext);
    fResult = TRUE;

CommonReturn:
    if (fProcess)
        LeaveCriticalSection(&DefaultContextCriticalSection);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR(UnexpectedError, E_UNEXPECTED)
}


static PDEFAULT_CONTEXT FindDefaultContext(
    IN DWORD dwDefaultType,
    IN const void *pvDefaultPara,
    IN PDEFAULT_CONTEXT pDefaultContext
    )
{
    for ( ; pDefaultContext; pDefaultContext = pDefaultContext->pNext) {
        switch (dwDefaultType) {
            case CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID:
                if (CRYPT_DEFAULT_CONTEXT_MULTI_CERT_SIGN_OID ==
                        pDefaultContext->dwDefaultType) {
                    PCRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA pOIDDefaultPara =
                        pDefaultContext->pOIDDefaultPara;
                    DWORD cOID;
                    LPSTR *ppszOID;

                    if (NULL == pOIDDefaultPara)
                        return pDefaultContext;

                    cOID = pOIDDefaultPara->cOID;
                    ppszOID = pOIDDefaultPara->rgpszOID;
                    for ( ; cOID; cOID--, ppszOID++) {
                        if (0 == strcmp(*ppszOID, (LPSTR) pvDefaultPara))
                            return pDefaultContext;
                    }
                }
                break;
            default:
                return NULL;
        }
    }

    return NULL;
}

//
// dwDefaultTypes:
//  CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID (pvDefaultPara :== pszOID)
BOOL
WINAPI
I_CryptGetDefaultContext(
    IN DWORD dwDefaultType,
    IN const void *pvDefaultPara,
    OUT HCRYPTPROV *phCryptProv,
    OUT HCRYPTDEFAULTCONTEXT *phDefaultContext
    )
{

    if (fHasThreadDefaultContext) {
        PDEFAULT_CONTEXT pDefaultContext;

        pDefaultContext = (PDEFAULT_CONTEXT) I_CryptGetTls(hTlsDefaultContext);
        if (pDefaultContext = FindDefaultContext(
                dwDefaultType,
                pvDefaultPara,
                pDefaultContext
                )) {
            *phCryptProv = pDefaultContext->hCryptProv;
            *phDefaultContext = NULL;
            return TRUE;
        }
    }

    if (fHasProcessDefaultContext) {
        PDEFAULT_CONTEXT pDefaultContext;

        EnterCriticalSection(&DefaultContextCriticalSection);
        if (pDefaultContext = FindDefaultContext(
                dwDefaultType,
                pvDefaultPara,
                pProcessDefaultContextHead
                ))
            pDefaultContext->lRefCnt++;
        LeaveCriticalSection(&DefaultContextCriticalSection);

        if (pDefaultContext) {
            *phCryptProv = pDefaultContext->hCryptProv;
            *phDefaultContext = (HCRYPTDEFAULTCONTEXT) pDefaultContext;
            return TRUE;
        }
    }

    *phCryptProv = NULL;
    *phDefaultContext = NULL;
    return FALSE;
}

// hDefaultContext is only NON-null for Process default context
void
WINAPI
I_CryptFreeDefaultContext(
    HCRYPTDEFAULTCONTEXT hDefaultContext
    )
{
    PDEFAULT_CONTEXT pDefaultContext = (PDEFAULT_CONTEXT) hDefaultContext;

    if (NULL == pDefaultContext)
        return;

    assert(pDefaultContext->dwFlags & CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG);
    assert(0 < pDefaultContext->lRefCnt);

    EnterCriticalSection(&DefaultContextCriticalSection);
    if (0 == --pDefaultContext->lRefCnt && pDefaultContext->hWait)
        SetEvent(pDefaultContext->hWait);
    LeaveCriticalSection(&DefaultContextCriticalSection);
}


#ifdef CMS_PKCS7

WINCRYPT32API
BOOL
WINAPI
CryptVerifyCertificateSignatureEx(
    IN OPTIONAL HCRYPTPROV hCryptProv,
    IN DWORD dwCertEncodingType,
    IN DWORD dwSubjectType,
    IN void *pvSubject,
    IN DWORD dwIssuerType,
    IN void *pvIssuer,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    )
{
    BOOL fResult;
    PCERT_SIGNED_CONTENT_INFO pSignedInfo = NULL;
    DWORD cbSignedInfo;
    HCRYPTDEFAULTCONTEXT hDefaultContext = NULL;
    HCRYPTKEY hSignKey = 0;
    HCRYPTHASH hHash = 0;
    BYTE *pbSignature;      // not allocated
    DWORD cbSignature;
    BYTE rgbDssSignature[CERT_DSS_SIGNATURE_LEN];
    ALG_ID aiHash;
    ALG_ID aiPubKey;
    DWORD dwProvType;
    HCRYPTPROV hAcquiredCryptProv = 0;
    DWORD dwSignFlags;
    DWORD dwErr;

    const BYTE *pbEncoded;  // not allocated
    DWORD cbEncoded;
    PCERT_PUBLIC_KEY_INFO pIssuerPubKeyInfo;
    CERT_PUBLIC_KEY_INFO IssuerPubKeyInfo;
    PCRYPT_OBJID_BLOB pIssuerPara;
    BYTE *pbAllocIssuerPara = NULL;

    switch (dwSubjectType) {
        case CRYPT_VERIFY_CERT_SIGN_SUBJECT_BLOB:
            {
                PCRYPT_DATA_BLOB pBlob = (PCRYPT_DATA_BLOB) pvSubject;
                pbEncoded = pBlob->pbData;
                cbEncoded = pBlob->cbData;
            }
            break;
        case CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT:
            {
                PCCERT_CONTEXT pSubject = (PCCERT_CONTEXT) pvSubject;
                pbEncoded = pSubject->pbCertEncoded;
                cbEncoded = pSubject->cbCertEncoded;
            }
            break;
        case CRYPT_VERIFY_CERT_SIGN_SUBJECT_CRL:
            {
                PCCRL_CONTEXT pSubject = (PCCRL_CONTEXT) pvSubject;
                pbEncoded = pSubject->pbCrlEncoded;
                cbEncoded = pSubject->cbCrlEncoded;
            }
            break;
        default:
            goto InvalidSubjectType;
    }
    
    if (!CryptDecodeObjectEx(
            dwCertEncodingType,
            X509_CERT,
            pbEncoded,
            cbEncoded,
            CRYPT_DECODE_NOCOPY_FLAG | CRYPT_DECODE_ALLOC_FLAG |
                CRYPT_DECODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG,
            &PkiDecodePara,
            (void *) &pSignedInfo,
            &cbSignedInfo
            )) goto DecodeCertError;

    if (!GetSignOIDInfo(pSignedInfo->SignatureAlgorithm.pszObjId,
            &aiHash, &aiPubKey, &dwSignFlags, &dwProvType))
        goto GetSignOIDInfoError;

    if (0 == hCryptProv) {
        if (!I_CryptGetDefaultContext(
                CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID,
                (const void *) pSignedInfo->SignatureAlgorithm.pszObjId,
                &hCryptProv,
                &hDefaultContext
                )) {
            if (dwProvType && CryptAcquireContext(
                    &hCryptProv,
                    NULL,               // pszContainer
                    NULL,               // pszProvider,
                    dwProvType,
                    CRYPT_VERIFYCONTEXT // dwFlags
                    ))
                hAcquiredCryptProv = hCryptProv;
            else if (0 == (hCryptProv = I_CryptGetDefaultCryptProv(aiPubKey)))
                goto GetDefaultCryptProvError;
        }
    }

#if 0
    // Slow down the signature verify while holding the default context
    // reference count
    if (hDefaultContext)
        Sleep(5000);
#endif

    switch (dwIssuerType) {
        case CRYPT_VERIFY_CERT_SIGN_ISSUER_PUBKEY:
            pIssuerPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) pvIssuer;
            break;
        case CRYPT_VERIFY_CERT_SIGN_ISSUER_CHAIN:
            {
                PCCERT_CHAIN_CONTEXT pChain = (PCCERT_CHAIN_CONTEXT) pvIssuer;

                // All chains have at least the leaf certificate context
                assert(pChain->cChain && pChain->rgpChain[0]->cElement);
                pvIssuer =
                    (void *) pChain->rgpChain[0]->rgpElement[0]->pCertContext;
                dwIssuerType = CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT;
            }
            // fall through
        case CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT:
            {
                PCCERT_CONTEXT pIssuer = (PCCERT_CONTEXT) pvIssuer;

                pIssuerPubKeyInfo = &pIssuer->pCertInfo->SubjectPublicKeyInfo;

                // Check if the public key parameters were omitted
                // from the encoded certificate. If omitted, try
                // to use the certificate's CERT_PUBKEY_ALG_PARA_PROP_ID
                // property.
                pIssuerPara = &pIssuerPubKeyInfo->Algorithm.Parameters;
                if (0 == pIssuerPara->cbData ||
                        NULL_ASN_TAG == *pIssuerPara->pbData) {
                    DWORD cbData;

                    if (CertGetCertificateContextProperty(
                            pIssuer,
                            CERT_PUBKEY_ALG_PARA_PROP_ID,
                            NULL,                       // pvData
                            &cbData) && 0 < cbData
                                    &&
                        (pbAllocIssuerPara = (BYTE *) PkiNonzeroAlloc(
                            cbData))
                                    &&
                        CertGetCertificateContextProperty(
                            pIssuer,
                            CERT_PUBKEY_ALG_PARA_PROP_ID,
                            pbAllocIssuerPara,
                            &cbData)) {

                        IssuerPubKeyInfo = *pIssuerPubKeyInfo;
                        IssuerPubKeyInfo.Algorithm.Parameters.pbData =
                            pbAllocIssuerPara;
                        IssuerPubKeyInfo.Algorithm.Parameters.cbData = cbData;
                        pIssuerPubKeyInfo = &IssuerPubKeyInfo;
                    }
                }
            }
            break;
        case CRYPT_VERIFY_CERT_SIGN_ISSUER_NULL:
            if (CALG_NO_SIGN != aiPubKey)
                goto InvalidIssuerType;
            pIssuerPubKeyInfo = NULL;
            break;
        default:
            goto InvalidIssuerType;
    }

    if (CALG_NO_SIGN == aiPubKey) {
        if (dwIssuerType != CRYPT_VERIFY_CERT_SIGN_ISSUER_NULL)
            goto InvalidIssuerType;
    } else {
        if (!CryptImportPublicKeyInfo(
                hCryptProv,
                dwCertEncodingType,
                pIssuerPubKeyInfo,
                &hSignKey
                )) goto ImportPublicKeyInfoError;
    }
    if (!CryptCreateHash(
                hCryptProv,
                aiHash,
                NULL,               // hKey - optional for MAC
                0,                  // dwFlags
                &hHash
                )) goto CreateHashError;
    if (!CryptHashData(
                hHash,
                pSignedInfo->ToBeSigned.pbData,
                pSignedInfo->ToBeSigned.cbData,
                0                   // dwFlags
                )) goto HashDataError;


    pbSignature = pSignedInfo->Signature.pbData;
    cbSignature = pSignedInfo->Signature.cbData;

    if (0 == cbSignature)
        goto NoSignatureError;

    if (CALG_NO_SIGN == aiPubKey) {
        BYTE rgbHash[MAX_HASH_LEN];
        DWORD cbHash = sizeof(rgbHash);

        if (!CryptGetHashParam(
                hHash,
                HP_HASHVAL,
                rgbHash,
                &cbHash,
                0                   // dwFlags
                ))
            goto GetHashValueError;

        if (cbHash != cbSignature || 0 != memcmp(rgbHash, pbSignature, cbHash))
            goto NoSignHashCompareError;

        goto SuccessReturn;
    }

    if (CALG_DSS_SIGN == aiPubKey &&
            0 == (dwSignFlags & CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG)) {
        DWORD cbData;

        // Convert from ASN.1 sequence of two integers to the CSP signature
        // format.
        cbData = sizeof(rgbDssSignature);
        if (!CryptDecodeObject(
                dwCertEncodingType,
                X509_DSS_SIGNATURE,
                pbSignature,
                cbSignature,
                0,                                  // dwFlags
                rgbDssSignature,
                &cbData
                ))
            goto DecodeDssSignatureError;
        pbSignature = rgbDssSignature;
        assert(cbData == sizeof(rgbDssSignature));
        cbSignature = sizeof(rgbDssSignature);
    } else 
        PkiAsn1ReverseBytes(pbSignature, cbSignature);

    if (!CryptVerifySignature(
                hHash,
                pbSignature,
                cbSignature,
                hSignKey,
                NULL,               // sDescription
                0                   // dwFlags
                )) goto VerifySignatureError;


    // For a certificate context certificate, check if the issuer has public
    // key parameters that can be inherited
    pIssuerPara = &pIssuerPubKeyInfo->Algorithm.Parameters;
    if (CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT == dwSubjectType &&
            pIssuerPara->cbData && NULL_ASN_TAG != *pIssuerPara->pbData) {
        // If a subject is missing its public key parameters and has
        // the same public key algorithm as its issuer, then, set
        // its CERT_PUBKEY_ALG_PARA_PROP_ID property.

        PCCERT_CONTEXT pSubject = (PCCERT_CONTEXT) pvSubject;
        PCERT_PUBLIC_KEY_INFO pSubjectPubKeyInfo =
            &pSubject->pCertInfo->SubjectPublicKeyInfo;
        PCCRYPT_OID_INFO pOIDInfo;
        PCRYPT_OBJID_BLOB pSubjectPara;
        DWORD cbData;

        pSubjectPara = &pSubjectPubKeyInfo->Algorithm.Parameters;
        if (pSubjectPara->cbData && NULL_ASN_TAG != *pSubjectPara->pbData)
            // Subject public key has parameters
            goto SuccessReturn;

        if (CertGetCertificateContextProperty(
                pSubject,
                CERT_PUBKEY_ALG_PARA_PROP_ID,
                NULL,                       // pvData
                &cbData) && 0 < cbData)
            // Subject already has public key parameters property
            goto SuccessReturn;

        pOIDInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            pSubjectPubKeyInfo->Algorithm.pszObjId,
            CRYPT_PUBKEY_ALG_OID_GROUP_ID);

        if (NULL == pOIDInfo || aiPubKey != pOIDInfo->Algid)
            // Subject and issuer don't have the same public key algorithms
            goto SuccessReturn;

        CertSetCertificateContextProperty(
            pSubject,
            CERT_PUBKEY_ALG_PARA_PROP_ID,
            CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG,
            pIssuerPara
            );
    }
    

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    dwErr = GetLastError();
    if (hSignKey)
        CryptDestroyKey(hSignKey);
    if (hHash)
        CryptDestroyHash(hHash);
    I_CryptFreeDefaultContext(hDefaultContext);
    if (hAcquiredCryptProv)
        CryptReleaseContext(hAcquiredCryptProv, 0);
    PkiFree(pSignedInfo);
    PkiFree(pbAllocIssuerPara);

    SetLastError(dwErr);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidSubjectType, E_INVALIDARG)
TRACE_ERROR(DecodeCertError)
TRACE_ERROR(GetSignOIDInfoError)
TRACE_ERROR(GetDefaultCryptProvError)
SET_ERROR(InvalidIssuerType, E_INVALIDARG)
TRACE_ERROR(ImportPublicKeyInfoError)
TRACE_ERROR(CreateHashError)
TRACE_ERROR(HashDataError)
SET_ERROR(NoSignatureError, TRUST_E_NOSIGNATURE)
TRACE_ERROR(GetHashValueError)
SET_ERROR(NoSignHashCompareError, NTE_BAD_SIGNATURE)
TRACE_ERROR(DecodeDssSignatureError)
TRACE_ERROR(VerifySignatureError)
}

//+-------------------------------------------------------------------------
//  Verify the signature of a subject certificate or a CRL using the
//  specified public key.
//
//  Returns TRUE for a valid signature.
//
//  hCryptProv specifies the crypto provider to use to verify the signature.
//  It doesn't need to use a private key.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptVerifyCertificateSignature(
    IN HCRYPTPROV   hCryptProv,
    IN DWORD        dwCertEncodingType,
    IN const BYTE * pbEncoded,
    IN DWORD        cbEncoded,
    IN PCERT_PUBLIC_KEY_INFO pPublicKey
    )
{
    CRYPT_DATA_BLOB Subject;

    Subject.cbData = cbEncoded;
    Subject.pbData = (BYTE *) pbEncoded;
    return CryptVerifyCertificateSignatureEx(
        hCryptProv,
        dwCertEncodingType,
        CRYPT_VERIFY_CERT_SIGN_SUBJECT_BLOB,
        (void *) &Subject,
        CRYPT_VERIFY_CERT_SIGN_ISSUER_PUBKEY,
        (void *) pPublicKey,
        0,                                      // dwFlags
        NULL                                    // pvReserved
        );
}

#endif  // CMS_PKCS7
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\async.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       async.cpp
//
//  Contents:   Async Parameter Management
//
//  History:    05-Aug-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
#include <async.h>
//+---------------------------------------------------------------------------
//
//  Function:   CryptCreateAsyncHandle
//
//  Synopsis:   create async param handle
//
//----------------------------------------------------------------------------
BOOL WINAPI
CryptCreateAsyncHandle (
     IN DWORD dwFlags,
     OUT PHCRYPTASYNC phAsync
     )
{
    CCryptAsyncHandle* pAsyncHandle;

    pAsyncHandle = new CCryptAsyncHandle( dwFlags );
    if ( pAsyncHandle == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    *phAsync = pAsyncHandle;
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   CryptSetAsyncParam
//
//  Synopsis:   set async parameter
//
//----------------------------------------------------------------------------
BOOL WINAPI
CryptSetAsyncParam (
     IN HCRYPTASYNC hAsync,
     IN LPSTR pszParamOid,
     IN LPVOID pvParam,
     IN OPTIONAL PFN_CRYPT_ASYNC_PARAM_FREE_FUNC pfnFree
     )
{
    return( ( ( CCryptAsyncHandle* )hAsync )->SetAsyncParam(
                                                 pszParamOid,
                                                 pvParam,
                                                 pfnFree
                                                 ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CryptGetAsyncParam
//
//  Synopsis:   get async parameter
//
//----------------------------------------------------------------------------
BOOL WINAPI
CryptGetAsyncParam (
     IN HCRYPTASYNC hAsync,
     IN LPSTR pszParamOid,
     OUT LPVOID* ppvParam,
     OUT OPTIONAL PFN_CRYPT_ASYNC_PARAM_FREE_FUNC* ppfnFree
     )
{
    return( ( ( CCryptAsyncHandle* )hAsync )->GetAsyncParam(
                                                 pszParamOid,
                                                 ppvParam,
                                                 ppfnFree
                                                 ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CryptCloseAsyncHandle
//
//  Synopsis:   close async handle
//
//----------------------------------------------------------------------------
BOOL WINAPI
CryptCloseAsyncHandle (
     IN HCRYPTASYNC hAsync
     )
{
    delete ( CCryptAsyncHandle * )hAsync;
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptAsyncHandle::CCryptAsyncHandle, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CCryptAsyncHandle::CCryptAsyncHandle (DWORD dwFlags)
{
    m_pConstOidList = NULL;
    m_pStrOidList = NULL;
    Pki_InitializeCriticalSection( &m_AsyncLock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptAsyncHandle::~CCryptAsyncHandle, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CCryptAsyncHandle::~CCryptAsyncHandle ()
{
    FreeOidList( m_pConstOidList, TRUE );
    FreeOidList( m_pStrOidList, FALSE );
    DeleteCriticalSection( &m_AsyncLock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptAsyncHandle::SetAsyncParam, public
//
//  Synopsis:   set an async parameter, if the pvParam is NULL then
//              the parameter is removed and freed if a free function
//              has been specified
//
//----------------------------------------------------------------------------
BOOL
CCryptAsyncHandle::SetAsyncParam (
                      LPSTR pszParamOid,
                      LPVOID pvParam,
                      PFN_CRYPT_ASYNC_PARAM_FREE_FUNC pfnFree
                      )
{
    BOOL               fReturn = FALSE;
    PCRYPT_ASYNC_PARAM pParam = NULL;
    BOOL               fConstOid = ( (DWORD_PTR)pszParamOid <= 0xFFFF );

    EnterCriticalSection( &m_AsyncLock );

    pParam = FindAsyncParam( pszParamOid, fConstOid );

    if ( pvParam == NULL )
    {
        if ( pParam != NULL )
        {
            RemoveAsyncParam( pParam );
            FreeAsyncParam( pParam, fConstOid );
            fReturn = TRUE;
        }
        else
        {
            SetLastError( (DWORD) E_INVALIDARG );
        }

        LeaveCriticalSection( &m_AsyncLock );
        return( fReturn );
    }

    if ( pParam != NULL )
    {
        if ( pParam->pfnFree != NULL )
        {
            (*pParam->pfnFree)( pszParamOid, pvParam );
        }

        pParam->pvParam = pvParam;

        LeaveCriticalSection( &m_AsyncLock );
        return( TRUE );
    }

    if ( AllocAsyncParam(
              pszParamOid,
              fConstOid,
              pvParam,
              pfnFree,
              &pParam
              ) == TRUE )
    {
        AddAsyncParam( pParam, fConstOid );
        fReturn = TRUE;
    }
    else
    {
        fReturn = FALSE;
    }

    LeaveCriticalSection( &m_AsyncLock );
    return( fReturn );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptAsyncHandle::GetAsyncParam, public
//
//  Synopsis:   get an async parameter
//
//----------------------------------------------------------------------------
BOOL
CCryptAsyncHandle::GetAsyncParam (
                      LPSTR pszParamOid,
                      LPVOID* ppvParam,
                      PFN_CRYPT_ASYNC_PARAM_FREE_FUNC* ppfnFree
                      )
{
    PCRYPT_ASYNC_PARAM pFoundParam = NULL;
    BOOL               fConstOid = ( (DWORD_PTR)pszParamOid <= 0xFFFF );

    EnterCriticalSection( &m_AsyncLock );

    pFoundParam = FindAsyncParam( pszParamOid, fConstOid );
    if ( pFoundParam == NULL )
    {
        LeaveCriticalSection( &m_AsyncLock );
        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }

    *ppvParam = pFoundParam->pvParam;
    if ( ppfnFree != NULL )
    {
        *ppfnFree = pFoundParam->pfnFree;
    }

    LeaveCriticalSection( &m_AsyncLock );
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptAsyncHandle::AllocAsyncParam, private
//
//  Synopsis:   allocate an async parameter block
//
//----------------------------------------------------------------------------
BOOL
CCryptAsyncHandle::AllocAsyncParam (
                        LPSTR pszParamOid,
                        BOOL fConstOid,
                        LPVOID pvParam,
                        PFN_CRYPT_ASYNC_PARAM_FREE_FUNC pfnFree,
                        PCRYPT_ASYNC_PARAM* ppParam
                        )
{
    HRESULT            hr = S_OK;
    PCRYPT_ASYNC_PARAM pParam;

    pParam = new CRYPT_ASYNC_PARAM;
    if ( pParam != NULL )
    {
        memset( pParam, 0, sizeof( CRYPT_ASYNC_PARAM ) );
        if ( fConstOid == FALSE )
        {
            pParam->pszOid = new CHAR [strlen( pszParamOid ) + 1];
            if ( pParam->pszOid != NULL )
            {
                strcpy( pParam->pszOid, pszParamOid );
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            pParam->pszOid = pszParamOid;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if ( hr != S_OK )
    {
        SetLastError( hr );
        return( FALSE );
    }

    pParam->pvParam = pvParam,
    pParam->pfnFree = pfnFree;
    *ppParam = pParam;

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptAsyncHandle::FreeAsyncParam, private
//
//  Synopsis:   free an async param
//
//----------------------------------------------------------------------------
VOID
CCryptAsyncHandle::FreeAsyncParam (
                       PCRYPT_ASYNC_PARAM pParam,
                       BOOL fConstOid
                       )
{
    if ( pParam->pfnFree != NULL )
    {
        (*pParam->pfnFree)( pParam->pszOid, pParam->pvParam );
    }

    if ( fConstOid == FALSE )
    {
        delete pParam->pszOid;
    }

    delete pParam;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptAsyncHandle::AddAsyncParam, private
//
//  Synopsis:   add an async parameter
//
//----------------------------------------------------------------------------
VOID
CCryptAsyncHandle::AddAsyncParam (
                      PCRYPT_ASYNC_PARAM pParam,
                      BOOL fConstOid
                      )
{
    PCRYPT_ASYNC_PARAM* ppOidList;

    if ( fConstOid == TRUE )
    {
        ppOidList = &m_pConstOidList;
    }
    else
    {
        ppOidList = &m_pStrOidList;
    }

    pParam->pNext = *ppOidList;
    pParam->pPrev = NULL;
    *ppOidList = pParam;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptAsyncHandle::RemoveAsyncParam, private
//
//  Synopsis:   remove an async parameter
//
//----------------------------------------------------------------------------
VOID
CCryptAsyncHandle::RemoveAsyncParam (
                         PCRYPT_ASYNC_PARAM pParam
                         )
{
    if ( pParam->pPrev != NULL )
    {
        pParam->pPrev->pNext = pParam->pNext;
    }

    if ( pParam->pNext != NULL )
    {
        pParam->pNext->pPrev = pParam->pPrev;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptAsyncHandle::FindAsyncParam, private
//
//  Synopsis:   find an async parameter
//
//----------------------------------------------------------------------------
PCRYPT_ASYNC_PARAM
CCryptAsyncHandle::FindAsyncParam (
                       LPSTR pszParamOid,
                       BOOL fConstOid
                       )
{
    PCRYPT_ASYNC_PARAM pParam;

    if ( fConstOid == TRUE )
    {
        pParam = m_pConstOidList;
    }
    else
    {
        pParam = m_pStrOidList;
    }

    while ( pParam != NULL )
    {
        if ( fConstOid == TRUE )
        {
            if ( pParam->pszOid == pszParamOid )
            {
                break;
            }
        }
        else
        {
            if ( _stricmp( pParam->pszOid, pszParamOid ) == 0 )
            {
                break;
            }
        }

        pParam = pParam->pNext;
    }

    return( pParam );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptAsyncHandle::FreeOidList, private
//
//  Synopsis:   free an OID list
//
//----------------------------------------------------------------------------
VOID
CCryptAsyncHandle::FreeOidList (
                       PCRYPT_ASYNC_PARAM pOidList,
                       BOOL fConstOidList
                       )
{
    PCRYPT_ASYNC_PARAM pParam;
    PCRYPT_ASYNC_PARAM pParamNext;

    pParam = pOidList;

    while ( pParam != NULL )
    {
        pParamNext = pParam->pNext;
        FreeAsyncParam( pParam, fConstOidList );
        pParam = pParamNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\certstr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       certstr.cpp
//
//  Contents:   Certificate String and Unicode Helper APIs
//
//  Functions:
//              CertRDNValueToStrA
//              CertRDNValueToStrW
//              UnicodeNameValueEncodeEx
//              UnicodeNameValueDecodeEx
//              UnicodeNameInfoEncodeEx
//              UnicodeNameInfoDecodeEx
//              CertNameToStrW
//              CertNameToStrA
//              CertStrToNameW
//              CertStrToNameA
//              CertGetNameStringW
//              CertGetNameStringA
//
//  Note:
//      Linked into xenroll.dll. xenroll.dll must be able to work with
//      crypt32.dll 3.02 which doesn't export CryptEncodeObjectEx.
//      xenroll.dll only calls CertNameToStrW.
//
//  History:    24-Mar-96   philh   created
//--------------------------------------------------------------------------


#include "global.hxx"
#include <dbgdef.h>


// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)

// Unicode Surrogate Pairs map to Universal characters as follows:
//     D800 -    DBFF : 0000 0000 0000 0000 1101 10YY YYYY YYYY  (10 Bits)
//     DC00 -    DFFF : 0000 0000 0000 0000 1101 11XX XXXX XXXX  (10 Bits)
//
//     10000 - 10FFFF : 0000 0000 0000 YYYY YYYY YYXX XXXX XXXX  (20 Bits)
//                                      +
//                      0000 0000 0000 0001 0000 0000 0000 0000

// Unicode Surrogate Pair Character ranges
#define UNICODE_HIGH_SURROGATE_START        0xD800
#define UNICODE_HIGH_SURROGATE_END          0xDBFF
#define UNICODE_LOW_SURROGATE_START         0xDC00
#define UNICODE_LOW_SURROGATE_END           0xDFFF

// Any Universal characters > 10FFFF map to the following Unicode character
#define UNICODE_REPLACEMENT_CHAR            0xFFFD

// Universal Surrogate Character ranges
#define UNIVERSAL_SURROGATE_START       0x00010000
#define UNIVERSAL_SURROGATE_END         0x0010FFFF

//+-------------------------------------------------------------------------
//  Maps an ASN.1 8 bit character string to a new wide-character (Unicode).
//
//  If fDisableIE4UTF8 isn't set, the 8 bit character string is initially
//  processed as UTF-8 encoded characters.
//
//  If fDisableIE4UTF8 is set or the UTF-8 conversion fails, converts to
//  wide characters by doing a WCHAR cast.
//--------------------------------------------------------------------------
static int WINAPI Asn1ToWideChar(
    IN LPCSTR lp8BitStr,
    IN int cch8Bit,
    IN BOOL fDisableIE4UTF8,
    OUT LPWSTR lpWideCharStr,
    IN int cchWideChar
    )
{
    int cchOutWideChar;

    if (!fDisableIE4UTF8) {
        int cchUTF8WideChar;

        cchUTF8WideChar = UTF8ToWideChar(
            lp8BitStr,
            cch8Bit,
            lpWideCharStr,
            cchWideChar
            );
        if (0 < cchUTF8WideChar)
            return cchUTF8WideChar;
    }

    if (cch8Bit < 0)
        cch8Bit = strlen(lp8BitStr) + 1;
    cchOutWideChar = cch8Bit;

    if (cchWideChar < 0)
        goto InvalidParameter;
    else if (0 == cchWideChar)
        goto CommonReturn;
    else if (cchOutWideChar > cchWideChar)
        goto InsufficientBuffer;

    while (cch8Bit--)
        *lpWideCharStr++ = (unsigned char) *lp8BitStr++;

CommonReturn:
    return cchOutWideChar;

ErrorReturn:
    cchOutWideChar = 0;
    goto CommonReturn;
SET_ERROR(InvalidParameter, ERROR_INVALID_PARAMETER)
SET_ERROR(InsufficientBuffer, ERROR_INSUFFICIENT_BUFFER)
}

//+-------------------------------------------------------------------------
//  Maps a wide-character (Unicode) string to a new ASN.1 8 bit character
//  string.
//--------------------------------------------------------------------------
static inline void WideCharToAsn1(
    IN LPCWSTR lpWideCharStr,
    IN DWORD cchWideChar,
    OUT LPSTR lp8BitStr
    )
{
    while (cchWideChar--)
        *lp8BitStr++ = (unsigned char) (*lpWideCharStr++ & 0xFF);
}

static void *AllocAndDecodeObject(
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwFlags,
    OUT OPTIONAL DWORD *pcbStructInfo = NULL
    )
{
    DWORD cbStructInfo;
    void *pvStructInfo;

    if (!CryptDecodeObjectEx(
            dwCertEncodingType,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            dwFlags | CRYPT_DECODE_ALLOC_FLAG | CRYPT_DECODE_NOCOPY_FLAG,
            &PkiDecodePara,
            (void *) &pvStructInfo,
            &cbStructInfo
            ))
        goto ErrorReturn;

CommonReturn:
    if (pcbStructInfo)
        *pcbStructInfo = cbStructInfo;
    return pvStructInfo;
ErrorReturn:
    pvStructInfo = NULL;
    cbStructInfo = 0;
    goto CommonReturn;
}

typedef BOOL (WINAPI *PFN_NESTED_DECODE_INFO_EX_CALLBACK)(
    IN void *pvDecodeInfo,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
    OUT OPTIONAL void *pvStructInfo,
    IN OUT LONG *plRemainExtra
    );

static BOOL WINAPI NestedDecodeAndAllocInfoEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_NESTED_DECODE_INFO_EX_CALLBACK pfnDecodeInfoExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;
    LONG lRemainExtra;
    DWORD cbStructInfo;
    void *pvDecodeInfo = NULL;
    DWORD cbDecodeInfo;

    if (NULL == pvStructInfo || (dwFlags & CRYPT_DECODE_ALLOC_FLAG)) {
        cbStructInfo = 0;
        lRemainExtra = 0;
    } else {
        cbStructInfo = *pcbStructInfo;
        lRemainExtra = (LONG) cbStructInfo;
    }

    if (!CryptDecodeObjectEx(
            dwCertEncodingType,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            CRYPT_DECODE_ALLOC_FLAG | CRYPT_DECODE_NOCOPY_FLAG,
            &PkiDecodePara,
            (void *) &pvDecodeInfo,
            &cbDecodeInfo
            )) goto DecodeObjectError;

    if (!pfnDecodeInfoExCallback(
            pvDecodeInfo,
            dwFlags & ~CRYPT_DECODE_ALLOC_FLAG,
            pDecodePara,
            pvStructInfo,
            &lRemainExtra
            )) goto DecodeCallbackError;

    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG) {
        void *pv;
        PFN_CRYPT_ALLOC pfnAlloc = PkiGetDecodeAllocFunction(pDecodePara);

        assert(0 > lRemainExtra);
        lRemainExtra = -lRemainExtra;
        cbStructInfo = (DWORD) lRemainExtra;

        if (NULL == (pv = pfnAlloc(cbStructInfo)))
            goto OutOfMemory;
        if (!pfnDecodeInfoExCallback(
                pvDecodeInfo,
                dwFlags & ~CRYPT_DECODE_ALLOC_FLAG,
                pDecodePara,
                pv,
                &lRemainExtra
                )) {
            PFN_CRYPT_FREE pfnFree = PkiGetDecodeFreeFunction(pDecodePara);
            pfnFree(pv);
            goto DecodeCallbackError;
        }
        *((void **) pvStructInfo) = pv;
        assert(0 <= lRemainExtra);
    }

    if (0 <= lRemainExtra) {
        cbStructInfo -= (DWORD) lRemainExtra;
    } else {
        cbStructInfo += (DWORD) -lRemainExtra;
        if (pvStructInfo) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
            goto CommonReturn;
        }
    }

    fResult = TRUE;
CommonReturn:
    *pcbStructInfo = cbStructInfo;
    PkiFree(pvDecodeInfo);
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG)
        *((void **) pvStructInfo) = NULL;
    cbStructInfo = 0;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(DecodeObjectError)
TRACE_ERROR(DecodeCallbackError)
TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  Convert a Name Value to a null terminated char string
//
//  Returns the number of bytes converted including the terminating null
//  character. If psz is NULL or csz is 0, returns the required size of the
//  destination string (including the terminating null char).
//
//  If psz != NULL && csz != 0, returned psz is always NULL terminated.
//
//  Note: csz includes the NULL char.
//--------------------------------------------------------------------------
DWORD
WINAPI
CertRDNValueToStrA(
    IN DWORD dwValueType,
    IN PCERT_RDN_VALUE_BLOB pValue,
    OUT OPTIONAL LPSTR psz,
    IN DWORD csz
    )
{
    DWORD cszOut = 0;
    LPWSTR pwsz = NULL;
    DWORD cwsz;

    if (psz == NULL)
        csz = 0;

    cwsz = CertRDNValueToStrW(
        dwValueType,
        pValue,
        NULL,                   // pwsz
        0                       // cwsz
        );
    if (pwsz = (LPWSTR) PkiNonzeroAlloc(cwsz * sizeof(WCHAR))) {
        CertRDNValueToStrW(
            dwValueType,
            pValue,
            pwsz,
            cwsz
            );

        int cchMultiByte;
        cchMultiByte = WideCharToMultiByte(
            CP_ACP,
            0,                      // dwFlags
            pwsz,
            -1,                     // Null terminated
            psz,
            (int) csz,
            NULL,                   // lpDefaultChar
            NULL                    // lpfUsedDefaultChar
            );
        if (cchMultiByte < 1)
            cszOut = 0;
        else
            // Subtract off the trailing null terminator
            cszOut = (DWORD) cchMultiByte - 1;

        PkiFree(pwsz);
    }

    if (csz != 0) {
        // Always NULL terminate
        *(psz + cszOut) = '\0';
    }
    return cszOut + 1;
}


DWORD
WINAPI
GetSurrogatePairCountFromUniversalString(
    IN DWORD *pdw,
    IN DWORD cdw
    )
{
    DWORD cSP = 0;

    for ( ; cdw > 0; cdw--, pdw++) {
        DWORD dw = *pdw;
        if (dw >= UNIVERSAL_SURROGATE_START &&
                dw <= UNIVERSAL_SURROGATE_END)
            cSP++;
    }

    return cSP;
}

//+-------------------------------------------------------------------------
//  Convert a Name Value to a null terminated WCHAR string
//
//  Returns the number of WCHARs converted including the terminating null
//  WCHAR. If pwsz is NULL or cwsz is 0, returns the required size of the
//  destination string (including the terminating null WCHAR).
//
//  If pwsz != NULL && cwsz != 0, returned pwsz is always NULL terminated.
//
//  Note: cwsz includes the NULL WCHAR.
//--------------------------------------------------------------------------
DWORD
WINAPI
CertRDNValueToStrW(
    IN DWORD dwValueType,
    IN PCERT_RDN_VALUE_BLOB pValue,
    OUT OPTIONAL LPWSTR pwsz,
    IN DWORD cwsz
    )
{
    BOOL fDisableIE4UTF8;
    DWORD cwszOut = 0;

    if (pwsz == NULL)
        cwsz = 0;

    fDisableIE4UTF8 = (0 != (dwValueType & CERT_RDN_DISABLE_IE4_UTF8_FLAG));
    dwValueType &= CERT_RDN_TYPE_MASK;

    if (dwValueType == CERT_RDN_UNICODE_STRING ||
            dwValueType == CERT_RDN_UTF8_STRING) {
        cwszOut = pValue->cbData / sizeof(WCHAR);
        if (cwsz > 0) {
            cwszOut = min(cwszOut, cwsz - 1);
            if (cwszOut)
                memcpy((BYTE *) pwsz, pValue->pbData, cwszOut * sizeof(WCHAR));
        }
    } else if (dwValueType == CERT_RDN_UNIVERSAL_STRING) {
        // 4 byte string. Characters < 0x10000 are converted directly to
        // Unicode. Characters within 0x10000 .. 0x10FFFF are mapped
        // to a surrogate pair. Any character > 0x10FFFF is mapped to
        // the replacement character, 0xFFFD.
        DWORD *pdwIn = (DWORD *) pValue->pbData;
        DWORD cdwIn = pValue->cbData / sizeof(DWORD);

        cwszOut = cdwIn +
            GetSurrogatePairCountFromUniversalString(pdwIn, cdwIn);
        if (cwsz > 0) {
            DWORD cOut;
            LPWSTR pwszOut;

            cwszOut = min(cwszOut, cwsz - 1);
            cOut = cwszOut;
            pwszOut = pwsz;
            for ( ; cdwIn > 0 && cOut > 0; cdwIn--, cOut--) {
                DWORD dw = *pdwIn++;
                if (dw < UNIVERSAL_SURROGATE_START)
                    *pwszOut++ = (WCHAR) dw;
                else if (dw <= UNIVERSAL_SURROGATE_END) {
                    if (cOut > 1) {
                        // Surrogate pair contains 20 bits.
                        DWORD dw20Bits;

                        dw20Bits = dw - UNIVERSAL_SURROGATE_START;
                        assert(dw20Bits <= 0xFFFFF);
                        *pwszOut++ = (WCHAR) (UNICODE_HIGH_SURROGATE_START +
                            (dw20Bits >> 10));
                        *pwszOut++ = (WCHAR) (UNICODE_LOW_SURROGATE_START +
                            (dw20Bits & 0x3FF));
                        cOut--;
                    } else
                        *pwszOut++ = UNICODE_REPLACEMENT_CHAR;
                } else
                    *pwszOut++ = UNICODE_REPLACEMENT_CHAR;
            }
        }
    } else {
        // Treat as a 8 bit character string
        if (cwsz != 1) {
            int cchWideChar;

            if (cwsz == 0)
                cchWideChar = 0;
            else
                cchWideChar = cwsz - 1;

            if (dwValueType != CERT_RDN_T61_STRING)
                fDisableIE4UTF8 = TRUE;
            cchWideChar = Asn1ToWideChar(
                (LPSTR) pValue->pbData,
                pValue->cbData,
                fDisableIE4UTF8,
                pwsz,
                cchWideChar
                );
            if (cchWideChar <= 0)
                cwszOut = 0;
            else
                cwszOut = (DWORD) cchWideChar;
        }
    }

    if (cwsz != 0) {
        // Always NULL terminate
        *(pwsz + cwszOut) = L'\0';
    }
    return cwszOut + 1;
}

//+-------------------------------------------------------------------------
//  Wide Character functions
//
//  Needed, since we don't link with 'C' runtime
//--------------------------------------------------------------------------
static inline BOOL IsSpaceW(WCHAR wc)
{
    return wc == L' ' || (wc >= 0x09 && wc <= 0x0d);
}
static BOOL IsInStrW(LPCWSTR pwszList, WCHAR wc)
{
    WCHAR wcList;
    while (wcList = *pwszList++)
        if (wc == wcList)
            return TRUE;
    return FALSE;
}

//+-------------------------------------------------------------------------
//  Checks if an ASN.1 numeric character
//--------------------------------------------------------------------------
static inline BOOL IsNumericW(WCHAR wc)
{
    return (wc >= L'0' && wc <= L'9') || wc == L' ';
}

//+-------------------------------------------------------------------------
//  Checks if an ASN.1 printable character
//--------------------------------------------------------------------------
static inline BOOL IsPrintableW(WCHAR wc)
{
    return (wc >= L'A' && wc <= L'Z') || (wc >= L'a' && wc <= L'z') ||
        IsNumericW(wc) || IsInStrW(L"\'()+,-./:=?", wc);
}

//+-------------------------------------------------------------------------
//  Returns 0 if the unicode character string doesn't contain any invalid
//  characters. Otherwise, returns CRYPT_E_INVALID_NUMERIC_STRING,
//  CRYPT_E_INVALID_PRINTABLE_STRING or CRYPT_E_INVALID_IA5_STRING with
//  *pdwErrLocation updated with the index of the first invalid character.
//--------------------------------------------------------------------------
static DWORD CheckUnicodeValueType(
        IN DWORD dwValueType,
        IN LPCWSTR pwszAttr,
        IN DWORD cchAttr,
        OUT DWORD *pdwErrLocation
        )
{
    DWORD i;
    DWORD dwErr;

    assert(dwValueType & CERT_RDN_TYPE_MASK);
    *pdwErrLocation = 0;

    dwErr = 0;
    for (i = 0; i < cchAttr; i++) {
        WCHAR wc = pwszAttr[i];

        switch (dwValueType & CERT_RDN_TYPE_MASK) {
        case CERT_RDN_NUMERIC_STRING:
            if (!IsNumericW(wc))
                dwErr = (DWORD) CRYPT_E_INVALID_NUMERIC_STRING;
            break;
        case CERT_RDN_PRINTABLE_STRING:
            if (!IsPrintableW(wc))
                dwErr = (DWORD) CRYPT_E_INVALID_PRINTABLE_STRING;
            break;
        case CERT_RDN_IA5_STRING:
            if (wc > 0x7F)
                dwErr = (DWORD) CRYPT_E_INVALID_IA5_STRING;
            break;
        default:
            return 0;
        }

        if (0 != dwErr) {
            assert(i <= CERT_UNICODE_VALUE_ERR_INDEX_MASK);
            *pdwErrLocation = i & CERT_UNICODE_VALUE_ERR_INDEX_MASK;
            return dwErr;
        }
    }

    return 0;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CERT_RDN attribute value. The values are unicode.
//+-------------------------------------------------------------------------
static BOOL SetUnicodeRDNAttributeValue(
        IN DWORD dwValueType,
        IN PCERT_RDN_VALUE_BLOB pSrcValue,
        IN BOOL fDisableCheckType,
        OUT PCERT_RDN_VALUE_BLOB pDstValue,
        OUT OPTIONAL DWORD *pdwErrLocation
        )
{
    BOOL fResult;
    LPCWSTR pwszAttr;
    DWORD cchAttr;
    DWORD dwErr;

    if (pdwErrLocation)
        *pdwErrLocation = 0;

    dwValueType &= CERT_RDN_TYPE_MASK;

    memset(pDstValue, 0, sizeof(CERT_RDN_VALUE_BLOB));
    if (CERT_RDN_ANY_TYPE == dwValueType)
        goto InvalidArg;
    assert(IS_CERT_RDN_CHAR_STRING(dwValueType));

    pwszAttr = pSrcValue->pbData ? (LPCWSTR) pSrcValue->pbData : L"";
    cchAttr = (DWORD)( pSrcValue->cbData ?
        pSrcValue->cbData / sizeof(WCHAR) : wcslen(pwszAttr) );

    // Update Destination Value
    if (cchAttr) {
        switch (dwValueType) {
        case CERT_RDN_UNICODE_STRING:
        case CERT_RDN_UTF8_STRING:
            // Use source. No allocation or copy required
            pDstValue->pbData = (BYTE *) pwszAttr;
            pDstValue->cbData = cchAttr * sizeof(WCHAR);
            break;
        case CERT_RDN_UNIVERSAL_STRING:
            // Update the "low" 16 bits of each 32 bit integer with
            // the UNICODE character. Also handle surrogate pairs.
            {
                DWORD cdw = cchAttr;
                DWORD cbData = cdw * sizeof(DWORD);
                DWORD *pdwDst;
                LPCWSTR pwszSrc = pwszAttr;

                if (NULL == (pdwDst = (DWORD *) PkiNonzeroAlloc(cbData)))
                    goto OutOfMemory;
                pDstValue->pbData = (BYTE *) pdwDst;
                for ( ; cdw > 0; cdw--) {
                    WCHAR wc = *pwszSrc++;
                    WCHAR wc2;

                    if (wc >= UNICODE_HIGH_SURROGATE_START &&
                            wc <= UNICODE_HIGH_SURROGATE_END
                                &&
                            cdw > 1
                                 &&
                            (wc2 = *pwszSrc) >= UNICODE_LOW_SURROGATE_START &&
                            wc2 <= UNICODE_LOW_SURROGATE_END) {
                        pwszSrc++;
                        cdw--;
                        cbData -= sizeof(DWORD);

                        *pdwDst++ =
                            (((DWORD)(wc - UNICODE_HIGH_SURROGATE_START)) << 10)
                                    +
                            ((DWORD)(wc2 - UNICODE_LOW_SURROGATE_START))
                                    +
                            UNIVERSAL_SURROGATE_START;
                    } else
                        *pdwDst++ = ((DWORD) wc) & 0xFFFF;
                }
                pDstValue->cbData = cbData;
            }
            break;
        default:
            // Convert each unicode character to 8 Bit character
            {
                BYTE *pbDst;

                if (pdwErrLocation && !fDisableCheckType) {
                    // Check that the unicode string doesn't contain any
                    // invalid dwValueType characters.
                    if (0 != (dwErr = CheckUnicodeValueType(
                            dwValueType,
                            pwszAttr,
                            cchAttr,
                            pdwErrLocation
                            ))) goto InvalidUnicodeValueType;
                }

                if (NULL == (pbDst = (BYTE *) PkiNonzeroAlloc(cchAttr)))
                    goto OutOfMemory;
                pDstValue->pbData = pbDst;
                pDstValue->cbData = cchAttr;

                WideCharToAsn1(
                    pwszAttr,
                    cchAttr,
                    (LPSTR) pbDst
                    );
            }
        }
    }

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR_VAR(InvalidUnicodeValueType, dwErr)
TRACE_ERROR(OutOfMemory)
}

static void FreeUnicodeRDNAttributeValue(
        IN DWORD dwValueType,
        IN OUT PCERT_RDN_VALUE_BLOB pValue
        )
{
    switch (dwValueType & CERT_RDN_TYPE_MASK) {
    case CERT_RDN_UNICODE_STRING:
    case CERT_RDN_UTF8_STRING:
    case CERT_RDN_ENCODED_BLOB:
    case CERT_RDN_OCTET_STRING:
        break;
    default:
        PkiFree(pValue->pbData);
    }
}

static BOOL GetUnicodeRDNAttributeValue(
        IN DWORD dwValueType,
        IN PCERT_RDN_VALUE_BLOB pSrcValue,
        IN DWORD dwFlags,
        OUT PCERT_RDN_VALUE_BLOB pDstValue,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    DWORD cbData;
    BYTE *pbSrcData;
    BOOL fDisableIE4UTF8;

    // Get Unicode value length
    cbData = pSrcValue->cbData;
    pbSrcData = pSrcValue->pbData;

    fDisableIE4UTF8 =
        (0 != (dwFlags & CRYPT_UNICODE_NAME_DECODE_DISABLE_IE4_UTF8_FLAG));

    assert(0 == (dwValueType & ~CERT_RDN_TYPE_MASK));
    dwValueType &= CERT_RDN_TYPE_MASK;

    switch (dwValueType) {
    case CERT_RDN_UNICODE_STRING:
    case CERT_RDN_UTF8_STRING:
    case CERT_RDN_ENCODED_BLOB:
    case CERT_RDN_OCTET_STRING:
        // The above cbData
        break;
    case CERT_RDN_UNIVERSAL_STRING:
        // 4 byte string. Characters < 0x10000 are converted directly to
        // Unicode. Characters within 0x10000 .. 0x10FFFF are mapped
        // to surrogate pair. Any character > 0x10FFFF is mapped to
        // the replacement character, 0xFFFD.
        cbData = (cbData / 4) * sizeof(WCHAR);
        cbData += GetSurrogatePairCountFromUniversalString(
                (DWORD *) pbSrcData,
                cbData / sizeof(WCHAR)) * sizeof(WCHAR);
        break;
    default:
        // Length of resultant WideChar
        if (cbData) {
            int cchWideChar;

            if (dwValueType != CERT_RDN_T61_STRING)
                fDisableIE4UTF8 = TRUE;
            cchWideChar = Asn1ToWideChar(
                (LPSTR) pbSrcData,
                cbData,
                fDisableIE4UTF8,
                NULL,                   // lpWideCharStr
                0                       // cchWideChar
                );
            if (cchWideChar <= 0)
                goto Asn1ToWideCharError;
            cbData = cchWideChar * sizeof(WCHAR);
        }
    }

    // Note, +sizeof(WCHAR) is unicode value's NULL terminator
    lAlignExtra = INFO_LEN_ALIGN(cbData + sizeof(WCHAR));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        pDstValue->pbData = pbExtra;
        pDstValue->cbData = cbData;

        switch (dwValueType) {
        case CERT_RDN_UNICODE_STRING:
        case CERT_RDN_UTF8_STRING:
        case CERT_RDN_ENCODED_BLOB:
        case CERT_RDN_OCTET_STRING:
            if (cbData)
                memcpy(pbExtra, pbSrcData, cbData);
            break;
        case CERT_RDN_UNIVERSAL_STRING:
            // Convert Universal to Unicode. See above comments.
            {
                DWORD cdw = pSrcValue->cbData / sizeof (DWORD);
                DWORD *pdwSrc = (DWORD *) pbSrcData;
                LPWSTR pwszDst = (LPWSTR) pbExtra;
                for ( ; cdw > 0; cdw--) {
                    DWORD dw = *pdwSrc++;

                    if (dw < UNIVERSAL_SURROGATE_START)
                        *pwszDst++ = (WCHAR) dw;
                    else if (dw <= UNIVERSAL_SURROGATE_END) {
                        // Surrogate pair contains 20 bits.
                        DWORD dw20Bits;
    
                        dw20Bits = dw - UNIVERSAL_SURROGATE_START;
                        assert(dw20Bits <= 0xFFFFF);
                        *pwszDst++ = (WCHAR) (UNICODE_HIGH_SURROGATE_START +
                            (dw20Bits >> 10));
                        *pwszDst++ = (WCHAR) (UNICODE_LOW_SURROGATE_START +
                            (dw20Bits & 0x3FF));
                    } else
                        *pwszDst++ = UNICODE_REPLACEMENT_CHAR;
                }

                assert(pbExtra + cbData == (BYTE *) pwszDst);
            }
            break;
        default:
            // Convert UTF8 to unicode
            if (cbData) {
                int cchWideChar;
                cchWideChar = Asn1ToWideChar(
                    (LPSTR) pbSrcData,
                    pSrcValue->cbData,
                    fDisableIE4UTF8,
                    (LPWSTR) pbExtra,
                    cbData / sizeof(WCHAR)
                    );
                if (cchWideChar > 0) {
                    if (((DWORD) cchWideChar * sizeof(WCHAR)) <= cbData) {
                        pDstValue->cbData = cchWideChar * sizeof(WCHAR);
                        *((LPWSTR) pbExtra + cchWideChar) = L'\0';
                    }
                 } else {
                    assert(0);
                    goto Asn1ToWideCharError;
                }
            }
        }
        // Ensure NULL termination
        memset(pbExtra + cbData, 0, sizeof(WCHAR));
        pbExtra += lAlignExtra;
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(Asn1ToWideCharError)
}

//+-------------------------------------------------------------------------
//  Encode the "UNICODE" Name Value
//--------------------------------------------------------------------------
BOOL WINAPI UnicodeNameValueEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_NAME_VALUE pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DWORD dwValueType;
    CERT_NAME_VALUE DstInfo;
    DWORD dwErrLocation;
    BOOL fDisableCheckType;

    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;

    dwValueType = pInfo->dwValueType;
    if (!IS_CERT_RDN_CHAR_STRING(dwValueType)) {
        *pcbEncoded = 0;
        SetLastError((DWORD) CRYPT_E_NOT_CHAR_STRING);
        return FALSE;
    }

    DstInfo.dwValueType = dwValueType & CERT_RDN_TYPE_MASK;
    fDisableCheckType =
        (0 != (dwFlags & CRYPT_UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG) ||
                0 != (dwValueType & CERT_RDN_DISABLE_CHECK_TYPE_FLAG));
    if (!SetUnicodeRDNAttributeValue(dwValueType, &pInfo->Value,
            fDisableCheckType, &DstInfo.Value, &dwErrLocation)) {
        fResult = FALSE;
        *pcbEncoded = dwErrLocation;
        goto CommonReturn;
    }

    fResult = CryptEncodeObjectEx(
        dwCertEncodingType,
        X509_NAME_VALUE,
        &DstInfo,
        dwFlags & ~CRYPT_UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

CommonReturn:
    FreeUnicodeRDNAttributeValue(dwValueType, &DstInfo.Value);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode the "UNICODE" Name Value
//--------------------------------------------------------------------------
BOOL WINAPI UnicodeNameValueDecodeExCallback(
        IN void *pvDecodeInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    PCERT_NAME_VALUE pNameValue = (PCERT_NAME_VALUE) pvDecodeInfo;
    PCERT_NAME_VALUE pInfo = (PCERT_NAME_VALUE) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    PCERT_RDN_VALUE_BLOB pValue;

    if (!IS_CERT_RDN_CHAR_STRING(pNameValue->dwValueType))
        goto NotCharString;

    lRemainExtra -= sizeof(CERT_NAME_VALUE);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
        pValue = NULL;
    } else {
        pbExtra = (BYTE *) pInfo + sizeof(CERT_NAME_VALUE);
        pInfo->dwValueType = pNameValue->dwValueType;
        pValue = &pInfo->Value;
    }

    if (!GetUnicodeRDNAttributeValue(
            pNameValue->dwValueType,
            &pNameValue->Value,
            dwFlags,
            pValue,
            &pbExtra,
            &lRemainExtra
            )) goto DecodeError;

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(NotCharString, CRYPT_E_NOT_CHAR_STRING)
TRACE_ERROR(DecodeError)
}

BOOL WINAPI UnicodeNameValueDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return NestedDecodeAndAllocInfoEx(
        dwCertEncodingType,
        X509_NAME_VALUE,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        UnicodeNameValueDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Default ordered list of acceptable RDN attribute value types. Used when
//  OIDInfo's ExtraInfo.cbData == 0. Or when ExtraInfo contains an empty
//  list.
//--------------------------------------------------------------------------
static const DWORD rgdwDefaultValueType[] = {
    CERT_RDN_PRINTABLE_STRING,
    CERT_RDN_UNICODE_STRING,
    0
};

//+-------------------------------------------------------------------------
//  Default X500 OID Information entry
//--------------------------------------------------------------------------
static CCRYPT_OID_INFO DefaultX500Info = {
    sizeof(CCRYPT_OID_INFO),            // cbSize
    "",                                 // pszOID
    L"",                                // pwszName
    0,                                  // dwLength
    0, NULL                             // ExtraInfo
};

// Please update the following if you add a new entry to the RDNAttrTable in
// oidinfo.cpp with a longer pwszName
#define MAX_X500_KEY_LEN    64

//+-------------------------------------------------------------------------
//  Checks if character needs to be quoted
//
//  Defined in RFC1779
//--------------------------------------------------------------------------
static inline BOOL IsQuotedW(WCHAR wc)
{
    return IsInStrW(L",+=\"\n<>#;", wc);
}

//+-------------------------------------------------------------------------
//  Checks if "decoded" unicode RDN value needs to be quoted
//--------------------------------------------------------------------------
static BOOL IsQuotedUnicodeRDNValue(PCERT_RDN_VALUE_BLOB pValue)
{
    LPCWSTR pwszValue = (LPCWSTR) pValue->pbData;
    DWORD cchValue = pValue->cbData / sizeof(WCHAR);
    if (0 == cchValue)
        return TRUE;

    // First or Last character is whitespace
    if (IsSpaceW(pwszValue[0]) || IsSpaceW(pwszValue[cchValue - 1]))
        return TRUE;

    for ( ; cchValue > 0; cchValue--, pwszValue++)
        if (IsQuotedW(*pwszValue))
            return TRUE;
    return FALSE;
}


//+-------------------------------------------------------------------------
//  Get the first dwValueType from the attribute's ordered list that is
//  an acceptable type for the input attribute character string.
//
//  If no type is acceptable, update the *pdwErrLocation with the first
//  bad character position using the last type in the list.
//--------------------------------------------------------------------------
static DWORD GetUnicodeValueType(
        IN PCCRYPT_OID_INFO pX500Info,
        IN LPCWSTR pwszAttr,
        IN DWORD cchAttr,
        IN DWORD dwUnicodeFlags,
        OUT DWORD *pdwErrLocation
        )
{
    DWORD dwValueType;
    const DWORD *pdwValueType;
    DWORD cValueType;
    DWORD dwErr = (DWORD) E_UNEXPECTED;
    DWORD i;

    pdwValueType = (DWORD *) pX500Info->ExtraInfo.pbData;
    cValueType = pX500Info->ExtraInfo.cbData / sizeof(DWORD);
    // Need at least two entries: a dwValueType and a 0 terminator. Otherwise,
    // use default value types.
    if (2 > cValueType || 0 == pdwValueType[0]) {
        pdwValueType = rgdwDefaultValueType;
        cValueType = sizeof(rgdwDefaultValueType) / sizeof(DWORD);
    }

    *pdwErrLocation = 0;
    for (i = 0; i < cValueType && 0 != (dwValueType = pdwValueType[i]); i++) {
        if (CERT_RDN_UNICODE_STRING == dwValueType) {
            if (dwUnicodeFlags & CERT_RDN_ENABLE_T61_UNICODE_FLAG) {
                DWORD j;
                BOOL fT61;

                fT61 = TRUE;
                for (j = 0; j < cchAttr; j++) {
                    if (pwszAttr[j] > 0xFF) {
                        fT61 = FALSE;
                        break;
                    }
                }
                if (fT61)
                    return CERT_RDN_T61_STRING;
            }

            if (dwUnicodeFlags & CERT_RDN_ENABLE_UTF8_UNICODE_FLAG)
                return CERT_RDN_UTF8_STRING;
            else
                return CERT_RDN_UNICODE_STRING;
           
        }
        dwErr = CheckUnicodeValueType(
            dwValueType,
            pwszAttr,
            cchAttr,
            pdwErrLocation
            );

        if (0 == dwErr)
            return dwValueType;
    }

    assert(dwErr);
    SetLastError(dwErr);

    return 0;
}


//+-------------------------------------------------------------------------
//  Get an acceptable dwValueType associated with the OID for the input
//  attribute character string.
//
//  If no type is acceptable, update the *pdwErrLocation with the indices
//  of the RDN, RDNAttribute, and character string.
//--------------------------------------------------------------------------
static DWORD GetUnicodeX500OIDValueType(
        IN LPCSTR pszObjId,
        IN LPCWSTR pwszAttr,
        IN DWORD cchAttr,
        IN DWORD dwRDNIndex,
        IN DWORD dwAttrIndex,
        IN DWORD dwUnicodeFlags,
        OUT DWORD *pdwErrLocation
        )
{
    PCCRYPT_OID_INFO pX500Info;
    DWORD dwValueType;

    assert(pszObjId);
    if (NULL == pszObjId)
        pszObjId = "";

    // Attempt to find the OID in the table. If OID isn't found,
    // use default
    if (NULL == (pX500Info = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            (void *) pszObjId,
            CRYPT_RDN_ATTR_OID_GROUP_ID
            )))
        pX500Info = &DefaultX500Info;

    if (0 == (dwValueType = GetUnicodeValueType(
            pX500Info,
            pwszAttr,
            cchAttr,
            dwUnicodeFlags,
            pdwErrLocation
            ))) {
        // Include the dwRDNIndex and dwAttrIndex in the error location.
        assert(dwRDNIndex <= CERT_UNICODE_RDN_ERR_INDEX_MASK);
        assert(dwAttrIndex <= CERT_UNICODE_ATTR_ERR_INDEX_MASK);
        *pdwErrLocation |=
            ((dwRDNIndex & CERT_UNICODE_RDN_ERR_INDEX_MASK) <<
                CERT_UNICODE_RDN_ERR_INDEX_SHIFT) |
            ((dwAttrIndex & CERT_UNICODE_ATTR_ERR_INDEX_MASK) <<
                CERT_UNICODE_ATTR_ERR_INDEX_SHIFT);
    }
    return dwValueType;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CERT_RDN_ATTR. The values are unicode.
//--------------------------------------------------------------------------
static BOOL SetUnicodeRDNAttribute(
        IN PCERT_RDN_ATTR pSrcRDNAttr,
        IN DWORD dwRDNIndex,
        IN DWORD dwAttrIndex,
        IN DWORD dwFlags,
        IN OUT PCERT_RDN_ATTR pDstRDNAttr,
        OUT DWORD *pdwErrLocation
        )
{
    BOOL fResult;
    DWORD dwValueType = pSrcRDNAttr->dwValueType;
    PCERT_RDN_VALUE_BLOB pSrcValue;
    LPCWSTR pwszAttr;
    DWORD cchAttr;
    DWORD dwErr;

    DWORD dwUnicodeFlags;
    BOOL fDisableCheckType;

    dwUnicodeFlags = 0;
    if ((dwFlags & CRYPT_UNICODE_NAME_ENCODE_ENABLE_T61_UNICODE_FLAG) ||
            (dwValueType & CERT_RDN_ENABLE_T61_UNICODE_FLAG))
        dwUnicodeFlags |= CERT_RDN_ENABLE_T61_UNICODE_FLAG;
    if ((dwFlags & CRYPT_UNICODE_NAME_ENCODE_ENABLE_UTF8_UNICODE_FLAG) ||
            (dwValueType & CERT_RDN_ENABLE_UTF8_UNICODE_FLAG))
        dwUnicodeFlags |= CERT_RDN_ENABLE_UTF8_UNICODE_FLAG;

    fDisableCheckType =
        (0 != (dwFlags & CRYPT_UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG) ||
                0 != (dwValueType & CERT_RDN_DISABLE_CHECK_TYPE_FLAG));

    dwValueType &= CERT_RDN_TYPE_MASK;

    *pdwErrLocation = 0;
    if (CERT_RDN_ENCODED_BLOB == dwValueType ||
            CERT_RDN_OCTET_STRING == dwValueType) {
        // No unicode conversion on this type
        memcpy(pDstRDNAttr, pSrcRDNAttr, sizeof(CERT_RDN_ATTR));
        return TRUE;
    }

    pSrcValue = &pSrcRDNAttr->Value;
    pwszAttr = pSrcValue->pbData ? (LPCWSTR) pSrcValue->pbData : L"";
    cchAttr = (DWORD)( pSrcValue->cbData ?
        pSrcValue->cbData / sizeof(WCHAR) : wcslen(pwszAttr) );

    if (0 == dwValueType) {
        if (0 == (dwValueType = GetUnicodeX500OIDValueType(
                pSrcRDNAttr->pszObjId,
                pwszAttr,
                cchAttr,
                dwRDNIndex,
                dwAttrIndex,
                dwUnicodeFlags,
                pdwErrLocation
                ))) goto GetValueTypeError;
    } else if (!fDisableCheckType) {
        if (0 != (dwErr = CheckUnicodeValueType(
                dwValueType,
                pwszAttr,
                cchAttr,
                pdwErrLocation
                ))) {
            // Include the dwRDNIndex and dwAttrIndex in the error location.
            assert(dwRDNIndex <= CERT_UNICODE_RDN_ERR_INDEX_MASK);
            assert(dwAttrIndex <= CERT_UNICODE_ATTR_ERR_INDEX_MASK);
            *pdwErrLocation |=
                ((dwRDNIndex & CERT_UNICODE_RDN_ERR_INDEX_MASK) <<
                    CERT_UNICODE_RDN_ERR_INDEX_SHIFT) |
                ((dwAttrIndex & CERT_UNICODE_ATTR_ERR_INDEX_MASK) <<
                    CERT_UNICODE_ATTR_ERR_INDEX_SHIFT);
            goto InvalidUnicodeValueType;
        }
    }

    pDstRDNAttr->pszObjId = pSrcRDNAttr->pszObjId;
    pDstRDNAttr->dwValueType = dwValueType;

    if (!SetUnicodeRDNAttributeValue(
            dwValueType,
            pSrcValue,
            TRUE,                   // fDisableCheckType
            &pDstRDNAttr->Value,
            NULL                    // OPTIONAL pdwErrLocation
            )) goto SetUnicodeRDNAttributeValueError;

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetValueTypeError)
SET_ERROR_VAR(InvalidUnicodeValueType, dwErr)
TRACE_ERROR(SetUnicodeRDNAttributeValueError)
}

static void FreeUnicodeRDNAttribute(
        IN OUT PCERT_RDN_ATTR pRDNAttr
        )
{
    FreeUnicodeRDNAttributeValue(pRDNAttr->dwValueType, &pRDNAttr->Value);
}

static BOOL GetUnicodeRDNAttribute(
        IN PCERT_RDN_ATTR pSrcRDNAttr,
        IN DWORD dwFlags,
        OUT PCERT_RDN_ATTR pDstRDNAttr,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lAlignExtra;
    DWORD cbObjId;
    DWORD dwValueType;
    PCERT_RDN_VALUE_BLOB pDstValue;

    // Get Object Identifier length
    if (pSrcRDNAttr->pszObjId)
        cbObjId = strlen(pSrcRDNAttr->pszObjId) + 1;
    else
        cbObjId = 0;

    dwValueType = pSrcRDNAttr->dwValueType;

    lAlignExtra = INFO_LEN_ALIGN(cbObjId);
    *plRemainExtra -= lAlignExtra;
    if (*plRemainExtra >= 0) {
        if(cbObjId) {
            pDstRDNAttr->pszObjId = (LPSTR) *ppbExtra;
            memcpy(*ppbExtra, pSrcRDNAttr->pszObjId, cbObjId);
        } else
            pDstRDNAttr->pszObjId = NULL;
        *ppbExtra += lAlignExtra;

        pDstRDNAttr->dwValueType = dwValueType;
        pDstValue = &pDstRDNAttr->Value;
    } else
        pDstValue = NULL;

    return GetUnicodeRDNAttributeValue(
        dwValueType,
        &pSrcRDNAttr->Value,
        dwFlags,
        pDstValue,
        ppbExtra,
        plRemainExtra
        );
}

//+-------------------------------------------------------------------------
//  Decode the "UNICODE" Name Info
//--------------------------------------------------------------------------
BOOL WINAPI UnicodeNameInfoDecodeExCallback(
        IN void *pvDecodeInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    PCERT_NAME_INFO pNameInfo = (PCERT_NAME_INFO) pvDecodeInfo;
    PCERT_NAME_INFO pInfo = (PCERT_NAME_INFO) pvStructInfo;
    BYTE *pbExtra;
    LONG lRemainExtra = *plRemainExtra;
    LONG lAlignExtra;

    DWORD cRDN, cAttr;
    PCERT_RDN pSrcRDN, pDstRDN;
    PCERT_RDN_ATTR pSrcAttr, pDstAttr;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra -= sizeof(CERT_NAME_INFO);
    if (lRemainExtra < 0)
        pbExtra = NULL;
    else
        pbExtra = (BYTE *) pInfo + sizeof(CERT_NAME_INFO);

    cRDN = pNameInfo->cRDN;
    pSrcRDN = pNameInfo->rgRDN;
    lAlignExtra = INFO_LEN_ALIGN(cRDN * sizeof(CERT_RDN));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        pInfo->cRDN = cRDN;
        pDstRDN = (PCERT_RDN) pbExtra;
        pInfo->rgRDN = pDstRDN;
        pbExtra += lAlignExtra;
    } else
        pDstRDN = NULL;

    // Array of RDNs
    for (; cRDN > 0; cRDN--, pSrcRDN++, pDstRDN++) {
        cAttr = pSrcRDN->cRDNAttr;
        pSrcAttr = pSrcRDN->rgRDNAttr;
        lAlignExtra = INFO_LEN_ALIGN(cAttr * sizeof(CERT_RDN_ATTR));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            pDstRDN->cRDNAttr = cAttr;
            pDstAttr = (PCERT_RDN_ATTR) pbExtra;
            pDstRDN->rgRDNAttr = pDstAttr;
            pbExtra += lAlignExtra;
        } else
            pDstAttr = NULL;

        // Array of attribute/values
        for (; cAttr > 0; cAttr--, pSrcAttr++, pDstAttr++)
            // We're now ready to get the attribute/value stuff
            if (!GetUnicodeRDNAttribute(pSrcAttr, dwFlags,
                    pDstAttr, &pbExtra, &lRemainExtra))
                goto DecodeError;
    }

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(DecodeError)
}

BOOL WINAPI UnicodeNameInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return NestedDecodeAndAllocInfoEx(
        dwCertEncodingType,
        X509_NAME,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        UnicodeNameInfoDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}



//+-------------------------------------------------------------------------
//  Encode the "UNICODE" Name Info
//--------------------------------------------------------------------------
static void FreeUnicodeNameInfo(
        PCERT_NAME_INFO pInfo
        )
{
    PCERT_RDN pRDN = pInfo->rgRDN;
    if (pRDN) {
        DWORD cRDN = pInfo->cRDN;
        for ( ; cRDN > 0; cRDN--, pRDN++) {
            PCERT_RDN_ATTR pAttr = pRDN->rgRDNAttr;
            if (pAttr) {
                DWORD cAttr = pRDN->cRDNAttr;
                for ( ; cAttr > 0; cAttr--, pAttr++)
                    FreeUnicodeRDNAttribute(pAttr);
                PkiFree(pRDN->rgRDNAttr);
            }
        }
        PkiFree(pInfo->rgRDN);
    }
}

static BOOL SetUnicodeNameInfo(
        IN PCERT_NAME_INFO pSrcInfo,
        IN DWORD dwFlags,
        OUT PCERT_NAME_INFO pDstInfo,
        OUT DWORD *pdwErrLocation
        )
{
    BOOL fResult;
    DWORD cRDN, cAttr;
    DWORD i, j;
    PCERT_RDN pSrcRDN;
    PCERT_RDN_ATTR pSrcAttr;
    PCERT_RDN pDstRDN = NULL;
    PCERT_RDN_ATTR pDstAttr = NULL;

    *pdwErrLocation = 0;

    cRDN = pSrcInfo->cRDN;
    pSrcRDN = pSrcInfo->rgRDN;
    pDstInfo->cRDN = cRDN;
    pDstInfo->rgRDN = NULL;
    if (cRDN > 0) {
        if (NULL == (pDstRDN = (PCERT_RDN) PkiZeroAlloc(
                cRDN * sizeof(CERT_RDN))))
            goto OutOfMemory;
        pDstInfo->rgRDN = pDstRDN;
    }

    // Array of RDNs
    for (i = 0; i < cRDN; i++, pSrcRDN++, pDstRDN++) {
        cAttr = pSrcRDN->cRDNAttr;
        pSrcAttr = pSrcRDN->rgRDNAttr;
        pDstRDN->cRDNAttr = cAttr;

        if (cAttr > 0) {
            if (NULL == (pDstAttr = (PCERT_RDN_ATTR) PkiZeroAlloc(cAttr *
                    sizeof(CERT_RDN_ATTR))))
                goto OutOfMemory;
            pDstRDN->rgRDNAttr = pDstAttr;
        }

        // Array of attribute/values
        for (j = 0; j < cAttr; j++, pSrcAttr++, pDstAttr++) {
            // We're now ready to convert the unicode string
            if (!SetUnicodeRDNAttribute(pSrcAttr, i, j, dwFlags, pDstAttr,
                    pdwErrLocation))
                goto SetUnicodeRDNAttributeError;
        }
    }

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(SetUnicodeRDNAttributeError)
}

BOOL WINAPI UnicodeNameInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_NAME_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CERT_NAME_INFO DstInfo;
    DWORD dwErrLocation;
    if (!SetUnicodeNameInfo(pInfo, dwFlags, &DstInfo, &dwErrLocation)) {
        if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
            *((void **) pvEncoded) = NULL;
        *pcbEncoded = dwErrLocation;
        fResult = FALSE;
        goto CommonReturn;
    }

    fResult = CryptEncodeObjectEx(
        dwCertEncodingType,
        X509_NAME,
        &DstInfo,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

CommonReturn:
    FreeUnicodeNameInfo(&DstInfo);
    return fResult;
}

static BOOL WINAPI UnicodeNameInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_NAME_INFO pInfo,
        OUT OPTIONAL BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CERT_NAME_INFO DstInfo;
    DWORD dwErrLocation;
    if (!SetUnicodeNameInfo(pInfo, 0, &DstInfo, &dwErrLocation)) {
        *pcbEncoded = dwErrLocation;
        fResult = FALSE;
        goto CommonReturn;
    }

    fResult = CryptEncodeObject(
        dwCertEncodingType,
        X509_NAME,
        &DstInfo,
        pbEncoded,
        pcbEncoded
        );

CommonReturn:
    FreeUnicodeNameInfo(&DstInfo);
    return fResult;
}


static void PutStrW(LPCWSTR pwszPut, LPWSTR *ppwsz, DWORD *pcwsz,
        DWORD *pcwszOut, BOOL fQuote = FALSE)
{
    WCHAR wc;
    while (wc = *pwszPut++) {
        if (L'\"' == wc && fQuote)
            PutStrW(L"\"", ppwsz, pcwsz, pcwszOut, FALSE);
        if (*pcwsz != 1) {
            if (*pcwsz) {
                **ppwsz = wc;
                *ppwsz += 1;
                *pcwsz -= 1;
            }
            *pcwszOut += 1;
        }
        // else
        //  Always reserve space for the NULL terminator.
    }
}

static void PutOIDStrW(
    IN DWORD dwStrType,
    IN LPCSTR pszObjId,
    IN OUT LPWSTR *ppwsz,
    IN OUT DWORD *pcwsz,
    IN OUT DWORD *pcwszOut
    )
{
    // Eliminate the upper flags before switching
    switch (dwStrType & 0xFFFF) {
        case CERT_X500_NAME_STR:
            {
                PCCRYPT_OID_INFO pX500Info;
                if (pX500Info = CryptFindOIDInfo(
                        CRYPT_OID_INFO_OID_KEY,
                        (void *) pszObjId,
                        CRYPT_RDN_ATTR_OID_GROUP_ID
                        )) {
                    if (*pX500Info->pwszName) {
                            PutStrW(pX500Info->pwszName, ppwsz, pcwsz,
                                pcwszOut);
                            PutStrW(L"=", ppwsz, pcwsz, pcwszOut);
                            return;
                    }
                }
                PutStrW(L"OID.", ppwsz, pcwsz, pcwszOut);
            }
            // Fall through
        case CERT_OID_NAME_STR:
            {
                int cchWideChar;
                cchWideChar = MultiByteToWideChar(
                    CP_ACP,
                    0,                      // dwFlags
                    pszObjId,
                    -1,                     // null terminated
                    *ppwsz,
                    *pcwsz) - 1;
                if (cchWideChar > 0) {
                    if (*pcwsz) {
                        assert(*pcwsz > (DWORD)cchWideChar);
                        *pcwsz -= cchWideChar;
                        *ppwsz += cchWideChar;
                    }
                    *pcwszOut += cchWideChar;
                }
                PutStrW(L"=", ppwsz, pcwsz, pcwszOut);
            }
            break;
        case CERT_SIMPLE_NAME_STR:
        default:
            break;
    }
}

static void PutHexW(
    IN PCERT_RDN_VALUE_BLOB pValue,
    IN OUT LPWSTR *ppwsz,
    IN OUT DWORD *pcwsz,
    IN OUT DWORD *pcwszOut
    )
{
    WCHAR wszHex[3];
    BYTE *pb = pValue->pbData;
    DWORD cb = pValue->cbData;

    PutStrW(L"#", ppwsz, pcwsz, pcwszOut);
    wszHex[2] = L'\0';

    for ( ; cb > 0; cb--, pb++) {
        int b;
        b = (*pb >> 4) & 0x0F;
        wszHex[0] = (WCHAR)( (b <= 9) ? b + L'0' : (b - 10) + L'A');
        b = *pb & 0x0F;
        wszHex[1] = (WCHAR)( (b <= 9) ? b + L'0' : (b - 10) + L'A');
        PutStrW(wszHex, ppwsz, pcwsz, pcwszOut);
    }
}

static void ReverseNameInfo(
    IN PCERT_NAME_INFO pInfo
    )
{
    DWORD cRDN;
    PCERT_RDN pLo;
    PCERT_RDN pHi;
    CERT_RDN Tmp;

    cRDN = pInfo->cRDN;
    if (0 == cRDN)
        return;

    pLo = pInfo->rgRDN;
    pHi = pInfo->rgRDN + cRDN - 1;
    for ( ; pLo < pHi; pHi--, pLo++) {
        Tmp = *pHi;
        *pHi = *pLo;
        *pLo = Tmp;
    }
}

//+-------------------------------------------------------------------------
//  Convert the decoded certificate name info to a null terminated WCHAR
//  string.
//
//  Note, if CERT_NAME_STR_REVERSE_FLAG is set, reverses the decoded
//  name info RDNs
//--------------------------------------------------------------------------
static DWORD WINAPI CertNameInfoToStrW(
    IN DWORD dwCertEncodingType,
    IN PCERT_NAME_INFO pInfo,
    IN DWORD dwStrType,
    OUT OPTIONAL LPWSTR pwsz,
    IN DWORD cwsz
    )
{
    DWORD cwszOut = 0;

    LPCWSTR pwszRDNSeparator;
    LPCWSTR pwszMultiValueSeparator;
    BOOL fEnableQuoting;

    if (dwStrType & CERT_NAME_STR_SEMICOLON_FLAG)
        pwszRDNSeparator = L"; ";
    else if (dwStrType & CERT_NAME_STR_CRLF_FLAG)
        pwszRDNSeparator = L"\r\n";
    else
        pwszRDNSeparator = L", ";

    if (dwStrType & CERT_NAME_STR_NO_PLUS_FLAG)
        pwszMultiValueSeparator = L" ";
    else
        pwszMultiValueSeparator = L" + ";

    if (dwStrType & CERT_NAME_STR_NO_QUOTING_FLAG)
        fEnableQuoting = FALSE;
    else
        fEnableQuoting = TRUE;

    if (pwsz == NULL)
        cwsz = 0;

    if (pInfo) {
        DWORD cRDN;
        PCERT_RDN pRDN;

        if (dwStrType & CERT_NAME_STR_REVERSE_FLAG)
            ReverseNameInfo(pInfo);

        cRDN = pInfo->cRDN;
        pRDN = pInfo->rgRDN;
        if (0 == cRDN)
            SetLastError((DWORD) CRYPT_E_NOT_FOUND);
        for ( ; cRDN > 0; cRDN--, pRDN++) {
            DWORD cAttr = pRDN->cRDNAttr;
            PCERT_RDN_ATTR pAttr = pRDN->rgRDNAttr;
            for ( ; cAttr > 0; cAttr--, pAttr++) {
                BOOL fQuote;
                PutOIDStrW(dwStrType, pAttr->pszObjId, &pwsz, &cwsz, &cwszOut);

                if (CERT_RDN_ENCODED_BLOB == pAttr->dwValueType ||
                        CERT_RDN_OCTET_STRING == pAttr->dwValueType)
                    PutHexW(&pAttr->Value, &pwsz, &cwsz, &cwszOut);
                else {
                    fQuote = fEnableQuoting && IsQuotedUnicodeRDNValue(
                        &pAttr->Value);
                    if (fQuote)
                        PutStrW(L"\"", &pwsz, &cwsz, &cwszOut);
                    PutStrW((LPCWSTR) pAttr->Value.pbData, &pwsz, &cwsz,
                        &cwszOut, fQuote);
                    if (fQuote)
                        PutStrW(L"\"", &pwsz, &cwsz, &cwszOut);
                }

                if (cAttr > 1)
                    PutStrW(pwszMultiValueSeparator, &pwsz, &cwsz, &cwszOut);
            }
            if (cRDN > 1)
                PutStrW(pwszRDNSeparator, &pwsz, &cwsz, &cwszOut);
        }
    }

    if (cwsz != 0) {
        // Always NULL terminate
        *pwsz = L'\0';
    }

    return cwszOut + 1;
}

//+-------------------------------------------------------------------------
//  Convert the certificate name blob to a null terminated WCHAR string.
//--------------------------------------------------------------------------
DWORD
WINAPI
CertNameToStrW(
    IN DWORD dwCertEncodingType,
    IN PCERT_NAME_BLOB pName,
    IN DWORD dwStrType,
    OUT OPTIONAL LPWSTR pwsz,
    IN DWORD cwsz
    )
{
    DWORD cwszOut;
    PCERT_NAME_INFO pInfo;
    pInfo = (PCERT_NAME_INFO) AllocAndDecodeObject(
        dwCertEncodingType,
        X509_UNICODE_NAME,
        pName->pbData,
        pName->cbData,
        (dwStrType & CERT_NAME_STR_DISABLE_IE4_UTF8_FLAG) ?
            CRYPT_UNICODE_NAME_DECODE_DISABLE_IE4_UTF8_FLAG : 0
        );

    // Note, decoded name info RDNs may be reversed
    cwszOut = CertNameInfoToStrW(
        dwCertEncodingType,
        pInfo,
        dwStrType,
        pwsz,
        cwsz
        );

    PkiFree(pInfo);
    return cwszOut;
}

//+-------------------------------------------------------------------------
//  Convert the Unicode string to Ascii
//--------------------------------------------------------------------------
static DWORD ConvertUnicodeStringToAscii(
    IN LPWSTR pwsz,
    IN DWORD cwsz,
    OUT OPTIONAL LPSTR psz,
    IN DWORD csz
    )
{
    DWORD cszOut = 0;

    if (psz == NULL)
        csz = 0;

    if (pwsz) {
        int cchMultiByte;
        cchMultiByte = WideCharToMultiByte(
            CP_ACP,
            0,                      // dwFlags
            pwsz,
            -1,                     // Null terminated
            psz,
            (int) csz,
            NULL,                   // lpDefaultChar
            NULL                    // lpfUsedDefaultChar
            );
        if (cchMultiByte < 1)
            cszOut = 0;
        else
            // Subtract off the trailing null terminator
            cszOut = (DWORD) cchMultiByte - 1;
    }

    if (csz != 0) {
        // Always NULL terminate
        *(psz + cszOut) = '\0';
    }
    return cszOut + 1;
}

//+-------------------------------------------------------------------------
//  Convert the certificate name blob to a null terminated char string.
//--------------------------------------------------------------------------
DWORD
WINAPI
CertNameToStrA(
    IN DWORD dwCertEncodingType,
    IN PCERT_NAME_BLOB pName,
    IN DWORD dwStrType,
    OUT OPTIONAL LPSTR psz,
    IN DWORD csz
    )
{
    DWORD cszOut;
    LPWSTR pwsz = NULL;
    DWORD cwsz;

    cwsz = CertNameToStrW(
        dwCertEncodingType,
        pName,
        dwStrType,
        NULL,                   // pwsz
        0                       // cwsz
        );
    if (pwsz = (LPWSTR) PkiNonzeroAlloc(cwsz * sizeof(WCHAR)))
        CertNameToStrW(
            dwCertEncodingType,
            pName,
            dwStrType,
            pwsz,
            cwsz
            );
    cszOut = ConvertUnicodeStringToAscii(pwsz, cwsz, psz, csz);

    PkiFree(pwsz);
    return cszOut;
}


//+-------------------------------------------------------------------------
//  Map the attribute key (for example "CN") to its Object Identifier
//  (for example, "2.5.4.3").
//
//  The input pwcKey isn't NULL terminated. cchKey > 0.
//
//  Returns NULL if unable to find a matching attribute key.
//--------------------------------------------------------------------------
static LPCSTR X500KeyToOID(IN LPCWSTR pwcKey, IN DWORD cchKey)
{
    PCCRYPT_OID_INFO pX500Info;
    WCHAR wszKey[MAX_X500_KEY_LEN + 1];

    if (cchKey > MAX_X500_KEY_LEN)
        return NULL;
    assert(cchKey > 0);

    // Null terminate the input Key
    memcpy(wszKey, pwcKey, cchKey * sizeof(WCHAR));
    wszKey[cchKey] = L'\0';

    if (pX500Info = CryptFindOIDInfo(
            CRYPT_OID_INFO_NAME_KEY,
            wszKey,
            CRYPT_RDN_ATTR_OID_GROUP_ID
            )) {
        if (*pX500Info->pszOID)
            return pX500Info->pszOID;
    }
    return NULL;
}


//+-------------------------------------------------------------------------
//  Checks if a digit
//--------------------------------------------------------------------------
static inline BOOL IsDigitA(char c)
{
    return c >= '0' && c <= '9';
}

#define X500_OID_PREFIX_A       "OID."
#define X500_OID_PREFIX_LEN     strlen(X500_OID_PREFIX_A)

#define NO_LOCALE MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT)

//+-------------------------------------------------------------------------
//  Check for the case insensitive leading "OID." If present, skip past
//  it. Check that the remaining string contains only digits or a dot (".").
//  Also, don't allow consecutive dots.
//
//  Returns NULL for an invalid OID.
//--------------------------------------------------------------------------
static LPCSTR GetX500OID(IN LPCSTR pszObjId)
{
    LPCSTR psz;
    char c;
    BOOL fDot;

    if (strlen(pszObjId) > X500_OID_PREFIX_LEN &&
            2 == CompareStringA(NO_LOCALE, NORM_IGNORECASE,
                X500_OID_PREFIX_A, X500_OID_PREFIX_LEN,
                pszObjId, X500_OID_PREFIX_LEN))
        pszObjId += X500_OID_PREFIX_LEN;

    // Verify the OID to have only digits and dots
    psz = pszObjId;
    fDot = FALSE;
    while (c = *psz++) {
        if (c == '.') {
            if (fDot)
                return NULL;
            fDot = TRUE;
        } else {
            if (!IsDigitA(c))
                return NULL;
            fDot = FALSE;
        }
    }
    return pszObjId;
}

//+-------------------------------------------------------------------------
//  Convert the the hex string, for example, #AB01, to binary.
//
//  The input string is assumed to have the leading #. Ignores embedded
//  whitespace.
//
//  The returned binary is allocated in pValue->pbData.
//--------------------------------------------------------------------------
static BOOL GetAndAllocHexW(
    IN LPCWSTR pwszToken,
    IN DWORD cchToken,
    OUT PCERT_RDN_VALUE_BLOB pValue
    )
{
    BOOL fResult;
    BYTE *pb;
    DWORD cb;
    BOOL fUpperNibble;

    pValue->pbData = NULL;
    pValue->cbData = 0;

    // Advance past #
    cchToken--;
    pwszToken++;
    if (0 == cchToken)
        goto NoHex;

    if (NULL == (pb = (BYTE *) PkiNonzeroAlloc(cchToken / 2 + 1)))
        goto OutOfMemory;
    pValue->pbData = pb;

    fUpperNibble = TRUE;
    cb = 0;
    while (cchToken--) {
        BYTE b;
        WCHAR wc = *pwszToken++;
        // only convert ascii hex characters 0..9, a..f, A..F
        // ignore whitespace
        if (wc >= L'0' && wc <= L'9')
            b = (BYTE) (wc - L'0');
        else if (wc >= L'a' && wc <= L'f')
            b = (BYTE) (10 + wc - L'a');
        else if (wc >= L'A' && wc <= L'F')
            b = (BYTE) (10 + wc - L'A');
        else if (IsSpaceW(wc))
            continue;
        else
            goto InvalidHex;

        if (fUpperNibble) {
            *pb = (BYTE)( b << 4 );
            cb++;
            fUpperNibble = FALSE;
        } else {
            *pb = (BYTE)( *pb | b);
            pb++;
            fUpperNibble = TRUE;
        }
    }
    if (cb == 0) {
        PkiFree(pValue->pbData);
        pValue->pbData = NULL;
    }
    pValue->cbData = cb;

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    PkiFree(pValue->pbData);
    pValue->pbData = NULL;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
SET_ERROR(NoHex, CRYPT_E_INVALID_X500_STRING)
SET_ERROR(InvalidHex, CRYPT_E_INVALID_X500_STRING)
}

#define X500_QUOTED_FLAG            0x1
#define X500_EMBEDDED_QUOTE_FLAG    0x2

//+-------------------------------------------------------------------------
//  Get the next key or value token.
//
//  Handles quoted tokens.
//
//  Upon return *ppwsz points at the delimiter or error location
//--------------------------------------------------------------------------
static BOOL GetX500Token(
    IN OUT LPCWSTR *ppwsz,
    IN LPCWSTR pwszDelimiter,
    IN BOOL fEnableQuoting,
    OUT LPCWSTR *ppwszToken,
    OUT DWORD *pcchToken,
    OUT DWORD *pdwFlags
    )
{
    BOOL fResult;
    LPCWSTR pwsz = *ppwsz;
    LPCWSTR pwszStart = NULL;
    LPCWSTR pwszEnd = NULL;
    DWORD dwQuote = 0;          // 1 - after leading ", 2 - after trailing "

    *pdwFlags = 0;
    while (TRUE) {
        WCHAR wc = *pwsz;
        if (0 == dwQuote) {
            // No quotes so far. Or quoting not enabled.
            if (fEnableQuoting && L'\"' == wc) {
                if (NULL == pwszStart) {
                    pwszStart = pwsz + 1;
                    dwQuote = 1;
                    *pdwFlags |= X500_QUOTED_FLAG;
                } else
                    // Quote after non whitespace
                    goto ErrorReturn;
            } else {
                if (L'\0' == wc || IsInStrW(pwszDelimiter, wc)) {
                    // Hit a delimiter (including the null terminator)
                    if (pwszStart)
                        *pcchToken = (DWORD)(pwszEnd - pwszStart) + 1;
                    else
                        *pcchToken = 0;
                    break;
                }

                if (!IsSpaceW(wc)) {
                    pwszEnd = pwsz;
                    if (NULL == pwszStart)
                        pwszStart = pwsz;
                }
            }
        } else if (1 == dwQuote) {
            // After first quote
            if (L'\0' == wc) {
                // Point to first quote
                pwsz = pwszStart - 1;
                goto ErrorReturn;
            } else if (L'\"' == wc) {
                if (L'\"' == *(pwsz + 1)) {
                    *pdwFlags |= X500_EMBEDDED_QUOTE_FLAG;
                    // Skip double quote
                    pwsz++;
                } else {
                    *pcchToken = (DWORD)(pwsz - pwszStart);
                    dwQuote++;
                }
            }
        } else {
            // After second quote
            if (L'\0' == wc || IsInStrW(pwszDelimiter, wc))
                break;
            else if (!IsSpaceW(wc))
                goto ErrorReturn;
        }
        pwsz++;
    }

    fResult = TRUE;
CommonReturn:
    *ppwszToken = pwszStart;
    *ppwsz = pwsz;
    return fResult;

ErrorReturn:
    pwszStart = NULL;
    *pcchToken = 0;
    fResult = FALSE;
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  Convert the null terminated X500 WCHAR string to an encoded
//  certificate name.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertStrToNameW(
    IN DWORD dwCertEncodingType,
    IN LPCWSTR pwszX500,
    IN DWORD dwStrType,
    IN OPTIONAL void *pvReserved,
    OUT BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded,
    OUT OPTIONAL LPCWSTR *ppwszError
    )
{

typedef struct _X500_ATTR_AUX {
    LPSTR pszAllocObjId;
    LPCWSTR pwszValue;
    BYTE *pbAllocValue;
    BOOL fNewRDN;
} X500_ATTR_AUX, *PX500_ATTR_AUX;
#define X500_ATTR_ALLOC_COUNT   20

    BOOL fResult;
    CERT_NAME_INFO NameInfo;
    PCERT_RDN pRDN = NULL;
    PCERT_RDN_ATTR pAttr = NULL;
    PX500_ATTR_AUX pAux = NULL;

    DWORD cRDN = 0;
    DWORD cAttr = 0;
    DWORD iRDN;
    DWORD iAttr;
    DWORD cAllocAttr;
    BOOL fNewRDN;
    DWORD dwValueType;

    WCHAR wszSeparators[8];
    BOOL fEnableQuoting;
    LPCWSTR pwszError = NULL;
    LPCWSTR pwszStartX500 = pwszX500;

    dwValueType = 0;
    if (dwStrType & CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG)
        dwValueType |= CERT_RDN_ENABLE_T61_UNICODE_FLAG;
    if (dwStrType & CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG)
        dwValueType |= CERT_RDN_ENABLE_UTF8_UNICODE_FLAG;

    // Check for an empty Name.
    if (NULL == pwszX500 || L'\0' == *pwszX500) {
        NameInfo.cRDN = 0;
        NameInfo.rgRDN = NULL;

        if (ppwszError)
            *ppwszError = NULL;

        return CryptEncodeObject(
            dwCertEncodingType,
            X509_NAME,
            &NameInfo,
            pbEncoded,
            pcbEncoded
            );
    }

    if (dwStrType & CERT_NAME_STR_SEMICOLON_FLAG)
        wcscpy(wszSeparators, L";");
    else if (dwStrType & CERT_NAME_STR_COMMA_FLAG)
        wcscpy(wszSeparators, L",");
    else if (dwStrType & CERT_NAME_STR_CRLF_FLAG)
        wcscpy(wszSeparators, L"\r\n");
    else
        wcscpy(wszSeparators, L",;");
    if (!(dwStrType & CERT_NAME_STR_NO_PLUS_FLAG))
        wcscat(wszSeparators, L"+");

    if (dwStrType & CERT_NAME_STR_NO_QUOTING_FLAG)
        fEnableQuoting = FALSE;
    else
        fEnableQuoting = TRUE;

    // Eliminate the upper flags before switching
    switch (dwStrType & 0xFFFF) {
        case 0:
        case CERT_OID_NAME_STR:
        case CERT_X500_NAME_STR:
            break;
        case CERT_SIMPLE_NAME_STR:
        default:
            goto InvalidArg;
    }

    // Do initial allocations of Attrs, and Auxs
    if (NULL == (pAttr = (PCERT_RDN_ATTR) PkiNonzeroAlloc(
                sizeof(CERT_RDN_ATTR) * X500_ATTR_ALLOC_COUNT)) ||
            NULL == (pAux = (PX500_ATTR_AUX) PkiNonzeroAlloc(
                sizeof(X500_ATTR_AUX) * X500_ATTR_ALLOC_COUNT)))
        goto OutOfMemory;
    cAllocAttr = X500_ATTR_ALLOC_COUNT;
    fNewRDN = TRUE;
    while (TRUE) {
        LPCWSTR pwszToken;
        DWORD cchToken;
        DWORD dwTokenFlags;
        LPCSTR pszObjId;

        // Get the key token
        if (!GetX500Token(
                &pwszX500,
                L"=",           // pwszDelimiter
                FALSE,          // fEnableQuoting
                &pwszToken,
                &cchToken,
                &dwTokenFlags
                )) {
            pwszError = pwszX500;
            goto X500KeyTokenError;
        }

        if (0 == cchToken) {
            if (*pwszX500 == L'\0')
                break;
            else {
                pwszError = pwszX500;
                goto EmptyX500KeyError;
            }
        } else if (*pwszX500 == L'\0') {
            pwszError = pwszToken;
            goto NoX500KeyEqualError;
        }

        if (cAttr >= cAllocAttr) {
            PCERT_RDN_ATTR pNewAttr;
            PX500_ATTR_AUX pNewAux;

            assert(cAttr == cAllocAttr);
            if (NULL == (pNewAttr = (PCERT_RDN_ATTR) PkiRealloc(pAttr,
                    sizeof(CERT_RDN_ATTR) *
                        (cAllocAttr + X500_ATTR_ALLOC_COUNT))))
                goto OutOfMemory;
            pAttr = pNewAttr;

            if (NULL == (pNewAux = (PX500_ATTR_AUX) PkiRealloc(pAux,
                    sizeof(X500_ATTR_AUX) *
                        (cAllocAttr + X500_ATTR_ALLOC_COUNT))))
                goto OutOfMemory;
            pAux = pNewAux;

            cAllocAttr += X500_ATTR_ALLOC_COUNT;
        }
        iAttr = cAttr;
        cAttr++;
        memset(&pAttr[iAttr], 0, sizeof(CERT_RDN_ATTR));
        memset(&pAux[iAttr], 0, sizeof(X500_ATTR_AUX));
        pAux[iAttr].fNewRDN = fNewRDN;
        if (fNewRDN)
            cRDN++;

        // Convert the Key token to an OID
        pszObjId = X500KeyToOID(pwszToken, cchToken);
        if (NULL == pszObjId) {
            // Convert to ascii and null terminate
            LPSTR pszAllocObjId;
            DWORD i;

            // Convert from unicode to ascii and null terminate
            if (NULL == (pszAllocObjId = (LPSTR) PkiNonzeroAlloc(
                    cchToken + 1)))
                goto OutOfMemory;
            pAux[iAttr].pszAllocObjId = pszAllocObjId;
            for (i = 0; i < cchToken; i++)
                pszAllocObjId[i] = (char) (pwszToken[i] & 0xFF);
            pszAllocObjId[cchToken] = '\0';

            // Skips by leading OID. and validates
            pszObjId = GetX500OID(pszAllocObjId);
            if (NULL == pszObjId) {
                pwszError = pwszToken;
                goto InvalidX500Key;
            }
        }
        pAttr[iAttr].pszObjId = (LPSTR) pszObjId;
        pAttr[iAttr].dwValueType = dwValueType;

        // Advance past the Key's "=" delimiter
        pwszX500++;

        // Get the value token
        if (!GetX500Token(
                &pwszX500,
                wszSeparators,
                fEnableQuoting,
                &pwszToken,
                &cchToken,
                &dwTokenFlags
                )) {
            pwszError = pwszX500;
            goto X500ValueTokenError;
        }
        if (cchToken) {
            if (*pwszToken == L'#' && 0 == (dwTokenFlags & X500_QUOTED_FLAG)) {
                // Convert ascii hex to binary
                if (!GetAndAllocHexW(pwszToken, cchToken,
                        &pAttr[iAttr].Value)) {
                    pwszError = pwszToken;
                    goto ConvertHexError;
                }
                pAttr[iAttr].dwValueType = CERT_RDN_OCTET_STRING;
                pAux[iAttr].pbAllocValue = pAttr[iAttr].Value.pbData;
            } else if (dwTokenFlags & X500_EMBEDDED_QUOTE_FLAG) {
                // Realloc and remove the double "'s
                LPWSTR pwszAlloc;
                DWORD cchAlloc;
                DWORD i;
                if (NULL == (pwszAlloc = (LPWSTR) PkiNonzeroAlloc(
                        cchToken * sizeof(WCHAR))))
                    goto OutOfMemory;
                pAux[iAttr].pbAllocValue = (BYTE *) pwszAlloc;
                cchAlloc = 0;
                for (i = 0; i < cchToken; i++) {
                    pwszAlloc[cchAlloc++] = pwszToken[i];
                    if (pwszToken[i] == L'\"')
                        i++;
                }
                assert(cchAlloc < cchToken);
                pAttr[iAttr].Value.pbData = (BYTE *) pwszAlloc;
                pAttr[iAttr].Value.cbData = cchAlloc * sizeof(WCHAR);
            } else {
                pAttr[iAttr].Value.pbData = (BYTE *) pwszToken;
                pAttr[iAttr].Value.cbData = cchToken * sizeof(WCHAR);
            }

            pAux[iAttr].pwszValue = pwszToken;
        }

        fNewRDN = TRUE;
        if (*pwszX500 == L'\0')
            break;
        else if (*pwszX500 == L'+')
            fNewRDN = FALSE;

        // Advance past the value's delimiter
        pwszX500++;
    }

    if (0 == cRDN) {
        pwszError = pwszStartX500;
        goto NoRDNError;
    }

    // Allocate array of RDNs and update
    if (NULL == (pRDN = (PCERT_RDN) PkiNonzeroAlloc(sizeof(CERT_RDN) * cRDN)))
        goto OutOfMemory;
    iRDN = 0;
    for (iAttr = 0; iAttr < cAttr; iAttr++) {
        if (pAux[iAttr].fNewRDN) {
            assert(iRDN < cRDN);
            pRDN[iRDN].cRDNAttr = 1;
            pRDN[iRDN].rgRDNAttr = &pAttr[iAttr];
            iRDN++;
        } else {
            assert(iRDN > 0);
            pRDN[iRDN - 1].cRDNAttr++;

        }
    }
    assert(iRDN == cRDN);
    NameInfo.cRDN = cRDN;
    NameInfo.rgRDN = pRDN;

    if (dwStrType & CERT_NAME_STR_REVERSE_FLAG)
        ReverseNameInfo(&NameInfo);

    // Encode the above built name
    fResult = UnicodeNameInfoEncode(
        dwCertEncodingType,
        X509_UNICODE_NAME,
        &NameInfo,
        pbEncoded,
        pcbEncoded
        );

    if (!fResult) {
        DWORD dwErr = GetLastError();
        if ((DWORD) CRYPT_E_INVALID_NUMERIC_STRING == dwErr ||
                (DWORD) CRYPT_E_INVALID_PRINTABLE_STRING == dwErr ||
                (DWORD) CRYPT_E_INVALID_IA5_STRING == dwErr) {
            // *pcbEncoded contains the location of the error

            PCERT_RDN_ATTR pErrAttr;
            DWORD iValue;

            if (dwStrType & CERT_NAME_STR_REVERSE_FLAG) {
                // Reverse back to get the correct location of the error
                // relative to the input string
                ReverseNameInfo(&NameInfo);
                fResult = UnicodeNameInfoEncode(
                    dwCertEncodingType,
                    X509_UNICODE_NAME,
                    &NameInfo,
                    pbEncoded,
                    pcbEncoded
                    );
                if (fResult)
                    goto UnexpectedReverseEncodeSuccess;
                dwErr = GetLastError();
                if (!( (DWORD) CRYPT_E_INVALID_NUMERIC_STRING == dwErr ||
                        (DWORD) CRYPT_E_INVALID_PRINTABLE_STRING == dwErr ||
                        (DWORD) CRYPT_E_INVALID_IA5_STRING == dwErr))
                    goto UnexpectedReverseEncodeError;
            }

            iValue = GET_CERT_UNICODE_VALUE_ERR_INDEX(*pcbEncoded);
            iRDN = GET_CERT_UNICODE_RDN_ERR_INDEX(*pcbEncoded);
            iAttr = GET_CERT_UNICODE_ATTR_ERR_INDEX(*pcbEncoded);
            *pcbEncoded = 0;

            assert(iRDN < cRDN);
            assert(iAttr < pRDN[iRDN].cRDNAttr);
            pErrAttr = &pRDN[iRDN].rgRDNAttr[iAttr];

            assert(pErrAttr->dwValueType != CERT_RDN_OCTET_STRING);

            // Index from beginning of pAttr
            iAttr = (DWORD)(pErrAttr - pAttr);
            assert(iAttr < cAttr);
            assert(iValue < pAttr[iAttr].Value.cbData / sizeof(WCHAR));
            pwszError = pAux[iAttr].pwszValue;
            assert(pwszError);
            if (pAux[iAttr].pbAllocValue) {
                // Adjust for embedded quotes where the the second quote
                // was removed above before encoding
                DWORD i = iValue;
                assert(pAux[iAttr].pbAllocValue == pAttr[iAttr].Value.pbData);
                LPCWSTR pwszValue = (LPCWSTR) pAttr[iAttr].Value.pbData;
                for ( ; i > 0; i--, pwszValue++)
                    if (*pwszValue == L'\"')
                        iValue++;
            }
            pwszError += iValue;
        }
    }
CommonReturn:
    while (cAttr--) {
        PkiFree(pAux[cAttr].pszAllocObjId);
        PkiFree(pAux[cAttr].pbAllocValue);
    }

    PkiFree(pRDN);
    PkiFree(pAttr);
    PkiFree(pAux);
    if (ppwszError)
        *ppwszError = pwszError;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
SET_ERROR(X500KeyTokenError, CRYPT_E_INVALID_X500_STRING)
SET_ERROR(EmptyX500KeyError, CRYPT_E_INVALID_X500_STRING)
SET_ERROR(NoX500KeyEqualError, CRYPT_E_INVALID_X500_STRING)
SET_ERROR(InvalidX500Key, CRYPT_E_INVALID_X500_STRING)
SET_ERROR(X500ValueTokenError, CRYPT_E_INVALID_X500_STRING)
SET_ERROR(ConvertHexError, CRYPT_E_INVALID_X500_STRING)
SET_ERROR(NoRDNError, CRYPT_E_INVALID_X500_STRING)
SET_ERROR(UnexpectedReverseEncodeSuccess, E_UNEXPECTED)
TRACE_ERROR(UnexpectedReverseEncodeError)
}

//+-------------------------------------------------------------------------
//  Convert the null terminated X500 char string to an encoded
//  certificate name.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertStrToNameA(
    IN DWORD dwCertEncodingType,
    IN LPCSTR pszX500,
    IN DWORD dwStrType,
    IN OPTIONAL void *pvReserved,
    OUT BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded,
    OUT OPTIONAL LPCSTR *ppszError
    )
{
    BOOL fResult;
    LPWSTR pwszX500 = NULL;
    LPCWSTR pwszError = NULL;

    assert(pszX500);
    if (NULL == (pwszX500 = MkWStr((LPSTR) pszX500)))
        goto ErrorReturn;
    fResult = CertStrToNameW(
        dwCertEncodingType,
        pwszX500,
        dwStrType,
        pvReserved,
        pbEncoded,
        pcbEncoded,
        &pwszError
        );
    if (ppszError) {
        // Update multi byte error location
        if (pwszError) {
            // Default to beginning of string
            *ppszError = pszX500;
            if (pwszError > pwszX500) {
                // After beginning of string. There should be at least 2
                // characters.
                //
                // Need to convert pwszX500 .. pwszError - 1 back to multi byte
                // to get the correct multi byte pointer.
                int cchError = strlen(pszX500) - 1; // exclude error char
                LPSTR pszError;
                DWORD dwSaveLastError = GetLastError();

                assert(cchError);
                if (pszError = (LPSTR) PkiNonzeroAlloc(cchError)) {
                    // Convert up through the previous multibyte character
                    cchError = WideCharToMultiByte(
                        CP_ACP,
                        0,                      // dwFlags
                        pwszX500,
                        (int)(pwszError - pwszX500),
                        pszError,
                        cchError,
                        NULL,                   // lpDefaultChar
                        NULL                    // lpfUsedDefaultChar
                        );
                    if (cchError > 0)
                        *ppszError = pszX500 + cchError;
                    PkiFree(pszError);
                }

                SetLastError(dwSaveLastError);
            }
        } else
            *ppszError = NULL;
    }

CommonReturn:
    FreeWStr(pwszX500);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    *pcbEncoded = 0;
    if (ppszError)
        *ppszError = NULL;
    goto CommonReturn;
}

//==========================================================================
//  CertGetNameStrW support functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Returns pointer to allocated CERT_NAME_INFO by decoding the name blob.
//
//  Returns NULL if cRDN == 0
//--------------------------------------------------------------------------
static PCERT_NAME_INFO AllocAndGetNameInfo(
    IN DWORD dwCertEncodingType,
    IN PCERT_NAME_BLOB pName,
    IN DWORD dwFlags
    )
{
    PCERT_NAME_INFO pInfo;

    assert(pName);
    if (0 == pName->cbData)
        return NULL;

    if (NULL == (pInfo = (PCERT_NAME_INFO) AllocAndDecodeObject(
            dwCertEncodingType,
            X509_UNICODE_NAME,
            pName->pbData,
            pName->cbData,
            (dwFlags & CERT_NAME_DISABLE_IE4_UTF8_FLAG) ?
                CRYPT_UNICODE_NAME_DECODE_DISABLE_IE4_UTF8_FLAG : 0
            )))
        return NULL;
    if (0 == pInfo->cRDN) {
        PkiFree(pInfo);
        return NULL;
    } else
        return pInfo;
}

//+-------------------------------------------------------------------------
//  Returns pointer to allocated CERT_NAME_INFO by decoding either the
//  Subject or Issuer field in the certificate. CERT_NAME_ISSUER_FLAG is
//  set to select the Issuer.
//
//  Returns NULL if cRDN == 0
//--------------------------------------------------------------------------
static PCERT_NAME_INFO AllocAndGetCertNameInfo(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwFlags
    )
{
    PCERT_NAME_BLOB pName;

    if (dwFlags & CERT_NAME_ISSUER_FLAG)
        pName = &pCertContext->pCertInfo->Issuer;
    else
        pName = &pCertContext->pCertInfo->Subject;

    return AllocAndGetNameInfo(pCertContext->dwCertEncodingType, pName,
        dwFlags);
}

//+-------------------------------------------------------------------------
//  Table of Subject and Issuer Alternative Name extension OIDs
//--------------------------------------------------------------------------
static const LPCSTR rgpszSubjectAltOID[] = {
    szOID_SUBJECT_ALT_NAME2,
    szOID_SUBJECT_ALT_NAME
};
#define NUM_SUBJECT_ALT_OID (sizeof(rgpszSubjectAltOID) / \
                                         sizeof(rgpszSubjectAltOID[0]))

static const LPCSTR rgpszIssuerAltOID[] = {
    szOID_ISSUER_ALT_NAME2,
    szOID_ISSUER_ALT_NAME
};
#define NUM_ISSUER_ALT_OID (sizeof(rgpszIssuerAltOID) / \
                                         sizeof(rgpszIssuerAltOID[0]))

//+-------------------------------------------------------------------------
//  Returns pointer to allocated CERT_ALT_NAME_INFO by decoding either the
//  Subject or Issuer Alternative Extension. CERT_NAME_ISSUER_FLAG is
//  set to select the Issuer.
//
//  Returns NULL if extension not found or cAltEntry == 0
//--------------------------------------------------------------------------
static PCERT_ALT_NAME_INFO AllocAndGetAltNameInfo(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwFlags
    )
{
    DWORD cAltOID;
    const LPCSTR *ppszAltOID;

    PCERT_EXTENSION pExt;
    PCERT_ALT_NAME_INFO pInfo;

    if (dwFlags & CERT_NAME_ISSUER_FLAG) {
        cAltOID = NUM_ISSUER_ALT_OID;
        ppszAltOID = rgpszIssuerAltOID;
    } else {
        cAltOID = NUM_SUBJECT_ALT_OID;
        ppszAltOID = rgpszSubjectAltOID;
    }

    // Try to find an alternative name extension
    pExt = NULL;
    for ( ; cAltOID > 0; cAltOID--, ppszAltOID++) {
        if (pExt = CertFindExtension(
                *ppszAltOID,
                pCertContext->pCertInfo->cExtension,
                pCertContext->pCertInfo->rgExtension
                ))
            break;
    }

    if (NULL == pExt)
        return NULL;

    if (NULL == (pInfo = (PCERT_ALT_NAME_INFO) AllocAndDecodeObject(
            pCertContext->dwCertEncodingType,
            X509_ALTERNATE_NAME,
            pExt->Value.pbData,
            pExt->Value.cbData,
            0                       // dwFlags
            )))
        return NULL;
    if (0 == pInfo->cAltEntry) {
        PkiFree(pInfo);
        return NULL;
    } else
        return pInfo;
}

//+-------------------------------------------------------------------------
//  Returns pointer to allocated CERT_NAME_INFO by decoding the first
//  Directory Name choice (if it exists) in the decoded CERT_ALT_NAME_INFO.
//
//  Returns NULL if no Directory Name choice or cRDN == 0.
//--------------------------------------------------------------------------
static PCERT_NAME_INFO AllocAndGetAltDirNameInfo(
    IN DWORD dwCertEncodingType,
    IN PCERT_ALT_NAME_INFO pAltNameInfo,
    IN DWORD dwFlags
    )
{
    DWORD cEntry;
    PCERT_ALT_NAME_ENTRY pEntry;

    if (NULL == pAltNameInfo)
        return NULL;

    cEntry = pAltNameInfo->cAltEntry;
    pEntry = pAltNameInfo->rgAltEntry;

    for ( ; cEntry > 0; cEntry--, pEntry++) {
        if (CERT_ALT_NAME_DIRECTORY_NAME == pEntry->dwAltNameChoice) {
            return AllocAndGetNameInfo(dwCertEncodingType,
                &pEntry->DirectoryName, dwFlags);
        }
    }

    return NULL;
}

//+-------------------------------------------------------------------------
//  First, returns pointer to allocated CERT_ALT_NAME_INFO by decoding either
//  the Subject or Issuer Alternative Extension. CERT_NAME_ISSUER_FLAG is
//  set to select the Issuer. Returns NULL if extension not found or
//  cAltEntry == 0
//
//  Then, if able to find the extension, returns pointer to allocated
//  CERT_NAME_INFO by decoding the first Directory Name choice (if it exists)
//  in the decoded CERT_ALT_NAME_INFO. Returns NULL if no Directory Name
//  choice or cRDN == 0.
//--------------------------------------------------------------------------
static PCERT_NAME_INFO AllocAndGetAltDirNameInfo(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwFlags,
    OUT PCERT_ALT_NAME_INFO *ppAltNameInfo
    )
{
    PCERT_ALT_NAME_INFO pAltNameInfo;
    *ppAltNameInfo = pAltNameInfo = AllocAndGetAltNameInfo(pCertContext,
        dwFlags);
    if (NULL == pAltNameInfo)
        return NULL;
    return AllocAndGetAltDirNameInfo(pCertContext->dwCertEncodingType,
        pAltNameInfo, dwFlags);
}

//+-------------------------------------------------------------------------
//  Copy name string. Ensure its NULL terminated.
//--------------------------------------------------------------------------
static void CopyNameStringW(
    IN LPCWSTR pwszSrc,
    OUT OPTIONAL LPWSTR pwszNameString,
    IN DWORD cchNameString,
    OUT DWORD *pcwszOut
    )
{
    PutStrW(pwszSrc, &pwszNameString, &cchNameString, pcwszOut);
    if (cchNameString != 0)
        // Always NULL terminate
        *pwszNameString = L'\0';
    *pcwszOut += 1;
}

//+-------------------------------------------------------------------------
//  Table of ordered RDN attributes to search for when formatting
//  SIMPLE_DISPLAY_TYPE
//--------------------------------------------------------------------------
static const LPCSTR rgpszSimpleDisplayAttrOID[] = {
    szOID_COMMON_NAME,
    szOID_ORGANIZATIONAL_UNIT_NAME,
    szOID_ORGANIZATION_NAME,
    szOID_RSA_emailAddr,
    NULL                                // any
};
#define NUM_SIMPLE_DISPLAY_ATTR_OID (sizeof(rgpszSimpleDisplayAttrOID) / \
                                        sizeof(rgpszSimpleDisplayAttrOID[0]))

//+-------------------------------------------------------------------------
//  Table of ordered RDN attributes to search for when formatting
//  EMAIL_TYPE
//--------------------------------------------------------------------------
static const LPCSTR rgpszEmailAttrOID[] = {
    szOID_RSA_emailAddr
};
#define NUM_EMAIL_ATTR_OID (sizeof(rgpszEmailAttrOID) / \
                                     sizeof(rgpszEmailAttrOID[0]))

//+-------------------------------------------------------------------------
//  Table of ordered RDN attributes to search for when formatting
//  DNS_TYPE
//--------------------------------------------------------------------------
static const LPCSTR rgpszDNSAttrOID[] = {
    szOID_COMMON_NAME
};
#define NUM_DNS_ATTR_OID (sizeof(rgpszDNSAttrOID) / \
                                     sizeof(rgpszDNSAttrOID[0]))


// Largest number from above tables
#define MAX_ATTR_OID            NUM_SIMPLE_DISPLAY_ATTR_OID

// PCERT_NAME_INFO table count and indices
#define NAME_INFO_CNT           2
#define CERT_NAME_INFO_INDEX    0
#define ALT_DIR_NAME_INFO_INDEX 1


//+-------------------------------------------------------------------------
//  Iterate through the list of attributes specified in rgpszAttrOID
//  and iterate through the table of decoded names specified in rgpNameInfo
//  and find the first occurrence of the attribute.
//--------------------------------------------------------------------------
static BOOL GetAttrStringW(
    IN DWORD cAttrOID,
    IN const LPCSTR *rgpszAttrOID,
    IN PCERT_NAME_INFO rgpNameInfo[NAME_INFO_CNT],
    OUT OPTIONAL LPWSTR pwszNameString,
    IN DWORD cchNameString,
    OUT DWORD *pcwszOut
    )
{
    DWORD iOID;
    PCERT_RDN_ATTR rgpFoundAttr[MAX_ATTR_OID];
    DWORD iInfo;

    assert(cAttrOID > 0 && cAttrOID <= MAX_ATTR_OID);
    for (iOID = 0; iOID < cAttrOID; iOID++)
        rgpFoundAttr[iOID] = NULL;

    for (iInfo = 0; iInfo < NAME_INFO_CNT; iInfo++) {
        PCERT_NAME_INFO pInfo;
        DWORD cRDN;

        if (NULL == (pInfo = rgpNameInfo[iInfo]))
            continue;

        // Search RDNs in reverse order
        for (cRDN = pInfo->cRDN; cRDN > 0; cRDN--) {
            PCERT_RDN pRDN = &pInfo->rgRDN[cRDN - 1];
            DWORD cAttr = pRDN->cRDNAttr;
            PCERT_RDN_ATTR pAttr = pRDN->rgRDNAttr;
            for ( ; cAttr > 0; cAttr--, pAttr++) {
                if (CERT_RDN_ENCODED_BLOB == pAttr->dwValueType ||
                        CERT_RDN_OCTET_STRING == pAttr->dwValueType)
                    continue;

                for (iOID = 0; iOID < cAttrOID; iOID++) {
                    if (NULL == rgpFoundAttr[iOID] &&
                            (NULL == rgpszAttrOID[iOID] ||
                                0 == strcmp(rgpszAttrOID[iOID],
                                    pAttr->pszObjId))) {
                        rgpFoundAttr[iOID] = pAttr;
                        if (0 == iOID)
                            goto FoundAttr;
                        else
                            break;
                    }
                }
            }
        }
    }


    // iOID == 0 was already found above
    assert(NULL == rgpFoundAttr[0]);
    for (iOID = 1; iOID < cAttrOID; iOID++) {
        if (rgpFoundAttr[iOID])
            break;
    }
    if (iOID >= cAttrOID)
        return FALSE;

FoundAttr:
    assert(iOID < cAttrOID && rgpFoundAttr[iOID]);
    CopyNameStringW((LPCWSTR) rgpFoundAttr[iOID]->Value.pbData, pwszNameString,
        cchNameString, pcwszOut);
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Attempt to find the specified choice in the decoded alternative name
//  extension.
//--------------------------------------------------------------------------
static BOOL GetAltNameUnicodeStringChoiceW(
    IN DWORD dwAltNameChoice,
    IN PCERT_ALT_NAME_INFO pAltNameInfo,
    OUT OPTIONAL LPWSTR pwszNameString,
    IN DWORD cchNameString,
    OUT DWORD *pcwszOut
    )
{
    DWORD cEntry;
    PCERT_ALT_NAME_ENTRY pEntry;

    if (NULL == pAltNameInfo)
        return FALSE;

    cEntry = pAltNameInfo->cAltEntry;
    pEntry = pAltNameInfo->rgAltEntry;
    for ( ; cEntry > 0; cEntry--, pEntry++) {
        if (dwAltNameChoice == pEntry->dwAltNameChoice) {
            // pwszRfc822Name union choice is the same as
            // pwszDNSName and pwszURL.
            CopyNameStringW(pEntry->pwszRfc822Name, pwszNameString,
                cchNameString, pcwszOut);
            return TRUE;
        }
    }

    return FALSE;
}

//+-------------------------------------------------------------------------
//  Attempt to find an OTHER_NAME choice in the decoded alternative name
//  extension whose pszObjId == szOID_NT_PRINCIPAL_NAME.
//
//  The UPN OtherName Value blob is decoded as a X509_UNICODE_ANY_STRING.
//--------------------------------------------------------------------------
static BOOL GetAltNameUPNW(
    IN PCERT_ALT_NAME_INFO pAltNameInfo,
    OUT OPTIONAL LPWSTR pwszNameString,
    IN DWORD cchNameString,
    OUT DWORD *pcwszOut
    )
{
    DWORD cEntry;
    PCERT_ALT_NAME_ENTRY pEntry;

    if (NULL == pAltNameInfo)
        return FALSE;

    cEntry = pAltNameInfo->cAltEntry;
    pEntry = pAltNameInfo->rgAltEntry;
    for ( ; cEntry > 0; cEntry--, pEntry++) {
        if (CERT_ALT_NAME_OTHER_NAME == pEntry->dwAltNameChoice &&
                0 == strcmp(pEntry->pOtherName->pszObjId,
                        szOID_NT_PRINCIPAL_NAME)) {
            PCERT_NAME_VALUE pNameValue;
            if (pNameValue = (PCERT_NAME_VALUE) AllocAndDecodeObject(
                    X509_ASN_ENCODING,
                    X509_UNICODE_ANY_STRING,
                    pEntry->pOtherName->Value.pbData,
                    pEntry->pOtherName->Value.cbData,
                    0                       // dwFlags
                    )) {
                BOOL fIsStr = IS_CERT_RDN_CHAR_STRING(pNameValue->dwValueType);

                if (fIsStr)
                    CopyNameStringW((LPWSTR) pNameValue->Value.pbData,
                        pwszNameString, cchNameString, pcwszOut);
                
                PkiFree(pNameValue);

                if (fIsStr)
                    return TRUE;
            }
        }
    }

    return FALSE;
}

//+-------------------------------------------------------------------------
//  Get the subject or issuer name from the certificate and
//  according to the specified format type, convert to a null terminated
//  WCHAR string.
//
//  CERT_NAME_ISSUER_FLAG can be set to get the issuer's name. Otherwise,
//  gets the subject's name.
//--------------------------------------------------------------------------
DWORD
WINAPI
CertGetNameStringW(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwType,
    IN DWORD dwFlags,
    IN void *pvTypePara,
    OUT OPTIONAL LPWSTR pwszNameString,
    IN DWORD cchNameString
    )
{
    DWORD cwszOut = 0;
    PCERT_NAME_INFO rgpNameInfo[NAME_INFO_CNT] = { NULL, NULL };
    PCERT_ALT_NAME_INFO pAltNameInfo = NULL;

    DWORD i;
    DWORD dwStrType;
    DWORD dwCertEncodingType;

    if (NULL == pwszNameString)
        cchNameString = 0;

    switch (dwType) {
        case CERT_NAME_EMAIL_TYPE:
            pAltNameInfo = AllocAndGetAltNameInfo(pCertContext, dwFlags);
            if (GetAltNameUnicodeStringChoiceW(
                    CERT_ALT_NAME_RFC822_NAME,
                    pAltNameInfo,
                    pwszNameString,
                    cchNameString,
                    &cwszOut
                    )) goto CommonReturn;

            rgpNameInfo[CERT_NAME_INFO_INDEX] = AllocAndGetCertNameInfo(
                pCertContext, dwFlags);
            if (!GetAttrStringW(
                    NUM_EMAIL_ATTR_OID,
                    rgpszEmailAttrOID,
                    rgpNameInfo,
                    pwszNameString,
                    cchNameString,
                    &cwszOut
                    )) goto NoEmail;
            break;

        case CERT_NAME_DNS_TYPE:
            pAltNameInfo = AllocAndGetAltNameInfo(pCertContext, dwFlags);
            if (GetAltNameUnicodeStringChoiceW(
                    CERT_ALT_NAME_DNS_NAME,
                    pAltNameInfo,
                    pwszNameString,
                    cchNameString,
                    &cwszOut
                    )) goto CommonReturn;

            rgpNameInfo[CERT_NAME_INFO_INDEX] = AllocAndGetCertNameInfo(
                pCertContext, dwFlags);
            if (!GetAttrStringW(
                    NUM_DNS_ATTR_OID,
                    rgpszDNSAttrOID,
                    rgpNameInfo,
                    pwszNameString,
                    cchNameString,
                    &cwszOut
                    )) goto NoDNS;
            break;

        case CERT_NAME_URL_TYPE:
            pAltNameInfo = AllocAndGetAltNameInfo(pCertContext, dwFlags);
            if (!GetAltNameUnicodeStringChoiceW(
                    CERT_ALT_NAME_URL,
                    pAltNameInfo,
                    pwszNameString,
                    cchNameString,
                    &cwszOut
                    )) goto NoURL;
            break;

        case CERT_NAME_UPN_TYPE:
            pAltNameInfo = AllocAndGetAltNameInfo(pCertContext, dwFlags);
            if (!GetAltNameUPNW(
                    pAltNameInfo,
                    pwszNameString,
                    cchNameString,
                    &cwszOut
                    )) goto NoUPN;
            break;

        case CERT_NAME_RDN_TYPE:
            dwStrType = pvTypePara ? *((DWORD *) pvTypePara) : 0;

            if (dwStrType & CERT_NAME_STR_DISABLE_IE4_UTF8_FLAG)
                dwFlags |= CERT_NAME_DISABLE_IE4_UTF8_FLAG;

            dwCertEncodingType = pCertContext->dwCertEncodingType;
            if (rgpNameInfo[CERT_NAME_INFO_INDEX] = AllocAndGetCertNameInfo(
                    pCertContext, dwFlags))
                // Note, decoded name info RDNs may be reversed
                cwszOut = CertNameInfoToStrW(
                    dwCertEncodingType,
                    rgpNameInfo[CERT_NAME_INFO_INDEX],
                    dwStrType,
                    pwszNameString,
                    cchNameString
                    );
            else if (rgpNameInfo[ALT_DIR_NAME_INFO_INDEX] =
                    AllocAndGetAltDirNameInfo(pCertContext, dwFlags,
                        &pAltNameInfo))
                // Note, decoded name info RDNs may be reversed
                cwszOut = CertNameInfoToStrW(
                    dwCertEncodingType,
                    rgpNameInfo[ALT_DIR_NAME_INFO_INDEX],
                    dwStrType,
                    pwszNameString,
                    cchNameString
                    );
            else
                goto NoRDN;
            break;

        case CERT_NAME_ATTR_TYPE:
            rgpNameInfo[CERT_NAME_INFO_INDEX] = AllocAndGetCertNameInfo(
                pCertContext, dwFlags);
            rgpNameInfo[ALT_DIR_NAME_INFO_INDEX] = AllocAndGetAltDirNameInfo(
                pCertContext, dwFlags, &pAltNameInfo);

            if (!GetAttrStringW(
                    1,                  // cAttrOID
                    (const LPCSTR *) &pvTypePara,
                    rgpNameInfo,
                    pwszNameString,
                    cchNameString,
                    &cwszOut
                    )) goto NoAttr;
            break;

        case CERT_NAME_FRIENDLY_DISPLAY_TYPE:
            {
                DWORD cbData = 0;

                CertGetCertificateContextProperty(
                    pCertContext,
                    CERT_FRIENDLY_NAME_PROP_ID,
                    NULL,                           // pvData
                    &cbData
                    );
                // Need at least one character, plus the null terminator
                if (cbData >= sizeof(WCHAR) * 2) {
                    LPWSTR pwszFriendlyName;

                    // Ensure the Friendly name is null terminated.
                    if (pwszFriendlyName = (LPWSTR) PkiZeroAlloc(
                            cbData + sizeof(WCHAR) * 2)) {
                        BOOL fResult;

                        fResult = CertGetCertificateContextProperty(
                            pCertContext,
                            CERT_FRIENDLY_NAME_PROP_ID,
                            pwszFriendlyName,
                            &cbData
                            );
                        if (fResult)
                            CopyNameStringW(
                                pwszFriendlyName,
                                pwszNameString,
                                cchNameString,
                                &cwszOut
                                );
                        PkiFree(pwszFriendlyName);
                        if (fResult)
                            goto CommonReturn;
                    }
                }
            }
            // Fall through

        case CERT_NAME_SIMPLE_DISPLAY_TYPE:
            rgpNameInfo[CERT_NAME_INFO_INDEX] = AllocAndGetCertNameInfo(
                pCertContext, dwFlags);
            rgpNameInfo[ALT_DIR_NAME_INFO_INDEX] = AllocAndGetAltDirNameInfo(
                pCertContext, dwFlags, &pAltNameInfo);

            if (GetAttrStringW(
                    NUM_SIMPLE_DISPLAY_ATTR_OID,
                    rgpszSimpleDisplayAttrOID,
                    rgpNameInfo,
                    pwszNameString,
                    cchNameString,
                    &cwszOut
                    )) goto CommonReturn;
            if (!GetAltNameUnicodeStringChoiceW(
                    CERT_ALT_NAME_RFC822_NAME,
                    pAltNameInfo,
                    pwszNameString,
                    cchNameString,
                    &cwszOut
                    )) goto NoSimpleDisplay;
            break;

        default:
            goto InvalidType;
    }

CommonReturn:
    for (i = 0; i < NAME_INFO_CNT; i++)
        PkiFree(rgpNameInfo[i]);
    PkiFree(pAltNameInfo);
    return cwszOut;

ErrorReturn:
    if (0 != cchNameString)
        // Always NULL terminate
        *pwszNameString = L'\0';
    cwszOut = 1;
    goto CommonReturn;

SET_ERROR(NoEmail, CRYPT_E_NOT_FOUND)
SET_ERROR(NoDNS, CRYPT_E_NOT_FOUND)
SET_ERROR(NoURL, CRYPT_E_NOT_FOUND)
SET_ERROR(NoUPN, CRYPT_E_NOT_FOUND)
SET_ERROR(NoRDN, CRYPT_E_NOT_FOUND)
SET_ERROR(NoAttr, CRYPT_E_NOT_FOUND)
SET_ERROR(NoSimpleDisplay, CRYPT_E_NOT_FOUND)
SET_ERROR(InvalidType, E_INVALIDARG)
}

//+-------------------------------------------------------------------------
//  Get the subject or issuer name from the certificate and
//  according to the specified format type, convert to a null terminated
//  char string.
//
//  CERT_NAME_ISSUER_FLAG can be set to get the issuer's name. Otherwise,
//  gets the subject's name.
//--------------------------------------------------------------------------
DWORD
WINAPI
CertGetNameStringA(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwType,
    IN DWORD dwFlags,
    IN void *pvTypePara,
    OUT OPTIONAL LPSTR pszNameString,
    IN DWORD cchNameString
    )
{
    DWORD cszOut;
    LPWSTR pwsz = NULL;
    DWORD cwsz;

    cwsz = CertGetNameStringW(
        pCertContext,
        dwType,
        dwFlags,
        pvTypePara,
        NULL,                   // pwsz
        0                       // cwsz
        );
    if (pwsz = (LPWSTR) PkiNonzeroAlloc(cwsz * sizeof(WCHAR)))
        CertGetNameStringW(
            pCertContext,
            dwType,
            dwFlags,
            pvTypePara,
            pwsz,
            cwsz
            );
    cszOut = ConvertUnicodeStringToAscii(pwsz, cwsz, pszNameString,
        cchNameString);

    PkiFree(pwsz);
    return cszOut;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\dblog.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dblog.h
//
//  Contents:   Public functions in dblog.cpp
//
//  History:    15-Sep-00   philh   created
//--------------------------------------------------------------------------

#ifndef __CRYPT32_DBLOG_H__
#define __CRYPT32_DBLOG_H__

//+=========================================================================
//  crypt32 Database Event Logging Functions
//==========================================================================
void
I_DBLogAttach();

void
I_DBLogDetach();

void
I_DBLogCrypt32Event(
    IN WORD wType,
    IN DWORD dwEventID,
    IN WORD wNumStrings,
    IN LPCWSTR *rgpwszStrings
    );

#endif  // __CRYPT32_DBLOG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\crypttls.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       crypttls.cpp
//
//  Contents:   Crypt Thread Local Storage (TLS) and OssGlobal "world"
//              installation and allocation functions
//
//  Functions:  I_CryptTlsDllMain
//              I_CryptAllocTls
//              I_CryptFreeTls
//              I_CryptGetTls
//              I_CryptSetTls
//              I_CryptDetachTls
//              I_CryptInstallOssGlobal
//              I_CryptUninstallOssGlobal
//              I_CryptGetOssGlobal
//
//              I_CryptInstallAsn1Module
//              I_CryptUninstallAsn1Module
//              I_CryptGetAsn1Encoder
//              I_CryptGetAsn1Decoder
//
//  Assumption:
//      For PROCESS_ATTACH or THREAD_ATTACH, I_CryptTlsDllMain is called
//      first. For PROCESS_DETACH or THREAD_DETACH, I_CryptTlsDllMain
//      is called last.
//
//  History:    17-Nov-96    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>
#include <asn1code.h>

#ifdef STATIC
#undef STATIC
#endif
#define STATIC

// CryptTls Entry types
#define FREE_CRYPTTLS       0
#define USER_CRYPTTLS       1
#define OSS_CRYPTTLS        2
#define ASN1_CRYPTTLS       3

typedef struct _ASN1_TLS_ENTRY {
    ASN1encoding_t pEnc;
    ASN1decoding_t pDec;
} ASN1_TLS_ENTRY, *PASN1_TLS_ENTRY;

// The following is reallocated and updated for each I_CryptAllocTls or
// I_CryptInstallOssGlobal. For I_CryptAllocTls, dwType is set to
// USER_CRYPTTLS and dwNext is zeroed.  For I_CryptInstallOssGlobal, dwType
// is set to OSS_CRYPTTLS and pvCtlTbl is updated with pvCtlTbl.
// For I_CryptFreeTls, dwType is set to FREE_CRYPTTLS and dwNext is
// updated with previous dwFreeProcessTlsHead.
//
// The array is indexed via hCryptTls -1 or hOssGlobal -1.
typedef struct _CRYPTTLS_PROCESS_ENTRY {
    DWORD                   dwType;
    union {
        void                    *pvCtlTbl;
        ASN1module_t            pMod;
        // Following is applicable to I_CryptFreeTls'ed entries.
        // Its the array index + 1 of the next free entry. A dwNext
        // of zero terminates.
        DWORD                   dwNext;
    };
} CRYPTTLS_PROCESS_ENTRY, *PCRYPTTLS_PROCESS_ENTRY;
static DWORD cProcessTls;
static PCRYPTTLS_PROCESS_ENTRY pProcessTls;


// The head of the entries freed by I_CryptFreeTls are indexed by the following.
// A 0 index indicates an empty free list.
//
// I_CryptAllocTls first checks this list before reallocating pProcessTls.
static DWORD dwFreeProcessTlsHead;

// The kernel32.dll Thread Local Storage (TLS) slot index
static DWORD iCryptTLS = 0xFFFFFFFF;

// The Thread Local Storage (TLS) referenced by iCryptTLS points to the
// following structure allocated for each thread. Once allocated, not
// reallocated. 
typedef struct _CRYPTTLS_THREAD_HDR CRYPTTLS_THREAD_HDR, *PCRYPTTLS_THREAD_HDR;
struct _CRYPTTLS_THREAD_HDR {
    DWORD                   cTls;
    void                    **ppvTls;   // reallocated
    PCRYPTTLS_THREAD_HDR    pNext;
    PCRYPTTLS_THREAD_HDR    pPrev;
};

// Linked list of all threads having CRYPTTLS
static PCRYPTTLS_THREAD_HDR pThreadTlsHead;


// Minimum number of entries allocated for pProcessTls and the ppvTls
//
// realloc optimization (MIN value is 1)
#define MIN_TLS_ALLOC_COUNT 16

// Used to protect the allocation of TLS and installation of OssGlobals
static CRITICAL_SECTION CryptTlsCriticalSection;


#define OSS_INIT_PROC_IDX                   0
#define OSS_TERM_PROC_IDX                   1
#define OSS_GET_OSS_GLOBAL_SIZE_PROC_IDX    2
#define OSS_SET_ENCODING_RULES_PROC_IDX     3
#define OSS_SET_DECODING_FLAGS_PROC_IDX     4
#define OSS_SET_ENCODING_FLAGS_PROC_IDX     5
#define OSS_PROC_CNT                        6

static LPSTR rgpszOssProc[OSS_PROC_CNT] = {
    "ossinit",                  // 0
    "ossterm",                  // 1
    "ossGetOssGlobalSize",      // 2
    "ossSetEncodingRules",      // 3
    "ossSetDecodingFlags",      // 4
    "ossSetEncodingFlags"       // 5
};

static void *rgpvOssProc[OSS_PROC_CNT];
static HMODULE hmsossDll = NULL;
static BOOL fLoadedOss = FALSE;

static void OssUnload()
{
    if (hmsossDll) {
        FreeLibrary(hmsossDll);
        hmsossDll = NULL;
    }
}

static void OssLoad()
{
    DWORD i;

    if (fLoadedOss)
        return;

    EnterCriticalSection(&CryptTlsCriticalSection);

    if (fLoadedOss)
        goto LeaveReturn;

    if (NULL == (hmsossDll = LoadLibraryA("msoss.dll")))
        goto msossLoadLibraryError;

    for (i = 0; i < OSS_PROC_CNT; i++) {
        if (NULL == (rgpvOssProc[i] = GetProcAddress(
                hmsossDll, rgpszOssProc[i])))
            goto msossGetProcAddressError;
    }

LeaveReturn:
    LeaveCriticalSection(&CryptTlsCriticalSection);
CommonReturn:
    fLoadedOss = TRUE;
    return;

ErrorReturn:
    LeaveCriticalSection(&CryptTlsCriticalSection);
    OssUnload();
    goto CommonReturn;
TRACE_ERROR(msossLoadLibraryError)
TRACE_ERROR(msossGetProcAddressError)
}


// nonstandard extension used : redefined extern to static
#pragma warning (disable: 4211)

typedef int  (DLL_ENTRY* pfnossinit)(struct ossGlobal *world,
							void *ctl_tbl);
static int  DLL_ENTRY ossinit(struct ossGlobal *world,
							void *ctl_tbl)
{
    if (hmsossDll)
        return ((pfnossinit) rgpvOssProc[OSS_INIT_PROC_IDX])(
            world,
            ctl_tbl);
    else
        return API_DLL_NOT_LINKED;
}

typedef void (DLL_ENTRY* pfnossterm)(struct ossGlobal *world);
static void DLL_ENTRY ossterm(struct ossGlobal *world)
{
    if (hmsossDll)
        ((pfnossterm) rgpvOssProc[OSS_TERM_PROC_IDX])(world);
}

typedef int (DLL_ENTRY* pfnossGetOssGlobalSize)(void);
static int DLL_ENTRY ossGetOssGlobalSize(void)
{
    if (hmsossDll)
        return ((pfnossGetOssGlobalSize)
            rgpvOssProc[OSS_GET_OSS_GLOBAL_SIZE_PROC_IDX])();
    else
        return 0;
}

typedef int (DLL_ENTRY* pfnossSetEncodingRules)(struct ossGlobal *world,
						ossEncodingRules rules);
static int DLL_ENTRY ossSetEncodingRules(struct ossGlobal *world,
						ossEncodingRules rules)
{
    if (hmsossDll)
        return ((pfnossSetEncodingRules)
            rgpvOssProc[OSS_SET_ENCODING_RULES_PROC_IDX])(
                world,
                rules);
    else
        return API_DLL_NOT_LINKED;
}

#if !DBG

typedef int (DLL_ENTRY* pfnossSetDecodingFlags)(struct ossGlobal *world,
							unsigned long flags);
static int DLL_ENTRY ossSetDecodingFlags(struct ossGlobal *world,
							unsigned long flags)
{
    if (hmsossDll)
        return ((pfnossSetDecodingFlags)
            rgpvOssProc[OSS_SET_DECODING_FLAGS_PROC_IDX])(
                world,
                flags);
    else
        return API_DLL_NOT_LINKED;
}

typedef int      (DLL_ENTRY* pfnossSetEncodingFlags)(struct ossGlobal *world,
							unsigned long flags);
static int DLL_ENTRY ossSetEncodingFlags(struct ossGlobal *world,
							unsigned long flags)
{
    if (hmsossDll)
        return ((pfnossSetEncodingFlags)
            rgpvOssProc[OSS_SET_ENCODING_FLAGS_PROC_IDX])(
                world,
                flags);
    else
        return API_DLL_NOT_LINKED;
}

#endif


//+-------------------------------------------------------------------------
//  Free the thread's CRYPT TLS
//
//  Upon entry/exit, in CryptTlsCriticalSection
//--------------------------------------------------------------------------
static void FreeCryptTls(
    IN PCRYPTTLS_THREAD_HDR pTlsHdr
    )
{
    if (pTlsHdr->pNext)
        pTlsHdr->pNext->pPrev = pTlsHdr->pPrev;
    if (pTlsHdr->pPrev)
        pTlsHdr->pPrev->pNext = pTlsHdr->pNext;
    else if (pTlsHdr == pThreadTlsHead)
        pThreadTlsHead = pTlsHdr->pNext;
    else {
        assert(pTlsHdr == pThreadTlsHead);
    }

    if (pTlsHdr->ppvTls)
        free(pTlsHdr->ppvTls);
    free(pTlsHdr);
}

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptTlsDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL fRet;
    PCRYPTTLS_THREAD_HDR pTlsHdr;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        if (!Pki_InitializeCriticalSection(&CryptTlsCriticalSection))
            goto InitCritSectionError;
        if ((iCryptTLS = TlsAlloc()) == 0xFFFFFFFF) {
            DeleteCriticalSection(&CryptTlsCriticalSection);
            goto TlsAllocError;
        }
        break;

    case DLL_PROCESS_DETACH:
    case DLL_THREAD_DETACH:
        if (pTlsHdr = (PCRYPTTLS_THREAD_HDR) TlsGetValue(iCryptTLS)) {
            DWORD cTls;
            DWORD cDetach = 0;
            DWORD i;

            cTls = pTlsHdr->cTls;

            EnterCriticalSection(&CryptTlsCriticalSection);
            assert(cTls <= cProcessTls);
            for (i = 0; i < cTls; i++) {
                void *pvTls;
                if (pvTls = pTlsHdr->ppvTls[i]) {
                    switch (pProcessTls[i].dwType) {
                        case OSS_CRYPTTLS:
                            // Following API is in delay loaded msoss.dll. 
                            __try {
                                ossterm((POssGlobal) pvTls);
                            } __except(EXCEPTION_EXECUTE_HANDLER) {
                            }
                            free(pvTls);
                            pTlsHdr->ppvTls[i] = NULL;
                            break;
                        case ASN1_CRYPTTLS:
                            {
                                PASN1_TLS_ENTRY pAsn1TlsEntry =
                                    (PASN1_TLS_ENTRY) pvTls;

                                if (pAsn1TlsEntry->pEnc)
                                    ASN1_CloseEncoder(pAsn1TlsEntry->pEnc);
                                if (pAsn1TlsEntry->pDec)
                                    ASN1_CloseDecoder(pAsn1TlsEntry->pDec);
                                free(pvTls);
                                pTlsHdr->ppvTls[i] = NULL;
                            }
                            break;
                        case USER_CRYPTTLS:
                            cDetach++;
                            break;
                        default:
                            assert(FREE_CRYPTTLS == pProcessTls[i].dwType);
                    }

                }
            }

            FreeCryptTls(pTlsHdr);
            TlsSetValue(iCryptTLS, 0);
            
            LeaveCriticalSection(&CryptTlsCriticalSection);
            assert(cDetach == 0);
        }

        if (ulReason == DLL_PROCESS_DETACH) {
            while(pThreadTlsHead)
                FreeCryptTls(pThreadTlsHead);

            if (pProcessTls) {
                free(pProcessTls);
                pProcessTls = NULL;
            }
            cProcessTls = 0;
            dwFreeProcessTlsHead = 0;

            OssUnload();
            DeleteCriticalSection(&CryptTlsCriticalSection);
            TlsFree(iCryptTLS);
            iCryptTLS = 0xFFFFFFFF;
        }
        break;

    default:
        break;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(InitCritSectionError)
TRACE_ERROR(TlsAllocError)
}

//+-------------------------------------------------------------------------
//  Get a pointer to the Crypt TLS entries. Check that the hCryptTls is
//  included in the list of entries. If hCryptTls isn't included and
//  allocation isn't inhibited, alloc/realloc the array of TLS entries.
//
//  Also verifies the hCryptTls handle.
//--------------------------------------------------------------------------
STATIC void **GetCryptTls(
    IN HCRYPTTLS hCryptTls,
    IN BOOL fInhibitAlloc       // TRUE for I_CryptDetachTls
    )
{
    PCRYPTTLS_THREAD_HDR pTlsHdr;
    DWORD cTls;
    void **ppvTls;
    DWORD i;

    if (0 == hCryptTls--) {
        SetLastError((DWORD) E_INVALIDARG);
        return NULL;
    }

    pTlsHdr = (PCRYPTTLS_THREAD_HDR) TlsGetValue(iCryptTLS);
    cTls = pTlsHdr ? pTlsHdr->cTls : 0;
    if (hCryptTls < cTls)
        return pTlsHdr->ppvTls;

    if (fInhibitAlloc)
        return NULL;

    EnterCriticalSection(&CryptTlsCriticalSection);

    if (hCryptTls >= cProcessTls)
        goto InvalidArg;
    assert(cTls < cProcessTls);

    // Note for !DBG: realloc is mapped to LocalReAlloc. For LocalRealloc()
    // the previous memory pointer can't be NULL.
    if (pTlsHdr) {
        if (cProcessTls > MIN_TLS_ALLOC_COUNT) {
            if (NULL == (ppvTls = (void **) realloc(pTlsHdr->ppvTls,
                    cProcessTls * sizeof(void *))))
                goto OutOfMemory;
        } else {
            ppvTls = pTlsHdr->ppvTls;
            assert(ppvTls);
        }
    } else {
        DWORD cAllocTls = (cProcessTls > MIN_TLS_ALLOC_COUNT) ?
            cProcessTls : MIN_TLS_ALLOC_COUNT;
        if (NULL == (ppvTls = (void **) malloc(cAllocTls * sizeof(void *))))
            goto OutOfMemory;
        if (NULL == (pTlsHdr = (PCRYPTTLS_THREAD_HDR) malloc(
                sizeof(CRYPTTLS_THREAD_HDR)))) {
            free(ppvTls);
            goto OutOfMemory;
        }

        if (!TlsSetValue(iCryptTLS, pTlsHdr)) {
            free(pTlsHdr);
            free(ppvTls);
            goto TlsSetValueError;
        }

        pTlsHdr->pPrev = NULL;
        pTlsHdr->pNext = pThreadTlsHead;
        if (pThreadTlsHead)
            pThreadTlsHead->pPrev = pTlsHdr;
        pThreadTlsHead = pTlsHdr;
    }

    for (i = cTls; i < cProcessTls; i++)
        ppvTls[i] = NULL;
    pTlsHdr->ppvTls = ppvTls;
    pTlsHdr->cTls = cProcessTls;

CommonReturn:
    LeaveCriticalSection(&CryptTlsCriticalSection);
    return ppvTls;

ErrorReturn:
    ppvTls = NULL;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
TRACE_ERROR(TlsSetValueError)
}

//+-------------------------------------------------------------------------
//  Install a thread local storage entry and return a handle for future access.
//--------------------------------------------------------------------------
HCRYPTTLS
WINAPI
I_CryptAllocTls()
{
    HCRYPTTLS hCryptTls;

    EnterCriticalSection(&CryptTlsCriticalSection);

    if (dwFreeProcessTlsHead) {
        PCRYPTTLS_PROCESS_ENTRY pEntry;

        hCryptTls = (HCRYPTTLS) dwFreeProcessTlsHead;
        assert(hCryptTls <= cProcessTls);
        pEntry = &pProcessTls[dwFreeProcessTlsHead - 1];
        assert(FREE_CRYPTTLS == pEntry->dwType);
        assert(pEntry->dwNext <= cProcessTls);

        pEntry->dwType = USER_CRYPTTLS;
        dwFreeProcessTlsHead = pEntry->dwNext;
        pEntry->dwNext = 0;
    } else {
        PCRYPTTLS_PROCESS_ENTRY pNewProcessTls;

        // Note for !DBG: realloc is mapped to LocalReAlloc. For LocalRealloc()
        // the previous memory pointer can't be NULL.
        if (pProcessTls) {
            if (cProcessTls + 1 > MIN_TLS_ALLOC_COUNT)
                pNewProcessTls = (PCRYPTTLS_PROCESS_ENTRY) realloc(pProcessTls,
                    (cProcessTls + 1) * sizeof(CRYPTTLS_PROCESS_ENTRY));
            else
                pNewProcessTls = pProcessTls;
        } else
            pNewProcessTls = (PCRYPTTLS_PROCESS_ENTRY) malloc(
                (MIN_TLS_ALLOC_COUNT) * sizeof(CRYPTTLS_PROCESS_ENTRY));

        if (pNewProcessTls) {
            pNewProcessTls[cProcessTls].dwType = USER_CRYPTTLS;
            pNewProcessTls[cProcessTls].dwNext = 0;
            hCryptTls = (HCRYPTTLS) ++cProcessTls;
            pProcessTls = pNewProcessTls;
        } else {
            SetLastError((DWORD) E_OUTOFMEMORY);
            hCryptTls = 0;
        }
    }

    LeaveCriticalSection(&CryptTlsCriticalSection);
    return hCryptTls;
}

//+-------------------------------------------------------------------------
//  Called at DLL_PROCESS_DETACH to free a thread local storage entry.
//  Optionally, calls the callback for each thread having a non-NULL pvTls.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptFreeTls(
    IN HCRYPTTLS hCryptTls,
    IN OPTIONAL PFN_CRYPT_FREE pfnFree
    )
{
    BOOL fResult;
    DWORD dwType;
    PCRYPTTLS_THREAD_HDR pThreadTls;

    if (0 == hCryptTls--) {
        SetLastError((DWORD) E_INVALIDARG);
        return FALSE;
    }

    EnterCriticalSection(&CryptTlsCriticalSection);

    if (hCryptTls >= cProcessTls)
        goto InvalidArg;

    dwType = pProcessTls[hCryptTls].dwType;
    if (!(OSS_CRYPTTLS == dwType || USER_CRYPTTLS == dwType ||
            ASN1_CRYPTTLS == dwType))
        goto InvalidArg;

    // Iterate through the threads having CRYPTTLS
    pThreadTls = pThreadTlsHead;
    while (pThreadTls) {
        PCRYPTTLS_THREAD_HDR pThreadTlsNext;

        pThreadTlsNext = pThreadTls->pNext;
        if (pThreadTls->cTls > hCryptTls) {
            void *pvTls = pThreadTls->ppvTls[hCryptTls];
            if (pvTls) {
                pThreadTls->ppvTls[hCryptTls] = NULL;

                if (OSS_CRYPTTLS == dwType) {
                    // Following API is in delay loaded msoss.dll. 
                    __try {
                        ossterm((POssGlobal) pvTls);
                    } __except(EXCEPTION_EXECUTE_HANDLER) {
                    }
                    free(pvTls);
                } else if (ASN1_CRYPTTLS == dwType) {
                    PASN1_TLS_ENTRY pAsn1TlsEntry =
                        (PASN1_TLS_ENTRY) pvTls;

                    if (pAsn1TlsEntry->pEnc)
                        ASN1_CloseEncoder(pAsn1TlsEntry->pEnc);
                    if (pAsn1TlsEntry->pDec)
                        ASN1_CloseDecoder(pAsn1TlsEntry->pDec);

                    free(pvTls);
                } else if (pfnFree) {
                    // Don't call the callback holding the critical section
                    LeaveCriticalSection(&CryptTlsCriticalSection);
                    pfnFree(pvTls);
                    EnterCriticalSection(&CryptTlsCriticalSection);

                    // In case this thread gets deleted, start over at
                    // the beginning.
                    pThreadTlsNext = pThreadTlsHead;
                }
            }
        }

        pThreadTls = pThreadTlsNext;
    }

    // Insert in beginning of process free list
    pProcessTls[hCryptTls].dwType = FREE_CRYPTTLS;
    pProcessTls[hCryptTls].dwNext = dwFreeProcessTlsHead;
    dwFreeProcessTlsHead = hCryptTls + 1;
    fResult = TRUE;

CommonReturn:
    LeaveCriticalSection(&CryptTlsCriticalSection);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
}

//+-------------------------------------------------------------------------
//  Get the thread specific pointer specified by the
//  hCryptTls returned by I_CryptAllocTls().
//
//  Returns NULL for an error or uninitialized or NULL pointer.
//--------------------------------------------------------------------------
void *
WINAPI
I_CryptGetTls(
    IN HCRYPTTLS hCryptTls
    )
{
    void **ppvTls;
    void *pvTls;
    if (ppvTls = GetCryptTls(
            hCryptTls,
            FALSE)) {       // fInhibitAlloc
        if (NULL == (pvTls = ppvTls[hCryptTls - 1]))
            SetLastError(NO_ERROR);
    } else
        pvTls = NULL;
    return pvTls;
}

//+-------------------------------------------------------------------------
//  Set the thread specific pointer specified by the
//  hCryptTls returned by I_CryptAllocTls().
//
//  Returns FALSE for an invalid handle or unable to allocate memory.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptSetTls(
    IN HCRYPTTLS hCryptTls,
    IN void *pvTls
    )
{
    void **ppvTls;
    if (ppvTls = GetCryptTls(
            hCryptTls,
            FALSE)) {       // fInhibitAlloc
        ppvTls[hCryptTls - 1] = pvTls;
        return TRUE;
    } else
        return FALSE;
}

//+-------------------------------------------------------------------------
//  Called at DLL_THREAD_DETACH to free the thread's
//  TLS entry specified by the hCryptTls. Returns the thread specific pointer
//  to be freed by the caller.
//
//  Note, at DLL_PROCESS_DETACH, I_CryptFreeTls should be called instead.
//--------------------------------------------------------------------------
void *
WINAPI
I_CryptDetachTls(
    IN HCRYPTTLS hCryptTls
    )
{
    void **ppvTls;
    void *pvTls;
    if (ppvTls = GetCryptTls(
            hCryptTls,
            TRUE)) {        // fInhibitAlloc
        if (pvTls = ppvTls[hCryptTls - 1])
            ppvTls[hCryptTls - 1] = NULL;
        else
            SetLastError(NO_ERROR);
    } else
        pvTls = NULL;
    return pvTls;
}

//+-------------------------------------------------------------------------
//  Install an OssGlobal entry and return a handle for future access.
//
//  Each thread has its own copy of OssGlobal. Allocation and
//  initialization are deferred until first referenced by the thread.
//
//  The parameter, pvCtlTbl is passed to ossinit() to initialize the OssGlobal.
//
//  I_CryptGetOssGlobal must be called with the handled returned by
//  I_CryptInstallOssGlobal to get the thread specific OssGlobal.
//
//  Currently, dwFlags and pvReserved aren't used and must be set to 0.
//--------------------------------------------------------------------------
HCRYPTOSSGLOBAL
WINAPI
I_CryptInstallOssGlobal(
    IN void *pvCtlTbl,
    IN DWORD dwFlags,
    IN void *pvReserved
    )
{
    HCRYPTOSSGLOBAL hOssGlobal;

    if (hOssGlobal = (HCRYPTOSSGLOBAL) I_CryptAllocTls()) {
        // Since pProcessTls can be reallocated in another thread
        // need CriticalSection
        EnterCriticalSection(&CryptTlsCriticalSection);
        pProcessTls[hOssGlobal - 1].dwType = OSS_CRYPTTLS;
        pProcessTls[hOssGlobal - 1].pvCtlTbl = pvCtlTbl;
        LeaveCriticalSection(&CryptTlsCriticalSection);
    }
    return hOssGlobal;
}

//+-------------------------------------------------------------------------
//  Called at DLL_PROCESS_DETACH to uninstall an OssGlobal entry. Iterate
//  through the threads and frees their allocated copy of OssGlobal.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptUninstallOssGlobal(
    IN HCRYPTOSSGLOBAL hOssGlobal
    )
{
    return I_CryptFreeTls(
        (HCRYPTTLS) hOssGlobal,
        NULL                        // pfnFree
        );
}

//+-------------------------------------------------------------------------
//  Get the thread specific pointer to the OssGlobal specified by the
//  hOssGlobal returned by CryptInstallOssGlobal. If the
//  OssGlobal doesn't exist, then, its allocated and initialized using
//  the pvCtlTbl associated with hOssGlobal.
//--------------------------------------------------------------------------
POssGlobal
WINAPI
I_CryptGetOssGlobal(
    IN HCRYPTOSSGLOBAL hOssGlobal
    )
{
    POssGlobal pog;
    void **ppvTls;
    DWORD iOssGlobal;
    DWORD dwType;
    void *pvCtlTbl;
    DWORD dwExceptionCode;
    int cbOssGlobalSize; 

    if (NULL == (ppvTls = GetCryptTls(
                                (HCRYPTTLS) hOssGlobal,
                                FALSE)))        // fInhibitAlloc
        return NULL;

    iOssGlobal = (DWORD) hOssGlobal - 1;
    if (pog = (POssGlobal) ppvTls[iOssGlobal])
        return pog;

    // Since pProcessTls can be reallocated in another thread
    // need CriticalSection
    EnterCriticalSection(&CryptTlsCriticalSection);
    dwType = pProcessTls[iOssGlobal].dwType;
    pvCtlTbl = pProcessTls[iOssGlobal].pvCtlTbl;
    LeaveCriticalSection(&CryptTlsCriticalSection);
    if (OSS_CRYPTTLS != dwType || NULL == pvCtlTbl)
        goto InvalidArg;

    __try {
        // Attempt to do delay, demand loading of msoss.dll
        OssLoad();

        if (0 >= (cbOssGlobalSize = ossGetOssGlobalSize()))
            goto ossGetOssGlobalSizeError;
        if (NULL == (pog = (POssGlobal) malloc(cbOssGlobalSize)))
            goto OutOfMemory;
        if (0 != ossinit(pog, pvCtlTbl))
            goto ossinitError;
        if (0 != ossSetEncodingRules(pog, OSS_DER))
            goto SetEncodingRulesError;
#if DBG
        if (!DbgInitOSS(pog))
            goto DbgInitOSSError;
#else
        if (0 != ossSetEncodingFlags(pog, NOTRAPPING | FRONT_ALIGN))
            goto SetEncodingFlagsError;
        if (0 != ossSetDecodingFlags(pog, NOTRAPPING | RELAXBER))
            goto SetDecodingFlagsError;
#endif
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwExceptionCode = GetExceptionCode();
        goto msossLoadLibraryException;
    }

    ppvTls[iOssGlobal] = pog;
CommonReturn:
    return pog;

ErrorReturn:
    if (pog) {
        free(pog);
        pog = NULL;
    }
    goto CommonReturn;

SET_ERROR(ossGetOssGlobalSizeError, ERROR_MOD_NOT_FOUND)
SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(ossinitError)
TRACE_ERROR(SetEncodingRulesError)
#if DBG
TRACE_ERROR(DbgInitOSSError)
#else
TRACE_ERROR(SetEncodingFlagsError)
TRACE_ERROR(SetDecodingFlagsError)
#endif
SET_ERROR_VAR(msossLoadLibraryException, dwExceptionCode)
}

//+-------------------------------------------------------------------------
//  Install an Asn1 module entry and return a handle for future access.
//
//  Each thread has its own copy of the decoder and encoder associated
//  with the Asn1 module. Creation is deferred until first referenced by
//  the thread.
//
//  I_CryptGetAsn1Encoder or I_CryptGetAsn1Decoder must be called with the
//  handle returned by I_CryptInstallAsn1Module to get the thread specific
//  Asn1 encoder or decoder.
//
//  Currently, dwFlags and pvReserved aren't used and must be set to 0.
//--------------------------------------------------------------------------
HCRYPTASN1MODULE
WINAPI
I_CryptInstallAsn1Module(
    IN ASN1module_t pMod,
    IN DWORD dwFlags,
    IN void *pvReserved
    )
{
    HCRYPTASN1MODULE hAsn1Module;

    if (hAsn1Module = (HCRYPTOSSGLOBAL) I_CryptAllocTls()) {
        // Since pProcessTls can be reallocated in another thread
        // need CriticalSection
        EnterCriticalSection(&CryptTlsCriticalSection);
        pProcessTls[hAsn1Module - 1].dwType = ASN1_CRYPTTLS;
        pProcessTls[hAsn1Module - 1].pMod = pMod;
        LeaveCriticalSection(&CryptTlsCriticalSection);
    }
    return hAsn1Module;
}

//+-------------------------------------------------------------------------
//  Called at DLL_PROCESS_DETACH to uninstall an hAsn1Module entry. Iterates
//  through the threads and frees their created Asn1 encoders and decoders.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptUninstallAsn1Module(
    IN HCRYPTASN1MODULE hAsn1Module
    )
{
    return I_CryptFreeTls(
        (HCRYPTTLS) hAsn1Module,
        NULL                        // pfnFree
        );
}


STATIC
PASN1_TLS_ENTRY
WINAPI
I_CryptGetAsn1Tls(
    IN HCRYPTASN1MODULE hAsn1Module
    )
{
    PASN1_TLS_ENTRY pAsn1TlsEntry;
    void **ppvTls;
    DWORD iAsn1Module;

    if (NULL == (ppvTls = GetCryptTls(
                                (HCRYPTTLS) hAsn1Module,
                                FALSE)))        // fInhibitAlloc
        return NULL;

    iAsn1Module = (DWORD) hAsn1Module - 1;
    if (pAsn1TlsEntry = (PASN1_TLS_ENTRY) ppvTls[iAsn1Module])
        return pAsn1TlsEntry;

    if (NULL == (pAsn1TlsEntry = (PASN1_TLS_ENTRY) malloc(
            sizeof(ASN1_TLS_ENTRY))))
        goto OutOfMemory;
    memset(pAsn1TlsEntry, 0, sizeof(ASN1_TLS_ENTRY));

    ppvTls[iAsn1Module] = pAsn1TlsEntry;
CommonReturn:
    return pAsn1TlsEntry;

ErrorReturn:
    goto CommonReturn;

SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
}


//+-------------------------------------------------------------------------
//  Get the thread specific pointer to the Asn1 encoder specified by the
//  hAsn1Module returned by CryptInstallAsn1Module. If the
//  encoder doesn't exist, then, its created using the Asn1 module
//  associated with hAsn1Module.
//--------------------------------------------------------------------------
ASN1encoding_t
WINAPI
I_CryptGetAsn1Encoder(
    IN HCRYPTASN1MODULE hAsn1Module
    )
{
    PASN1_TLS_ENTRY pAsn1TlsEntry;
    ASN1encoding_t pEnc;
    DWORD iAsn1Module;
    DWORD dwType;
    ASN1module_t pMod;
    ASN1error_e Asn1Err;

    if (NULL == (pAsn1TlsEntry = I_CryptGetAsn1Tls(hAsn1Module)))
        return NULL;
    if (pEnc = pAsn1TlsEntry->pEnc)
        return pEnc;

    iAsn1Module = (DWORD) hAsn1Module - 1;

    // Since pProcessTls can be reallocated in another thread
    // need CriticalSection
    EnterCriticalSection(&CryptTlsCriticalSection);
    dwType = pProcessTls[iAsn1Module].dwType;
    pMod = pProcessTls[iAsn1Module].pMod;
    LeaveCriticalSection(&CryptTlsCriticalSection);
    if (ASN1_CRYPTTLS != dwType || NULL == pMod)
        goto InvalidArg;

    Asn1Err = ASN1_CreateEncoder(
        pMod,
        &pEnc,
        NULL,           // pbBuf
        0,              // cbBufSize
        NULL            // pParent
        );
    if (ASN1_SUCCESS != Asn1Err)
        goto CreateEncoderError;

    pAsn1TlsEntry->pEnc = pEnc;
CommonReturn:
    return pEnc;

ErrorReturn:
    pEnc = NULL;
    goto CommonReturn;

SET_ERROR_VAR(CreateEncoderError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(InvalidArg, E_INVALIDARG)
}

//+-------------------------------------------------------------------------
//  Get the thread specific pointer to the Asn1 decoder specified by the
//  hAsn1Module returned by CryptInstallAsn1Module. If the
//  decoder doesn't exist, then, its created using the Asn1 module
//  associated with hAsn1Module.
//--------------------------------------------------------------------------
ASN1decoding_t
WINAPI
I_CryptGetAsn1Decoder(
    IN HCRYPTASN1MODULE hAsn1Module
    )
{
    PASN1_TLS_ENTRY pAsn1TlsEntry;
    ASN1decoding_t pDec;
    DWORD iAsn1Module;
    DWORD dwType;
    ASN1module_t pMod;
    ASN1error_e Asn1Err;

    if (NULL == (pAsn1TlsEntry = I_CryptGetAsn1Tls(hAsn1Module)))
        return NULL;
    if (pDec = pAsn1TlsEntry->pDec)
        return pDec;

    iAsn1Module = (DWORD) hAsn1Module - 1;

    // Since pProcessTls can be reallocated in another thread
    // need CriticalSection
    EnterCriticalSection(&CryptTlsCriticalSection);
    dwType = pProcessTls[iAsn1Module].dwType;
    pMod = pProcessTls[iAsn1Module].pMod;
    LeaveCriticalSection(&CryptTlsCriticalSection);
    if (ASN1_CRYPTTLS != dwType || NULL == pMod)
        goto InvalidArg;

    Asn1Err = ASN1_CreateDecoder(
        pMod,
        &pDec,
        NULL,           // pbBuf
        0,              // cbBufSize
        NULL            // pParent
        );
    if (ASN1_SUCCESS != Asn1Err)
        goto CreateDecoderError;

    pAsn1TlsEntry->pDec = pDec;
CommonReturn:
    return pDec;

ErrorReturn:
    pDec = NULL;
    goto CommonReturn;

SET_ERROR_VAR(CreateDecoderError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(InvalidArg, E_INVALIDARG)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\dblog.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       dblog.cpp
//
//  Contents:   Database Log Event APIs
//
//  Functions:  I_DBLogCrypt32Event
//              I_DBLogAttach
//              I_DBLogDetach
//
//  History:    11-Oct-00    philh   created
//--------------------------------------------------------------------------


#include "global.hxx"
#include <dbgdef.h>

#ifdef ROOT_AUTO_UPDATE_DOGFOOD

#ifdef STATIC
#undef STATIC
#endif
#define STATIC

#include "sql.h"
#include "sqlext.h"
#include "sqltypes.h"
#include "odbcss.h"

#define SQL_CALL_SUCCESS(status) (status == SQL_SUCCESS || status == SQL_SUCCESS_WITH_INFO)
				 
#if DBG || DEBUG
#define DebugPrint(a) _DebugPrintW a
void
__cdecl
_DebugPrintW(
    LPCWSTR szFormat,
    ...
    )
{
    WCHAR szBuffer[512];
    va_list ap;

    va_start(ap, szFormat);
    vswprintf(szBuffer, szFormat, ap);
    OutputDebugStringW(szBuffer);
}

int debugLine = __LINE__;
#define DEBUG_MARKER debugLine = __LINE__

#else

#define DebugPrint(a)
#define DEBUG_MARKER

#endif

#define SHA1_HASH_LEN               20
#define SHA1_HASH_NAME_LEN          (2 * SHA1_HASH_LEN)

typedef struct _DBLOG_EVENT_DATA {
    DWORD               dwStatus;
    DWORD               dwCPU64;
    TIMESTAMP_STRUCT    TimeStamp;
    WCHAR               wszOperation[16];
    WCHAR               wszHash[SHA1_HASH_NAME_LEN + 1];
    WCHAR               wszSubject[64];
    WCHAR               wszBuildLab[64];
    WCHAR               wszMachineName[32];
} DBLOG_EVENT_DATA, *PDBLOG_EVENT_DATA;


void
I_DBLogAttach()
{
}

void
I_DBLogDetach()
{
}

DWORD WINAPI I_DBLogCrypt32EventThreadProc(
    LPVOID lpThreadParameter
    )
{
    PDBLOG_EVENT_DATA pEventData = (PDBLOG_EVENT_DATA) lpThreadParameter;

	SQLRETURN RetCode = SQL_SUCCESS;
	HSTMT hStmt = NULL;
	HENV	hEnv = NULL, hDbc = NULL;

    __try {
		__try {
            RetCode = SQLAllocHandle(
                SQL_HANDLE_ENV, 
                SQL_NULL_HANDLE,
                &hEnv
                );

            if(!SQL_CALL_SUCCESS(RetCode)) {
                DEBUG_MARKER;
                __leave;
            }

            RetCode = SQLSetEnvAttr(
                hEnv,
                SQL_ATTR_ODBC_VERSION,
                (SQLPOINTER) SQL_OV_ODBC3,	
                SQL_IS_INTEGER
                );

            if(!SQL_CALL_SUCCESS(RetCode)) {
                DEBUG_MARKER;
                __leave;
            }

            RetCode = SQLAllocHandle(
                SQL_HANDLE_DBC,
                hEnv,
                &hDbc
                );

            if(!SQL_CALL_SUCCESS(RetCode)) {
                DEBUG_MARKER;
                __leave;
            }

            RetCode = SQLSetConnectAttr(
                hDbc, 
                SQL_ATTR_LOGIN_TIMEOUT, 
                (SQLPOINTER) 120,
                SQL_IS_UINTEGER
                );

            if(!SQL_CALL_SUCCESS(RetCode)) {
                DEBUG_MARKER;
                __leave;
            }

            RetCode = SQLSetConnectAttr(
                hDbc, 
                SQL_COPT_SS_INTEGRATED_SECURITY, 
                (SQLPOINTER) SQL_IS_OFF,
                SQL_IS_INTEGER
                );

            if(!SQL_CALL_SUCCESS(RetCode)) {
                DEBUG_MARKER;
                __leave;
            }

			{
				SQLWCHAR szConnect[1024];
				SQLSMALLINT cbConnect = 0;

				SQLWCHAR szInConnect[] = L"DRIVER=SQL Server;SERVER=kschutz-team2;UID=crypt32;PWD=crypt32;DATABASE=Crypt32";

				RetCode = SQLDriverConnectW(
					hDbc,
					NULL,
					szInConnect,
					SQL_NTS,
					szConnect,
					sizeof(szConnect) / sizeof(szConnect[0]),
					&cbConnect,
					SQL_DRIVER_NOPROMPT
					);

				if(!SQL_CALL_SUCCESS(RetCode)) {
					DEBUG_MARKER;
					__leave;
				}
			}

			RetCode = SQLAllocHandle(
				SQL_HANDLE_STMT,
				hDbc, 
				&hStmt
				);

			if(!SQL_CALL_SUCCESS(RetCode)) {
				DEBUG_MARKER;
				__leave;
			}

			WCHAR szStatement[] = 
				L"INSERT INTO AddRoot2 ("
				L"OPERATION,"
				L"STATUS,"
				L"TIMESTAMP,"
				L"HASH,"
				L"SUBJECT,"
				L"MACHINENAME,"
				L"BUILDLAB,"
				L"CPU64"
				L") VALUES (?,?,?,?,?,?,?,?)";

			RetCode = SQLPrepareW(
				hStmt,
				szStatement, 
				SQL_NTS
				);

			if(!SQL_CALL_SUCCESS(RetCode)) {
				DEBUG_MARKER;
				__leave;
			}

			SQLUSMALLINT iParamNo = 1;

			//
			// OPERATION
			//
			SQLLEN cbOperation = SQL_NTS;
			SQLBindParameter(
				hStmt, 
				iParamNo++, 
				SQL_PARAM_INPUT,
				SQL_C_WCHAR,
				SQL_WCHAR,
				sizeof(pEventData->wszOperation) / sizeof(WCHAR),
				0,
				pEventData->wszOperation,
				0,
				&cbOperation
				);

			//
			// STATUS
			//
			SQLLEN cbStatus = 0;
			SQLBindParameter(
				hStmt, 
				iParamNo++, 
				SQL_PARAM_INPUT,
				SQL_C_LONG,
				SQL_INTEGER,
				0,
				0,
				&pEventData->dwStatus,
				0,
				&cbStatus
				);

			//
			// TIMESTAMP
			//

			SQLLEN cbTimeStamp = 0;
			SQLBindParameter(
				hStmt, 
				iParamNo++, 
				SQL_PARAM_INPUT,
				SQL_C_TIMESTAMP, 
				SQL_TIMESTAMP,
				19,
				0,
				&pEventData->TimeStamp,
				0,
				&cbTimeStamp
				);

			//
			// HASH
			//

			SQLLEN cbHash = SQL_NTS;
			SQLBindParameter(
				hStmt, 
				iParamNo++, 
				SQL_PARAM_INPUT,
				SQL_C_WCHAR,
				SQL_WCHAR,
				sizeof(pEventData->wszHash) / sizeof(WCHAR),
				0,
				pEventData->wszHash,
				0,
				&cbHash
				);

			//
			// SUBJECT
			//

			SQLLEN cbSubject = SQL_NTS;
			SQLBindParameter(
				hStmt, 
				iParamNo++, 
				SQL_PARAM_INPUT,
				SQL_C_WCHAR,
				SQL_WCHAR,
				sizeof(pEventData->wszSubject) / sizeof(WCHAR),
				0,
				pEventData->wszSubject,
				0,
				&cbSubject
				);

			//
			// MACHINENAME
			//

			SQLLEN cbMachineName = SQL_NTS;
			SQLBindParameter(
				hStmt, 
				iParamNo++, 
				SQL_PARAM_INPUT,
				SQL_C_WCHAR,
				SQL_WCHAR,
				sizeof(pEventData->wszMachineName) / sizeof(WCHAR),
				0,
				pEventData->wszMachineName,
				0,
				&cbMachineName
				);

			//
			// BUILDLAB
			//

			SQLLEN cbBuildLab = SQL_NTS;
			SQLBindParameter(
				hStmt, 
				iParamNo++, 
				SQL_PARAM_INPUT,
				SQL_C_WCHAR,
				SQL_WCHAR,
				sizeof(pEventData->wszBuildLab) / sizeof(WCHAR),
				0,
				pEventData->wszBuildLab,
				0,
				&cbBuildLab
				);

			//
			// CPU64
			//
			SQLLEN cbCPU64 = 0;
			SQLBindParameter(
				hStmt, 
				iParamNo++, 
				SQL_PARAM_INPUT,
				SQL_C_TINYINT,
				SQL_TINYINT,
				0,
				0,
				&pEventData->dwCPU64,
				0,
				&cbCPU64
				);


			RetCode = SQLExecute(hStmt);
			DEBUG_MARKER;
		}
		__finally {

		}

		if (!SQL_CALL_SUCCESS(RetCode)) {

			SDWORD		swError;
			SQLWCHAR	szErrorMsg[SQL_MAX_MESSAGE_LENGTH];
			SWORD		swErrorMsg;
			SQLWCHAR	szSQLState[50];

			SQLErrorW(
				hEnv, 
				hDbc, 
				hStmt, 
				szSQLState,
				&swError, 
				szErrorMsg, 
				SQL_MAX_MESSAGE_LENGTH - 1, 
				&swErrorMsg
				);

			DebugPrint(
				(L"I_DBLogCrypt32EventThreadProc: Error (%d) - %s (%s)\n", 
				debugLine,
				szErrorMsg,
				szSQLState)
				);
		}

		if (hStmt) {
			SQLFreeHandle(SQL_HANDLE_STMT, hStmt);
		}


        if (hDbc) {
            SQLDisconnect(hDbc);
            SQLFreeHandle(SQL_HANDLE_DBC, hDbc);
        }

        if (hEnv) {
            SQLFreeHandle(SQL_HANDLE_ENV, hEnv);
        }
			
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        DebugPrint(
            (L"I_DBLogCrypt32EventThreadProc: Exception Error (%d)\n", 
            GetExceptionCode())
            );
        RetCode = SQL_ERROR;
    }

    PkiFree(pEventData);


    DebugPrint(
        (L"I_DBLogCrypt32EventThreadProc %s\n", 
        (SQL_CALL_SUCCESS(RetCode) ? L"succeeded" : L"failed"))
        );

	return 0;
}

void
I_DBLogCrypt32Event(
    IN WORD wType,
    IN DWORD dwEventID,
    IN WORD wNumStrings,
    IN LPCWSTR *rgpwszStrings
    )
{
    PDBLOG_EVENT_DATA pEventData = NULL;
    HANDLE hThread = NULL;

    if (NULL == (pEventData = (PDBLOG_EVENT_DATA) PkiZeroAlloc(
            sizeof(DBLOG_EVENT_DATA))))
        goto OutOfMemory;

    switch (dwEventID) {
        case MSG_ROOT_AUTO_UPDATE_INFORMATIONAL:
        case MSG_UNTRUSTED_ROOT_INFORMATIONAL:
        case MSG_PARTIAL_CHAIN_INFORMATIONAL:
            switch (dwEventID) {
                case MSG_ROOT_AUTO_UPDATE_INFORMATIONAL:
                    // Successful auto update of third-party root certificate::
                    // Subject: <%1> Sha1 thumbprint: <%2>
                    wcscpy(pEventData->wszOperation, L"AddCert");
                    break;
                case MSG_UNTRUSTED_ROOT_INFORMATIONAL:
                    // Untrusted root certificate:: Subject: <%1>
                    // Sha1 thumbprint: <%2>
                    wcscpy(pEventData->wszOperation, L"UntrustedRoot");
                    break;
                case MSG_PARTIAL_CHAIN_INFORMATIONAL:
                    // Partial Chain:: Issuer: <%1>
                    // Subject Sha1 thumbprint: <%2>
                    wcscpy(pEventData->wszOperation, L"PartialChain");
                    break;
            }
            if (2 <= wNumStrings) {
                wcsncpy(pEventData->wszSubject, rgpwszStrings[0],
                    sizeof(pEventData->wszSubject) / sizeof(WCHAR) - 1);
                wcsncpy(pEventData->wszHash, rgpwszStrings[1],
                    sizeof(pEventData->wszHash) / sizeof(WCHAR) - 1);
            }
            break;

        case MSG_ROOT_LIST_AUTO_UPDATE_URL_RETRIEVAL_INFORMATIONAL:
            // Successful auto update of third-party root list cab from: <%1>
        case MSG_ROOT_LIST_AUTO_UPDATE_URL_RETRIEVAL_ERROR:
            // Failed auto update of third-party root list cab from: <%1>
            // with error: %2
            wcscpy(pEventData->wszOperation, L"FetchCab");
            break;

        case MSG_ROOT_LIST_AUTO_UPDATE_EXTRACT_ERROR:
            // Failed extract of third-party root list from auto update
            // cab at: <%1> with error: %2
            wcscpy(pEventData->wszOperation, L"ExtractCtl");
            break;

        case MSG_ROOT_CERT_AUTO_UPDATE_URL_RETRIEVAL_INFORMATIONAL:
            // Successful auto update of third-party root certificate from: <%1>
        case MSG_ROOT_CERT_AUTO_UPDATE_URL_RETRIEVAL_ERROR:
            // Failed auto update of third-party root certificate from: <%1>
            //  with error: %2
            wcscpy(pEventData->wszOperation, L"FetchCert");

            // %1 contains
            //  "RootDir" "/" "AsciiHexHash" ".cer"
            //  for example,
            //  "http://www.xyz.com/roots/216B2A29E62A00CE820146D8244141B92511B279.cer"
            {
                LPCWSTR pwszHash = rgpwszStrings[0];
                DWORD cchHash;

                cchHash = wcslen(pwszHash);

                if ((SHA1_HASH_NAME_LEN + 4) <= cchHash)
                    memcpy(pEventData->wszHash,
                        pwszHash + (cchHash - (SHA1_HASH_NAME_LEN + 4)),
                        SHA1_HASH_NAME_LEN * sizeof(WCHAR));
            }
            break;

        case MSG_CRYPT32_EVENT_LOG_THRESHOLD_WARNING:
            // Reached crypt32 threshold of %1 events and will suspend
            // logging for %2 minutes
            wcscpy(pEventData->wszOperation, L"EventOverflow");
            break;

        case MSG_ROOT_SEQUENCE_NUMBER_AUTO_UPDATE_URL_RETRIEVAL_INFORMATIONAL:
            // Successful auto update of third-party root list sequence
            // number from: <%1>
        case MSG_ROOT_SEQUENCE_NUMBER_AUTO_UPDATE_URL_RETRIEVAL_ERROR:
            // Failed auto update of third-party root list sequence number
            // from: <%1> with error: %2
            wcscpy(pEventData->wszOperation, L"FetchSeq");
            break;

        default:
            goto SkipDbLogCrypt32Event;
    }

    if (MSG_CRYPT32_EVENT_LOG_THRESHOLD_WARNING == dwEventID)
        pEventData->dwStatus = (DWORD) ERROR_BUFFER_OVERFLOW;
    else if (EVENTLOG_ERROR_TYPE == wType && 2 <= wNumStrings)
        // The second string should contain the error code string
        pEventData->dwStatus = (DWORD) wcstoul(rgpwszStrings[1], NULL, 0);

    {
        SYSTEMTIME SystemTime;
        GetLocalTime(&SystemTime);
        pEventData->TimeStamp.day = SystemTime.wDay;
        pEventData->TimeStamp.month = SystemTime.wMonth;
        pEventData->TimeStamp.year = SystemTime.wYear;
        pEventData->TimeStamp.hour = SystemTime.wHour;
        pEventData->TimeStamp.minute = SystemTime.wMinute;
        pEventData->TimeStamp.second = SystemTime.wSecond;
        // pEventData->TimeStamp.fraction = 0;
    }

    {
        WCHAR wszMachineName[MAX_PATH] = L"";
        DWORD cchMachineName = sizeof(wszMachineName) / sizeof(WCHAR);

        // intentionally ignore any failures
        GetComputerNameExW(
            ComputerNameDnsHostname, 
            wszMachineName,         
            &cchMachineName    
            );

        wcsncpy(pEventData->wszMachineName, wszMachineName,
            sizeof(pEventData->wszMachineName) / sizeof(WCHAR) - 1);
    }

    {
        HKEY hKey;
        WCHAR wszBuildLab[MAX_PATH];
        DWORD dwStatus;

        wcscpy(wszBuildLab, L"<BuildLab Unknown>");

        dwStatus = RegOpenKeyExW(
            HKEY_LOCAL_MACHINE,
            L"Software\\Microsoft\\Windows NT\\CurrentVersion",
            0,
            KEY_READ,
            &hKey
            );

        if (dwStatus == ERROR_SUCCESS) {
            DWORD dwType = REG_SZ;
            DWORD cbBuildLab = sizeof(wszBuildLab);

            dwStatus = RegQueryValueExW(
                hKey,
                L"BuildLab",
                0,
                &dwType,
                (LPBYTE) wszBuildLab,
                &cbBuildLab
                );

            if (dwStatus != ERROR_SUCCESS) {
                dwType = REG_SZ;
                cbBuildLab = sizeof(wszBuildLab);

                dwStatus = RegQueryValueExW(
                    hKey,
                    L"CurrentBuildNumber",
                    0,
                    &dwType,
                    (LPBYTE) wszBuildLab,
                    &cbBuildLab
                    );
            }
            RegCloseKey(hKey);
        }

        wcsncpy(pEventData->wszBuildLab, wszBuildLab,
            sizeof(pEventData->wszBuildLab) / sizeof(WCHAR) - 1);
    }

#if defined(M_IA64) || defined(IA64) || defined(_IA64_)
    pEventData->dwCPU64 = 1;
#endif

    // Create the thread to do the logging to the database
    if (NULL == (hThread = CreateThread(
            NULL,           // lpThreadAttributes
            0,              // dwStackSize
            I_DBLogCrypt32EventThreadProc,
            pEventData,
            0,              // dwCreationFlags
            NULL            // pdwThreadId
            )))
        goto CreateThreadError;

    CloseHandle(hThread);

CommonReturn:
    return;

ErrorReturn:
    PkiFree(pEventData);
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
TRACE_ERROR(SkipDbLogCrypt32Event)
TRACE_ERROR(CreateThreadError)
}


#else

void
I_DBLogAttach()
{
}

void
I_DBLogDetach()
{
}

void
I_DBLogCrypt32Event(
    IN WORD wType,
    IN DWORD dwEventID,
    IN WORD wNumStrings,
    IN LPCWSTR *rgpwszStrings
    )
{
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\ctlfunc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       ctlfunc.cpp
//
//  Contents:   Certificate Verify CTL Usage Dispatch Functions
//
//  Functions:  I_CertCTLUsageFuncDllMain
//              CertVerifyCTLUsage
//
//  History:    29-Apr-97    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

static HCRYPTOIDFUNCSET hUsageFuncSet;

typedef BOOL (WINAPI *PFN_CERT_DLL_VERIFY_CTL_USAGE)(
    IN DWORD dwEncodingType,
    IN DWORD dwSubjectType,
    IN void *pvSubject,
    IN PCTL_USAGE pSubjectUsage,
    IN DWORD dwFlags,
    IN OPTIONAL PCTL_VERIFY_USAGE_PARA pVerifyUsagePara,
    IN OUT PCTL_VERIFY_USAGE_STATUS pVerifyUsageStatus
    );

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertCTLUsageFuncDllMain(
        HMODULE hModule,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL    fRet;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        if (NULL == (hUsageFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_VERIFY_CTL_USAGE_FUNC,
                0)))                                // dwFlags
            goto CryptInitOIDFunctionSetError;
        break;

    case DLL_PROCESS_DETACH:
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CryptInitOIDFunctionSetError)
}

static void ZeroUsageStatus(
    IN OUT PCTL_VERIFY_USAGE_STATUS pUsageStatus)
{
    pUsageStatus->dwError = 0;
    pUsageStatus->dwFlags = 0;
    if (pUsageStatus->ppCtl)
        *pUsageStatus->ppCtl = NULL;
    pUsageStatus->dwCtlEntryIndex = 0;
    if (pUsageStatus->ppSigner)
        *pUsageStatus->ppSigner = NULL;
    pUsageStatus->dwSignerIndex = 0;
}

//+-------------------------------------------------------------------------
//  Remember the "most interesting" error
//--------------------------------------------------------------------------
static void UpdateUsageError(
    IN DWORD dwNewError,
    IN OUT DWORD *pdwError
    )
{
    if (0 != dwNewError) {
        DWORD dwError = *pdwError;
        if ((DWORD) CRYPT_E_NOT_IN_CTL == dwNewError ||
                (DWORD) CRYPT_E_NO_VERIFY_USAGE_DLL == dwError
                        ||
            ((DWORD) CRYPT_E_NOT_IN_CTL != dwError &&
                (DWORD) CRYPT_E_NO_TRUSTED_SIGNER != dwError &&
                (DWORD) CRYPT_E_NO_VERIFY_USAGE_CHECK != dwNewError))
            *pdwError = dwNewError;
    }
}

static BOOL VerifyDefaultUsage(
    IN DWORD dwEncodingType,
    IN DWORD dwSubjectType,
    IN void *pvSubject,
    IN PCTL_USAGE pSubjectUsage,
    IN DWORD dwFlags,
    IN OPTIONAL PCTL_VERIFY_USAGE_PARA pVerifyUsagePara,
    IN OUT PCTL_VERIFY_USAGE_STATUS pVerifyUsageStatus
    )
{
    BOOL fResult;
    DWORD dwError = (DWORD) CRYPT_E_NO_VERIFY_USAGE_DLL;
    LPWSTR pwszDllList;       // _alloca'ed
    DWORD cchDllList;
    DWORD cchDll;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;

    // Iterate through the installed default functions.
    // Setting pwszDll to NULL searches the installed list. Setting
    // hFuncAddr to NULL starts the search at the beginning.
    hFuncAddr = NULL;
    while (CryptGetDefaultOIDFunctionAddress(
                hUsageFuncSet,
                dwEncodingType,
                NULL,               // pwszDll
                0,                  // dwFlags
                &pvFuncAddr,
                &hFuncAddr)) {
        ZeroUsageStatus(pVerifyUsageStatus);
        fResult = ((PFN_CERT_DLL_VERIFY_CTL_USAGE) pvFuncAddr)(
                dwEncodingType,
                dwSubjectType,
                pvSubject,
                pSubjectUsage,
                dwFlags,
                pVerifyUsagePara,
                pVerifyUsageStatus);
        if (fResult) {
            CryptFreeOIDFunctionAddress(hFuncAddr, 0);
            goto CommonReturn;
        } else
            // Unable to verify usage for this installed
            // function. However, remember any "interesting"
            // errors.
            UpdateUsageError(pVerifyUsageStatus->dwError, &dwError);
    }

    if (!CryptGetDefaultOIDDllList(
            hUsageFuncSet,
            dwEncodingType,
            NULL,               // pszDllList
            &cchDllList)) goto GetDllListError;
    __try {
        pwszDllList = (LPWSTR) _alloca(cchDllList * sizeof(WCHAR));
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        goto OutOfMemory;
    }
    if (!CryptGetDefaultOIDDllList(
            hUsageFuncSet,
            dwEncodingType,
            pwszDllList,
            &cchDllList)) goto GetDllListError;

    for (; 0 != (cchDll = wcslen(pwszDllList)); pwszDllList += cchDll + 1) {
        if (CryptGetDefaultOIDFunctionAddress(
                hUsageFuncSet,
                dwEncodingType,
                pwszDllList,
                0,              // dwFlags
                &pvFuncAddr,
                &hFuncAddr)) {
            ZeroUsageStatus(pVerifyUsageStatus);
            fResult = ((PFN_CERT_DLL_VERIFY_CTL_USAGE) pvFuncAddr)(
                    dwEncodingType,
                    dwSubjectType,
                    pvSubject,
                    pSubjectUsage,
                    dwFlags,
                    pVerifyUsagePara,
                    pVerifyUsageStatus);
            CryptFreeOIDFunctionAddress(hFuncAddr, 0);
            if (fResult)
                goto CommonReturn;
            else
                // Unable to verify usage for this registered
                // function. However, remember any "interesting"
                // errors.
                UpdateUsageError(pVerifyUsageStatus->dwError, &dwError);
        }
    }

    goto ErrorReturn;

CommonReturn:
    return fResult;
ErrorReturn:
    pVerifyUsageStatus->dwError = dwError;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetDllListError)
TRACE_ERROR(OutOfMemory)
}

static BOOL VerifyOIDUsage(
    IN DWORD dwEncodingType,
    IN DWORD dwSubjectType,
    IN void *pvSubject,
    IN PCTL_USAGE pSubjectUsage,
    IN DWORD dwFlags,
    IN OPTIONAL PCTL_VERIFY_USAGE_PARA pVerifyUsagePara,
    IN OUT PCTL_VERIFY_USAGE_STATUS pVerifyUsageStatus
    )
{
    BOOL fResult;
    HCRYPTOIDFUNCADDR hFuncAddr;
    PVOID pvFuncAddr;

    if (pSubjectUsage && pSubjectUsage->cUsageIdentifier > 0 && 
            CryptGetOIDFunctionAddress(
                hUsageFuncSet,
                dwEncodingType,
                pSubjectUsage->rgpszUsageIdentifier[0],
                0,                                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr)) {
            ZeroUsageStatus(pVerifyUsageStatus);
            fResult = ((PFN_CERT_DLL_VERIFY_CTL_USAGE) pvFuncAddr)(
                        dwEncodingType,
                        dwSubjectType,
                        pvSubject,
                        pSubjectUsage,
                        dwFlags,
                        pVerifyUsagePara,
                        pVerifyUsageStatus);
            CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    } else {
        pVerifyUsageStatus->dwError = (DWORD) CRYPT_E_NO_VERIFY_USAGE_DLL;
        fResult = FALSE;
    }

    return fResult;
}

//+-------------------------------------------------------------------------
//  Verify that a subject is trusted for the specified usage by finding a
//  signed and time valid CTL with the usage identifiers and containing the
//  the subject. A subject can be identified by either its certificate context
//  or any identifier such as its SHA1 hash.
//
//  See CertFindSubjectInCTL for definition of dwSubjectType and pvSubject
//  parameters.
//
//  Via pVerifyUsagePara, the caller can specify the stores to be searched
//  to find the CTL. The caller can also specify the stores containing
//  acceptable CTL signers. By setting the ListIdentifier, the caller
//  can also restrict to a particular signer CTL list.
//
//  Via pVerifyUsageStatus, the CTL containing the subject, the subject's
//  index into the CTL's array of entries, and the signer of the CTL
//  are returned. If the caller is interested, ppCtl and ppSigner can be set
//  to NULL. Returned contexts must be freed via the store's free context APIs.
//
//  If the CERT_VERIFY_INHIBIT_CTL_UPDATE_FLAG isn't set, then, a time
//  invalid CTL in one of the CtlStores may be replaced. When replaced, the
//  CERT_VERIFY_UPDATED_CTL_FLAG is set in pVerifyUsageStatus->dwFlags.
//
//  If the CERT_VERIFY_TRUSTED_SIGNERS_FLAG is set, then, only the
//  SignerStores specified in pVerifyUsageStatus are searched to find
//  the signer. Otherwise, the SignerStores provide additional sources
//  to find the signer's certificate.
//
//  If CERT_VERIFY_NO_TIME_CHECK_FLAG is set, then, the CTLs aren't checked
//  for time validity.
//
//  If CERT_VERIFY_ALLOW_MORE_USAGE_FLAG is set, then, the CTL may contain
//  additional usage identifiers than specified by pSubjectUsage. Otherwise,
//  the found CTL will contain the same usage identifers and no more.
//
//  CertVerifyCTLUsage will be implemented as a dispatcher to OID installable
//  functions. First, it will try to find an OID function matching the first
//  usage object identifier in the pUsage sequence. Next, it will dispatch
//  to the default CertDllVerifyCTLUsage functions.
//
//  If the subject is trusted for the specified usage, then, TRUE is
//  returned. Otherwise, FALSE is returned with dwError set to one of the
//  following:
//      CRYPT_E_NO_VERIFY_USAGE_DLL
//      CRYPT_E_NO_VERIFY_USAGE_CHECK
//      CRYPT_E_VERIFY_USAGE_OFFLINE
//      CRYPT_E_NOT_IN_CTL
//      CRYPT_E_NO_TRUSTED_SIGNER
//--------------------------------------------------------------------------
BOOL
WINAPI
CertVerifyCTLUsage(
    IN DWORD dwEncodingType,
    IN DWORD dwSubjectType,
    IN void *pvSubject,
    IN PCTL_USAGE pSubjectUsage,
    IN DWORD dwFlags,
    IN OPTIONAL PCTL_VERIFY_USAGE_PARA pVerifyUsagePara,
    IN OUT PCTL_VERIFY_USAGE_STATUS pVerifyUsageStatus
    )
{
    BOOL fResult;

    assert(NULL == pVerifyUsagePara || pVerifyUsagePara->cbSize >=
        sizeof(CTL_VERIFY_USAGE_PARA));
    assert(pVerifyUsageStatus && pVerifyUsageStatus->cbSize >=
        sizeof(CTL_VERIFY_USAGE_STATUS));
    if (pVerifyUsagePara && pVerifyUsagePara->cbSize <
            sizeof(CTL_VERIFY_USAGE_PARA))
        goto InvalidArg;
    if (NULL == pVerifyUsageStatus || pVerifyUsageStatus->cbSize <
            sizeof(CTL_VERIFY_USAGE_STATUS))
        goto InvalidArg;


    fResult = VerifyOIDUsage(
        dwEncodingType,
        dwSubjectType,
        pvSubject,
        pSubjectUsage,
        dwFlags,
        pVerifyUsagePara,
        pVerifyUsageStatus);
    if (!fResult) {
        DWORD dwError = pVerifyUsageStatus->dwError;

        fResult = VerifyDefaultUsage(
            dwEncodingType,
            dwSubjectType,
            pvSubject,
            pSubjectUsage,
            dwFlags,
            pVerifyUsagePara,
            pVerifyUsageStatus);
        if (!fResult) {
            UpdateUsageError(pVerifyUsageStatus->dwError, &dwError);
            ZeroUsageStatus(pVerifyUsageStatus);
            pVerifyUsageStatus->dwError = dwError;
            SetLastError(dwError);
        }
    }

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\ekuhlpr.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       ekuhlpr.cpp
//
//  Contents:   Certificate Enhanced Key Usage Helper API implementation
//
//  History:    21-May-97    kirtd    Created
//              xx-xxx-xx    reidk    Added CertGetValidUsages
//
//----------------------------------------------------------------------------
#include <global.hxx>
#include <dbgdef.h>
//+---------------------------------------------------------------------------
//
//  Function:   CertGetEnhancedKeyUsage
//
//  Synopsis:   gets the enhanced key usage extension/property from the
//              certificate
//
//----------------------------------------------------------------------------
BOOL WINAPI CertGetEnhancedKeyUsage (
                IN     PCCERT_CONTEXT     pCertContext,
                IN     DWORD              dwFlags,
                OUT    PCERT_ENHKEY_USAGE pUsage,
                IN OUT DWORD*             pcbUsage
                )
{
    HRESULT           hr = S_OK;
    CRYPT_OBJID_BLOB  cob;
    BOOL fExtCertPolicies = FALSE;
    PCRYPT_OBJID_BLOB pExtBlob = NULL;
    PCRYPT_OBJID_BLOB pPropBlob = NULL;

    //
    // If the flags are zero then assume they want everything
    //

    if ( dwFlags == 0 )
    {
        dwFlags = CERT_FIND_ALL_ENHKEY_USAGE_FLAG;
    }

    //
    // Validate the parameters
    //

    if ( ( ( dwFlags & CERT_FIND_ALL_ENHKEY_USAGE_FLAG ) == 0 ) ||
         ( pCertContext == NULL ) || ( pcbUsage == NULL ) )
    {
        SetLastError((DWORD) ERROR_INVALID_PARAMETER);
        return( FALSE );
    }

    //
    // If they want everything, call CertGetValidUsages
    //

    if ( dwFlags == CERT_FIND_ALL_ENHKEY_USAGE_FLAG )
    {
        return( EkuGetIntersectedUsageViaGetValidUsages(
                   pCertContext,
                   pcbUsage,
                   pUsage
                   ) );
    }

    //
    // If they want extensions get the extension blob, if they want
    // properties get the property blob
    //

    if ( dwFlags & CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG )
    {
        pExtBlob = EkuGetExtension(pCertContext, &fExtCertPolicies);
    }

    if ( dwFlags & CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG )
    {
        hr = EkuGetProperty(pCertContext, &cob);
        if ( hr == S_OK )
        {
            pPropBlob = &cob;
        }
    }

    //
    // Make sure that at least something was found and that what has occurred
    // is correctly indicated
    //

    if ( ( pExtBlob == NULL ) && ( pPropBlob == NULL ) )
    {
        if ( hr == S_OK )
        {
            hr = CRYPT_E_NOT_FOUND;
        }
    }
    else
    {
        hr = S_OK;
    }

    //
    // If all they wanted was the size, give it to them, otherwise, we
    // need to decode and give the caller what they requested
    //

    if ( hr == S_OK )
    {
        if ( pUsage == NULL )
        {
            DWORD cbSize = 0;
            DWORD cbExtSize = 0;
            DWORD cbPropSize = 0;

            hr = EkuGetDecodedUsageSizes(
                       fExtCertPolicies,
                       pExtBlob,
                       pPropBlob,
                       &cbSize,
                       &cbExtSize,
                       &cbPropSize
                       );

            if ( hr == S_OK )
            {
                if ( cbSize > 0 )
                {
                    *pcbUsage = cbSize;
                }
                else
                {
                    // Need better last error code
                    hr = E_INVALIDARG;
                }
            }
        }
        else
        {
            hr = EkuGetMergedDecodedUsage(
                             fExtCertPolicies,
                             pExtBlob,
                             pPropBlob,
                             pcbUsage,
                             pUsage
                             );
        }
    }

    //
    // Cleanup and return
    //

    if ( pPropBlob != NULL )
    {
        delete pPropBlob->pbData;
    }

    if ( hr != S_OK )
    {
        SetLastError(hr);
        return( FALSE );
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   CertSetEnhancedKeyUsage
//
//  Synopsis:   sets the enhanced key usage property on the certificate
//
//----------------------------------------------------------------------------
BOOL WINAPI CertSetEnhancedKeyUsage (
                IN PCCERT_CONTEXT     pCertContext,
                IN PCERT_ENHKEY_USAGE pUsage
                )
{
    HRESULT          hr;
    CRYPT_OBJID_BLOB EkuBlob;

    //
    // if pUsage is NULL, then just set the NULL property
    //
    if (pUsage == NULL)
    {
        hr = EkuSetProperty(pCertContext, NULL);
    }
    else
    {
        //
        // Encode the usage and set the property
        //
        hr = EkuEncodeUsage(pUsage, &EkuBlob);
        if ( hr == S_OK )
        {
            hr = EkuSetProperty(pCertContext, &EkuBlob);
            delete EkuBlob.pbData;
        }
    }

    if ( hr != S_OK )
    {
        SetLastError(hr);
        return( FALSE );
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   CertAddEnhancedKeyUsageIdentifier
//
//  Synopsis:   adds a key usage identifier to the enhanced key usage property
//              on the certificate
//
//----------------------------------------------------------------------------
BOOL WINAPI CertAddEnhancedKeyUsageIdentifier (
                IN PCCERT_CONTEXT pCertContext,
                IN LPCSTR         pszUsageIdentifier
                )
{
    HRESULT            hr;
    DWORD              cbUsage1 = 0;
    DWORD              cbUsage2 = 0;
    DWORD              cbUsageM = 0;
    DWORD              cId;
    PCERT_ENHKEY_USAGE pUsage1 = NULL;
    PCERT_ENHKEY_USAGE pUsage2 = NULL;
    PCERT_ENHKEY_USAGE pUsageM = NULL;

    //
    // Create a one element, properly "encoded" (see EkuMergeUsage) enhanced
    // key usage structure
    //

    cId = strlen(pszUsageIdentifier)+1;
    cbUsage1 = sizeof(CERT_ENHKEY_USAGE)+sizeof(LPSTR)+cId;
    pUsage1 = (PCERT_ENHKEY_USAGE)new BYTE [cbUsage1];
    if ( pUsage1 == NULL )
    {
        SetLastError((DWORD) E_OUTOFMEMORY);
        return( FALSE );
    }

    pUsage1->cUsageIdentifier = 1;
    pUsage1->rgpszUsageIdentifier = (LPSTR *)((LPBYTE)pUsage1+sizeof(CERT_ENHKEY_USAGE));
    pUsage1->rgpszUsageIdentifier[0] = (LPSTR)((LPBYTE)pUsage1->rgpszUsageIdentifier+sizeof(LPSTR));
    strcpy(pUsage1->rgpszUsageIdentifier[0], pszUsageIdentifier);

    //
    // Get the current enhanced key usage properties and get an appropriately
    // sized block for the merged data unless there are no current usage
    // properties in which case we just set the one we have now
    //

    hr = EkuGetUsage(
               pCertContext,
               CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG,
               &cbUsage2,
               &pUsage2
               );

    if ( hr == S_OK )
    {
        cbUsageM = cbUsage1 + cbUsage2;
        pUsageM = (PCERT_ENHKEY_USAGE)new BYTE [cbUsageM];
        if ( pUsageM == NULL )
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if ( hr == CRYPT_E_NOT_FOUND )
    {
        BOOL fReturn;

        fReturn = CertSetEnhancedKeyUsage(pCertContext, pUsage1);
        delete pUsage1;
        return( fReturn );
    }
    else
    {
        SetLastError(hr);
        return( FALSE );
    }

    //
    // Merge the usage structures and set the properties
    //

    hr = EkuMergeUsage(cbUsage1, pUsage1, cbUsage2, pUsage2, cbUsageM, pUsageM);
    if ( hr == S_OK )
    {
        if ( CertSetEnhancedKeyUsage(pCertContext, pUsageM) == FALSE )
        {
            hr = GetLastError();
        }
    }

    //
    // Cleanup
    //

    delete pUsage1;
    delete pUsage2;
    delete pUsageM;

    if ( hr != S_OK )
    {
        SetLastError(hr);
        return( FALSE );
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   CertRemoveEnhancedKeyUsageIdentifier
//
//  Synopsis:   removes a key usage identifier from the enhanced key usage
//              property on the certificate
//
//----------------------------------------------------------------------------
BOOL WINAPI CertRemoveEnhancedKeyUsageIdentifier (
                IN PCCERT_CONTEXT pCertContext,
                IN LPCSTR         pszUsageIdentifier
                )
{
    HRESULT            hr;
    DWORD              cFound = 0;
    DWORD              cCount;
    PCERT_ENHKEY_USAGE pUsage;
    LPSTR*             apsz;

    //
    // Get the current usage properties
    //

    hr = EkuGetUsage(
            pCertContext,
            CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG,
            NULL,
            &pUsage
            );

    if ( hr != S_OK )
    {
        SetLastError(hr);
        return( FALSE );
    }

    //
    // Loop through the usage identifiers and remove ones that match
    // the passed in id
    //

    apsz = pUsage->rgpszUsageIdentifier;

    for (cCount = 0; cCount < pUsage->cUsageIdentifier; cCount++)
    {
        if ( strcmp(apsz[cCount], pszUsageIdentifier) == 0 )
        {
            cFound++;
        }
        else if ( cFound > 0 )
        {
            apsz[cCount-cFound] = apsz[cCount];
        }
    }

    //
    // If we removed any, update the usage id count and set the new property
    //

    if ( cFound > 0 )
    {
        pUsage->cUsageIdentifier -= cFound;

        if ( pUsage->cUsageIdentifier == 0 )
        {
            // Delete the property if we are down to zero
            hr = EkuSetProperty(pCertContext, NULL);
        }
        else if ( CertSetEnhancedKeyUsage(pCertContext, pUsage) == FALSE )
        {
            hr = GetLastError();
        }
    }

    //
    // Cleanup
    //

    delete pUsage;

    if ( hr != S_OK )
    {
        SetLastError(hr);
        return( FALSE );
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   EkuGetExtension
//
//  Synopsis:   gets the application cert policies or enhanced key usage
//              extension blob from the certificate
//
//              *pfAppCertPolicies is set to TRUE for an
//              szOID_APPLICATION_CERT_POLICIES extension.
//
//----------------------------------------------------------------------------
PCRYPT_OBJID_BLOB EkuGetExtension (
                        PCCERT_CONTEXT pCertContext,
                        BOOL           *pfAppCertPolicies
                        )
{
    PCERT_EXTENSION pExtension;

    //
    // Get the application cert policies or enhanced key usage extension
    // from the certificate and if we couldn't find either
    // extension return NULL otherwise, return
    // the appropriate field of the found extension
    //

    pExtension = CertFindExtension(
                         szOID_APPLICATION_CERT_POLICIES,
                         pCertContext->pCertInfo->cExtension,
                         pCertContext->pCertInfo->rgExtension
                         );
    if ( pExtension )
    {
        *pfAppCertPolicies = TRUE;
    }
    else
    {
        *pfAppCertPolicies = FALSE;

        pExtension = CertFindExtension(
                             szOID_ENHANCED_KEY_USAGE,
                             pCertContext->pCertInfo->cExtension,
                             pCertContext->pCertInfo->rgExtension
                             );

        if ( pExtension == NULL )
        {
            return( NULL );
        }
    }

    return( &pExtension->Value );
}

//+---------------------------------------------------------------------------
//
//  Function:   EkuGetProperty
//
//  Synopsis:   gets the enhanced key usage property from the certificate
//
//----------------------------------------------------------------------------
HRESULT EkuGetProperty (
              PCCERT_CONTEXT    pCertContext,
              PCRYPT_OBJID_BLOB pEkuBlob
              )
{
    DWORD cb;

    if ( CertGetCertificateContextProperty(
                           pCertContext,
                           CERT_ENHKEY_USAGE_PROP_ID,
                           NULL,
                           &cb
                           ) == FALSE )
    {
        return( GetLastError() );
    }

    pEkuBlob->cbData = cb;
    pEkuBlob->pbData = new BYTE [cb];

    if ( pEkuBlob->pbData == NULL )
    {
        return( E_OUTOFMEMORY );
    }

    if ( CertGetCertificateContextProperty(
                           pCertContext,
                           CERT_ENHKEY_USAGE_PROP_ID,
                           pEkuBlob->pbData,
                           &cb
                           ) == FALSE )
    {
        return( GetLastError() );
    }

    return( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:   EkuSetProperty
//
//  Synopsis:   sets an enhanced key usage property on the certificate
//
//----------------------------------------------------------------------------
HRESULT EkuSetProperty (
              PCCERT_CONTEXT    pCertContext,
              PCRYPT_OBJID_BLOB pEkuBlob
              )
{
    if ( CertSetCertificateContextProperty(
                           pCertContext,
                           CERT_ENHKEY_USAGE_PROP_ID,
                           0,
                           pEkuBlob
                           ) == FALSE )
    {
        return( GetLastError() );
    }

    return( S_OK );
}


//+---------------------------------------------------------------------------
//
//  Function:   EkuDecodeCertPoliciesAndConvertToUsage
//
//  Synopsis:   decodes an encoded cert policies and converts to enhanced
//              key usage
//
//----------------------------------------------------------------------------
HRESULT EkuDecodeCertPoliciesAndConvertToUsage (
              PCRYPT_OBJID_BLOB  pEkuBlob,
              DWORD*             pcbSize,
              PCERT_ENHKEY_USAGE pUsage     // OPTIONAL
              )
{
    HRESULT hr = S_OK;
    DWORD cbCertPolicies = 0;
    PCERT_POLICIES_INFO pCertPolicies = NULL;
    DWORD cbSize = 0;

    if ( !CryptDecodeObject(
              X509_ASN_ENCODING,
              X509_CERT_POLICIES,
              pEkuBlob->pbData,
              pEkuBlob->cbData,
              CRYPT_DECODE_NOCOPY_FLAG |
                  CRYPT_DECODE_SHARE_OID_STRING_FLAG |
                  CRYPT_DECODE_ALLOC_FLAG,
              (void *) &pCertPolicies,
              &cbCertPolicies
              ))
    {
        hr = GetLastError();
    }
    else
    {
        // Convert policies OIDs to EKU OIDs
        LONG lRemainExtra;
        DWORD cOID;
        LPSTR *ppszOID;
        LPSTR pszOID;
        PCERT_POLICY_INFO pPolicy;

        cOID = pCertPolicies->cPolicyInfo;
        pPolicy = pCertPolicies->rgPolicyInfo;

        if ( pUsage )
        {
            cbSize = *pcbSize;
        }

        lRemainExtra = cbSize - sizeof(CERT_ENHKEY_USAGE) -
            sizeof(LPSTR) * cOID;
        if ( lRemainExtra < 0 )
        {
            ppszOID = NULL;
            pszOID = NULL;
        }
        else
        {
            ppszOID = (LPSTR *) &pUsage[1];
            pszOID = (LPSTR) &ppszOID[cOID];

            pUsage->cUsageIdentifier = cOID;
            pUsage->rgpszUsageIdentifier = ppszOID;
        }

        for ( ; cOID > 0; cOID--, ppszOID++, pPolicy++ )
        {
            DWORD cchOID;

            cchOID = strlen(pPolicy->pszPolicyIdentifier) + 1;
            lRemainExtra -= cchOID;
            if ( lRemainExtra >= 0 )
            {
                *ppszOID = pszOID;
                memcpy(pszOID, pPolicy->pszPolicyIdentifier, cchOID);
                pszOID += cchOID;
            }
        }

        if ( lRemainExtra >= 0)
        {
            cbSize -= (DWORD) lRemainExtra;
        }
        else
        {
            cbSize += (DWORD) -lRemainExtra;
            if ( pUsage )
            {
                hr = ERROR_MORE_DATA;
            }
        }
            
    }

    if ( pCertPolicies )
    {
        LocalFree( pCertPolicies );
    }

    *pcbSize = cbSize;
    return( hr );
}

//+---------------------------------------------------------------------------
//
//  Function:   EkuGetDecodedSize
//
//  Synopsis:   gets the decoded size of the enhanced key usage blob
//
//----------------------------------------------------------------------------
HRESULT EkuGetDecodedSize (
              PCRYPT_OBJID_BLOB pEkuBlob,
              DWORD*            pcbSize
              )
{
    if ( CryptDecodeObject(
              X509_ASN_ENCODING,
              szOID_ENHANCED_KEY_USAGE,
              pEkuBlob->pbData,
              pEkuBlob->cbData,
              0,
              NULL,
              pcbSize
              ) == FALSE )
    {
        return( GetLastError() );
    }

    return( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:   EkuGetDecodedUsageSizes
//
//  Synopsis:   gets the decoded sizes for enhanced key usage blobs from the
//              certificate extension and/or the certificate context property
//
//----------------------------------------------------------------------------
HRESULT EkuGetDecodedUsageSizes (
              BOOL              fExtCertPolicies,
              PCRYPT_OBJID_BLOB pExtBlob,
              PCRYPT_OBJID_BLOB pPropBlob,
              DWORD*            pcbSize,
              DWORD*            pcbExtSize,
              DWORD*            pcbPropSize
              )
{
    HRESULT hr = S_OK;
    DWORD   cbExtSize = 0;
    DWORD   cbPropSize = 0;

    //
    // Get the appropriate decoded size based on what was requested
    //

    if ( pExtBlob != NULL )
    {
        if ( fExtCertPolicies )
        {
            hr = EkuDecodeCertPoliciesAndConvertToUsage(
                pExtBlob, &cbExtSize, NULL);
        }
        else
        {
            hr = EkuGetDecodedSize(pExtBlob, &cbExtSize);
        }
    }

    if ( ( hr == S_OK ) && ( pPropBlob != NULL ) )
    {
        hr = EkuGetDecodedSize(pPropBlob, &cbPropSize);
    }

    //
    // Collect into the out parameters
    //

    if ( hr == S_OK )
    {
        *pcbExtSize = cbExtSize;
        *pcbPropSize = cbPropSize;
        *pcbSize = cbExtSize + cbPropSize;
    }

    return( hr );
}

//+---------------------------------------------------------------------------
//
//  Function:   EkuGetDecodedUsage
//
//  Synopsis:   gets the decoded enhanced key usage from the encoded blob
//
//----------------------------------------------------------------------------
HRESULT EkuGetDecodedUsage (
              PCRYPT_OBJID_BLOB  pEkuBlob,
              DWORD*             pcbSize,
              PCERT_ENHKEY_USAGE pUsage
              )
{
    if ( CryptDecodeObject(
              X509_ASN_ENCODING,
              szOID_ENHANCED_KEY_USAGE,
              pEkuBlob->pbData,
              pEkuBlob->cbData,
              0,
              pUsage,
              pcbSize
              ) == FALSE )
    {
        return( GetLastError() );
    }

    return( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:   EkuMergeUsage
//
//  Synopsis:   merges enhanced key usage structures
//
//              NOTE: The structures are assumed to be in single allocated
//                    block form where the string pointers point back into
//                    the bottom part of the allocated block where the
//                    have been placed
//
//----------------------------------------------------------------------------
HRESULT EkuMergeUsage (
              DWORD              cbSize1,
              PCERT_ENHKEY_USAGE pUsage1,
              DWORD              cbSize2,
              PCERT_ENHKEY_USAGE pUsage2,
              DWORD              cbSizeM,
              PCERT_ENHKEY_USAGE pUsageM
              )
{
    DWORD  cUsage1;
    DWORD  cUsage2;
    DWORD  cUsageM;
    DWORD  cbOids1;
    DWORD  cbOids2;
    DWORD  cbUsage1;
    DWORD  cbUsage2;
    DWORD  cCount;
    DWORD  cbOffset;
    LPSTR* apsz1;
    LPSTR* apsz2;
    LPSTR* apszM;

    //
    // Copy the data from the source to the destination
    //

    cUsage1 = pUsage1->cUsageIdentifier;
    cUsage2 = pUsage2->cUsageIdentifier;
    cUsageM = cUsage1 + cUsage2;

    cbUsage1 = ( cUsage1 * sizeof(LPSTR) ) + sizeof(CERT_ENHKEY_USAGE);
    cbUsage2 = ( cUsage2 * sizeof(LPSTR) ) + sizeof(CERT_ENHKEY_USAGE);

    apsz1 = pUsage1->rgpszUsageIdentifier;
    apsz2 = pUsage2->rgpszUsageIdentifier;
    apszM = (LPSTR *)((LPBYTE)pUsageM+sizeof(CERT_ENHKEY_USAGE));

    pUsageM->cUsageIdentifier = cUsageM;
    pUsageM->rgpszUsageIdentifier = apszM;

    memcpy(apszM, apsz1, cUsage1*sizeof(LPSTR));
    memcpy(&apszM[cUsage1], apsz2, cUsage2*sizeof(LPSTR));

    cbOids1 = cbSize1 - cbUsage1;
    cbOids2 = cbSize2 - cbUsage2;

    memcpy(&apszM[cUsageM], &apsz1[cUsage1], cbOids1);

    memcpy(
       (LPBYTE)(&apszM[cUsageM])+cbOids1,
       &apsz2[cUsage2],
       cbOids2
       );

    //
    // Fix up the pointers
    //

    for ( cCount = 0; cCount < cUsage1; cCount++)
    {
        cbOffset = (DWORD)((LPBYTE)(apsz1[cCount]) - (LPBYTE)apsz1) + cbUsage2;
        apszM[cCount] = (LPSTR)((LPBYTE)pUsageM+cbOffset);
    }

    for ( cCount = 0; cCount < cUsage2; cCount++ )
    {
        cbOffset = (DWORD)((LPBYTE)(apsz2[cCount]) - (LPBYTE)apsz2) + cbUsage1 + cbOids1;
        apszM[cCount+cUsage1] = (LPSTR)((LPBYTE)pUsageM+cbOffset);
    }

    return( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:   EkuGetMergedDecodedUsage
//
//  Synopsis:   gets merged decoded enhanced key usage from the certificate
//              extension and the certificate properties
//
//----------------------------------------------------------------------------
HRESULT EkuGetMergedDecodedUsage (
              BOOL               fExtCertPolicies,
              PCRYPT_OBJID_BLOB  pExtBlob,
              PCRYPT_OBJID_BLOB  pPropBlob,
              DWORD*             pcbSize,
              PCERT_ENHKEY_USAGE pUsage
              )
{
    HRESULT            hr;
    DWORD              cbExtSize = 0;
    DWORD              cbPropSize = 0;
    DWORD              cbMergedSize = 0;
    PCERT_ENHKEY_USAGE pExtUsage = NULL;
    PCERT_ENHKEY_USAGE pPropUsage = NULL;

    //
    // If either the extension or the properties are NULL, we just need
    // to get the other one
    //

    if ( pExtBlob == NULL )
    {
        return( EkuGetDecodedUsage(pPropBlob, pcbSize, pUsage) );
    }
    else if ( pPropBlob == NULL )
    {
        if ( fExtCertPolicies )
        {
            return( EkuDecodeCertPoliciesAndConvertToUsage(
                pExtBlob, pcbSize, pUsage) );
        }
        else
        {
            return( EkuGetDecodedUsage(pExtBlob, pcbSize, pUsage) );
        }
    }

    //
    // Get the sizes we will need to allocate for decoding and validate
    // the total against what was passed in
    //

    hr = EkuGetDecodedUsageSizes(
               fExtCertPolicies,
               pExtBlob,
               pPropBlob,
               &cbMergedSize,
               &cbExtSize,
               &cbPropSize
               );

    if ( hr != S_OK )
    {
        return( hr );
    }
    else if ( *pcbSize < cbMergedSize )
    {
        *pcbSize = cbMergedSize;
        return( ERROR_MORE_DATA );
    }

    //
    // Allocate the enhanced key usage structures and decode into them
    //

    pExtUsage = (PCERT_ENHKEY_USAGE)new BYTE [cbExtSize];
    pPropUsage = (PCERT_ENHKEY_USAGE)new BYTE [cbPropSize];

    if ( ( pExtUsage == NULL ) || ( pPropUsage == NULL ) )
    {
        delete pExtUsage;
        delete pPropUsage;
        return( E_OUTOFMEMORY );
    }

    if ( fExtCertPolicies )
    {
        hr = EkuDecodeCertPoliciesAndConvertToUsage(
            pExtBlob, &cbExtSize, pExtUsage);
    }
    else
    {
        hr = EkuGetDecodedUsage(pExtBlob, &cbExtSize, pExtUsage);
    }

    if ( hr == S_OK )
    {
        hr = EkuGetDecodedUsage(pPropBlob, &cbPropSize, pPropUsage);
    }

    //
    // Merge the usage structures
    //

    if ( hr == S_OK )
    {
        hr = EkuMergeUsage(
                     cbExtSize,
                     pExtUsage,
                     cbPropSize,
                     pPropUsage,
                     *pcbSize,
                     pUsage
                     );
    }

    //
    // Cleanup
    //

    delete pExtUsage;
    delete pPropUsage;

    return( hr );
}

//+---------------------------------------------------------------------------
//
//  Function:   EkuEncodeUsage
//
//  Synopsis:   encodes the enhanced key usage into a blob useful for setting
//              as a certificate property
//
//----------------------------------------------------------------------------
HRESULT EkuEncodeUsage (
              PCERT_ENHKEY_USAGE pUsage,
              PCRYPT_OBJID_BLOB  pEkuBlob
              )
{
    HRESULT hr = S_OK;
    DWORD   cbData = 0;
    LPBYTE  pbData;

    if ( CryptEncodeObject(
              X509_ASN_ENCODING,
              szOID_ENHANCED_KEY_USAGE,
              pUsage,
              NULL,
              &cbData
              ) == FALSE )
    {
        return( GetLastError() );
    }

    pbData = new BYTE [cbData];

    if ( pbData != NULL )
    {
        if ( CryptEncodeObject(
                  X509_ASN_ENCODING,
                  szOID_ENHANCED_KEY_USAGE,
                  pUsage,
                  pbData,
                  &cbData
                  ) == FALSE )
        {
            hr = GetLastError();
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if ( hr == S_OK )
    {
        pEkuBlob->cbData = cbData;
        pEkuBlob->pbData = pbData;
    }
    else
    {
        delete pbData;
    }

    return( hr );
}

//+---------------------------------------------------------------------------
//
//  Function:   EkuGetUsage
//
//  Synopsis:   gets the usage based on the flags with CertGetEnhancedKeyUsage
//
//----------------------------------------------------------------------------
HRESULT EkuGetUsage (
              PCCERT_CONTEXT      pCertContext,
              DWORD               dwFlags,
              DWORD*              pcbSize,
              PCERT_ENHKEY_USAGE* ppUsage
              )
{
    DWORD              cbSize;
    PCERT_ENHKEY_USAGE pUsage;

    //
    // Get an appropriately sized block to hold the usage
    //

    if ( CertGetEnhancedKeyUsage(
                pCertContext,
                dwFlags,
                NULL,
                &cbSize
                ) == FALSE )
    {
        return( GetLastError() );
    }

    pUsage = (PCERT_ENHKEY_USAGE)new BYTE [cbSize];
    if ( pUsage == NULL )
    {
        return( E_OUTOFMEMORY );
    }

    //
    // Now get the enhanced key usage data and fill in the out parameters
    //

    if ( CertGetEnhancedKeyUsage(
                pCertContext,
                dwFlags,
                pUsage,
                &cbSize
                ) == FALSE )
    {
        delete pUsage;
        return( GetLastError() );
    }

    if ( pcbSize != NULL )
    {
        *pcbSize = cbSize;
    }

    *ppUsage = pUsage;

    return( S_OK );
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static BOOL OIDInUsages(PCERT_ENHKEY_USAGE pUsage, LPCSTR pszOID)
{
    DWORD i;

    // check every extension
    for(i=0; i<pUsage->cUsageIdentifier; i++)
    {
        if(!strcmp(pUsage->rgpszUsageIdentifier[i], pszOID))
            break;
    }

    return (i < pUsage->cUsageIdentifier);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static BOOL OIDExistsInArray(LPSTR *rghPropOIDs, DWORD cPropOIDs, LPSTR pszOID)
{
    DWORD i;

    // check every extension
    for(i=0; i<cPropOIDs; i++)
    {
        if(!strcmp(rghPropOIDs[i], pszOID))
            break;
    }

    return (i < cPropOIDs);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static LPSTR AllocAndCopyStr(LPSTR psz)
{
    LPSTR pszNew;

    pszNew = (LPSTR) new BYTE[strlen(psz)+1];

    if (pszNew == NULL)
    {
        SetLastError((DWORD) E_OUTOFMEMORY);
        return NULL;
    }

    strcpy(pszNew, psz);
    return (pszNew);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void IntersectUsages(DWORD *pcExtOIDs, LPSTR *rghExtOIDs, PCERT_ENHKEY_USAGE pUsageExt)
{
    DWORD i;
    DWORD dwNumOIDs;

    dwNumOIDs = *pcExtOIDs;
    *pcExtOIDs = 0;

    for (i=0; i<dwNumOIDs; i++)
    {
        if (OIDInUsages(pUsageExt, rghExtOIDs[i]))
        {
            if (*pcExtOIDs != i)
            {
                rghExtOIDs[*pcExtOIDs] = rghExtOIDs[i];
                rghExtOIDs[i] = NULL;
            }
            (*pcExtOIDs)++;
        }
        else
        {
            delete(rghExtOIDs[i]);
            rghExtOIDs[i] = NULL;
        }
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static BOOL ProcessCertForEKU(
                    PCCERT_CONTEXT  pCert,
                    BOOL            *pfAllProp,
                    DWORD           *pcPropOIDs,
                    LPSTR           *rghPropOIDs,
                    BOOL            *pfAllExt,
                    DWORD           *pcExtOIDs,
                    LPSTR           *rghExtOIDs)
{
    BOOL                fRet        = TRUE;
    PCERT_ENHKEY_USAGE  pExtUsage   = NULL;
    PCERT_ENHKEY_USAGE  pPropUsage  = NULL;
    DWORD               i;

    EkuGetUsage(pCert, CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG, NULL, &pExtUsage);
    EkuGetUsage(pCert, CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG, NULL, &pPropUsage);

    //
    // if there are EKU extensions then we are limited to that set of EKUs at the maximum
    //
    if (pExtUsage != NULL)
    {
        //
        // if this is the first cert with extensions then just copy all the EKUs,
        // otherwise take the intersection of the current certs EKUs and the intersection
        // of all the previous certs EKUs
        //
        if (*pfAllExt == TRUE)
        {
            *pfAllExt = FALSE;
            for (i=0; i<pExtUsage->cUsageIdentifier; i++)
            {
                rghExtOIDs[i] = AllocAndCopyStr(pExtUsage->rgpszUsageIdentifier[i]);
                if (rghExtOIDs[i] == NULL)
                {
                    goto ErrorCleanUp;
                }
                (*pcExtOIDs)++;
            }
        }
        else
        {
            IntersectUsages(pcExtOIDs, rghExtOIDs, pExtUsage);
        }
    }

    //
    // if there are EKU propertis then we are limited to that set of EKUs at the maximum
    //
    if (pPropUsage != NULL)
    {
        //
        // if this is the first cert with extensions then just copy all the EKUs,
        // otherwise take the intersection of the current certs EKUs and the intersection
        // of all the previous certs EKUs
        //
        if (*pfAllProp == TRUE)
        {
            *pfAllProp = FALSE;
            for (i=0; i<pPropUsage->cUsageIdentifier; i++)
            {
                rghPropOIDs[i] = AllocAndCopyStr(pPropUsage->rgpszUsageIdentifier[i]);
                if (rghPropOIDs[i] == NULL)
                {
                    goto ErrorCleanUp;
                }
                (*pcPropOIDs)++;
            }
        }
        else
        {
            IntersectUsages(pcPropOIDs, rghPropOIDs, pPropUsage);
        }
    }

CleanUp:

    if (pExtUsage != NULL)
        delete(pExtUsage);

    if (pPropUsage != NULL)
        delete(pPropUsage);

    return(fRet);

ErrorCleanUp:

    fRet = FALSE;
    goto CleanUp;
}


//+---------------------------------------------------------------------------
//
//  Function:   CertGetValidUsages
//
//  Synopsis:   takes an array of certs and returns an array of usages
//              which consists of the intersection of the the valid usages for each cert.
//              if each cert is good for all possible usages then cNumOIDs is set to -1.
//
//----------------------------------------------------------------------------
BOOL WINAPI CertGetValidUsages(
                    IN      DWORD           cCerts,
                    IN      PCCERT_CONTEXT  *rghCerts,
                    OUT     int             *cNumOIDs,
                    OUT     LPSTR           *rghOIDs,
                    IN OUT  DWORD           *pcbOIDs)
{
    BOOL            fAllExt = TRUE;
    BOOL            fAllProp = TRUE;
    DWORD           cPropOIDs = 0;
    LPSTR           rghPropOIDs[100];
    DWORD           cExtOIDs = 0;
    LPSTR           rghExtOIDs[100];
    BOOL            fRet = TRUE;
    BYTE            *pbBufferLocation;
    DWORD           cIntersectOIDs = 0;
    DWORD           i;
    DWORD           cbNeeded = 0;

    for (i=0; i<cCerts; i++)
    {
        if (!ProcessCertForEKU(rghCerts[i], &fAllProp, &cPropOIDs, rghPropOIDs, &fAllExt, &cExtOIDs, rghExtOIDs))
        {
            goto ErrorCleanUp;
        }
    }

    *cNumOIDs = 0;

    if (fAllExt && fAllProp)
    {
        *pcbOIDs = 0;
        *cNumOIDs = -1;
    }
    else if (!fAllExt && fAllProp)
    {
        for (i=0; i<cExtOIDs; i++)
        {
            cbNeeded += strlen(rghExtOIDs[i]) + 1 + sizeof(LPSTR);
            (*cNumOIDs)++;
        }

        if (*pcbOIDs == 0)
        {
            *pcbOIDs = cbNeeded;
            goto CleanUp;
        }

        if (cbNeeded > *pcbOIDs)
        {
            *pcbOIDs = cbNeeded;
            SetLastError((DWORD) ERROR_MORE_DATA);
            goto ErrorCleanUp;
        }

        pbBufferLocation = ((BYTE *)rghOIDs) + (cExtOIDs * sizeof(LPSTR));
        for (i=0; i<cExtOIDs; i++)
        {
            rghOIDs[i] = (LPSTR) pbBufferLocation;
            strcpy(rghOIDs[i], rghExtOIDs[i]);
            pbBufferLocation += strlen(rghExtOIDs[i]) + 1;
        }
    }
    else if (fAllExt && !fAllProp)
    {
        for (i=0; i<cPropOIDs; i++)
        {
            cbNeeded += strlen(rghPropOIDs[i]) + 1 + sizeof(LPSTR);
            (*cNumOIDs)++;
        }

        if (*pcbOIDs == 0)
        {
            *pcbOIDs = cbNeeded;
            goto CleanUp;
        }

        if (cbNeeded > *pcbOIDs)
        {
            *pcbOIDs = cbNeeded;
            SetLastError((DWORD) ERROR_MORE_DATA);
            goto ErrorCleanUp;
        }

        pbBufferLocation = ((BYTE *)rghOIDs) + (cPropOIDs * sizeof(LPSTR));
        for (i=0; i<cPropOIDs; i++)
        {
            rghOIDs[i] = (LPSTR) pbBufferLocation;
            strcpy(rghOIDs[i], rghPropOIDs[i]);
            pbBufferLocation += strlen(rghPropOIDs[i]) + 1;
        }
    }
    else
    {
        for (i=0; i<cExtOIDs; i++)
        {
            if (OIDExistsInArray(rghPropOIDs, cPropOIDs, rghExtOIDs[i]))
            {
                cbNeeded += strlen(rghExtOIDs[i]) + 1 + sizeof(LPSTR);
                (*cNumOIDs)++;
                cIntersectOIDs++;
            }
        }

        if (*pcbOIDs == 0)
        {
            *pcbOIDs = cbNeeded;
            goto CleanUp;
        }

        if (cbNeeded > *pcbOIDs)
        {
            *pcbOIDs = cbNeeded;
            SetLastError((DWORD) ERROR_MORE_DATA);
            goto ErrorCleanUp;
        }

        pbBufferLocation = ((BYTE *)rghOIDs) + (cIntersectOIDs * sizeof(LPSTR));
        for (i=0; i<cExtOIDs; i++)
        {
            if (OIDExistsInArray(rghPropOIDs, cPropOIDs, rghExtOIDs[i]))
            {
                cIntersectOIDs--;
                rghOIDs[cIntersectOIDs] = (LPSTR) pbBufferLocation;
                strcpy(rghOIDs[cIntersectOIDs], rghExtOIDs[i]);
                pbBufferLocation += strlen(rghExtOIDs[i]) + 1;
            }
        }
    }

CleanUp:

    for (i=0; i<cExtOIDs; i++)
    {
        delete(rghExtOIDs[i]);
    }

    for (i=0; i<cPropOIDs; i++)
    {
        delete(rghPropOIDs[i]);
    }

    return (fRet);

ErrorCleanUp:
    fRet = FALSE;
    goto CleanUp;

}
//+---------------------------------------------------------------------------
//
//  Function:   EkuGetIntersectedUsageViaGetValidUsages
//
//  Synopsis:   get the intersected extension and property usages
//
//----------------------------------------------------------------------------
BOOL
EkuGetIntersectedUsageViaGetValidUsages (
   PCCERT_CONTEXT pCertContext,
   DWORD* pcbSize,
   PCERT_ENHKEY_USAGE pUsage
   )
{
    BOOL  fResult;
    int   cUsage = 0;
    DWORD cbUsage = 0;
    DWORD cbSize = 0;

    fResult = CertGetValidUsages( 1, &pCertContext, &cUsage, NULL, &cbUsage );

    if ( fResult == TRUE )
    {
        cbSize = cbUsage + sizeof( CERT_ENHKEY_USAGE );

        if ( pUsage == NULL )
        {
            *pcbSize = cbSize;
            return( TRUE );
        }
        else if ( ( pUsage != NULL ) && ( *pcbSize < cbSize ) )
        {
            *pcbSize = cbSize;
            SetLastError( (DWORD) ERROR_MORE_DATA );
            return( FALSE );
        }

        pUsage->cUsageIdentifier = 0;
        pUsage->rgpszUsageIdentifier = (LPSTR *)( (LPBYTE)pUsage + sizeof( CERT_ENHKEY_USAGE ) );
        cbUsage = *pcbSize - sizeof( CERT_ENHKEY_USAGE );

        fResult = CertGetValidUsages(
                      1,
                      &pCertContext,
                      (int *)&pUsage->cUsageIdentifier,
                      pUsage->rgpszUsageIdentifier,
                      &cbUsage
                      );

        if ( fResult == TRUE )
        {
            if ( pUsage->cUsageIdentifier == 0xFFFFFFFF )
            {
                pUsage->cUsageIdentifier = 0;
                SetLastError( (DWORD) CRYPT_E_NOT_FOUND );
            }
            else if ( pUsage->cUsageIdentifier == 0 )
            {
                SetLastError( 0 );
            }
        }
    }

    return( fResult );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\ekuhlpr.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       ekuhlpr.h
//
//  Contents:   Certificate Enhanced Key Usage Helper API implementation
//
//  History:    22-May-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__EKUHLPR_H__)
#define __EKUHLPR_H__

PCRYPT_OBJID_BLOB EkuGetExtension (
                        PCCERT_CONTEXT pCertContext,
                        BOOL           *pfAppCertPolicies
                        );

HRESULT EkuGetProperty (
              PCCERT_CONTEXT    pCertContext,
              PCRYPT_OBJID_BLOB pEkuBlob
              );

HRESULT EkuSetProperty (
              PCCERT_CONTEXT    pCertContext,
              PCRYPT_OBJID_BLOB pEkuBlob
              );

HRESULT EkuDecodeCertPoliciesAndConvertToUsage (
              PCRYPT_OBJID_BLOB  pEkuBlob,
              DWORD*             pcbSize,
              PCERT_ENHKEY_USAGE pUsage     // OPTIONAL
              );

HRESULT EkuGetDecodedSize (
              PCRYPT_OBJID_BLOB pEkuBlob,
              DWORD*            pcbSize
              );

HRESULT EkuGetDecodedUsageSizes (
              BOOL              fExtCertPolicies,
              PCRYPT_OBJID_BLOB pExtBlob,
              PCRYPT_OBJID_BLOB pPropBlob,
              DWORD*            pcbSize,
              DWORD*            pcbExtSize,
              DWORD*            pcbPropSize
              );

HRESULT EkuGetDecodedUsage (
              PCRYPT_OBJID_BLOB  pEkuBlob,
              DWORD*             pcbSize,
              PCERT_ENHKEY_USAGE pUsage
              );

HRESULT EkuMergeUsage (
              DWORD              cbSize1,
              PCERT_ENHKEY_USAGE pUsage1,
              DWORD              cbSize2,
              PCERT_ENHKEY_USAGE pUsage2,
              DWORD              cbSizeM,
              PCERT_ENHKEY_USAGE pUsageM
              );

HRESULT EkuGetMergedDecodedUsage (
              BOOL               fExtCertPolicies,
              PCRYPT_OBJID_BLOB  pExtBlob,
              PCRYPT_OBJID_BLOB  pPropBlob,
              DWORD*             pcbSize,
              PCERT_ENHKEY_USAGE pUsage
              );

HRESULT EkuEncodeUsage (
              PCERT_ENHKEY_USAGE pUsage,
              PCRYPT_OBJID_BLOB  pEkuBlob
              );

HRESULT EkuGetUsage (
              PCCERT_CONTEXT      pCertContext,
              DWORD               dwFlags,
              DWORD*              pcbSize,
              PCERT_ENHKEY_USAGE* ppUsage
              );

#define CERT_FIND_ALL_ENHKEY_USAGE_FLAG (CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG |\
                                         CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG)

BOOL
EkuGetIntersectedUsageViaGetValidUsages (
   PCCERT_CONTEXT pCertContext,
   DWORD* pcbSize,
   PCERT_ENHKEY_USAGE pUsage
   );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\fndchain.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       fndchain.cpp
//
//  Contents:   Find Certificate Chain in Store API
//
//  Functions:  CertFindChainInStore
//              IFC_IsEndCertValidForUsage
//
//  History:    28-Feb-98   philh   created
//--------------------------------------------------------------------------


#include "global.hxx"
#include <dbgdef.h>


BOOL IFC_IsEndCertValidForUsages(
    IN PCCERT_CONTEXT pCert,
    IN PCERT_ENHKEY_USAGE pUsage,
    IN BOOL fOrUsage
    )
{
    BOOL fResult;
    int cNumOIDs;
    LPSTR *ppOIDs = NULL;
    DWORD cbOIDs;

    if (0 == pUsage->cUsageIdentifier)
        goto SuccessReturn;

    cbOIDs = 0;
    if (!CertGetValidUsages(
          1,    // cCerts
          &pCert,
          &cNumOIDs,
          NULL,             // rghOIDs
          &cbOIDs
          )) goto CertGetValidUsagesError;

    if (-1 == cNumOIDs)
        // Cert doesn't have any EKU
        goto SuccessReturn;
    else if (0 == cNumOIDs)
        // Intersection of usages in properties and extensions is NONE
        goto NoMatch;

    assert(cbOIDs);

    if (NULL == (ppOIDs = (LPSTR *) PkiNonzeroAlloc(cbOIDs)))
        goto OutOfMemory;

    if (!CertGetValidUsages(
          1,    // cCerts
          &pCert,
          &cNumOIDs,
          ppOIDs,
          &cbOIDs
          )) goto CertGetValidUsagesError;

    if (0 >= cNumOIDs)
        // We had a change from the first call
        goto NoMatch;


    {
        DWORD cId1 = pUsage->cUsageIdentifier;
        LPSTR *ppszId1 = pUsage->rgpszUsageIdentifier;
        for ( ; cId1 > 0; cId1--, ppszId1++) {
            DWORD cId2 = cNumOIDs;
            LPSTR *ppszId2 = ppOIDs;
            for ( ; cId2 > 0; cId2--, ppszId2++) {
                if (0 == strcmp(*ppszId1, *ppszId2)) {
                    if (fOrUsage)
                        goto SuccessReturn;
                    else
                        break;
                }
            }
            if (!fOrUsage && 0 == cId2)
                goto NoMatch;
        }

        if (fOrUsage)
            // For the "OR" option we're here without any match
            goto NoMatch;
        // else
        //  For the "AND" option we have matched all the specified
        //  identifiers
    }

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    PkiFree(ppOIDs);
    return fResult;

NoMatch:
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(CertGetValidUsagesError)
TRACE_ERROR(OutOfMemory)
}

BOOL IFC_IsEndCertValidForUsage(
    IN PCCERT_CONTEXT pCert,
    IN LPCSTR pszUsageIdentifier
    )
{
    CERT_ENHKEY_USAGE Usage = { 1, (LPSTR *) &pszUsageIdentifier};

    return IFC_IsEndCertValidForUsages(
        pCert,
        &Usage,
        TRUE        // fOrUsage
        );
}

BOOL CompareChainIssuerNameBlobs(
    IN DWORD dwCertEncodingType,
    IN DWORD dwFindFlags,
    IN PCERT_CHAIN_FIND_BY_ISSUER_PARA pPara,
    IN OUT PCCERT_CHAIN_CONTEXT *ppChainContext
    )
{
    DWORD i;
    DWORD cIssuer = pPara->cIssuer;
    PCERT_NAME_BLOB pIssuer = pPara->rgIssuer;
    PCCERT_CHAIN_CONTEXT pChainContext = *ppChainContext;

    if (0 == cIssuer)
        return TRUE;

    for (i = 0; i < pChainContext->cChain; i++) {
        DWORD j;
        PCERT_SIMPLE_CHAIN pChain;

        if (0 < i && 0 == (dwFindFlags &
                CERT_CHAIN_FIND_BY_ISSUER_COMPLEX_CHAIN_FLAG))
            break;

        pChain = pChainContext->rgpChain[i];
        for (j = 0; j < pChain->cElement; j++) {
            DWORD k;
            PCCERT_CONTEXT pCert = pChain->rgpElement[j]->pCertContext;
            PCERT_NAME_BLOB pChainIssuer = &pCert->pCertInfo->Issuer;

            for (k = 0; k < cIssuer; k++) {
                if (CertCompareCertificateName(
                        dwCertEncodingType,
                        pChainIssuer,
                        &pIssuer[k]
                        )) {
                    if (STRUCT_CBSIZE(CERT_CHAIN_FIND_BY_ISSUER_PARA,
                            pdwIssuerElementIndex) <= pPara->cbSize) {
                        if (pPara->pdwIssuerChainIndex)
                            *pPara->pdwIssuerChainIndex = i;
                        if (pPara->pdwIssuerElementIndex)
                            *pPara->pdwIssuerElementIndex = j + 1;
                    }
                    return TRUE;
                }
            }
        }
    }

    // See if we have a match in any of the lower quality chains

    for (i = 0; i < pChainContext->cLowerQualityChainContext; i++) {
        PCCERT_CHAIN_CONTEXT pLowerQualityChainContext =
            pChainContext->rgpLowerQualityChainContext[i];

        if (pLowerQualityChainContext->TrustStatus.dwErrorStatus &
                CERT_TRUST_IS_NOT_SIGNATURE_VALID)
            // Lower quality chains must at least have valid signatures
            continue;
        
        CertDuplicateCertificateChain(pLowerQualityChainContext);

        if (CompareChainIssuerNameBlobs(
                dwCertEncodingType,
                dwFindFlags,
                pPara,
                &pLowerQualityChainContext
                )) {
            // Replace the input chain context with the lower quality
            // chain context
            CertFreeCertificateChain(pChainContext);
            *ppChainContext = pLowerQualityChainContext;

            return TRUE;
        } else {
            assert(pLowerQualityChainContext ==
                pChainContext->rgpLowerQualityChainContext[i]);
            CertFreeCertificateChain(pLowerQualityChainContext);
        }
    }

    return FALSE;
}

static DWORD GetChainKeyIdentifierPropId(
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwKeySpec
    )
{
    DWORD dwPropId;
    PCRYPT_KEY_PROV_INFO pKeyProvInfo = NULL;
    DWORD cbKeyProvInfo;
    BYTE rgbKeyId[MAX_HASH_LEN];
    DWORD cbKeyId;
    CRYPT_HASH_BLOB KeyIdentifier;

    cbKeyId = sizeof(rgbKeyId);
    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_KEY_IDENTIFIER_PROP_ID,
            rgbKeyId,
            &cbKeyId
            ))
        return 0;

    KeyIdentifier.pbData = rgbKeyId;
    KeyIdentifier.cbData = cbKeyId;

    if (!CryptGetKeyIdentifierProperty(
            &KeyIdentifier,
            CERT_KEY_PROV_INFO_PROP_ID,
            CRYPT_KEYID_ALLOC_FLAG,
            NULL,                           // pwszComputerName
            NULL,                           // pvReserved
            (void *) &pKeyProvInfo,
            &cbKeyProvInfo
            )) {
        // Try again, searching LocalMachine
        if (!CryptGetKeyIdentifierProperty(
                &KeyIdentifier,
                CERT_KEY_PROV_INFO_PROP_ID,
                CRYPT_KEYID_ALLOC_FLAG | CRYPT_KEYID_MACHINE_FLAG,
                NULL,                           // pwszComputerName
                NULL,                           // pvReserved
                (void *) &pKeyProvInfo,
                &cbKeyProvInfo
                ))
            return 0;
    }

    if (dwKeySpec && dwKeySpec != pKeyProvInfo->dwKeySpec)
        dwPropId = 0;
    else
        dwPropId = CERT_KEY_PROV_INFO_PROP_ID;

    PkiDefaultCryptFree(pKeyProvInfo);
    return dwPropId;
}

DWORD GetChainPrivateKeyPropId(
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwKeySpec
    )
{
    DWORD dwPropId;
    CERT_KEY_CONTEXT KeyContext;
    PCRYPT_KEY_PROV_INFO pKeyProvInfo = NULL;
    DWORD cbProp;

    cbProp = sizeof(KeyContext);
    if (CertGetCertificateContextProperty(
            pCert,
            CERT_KEY_CONTEXT_PROP_ID,
            &KeyContext,
            &cbProp
            )) {
        assert(sizeof(KeyContext) <= cbProp);
        if (dwKeySpec && dwKeySpec != KeyContext.dwKeySpec)
            return 0;
        else
            return CERT_KEY_CONTEXT_PROP_ID;
    }

    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_KEY_PROV_INFO_PROP_ID,
            NULL,                       // pvData
            &cbProp
            ))
        return 0;

    if (NULL == (pKeyProvInfo = (PCRYPT_KEY_PROV_INFO) PkiNonzeroAlloc(
            cbProp)))
        goto OutOfMemory;

    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_KEY_PROV_INFO_PROP_ID,
            pKeyProvInfo,
            &cbProp
            )) goto CertGetCertificateContextPropertyError;

    if (dwKeySpec && dwKeySpec != pKeyProvInfo->dwKeySpec)
        goto NoMatch;

    dwPropId = CERT_KEY_PROV_INFO_PROP_ID;

CommonReturn:
    PkiFree(pKeyProvInfo);
    return dwPropId;

NoMatch:
ErrorReturn:
    dwPropId = 0;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
TRACE_ERROR(CertGetCertificateContextPropertyError)
}

BOOL FindChainByIssuer(
    IN DWORD dwCertEncodingType,
    IN DWORD dwFindFlags,
    IN PCERT_CHAIN_FIND_BY_ISSUER_PARA pPara,
    IN PCCERT_CONTEXT pCert,
    OUT PCCERT_CHAIN_CONTEXT *ppChainContext
    )
{
    BOOL fResult = TRUE;
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;
    DWORD dwPrivateKeyPropId;
    CERT_CHAIN_PARA ChainPara;
    DWORD dwCreateChainFlags;

    if (NULL == pPara ||
            offsetof(CERT_CHAIN_FIND_BY_ISSUER_PARA, pvFindArg) >
                pPara->cbSize) {
        fResult = FALSE;
        goto InvalidArg;
    }

    if (dwFindFlags & CERT_CHAIN_FIND_BY_ISSUER_NO_KEY_FLAG)
        dwPrivateKeyPropId = CERT_KEY_CONTEXT_PROP_ID;
    else if (0 == (dwPrivateKeyPropId = GetChainPrivateKeyPropId(
            pCert,
            pPara->dwKeySpec
            ))) {
        if (0 == (dwPrivateKeyPropId = GetChainKeyIdentifierPropId(
                pCert,
                pPara->dwKeySpec
                )))
            goto NoMatch;
    }

    if (pPara->pszUsageIdentifier) {
        if (!IFC_IsEndCertValidForUsage(
                pCert,
                pPara->pszUsageIdentifier
                )) goto NoMatch;
    }

    if (pPara->pfnFindCallback) {
        if (!pPara->pfnFindCallback(
                pCert,
                pPara->pvFindArg
                )) goto NoMatch;
    }

    memset(&ChainPara, 0, sizeof(ChainPara));
    ChainPara.cbSize = sizeof(ChainPara);
    if (pPara->pszUsageIdentifier) {
        ChainPara.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
        ChainPara.RequestedUsage.Usage.cUsageIdentifier = 1;
        ChainPara.RequestedUsage.Usage.rgpszUsageIdentifier =
            (LPSTR *) &pPara->pszUsageIdentifier;
    }

    dwCreateChainFlags = 0;
    if (0 != pPara->cIssuer) {
        // For cross certs, might need to look at the lower quality chains
        dwCreateChainFlags |= CERT_CHAIN_RETURN_LOWER_QUALITY_CONTEXTS;
    }

    if (dwFindFlags & CERT_CHAIN_FIND_BY_ISSUER_CACHE_ONLY_URL_FLAG)
        dwCreateChainFlags |= CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL;
    if (dwFindFlags & CERT_CHAIN_FIND_BY_ISSUER_LOCAL_MACHINE_FLAG)
        dwCreateChainFlags |= CERT_CHAIN_USE_LOCAL_MACHINE_STORE;

    if (!CertGetCertificateChain(
            NULL,                   // hChainEngine
            pCert,
            NULL,                   // pTime
            dwFindFlags & CERT_CHAIN_FIND_BY_ISSUER_CACHE_ONLY_FLAG ?
                0 : pCert->hCertStore,
            &ChainPara,
            dwCreateChainFlags,
            NULL,                   // pvReserved
            &pChainContext
            )) goto CertGetCertificateChainError;

    if (!CompareChainIssuerNameBlobs(
            dwCertEncodingType,
            dwFindFlags,
            pPara,
            &pChainContext
            )) goto NoMatch;


    if (dwFindFlags & CERT_CHAIN_FIND_BY_ISSUER_COMPARE_KEY_FLAG) {
        if (CERT_KEY_CONTEXT_PROP_ID != dwPrivateKeyPropId) {
            DWORD dwAcquireFlags = pPara->dwAcquirePrivateKeyFlags |
                CRYPT_ACQUIRE_COMPARE_KEY_FLAG;
            HCRYPTPROV hProv;
            BOOL fCallerFreeProv;

            if (!CryptAcquireCertificatePrivateKey(
                    pCert,
                    dwAcquireFlags,
                    NULL,               // pvReserved
                    &hProv,
                    NULL,               // pdwKeySpec
                    &fCallerFreeProv
                    )) goto CryptAcquireCertificatePrivateKeyError;

            if (fCallerFreeProv)
                CryptReleaseContext(hProv, 0);
        }
    }


CommonReturn:
    *ppChainContext = pChainContext;
    return fResult;

NoMatch:
ErrorReturn:
    if (pChainContext) {
        CertFreeCertificateChain(pChainContext);
        pChainContext = NULL;
    }
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(CertGetCertificateChainError)
TRACE_ERROR(CryptAcquireCertificatePrivateKeyError)
}
    

PCCERT_CHAIN_CONTEXT
WINAPI
CertFindChainInStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN DWORD dwFindFlags,
    IN DWORD dwFindType,
    IN const void *pvFindPara,
    IN PCCERT_CHAIN_CONTEXT pPrevChainContext
    )
{
    PCCERT_CONTEXT pCert = NULL;
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;

    if (0 == dwCertEncodingType)
        dwCertEncodingType = X509_ASN_ENCODING;

    if (pPrevChainContext) {
        if (pPrevChainContext->cChain) {
            PCERT_SIMPLE_CHAIN pChain = pPrevChainContext->rgpChain[0];
            if (pChain->cElement)
                pCert = CertDuplicateCertificateContext(
                    pChain->rgpElement[0]->pCertContext);
        }
        CertFreeCertificateChain(pPrevChainContext);
    }

    while (pCert = CertEnumCertificatesInStore(hCertStore, pCert)) {
        switch (dwFindType) {
            case CERT_CHAIN_FIND_BY_ISSUER:
                if (!FindChainByIssuer(
                        dwCertEncodingType,
                        dwFindFlags,
                        (PCERT_CHAIN_FIND_BY_ISSUER_PARA) pvFindPara,
                        pCert,
                        &pChainContext
                        )) goto FindChainByIssuerError;
                if (pChainContext)
                    goto CommonReturn;
                break;
            default:
                goto InvalidArg;
        }
    }

    SetLastError((DWORD) CRYPT_E_NOT_FOUND);

CommonReturn:
    if (pCert)
        CertFreeCertificateContext(pCert);
    return pChainContext;
ErrorReturn:
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(FindChainByIssuerError)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\frmtfunc.h ===
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:     frmtfunc.h
//
//  Contents:   The header for frmtfunc.cpp
//
//  History:    Sept. 1st, 1997
//              
//--------------------------------------------------------------------------

#ifndef __FRMTFUNC_H__
#define __FRMTFUNC_H__

#include <wchar.h> 
        
#include "wintrust.h"
#include "mssip.h"
#include "sipbase.h"
#include "pfx.h"


#ifdef __cplusplus
extern "C" {
#endif

//----------------------------------------------------------------------------
//	 constants
//--------------------------------------------------------------------------
#define	    UPPER_BITS			                        0xF0
#define	    LOWER_BITS			                        0x0F
#define	    CHAR_SIZE			                        2
#define	    HEX_SIZE			                        3    

//for other name in the subject alt name
#define		PREFIX_SIZE									50
#define		POSTFIX_SIZE								10
#define		INT_SIZE									20

//for szOID_BASIC_CONSTRAINTS2
#define		SUBJECT_SIZE								256
#define		NONE_SIZE									256
   
//for szOID_CRL_REASON_CODE
#define		CRL_REASON_SIZE								256

//for szOID_ENHANCED_KEY_USAGE
#define     NO_INFO_SIZE                                256

//for szOID_ALT_NAME
#define     UNKNOWN_VALUE_SIZE                          256
#define     ALT_NAME_SIZE                               256

//for SPC_FINANCIAL_CRIERIA
#define     AVAIL_SIZE                                  256
#define     YES_NO_SIZE                                 256

//for netscape cert type
#define		CERT_TYPE_SIZE								100

//
// Post Win2K
//

// for szOID_NAME_CONSTRAINTS
#define     NAME_CONSTRAINTS_SIZE                       256

//for Key Usage                                         
#define     KEY_USAGE_SIZE                              256
#define     UNKNOWN_ACCESS_METHOD_SIZE                  256
#define     UNKNOWN_KEY_USAGE_SIZE                      256
#define     DAY_SIZE                                    256
#define     MONTH_SIZE                                  256
#define     AMPM_SIZE                                   256
#define     CRL_DIST_NAME_SIZE                          256
#define     UNKNOWN_CRL_REASON_SIZE                     256
#define     PRE_FIX_SIZE                                256
#define     UNKNOWN_OID_SIZE                            256

//----------------------------------------------------------------------------
//	 WCHAR string contants
//--------------------------------------------------------------------------

//used for formatting
#define	wszPLUS			L" + "
#define	wszCOMMA		L", "
#define	wszSEMICOLON	L"; "
#define	wszCRLF			L"\r\n"
#define	wszEQUAL		L"="
#define	strCOMMA		", "

//
// Post Win2K
//
#define wszSPACE        L" "
#define wszTAB          L"     "
#define wszCOLON        L": "
#define wszEMPTY        L""

//certificate
#define BEGINCERT_W                 L"-----BEGIN CERTIFICATE-----"
#define CBBEGINCERT_W               (sizeof(BEGINCERT_W)/sizeof(WCHAR) - 1)

#define BEGINCERT_A                 "-----BEGIN CERTIFICATE-----"
#define CBBEGINCERT_A               (sizeof(BEGINCERT_A)/sizeof(CHAR) - 1)


//CRL
#define BEGINCRL_W					L"-----BEGIN X509 CRL-----"
#define	CBBEGINCRL_W				(sizeof(BEGINCRL_W)/sizeof(WCHAR) - 1)

#define BEGINCRL_A					"-----BEGIN X509 CRL-----"
#define	CBBEGINCRL_A				(sizeof(BEGINCRL_A)/sizeof(CHAR) - 1)


//certificate request
#define BEGINREQUEST_W				L"-----BEGIN NEW CERTIFICATE REQUEST-----"
#define CBBEGINREQUEST_W			(sizeof(BEGINREQUEST_W)/sizeof(WCHAR) - 1)

#define BEGINREQUEST_A				"-----BEGIN NEW CERTIFICATE REQUEST-----"
#define CBBEGINREQUEST_A			(sizeof(BEGINREQUEST_A)/sizeof(CHAR) - 1)


//---------------------------------------------------------
//	The following is used by this dll
//
//-----------------------------------------------------------  

const DWORD	g_AllocateSize=128*sizeof(WCHAR);


//macro needed to format the CA
#define _16BITMASK              ((1 << 16) - 1)
#define CANAMEIDTOIKEY(NameId)	((NameId) >> 16)
#define CANAMEIDTOICERT(NameId)	(_16BITMASK & (NameId))

typedef struct _FORMAT_CERT_TYPE_INFO {
	BYTE			bCertType;
	UINT			idsCertType;
} FORMAT_CERT_TYPE_INFO;

//---------------------------------------------------------------------------
//
//	Unitlity functions used by the dll
//---------------------------------------------------------------------------								
BOOL	DecodeGenericBLOB(DWORD dwEncodingType, LPCSTR lpszStructType,
			const BYTE *pbEncoded, DWORD cbEncoded,void **ppStructInfo); 
BOOL	FormatMessageUnicode(LPWSTR	*ppwszFormat,UINT ids,...);
HRESULT	SZtoWSZ(LPSTR szStr,LPWSTR *pwsz);
DWORD   FormatToStr(DWORD   dwFormatType);
//BOOL	FormatMessageStr(LPSTR	*ppszFormat,UINT ids,...);

BOOL    GetCertNameMulti(LPWSTR          pwszNameStr,
                         UINT            idsPreFix, 
                         LPWSTR          *ppwsz);

BOOL	FormatFileTime(FILETIME *pFileTime,LPWSTR   *ppwszFormat);

BOOL    FormatCertPolicyID(PCERT_POLICY_ID pCertPolicyID, LPWSTR    *ppwszFormat);

BOOL    FormatCRLReason(DWORD		    dwCertEncodingType,
	                    DWORD		    dwFormatType,
	                    DWORD		    dwFormatStrType,
	                    void		    *pFormatStruct,
	                    LPCSTR		    lpszStructType,
                        PCRYPT_BIT_BLOB pInfo,
                        LPWSTR          *ppwszFormat);



static BOOL
WINAPI
FormatBytesToHex(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);


BOOL FormatAltNameInfo(
    DWORD		            dwCertEncodingType,
	DWORD		            dwFormatType,
    DWORD                   dwFormatStrType,
    void	            	*pFormatStruct,
    UINT                    idsPreFix,
    BOOL                    fNewLine,
    PCERT_ALT_NAME_INFO	    pInfo,
    void	                *pbFormat,
	DWORD	                *pcbFormat);

static BOOL
WINAPI
FormatKeyUsageBLOB(
	DWORD		    dwCertEncodingType,
	DWORD		    dwFormatType,
	DWORD		    dwFormatStrType,
	void		    *pFormatStruct,
	LPCSTR		    lpszStructType,
    PCRYPT_BIT_BLOB	pInfo,
	void	        *pbFormat,
	DWORD	        *pcbFormat);

BOOL    FormatDistPointName(
    DWORD		            dwCertEncodingType,                         
	DWORD		            dwFormatType,                               
	DWORD		            dwFormatStrType,                            
	void		            *pFormatStruct,                             
    PCRL_DIST_POINT_NAME    pInfo,                                      
    LPWSTR                  *ppwszFormat);    

BOOL FormatCertQualifier(
	DWORD		                    dwCertEncodingType,
	DWORD		                    dwFormatType,
	DWORD		                    dwFormatStrType,
	void		                    *pFormatStruct,
    PCERT_POLICY_QUALIFIER_INFO     pInfo,
    LPWSTR                          *ppwszFormat);

BOOL FormatSPCObject(
	DWORD		                dwFormatType,
	DWORD		                dwFormatStrType,
    void		                *pFormatStruct,
    UINT                        idsPrefix,
    PSPC_SERIALIZED_OBJECT      pInfo,
    LPWSTR                      *ppwszFormat);

BOOL FormatSPCLink(
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
    void		*pFormatStruct,
    UINT        idsPrefix,
    PSPC_LINK   pInfo,
    LPWSTR      *ppwszFormat);

BOOL FormatSPCImage(
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
    void		*pFormatStruct,
    UINT        idsPrefix,
    PSPC_IMAGE  pInfo,
    LPWSTR      *ppwszImageFormat);


BOOL	CryptDllFormatNameAll(  
				DWORD		dwEncodingType,	
				DWORD		dwFormatType,
				DWORD		dwFormatStrType,
				void		*pStruct,
                UINT        idsPreFix,
                BOOL        fToAllocate,
				const BYTE	*pbEncoded,
				DWORD		cbEncoded,
				void		**ppbBuffer,
				DWORD		*pcbBuffer);

                          


#ifdef __cplusplus
}       // Balance extern "C" above
#endif


#endif // __FRMTFUNC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\frmtfunc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       frmtfunc.cpp
//
//  Contents:   OID format functions
//
//  Functions:  CryptFrmtFuncDllMain
//              CryptFormatObject
//              CryptQueryObject
//
//  History:    15-05-97    xiaohs   created
//              27 Oct 1999 dsie     add post win2k features.
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>
#include "frmtfunc.h"

HMODULE hFrmtFuncInst;

static HCRYPTOIDFUNCSET hFormatFuncSet;


//function type define
typedef BOOL (WINAPI *PFN_FORMAT_FUNC)(
	IN DWORD dwCertEncodingType,
    IN DWORD dwFormatType,
	IN DWORD dwFormatStrType,
	IN void	 *pFormatStruct,
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
	OUT void *pbFormat,
    IN OUT DWORD *pcbFormat
    );

static BOOL
WINAPI
FormatBytesToHex(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);


static BOOL	
WINAPI	
CryptDllFormatAttr(
				DWORD		dwEncodingType,	
				DWORD		dwFormatType,
				DWORD		dwFormatStrType,
				void		*pStruct,
				LPCSTR		lpszStructType,
				const BYTE	*pbEncoded,
				DWORD		cbEncoded,
				void		*pBuffer,
				DWORD		*pcBuffer);


static BOOL	
WINAPI	
CryptDllFormatName(
				DWORD		dwEncodingType,	
				DWORD		dwFormatType,
				DWORD		dwFormatStrType,
				void		*pStruct,
				LPCSTR		lpszStructType,
				const BYTE	*pbEncoded,
				DWORD		cbEncoded,
				void		*pbBuffer,
				DWORD		*pcbBuffer);

static BOOL
WINAPI
FormatBasicConstraints2(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatBasicConstraints(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);


static BOOL
WINAPI
FormatCRLReasonCode(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatEnhancedKeyUsage(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);


static BOOL
WINAPI
FormatAltName(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatAuthorityKeyID(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatAuthorityKeyID2(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatNextUpdateLocation(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatSubjectKeyID(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatFinancialCriteria(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);


static BOOL
WINAPI
FormatSMIMECapabilities(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatKeyUsage(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);


static BOOL
WINAPI
FormatAuthortiyInfoAccess(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatKeyAttributes(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);


static BOOL
WINAPI
FormatKeyRestriction(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatCRLDistPoints(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatCertPolicies(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatCAVersion(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatAnyUnicodeStringExtension(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);


static BOOL
WINAPI
FormatAnyNameValueStringAttr(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatNetscapeCertType(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);


static BOOL
WINAPI
FormatSPAgencyInfo(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

//
// DSIE: Post Win2K.
//

static BOOL
WINAPI
FormatCrlNumber (
	DWORD       dwCertEncodingType,
	DWORD       dwFormatType,
	DWORD       dwFormatStrType,
	void       *pFormatStruct,
	LPCSTR      lpszStructType,
	const BYTE *pbEncoded,
	DWORD       cbEncoded,
	void       *pbFormat,
	DWORD      *pcbFormat);

static BOOL
WINAPI
FormatCrlNextPublish (
	DWORD       dwCertEncodingType,
	DWORD       dwFormatType,
	DWORD       dwFormatStrType,
	void       *pFormatStruct,
	LPCSTR      lpszStructType,
	const BYTE *pbEncoded,
	DWORD       cbEncoded,
	void       *pbFormat,
	DWORD      *pcbFormat);

static BOOL
WINAPI
FormatIssuingDistPoint (
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatNameConstraints (
	DWORD       dwCertEncodingType,
	DWORD       dwFormatType,
	DWORD       dwFormatStrType,
	void       *pFormatStruct,
	LPCSTR      lpszStructType,
	const BYTE *pbEncoded,
	DWORD       cbEncoded,
	void       *pbFormat,
	DWORD      *pcbFormat);

static BOOL
WINAPI
FormatCertSrvPreviousCertHash (
	DWORD       dwCertEncodingType,
	DWORD       dwFormatType,
	DWORD       dwFormatStrType,
	void       *pFormatStruct,
	LPCSTR      lpszStructType,
	const BYTE *pbEncoded,
	DWORD       cbEncoded,
	void       *pbFormat,
	DWORD      *pcbFormat);

static BOOL
WINAPI
FormatPolicyMappings (
	DWORD       dwCertEncodingType,
	DWORD       dwFormatType,
	DWORD       dwFormatStrType,
	void       *pFormatStruct,
	LPCSTR      lpszStructType,
	const BYTE *pbEncoded,
	DWORD       cbEncoded,
	void       *pbFormat,
	DWORD      *pcbFormat);

static BOOL
WINAPI
FormatPolicyConstraints (
	DWORD       dwCertEncodingType,
	DWORD       dwFormatType,
	DWORD       dwFormatStrType,
	void       *pFormatStruct,
	LPCSTR      lpszStructType,
	const BYTE *pbEncoded,
	DWORD       cbEncoded,
	void       *pbFormat,
	DWORD      *pcbFormat);

static BOOL
WINAPI
FormatCertificateTemplate (
	DWORD       dwCertEncodingType,
	DWORD       dwFormatType,
	DWORD       dwFormatStrType,
	void       *pFormatStruct,
	LPCSTR      lpszStructType,
	const BYTE *pbEncoded,
	DWORD       cbEncoded,
	void       *pbFormat,
	DWORD      *pcbFormat);

static BOOL
WINAPI
FormatXCertDistPoints(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static const CRYPT_OID_FUNC_ENTRY DefaultFormatTable[] = {
    CRYPT_DEFAULT_OID, FormatBytesToHex};

static const CRYPT_OID_FUNC_ENTRY OIDFormatTable[] = {
				szOID_COMMON_NAME,						CryptDllFormatAttr,	
				szOID_SUR_NAME,                      	CryptDllFormatAttr,
				szOID_DEVICE_SERIAL_NUMBER,          	CryptDllFormatAttr,
				szOID_COUNTRY_NAME,                  	CryptDllFormatAttr,
				szOID_LOCALITY_NAME,                 	CryptDllFormatAttr,
				szOID_STATE_OR_PROVINCE_NAME,        	CryptDllFormatAttr,
				szOID_STREET_ADDRESS,                	CryptDllFormatAttr,
				szOID_ORGANIZATION_NAME,             	CryptDllFormatAttr,
				szOID_ORGANIZATIONAL_UNIT_NAME,      	CryptDllFormatAttr,
				szOID_TITLE,                         	CryptDllFormatAttr,
				szOID_DESCRIPTION,                   	CryptDllFormatAttr,
				szOID_SEARCH_GUIDE,                  	CryptDllFormatAttr,
				szOID_BUSINESS_CATEGORY,             	CryptDllFormatAttr,
				szOID_POSTAL_ADDRESS,                	CryptDllFormatAttr,
				szOID_POSTAL_CODE,                   	CryptDllFormatAttr,
				szOID_POST_OFFICE_BOX,               	CryptDllFormatAttr,
				szOID_PHYSICAL_DELIVERY_OFFICE_NAME, 	CryptDllFormatAttr,
				szOID_TELEPHONE_NUMBER,              	CryptDllFormatAttr,
				szOID_TELEX_NUMBER,                  	CryptDllFormatAttr,
				szOID_TELETEXT_TERMINAL_IDENTIFIER,  	CryptDllFormatAttr,
				szOID_FACSIMILE_TELEPHONE_NUMBER,    	CryptDllFormatAttr,
				szOID_X21_ADDRESS,                   	CryptDllFormatAttr,
				szOID_INTERNATIONAL_ISDN_NUMBER,     	CryptDllFormatAttr,
				szOID_REGISTERED_ADDRESS,            	CryptDllFormatAttr,
				szOID_DESTINATION_INDICATOR,         	CryptDllFormatAttr,
				szOID_PREFERRED_DELIVERY_METHOD,     	CryptDllFormatAttr,
				szOID_PRESENTATION_ADDRESS,          	CryptDllFormatAttr,
				szOID_SUPPORTED_APPLICATION_CONTEXT, 	CryptDllFormatAttr,
				szOID_MEMBER,                        	CryptDllFormatAttr,
				szOID_OWNER,                         	CryptDllFormatAttr,
				szOID_ROLE_OCCUPANT,                 	CryptDllFormatAttr,
				szOID_SEE_ALSO,                      	CryptDllFormatAttr,
				szOID_USER_PASSWORD,                 	CryptDllFormatAttr,
				szOID_USER_CERTIFICATE,              	CryptDllFormatAttr,
				szOID_CA_CERTIFICATE,                	CryptDllFormatAttr,
				szOID_AUTHORITY_REVOCATION_LIST,     	CryptDllFormatAttr,
				szOID_CERTIFICATE_REVOCATION_LIST,   	CryptDllFormatAttr,
				szOID_CROSS_CERTIFICATE_PAIR,        	CryptDllFormatAttr,
				szOID_GIVEN_NAME,                    	CryptDllFormatAttr,
				szOID_INITIALS,                     	CryptDllFormatAttr,
                szOID_DOMAIN_COMPONENT,                 CryptDllFormatAttr,
                szOID_PKCS_12_FRIENDLY_NAME_ATTR,       CryptDllFormatAttr,
                szOID_PKCS_12_LOCAL_KEY_ID,             CryptDllFormatAttr,
				X509_NAME,								CryptDllFormatName,
				X509_UNICODE_NAME,						CryptDllFormatName,
				szOID_BASIC_CONSTRAINTS2,				FormatBasicConstraints2,
				X509_BASIC_CONSTRAINTS2,				FormatBasicConstraints2,
                szOID_BASIC_CONSTRAINTS,                FormatBasicConstraints,
                X509_BASIC_CONSTRAINTS,                 FormatBasicConstraints,
				szOID_CRL_REASON_CODE,					FormatCRLReasonCode,
				X509_CRL_REASON_CODE,					FormatCRLReasonCode,
				szOID_ENHANCED_KEY_USAGE,				FormatEnhancedKeyUsage,
				X509_ENHANCED_KEY_USAGE,				FormatEnhancedKeyUsage,
                szOID_SUBJECT_ALT_NAME,                 FormatAltName,
                szOID_ISSUER_ALT_NAME,                  FormatAltName,
                szOID_SUBJECT_ALT_NAME2,                FormatAltName,
                szOID_ISSUER_ALT_NAME2,                 FormatAltName,
                X509_ALTERNATE_NAME,                    FormatAltName,
                szOID_AUTHORITY_KEY_IDENTIFIER,         FormatAuthorityKeyID,
                X509_AUTHORITY_KEY_ID,                  FormatAuthorityKeyID,
                szOID_AUTHORITY_KEY_IDENTIFIER2,        FormatAuthorityKeyID2,
                X509_AUTHORITY_KEY_ID2,                 FormatAuthorityKeyID2,
                szOID_NEXT_UPDATE_LOCATION,             FormatNextUpdateLocation,
                szOID_SUBJECT_KEY_IDENTIFIER,           FormatSubjectKeyID,
                SPC_FINANCIAL_CRITERIA_OBJID,           FormatFinancialCriteria,
                SPC_FINANCIAL_CRITERIA_STRUCT,          FormatFinancialCriteria,
                szOID_RSA_SMIMECapabilities,            FormatSMIMECapabilities,
                PKCS_SMIME_CAPABILITIES,                FormatSMIMECapabilities,
                szOID_KEY_USAGE,                        FormatKeyUsage,
                X509_KEY_USAGE,                         FormatKeyUsage,
                szOID_AUTHORITY_INFO_ACCESS,            FormatAuthortiyInfoAccess,
                X509_AUTHORITY_INFO_ACCESS,             FormatAuthortiyInfoAccess,
                szOID_KEY_ATTRIBUTES,                   FormatKeyAttributes,
                X509_KEY_ATTRIBUTES,                    FormatKeyAttributes,
                szOID_KEY_USAGE_RESTRICTION,            FormatKeyRestriction,
                X509_KEY_USAGE_RESTRICTION,             FormatKeyRestriction,
                szOID_CRL_DIST_POINTS,                  FormatCRLDistPoints,
                X509_CRL_DIST_POINTS,                   FormatCRLDistPoints,
                szOID_FRESHEST_CRL,                     FormatCRLDistPoints,    // Post Win2K
                szOID_CERT_POLICIES,                    FormatCertPolicies,
                X509_CERT_POLICIES,                     FormatCertPolicies,
				szOID_ENROLL_CERTTYPE_EXTENSION,		FormatAnyUnicodeStringExtension,
				szOID_OS_VERSION,						FormatAnyUnicodeStringExtension,
				szOID_NETSCAPE_CERT_TYPE,				FormatNetscapeCertType,
				szOID_NETSCAPE_BASE_URL,				FormatAnyUnicodeStringExtension,
				szOID_NETSCAPE_REVOCATION_URL,			FormatAnyUnicodeStringExtension,
				szOID_NETSCAPE_CA_REVOCATION_URL,		FormatAnyUnicodeStringExtension,
				szOID_NETSCAPE_CERT_RENEWAL_URL,		FormatAnyUnicodeStringExtension,
				szOID_NETSCAPE_CA_POLICY_URL,			FormatAnyUnicodeStringExtension,
				szOID_NETSCAPE_SSL_SERVER_NAME,			FormatAnyUnicodeStringExtension,
				szOID_NETSCAPE_COMMENT,					FormatAnyUnicodeStringExtension,
				szOID_ENROLLMENT_NAME_VALUE_PAIR,		FormatAnyNameValueStringAttr,
				szOID_CERTSRV_CA_VERSION,				FormatCAVersion,
				SPC_SP_AGENCY_INFO_OBJID,               FormatSPAgencyInfo,
                SPC_SP_AGENCY_INFO_STRUCT,              FormatSPAgencyInfo,

                // Post Win2K
                szOID_CRL_NUMBER,                       FormatCrlNumber,
                szOID_DELTA_CRL_INDICATOR,              FormatCrlNumber,
				szOID_CRL_VIRTUAL_BASE,					FormatCrlNumber,
                szOID_CRL_NEXT_PUBLISH,                 FormatCrlNextPublish,
                szOID_ISSUING_DIST_POINT,               FormatIssuingDistPoint,
                X509_ISSUING_DIST_POINT,                FormatIssuingDistPoint,
                szOID_NAME_CONSTRAINTS,                 FormatNameConstraints,
                X509_NAME_CONSTRAINTS,                  FormatNameConstraints,
                szOID_CERTSRV_PREVIOUS_CERT_HASH,       FormatCertSrvPreviousCertHash,

                szOID_APPLICATION_CERT_POLICIES,        FormatCertPolicies,
                X509_POLICY_MAPPINGS,                   FormatPolicyMappings,
                szOID_POLICY_MAPPINGS,                  FormatPolicyMappings,
                szOID_APPLICATION_POLICY_MAPPINGS,      FormatPolicyMappings,
                X509_POLICY_CONSTRAINTS,                FormatPolicyConstraints,
                szOID_POLICY_CONSTRAINTS,               FormatPolicyConstraints,
                szOID_APPLICATION_POLICY_CONSTRAINTS,   FormatPolicyConstraints,
                X509_CERTIFICATE_TEMPLATE,              FormatCertificateTemplate,
                szOID_CERTIFICATE_TEMPLATE,             FormatCertificateTemplate,
                szOID_CRL_SELF_CDP,                     FormatCRLDistPoints,
                X509_CROSS_CERT_DIST_POINTS,            FormatXCertDistPoints,
                szOID_CROSS_CERT_DIST_POINTS,           FormatXCertDistPoints,
};

DWORD dwOIDFormatCount = sizeof(OIDFormatTable) / sizeof(OIDFormatTable[0]);

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptFrmtFuncDllMain(
        HMODULE hModule,
        DWORD  fdwReason,
        LPVOID lpReserved)
{
    BOOL    fRet;

    switch (fdwReason) {
    case DLL_PROCESS_ATTACH:

		hFrmtFuncInst = hModule;

        if (NULL == (hFormatFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_FORMAT_OBJECT_FUNC,
                0)))                                // dwFlags
            goto CryptInitFrmtFuncError;

		//install the default formatting routine
		if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CRYPT_OID_FORMAT_OBJECT_FUNC,
                1,
                DefaultFormatTable,
                0))                         // dwFlags
            goto CryptInstallFrmtFuncError;

		//install the OID formatting routine
		if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CRYPT_OID_FORMAT_OBJECT_FUNC,
                dwOIDFormatCount,
                OIDFormatTable,
                0))                         // dwFlags
            goto CryptInstallFrmtFuncError;


		break;

    case DLL_PROCESS_DETACH:
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CryptInitFrmtFuncError)
TRACE_ERROR(CryptInstallFrmtFuncError)
}


//------------------------------------------------------------------------
//	   Convert the byte to its Hex presentation.
//
//	   Precondition: byte is less than 15
//
//------------------------------------------------------------------------
ULONG ByteToHex(BYTE byte, LPWSTR wszZero, LPWSTR wszA)
{
	ULONG uValue=0;

	if(((ULONG)byte)<=9)
	{
		uValue=((ULONG)byte)+ULONG(*wszZero);	
	}
	else
	{
		uValue=(ULONG)byte-10+ULONG(*wszA);

	}

	return uValue;

}
//--------------------------------------------------------------------------
//
//	 Format the encoded bytes into a hex string in the format of
//   xxxx xxxx xxxx xxxx ...
//
//   DSIE 6/28/2000: change format to xx xx xx xx, per VicH's request.
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatBytesToHex(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	LPWSTR	pwszBuffer=NULL;
	DWORD	dwBufferSize=0;
	DWORD	dwBufferIndex=0;
	DWORD	dwEncodedIndex=0;
	WCHAR	wszSpace[CHAR_SIZE];
	WCHAR	wszZero[CHAR_SIZE];
	WCHAR	wszA[CHAR_SIZE];
	WCHAR	wszHex[HEX_SIZE];
	
	//check for input parameters
	if(( pbEncoded!=NULL && cbEncoded==0)
		||(pbEncoded==NULL && cbEncoded!=0)
		|| (pcbFormat==NULL))
	{
		SetLastError((DWORD) E_INVALIDARG);
		return FALSE;
	}

#if (0) // DSIE: Fix bug 128630.
	//check for simple case.  No work needed
	if(pbEncoded==NULL && cbEncoded==0)
	{
		*pcbFormat=0;
		return TRUE;
	}
#endif

	//calculate the memory needed, in bytes
	//we need 3 wchars per byte, along with the NULL terminator
	dwBufferSize=sizeof(WCHAR)*(cbEncoded*3+1);

	//length only calculation
	if(pcbFormat!=NULL && pbFormat==NULL)
	{
		*pcbFormat=dwBufferSize;
		return TRUE;
	}

	//load the string
	if(!LoadStringU(hFrmtFuncInst, IDS_FRMT_SPACE, wszSpace,
		CHAR_SIZE)
	  ||!LoadStringU(hFrmtFuncInst, IDS_FRMT_ZERO, wszZero,
	    CHAR_SIZE)
	  ||!LoadStringU(hFrmtFuncInst, IDS_FRMT_A, wszA,
	   CHAR_SIZE)
	  ||!LoadStringU(hFrmtFuncInst, IDS_FRMT_HEX, wszHex,
	  HEX_SIZE)
	  )
	{
		SetLastError((DWORD) E_UNEXPECTED);
		return FALSE;
	}

	pwszBuffer=(LPWSTR)malloc(dwBufferSize);
	if(!pwszBuffer)
	{
		SetLastError((DWORD) E_OUTOFMEMORY);
		return FALSE;
	}

	dwBufferIndex=0;

	//format the wchar buffer one byte at a time
	for(dwEncodedIndex=0; dwEncodedIndex<cbEncoded; dwEncodedIndex++)
	{
#if (0) // DSIE:
		//copy the space between every two bytes.  Skip for the 1st byte
        if((0!=dwEncodedIndex) && (0==(dwEncodedIndex % 2)))
#else
		//copy the space between every byte.  Skip for the 1st byte
        if(dwEncodedIndex != 0)
#endif
        {
		    pwszBuffer[dwBufferIndex]=wszSpace[0];
		    dwBufferIndex++;
        }

		//format the higher 4 bits
		pwszBuffer[dwBufferIndex]=(WCHAR)ByteToHex(
			 (BYTE)( (pbEncoded[dwEncodedIndex]&UPPER_BITS)>>4 ),
			 wszZero, wszA);

		dwBufferIndex++;

		//format the lower 4 bits
		pwszBuffer[dwBufferIndex]=(WCHAR)ByteToHex(
			 (BYTE)( pbEncoded[dwEncodedIndex]&LOWER_BITS ),
			 wszZero, wszA);

		dwBufferIndex++;
	}

	//add the NULL terminator to the string
	pwszBuffer[dwBufferIndex]=wszSpace[1];

    //calculate the real size for the buffer
    dwBufferSize=sizeof(WCHAR)*(wcslen(pwszBuffer)+1);

	//copy the buffer
	memcpy(pbFormat, pwszBuffer,
		(*pcbFormat>=dwBufferSize) ? dwBufferSize : *pcbFormat);

	free(pwszBuffer);

	//make sure the user has supplied enough memory
	if(*pcbFormat < dwBufferSize)
	{
		*pcbFormat=dwBufferSize;
		SetLastError((DWORD) ERROR_MORE_DATA);
		return FALSE;
	}
		
	*pcbFormat=dwBufferSize;

	return TRUE;
}

//+-----------------------------------------------------------------------------
//
//  AllocateAnsiToUnicode
//
//------------------------------------------------------------------------------

static BOOL
WINAPI
AllocateAnsiToUnicode(
    LPCSTR pszAnsi, 
    LPWSTR * ppwszUnicode)
{
    BOOL   fResult     = FALSE;
    LPWSTR pwszUnicode = NULL;
    DWORD  dwWideSize  = 0;

    if (!ppwszUnicode)
    {
		goto InvalidArg;
    }

    *ppwszUnicode = NULL;

    if (!pszAnsi)
    {
        return TRUE;
    }

	if (!(dwWideSize = MultiByteToWideChar(CP_ACP,
                                           0,
	                                       pszAnsi,
                                           strlen(pszAnsi),
                                           NULL,
                                           0)))
    {
		goto szTOwszError;
    }

    //
	// Allocate memory, including the NULL terminator.
    //
	if (!(pwszUnicode = (WCHAR *) malloc(sizeof(WCHAR) * (dwWideSize + 1))))
    {
		goto MemoryError;
    }

    memset(pwszUnicode, 0, sizeof(WCHAR) * (dwWideSize + 1));

	if (!MultiByteToWideChar(CP_ACP,
                             0,
	                         pszAnsi,
                             strlen(pszAnsi),
                             pwszUnicode,
                             dwWideSize))
    {
        free(pwszUnicode);
		goto szTOwszError;
    }

    *ppwszUnicode = pwszUnicode;

    fResult = TRUE;

CommonReturn:

    return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg,E_INVALIDARG);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(szTOwszError);
}

//+-----------------------------------------------------------------------------
//
//  FormatObjectId
//
//------------------------------------------------------------------------------

static BOOL
WINAPI
FormatObjectId (
    LPSTR    pszObjId,
    DWORD    dwGroupId,
    BOOL     bMultiLines,
    LPWSTR * ppwszFormat)
{
    BOOL              fResult;
	PCCRYPT_OID_INFO  pOIDInfo    = NULL;
    LPWSTR            pwszObjId   = NULL;

    //
    // Initialize.
    //
    *ppwszFormat = NULL;

    //
    // Convert OID to Unicode.
    //
    if (!AllocateAnsiToUnicode(pszObjId, &pwszObjId))
    {
        goto AnsiToUnicodeError;
    }

    //
    // Find OID info.
    //
    if (pOIDInfo = CryptFindOIDInfo(CRYPT_OID_INFO_OID_KEY,
                                    (void *) pszObjId,
                                    dwGroupId))
	{
        //
        // "%1!s!(%2!s!)%3!s!"
        //
        if (!FormatMessageUnicode(ppwszFormat, 
                                  IDS_GENERIC_OBJECT_ID,
                                  pOIDInfo->pwszName,
                                  pwszObjId,
                                  bMultiLines ? wszCRLF : wszEMPTY))
        {
            goto FormatMessageError;
        }
    }
    else
    {
        //
        // "%1!s!%2!s!"
        //
        if (!FormatMessageUnicode(ppwszFormat, 
                                  IDS_STRING,
                                  pwszObjId,
                                  bMultiLines ? wszCRLF : wszEMPTY))
        {
            goto FormatMessageError;
        }
    }

    fResult = TRUE;

CommonReturn:

    if (pwszObjId)
    {
        free(pwszObjId);
    }

    return fResult;

ErrorReturn:

	fResult = FALSE;
	goto CommonReturn;

TRACE_ERROR(AnsiToUnicodeError);
TRACE_ERROR(FormatMessageError);
}

//+-----------------------------------------------------------------------------
//
//  FormatIPAddress
//
//------------------------------------------------------------------------------

static BOOL
WINAPI
FormatIPAddress(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void	   *pFormatStruct,
	LPCSTR	    lpszStructType,
    UINT        idsPrefix,
    const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
    BOOL   fResult;
    DWORD  cbNeeded    = 0;
    LPWSTR pwszFormat  = NULL;
    WCHAR  wszPrefix[PRE_FIX_SIZE] = wszEMPTY;
    BOOL   bMultiLines = dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE;

    //
	// Check for input parameters.
    //
	if ((pbEncoded!=NULL && cbEncoded==0) ||
        (pbEncoded==NULL && cbEncoded!=0) || 
        (pcbFormat==NULL))
	{
		goto InvalidArg;
	}

    if (bMultiLines && idsPrefix)
    {
        if(!LoadStringU(hFrmtFuncInst, 
                        idsPrefix,
                        wszPrefix, 
                        sizeof(wszPrefix) / sizeof(wszPrefix[0])))
        {
            goto LoadStringError;
        }
    }

    switch (cbEncoded)
    {
        case 4:
        {
            //
            // "%1!d!.%2!d!.%3!d!.%4!d!"
            //
            if (!FormatMessageUnicode(&pwszFormat,
                                      IDS_IPADDRESS_V4_4,
                                      (DWORD) pbEncoded[0],
                                      (DWORD) pbEncoded[1],
                                      (DWORD) pbEncoded[2],
                                      (DWORD) pbEncoded[3]))
            {
                goto FormatMessageError;
            }

            break;
        }

        case 8:
        {
            //
            // "%1!d!.%2!d!.%3!d!.%4!d!%5!s!%6!s!Mask=%7!d!.%8!d!.%9!d!.%10!d!"
            //
            if (!FormatMessageUnicode(&pwszFormat,
                                      IDS_IPADDRESS_V4_8,
                                      (DWORD) pbEncoded[0],
                                      (DWORD) pbEncoded[1],
                                      (DWORD) pbEncoded[2],
                                      (DWORD) pbEncoded[3],
                                      bMultiLines ? wszCRLF : wszEMPTY,
                                      bMultiLines ? wszPrefix : wszCOMMA,
                                      (DWORD) pbEncoded[4],
                                      (DWORD) pbEncoded[5],
                                      (DWORD) pbEncoded[6],
                                      (DWORD) pbEncoded[7]))
            {
                goto FormatMessageError;
            }

            break;
        }

        case 16:
        {
            //
            // "%1!02x!%2!02x!:%3!02x!%4!02x!:%5!02x!%6!02x!:%7!02x!%8!02x!:%9!02x!%10!02x!:%11!02x!%12!02x!:%13!02x!%14!02x!:%15!02x!%16!02x!"
            //
            if (!FormatMessageUnicode(&pwszFormat,
                                      IDS_IPADDRESS_V6_16,
                                      (DWORD) pbEncoded[0],
                                      (DWORD) pbEncoded[1],
                                      (DWORD) pbEncoded[2],
                                      (DWORD) pbEncoded[3],
                                      (DWORD) pbEncoded[4],
                                      (DWORD) pbEncoded[5],
                                      (DWORD) pbEncoded[6],
                                      (DWORD) pbEncoded[7],
                                      (DWORD) pbEncoded[8],
                                      (DWORD) pbEncoded[9],
                                      (DWORD) pbEncoded[10],
                                      (DWORD) pbEncoded[11],
                                      (DWORD) pbEncoded[12],
                                      (DWORD) pbEncoded[13],
                                      (DWORD) pbEncoded[14],
                                      (DWORD) pbEncoded[15]))
            {
                goto FormatMessageError;
            }

            break;
        }

        case 32:
        {
            //
            // "%1!02x!%2!02x!:%3!02x!%4!02x!:%5!02x!%6!02x!:%7!02x!%8!02x!:%9!02x!%10!02x!:%11!02x!%12!02x!:%13!02x!%14!02x!:%15!02x!%16!02x!%17!s!%18!s!
            //  Mask=%19!02x!%20!02x!:%21!02x!%22!02x!:%23!02x!%24!02x!:%25!02x!%26!02x!:%27!02x!%28!02x!:%29!02x!%30!02x!:%31!02x!%32!02x!:%33!02x!%34!02x!"
            //
            if (!FormatMessageUnicode(&pwszFormat,
                                      IDS_IPADDRESS_V6_32,
                                      (DWORD) pbEncoded[0],
                                      (DWORD) pbEncoded[1],
                                      (DWORD) pbEncoded[2],
                                      (DWORD) pbEncoded[3],
                                      (DWORD) pbEncoded[4],
                                      (DWORD) pbEncoded[5],
                                      (DWORD) pbEncoded[6],
                                      (DWORD) pbEncoded[7],
                                      (DWORD) pbEncoded[8],
                                      (DWORD) pbEncoded[9],
                                      (DWORD) pbEncoded[10],
                                      (DWORD) pbEncoded[11],
                                      (DWORD) pbEncoded[12],
                                      (DWORD) pbEncoded[13],
                                      (DWORD) pbEncoded[14],
                                      (DWORD) pbEncoded[15],
                                      bMultiLines ? wszCRLF : wszEMPTY,
                                      bMultiLines ? wszPrefix : wszCOMMA,
                                      (DWORD) pbEncoded[16],
                                      (DWORD) pbEncoded[17],
                                      (DWORD) pbEncoded[18],
                                      (DWORD) pbEncoded[19],
                                      (DWORD) pbEncoded[20],
                                      (DWORD) pbEncoded[21],
                                      (DWORD) pbEncoded[22],
                                      (DWORD) pbEncoded[23],
                                      (DWORD) pbEncoded[24],
                                      (DWORD) pbEncoded[25],
                                      (DWORD) pbEncoded[26],
                                      (DWORD) pbEncoded[27],
                                      (DWORD) pbEncoded[28],
                                      (DWORD) pbEncoded[29],
                                      (DWORD) pbEncoded[30],
                                      (DWORD) pbEncoded[31]))
            {
                goto FormatMessageError;
            }

            break;
        }

        default:
        {
            if (!(fResult = FormatBytesToHex(dwCertEncodingType,
                                             dwFormatType,
                                             dwFormatStrType,
                                             pFormatStruct,
                                             lpszStructType,
                                             pbEncoded,
                                             cbEncoded,
                                             pbFormat,
                                             pcbFormat)))
            {
                goto FormatBytesToHexError;
            }

            goto CommonReturn;
        }
    }

    //
    // Total length needed.
    //
    cbNeeded = sizeof(WCHAR) * (wcslen(pwszFormat) + 1);

    //
    // Length only calculation?
    //
    if (NULL == pbFormat)
    {
        *pcbFormat = cbNeeded;
        goto SuccessReturn;
    }

    //
    // Caller provided us with enough memory?
    //
    if (*pcbFormat < cbNeeded)
    {
        *pcbFormat = cbNeeded;
        goto MoreDataError;
    }

    //
    // Copy size and data.
    //
    memcpy(pbFormat, pwszFormat, cbNeeded);
    *pcbFormat = cbNeeded;

SuccessReturn:

    fResult = TRUE;

CommonReturn:

    if (pwszFormat)
    {
        LocalFree((HLOCAL) pwszFormat);
    }

    return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg,E_INVALIDARG);
TRACE_ERROR(LoadStringError);
TRACE_ERROR(FormatMessageError);
TRACE_ERROR(FormatBytesToHexError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);

}

//+-------------------------------------------------------------------------
// format the specified data structure according to the certificate
// encoding type.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptFormatObject(
    IN DWORD dwCertEncodingType,
    IN DWORD dwFormatType,
	IN DWORD dwFormatStrType,
	IN void	 *pFormatStruct,
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
	OUT void *pbFormat,
    IN OUT DWORD *pcbFormat
    )
{
    BOOL				fResult=FALSE;
    void				*pvFuncAddr;
    HCRYPTOIDFUNCADDR   hFuncAddr;

    if (CryptGetOIDFunctionAddress(
            hFormatFuncSet,
            dwCertEncodingType,
            lpszStructType,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr))
	{
        fResult = ((PFN_FORMAT_FUNC) pvFuncAddr)(
				dwCertEncodingType,
				dwFormatType,
				dwFormatStrType,
				pFormatStruct,
				lpszStructType,
				pbEncoded,
				cbEncoded,
				pbFormat,
				pcbFormat
            );
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    }
	else
	{
        //do not call the default hex dump if CRYPT_FORMAT_STR_NO_HEX is set
        if(0==(dwFormatStrType & CRYPT_FORMAT_STR_NO_HEX))
        {
		    //call the default routine automatically
		    if (CryptGetOIDFunctionAddress(
                hFormatFuncSet,
                dwCertEncodingType,
                CRYPT_DEFAULT_OID,
                0,                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr))
		    {
			    fResult = ((PFN_FORMAT_FUNC) pvFuncAddr)(
					dwCertEncodingType,
					dwFormatType,
					dwFormatStrType,
					pFormatStruct,
					lpszStructType,
					pbEncoded,
					cbEncoded,
					pbFormat,
					pcbFormat);

			    CryptFreeOIDFunctionAddress(hFuncAddr, 0);
		    }
            else
            {
			    *pcbFormat = 0;
			    fResult = FALSE;
            }
        }
		else
		{
			*pcbFormat = 0;
			fResult = FALSE;
		}
	}
    return fResult;
}



//-----------------------------------------------------------
//
//  This is the actual format routine for an particular RDN attribute.
//
//	lpszStructType is any OID for CERT_RDN_ATTR.  pbEncoded is
//	an encoded BLOB for CERT_NAME_INFO struct.  When pBuffer==NULL,
//	*pcbBuffer return the size of memory to be allocated in bytes.
//	Please notice the string is not NULL terminated.
//
//	For example, to ask for an unicode string of common name,
//	pass lpszStructType=szOID_COMMON_NAME,
//	pass dwFormatType==CRYPT_FORMAT_SIMPL,
//  pBuffer will be set the L"xiaohs@microsoft.com".
//
//
//-------------------------------------------------------------
static BOOL	WINAPI	CryptDllFormatAttr(
				DWORD		dwEncodingType,	
				DWORD		dwFormatType,
				DWORD		dwFormatStrType,
				void		*pStruct,
				LPCSTR		lpszStructType,
				const BYTE	*pbEncoded,
				DWORD		cbEncoded,
				void		*pBuffer,
				DWORD		*pcbBuffer)
{
		BOOL		fResult=FALSE;
		WCHAR		*pwszSeperator=NULL;
		BOOL		fHeader=FALSE;
		BOOL		flengthOnly=FALSE;
		DWORD		dwBufferCount=0;
		DWORD		dwBufferLimit=0;
		DWORD		dwBufferIncrement=0;
		DWORD		dwSeperator=0;
		DWORD		dwHeader=0;
		DWORD		dwOIDSize=0;
		WCHAR		*pwszBuffer=NULL;
		WCHAR		*pwszHeader=NULL;
		BOOL		fAddSeperator=FALSE;


		DWORD			cbStructInfo=0;
		CERT_NAME_INFO	*pStructInfo=NULL;
		DWORD			dwRDNIndex=0;
		DWORD			dwAttrIndex=0;
		DWORD			dwAttrCount=0;
		CERT_RDN_ATTR	*pCertRDNAttr=NULL;
		PCCRYPT_OID_INFO pOIDInfo=NULL;

        LPWSTR           pwszTemp;
		
		//check input parameters
		if(lpszStructType==NULL ||
			(pbEncoded==NULL && cbEncoded!=0) ||
			pcbBuffer==NULL	
		  )
			goto InvalidArg;

		if(cbEncoded==0)
		{
			*pcbBuffer=0;
			goto InvalidArg;
		}

		//get the seperator of the attributes
		//wszCOMMA is the default seperator
		if(dwFormatType & CRYPT_FORMAT_COMMA)
			pwszSeperator=wszCOMMA;
		else
		{
			if(dwFormatType & CRYPT_FORMAT_SEMICOLON)
				pwszSeperator=wszSEMICOLON;
			else
			{
				if(dwFormatType & CRYPT_FORMAT_CRLF)
					pwszSeperator=wszCRLF;
				else
                {
					pwszSeperator=wszPLUS;
                }
			}
		}

		//calculate the length of the seperator
		dwSeperator=wcslen(pwszSeperator)*sizeof(WCHAR);

		//check the requirement for the header
		if(dwFormatType & CRYPT_FORMAT_X509 ||
			dwFormatType & CRYPT_FORMAT_OID)
		{	
			fHeader=TRUE;
		}


		if(NULL==pBuffer)
			flengthOnly=TRUE;

		//decode the X509_UNICODE_NAME
		if(!CryptDecodeObject(dwEncodingType, X509_UNICODE_NAME,
			pbEncoded, cbEncoded, CRYPT_DECODE_NOCOPY_FLAG,
			NULL, &cbStructInfo))
			goto DecodeError;

		//allocate memory
		pStructInfo=(CERT_NAME_INFO *)malloc(cbStructInfo);
		if(!pStructInfo)
			goto MemoryError;	

		//decode the struct
 		if(!CryptDecodeObject(dwEncodingType, X509_UNICODE_NAME,
			pbEncoded, cbEncoded, CRYPT_DECODE_NOCOPY_FLAG,
			pStructInfo, &cbStructInfo))
			goto DecodeError;


		 //allocate the buffer for formatting
		if(!flengthOnly)
		{
			pwszBuffer=(WCHAR *)malloc(g_AllocateSize);
			if(!pwszBuffer)
				goto MemoryError;
				
			dwBufferLimit=g_AllocateSize;
		}

	   	//search for the OID requested.  If found one, put it
		//to the buffer.  If no requested attribut is found,
		//return.
		for(dwRDNIndex=0; dwRDNIndex<pStructInfo->cRDN; dwRDNIndex++)
		{
			//the following line is for code optimization
			dwAttrCount=(pStructInfo->rgRDN)[dwRDNIndex].cRDNAttr;

			for(dwAttrIndex=0; dwAttrIndex<dwAttrCount; dwAttrIndex++)
			{
				//look for the specific OIDs in the function
				if(_stricmp(lpszStructType,
				(pStructInfo->rgRDN)[dwRDNIndex].rgRDNAttr[dwAttrIndex].pszObjId)==0)
				{
					pCertRDNAttr=&((pStructInfo->rgRDN)[dwRDNIndex].rgRDNAttr[dwAttrIndex]);

					//init the dwBufferIncrement
					dwBufferIncrement=0;

					//get the header of the tag
					if(fHeader)
					{
						if(dwFormatType & CRYPT_FORMAT_X509)
						{
							//get the OID's name
							pOIDInfo=CryptFindOIDInfo(CRYPT_OID_INFO_OID_KEY,
														  (void *)lpszStructType,
														  CRYPT_RDN_ATTR_OID_GROUP_ID);

							if(pOIDInfo)
							{
								//allocate memory, including the NULL terminator
								pwszHeader=(WCHAR *)malloc((wcslen(pOIDInfo->pwszName)+wcslen(wszEQUAL)+1)*
									sizeof(WCHAR));
								if(!pwszHeader)
									goto MemoryError;

								wcscpy(pwszHeader,pOIDInfo->pwszName);

							}
						}

						//use the OID is no mapping is found or
						//OID is requested in the header
						if(pwszHeader==NULL)
						{
							//get the wide character string to the OID
							if(!(dwOIDSize=MultiByteToWideChar(CP_ACP,0,
							lpszStructType,strlen(lpszStructType),NULL,0)))
								goto szTOwszError;

							//allocate memory, including the NULL terminator
							pwszHeader=(WCHAR *)malloc((dwOIDSize+wcslen(wszEQUAL)+1)*
										sizeof(WCHAR));
							if(!pwszHeader)
								goto MemoryError;

							if(!(dwHeader=MultiByteToWideChar(CP_ACP,0,
							lpszStructType,strlen(lpszStructType),pwszHeader,dwOIDSize)))
								 goto szTOwszError;

							//NULL terminate the string
							*(pwszHeader+dwHeader)=L'\0';
							
						}

						//add the euqal sign
						wcscat(pwszHeader,	wszEQUAL);

						//get the header size, in bytes, excluding the NULL terminator
						dwHeader=wcslen(pwszHeader)*sizeof(WCHAR);
						dwBufferIncrement+=dwHeader;
					}


					//allocate enough memory.  Including the NULL terminator
					dwBufferIncrement+=pCertRDNAttr->Value.cbData;
					dwBufferIncrement+=dwSeperator;
					dwBufferIncrement+=2;
	

					if(!flengthOnly && ((dwBufferCount+dwBufferIncrement)>dwBufferLimit))
					{
					   //reallocate the memory
                        #if (0) // DSIE: Bug 27436
						pwszBuffer=(WCHAR *)realloc(pwszBuffer,
								max(dwBufferLimit+g_AllocateSize,
								dwBufferLimit+dwBufferIncrement));
						if(!pwszBuffer)
							goto MemoryError;
                        #endif

						pwszTemp=(WCHAR *)realloc(pwszBuffer,
								max(dwBufferLimit+g_AllocateSize,
    							dwBufferLimit+dwBufferIncrement));
						if(!pwszTemp)
							goto MemoryError;
                        pwszBuffer = pwszTemp;

                        dwBufferLimit+=max(g_AllocateSize,dwBufferIncrement);

					}
					
					//add the header if necessary
					if(fHeader)
					{							
						if(!flengthOnly)
						{
							memcpy((BYTE *)(pwszBuffer+dwBufferCount/sizeof(WCHAR)),
								pwszHeader,dwHeader);
						}

						dwBufferCount+=dwHeader;

						//do not need to do header anymore
						fHeader=FALSE;
					}

					//add the seperator	after the 1st iteration
					if(fAddSeperator)
					{
						
						if(!flengthOnly)
						{
							memcpy((BYTE *)(pwszBuffer+dwBufferCount/sizeof(WCHAR)),
								pwszSeperator,dwSeperator);
						}

						dwBufferCount+=dwSeperator;
					}
					else
						fAddSeperator=TRUE;

					//add the attr content
					if(!flengthOnly)
					{
						memcpy((BYTE *)(pwszBuffer+dwBufferCount/sizeof(WCHAR)),
							(pCertRDNAttr->Value.pbData),
							pCertRDNAttr->Value.cbData);
					}

					//increment the buffercount
					dwBufferCount+=pCertRDNAttr->Value.cbData;

				}
			}
		}


		//return the result as requested
		//check if the requested OID is actually in the DN
		if(0==dwBufferCount)
		{
			*pcbBuffer=dwBufferCount;
			goto NotFoundError;
		}


		//we need to NULL terminate the string
		if(!flengthOnly)
			*(pwszBuffer+dwBufferCount/sizeof(WCHAR))=L'\0';

		dwBufferCount+=2;

		if(pBuffer==NULL)
		{
			*pcbBuffer=dwBufferCount;
			fResult=TRUE;
			goto CommonReturn;
		}

		if((*pcbBuffer)<dwBufferCount)
		{
			*pcbBuffer=dwBufferCount;
			goto MoreDataError;		
		}


		*pcbBuffer=dwBufferCount;
		memcpy(pBuffer, pwszBuffer,dwBufferCount);

		fResult=TRUE;

CommonReturn:
		if(pwszHeader)
			free(pwszHeader);

		if(pwszBuffer)
			free(pwszBuffer);

		if(pStructInfo)
			free(pStructInfo);

		return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;


SET_ERROR(InvalidArg, E_INVALIDARG);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(DecodeError);
TRACE_ERROR(szTOwszError);
SET_ERROR(NotFoundError, E_FAIL);
SET_ERROR(MoreDataError, ERROR_MORE_DATA);
}




//-----------------------------------------------------------
//
//  This is the actual format routine for an complete CERT_NAME
//
//
//	lpszStructType should be X509_NAME  pbEncoded is
//	an encoded BLOB for CERT_NAME_INFO struct.  When pBuffer==NULL,
//	*pcbBuffer return the size of memory to be allocated in bytes.
//	Please notice the string is NULL terminated.
//
//-------------------------------------------------------------
static BOOL	WINAPI	CryptDllFormatName(
				DWORD		dwEncodingType,	
				DWORD		dwFormatType,
				DWORD		dwFormatStrType,
				void		*pStruct,
				LPCSTR		lpszStructType,
				const BYTE	*pbEncoded,
				DWORD		cbEncoded,
				void		*pbBuffer,
				DWORD		*pcbBuffer)
{
    //makesure lpszStructType is X509_NAME or X509_UNICODE_NAME
	if((X509_NAME != lpszStructType) &&
		    (X509_UNICODE_NAME != lpszStructType))
    {
        SetLastError((DWORD) E_INVALIDARG);
        return FALSE;
    }

 	//check input parameters
	if((pbEncoded==NULL && cbEncoded!=0) || pcbBuffer==NULL)
    {
        SetLastError((DWORD) E_INVALIDARG);
        return FALSE;
    }

	if(cbEncoded==0)
    {
        SetLastError((DWORD) E_INVALIDARG);
        return FALSE;
    }

    //call CryptDllFormatNameAll with no prefix
    return  CryptDllFormatNameAll(dwEncodingType,	
                                  dwFormatType,
                                  dwFormatStrType,
                                  pStruct,
                                  0,
                                  FALSE,
                                  pbEncoded,
                                  cbEncoded,
                                  &pbBuffer,
                                  pcbBuffer);

}


//-----------------------------------------------------------
//
//  This is the actual format routine for an complete CERT_NAME
//
//
//	lpszStructType should be X509_NAME  pbEncoded is
//	an encoded BLOB for CERT_NAME_INFO struct.  When pBuffer==NULL,
//	*pcbBuffer return the size of memory to be allocated in bytes.
//	Please notice the string is NULL terminated.
//
//-------------------------------------------------------------
BOOL	CryptDllFormatNameAll(
				DWORD		dwEncodingType,	
				DWORD		dwFormatType,
				DWORD		dwFormatStrType,
				void		*pStruct,
                UINT        idsPreFix,
                BOOL        fToAllocate,
				const BYTE	*pbEncoded,
				DWORD		cbEncoded,
				void		**ppbBuffer,
				DWORD		*pcbBuffer)
{

		BOOL			    fResult=FALSE;
		DWORD			    dwStrType=0;
		CERT_NAME_BLOB	    Cert_Name_Blob;
		DWORD			    dwSize=0;
        LPWSTR              pwszName=NULL;
        LPWSTR              pwszMulti=NULL;

		Cert_Name_Blob.cbData=cbEncoded;
		Cert_Name_Blob.pbData=(BYTE *)pbEncoded;

	
		//calculate the dwStryType to use for CertNameToStrW
        dwStrType=FormatToStr(dwFormatType);

        //overwrite dwStrType to default if we are doing MULTI line format
        //since the options will be ignored
        //We want to use + and , for the seperator
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
        {

            dwStrType &=~(CERT_NAME_STR_CRLF_FLAG);
            dwStrType &=~(CERT_NAME_STR_COMMA_FLAG);
            dwStrType &=~(CERT_NAME_STR_SEMICOLON_FLAG);
            dwStrType &=~(CERT_NAME_STR_NO_QUOTING_FLAG);
            dwStrType &=~(CERT_NAME_STR_NO_PLUS_FLAG);


        }

        //if this function is not called from CryptDllFormatName,
        //make sure that we use the RESERSE Flag
        if(TRUE == fToAllocate)
            dwStrType |= CERT_NAME_STR_REVERSE_FLAG;

		//call the CertNameToStrW to convert
        dwSize=CertNameToStrW(dwEncodingType,
                        &Cert_Name_Blob,
                        dwStrType,
                        NULL,
                        0);

        if(0==dwSize)
            goto CertNameToStrError;

        pwszName=(LPWSTR)malloc(sizeof(WCHAR)*(dwSize));
        if(NULL==pwszName)
            goto MemoryError;

        dwSize=CertNameToStrW(dwEncodingType,
                        &Cert_Name_Blob,
                        dwStrType,
                        pwszName,
                        dwSize);
        if(0==dwSize)
            goto CertNameToStrError;

        //we do not need to parse the string for single line format
        if(0==(dwFormatStrType &  CRYPT_FORMAT_STR_MULTI_LINE))
        {
            //calculate the bytes needed
            dwSize=sizeof(WCHAR)*(wcslen(pwszName)+1);

            //if FALSE==fToAllocate, we do not allocate the memory on user's
            //behalf; otherwize, allocate memory to eliminate the need for
            //double call
            if(FALSE==fToAllocate)
            {
                if(NULL==(*ppbBuffer))
                {
                    *pcbBuffer=dwSize;
                    fResult=TRUE;
                    goto CommonReturn;
                }

                if(*pcbBuffer < dwSize)
                {
                    *pcbBuffer=dwSize;
                    goto MoreDataError;
                }

                memcpy(*ppbBuffer, pwszName, dwSize);
                *pcbBuffer=dwSize;
            }
            else
            {
                *ppbBuffer=malloc(dwSize);
                if(NULL==(*ppbBuffer))
                    goto MemoryError;

                memcpy(*ppbBuffer, pwszName, dwSize);

                //pcbBuffer can be NULL in this case
            }
        }
        else
        {
            //we need to parse the string to make the multiple format
            if(!GetCertNameMulti(pwszName, idsPreFix, &pwszMulti))
                goto GetCertNameError;

            //calculate the bytes needee
            dwSize=sizeof(WCHAR)*(wcslen(pwszMulti)+1);

            //if FALSE==fToAllocate, we do not allocate the memory on user's
            //behalf; otherwize, allocate memory to eliminate the need for
            //double call
            if(FALSE==fToAllocate)
            {
                if(NULL==(*ppbBuffer))
                {
                    *pcbBuffer=dwSize;
                    fResult=TRUE;
                    goto CommonReturn;
                }

                if(*pcbBuffer < dwSize)
                {
                    *pcbBuffer=dwSize;
                    goto MoreDataError;
                }

                memcpy(*ppbBuffer, pwszMulti, dwSize);
                *pcbBuffer=dwSize;

            }
            else
            {
                *ppbBuffer=malloc(dwSize);
                if(NULL==(*ppbBuffer))
                    goto MemoryError;

                memcpy(*ppbBuffer, pwszMulti, dwSize);

                //pcbBuffer can be NULL in this case
            }
        }


        fResult=TRUE;


CommonReturn:

    if(pwszName)
        free(pwszName);

    if(pwszMulti)
        free(pwszMulti);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(CertNameToStrError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(GetCertNameError);

}

//--------------------------------------------------------------------------
//
//	 FormatBasicConstraints2:   szOID_BASIC_CONSTRAINTS2
//                              X509_BASIC_CONSTRAINTS2
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatBasicConstraints2(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	LPWSTR							pwszFormat=NULL;
	WCHAR							wszSubject[SUBJECT_SIZE];
	WCHAR							wszNone[NONE_SIZE];
	PCERT_BASIC_CONSTRAINTS2_INFO	pInfo=NULL;
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
	UINT							idsSub=0;

	
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_BASIC_CONSTRAINTS2,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

	//load the string for the subjectType
    if (pInfo->fCA)
		idsSub=IDS_SUB_CA;
	else
		idsSub=IDS_SUB_EE;

	if(!LoadStringU(hFrmtFuncInst,idsSub, wszSubject, sizeof(wszSubject)/sizeof(wszSubject[0])))
		goto LoadStringError;

    if (pInfo->fPathLenConstraint)
	{
        //decide between signle line and multi line display
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            idsSub=IDS_BASIC_CONS2_PATH_MULTI;
        else
            idsSub=IDS_BASIC_CONS2_PATH;

        if(!FormatMessageUnicode(&pwszFormat,idsSub,
								wszSubject, pInfo->dwPathLenConstraint))
			goto FormatMsgError;
	}
    else
	{
		if(!LoadStringU(hFrmtFuncInst,IDS_NONE, wszNone, sizeof(wszNone)/sizeof(wszNone[0])))
			goto LoadStringError;

        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            idsSub=IDS_BASIC_CONS2_NONE_MULTI;
        else
            idsSub=IDS_BASIC_CONS2_NONE;

        if(!FormatMessageUnicode(&pwszFormat,idsSub,
								wszSubject, wszNone))
			goto FormatMsgError;
	}


	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:
	if(pwszFormat)
		LocalFree((HLOCAL)pwszFormat);

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);

}


//--------------------------------------------------------------------------
//
//	 FormatSPCObject:
//
//   idsPreFix is the pre fix for mulit-line display
//--------------------------------------------------------------------------
BOOL FormatSPCObject(
	DWORD		                dwFormatType,
	DWORD		                dwFormatStrType,
    void		                *pFormatStruct,
    UINT                        idsPreFix,
    PSPC_SERIALIZED_OBJECT      pInfo,
    LPWSTR                      *ppwszFormat)
{

    BOOL        fResult=FALSE;
    LPWSTR      pwszHex=NULL;
    LPWSTR      pwszClassId=NULL;
    WCHAR       wszPreFix[PRE_FIX_SIZE];
    DWORD       cbNeeded=0;

    LPWSTR      pwszClassFormat=NULL;
    LPWSTR      pwszDataFormat=NULL;

    LPWSTR      pwszTemp;

    assert(pInfo);

    *ppwszFormat=NULL;

   //load the pre-dix
   if(0!=idsPreFix)
   {
       if(!LoadStringU(hFrmtFuncInst, idsPreFix,
                        wszPreFix, sizeof(wszPreFix)/sizeof(wszPreFix[0])))
        goto LoadStringError;

   }


    cbNeeded=0;

    if(!FormatBytesToHex(
                        0,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->ClassId,
                        16,
                        NULL,
	                    &cbNeeded))
            goto FormatBytesToHexError;

    pwszClassId=(LPWSTR)malloc(cbNeeded);
    if(NULL==pwszClassId)
         goto MemoryError;

    if(!FormatBytesToHex(
                        0,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->ClassId,
                        16,
                        pwszClassId,
	                    &cbNeeded))
        goto FormatBytesToHexError;


    //format
    if(!FormatMessageUnicode(&pwszClassFormat, IDS_SPC_OBJECT_CLASS, pwszClassId))
            goto FormatMsgError;

    //strcat
    *ppwszFormat=(LPWSTR)malloc(sizeof(WCHAR) * (wcslen(pwszClassFormat)+wcslen(wszPreFix)+wcslen(wszCOMMA)+1));
    if(NULL==*ppwszFormat)
        goto MemoryError;

    **ppwszFormat=L'\0';

    if(0!=idsPreFix)
        wcscat(*ppwszFormat, wszPreFix);

    wcscat(*ppwszFormat, pwszClassFormat);

    //format based on the availability of SerializedData
    if(0!=pInfo->SerializedData.cbData)
    {
        //cancatenate the ", " or \n"
        if(NULL != (*ppwszFormat))
        {
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
               wcscat(*ppwszFormat, wszCRLF);
            else
               wcscat(*ppwszFormat, wszCOMMA);
        }

       cbNeeded=0;

       if(!FormatBytesToHex(
                        0,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->SerializedData.pbData,
                        pInfo->SerializedData.cbData,
                        NULL,
	                    &cbNeeded))
            goto FormatBytesToHexError;

        pwszHex=(LPWSTR)malloc(cbNeeded);
        if(NULL==pwszHex)
            goto MemoryError;

        if(!FormatBytesToHex(
                        0,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->SerializedData.pbData,
                        pInfo->SerializedData.cbData,
                        pwszHex,
	                    &cbNeeded))
            goto FormatBytesToHexError;

          if(!FormatMessageUnicode(&pwszDataFormat, IDS_SPC_OBJECT_DATA,pwszHex))
            goto FormatMsgError;

        //strcat
        #if (0) // DSIE: Bug 27436
        *ppwszFormat=(LPWSTR)realloc(*ppwszFormat,
                sizeof(WCHAR)* (wcslen(*ppwszFormat)+wcslen(pwszDataFormat)+wcslen(wszPreFix)+1));
        if(NULL==*ppwszFormat)
            goto MemoryError;
        #endif

        pwszTemp=(LPWSTR)realloc(*ppwszFormat,
                sizeof(WCHAR)* (wcslen(*ppwszFormat)+wcslen(pwszDataFormat)+wcslen(wszPreFix)+1));
        if(NULL==pwszTemp)
            goto MemoryError;
        *ppwszFormat = pwszTemp;

        if(0!=idsPreFix)
            wcscat(*ppwszFormat, wszPreFix);

        wcscat(*ppwszFormat, pwszDataFormat);

    }

	fResult=TRUE;
	

CommonReturn:
    if(pwszHex)
        free(pwszHex);

    if(pwszClassId)
        free(pwszClassId);

    if(pwszClassFormat)
        LocalFree((HLOCAL)pwszClassFormat);

    if(pwszDataFormat)
        LocalFree((HLOCAL)pwszDataFormat);

	return fResult;

ErrorReturn:
    if(*ppwszFormat)
    {
        free(*ppwszFormat);
        *ppwszFormat=NULL;
    }


	fResult=FALSE;
	goto CommonReturn;


TRACE_ERROR(FormatBytesToHexError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatMsgError);
TRACE_ERROR(LoadStringError);
}


//--------------------------------------------------------------------------
//
//	 FormatSPCLink:
//--------------------------------------------------------------------------
BOOL FormatSPCLink(
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
    void		*pFormatStruct,
    UINT        idsPreFix,
    PSPC_LINK   pInfo,
    LPWSTR      *ppwsz)
{

    BOOL        fResult=FALSE;
    LPWSTR      pwszObj=NULL;
    UINT        ids=0;
    LPWSTR      pwszFormat=NULL;


    assert(pInfo);

    *ppwsz=NULL;

    switch(pInfo->dwLinkChoice)
    {
        case SPC_URL_LINK_CHOICE:
                if(!FormatMessageUnicode(&pwszFormat, IDS_SPC_URL_LINK,pInfo->pwszUrl))
                    goto FormatMsgError;
            break;

        case SPC_MONIKER_LINK_CHOICE:
                if(!FormatSPCObject(
                            dwFormatType,
                            dwFormatStrType,
                            pFormatStruct,
                            idsPreFix,
                            &(pInfo->Moniker),
                            &pwszObj))
                    goto FormatSPCObjectError;


                //decide between single line and mulitple line format
                if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                    ids=IDS_SPC_MONIKER_LINK_MULTI;
                else
                    ids=IDS_SPC_MONIKER_LINK;

                if(!FormatMessageUnicode(&pwszFormat,ids,pwszObj))
                    goto FormatMsgError;
            break;


        case SPC_FILE_LINK_CHOICE:
               if(!FormatMessageUnicode(&pwszFormat, IDS_SPC_FILE_LINK, pInfo->pwszFile))
                    goto FormatMsgError;

            break;

        default:

               if(!FormatMessageUnicode(&pwszFormat, IDS_SPC_LINK_UNKNOWN,
                        pInfo->dwLinkChoice))
                    goto FormatMsgError;
    }

    *ppwsz=(LPWSTR)malloc(sizeof(WCHAR) * (wcslen(pwszFormat)+1));
    if(NULL==(*ppwsz))
        goto MemoryError;

    memcpy(*ppwsz, pwszFormat, sizeof(WCHAR) * (wcslen(pwszFormat)+1));
	fResult=TRUE;
	

CommonReturn:

    if(pwszObj)
        free(pwszObj);

    if(pwszFormat)
        LocalFree((HLOCAL)pwszFormat);

	return fResult;

ErrorReturn:

    if(*ppwsz)
    {
        free(*ppwsz);
        *ppwsz=NULL;
    }

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(FormatMsgError);
TRACE_ERROR(FormatSPCObjectError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
}


//--------------------------------------------------------------------------
//
//	 FormatSPCImage:
//--------------------------------------------------------------------------
BOOL FormatSPCImage(
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
    void		*pFormatStruct,
    UINT        idsPreFix,
    PSPC_IMAGE  pInfo,
    LPWSTR      *ppwszImageFormat)
{
    BOOL        fResult=FALSE;
    LPWSTR       pwszFormat=NULL;
    LPWSTR       pwszLink=NULL;
    LPWSTR       pwszLinkFormat=NULL;
    LPWSTR      pwszHex=NULL;
    LPWSTR      pwszHexFormat=NULL;
    UINT        ids=0;

    DWORD       cbNeeded=0;

    LPWSTR      pwszTemp;

    assert(pInfo);

    //init
    *ppwszImageFormat=NULL;

	pwszFormat=(LPWSTR)malloc(sizeof(WCHAR));
    if(NULL==pwszFormat)
        goto MemoryError;

    *pwszFormat=L'\0';

    if(pInfo->pImageLink)
    {
        if(!FormatSPCLink(dwFormatType,
                          dwFormatStrType,
                          pFormatStruct,
                          idsPreFix,
                          pInfo->pImageLink,
                          &pwszLink))
            goto FormatSPCLinkError;

       //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_IMAGE_LINK_MULTI;
        else
            ids=IDS_IMAGE_LINK;


        if(!FormatMessageUnicode(&pwszLinkFormat, ids,
                            &pwszLink))
            goto FormatMsgError;

        #if (0) // DSIE: Bug 27436
        pwszFormat=(LPWSTR)realloc(pwszFormat, 
                    sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszCOMMA)+wcslen(pwszLinkFormat)+1));
        if(NULL==pwszFormat)
            goto MemoryError;
        #endif

        pwszTemp=(LPWSTR)realloc(pwszFormat, 
                    sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszCOMMA)+wcslen(pwszLinkFormat)+1));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwszFormat = pwszTemp;

        wcscat(pwszFormat, pwszLinkFormat);
    }

    if(0!=pInfo->Bitmap.cbData)
    {
        //strcat ", "
        if(0!=wcslen(pwszFormat))
        {
            if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                wcscat(pwszFormat, wszCOMMA);
        }

       cbNeeded=0;

       if(!FormatBytesToHex(
                        0,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->Bitmap.pbData,
                        pInfo->Bitmap.cbData,
                        NULL,
	                    &cbNeeded))
            goto FormatBytesToHexError;

        pwszHex=(LPWSTR)malloc(cbNeeded);
        if(NULL==pwszHex)
            goto MemoryError;

        if(!FormatBytesToHex(
                        0,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->Bitmap.pbData,
                        pInfo->Bitmap.cbData,
                        pwszHex,
	                    &cbNeeded))
            goto FormatBytesToHexError;

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_IMAGE_BITMAP_MULTI;
        else
            ids=IDS_IMAGE_BITMAP;


        if(!FormatMessageUnicode(&pwszHexFormat, ids, pwszHex))
            goto FormatMsgError;

        #if (0) // DSIE: Bug 27436
        pwszFormat=(LPWSTR)realloc(pwszFormat, 
            sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszCOMMA)+wcslen(pwszHexFormat)+1));
        if(NULL==pwszFormat)
            goto MemoryError;
        #endif

        pwszTemp=(LPWSTR)realloc(pwszFormat, 
            sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszCOMMA)+wcslen(pwszHexFormat)+1));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwszFormat = pwszTemp;

        wcscat(pwszFormat, pwszHexFormat);

       //free memory
        free(pwszHex);
        pwszHex=NULL;
        LocalFree((HLOCAL)pwszHexFormat);
        pwszHexFormat=NULL;

    }

   if(0!=pInfo->Metafile.cbData)
    {
        //strcat ", "
        if(0!=wcslen(pwszFormat))
        {
            if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                wcscat(pwszFormat, wszCOMMA);
        }

       cbNeeded=0;

       if(!FormatBytesToHex(
                        0,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->Metafile.pbData,
                        pInfo->Metafile.cbData,
                        NULL,
	                    &cbNeeded))
            goto FormatBytesToHexError;

        pwszHex=(LPWSTR)malloc(cbNeeded);
        if(NULL==pwszHex)
            goto MemoryError;

        if(!FormatBytesToHex(
                        0,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->Metafile.pbData,
                        pInfo->Metafile.cbData,
                        pwszHex,
	                    &cbNeeded))
            goto FormatBytesToHexError;

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_IMAGE_METAFILE_MULTI;
        else
            ids=IDS_IMAGE_METAFILE;

        if(!FormatMessageUnicode(&pwszHexFormat, ids, pwszHex))
            goto FormatMsgError;

        #if (0) // DSIE: Bug 27436
        pwszFormat=(LPWSTR)realloc(pwszFormat, 
            sizeof(WCHAR) *(wcslen(pwszFormat)+wcslen(wszCOMMA)+wcslen(pwszHexFormat)+1));
        if(NULL==pwszFormat)
            goto MemoryError;
        #endif

        pwszTemp=(LPWSTR)realloc(pwszFormat, 
            sizeof(WCHAR) *(wcslen(pwszFormat)+wcslen(wszCOMMA)+wcslen(pwszHexFormat)+1));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwszFormat = pwszTemp;

        wcscat(pwszFormat, pwszHexFormat);

       //free memory
        free(pwszHex);
        pwszHex=NULL;
        LocalFree((HLOCAL)pwszHexFormat);
        pwszHexFormat=NULL;

    }

   if(0!=pInfo->EnhancedMetafile.cbData)
    {
        //strcat ", "
        if(0!=wcslen(pwszFormat))
        {
            if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                wcscat(pwszFormat, wszCOMMA);
        }

       cbNeeded=0;

       if(!FormatBytesToHex(
                        0,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->EnhancedMetafile.pbData,
                        pInfo->EnhancedMetafile.cbData,
                        NULL,
	                    &cbNeeded))
            goto FormatBytesToHexError;

        pwszHex=(LPWSTR)malloc(cbNeeded);
        if(NULL==pwszHex)
            goto MemoryError;

        if(!FormatBytesToHex(
                        0,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->EnhancedMetafile.pbData,
                        pInfo->EnhancedMetafile.cbData,
                        pwszHex,
	                    &cbNeeded))
            goto FormatBytesToHexError;

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_IMAGE_ENHANCED_METAFILE_MULTI;
        else
            ids=IDS_IMAGE_ENHANCED_METAFILE;

        if(!FormatMessageUnicode(&pwszHexFormat, ids, pwszHex))
            goto FormatMsgError;

        #if (0) // DSIE: Bug 27436
        pwszFormat=(LPWSTR)realloc(pwszFormat, 
            sizeof(WCHAR) *(wcslen(pwszFormat)+wcslen(wszCOMMA)+wcslen(pwszHexFormat)+1));
        if(NULL==pwszFormat)
            goto MemoryError;
        #endif

        pwszTemp=(LPWSTR)realloc(pwszFormat, 
            sizeof(WCHAR) *(wcslen(pwszFormat)+wcslen(wszCOMMA)+wcslen(pwszHexFormat)+1));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwszFormat = pwszTemp;

        wcscat(pwszFormat, pwszHexFormat);

       //free memory
        free(pwszHex);
        pwszHex=NULL;
        LocalFree((HLOCAL)pwszHexFormat);
        pwszHexFormat=NULL;

    }

   if(0!=pInfo->GifFile.cbData)
    {
        //strcat ", "
        if(0!=wcslen(pwszFormat))
        {
            if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                wcscat(pwszFormat, wszCOMMA);
        }

       cbNeeded=0;

       if(!FormatBytesToHex(
                        0,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->GifFile.pbData,
                        pInfo->GifFile.cbData,
                        NULL,
	                    &cbNeeded))
            goto FormatBytesToHexError;

        pwszHex=(LPWSTR)malloc(cbNeeded);
        if(NULL==pwszHex)
            goto MemoryError;

        if(!FormatBytesToHex(
                        0,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->GifFile.pbData,
                        pInfo->GifFile.cbData,
                        pwszHex,
	                    &cbNeeded))
            goto FormatBytesToHexError;

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_IMAGE_GIFFILE_MULTI;
        else
            ids=IDS_IMAGE_GIFFILE;

        if(!FormatMessageUnicode(&pwszHexFormat, IDS_IMAGE_GIFFILE,
            pwszHex))
            goto FormatMsgError;

        #if (0) // DSIE: Bug 27436
        pwszFormat=(LPWSTR)realloc(pwszFormat, 
            sizeof(WCHAR) *(wcslen(pwszFormat)+wcslen(wszCOMMA)+wcslen(pwszHexFormat)+1));
        if(NULL==pwszFormat)
            goto MemoryError;
        #endif

        pwszTemp=(LPWSTR)realloc(pwszFormat, 
            sizeof(WCHAR) *(wcslen(pwszFormat)+wcslen(wszCOMMA)+wcslen(pwszHexFormat)+1));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwszFormat = pwszTemp;

        wcscat(pwszFormat, pwszHexFormat);

       //free memory
        free(pwszHex);
        pwszHex=NULL;
        LocalFree((HLOCAL)pwszHexFormat);
        pwszHexFormat=NULL;

    }

    if(0==wcslen(pwszFormat))
    {
        //fine if nothing is formatted
        *ppwszImageFormat=NULL;
    }
    else
    {
        *ppwszImageFormat=(LPWSTR)malloc(sizeof(WCHAR)*(wcslen(pwszFormat)+1));  
        #if (0) //  DSIE: Bug 27432 & 27434
        if(NULL == ppwszImageFormat)
        #endif
        if(NULL == *ppwszImageFormat)
            goto MemoryError;

        memcpy(*ppwszImageFormat, pwszFormat, sizeof(WCHAR)*(wcslen(pwszFormat)+1));
    }

	fResult=TRUE;
	

CommonReturn:
    if(pwszHex)
        free(pwszHex);

    if(pwszHexFormat)
        LocalFree((HLOCAL)pwszHexFormat);

    if(pwszLink)
        free(pwszLink);

    if(pwszLinkFormat)
        LocalFree((HLOCAL)pwszLinkFormat);

    if(pwszFormat)
        free(pwszFormat);

	return fResult;

ErrorReturn:

    if(*ppwszImageFormat)
    {
        free(*ppwszImageFormat);
        *ppwszImageFormat=NULL;
    }

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(FormatSPCLinkError);
TRACE_ERROR(FormatMsgError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatBytesToHexError);

}


//--------------------------------------------------------------------------
//
//	 FormatSPAgencyInfo:   SPC_SP_AGENCY_INFO_STRUCT
//                         SPC_SP_AGENCY_INFO_OBJID
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatSPAgencyInfo(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	LPWSTR							pwszFormat=NULL;
    LPWSTR                          pwsz=NULL;
	PSPC_SP_AGENCY_INFO         	pInfo=NULL;

    LPWSTR                          pwszPolicyInfo=NULL;
    LPWSTR                          pwszPolicyInfoFormat=NULL;
    LPWSTR                          pwszLogoLink=NULL;
    LPWSTR                          pwszLogoLinkFormat=NULL;
    LPWSTR                          pwszPolicyDsplyFormat=NULL;
    LPWSTR                          pwszLogoImage=NULL;
    LPWSTR                          pwszLogoImageFormat=NULL;

	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
    UINT                            ids=0;

    LPWSTR                          pwszTemp;
	
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,SPC_SP_AGENCY_INFO_STRUCT,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

	pwsz=(LPWSTR)malloc(sizeof(WCHAR));
    if(NULL==pwsz)
        goto MemoryError;

    *pwsz=L'\0';

    //format pPolicyInformation
    if(pInfo->pPolicyInformation)
    {

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_TWO_TABS;
        else
            ids=0;

        if(!FormatSPCLink(dwFormatType,
                             dwFormatStrType,
                             pFormatStruct,
                             ids,
                             pInfo->pPolicyInformation,
                             &pwszPolicyInfo))
            goto FormatSPCLinkError;

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_AGENCY_POLICY_INFO_MULTI;
        else
            ids=IDS_AGENCY_POLICY_INFO;

        if(!FormatMessageUnicode(&pwszPolicyInfoFormat, ids, pwszPolicyInfo))
            goto FormatMsgError;

        //strcat
        #if (0) // DSIE: Bug 27436
        pwsz=(LPWSTR)realloc(pwsz, 
            sizeof(WCHAR) *(wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszPolicyInfoFormat)+1));
        if(NULL==pwsz)
            goto MemoryError;
        #endif

        pwszTemp=(LPWSTR)realloc(pwsz, 
            sizeof(WCHAR) *(wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszPolicyInfoFormat)+1));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwsz = pwszTemp;

        wcscat(pwsz, pwszPolicyInfoFormat);
    }


    //format pwszPolicyDisplayText
    if(pInfo->pwszPolicyDisplayText)
    {
        //strcat ", "
        if(0!=wcslen(pwsz))
        {
            if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                wcscat(pwsz, wszCOMMA);
        }

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_AGENCY_POLICY_DSPLY_MULTI;
        else
            ids=IDS_AGENCY_POLICY_DSPLY;

        if(!FormatMessageUnicode(&pwszPolicyDsplyFormat, ids, pInfo->pwszPolicyDisplayText))
            goto FormatMsgError;

        //strcat
        #if (0) // DSIE: Bug 27436
        pwsz=(LPWSTR)realloc(pwsz,
            sizeof(WCHAR) *(wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszPolicyDsplyFormat)+1));
        if(NULL==pwsz)
            goto MemoryError;
        #endif

        pwszTemp=(LPWSTR)realloc(pwsz,
            sizeof(WCHAR) *(wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszPolicyDsplyFormat)+1));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwsz = pwszTemp;

        wcscat(pwsz, pwszPolicyDsplyFormat);
    }

    //pLogoImage
    if(pInfo->pLogoImage)
    {

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_THREE_TABS;
        else
            ids=0;


        if(!FormatSPCImage(dwFormatType,
                             dwFormatStrType,
                             pFormatStruct,
                             ids,
                             pInfo->pLogoImage,
                             &pwszLogoImage))
            goto FormatSPCImageError;

        //spcImage can include nothing
        if(NULL!=pwszLogoImage)
        {
            //strcat ", "
            if(0!=wcslen(pwsz))
            {
                if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                    wcscat(pwsz, wszCOMMA);
            }

            //decide between single line and mulitple line format
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_AGENCY_LOGO_IMAGE_MULTI;
            else
                ids=IDS_AGENCY_LOGO_IMAGE;


            if(!FormatMessageUnicode(&pwszLogoImageFormat,ids,pwszLogoImage))
                goto FormatMsgError;

            //strcat
            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz,
                sizeof(WCHAR) *(wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszLogoImageFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz,
                sizeof(WCHAR) *(wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszLogoImageFormat)+1));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz, pwszLogoImageFormat);
        }

    }

    //format pLogoLink
    if(pInfo->pLogoLink)
    {
        //strcat ", "
        if(0!=wcslen(pwsz))
        {
            if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                wcscat(pwsz, wszCOMMA);
        }

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_TWO_TABS;
        else
            ids=0;


        if(!FormatSPCLink(dwFormatType,
                             dwFormatStrType,
                             pFormatStruct,
                             ids,
                             pInfo->pLogoLink,
                             &pwszLogoLink))
            goto FormatSPCLinkError;


        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_AGENCY_LOGO_LINK_MULTI;
        else
            ids=IDS_AGENCY_LOGO_LINK;

        if(!FormatMessageUnicode(&pwszLogoLinkFormat, ids, pwszLogoLink))
            goto FormatMsgError;

        //strcat
        #if (0) // DSIE: Bug 27436
        pwsz=(LPWSTR)realloc(pwsz,
            sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszLogoLinkFormat)+1));
        if(NULL==pwsz)
            goto MemoryError;
        #endif

        pwszTemp=(LPWSTR)realloc(pwsz,
            sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszLogoLinkFormat)+1));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwsz = pwszTemp;

        wcscat(pwsz, pwszLogoLinkFormat);
    }

    if(0==wcslen(pwsz))
    {
       //no data
        pwszFormat=(LPWSTR)malloc((NO_INFO_SIZE+1)*sizeof(WCHAR));
        if(NULL==pwszFormat)
            goto MemoryError;

        if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, pwszFormat, NO_INFO_SIZE))
            goto LoadStringError;

    }
    else
    {
        pwszFormat=pwsz;
        pwsz=NULL;
    }


	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:

    if(pwszPolicyInfo)
        free(pwszPolicyInfo);

    if(pwszPolicyInfoFormat)
        LocalFree((HLOCAL)pwszPolicyInfoFormat);

    if(pwszLogoLink)
        free(pwszLogoLink);

    if(pwszLogoLinkFormat)
        LocalFree((HLOCAL)pwszLogoLinkFormat);

    if(pwszPolicyDsplyFormat)
        LocalFree((HLOCAL)pwszPolicyDsplyFormat);

    if(pwszLogoImage)
        free(pwszLogoImage);

    if(pwszLogoImageFormat)
        LocalFree((HLOCAL)pwszLogoImageFormat);

	if(pwszFormat)
		free(pwszFormat);

    if(pwsz)
        free(pwsz);

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatSPCLinkError);
TRACE_ERROR(FormatSPCImageError);

}

//--------------------------------------------------------------------------
//
//	 GetNoticeNumberString:
//
//	 The memory should be allocated via malloc
//--------------------------------------------------------------------------
BOOL WINAPI	GetNoticeNumberString(	DWORD	cNoticeNumbers,
								int		*rgNoticeNumbers,
								LPWSTR	*ppwszNumber)
{
    BOOL		fResult=FALSE;
	WCHAR		wszNumber[INT_SIZE];
	DWORD		dwIndex=0;
    
    LPWSTR      pwszTemp;

	*ppwszNumber=NULL;

	if(NULL==rgNoticeNumbers || 0==cNoticeNumbers)
		goto InvalidArg;

	*ppwszNumber=(LPWSTR)malloc(sizeof(WCHAR));
	if(NULL==*ppwszNumber)
		goto MemoryError;

	**ppwszNumber=L'\0';

	for(dwIndex=0; dwIndex<cNoticeNumbers; dwIndex++)
	{
		wszNumber[0]='\0';

		_itow(rgNoticeNumbers[dwIndex], wszNumber, 10);

		if(wcslen(wszNumber) > 0)
		{
            #if (0) // DSIE: Bug 27436
			*ppwszNumber=(LPWSTR)realloc(*ppwszNumber,
				sizeof(WCHAR)*(wcslen(*ppwszNumber)+wcslen(wszNumber)+wcslen(wszCOMMA)+1));
			if(NULL==*ppwszNumber)
				goto MemoryError;
            #endif

			pwszTemp=(LPWSTR)realloc(*ppwszNumber,
				sizeof(WCHAR)*(wcslen(*ppwszNumber)+wcslen(wszNumber)+wcslen(wszCOMMA)+1));
			if(NULL==pwszTemp)
				goto MemoryError;
            *ppwszNumber = pwszTemp;

			wcscat(*ppwszNumber, wszNumber);

			if(dwIndex != (cNoticeNumbers-1))
				wcscat(*ppwszNumber, wszCOMMA);
		}
	}

	if(0==wcslen(*ppwszNumber))
		goto InvalidArg;

	fResult=TRUE;
	

CommonReturn:

	return fResult;

ErrorReturn:

	if(*ppwszNumber)
	{
		free(*ppwszNumber);
		*ppwszNumber=NULL;
	}

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
}


//--------------------------------------------------------------------------
//
//	 FormatCertQualifier:
//
//	 The memory should be allocated via malloc
//--------------------------------------------------------------------------
BOOL	FormatPolicyUserNotice(
						DWORD		        dwCertEncodingType,
						DWORD		        dwFormatType,
						DWORD		        dwFormatStrType,
						void		        *pFormatStruct,
						UINT				idsPreFix,
						BYTE				*pbEncoded,	
						DWORD				cbEncoded,
						LPWSTR				*ppwsz)
{
    BOOL							fResult=FALSE;
    WCHAR                           wszNoInfo[NO_INFO_SIZE];
	WCHAR							wszPreFix[PREFIX_SIZE];
	WCHAR							wszNextPre[PREFIX_SIZE];
	WCHAR							wszText[SUBJECT_SIZE];
	BOOL							fComma=FALSE;

	CERT_POLICY_QUALIFIER_USER_NOTICE	*pInfo=NULL;
	LPWSTR							pwszOrg=NULL;
	LPWSTR							pwszNumber=NULL;

    LPWSTR                          pwszTemp;

	*ppwsz=NULL;

    if (!DecodeGenericBLOB(dwCertEncodingType,	szOID_PKIX_POLICY_QUALIFIER_USERNOTICE,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

	if(!LoadStringU(hFrmtFuncInst,idsPreFix, wszPreFix, sizeof(wszPreFix)/sizeof(wszPreFix[0])))
		goto LoadStringError;

	if(!LoadStringU(hFrmtFuncInst,idsPreFix+1, wszNextPre, sizeof(wszNextPre)/sizeof(wszNextPre[0])))
		goto LoadStringError;

	if(NULL == pInfo->pNoticeReference && NULL == pInfo->pszDisplayText)
	{

        //load the string "Info Not Available"
	    if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, wszNoInfo, sizeof(wszNoInfo)/sizeof(wszNoInfo[0])))
		    goto LoadStringError;

        *ppwsz=(LPWSTR)malloc(sizeof(WCHAR) * (wcslen(wszNoInfo) + wcslen(wszPreFix) + POSTFIX_SIZE + 1));
		if(NULL==*ppwsz)
			goto MemoryError;  

		**ppwsz=L'\0';

        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
			wcscat(*ppwsz, wszPreFix);

		wcscat(*ppwsz, wszNoInfo);

        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
			wcscat(*ppwsz, wszCRLF);
	}
	else
	{
		*ppwsz=(LPWSTR)malloc(sizeof(WCHAR));
		if(NULL==*ppwsz)
			goto MemoryError; 

		**ppwsz=L'\0';

		if(pInfo->pNoticeReference)
		{

			if(!LoadStringU(hFrmtFuncInst,IDS_USER_NOTICE_REF, wszText, sizeof(wszText)/sizeof(wszText[0])))
				goto LoadStringError;

            #if (0) // DSIE: Bug 27436
            *ppwsz=(LPWSTR)realloc(*ppwsz, 
                 sizeof(WCHAR) * (wcslen(*ppwsz)+wcslen(wszText)+wcslen(wszPreFix)+POSTFIX_SIZE+1));
			if(NULL==*ppwsz)
				 goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(*ppwsz, 
                 sizeof(WCHAR) * (wcslen(*ppwsz)+wcslen(wszText)+wcslen(wszPreFix)+POSTFIX_SIZE+1));
			if(NULL==pwszTemp)
				 goto MemoryError;
            *ppwsz = pwszTemp;

			if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
				wcscat(*ppwsz, wszPreFix);

			wcscat(*ppwsz, wszText);

			if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
				wcscat(*ppwsz, wszCRLF);

			if(pInfo->pNoticeReference->pszOrganization)
			{
				if(S_OK!=SZtoWSZ(pInfo->pNoticeReference->pszOrganization, &pwszOrg))
					goto SZtoWSZError;

				if(!LoadStringU(hFrmtFuncInst,IDS_USER_NOTICE_REF_ORG, wszText, sizeof(wszText)/sizeof(wszText[0])))
					goto LoadStringError;

                #if (0) // DSIE: Bug 27436
			    *ppwsz=(LPWSTR)realloc(*ppwsz, 
					 sizeof(WCHAR) * (wcslen(*ppwsz)+wcslen(wszText)+wcslen(pwszOrg)+wcslen(wszNextPre)+POSTFIX_SIZE+1));
    			if(NULL==*ppwsz)
					 goto MemoryError;
                #endif

			    pwszTemp=(LPWSTR)realloc(*ppwsz, 
					 sizeof(WCHAR) * (wcslen(*ppwsz)+wcslen(wszText)+wcslen(pwszOrg)+wcslen(wszNextPre)+POSTFIX_SIZE+1));
    			if(NULL==pwszTemp)
					 goto MemoryError;
                *ppwsz = pwszTemp;

				if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
					wcscat(*ppwsz, wszNextPre);

				wcscat(*ppwsz, wszText);
				wcscat(*ppwsz, pwszOrg);

				if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
					wcscat(*ppwsz, wszCRLF);
				else
				{
					wcscat(*ppwsz, wszCOMMA);
					fComma=TRUE;
				}
			}

			if(pInfo->pNoticeReference->cNoticeNumbers)
			{
				if(NULL == pInfo->pNoticeReference->rgNoticeNumbers)
					goto InvalidArg;

				if(!GetNoticeNumberString(pInfo->pNoticeReference->cNoticeNumbers,
										  pInfo->pNoticeReference->rgNoticeNumbers,
										  &pwszNumber))
					goto GetNumberError;

				if(!LoadStringU(hFrmtFuncInst,IDS_USER_NOTICE_REF_NUMBER, wszText, sizeof(wszText)/sizeof(wszText[0])))
					goto LoadStringError;

                #if (0) // DSIE: Bug 27436
    		    *ppwsz=(LPWSTR)realloc(*ppwsz, 
					 sizeof(WCHAR) * (wcslen(*ppwsz)+wcslen(wszText)+wcslen(pwszNumber)+wcslen(wszNextPre)+POSTFIX_SIZE+1));
				if(NULL==*ppwsz)
					 goto MemoryError;
                #endif

    		    pwszTemp=(LPWSTR)realloc(*ppwsz, 
					 sizeof(WCHAR) * (wcslen(*ppwsz)+wcslen(wszText)+wcslen(pwszNumber)+wcslen(wszNextPre)+POSTFIX_SIZE+1));
				if(NULL==pwszTemp)
					 goto MemoryError;
                *ppwsz = pwszTemp;

				if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
					wcscat(*ppwsz, wszNextPre);

				wcscat(*ppwsz, wszText);
				wcscat(*ppwsz, pwszNumber);

				if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
					wcscat(*ppwsz, wszCRLF);
				else
				{
					wcscat(*ppwsz, wszCOMMA);
					fComma=TRUE;
				}
			}
		}

		if(pInfo->pszDisplayText)
		{
			if(!LoadStringU(hFrmtFuncInst,IDS_USER_NOTICE_TEXT, wszText, sizeof(wszText)/sizeof(wszText[0])))
				goto LoadStringError;

            #if (0) // DSIE: Bug 27436
            *ppwsz=(LPWSTR)realloc(*ppwsz, 
                 sizeof(WCHAR) * (wcslen(*ppwsz)+wcslen(wszText)+wcslen(pInfo->pszDisplayText)+wcslen(wszPreFix)+POSTFIX_SIZE+1));
		    if(NULL==*ppwsz)
				 goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(*ppwsz, 
                 sizeof(WCHAR) * (wcslen(*ppwsz)+wcslen(wszText)+wcslen(pInfo->pszDisplayText)+wcslen(wszPreFix)+POSTFIX_SIZE+1));
		    if(NULL==pwszTemp)
				 goto MemoryError;
            *ppwsz = pwszTemp;

			if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
				wcscat(*ppwsz, wszPreFix);

			wcscat(*ppwsz, wszText);
			wcscat(*ppwsz, pInfo->pszDisplayText);

			if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
				wcscat(*ppwsz, wszCRLF);
			else
			{
				wcscat(*ppwsz, wszCOMMA);
				fComma=TRUE;
			}
		}

		//get rid of the last comma
		if(fComma)
			*(*ppwsz+wcslen(*ppwsz)-wcslen(wszCOMMA))=L'\0';
	}

	fResult=TRUE;
	

CommonReturn:

	if(pInfo)
		free(pInfo);

	if(pwszOrg)
		free(pwszOrg);

	if(pwszNumber)
		free(pwszNumber);

	return fResult;

ErrorReturn:

	if(*ppwsz)
	{
		free(*ppwsz);
		*ppwsz=NULL;
	}

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(LoadStringError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(SZtoWSZError);
TRACE_ERROR(GetNumberError);
SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
}


//--------------------------------------------------------------------------
//
//	 FormatCertQualifier:
//--------------------------------------------------------------------------
BOOL FormatCertQualifier(
	DWORD		                    dwCertEncodingType,
	DWORD		                    dwFormatType,
	DWORD		                    dwFormatStrType,
	void		                    *pFormatStruct,
    PCERT_POLICY_QUALIFIER_INFO     pInfo,
    LPWSTR                          *ppwszFormat)
{
    BOOL				fResult=FALSE;
    DWORD				cbNeeded=0;
    UINT				ids=0;
    PCCRYPT_OID_INFO	pOIDInfo=NULL;

    LPWSTR				pwszName=NULL;
	LPWSTR				pwszElement=NULL;
	LPWSTR				pwszOID=NULL;

    *ppwszFormat=NULL;

	//get the oid name
	pOIDInfo=CryptFindOIDInfo(CRYPT_OID_INFO_OID_KEY,
				pInfo->pszPolicyQualifierId,
				0);

	if(NULL == pOIDInfo)
	{
		if(S_OK!=SZtoWSZ(pInfo->pszPolicyQualifierId, &pwszOID))
			goto SZtoWSZError;
	}

    if(pInfo->Qualifier.cbData)
    {
	   if(0==strcmp(szOID_PKIX_POLICY_QUALIFIER_CPS, pInfo->pszPolicyQualifierId))
	   {
			//this is just a unicode format
			//turn off the multi line here
		   cbNeeded=0;

			if(!FormatAnyUnicodeStringExtension(
					dwCertEncodingType,
					dwFormatType,
					dwFormatStrType & (~CRYPT_FORMAT_STR_MULTI_LINE),
					pFormatStruct,
					pInfo->pszPolicyQualifierId,
					pInfo->Qualifier.pbData,
					pInfo->Qualifier.cbData,
					NULL,		
					&cbNeeded))
				goto FormatUnicodeError;

			pwszName=(LPWSTR)malloc(cbNeeded);
			if(NULL==pwszName)
				goto MemoryError;

			if(!FormatAnyUnicodeStringExtension(
					dwCertEncodingType,
					dwFormatType,
					dwFormatStrType & (~CRYPT_FORMAT_STR_MULTI_LINE),
					pFormatStruct,
					pInfo->pszPolicyQualifierId,
					pInfo->Qualifier.pbData,
					pInfo->Qualifier.cbData,
					pwszName,		
					&cbNeeded))
				goto FormatUnicodeError;

	   }
	   else
	   {
			if(0==strcmp(szOID_PKIX_POLICY_QUALIFIER_USERNOTICE,pInfo->pszPolicyQualifierId))
			{
				//this is yet another struct to format.  We remember to have
				//a 3 tab prefix
				if(!FormatPolicyUserNotice(
								dwCertEncodingType,
								dwFormatType,
								dwFormatStrType,
								pFormatStruct,
								IDS_THREE_TABS,
								pInfo->Qualifier.pbData,
								pInfo->Qualifier.cbData,
								&pwszName))
					goto FormatUserNoticdeError;
			}
			else
			{
			   //get the Hex dump of the Key Usage
			   cbNeeded=0;

			   if(!FormatBytesToHex(
								dwCertEncodingType,
								dwFormatType,
								dwFormatStrType,
								pFormatStruct,
								NULL,
								pInfo->Qualifier.pbData,
								pInfo->Qualifier.cbData,
								NULL,
								&cbNeeded))
					goto FormatBytesToHexError;

				pwszName=(LPWSTR)malloc(cbNeeded);
				if(NULL==pwszName)
					goto MemoryError;

				if(!FormatBytesToHex(
								dwCertEncodingType,
								dwFormatType,
								dwFormatStrType,
								pFormatStruct,
								NULL,
								pInfo->Qualifier.pbData,
								pInfo->Qualifier.cbData,
								pwszName,
								&cbNeeded))
					goto FormatBytesToHexError;

			}
	   }

	   //add the desired 3 tab prefix and new line for CSP and the new line
	   //for the multi line case
	   if((dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE) &&
		   (0!=strcmp(szOID_PKIX_POLICY_QUALIFIER_USERNOTICE,pInfo->pszPolicyQualifierId)))
	   {
			if(!FormatMessageUnicode(&pwszElement, IDS_POLICY_QUALIFIER_ELEMENT,
					pwszName))
				goto FormatMsgError;
	   }

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_POLICY_QUALIFIER_MULTI;
        else
            ids=IDS_POLICY_QUALIFIER;


        if(!FormatMessageUnicode(ppwszFormat, ids,
            pOIDInfo? pOIDInfo->pwszName : pwszOID, 
			pwszElement? pwszElement : pwszName))
            goto FormatMsgError;
    }
    else
    {
        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_POLICY_QUALIFIER_NO_BLOB_MULTI;
        else
            ids=IDS_POLICY_QUALIFIER_NO_BLOB;

        if(!FormatMessageUnicode(ppwszFormat, ids,
           pOIDInfo? pOIDInfo->pwszName : pwszOID))
            goto FormatMsgError;

    }

	fResult=TRUE;
	

CommonReturn:

    if(pwszName)
        free(pwszName);

	if(pwszElement)
		LocalFree((HLOCAL)pwszElement);

	if(pwszOID)
		free(pwszOID);

	return fResult;

ErrorReturn:

    if(*ppwszFormat)
    {
        LocalFree((HLOCAL)(*ppwszFormat));
        *ppwszFormat=NULL;
    }


	fResult=FALSE;
	goto CommonReturn;


TRACE_ERROR(FormatBytesToHexError);
TRACE_ERROR(FormatMsgError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatUnicodeError);
TRACE_ERROR(FormatUserNoticdeError);
TRACE_ERROR(SZtoWSZError);
}


//--------------------------------------------------------------------------
//
//	 FormatCertPolicies:     X509_CERT_POLICIES
//                           szOID_CERT_POLICIES
//                           szOID_APPLICATION_CERT_POLICIES
//
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatCertPolicies(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	LPWSTR							pwszFormat=NULL;
    LPWSTR                           pwsz=NULL;
    LPWSTR                           pwszPolicyFormat=NULL;
    LPWSTR                           pwszQualifiers=NULL;
    LPWSTR                           pwszQualifierFormat=NULL;
    LPWSTR                           pwszOneQualifier=NULL;
	LPWSTR							 pwszOID=NULL;

	PCERT_POLICIES_INFO	            pInfo=NULL;

    PCERT_POLICY_INFO               pPolicyInfo=NULL;
    DWORD                           dwIndex=0;
    DWORD                           dwQualifierIndex=0;
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
    UINT                            ids=0;
    PCCRYPT_OID_INFO                pOIDInfo=NULL;

    LPWSTR                          pwszTemp;
	
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_CERT_POLICIES,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

    pwsz=(LPWSTR)malloc(sizeof(WCHAR));
    if(NULL==pwsz)
        goto MemoryError;

    *pwsz=L'\0';

    for(dwIndex=0; dwIndex < pInfo->cPolicyInfo; dwIndex++)
    {
        //strcat ", "
        if(0!=wcslen(pwsz))
        {
            if(0==(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
               wcscat(pwsz, wszCOMMA);
        }

        pPolicyInfo=&(pInfo->rgPolicyInfo[dwIndex]);


        pwszQualifiers=(LPWSTR)malloc(sizeof(WCHAR));
        if(NULL==pwszQualifiers)
            goto MemoryError;

        *pwszQualifiers=L'\0';

         //format the qualifiers
         for(dwQualifierIndex=0;  dwQualifierIndex < pPolicyInfo->cPolicyQualifier;
            dwQualifierIndex++)
         {
            //strcat ", "
            if(0!=wcslen(pwszQualifiers))
            {
                if(0==(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                    wcscat(pwszQualifiers, wszCOMMA);
            }

            if(!FormatCertQualifier(dwCertEncodingType,
                                    dwFormatType,
                                    dwFormatStrType,
                                    pFormatStruct,
                                    &(pPolicyInfo->rgPolicyQualifier[dwQualifierIndex]),
                                    &pwszOneQualifier))
                   goto FormatCertQualifierError;

            //decide between single line and mulitple line format
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_POLICY_QUALIFIER_INFO_MULTI;
            else
                ids=IDS_POLICY_QUALIFIER_INFO;

             //format
             if(!FormatMessageUnicode(&pwszQualifierFormat,ids,
                    dwIndex+1,
                    dwQualifierIndex+1,
                    pwszOneQualifier))
                    goto FormatMsgError;

             //strcat
             #if (0) // DSIE: Bug 27436
             pwszQualifiers=(LPWSTR)realloc(pwszQualifiers, 
                 sizeof(WCHAR) * (wcslen(pwszQualifiers)+wcslen(wszCOMMA)+wcslen(pwszQualifierFormat)+1));
             if(NULL==pwszQualifiers)
                 goto MemoryError;
             #endif

             pwszTemp=(LPWSTR)realloc(pwszQualifiers, 
                 sizeof(WCHAR) * (wcslen(pwszQualifiers)+wcslen(wszCOMMA)+wcslen(pwszQualifierFormat)+1));
             if(NULL==pwszTemp)
                 goto MemoryError;
             pwszQualifiers = pwszTemp;

             wcscat(pwszQualifiers, pwszQualifierFormat);

             LocalFree((HLOCAL)pwszOneQualifier);
             pwszOneQualifier=NULL;

             LocalFree((HLOCAL)pwszQualifierFormat);
             pwszQualifierFormat=NULL;
         }

         //now, format the certPolicyInfo
		 pOIDInfo=CryptFindOIDInfo(CRYPT_OID_INFO_OID_KEY,
						pPolicyInfo->pszPolicyIdentifier,
					    0);

		 if(NULL == pOIDInfo)
		 {
			if(S_OK!=SZtoWSZ(pPolicyInfo->pszPolicyIdentifier, &pwszOID))
				goto SZtoWSZError;
		 }

         if(0!=pPolicyInfo->cPolicyQualifier)
         {
            //decide between single line and mulitple line format
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                if (0 == strcmp(lpszStructType, szOID_CERT_POLICIES))
                    ids=IDS_CERT_POLICY_MULTI;
                else
                    ids=IDS_APPLICATION_CERT_POLICY_MULTI;
            else
                if (0 == strcmp(lpszStructType, szOID_CERT_POLICIES))
                    ids=IDS_CERT_POLICY;
                else
                    ids=IDS_APPLICATION_CERT_POLICY;

             if(!FormatMessageUnicode(&pwszPolicyFormat,ids,
						dwIndex+1, pOIDInfo? pOIDInfo->pwszName : pwszOID,
                        pwszQualifiers))
                goto FormatMsgError;
         }
         else
         {
            //decide between single line and mulitple line format
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                if (0 == strcmp(lpszStructType, szOID_CERT_POLICIES))
                    ids=IDS_CERT_POLICY_NO_QUA_MULTI;
                else
                    ids=IDS_APPLICATION_CERT_POLICY_NO_QUA_MULTI;
            else
                if (0 == strcmp(lpszStructType, szOID_CERT_POLICIES))
                    ids=IDS_CERT_POLICY_NO_QUA;
                else
                    ids=IDS_APPLICATION_CERT_POLICY_NO_QUA;

             if(!FormatMessageUnicode(&pwszPolicyFormat, ids,
                        dwIndex+1, pOIDInfo? pOIDInfo->pwszName : pwszOID))
                goto FormatMsgError;
         }

         //strcat
         #if (0) // DSIE: Bug 27436
         pwsz=(LPWSTR)realloc(pwsz, 
             sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszPolicyFormat)+1));
         if(NULL==pwsz)
             goto MemoryError;
         #endif

         pwszTemp=(LPWSTR)realloc(pwsz, 
             sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszPolicyFormat)+1));
         if(NULL==pwszTemp)
             goto MemoryError;
         pwsz = pwszTemp;

         wcscat(pwsz, pwszPolicyFormat);

         free(pwszQualifiers);
         pwszQualifiers=NULL;

         LocalFree((HLOCAL)pwszPolicyFormat);
         pwszPolicyFormat=NULL;

		 if(pwszOID)
			free(pwszOID);
		 pwszOID=NULL;
    }


    if(0==wcslen(pwsz))
    {
       //no data
        pwszFormat=(LPWSTR)malloc(sizeof(WCHAR)*(NO_INFO_SIZE+1));
        if(NULL==pwszFormat)
            goto MemoryError;

        if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, pwszFormat, NO_INFO_SIZE))
            goto LoadStringError;

    }
    else
    {
        pwszFormat=pwsz;
        pwsz=NULL;
    }

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:
	if(pwszOID)
		free(pwszOID);

    if(pwszOneQualifier)
        LocalFree((HLOCAL)pwszOneQualifier);

    if(pwszQualifierFormat)
        LocalFree((HLOCAL)pwszQualifierFormat);

    if(pwszQualifiers)
      free(pwszQualifiers);

    if(pwszPolicyFormat)
        LocalFree((HLOCAL)pwszPolicyFormat);

    if(pwsz)
        free(pwsz);

	if(pwszFormat)
		free(pwszFormat);

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);
SET_ERROR(MemoryError,E_OUTOFMEMORY);
TRACE_ERROR(FormatCertQualifierError);
TRACE_ERROR(SZtoWSZError);
}


//--------------------------------------------------------------------------
//
//	 FormatCAVersion:   szOID_CERTSRV_CA_VERSION
//						Decode as X509_INTEGER
//
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatCAVersion(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	BOOL							fResult=FALSE;
	DWORD							cbNeeded=0;
	UINT							ids=0;
	DWORD							dwCAVersion=0;
	DWORD							cbCAVersion=sizeof(dwCAVersion);

	LPWSTR							pwszFormat=NULL;

	//check for input parameters
	if((NULL==pbEncoded && 0!=cbEncoded) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

	if(!CryptDecodeObject(dwCertEncodingType,X509_INTEGER,pbEncoded, cbEncoded,
		0,&dwCAVersion,&cbCAVersion))
		goto DecodeGenericError;

    //decide between single line and mulitple line format
    if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
        ids=IDS_CA_VERSION_MULTI;
    else
        ids=IDS_CA_VERSION;

	if(!FormatMessageUnicode(&pwszFormat, ids,
            CANAMEIDTOICERT(dwCAVersion), CANAMEIDTOIKEY(dwCAVersion)))
		goto FormatMsgError;

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;

CommonReturn:

	if(pwszFormat)
		LocalFree((HLOCAL)pwszFormat);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(FormatMsgError);
}

//--------------------------------------------------------------------------
//
//	 FormatNetscapeCertType:     
//							szOID_NETSCAPE_CERT_TYPE
//							Decode as X509_BITS
//
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatNetscapeCertType(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	BOOL							fResult=FALSE;
	DWORD							cbNeeded=0;
    WCHAR                           wszCertType[CERT_TYPE_SIZE+1];
	FORMAT_CERT_TYPE_INFO			rgCertType[]={
		  NETSCAPE_SSL_CLIENT_AUTH_CERT_TYPE,	IDS_NETSCAPE_SSL_CLIENT_AUTH,  //0x80
		  NETSCAPE_SSL_SERVER_AUTH_CERT_TYPE,	IDS_NETSCAPE_SSL_SERVER_AUTH,  //0x40
		  NETSCAPE_SMIME_CERT_TYPE,          	IDS_NETSCAPE_SMIME,			   //0x20
		  NETSCAPE_SIGN_CERT_TYPE,           	IDS_NETSCAPE_SIGN,			   //0x10
		  0x08,									IDS_UNKNOWN_CERT_TYPE,		   //0x08
		  NETSCAPE_SSL_CA_CERT_TYPE,         	IDS_NETSCAPE_SSL_CA,		   //0x04	
		  NETSCAPE_SMIME_CA_CERT_TYPE,       	IDS_NETSCAPE_SMIME_CA,		   //0x02
		  NETSCAPE_SIGN_CA_CERT_TYPE, 			IDS_NETSCAPE_SIGN_CA};		   //0x01
	DWORD							dwCertType=0;
	DWORD							dwIndex=0;

	CRYPT_BIT_BLOB					*pInfo=NULL;
    LPWSTR                          pwsz=NULL;
    LPWSTR                          pwszByte=NULL;
	LPWSTR							pwszFormat=NULL;

    LPWSTR                          pwszTemp;

	//check for input parameters
	if((NULL==pbEncoded && 0!=cbEncoded) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

   if(!DecodeGenericBLOB(dwCertEncodingType,X509_BITS,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;	 

    if(0==pInfo->cbData)
	   goto InvalidArg;

    pwsz=(LPWSTR)malloc(sizeof(WCHAR));
    if(NULL==pwsz)
        goto MemoryError;

    *pwsz=L'\0';

    //the count of bits to consider
	dwCertType=sizeof(rgCertType)/sizeof(rgCertType[0]);

	//we need to consider the unused bits in the last byte
	if((1 == pInfo->cbData) && (8 > pInfo->cUnusedBits))
	{
		dwCertType=8-pInfo->cUnusedBits;
	}

	for(dwIndex=0; dwIndex<dwCertType; dwIndex++)
	{
		if(pInfo->pbData[0] & rgCertType[dwIndex].bCertType)
		{
			if(!LoadStringU(hFrmtFuncInst, rgCertType[dwIndex].idsCertType, wszCertType, CERT_TYPE_SIZE))
				goto LoadStringError;

            #if (0) // DSIE: Bug 27436
			pwsz=(LPWSTR)realloc(pwsz, 
				sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCertType)+1+wcslen(wszCOMMA)));
			if(NULL==pwsz)
				goto MemoryError;
            #endif

			pwszTemp=(LPWSTR)realloc(pwsz, 
				sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCertType)+1+wcslen(wszCOMMA)));
			if(NULL==pwszTemp)
				goto MemoryError;
            pwsz = pwszTemp;

			wcscat(pwsz, wszCertType);
			wcscat(pwsz, wszCOMMA);
		}
	}

	//there is data that we can not interpret if the bit number is more than 8
	if(8 < (8 * pInfo->cbData - pInfo->cUnusedBits))
	{
		if(!LoadStringU(hFrmtFuncInst, IDS_UNKNOWN_CERT_TYPE, wszCertType, CERT_TYPE_SIZE))
			goto LoadStringError;

        #if (0) // DSIE: Bug 27436
		pwsz=(LPWSTR)realloc(pwsz, 
			sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCertType)+1+wcslen(wszCOMMA)));
		if(NULL==pwsz)
			goto MemoryError;
        #endif

		pwszTemp=(LPWSTR)realloc(pwsz, 
			sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCertType)+1+wcslen(wszCOMMA)));
		if(NULL==pwszTemp)
			goto MemoryError;
        pwsz = pwszTemp;

		wcscat(pwsz, wszCertType);
		wcscat(pwsz, wszCOMMA);
	}

	
    if(0==wcslen(pwsz))
    {
       #if (0) // DSIE: Bug 27436
       pwsz=(LPWSTR)realloc(pwsz, sizeof(WCHAR) * (CERT_TYPE_SIZE+1));
	   if(NULL == pwsz)
		   goto MemoryError;
       #endif

       pwszTemp=(LPWSTR)realloc(pwsz, sizeof(WCHAR) * (CERT_TYPE_SIZE+1));
	   if(NULL == pwszTemp)
		   goto MemoryError;
       pwsz = pwszTemp;

       if(!LoadStringU(hFrmtFuncInst, IDS_UNKNOWN_CERT_TYPE, pwsz,
           CERT_TYPE_SIZE))
		        goto LoadStringError;
    }
    else
    {
        //get rid of the last comma
        *(pwsz+wcslen(pwsz)-wcslen(wszCOMMA))=L'\0';
    }

    //get the Hex dump of the cert type
   cbNeeded=0;

   if(!FormatBytesToHex(
                    dwCertEncodingType,
                    dwFormatType,
                    dwFormatStrType,
                    pFormatStruct,
                    lpszStructType,
                    pInfo->pbData,
                    pInfo->cbData,
                    NULL,
	                &cbNeeded))
		goto FormatBytesToHexError;

    pwszByte=(LPWSTR)malloc(cbNeeded);
    if(NULL==pwszByte)
        goto MemoryError;

    if(!FormatBytesToHex(
                    dwCertEncodingType,
                    dwFormatType,
                    dwFormatStrType,
                    pFormatStruct,
                    lpszStructType,
                    pInfo->pbData,
                    pInfo->cbData,
                    pwszByte,
	                &cbNeeded))
        goto FormatBytesToHexError;


    //convert the WSZ
    if(!FormatMessageUnicode(&pwszFormat, IDS_BIT_BLOB, pwsz,
        pwszByte))
        goto FormatMsgError;

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:

	if(pInfo)
		free(pInfo);

    if(pwsz)
        free(pwsz);

    if(pwszByte)
        free(pwszByte);

	if(pwszFormat)
		LocalFree((HLOCAL)pwszFormat);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(FormatMsgError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatBytesToHexError);	
TRACE_ERROR(LoadStringError);
}


//--------------------------------------------------------------------------
//
//	 FormatAnyUnicodeStringExtension:     
//									szOID_ENROLLMENT_NAME_VALUE_PAIR
//									Decode as szOID_ENROLLMENT_NAME_VALUE_PAIR
//
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatAnyNameValueStringAttr(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	BOOL								fResult=FALSE;
	DWORD								cbNeeded=0;
	UINT								ids=0;

	CRYPT_ENROLLMENT_NAME_VALUE_PAIR	*pInfo=NULL;
	LPWSTR								pwszFormat=NULL;

	//check for input parameters
	if((NULL==pbEncoded && 0!=cbEncoded) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,szOID_ENROLLMENT_NAME_VALUE_PAIR,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

	if(NULL == pInfo->pwszName || NULL == pInfo->pwszValue)
		goto InvalidArg;

    //decide between single line and mulitple line format
    if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
        ids=IDS_NAME_VALUE_MULTI;
    else
        ids=IDS_NAME_VALUE;

	if(!FormatMessageUnicode(&pwszFormat, ids,
            pInfo->pwszName, pInfo->pwszValue))
		goto FormatMsgError;

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:

	if(pInfo)
		free(pInfo);

	if(pwszFormat)
		LocalFree((HLOCAL)pwszFormat);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(FormatMsgError);
}


//--------------------------------------------------------------------------
//
//	 FormatAnyUnicodeStringExtension:     
//									szOID_ENROLL_CERTTYPE_EXTENSION
//									szOID_NETSCAPE_REVOCATION_URL
//									Decode as X509_ANY_UNICODE_STRING
//
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatAnyUnicodeStringExtension(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	BOOL							fResult=FALSE;
	DWORD							cbNeeded=0;
	UINT							ids=0;

	CERT_NAME_VALUE					*pInfo=NULL;
	LPWSTR							pwszFormat=NULL;

	//check for input parameters
	if((NULL==pbEncoded && 0!=cbEncoded) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_UNICODE_ANY_STRING,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

	//the data can not be the encoded blob or the octect string
	if(!IS_CERT_RDN_CHAR_STRING(pInfo->dwValueType))
		goto DecodeGenericError;

    //decide between single line and mulitple line format
    if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
        ids=IDS_UNICODE_STRING_MULTI;
    else
        ids=IDS_UNICODE_STRING;

	if(!FormatMessageUnicode(&pwszFormat, ids,
            (LPWSTR)(pInfo->Value.pbData)))
		goto FormatMsgError;

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:

	if(pInfo)
		free(pInfo);

	if(pwszFormat)
		LocalFree((HLOCAL)pwszFormat);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(FormatMsgError);
}


//--------------------------------------------------------------------------
//
//	 FormatDistPointName:  Pre-condition: dwDistPointNameChoice!=0
//--------------------------------------------------------------------------
BOOL    FormatDistPointName(DWORD		            dwCertEncodingType,
	                        DWORD		            dwFormatType,
	                        DWORD		            dwFormatStrType,
	                        void		            *pFormatStruct,
                            PCRL_DIST_POINT_NAME    pInfo,
                            LPWSTR                  *ppwszFormat)
{
    BOOL            fResult=FALSE;
    DWORD           cbNeeded=0;
    LPWSTR          pwszCRLIssuer=NULL;
    UINT            ids=0;

    *ppwszFormat=NULL;

    if(CRL_DIST_POINT_FULL_NAME==pInfo->dwDistPointNameChoice)
    {
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
              ids=IDS_THREE_TABS;

        cbNeeded=0;
        if(!FormatAltNameInfo(dwCertEncodingType,
                                 dwFormatType,
                                 dwFormatStrType,
                                 pFormatStruct,
                                 ids,
                                 FALSE,
                                 &(pInfo->FullName),
                                 NULL,
                                 &cbNeeded))
                goto FormatAltNameError;

        pwszCRLIssuer=(LPWSTR)malloc(cbNeeded);
        if(NULL==pwszCRLIssuer)
            goto MemoryError;

         if(!FormatAltNameInfo(dwCertEncodingType,
                                 dwFormatType,
                                 dwFormatStrType,
                                 pFormatStruct,
                                 ids,
                                 FALSE,
                                 &(pInfo->FullName),
                                 pwszCRLIssuer,
                                 &cbNeeded))
              goto FormatAltNameError;

        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
              ids=IDS_CRL_DIST_FULL_NAME_MULTI;
        else
              ids=IDS_CRL_DIST_FULL_NAME;


         if(!FormatMessageUnicode(ppwszFormat, ids,pwszCRLIssuer))
             goto FormatMsgError;
    }
    else if(CRL_DIST_POINT_ISSUER_RDN_NAME==pInfo->dwDistPointNameChoice)
    {
        *ppwszFormat=(LPWSTR)malloc(sizeof(WCHAR)*(CRL_DIST_NAME_SIZE+1));
        if(NULL==*ppwszFormat)
            goto MemoryError;

        if(!LoadStringU(hFrmtFuncInst, IDS_CRL_DIST_ISSUER_RDN,
                *ppwszFormat,CRL_DIST_NAME_SIZE))
            goto LoadStringError;

    }
    else
    {
        if(!FormatMessageUnicode(ppwszFormat, IDS_DWORD,
            pInfo->dwDistPointNameChoice))
            goto FormatMsgError;
    }

	fResult=TRUE;
	

CommonReturn:
    if(pwszCRLIssuer)
        free(pwszCRLIssuer);

	return fResult;

ErrorReturn:
    if(*ppwszFormat)
    {
        LocalFree((HLOCAL)(*ppwszFormat));
        *ppwszFormat=NULL;
    }

	fResult=FALSE;
	goto CommonReturn;


TRACE_ERROR(FormatMsgError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(LoadStringError);
TRACE_ERROR(FormatAltNameError);

}
//--------------------------------------------------------------------------
//
//	 FormatCRLReason:  Pre-condition: pReason.cbData != 0
//--------------------------------------------------------------------------
BOOL    FormatCRLReason(DWORD		    dwCertEncodingType,
	                    DWORD		    dwFormatType,
	                    DWORD		    dwFormatStrType,
	                    void		    *pFormatStruct,
	                    LPCSTR		    lpszStructType,
                        PCRYPT_BIT_BLOB pInfo,
                        LPWSTR          *ppwszFormat)
{
    LPWSTR                          pwszFormat=NULL;
    LPWSTR                          pwszByte=NULL;

    WCHAR                           wszReason[CRL_REASON_SIZE+1];
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;

    LPWSTR                          pwszTemp;

	*ppwszFormat=NULL;

    pwszFormat=(LPWSTR)malloc(sizeof(WCHAR));
    if(NULL==pwszFormat)
        goto MemoryError;

    *pwszFormat=L'\0';

    //format the 1st byte
    if(pInfo->pbData[0] & CRL_REASON_UNUSED_FLAG)
    {
        if(!LoadStringU(hFrmtFuncInst, IDS_UNSPECIFIED, wszReason, CRL_REASON_SIZE))
	        goto LoadStringError;

        #if (0) // DSIE: Bug 27436
        pwszFormat=(LPWSTR)realloc(pwszFormat, 
			sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszReason)+1+wcslen(wszCOMMA)));
        if(NULL==pwszFormat)
            goto MemoryError;
        #endif

        pwszTemp=(LPWSTR)realloc(pwszFormat, 
			sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszReason)+1+wcslen(wszCOMMA)));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwszFormat = pwszTemp;

        wcscat(pwszFormat, wszReason);
        wcscat(pwszFormat, wszCOMMA);
    }

    if(pInfo->pbData[0] & CRL_REASON_KEY_COMPROMISE_FLAG)
    {
        if(!LoadStringU(hFrmtFuncInst, IDS_KEY_COMPROMISE, wszReason,CRL_REASON_SIZE))
	        goto LoadStringError;

        #if (0) // DSIE: Bug 27436
        pwszFormat=(LPWSTR)realloc(pwszFormat, 
			sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszReason)+1+wcslen(wszCOMMA)));
        if(NULL==pwszFormat)
            goto MemoryError;
        #endif

        pwszTemp=(LPWSTR)realloc(pwszFormat, 
			sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszReason)+1+wcslen(wszCOMMA)));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwszFormat = pwszTemp;

        wcscat(pwszFormat, wszReason);
        wcscat(pwszFormat, wszCOMMA);
    }

    if(pInfo->pbData[0] & CRL_REASON_CA_COMPROMISE_FLAG )
    {
        if(!LoadStringU(hFrmtFuncInst, IDS_CA_COMPROMISE,wszReason, CRL_REASON_SIZE))
		        goto LoadStringError;

        #if (0) // DSIE: Bug 27436
        pwszFormat=(LPWSTR)realloc(pwszFormat, 
				sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszReason)+1+wcslen(wszCOMMA)));
        if(NULL==pwszFormat)
            goto MemoryError;
        #endif

        pwszTemp=(LPWSTR)realloc(pwszFormat, 
				sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszReason)+1+wcslen(wszCOMMA)));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwszFormat = pwszTemp;

        wcscat(pwszFormat, wszReason);
        wcscat(pwszFormat, wszCOMMA);
    }


    if(pInfo->pbData[0] & CRL_REASON_AFFILIATION_CHANGED_FLAG )
    {
        if(!LoadStringU(hFrmtFuncInst, IDS_AFFILIATION_CHANGED, wszReason, CRL_REASON_SIZE))
	        goto LoadStringError;

        #if (0) // DSIE: Bug 27436
        pwszFormat=(LPWSTR)realloc(pwszFormat, 
			sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszReason)+1+wcslen(wszCOMMA)));
        if(NULL==pwszFormat)
            goto MemoryError;
        #endif

        pwszTemp=(LPWSTR)realloc(pwszFormat, 
			sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszReason)+1+wcslen(wszCOMMA)));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwszFormat = pwszTemp;

        wcscat(pwszFormat, wszReason);
        wcscat(pwszFormat, wszCOMMA);
    }

    if(pInfo->pbData[0] & CRL_REASON_SUPERSEDED_FLAG )
    {
        if(!LoadStringU(hFrmtFuncInst, IDS_SUPERSEDED, wszReason, CRL_REASON_SIZE))
	        goto LoadStringError;

        #if (0) // DSIE: Bug 27436
		pwszFormat=(LPWSTR)realloc(pwszFormat, 
			sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszReason)+1+wcslen(wszCOMMA)));
        if(NULL==pwszFormat)
            goto MemoryError;
        #endif

		pwszTemp=(LPWSTR)realloc(pwszFormat, 
			sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszReason)+1+wcslen(wszCOMMA)));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwszFormat = pwszTemp;

        wcscat(pwszFormat, wszReason);
        wcscat(pwszFormat, wszCOMMA);
    }

    if(pInfo->pbData[0] & CRL_REASON_CESSATION_OF_OPERATION_FLAG )
    {
        if(!LoadStringU(hFrmtFuncInst, IDS_CESSATION_OF_OPERATION, wszReason, CRL_REASON_SIZE))
		        goto LoadStringError;

        #if (0) // DSIE: Bug 27436
        pwszFormat=(LPWSTR)realloc(pwszFormat, 
				sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszReason)+1+wcslen(wszCOMMA)));
        if(NULL==pwszFormat)
            goto MemoryError;
        #endif

        pwszTemp=(LPWSTR)realloc(pwszFormat, 
				sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszReason)+1+wcslen(wszCOMMA)));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwszFormat = pwszTemp;

        wcscat(pwszFormat, wszReason);
        wcscat(pwszFormat, wszCOMMA);
    }

    if(pInfo->pbData[0] & CRL_REASON_CERTIFICATE_HOLD_FLAG  )
    {
        if(!LoadStringU(hFrmtFuncInst, IDS_CERTIFICATE_HOLD, wszReason, CRL_REASON_SIZE))
	        goto LoadStringError;

        #if (0) // DSIE: Bug 27436
        pwszFormat=(LPWSTR)realloc(pwszFormat, 
			sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszReason)+1+wcslen(wszCOMMA)));
        if(NULL==pwszFormat)
            goto MemoryError;
        #endif

        pwszTemp=(LPWSTR)realloc(pwszFormat, 
			sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszReason)+1+wcslen(wszCOMMA)));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwszFormat = pwszTemp;

        wcscat(pwszFormat, wszReason);
        wcscat(pwszFormat, wszCOMMA);
    }

    if(0==wcslen(pwszFormat))
    {
        #if (0) // DSIE: Bug 27436
        pwszFormat=(LPWSTR)realloc(pwszFormat, sizeof(WCHAR) * (UNKNOWN_CRL_REASON_SIZE+1));
        #endif

        pwszTemp=(LPWSTR)realloc(pwszFormat, sizeof(WCHAR) * (UNKNOWN_CRL_REASON_SIZE+1));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwszFormat = pwszTemp;

        if(!LoadStringU(hFrmtFuncInst, IDS_UNKNOWN_CRL_REASON, pwszFormat,
            UNKNOWN_CRL_REASON_SIZE))
	            goto LoadStringError;
    }
    else
    {
        //get rid of the last comma
        *(pwszFormat+wcslen(pwszFormat)-wcslen(wszCOMMA))=L'\0';
    }

    //get the Hex dump of the Key Usage
    cbNeeded=0;

    if(!FormatBytesToHex(
                    dwCertEncodingType,
                    dwFormatType,
                    dwFormatStrType,
                    pFormatStruct,
                    lpszStructType,
                    pInfo->pbData,
                    pInfo->cbData,
                    NULL,
	                &cbNeeded))
        goto FormatBytesToHexError;

    pwszByte=(LPWSTR)malloc(cbNeeded);
    if(NULL==pwszByte)
        goto MemoryError;

    if(!FormatBytesToHex(
                    dwCertEncodingType,
                    dwFormatType,
                    dwFormatStrType,
                    pFormatStruct,
                    lpszStructType,
                    pInfo->pbData,
                    pInfo->cbData,
                    pwszByte,
	                &cbNeeded))
        goto FormatBytesToHexError;

    //convert the WSZ
    if(!FormatMessageUnicode(ppwszFormat, IDS_BIT_BLOB, pwszFormat,
        pwszByte))
        goto FormatMsgError;

	fResult=TRUE;
	
CommonReturn:
    if(pwszFormat)
        free(pwszFormat);

    if(pwszByte)
        free(pwszByte);

	return fResult;

ErrorReturn:
    if(*ppwszFormat)
    {
        LocalFree((HLOCAL)(*ppwszFormat));
        *ppwszFormat=NULL;
    }

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(LoadStringError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatBytesToHexError);
TRACE_ERROR(FormatMsgError);

}

//--------------------------------------------------------------------------
//
//	 FormatCRLDistPoints:   X509_CRL_DIST_POINTS
//                          szOID_CRL_DIST_POINTS
//                          szOID_FRESHEST_CRL
//                          szOID_CRL_SELF_CDP
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatCRLDistPoints(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	LPWSTR					pwszFormat=NULL;
    LPWSTR                  pwsz=NULL;
    LPWSTR                  pwszEntryFormat=NULL;
    LPWSTR                  pwszEntryTagFormat=NULL;

    LPWSTR                  pwszPointName=NULL;
    LPWSTR                  pwszNameFormat=NULL;
    LPWSTR                  pwszCRLReason=NULL;
    LPWSTR                  pwszReasonFormat=NULL;
    LPWSTR                  pwszCRLIssuer=NULL;
    LPWSTR                  pwszIssuerFormat=NULL;

	PCRL_DIST_POINTS_INFO	pInfo=NULL;

	DWORD					cbNeeded=0;
    DWORD                   dwIndex=0;
	BOOL					fResult=FALSE;
    UINT                    ids=0;

    LPWSTR                  pwszTemp;
    LPCSTR                  pszOID;
    
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    //DSIE: Cert server encodes szOID_CRL_SEL_CDP using szOID_CRL_DIST_POINTS,
    //      so we need to change the lpszStructType for decoding.
    if (0 == strcmp(lpszStructType, szOID_CRL_SELF_CDP))
    {
        pszOID = szOID_CRL_DIST_POINTS;
    }
    else
    {
        pszOID = lpszStructType;
    }
    
    if (!DecodeGenericBLOB(dwCertEncodingType, pszOID, //lpszStructType,
			pbEncoded, cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

    pwsz=(LPWSTR)malloc(sizeof(WCHAR));
    if(NULL==pwsz)
        goto MemoryError;
    *pwsz=L'\0';

    for(dwIndex=0; dwIndex<pInfo->cDistPoint; dwIndex++)
    {
        //format distribution name
        if(0!=pInfo->rgDistPoint[dwIndex].DistPointName.dwDistPointNameChoice)
        {
            if(!FormatDistPointName(
                    dwCertEncodingType,
                    dwFormatType,
                    dwFormatStrType,
                    pFormatStruct,
                    &(pInfo->rgDistPoint[dwIndex].DistPointName),
                    &pwszPointName))
                goto FormatDistPointNameError;

           //decide between single line and mulitple line format
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_CRL_DIST_NAME_MULTI;
            else
                ids=IDS_CRL_DIST_NAME;


            if(!FormatMessageUnicode(&pwszNameFormat, ids,pwszPointName))
                goto FormatMsgError;
        }

        //format the CRL reason
        if(0!=pInfo->rgDistPoint[dwIndex].ReasonFlags.cbData)
        {
            if(!FormatCRLReason(dwCertEncodingType,
                                dwFormatType,
                                dwFormatStrType,
                                pFormatStruct,
                                lpszStructType,
                                &(pInfo->rgDistPoint[dwIndex].ReasonFlags),
                                &pwszCRLReason))
                goto FormatCRLReasonError;


            //decide between single line and mulitple line format
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_CRL_DIST_REASON_MULTI;
            else
                ids=IDS_CRL_DIST_REASON;

            if(!FormatMessageUnicode(&pwszReasonFormat, ids ,pwszCRLReason))
                goto FormatMsgError;

        }

        //format the Issuer
       if(0!=pInfo->rgDistPoint[dwIndex].CRLIssuer.cAltEntry)
       {
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_TWO_TABS;
            else
                ids=0;


            cbNeeded=0;
            if(!FormatAltNameInfo(dwCertEncodingType,
                                  dwFormatType,
                                  dwFormatStrType,
                                  pFormatStruct,
                                  ids,
                                  FALSE,
                                  &(pInfo->rgDistPoint[dwIndex].CRLIssuer),
                                  NULL,
                                  &cbNeeded))
                goto FormatAltNameError;

           pwszCRLIssuer=(LPWSTR)malloc(cbNeeded);
           if(NULL==pwszCRLIssuer)
               goto MemoryError;

            if(!FormatAltNameInfo(dwCertEncodingType,
                                 dwFormatType,
                                 dwFormatStrType,
                                 pFormatStruct,
                                 ids,
                                 FALSE,
                                 &(pInfo->rgDistPoint[dwIndex].CRLIssuer),
                                 pwszCRLIssuer,
                                 &cbNeeded))
                goto FormatAltNameError;

            //decide between single line and mulitple line format
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_CRL_DIST_ISSUER_MULTI;
            else
                ids=IDS_CRL_DIST_ISSUER;

            if(!FormatMessageUnicode(&pwszIssuerFormat,ids,pwszCRLIssuer))
                goto FormatMsgError;
       }

       cbNeeded=0;

       if(pwszNameFormat)
           cbNeeded+=wcslen(pwszNameFormat);

       if(pwszReasonFormat)
           cbNeeded+=wcslen(pwszReasonFormat);

       if(pwszIssuerFormat)
           cbNeeded+=wcslen(pwszIssuerFormat);

       if(0!=cbNeeded)
       {
            //add ", " between each element for single line format
            if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
            {
                if(0!=wcslen(pwsz))
                    wcscat(pwsz, wszCOMMA);
            }

            //strcat all the information, including the COMMA
            cbNeeded += wcslen(wszCOMMA)*2;

            pwszEntryFormat=(LPWSTR)malloc(sizeof(WCHAR) * (cbNeeded+1));
            if(NULL==pwszEntryFormat)
                goto MemoryError;

            *pwszEntryFormat=L'\0';

            //strcat all three fields one at a time
            if(pwszNameFormat)
                wcscat(pwszEntryFormat, pwszNameFormat);

            if(pwszReasonFormat)
            {
                if(0!=wcslen(pwszEntryFormat))
                {
                    if(0==(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                        wcscat(pwszEntryFormat, wszCOMMA);
                }

                wcscat(pwszEntryFormat, pwszReasonFormat);
            }

            if(pwszIssuerFormat)
            {
                if(0!=wcslen(pwszEntryFormat))
                {
                    if(0==(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                        wcscat(pwszEntryFormat, wszCOMMA);
                }

                wcscat(pwszEntryFormat, pwszIssuerFormat);
            }

            //format the entry
            //decide between single line and mulitple line format
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                //
                // DSIE: Load appropriate format string.
                //
                if (0 == strcmp(lpszStructType, szOID_FRESHEST_CRL))
                    ids=IDS_FRESHEST_CRL_MULTI;
                else if (0 == strcmp(lpszStructType, szOID_CRL_SELF_CDP))
                    ids=IDS_CRL_SELF_CDP_MULTI;
                else
                    ids=IDS_CRL_DIST_ENTRY_MULTI;
            else
                if (0 == strcmp(lpszStructType, szOID_FRESHEST_CRL))
                    ids=IDS_FRESHEST_CRL;
                else if (0 == strcmp(lpszStructType, szOID_CRL_SELF_CDP))
                    ids=IDS_CRL_SELF_CDP;
                else
                    ids=IDS_CRL_DIST_ENTRY;

            if(!FormatMessageUnicode(&pwszEntryTagFormat, ids, dwIndex+1,
                pwszEntryFormat))
                goto FormatMsgError;

            //strcat the entry
            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszEntryTagFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszEntryTagFormat)+1));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz, pwszEntryTagFormat);

            //free memory
            free(pwszEntryFormat);
            pwszEntryFormat=NULL;

            LocalFree(pwszEntryTagFormat);
            pwszEntryTagFormat=NULL;
       }

       //free memory
       if(pwszPointName)
       {
           LocalFree((HLOCAL)pwszPointName);
           pwszPointName=NULL;
       }

       if(pwszCRLReason)
       {
           LocalFree((HLOCAL)(pwszCRLReason));
           pwszCRLReason=NULL;
       }

       if(pwszCRLIssuer)
       {
           free(pwszCRLIssuer);
           pwszCRLIssuer=NULL;
       }

       if(pwszNameFormat)
       {
            LocalFree((HLOCAL)pwszNameFormat);
            pwszNameFormat=NULL;
       }

       if(pwszReasonFormat)
       {
            LocalFree((HLOCAL)pwszReasonFormat);
            pwszReasonFormat=NULL;
       }

       if(pwszIssuerFormat)
       {
            LocalFree((HLOCAL)pwszIssuerFormat);
            pwszIssuerFormat=NULL;
       }
    }

    if(0==wcslen(pwsz))
    {
       //no data
        pwszFormat=(LPWSTR)malloc(sizeof(WCHAR)*(NO_INFO_SIZE+1));
        if(NULL==pwszFormat)
            goto MemoryError;

        if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, pwszFormat, NO_INFO_SIZE))
            goto LoadStringError;

    }
    else
    {
        pwszFormat=pwsz;
        pwsz=NULL;

    }

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:
    if(pwszEntryFormat)
      free(pwszEntryFormat);

    if(pwszEntryTagFormat)
      LocalFree((HLOCAL)pwszEntryTagFormat);

    //free memory
    if(pwszPointName)
       LocalFree((HLOCAL)pwszPointName);

    if(pwszCRLReason)
       LocalFree((HLOCAL)(pwszCRLReason));

    if(pwszCRLIssuer)
       free(pwszCRLIssuer);

    if(pwszNameFormat)
        LocalFree((HLOCAL)pwszNameFormat);

    if(pwszReasonFormat)
        LocalFree((HLOCAL)pwszReasonFormat);

    if(pwszIssuerFormat)
        LocalFree((HLOCAL)pwszIssuerFormat);

    if(pwsz)
        free(pwsz);

	if(pwszFormat)
		free(pwszFormat);

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatDistPointNameError);
TRACE_ERROR(FormatCRLReasonError);
TRACE_ERROR(FormatAltNameError);

}

//--------------------------------------------------------------------------
//
//	FormatCertPolicyID:
//
//      Pre-condition: pCertPolicyID has to include the valid information.that is,
//      cCertPolicyElementId can not be 0.
//--------------------------------------------------------------------------
BOOL FormatCertPolicyID(PCERT_POLICY_ID pCertPolicyID, LPWSTR  *ppwszFormat)
{

    BOOL        fResult=FALSE;
    LPSTR       pszFormat=NULL;
    DWORD       dwIndex=0;
    HRESULT     hr=S_OK;

    LPSTR       pwszTemp;

    *ppwszFormat=NULL;

    if(0==pCertPolicyID->cCertPolicyElementId)
        goto InvalidArg;

    pszFormat=(LPSTR)malloc(sizeof(CHAR));
    if(NULL==pszFormat)
        goto MemoryError;

    *pszFormat='\0';


    for(dwIndex=0; dwIndex<pCertPolicyID->cCertPolicyElementId; dwIndex++)
    {
        #if (0) // DSIE: Bug 27436
        pszFormat=(LPSTR)realloc(pszFormat, strlen(pszFormat)+
                strlen(pCertPolicyID->rgpszCertPolicyElementId[dwIndex])+strlen(strCOMMA)+1);
        if(NULL==pszFormat)
            goto MemoryError;
        #endif

        pwszTemp=(LPSTR)realloc(pszFormat, strlen(pszFormat)+
                strlen(pCertPolicyID->rgpszCertPolicyElementId[dwIndex])+strlen(strCOMMA)+1);
        if(NULL==pwszTemp)
            goto MemoryError;
        pszFormat = pwszTemp;

        strcat(pszFormat,pCertPolicyID->rgpszCertPolicyElementId[dwIndex]);

        strcat(pszFormat, strCOMMA);
    }

    //get rid of the last COMMA
    *(pszFormat+strlen(pszFormat)-strlen(strCOMMA))='\0';

    //convert to WCHAR
    if(S_OK!=(hr=SZtoWSZ(pszFormat, ppwszFormat)))
        goto SZtoWSZError;

	fResult=TRUE;

CommonReturn:

    if(pszFormat)
        free(pszFormat);

	return fResult;

ErrorReturn:
    if(*ppwszFormat)
    {
        free(*ppwszFormat);
        *ppwszFormat=NULL;
    }

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
SET_ERROR_VAR(SZtoWSZError,hr);
}

//--------------------------------------------------------------------------
//
//	 FormatKeyRestriction:   X509_KEY_USAGE_RESTRICTION
//                           szOID_KEY_USAGE_RESTRICTION
//
//
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatKeyRestriction(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	LPWSTR							    pwszFormat=NULL;
    LPWSTR                              pwsz=NULL;
	PCERT_KEY_USAGE_RESTRICTION_INFO	pInfo=NULL;
    LPWSTR                              pwszPolicy=NULL;
    LPWSTR                              pwszPolicyFormat=NULL;
    LPWSTR                              pwszKeyUsage=NULL;
    LPWSTR                              pwszKeyUsageFormat=NULL;

	DWORD							    cbNeeded=0;
    DWORD                               dwIndex=0;
	BOOL							    fResult=FALSE;
    UINT                                ids=0;

    LPWSTR                              pwszTemp;
    
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_KEY_USAGE_RESTRICTION,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

    pwsz=(LPWSTR)malloc(sizeof(WCHAR));
    if(NULL==pwsz)
        goto MemoryError;

    *pwsz=L'\0';

    for(dwIndex=0; dwIndex<pInfo->cCertPolicyId; dwIndex++)
    {

       if(0!=((pInfo->rgCertPolicyId)[dwIndex].cCertPolicyElementId))
       {
            //concatecate the comma if not the 1st item
            if(0!=wcslen(pwsz))
            {
                if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                    wcscat(pwsz, wszCOMMA);
            }

            if(!FormatCertPolicyID(&((pInfo->rgCertPolicyId)[dwIndex]), &pwszPolicy))
                goto FormatCertPolicyIDError;

            //decide between single line and mulitple line format
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_KEY_RES_ID_MULTI;
            else
                ids=IDS_KEY_RES_ID;

            if(!FormatMessageUnicode(&pwszPolicyFormat, ids,dwIndex+1,pwszPolicy))
                goto FormatMsgError;

            //allocate memory, including the ", "
            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszPolicyFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszPolicyFormat)+1));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz, pwszPolicyFormat);

            free(pwszPolicy);
            pwszPolicy=NULL;

            LocalFree((HLOCAL)pwszPolicyFormat);
            pwszPolicyFormat=NULL;
       }
    }

    //format the RestrictedKeyUsage
    if(0!=pInfo->RestrictedKeyUsage.cbData)
    {
       //concatecate the comma if not the 1st item
        if(0!=wcslen(pwsz))
        {
            if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                wcscat(pwsz, wszCOMMA);
        }


        cbNeeded=0;

        if(!FormatKeyUsageBLOB(
                        dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        lpszStructType,
                        &(pInfo->RestrictedKeyUsage),
                        NULL,
	                    &cbNeeded))
             goto FormatKeyUsageBLOBError;

        pwszKeyUsage=(LPWSTR)malloc(cbNeeded);
        if(NULL==pwszKeyUsage)
               goto MemoryError;

       if(!FormatKeyUsageBLOB(
                        dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        lpszStructType,
                        &(pInfo->RestrictedKeyUsage),
                        pwszKeyUsage,
	                    &cbNeeded))
              goto FormatKeyUsageBLOBError;

      //decide between single line and mulitple line format
      if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_KEY_RES_USAGE_MULTI;
       else
                ids=IDS_KEY_RES_USAGE;

        //format the element string
        if(!FormatMessageUnicode(&pwszKeyUsageFormat, ids, pwszKeyUsage))
            goto FormatMsgError;

        #if (0) // DSIE: Bug 27436
        pwsz=(LPWSTR)realloc(pwsz, 
            sizeof(WCHAR) * (wcslen(pwsz)+wcslen(pwszKeyUsageFormat)+1));
        if(NULL==pwsz)
            goto MemoryError;
        #endif
        
        pwszTemp=(LPWSTR)realloc(pwsz, 
            sizeof(WCHAR) * (wcslen(pwsz)+wcslen(pwszKeyUsageFormat)+1));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwsz = pwszTemp;

        wcscat(pwsz, pwszKeyUsageFormat);
    }

    if(0==wcslen(pwsz))
    {
       //no data
        pwszFormat=(LPWSTR)malloc(sizeof(WCHAR)*(NO_INFO_SIZE+1));
        if(NULL==pwszFormat)
            goto MemoryError;

        if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, pwszFormat, NO_INFO_SIZE))
            goto LoadStringError;

    }
    else
    {
        pwszFormat=pwsz;
        pwsz=NULL;
    }

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:
    if(pwszPolicy)
        free(pwszPolicy);

    if(pwszPolicyFormat)
        LocalFree((HLOCAL)pwszPolicyFormat);

    if(pwszKeyUsage)
        free(pwszKeyUsage);

    if(pwszKeyUsageFormat)
        LocalFree((HLOCAL)pwszKeyUsageFormat);

    if(pwszFormat)
		free(pwszFormat);

    if(pwsz)
        free(pwsz);

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatCertPolicyIDError);
TRACE_ERROR(FormatKeyUsageBLOBError);

}

//-----------------------------------------------------------------------
//
//	 FormatFileTime
//
//   Pre-condition: pFileTime points to valid data
//
//------------------------------------------------------------------------
BOOL	FormatFileTime(FILETIME *pFileTime,LPWSTR *ppwszFormat)
{
    BOOL                fResult;
    int                 cch;
    int                 cch2;
    LPWSTR              psz;
    SYSTEMTIME          st;
    FILETIME            localTime;
    DWORD               locale;
    BOOL                bRTLLocale;
    DWORD               dwFlags = DATE_LONGDATE;

    //  See if the user locale id is RTL (Arabic, Urdu, Farsi or Hebrew).
    locale = GetUserDefaultLCID();
    bRTLLocale = ((PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_ARABIC) ||
                  (PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_URDU)   ||
                  (PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_FARSI)  ||
                  (PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_HEBREW));
    locale = MAKELCID( MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), SORT_DEFAULT) ;

    if (bRTLLocale)
    {
       DWORD dwLayout;

       if (GetProcessDefaultLayout(&dwLayout)) 
       {
           if (dwLayout & LAYOUT_RTL) 
           {
               dwFlags |= DATE_RTLREADING;
           } 
           else 
           {
               dwFlags |= DATE_LTRREADING;
           }
       }
       else
       {
           dwFlags |= DATE_LTRREADING;
       }
    }

    if (!FileTimeToLocalFileTime(pFileTime, &localTime))
    {
        goto ToLocalTimeError;
    }
    
    if (!FileTimeToSystemTime(&localTime, &st)) 
    {
        //
        // if the conversion to local time failed, then just use the original time
        //
        if (!FileTimeToSystemTime(pFileTime, &st)) 
        {
            goto ToSystemTimeError;
        }
    }

    cch = (GetTimeFormatU(LOCALE_USER_DEFAULT, 0, &st, NULL, NULL, 0) +
           GetDateFormatU(locale, dwFlags, &st, NULL, NULL, 0) + 5);

    if (NULL == (psz = (LPWSTR) LocalAlloc(LPTR, (cch+5) * sizeof(WCHAR))))
    {
        goto OutOfMemoryError;
    }
    
    cch2 = GetDateFormatU(locale, dwFlags, &st, NULL, psz, cch);

    psz[cch2-1] = ' ';
    GetTimeFormatU(LOCALE_USER_DEFAULT, 0, &st, NULL, &psz[cch2], cch-cch2);
    
    *ppwszFormat = psz;

    fResult = TRUE;

CommonReturn:

	return fResult;

ErrorReturn:
    if(*ppwszFormat)
    {
        LocalFree((HLOCAL)(*ppwszFormat));
        *ppwszFormat=NULL;
    }

    fResult=FALSE;
    goto CommonReturn;

TRACE_ERROR(ToLocalTimeError);
TRACE_ERROR(ToSystemTimeError);
TRACE_ERROR(OutOfMemoryError);
}




//--------------------------------------------------------------------------
//
//	 FormatKeyAttributes:   X509_KEY_ATTRIBUTES
//                          szOID_KEY_ATTRIBUTES
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatKeyAttributes(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{

    LPWSTR							pwszFormat=NULL;
    LPWSTR                          pwsz=NULL;

    LPWSTR                          pwszKeyIDFormat=NULL;
    LPWSTR                          pwszKeyID=NULL;

    LPWSTR                          pwszKeyUsageFormat=NULL;
    LPWSTR                          pwszKeyUsage=NULL;

    LPWSTR                          pwszKeyBeforeFormat=NULL;
    LPWSTR                          pwszKeyBefore=NULL;

    LPWSTR                          pwszKeyAfterFormat=NULL;
    LPWSTR                          pwszKeyAfter=NULL;
	PCERT_KEY_ATTRIBUTES_INFO   	pInfo=NULL;


	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
    UINT                            ids=0;

    LPWSTR                          pwszTemp;
	
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_KEY_ATTRIBUTES,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

    pwsz=(LPWSTR)malloc(sizeof(WCHAR));
    if(NULL==pwsz)
        goto MemoryError;

    *pwsz=L'\0';


    if(0!=pInfo->KeyId.cbData)
    {
        cbNeeded=0;

        if(!FormatBytesToHex(
                        dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        lpszStructType,
                        pInfo->KeyId.pbData,
                        pInfo->KeyId.cbData,
                        NULL,
	                    &cbNeeded))
             goto FormatBytesToHexError;

        pwszKeyID=(LPWSTR)malloc(cbNeeded);
        if(NULL==pwszKeyID)
               goto MemoryError;

       if(!FormatBytesToHex(
                        dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        lpszStructType,
                        pInfo->KeyId.pbData,
                        pInfo->KeyId.cbData,
                        pwszKeyID,
	                    &cbNeeded))
              goto FormatBytesToHexError;


        //format the element string

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_KEY_ATTR_ID_MULTI;
        else
            ids=IDS_KEY_ATTR_ID;

        if(!FormatMessageUnicode(&pwszKeyIDFormat, ids, pwszKeyID))
            goto FormatMsgError;

        #if (0) // DSIE: Bug 27436
        pwsz=(LPWSTR)realloc(pwsz, 
            sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszKeyIDFormat)+1));
        if(NULL==pwsz)
            goto MemoryError;
        #endif

        pwszTemp=(LPWSTR)realloc(pwsz, 
            sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszKeyIDFormat)+1));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwsz = pwszTemp;

        wcscat(pwsz, pwszKeyIDFormat);
    }


    //check the no data situation
    if(0!=pInfo->IntendedKeyUsage.cbData)
    {
        //strcat a ", " symbol for signle line format
       if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
        {
            if(0!=wcslen(pwsz))
                wcscat(pwsz, wszCOMMA);
        }


        cbNeeded=0;

        if(!FormatKeyUsageBLOB(
                        dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        lpszStructType,
                        &(pInfo->IntendedKeyUsage),
                        NULL,
	                    &cbNeeded))
             goto FormatKeyUsageBLOBError;

        pwszKeyUsage=(LPWSTR)malloc(cbNeeded);
        if(NULL==pwszKeyUsage)
               goto MemoryError;

       if(!FormatKeyUsageBLOB(
                        dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        lpszStructType,
                        &(pInfo->IntendedKeyUsage),
                        pwszKeyUsage,
	                    &cbNeeded))
              goto FormatKeyUsageBLOBError;


        //format the element string

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_KEY_ATTR_USAGE_MULTI;
        else
            ids=IDS_KEY_ATTR_USAGE;

        if(!FormatMessageUnicode(&pwszKeyUsageFormat, ids, pwszKeyUsage))
            goto FormatMsgError;

        #if (0) // DSIE: Bug 27436
        pwsz=(LPWSTR)realloc(pwsz, 
            sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszKeyUsageFormat)+1));
        if(NULL==pwsz)
            goto MemoryError;
        #endif

        pwszTemp=(LPWSTR)realloc(pwsz, 
            sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszKeyUsageFormat)+1));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwsz = pwszTemp;

        wcscat(pwsz, pwszKeyUsageFormat);

    }

    if(NULL!=pInfo->pPrivateKeyUsagePeriod)
    {
        //format only if there is some information
        if(!((0==pInfo->pPrivateKeyUsagePeriod->NotBefore.dwHighDateTime)
           &&(0==pInfo->pPrivateKeyUsagePeriod->NotBefore.dwLowDateTime)))
        {
            //strcat a ", " symbol for signle line format
            if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
            {
                if(0!=wcslen(pwsz))
                    wcscat(pwsz, wszCOMMA);
            }


            if(!FormatFileTime(&(pInfo->pPrivateKeyUsagePeriod->NotBefore),
                            &pwszKeyBefore))
                goto FormatFileTimeError;


            //format the element string

            //decide between single line and mulitple line format
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_KEY_ATTR_BEFORE_MULTI;
            else
                ids=IDS_KEY_ATTR_BEFORE;

            if(!FormatMessageUnicode(&pwszKeyBeforeFormat, ids,
                    pwszKeyBefore))
                goto FormatMsgError;

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR)*(wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszKeyBeforeFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR)*(wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszKeyBeforeFormat)+1));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz, pwszKeyBeforeFormat);
        }

        if(!((0==pInfo->pPrivateKeyUsagePeriod->NotAfter.dwHighDateTime)
           &&(0==pInfo->pPrivateKeyUsagePeriod->NotAfter.dwLowDateTime)))
        {

            //strcat a ", " symbol for signle line format
            if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
            {
                if(0!=wcslen(pwsz))
                    wcscat(pwsz, wszCOMMA);
            }


            if(!FormatFileTime(&(pInfo->pPrivateKeyUsagePeriod->NotAfter),
                            &pwszKeyAfter))
                goto FormatFileTimeError;

            //format the element string

           //decide between single line and mulitple line format
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_KEY_ATTR_AFTER_MULTI;
            else
                ids=IDS_KEY_ATTR_AFTER;

            if(!FormatMessageUnicode(&pwszKeyAfterFormat, ids,
                    pwszKeyAfter))
                goto FormatMsgError;

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszKeyAfterFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszKeyAfterFormat)+1));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz, pwszKeyAfterFormat);

        }

    }

    if(0==wcslen(pwsz))
    {
       pwszFormat=(LPWSTR)malloc(sizeof(WCHAR)*(NO_INFO_SIZE+1));
       if(NULL==pwszFormat)
           goto MemoryError;

       if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, pwszFormat,NO_INFO_SIZE))
           goto LoadStringError;

    }
    else
    {
        pwszFormat=pwsz;
        pwsz=NULL;

    }

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:

    if(pwszKeyIDFormat)
        LocalFree((HLOCAL)pwszKeyIDFormat);

    if(pwszKeyID)
        free(pwszKeyID);

    if(pwszKeyUsageFormat)
        LocalFree((HLOCAL)pwszKeyUsageFormat);

    if(pwszKeyUsage)
        free(pwszKeyUsage);

    if(pwszKeyBeforeFormat)
        LocalFree((HLOCAL)pwszKeyBeforeFormat);

    if(pwszKeyBefore)
        LocalFree((HLOCAL)pwszKeyBefore);

    if(pwszKeyAfterFormat)
        LocalFree((HLOCAL)pwszKeyAfterFormat);

    if(pwszKeyAfter)
        LocalFree((HLOCAL)pwszKeyAfter);

	if(pwszFormat)
		free(pwszFormat);

    if(pwsz)
        free(pwsz);

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatKeyUsageBLOBError);
TRACE_ERROR(FormatFileTimeError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatBytesToHexError);
TRACE_ERROR(FormatMsgError);
}

//--------------------------------------------------------------------------
//
//	 FormatAuthortiyInfoAccess:   X509_AUTHORITY_INFO_ACCESS
//                                szOID_AUTHORITY_INFO_ACCESS
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatAuthortiyInfoAccess(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
    BOOL                            fMethodAllocated=FALSE;
    WCHAR                           wszNoInfo[NO_INFO_SIZE];
    WCHAR                           wszUnknownAccess[UNKNOWN_ACCESS_METHOD_SIZE];
    PCCRYPT_OID_INFO                pOIDInfo=NULL;
    CERT_ALT_NAME_INFO              CertAltNameInfo;


	LPWSTR							pwszFormat=NULL;
    LPWSTR                          pwsz=NULL;
    LPWSTR                          pwszMethod=NULL;
    LPWSTR                          pwszAltName=NULL;
    LPWSTR                          pwszEntryFormat=NULL;
	PCERT_AUTHORITY_INFO_ACCESS	    pInfo=NULL;

    DWORD                           dwIndex=0;
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
    UINT                            ids=0;

    LPWSTR                          pwszTemp;
    
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_AUTHORITY_INFO_ACCESS,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;


    if(0==pInfo->cAccDescr)
    {
        //load the string "Info Not Available"
	    if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, wszNoInfo, sizeof(wszNoInfo)/sizeof(wszNoInfo[0])))
		    goto LoadStringError;

        pwszFormat=wszNoInfo;
    }
    else
    {
        pwsz=(LPWSTR)malloc(sizeof(WCHAR));
        if(NULL==pwsz)
            goto MemoryError;

        *pwsz=L'\0';

        //load the string "Unknown Access Method:
	    if(!LoadStringU(hFrmtFuncInst,IDS_UNKNOWN_ACCESS_METHOD, wszUnknownAccess,
            sizeof(wszUnknownAccess)/sizeof(wszUnknownAccess[0])))
		    goto LoadStringError;

        for(dwIndex=0; dwIndex < pInfo->cAccDescr; dwIndex++)
        {
            fMethodAllocated=FALSE;

            //need a ", " between each element for single line format
            if(0!=wcslen(pwsz))
            {
                if(0==(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE) )
                    wcscat(pwsz, wszCOMMA);
            }

            //get the name of the access method
            if(pInfo->rgAccDescr[dwIndex].pszAccessMethod)
            {

                pOIDInfo=CryptFindOIDInfo(CRYPT_OID_INFO_OID_KEY,
									 (void *)(pInfo->rgAccDescr[dwIndex].pszAccessMethod),
									  CRYPT_EXT_OR_ATTR_OID_GROUP_ID);

                //get the access method OID
                if(pOIDInfo)
			    {
				    //allocate memory, including the NULL terminator
				    pwszMethod=(LPWSTR)malloc((wcslen(pOIDInfo->pwszName)+1)*
				    					sizeof(WCHAR));
				    if(NULL==pwszMethod)
					    goto MemoryError;

                    fMethodAllocated=TRUE;

				    wcscpy(pwszMethod,pOIDInfo->pwszName);

			    }else
                    pwszMethod=wszUnknownAccess;
            }

            memset(&CertAltNameInfo, 0, sizeof(CERT_ALT_NAME_INFO));
            CertAltNameInfo.cAltEntry=1;
            CertAltNameInfo.rgAltEntry=&(pInfo->rgAccDescr[dwIndex].AccessLocation);

            //need to tell if it is for multi line format.  We need two \t\t
            //in front of each alt name entry
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_TWO_TABS;
            else
                ids=0;

            //get the alternative name entry
            cbNeeded=0;
            if(!FormatAltNameInfo(dwCertEncodingType,
                                 dwFormatType,
                                 dwFormatStrType,
                                 pFormatStruct,
                                 ids,
                                 FALSE,
                                 &CertAltNameInfo,
                                 NULL,
                                 &cbNeeded))
                goto FormatAltNameError;

           pwszAltName=(LPWSTR)malloc(cbNeeded);
           if(NULL==pwszAltName)
               goto MemoryError;

            if(!FormatAltNameInfo(dwCertEncodingType,
                                 dwFormatType,
                                 dwFormatStrType,
                                 pFormatStruct,
                                 ids,
                                 FALSE,
                                 &CertAltNameInfo,
                                 pwszAltName,
                                 &cbNeeded))
                goto FormatAltNameError;

            //format the entry
            if(pInfo->rgAccDescr[dwIndex].pszAccessMethod)
            {

                //decide between single line and mulitple line format
                if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                    ids=IDS_AUTHORITY_ACCESS_INFO_MULTI;
                else
                    ids=IDS_AUTHORITY_ACCESS_INFO;


                if(!FormatMessageUnicode(&pwszEntryFormat, ids,
                    dwIndex+1, pwszMethod, pInfo->rgAccDescr[dwIndex].pszAccessMethod,
                    pwszAltName))
                    goto FormatMsgError;
            }
            else
            {
                //decide between single line and mulitple line format
                if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                    ids=IDS_AUTHORITY_ACCESS_NO_METHOD_MULTI;
                else
                    ids=IDS_AUTHORITY_ACCESS_NO_METHOD;


                if(!FormatMessageUnicode(&pwszEntryFormat, ids, dwIndex+1, pwszAltName))
                    goto FormatMsgError;

            }

            //reallocat the memory.  Leave space for szComma
            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(pwszEntryFormat)+
                                        wcslen(wszCOMMA)+1));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(pwszEntryFormat)+
                                        wcslen(wszCOMMA)+1));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz, pwszEntryFormat);

            //free memory
            LocalFree((HLOCAL)pwszEntryFormat);
            pwszEntryFormat=NULL;

            free(pwszAltName);
            pwszAltName=NULL;

            if(TRUE==fMethodAllocated)
                free(pwszMethod);

            pwszMethod=NULL;

        }

        //convert to WCHAR
        pwszFormat=pwsz;
    }


	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:

    if(pwsz)
        free(pwsz);

    if(pwszEntryFormat)
         LocalFree((HLOCAL)pwszEntryFormat);

    if(pwszAltName)
        free(pwszAltName);

    if(fMethodAllocated)
    {
        if(pwszMethod)
             free(pwszMethod);
    }

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);
TRACE_ERROR(FormatAltNameError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);

}

//--------------------------------------------------------------------------
//
//	 FormatKeyUsageBLOB
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatKeyUsageBLOB(
	DWORD		    dwCertEncodingType,
	DWORD		    dwFormatType,
	DWORD		    dwFormatStrType,
	void		    *pFormatStruct,
	LPCSTR		    lpszStructType,
    PCRYPT_BIT_BLOB	pInfo,
	void	        *pbFormat,
	DWORD	        *pcbFormat)
{
	LPWSTR							pwszFinal=NULL;
   	LPWSTR							pwszFormat=NULL;
    LPWSTR                          pwsz=NULL;
    LPWSTR                          pwszByte=NULL;

    WCHAR                           wszKeyUsage[KEY_USAGE_SIZE+1];
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;

    LPWSTR                          pwszTemp;

        pwsz=(LPWSTR)malloc(sizeof(WCHAR));
        if(NULL==pwsz)
            goto MemoryError;

        *pwsz=L'\0';

        //format the 1st byte
        if(pInfo->pbData[0] & CERT_DIGITAL_SIGNATURE_KEY_USAGE)
        {
            if(!LoadStringU(hFrmtFuncInst, IDS_DIG_SIG, wszKeyUsage, KEY_USAGE_SIZE))
		        goto LoadStringError;

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz, wszKeyUsage);
            wcscat(pwsz, wszCOMMA);
        }

        if(pInfo->pbData[0] & CERT_NON_REPUDIATION_KEY_USAGE)
        {
            if(!LoadStringU(hFrmtFuncInst, IDS_NON_REPUDIATION, wszKeyUsage, KEY_USAGE_SIZE))
		        goto LoadStringError;

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz, wszKeyUsage);
            wcscat(pwsz, wszCOMMA);
        }

        if(pInfo->pbData[0] & CERT_KEY_ENCIPHERMENT_KEY_USAGE )
        {
            if(!LoadStringU(hFrmtFuncInst, IDS_KEY_ENCIPHERMENT, wszKeyUsage, KEY_USAGE_SIZE))
		        goto LoadStringError;

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz, wszKeyUsage);
            wcscat(pwsz, wszCOMMA);
       }


        if(pInfo->pbData[0] & CERT_DATA_ENCIPHERMENT_KEY_USAGE )
        {
            if(!LoadStringU(hFrmtFuncInst, IDS_DATA_ENCIPHERMENT, wszKeyUsage, KEY_USAGE_SIZE))
		        goto LoadStringError;

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz, wszKeyUsage);
            wcscat(pwsz, wszCOMMA);
        }

        if(pInfo->pbData[0] & CERT_KEY_AGREEMENT_KEY_USAGE )
        {
            if(!LoadStringU(hFrmtFuncInst, IDS_KEY_AGREEMENT, wszKeyUsage, KEY_USAGE_SIZE))
		        goto LoadStringError;

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz, wszKeyUsage);
            wcscat(pwsz, wszCOMMA);
        }

        if(pInfo->pbData[0] & CERT_KEY_CERT_SIGN_KEY_USAGE )
        {
            if(!LoadStringU(hFrmtFuncInst, IDS_CERT_SIGN, wszKeyUsage, KEY_USAGE_SIZE))
		        goto LoadStringError;

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz, wszKeyUsage);
            wcscat(pwsz, wszCOMMA);
       }

         if(pInfo->pbData[0] & CERT_OFFLINE_CRL_SIGN_KEY_USAGE )
        {
            if(!LoadStringU(hFrmtFuncInst, IDS_OFFLINE_CRL_SIGN, wszKeyUsage, KEY_USAGE_SIZE))
		        goto LoadStringError;

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz, wszKeyUsage);
            wcscat(pwsz, wszCOMMA);
        }

        if(pInfo->pbData[0] & CERT_CRL_SIGN_KEY_USAGE )
        {
            if(!LoadStringU(hFrmtFuncInst, IDS_CRL_SIGN, wszKeyUsage, KEY_USAGE_SIZE))
		        goto LoadStringError;

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz, wszKeyUsage);
            wcscat(pwsz, wszCOMMA);
       }

        if(pInfo->pbData[0] & CERT_ENCIPHER_ONLY_KEY_USAGE  )
        {
            if(!LoadStringU(hFrmtFuncInst, IDS_ENCIPHER_ONLY, wszKeyUsage, KEY_USAGE_SIZE))
		        goto LoadStringError;

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz, wszKeyUsage);
            wcscat(pwsz, wszCOMMA);
        }

        //deal with the second byte
        if(pInfo->cbData>=2)
        {

            if(pInfo->pbData[1] & CERT_DECIPHER_ONLY_KEY_USAGE  )
            {
                if(!LoadStringU(hFrmtFuncInst, IDS_DECIPHER_ONLY, wszKeyUsage, KEY_USAGE_SIZE))
		            goto LoadStringError;

                #if (0) // DSIE: Bug 27436
                pwsz=(LPWSTR)realloc(pwsz, 
                    sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
                if(NULL==pwsz)
                    goto MemoryError;
                #endif

                pwszTemp=(LPWSTR)realloc(pwsz, 
                    sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
                if(NULL==pwszTemp)
                    goto MemoryError;
                pwsz = pwszTemp;

                wcscat(pwsz, wszKeyUsage);
                wcscat(pwsz, wszCOMMA);
            }
        }

        if(0==wcslen(pwsz))
        {
            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, sizeof(WCHAR) * (UNKNOWN_KEY_USAGE_SIZE+1));
		    // if(NULL==pwszFormat) DSIE: Bug 27348
		    if(NULL==pwsz)
				goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, sizeof(WCHAR) * (UNKNOWN_KEY_USAGE_SIZE+1));
		    if(NULL==pwszTemp)
				goto MemoryError;
            pwsz = pwszTemp;

            if(!LoadStringU(hFrmtFuncInst, IDS_UNKNOWN_KEY_USAGE, pwsz,
                UNKNOWN_KEY_USAGE_SIZE))
		            goto LoadStringError;
        }
        else
        {
            //get rid of the last comma
            *(pwsz+wcslen(pwsz)-wcslen(wszCOMMA))=L'\0';
        }

        //get the Hex dump of the Key Usage
       cbNeeded=0;

       if(!FormatBytesToHex(
                        dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        lpszStructType,
                        pInfo->pbData,
                        pInfo->cbData,
                        NULL,
	                    &cbNeeded))
            goto FormatBytesToHexError;

        pwszByte=(LPWSTR)malloc(cbNeeded);
        if(NULL==pwszByte)
            goto MemoryError;

        if(!FormatBytesToHex(
                        dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        lpszStructType,
                        pInfo->pbData,
                        pInfo->cbData,
                        pwszByte,
	                    &cbNeeded))
            goto FormatBytesToHexError;


    //convert the WSZ
    if(!FormatMessageUnicode(&pwszFormat, IDS_BIT_BLOB, pwsz,
        pwszByte))
        goto FormatMsgError;

	//
	// DSIE: Fix bug 91502, 256396.
	//
    pwszFinal=(LPWSTR)malloc(sizeof(WCHAR) * (wcslen(pwszFormat)+1+wcslen(wszCRLF)));
    if(NULL==pwszFinal)
        goto MemoryError;
	wcscpy(pwszFinal, pwszFormat);
    if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
        wcscat(pwszFinal, wszCRLF);

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFinal)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}

	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFinal, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;

CommonReturn:

	if (pwszFinal)
		free(pwszFinal);

    if(pwszFormat)
        LocalFree((HLOCAL)pwszFormat);

    if(pwsz)
        free(pwsz);

    if(pwszByte)
        free(pwszByte);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatBytesToHexError);
TRACE_ERROR(FormatMsgError);

}
//--------------------------------------------------------------------------
//
//	 FormatKeyUsage:  X509_KEY_USAGE
//                    szOID_KEY_USAGE
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatKeyUsage(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	LPWSTR							pwszFormat=NULL;
    WCHAR                           wszNoInfo[NO_INFO_SIZE];
	PCRYPT_BIT_BLOB	                pInfo=NULL;
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;

	
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_KEY_USAGE,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

   //load the string "Info Not Available"
	if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, wszNoInfo, sizeof(wszNoInfo)/sizeof(wszNoInfo[0])))
		 goto LoadStringError;

    //check the no data situation
    if(0==pInfo->cbData)
        pwszFormat=wszNoInfo;
    else
    {
        if(1==pInfo->cbData)
        {
           if(0==pInfo->pbData[0])
                pwszFormat=wszNoInfo;
        }
        else
        {
            if(2==pInfo->cbData)
            {
                if((0==pInfo->pbData[0])&&(0==pInfo->pbData[1]))
                    pwszFormat=wszNoInfo;
            }
        }
    }

    if(NULL==pwszFormat)
    {
        fResult=FormatKeyUsageBLOB(dwCertEncodingType,
                                   dwFormatType,
                                   dwFormatStrType,
                                   pFormatStruct,
                                   lpszStructType,
                                   pInfo,
                                   pbFormat,
                                   pcbFormat);

        if(FALSE==fResult)
            goto FormatKeyUsageBLOBError;
    }
    else
    {
       	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	    //length only calculation
	    if(NULL==pbFormat)
	    {
		    *pcbFormat=cbNeeded;
		    fResult=TRUE;
		    goto CommonReturn;
    	}


	    if((*pcbFormat)<cbNeeded)
        {
            *pcbFormat=cbNeeded;
		    goto MoreDataError;
        }

	    //copy the data
	    memcpy(pbFormat, pwszFormat, cbNeeded);

	    //copy the size
	    *pcbFormat=cbNeeded;

	    fResult=TRUE;
    }


CommonReturn:
   	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatKeyUsageBLOBError);
}


//--------------------------------------------------------------------------
//
//	 FormatSMIMECapabilities:   PKCS_SMIME_CAPABILITIES
//                              szOID_RSA_SMIMECapabilities
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatSMIMECapabilities(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	LPWSTR							pwszFormat=NULL;
    LPWSTR                          pwsz=NULL;
    LPWSTR                          pwszElementFormat=NULL;
    LPWSTR                          pwszParam=NULL;


	WCHAR							wszNoInfo[NO_INFO_SIZE];
    BOOL                            fParamAllocated=FALSE;
	PCRYPT_SMIME_CAPABILITIES	    pInfo=NULL;
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
    DWORD                           dwIndex =0;
    UINT                            idsSub=0;

	LPWSTR                          pwszTemp;

	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,PKCS_SMIME_CAPABILITIES,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

	//check to see if information if available
    if(0==pInfo->cCapability)
    {
         //load the string "Info Not Available"
	    if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, wszNoInfo, sizeof(wszNoInfo)/sizeof(wszNoInfo[0])))
		    goto LoadStringError;

        pwszFormat=wszNoInfo;
    }
    else
    {
        pwsz=(LPWSTR)malloc(sizeof(WCHAR));
        if(NULL==pwsz)
            goto MemoryError;

        *pwsz=L'\0';

        for(dwIndex=0; dwIndex < pInfo->cCapability; dwIndex++)
        {
            fParamAllocated=FALSE;

           //strcat ", " if single line.  No need for multi-line
            if(0!=wcslen(pwsz))
            {
                if(0==(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                 wcscat(pwsz, wszCOMMA);
            }


            if(0!=(pInfo->rgCapability)[dwIndex].Parameters.cbData)
            {
                cbNeeded=0;

                if(!FormatBytesToHex(
                        dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        lpszStructType,
                        (pInfo->rgCapability)[dwIndex].Parameters.pbData,
                        (pInfo->rgCapability)[dwIndex].Parameters.cbData,
                        NULL,
	                    &cbNeeded))
                        goto FormatBytesToHexError;

                pwszParam=(LPWSTR)malloc(cbNeeded);
                if(NULL==pwszParam)
                    goto MemoryError;

                fParamAllocated=TRUE;

                if(!FormatBytesToHex(
                        dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        lpszStructType,
                        (pInfo->rgCapability)[dwIndex].Parameters.pbData,
                        (pInfo->rgCapability)[dwIndex].Parameters.cbData,
                        pwszParam,
	                    &cbNeeded))
                        goto FormatBytesToHexError;

                //decide between single line and mulitple line format
                if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                    idsSub=IDS_MIME_CAPABILITY_MULTI;
                else
                    idsSub=IDS_MIME_CAPABILITY;

                 //format the element string
                if(!FormatMessageUnicode(&pwszElementFormat, idsSub,
                        dwIndex+1,
                        (pInfo->rgCapability)[dwIndex].pszObjId,
                        pwszParam))
                    goto FormatMsgError;
            }
            else
            {
                //decide between single line and mulitple line format
                if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                    idsSub=IDS_MIME_CAPABILITY_NO_PARAM_MULTI;
                else
                    idsSub=IDS_MIME_CAPABILITY_NO_PARAM;

                 //format the element string
                if(!FormatMessageUnicode(&pwszElementFormat, idsSub,
                        dwIndex+1,
                        (pInfo->rgCapability)[dwIndex].pszObjId))
                    goto FormatMsgError;
            }

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszElementFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszElementFormat)+1));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            //strcat the element
            wcscat(pwsz, pwszElementFormat);

            //free the memory
            LocalFree((HLOCAL)pwszElementFormat);
            pwszElementFormat=NULL;

            if(fParamAllocated)
                free(pwszParam);

            pwszParam=NULL;

        }

        pwszFormat=pwsz;

    }


	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:

    if(pwszElementFormat)
        LocalFree((HLOCAL)pwszElementFormat);

    if(fParamAllocated)
    {
        if(pwszParam)
            free(pwszParam);
    }


	if(pInfo)
		free(pInfo);

    if(pwsz)
        free(pwsz);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatBytesToHexError);
}

//--------------------------------------------------------------------------
//
//	 FormatFinancialCriteria: SPC_FINANCIAL_CRITERIA_OBJID
//                            SPC_FINANCIAL_CRITERIA_STRUCT
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatFinancialCriteria(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	LPWSTR							pwszFormat=NULL;
	WCHAR							wszYesNo[YES_NO_SIZE];
	WCHAR							wszAvailable[AVAIL_SIZE];
	PSPC_FINANCIAL_CRITERIA     	pInfo=NULL;
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
    UINT                            idsInfo=0;


	
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,SPC_FINANCIAL_CRITERIA_STRUCT,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

	//load the string for financial info
    if(TRUE==pInfo->fFinancialInfoAvailable)
    {
        if(TRUE==pInfo->fMeetsCriteria)
            idsInfo=IDS_YES;
        else
            idsInfo=IDS_NO;

        //load the string for "yes" or "no"
        if(!LoadStringU(hFrmtFuncInst,idsInfo, wszYesNo, sizeof(wszYesNo)/sizeof(wszYesNo[0])))
		        goto LoadStringError;

        //mark the avaiblility of the financial info
        idsInfo=IDS_AVAILABLE;
    }
    else
        idsInfo=IDS_NOT_AVAILABLE;

	if(!LoadStringU(hFrmtFuncInst,idsInfo, wszAvailable,
        sizeof(wszAvailable)/sizeof(wszAvailable[0])))
		goto LoadStringError;

    //format the output string
    if(TRUE==pInfo->fFinancialInfoAvailable)
    {
        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            idsInfo=IDS_SPC_FINANCIAL_AVAIL_MULTI;
        else
            idsInfo=IDS_SPC_FINANCIAL_AVAIL;

        if(!FormatMessageUnicode(&pwszFormat, idsInfo,
            wszAvailable, wszYesNo))
            goto FormatMsgError;
    }
    else
    {
        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            idsInfo=IDS_SPC_FINANCIAL_NOT_AVAIL_MULTI;
        else
            idsInfo=IDS_SPC_FINANCIAL_NOT_AVAIL;

        if(!FormatMessageUnicode(&pwszFormat, idsInfo,
            wszAvailable))
            goto FormatMsgError;
    }

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:
	if(pwszFormat)
		LocalFree((HLOCAL)pwszFormat);

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);

}

//--------------------------------------------------------------------------
//
//	 FormatNextUpdateLocation: szOID_NEXT_UPDATE_LOCATION
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatNextUpdateLocation(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	PCERT_ALT_NAME_INFO	            pInfo=NULL;
	BOOL							fResult=FALSE;

	//check for input parameters
	if((NULL==pbEncoded && cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,szOID_NEXT_UPDATE_LOCATION,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

	//format the alternative name
    fResult=FormatAltNameInfo(dwCertEncodingType, dwFormatType,dwFormatStrType,
                            pFormatStruct,
                            0,      //no prefix
                            TRUE,
                            pInfo, pbFormat, pcbFormat);

    if(FALSE==fResult)
        goto FormatAltNameError;

CommonReturn:

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(FormatAltNameError);

}

//--------------------------------------------------------------------------
//
//	 FormatSubjectKeyID: szOID_SUBJECT_KEY_IDENTIFIER
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatSubjectKeyID(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	PCRYPT_DATA_BLOB	            pInfo=NULL;
	BOOL							fResult=FALSE;
    WCHAR                           wszNoInfo[NO_INFO_SIZE];
    DWORD                           cbNeeded=0;

	// DSIE: Fix bug 91502
	LPWSTR							pwsz=NULL;
	LPWSTR							pwszFormat=NULL;
  
	LPWSTR                          pwszKeyID=NULL;
    LPWSTR                          pwszKeyIDFormat=NULL;

	LPWSTR							pwszTemp;

	//check for input parameters
	if((NULL==pbEncoded && cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,szOID_SUBJECT_KEY_IDENTIFIER,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

	//format the key subject ID
    //handle NULL data case
    if(0==pInfo->cbData)
    {
         //load the string "Info Not Available"
	    if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, wszNoInfo, sizeof(wszNoInfo)/sizeof(wszNoInfo[0])))
		    goto LoadStringError;

		pwszFormat = wszNoInfo;
    }
    else
    {
        pwsz=(LPWSTR)malloc(sizeof(WCHAR));
        if(NULL==pwsz)
            goto MemoryError;
        *pwsz=L'\0';

        cbNeeded=0;

        if(!FormatBytesToHex(dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        NULL,
                        NULL,
                        pInfo->pbData,
                        pInfo->cbData,
                        NULL,
                        &cbNeeded))
            goto KeyIDBytesToHexError;

        pwszKeyID=(LPWSTR)malloc(cbNeeded);
        if(NULL==pwszKeyID)
            goto MemoryError;

        if(!FormatBytesToHex(dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        NULL,
                        NULL,
                        pInfo->pbData,
                        pInfo->cbData,
                        pwszKeyID,
                        &cbNeeded))
            goto KeyIDBytesToHexError;

        if(!FormatMessageUnicode(&pwszKeyIDFormat,IDS_UNICODE_STRING,pwszKeyID))
            goto FormatMsgError;

        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
	        pwszTemp=(LPWSTR)realloc(pwsz, 
		        sizeof(WCHAR) * (wcslen(pwsz)+wcslen(pwszKeyIDFormat)+wcslen(wszCRLF)+1));
		else
	        pwszTemp=(LPWSTR)realloc(pwsz, 
		        sizeof(WCHAR) * (wcslen(pwsz)+wcslen(pwszKeyIDFormat)+1));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwsz = pwszTemp;

        //strcat the KeyID
        wcscat(pwsz,pwszKeyIDFormat);

        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            wcscat(pwsz, wszCRLF);

        pwszFormat=pwsz;
	}

    cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
	    *pcbFormat=cbNeeded;
	    fResult=TRUE;
	    goto CommonReturn;
	}

	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
	    goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;

CommonReturn:

    if(pwszKeyID)
       free(pwszKeyID);

    if(pwszKeyIDFormat)
        LocalFree((HLOCAL)pwszKeyIDFormat);

    if(pwsz)
        free(pwsz);

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(FormatMsgError);
TRACE_ERROR(KeyIDBytesToHexError);
//TRACE_ERROR(FormatBytestToHexError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
}

//--------------------------------------------------------------------------
//
//	 FormatAuthorityKeyID: szOID_AUTHORITY_KEY_IDENTIFIER
//                         X509_AUTHORITY_KEY_ID
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatAuthorityKeyID(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	LPWSTR							pwszFormat=NULL;
    LPWSTR                          pwsz=NULL;

    LPWSTR                          pwszKeyID=NULL;
    LPWSTR                          pwszKeyIDFormat=NULL;
    LPWSTR                          pwszCertIssuer=NULL;
    LPWSTR                          pwszCertIssuerFormat=NULL;
    LPWSTR                          pwszCertNumber=NULL;
    LPWSTR                          pwszCertNumberFormat=NULL;
    BYTE                            *pByte=NULL;

    DWORD                           dwByteIndex=0;
    WCHAR                           wszNoInfo[NO_INFO_SIZE];
	PCERT_AUTHORITY_KEY_ID_INFO	    pInfo=NULL;
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
    UINT                            ids=0;

	LPWSTR                          pwszTemp;

	//check for input parameters
	if((NULL==pbEncoded && cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_AUTHORITY_KEY_ID,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

    //load the string "Info Not Available"
    if((0==pInfo->KeyId.cbData)&&(0==pInfo->CertIssuer.cbData)
        &&(0==pInfo->CertSerialNumber.cbData))
    {
	    if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, wszNoInfo, sizeof(wszNoInfo)/sizeof(wszNoInfo[0])))
		    goto LoadStringError;

        pwszFormat=wszNoInfo;
    }
    else
    {
        pwsz=(LPWSTR)malloc(sizeof(WCHAR));
        if(NULL==pwsz)
            goto MemoryError;
        *pwsz=L'\0';

        //format the three fields in the struct: KeyID; CertIssuer; CertSerialNumber
        if(0!=pInfo->KeyId.cbData)
        {
            cbNeeded=0;

            if(!FormatBytesToHex(dwCertEncodingType,
                            dwFormatType,
                            dwFormatStrType,
                            NULL,
                            NULL,
                            pInfo->KeyId.pbData,
                            pInfo->KeyId.cbData,
                            NULL,
                            &cbNeeded))
                goto KeyIDBytesToHexError;

            pwszKeyID=(LPWSTR)malloc(cbNeeded);
            if(NULL==pwszKeyID)
                goto MemoryError;

            if(!FormatBytesToHex(dwCertEncodingType,
                            dwFormatType,
                            dwFormatStrType,
                            NULL,
                            NULL,
                            pInfo->KeyId.pbData,
                            pInfo->KeyId.cbData,
                            pwszKeyID,
                            &cbNeeded))
                goto KeyIDBytesToHexError;

            if(!FormatMessageUnicode(&pwszKeyIDFormat, IDS_AUTH_KEY_ID,pwszKeyID))
                goto FormatMsgError;

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszKeyIDFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

#if (0) //DSIE: Potential AV. Need two more chars, \r\n, for multi-lines.
            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszKeyIDFormat)+1));
#else
			if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
				pwszTemp=(LPWSTR)realloc(pwsz, 
					sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszKeyIDFormat)+wcslen(wszCRLF)+1));
			else
				pwszTemp=(LPWSTR)realloc(pwsz, 
					sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszKeyIDFormat)+1));
#endif
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            //strcat the KeyID
            wcscat(pwsz,pwszKeyIDFormat);

            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                wcscat(pwsz, wszCRLF);
        }

        //format certIssuer
        if(0!=pInfo->CertIssuer.cbData)
        {
            //strcat ", " if there is data before
            if(0!=wcslen(pwsz))
            {
                if(0==(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                    wcscat(pwsz, wszCOMMA);
            }

            if(!CryptDllFormatNameAll(
				dwCertEncodingType,	
				dwFormatType,
				dwFormatStrType,
				pFormatStruct,
                IDS_ONE_TAB,
                TRUE,             //memory allocation
				pInfo->CertIssuer.pbData,
				pInfo->CertIssuer.cbData,
				(void **)&pwszCertIssuer,
				NULL))
                goto GetCertNameError;

            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_AUTH_CERT_ISSUER_MULTI;
            else
                ids=IDS_AUTH_CERT_ISSUER;

            if(!FormatMessageUnicode(&pwszCertIssuerFormat, ids,pwszCertIssuer))
                goto FormatMsgError;

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszCertIssuerFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszCertIssuerFormat)+1));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz,pwszCertIssuerFormat);

            //no need for \n for CERT_NAME
        }

        //format CertSerialNumber
        if(0!=pInfo->CertSerialNumber.cbData)
        {

            //strcat ", " if there is data before
            if(0!=wcslen(pwsz))
            {
                if(0==(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                    wcscat(pwsz, wszCOMMA);
            }

            //copy the serial number into the correct order
            pByte=(BYTE *)malloc(pInfo->CertSerialNumber.cbData);
            if(NULL==pByte)
                goto MemoryError;

            for(dwByteIndex=0; dwByteIndex <pInfo->CertSerialNumber.cbData;
                dwByteIndex++)
            {

                pByte[dwByteIndex]=*(pInfo->CertSerialNumber.pbData+
                        pInfo->CertSerialNumber.cbData-1-dwByteIndex);
            }

            cbNeeded=0;

            if(!FormatBytesToHex(dwCertEncodingType,
                            dwFormatType,
                            dwFormatStrType,
                            NULL,
                            NULL,
                            pByte,
                            pInfo->CertSerialNumber.cbData,
                            NULL,
                            &cbNeeded))
                goto CertNumberBytesToHexError;

            pwszCertNumber=(LPWSTR)malloc(cbNeeded);
            if(NULL==pwszCertNumber)
                goto MemoryError;

            if(!FormatBytesToHex(dwCertEncodingType,
                            dwFormatType,
                            dwFormatStrType,
                            NULL,
                            NULL,
                            pByte,
                            pInfo->CertSerialNumber.cbData,
                            pwszCertNumber,
                            &cbNeeded))
             goto CertNumberBytesToHexError;


            if(!FormatMessageUnicode(&pwszCertNumberFormat, IDS_AUTH_CERT_NUMBER,pwszCertNumber))
                goto FormatMsgError;

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszCertNumberFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszCertNumberFormat)+1));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz,pwszCertNumberFormat);

            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                wcscat(pwsz, wszCRLF);

        }

        pwszFormat=pwsz;
    }


	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:
    if(pByte)
        free(pByte);

    if(pwszKeyID)
       free(pwszKeyID);

    if(pwszKeyIDFormat)
        LocalFree((HLOCAL)pwszKeyIDFormat);

    if(pwszCertIssuer)
       free(pwszCertIssuer);

    if(pwszCertIssuerFormat)
        LocalFree((HLOCAL)pwszCertIssuerFormat);

    if(pwszCertNumber)
       free(pwszCertNumber);


    if(pwszCertNumberFormat)
        LocalFree((HLOCAL)pwszCertNumberFormat);

    if(pwsz)
        free(pwsz);

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);
TRACE_ERROR(KeyIDBytesToHexError);
TRACE_ERROR(GetCertNameError);
TRACE_ERROR(CertNumberBytesToHexError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
}

//--------------------------------------------------------------------------
//
//	 FormatAuthorityKeyID2: szOID_AUTHORITY_KEY_IDENTIFIER2
//                          X509_AUTHORITY_KEY_ID2
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatAuthorityKeyID2(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
    LPWSTR							pwszFormat=NULL;
    LPWSTR                          pwsz=NULL;

    LPWSTR                          pwszKeyID=NULL;
    LPWSTR                          pwszKeyIDFormat=NULL;
    LPWSTR                          pwszCertIssuer=NULL;
    LPWSTR                          pwszCertIssuerFormat=NULL;
    LPWSTR                          pwszCertNumber=NULL;
    LPWSTR                          pwszCertNumberFormat=NULL;
    BYTE                            *pByte=NULL;

    DWORD                           dwByteIndex=0;
    WCHAR                           wszNoInfo[NO_INFO_SIZE];
	PCERT_AUTHORITY_KEY_ID2_INFO	pInfo=NULL;
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
    UINT                            ids=0;

	LPWSTR                          pwszTemp;

	//check for input parameters
	if((NULL==pbEncoded && cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_AUTHORITY_KEY_ID2,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

    //load the string "Info Not Available"
    if((0==pInfo->KeyId.cbData)&&(0==pInfo->AuthorityCertIssuer.cAltEntry)
        &&(0==pInfo->AuthorityCertSerialNumber.cbData))
    {
	    if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, wszNoInfo, sizeof(wszNoInfo)/sizeof(wszNoInfo[0])))
		    goto LoadStringError;

        pwszFormat=wszNoInfo;
    }
    else
    {
        pwsz=(LPWSTR)malloc(sizeof(WCHAR));
        if(NULL==pwsz)
            goto MemoryError;
        *pwsz=L'\0';

        //format the three fields in the struct: KeyID; CertIssuer; CertSerialNumber
        if(0!=pInfo->KeyId.cbData)
        {
            cbNeeded=0;

            if(!FormatBytesToHex(dwCertEncodingType,
                            dwFormatType,
                            dwFormatStrType,
                            NULL,
                            NULL,
                            pInfo->KeyId.pbData,
                            pInfo->KeyId.cbData,
                            NULL,
                            &cbNeeded))
                goto KeyIDBytesToHexError;

            pwszKeyID=(LPWSTR)malloc(cbNeeded);
            if(NULL==pwszKeyID)
                goto MemoryError;

            if(!FormatBytesToHex(dwCertEncodingType,
                            dwFormatType,
                            dwFormatStrType,
                            NULL,
                            NULL,
                            pInfo->KeyId.pbData,
                            pInfo->KeyId.cbData,
                            pwszKeyID,
                            &cbNeeded))
                goto KeyIDBytesToHexError;

            if(!FormatMessageUnicode(&pwszKeyIDFormat, IDS_AUTH_KEY_ID,pwszKeyID))
                goto FormatMsgError;

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+
                                wcslen(pwszKeyIDFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+
                                wcslen(pwszKeyIDFormat)+1));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz,pwszKeyIDFormat);

            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                wcscat(pwsz, wszCRLF);

        }

        //format certIssuer
        if(0!=pInfo->AuthorityCertIssuer.cAltEntry)
        {
            //strcat ", " if there is data before
            if(0!=wcslen(pwsz))
            {
                if(0==(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                    wcscat(pwsz, wszCOMMA);
            }


            cbNeeded=0;

            //need a \t before each entry of the alternative name
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_ONE_TAB;
            else
                ids=0;

            //format the alternative name
            if(!FormatAltNameInfo(dwCertEncodingType,
                            dwFormatType,
                            dwFormatStrType,
                            pFormatStruct,
                            ids,
                            FALSE,
                            &(pInfo->AuthorityCertIssuer),
                            NULL,
                            &cbNeeded))
                goto FormatAltNameError;

            pwszCertIssuer=(LPWSTR)malloc(cbNeeded);
            if(NULL==pwszCertIssuer)
                goto MemoryError;

            if(!FormatAltNameInfo(dwCertEncodingType,
                            dwFormatType,
                            dwFormatStrType,
                            pFormatStruct,
                            ids,
                            FALSE,
                            &(pInfo->AuthorityCertIssuer),
                            pwszCertIssuer,
                            &cbNeeded))
                goto FormatAltNameError;

            //format the element.  Has to distinguish between the multi line
            //and single line for alternative name:
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            {
                if(!FormatMessageUnicode(&pwszCertIssuerFormat, IDS_AUTH_CERT_ISSUER_MULTI,pwszCertIssuer))
                    goto FormatMsgError;
            }
            else
            {
                if(!FormatMessageUnicode(&pwszCertIssuerFormat, IDS_AUTH_CERT_ISSUER,pwszCertIssuer))
                    goto FormatMsgError;
            }

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)
                        +wcslen(pwszCertIssuerFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)
                        +wcslen(pwszCertIssuerFormat)+1));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz,pwszCertIssuerFormat);

            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                wcscat(pwsz, wszCRLF);
        }

        //format CertSerialNumber
        if(0!=pInfo->AuthorityCertSerialNumber.cbData)
        {
            //strcat ", " if there is data before
            if(0!=wcslen(pwsz))
            {
                if(0==(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                    wcscat(pwsz, wszCOMMA);
            }

            //copy the serial number into the correct order
            pByte=(BYTE *)malloc(pInfo->AuthorityCertSerialNumber.cbData);
            if(NULL==pByte)
                goto MemoryError;

            for(dwByteIndex=0; dwByteIndex <pInfo->AuthorityCertSerialNumber.cbData;
                dwByteIndex++)
            {

                pByte[dwByteIndex]=*(pInfo->AuthorityCertSerialNumber.pbData+
                        pInfo->AuthorityCertSerialNumber.cbData-1-dwByteIndex);
            }

            cbNeeded=0;

            if(!FormatBytesToHex(dwCertEncodingType,
                            dwFormatType,
                            dwFormatStrType,
                            NULL,
                            NULL,
                            pByte,
                            pInfo->AuthorityCertSerialNumber.cbData,
                            NULL,
                            &cbNeeded))
                goto CertNumberBytesToHexError;

            pwszCertNumber=(LPWSTR)malloc(cbNeeded);
            if(NULL==pwszCertNumber)
                goto MemoryError;

            if(!FormatBytesToHex(dwCertEncodingType,
                            dwFormatType,
                            dwFormatStrType,
                            NULL,
                            NULL,
                            pByte,
                            pInfo->AuthorityCertSerialNumber.cbData,
                            pwszCertNumber,
                            &cbNeeded))
                goto CertNumberBytesToHexError;

            if(!FormatMessageUnicode(&pwszCertNumberFormat, IDS_AUTH_CERT_NUMBER,pwszCertNumber))
                goto FormatMsgError;

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)
                    +wcslen(pwszCertNumberFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)
                    +wcslen(pwszCertNumberFormat)+1));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz,pwszCertNumberFormat);

            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                wcscat(pwsz, wszCRLF);
        }

        //convert the WCHAR version
        pwszFormat=pwsz;
    }

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}

	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;

CommonReturn:
    if(pByte)
        free(pByte);

    if(pwszKeyID)
       free(pwszKeyID);

    if(pwszKeyIDFormat)
        LocalFree((HLOCAL)pwszKeyIDFormat);

    if(pwszCertIssuer)
       free(pwszCertIssuer);

    if(pwszCertIssuerFormat)
        LocalFree((HLOCAL)pwszCertIssuerFormat);

    if(pwszCertNumber)
       free(pwszCertNumber);


    if(pwszCertNumberFormat)
        LocalFree((HLOCAL)pwszCertNumberFormat);

    if(pwsz)
        free(pwsz);

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);
TRACE_ERROR(KeyIDBytesToHexError);
TRACE_ERROR(FormatAltNameError);
TRACE_ERROR(CertNumberBytesToHexError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);

}

//--------------------------------------------------------------------------
//
//	 FormatBasicConstraints:   szOID_BASIC_CONSTRAINTS
//                             X509_BASIC_CONSTRAINTS
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatBasicConstraints(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	LPWSTR							pwszFormat=NULL;
	WCHAR							wszSubject[SUBJECT_SIZE * 2];
	WCHAR							wszNone[NONE_SIZE];
    LPWSTR                          pwszFormatSub=NULL;
    LPWSTR                          pwszFormatWhole=NULL;
    LPWSTR                          pwszSubtreeName=NULL;
    LPWSTR                          pwszSubtreeFormat=NULL;
    DWORD                           dwIndex=0;
	PCERT_BASIC_CONSTRAINTS_INFO	pInfo=NULL;
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
	UINT							idsSub=0;

	LPWSTR                          pwszTemp;

	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_BASIC_CONSTRAINTS,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;


	//load the string for the subjectType
    //init to "\0"
    *wszSubject=L'\0';

    if(0!=pInfo->SubjectType.cbData)
    {
        //get the subjectType info
        if ((pInfo->SubjectType.pbData[0]) & CERT_CA_SUBJECT_FLAG)
        {
       	    if(!LoadStringU(hFrmtFuncInst,IDS_SUB_CA, wszSubject, sizeof(wszSubject)/sizeof(wszSubject[0])))
		        goto LoadStringError;
        }

        if ((pInfo->SubjectType.pbData[0]) & CERT_END_ENTITY_SUBJECT_FLAG)
        {
            if(wcslen(wszSubject)!=0)
            {
                 wcscat(wszSubject, wszCOMMA);
            }

       	    if(!LoadStringU(hFrmtFuncInst,IDS_SUB_EE, wszSubject+wcslen(wszSubject),
                        SUBJECT_SIZE))
		          goto LoadStringError;
       }

        //load string "NONE"
        if(0==wcslen(wszSubject))
        {
            if(!LoadStringU(hFrmtFuncInst,IDS_NONE, wszSubject, sizeof(wszSubject)/sizeof(wszSubject[0])))
		    goto LoadStringError;
        }

    }

    //path contraints
    if (pInfo->fPathLenConstraint)
	{
        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            idsSub=IDS_BASIC_CONS2_PATH_MULTI;
        else
            idsSub=IDS_BASIC_CONS2_PATH;

        if(!FormatMessageUnicode(&pwszFormatSub,idsSub,
								wszSubject, pInfo->dwPathLenConstraint))
			goto FormatMsgError;
	}
    else
	{
		if(!LoadStringU(hFrmtFuncInst,IDS_NONE, wszNone, sizeof(wszNone)/sizeof(wszNone[0])))
			goto LoadStringError;

        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            idsSub=IDS_BASIC_CONS2_NONE_MULTI;
        else
            idsSub=IDS_BASIC_CONS2_NONE;

        if(!FormatMessageUnicode(&pwszFormatSub,idsSub,
								wszSubject, wszNone))
			goto FormatMsgError;
	}

    pwszFormatWhole=(LPWSTR)malloc(sizeof(WCHAR) * (wcslen(pwszFormatSub)+1));
    if(!pwszFormatWhole)
        goto MemoryError;

    wcscpy(pwszFormatWhole, pwszFormatSub);

    //now, format SubTreeContraints one at a time

   for(dwIndex=0; dwIndex<pInfo->cSubtreesConstraint; dwIndex++)
    {
        //get WCHAR version of the name
        if(!CryptDllFormatNameAll(
				dwCertEncodingType,	
				dwFormatType,
				dwFormatStrType,
				pFormatStruct,
                IDS_ONE_TAB,
                TRUE,                 //memory allocation
				pInfo->rgSubtreesConstraint[dwIndex].pbData,
				pInfo->rgSubtreesConstraint[dwIndex].cbData,
				(void **)&pwszSubtreeName,
				NULL))
                goto GetCertNameError;

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            idsSub=IDS_SUBTREE_CONSTRAINT_MULTI;
        else
            idsSub=IDS_SUBTREE_CONSTRAINT;

        if(!FormatMessageUnicode(&pwszSubtreeFormat,idsSub,
								dwIndex+1, pwszSubtreeName))
			goto FormatNameError;

        #if (0) // DSIE: Bug 27436
        pwszFormatWhole=(LPWSTR)realloc(pwszFormatWhole, 
            sizeof(WCHAR) * (wcslen(pwszFormatWhole)+1+wcslen(pwszSubtreeFormat)));
        if(NULL == pwszFormatWhole)
            goto MemoryError;
        #endif

        pwszTemp=(LPWSTR)realloc(pwszFormatWhole, 
            sizeof(WCHAR) * (wcslen(pwszFormatWhole)+1+wcslen(pwszSubtreeFormat)));
        if(NULL == pwszTemp)
            goto MemoryError;
        pwszFormatWhole = pwszTemp;

        wcscat(pwszFormatWhole,pwszSubtreeFormat);

        LocalFree((HLOCAL)pwszSubtreeFormat);
        pwszSubtreeFormat=NULL;

        free(pwszSubtreeName);
        pwszSubtreeName=NULL;

    }

    //format to the wide char version
    pwszFormat=pwszFormatWhole;

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:

    if(pwszFormatSub)
        LocalFree((HLOCAL)pwszFormatSub);

    if(pwszSubtreeFormat)
        LocalFree((HLOCAL)pwszSubtreeFormat);

    if(pwszFormatWhole)
        free(pwszFormatWhole);

    if(pwszSubtreeName)
        free(pwszSubtreeName);

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);
TRACE_ERROR(FormatNameError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(GetCertNameError);
}


//--------------------------------------------------------------------------
//
//	 FormatCRLReasonCode:szOID_CRL_REASON_CODE
//                         X509_CRL_REASON_CODE
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatCRLReasonCode(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	WCHAR							wszReason[CRL_REASON_SIZE];
    LPWSTR                          pwszFormat=NULL;
	int								*pInfo=NULL;
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
	UINT							idsCRLReason=0;

	
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_CRL_REASON_CODE,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

	//decide which ids to use
	switch(*pInfo)
	{
		case CRL_REASON_UNSPECIFIED:
				idsCRLReason=IDS_UNSPECIFIED;
			break;
		case CRL_REASON_KEY_COMPROMISE:
				idsCRLReason=IDS_KEY_COMPROMISE;
			break;
		case CRL_REASON_CA_COMPROMISE:
				idsCRLReason=IDS_CA_COMPROMISE;
			break;
		case CRL_REASON_AFFILIATION_CHANGED:
				idsCRLReason=IDS_AFFILIATION_CHANGED;
			break;
		case CRL_REASON_SUPERSEDED:
				idsCRLReason=IDS_SUPERSEDED;
			break;
		case CRL_REASON_CESSATION_OF_OPERATION:
				idsCRLReason=IDS_CESSATION_OF_OPERATION;
			break;
		case CRL_REASON_CERTIFICATE_HOLD:
				idsCRLReason=IDS_CERTIFICATE_HOLD;
			break;
		case CRL_REASON_REMOVE_FROM_CRL:
				idsCRLReason=IDS_REMOVE_FROM_CRL;
			break;
		default:
				idsCRLReason=IDS_UNKNOWN_CRL_REASON;
			break;
	}

	//load string
	if(!LoadStringU(hFrmtFuncInst,idsCRLReason, wszReason, sizeof(wszReason)/sizeof(wszReason[0])))
		goto LoadStringError;

    //format
    if(!FormatMessageUnicode(&pwszFormat, IDS_CRL_REASON, wszReason, *pInfo))
        goto FormatMsgError;

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:
    if(pwszFormat)
        LocalFree((HLOCAL)pwszFormat);

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);

}

//--------------------------------------------------------------------------
//
//	 FormatEnhancedKeyUsage: szOID_ENHANCED_KEY_USAGE
//							 X509_ENHANCED_KEY_USAGE
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatEnhancedKeyUsage(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
    BOOL                            fOIDNameAllocated=FALSE;
	WCHAR							wszNoInfo[NO_INFO_SIZE];
    WCHAR                           wszUnknownOID[UNKNOWN_KEY_USAGE_SIZE];
	PCCRYPT_OID_INFO                pOIDInfo=NULL;

    LPWSTR							pwszFormat=NULL;
    LPWSTR                          pwszOIDName=NULL;
	PCERT_ENHKEY_USAGE				pInfo=NULL;
	LPWSTR							pwsz=NULL;
    LPWSTR                          pwszOIDFormat=NULL;

	DWORD							dwIndex=0;
    DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;

    LPWSTR                          pwszTemp;
    
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_ENHANCED_KEY_USAGE,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

	//load string NONE if there is no value available
	if(0==pInfo->cUsageIdentifier)
	{
		if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, wszNoInfo, sizeof(wszNoInfo)/sizeof(wszNoInfo[0])))
			goto LoadStringError;

	    pwszFormat=wszNoInfo;
	}
	else
	{
        //load the string for "unknown key usage"
        if(!LoadStringU(hFrmtFuncInst,IDS_UNKNOWN_KEY_USAGE, wszUnknownOID,
            sizeof(wszUnknownOID)/sizeof(wszUnknownOID[0])))
			goto LoadStringError;

        pwsz=(LPWSTR)malloc(sizeof(WCHAR));
        if(NULL==pwsz)
            goto MemoryError;
        *pwsz=L'\0';

		//build the comma/\n seperated string
		for(dwIndex=0; dwIndex<pInfo->cUsageIdentifier; dwIndex++)
        {
            fOIDNameAllocated=FALSE;

           	pOIDInfo=CryptFindOIDInfo(CRYPT_OID_INFO_OID_KEY,
									 (void *)(pInfo->rgpszUsageIdentifier[dwIndex]),
									  CRYPT_ENHKEY_USAGE_OID_GROUP_ID);

            if(pOIDInfo)
			{
				//allocate memory, including the NULL terminator
				pwszOIDName=(LPWSTR)malloc((wcslen(pOIDInfo->pwszName)+1)*
									sizeof(WCHAR));
				if(NULL==pwszOIDName)
					goto MemoryError;

                fOIDNameAllocated=TRUE;

				wcscpy(pwszOIDName,pOIDInfo->pwszName);

			}else
                pwszOIDName=wszUnknownOID;

            if(!FormatMessageUnicode(&pwszOIDFormat, IDS_ENHANCED_KEY_USAGE, pwszOIDName,
                          (pInfo->rgpszUsageIdentifier)[dwIndex]))
                   goto FormatMsgError;

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+
                            wcslen(wszCOMMA)+wcslen(pwszOIDFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+
                            wcslen(wszCOMMA)+wcslen(pwszOIDFormat)+1));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            //strcat the OID
            wcscat(pwsz, pwszOIDFormat);

            //strcat the , or '\n'
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                wcscat(pwsz, wszCRLF);
            else
            {
                if(dwIndex!=(pInfo->cUsageIdentifier-1))
                    wcscat(pwsz, wszCOMMA);
            }


            LocalFree((HLOCAL)pwszOIDFormat);
            pwszOIDFormat=NULL;

            if(fOIDNameAllocated)
                free(pwszOIDName);

            pwszOIDName=NULL;
        }

        pwszFormat=pwsz;

	}

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:

	if(pwsz)
		free(pwsz);

    if(pwszOIDFormat)
        LocalFree((HLOCAL)pwszOIDFormat);

    if(fOIDNameAllocated)
    {
        if(pwszOIDName)
            free(pwszOIDName);
    }


	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatMsgError);
}

//--------------------------------------------------------------------------
//
//	 GetOtherName:
//
//		The idsPreFix is for multi line formatting only.
//		It should never be 0.
//--------------------------------------------------------------------------
BOOL GetOtherName(	DWORD		            dwCertEncodingType,
					DWORD		            dwFormatType,
					DWORD                   dwFormatStrType,
					void	            	*pFormatStruct,
					CERT_OTHER_NAME			*pOtherName,
					UINT					idsPreFix,
					LPWSTR					*ppwszOtherName)
{

	BOOL				fResult=FALSE;
	PCCRYPT_OID_INFO	pOIDInfo=NULL;
	DWORD				cbSize=0;
	WCHAR				wszPreFix[PREFIX_SIZE];

    LPWSTR              pwszObjId   = NULL;
	LPWSTR				pwszName=NULL;
	LPWSTR				pwszFormat=NULL;

	if(NULL == pOtherName || NULL == ppwszOtherName)
		goto InvalidArg;

	*ppwszOtherName=NULL;

	//get the OID name
	pOIDInfo=CryptFindOIDInfo(CRYPT_OID_INFO_OID_KEY,
							pOtherName->pszObjId,
							0);

	//get the value.  If OID is szOID_NT_PRINCIPAL_NAME, we format it 
	//as the unicode string.  Otherwise, we hex dump
	if(0 == strcmp(szOID_NT_PRINCIPAL_NAME, pOtherName->pszObjId))
	{
		//turn off the multi line here
		if(!FormatAnyUnicodeStringExtension(
				dwCertEncodingType,
				dwFormatType,
				dwFormatStrType & (~CRYPT_FORMAT_STR_MULTI_LINE),
				pFormatStruct,
				pOtherName->pszObjId,
				pOtherName->Value.pbData,
				pOtherName->Value.cbData,
				NULL,		
				&cbSize))
			goto FormatUnicodeError;

		pwszName=(LPWSTR)malloc(cbSize);
		if(NULL==pwszName)
			goto MemoryError;

		if(!FormatAnyUnicodeStringExtension(
				dwCertEncodingType,
				dwFormatType,
				dwFormatStrType & (~CRYPT_FORMAT_STR_MULTI_LINE),
				pFormatStruct,
				pOtherName->pszObjId,
				pOtherName->Value.pbData,
				pOtherName->Value.cbData,
				pwszName,		
				&cbSize))
			goto FormatUnicodeError;
	}
	else
	{
		if(!FormatBytesToHex(dwCertEncodingType,
							dwFormatType,
							dwFormatStrType & (~CRYPT_FORMAT_STR_MULTI_LINE),
							pFormatStruct,
							NULL,
							pOtherName->Value.pbData,
							pOtherName->Value.cbData,
							NULL,
							&cbSize))
			goto FormatByesToHexError;

		pwszName=(LPWSTR)malloc(cbSize);
		if(NULL==pwszName)
			goto MemoryError;

		if(!FormatBytesToHex(dwCertEncodingType,
							dwFormatType,
							dwFormatStrType & (~CRYPT_FORMAT_STR_MULTI_LINE),
							pFormatStruct,
							NULL,
							pOtherName->Value.pbData,
							pOtherName->Value.cbData,
							pwszName,
							&cbSize))
			goto FormatByesToHexError;
	}

	if(pOIDInfo)
	{
		if(!FormatMessageUnicode(&pwszFormat,
                                 IDS_OTHER_NAME_OIDNAME, 
                                 pOIDInfo->pwszName,
			                     pwszName))
			goto FormatMsgError;
	}
	else
	{
        //
        // Convert OID to Unicode.
        //
        if (!AllocateAnsiToUnicode(pOtherName->pszObjId, &pwszObjId))
            goto AnsiToUnicodeError;

		if(!FormatMessageUnicode(&pwszFormat,IDS_OTHER_NAME_OID, pwszObjId,	pwszName))
			goto FormatMsgError;
	}

	//copy the prefix and content
    if(!LoadStringU(hFrmtFuncInst,idsPreFix, wszPreFix, sizeof(wszPreFix)/sizeof(wszPreFix[0])))
		    goto LoadStringError;

	*ppwszOtherName=(LPWSTR)malloc(sizeof(WCHAR) * (wcslen(wszPreFix) + wcslen(pwszFormat) + 1));
	if(NULL == *ppwszOtherName)
		goto MemoryError;

	**ppwszOtherName=L'\0';

	if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
		wcscat(*ppwszOtherName, wszPreFix);

	wcscat(*ppwszOtherName, pwszFormat);

	fResult=TRUE;
	

CommonReturn:

    if (pwszObjId)
        free(pwszObjId);

	if(pwszName)
		free(pwszName);

	if(pwszFormat)
		LocalFree((HLOCAL)pwszFormat);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(FormatByesToHexError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(AnsiToUnicodeError);
TRACE_ERROR(FormatUnicodeError);
TRACE_ERROR(LoadStringError);
TRACE_ERROR(FormatMsgError);
}

//--------------------------------------------------------------------------
//
//	 FormatAltNameInfo:
//
//--------------------------------------------------------------------------
BOOL FormatAltNameInfo(
    DWORD		            dwCertEncodingType,
	DWORD		            dwFormatType,
    DWORD                   dwFormatStrType,
    void	            	*pFormatStruct,
    UINT                    idsPreFix,
    BOOL                    fNewLine,
    PCERT_ALT_NAME_INFO	    pInfo,
    void	                *pbFormat,
	DWORD	                *pcbFormat)
{
	
	LPWSTR							pwszFormat=NULL;
    LPWSTR                          pwsz=NULL;

    LPWSTR                          pwszAltEntryFormat=NULL;
    LPWSTR                          pwszAltEntry=NULL;

	WCHAR							wszNoInfo[NO_INFO_SIZE];
    WCHAR                           wszAltName[ALT_NAME_SIZE];
    WCHAR                           wszPreFix[PRE_FIX_SIZE];
    BOOL                            fEntryAllocated=FALSE;
    DWORD                           dwIndex=0;
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
    HRESULT                         hr=S_OK;
    UINT                            idsAltEntryName=0;

    LPWSTR                          pwszTemp;
    
    //load the string "info not available"
    if(!LoadStringU(hFrmtFuncInst,IDS_NO_ALT_NAME, wszNoInfo, sizeof(wszNoInfo)/sizeof(wszNoInfo[0])))
		goto LoadStringError;

	//build the list of alternative name entries
    //1st, check if any information is available
    if(0==pInfo->cAltEntry)
    {
	    pwszFormat=wszNoInfo;
    }
    else
    {
        //load the pre-dix
        if(0!=idsPreFix)
        {
            if(!LoadStringU(hFrmtFuncInst, idsPreFix,
                        wszPreFix, sizeof(wszPreFix)/sizeof(wszPreFix[0])))
                goto LoadStringError;

        }

        pwsz=(LPWSTR)malloc(sizeof(WCHAR));
        if(NULL==pwsz)
            goto MemoryError;

        //NULL terminate the string
        *pwsz=L'\0';

        //build the list of alternative name entries
        for(dwIndex=0; dwIndex<pInfo->cAltEntry; dwIndex++)
        {
			// DSIE: Fix bug 128630.
			cbNeeded = 0;

            fEntryAllocated=FALSE;

             switch((pInfo->rgAltEntry)[dwIndex].dwAltNameChoice)
             {
                case CERT_ALT_NAME_OTHER_NAME:
                         if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                            idsAltEntryName=IDS_OTHER_NAME_MULTI;
                         else
                            idsAltEntryName=IDS_OTHER_NAME;

						 if(!GetOtherName(
							 dwCertEncodingType,
                             dwFormatType,
                             dwFormatStrType,
                             pFormatStruct,
							 (pInfo->rgAltEntry)[dwIndex].pOtherName,
							 (0!=idsPreFix) ? idsPreFix+1 : IDS_ONE_TAB,
							 &pwszAltEntry))
								goto GetOtherNameError;

						 fEntryAllocated=TRUE;

                    break;

                case CERT_ALT_NAME_RFC822_NAME:
                         idsAltEntryName=IDS_RFC822_NAME;
                         pwszAltEntry=(pInfo->rgAltEntry)[dwIndex].pwszRfc822Name;
                    break;
                case CERT_ALT_NAME_DNS_NAME:
                         idsAltEntryName=IDS_DNS_NAME;
                         pwszAltEntry=(pInfo->rgAltEntry)[dwIndex].pwszDNSName;
                   break;

                case CERT_ALT_NAME_X400_ADDRESS:
                         idsAltEntryName=IDS_X400_ADDRESS;
                         pwszAltEntry=wszNoInfo;
                   break;

                case CERT_ALT_NAME_DIRECTORY_NAME:
                         if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                            idsAltEntryName=IDS_DIRECTORY_NAME_MULTI;
                         else
                            idsAltEntryName=IDS_DIRECTORY_NAME;

                        if(!CryptDllFormatNameAll(
				            dwCertEncodingType,	
				            dwFormatType,
				            dwFormatStrType,
				            pFormatStruct,
                            (0!=idsPreFix) ? idsPreFix+1 : IDS_ONE_TAB,
                            TRUE,           //memory allocation
				            (pInfo->rgAltEntry)[dwIndex].DirectoryName.pbData,
				            (pInfo->rgAltEntry)[dwIndex].DirectoryName.cbData,
				            (void **)&pwszAltEntry,
				            NULL))
                            goto GetCertNameError;

                         fEntryAllocated=TRUE;

                    break;

                case CERT_ALT_NAME_EDI_PARTY_NAME:
                        idsAltEntryName=IDS_EDI_PARTY_NAME;
                        pwszAltEntry=wszNoInfo;
                    break;

                case CERT_ALT_NAME_URL:
                         idsAltEntryName=IDS_URL;
                         pwszAltEntry=(pInfo->rgAltEntry)[dwIndex].pwszURL;
                   break;

                case CERT_ALT_NAME_IP_ADDRESS:
                        idsAltEntryName=IDS_IP_ADDRESS;

#if (0) // DSIE: 7/25/2000
                        if(!FormatBytesToHex(dwCertEncodingType,
                                            dwFormatType,
                                            dwFormatStrType,
                                            pFormatStruct,
                                            NULL,
                                            (pInfo->rgAltEntry)[dwIndex].IPAddress.pbData,
                                            (pInfo->rgAltEntry)[dwIndex].IPAddress.cbData,
                                            NULL,
                                            &cbNeeded))
                            goto FormatByesToHexError;

                        pwszAltEntry=(LPWSTR)malloc(cbNeeded);
                        if(NULL==pwszAltEntry)
                            goto MemoryError;

                        if(!FormatBytesToHex(dwCertEncodingType,
                                            dwFormatType,
                                            dwFormatStrType,
                                            pFormatStruct,
                                            NULL,
                                            (pInfo->rgAltEntry)[dwIndex].IPAddress.pbData,
                                            (pInfo->rgAltEntry)[dwIndex].IPAddress.cbData,
                                            pwszAltEntry,
                                            &cbNeeded))
                            goto FormatByesToHexError;
#else
                        if (!FormatIPAddress(dwCertEncodingType,
                                            dwFormatType,
                                            dwFormatStrType,
                                            pFormatStruct,
                                            NULL,
                                            idsPreFix,
                                            (pInfo->rgAltEntry)[dwIndex].IPAddress.pbData,
                                            (pInfo->rgAltEntry)[dwIndex].IPAddress.cbData,
                                            pwszAltEntry,
                                            &cbNeeded))
                            goto FormatIPAddressError;

                        pwszAltEntry=(LPWSTR)malloc(cbNeeded);
                        if(NULL==pwszAltEntry)
                            goto MemoryError;

                        if (!FormatIPAddress(dwCertEncodingType,
                                            dwFormatType,
                                            dwFormatStrType,
                                            pFormatStruct,
                                            NULL,
                                            idsPreFix,
                                            (pInfo->rgAltEntry)[dwIndex].IPAddress.pbData,
                                            (pInfo->rgAltEntry)[dwIndex].IPAddress.cbData,
                                            pwszAltEntry,
                                            &cbNeeded))
                            goto FormatIPAddressError;
#endif
                        fEntryAllocated=TRUE;

                    break;

                case CERT_ALT_NAME_REGISTERED_ID:
                        idsAltEntryName=IDS_REGISTERED_ID;

                        if(S_OK!=(hr=SZtoWSZ((pInfo->rgAltEntry)[dwIndex].pszRegisteredID,
                                            &pwszAltEntry)))
                            goto SZtoWSZError;

                        fEntryAllocated=TRUE;
                    break;

                default:
                        idsAltEntryName=IDS_UNKNOWN_VALUE;
                        pwszAltEntry=wszNoInfo;
                    break;

             }

             //load the alternative name string
            if(!LoadStringU(hFrmtFuncInst,idsAltEntryName, wszAltName, sizeof(wszAltName)/sizeof(wszAltName[0])))
		            goto LoadStringError;

            //format message
            if(idsAltEntryName!=IDS_UNKNOWN_VALUE)
            {
                if(!FormatMessageUnicode(&pwszAltEntryFormat,IDS_ALT_NAME_ENTRY, wszAltName,
                    pwszAltEntry))
                    goto FormatMsgError;
            }
            else
            {
                if(!FormatMessageUnicode(&pwszAltEntryFormat,IDS_ALT_NAME_ENTRY_UNKNOWN, wszAltName,
                    (pInfo->rgAltEntry)[dwIndex].dwAltNameChoice))
                    goto FormatMsgError;
            }

            //concatenate the string, including the postfix and prefix if necessary
            if(0!=idsPreFix)
            {
                #if (0) // DSIE: Bug 27436
                pwsz=(LPWSTR)realloc(pwsz, 
                    sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(wszPreFix)+wcslen(pwszAltEntryFormat)+1));
                #endif

                pwszTemp=(LPWSTR)realloc(pwsz, 
                    sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(wszPreFix)+wcslen(pwszAltEntryFormat)+1));
            }
            else
            {
                #if (0) // DSIE: Bug 27436
                pwsz=(LPWSTR)realloc(pwsz, 
                    sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszAltEntryFormat)+1));
                #endif

                pwszTemp=(LPWSTR)realloc(pwsz, 
                    sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszAltEntryFormat)+1));
            }

            #if (0) // DSIE: Bug 27436
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            //strcat the preFix
            if(0!=idsPreFix)
                wcscat(pwsz, wszPreFix);

            //strcat the entry
            wcscat(pwsz, pwszAltEntryFormat);

            //strcat the postFix
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            {
                if((TRUE==fNewLine) || (dwIndex != (pInfo->cAltEntry-1)))
                {
                    //no need for \n if the name is directory name (CERT_NAME)
                    //in multi line format
                    if(idsAltEntryName !=IDS_DIRECTORY_NAME_MULTI)
                        wcscat(pwsz, wszCRLF);
                }

            }
            else
            {
                if(dwIndex != (pInfo->cAltEntry-1))
                    wcscat(pwsz, wszCOMMA);
            }

            LocalFree((HLOCAL)pwszAltEntryFormat);
            pwszAltEntryFormat=NULL;

            if(fEntryAllocated)
                free(pwszAltEntry);
            pwszAltEntry=NULL;
        }

        //if the last entry in the alternative name is  IDS_DIRECTORY_NAME_MULTI,
        //we need to get rid of the last \n if fNewLine is FALSE
        if(FALSE==fNewLine)
        {
            if(idsAltEntryName==IDS_DIRECTORY_NAME_MULTI)
            {
                *(pwsz+wcslen(pwsz)-wcslen(wszCRLF))=L'\0';
            }
        }

        //conver to the WCHAR format

        pwszFormat=pwsz;
    }

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}

	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:

    if(pwsz)
        free(pwsz);

    if(pwszAltEntryFormat)
        LocalFree((HLOCAL)pwszAltEntryFormat);

    if(fEntryAllocated)
    {
        if(pwszAltEntry)
            free(pwszAltEntry);
    }


	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);
SET_ERROR_VAR(SZtoWSZError, hr);
TRACE_ERROR(GetCertNameError);
#if (0) //DSIE
TRACE_ERROR(FormatByesToHexError);
#else
TRACE_ERROR(FormatIPAddressError);
#endif
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(GetOtherNameError);
}

//--------------------------------------------------------------------------
//
//	 FormatAltName:  X509_ALTERNATE_NAME
//                   szOID_SUBJECT_ALT_NAME
//                   szOID_ISSUER_ALT_NAME
//                   szOID_SUBJECT_ALT_NAME2
//                   szOID_ISSUER_ALT_NAME2
//
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatAltName(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	BOOL							fResult=FALSE;
	PCERT_ALT_NAME_INFO	            pInfo=NULL;
	
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_ALTERNATE_NAME,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

    fResult=FormatAltNameInfo(dwCertEncodingType, dwFormatType,dwFormatStrType,
                            pFormatStruct,
                            0,
                            TRUE,
                            pInfo, pbFormat, pcbFormat);

    if(FALSE==fResult)
        goto FormatAltNameError;

CommonReturn:

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(FormatAltNameError);

}

//--------------------------------------------------------------------------
//
//	  GetCertNameMulti
//
//    Get the multi line display of the certificate name
//--------------------------------------------------------------------------
BOOL    GetCertNameMulti(LPWSTR          pwszNameStr,
                         UINT            idsPreFix,
                         LPWSTR          *ppwsz)
{

    BOOL            fResult=FALSE;
    WCHAR           wszPreFix[PRE_FIX_SIZE];
    LPWSTR          pwszStart=NULL;
    LPWSTR          pwszEnd=NULL;
    DWORD           dwCopy=0;
    LPWSTR          pwszNameStart=NULL;
    BOOL            fDone=FALSE;
    BOOL            fInQuote=FALSE;

    LPWSTR          pwszTemp;

    //init
    *ppwsz=NULL;

    //load string for the preFix
    if(0!=idsPreFix && 1!=idsPreFix)
    {
        if(!LoadStringU(hFrmtFuncInst, idsPreFix, wszPreFix, PRE_FIX_SIZE))
            goto LoadStringError;
    }

   *ppwsz=(LPWSTR)malloc(sizeof(WCHAR));
   if(NULL==*ppwsz)
        goto MemoryError;
   **ppwsz=L'\0';

   //now, start the search for the symbol '+' or ','
   pwszStart=pwszNameStr;
   pwszEnd=pwszNameStr;

   //parse the whole string
   for(;FALSE==fDone; pwszEnd++)
   {
       //mark fInQuote to TRUE if we are inside " "
       if(L'\"'==*pwszEnd)
           fInQuote=!fInQuote;

       if((L'+'==*pwszEnd) || (L','==*pwszEnd) ||(L'\0'==*pwszEnd))
       {
           //make sure + and ; are not quoted
           if((L'+'==*pwszEnd) || (L','==*pwszEnd))
           {
                if(TRUE==fInQuote)
                    continue;

           }

           //skip the leading spaces
           for(;*pwszStart != L'\0'; pwszStart++)
           {
                if(*pwszStart != L' ')
                    break;
           }

           //we are done if NULL is reached
           if(L'\0'==*pwszStart)
               break;

           //calculate the length to copy
           dwCopy=(DWORD)(pwszEnd-pwszStart);

           if(0!=idsPreFix && 1!=idsPreFix)
           {
                #if (0) // DSIE: Bug 27436
                *ppwsz=(LPWSTR)realloc(*ppwsz,
                    (wcslen(*ppwsz)+dwCopy+wcslen(wszPreFix)+wcslen(wszCRLF)+1)*sizeof(WCHAR));
                #endif

                pwszTemp=(LPWSTR)realloc(*ppwsz,
                    (wcslen(*ppwsz)+dwCopy+wcslen(wszPreFix)+wcslen(wszCRLF)+1)*sizeof(WCHAR));
           }
           else
           {
                #if (0) // DSIE: Bug 27436
                *ppwsz=(LPWSTR)realloc(*ppwsz,
                    (wcslen(*ppwsz)+dwCopy+wcslen(wszCRLF)+1)*sizeof(WCHAR));
                #endif

                pwszTemp=(LPWSTR)realloc(*ppwsz,
                    (wcslen(*ppwsz)+dwCopy+wcslen(wszCRLF)+1)*sizeof(WCHAR));
           }

           #if (0) // DSIE: Bug 27436
           if(NULL == *ppwsz)
               goto MemoryError;
           #endif

           if(NULL == pwszTemp)
               goto MemoryError;
           *ppwsz = pwszTemp;

           //copy the prefix
           if(0!=idsPreFix && 1!=idsPreFix)
                wcscat(*ppwsz, wszPreFix);

           pwszNameStart=(*ppwsz)+wcslen(*ppwsz);

           //copy the string to *ppwsz
           memcpy(pwszNameStart, pwszStart, dwCopy*sizeof(WCHAR));
           pwszNameStart += dwCopy;

           //NULL terminate the string
           *pwszNameStart=L'\0';

           //copy the "\n"
           wcscat(*ppwsz, wszCRLF);

           //reset pwszStart and pwszEnd.
           pwszStart=pwszEnd+1;

           if(L'\0'==*pwszEnd)
               fDone=TRUE;
       }

   }


    fResult=TRUE;

CommonReturn:

     return fResult;

ErrorReturn:

     if(*ppwsz)
     {
         free(*ppwsz);
         *ppwsz=NULL;
     }

     fResult=FALSE;

     goto CommonReturn;

SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(LoadStringError);
}

//--------------------------------------------------------------------------
//
//	  FormatMessageUnicode
//
//--------------------------------------------------------------------------
BOOL FormatMessageUnicode(LPWSTR * ppwszFormat, UINT ids, ...)
{
    // get format string from resources
    WCHAR		wszFormat[1000];
	va_list		argList;
	DWORD		cbMsg=0;
	BOOL		fResult=FALSE;

    if(NULL == ppwszFormat)
        goto InvalidArgErr;

#if (0) //DSIE: Bug 160605
    if(!LoadStringU(hFrmtFuncInst, ids, wszFormat, sizeof(wszFormat)))
#else
    if(!LoadStringU(hFrmtFuncInst, ids, wszFormat, sizeof(wszFormat) / sizeof(wszFormat[0])))
#endif
		goto LoadStringError;

    // format message into requested buffer
    va_start(argList, ids);

    cbMsg = FormatMessageU(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        wszFormat,
        0,                  // dwMessageId
        0,                  // dwLanguageId
        (LPWSTR) (ppwszFormat),
        0,                  // minimum size to allocate
        &argList);

    va_end(argList);

	if(!cbMsg)
#if (1) // DSIE: Fix bug #128630
		//
		// FormatMessageU() will return 0 byte, if data to be
		// formatted is empty. CertSrv generates extensions
		// with empty data for name constraints, so we need to
		// make sure we return an empty string, "", instead of
		// an error and NULL pointer.
		//
		if (0 == GetLastError())
		{
			if (NULL == (*ppwszFormat = (LPWSTR) LocalAlloc(LPTR, sizeof(WCHAR))))
				goto MemoryError;
		}
		else
#endif
			goto FormatMessageError;

	fResult=TRUE;

CommonReturn:

	return fResult;

ErrorReturn:
	fResult=FALSE;

	goto CommonReturn;


TRACE_ERROR(LoadStringError);
TRACE_ERROR(FormatMessageError);
SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
}

//--------------------------------------------------------------------------
//
//	  FormatMessageStr
//
//--------------------------------------------------------------------------
/*BOOL	FormatMessageStr(LPSTR	*ppszFormat,UINT ids,...)
{
    // get format string from resources
    CHAR		szFormat[1000];
	va_list		argList;
	BOOL		fResult=FALSE;
	HRESULT		hr=S_OK;

    if(!LoadStringA(hFrmtFuncInst, ids, szFormat, sizeof(szFormat)))
		goto LoadStringError;

    // format message into requested buffer
    va_start(argList, ids);

    if(0==FormatMessageA(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        szFormat,
        0,                  // dwMessageId
        0,                  // dwLanguageId
        (LPSTR) ppszFormat,
        0,                  // minimum size to allocate
        &argList))
        goto FormatMessageError;

    va_end(argList);

	fResult=TRUE;

CommonReturn:
	
	return fResult;

ErrorReturn:
	fResult=FALSE;

	goto CommonReturn;


TRACE_ERROR(LoadStringError);
TRACE_ERROR(FormatMessageError);

} */

//--------------------------------------------------------------------------
//
//	  Decode a generic BLOB
//
//--------------------------------------------------------------------------
BOOL	DecodeGenericBLOB(DWORD dwEncodingType, LPCSTR lpszStructType,
			const BYTE *pbEncoded, DWORD cbEncoded,void **ppStructInfo)
{
	DWORD	cbStructInfo=0;

	//decode the object.  No copying
	if(!CryptDecodeObject(dwEncodingType,lpszStructType,pbEncoded, cbEncoded,
		0,NULL,	&cbStructInfo))
		return FALSE;

	*ppStructInfo=malloc(cbStructInfo);
	if(!(*ppStructInfo))
	{
		SetLastError((DWORD) E_OUTOFMEMORY);
		return FALSE;
	}

	return CryptDecodeObject(dwEncodingType,lpszStructType,pbEncoded, cbEncoded,
		0,*ppStructInfo,&cbStructInfo);
}

////////////////////////////////////////////////////////
//
// Convert STR to WSTR
//
HRESULT	SZtoWSZ(LPSTR szStr,LPWSTR *pwsz)
{
	DWORD	dwSize=0;
	DWORD	dwError=0;

	*pwsz=NULL;

	//return NULL
	if(!szStr)
		return S_OK;

	dwSize=MultiByteToWideChar(0, 0,szStr, -1,NULL,0);

	if(dwSize==0)
	{
		dwError=GetLastError();
		return HRESULT_FROM_WIN32(dwError);
	}

	//allocate memory
	*pwsz=(LPWSTR)malloc(dwSize * sizeof(WCHAR));
	if(*pwsz==NULL)
		return E_OUTOFMEMORY;

	if(MultiByteToWideChar(0, 0,szStr, -1,
		*pwsz,dwSize))
	{
		return S_OK;
	}
	else
	{
		 free(*pwsz);
         *pwsz=NULL;
		 dwError=GetLastError();
		 return HRESULT_FROM_WIN32(dwError);
	}
}

//--------------------------------------------------------------------------
//
//	  Convert dwFormatType to dwStrType
//
//--------------------------------------------------------------------------
DWORD   FormatToStr(DWORD   dwFormatType)
{
    DWORD   dwStrType=0;

    //we default to CERT_X500_NAME_STR
    if(0==dwFormatType)
    {
        return CERT_X500_NAME_STR;
    }

    if(dwFormatType &  CRYPT_FORMAT_SIMPLE)
		dwStrType |= CERT_SIMPLE_NAME_STR;

	if(dwFormatType & CRYPT_FORMAT_X509)
		dwStrType |= CERT_X500_NAME_STR;

	if(dwFormatType & CRYPT_FORMAT_OID)
		dwStrType |= CERT_OID_NAME_STR;

	if(dwFormatType & CRYPT_FORMAT_RDN_SEMICOLON)
		dwStrType |= CERT_NAME_STR_SEMICOLON_FLAG;

	if(dwFormatType & CRYPT_FORMAT_RDN_CRLF)
		dwStrType |= CERT_NAME_STR_CRLF_FLAG;

	if(dwFormatType & CRYPT_FORMAT_RDN_UNQUOTE)
		dwStrType |= CERT_NAME_STR_NO_QUOTING_FLAG;

	if(dwFormatType & CRYPT_FORMAT_RDN_REVERSE)
		dwStrType |= CERT_NAME_STR_REVERSE_FLAG;

    return dwStrType;

}


//+-----------------------------------------------------------------------------
//  Post Win2k.
//------------------------------------------------------------------------------

//+-----------------------------------------------------------------------------
//
//  FormatInteger           X509_INTEGER
//
//------------------------------------------------------------------------------

static BOOL
WINAPI
FormatInteger (
	DWORD       dwCertEncodingType,
	DWORD       dwFormatStrType,
	const BYTE *pbEncoded,
	DWORD       cbEncoded,
	void       *pbFormat,
	DWORD      *pcbFormat,
    DWORD       ids)
{
	BOOL    fResult;
    DWORD   cbNeeded;
    int    *pInfo = NULL;
    LPWSTR  pwszFormat = NULL;
    BOOL    bMultiLines = dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE;

    //
	// Check input parameters.
    //
    if ((NULL == pbEncoded && 0 != cbEncoded) ||
        (NULL == pcbFormat) ||
        (0 == cbEncoded))
	{
		goto InvalidArg;
	}

    //
    // Decode extension.
    //
    if (!DecodeGenericBLOB(dwCertEncodingType, 
                           X509_INTEGER,
			               pbEncoded,
                           cbEncoded, 
                           (void **)&pInfo))
    {
        goto DecodeGenericError;
    }

    //
    // Some extension name=%1!d!%2!s!
    //
    if (!FormatMessageUnicode(&pwszFormat, 
                              ids,
                              *pInfo,
                              bMultiLines ? wszCRLF : wszEMPTY))
    {
        goto FormatMessageError;                                  
    }

    //
    // Total length needed.
    //
    cbNeeded = sizeof(WCHAR) * (wcslen(pwszFormat) + 1);

    //
    // length only calculation?
    //
    if (NULL == pbFormat)
    {
        *pcbFormat = cbNeeded;
        goto SuccessReturn;
    }

    //
    // Caller provided us with enough memory?
    //
    if (*pcbFormat < cbNeeded)
    {
        *pcbFormat = cbNeeded;
        goto MoreDataError;
    }

    //
    // Copy size and data.
    //
    memcpy(pbFormat, pwszFormat, cbNeeded);
    *pcbFormat = cbNeeded;

SuccessReturn:

    fResult = TRUE;

CommonReturn:

    //
    // Free resources.
    //
	if (pInfo)
    {
        free(pInfo);
    }

    if (pwszFormat)
    {
        LocalFree((HLOCAL) pwszFormat);
    }

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg,E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(FormatMessageError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
}

//+-----------------------------------------------------------------------------
//
//  FormatCrlNumber           szOID_CRL_NUMBER
//                            szOID_DELTA_CRL_INDICATOR
//                            szOID_CRL_VIRTUAL_BASE
//
//------------------------------------------------------------------------------

static BOOL
WINAPI
FormatCrlNumber (
	DWORD       dwCertEncodingType,
	DWORD       dwFormatType,
	DWORD       dwFormatStrType,
	void       *pFormatStruct,
	LPCSTR      lpszStructType,
	const BYTE *pbEncoded,
	DWORD       cbEncoded,
	void       *pbFormat,
	DWORD      *pcbFormat)
{
	BOOL    fResult;
    DWORD   cbNeeded = 0;
    DWORD   ids = 0;
    BOOL    bMultiLines = dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE;

    //
	// Check input parameters.
    //
    if ((NULL == pbEncoded && 0 != cbEncoded) ||
        (NULL == pcbFormat) || (0 == cbEncoded))
	{
		goto InvalidArg;
	}

    //
    // Decide between single line and mulitple line format.
    //
    if (bMultiLines)
    {
        ids = 0 == strcmp(lpszStructType, szOID_CRL_NUMBER) ? IDS_CRL_NUMBER : 
              0 == strcmp(lpszStructType, szOID_DELTA_CRL_INDICATOR) ? IDS_DELTA_CRL_INDICATOR : IDS_CRL_VIRTUAL_BASE;
    }
    else
    {
        ids = IDS_INTEGER;
    }

    //
    // Decode extension to get length.
    //
    //  %1!d!%2!s!
    //  CRL Number=%1!d!%2!s!
    //  Delta CRL Number=%1!d!%2!s!
    //  Virtual Base CRL Number=%1!d!%2!s!
    //
    if (!FormatInteger(dwCertEncodingType, 
                       dwFormatStrType,
			           pbEncoded,
                       cbEncoded, 
                       NULL,
                       &cbNeeded,
                       ids))
    {
        goto FormatIntegerError;
    }

    //
    // length only calculation?
    //
    if (NULL == pbFormat)
    {
        *pcbFormat = cbNeeded;
        goto SuccessReturn;
    }

    //
    // Caller provided us with enough memory?
    //
    if (*pcbFormat < cbNeeded)
    {
        *pcbFormat = cbNeeded;
        goto MoreDataError;
    }

    //
    // Decode again to get data.
    //
    if (!FormatInteger(dwCertEncodingType, 
                       dwFormatStrType,
			           pbEncoded,
                       cbEncoded, 
                       pbFormat,
                       &cbNeeded,
                       ids))
    {
        goto FormatIntegerError;
    }

    //
    // Copy size .
    //
    *pcbFormat = cbNeeded;

SuccessReturn:

    fResult = TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg,E_INVALIDARG);
TRACE_ERROR(FormatIntegerError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
}

//+-----------------------------------------------------------------------------
//
//  FormatCrlNextPublish      szOID_CRL_NEXT_PUBLISH
//
//------------------------------------------------------------------------------

static BOOL
WINAPI
FormatCrlNextPublish (
	DWORD       dwCertEncodingType,
	DWORD       dwFormatType,
	DWORD       dwFormatStrType,
	void       *pFormatStruct,
	LPCSTR      lpszStructType,
	const BYTE *pbEncoded,
	DWORD       cbEncoded,
	void       *pbFormat,
	DWORD      *pcbFormat)
{
	BOOL       fResult;
    DWORD      cbNeeded     = 0;
    FILETIME * pInfo        = NULL;
    LPWSTR     pwszFileTime = NULL;
    LPWSTR     pwszFormat   = NULL;
    BOOL       bMultiLines  = dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE;

    //
	// Check input parameters.
    //
    if ((NULL == pbEncoded && 0 != cbEncoded) ||
        (NULL == pcbFormat) || (0 == cbEncoded))
	{
		goto InvalidArg;
	}

    //
    // Decode extension.
    //
    if (!DecodeGenericBLOB(dwCertEncodingType, 
                           X509_CHOICE_OF_TIME,
			               pbEncoded,
                           cbEncoded, 
                           (void **) &pInfo))
    {
        goto DecodeGenericError;
    }

    //
    // Get formatted date/time.
    //
    if (!FormatFileTime(pInfo, &pwszFileTime))
    {
        goto FormatFileTimeError;
    }

    if (!FormatMessageUnicode(&pwszFormat, 
                              IDS_STRING, 
                              pwszFileTime,
                              bMultiLines ? wszCRLF : wszEMPTY))
    {
        goto FormatMessageError;
    }

    //
    // Total length needed.
    //
    cbNeeded = sizeof(WCHAR) * (wcslen(pwszFormat) + 1);

    //
    // length only calculation?
    //
    if (NULL == pbFormat)
    {
        *pcbFormat = cbNeeded;
        goto SuccessReturn;
    }

    //
    // Caller provided us with enough memory?
    //
    if (*pcbFormat < cbNeeded)
    {
        *pcbFormat = cbNeeded;
        goto MoreDataError;
    }

    //
    // Copy size and data.
    //
    memcpy(pbFormat, pwszFormat, cbNeeded);
    *pcbFormat = cbNeeded;

SuccessReturn:

    fResult = TRUE;

CommonReturn:

	if (pInfo)
    {
        free(pInfo);
    }

    if (pwszFileTime)
    {
        LocalFree((HLOCAL) pwszFileTime);
    }

    if (pwszFormat)
    {
        LocalFree((HLOCAL) pwszFormat);
    }

    return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg,E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(FormatFileTimeError);
TRACE_ERROR(FormatMessageError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
}

//+-----------------------------------------------------------------------------
//
//  FormatIssuingDistPoint      X509_ISSUING_DIST_POINT
//                              szOID_ISSUING_DIST_POINT
//
//  typedef struct _CRL_ISSUING_DIST_POINT {
//      CRL_DIST_POINT_NAME     DistPointName;              // OPTIONAL
//      BOOL                    fOnlyContainsUserCerts;
//      BOOL                    fOnlyContainsCACerts;
//      CRYPT_BIT_BLOB          OnlySomeReasonFlags;        // OPTIONAL
//      BOOL                    fIndirectCRL;
//  } CRL_ISSUING_DIST_POINT, *PCRL_ISSUING_DIST_POINT;
//
//  typedef struct _CRL_DIST_POINT_NAME {
//      DWORD   dwDistPointNameChoice;
//      union {
//          CERT_ALT_NAME_INFO      FullName;       // 1
//          // Not implemented      IssuerRDN;      // 2
//      };
//  } CRL_DIST_POINT_NAME, *PCRL_DIST_POINT_NAME;
//
//------------------------------------------------------------------------------

static BOOL
WINAPI
FormatIssuingDistPoint (
	DWORD       dwCertEncodingType,
	DWORD       dwFormatType,
	DWORD       dwFormatStrType,
	void       *pFormatStruct,
	LPCSTR      lpszStructType,
	const BYTE *pbEncoded,
	DWORD       cbEncoded,
	void       *pbFormat,
	DWORD      *pcbFormat)
{
	BOOL    fResult;
    DWORD   cbNeeded = 0;
    DWORD   ids = 0;
    WCHAR   wszYes[YES_NO_SIZE];
    WCHAR   wszNo[YES_NO_SIZE];
    LPWSTR  pwszTemp = NULL;
    LPWSTR  pwszFormat = NULL;
    LPWSTR  pwszPointName = NULL;
    LPWSTR  pwszNameFormat = NULL;
    LPWSTR  pwszOnlyContainsUserCerts = NULL;
    LPWSTR  pwszOnlyContainsCACerts = NULL;
    LPWSTR  pwszIndirectCRL = NULL;
    LPWSTR  pwszCRLReason=NULL;
    LPWSTR  pwszReasonFormat=NULL;
    BOOL    bMultiLines = dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE;

    PCRL_ISSUING_DIST_POINT pInfo = NULL;

    //
	// Check input parameters.
    //
    if ((NULL == pbEncoded && 0 != cbEncoded) ||
        (NULL == pcbFormat) || (0 == cbEncoded))
	{
		goto InvalidArg;
	}

    //
    // Decode extension.
    //
    if (!DecodeGenericBLOB(dwCertEncodingType, 
                           lpszStructType,
			               pbEncoded,
                           cbEncoded, 
                           (void **)&pInfo))
    {
        goto DecodeGenericError;
    }

    //
    // Allocate format buffer.
    //
    if (!(pwszFormat = (LPWSTR) malloc(sizeof(WCHAR))))
    {
        goto MemoryError;
    }
    *pwszFormat = L'\0';

    //
    // Format distribution name, if exists.
    //
    if (CRL_DIST_POINT_NO_NAME != pInfo->DistPointName.dwDistPointNameChoice)
    {
        if (!FormatDistPointName(dwCertEncodingType,
                                 dwFormatType,
                                 dwFormatStrType,
                                 pFormatStruct,
                                 &(pInfo->DistPointName),
                                 &pwszPointName))
        {
            goto FormatDistPointNameError;
        }

        //
        // Decide between single line and mulitple line format.
        //
        ids = bMultiLines ? IDS_ONLY_SOME_CRL_DIST_NAME_MULTI: IDS_ONLY_SOME_CRL_DIST_NAME;

        if (!FormatMessageUnicode(&pwszNameFormat, ids, pwszPointName))
        {
            goto FormatMessageError;
        }

        //
        // Reallocate and concate to format buffer.
        //
        pwszTemp = (LPWSTR) realloc(pwszFormat, sizeof(WCHAR) * (wcslen(pwszFormat) + wcslen(pwszNameFormat) + 1));
        if (NULL == pwszTemp)
        {
            goto MemoryError;
        }

        pwszFormat = pwszTemp;
        wcscat(pwszFormat, pwszNameFormat);

        LocalFree((HLOCAL) pwszPointName);
        pwszPointName = NULL;

        LocalFree((HLOCAL) pwszNameFormat);
        pwszNameFormat = NULL;
    }

    //
    // Format onlyContainsXXX fields.
    //
    if (!LoadStringU(hFrmtFuncInst, 
                     IDS_YES, 
                     wszYes,
                     sizeof(wszYes) / sizeof(wszYes[0])))
    {
        goto LoadStringError;
    }

    if (!LoadStringU(hFrmtFuncInst, 
                     IDS_NO, 
                     wszNo,
                     sizeof(wszNo) / sizeof(wszNo[0])))
    {
        goto LoadStringError;
    }

    //
    // %1!s!Only Contains User Certs=%2!s!%3!s!
    //
    if (!FormatMessageUnicode(&pwszOnlyContainsUserCerts,
                              IDS_ONLY_CONTAINS_USER_CERTS,
                              bMultiLines ? wszEMPTY : wszCOMMA,
                              pInfo->fOnlyContainsUserCerts ? wszYes : wszNo,
                              bMultiLines ? wszCRLF : wszEMPTY))
    {
        goto FormatMessageError;                                  
    }

    //
    // %1!s!Only Contains CA Certs=%2!s!%3!s!
    //
    if (!FormatMessageUnicode(&pwszOnlyContainsCACerts,
                              IDS_ONLY_CONTAINS_CA_CERTS,
                              bMultiLines ? wszEMPTY : wszCOMMA,
                              pInfo->fOnlyContainsCACerts ? wszYes : wszNo,
                              bMultiLines ? wszCRLF : wszEMPTY))
    {
        goto FormatMessageError;                                  
    }

    //
    // %1!s!Indirect CRL=%2!s!%3!s!
    //
    if (!FormatMessageUnicode(&pwszIndirectCRL,
                              IDS_INDIRECT_CRL,
                              bMultiLines ? wszEMPTY : wszCOMMA,
                              pInfo->fIndirectCRL ? wszYes : wszNo,
                              bMultiLines ? wszCRLF : wszEMPTY))
    {
        goto FormatMessageError;                                  
    }

    //
    // Reallocate and concate to format buffer.
    //
    pwszTemp = (LPWSTR) realloc(pwszFormat, sizeof(WCHAR) * 
                      (wcslen(pwszFormat) + wcslen(pwszOnlyContainsUserCerts) + 
                       wcslen(pwszOnlyContainsCACerts) + wcslen(pwszIndirectCRL) + 1));
    if (NULL == pwszTemp)
    {
        goto MemoryError;
    }

    pwszFormat = pwszTemp;
    wcscat(pwszFormat, pwszOnlyContainsUserCerts);      
    wcscat(pwszFormat, pwszOnlyContainsCACerts);      
    wcscat(pwszFormat, pwszIndirectCRL);      

    //
    // Format the CRL reason.
    //
    if (0 != pInfo->OnlySomeReasonFlags.cbData)
    {
        if (!FormatCRLReason(dwCertEncodingType,
                             dwFormatType,
                             dwFormatStrType,
                             pFormatStruct,
                             lpszStructType,
                             &(pInfo->OnlySomeReasonFlags),
                             &pwszCRLReason))
        {
            goto FormatCRLReasonError;
        }

        //
        // Format Decide between single line and mulitple line format.
        //
        if (!FormatMessageUnicode(&pwszReasonFormat, 
                                  bMultiLines ? IDS_CRL_DIST_REASON_MULTI : IDS_CRL_DIST_REASON,
                                  pwszCRLReason))
        {
            goto FormatMessageError;
        }

        //
        // Reallocate and concate to format buffer.
        //
        pwszTemp = (LPWSTR) realloc(pwszFormat, sizeof(WCHAR) * (wcslen(pwszFormat) + wcslen(pwszReasonFormat) + 1));
        if (NULL == pwszTemp)
        {
            goto MemoryError;
        }

        pwszFormat = pwszTemp;
        wcscat(pwszFormat, pwszReasonFormat);

        LocalFree((HLOCAL) pwszCRLReason);
        pwszCRLReason = NULL;

        LocalFree((HLOCAL) pwszReasonFormat);
        pwszReasonFormat = NULL;
    }

    //
    // length needed.
    //
    cbNeeded = sizeof(WCHAR) * (wcslen(pwszFormat) + 1);

    //
    // length only calculation?
    //
    if (NULL == pbFormat)
    {
        *pcbFormat = cbNeeded;
        goto SuccessReturn;
    }

    //
    // Caller provided us with enough memory?
    //
    if (*pcbFormat < cbNeeded)
    {
        *pcbFormat = cbNeeded;
        goto MoreDataError;
    }

    //
    // Copy size and data.
    //
    memcpy(pbFormat, pwszFormat, cbNeeded);
    *pcbFormat = cbNeeded;

SuccessReturn:

    fResult = TRUE;

CommonReturn:

    //
    // Free resources.
    //
    if (pwszCRLReason)
    {
        LocalFree((HLOCAL) pwszCRLReason);
    }

    if (pwszReasonFormat)
    {
        LocalFree((HLOCAL) pwszReasonFormat);
    }

    if(pwszIndirectCRL)
    {
        LocalFree((HLOCAL) pwszIndirectCRL);
    }

    if(pwszOnlyContainsCACerts)
    {
        LocalFree((HLOCAL) pwszOnlyContainsCACerts);
    }

    if(pwszOnlyContainsUserCerts)
    {
        LocalFree((HLOCAL) pwszOnlyContainsUserCerts);
    }

    if(pwszPointName)
    {
        LocalFree((HLOCAL) pwszPointName);
    }

    if (pwszNameFormat)
    {
        LocalFree((HLOCAL) pwszNameFormat);
    }

    if (pwszFormat)
    {
        free(pwszFormat);
    }

	if (pInfo)
    {
        free(pInfo);
    }

    return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg,E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
SET_ERROR(MemoryError,E_OUTOFMEMORY);
TRACE_ERROR(FormatDistPointNameError);
TRACE_ERROR(LoadStringError);
TRACE_ERROR(FormatCRLReasonError);
TRACE_ERROR(FormatMessageError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
}

//+-----------------------------------------------------------------------------
//
// FormatNameConstraintsSubtree.
//
// typedef struct _CERT_GENERAL_SUBTREE {
//      CERT_ALT_NAME_ENTRY     Base;
//      DWORD                   dwMinimum;
//      BOOL                    fMaximum;
//      DWORD                   dwMaximum;
// } CERT_GENERAL_SUBTREE, *PCERT_GENERAL_SUBTREE;
//
//
// Note: Intended to be called only by FormatNameConstrants. So no validity 
//       checks are done on parameters.
//
//------------------------------------------------------------------------------

//static 
BOOL
FormatNameConstraintsSubtree (
	DWORD                   dwCertEncodingType,
	DWORD                   dwFormatType,
	DWORD                   dwFormatStrType,
	void                   *pFormatStruct,
	void                   *pbFormat,
	DWORD                  *pcbFormat,
    DWORD                   idSubtree,
    DWORD                   cSubtree,
    PCERT_GENERAL_SUBTREE   pSubtree)
{
	BOOL        fResult;
    DWORD       dwIndex;
    DWORD       cbNeeded;
    WCHAR       wszOneTab[PRE_FIX_SIZE] = wszEMPTY;
    LPWSTR      pwszType = NULL;
    LPWSTR      pwszSubtree = NULL;
    LPWSTR      pwszAltName = NULL;
    LPWSTR      pwszFormat = NULL;
    BOOL        bMultiLines = dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE;

    //
    // Any subtree?
    //
    if (0 == cSubtree)
    {
        //
        // Permitted=None%1!s!
        // Excluded=None%1!s!
        //
        if (IDS_NAME_CONSTRAINTS_PERMITTED == idSubtree)
        {
            idSubtree = IDS_NAME_CONSTRAINTS_PERMITTED_NONE;
        }
        else // if (IDS_NAME_CONSTRAINTS_EXCLUDED == idSubtree)
        {
            idSubtree = IDS_NAME_CONSTRAINTS_EXCLUDED_NONE;
        }

        if (!FormatMessageUnicode(&pwszType, 
                                  idSubtree,
                                  bMultiLines ? wszCRLF : wszEMPTY))
        {
            goto FormatMessageError;                                  
        }
    }
    else
    {
        //
        // "Permitted%1!s!"
        // "Excluded%1!s!"
        //
        if (!FormatMessageUnicode(&pwszType,
                                  idSubtree,
                                  bMultiLines ? wszCRLF : wszCOLON))
        {
            goto FormatMessageError;                                  
        }

        //
        // Load tab strings.
        //
        if (!LoadStringU(hFrmtFuncInst, 
                         IDS_ONE_TAB, 
                         wszOneTab,
                         sizeof(wszOneTab) / sizeof(wszOneTab[0])))
        {
            goto LoadStringError;
        }
    }

    //
    // Allocate format buffer.
    //
    if (!(pwszFormat = (LPWSTR) malloc(sizeof(WCHAR) * (wcslen(pwszType) + 1))))
    {
        goto MemoryError;
    }

    //
    // Initialize formatted string.
    //
    wcscpy(pwszFormat, pwszType);

    //
    // Format each subtree parts.
    //
    for (dwIndex = 0; dwIndex < cSubtree; dwIndex++, pSubtree++) 
    {
        LPWSTR pwszTemp;
        
        //
        // Maximum specified?
        //
        if (pSubtree->fMaximum)
        {
            //
            // "%1!s![%2!d!]Subtrees (%3!d!..%4!d!):%5!s!"
            //
            if (!FormatMessageUnicode(&pwszSubtree,
                    IDS_NAME_CONSTRAINTS_SUBTREE,
                    bMultiLines ? wszOneTab : dwIndex ? wszCOMMA : wszEMPTY,
                    dwIndex + 1,
                    pSubtree->dwMinimum,
                    pSubtree->dwMaximum,
                    bMultiLines ? wszCRLF : wszEMPTY))
            {
                goto FormatMessageError;                                  
            }
        }
        else
        {
            //
            // "%1!s![%2!d!]Subtrees (%3!d!...):%4!s"
            //
            if (!FormatMessageUnicode(&pwszSubtree,
                    IDS_NAME_CONSTRAINTS_SUBTREE_NO_MAX,
                    bMultiLines ? wszOneTab : dwIndex ? wszCOMMA : wszEMPTY,
                    dwIndex + 1,
                    pSubtree->dwMinimum,
                    bMultiLines ? wszCRLF : wszEMPTY))
            {
                goto FormatMessageError;                                  
            }
        }

        //
        // Reallocate and concate to format buffer.
        //
        pwszTemp = (LPWSTR) realloc(pwszFormat, sizeof(WCHAR) * (wcslen(pwszFormat) + 1 + wcslen(pwszSubtree)));
        if (NULL == pwszTemp)
        {
            goto MemoryError;
        }

        pwszFormat = pwszTemp;
        wcscat(pwszFormat, pwszSubtree);
        LocalFree((HLOCAL) pwszSubtree);
        pwszSubtree = NULL;

        //
        // Format name.
        //
        CERT_ALT_NAME_INFO  CertAltNameInfo;

        memset(&CertAltNameInfo, 0, sizeof(CERT_ALT_NAME_INFO));
        CertAltNameInfo.cAltEntry = 1;
        CertAltNameInfo.rgAltEntry = &(pSubtree->Base);

        // Need to tell if it is for multi line format.  We need two \t\t
        // in front of each alt name entry
        DWORD ids = bMultiLines ? IDS_TWO_TABS : 0;

        // Get the alternative name entry
        cbNeeded = 0;
        
		if (!FormatAltNameInfo(dwCertEncodingType,
                               dwFormatType,
                               dwFormatStrType,
                               pFormatStruct,
                               ids,
                               FALSE,
                               &CertAltNameInfo,
                               NULL,
                               &cbNeeded))
        {
            goto FormatAltNameError;
        }

        if (NULL == (pwszAltName = (LPWSTR) malloc(cbNeeded)))
        {
            goto MemoryError;
        }

        if (!FormatAltNameInfo(dwCertEncodingType,
                               dwFormatType,
                               dwFormatStrType,
                               pFormatStruct,
                               ids,
                               FALSE,
                               &CertAltNameInfo,
                               pwszAltName,
                               &cbNeeded))
        {
            goto FormatAltNameError;
        }

        //
        // Append "\r\n" if multi-line.
        //
        if (bMultiLines)
        {
			pwszTemp = (LPWSTR) realloc(pwszAltName, sizeof(WCHAR) * (wcslen(pwszAltName) + wcslen(wszCRLF) + 1));
			if (NULL == pwszTemp)
			{
				goto MemoryError;
			}
			pwszAltName = pwszTemp;
            wcscat(pwszAltName, wszCRLF);
        }

        //
        // Reallocate and concate to format buffer.
        //
        pwszTemp = (LPWSTR) realloc(pwszFormat, sizeof(WCHAR) * (wcslen(pwszFormat) + 1 + wcslen(pwszAltName)));
        if (NULL == pwszTemp)
        {
            goto MemoryError;
        }

        pwszFormat = pwszTemp;
        wcscat(pwszFormat, pwszAltName);
        free(pwszAltName);
        pwszAltName = NULL;
    }

    //
    // Total length needed.
    //
    cbNeeded = sizeof(WCHAR) * (wcslen(pwszFormat) + 1);

    //
    // length only calculation?
    //
    if (NULL == pbFormat)
    {
        *pcbFormat = cbNeeded;
        goto SuccessReturn;
    }

    //
    // Caller provided us with enough memory?
    //
    if (*pcbFormat < cbNeeded)
    {
        *pcbFormat = cbNeeded;
        goto MoreDataError;
    }

    //
    // Copy size and data.
    //
    memcpy(pbFormat, pwszFormat, cbNeeded);
    *pcbFormat = cbNeeded;

SuccessReturn:

    fResult = TRUE;

CommonReturn:

    //
    // Free resources.
    //
    if (pwszType)
    {
        LocalFree((HLOCAL) pwszType);
    }

    if (pwszSubtree)
    {
        LocalFree((HLOCAL) pwszSubtree);
    }

    if (pwszAltName)
    {
        free((HLOCAL) pwszAltName);
    }

    if (pwszFormat)
    {
        free(pwszFormat);
    }

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(FormatMessageError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MemoryError,E_OUTOFMEMORY);
TRACE_ERROR(FormatAltNameError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
}

//+-----------------------------------------------------------------------------
//
//  FormatNameConstrains:   szOID_NAME_CONSTRAINTS
//                          X509_NAME_CONSTRAINTS
//
//  typedef struct _CERT_NAME_CONSTRAINTS_INFO {
//      DWORD                   cPermittedSubtree;
//      PCERT_GENERAL_SUBTREE   rgPermittedSubtree;
//      DWORD                   cExcludedSubtree;
//      PCERT_GENERAL_SUBTREE   rgExcludedSubtree;
//  } CERT_NAME_CONSTRAINTS_INFO, *PCERT_NAME_CONSTRAINTS_INFO;
//
//------------------------------------------------------------------------------

//static 
BOOL
WINAPI
FormatNameConstraints (
	DWORD       dwCertEncodingType,
	DWORD       dwFormatType,
	DWORD       dwFormatStrType,
	void       *pFormatStruct,
	LPCSTR      lpszStructType,
	const BYTE *pbEncoded,
	DWORD       cbEncoded,
	void       *pbFormat,
	DWORD      *pcbFormat)
{
	BOOL  fResult = FALSE;
    DWORD cbPermitNeeded = 0;
    DWORD cbExcludeNeeded = 0;
    DWORD cbTotalNeeded = 0;

    PCERT_NAME_CONSTRAINTS_INFO pInfo = NULL;

    //
	// Check input parameters.
    //
    if ((NULL == pbEncoded && 0 != cbEncoded) ||
        (NULL == pcbFormat) || (0 == cbEncoded))
	{
		goto InvalidArg;
	}

    //
    // Decode extension.
    //
    if (!DecodeGenericBLOB(dwCertEncodingType, 
                           lpszStructType,
			               pbEncoded,
                           cbEncoded, 
                           (void **)&pInfo))
    {
        goto DecodeGenericError;
    }

    //
    // Find out memory size needed.
    //
    if ((!FormatNameConstraintsSubtree(dwCertEncodingType,
                                       dwFormatType,
                                       dwFormatStrType,
                                       pFormatStruct,
                                       NULL,
                                       &cbPermitNeeded,
                                       IDS_NAME_CONSTRAINTS_PERMITTED,
                                       pInfo->cPermittedSubtree,
                                       pInfo->rgPermittedSubtree)) ||
        (!FormatNameConstraintsSubtree(dwCertEncodingType,
                                       dwFormatType,
                                       dwFormatStrType,
                                       pFormatStruct,
                                       NULL,
                                       &cbExcludeNeeded,
                                       IDS_NAME_CONSTRAINTS_EXCLUDED,
                                       pInfo->cExcludedSubtree,
                                       pInfo->rgExcludedSubtree)))
    {
        goto ErrorReturn;
    }

    //
    // Total length needed.
    //
    cbTotalNeeded = cbPermitNeeded + cbExcludeNeeded;
    if (0 == cbTotalNeeded)
    {
        *pcbFormat = cbTotalNeeded;
        goto SuccessReturn;
    }

    //
    // One char less after we concate both strings.
    //
    if (cbPermitNeeded > 0 && cbExcludeNeeded > 0)
    {
        cbTotalNeeded -= sizeof(WCHAR);

        //
        // If not multi-lines and both strings are present, allow 2 more 
        // chars for ", " to separate the strings.
        //
        if (!(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
        {
            cbTotalNeeded += sizeof(WCHAR) * wcslen(wszCOMMA);
        }
    }

    //
    // length only calculation?
    //
    if (NULL == pbFormat)
    {
        *pcbFormat = cbTotalNeeded;
        goto SuccessReturn;
    }
   
    //
    // Caller provided us with enough memory?
    //
    if (*pcbFormat < cbTotalNeeded)
    {
        *pcbFormat = cbTotalNeeded;
        goto MoreDataError;
    }

    //
    // Now format both subtrees.
    //
    if (!FormatNameConstraintsSubtree(dwCertEncodingType,
                                      dwFormatType,
                                      dwFormatStrType,
                                      pFormatStruct,
                                      pbFormat,
                                      &cbPermitNeeded,
                                      IDS_NAME_CONSTRAINTS_PERMITTED,
                                      pInfo->cPermittedSubtree,
                                      pInfo->rgPermittedSubtree))
    {
       goto ErrorReturn;
    }

    //
    // If not multi-lines and both strings are present, then add ", "
    // to separate them.
    //
    if (!(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE) &&
        (cbPermitNeeded > 0) && (cbExcludeNeeded > 0))
    {
        wcscat((LPWSTR) pbFormat, wszCOMMA);
    }

    pbFormat = (void *) ((BYTE *) pbFormat + wcslen((LPWSTR) pbFormat) * sizeof(WCHAR));

    if (!FormatNameConstraintsSubtree(dwCertEncodingType,
                                      dwFormatType,
                                      dwFormatStrType,
                                      pFormatStruct,
                                      pbFormat,
                                      &cbExcludeNeeded,
                                      IDS_NAME_CONSTRAINTS_EXCLUDED,
                                      pInfo->cExcludedSubtree,
                                      pInfo->rgExcludedSubtree))
    {
       goto ErrorReturn;
    }

    //
    // Copy the size needed.
    //
    *pcbFormat = cbTotalNeeded;

SuccessReturn:

    fResult = TRUE;

CommonReturn:

    //
    // Free resources.
    //
	if (pInfo)
    {
        free(pInfo);
    }

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg,E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
}

//+-----------------------------------------------------------------------------
//
//  FormatCertSrvPreviousCertHash      szOID_CERTSRV_PREVIOUS_CERT_HASH
//
//------------------------------------------------------------------------------

static BOOL
WINAPI
FormatCertSrvPreviousCertHash (
	DWORD       dwCertEncodingType,
	DWORD       dwFormatType,
	DWORD       dwFormatStrType,
	void       *pFormatStruct,
	LPCSTR      lpszStructType,
	const BYTE *pbEncoded,
	DWORD       cbEncoded,
	void       *pbFormat,
	DWORD      *pcbFormat)
{
	BOOL              fResult;
    DWORD             cbNeeded    = 0;
    CRYPT_DATA_BLOB * pInfo       = NULL;
    WCHAR           * pwszHex     = NULL;
    WCHAR           * pwszFormat  = NULL;
    BOOL              bMultiLines = dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE;

    //
	// Check input parameters.
    //
    if ((NULL == pbEncoded && 0 != cbEncoded) ||
        (NULL == pcbFormat) || (0 == cbEncoded))
	{
		goto InvalidArg;
	}

    //
    // Decode extension.
    //
    if (!DecodeGenericBLOB(dwCertEncodingType, 
                           X509_OCTET_STRING,
			               pbEncoded,
                           cbEncoded, 
                           (void **) &pInfo))
    {
        goto DecodeGenericError;
    }

    //
    // Get formatted hex string.
    //
    if(!FormatBytesToHex(0,
                         dwFormatType,
                         dwFormatStrType,
                         pFormatStruct,
                         NULL,
                         pInfo->pbData,
                         pInfo->cbData,
                         NULL,
	                     &cbNeeded))
    {
        goto FormatBytesToHexError;
    }

    if (!(pwszHex = (LPWSTR) malloc(cbNeeded)))
    {
        goto MemoryError;
    }

    if(!FormatBytesToHex(0,
                         dwFormatType,
                         dwFormatStrType,
                         pFormatStruct,
                         NULL,
                         pInfo->pbData,
                         pInfo->cbData,
                         pwszHex,
	                     &cbNeeded))
    {
        goto FormatBytesToHexError;
    }

    if (!FormatMessageUnicode(&pwszFormat, 
                              IDS_STRING, 
                              pwszHex,
                              bMultiLines ? wszCRLF : wszEMPTY))
    {
        goto FormatMessageError;
    }
    
    //
    // Total length needed.
    //
    cbNeeded = sizeof(WCHAR) * (wcslen(pwszFormat) + 1);

    //
    // Length only calculation?
    //
    if (NULL == pbFormat)
    {
        *pcbFormat = cbNeeded;
        goto SuccessReturn;
    }

    //
    // Caller provided us with enough memory?
    //
    if (*pcbFormat < cbNeeded)
    {
        *pcbFormat = cbNeeded;
        goto MoreDataError;
    }

    //
    // Copy size and data.
    //
    memcpy(pbFormat, pwszFormat, cbNeeded);
    *pcbFormat = cbNeeded;

SuccessReturn:

    fResult = TRUE;

CommonReturn:

	if (pInfo)
    {
        free(pInfo);
    }

    if (pwszHex)
    {
        free(pwszHex);
    }

    if (pwszFormat)
    {
        LocalFree((HLOCAL) pwszFormat);
    }

    return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg,E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatBytesToHexError);
TRACE_ERROR(FormatMessageError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
}

//+-----------------------------------------------------------------------------
//
//  FormatPolicyMappings               X509_POLICY_MAPPINGS
//                                     szOID_POLICY_MAPPINGS
//                                     szOID_APPLICATION_POLICY_MAPPINGS
//
//------------------------------------------------------------------------------

static BOOL
WINAPI
FormatPolicyMappings (
	DWORD       dwCertEncodingType,
	DWORD       dwFormatType,
	DWORD       dwFormatStrType,
	void       *pFormatStruct,
	LPCSTR      lpszStructType,
	const BYTE *pbEncoded,
	DWORD       cbEncoded,
	void       *pbFormat,
	DWORD      *pcbFormat)
{
	BOOL   fResult;
    DWORD  dwIndex     = 0;
    DWORD  cbNeeded    = 0;
    char   szEmpty[1]  = {'\0'};
    LPSTR  pszObjectId = NULL;
    LPWSTR pwszFormat  = NULL;
    LPWSTR pwszTemp    = NULL;
    LPWSTR pwszLine    = NULL;
    LPWSTR pwszPolicy  = NULL;
    BOOL   bMultiLines = dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE;
    CERT_POLICY_MAPPINGS_INFO * pInfo = NULL;

    //
	// Check input parameters.
    //
    if ((NULL == pbEncoded && 0 != cbEncoded) ||
        (NULL == pcbFormat) || (0 == cbEncoded))
	{
		goto InvalidArg;
	}

    //
    // Decode extension.
    //
    if (!DecodeGenericBLOB(dwCertEncodingType, 
                           X509_POLICY_MAPPINGS,
			               pbEncoded,
                           cbEncoded, 
                           (void **) &pInfo))
    {
        goto DecodeGenericError;
    }

    //
    // Make sure data is valid.
    //
    if (pInfo->cPolicyMapping && !pInfo->rgPolicyMapping)
    {
        goto BadDataError;
    }

    //
    // Initialize formatted string.
    //
    if (!(pwszFormat = (LPWSTR) malloc(sizeof(WCHAR))))
    {
        goto MemoryError;
    }
    *pwszFormat = NULL;

    //
    // Loop thru each mapping.
    //
    for (dwIndex = 0; dwIndex < pInfo->cPolicyMapping; dwIndex++)
    {
        //
        // Format Issuer Domain Policy, if available.
        //
        if (pInfo->rgPolicyMapping[dwIndex].pszIssuerDomainPolicy)
        {
            pszObjectId = pInfo->rgPolicyMapping[dwIndex].pszIssuerDomainPolicy;
        }
        else
        {
            pszObjectId = szEmpty;
        }

        if (!FormatObjectId(pszObjectId,
                            CRYPT_POLICY_OID_GROUP_ID,
                            FALSE,
                            &pwszPolicy))
        {
            goto FormatObjectIdError;
        }

        //
        // "[%1!d!]Issuer Domain=%2!s!%3!s!"
        //
        if (!FormatMessageUnicode(&pwszLine, 
                                  IDS_ISSUER_DOMAIN_POLICY,
                                  dwIndex + 1,
                                  pwszPolicy,
                                  bMultiLines ? wszCRLF : wszCOMMA))
        {
            goto FormatMessageError;
        }

        //
        // Reallocate and concate line to format buffer.
        //
        pwszTemp = (LPWSTR) realloc(pwszFormat, sizeof(WCHAR) * (wcslen(pwszFormat) + wcslen(pwszLine) + 1));
        if (NULL == pwszTemp)
        {
            goto MemoryError;
        }

        pwszFormat = pwszTemp;
        wcscat(pwszFormat, pwszLine);

        LocalFree((HLOCAL) pwszPolicy);
        pwszPolicy = NULL;

        LocalFree((HLOCAL) pwszLine);
        pwszLine = NULL;
 
        //
        // Format Subject Domain Policy, if available.
        //
        if (pInfo->rgPolicyMapping[dwIndex].pszSubjectDomainPolicy)
        {
            pszObjectId = pInfo->rgPolicyMapping[dwIndex].pszSubjectDomainPolicy;
        }
        else
        {
            pszObjectId = szEmpty;
        }

        if (!FormatObjectId(pszObjectId,
                            CRYPT_POLICY_OID_GROUP_ID,
                            FALSE,
                            &pwszPolicy))
        {
            goto FormatObjectIdError;
        }

        //
        // "%1!s!Subject Domain=%2!s!%3!s!"
        //
        if (!FormatMessageUnicode(&pwszLine, 
                                  IDS_SUBJECT_DOMAIN_POLICY,
                                  bMultiLines ? wszTAB : wszEMPTY,
                                  pwszPolicy,
                                  bMultiLines ? wszCRLF : (dwIndex + 1) < pInfo->cPolicyMapping ? wszCOMMA : wszEMPTY))
        {
            goto FormatMessageError;
        }

        //
        // Reallocate and concate line to format buffer.
        //
        pwszTemp = (LPWSTR) realloc(pwszFormat, sizeof(WCHAR) * (wcslen(pwszFormat) + wcslen(pwszLine) + 1));
        if (NULL == pwszTemp)
        {
            goto MemoryError;
        }

        pwszFormat = pwszTemp;
        wcscat(pwszFormat, pwszLine);

        LocalFree((HLOCAL) pwszPolicy);
        pwszPolicy = NULL;

        LocalFree((HLOCAL) pwszLine);
        pwszLine = NULL;
    }
    
    //
    // Total length needed.
    //
    cbNeeded = sizeof(WCHAR) * (wcslen(pwszFormat) + 1);

    //
    // Length only calculation?
    //
    if (NULL == pbFormat)
    {
        *pcbFormat = cbNeeded;
        goto SuccessReturn;
    }

    //
    // Caller provided us with enough memory?
    //
    if (*pcbFormat < cbNeeded)
    {
        *pcbFormat = cbNeeded;
        goto MoreDataError;
    }

    //
    // Copy size and data.
    //
    memcpy(pbFormat, pwszFormat, cbNeeded);
    *pcbFormat = cbNeeded;

SuccessReturn:

    fResult = TRUE;

CommonReturn:

    if (pwszLine)
    {
        LocalFree((HLOCAL) pwszLine);
    }

    if (pwszPolicy)
    {
        LocalFree((HLOCAL) pwszPolicy);
    }

    if (pwszFormat)
    {
        free(pwszFormat);
    }

	if (pInfo)
    {
        free(pInfo);
    }

    return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg,E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
SET_ERROR(BadDataError, E_POINTER);
TRACE_ERROR(FormatObjectIdError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatMessageError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
}

//+-----------------------------------------------------------------------------
//
//  FormatPolicyConstraints            X509_POLICY_CONSTRAINTS
//                                     szOID_POLICY_CONSTRAINTS
//                                     szOID_APPLICATION_POLICY_CONSTRAINTS
//
//------------------------------------------------------------------------------

static BOOL
WINAPI
FormatPolicyConstraints (
	DWORD       dwCertEncodingType,
	DWORD       dwFormatType,
	DWORD       dwFormatStrType,
	void       *pFormatStruct,
	LPCSTR      lpszStructType,
	const BYTE *pbEncoded,
	DWORD       cbEncoded,
	void       *pbFormat,
	DWORD      *pcbFormat)
{
	BOOL    fResult;
    DWORD   cbNeeded    = 0;
    LPWSTR  pwszFormat  = NULL;
    LPWSTR  pwszTemp    = NULL;
    LPWSTR  pwszLine    = NULL;
    BOOL    bMultiLines = dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE;
    CERT_POLICY_CONSTRAINTS_INFO * pInfo = NULL;

    //
	// Check input parameters.
    //
    if ((NULL == pbEncoded && 0 != cbEncoded) ||
        (NULL == pcbFormat) || (0 == cbEncoded))
	{
		goto InvalidArg;
	}

    //
    // Decode extension.
    //
    if (!DecodeGenericBLOB(dwCertEncodingType, 
                           X509_POLICY_CONSTRAINTS,
			               pbEncoded,
                           cbEncoded, 
                           (void **) &pInfo))
    {
        goto DecodeGenericError;
    }

    //
    // Initialize formatted string.
    //
    if (!(pwszFormat = (LPWSTR) malloc(sizeof(WCHAR))))
    {
        goto MemoryError;
    }
    *pwszFormat = NULL;

    //
    // Format Required Explicit Policy Skip Certs, if available.
    //
    if (pInfo->fRequireExplicitPolicy)
    {
        //
        // "Required Explicit Policy Skip Certs=%1!d!%2!s!"
        //
        if (!FormatMessageUnicode(&pwszLine, 
                                  IDS_REQUIRED_EXPLICIT_POLICY_SKIP_CERTS,
                                  pInfo->dwRequireExplicitPolicySkipCerts,
                                  bMultiLines ? wszCRLF : wszCOMMA))
        {
            goto FormatMessageError;
        }

        //
        // Reallocate and concate line to format buffer.
        //
        pwszTemp = (LPWSTR) realloc(pwszFormat, sizeof(WCHAR) * (wcslen(pwszFormat) + wcslen(pwszLine) + 1));
        if (NULL == pwszTemp)
        {
            goto MemoryError;
        }

        pwszFormat = pwszTemp;
        wcscat(pwszFormat, pwszLine);

        LocalFree((HLOCAL) pwszLine);
        pwszLine = NULL;
    }

    //
    // Format Inhibit Policy Mapping Skip Certs, if available.
    //
    if (pInfo->fInhibitPolicyMapping)
    {
        //
        // "Inhibit Policy Mapping Skip Certs=%1!d!%2!s!"
        //
        if (!FormatMessageUnicode(&pwszLine, 
                                  IDS_INHIBIT_POLICY_MAPPING_SKIP_CERTS,
                                  pInfo->dwInhibitPolicyMappingSkipCerts,
                                  bMultiLines ? wszCRLF : wszEMPTY))
        {
            goto FormatMessageError;
        }

        //
        // Reallocate and concate line to format buffer.
        //
        pwszTemp = (LPWSTR) realloc(pwszFormat, sizeof(WCHAR) * (wcslen(pwszFormat) + wcslen(pwszLine) + 1));
        if (NULL == pwszTemp)
        {
            goto MemoryError;
        }

        pwszFormat = pwszTemp;
        wcscat(pwszFormat, pwszLine);

        LocalFree((HLOCAL) pwszLine);
        pwszLine = NULL;
    }
    
    //
    // Total length needed.
    //
    cbNeeded = sizeof(WCHAR) * (wcslen(pwszFormat) + 1);

    //
    // Length only calculation?
    //
    if (NULL == pbFormat)
    {
        *pcbFormat = cbNeeded;
        goto SuccessReturn;
    }

    //
    // Caller provided us with enough memory?
    //
    if (*pcbFormat < cbNeeded)
    {
        *pcbFormat = cbNeeded;
        goto MoreDataError;
    }

    //
    // Copy size and data.
    //
    memcpy(pbFormat, pwszFormat, cbNeeded);
    *pcbFormat = cbNeeded;

SuccessReturn:

    fResult = TRUE;

CommonReturn:

    if (pwszLine)
    {
        LocalFree((HLOCAL) pwszLine);
    }

    if (pwszFormat)
    {
        free(pwszFormat);
    }

	if (pInfo)
    {
        free(pInfo);
    }

    return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg,E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatMessageError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
}

//+-----------------------------------------------------------------------------
//
//  FormatCertificateTemplate          X509_CERTIFICATE_TEMPLATE
//                                     szOID_CERTIFICATE_TEMPLATE
//
//------------------------------------------------------------------------------

static BOOL
WINAPI
FormatCertificateTemplate (
	DWORD       dwCertEncodingType,
	DWORD       dwFormatType,
	DWORD       dwFormatStrType,
	void       *pFormatStruct,
	LPCSTR      lpszStructType,
	const BYTE *pbEncoded,
	DWORD       cbEncoded,
	void       *pbFormat,
	DWORD      *pcbFormat)
{
	BOOL    fResult;
    DWORD   cbNeeded    = 0;
    LPWSTR  pwszFormat  = NULL;
    LPWSTR  pwszObjId   = NULL;
    LPWSTR  pwszTemp    = NULL;
    LPWSTR  pwszLine    = NULL;
    BOOL    bMultiLines = dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE;
    CERT_TEMPLATE_EXT * pInfo = NULL;

    //
	// Check input parameters.
    //
    if ((NULL == pbEncoded && 0 != cbEncoded) ||
        (NULL == pcbFormat) || (0 == cbEncoded))
	{
		goto InvalidArg;
	}

    //
    // Decode extension.
    //
    if (!DecodeGenericBLOB(dwCertEncodingType, 
                           X509_CERTIFICATE_TEMPLATE,
			               pbEncoded,
                           cbEncoded, 
                           (void **) &pInfo))
    {
        goto DecodeGenericError;
    }

    //
    // Initialize formatted string.
    //
    if (!(pwszFormat = (LPWSTR) malloc(sizeof(WCHAR))))
    {
        goto MemoryError;
    }
    *pwszFormat = NULL;

#if (0) //DSIE: Bug 157853
    //
    // Convert OID to Unicode.
    //
    if (!AllocateAnsiToUnicode(pInfo->pszObjId, &pwszObjId))
    {
        goto AnsiToUnicodeError;
    }
#else
    if (!FormatObjectId(pInfo->pszObjId,
                        CRYPT_TEMPLATE_OID_GROUP_ID,
                        FALSE,
                        &pwszObjId))
    {
        goto FormatObjectIdError;
    }
#endif

    //
    // "Template=%1!s!%2!s!Major Version Number=%3!d!%4!s!"
    //
    if (!FormatMessageUnicode(&pwszLine, 
                              IDS_CERTIFICATE_TEMPLATE_MAJOR_VERSION,
                              pwszObjId,
                              bMultiLines ? wszCRLF : wszCOMMA,
                              pInfo->dwMajorVersion,
                              bMultiLines ? wszCRLF : wszCOMMA))
    {
        goto FormatMessageError;
    }

    //
    // Reallocate and concate line to format buffer.
    //
    pwszTemp = (LPWSTR) realloc(pwszFormat, sizeof(WCHAR) * (wcslen(pwszFormat) + wcslen(pwszLine) + 1));
    if (NULL == pwszTemp)
    {
        goto MemoryError;
    }

    pwszFormat = pwszTemp;
    wcscat(pwszFormat, pwszLine);

    LocalFree((HLOCAL) pwszLine);
    pwszLine = NULL;

    //
    // Format Minor Version, if available.
    //
    if (pInfo->fMinorVersion)
    {
        //
        // "Minor Version Number=%1!d!%2!s!"
        //
        if (!FormatMessageUnicode(&pwszLine, 
                                  IDS_CERTIFICATE_TEMPLATE_MINOR_VERSION,
                                  pInfo->dwMinorVersion,
                                  bMultiLines ? wszCRLF : wszEMPTY))
        {
            goto FormatMessageError;
        }

        //
        // Reallocate and concate line to format buffer.
        //
        pwszTemp = (LPWSTR) realloc(pwszFormat, sizeof(WCHAR) * (wcslen(pwszFormat) + wcslen(pwszLine) + 1));
        if (NULL == pwszTemp)
        {
            goto MemoryError;
        }

        pwszFormat = pwszTemp;
        wcscat(pwszFormat, pwszLine);

        LocalFree((HLOCAL) pwszLine);
        pwszLine = NULL;
    }
    
    //
    // Total length needed.
    //
    cbNeeded = sizeof(WCHAR) * (wcslen(pwszFormat) + 1);

    //
    // Length only calculation?
    //
    if (NULL == pbFormat)
    {
        *pcbFormat = cbNeeded;
        goto SuccessReturn;
    }

    //
    // Caller provided us with enough memory?
    //
    if (*pcbFormat < cbNeeded)
    {
        *pcbFormat = cbNeeded;
        goto MoreDataError;
    }

    //
    // Copy size and data.
    //
    memcpy(pbFormat, pwszFormat, cbNeeded);
    *pcbFormat = cbNeeded;

SuccessReturn:

    fResult = TRUE;

CommonReturn:

    if (pwszObjId)
    {
#if (0) //DSIE: Bug 157853
        free(pwszObjId);
#else
        LocalFree((HLOCAL) pwszObjId);
#endif
    }

    if (pwszLine)
    {
        LocalFree((HLOCAL) pwszLine);
    }

    if (pwszFormat)
    {
        free(pwszFormat);
    }

	if (pInfo)
    {
        free(pInfo);
    }

    return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg,E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
#if (0) //DSIE: Bug 157853
TRACE_ERROR(AnsiToUnicodeError);
#else
TRACE_ERROR(FormatObjectIdError);
#endif
TRACE_ERROR(FormatMessageError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
}



//--------------------------------------------------------------------------
//
//	 FormatXCertDistPoints:   X509_CROSS_CERT_DIST_POINTS
//                            szOID_CROSS_CERT_DIST_POINTS
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatXCertDistPoints(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	LPWSTR					        pwszFormat=NULL;
    LPWSTR                          pwszDeltaTime=NULL;
    LPWSTR                          pwszEntryLine=NULL;
    LPWSTR                          pwszDistPoint=NULL;

	PCROSS_CERT_DIST_POINTS_INFO    pInfo=NULL;

	DWORD					        cbNeeded=0;
    DWORD                           dwIndex=0;
	BOOL					        fResult=FALSE;
    BOOL                            bMultiLines = dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE;
                                    
    LPWSTR                          pwszTemp;
    
	//check for input parameters
	if ((NULL==pbEncoded && cbEncoded!=0) || (NULL==pcbFormat))
		goto InvalidArg;

	if (cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}
  
    if (!DecodeGenericBLOB(dwCertEncodingType, lpszStructType,
			pbEncoded, cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

    //
    // "Delta Sync Time=%1!d! seconds%2!s!"
    //
    if (!FormatMessageUnicode(&pwszDeltaTime, 
                              IDS_XCERT_DELTA_SYNC_TIME,
                              pInfo->dwSyncDeltaTime,
                              bMultiLines ? wszCRLF : wszCOMMA))
    {
        goto FormatMessageError;
    }

    pwszFormat=(LPWSTR)malloc(sizeof(WCHAR) * (wcslen(pwszDeltaTime)+1));
    if(NULL==pwszFormat)
        goto MemoryError;

    wcscpy(pwszFormat, pwszDeltaTime);

    //format the xcert dist point entries.
    for (dwIndex=0; dwIndex<pInfo->cDistPoint; dwIndex++)
    {
        cbNeeded=0;
        if (!FormatAltNameInfo(dwCertEncodingType,
                               dwFormatType,
                               dwFormatStrType,
                               pFormatStruct,
                               bMultiLines ? IDS_ONE_TAB : 0,
                               FALSE,
                               &pInfo->rgDistPoint[dwIndex],
                               NULL,
                               &cbNeeded))
            goto FormatAltNameError;

        pwszEntryLine=(LPWSTR)malloc(cbNeeded);
        if (NULL==pwszEntryLine)
            goto MemoryError;

        if (!FormatAltNameInfo(dwCertEncodingType,
                               dwFormatType,
                               dwFormatStrType,
                               pFormatStruct,
                               bMultiLines ? IDS_ONE_TAB : 0,
                               FALSE,
                               &pInfo->rgDistPoint[dwIndex],
                               pwszEntryLine,
                               &cbNeeded))
            goto FormatAltNameError;

        //"[%1!d!]Cross-Certificate Distribution Point: %2!s!%3!s!%4!s!"
        if(!FormatMessageUnicode(&pwszDistPoint,
                                 IDS_XCERT_DIST_POINT,
                                 dwIndex + 1,
                                 bMultiLines ? wszCRLF : wszEMPTY,
                                 pwszEntryLine,
                                 bMultiLines || (dwIndex == pInfo->cDistPoint - 1) ? wszCRLF : wszCOMMA))
            goto FormatMessageError;

        pwszTemp=(LPWSTR)realloc(pwszFormat, sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(pwszDistPoint)+1));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwszFormat = pwszTemp;

        wcscat(pwszFormat, pwszDistPoint);

        //free memory
        free(pwszEntryLine);
        pwszEntryLine=NULL;

        LocalFree((HLOCAL) pwszDistPoint);
        pwszDistPoint=NULL;
    }

    if(0==wcslen(pwszFormat))
    {
        //no data
        pwszFormat=(LPWSTR)malloc(sizeof(WCHAR)*(NO_INFO_SIZE+1));
        if(NULL==pwszFormat)
            goto MemoryError;

        if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, pwszFormat, NO_INFO_SIZE))
            goto LoadStringError;

    }

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}

	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;	

CommonReturn:
    if(pwszDeltaTime)
        LocalFree((HLOCAL) pwszDeltaTime);

    if(pwszDistPoint)
        LocalFree((HLOCAL) pwszDistPoint);

    if(pwszEntryLine)
        free(pwszEntryLine);

    if (pwszFormat)
        free(pwszFormat);

    if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:


	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(LoadStringError);
TRACE_ERROR(FormatMessageError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatAltNameError);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\logstor.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       logstor.cpp
//
//  Contents:   Registry Certificate Store Provider APIs
//
//  Functions:  I_RegStoreDllMain
//              I_CertDllOpenRegStoreProv
//              CertRegisterSystemStore
//              CertRegisterPhysicalStore
//              CertUnregisterSystemStore
//              CertUnregisterPhysicalStore
//              CertEnumSystemStoreLocation
//              CertEnumSystemStore
//              CertEnumPhysicalStore
//              I_CertDllOpenSystemRegistryStoreProvW
//              I_CertDllOpenSystemRegistryStoreProvA
//              I_CertDllOpenSystemStoreProvW
//              I_CertDllOpenSystemStoreProvA
//              I_CertDllOpenPhysicalStoreProvW
//
//  History:    28-Dec-96    philh   created
//              13-Aug-96    philh   added change notify and resync support
//              24-Aug-96    philh   added logical store support
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>


#ifdef STATIC
#undef STATIC
#endif
#define STATIC

// Note, this flag must not collide with CertControlStore dwFlags
#define REG_STORE_CTRL_CANCEL_NOTIFY_FLAG 0x80000000


// Pointer to an allocated LONG containing thread's enum recursion depth
static HCRYPTTLS hTlsEnumPhysicalStoreDepth;
#define MAX_ENUM_PHYSICAL_STORE_DEPTH       20

#define SYSTEM_STORE_REGPATH        L"Software\\Microsoft\\SystemCertificates"
#define PHYSICAL_STORES_SUBKEY_NAME L"PhysicalStores"
#define CONST_OID_STR_PREFIX_CHAR   '#'
#define SERVICES_REGPATH            L"Software\\Microsoft\\Cryptography\\Services"
#define SYSTEM_CERTIFICATES_SUBKEY_NAME L"SystemCertificates"
#define GROUP_POLICY_STORE_REGPATH  L"Software\\Policies\\Microsoft\\SystemCertificates"
#define ENTERPRISE_STORE_REGPATH    L"Software\\Microsoft\\EnterpriseCertificates"

#define ROAMING_MY_STORE_SUBDIR     L"Microsoft\\SystemCertificates\\My"
#define ROAMING_REQUEST_STORE_SUBDIR L"Microsoft\\SystemCertificates\\Request"

#define REGISTER_FLAGS_MASK         (CERT_SYSTEM_STORE_MASK | \
                                        CERT_STORE_BACKUP_RESTORE_FLAG | \
                                        CERT_STORE_CREATE_NEW_FLAG)
#define UNREGISTER_FLAGS_MASK       (CERT_SYSTEM_STORE_MASK | \
                                        CERT_STORE_DELETE_FLAG | \
                                        CERT_STORE_BACKUP_RESTORE_FLAG | \
                                        CERT_STORE_OPEN_EXISTING_FLAG)
#define ENUM_FLAGS_MASK             (CERT_SYSTEM_STORE_MASK | \
                                        CERT_STORE_OPEN_EXISTING_FLAG | \
                                        CERT_STORE_MAXIMUM_ALLOWED_FLAG | \
                                        CERT_STORE_SHARE_CONTEXT_FLAG | \
                                        CERT_STORE_SHARE_STORE_FLAG | \
                                        CERT_STORE_BACKUP_RESTORE_FLAG | \
                                        CERT_STORE_READONLY_FLAG)

#define OPEN_REG_FLAGS_MASK         (CERT_STORE_CREATE_NEW_FLAG | \
                                        CERT_STORE_DELETE_FLAG | \
                                        CERT_STORE_OPEN_EXISTING_FLAG | \
                                        CERT_STORE_MAXIMUM_ALLOWED_FLAG | \
                                        CERT_STORE_SHARE_CONTEXT_FLAG | \
                                        CERT_STORE_SHARE_STORE_FLAG | \
                                        CERT_STORE_BACKUP_RESTORE_FLAG | \
                                        CERT_STORE_READONLY_FLAG | \
                                        CERT_STORE_MANIFOLD_FLAG | \
                                        CERT_STORE_UPDATE_KEYID_FLAG | \
                                        CERT_STORE_ENUM_ARCHIVED_FLAG | \
                                        CERT_STORE_SET_LOCALIZED_NAME_FLAG | \
                                        CERT_STORE_NO_CRYPT_RELEASE_FLAG | \
                                        CERT_REGISTRY_STORE_REMOTE_FLAG | \
                                        CERT_REGISTRY_STORE_SERIALIZED_FLAG | \
                                        CERT_REGISTRY_STORE_ROAMING_FLAG | \
                                        CERT_REGISTRY_STORE_CLIENT_GPT_FLAG | \
                                        CERT_REGISTRY_STORE_MY_IE_DIRTY_FLAG | \
                                        CERT_REGISTRY_STORE_LM_GPT_FLAG)
#define OPEN_SYS_FLAGS_MASK         (CERT_SYSTEM_STORE_MASK | \
                                        CERT_STORE_CREATE_NEW_FLAG | \
                                        CERT_STORE_DELETE_FLAG | \
                                        CERT_STORE_OPEN_EXISTING_FLAG | \
                                        CERT_STORE_MAXIMUM_ALLOWED_FLAG | \
                                        CERT_STORE_SHARE_CONTEXT_FLAG | \
                                        CERT_STORE_SHARE_STORE_FLAG | \
                                        CERT_STORE_BACKUP_RESTORE_FLAG | \
                                        CERT_STORE_READONLY_FLAG | \
                                        CERT_STORE_MANIFOLD_FLAG | \
                                        CERT_STORE_UPDATE_KEYID_FLAG | \
                                        CERT_STORE_ENUM_ARCHIVED_FLAG | \
                                        CERT_STORE_SET_LOCALIZED_NAME_FLAG | \
                                        CERT_STORE_NO_CRYPT_RELEASE_FLAG)
#define OPEN_PHY_FLAGS_MASK         (CERT_SYSTEM_STORE_MASK | \
                                        CERT_STORE_DELETE_FLAG | \
                                        CERT_STORE_OPEN_EXISTING_FLAG | \
                                        CERT_STORE_MAXIMUM_ALLOWED_FLAG | \
                                        CERT_STORE_SHARE_CONTEXT_FLAG | \
                                        CERT_STORE_SHARE_STORE_FLAG | \
                                        CERT_STORE_BACKUP_RESTORE_FLAG | \
                                        CERT_STORE_READONLY_FLAG | \
                                        CERT_STORE_MANIFOLD_FLAG | \
                                        CERT_STORE_UPDATE_KEYID_FLAG | \
                                        CERT_STORE_ENUM_ARCHIVED_FLAG | \
                                        CERT_STORE_SET_LOCALIZED_NAME_FLAG | \
                                        CERT_STORE_NO_CRYPT_RELEASE_FLAG)
//+-------------------------------------------------------------------------
//  Common, global logical store critical section. Used by:
//      GptStore, Win95Store, RoamingStore.
//--------------------------------------------------------------------------
static CRITICAL_SECTION ILS_CriticalSection;


//+-------------------------------------------------------------------------
//  Registry Store Context SubKeys
//--------------------------------------------------------------------------
#define CONTEXT_COUNT       3
static const LPCWSTR rgpwszContextSubKeyName[CONTEXT_COUNT] = {
    L"Certificates",
    L"CRLs",
    L"CTLs"
};

#define KEYID_CONTEXT_NAME          L"Keys"

static DWORD rgdwContextTypeFlags[CONTEXT_COUNT] = {
    CERT_STORE_CERTIFICATE_CONTEXT_FLAG,
    CERT_STORE_CRL_CONTEXT_FLAG,
    CERT_STORE_CTL_CONTEXT_FLAG
};

#define MY_SYSTEM_INDEX         0
#define ROOT_SYSTEM_INDEX       1
#define TRUST_SYSTEM_INDEX      2
#define CA_SYSTEM_INDEX         3
#define USER_DS_SYSTEM_INDEX    4
#define TRUST_PUB_SYSTEM_INDEX  5
#define DISALLOWED_SYSTEM_INDEX 6
#define AUTH_ROOT_SYSTEM_INDEX  7
#define TRUST_PEOPLE_SYSTEM_INDEX 8

#define MY_SYSTEM_FLAG          (1 << MY_SYSTEM_INDEX)
#define ROOT_SYSTEM_FLAG        (1 << ROOT_SYSTEM_INDEX)
#define TRUST_SYSTEM_FLAG       (1 << TRUST_SYSTEM_INDEX)
#define CA_SYSTEM_FLAG          (1 << CA_SYSTEM_INDEX)
#define USER_DS_SYSTEM_FLAG     (1 << USER_DS_SYSTEM_INDEX)
#define TRUST_PUB_SYSTEM_FLAG   (1 << TRUST_PUB_SYSTEM_INDEX)
#define DISALLOWED_SYSTEM_FLAG  (1 << DISALLOWED_SYSTEM_INDEX)
#define AUTH_ROOT_SYSTEM_FLAG   (1 << AUTH_ROOT_SYSTEM_INDEX)
#define TRUST_PEOPLE_SYSTEM_FLAG (1 << TRUST_PEOPLE_SYSTEM_INDEX)

#define COMMON_SYSTEM_FLAGS     ( \
    MY_SYSTEM_FLAG | \
    ROOT_SYSTEM_FLAG | \
    TRUST_SYSTEM_FLAG | \
    CA_SYSTEM_FLAG | \
    TRUST_PUB_SYSTEM_FLAG | \
    DISALLOWED_SYSTEM_FLAG | \
    AUTH_ROOT_SYSTEM_FLAG | \
    TRUST_PEOPLE_SYSTEM_FLAG \
    )

#define wsz_MY_STORE            L"My"
#define wsz_ROOT_STORE          L"Root"
#define wsz_TRUST_STORE         L"Trust"
#define wsz_CA_STORE            L"CA"
#define wsz_USER_DS_STORE       L"UserDS"
#define wsz_TRUST_PUB_STORE     L"TrustedPublisher"
#define wsz_DISALLOWED_STORE    L"Disallowed"
#define wsz_AUTH_ROOT_STORE     L"AuthRoot"
#define wsz_TRUST_PEOPLE_STORE  L"TrustedPeople"
static LPCWSTR rgpwszPredefinedSystemStore[] = {
    wsz_MY_STORE,
    wsz_ROOT_STORE,
    wsz_TRUST_STORE,
    wsz_CA_STORE,
    wsz_USER_DS_STORE,
    wsz_TRUST_PUB_STORE,
    wsz_DISALLOWED_STORE,
    wsz_AUTH_ROOT_STORE,
    wsz_TRUST_PEOPLE_STORE
};
#define NUM_PREDEFINED_SYSTEM_STORE (sizeof(rgpwszPredefinedSystemStore) / \
                                        sizeof(rgpwszPredefinedSystemStore[0]))


#define wsz_REQUEST_STORE     L"Request"

#define DEFAULT_PHYSICAL_INDEX          0
#define AUTH_ROOT_PHYSICAL_INDEX        1
#define GROUP_POLICY_PHYSICAL_INDEX     2
#define LOCAL_MACHINE_PHYSICAL_INDEX    3
#define DS_USER_CERT_PHYSICAL_INDEX     4
#define LMGP_PHYSICAL_INDEX             5
#define ENTERPRISE_PHYSICAL_INDEX       6
#define NUM_PREDEFINED_PHYSICAL         7

#define DEFAULT_PHYSICAL_FLAG           (1 << DEFAULT_PHYSICAL_INDEX)
#define AUTH_ROOT_PHYSICAL_FLAG         (1 << AUTH_ROOT_PHYSICAL_INDEX)
#define GROUP_POLICY_PHYSICAL_FLAG      (1 << GROUP_POLICY_PHYSICAL_INDEX)
#define LOCAL_MACHINE_PHYSICAL_FLAG     (1 << LOCAL_MACHINE_PHYSICAL_INDEX)
#define DS_USER_CERT_PHYSICAL_FLAG      (1 << DS_USER_CERT_PHYSICAL_INDEX)
#define LMGP_PHYSICAL_FLAG              (1 << LMGP_PHYSICAL_INDEX)
#define ENTERPRISE_PHYSICAL_FLAG        (1 << ENTERPRISE_PHYSICAL_INDEX)

static LPCWSTR rgpwszPredefinedPhysical[NUM_PREDEFINED_PHYSICAL] = {
    CERT_PHYSICAL_STORE_DEFAULT_NAME,
    CERT_PHYSICAL_STORE_AUTH_ROOT_NAME,
    CERT_PHYSICAL_STORE_GROUP_POLICY_NAME,
    CERT_PHYSICAL_STORE_LOCAL_MACHINE_NAME,
    CERT_PHYSICAL_STORE_DS_USER_CERTIFICATE_NAME,
    CERT_PHYSICAL_STORE_LOCAL_MACHINE_GROUP_POLICY_NAME,
    CERT_PHYSICAL_STORE_ENTERPRISE_NAME,
};

#define NOT_IN_REGISTRY_SYSTEM_STORE_LOCATION_FLAG  0x1
#define REMOTABLE_SYSTEM_STORE_LOCATION_FLAG        0x2
#define SERIALIZED_SYSTEM_STORE_LOCATION_FLAG       0x4
#define LM_SYSTEM_STORE_LOCATION_FLAG               0x8

typedef struct _SYSTEM_STORE_LOCATION_INFO {
    DWORD       dwFlags;
    DWORD       dwPredefinedSystemFlags;
    DWORD       dwPredefinedPhysicalFlags;
} SYSTEM_STORE_LOCATION_INFO, *PSYSTEM_STORE_LOCATION_INFO;


static const SYSTEM_STORE_LOCATION_INFO rgSystemStoreLocationInfo[] = {
    //  Not Defined                                     0
    NOT_IN_REGISTRY_SYSTEM_STORE_LOCATION_FLAG,
    0,
    0,

    //  CERT_SYSTEM_STORE_CURRENT_USER_ID               1
    0,
    COMMON_SYSTEM_FLAGS | USER_DS_SYSTEM_FLAG,
    DEFAULT_PHYSICAL_FLAG | GROUP_POLICY_PHYSICAL_FLAG |
        LOCAL_MACHINE_PHYSICAL_FLAG,

    // CERT_SYSTEM_STORE_LOCAL_MACHINE_ID               2
    LM_SYSTEM_STORE_LOCATION_FLAG | REMOTABLE_SYSTEM_STORE_LOCATION_FLAG,
    COMMON_SYSTEM_FLAGS,
    DEFAULT_PHYSICAL_FLAG | GROUP_POLICY_PHYSICAL_FLAG |
        ENTERPRISE_PHYSICAL_FLAG,

    //  Not Defined                                     3
    NOT_IN_REGISTRY_SYSTEM_STORE_LOCATION_FLAG,
    0,
    0,

    // CERT_SYSTEM_STORE_CURRENT_SERVICE_ID             4
    LM_SYSTEM_STORE_LOCATION_FLAG,
    COMMON_SYSTEM_FLAGS,
    DEFAULT_PHYSICAL_FLAG | LOCAL_MACHINE_PHYSICAL_FLAG,

    // CERT_SYSTEM_STORE_SERVICES_ID                    5
    LM_SYSTEM_STORE_LOCATION_FLAG | REMOTABLE_SYSTEM_STORE_LOCATION_FLAG,
    COMMON_SYSTEM_FLAGS,
    DEFAULT_PHYSICAL_FLAG | LOCAL_MACHINE_PHYSICAL_FLAG,

    // CERT_SYSTEM_STORE_USERS_ID                       6
    REMOTABLE_SYSTEM_STORE_LOCATION_FLAG,
    COMMON_SYSTEM_FLAGS,
    DEFAULT_PHYSICAL_FLAG | LOCAL_MACHINE_PHYSICAL_FLAG,

    // CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY_ID   7
    //SERIALIZED_SYSTEM_STORE_LOCATION_FLAG,
    0,
    COMMON_SYSTEM_FLAGS,
    DEFAULT_PHYSICAL_FLAG,

    // CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY_ID  8
    //SERIALIZED_SYSTEM_STORE_LOCATION_FLAG |
        LM_SYSTEM_STORE_LOCATION_FLAG | REMOTABLE_SYSTEM_STORE_LOCATION_FLAG,
    COMMON_SYSTEM_FLAGS,
    DEFAULT_PHYSICAL_FLAG,

    // CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE_ID    9
    LM_SYSTEM_STORE_LOCATION_FLAG | REMOTABLE_SYSTEM_STORE_LOCATION_FLAG,
    COMMON_SYSTEM_FLAGS,
    DEFAULT_PHYSICAL_FLAG
};

#define NUM_SYSTEM_STORE_LOCATION   (sizeof(rgSystemStoreLocationInfo) / \
                                        sizeof(rgSystemStoreLocationInfo[0]))

#define CURRENT_USER_ROOT_PHYSICAL_FLAGS ( \
    DEFAULT_PHYSICAL_FLAG | \
    LOCAL_MACHINE_PHYSICAL_FLAG \
    )

#define LOCAL_MACHINE_ROOT_PHYSICAL_FLAGS ( \
    DEFAULT_PHYSICAL_FLAG | \
    AUTH_ROOT_PHYSICAL_FLAG | \
    GROUP_POLICY_PHYSICAL_FLAG | \
    ENTERPRISE_PHYSICAL_FLAG \
    )

#define USERS_ROOT_PHYSICAL_FLAGS ( \
    LOCAL_MACHINE_PHYSICAL_FLAG \
    )

#define MY_PHYSICAL_FLAGS ( \
    DEFAULT_PHYSICAL_FLAG \
    )

#define USER_DS_PHYSICAL_FLAGS ( \
    DS_USER_CERT_PHYSICAL_FLAG \
    )

#define CURRENT_USER_TRUST_PUB_PHYSICAL_FLAGS ( \
    DEFAULT_PHYSICAL_FLAG | \
    LOCAL_MACHINE_PHYSICAL_FLAG | \
    GROUP_POLICY_PHYSICAL_FLAG \
    )

#define LOCAL_MACHINE_TRUST_PUB_PHYSICAL_FLAGS ( \
    DEFAULT_PHYSICAL_FLAG | \
    GROUP_POLICY_PHYSICAL_FLAG | \
    ENTERPRISE_PHYSICAL_FLAG \
    )


#define sz_CRYPTNET_DLL             "cryptnet.dll"
#define sz_GetUserDsStoreUrl        "I_CryptNetGetUserDsStoreUrl"
typedef BOOL (WINAPI *PFN_GET_USER_DS_STORE_URL)(
          IN LPWSTR pwszUserAttribute,
          OUT LPWSTR* ppwszUrl
          );

#define wsz_USER_CERTIFICATE_ATTR   L"userCertificate"


#define PHYSICAL_NAME_INDEX     0
#define SYSTEM_NAME_INDEX       1
#define SERVICE_NAME_INDEX      2
#define USER_NAME_INDEX         2
#define COMPUTER_NAME_INDEX     3
#define SYSTEM_NAME_PATH_COUNT  4

#define DEFAULT_USER_NAME       L".Default"

typedef struct _SYSTEM_NAME_INFO {
    LPWSTR      rgpwszName[SYSTEM_NAME_PATH_COUNT];
    // non-NULL for relocated store. Note hKeyBase isn't opened and
    // doesn't need to be closed
    HKEY        hKeyBase;
} SYSTEM_NAME_INFO, *PSYSTEM_NAME_INFO;


typedef struct _REG_STORE REG_STORE, *PREG_STORE;

typedef struct _ILS_RESYNC_ENTRY {
    HANDLE              hOrigEvent;

    // hDupEvent is NULL for CERT_STORE_CTRL_INHIBIT_DUPLICATE_HANDLE_FLAG
    HANDLE              hDupEvent;
    PREG_STORE          pRegStore;
} ILS_RESYNC_ENTRY, *PILS_RESYNC_ENTRY;

#define REG_CHANGE_INFO_TYPE    1
#define CU_GPT_CHANGE_INFO_TYPE 2
#define LM_GPT_CHANGE_INFO_TYPE 3

typedef struct _REGISTRY_STORE_CHANGE_INFO {
    // REG_CHANGE_INFO_TYPE
    DWORD               dwType;
    HANDLE              hChange;
    HANDLE              hRegWaitFor;
    DWORD               cNotifyEntry;
    PILS_RESYNC_ENTRY   rgNotifyEntry;
} REGISTRY_STORE_CHANGE_INFO, *PREGISTRY_STORE_CHANGE_INFO;

typedef struct _GPT_STORE_CHANGE_INFO {
    // CU_GPT_CHANGE_INFO_TYPE or LM_GPT_CHANGE_INFO_TYPE
    DWORD               dwType;
    HKEY                hKeyBase;       // not duplicated
    PREG_STORE          pRegStore;      // NULL for LM_GPT_CHANGE_INFO_TYPE

    HKEY                hPoliciesKey;
    HANDLE              hPoliciesEvent;
    HANDLE              hRegWaitFor;
    HANDLE              hGPNotificationEvent;
    DWORD               cNotifyEntry;
    PILS_RESYNC_ENTRY   rgNotifyEntry;
} GPT_STORE_CHANGE_INFO, *PGPT_STORE_CHANGE_INFO;

//+-------------------------------------------------------------------------
//  Registry Store Provider handle information
//
//  hMyNotifyChange is our internal NotifyChange event handle.
//--------------------------------------------------------------------------
struct _REG_STORE {
    HCERTSTORE          hCertStore;         // not duplicated
    CRITICAL_SECTION    CriticalSection;
    HANDLE              hMyNotifyChange;
    BOOL                fResync;            // when set, ignore callback deletes
    HKEY                hKey;
    DWORD               dwFlags;

    // Following field is applicable to the CurrentUser "Root" store
    BOOL                fProtected;

    // Following field is applicable when
    // CERT_REGISTRY_STORE_SERIALIZED_FLAG is set in dwFlags
    BOOL                fTouched;      // set for write, delete or set property

    union {
        // Following field is applicable when
        // CERT_REGISTRY_STORE_CLIENT_GPT_FLAG is set in dwFlags
        CERT_REGISTRY_STORE_CLIENT_GPT_PARA GptPara;

        // Following field is applicable when
        // CERT_REGISTRY_STORE_ROAMING_FLAG is set in dwFlags
        LPWSTR              pwszStoreDirectory;
    };

    union {
        // Following field is applicable for change notify of registry or
        // roaming file store
        PREGISTRY_STORE_CHANGE_INFO pRegistryStoreChangeInfo;

        // Following field is applicable for change notify of CU GPT store
        PGPT_STORE_CHANGE_INFO      pGptStoreChangeInfo;
    };
};


typedef struct _ENUM_SYSTEM_STORE_LOCATION_INFO {
    DWORD               dwFlags;
    LPCWSTR             pwszLocation;
} ENUM_SYSTEM_STORE_LOCATION_INFO, *PENUM_SYSTEM_STORE_LOCATION_INFO;

// Predefined crypt32.dll locations. MUST NOT BE REGISTERED!!!
static const ENUM_SYSTEM_STORE_LOCATION_INFO rgEnumSystemStoreLocationInfo[] = {
    CERT_SYSTEM_STORE_CURRENT_USER, L"CurrentUser",
    CERT_SYSTEM_STORE_LOCAL_MACHINE, L"LocalMachine",
    CERT_SYSTEM_STORE_CURRENT_SERVICE, L"CurrentService",
    CERT_SYSTEM_STORE_SERVICES, L"Services",
    CERT_SYSTEM_STORE_USERS, L"Users",
    CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY, L"CurrentUserGroupPolicy",
    CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY, L"LocalMachineGroupPolicy",
    CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE, L"LocalMachineEnterprise"
};
#define ENUM_SYSTEM_STORE_LOCATION_CNT \
        (sizeof(rgEnumSystemStoreLocationInfo) / \
            sizeof(rgEnumSystemStoreLocationInfo[0]))

#define OPEN_SYSTEM_STORE_PROV_FUNC_SET     0
#define REGISTER_SYSTEM_STORE_FUNC_SET      1
#define UNREGISTER_SYSTEM_STORE_FUNC_SET    2
#define ENUM_SYSTEM_STORE_FUNC_SET          3
#define REGISTER_PHYSICAL_STORE_FUNC_SET    4
#define UNREGISTER_PHYSICAL_STORE_FUNC_SET  5
#define ENUM_PHYSICAL_STORE_FUNC_SET        6
#define FUNC_SET_COUNT                      7

static HCRYPTOIDFUNCSET rghFuncSet[FUNC_SET_COUNT];
static const LPCSTR rgpszFuncName[FUNC_SET_COUNT] = {
    CRYPT_OID_OPEN_SYSTEM_STORE_PROV_FUNC,
    CRYPT_OID_REGISTER_SYSTEM_STORE_FUNC,
    CRYPT_OID_UNREGISTER_SYSTEM_STORE_FUNC,
    CRYPT_OID_ENUM_SYSTEM_STORE_FUNC,
    CRYPT_OID_REGISTER_PHYSICAL_STORE_FUNC,
    CRYPT_OID_UNREGISTER_PHYSICAL_STORE_FUNC,
    CRYPT_OID_ENUM_PHYSICAL_STORE_FUNC
};

typedef BOOL (WINAPI *PFN_REGISTER_SYSTEM_STORE)(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN PCERT_SYSTEM_STORE_INFO pStoreInfo,
    IN OPTIONAL void *pvReserved
    );
typedef BOOL (WINAPI *PFN_UNREGISTER_SYSTEM_STORE)(
    IN const void *pvSystemStore,
    IN DWORD dwFlags
    );
typedef BOOL (WINAPI *PFN_ENUM_SYSTEM_STORE)(
    IN DWORD dwFlags,
    IN OPTIONAL void *pvSystemStoreLocationPara,
    IN void *pvArg,
    IN PFN_CERT_ENUM_SYSTEM_STORE pfnEnum
    );

typedef BOOL (WINAPI *PFN_REGISTER_PHYSICAL_STORE)(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN LPCWSTR pwszStoreName,
    IN PCERT_PHYSICAL_STORE_INFO pStoreInfo,
    IN OPTIONAL void *pvReserved
    );
typedef BOOL (WINAPI *PFN_UNREGISTER_PHYSICAL_STORE)(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN LPCWSTR pwszStoreName
    );
typedef BOOL (WINAPI *PFN_ENUM_PHYSICAL_STORE)(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN void *pvArg,
    IN PFN_CERT_ENUM_PHYSICAL_STORE pfnEnum
    );


//+-------------------------------------------------------------------------
//  Registry Store Provider Functions.
//--------------------------------------------------------------------------
STATIC void WINAPI RegStoreProvClose(
        IN HCERTSTOREPROV hStoreProv,
        IN DWORD dwFlags
        );
STATIC BOOL WINAPI RegStoreProvReadCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pStoreCertContext,
        IN DWORD dwFlags,
        OUT PCCERT_CONTEXT *ppProvCertContext
        );
STATIC BOOL WINAPI RegStoreProvWriteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        );
STATIC BOOL WINAPI RegStoreProvDeleteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        );
STATIC BOOL WINAPI RegStoreProvSetCertProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        IN const void *pvData
        );

STATIC BOOL WINAPI RegStoreProvReadCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pStoreCrlContext,
        IN DWORD dwFlags,
        OUT PCCRL_CONTEXT *ppProvCrlContext
        );
STATIC BOOL WINAPI RegStoreProvWriteCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwFlags
        );
STATIC BOOL WINAPI RegStoreProvDeleteCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwFlags
        );
STATIC BOOL WINAPI RegStoreProvSetCrlProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        IN const void *pvData
        );

STATIC BOOL WINAPI RegStoreProvReadCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pStoreCtlContext,
        IN DWORD dwFlags,
        OUT PCCTL_CONTEXT *ppProvCtlContext
        );
STATIC BOOL WINAPI RegStoreProvWriteCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwFlags
        );
STATIC BOOL WINAPI RegStoreProvDeleteCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwFlags
        );
STATIC BOOL WINAPI RegStoreProvSetCtlProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        IN const void *pvData
        );

STATIC BOOL WINAPI RegStoreProvControl(
        IN HCERTSTOREPROV hStoreProv,
        IN DWORD dwFlags,
        IN DWORD dwCtrlType,
        IN void const *pvCtrlPara
        );

static void * const rgpvRegStoreProvFunc[] = {
    // CERT_STORE_PROV_CLOSE_FUNC              0
    RegStoreProvClose,
    // CERT_STORE_PROV_READ_CERT_FUNC          1
    RegStoreProvReadCert,
    // CERT_STORE_PROV_WRITE_CERT_FUNC         2
    RegStoreProvWriteCert,
    // CERT_STORE_PROV_DELETE_CERT_FUNC        3
    RegStoreProvDeleteCert,
    // CERT_STORE_PROV_SET_CERT_PROPERTY_FUNC  4
    RegStoreProvSetCertProperty,
    // CERT_STORE_PROV_READ_CRL_FUNC           5
    RegStoreProvReadCrl,
    // CERT_STORE_PROV_WRITE_CRL_FUNC          6
    RegStoreProvWriteCrl,
    // CERT_STORE_PROV_DELETE_CRL_FUNC         7
    RegStoreProvDeleteCrl,
    // CERT_STORE_PROV_SET_CRL_PROPERTY_FUNC   8
    RegStoreProvSetCrlProperty,
    // CERT_STORE_PROV_READ_CTL_FUNC           9
    RegStoreProvReadCtl,
    // CERT_STORE_PROV_WRITE_CTL_FUNC          10
    RegStoreProvWriteCtl,
    // CERT_STORE_PROV_DELETE_CTL_FUNC         11
    RegStoreProvDeleteCtl,
    // CERT_STORE_PROV_SET_CTL_PROPERTY_FUNC   12
    RegStoreProvSetCtlProperty,
    // CERT_STORE_PROV_CONTROL_FUNC            13
    RegStoreProvControl
};
#define REG_STORE_PROV_FUNC_COUNT (sizeof(rgpvRegStoreProvFunc) / \
                                    sizeof(rgpvRegStoreProvFunc[0]))

STATIC BOOL WINAPI RootStoreProvWriteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        );

STATIC BOOL WINAPI RootStoreProvDeleteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        );

static void * const rgpvRootStoreProvFunc[] = {
    // CERT_STORE_PROV_CLOSE_FUNC              0
    RegStoreProvClose,
    // CERT_STORE_PROV_READ_CERT_FUNC          1
    RegStoreProvReadCert,
    // CERT_STORE_PROV_WRITE_CERT_FUNC         2
    RootStoreProvWriteCert,
    // CERT_STORE_PROV_DELETE_CERT_FUNC        3
    RootStoreProvDeleteCert,
    // CERT_STORE_PROV_SET_CERT_PROPERTY_FUNC  4
    RegStoreProvSetCertProperty,
    // CERT_STORE_PROV_READ_CRL_FUNC           5
    RegStoreProvReadCrl,
    // CERT_STORE_PROV_WRITE_CRL_FUNC          6
    RegStoreProvWriteCrl,
    // CERT_STORE_PROV_DELETE_CRL_FUNC         7
    RegStoreProvDeleteCrl,
    // CERT_STORE_PROV_SET_CRL_PROPERTY_FUNC   8
    RegStoreProvSetCrlProperty,
    // CERT_STORE_PROV_READ_CTL_FUNC           9
    RegStoreProvReadCtl,
    // CERT_STORE_PROV_WRITE_CTL_FUNC          10
    RegStoreProvWriteCtl,
    // CERT_STORE_PROV_DELETE_CTL_FUNC         11
    RegStoreProvDeleteCtl,
    // CERT_STORE_PROV_SET_CTL_PROPERTY_FUNC   12
    RegStoreProvSetCtlProperty,
    // CERT_STORE_PROV_CONTROL_FUNC            13
    RegStoreProvControl
};
#define ROOT_STORE_PROV_FUNC_COUNT (sizeof(rgpvRootStoreProvFunc) / \
                                    sizeof(rgpvRootStoreProvFunc[0]))

//+-------------------------------------------------------------------------
//  Add the serialized store to the store.
//
//  from newstor.cpp
//--------------------------------------------------------------------------
extern BOOL WINAPI I_CertAddSerializedStore(
        IN HCERTSTORE hCertStore,
        IN BYTE *pbStore,
        IN DWORD cbStore
        );

LPWSTR ILS_AllocAndCopyString(
    IN LPCWSTR pwszSrc,
    IN LONG cchSrc
    )
{
    LPWSTR pwszDst;

    if (cchSrc < 0)
        cchSrc = wcslen(pwszSrc);
    if (NULL == (pwszDst = (LPWSTR) PkiNonzeroAlloc(
            (cchSrc + 1) * sizeof(WCHAR))))
        return NULL;
    if (0 < cchSrc)
        memcpy((BYTE *) pwszDst, (BYTE *) pwszSrc, cchSrc * sizeof(WCHAR));
    pwszDst[cchSrc] = L'\0';
    return pwszDst;
}

extern
BOOL
WINAPI
I_ProtectedRootDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved);

//+=========================================================================
//  Register WaitFor Forward Function References
//==========================================================================
STATIC void RegWaitForProcessAttach();
STATIC void RegWaitForProcessDetach();

//+=========================================================================
//  Client "GPT" Store Forward Function References
//==========================================================================
STATIC void GptStoreProcessAttach();
STATIC void GptStoreProcessDetach();

STATIC BOOL OpenAllFromGptRegistry(
    IN PREG_STORE pRegStore,
    IN HCERTSTORE hCertStore
    );

STATIC BOOL CommitAllToGptRegistry(
    IN PREG_STORE pRegStore,
    IN DWORD dwFlags
    );

STATIC void GptStoreSignalAndFreeRegStoreResyncEntries(
    IN PREG_STORE pRegStore
    );

STATIC void FreeGptStoreChangeInfo(
    IN OUT PGPT_STORE_CHANGE_INFO *ppInfo
    );

STATIC BOOL RegGptStoreChange(
    IN PREG_STORE pRegStore,
    IN HANDLE hEvent,
    IN DWORD dwFlags
    );

static inline BOOL IsClientGptStore(
    IN PSYSTEM_NAME_INFO pInfo,
    IN DWORD dwFlags
    )
{
    DWORD dwStoreLocation = dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK;

    if (!(CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY == dwStoreLocation ||
          CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY == dwStoreLocation))
        return FALSE;

    if (dwFlags & (CERT_SYSTEM_STORE_RELOCATE_FLAG | CERT_STORE_DELETE_FLAG))
        return FALSE;

    return TRUE;
}

//+=========================================================================
//  Win95 Notify Store Forward Function References
//==========================================================================

// Following is created at ProcessAttach for Win95 clients
static HANDLE hWin95NotifyEvent = NULL;

STATIC void Win95StoreProcessAttach();
STATIC void Win95StoreProcessDetach();

STATIC void Win95StoreSignalAndFreeRegStoreResyncEntries(
    IN PREG_STORE pRegStore
    );

STATIC BOOL RegWin95StoreChange(
    IN PREG_STORE pRegStore,
    IN HANDLE hEvent,
    IN DWORD dwFlags
    );

//+=========================================================================
// Roaming Store Forward Function References
//==========================================================================
STATIC void RoamingStoreProcessAttach();
STATIC void RoamingStoreProcessDetach();

LPWSTR
ILS_GetRoamingStoreDirectory(
    IN LPCWSTR pwszStoreName
    );

BOOL
ILS_WriteElementToFile(
    IN LPCWSTR pwszStoreDir,
    IN LPCWSTR pwszContextName,
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN DWORD dwFlags,       // CERT_STORE_CREATE_NEW_FLAG or
                            // CERT_STORE_BACKUP_RESTORE_FLAG may be set
    IN const BYTE *pbElement,
    IN DWORD cbElement
    );

BOOL
ILS_ReadElementFromFile(
    IN LPCWSTR pwszStoreDir,
    IN LPCWSTR pwszContextName,
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN DWORD dwFlags,           // CERT_STORE_BACKUP_RESTORE_FLAG may be set
    OUT BYTE **ppbElement,
    OUT DWORD *pcbElement
    );

BOOL
ILS_DeleteElementFromDirectory(
    IN LPCWSTR pwszStoreDir,
    IN LPCWSTR pwszContextName,
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN DWORD dwFlags
    );

typedef BOOL (*PFN_ILS_OPEN_ELEMENT)(
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN const BYTE *pbElement,
    IN DWORD cbElement,
    IN void *pvArg
    );

BOOL
ILS_OpenAllElementsFromDirectory(
    IN LPCWSTR pwszStoreDir,
    IN LPCWSTR pwszContextName,
    IN DWORD dwFlags,
    IN void *pvArg,
    IN PFN_ILS_OPEN_ELEMENT pfnOpenElement
    );

//+=========================================================================
// Registry or Roaming Store Change Notify Functions
//==========================================================================
STATIC BOOL RegRegistryStoreChange(
    IN PREG_STORE pRegStore,
    IN HANDLE hEvent,
    IN DWORD dwFlags
    );

STATIC void FreeRegistryStoreChange(
    IN PREG_STORE pRegStore
    );

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
I_RegStoreDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL    fRet;
    DWORD   i;

    if (!I_ProtectedRootDllMain(hInst, ulReason, lpReserved))
        return FALSE;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        for (i = 0; i < FUNC_SET_COUNT; i++) {
            if (NULL == (rghFuncSet[i] = CryptInitOIDFunctionSet(
                rgpszFuncName[i], 0)))
            goto CryptInitOIDFunctionSetError;
        }

        if (!Pki_InitializeCriticalSection(&ILS_CriticalSection))
            goto InitCritSectionError;

        if (NULL == (hTlsEnumPhysicalStoreDepth = I_CryptAllocTls())) {
            DeleteCriticalSection(&ILS_CriticalSection);
            goto CryptAllocTlsError;
        }

        RegWaitForProcessAttach();
        GptStoreProcessAttach();
        Win95StoreProcessAttach();
        RoamingStoreProcessAttach();
        break;

    case DLL_PROCESS_DETACH:
        RoamingStoreProcessDetach();
        Win95StoreProcessDetach();
        GptStoreProcessDetach();
        RegWaitForProcessDetach();
        DeleteCriticalSection(&ILS_CriticalSection);
        I_CryptFreeTls(hTlsEnumPhysicalStoreDepth, PkiFree);
        break;

    case DLL_THREAD_DETACH:
        PkiFree(I_CryptDetachTls(hTlsEnumPhysicalStoreDepth));
        break;
    default:
        break;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    I_ProtectedRootDllMain(hInst, DLL_PROCESS_DETACH, NULL);
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(InitCritSectionError)
TRACE_ERROR(CryptInitOIDFunctionSetError)
TRACE_ERROR(CryptAllocTlsError)
}

//+-------------------------------------------------------------------------
//  Converts the bytes into UNICODE ASCII HEX
//
//  Needs (cb * 2 + 1) * sizeof(WCHAR) bytes of space in wsz
//--------------------------------------------------------------------------
void ILS_BytesToWStr(DWORD cb, void* pv, LPWSTR wsz)
{
    BYTE* pb = (BYTE*) pv;
    for (DWORD i = 0; i<cb; i++) {
        int b;
        b = (*pb & 0xF0) >> 4;
        *wsz++ = (WCHAR)( (b <= 9) ? b + L'0' : (b - 10) + L'A');
        b = *pb & 0x0F;
        *wsz++ = (WCHAR)( (b <= 9) ? b + L'0' : (b - 10) + L'A');
        pb++;
    }
    *wsz++ = 0;
}

//+-------------------------------------------------------------------------
//  Converts the UNICODE ASCII HEX to an array of bytes
//--------------------------------------------------------------------------
STATIC void WStrToBytes(
    IN const WCHAR wsz[MAX_HASH_NAME_LEN],
    OUT BYTE rgb[MAX_HASH_LEN],
    OUT DWORD *pcb
    )
{
    BOOL fUpperNibble = TRUE;
    DWORD cb = 0;
    LPCWSTR pwsz = wsz;
    WCHAR wch;

    while (cb < MAX_HASH_LEN && (wch = *pwsz++)) {
        BYTE b;

        // only convert ascii hex characters 0..9, a..f, A..F
        // silently ignore all others
        if (wch >= L'0' && wch <= L'9')
            b = (BYTE) (wch - L'0');
        else if (wch >= L'a' && wch <= L'f')
            b = (BYTE) (10 + wch - L'a');
        else if (wch >= L'A' && wch <= L'F')
            b = (BYTE) (10 + wch - L'A');
        else
            continue;

        if (fUpperNibble) {
            rgb[cb] = (BYTE)( b << 4);
            fUpperNibble = FALSE;
        } else {
            rgb[cb] = (BYTE)( rgb[cb] | b);
            cb++;
            fUpperNibble = TRUE;
        }
    }

    *pcb = cb;
}

//+-------------------------------------------------------------------------
//  Lock and unlock registry functions
//--------------------------------------------------------------------------
static inline void LockRegStore(IN PREG_STORE pRegStore)
{
    EnterCriticalSection(&pRegStore->CriticalSection);
}
static inline void UnlockRegStore(IN PREG_STORE pRegStore)
{
    LeaveCriticalSection(&pRegStore->CriticalSection);
}

//+-------------------------------------------------------------------------
//  Checks if current thread is doing a Resync. Other threads block until
//  the resync completes
//--------------------------------------------------------------------------
STATIC BOOL IsInResync(IN PREG_STORE pRegStore)
{
    BOOL fResync;

    LockRegStore(pRegStore);
    fResync = pRegStore->fResync;
    UnlockRegStore(pRegStore);
    return fResync;
}

//+=========================================================================
//  Low level context support functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Get the certificate's registry value name by formatting its SHA1 hash as
//  UNICODE hex.
//--------------------------------------------------------------------------
STATIC BOOL GetCertRegValueName(
        IN PCCERT_CONTEXT pCertContext,
        OUT WCHAR wszRegName[MAX_CERT_REG_VALUE_NAME_LEN]
        )
{
    BYTE    rgbHash[MAX_HASH_LEN];
    DWORD   cbHash = MAX_HASH_LEN;

    // get the thumbprint
    if(!CertGetCertificateContextProperty(
            pCertContext,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &cbHash))
        return FALSE;

    // convert to a string
    ILS_BytesToWStr(cbHash, rgbHash, wszRegName);
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Get the CRL's registry value name by formatting its SHA1 hash as
//  UNICODE hex.
//--------------------------------------------------------------------------
STATIC BOOL GetCrlRegValueName(
        IN PCCRL_CONTEXT pCrlContext,
        OUT WCHAR wszRegName[MAX_CERT_REG_VALUE_NAME_LEN]
        )
{
    BYTE    rgbHash[MAX_HASH_LEN];
    DWORD   cbHash = MAX_HASH_LEN;

    // get the thumbprint
    if(!CertGetCRLContextProperty(
            pCrlContext,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &cbHash))
        return FALSE;

    // convert to a string
    ILS_BytesToWStr(cbHash, rgbHash, wszRegName);
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Get the CTL's registry value name by formatting its SHA1 hash as
//  UNICODE hex.
//--------------------------------------------------------------------------
STATIC BOOL GetCtlRegValueName(
        IN PCCTL_CONTEXT pCtlContext,
        OUT WCHAR wszRegName[MAX_CERT_REG_VALUE_NAME_LEN]
        )
{
    BYTE    rgbHash[MAX_HASH_LEN];
    DWORD   cbHash = MAX_HASH_LEN;

    // get the thumbprint
    if(!CertGetCTLContextProperty(
            pCtlContext,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &cbHash))
        return FALSE;

    // convert to a string
    ILS_BytesToWStr(cbHash, rgbHash, wszRegName);
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Convert's the context's SHA1 hash to UNICODE hex. Returns TRUE if the
//  same as the specified Uniocde reg name.
//--------------------------------------------------------------------------
STATIC BOOL IsValidRegValueNameForContext(
        IN DWORD dwContextType,
        IN const void *pvContext,
        IN const WCHAR wszRegName[MAX_CERT_REG_VALUE_NAME_LEN]
        )
{
    BOOL fResult;
    WCHAR wszContextHash[MAX_CERT_REG_VALUE_NAME_LEN];

    switch (dwContextType) {
        case CERT_STORE_CERTIFICATE_CONTEXT:
            fResult = GetCertRegValueName(
                (PCCERT_CONTEXT) pvContext, wszContextHash);
            break;
        case CERT_STORE_CRL_CONTEXT:
            fResult = GetCrlRegValueName(
                (PCCRL_CONTEXT) pvContext, wszContextHash);
            break;
        case CERT_STORE_CTL_CONTEXT:
            fResult = GetCtlRegValueName(
                (PCCTL_CONTEXT) pvContext, wszContextHash);
            break;
        default:
            goto InvalidContext;
    }

    if (!fResult)
        goto GetContextHashError;

    if (0 != _wcsicmp(wszRegName, wszContextHash))
        goto InvalidRegValueNameForContext;

    fResult = TRUE;

CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidContext, E_UNEXPECTED)
TRACE_ERROR(GetContextHashError)
SET_ERROR(InvalidRegValueNameForContext, ERROR_BAD_PATHNAME)
}

//+-------------------------------------------------------------------------
//  Deletes the context from the store.
//--------------------------------------------------------------------------
STATIC void DeleteContextFromStore(
        IN DWORD dwContextType,
        IN const void *pvContext
        )
{
    switch (dwContextType) {
        case CERT_STORE_CERTIFICATE_CONTEXT:
            CertDeleteCertificateFromStore((PCCERT_CONTEXT) pvContext);
            break;
        case CERT_STORE_CRL_CONTEXT:
            CertDeleteCRLFromStore((PCCRL_CONTEXT) pvContext);
            break;
        case CERT_STORE_CTL_CONTEXT:
            CertDeleteCTLFromStore((PCCTL_CONTEXT) pvContext);
            break;
        default:
            break;
    }
}

//+-------------------------------------------------------------------------
//  Frees the context.
//--------------------------------------------------------------------------
STATIC void FreeContext(
        IN DWORD dwContextType,
        IN const void *pvContext
        )
{
    switch (dwContextType) {
        case CERT_STORE_CERTIFICATE_CONTEXT:
            CertFreeCertificateContext((PCCERT_CONTEXT) pvContext);
            break;
        case CERT_STORE_CRL_CONTEXT:
            CertFreeCRLContext((PCCRL_CONTEXT) pvContext);
            break;
        case CERT_STORE_CTL_CONTEXT:
            CertFreeCTLContext((PCCTL_CONTEXT) pvContext);
            break;
        default:
            break;
    }
}

//+=========================================================================
//  Low level registry support functions
//==========================================================================

//+-------------------------------------------------------------------------
//  For CERT_STORE_BACKUP_RESTORE_FLAG, enable backup and restore
//  privileges.
//--------------------------------------------------------------------------
void ILS_EnableBackupRestorePrivileges()
{
    IPR_EnableSecurityPrivilege(SE_BACKUP_NAME);
    IPR_EnableSecurityPrivilege(SE_RESTORE_NAME);
}

// LastError can get globbered when doing remote registry access
void
ILS_CloseRegistryKey(
    IN HKEY hKey
    )
{
    if (hKey) {
        DWORD dwErr = GetLastError();
        LONG RegCloseKeyStatus;
        RegCloseKeyStatus = RegCloseKey(hKey);
        assert(ERROR_SUCCESS == RegCloseKeyStatus);
        SetLastError(dwErr);
    }
}

// Ensure LastError is preserved
void
ILS_CloseHandle(
    IN HANDLE h
    )
{
    if (h) {
        DWORD dwErr = GetLastError();

        CloseHandle(h);

        SetLastError(dwErr);
    }
}

STATIC BOOL WriteDWORDValueToRegistry(
    IN HKEY hKey,
    IN LPCWSTR pwszValueName,
    IN DWORD dwValue
    )
{
    LONG err;
    if (ERROR_SUCCESS == (err = RegSetValueExU(
            hKey,
            pwszValueName,
            0,          // dwReserved
            REG_DWORD,
            (BYTE *) &dwValue,
            sizeof(DWORD))))
        return TRUE;
    else {
        SetLastError((DWORD) err);
        return FALSE;
    }
}

BOOL
ILS_ReadDWORDValueFromRegistry(
    IN HKEY hKey,
    IN LPCWSTR pwszValueName,
    IN DWORD *pdwValue
    )
{
    BOOL fResult;
    LONG err;
    DWORD dwType;
    DWORD dwValue;
    DWORD cbValue = sizeof(DWORD);

    if (ERROR_SUCCESS != (err = RegQueryValueExU(
            hKey,
            pwszValueName,
            NULL,       // pdwReserved
            &dwType,
            (BYTE *) &dwValue,
            &cbValue))) goto RegQueryValueError;
    if (dwType != REG_DWORD || cbValue != sizeof(DWORD))
        goto InvalidRegistryValue;
    fResult = TRUE;
CommonReturn:
    *pdwValue = dwValue;
    return fResult;
ErrorReturn:
    dwValue = 0;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR_VAR(RegQueryValueError, err)
SET_ERROR(InvalidRegistryValue, CRYPT_E_FILE_ERROR)
}

// Ensure a binary value that may contain a LPCWSTR is NULL terminated.
// Always adds a NULL terminator not included in the returned cbValue.
//
// May return an allocated pbValue with a cbValue = 0.
BOOL
ILS_ReadBINARYValueFromRegistry(
    IN HKEY hKey,
    IN LPCWSTR pwszValueName,
    OUT BYTE **ppbValue,
    OUT DWORD *pcbValue
    )
{
    BOOL fResult;
    LONG err;
    DWORD dwType;
    BYTE *pbValue = NULL;
    DWORD cbValue = 0;
    DWORD cbAllocValue;

    err = RegQueryValueExU(
            hKey,
            pwszValueName,
            NULL,       // pdwReserved
            &dwType,
            NULL,       // lpData
            &cbValue);
    // For Win95 Remote Registry Access:: returns ERROR_MORE_DATA
    if (!(ERROR_SUCCESS == err || ERROR_MORE_DATA == err))
        goto RegQueryValueError;
    if (dwType != REG_BINARY)
        goto InvalidRegistryValue;
    cbAllocValue = cbValue + 3;
    if (NULL == (pbValue = (BYTE *) PkiNonzeroAlloc(cbAllocValue)))
        goto OutOfMemory;
    if (0 < cbValue) {
        if (ERROR_SUCCESS != (err = RegQueryValueExU(
                hKey,
                pwszValueName,
                NULL,       // pdwReserved
                &dwType,
                pbValue,
                &cbValue))) goto RegQueryValueError;
    }
    assert(cbAllocValue >= cbValue + 3);

    // Ensure an LPWSTR is null terminated
    memset(pbValue + cbValue, 0, 3);

    fResult = TRUE;
CommonReturn:
    *ppbValue = pbValue;
    *pcbValue = cbValue;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    PkiFree(pbValue);
    pbValue = NULL;
    cbValue = 0;
    goto CommonReturn;

SET_ERROR_VAR(RegQueryValueError, err)
SET_ERROR(InvalidRegistryValue, CRYPT_E_FILE_ERROR)
TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  Get and allocate the REG_SZ value
//--------------------------------------------------------------------------
LPWSTR ILS_ReadSZValueFromRegistry(
    IN HKEY hKey,
    IN LPCWSTR pwszValueName
    )
{
    LONG err;
    DWORD dwType;
    LPWSTR pwszValue = NULL;
    DWORD cbValue = 0;

    err = RegQueryValueExU(
            hKey,
            pwszValueName,
            NULL,       // pdwReserved
            &dwType,
            NULL,       // lpData
            &cbValue);
    // For Win95 Remote Registry Access:: returns ERROR_MORE_DATA
    if (!(ERROR_SUCCESS == err || ERROR_MORE_DATA == err))
        goto RegQueryValueError;
    if (dwType != REG_SZ || cbValue < sizeof(WCHAR))
        goto InvalidRegistryValue;
    // Ensure NULL terminated
    if (NULL == (pwszValue = (LPWSTR) PkiNonzeroAlloc(cbValue + sizeof(WCHAR))))
        goto OutOfMemory;
    if (ERROR_SUCCESS != (err = RegQueryValueExU(
            hKey,
            pwszValueName,
            NULL,       // pdwReserved
            &dwType,
            (BYTE *) pwszValue,
            &cbValue))) goto RegQueryValueError;
    pwszValue[cbValue / sizeof(WCHAR)] = L'\0';
CommonReturn:
    return pwszValue;
ErrorReturn:
    PkiFree(pwszValue);
    pwszValue = NULL;
    goto CommonReturn;

SET_ERROR_VAR(RegQueryValueError, err)
SET_ERROR(InvalidRegistryValue, CRYPT_E_FILE_ERROR)
TRACE_ERROR(OutOfMemory)
}

LPSTR ILS_ReadSZValueFromRegistry(
    IN HKEY hKey,
    IN LPCSTR pszValueName
    )
{
    LONG err;
    DWORD dwType;
    LPSTR pszValue = NULL;
    DWORD cbValue = 0;

    err = RegQueryValueExA(
            hKey,
            pszValueName,
            NULL,       // pdwReserved
            &dwType,
            NULL,       // lpData
            &cbValue);
    // For Win95 Remote Registry Access:: returns ERROR_MORE_DATA
    if (!(ERROR_SUCCESS == err || ERROR_MORE_DATA == err))
        goto RegQueryValueError;
    if (dwType != REG_SZ || cbValue == 0)
        goto InvalidRegistryValue;
    // Ensure NULL terminated
    if (NULL == (pszValue = (LPSTR) PkiNonzeroAlloc(cbValue + sizeof(CHAR))))
        goto OutOfMemory;
    if (ERROR_SUCCESS != (err = RegQueryValueExA(
            hKey,
            pszValueName,
            NULL,       // pdwReserved
            &dwType,
            (BYTE *) pszValue,
            &cbValue))) goto RegQueryValueError;
    pszValue[cbValue / sizeof(CHAR)] = '\0';
CommonReturn:
    return pszValue;
ErrorReturn:
    PkiFree(pszValue);
    pszValue = NULL;
    goto CommonReturn;

SET_ERROR_VAR(RegQueryValueError, err)
SET_ERROR(InvalidRegistryValue, CRYPT_E_FILE_ERROR)
TRACE_ERROR(OutOfMemory)
}

STATIC BOOL GetSubKeyInfo(
    IN HKEY hKey,
    OUT OPTIONAL DWORD *pcSubKeys,
    OUT OPTIONAL DWORD *pcchMaxSubKey = NULL
    )
{
    BOOL fResult;
    LONG err;

    // I have seen a couple of stress failures where the following returns
    // ERROR_SUCCESS without updating *pcSubKeys
    if (pcSubKeys)
        *pcSubKeys = 0;
    if (pcchMaxSubKey)
        *pcchMaxSubKey = 0;

    if (ERROR_SUCCESS != (err = RegQueryInfoKeyU(
            hKey,
            NULL,       // lpszClass
            NULL,       // lpcchClass
            NULL,       // lpdwReserved
            pcSubKeys,
            pcchMaxSubKey,
            NULL,       // lpcchMaxClass
            NULL,       // lpcValues
            NULL,       // lpcchMaxValuesName
            NULL,       // lpcbMaxValueData
            NULL,       // lpcbSecurityDescriptor
            NULL        // lpftLastWriteTime
            ))) goto RegQueryInfoKeyError;
    fResult = TRUE;

CommonReturn:
    // For Win95 Remote Registry Access:: returns half of the cch
    if (pcchMaxSubKey && *pcchMaxSubKey)
        *pcchMaxSubKey = (*pcchMaxSubKey + 1) * 2 + 2;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    if (pcSubKeys)
        *pcSubKeys = 0;
    if (pcchMaxSubKey)
        *pcchMaxSubKey = 0;
    goto CommonReturn;
SET_ERROR_VAR(RegQueryInfoKeyError, err)
}

//+-------------------------------------------------------------------------
//  Open the SubKey with support for backup/restore
//--------------------------------------------------------------------------
STATIC LONG WINAPI OpenHKCUKeyExU (
    HKEY hKey,
    IN LPCWSTR pwszSubKeyName,
    IN DWORD dwFlags,           // CERT_STORE_BACKUP_RESTORE_FLAG may be set
    REGSAM samDesired,
    PHKEY phkResult
    )
{
    LONG err;

    if (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG) {
        DWORD dwDisposition;

        err = RegCreateHKCUKeyExU(
                hKey,
                pwszSubKeyName,
                NULL,
                NULL,
                REG_OPTION_BACKUP_RESTORE,
                samDesired,
                NULL,
                phkResult,
                &dwDisposition
                );
    } else {
        err = RegOpenHKCUKeyExU(
                hKey,
                pwszSubKeyName,
                0,                      // dwReserved
                samDesired,
                phkResult
                );
    }

    return err;
}

//+-------------------------------------------------------------------------
//  Open the SubKey.
//
//  dwFlags:
//      CERT_STORE_READONLY_FLAG
//      CERT_STORE_OPEN_EXISTING_FLAG
//      CERT_STORE_CREATE_NEW_FLAG
//      CERT_STORE_BACKUP_RESTORE_FLAG
//--------------------------------------------------------------------------
STATIC HKEY OpenSubKey(
    IN HKEY hKey,
    IN LPCWSTR pwszSubKeyName,
    IN DWORD dwFlags
    )
{
    LONG err;
    HKEY hSubKey;

    if (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG) {
        DWORD dwDisposition;
        REGSAM samDesired;

        if (dwFlags & CERT_STORE_READONLY_FLAG)
            samDesired = KEY_READ;
        else
            samDesired = KEY_ALL_ACCESS;

        if (NULL == pwszSubKeyName)
            pwszSubKeyName = L"";

        if (ERROR_SUCCESS != (err = RegCreateHKCUKeyExU(
                hKey,
                pwszSubKeyName,
                0,                      // dwReserved
                NULL,                   // lpClass
                REG_OPTION_BACKUP_RESTORE,
                samDesired,
                NULL,                   // lpSecurityAttributes
                &hSubKey,
                &dwDisposition))) {
            if (dwFlags &
                    (CERT_STORE_READONLY_FLAG | CERT_STORE_OPEN_EXISTING_FLAG))
                err = ERROR_FILE_NOT_FOUND;
            goto RegCreateBackupRestoreKeyError;
        }

        if (dwFlags & CERT_STORE_CREATE_NEW_FLAG) {
            if (REG_CREATED_NEW_KEY != dwDisposition) {
                RegCloseKey(hSubKey);
                goto ExistingSubKey;
            }
        }

        goto CommonReturn;
    }

    if (dwFlags & CERT_STORE_CREATE_NEW_FLAG) {
        // First check if SubKey already exists
        if (hSubKey = OpenSubKey(
                hKey,
                pwszSubKeyName,
                (dwFlags & ~CERT_STORE_CREATE_NEW_FLAG) |
                    CERT_STORE_OPEN_EXISTING_FLAG |
                    CERT_STORE_READONLY_FLAG
                )) {
            RegCloseKey(hSubKey);
            goto ExistingSubKey;
        } else if (ERROR_FILE_NOT_FOUND != GetLastError())
            goto OpenNewSubKeyError;
    }

    if (dwFlags & (CERT_STORE_READONLY_FLAG | CERT_STORE_OPEN_EXISTING_FLAG)) {
        REGSAM samDesired;
        if (dwFlags & CERT_STORE_READONLY_FLAG)
            samDesired = KEY_READ;
        else
            samDesired = KEY_ALL_ACCESS;

        if (ERROR_SUCCESS != (err = RegOpenHKCUKeyExU(
                hKey,
                pwszSubKeyName,
                0,                      // dwReserved
                samDesired,
                &hSubKey)))
            goto RegOpenKeyError;
    } 